import{_ as h,o as n,c as i,a as t,m as c,t as d,C as g,M as _,U as y,f as u,F as b,p as w,e as v,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},E={class:"review-title"},I={class:"review-content"};function A(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",E,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",I,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(l.poem.solution),1)])])])}const C=h(k,[["render",A],["__scopeId","data-v-16d21a64"]]),N=JSON.parse('[{"question":"# Problem Statement One of the popular text formatting needs in document processing is formatting numbers as words in English. For example, converting `123` to \\"one hundred twenty-three\\". This capability can greatly enhance document readability and automate the creation of more human-friendly content. # Requirements Implement a Python function `number_to_words` that takes a single parameter, `num: int`, representing a non-negative integer, and returns a string representing the English words for the given number. # Constraints * The function should handle numbers in the range `[0, 999999]` inclusive. * You should avoid using any third-party libraries that directly convert numbers to words. # Input and Output Formats * **Input**: * `num: int` - A non-negative integer that needs to be converted to words. * **Output**: * `str` - A string representing the English words for the given number. # Example ```python def number_to_words(num: int) -> str: # Your implementation here # Test cases print(number_to_words(0)) # Output: \\"zero\\" print(number_to_words(123)) # Output: \\"one hundred twenty-three\\" print(number_to_words(1001)) # Output: \\"one thousand one\\" print(number_to_words(100000)) # Output: \\"one hundred thousand\\" print(number_to_words(123456)) # Output: \\"one hundred twenty-three thousand four hundred fifty-six\\" ``` # Hints * Consider breaking down the problem by handling units, tens, hundreds, thousands, and so on separately. * Handle special cases such as numbers involving \\"zero\\" correctly to avoid issues with concatenation. # Notes * Ensure to follow proper English grammar rules for converting numbers to words. * Test your function thoroughly with edge cases like `0`, `999999`, and different ranges of numbers to ensure accuracy.","solution":"def number_to_words(num: int) -> str: if num == 0: return \\"zero\\" ones = [\\"\\", \\"one\\", \\"two\\", \\"three\\", \\"four\\", \\"five\\", \\"six\\", \\"seven\\", \\"eight\\", \\"nine\\"] teens = [\\"\\", \\"eleven\\", \\"twelve\\", \\"thirteen\\", \\"fourteen\\", \\"fifteen\\", \\"sixteen\\", \\"seventeen\\", \\"eighteen\\", \\"nineteen\\"] tens = [\\"\\", \\"ten\\", \\"twenty\\", \\"thirty\\", \\"forty\\", \\"fifty\\", \\"sixty\\", \\"seventy\\", \\"eighty\\", \\"ninety\\"] def one(num): return ones[num] def two_less_20(num): return teens[num - 10] def ten(num): return tens[num] def two(num): if not num: return \\"\\" elif num < 10: return one(num) elif num < 20: return two_less_20(num) else: ten_val = num // 10 rest = num % 10 return ten(ten_val) + (\\"-\\" + one(rest) if rest else \\"\\") def three(num): hundred_val = num // 100 rest = num % 100 if hundred_val and rest: return one(hundred_val) + \\" hundred \\" + two(rest) elif not hundred_val and rest: return two(rest) elif hundred_val and not rest: return one(hundred_val) + \\" hundred\\" def word(num): million = num // 1_000_000 thousand = (num // 1_000) % 1_000 rest = num % 1_000 part = [] if million: part.append(three(million) + \\" million\\") if thousand: part.append(three(thousand) + \\" thousand\\") if rest: part.append(three(rest)) return \\" \\".join(part) return word(num)"},{"question":"# Problem Statement You are given an `n x n` grid where each cell has a non-negative integer representing the cost of passing through that cell. You are required to find the minimum path sum from the top-left corner to the bottom-right corner. You can only move down or right at any point in time. Implement the function `min_path_sum(grid: List[List[int]]) -> int`. # Function Signature ```python def min_path_sum(grid: List[List[int]]) -> int: ``` # Input - `grid`: A list of lists of integers where `1 <= len(grid), len(grid[0]) <= 100` and each integer is between `0` and `100` inclusive. # Output - An integer representing the minimum path sum to travel from the top-left corner to the bottom-right corner of the grid. # Constraints - All input values and dimensions are guaranteed to be valid as per the specifications. # Example ```python grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(min_path_sum(grid)) # Outputs: 7 grid = [ [1, 2, 3], [4, 5, 6] ] print(min_path_sum(grid)) # Outputs: 12 ``` # Execution Requirements - The function should be efficient in terms of both time and space complexity, given the constraints. - Memory usage should be handled carefully to avoid excessive consumption. # Scenario Imagine you are programming a robot to navigate a warehouse with a specific layout. The goal is to minimize the energy consumption of the robot as it travels from its starting position at the entrance (top-left corner) to its target at the exit (bottom-right corner). The grid represents the layout of the warehouse where each cell requires a different amount of energy to pass through. Your function will calculate the optimal path for the robot, ensuring minimal energy usage.","solution":"from typing import List def min_path_sum(grid: List[List[int]]) -> int: Given a 2D grid of non-negative integers representing the cost of passing through cells, returns the minimum path sum from the top-left corner to the bottom-right corner. You can only move down or right at any point in time. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) # Create a 2D dp array with the same dimensions as grid dp = [[0] * cols for _ in range(rows)] dp[0][0] = grid[0][0] # Initialize the first column for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] # Initialize the first row for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill up the dp array for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[rows-1][cols-1]"},{"question":"# Question: Implement Insertion Sort Context: Your task is to implement the insertion sort algorithm for a given list of integers. The function should sort the list in ascending order using the insertion sort technique. Function Signature: ```python def insertion_sort(lst: list) -> list: ``` Parameters: - `lst`: a list of integers that need to be sorted. Returns: - The function returns a list of integers sorted in ascending order. Constraints: - The input list can be empty. - Consider edge cases like a list with only one element, a list that is already sorted, and a list that is sorted in reverse order. - Do not use any in-built sort functions. Examples: ```python # Example 1 print(insertion_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5])) # Output: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] # Example 2 print(insertion_sort([5, 4, 3, 2, 1])) # Output: [1, 2, 3, 4, 5] # Example 3 print(insertion_sort([1, 2, 3, 4, 5])) # Output: [1, 2, 3, 4, 5] # Example 4 print(insertion_sort([7])) # Output: [7] # Example 5 print(insertion_sort([])) # Output: [] ``` Note: Implement the insertion sort algorithm by iterating through the list and inserting each element into its correct position relative to the sorted portion of the list. Ensure to handle the provided edge cases and that the function works optimally for different sizes of input lists.","solution":"def insertion_sort(lst: list) -> list: Perform insertion sort on a list of integers. :param lst: List of integers to be sorted. :return: List of integers sorted in ascending order. for i in range(1, len(lst)): key = lst[i] j = i - 1 while j >= 0 and key < lst[j]: lst[j + 1] = lst[j] j -= 1 lst[j + 1] = key return lst"},{"question":"# Matrix Transpose Function Implement a function to compute the transpose of a given square matrix. Ensure your implementation is optimized for performance and adheres to the constraints and requirements detailed below. Function Signature ```python def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Given a square matrix, return its transpose. ``` Input * A List of Lists (2D List) `matrix` representing the square matrix, where each inner list has the same number of integer elements as the number of inner lists. Output * A new 2D List that represents the transpose of the input matrix. Constraints and Requirements * The function should handle matrices ranging from 1x1 to 1000x1000 elements. * The function should raise a `ValueError` if the input `matrix` is not square. * The function should perform the transpose operation in O(n^2) time complexity, where `n` is the dimension of the matrix. * Space complexity should remain O(n^2) for the result storage but avoid using any additional significant data structures. Example ```python # Example usage matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] transposed = transpose_matrix(matrix) # transposed should be: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] ``` Testing Design and include unittests to verify your implementation, taking care to include edge cases such as: - Empty matrix - Single-element matrix - Typical square patterns of varying sizes (2x2, 3x3, etc.) - Maximum constraint size (1000x1000) For example, for unit testing in Python: ```python import unittest class TestTransposeMatrix(unittest.TestCase): def test_empty_matrix(self): self.assertEqual(transpose_matrix([]), []) def test_single_element_matrix(self): self.assertEqual(transpose_matrix([[1]]), [[1]]) def test_typical_case(self): self.assertEqual(transpose_matrix([[1, 2], [3, 4]]), [[1, 3], [2, 4]]) def test_large_matrix(self): matrix = [[i + j*1000 for i in range(1000)] for j in range(1000)] expected = [[matrix[j][i] for j in range(1000)] for i in range(1000)] self.assertEqual(transpose_matrix(matrix), expected) def test_non_square_matrix(self): with self.assertRaises(ValueError): transpose_matrix([[1, 2, 3], [4, 5, 6]]) if __name__ == \\"__main__\\": unittest.main() ```","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Given a square matrix, return its transpose. if not matrix: return [] n = len(matrix) if any(len(row) != n for row in matrix): raise ValueError(\\"The input matrix is not square\\") transposed = [[matrix[j][i] for j in range(n)] for i in range(n)] return transposed"},{"question":"# Problem Statement You need to create a function that checks whether a given string of digits is an additive sequence. In an additive sequence, each subsequent number is the sum of the previous two numbers. The function should return `True` if the sequence is valid and `False` otherwise. # Requirements: - Function Name: `is_additive_sequence` - Input: a single string `num` consisting of digits only. - Output: a boolean, `True` if the string forms a valid additive sequence, `False` otherwise. # Example ```python assert is_additive_sequence(\\"112358\\") == True assert is_additive_sequence(\\"199100199\\") == True assert is_additive_sequence(\\"12345\\") == False assert is_additive_sequence(\\"1023\\") == False ``` # Constraints: - The length of the string is at most 35. - Leading zeros are allowed only in the case where the number itself is zero (i.e., \\"0\\", \\"00\\" are not valid but \\"0\\" can be a part of \\"0123\\"). # Notes: - You need to check different possible partitions for the first two numbers to determine if the rest of the string can form a valid additive sequence. - Recall the properties of additive sequences and use arithmetic properties to validate the sequence correctly. # Function Signature: ```python def is_additive_sequence(num: str) -> bool: # Your code here ```","solution":"def is_additive_sequence(num: str) -> bool: n = len(num) def is_valid(first, second, remaining): sum_str = str(int(first) + int(second)) if not remaining.startswith(sum_str): return False if len(remaining) == len(sum_str): return True return is_valid(second, sum_str, remaining[len(sum_str):]) for i in range(1, n): for j in range(i + 1, n): first, second = num[:i], num[i:j] if (len(first) > 1 and first[0] == \'0\') or (len(second) > 1 and second[0] == \'0\'): continue if is_valid(first, second, num[j:]): return True return False"},{"question":"# Reverse a LinkedList in Groups of K You are required to implement a function that reverses a linked list in groups of `k` nodes. A linked list is defined by a series of `Node` objects where each node points to the next node in the series. This operation helps in reorganizing the linked list by taking consecutive groups of `k` nodes and reversing their order. **Objective**: Implement the function to reverse a linked list in groups of `k` nodes: 1. **Initialization**: Define the Node class and a function to create a linked list from a list of values. 2. **Reverse in Groups**: Implement the function `reverse_in_groups(head, k)`, which takes the head of the linked list and an integer `k` as inputs and returns the head of the modified linked list. **Detailed Instructions**: 1. **Node Class** - Define the `Node` class to represent a single node in the linked list. - The `Node` class should have properties `value` and `next`. 2. **Function to Create Linked List** - Implement the function `create_linked_list(lst)` which takes a list of values (`lst`) and returns the head of the constructed linked list. 3. **Reverse in Groups Function** - Implement the function `reverse_in_groups(head, k)` in the `Solution` class. - The function should reverse the linked list in groups of `k` and return the new head of the modified linked list. 4. **Print Linked List** - Implement the function `print_linked_list(head)` to print the linked list values for validation. Here is the structure of the `Node` class and the required functions: ```python class Node: def __init__(self, value=0, next=None): self.value = value self.next = next class Solution: def reverse_in_groups(self, head, k): if head is None or k == 1: return head dummy = Node(0) dummy.next = head prev = dummy current = dummy nex = dummy count = 0 to_loop = head while to_loop: count += 1 to_loop = to_loop.next while count >= k: current = prev.next nex = current.next for i in range(1, k): current.next = nex.next nex.next = prev.next prev.next = nex nex = current.next prev = current count -= k return dummy.next def create_linked_list(lst): if not lst: return None head = Node(lst[0]) current = head for value in lst[1:]: current.next = Node(value) current = current.next return head def print_linked_list(head): values = [] current = head while current: values.append(current.value) current = current.next print(\\" -> \\".join(map(str, values))) ``` **Constraints**: 1. The list length (`n`) will be between 1 and 10,000. 2. The integer `k` will be between 1 and 1,000. 3. Ensure the operation maintains the correct order for any remaining nodes if the length is not a multiple of `k`. **Examples**: ```python # Example 1 lst = [1, 2, 3, 4, 5] k = 2 head = create_linked_list(lst) solution = Solution() new_head = solution.reverse_in_groups(head, k) print_linked_list(new_head) # Output: 2 -> 1 -> 4 -> 3 -> 5 # Example 2 lst = [1, 2, 3, 4, 5, 6, 7, 8] k = 3 head = create_linked_list(lst) solution = Solution() new_head = solution.reverse_in_groups(head, k) print_linked_list(new_head) # Output: 3 -> 2 -> 1 -> 6 -> 5 -> 4 -> 7 -> 8 ``` **Explanation**: 1. In the first example, the linked list `[1, 2, 3, 4, 5]` is reversed in groups of 2, resulting in `[2, 1, 4, 3, 5]`. 2. In the second example, the linked list `[1, 2, 3, 4, 5, 6, 7, 8]` is reversed in groups of 3, resulting in `[3, 2, 1, 6, 5, 4, 7, 8]`.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next class Solution: def reverse_in_groups(self, head, k): if head is None or k == 1: return head dummy = Node(0) dummy.next = head prev = dummy current = dummy nex = dummy count = 0 to_loop = head while to_loop: count += 1 to_loop = to_loop.next while count >= k: current = prev.next nex = current.next for i in range(1, k): current.next = nex.next nex.next = prev.next prev.next = nex nex = current.next prev = current count -= k return dummy.next def create_linked_list(lst): if not lst: return None head = Node(lst[0]) current = head for value in lst[1:]: current.next = Node(value) current = current.next return head def print_linked_list(head): values = [] current = head while current: values.append(current.value) current = current.next print(\\" -> \\".join(map(str, values)))"},{"question":"Consider a scenario where you are developing a system to analyze word frequency in a research paper. Your system should identify the most frequent words and their counts, excluding a predefined list of common stop words. # Task Complete the given function to analyze the word frequency in the input text, excluding the specified stop words. Then return the top N most frequent words along with their counts. Function Signature ```python def top_n_frequent_words(text: str, stop_words: List[str], n: int) -> List[Tuple[str, int]]: # Implement this function ``` Input Format * A single string `text` of length `l` containing the research paper\'s text. * A list of strings `stop_words` containing the common words to exclude from the analysis. * An integer `n` specifying the number of top frequent words to return. Output Format * Return a list of tuples, where each tuple contains a word and its frequency count. The list should be sorted by frequency in descending order. In case of a tie, sort the words lexicographically. Constraints * 1 ≤ l ≤ 10^5 * 1 ≤ |stop_words| ≤ 10^3 * Each word in `text` and `stop_words` will consist of only lowercase English letters. * Words are separated by spaces in `text`. # Example ```python text = \\"the quick brown fox jumps over the lazy dog the quick brown fox jumps\\" stop_words = [\\"the\\", \\"over\\", \\"a\\"] n = 3 print(top_n_frequent_words(text, stop_words, n)) # Output: [(\\"quick\\", 2), (\\"brown\\", 2), (\\"fox\\", 2)] ``` # Notes * Consider using a dictionary to count word frequencies. * Utilize appropriate data structures to manage and sort the top N frequent words efficiently. * Ignore punctuation and treat words as case-insensitive for the purpose of frequency calculation.","solution":"from typing import List, Tuple from collections import Counter import re def top_n_frequent_words(text: str, stop_words: List[str], n: int) -> List[Tuple[str, int]]: # Convert text to lowercase and remove punctuation text = text.lower() text = re.sub(r\'[^ws]\', \'\', text) # Split the text into words words = text.split() # Filter out stop words filtered_words = [word for word in words if word not in stop_words] # Count the frequency of each word word_counts = Counter(filtered_words) # Get the top N most common words most_common_words = word_counts.most_common(n) return most_common_words"},{"question":"# Sorting a List of Custom Objects Context: In many practical applications, sorting data based on custom criteria is crucial. This could involve sorting based on multiple attributes or redefining the comparison logic. Consider a scenario where you need to sort a list of `Person` objects. Task: Implement a function that sorts a list of `Person` objects first by their age in ascending order, and if two people have the same age, by their name in lexicographical order. Class and Function Signature: ```python class Person: def __init__(self, name: str, age: int): self.name = name self.age = age def sort_people(people: List[Person]) -> List[Person]: pass ``` Input: * `people`: A list of `n` `Person` objects, where `0 ≤ n ≤ 10^5`. Output: * A list of `Person` objects sorted first by age in ascending order, and by name in lexicographical order if two ages are the same. Performance Requirement: The solution should function efficiently for lists containing up to 10^5 objects. Constraints: * Each `Person` object has a `name` (a string of up to 100 characters) and `age` (an integer between 0 and 150). Example: ```python # Example 1: people = [Person(\\"Alice\\", 30), Person(\\"Bob\\", 25), Person(\\"Charlie\\", 30), Person(\\"Dave\\", 25)] # Explanation: Sorting by age, then name. # Result: [Person(\\"Bob\\", 25), Person(\\"Dave\\", 25), Person(\\"Alice\\", 30), Person(\\"Charlie\\", 30)] sorted_people = sort_people(people) print([(person.name, person.age) for person in sorted_people]) # Output: [(\'Bob\', 25), (\'Dave\', 25), (\'Alice\', 30), (\'Charlie\', 30)] # Example 2: people = [Person(\\"Zack\\", 40), Person(\\"Anna\\", 26), Person(\\"Tom\\", 40), Person(\\"Anna\\", 26)] # Explanation: Sorting by age, then name. # Result: [Person(\\"Anna\\", 26), Person(\\"Anna\\", 26), Person(\\"Tom\\", 40), Person(\\"Zack\\", 40)] sorted_people = sort_people(people) print([(person.name, person.age) for person in sorted_people]) # Output: [(\'Anna\', 26), (\'Anna\', 26), (\'Tom\', 40), (\'Zack\', 40)] ``` # Note: Feel free to create additional test cases to verify the correctness and efficiency of your sorting function. Ensure that the sorted output matches the expected order based on the given criteria.","solution":"class Person: def __init__(self, name: str, age: int): self.name = name self.age = age def sort_people(people): Sorts a list of Person objects first by age in ascending order, and if two people have the same age, by their name in lexicographical order. return sorted(people, key=lambda person: (person.age, person.name))"},{"question":"# Scenario: You are asked to implement a system to manage a collection of social network messages. Each message has a unique ID, a timestamp, and a content string. You must provide functionality to **add** a message and **retrieve** the most recent N messages, sorted by their timestamps. # Requirements: 1. **Add Message operation** should add a new message to the system. 2. **Retrieve Recent Messages operation** should return the most recent N messages, sorted by their timestamps in descending order (most recent first). # Function Specifications: 1. **Add Message Function**: ```python def add_message(self, message_id: int, timestamp: int, content: str) -> None: Adds a new message to the system. Parameters: message_id (int): Unique identifier for the message. timestamp (int): UNIX timestamp of when the message was posted. content (str): The content of the message. # Your implementation here ``` 2. **Retrieve Recent Messages Function**: ```python def get_recent_messages(self, N: int) -> List[Tuple[int, int, str]]: Retrieves the most recent N messages sorted by their timestamps. Parameters: N (int): The number of recent messages to retrieve. Returns: List[Tuple[int, int, str]]: A list of tuples, each containing (message_id, timestamp, content) # Your implementation here ``` # Constraints: - **Number of Messages**: 1 <= number of messages <= 10^5 - **Message ID Range**: Message IDs are unique integers in the range [1, 10^9]. - **Timestamp Range**: All timestamps are UNIX timestamps (non-negative integers). - **Content Length**: Content strings will have a length of up to 280 characters. # Performance Requirements: - **Add Message operation** should run in constant time. - **Retrieve Recent Messages operation** should run in O(N log M) time, where M is the number of messages in the system. # Example Usage: ```python # Initialize the message system message_system = MessageSystem() # Add messages to the system message_system.add_message(1, 1633030123, \\"Hello World\\") message_system.add_message(2, 1633031123, \\"Welcome to the social network\\") message_system.add_message(3, 1633032123, \\"Enjoy your stay\\") # Retrieve the most recent 2 messages recent_messages = message_system.get_recent_messages(2) # Should return the following list: # [ # (3, 1633032123, \\"Enjoy your stay\\"), # (2, 1633031123, \\"Welcome to the social network\\") # ] ``` Ensure that the operations add_message and get_recent_messages follow the constraints and perform efficiently.","solution":"from typing import List, Tuple class MessageSystem: def __init__(self): self.messages = [] def add_message(self, message_id: int, timestamp: int, content: str) -> None: import heapq heapq.heappush(self.messages, (-timestamp, message_id, content)) def get_recent_messages(self, N: int) -> List[Tuple[int, int, str]]: import heapq return [(message_id, -timestamp, content) for timestamp, message_id, content in heapq.nsmallest(N, self.messages)]"},{"question":"# Coding Question Scenario You have been hired by an e-commerce company to improve their price comparison tool. The tool takes a list of product prices from different merchants and returns them sorted in descending order. The prices are represented as floating-point numbers. Objective Implement the `sort_prices_descending` function that efficiently sorts an input list of prices in descending order. Function Signature ```python def sort_prices_descending(prices: list[float]) -> list[float]: ``` Input * A list of floating-point numbers, where each number represents the price of a product. Output * A list of floating-point numbers, representing the sorted prices in descending order. Constraints * The list can contain between 0 and 10^5 prices. * Each price is guaranteed to be a non-negative floating-point number. * The input list may be empty. Example ```python assert sort_prices_descending([19.99, 5.49, 99.99, 0.99, 15.50]) == [99.99, 19.99, 15.50, 5.49, 0.99] assert sort_prices_descending([]) == [] assert sort_prices_descending([10.0, 10.0, 10.0]) == [10.0, 10.0, 10.0] ``` Constraints & Performance Requirements * The function should run in linearithmic time relative to the number of prices (`O(n log n)`). * The solution should be simple and clear. * Optimize for clarity and maintainability. Instructions 1. Implement the function `sort_prices_descending`. 2. Write your implementation to pass all the given example cases. 3. Consider edge cases such as an empty list or a list with duplicate prices.","solution":"def sort_prices_descending(prices): Sorts a list of prices in descending order. :param prices: List of floating point numbers representing prices. :return: List of prices sorted in descending order. return sorted(prices, reverse=True)"},{"question":"# Problem: Determining the Edit Distance between Two Strings You need to write a function that calculates the minimum edit distance (Levenshtein distance) between two strings. The edit distance is defined as the minimum number of operations (insertions, deletions, or substitutions) required to transform one string into the other. # Constraints and Requirements 1. **Input**: Two strings `str1` and `str2`. 2. **Output**: An integer representing the minimum number of edit operations needed. # Specifications 1. Both input strings will consist of lowercase alphabetical characters only. 2. The function should handle inputs up to 500 characters in length. 3. Any invalid input (non-string input) must raise appropriate exceptions. # Function Signature ```python def calculate_edit_distance(str1: str, str2: str) -> int: pass ``` # Example Usage ```python # Example 1 str1 = \\"kitten\\" str2 = \\"sitting\\" assert calculate_edit_distance(str1, str2) == 3 # Example 2 str1 = \\"flaw\\" str2 = \\"lawn\\" assert calculate_edit_distance(str1, str2) == 2 # Example 3 str1 = \\"intention\\" str2 = \\"execution\\" assert calculate_edit_distance(str1, str2) == 5 # Example 4 - Invalid Input try: calculate_edit_distance([\\"invalid\\", \\"input\\"], \\"string\\") except TypeError as e: assert str(e) == \\"Both inputs must be strings\\" ``` # Additional Considerations 1. Your function should efficiently handle dynamic programming techniques to compute the edit distance. 2. Ensure the function uses space and time complexity optimizations where possible. 3. Include comprehensive error handling for invalid inputs. This question requires implementing a dynamic programming solution for a well-known problem in computer science, testing the candidate\'s ability to design algorithms efficiently and handle edge cases robustly.","solution":"def calculate_edit_distance(str1: str, str2: str) -> int: if not isinstance(str1, str) or not isinstance(str2, str): raise TypeError(\\"Both inputs must be strings\\") len1, len2 = len(str1), len(str2) dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] for i in range(len1 + 1): for j in range(len2 + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1]) # Substitution return dp[len1][len2]"},{"question":"# Prime Factors and Exponentiation **Context:** Prime factorization is a foundational problem in number theory, where a number is expressed as the product of prime numbers. Exponentiating these factors can be critical for understanding the structure of numbers and their properties. **Problem Statement:** Write a function `prime_factors_exp` that takes an integer `n` and returns a list of tuples. Each tuple contains a prime factor and its respective exponent in the prime factorization of `n`. Ensure the list is sorted by the prime factors in ascending order. ```python def prime_factors_exp(n: int) -> list[tuple[int, int]]: pass ``` **Function Definition:** * **Input**: * `n` (int): The integer to factorize. ( 1 leq n leq 10^9 ) * **Output**: * Returns list[tuple[int, int]]: A list of tuples where each tuple contains a prime factor and its exponent. **Constraints**: 1. Input `n` will always be a positive integer. 2. The prime factors list should be in ascending order. 3. Each prime factor should be greater than or equal to 2. **Edge Cases to Consider**: 1. `n` is a prime number. 2. `n` is a power of a prime number. 3. Large `n` values close to the upper limit. # Example: ```python print(prime_factors_exp(18)) # Output: [(2, 1), (3, 2)] print(prime_factors_exp(100)) # Output: [(2, 2), (5, 2)] print(prime_factors_exp(37)) # Output: [(37, 1)] ``` **Verification**: Create a unit test class `TestPrimeFactorsExp` with methods to test the prime_factors_exp function covering all edge cases, including prime numbers, composite numbers, and large values. ```python import unittest class TestPrimeFactorsExp(unittest.TestCase): def test_small_number(self): self.assertEqual(prime_factors_exp(18), [(2, 1), (3, 2)]) def test_power_of_prime(self): self.assertEqual(prime_factors_exp(32), [(2, 5)]) def test_large_prime(self): self.assertEqual(prime_factors_exp(997), [(997, 1)]) def test_composite_large(self): self.assertEqual(prime_factors_exp(100), [(2, 2), (5, 2)]) if __name__ == \'__main__\': unittest.main() ```","solution":"import math def prime_factors_exp(n: int) -> list: Returns a list of tuples containing the prime factor and its exponent in the factorization of n. factors = [] # Check count of 2s count = 0 while n % 2 == 0: n //= 2 count += 1 if count > 0: factors.append((2, count)) # Check for odd factors from 3 onwards for i in range(3, int(math.sqrt(n)) + 1, 2): count = 0 while n % i == 0: n //= i count += 1 if count > 0: factors.append((i, count)) # If remaining n is a prime number if n > 2: factors.append((n, 1)) return factors"},{"question":"# Question: Stock Portfolio Analysis for Maximum Profit # Context: In stock trading, an investor buys and sells stocks to maximize their profit. A crucial aspect of portfolio analysis is determining the most profitable pair of buying and selling days within a given time frame. This helps investors understand the potential maximum profit they could achieve by buying on one day and selling on another subsequent day. # Task: Implement a function `max_profit` that computes the maximum possible profit from a list of daily stock prices. The function determines the best days to buy and sell the stock to achieve this profit. # Function Signature: ```python def max_profit(prices: list[int]) -> int: pass ``` # Input: * `prices` (list of int): A list of stock prices where `prices[i]` is the price of the stock on the ith day. # Output: * An integer representing the maximum profit that can be achieved. If no profit is possible, return 0. # Constraints: * The number of days will be between 1 and 10^5. * Each stock price will be between 1 and 10^5. # Example: ```python >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([2, 4, 1]) 2 >>> max_profit([2, 4]) 2 >>> max_profit([4, 2]) 0 ``` # Notes: * The investor cannot sell a stock before buying it. So the sell day must be after the buy day. * Ensure your implementation handles the edge cases where no transactions can yield a profit. * The function must be efficient enough to handle the upper limits of input constraints.","solution":"def max_profit(prices: list[int]) -> int: if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"# Question: Implement a Data Structure for Constant Time Maximum Frequency Element Retrieval. You are required to implement a class `FreqStack` that supports efficient insertion of elements and retrieval of the most frequent element. If multiple elements have the same frequency, the most recently inserted element is considered the most frequent. The `FreqStack` class should have the following functionalities: 1. **push(int val)**: Adds an integer `val` onto the stack. 2. **pop() -> int**: Removes and returns the most frequent element in the stack. * If multiple elements have the same frequency, the element closest to the top of the stack is removed and returned. **Constraints**: - All elements pushed onto the stack are integers within the range of a 32-bit signed integer. - The number of `push` and `pop` operations will be at most 10000. **Properties**: - The implementation should ensure that both `push` and `pop` operations have an average time complexity of O(1). **Example**: ```python fs = FreqStack() fs.push(5) fs.push(7) fs.push(5) fs.push(7) fs.push(4) fs.push(5) print(fs.pop()) # Output: 5 print(fs.pop()) # Output: 7 print(fs.pop()) # Output: 5 print(fs.pop()) # Output: 4 ``` **Note**: You should leverage appropriate data structures to maintain the frequency of elements and manage the order of elements with the same frequency efficiently.","solution":"from collections import defaultdict, deque class FreqStack: def __init__(self): self.freq = defaultdict(int) self.group = defaultdict(deque) self.max_freq = 0 def push(self, val: int) -> None: self.freq[val] += 1 f = self.freq[val] if f > self.max_freq: self.max_freq = f self.group[f].append(val) def pop(self) -> int: val = self.group[self.max_freq].pop() self.freq[val] -= 1 if not self.group[self.max_freq]: self.max_freq -= 1 return val"},{"question":"# Coding Question Introduction: Dynamic programming is a powerful technique used to solve optimization problems by breaking them down into simpler subproblems and storing the results of these subproblems to avoid redundant computations. In this exercise, you will implement a solution to the \\"House Robber II\\" problem, where a series of houses are arranged in a circular manner, and a robber cannot rob two adjacent houses. Task: Write a function `rob` that takes a list of integers `nums` as input, representing the amount of money in each house arranged in a circle, and returns the maximum amount of money the robber can rob without alerting the police. Function Signature: ```python def rob(nums: List[int]) -> int: ``` Input: - `nums`: A list of integers where each integer represents the amount of money in a house. (0 <= len(nums) <= 100, 0 <= nums[i] <= 1000). Output: - An integer representing the maximum amount of money the robber can rob without alerting the police. Constraints: - The list `nums` can be empty, in which case the function should return 0. - The houses are arranged in a circular manner, which means the first and the last house cannot both be robbed. Example: ```python # Example call result = rob([3, 2, 3, 4]) # Expected output # 6 ``` Notes: 1. Address the scenario where robbing the first house excludes the possibility of robbing the last house. 2. Develop and utilize a helper function to solve the subproblems. 3. Cover edge cases, such as when the input list is empty or contains only one house.","solution":"from typing import List def rob(nums: List[int]) -> int: def rob_linear(nums: List[int]) -> int: prev, curr = 0, 0 for num in nums: prev, curr = curr, max(curr, prev + num) return curr if not nums: return 0 if len(nums) == 1: return nums[0] return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))"},{"question":"# Question Title: Weather Data Aggregator with Caching Mechanism # Scenario You are tasked with developing a script that retrieves weather data for a list of cities from a public weather API. The data should be cached to minimize the number of requests made to the API in a short period. Implement a caching mechanism that stores the results in memory and uses them if a request for the same city is made within 10 minutes. # Requirements 1. **Data Fetching and Parsing**: - Use the `requests` library to fetch weather data from the URL `https://api.openweathermap.org/data/2.5/weather?q={city_name}&appid={API_key}`. - Parse the JSON response to extract the necessary weather information: city name, temperature, humidity, and weather description. 2. **Caching Mechanism**: - Implement an in-memory caching mechanism with a dictionary to store the API responses. - Cache the responses with a timestamp and use the cached result if a request for the same city is made within 10 minutes. - Ensure expired cache entries are removed or updated with a new request after 10 minutes. 3. **Edge Case Consideration**: - Handle potential HTTP errors (e.g., 404 for city not found, 500 for server issues) and network issues (e.g., timeouts). - Ensure the program detects and prints an appropriate message if the API response is not as expected. - Utilize Python\'s exception handling to manage unexpected errors during the request and parsing process. # Function Signature Implement the following function: ```python def get_weather_data(city_names: List[str], api_key: str) -> Dict[str, Dict[str, Any]]: pass ``` # Input - `city_names`: A list of strings representing the city names for which the weather data is to be fetched. - `api_key`: A string representing the API key required to authenticate and access the OpenWeatherMap API. # Output The function should return a dictionary where the keys are city names, and the values are dictionaries containing: - `temperature`: The current temperature in the city (in Celsius). - `humidity`: The humidity percentage in the city. - `weather_description`: A brief description of the weather (e.g., clear sky, rain). # Constraints - Use the `requests` library for fetching data and handle the network reliability and error responses. - Implement the caching mechanism so that requests for the same city within 10 minutes are served from the cache. - Ensure proper error handling for both network errors and unexpected API responses. # Example Usage ```python weather_data = get_weather_data([\\"New York\\", \\"Los Angeles\\", \\"Sydney\\"], \\"your_api_key\\") for city, data in weather_data.items(): print(f\\"Weather in {city}:\\") print(f\\"Temperature: {data[\'temperature\']}°C\\") print(f\\"Humidity: {data[\'humidity\']}%\\") print(f\\"Description: {data[\'weather_description\']}\\") print(\\"-\\" * 40) ``` Expected output (subject to current weather data): ``` Weather in New York: Temperature: 22°C Humidity: 60% Description: clear sky ---------------------------------------- Weather in Los Angeles: Temperature: 24°C Humidity: 55% Description: few clouds ---------------------------------------- Weather in Sydney: Temperature: 17°C Humidity: 75% Description: shower rain ---------------------------------------- ``` Write your implementation of `get_weather_data` and ensure it meets the requirements specified above.","solution":"import requests import time from typing import List, Dict, Any cache = {} def get_weather_data(city_names: List[str], api_key: str) -> Dict[str, Dict[str, Any]]: def fetch_weather(city: str) -> Dict[str, Any]: try: response = requests.get(f\\"https://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}&units=metric\\") response.raise_for_status() data = response.json() weather_info = { \'temperature\': data[\'main\'][\'temp\'], \'humidity\': data[\'main\'][\'humidity\'], \'weather_description\': data[\'weather\'][0][\'description\'] } return weather_info except requests.RequestException as e: print(f\\"Request for {city} failed: {e}\\") return {\'temperature\': None, \'humidity\': None, \'weather_description\': \'Data not available\'} result = {} current_time = time.time() for city in city_names: if city in cache and (current_time - cache[city][\'timestamp\']) < 600: result[city] = cache[city][\'data\'] else: weather_data = fetch_weather(city) cache[city] = { \'data\': weather_data, \'timestamp\': current_time } result[city] = weather_data return result"},{"question":"You need to write a function that counts the number of distinct characters in a string and summarizes the character distribution. This will help in understanding the frequency and variety of characters in a given string. # Function Definition Implement the function `character_distribution(text)` that takes in a string `text` and returns a dictionary summarizing the character distribution. # Return Format The function should return a dictionary with the following keys and their corresponding values: - `\'total_characters\'`: The total number of characters in the string. - `\'unique_characters\'`: The number of unique characters in the string. - `\'frequency_distribution\'`: A dictionary where keys are individual characters and values are their frequencies in the string. - `\'most_frequent_char\'`: The character that appears most frequently in the string. If there are multiple characters with the same highest frequency, return any one of them. # Constraints - The input string `text` will have a length ranging from 1 to 10^6 characters. - The string will contain printable ASCII characters including letters, digits, punctuation, and whitespace. # Example ```python text = \\"hello world\\" result = character_distribution(text) # Expected Output: # { # \'total_characters\': 11, # \'unique_characters\': 8, # \'frequency_distribution\': { # \'h\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \' \': 1, \'w\': 1, \'r\': 1, \'d\': 1 # }, # \'most_frequent_char\': \'l\' # } ``` # Additional Information - Handle cases with punctuation, digits, and special characters correctly. - Ensure the function performs efficiently even for larger strings. By following the provided example and structure, implement the `character_distribution` function to accurately compute and summarize the character distribution in a given string.","solution":"def character_distribution(text): Returns a dictionary summarizing the character distribution in the given text. distribution = {} total_characters = len(text) # Compute frequency distribution for char in text: if char in distribution: distribution[char] += 1 else: distribution[char] = 1 # Find the most frequent character most_frequent_char = max(distribution, key=distribution.get) # Return the summarized character distribution result = { \'total_characters\': total_characters, \'unique_characters\': len(distribution), \'frequency_distribution\': distribution, \'most_frequent_char\': most_frequent_char } return result"},{"question":"# Problem You are tasked with implementing a system to manage and process a queue of print jobs in a printer server. Each print job has an ID, a priority, and a number of pages. The server processes the print jobs based on their priority (higher priority jobs are processed first). If two jobs have the same priority, they are processed in the order they were added to the queue. Your task is to complete a class implementation that manages and processes the print queue according to these rules. # Class Definition ```python class PrintServer: def __init__(self): pass def add_job(self, job_id: int, priority: int, pages: int) -> None: pass def get_next_job(self) -> dict: pass def process_job(self) -> dict: pass ``` # Methods 1. **`__init__(self)`**: - Initializes the print server with an empty queue. 2. **`add_job(self, job_id: int, priority: int, pages: int) -> None`**: - Adds a new print job to the queue with the given ID, priority, and number of pages. 3. **`get_next_job(self) -> dict`**: - Returns the next job to be processed without removing it from the queue. - If the queue is empty, return an empty dictionary `{}`. 4. **`process_job(self) -> dict`**: - Processes and removes the next job from the queue. - Returns the job details in a dictionary. If the queue is empty, return an empty dictionary `{}`. # Example ```python server = PrintServer() server.add_job(1, 2, 10) server.add_job(2, 1, 5) server.add_job(3, 3, 15) assert server.get_next_job() == {\'job_id\': 3, \'priority\': 3, \'pages\': 15} assert server.process_job() == {\'job_id\': 3, \'priority\': 3, \'pages\': 15} assert server.get_next_job() == {\'job_id\': 1, \'priority\': 2, \'pages\': 10} server.add_job(4, 2, 20) assert server.process_job() == {\'job_id\': 1, \'priority\': 2, \'pages\': 10} assert server.get_next_job() == {\'job_id\': 4, \'priority\': 2, \'pages\': 20} assert server.process_job() == {\'job_id\': 4, \'priority\': 2, \'pages\': 20} assert server.get_next_job() == {\'job_id\': 2, \'priority\': 1, \'pages\': 5} assert server.process_job() == {\'job_id\': 2, \'priority\': 1, \'pages\': 5} assert server.get_next_job() == {} assert server.process_job() == {} ``` # Constraints - `0 ≤ job_id ≤ 10^9` - `1 ≤ priority ≤ 10` - `1 ≤ pages ≤ 1000` - A maximum of `10^4` jobs can be added to the queue during the server\'s lifetime.","solution":"import heapq class PrintServer: def __init__(self): self.queue = [] self.counter = 0 # To maintain insertion order def add_job(self, job_id: int, priority: int, pages: int) -> None: heapq.heappush(self.queue, (-priority, self.counter, {\'job_id\': job_id, \'priority\': priority, \'pages\': pages})) self.counter += 1 def get_next_job(self) -> dict: if self.queue: return self.queue[0][2] return {} def process_job(self) -> dict: if self.queue: return heapq.heappop(self.queue)[2] return {}"},{"question":"# Coding Assessment Question Context You are building a software application that deals with the analysis of sequences. One specific requirement is to determine if a given sequence of integers can be rearranged to form a consecutive sequence. For example, the sequence `[1, 2, 3, 4, 5]` is already consecutive, while `[1, 2, 4, 5]` is not, but it can be rearranged to `[1, 2, 3, 4, 5]`. Task Write a function `can_form_consecutive_sequence(nums: List[int]) -> bool` that takes a list of integers `nums` and returns `True` if the integers can be rearranged to form a consecutive sequence, otherwise returns `False`. Input * A list of integers `nums`, where `0 <= len(nums) <= 10^5`. Output * A boolean value: `True` if the integers can be rearranged to form a consecutive sequence, otherwise `False`. Constraints * The sequence may contain duplicate values. * Your implementation should be efficient both in terms of time and space. * Aim for O(n) time complexity. Examples ```python assert can_form_consecutive_sequence([1, 2, 3, 4, 5]) == True assert can_form_consecutive_sequence([1, 2, 4, 5]) == False assert can_form_consecutive_sequence([5, 3, 2, 1, 4]) == True assert can_form_consecutive_sequence([]) == False assert can_form_consecutive_sequence([3, 3, 2, 1, 4]) == False assert can_form_consecutive_sequence([0, -1, -2, 1, 2]) == True ``` **Note**: Focus on creating an efficient algorithm that avoids unnecessary sorting or additional data structures that increase time or space complexity.","solution":"from typing import List def can_form_consecutive_sequence(nums: List[int]) -> bool: if not nums: return False num_set = set(nums) if len(num_set) != len(nums): return False return max(num_set) - min(num_set) + 1 == len(num_set)"},{"question":"# Problem: Enhancing a Weather Data Aggregator You are given a function that fetches and parses weather data from an online API. The site provides data on temperature, humidity, and wind speed for different cities. The current implementation uses the `requests` library to make the API call and json to parse the response. Your task is to enhance this function by introducing the following improvements: 1. **Error Handling**: Add robust error handling to manage potential request failures, network issues, or changes in the API response. 2. **Extensibility**: Modify the function so that it can easily accommodate additional data points (like precipitation, air quality) provided in the future without major code changes. 3. **Efficiency**: Ensure the function remains efficient and optimized for cases where multiple city data is fetched simultaneously. # Input - `cities` (list): A list of city names for which the weather data needs to be fetched. # Output - A dictionary where each key is a city name and the value is another dictionary containing the weather data points like `temperature`, `humidity`, `wind_speed`, etc. # Constraints - Ensure the function handles API failures gracefully. - API responses should be parsed to accommodate changes in the structure. - The solution should complete in a reasonable timeframe even when fetching data for multiple cities. - Validate the format and data type of the extracted data points to ensure they are correctly parsed. # Example Usage ```python cities = [\\"New York\\", \\"Los Angeles\\", \\"Chicago\\"] result = enhanced_weather_aggregator(cities) print(result) # Expected output: { # \\"New York\\": { # \\"temperature\\": 21.2, # \\"humidity\\": 54, # \\"wind_speed\\": 5.5, # // Potentially more data points if available in the future # }, # \\"Los Angeles\\": { # \\"temperature\\": 25.4, # \\"humidity\\": 47, # \\"wind_speed\\": 3.2, # // Potentially more data points if available in the future # }, # \\"Chicago\\": { # \\"temperature\\": 18.3, # \\"humidity\\": 62, # \\"wind_speed\\": 7.1, # // Potentially more data points if available in the future # } # } ``` # Implementation Tips - Use `try-except` blocks to handle network, parsing errors, and potential API issues. - Consider making the API requests concurrently to improve efficiency. - Validate each data point to confirm it is correctly extracted and formatted. - Use features of the response JSON structure to dynamically adapt to additional fields. ```python import requests def enhanced_weather_aggregator(cities): api_key = \\"your_api_key_here\\" base_url = \\"http://api.openweathermap.org/data/2.5/weather\\" weather_data = {} for city in cities: try: response = requests.get(base_url, params={\\"q\\": city, \\"appid\\": api_key}) response.raise_for_status() data = response.json() if \\"main\\" in data and \\"wind\\" in data: city_weather = { \\"temperature\\": data[\\"main\\"].get(\\"temp\\"), \\"humidity\\": data[\\"main\\"].get(\\"humidity\\"), \\"wind_speed\\": data[\\"wind\\"].get(\\"speed\\") } # Collect additional fields dynamically for key in data[\\"main\\"]: if key not in city_weather: city_weather[key] = data[\\"main\\"][key] for key in data[\\"wind\\"]: if key not in city_weather: city_weather[key] = data[\\"wind\\"][key] weather_data[city] = city_weather except requests.RequestException as e: print(f\\"An error occurred while fetching data for {city}: {str(e)}\\") weather_data[city] = {\\"error\\": \\"Unable to fetch data\\"} return weather_data # Example usage cities = [\\"New York\\", \\"Los Angeles\\", \\"Chicago\\"] result = enhanced_weather_aggregator(cities) print(result) ```","solution":"import requests def enhanced_weather_aggregator(cities): api_key = \\"your_api_key_here\\" # Replace with an actual API key base_url = \\"http://api.openweathermap.org/data/2.5/weather\\" weather_data = {} for city in cities: try: response = requests.get(base_url, params={\\"q\\": city, \\"appid\\": api_key}) response.raise_for_status() data = response.json() city_weather = { \\"temperature\\": data.get(\\"main\\", {}).get(\\"temp\\"), \\"humidity\\": data.get(\\"main\\", {}).get(\\"humidity\\"), \\"wind_speed\\": data.get(\\"wind\\", {}).get(\\"speed\\"), } # Collect additional fields dynamically if they exist additional_fields_main = (\'pressure\', \'temp_min\', \'temp_max\') for field in additional_fields_main: if field in data.get(\\"main\\", {}): city_weather[field] = data[\\"main\\"][field] additional_fields_wind = (\'deg\', \'gust\') for field in additional_fields_wind: if field in data.get(\\"wind\\", {}): city_weather[field] = data[\\"wind\\"][field] weather_data[city] = city_weather except requests.RequestException as e: print(f\\"An error occurred while fetching data for {city}: {str(e)}\\") weather_data[city] = {\\"error\\": \\"Unable to fetch data\\"} return weather_data # Example usage cities = [\\"New York\\", \\"Los Angeles\\", \\"Chicago\\"] result = enhanced_weather_aggregator(cities) print(result)"},{"question":"# Problem Statement You are tasked with developing a software system to manage a library\'s book reservation process. The library allows patrons to reserve books, and a book cannot be reserved by multiple patrons simultaneously. When a book is reserved, it also has a reservation expiry date. # Requirements: Implement a class `LibrarySystem` that manages the book reservation process. The class should support the following operations: 1. **Reserve a book** - A book can be reserved by providing a book ID, patron ID, and reservation duration (in days). 2. **Extend a reservation** - A reservation can be extended by providing a book ID, patron ID, and additional days to extend the reservation. 3. **Check reservation status** - The system should be able to return the current status of a book reservation, including reservation expiry date and the patron who reserved it. Constraints: * Book IDs and Patron IDs are positive integers. * Reservation durations and extension days are positive integers. * Reservation duration cannot exceed 30 days. * The system should raise appropriate errors for invalid operations (e.g., trying to reserve a book that\'s already reserved, trying to extend a reservation beyond the allowed limits). # Class Definition: ```python from datetime import datetime, timedelta class LibrarySystem: def __init__(self): pass def reserve_book(self, book_id: int, patron_id: int, duration: int) -> None: pass def extend_reservation(self, book_id: int, patron_id: int, additional_days: int) -> None: pass def check_reservation_status(self, book_id: int) -> str: pass ``` # Example: ```python from datetime import datetime, timedelta class LibrarySystem: def __init__(self): self.reservations = {} def reserve_book(self, book_id: int, patron_id: int, duration: int) -> None: if duration > 30: raise ValueError(\\"Reservation duration cannot exceed 30 days\\") if book_id in self.reservations: raise ValueError(\\"Book is already reserved\\") expiry_date = datetime.now() + timedelta(days=duration) self.reservations[book_id] = (patron_id, expiry_date) def extend_reservation(self, book_id: int, patron_id: int, additional_days: int) -> None: if book_id not in self.reservations: raise ValueError(\\"Book is not reserved\\") current_patron_id, current_expiry_date = self.reservations[book_id] if current_patron_id != patron_id: raise ValueError(\\"Only the patron who reserved the book can extend the reservation\\") new_expiry_date = current_expiry_date + timedelta(days=additional_days) if (new_expiry_date - datetime.now()).days > 30: raise ValueError(\\"Extended reservation duration cannot exceed 30 days from now\\") self.reservations[book_id] = (patron_id, new_expiry_date) def check_reservation_status(self, book_id: int) -> str: if book_id not in self.reservations: return \\"Book is not reserved\\" patron_id, expiry_date = self.reservations[book_id] return f\\"Book is reserved by patron {patron_id} until {expiry_date.strftime(\'%Y-%m-%d %H:%M:%S\')}\\" # Example Usage library = LibrarySystem() library.reserve_book(1, 101, 10) print(library.check_reservation_status(1)) # Output: Book is reserved by patron 101 until YYYY-MM-DD HH:MM:SS library.extend_reservation(1, 101, 5) print(library.check_reservation_status(1)) # Output: Book is reserved by patron 101 until YYYY-MM-DD HH:MM:SS try: library.reserve_book(1, 102, 2) except ValueError as e: print(e) # Output: Book is already reserved ``` # Additional Examples: ```python library = LibrarySystem() library.reserve_book(2, 102, 20) print(library.check_reservation_status(2)) # Output: Book is reserved by patron 102 until YYYY-MM-DD HH:MM:SS try: library.extend_reservation(2, 103, 5) except ValueError as e: print(e) # Output: Only the patron who reserved the book can extend the reservation library.extend_reservation(2, 102, 10) print(library.check_reservation_status(2)) # Output: Book is reserved by patron 102 until YYYY-MM-DD HH:MM:SS try: library.extend_reservation(2, 102, 20) except ValueError as e: print(e) # Output: Extended reservation duration cannot exceed 30 days from now print(library.check_reservation_status(3)) # Output: Book is not reserved ``` # Notes: * Use the `datetime` and `timedelta` classes from the `datetime` module to handle dates and times. * Ensure all methods in the `LibrarySystem` class handle exceptions appropriately and provide meaningful error messages.","solution":"from datetime import datetime, timedelta class LibrarySystem: def __init__(self): self.reservations = {} def reserve_book(self, book_id: int, patron_id: int, duration: int) -> None: if duration > 30: raise ValueError(\\"Reservation duration cannot exceed 30 days\\") if book_id in self.reservations: raise ValueError(\\"Book is already reserved\\") expiry_date = datetime.now() + timedelta(days=duration) self.reservations[book_id] = (patron_id, expiry_date) def extend_reservation(self, book_id: int, patron_id: int, additional_days: int) -> None: if book_id not in self.reservations: raise ValueError(\\"Book is not reserved\\") current_patron_id, current_expiry_date = self.reservations[book_id] if current_patron_id != patron_id: raise ValueError(\\"Only the patron who reserved the book can extend the reservation\\") new_expiry_date = current_expiry_date + timedelta(days=additional_days) if (new_expiry_date - datetime.now()).days > 30: raise ValueError(\\"Extended reservation duration cannot exceed 30 days from now\\") self.reservations[book_id] = (patron_id, new_expiry_date) def check_reservation_status(self, book_id: int) -> str: if book_id not in self.reservations: return \\"Book is not reserved\\" patron_id, expiry_date = self.reservations[book_id] return f\\"Book is reserved by patron {patron_id} until {expiry_date.strftime(\'%Y-%m-%d %H:%M:%S\')}\\""},{"question":"# Question: JSON Data Aggregation for E-commerce Orders You are tasked with developing a Python function that aggregates order information from an e-commerce platform\'s API. The API returns individual orders in JSON format, and your function should consolidate this data into a summarized report. Function Signature ```python def aggregate_orders(api_url: str, num_orders: int) -> dict[str, Any]: pass ``` Input: - `api_url` (str): The base URL of the e-commerce API endpoint for fetching orders. - `num_orders` (int): The number of most recent orders to fetch. Output: - A dictionary containing the following keys: - `\'total_orders\'`: The total number of orders processed. - `\'total_revenue\'`: The sum of the order totals for all fetched orders. - `\'average_order_value\'`: The average value of an order. - `\'order_details\'`: A list of dictionaries, where each dictionary contains: - `\'order_id\'`: The unique identifier for the order. - `\'order_total\'`: The total amount for the order. - `\'created_at\'`: The creation date of the order in ISO 8601 format. Constraints: - The function should handle HTTP errors gracefully by returning a dictionary with zero totals and an empty order list on failure. - Your solution must handle fetching and parsing JSON data correctly. - Ensure that the function can dynamically construct the API request to fetch the required number of orders. Sample Execution: ```python # Fetch order data orders_summary = aggregate_orders(\\"https://api.example.com/orders\\", 5) print(orders_summary) # Expected output: # { # \'total_orders\': 5, # \'total_revenue\': 1234.56, # \'average_order_value\': 246.91, # \'order_details\': [ # {\'order_id\': \'ABC123\', \'order_total\': 250.00, \'created_at\': \'2023-01-01T12:00:00Z\'}, # {\'order_id\': \'XYZ789\', \'order_total\': 220.00, \'created_at\': \'2023-01-02T14:30:00Z\'}, # ... # ] # } ``` Background: This exercise is meant to test your understanding of: - Interacting with web APIs to fetch and process data. - Aggregating and summarizing data programmatically. - Parsing and handling JSON responses. - Implementing error handling for network requests. **Example of the JSON structure from the e-commerce API for an order**: ```json { \\"order_id\\": \\"ABC123\\", \\"total\\": 250.00, \\"created_at\\": \\"2023-01-01T12:00:00Z\\" } ``` Refer to the [E-commerce API documentation](https://api.example.com/docs/orders) for more details.","solution":"import requests from typing import Any, Dict def aggregate_orders(api_url: str, num_orders: int) -> Dict[str, Any]: try: response = requests.get(f\\"{api_url}?limit={num_orders}\\") response.raise_for_status() orders = response.json() except (requests.RequestException, ValueError): return { \'total_orders\': 0, \'total_revenue\': 0.0, \'average_order_value\': 0.0, \'order_details\': [] } total_orders = len(orders) total_revenue = sum(order[\'total\'] for order in orders) average_order_value = total_revenue / total_orders if total_orders > 0 else 0.0 order_details = [{ \'order_id\': order[\'order_id\'], \'order_total\': order[\'total\'], \'created_at\': order[\'created_at\'] } for order in orders] return { \'total_orders\': total_orders, \'total_revenue\': total_revenue, \'average_order_value\': average_order_value, \'order_details\': order_details }"},{"question":"# Coding Assessment Question You are tasked with writing a Python function to parse a given CSV file, perform a set of transformations, and export the resulting data as a new CSV file. **Function Description:** Write a function `transform_csv(input_file: str, output_file: str, transformation_rules: List[Tuple[str, Callable[[str], str]]]) -> None` that reads a CSV file, applies a set of transformations to specific columns, and then writes the transformed data to a new CSV file. Input: * `input_file` (str): The path to the input CSV file. * `output_file` (str): The path to the output CSV file. * `transformation_rules` (List[Tuple[str, Callable[[str], str]]]): A list of tuples where each tuple contains a column name and a transformation function to apply to that column. Output: * The function does not return anything. It writes the transformed data to the specified `output_file`. Transformation Rules: * The input CSV will have a header row with column names. * Each transformation function will take a single string (cell value) as input and return the transformed string. * Columns that do not have specified transformation rules should remain unchanged in the output. Example: For an input CSV file `data.csv` with the following content: ``` Name, Age, Country Alice, 30, USA Bob, 25, Canada Charlie, 35, UK ``` And the specified transformation rules: ```python transformation_rules = [ (\\"Name\\", lambda x: x.upper()), (\\"Age\\", lambda x: str(int(x) + 1)), (\\"Country\\", lambda x: x.lower()) ] ``` The function should create a new CSV file with the following content: ``` Name, Age, Country ALICE, 31, usa BOB, 26, canada CHARLIE, 36, uk ``` **Constraints:** * You may assume that the input CSV file is well-formed and that each transformation function is valid. * Handle edge cases such as empty columns gracefully. * Use the `csv` module for reading and writing the CSV files. Here\'s the function outline to get you started: ```python import csv from typing import List, Tuple, Callable def transform_csv(input_file: str, output_file: str, transformation_rules: List[Tuple[str, Callable[[str], str]]]) -> None: # Your implementation here pass ```","solution":"import csv from typing import List, Tuple, Callable def transform_csv(input_file: str, output_file: str, transformation_rules: List[Tuple[str, Callable[[str], str]]]) -> None: # Read the input file with open(input_file, mode=\'r\', newline=\'\') as infile: reader = csv.DictReader(infile) data = [row for row in reader] header = reader.fieldnames # Create a map for transformation functions transform_map = {col: func for col, func in transformation_rules} # Apply transformations for row in data: for col, func in transform_map.items(): if col in row: row[col] = func(row[col]) # Write the output file with open(output_file, mode=\'w\', newline=\'\') as outfile: writer = csv.DictWriter(outfile, fieldnames=header) writer.writeheader() writer.writerows(data)"},{"question":"# Reverse Word Order You need to implement a function that takes a sentence (string) and returns a new sentence with the words in reverse order. The function must preserve the original capitalization and punctuation. Background Reversing the word order in a sentence while maintaining the original structure and punctuation can help in understanding string manipulation and word boundary detection. This task involves splitting the sentence into words and rearranging them without altering the individual word content or punctuation. Requirements Implement a function `reverse_words(sentence: str) -> str` that: * Takes a single argument, `sentence`, which is a string. * Returns a string with the words in reverse order. * Handles edge cases, such as empty strings and single-word sentences. * Should not use any imports except those necessary for testing or handling included characters. # Function Signature ```python def reverse_words(sentence: str) -> str: pass ``` # Input - `sentence`: A string (0 <= |sentence| <= 1000) # Output - A string with the words in reverse order, keeping the original punctuation and capitalization. # Constraints - The input string will contain only printable ASCII characters and spaces. - Preserve the original placement of punctuation marks. Example You should include validation through docstring tests: ```python def reverse_words(sentence: str) -> str: Reverses the order of words in a given sentence. >>> reverse_words(\\"\\") \'\' >>> reverse_words(\\"Hello\\") \'Hello\' >>> reverse_words(\\"Hello, world!\\") \'world! Hello,\' >>> reverse_words(\\"Python is cool.\\") \'cool. is Python\' >>> reverse_words(\\"Keep calm and code on.\\") \'on. code and calm Keep\' >>> reverse_words(\\"This is a test sentence.\\") \'sentence. test a is This\' >>> reverse_words(\\"Reverse the words in this sentence, please.\\") \'please. sentence, this in words the Reverse\' >>> reverse_words(123) Traceback (most recent call last): ... TypeError: sentence must be a string if not isinstance(sentence, str): raise TypeError(\\"sentence must be a string\\") words = sentence.split() reversed_words = words[::-1] return \\" \\".join(reversed_words) ``` # Testing In addition to the examples provided, ensure to test edge cases such as: - Highly punctuated sentences. - Sentences with varying whitespace lengths between words. - Performance with longer sentences approaching the 1000 characters limit. This problem assesses the candidate\'s ability to handle string manipulations, respect input constraints, and manage edge cases effectively. By requiring the preservation of punctuation and capitalization, it ensures a deeper understanding of string operations beyond basic reversal.","solution":"def reverse_words(sentence: str) -> str: Reverses the order of words in a given sentence. >>> reverse_words(\\"\\") \'\' >>> reverse_words(\\"Hello\\") \'Hello\' >>> reverse_words(\\"Hello, world!\\") \'world! Hello,\' >>> reverse_words(\\"Python is cool.\\") \'cool. is Python\' >>> reverse_words(\\"Keep calm and code on.\\") \'on. code and calm Keep\' >>> reverse_words(\\"This is a test sentence.\\") \'sentence. test a is This\' >>> reverse_words(\\"Reverse the words in this sentence, please.\\") \'please. sentence, this in words the Reverse\' >>> reverse_words(123) Traceback (most recent call last): ... TypeError: sentence must be a string if not isinstance(sentence, str): raise TypeError(\\"sentence must be a string\\") words = sentence.split() reversed_words = words[::-1] return \\" \\".join(reversed_words)"},{"question":"# Question: Implement a Complex Number Class with Special Operations You are tasked with creating a `ComplexNumber` class that supports essential arithmetic operations as well as handling specific edge cases. Problem Statement Implement a `ComplexNumber` class that can perform addition, subtraction, multiplication, and division of complex numbers. Additionally, ensure that edge cases such as division by zero and operations involving infinity (∞) or NaN are handled gracefully. Requirements 1. **ComplexNumber Class Implementation**: - Define a `ComplexNumber` class that includes real and imaginary parts. - Overload the `__add__`, `__sub__`, `__mul__`, and `__truediv__` methods to handle arithmetic operations. - Ensure that the class can handle cases where the operations might produce infinity (∞) or NaN values. 2. **Edge Case Consideration**: - For division, handle division by zero by returning a ComplexNumber instance with infinity (∞) or NaN as appropriate. - Ensure operations involving infinity or NaN are handled safely and informative results are produced. Input and Output - The `ComplexNumber` class should accept two floats representing the real and imaginary parts of a complex number. - Arithmetic operations should return a new instance of the `ComplexNumber` class. - Implement checks within the arithmetic operations to handle edge cases and return appropriate results. Constraints - Consider cases where the real or imaginary parts are zero. - Avoid changing the original structure of the complex number during operations. - Ensure minimal changes to avoid introducing bugs or significant performance degradation. Testing and Performance - Add test cases to validate normal operations as well as edge cases handling division by zero, and operations with infinity (∞) or NaN. Example ```python class ComplexNumber: def __init__(self, real: float, imaginary: float): self.real = real self.imaginary = imaginary def __add__(self, other): return ComplexNumber(self.real + other.real, self.imaginary + other.imaginary) def __sub__(self, other): return ComplexNumber(self.real - other.real, self.imaginary - other.imaginary) def __mul__(self, other): real_part = self.real * other.real - self.imaginary * other.imaginary imaginary_part = self.real * other.imaginary + self.imaginary * other.real return ComplexNumber(real_part, imaginary_part) def __truediv__(self, other): denominator = other.real ** 2 + other.imaginary ** 2 if denominator == 0: return ComplexNumber(float(\'inf\'), float(\'inf\')) # handle division by zero real_part = (self.real * other.real + self.imaginary * other.imaginary) / denominator imaginary_part = (self.imaginary * other.real - self.real * other.imaginary) / denominator return ComplexNumber(real_part, imaginary_part) def __str__(self): return f\\"({self.real} + {self.imaginary}i)\\" # Example usage: a = ComplexNumber(1, 2) b = ComplexNumber(3, 0) c = ComplexNumber(0, 0) # For testing edge case print(a + b) print(a - b) print(a * b) print(a / b) print(a / c) # Should handle division by zero gracefully ``` Expected Output: ```plaintext (4.0 + 2.0i) (-2.0 + 2.0i) (3.0 + 6.0i) (0.3333333333333333 + 0.6666666666666666i) (inf + infi) # division by zero case ``` Implement the above solution ensuring that complex number arithmetic operates correctly and edge cases are handled gracefully. Validate with appropriate test cases.","solution":"class ComplexNumber: def __init__(self, real: float, imaginary: float): self.real = real self.imaginary = imaginary def __add__(self, other): return ComplexNumber(self.real + other.real, self.imaginary + other.imaginary) def __sub__(self, other): return ComplexNumber(self.real - other.real, self.imaginary - other.imaginary) def __mul__(self, other): real_part = self.real * other.real - self.imaginary * other.imaginary imaginary_part = self.real * other.imaginary + self.imaginary * other.real return ComplexNumber(real_part, imaginary_part) def __truediv__(self, other): denominator = other.real ** 2 + other.imaginary ** 2 if denominator == 0: return ComplexNumber(float(\'inf\'), float(\'inf\')) # handle division by zero real_part = (self.real * other.real + self.imaginary * other.imaginary) / denominator imaginary_part = (self.imaginary * other.real - self.real * other.imaginary) / denominator return ComplexNumber(real_part, imaginary_part) def __str__(self): return f\\"({self.real} + {self.imaginary}i)\\""},{"question":"# Coding Assessment Question You are developing a feature for an application that involves currency conversion between two different currencies. You will be provided the amount to be converted and the exchange rate. Your task is to implement a function that performs this conversion accurately. # Task Write a function `currency_converter` that takes two parameters: - `amount` (float): The amount of money to be converted. - `exchange_rate` (float): The rate at which the currency will be converted. The function should return the equivalent amount in the target currency. Ensure that your function handles edge cases such as zero or negative values for `amount` and `exchange_rate`. Function Signature ```python def currency_converter(amount: float, exchange_rate: float) -> float: ``` Input/Output Formats - The input consists of: - `amount`: A float representing the amount of money in the original currency. - `exchange_rate`: A float representing the conversion rate between the original and target currencies. - The output is: - A float representing the equivalent amount in the target currency after applying the exchange rate. Constraints - -100000.0 ≤ `amount` ≤ 100000.0 - -100.0 ≤ `exchange_rate` ≤ 100.0 Performance Requirements - The calculation must be performed in constant time, O(1). - The function should handle floating-point precision correctly. # Example ```python >>> currency_converter(100, 1.25) 125.0 >>> currency_converter(200, 0.5) 100.0 >>> currency_converter(100, 0) 0.0 >>> currency_converter(0, 1.25) 0.0 >>> currency_converter(-100, 1.25) -125.0 >>> currency_converter(100, -0.5) -50.0 ```","solution":"def currency_converter(amount: float, exchange_rate: float) -> float: Converts the given amount to a different currency using the exchange rate provided. Parameters: amount (float): The amount of money to be converted. exchange_rate (float): The conversion rate between the original and target currencies. Returns: float: The equivalent amount in the target currency. return amount * exchange_rate"},{"question":"Currency Conversion with Real-Time Exchange Rate Retrieval You\'re tasked with creating a Python function to convert an amount of money from one currency to another using real-time exchange rates. The conversion involves the following steps: 1. Fetch the latest exchange rate data from an external API. 2. Extract the required exchange rate from the API response. 3. Perform the currency conversion. 4. Handle any potential errors, such as network issues or invalid currency codes. # Input - A float representing the amount of money to be converted. - A string representing the source currency code (e.g., \\"USD\\"). - A string representing the target currency code (e.g., \\"EUR\\"). # Output - A float representing the converted amount of money. # Constraints - Use the provided function structure but feel free to add additional helper functions or parameters if needed. - Ensure your code handles cases such as invalid currency codes, API errors, and network issues gracefully. - The external API may have a response time of up to 2 seconds. # Example ```python # Example main function def convert_currency(amount, source_currency, target_currency): import requests # Your implementation here return converted_amount # Example usage if __name__ == \\"__main__\\": try: result = convert_currency(100, \\"USD\\", \\"EUR\\") print(f\\"Converted amount: {result} EUR\\") except Exception as e: print(f\\"Failed to convert currency: {e}\\") ``` **Note**: Assume that appropriate external libraries (e.g., requests) are imported, and the user provides valid currency codes in `ISO 4217` format.","solution":"import requests def convert_currency(amount, source_currency, target_currency): Converts an amount from source_currency to target_currency using real-time exchange rates. try: api_key = \\"your_api_key\\" # Replace with your actual API key url = f\\"https://open.er-api.com/v6/latest/{source_currency.upper()}\\" response = requests.get(url) if response.status_code != 200: raise Exception(f\\"Error fetching data from API: {response.status_code}\\") data = response.json() if \\"rates\\" not in data or target_currency.upper() not in data[\\"rates\\"]: raise Exception(f\\"Invalid currency code: {target_currency.upper()}\\") exchange_rate = data[\\"rates\\"][target_currency.upper()] converted_amount = amount * exchange_rate return converted_amount except requests.exceptions.RequestException as e: raise Exception(f\\"Network error: {e}\\") except Exception as e: raise Exception(f\\"Error: {e}\\")"},{"question":"# Matrix Operations and Transformation Task You are tasked with creating a function to perform a series of matrix operations for image processing applications. Specifically, you need to create a function that can rotate a given NxN matrix by 90 degrees clockwise. # Function Signature ```python def rotate_matrix(matrix: list[list[int]]) -> list[list[int]]: Rotates a given NxN matrix by 90 degrees clockwise. Parameters: - matrix (list[list[int]]): A 2D list representing an NxN matrix. Returns: - list[list[int]]: The rotated NxN matrix. ``` # Requirements 1. Create a function that accepts an NxN matrix (square matrix). 2. Rotate the matrix by 90 degrees in a clockwise direction. 3. Return the rotated matrix as the output. # Constraints - The input matrix will always be a valid NxN matrix with 1 ≤ N ≤ 1000. - Handle edge cases such as an empty matrix or single-element matrix appropriately. # Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotated_matrix = rotate_matrix(matrix) print(rotated_matrix) # Expected output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ``` # Additional Guidelines 1. Ensure the function handles large matrices efficiently. 2. Avoid using extra space for the rotated matrix apart from the necessary variables for computation. 3. If any errors or unexpected input is encountered, provide a meaningful error message or handle gracefully within the function. # Tips - Think about indexing and how the elements\' positions are transformed during the rotation. - Consider solving with in-place operations to optimize space complexity.","solution":"def rotate_matrix(matrix: list[list[int]]) -> list[list[int]]: Rotates a given NxN matrix by 90 degrees clockwise. Parameters: - matrix (list[list[int]]): A 2D list representing an NxN matrix. Returns: - list[list[int]]: The rotated NxN matrix. n = len(matrix) # Create a new empty matrix to store the rotated result rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - 1 - i] = matrix[i][j] return rotated"},{"question":"# Data Processing and CSV Handling Challenge **Objective:** Write a Python function `process_csv_data(file_path: str, name_to_update: str, average_grade: float) -> Dict[str, Any]` which reads a CSV file containing student grades, updates the grade for a specific student, and calculates overall statistics. **Input:** * `file_path` - A string representing the path to the CSV file. * `name_to_update` - A string representing the name of a student whose grade needs to be updated. * `average_grade` - A float representing the new average grade for the student. **Output:** * A dictionary containing: * `updated_records` - A list of dictionaries where each dictionary represents a student record. * `class_average` - A float representing the updated average grade for the class. * `highest_grade` - The highest grade in the class after the update. * `lowest_grade` - The lowest grade in the class after the update. **Constraints:** * The CSV file format is assumed to have the following columns: `Name`, `Grade`. * Handle file reading errors gracefully. * If the specified student name does not exist in the file, the function should add a new entry. **Requirements:** 1. Read the CSV file into an appropriate data structure. 2. Update the grade for the specified student. If the student does not exist, add a new record with the given grade. 3. Compute the overall class average, the highest grade, and the lowest grade after the update. 4. Save the updated records back to the CSV file in the same format. 5. Use error handling to ensure the program does not crash due to file read/write errors. **Example Usage:** ```python result = process_csv_data(\'grades.csv\', \'John Doe\', 88.5) print(\\"Updated Records:\\", result[\'updated_records\']) print(\\"Class Average:\\", result[\'class_average\']) print(\\"Highest Grade:\\", result[\'highest_grade\']) print(\\"Lowest Grade:\\", result[\'lowest_grade\']) ``` Expected behavior for an input file \'grades.csv\': ``` Name,Grade Alice,76.0 Bob,85.5 Charlie,92.0 ``` And input `process_csv_data(\'grades.csv\', \'Bob\', 90.0)`, could produce an output: ```python { \'updated_records\': [{\'Name\': \'Alice\', \'Grade\': 76.0}, {\'Name\': \'Bob\', \'Grade\': 90.0}, {\'Name\': \'Charlie\', \'Grade\': 92.0}], \'class_average\': 86.0, \'highest_grade\': 92.0, \'lowest_grade\': 76.0 } ``` Note: Ensure proper handling of edge cases such as empty files, invalid grades, or file access issues.","solution":"import csv from typing import Dict, Any def process_csv_data(file_path: str, name_to_update: str, average_grade: float) -> Dict[str, Any]: try: updated_records = [] student_found = False total_grade = 0 highest_grade = float(\'-inf\') lowest_grade = float(\'inf\') # Read the CSV file with open(file_path, mode=\'r\', newline=\'\') as file: reader = csv.DictReader(file) for row in reader: if row[\'Name\'] == name_to_update: row[\'Grade\'] = average_grade student_found = True grade = float(row[\'Grade\']) total_grade += grade highest_grade = max(highest_grade, grade) lowest_grade = min(lowest_grade, grade) updated_records.append({\'Name\': row[\'Name\'], \'Grade\': grade}) if not student_found: updated_records.append({\'Name\': name_to_update, \'Grade\': average_grade}) total_grade += average_grade highest_grade = max(highest_grade, average_grade) lowest_grade = min(lowest_grade, average_grade) # Calculate the new class average class_size = len(updated_records) class_average = total_grade / class_size # Write the updated records back to the CSV file with open(file_path, mode=\'w\', newline=\'\') as file: fieldnames = [\'Name\', \'Grade\'] writer = csv.DictWriter(file, fieldnames=fieldnames) writer.writeheader() for record in updated_records: writer.writerow(record) return { \'updated_records\': updated_records, \'class_average\': class_average, \'highest_grade\': highest_grade, \'lowest_grade\': lowest_grade } except Exception as e: print(f\\"Error processing the file: {e}\\") return { \'updated_records\': [], \'class_average\': 0.0, \'highest_grade\': 0.0, \'lowest_grade\': 0.0 }"},{"question":"# Evaluate Reverse Polish Notation You are given an expression in Reverse Polish Notation (also known as postfix notation). Your task is to evaluate this expression and return the result. # Function Signature: ```python def evaluate_rpn(expression_list: list) -> int: ``` # Input: * `expression_list` (list): A list of strings where each string is either an operand (digits, possibly negative) or an operator (`+`, `-`, `*`, `/`). # Output: * Returns an integer representing the result of the postfix expression. # Constraints: * The expression is valid and always evaluates to an integer. * Operators `+`, `-`, `*`, and `/` follow integers in the list indicating the operations. * The division operator `/` should truncate towards zero. * There will be no division by zero. * The input list is non-empty. # Example: ```python >>> evaluate_rpn([\\"2\\", \\"1\\", \\"+\\", \\"3\\", \\"*\\"]) 9 >>> evaluate_rpn([\\"4\\", \\"13\\", \\"5\\", \\"/\\", \\"+\\"]) 6 >>> evaluate_rpn([\\"10\\", \\"6\\", \\"9\\", \\"3\\", \\"+\\", \\"-11\\", \\"*\\", \\"/\\", \\"*\\", \\"17\\", \\"+\\", \\"5\\", \\"+\\"]) 22 >>> evaluate_rpn([\\"3\\", \\"4\\", \\"+\\", \\"2\\", \\"*\\", \\"7\\", \\"/\\"]) 2 >>> evaluate_rpn([\\"5\\", \\"1\\", \\"2\\", \\"+\\", \\"4\\", \\"*\\", \\"+\\", \\"3\\", \\"-\\"]) 14 ``` # Note: 1. You should handle invalid elements in the expression by raising a `ValueError` with the message \\"Invalid expression element\\". 2. You should validate that the input provides correct postfix notation and raise a `ValueError` with the message \\"Invalid postfix expression\\" if it does not.","solution":"def evaluate_rpn(expression_list: list) -> int: def is_operator(token): return token in {\\"+\\", \\"-\\", \\"*\\", \\"/\\"} stack = [] for token in expression_list: if token.lstrip(\'-\').isdigit(): # Check if the token is a number (considering negative numbers too) stack.append(int(token)) elif is_operator(token): if len(stack) < 2: raise ValueError(\\"Invalid postfix expression\\") b = stack.pop() a = stack.pop() if token == \'+\': stack.append(a + b) elif token == \'-\': stack.append(a - b) elif token == \'*\': stack.append(a * b) elif token == \'/\': stack.append(int(a / b)) # Truncate towards zero else: raise ValueError(\\"Invalid expression element\\") if len(stack) != 1: raise ValueError(\\"Invalid postfix expression\\") return stack[0]"},{"question":"**Context**: You are developing a financial application that analyzes transaction data to detect potential fraudulent activities. The system should be able to preprocess the data, train a RandomForest Classifier for prediction, and evaluate its performance. **Task**: You are required to implement crucial functions to load data, preprocess it, and train a RandomForest classifier. Your implementation should include: 1. Writing a `load_transaction_data` function to load the dataset, split it into features and targets, and then further split the data into training and testing sets. 2. Implementing a `random_forest_classifier` function to train a RandomForest classifier using the training data. 3. Writing a function called `evaluate_fraud_detector` to compute and display the accuracy score of the model using the testing data. **Function Specifications**: 1. `load_transaction_data(file_path: str, test_size: float) -> tuple` - Loads the transaction dataset from a CSV file located at `file_path`. - Splits the dataset into features and target variables. - Further divides the data into training and testing sets based on `test_size`. - Returns a tuple of four arrays: `(x_train, x_test, y_train, y_test)`. 2. `random_forest_classifier(x_train: np.ndarray, y_train: np.ndarray) -> RandomForestClassifier` - Trains a RandomForest Classifier with the provided training data. - Returns the trained classifier. 3. `evaluate_fraud_detector(classifier: RandomForestClassifier, x_test: np.ndarray, y_test: np.ndarray) -> None` - Calculates and prints the accuracy score of the given classifier using the testing data. **Constraints**: - Utilize `pandas` for data loading and manipulation. - Use `sklearn`\'s `train_test_split` for splitting the dataset. **Example**: ```python import pandas as pd import numpy as np from sklearn.model_selection import train_test_split from sklearn.ensemble import RandomForestClassifier from sklearn.metrics import accuracy_score def load_transaction_data(file_path: str, test_size: float) -> tuple: data = pd.read_csv(file_path) x = data.drop(\'target\', axis=1) y = data[\'target\'] x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=test_size, random_state=42) return x_train, x_test, y_train, y_test def random_forest_classifier(x_train: np.ndarray, y_train: np.ndarray) -> RandomForestClassifier: classifier = RandomForestClassifier(n_estimators=100, random_state=42) classifier.fit(x_train, y_train) return classifier def evaluate_fraud_detector(classifier: RandomForestClassifier, x_test: np.ndarray, y_test: np.ndarray) -> None: y_pred = classifier.predict(x_test) accuracy = accuracy_score(y_test, y_pred) print(f\'Accuracy: {accuracy}\') def main(): x_train, x_test, y_train, y_test = load_transaction_data(\'transactions.csv\', test_size=0.25) model = random_forest_classifier(x_train, y_train) evaluate_fraud_detector(model, x_test, y_test) if __name__ == \\"__main__\\": main() ```","solution":"import pandas as pd import numpy as np from sklearn.model_selection import train_test_split from sklearn.ensemble import RandomForestClassifier from sklearn.metrics import accuracy_score def load_transaction_data(file_path: str, test_size: float) -> tuple: Load the transaction dataset, split it into features and targets, then further split into training and testing sets. data = pd.read_csv(file_path) x = data.drop(\'target\', axis=1) y = data[\'target\'] x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=test_size, random_state=42) return x_train, x_test, y_train, y_test def random_forest_classifier(x_train: np.ndarray, y_train: np.ndarray) -> RandomForestClassifier: Train a RandomForest Classifier using the training data. classifier = RandomForestClassifier(n_estimators=100, random_state=42) classifier.fit(x_train, y_train) return classifier def evaluate_fraud_detector(classifier: RandomForestClassifier, x_test: np.ndarray, y_test: np.ndarray) -> None: Calculate and display the accuracy score of the classifier using the testing data. y_pred = classifier.predict(x_test) accuracy = accuracy_score(y_test, y_pred) print(f\'Accuracy: {accuracy}\')"},{"question":"# Unique Email Addresses Implement a function that takes a list of email addresses and returns the number of unique email addresses. A unique email is considered by applying the following transformation rules: * Local names (the part before the \'@\' symbol) may include dots `\'.\'`, which should be ignored. * Local names may also contain a plus `\'+\'` character, which means everything after the plus (up to the \'@\') should be ignored. * The domain name (the part after the \'@\' symbol) should not be altered in any way. Your function should account for these rules to count unique email addresses correctly. # Function Signature ```python def num_unique_emails(emails: list[str]) -> int: pass ``` Input: * `emails` (List[str]): A list of email addresses. Output: * An integer representing the number of unique email addresses. # Example: ```python emails = [ \\"test.email+alex@leetcode.com\\", \\"test.e.mail+bob.cathy@leetcode.com\\", \\"testemail+david@lee.tcode.com\\" ] assert num_unique_emails(emails) == 2 emails = [ \\"a@leetcode.com\\", \\"b@leetcode.com\\", \\"c@leetcode.com\\" ] assert num_unique_emails(emails) == 3 ``` # Constraints: * `1 <= len(emails) <= 100` * Each email is guaranteed to be a valid email as per the defined transformation rules and well-formedness of email addresses. * Length of each email is between `1` and `100`.","solution":"def num_unique_emails(emails: list[str]) -> int: unique_emails = set() for email in emails: local, domain = email.split(\'@\') local = local.split(\'+\')[0] # Remove everything after \'+\' local = local.replace(\'.\', \'\') # Remove all dots normalized_email = f\\"{local}@{domain}\\" unique_emails.add(normalized_email) return len(unique_emails)"},{"question":"# Subject: String Manipulation and Pattern Matching You are given a task to write a function that finds the shortest palindrome greater than the given string when treated as a numerical value. # Description A palindrome is a string that reads the same forward and backward. For a given string `s` composed of digits, your task is to find the shortest palindrome that is numerically greater than `s`. # Implementation Function 1. **`shortest_greater_palindrome(s: str) -> str`**: - **Input**: A string `s` (where `1 leq len(s) leq 1000` and `s` is composed of digits only). - **Output**: Returns the shortest palindrome that is numerically greater than `s`. # Function Definition ```python def shortest_greater_palindrome(s: str) -> str: Find the shortest numerically greater palindrome for the given string s. Args: s (str): The input numeric string. Returns: str: The shortest palindrome greater than the input string. pass ``` # Requirements - Do not use any external libraries except for `math`. - Ensure your code handles large inputs efficiently. - Consider edge cases, such as strings with all identical digits, or palindromic strings themselves. # Examples ```python # Example 1 print(shortest_greater_palindrome(\\"12321\\")) # Should return \\"12421\\" # Example 2 print(shortest_greater_palindrome(\\"999\\")) # Should return \\"1001\\" # Example 3 print(shortest_greater_palindrome(\\"1\\")) # Should return \\"2\\" ``` Ensure your code passes these tests and handle edge cases thoroughly (e.g., converting \\"999\\" to \\"1001\\"). # Constraints - Your solution should aim for clarity and efficiency, making sure it runs within a reasonable time for input length up to 1000 characters.","solution":"def shortest_greater_palindrome(s: str) -> str: Find the shortest numerically greater palindrome for the given string s. Args: s (str): The input numeric string. Returns: str: The shortest palindrome greater than the input string. length = len(s) if s == \'9\' * length: return \'1\' + \'0\' * (length - 1) + \'1\' def is_palindrome(k: str) -> bool: return k == k[::-1] def make_palindrome(k: str) -> str: half = k[:(len(k) + 1) // 2] return half + half[::-1][len(k) & 1:] if is_palindrome(s): mid = (length - 1) // 2 left_half = s[:mid + 1] new_left_half = str(int(left_half) + 1) palindrome = new_left_half + new_left_half[::-1][length & 1:] return palindrome original_pal = make_palindrome(s) if original_pal > s: return original_pal mid = (length - 1) // 2 left_half = s[:mid + 1] new_left_half = str(int(left_half) + 1) palindrome = new_left_half + new_left_half[::-1][length & 1:] return palindrome"},{"question":"# Unique Elements Finder Your task is to develop a function that identifies unique elements in an array, calculates their sum, and provides details on both the sum and the unique elements. Problem Statement Implement a function `unique_elements_summary(arr: List[int]) -> Tuple[int, List[int]]` that takes a list of integers and returns a tuple. The first element of the tuple is the sum of all unique elements in the list, and the second element is the list of unique elements sorted in ascending order. # Input * `arr` (List of integers): An array containing between `0` and `10^4` integers. Each integer will be between `-10^6` and `10^6`. # Output * A tuple where: - The first element is an integer representing the sum of all unique integers in the array. - The second element is a list of unique integers sorted in ascending order. # Constraints * The input list can be empty, in which case the function should return `(0, [])`. # Function Signature ```python from typing import List, Tuple def unique_elements_summary(arr: List[int]) -> Tuple[int, List[int]]: pass ``` # Examples ```python >>> unique_elements_summary([1, 2, 2, 3, 4, 4, 5]) (15, [1, 2, 3, 4, 5]) >>> unique_elements_summary([10, 10, 10, 10]) (10, [10]) >>> unique_elements_summary([3, 5, 7, 7, 7, -3]) (12, [-3, 3, 5, 7]) >>> unique_elements_summary([]) (0, []) >>> unique_elements_summary([1]) (1, [1]) ``` # Instructions - Use appropriate data structures to ensure that the solution is efficient. - Consider edge cases such as an empty list or a list with all identical elements. - Ensure the returned list of unique elements is sorted in ascending order. - Write clean and well-documented code to maintain readability and efficiency. This question tests the ability to work with data structures, handle sorting, and efficiently compute results from a given list of integers.","solution":"from typing import List, Tuple def unique_elements_summary(arr: List[int]) -> Tuple[int, List[int]]: unique_elements = set(arr) sorted_unique_elements = sorted(unique_elements) sum_unique_elements = sum(sorted_unique_elements) return sum_unique_elements, sorted_unique_elements"},{"question":"# Sorting List of Tuples by Second Element Problem Description Write a function named `sort_by_second` that takes a list of tuples and returns it sorted in ascending order based on the second element of each tuple. If two tuples have the same second element, they should be ordered based on their first element. For example: - `sort_by_second([(3, 1), (1, 2), (4, 1)])` should return `[(3, 1), (4, 1), (1, 2)]` - `sort_by_second([(\\"b\\", 3), (\\"a\\", 3), (\\"c\\", 1)])` should return `[(\'c\', 1), (\'a\', 3), (\'b\', 3)]` Function Signature ```python def sort_by_second(tuples: list) -> list: pass ``` Input - `tuples`: A list containing tuples. Each tuple will be of two elements. The first element can be any comparable data type, and the second element will be integer. Output - A list of tuples sorted based on the criteria described above. Constraints - The list will not be empty and will contain at least one element. - The tuples can contain any data type that is comparable. - Consider edge cases where tuples have the same second element. Examples ```python >>> sort_by_second([(3, 1), (1, 2), (4, 1)]) [(3, 1), (4, 1), (1, 2)] >>> sort_by_second([(\\"b\\", 3), (\\"a\\", 3), (\\"c\\", 1)]) [(\'c\', 1), (\'a\', 3), (\'b\', 3)] >>> sort_by_second([(10, 15), (1, 1), (2, 2)]) [(1, 1), (2, 2), (10, 15)] >>> sort_by_second([(\\"apple\\", 2), (\\"orange\\", 2), (\\"banana\\", 1)]) [(\'banana\', 1), (\'apple\', 2), (\'orange\', 2)] ``` Edge Cases to Consider - Lists containing tuples with the same second element to ensure stability. - Mixed data types in the first element of the tuples. Performance Requirements - Sorting should be efficient and handle lists containing multiple elements.","solution":"def sort_by_second(tuples: list) -> list: Sorts a list of tuples based on the second element of each tuple. If two tuples have the same second element, they are ordered based on their first element. return sorted(tuples, key=lambda x: (x[1], x[0]))"},{"question":"You need to implement a function `count_occurrences` that reads a text file and returns a dictionary with the frequency of each word in the file. The function should handle different cases of words, punctuation, and common errors such as file not found or unreadable file. Objective Implement the function `count_occurrences` to: 1. Read the contents of a file efficiently. 2. Normalize and clean the text to ensure words are counted accurately. 3. Handle and report errors like missing files or unreadable contents gracefully. Requirements - **Input**: - `filepath`: A string representing the path to the text file. - **Output**: - A dictionary with words as keys and their respective counts as values. - **Constraints**: - The function should be case-insensitive. - Punctuation should be ignored in word counting. - The function should handle large files efficiently. - Ensure words are separated correctly, taking whitespace variations into account. Performance Requirements - Efficiently process large files without excessive memory usage. - Use appropriate data structures to manage word counting. Edge Cases & Error Handling - Gracefully handle scenarios where the file does not exist or is unreadable. - Correctly handle empty files or files with only punctuation marks. - Manage discrepancies in word delimiters, like multiple spaces or newline characters. # Scenario You are developing a text analysis tool that processes large textual data files, cleans them, and provides a summary of word frequencies. This tool needs to be robust, efficient, and accurate in its reporting. Function Signature ```python def count_occurrences(filepath: str) -> dict: # Your implementation here ``` Example Consider the file `text.txt` with contents: ``` Hello, world! Hello. This is a test. This is only a test. ``` ```python count_occurrences(\\"text.txt\\") ``` Expected output: ```python { \\"hello\\": 2, \\"world\\": 1, \\"this\\": 2, \\"is\\": 2, \\"a\\": 2, \\"test\\": 2, \\"only\\": 1 } ``` The function should read the file, process the text, and return a frequency dictionary reflecting the normalized word counts.","solution":"import re import os def count_occurrences(filepath: str) -> dict: Reads a text file and returns a dictionary with the frequency of each word in the file. It handles different cases, punctuation, and common file errors. if not os.path.isfile(filepath): raise FileNotFoundError(f\\"The file {filepath} does not exist.\\") word_count = {} try: with open(filepath, \'r\', encoding=\'utf-8\') as file: for line in file: words = re.findall(r\'bw+b\', line.lower()) for word in words: word_count[word] = word_count.get(word, 0) + 1 except Exception as e: raise IOError(f\\"Unable to read the file {filepath}. Error: {str(e)}\\") return word_count"},{"question":"# Coding Assessment Question: You are given a string consisting of lowercase English letters and spaces. Your task is to write a function `reverse_words(s)` that takes a string `s` and returns a new string with the words in reverse order, while preserving the original order of characters within each word. Input: * A string `s` (1 ≤ len(s) ≤ 10^5) composed of lowercase English letters and spaces. Output: * A new string with the words in reverse order. Example: ```python assert reverse_words(\\"the sky is blue\\") == \\"blue is sky the\\" assert reverse_words(\\"hello world\\") == \\"world hello\\" assert reverse_words(\\"a b c d\\") == \\"d c b a\\" assert reverse_words(\\"single_word\\") == \\"single_word\\" assert reverse_words(\\"\\") == \\"\\" assert reverse_words(\\"a\\") == \\"a\\" ``` Your function will be evaluated on the following: * Correctness in reversing the order of words. * Proper handling of edge cases such as empty strings and single-word strings. * Efficiency in processing the string within the given constraints. **Constraints**: * Do not use in-built string-reversing functions. * Ensure your implementation handles multiple consecutive spaces correctly. **Performance Requirement**: Ensure your implementation can efficiently process strings at the upper limit of the input size within an acceptable runtime.","solution":"def reverse_words(s): Returns a new string with the words in reverse order, while preserving the original order of characters within each word. words = s.split() reversed_words = words[::-1] return \' \'.join(reversed_words)"},{"question":"# Array Triplet Sum Challenge Objective: Implement a function that determines if there exist three numbers in a given list such that their sum equals a specified target value. Instructions: 1. Implement the function `find_triplet_sum(arr: List[int], target: int) -> bool` to check if there are three numbers in the list that add up to `target`. 2. You may assume that each input would have at most one such triplet. 3. Optimize your solution so that it runs efficiently for large input sizes. Input: * `arr` - A list of integers. - Constraints: * `1 <= len(arr) <= 10^5` * `-10^9 <= arr[i] <= 10^9` * `target` - An integer representing the target sum. - Constraints: * `-10^9 <= target <= 10^9` Output: * Return `True` if there is a triplet `(arr[i], arr[j], arr[k])` such that `arr[i] + arr[j] + arr[k] = target`. Otherwise, return `False`. Example: ```python assert find_triplet_sum([12, 3, 4, 1, 6, 9], 24) == True assert find_triplet_sum([-1, 0, 1, 2, -1, -4], 0) == True assert find_triplet_sum([1, 2, 3, 4, 5], 50) == False ``` Additional Notes: 1. The function should consider using sorting and a two-pointer technique for optimal performance. 2. Consider edge cases such as: * The array having fewer than three elements. * Positive, negative, and zero values within the array. * The array containing duplicate numbers and ensuring a unique triplet is found or not. Good luck and happy coding!","solution":"from typing import List def find_triplet_sum(arr: List[int], target: int) -> bool: Check if there exist three numbers in the list such that their sum equals the target value. Parameters: arr (List[int]): List of integers. target (int): Target sum value. Returns: bool: True if such a triplet exists, otherwise False. arr.sort() # Sort the array for the two-pointer approach n = len(arr) for i in range(n - 2): if i > 0 and arr[i] == arr[i - 1]: continue # Skip duplicate elements to avoid redundant triplets left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"# Git Merge Conflict Resolution You are a software engineer responsible for maintaining a project that utilizes Git for version control. During a feature development, a merge conflict occurs and you are required to resolve it. **Task**: Implement a function to automate the resolution of a simple merge conflict in a textual file. Your function will take the content of the file with conflict markers and resolve it based on certain rules. **Rules**: 1. If both sections between `<<<<<<<` and `=======` and `=======` and `>>>>>>>` are identical, keep either of them. 2. If the sections are different, concatenate them with a newline separator in between. **Task**: Implement the function: 1. **resolve_merge_conflict(content: str) -> str**: - **Input**: `content` (str) - A string representing the content of the file with merge conflict markers. - **Output**: Resolved content (str) with all conflicts resolved based on the described rules. # Constraints: - The conflict markers will be in a valid format with no nested conflicts. - The input content will not exceed 1000 lines. **Examples**: ```python >>> content = \'\'\'This is some text. <<<<<<< HEAD This is from master branch. ======= This is from feature branch. >>>>>>> feature-branch This is more text.\'\'\' >>> resolve_merge_conflict(content) \'This is some text. This is from master branch. This is from feature branch. This is more text.\' >>> content = \'\'\'This is some common text. <<<<<<< HEAD Common text. ======= Common text. >>>>>>> feature-branch\'\'\' >>> resolve_merge_conflict(content) \'This is some common text. Common text.\' ```","solution":"def resolve_merge_conflict(content: str) -> str: lines = content.split(\'n\') resolved_lines = [] inside_conflict = False section_1 = [] section_2 = [] for line in lines: if line.startswith(\\"<<<<<<<\\"): inside_conflict = True section_1 = [] section_2 = [] elif line.startswith(\\"=======\\"): inside_conflict = \'section_2\' elif line.startswith(\\">>>>>>>\\"): inside_conflict = False if section_1 == section_2: resolved_lines.extend(section_1) else: resolved_lines.extend(section_1) resolved_lines.append(\'\') resolved_lines.extend(section_2) elif inside_conflict == True: section_1.append(line) elif inside_conflict == \'section_2\': section_2.append(line) else: resolved_lines.append(line) return \'n\'.join(resolved_lines)"},{"question":"# Coding Assessment Question **Context**: You have been provided with a system that needs to handle user log data efficiently. Your task is to implement a function to analyze this log data and identify the top K most active users within a specified time range. **Objective**: Implement a function `top_k_active_users` that identifies the top K most active users based on the number of log entries within a given time range from a list of log entries. Each log entry contains a timestamp and user ID. **Function Signature**: ```python def top_k_active_users(logs: list, start_time: str, end_time: str, k: int) -> list: Parameters: - logs: list, List containing user log data where each log entry is a tuple (timestamp, user_id). Timestamp is a string in the format \'YYYY-MM-DD HH:MM:SS\'. - start_time: str, Start time of the range in the format \'YYYY-MM-DD HH:MM:SS\'. - end_time: str, End time of the range in the format \'YYYY-MM-DD HH:MM:SS\'. - k: int, Number of top active users to return. Returns: - list: List of user IDs of the top K most active users sorted by their activity count in descending order. ``` **Input**: * `logs`: A list of tuples where each tuple contains: ```python logs = [(\'2023-01-01 12:00:00\', \'user1\'), (\'2023-01-01 12:05:00\', \'user2\'), (\'2023-01-02 14:00:00\', \'user1\'), (\'2023-01-03 16:00:00\', \'user3\')] ``` * `start_time`: A string representing the start time of the log interval. * `end_time`: A string representing the end time of the log interval. * `k`: An integer denoting the number of top active users to return. **Output**: * Returns a list of user IDs of the top K most active users sorted by their activity count in descending order. **Constraints**: * If two users have the same activity count, their order in the resulting list should be the same as their first appearance in the logs list. * Use the standard library and focus on time and space complexity. **Additional Information**: You may assume all timestamps are in the same timezone and correctly formatted. **Example**: ```python import datetime from collections import defaultdict, Counter def top_k_active_users(logs: list, start_time: str, end_time: str, k: int) -> list: start_dt = datetime.datetime.strptime(start_time, \\"%Y-%m-%d %H:%M:%S\\") end_dt = datetime.datetime.strptime(end_time, \\"%Y-%m-%d %H:%M:%S\\") user_activity_count = Counter() for log in logs: timestamp, user_id = log log_dt = datetime.datetime.strptime(timestamp, \\"%Y-%m-%d %H:%M:%S\\") if start_dt <= log_dt <= end_dt: user_activity_count[user_id] += 1 most_active_users = user_activity_count.most_common(k) return [user for user, _ in most_active_users] # Example Usage logs = [ (\'2023-01-01 12:00:00\', \'user1\'), (\'2023-01-01 12:05:00\', \'user2\'), (\'2023-01-02 14:00:00\', \'user1\'), (\'2023-01-03 16:00:00\', \'user3\'), (\'2023-01-03 16:30:00\', \'user2\'), (\'2023-01-02 10:00:00\', \'user1\'), (\'2023-01-03 18:00:00\', \'user2\') ] start_time = \'2023-01-01 00:00:00\' end_time = \'2023-01-03 23:59:59\' k = 2 print(top_k_active_users(logs, start_time, end_time, k)) ``` **Note**: You may test the function with different data sets and time ranges to validate the accuracy of the results.","solution":"from collections import Counter import datetime def top_k_active_users(logs, start_time, end_time, k): Identifies the top K most active users based on the number of log entries within a given time range. start_dt = datetime.datetime.strptime(start_time, \\"%Y-%m-%d %H:%M:%S\\") end_dt = datetime.datetime.strptime(end_time, \\"%Y-%m-%d %H:%M:%S\\") user_activity_count = Counter() for log in logs: timestamp, user_id = log log_dt = datetime.datetime.strptime(timestamp, \\"%Y-%m-%d %H:%M:%S\\") if start_dt <= log_dt <= end_dt: user_activity_count[user_id] += 1 most_active_users = user_activity_count.most_common(k) return [user for user, _ in most_active_users]"},{"question":"# Question: Calculate Loan Payment Schedules You are asked to write two functions to calculate loan payment schedules: fixed monthly payments for a fixed rate loan, and monthly interest payments for an interest-only loan. Each function needs to handle various input validations and return the monthly payments computed according to financial principles. Function 1: `fixed_monthly_payment(principal: float, annual_interest_rate: float, loan_term_years: int) -> float` **Calculate the fixed monthly payment for a fixed-rate loan.** - **Input**: - `principal` (float): The amount borrowed for the loan. - `annual_interest_rate` (float): The annual interest rate. - `loan_term_years` (int): The term of the loan in years. - **Output**: - `float`: The amount of the fixed monthly payment. - **Constraints**: - `principal` must be greater than 0. - `annual_interest_rate` must be non-negative. - `loan_term_years` must be a positive integer. Function 2: `monthly_interest_payment(principal: float, annual_interest_rate: float) -> float` **Calculate the monthly interest payment for an interest-only loan.** - **Input**: - `principal` (float): The amount borrowed for the loan. - `annual_interest_rate` (float): The annual interest rate. - **Output**: - `float`: The amount of the monthly interest payment. - **Constraints**: - `principal` must be greater than 0. - `annual_interest_rate` must be non-negative. # Testing & Validation - Include checks for invalid inputs like negative values for principal and interest rates. - Ensure `loan_term_years` is a positive integer. - Use various test cases to validate the correctness of your implementation.","solution":"def fixed_monthly_payment(principal, annual_interest_rate, loan_term_years): Calculate the fixed monthly payment for a fixed-rate loan. Parameters: - principal: float, the amount borrowed for the loan (must be greater than 0) - annual_interest_rate: float, the annual interest rate (must be non-negative) - loan_term_years: int, the term of the loan in years (must be a positive integer) Returns: - float: the amount of the fixed monthly payment if principal <= 0: raise ValueError(\\"Principal must be greater than 0.\\") if annual_interest_rate < 0: raise ValueError(\\"Annual interest rate must be non-negative.\\") if loan_term_years <= 0: raise ValueError(\\"Loan term years must be a positive integer.\\") monthly_interest_rate = annual_interest_rate / 12 / 100 number_of_payments = loan_term_years * 12 if monthly_interest_rate == 0: return principal / number_of_payments monthly_payment = (principal * monthly_interest_rate) / (1 - (1 + monthly_interest_rate) ** -number_of_payments) return monthly_payment def monthly_interest_payment(principal, annual_interest_rate): Calculate the monthly interest payment for an interest-only loan. Parameters: - principal: float, the amount borrowed for the loan (must be greater than 0) - annual_interest_rate: float, the annual interest rate (must be non-negative) Returns: - float: the amount of the monthly interest payment if principal <= 0: raise ValueError(\\"Principal must be greater than 0.\\") if annual_interest_rate < 0: raise ValueError(\\"Annual interest rate must be non-negative.\\") monthly_interest_rate = annual_interest_rate / 12 / 100 return principal * monthly_interest_rate"},{"question":"# Problem Statement You are tasked with implementing a function that identifies all the distinct subsets of a given list of unique integers. This should include the empty subset and subsets of all sizes up to the full set. The function should ensure that no subset is repeated and the subsets are returned in lexicographically sorted order based on their constituent elements. # Function Signature ```python def generate_subsets(nums: List[int]) -> List[List[int]]: pass ``` # Input * `nums`: A list of `n` unique integers, where (0 leq n leq 10). # Output * A list of lists, each containing one subset of the input list `nums`. # Constraints * The function should correctly handle edge cases where the list is empty. * The function should not use any libraries for generating subsets such as `itertools.combinations`. * The function should create subsets in lexicographic order based on the values in the input list. # Example ```python >>> generate_subsets([]) [[]] >>> generate_subsets([1]) [[], [1]] >>> generate_subsets([1, 2]) [[], [1], [1, 2], [2]] >>> generate_subsets([1, 2, 3]) [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]] ``` # Additional Information The solution should build subsets by considering each element decision (include or exclude) step-by-step to construct all possible subsets, and then sort and return them in a lexicographical order. Sorting and subset generation efficiency will be considered in the evaluation.","solution":"from typing import List def generate_subsets(nums: List[int]) -> List[List[int]]: Returns all subsets of the list nums in lexicographical order. # Sort the input for lexicographical order nums.sort() result = [] def backtrack(start: int, path: List[int]): # Append the current subset (path) to the result result.append(path.copy()) for i in range(start, len(nums)): path.append(nums[i]) backtrack(i + 1, path) path.pop() # Initiate the backtracking process backtrack(0, []) return result"},{"question":"# Coding Question Your task is to implement a function that simulates a simplified version of a case-sensitive spell checker. The spell checker will suggest corrections for a given word based on a dictionary of valid words. If the word is a valid dictionary word, the function should return the word itself. Otherwise, it should return the closest matching word from the dictionary in terms of the minimum number of character insertions, deletions, and substitutions needed (Levenshtein distance). Function Signature ```python def spell_checker(word: str, dictionary: list[str]) -> str: pass ``` Input - `word` (str): The word to be checked. - `dictionary` (list[str]): A list of valid words. Output - Returns a str, the corrected word from the dictionary if the `word` was incorrect, or the word itself if it was correct. Constraints - All inputs are non-empty. - The dictionary contains at least one word. - The Levenshtein distance calculation should be case-sensitive. - If multiple words have the same minimum distance to the input word, return the one which appears first in the dictionary. Helper Function 1. **Levenshtein Distance** ```python def levenshtein_distance(word1: str, word2: str) -> int: pass ``` Example ```python dictionary = [\\"example\\", \\"spelling\\", \\"checker\\", \\"examples\\", \\"exemplar\\"] word = \\"exampl\\" # Expected Output # The word \\"exampl\\" is not in the dictionary. # The closest word by Levenshtein distance is \\"example\\" (with a distance of 1). print(spell_checker(word, dictionary)) # Output: \\"example\\" ``` Implement the `spell_checker` function along with the `levenshtein_distance` helper function to suggest corrections for misspelled words.","solution":"def levenshtein_distance(word1: str, word2: str) -> int: Helper function to calculate the Levenshtein distance between two words. if len(word1) < len(word2): return levenshtein_distance(word2, word1) # len(word1) >= len(word2) previous_row = range(len(word2) + 1) for i, c1 in enumerate(word1): current_row = [i + 1] for j, c2 in enumerate(word2): insertions = previous_row[j + 1] + 1 deletions = current_row[j] + 1 substitutions = previous_row[j] + (c1 != c2) current_row.append(min(insertions, deletions, substitutions)) previous_row = current_row return previous_row[-1] def spell_checker(word: str, dictionary: list[str]) -> str: Returns the closest word from the dictionary in terms of Levenshtein distance if the input word is not valid. If the word is a valid dictionary word, returns the word itself. if word in dictionary: return word min_distance = float(\'inf\') suggested_word = word for dict_word in dictionary: distance = levenshtein_distance(word, dict_word) if distance < min_distance: min_distance = distance suggested_word = dict_word return suggested_word # Example usage dictionary = [\\"example\\", \\"spelling\\", \\"checker\\", \\"examples\\", \\"exemplar\\"] word = \\"exampl\\" print(spell_checker(word, dictionary)) # Output: \\"example\\""},{"question":"# Hash Map Analysis and Optimization **Objective**: Evaluate a student\'s knowledge on hash maps and their ability to identify optimization opportunities in a data structure. **Task**: Write a Python function `analyze_and_optimize_hash_map` that takes a dictionary (hash map) as input and returns a new dictionary that contains the same key-value pairs but optimized by eliminating redundant keys holding the same values, retaining only the first occurrence of each distinct value. **Function Signature**: ```python def analyze_and_optimize_hash_map( hash_map: Dict[str, int] ) -> Dict[str, int]: Parameters: - hash_map (Dict[str, int]): A dictionary where keys are strings and values are integers. Returns: - Dict[str, int]: A new dictionary with redundant keys removed, retaining only the first occurrence of each distinct value. ``` **Input**: - A dictionary `hash_map` with string keys and integer values. **Output**: - A new dictionary with only the first occurrence of each value, discarding subsequent duplicate values. **Example**: ```python hash_map = { \'a\': 1, \'b\': 2, \'c\': 1, \'d\': 3, \'e\': 2 } analyze_and_optimize_hash_map(hash_map) # Expected Output: # {\'a\': 1, \'b\': 2, \'d\': 3} ``` **Constraints**: - The input dictionary will have at most 10^4 key-value pairs. - Maintain the order of keys as they appear in the input dictionary. **Notes**: - The solution must handle cases where multiple keys have the same value in an efficient manner. - The implementation should avoid using additional libraries other than the standard Python library. **Testing**: - Include unit tests to validate your function with dictionaries of various sizes and configurations, including edge cases like empty dictionaries or dictionaries where all values are the same.","solution":"from typing import Dict def analyze_and_optimize_hash_map(hash_map: Dict[str, int]) -> Dict[str, int]: Parameters: - hash_map (Dict[str, int]): A dictionary where keys are strings and values are integers. Returns: - Dict[str, int]: A new dictionary with redundant keys removed, retaining only the first occurrence of each distinct value. seen_values = set() optimized_hash_map = {} for key, value in hash_map.items(): if value not in seen_values: optimized_hash_map[key] = value seen_values.add(value) return optimized_hash_map"},{"question":"# Problem Statement To demonstrate your expertise in string manipulation and validation, you will implement a function that checks whether a given string can become a palindrome through the rearrangement of its characters while considering case insensitivity and ignoring non-alphanumeric characters. # Palindrome Permutation Checker # Objective: Implement a function `can_form_palindrome(s: str) -> bool` that determines if any permutation of the characters in the input string can form a palindrome. # Requirements: 1. **Input**: * A string `s` with length `n (0 <= n <= 10^5)`. 2. **Output**: * A boolean `True` if any permutation of the characters in `s` can form a palindrome; otherwise, `False`. 3. **Constraints**: * The function should run in O(n) time complexity. * Only consider alphanumeric characters and treat them case insensitively. 4. **Edge cases**: * Handle empty strings and strings with a single character. * Ensure the function does not error out for valid inputs. # Function Signature: ```python def can_form_palindrome(s: str) -> bool: pass ``` # Example: ```python # Example 1: s = \\"Tact Coa\\" # Output: True # Explanation: Permutations \\"tacocat\\", \\"atcocta\\", etc. are palindromes. # Example 2: s = \\"A man, a plan, a canal, Panama\\" # Output: True # Explanation: When ignoring non-alphanumeric characters and case, the permutations are palindromes. # Example 3: s = \\"race a car\\" # Output: False # Example 4: s = \\"a\\" # Output: True # Example 5: s = \\"\\" # Output: True ``` # Notes: 1. Your function should work efficiently for strings up to the maximum constraint size. 2. Remember to ignore spaces and any non-alphanumeric characters. 3. Consider all letters in a case-insensitive manner while checking for palindrome permutations.","solution":"def can_form_palindrome(s: str) -> bool: Determines if any permutation of the input string can form a palindrome. Parameters: s (str): Input string Returns: bool: True if any permutation of the characters in the input string can form a palindrome, False otherwise. from collections import Counter # Normalize the string: convert to lowercase and filter out non-alphanumeric characters normalized_str = \'\'.join(char.lower() for char in s if char.isalnum()) # Count the frequency of each character char_count = Counter(normalized_str) # Count characters with odd frequencies odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # For the string to be able to form a palindrome, it can have at most one odd count character return odd_count <= 1"},{"question":"# Find the Diameter of a Binary Tree You are given a binary tree where each node contains an integer data value. The diameter of a binary tree is the length of the longest path between any two nodes in the tree. This path may or may not pass through the root. The length of a path between two nodes is represented by the number of edges between them. Your task is to write a function that calculates the diameter of a given binary tree. Implement the following functions: - `diameterOfBinaryTree(root: TreeNode) -> int`: This function takes the root of a binary tree and returns its diameter. - `build_tree() -> TreeNode`: (Provided) Builds and returns a sample binary tree. # Example: Given the binary tree: ``` 1 / 2 3 / 4 5 ``` The longest path in this binary tree is `[4, 2, 1, 3]` or `[5, 2, 1, 3]`, which has a length of 3. Return the diameter: `3`. Function Signature: ```python def diameterOfBinaryTree(root: TreeNode) -> int: pass ``` Constraints: * The number of nodes in the tree is in the range [0, 1000]. * -100 <= Node.data <= 100 # Implementation Details: 1. The diameter of the tree is the number of edges in the longest path between any two nodes. 2. Write any necessary helper functions within the same file. 3. Attempt to solve the problem with optimal time complexity. # Example Usage: Provided function `build_tree` can be used to test your implementation: ```python root = build_tree() print(diameterOfBinaryTree(root)) # Output should be: 3 ```","solution":"class TreeNode: def __init__(self, data=0, left=None, right=None): self.data = data self.left = left self.right = right def diameterOfBinaryTree(root: TreeNode) -> int: Returns the diameter of a binary tree. def height_and_diameter(node): if not node: return 0, 0 left_height, left_diameter = height_and_diameter(node.left) right_height, right_diameter = height_and_diameter(node.right) # The \\"height\\" is the max height at the current node. current_height = max(left_height, right_height) + 1 # The diameter is the maximum value found in either left/right subtree diameter # or the current diameter passing through this node. current_diameter = max(left_diameter, right_diameter, left_height + right_height) return current_height, current_diameter _, diameter = height_and_diameter(root) return diameter # Example function to build a tree for testing def build_tree() -> TreeNode: # Building a sample tree: # 1 # / # 2 3 # / # 4 5 node4 = TreeNode(4) node5 = TreeNode(5) node2 = TreeNode(2, left=node4, right=node5) node3 = TreeNode(3) root = TreeNode(1, left=node2, right=node3) return root"},{"question":"# Question: Implement FIFO Queue Using Stack Operations You are tasked with implementing a FIFO (First-In-First-Out) queue using just two stacks. Stacks are LIFO (Last-In-First-Out) structures, meaning that elements are added and removed from the same end. The challenge is to use these LIFO operations to mimic FIFO behavior for the queue. Class Specifications: 1. `MyQueue` - **Methods**: - `__init__(self) -> None` - Initializes the queue. - `push(self, x: int) -> None` - **Input**: An integer element `x`. - **Output**: None. - Adds the element `x` to the end of the queue. - `pop(self) -> int` - **Output**: An integer element. - Removes the element from the front of the queue and returns it. - `peek(self) -> int` - **Output**: An integer element. - Gets the front element of the queue. - `empty(self) -> bool` - **Output**: A boolean value. - Returns `True` if the queue is empty, `False` otherwise. Constraints: - All elements are non-negative integers. - You must use only standard stack operations: `push`, `pop`, `peek`, and empty checks. - The operations `pop` and `peek` should be efficient and avoid unnecessary complexities. Example Usage: ```python queue = MyQueue() queue.push(1) queue.push(2) assert queue.peek() == 1 # returns 1 assert queue.pop() == 1 # returns 1 assert not queue.empty() # returns False queue.push(3) queue.push(4) assert queue.pop() == 2 # returns 2 assert queue.peek() == 3 # returns 3 assert queue.pop() == 3 # returns 3 assert queue.peek() == 4 # returns 4 assert queue.pop() == 4 # returns 4 assert queue.empty() # returns True ``` Requirements: - Ensure correct and efficient handling of the stack operations to maintain FIFO behavior. - Consider edge cases such as performing `pop` or `peek` on an empty queue. These should be handled gracefully according to typical queue behavior. --- By following the guidelines, this question integrates seamlessly with the existing set, as it matches the styling, complexity, and topic area of implementing basic data structures with optimized handling and constraints.","solution":"class MyQueue: def __init__(self): self.stack_in = [] self.stack_out = [] def push(self, x: int) -> None: self.stack_in.append(x) def pop(self) -> int: if not self.stack_out: while self.stack_in: self.stack_out.append(self.stack_in.pop()) return self.stack_out.pop() if self.stack_out else None def peek(self) -> int: if not self.stack_out: while self.stack_in: self.stack_out.append(self.stack_in.pop()) return self.stack_out[-1] if self.stack_out else None def empty(self) -> bool: return not self.stack_in and not self.stack_out"},{"question":"# Sum of Digits of Power Write a Python function named `sum_of_digits_of_power(base: int, exponent: int) -> int` that takes two integers `base` and `exponent`, and returns the sum of the digits of the number resulting from `base` raised to the power of `exponent`. # Input - `base` (int): the base number, where 1 <= base <= 1000. - `exponent` (int): the exponent, where 1 <= exponent <= 1000. # Output - Returns an integer representing the sum of the digits of the number `base**exponent`. # Constraints - Python\'s integer type can handle the large numbers resulting from the power operation, but efficiency in handling the digits is essential. # Example ```python assert sum_of_digits_of_power(2, 10) == 7 # 2^10 = 1024, sum of digits = 1 + 0 + 2 + 4 = 7 assert sum_of_digits_of_power(7, 3) == 10 # 7^3 = 343, sum of digits = 3 + 4 + 3 = 10 assert sum_of_digits_of_power(5, 4) == 8 # 5^4 = 625, sum of digits = 6 + 2 + 5 = 13 assert sum_of_digits_of_power(10, 3) == 1 # 10^3 = 1000, sum of digits = 1 + 0 + 0 + 0 = 1 ``` # Notes - Ensure that your implementation is optimized for handling large integers efficiently. - Break down the problem into manageable steps: compute the power, convert to string, and sum the individual digits.","solution":"def sum_of_digits_of_power(base, exponent): Calculates the sum of the digits of `base` raised to the power of `exponent`. Parameters: - base (int): The base number. - exponent (int): The exponent. Returns: - int: Sum of the digits of the resulting number. power_result = base ** exponent return sum(int(digit) for digit in str(power_result))"},{"question":"# Employee Salary Increment You are tasked to implement a function that calculates the new salaries of employees after applying an increment. The company rules state that all employees will get a specific percentage increase in their current salary. Problem Statement Implement a function `apply_increment` to calculate the updated salaries for a list of employees given a specific increment percentage. 1. **apply_increment(employees: List[Dict[str, Any]], increment: float) -> List[Dict[str, Any]]**: - **Input**: - `employees`: A list of dictionaries where each dictionary represents an employee. Each dictionary contains the keys `\'name\'`, `\'age\'`, and `\'salary\'`: - `\'name\'`: A string representing the employee\'s name. - `\'age\'`: An integer representing the employee\'s age. - `\'salary\'`: A float representing the employee\'s current salary. - `increment`: A float representing the percentage increment to be applied on the employee\'s salary. - **Output**: Returns a list of dictionaries with the updated salaries while keeping other employee details unchanged. Constraints * The increment percentage is a non-negative float. * Salaries are always positive. * The list of employees is non-empty. * The resulting salary should be rounded to 2 decimal places. Example ```python employees = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"salary\\": 50000.0}, {\\"name\\": \\"Bob\\", \\"age\\": 24, \\"salary\\": 40000.0}, {\\"name\\": \\"Charlie\\", \\"age\\": 28, \\"salary\\": 60000.0} ] increment = 10.0 updated_employees = apply_increment(employees, increment) # updated_employees == [ # {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"salary\\": 55000.0}, # {\\"name\\": \\"Bob\\", \\"age\\": 24, \\"salary\\": 44000.0}, # {\\"name\\": \\"Charlie\\", \\"age\\": 28, \\"salary\\": 66000.0} # ] ``` Function Definition ```python from typing import List, Dict, Any def apply_increment(employees: List[Dict[str, Any]], increment: float) -> List[Dict[str, Any]]: pass ``` # Requirements - Implement the function using appropriate data structures. - Ensure the function handles edge cases effectively. - The function should have a clear and concise logic for updating the salaries.","solution":"from typing import List, Dict, Any def apply_increment(employees: List[Dict[str, Any]], increment: float) -> List[Dict[str, Any]]: for employee in employees: current_salary = employee[\'salary\'] updated_salary = current_salary + (current_salary * increment / 100) employee[\'salary\'] = round(updated_salary, 2) return employees"},{"question":"# Problem Statement You are developing a feature for a navigation system that determines the shortest route between various landmarks in a city. The city is represented as a 2D grid, where certain cells contain obstacles that cannot be traversed. This task assesses your ability to implement pathfinding algorithms and handle grid-based movement and obstacles. Function Specification Implement a function `find_shortest_path` with the following signature: ```python from typing import List, Tuple from collections import deque def find_shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: Finds the shortest path from start to end in a 2D grid avoiding obstacles. Args: grid: A 2D list of integers where 0 represents an empty cell and 1 represents an obstacle. start: A tuple (x, y) representing the start position. end: A tuple (x, y) representing the end position. Returns: The length of the shortest path from start to end. Returns -1 if no path exists. ``` Parameters - **grid**: A `List[List[int]]` representing a 2D grid where `grid[i][j]` is `0` if the cell at (i, j) is empty and `1` if it contains an obstacle. The grid dimensions are `1 <= len(grid) <= 1000` and `1 <= len(grid[0]) <= 1000`. - **start**: A `Tuple[int, int]` representing the starting cell in the grid. - **end**: A `Tuple[int, int]` representing the target cell in the grid. Returns - An integer representing the length of the shortest path from the start cell to the end cell. If no valid path exists, return `-1`. Constraints - Ensure all inputs are within the specified limits. - Handle edge cases where the start or end positions might be blocked. - Movement is allowed in four directions: up, down, left, and right. # Example ```python grid = [ [0, 0, 0, 0], [1, 1, 0, 1], [0, 0, 0, 0], [0, 1, 1, 0] ] start = (0, 0) end = (3, 3) result = find_shortest_path(grid, start, end) print(result) ``` This could output: ``` 6 ``` Performance Requirements - The function must be efficient, employing suitable pathfinding algorithms such as Breadth-First Search (BFS) to handle large grids and avoid pitfalls of unoptimized traversal.","solution":"from typing import List, Tuple from collections import deque def find_shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: Finds the shortest path from start to end in a 2D grid avoiding obstacles. Args: grid: A 2D list of integers where 0 represents an empty cell and 1 represents an obstacle. start: A tuple (x, y) representing the start position. end: A tuple (x, y) representing the end position. Returns: The length of the shortest path from start to end. Returns -1 if no path exists. rows, cols = len(grid), len(grid[0]) if start == end: return 0 if grid[start[0]][start[1]] == 1 or grid[end[0]][end[1]] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(start[0], start[1], 0)]) visited = set() visited.add(start) while queue: x, y, dist = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and grid[nx][ny] == 0: if (nx, ny) == end: return dist + 1 queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"# Merge Sorted Arrays **Scenario**: You are creating a part of a data processing pipeline where you need to merge multiple sorted arrays into a single sorted array. Given several sorted arrays, your task is to efficiently merge them into one. **Task**: Write a function `merge_sorted_arrays(arrays: list[list[int]]) -> list[int]` that merges multiple sorted arrays into one sorted array. Summary points to consider: * The function should handle arrays of different lengths. * Ensure the result is sorted in ascending order. **Input**: * `arrays` - A list of lists, where each list is a sorted array of integers. **Output**: * Return a single list containing all elements from the input arrays, sorted in ascending order. **Constraints**: * 1 <= len(arrays) <= 10 * 0 <= len(arrays[i]) <= 1000 * The integers in the arrays can be negative or positive and fit within the 32-bit integer range. Your function must efficiently manage the merging process. **Example**: ```python >>> merge_sorted_arrays([[1, 4, 6], [2, 5], [3], [7, 8, 9]]) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> merge_sorted_arrays([[-10, -5, 0, 5], [1, 2, 3], [9, 10]]) [-10, -5, 0, 1, 2, 3, 5, 9, 10] >>> merge_sorted_arrays([[], [1, 2], [], [3, 4]]) [1, 2, 3, 4] ``` **Notes**: - The function should handle empty arrays gracefully. - Aim to achieve an optimal time complexity, leveraging algorithms suitable for merging multiple sorted arrays.","solution":"import heapq def merge_sorted_arrays(arrays): Merges multiple sorted arrays into a single sorted array. :param arrays: A list of lists, where each list is a sorted array of integers. :return: A single list containing all elements from the input arrays, sorted in ascending order. merged_list = [] min_heap = [] # Initialize the heap with the first element of each array for i, array in enumerate(arrays): if array: heapq.heappush(min_heap, (array[0], i, 0)) # Extract the smallest element from the heap and add the next element from that array to the heap while min_heap: val, list_idx, elem_idx = heapq.heappop(min_heap) merged_list.append(val) if elem_idx + 1 < len(arrays[list_idx]): next_val = arrays[list_idx][elem_idx + 1] heapq.heappush(min_heap, (next_val, list_idx, elem_idx + 1)) return merged_list"},{"question":"# Problem Description You are required to implement a function `transpose_dict` that takes a dictionary where keys are integers and values are lists of integers, and returns a new dictionary where each integer in the lists becomes a key and the corresponding values are lists of integers containing all keys that pointed to them. # Function Signature ```python def transpose_dict(input_dict: dict) -> dict: ``` # Input * `input_dict`: A dictionary where keys are integers and values are lists of integers (1 ≤ |input_dict| ≤ 10^3, 0 ≤ |values of each key| ≤ 10^3) # Output * Return a dictionary where each value in the lists of the input dictionary becomes a key, and its corresponding value is a list of keys from the input dictionary that contained this value. # Constraints 1. The function should raise an AssertionError with a message if the input is not a dictionary. 2. All values in the input lists are distinct within a list but can be present in multiple lists corresponding to different keys. # Example ```python input_dict = {1: [2, 3], 2: [3, 4], 3: [4, 5]} expected_output = {2: [1], 3: [1, 2], 4: [2, 3], 5: [3]} assert transpose_dict(input_dict) == expected_output input_dict = {6: [7, 8], 9: [8, 10]} expected_output = {7: [6], 8: [6, 9], 10: [9]} assert transpose_dict(input_dict) == expected_output input_dict = {1: [1], 2: [2], 3: [3]} expected_output = {1: [1], 2: [2], 3: [3]} assert transpose_dict(input_dict) == expected_output ``` # Notes * Ensure your function handles cases where any of the input lists are empty. * The function should handle keys and values properly, even if the input dictionary is empty.","solution":"def transpose_dict(input_dict): Returns a transposed dictionary where each value in the lists of the input dictionary becomes a key, and its corresponding value is a list of keys from the input dictionary that contained this value. if not isinstance(input_dict, dict): raise AssertionError(\\"The input must be a dictionary\\") transposed = {} for key, values in input_dict.items(): for value in values: if value not in transposed: transposed[value] = [] transposed[value].append(key) return transposed"},{"question":"# Question Statement Context: You are tasked with designing a function to detect the majority element in an array of integers. The majority element is defined as the element that appears more than `n // 2` times, where `n` is the length of the array. If no majority element exists, return `-1`. Implement this function using Boyer-Moore Voting Algorithm for optimal performance in terms of time and space complexity. Objective: Write a function `find_majority_element(arr: List[int]) -> int`, which takes a list of integers and returns the majority element or `-1` if no such element exists. Input: - `arr`: A list of integers (1 ≤ len(arr) ≤ 10**6) Output: - A single integer, which is the majority element of the list, or `-1` if no majority element exists. Constraints and Requirements: - The function should handle edge cases, such as small arrays, arrays with all distinct elements, and arrays with repetitive patterns. - Use Boyer-Moore Voting Algorithm to achieve linear time complexity O(n) for the finding phase. - After identifying a candidate for the majority element, validate the candidate by counting its occurrences to ensure it appears more than `n // 2` times. Examples: ```python print(find_majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4])) # Output: 4 print(find_majority_element([3, 3, 4, 2, 4, 4, 2, 4])) # Output: -1 (no majority element) print(find_majority_element([1, 1, 1, 1, 1, 1, 1, 1])) # Output: 1 ``` Implementation Hint: The Boyer-Moore Voting Algorithm works by maintaining a count which is incremented when encountering the same element and decremented otherwise. Finally, verify the candidate by counting its occurrences in the array.","solution":"from typing import List def find_majority_element(arr: List[int]) -> int: Finds the majority element in the array using Boyer-Moore Voting Algorithm. Returns the majority element or -1 if no majority element exists. if not arr: return -1 # Phase 1: Find a candidate for the majority element candidate, count = None, 0 for num in arr: if count == 0: candidate, count = num, 1 elif num == candidate: count += 1 else: count -= 1 # Phase 2: Validate the candidate count = 0 for num in arr: if num == candidate: count += 1 return candidate if count > len(arr) // 2 else -1"},{"question":"# Coding Question You are required to develop a function that takes a list of integers and returns a list of the running totals. **Objective**: Create a function `running_totals(lst: List[int]) -> List[int]` that computes the running totals of the input list of integers. Input/Output Format * **Input**: - `lst` (list of integers): A list of integers, which may include negative values and zeros. * **Output**: - Return a new list of integers representing the running totals. Explanation A running total is the cumulative sum of the values up to each index in the list. For instance, if the input list is `[1, 2, 3, 4]`, the running totals would be `[1, 3, 6, 10]`. Constraints - The length of the list `lst` will be between 0 and 10,000 - Each element of the list `lst` will be between -1,000 and 1,000 **Performance Requirement**: - The solution should run efficiently for the given constraints. Example ```python >>> running_totals([1, 2, 3, 4]) [1, 3, 6, 10] >>> running_totals([5, -2, 3, 8]) [5, 3, 6, 14] >>> running_totals([]) [] >>> running_totals([-1, -1, -1, -1]) [-1, -2, -3, -4] ``` **Instructions**: - Implement the function `running_totals(lst: List[int]) -> List[int>` - The function should adhere to the input/output requirements and handle edge cases properly.","solution":"from typing import List def running_totals(lst: List[int]) -> List[int]: Returns the running totals of the input list of integers. if not lst: return [] running_sum = 0 result = [] for number in lst: running_sum += number result.append(running_sum) return result"},{"question":"# Find Missing Number in Sorted Array Objective Write a function that identifies a missing number in a sorted array of unique integers. The array contains integers starting from a given base number up to a certain end number, but one number in the range is missing. Function Signature ```python def find_missing_number(arr: list[int], base: int) -> int: ``` Input * `arr`: A list of unique integers sorted in ascending order. * `base`: An integer representing the starting number of the sequence. Output * Returns an integer, which is the missing number in the sorted list. Constraints 1. The list `arr` will contain at least 2 and at most 10^6 elements. 2. The difference between the maximum and minimum values in `arr` will not exceed 10^6. 3. The missing number will be exactly one number in the sequence defined by `[base, base + 1, ..., base + n - 1]` where `n` is the length of `arr` plus one. Example ```python assert find_missing_number([1, 2, 4, 5, 6], 1) == 3 assert find_missing_number([10, 11, 12, 14], 10) == 13 assert find_missing_number([100, 101, 102, 104, 105], 100) == 103 assert find_missing_number([0, 1, 2, 3, 4, 5, 7], 0) == 6 assert find_missing_number([20, 21, 23], 20) == 22 ``` Notes 1. Use binary search to achieve optimal performance. 2. You may assume the missing number is always within the range defined by `base` to `base + len(arr)`. 3. Consider edge cases such as the missing number being at the start or end of the array. Good luck, and ensure your solution has optimal performance and handles all boundary cases effectively!","solution":"def find_missing_number(arr: list[int], base: int) -> int: Identifies the missing number in a sorted array of unique integers. Arguments: arr -- A list of unique integers sorted in ascending order. base -- An integer representing the starting number of the sequence. Returns: An integer which is the missing number. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 expected_value_at_mid = base + mid if arr[mid] == expected_value_at_mid: left = mid + 1 else: right = mid - 1 return base + left"},{"question":"# Number of Islands in a 2D Matrix **Context**: In geographic mapping and image processing, finding distinct regions in a 2D grid is a common operation. Here, you are tasked with identifying separate land masses on an island map represented as a 2D binary matrix. **Task**: Implement a function to count the number of distinct islands in a given 2D binary matrix. An island is defined as a group of adjacent \'1\'s (horizontally or vertically connected) surrounded by \'0\'s (water). You can assume all four edges of the grid are surrounded by water. **Function Signature**: ```python def count_islands(matrix: list[list[int]]) -> int: pass ``` **Parameters**: * `matrix`: A 2D list of integers where each element is either 0 (water) or 1 (land). **Returns**: * An integer representing the number of distinct islands. **Constraints**: * Number of rows (m) is between 1 and 300. * Number of columns (n) is between 1 and 300. **Example**: ```python map1 = [ [1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1], ] print(count_islands(map1)) # Outputs: 3 map2 = [ [1, 1, 0, 1, 1], [1, 0, 0, 1, 0], [0, 0, 1, 0, 0], [0, 1, 0, 1, 1], ] print(count_islands(map2)) # Outputs: 5 map3 = [ [0, 0, 0], [0, 0, 0], [0, 0, 0], ] print(count_islands(map3)) # Outputs: 0 map4 = [ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], ] print(count_islands(map4)) # Outputs: 1 ``` **Note**: * You may use depth-first search (DFS) or breadth-first search (BFS) to explore the grid and determine the number of islands. * Ensure the solution is efficient and scales within the given constraints. * Avoid modifying the input `matrix` parameter.","solution":"def count_islands(matrix): Returns the number of distinct islands in the given 2D binary matrix. if not matrix: return 0 rows = len(matrix) cols = len(matrix[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(x, y): stack = [(x, y)] while stack: cx, cy = stack.pop() if cx < 0 or cy < 0 or cx >= rows or cy >= cols or visited[cx][cy] or matrix[cx][cy] == 0: continue visited[cx][cy] = True stack.append((cx + 1, cy)) stack.append((cx - 1, cy)) stack.append((cx, cy + 1)) stack.append((cx, cy - 1)) island_count = 0 for i in range(rows): for j in range(cols): if matrix[i][j] == 1 and not visited[i][j]: dfs(i, j) island_count += 1 return island_count"},{"question":"# Binary Tree Symmetry Check Context Understanding the properties of trees, particularly binary trees, is crucial in many areas of computer science. One interesting property of binary trees is symmetry. A binary tree is symmetrical if the left and right subtrees are mirror images of each other. Task 1. **Class Definition**: Implement a `TreeNode` class to represent nodes of a binary tree, where each node contains an integer value and pointers to its left and right children. 2. **Symmetry Check**: Create a method `isSymmetrical` in the `SymmetricalTree` class that determines if a given binary tree is symmetrical around its center. Function Signatures You are to implement the following functions: ```python class TreeNode: def __init__(self, x: int, left: \'TreeNode\' = None, right: \'TreeNode\' = None): ... class SymmetricalTree: def isSymmetrical(self, root: TreeNode) -> bool: ... def isMirror(self, left: TreeNode, right: TreeNode) -> bool: ... ``` Constraints - The binary tree can have up to 1000 nodes. - Nodes\' values are integers between -1000 and 1000. Example Suppose we have the following binary tree: ``` 1 / 2 2 / / 3 4 4 3 ``` Calling your `isSymmetrical` method should return `True` for this tree since it is symmetrical. Another tree: ``` 1 / 2 2 3 3 ``` Calling your `isSymmetrical` method should return `False` as it is not symmetrical. ```python left = TreeNode(2, TreeNode(3), TreeNode(4)) right = TreeNode(2, TreeNode(4), TreeNode(3)) root = TreeNode(1, left, right) sym_tree = SymmetricalTree() print(sym_tree.isSymmetrical(root)) # Output: True right = TreeNode(2, None, TreeNode(3)) root = TreeNode(1, left, right) print(sym_tree.isSymmetrical(root)) # Output: False ``` Ensure that the method correctly identifies symmetrical and non-symmetrical trees. # Implementation Tip To determine the symmetry of the tree, you should create a helper function `isMirror` that compares whether two trees are mirrors of each other. The `isSymmetrical` method should then utilize `isMirror` to check if the left and right subtrees of the root are mirrors.","solution":"class TreeNode: def __init__(self, x: int, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = x self.left = left self.right = right class SymmetricalTree: def isSymmetrical(self, root: TreeNode) -> bool: if not root: return True return self.isMirror(root.left, root.right) def isMirror(self, left: TreeNode, right: TreeNode) -> bool: if not left and not right: return True if not left or not right: return False return (left.val == right.val) and self.isMirror(left.left, right.right) and self.isMirror(left.right, right.left)"},{"question":"# Coding Assessment Question Background & Context You are developing a system that tracks and logs user activities on a website. To ensure data consistency and accuracy over time, you need a logging mechanism that filters out duplicate consecutive activities by the same user. Task Write a function `unique_session_logs` that takes a list of user activity logs and returns a filtered version of this list with no consecutive duplicate activities by the same user. Each log entry is a tuple consisting of the user ID and activity performed. Function Signature ```python def unique_session_logs(logs: list) -> list: Filters out consecutive duplicate activities by the same user from the list of logs. :param logs: list of tuples, where each tuple contains: - user_id (int): The ID of the user - activity (str): The activity performed by the user :return: list of tuples containing filtered logs ``` Input and Output Format * **Input**: - `logs` (List[Tuple[int, str]]): A list of tuples where each tuple contains: - `user_id` (int): The ID of the user - `activity` (str): The activity performed by the user * **Output**: - Returns a list of tuples containing the filtered logs with no consecutive duplicate activities by the same user. Constraints * A user can only have consecutive duplicate activities filtered out; different users performing the same activity consecutively should not be filtered. * The function should handle the logs efficiently, respecting the input list order. Example ```python logs = [ (1, \'login\'), (1, \'view_page\'), (1, \'view_page\'), (2, \'login\'), (2, \'login\'), (1, \'logout\'), (2, \'logout\') ] result = unique_session_logs(logs) # Expected output: # [ # (1, \'login\'), # (1, \'view_page\'), # (2, \'login\'), # (1, \'logout\'), # (2, \'logout\') # ] ``` Notes * Pay careful attention to ensuring that only consecutive duplicate activities by the same user are filtered. * The order of the logs should remain unchanged apart from the removed consecutive duplicates. This problem will test your ability to manipulate and filter list data, ensuring you respect specific criteria in the context of log management.","solution":"def unique_session_logs(logs): Filters out consecutive duplicate activities by the same user from the list of logs. :param logs: list of tuples, where each tuple contains: - user_id (int): The ID of the user - activity (str): The activity performed by the user :return: list of tuples containing filtered logs if not logs: return [] filtered_logs = [logs[0]] for i in range(1, len(logs)): if logs[i][0] != logs[i-1][0] or logs[i][1] != logs[i-1][1]: filtered_logs.append(logs[i]) return filtered_logs"},{"question":"# Maze Path Finder with Obstacles Context: In robotics and game development, finding a path from a start point to an end point on a grid while avoiding obstacles is a common problem. This problem tests your understanding of graph traversal algorithms, such as Breadth-First Search (BFS) or Depth-First Search (DFS). Problem Statement: Write a function `find_path_with_obstacles(grid: List[List[int]]) -> List[Tuple[int, int]]` that returns the shortest path from the top-left corner to the bottom-right corner of a 2D grid. If no path exists, return an empty list. * The grid is represented as a list of lists, where each element is either: * `0` for an open cell you can walk on. * `1` for an obstacle you cannot walk on. Input: * `grid` - a list of lists of integers representing the grid (0 ≤ grid[i][j] ≤ 1). * The dimensions of the grid are m x n (1 ≤ m, n ≤ 100). * The top-left and bottom-right corners will always be open cells `0`. Output: * A list of tuples representing the path from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1). Each tuple indicates the coordinates `(row, col)` of the path. If no path exists, return an empty list. Example: ```python grid = [ [0, 0, 0, 1], [1, 0, 1, 0], [0, 0, 0, 0], [1, 1, 0, 0] ] find_path_with_obstacles(grid) ``` Expected Output: ```python [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2), (2, 3), (3, 3)] ``` Constraints: 1. Ensure your solution handles the largest possible grid size efficiently. 2. If multiple shortest paths exist, returning any one of them is acceptable. Function Signature: ```python from typing import List, Tuple def find_path_with_obstacles(grid: List[List[int]]) -> List[Tuple[int, int]]: pass ``` Notes: * Consider edge cases such as a grid full of obstacles except for the start and end points. * Optimize your solution to handle the worst-case scenario within a reasonable time for given constraints.","solution":"from typing import List, Tuple from collections import deque def find_path_with_obstacles(grid: List[List[int]]) -> List[Tuple[int, int]]: if not grid or not grid[0]: return [] rows, cols = len(grid), len(grid[0]) start, end = (0, 0), (rows - 1, cols - 1) if grid[start[0]][start[1]] == 1 or grid[end[0]][end[1]] == 1: return [] # Direction vectors for moving in 4 directions: right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Queue for BFS: stores (current_position, path_taken) queue = deque([(start, [start])]) visited = set([start]) while queue: (curr_x, curr_y), path = queue.popleft() if (curr_x, curr_y) == end: return path for dx, dy in directions: next_x, next_y = curr_x + dx, curr_y + dy if 0 <= next_x < rows and 0 <= next_y < cols and grid[next_x][next_y] == 0: next_position = (next_x, next_y) if next_position not in visited: visited.add(next_position) queue.append((next_position, path + [next_position])) return []"},{"question":"**Question**: You are required to implement a function that detects and removes cycles in an undirected graph. The resulting graph should be a tree and all duplicate edges that form cycles must be removed. # Input - An integer `V` (1 ≤ `V` ≤ 500) representing the number of vertices. - An integer `E` (0 ≤ `E` ≤ 1000) representing the number of edges. - A list of `E` edges, where each edge is represented by two integers: `src` and `dst`. # Output - A list of edges remaining in the graph after all cycles are removed. Each edge should be represented by two integers: `src` and `dst`. # Function Signature ```python def remove_cycles(vertices: int, edges: list[tuple[int, int]]) -> list[tuple[int, int]]: pass ``` # Constraints - All vertices are numbered from 0 to V-1. - The graph is undirected. - If there are multiple valid results, any correct output is acceptable. - Ensure the graph remains connected after removing cycles (i.e., each vertex should be reachable from any other vertex). # Example ```python vertices = 5 edges = [(0, 1), (0, 2), (1, 2), (1, 3), (2, 4), (3, 4)] result = remove_cycles(vertices, edges) print(result) # Output: [(0, 1), (0, 2), (1, 3), (2, 4)] or any other valid spanning tree ``` In this example, the function should return the list of edges that form a tree by removing the redundant edges creating cycles. Any valid tree that spans all vertices can be the correct output.","solution":"def remove_cycles(vertices: int, edges: list[tuple[int, int]]) -> list[tuple[int, int]]: This function removes cycles from an undirected graph represented by vertices and edges and returns a list of edges that forms a tree. parent = list(range(vertices)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootX] = rootY return True return False tree_edges = [] for src, dst in edges: if union(src, dst): tree_edges.append((src, dst)) return tree_edges"},{"question":"# Pascal\'s Triangle Row Calculation **Background**: Pascal\'s Triangle is a triangular array of the binomial coefficients. Each row represents the coefficients in the expansion of a binomial expression raised to a successive power. The rows of Pascal\'s Triangle are conventionally enumerated starting with row `0`. **Task**: Write a function `generate_pascals_triangle_row` that takes an integer `k` and returns a list representing the `k-th` row of Pascal\'s Triangle. Function Signature: ```python def generate_pascals_triangle_row(k: int) -> list: pass ``` Input: * An integer `k` (0 <= k <= 33) Output: * A list of integers representing the `k-th` row of Pascal\'s Triangle. Examples: ```python generate_pascals_triangle_row(0) -> [1] generate_pascals_triangle_row(1) -> [1, 1] generate_pascals_triangle_row(3) -> [1, 3, 3, 1] generate_pascals_triangle_row(5) -> [1, 5, 10, 10, 5, 1] generate_pascals_triangle_row(10) -> [1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1] ``` # Constraints: * The function should handle the generation of Pascal\'s Triangle row for any valid value of `k` efficiently. * Consider edge cases such as `k = 0` and `k = 33`. # Scenario: Imagine you are contributing to an educational software that visualizes mathematical concepts. As part of this work, you need to provide accurate and efficient generation of rows from Pascal\'s Triangle to support combinatorial calculations and binomial expansions. Ensure the correctness of your implementation, keeping in mind edge cases and efficiency.","solution":"def generate_pascals_triangle_row(k: int) -> list: Generates the k-th row of Pascal\'s Triangle. Args: k (int): The row index (0 <= k <= 33). Returns: list: The k-th row of Pascal\'s Triangle. if k < 0 or k > 33: raise ValueError(\\"k must be between 0 and 33 inclusive.\\") row = [1] # Starting with the first element of the row for i in range(1, k + 1): # Compute the next element using the combination formula row.append(row[-1] * (k - i + 1) // i) return row"},{"question":"# Problem Statement You are given a string that contains a mix of letters, digits, and special characters. Your task is to extract the numbers from the string, sum them up, and return the integer result. If there are no numbers in the string, the function should return `0`. # Task Write a function `sum_of_numbers_in_string(input_string)` that takes: * A string `input_string` containing a mix of letters, digits, and special characters. Your function should return an integer representing the sum of all the numbers extracted from the string. # Input * `input_string`: A string containing a mix of letters, digits, and special characters. # Output * An integer representing the sum of all the numbers in the input string. # Examples: 1. ```python sum_of_numbers_in_string(\\"abc123xyz\\") ``` Expected Output: ``` 123 ``` 2. ```python sum_of_numbers_in_string(\\"hello5world15!\\") ``` Expected Output: ``` 20 ``` 3. ```python sum_of_numbers_in_string(\\"!@#%^&*()\\") ``` Expected Output: ``` 0 ``` # Constraints * The input string can be up to 10^6 characters long. * The numbers can be of any length. * The function should handle strings with no numbers gracefully. # Performance Requirements * Your implementation should handle large input sizes efficiently. Ensure that your approach does not lead to performance deterioration with strings of maximum length.","solution":"import re def sum_of_numbers_in_string(input_string): Extracts numbers from the input string, sums them up, and returns the result. Parameters: - input_string (str): The string containing a mix of letters, digits, and special characters. Returns: - int: The sum of all the numbers extracted from the input string. numbers = re.findall(r\'d+\', input_string) return sum(map(int, numbers))"},{"question":"# Coding Assessment Question: Implement a Text Autocompletion System Context You are working on a text-autocompletion feature like those found in search engines or messaging apps. Your task is to build a system that can generate autocomplete suggestions based on a given prefix. The system should use a list of words provided as the dictionary. Task 1. **Trie Implementation**: Implement a Trie (prefix tree) that will be used to store the dictionary words efficiently. 2. **Insertion Method**: Implement a method `insert(word)` that takes a single word and inserts it into the Trie. 3. **Autocomplete Method**: Implement a method `autocomplete(prefix)` that returns a list of all words in the dictionary that start with the given prefix. Implementation ```python class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): current = self.root for char in word: if char not in current.children: current.children[char] = TrieNode() current = current.children[char] current.is_end_of_word = True def _find_node(self, prefix): current = self.root for char in prefix: if char not in current.children: return None current = current.children[char] return current def _collect_all_words(self, node, prefix, words): if node.is_end_of_word: words.append(prefix) for char, next_node in node.children.items(): self._collect_all_words(next_node, prefix + char, words) def autocomplete(self, prefix): node = self._find_node(prefix) if not node: return [] words = [] self._collect_all_words(node, prefix, words) return words ``` Input Format - The `insert` method takes a single string `word`. - The `autocomplete` method takes a single string `prefix`. Output Format - The `autocomplete` method returns a list of strings. Constraints - All dictionary words and prefixes are lowercase letters. - The length of dictionary words and prefixes will not exceed 1000 characters. - The total number of words in the dictionary will not exceed 10000. You should write your implementation within the given `Trie` class template. Feel free to add helper methods as needed.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): current = self.root for char in word: if char not in current.children: current.children[char] = TrieNode() current = current.children[char] current.is_end_of_word = True def _find_node(self, prefix): current = self.root for char in prefix: if char not in current.children: return None current = current.children[char] return current def _collect_all_words(self, node, prefix, words): if node.is_end_of_word: words.append(prefix) for char, next_node in node.children.items(): self._collect_all_words(next_node, prefix + char, words) def autocomplete(self, prefix): node = self._find_node(prefix) if not node: return [] words = [] self._collect_all_words(node, prefix, words) return words"},{"question":"# Self-Balancing Binary Search Tree Binary Search Trees (BSTs) are important data structures that allow efficient implementation of dynamic sets and lookup tables. However, in the worst case, a simple BST can degenerate into a linked list with operations taking linear time. Self-balancing BSTs such as AVL trees ensure that the tree height remains logarithmic, providing good average and worst-case performance. Your task is to implement a self-balancing binary search tree, specifically an AVL tree, which automatically balances itself during insertion and deletion operations. # Function Signatures ```python class AVLTree: def __init__(self): pass def insert(self, key: int) -> None: pass def delete(self, key: int) -> None: pass def search(self, key: int) -> bool: pass def inorder_traversal(self) -> List[int]: pass ``` # Methods - `insert(key: int) -> None`: Insert a key into the AVL tree. - `delete(key: int) -> None`: Delete a key from the AVL tree. - `search(key: int) -> bool`: Return `True` if the key exists in the AVL tree, otherwise `False`. - `inorder_traversal() -> List[int]`: Return a list of keys in the AVL tree in inorder traversal. # Example ```python # Example usage: avltree = AVLTree() avltree.insert(10) avltree.insert(20) avltree.insert(30) print(avltree.search(20)) # Returns True print(avltree.inorder_traversal()) # Returns [10, 20, 30] avltree.delete(20) print(avltree.search(20)) # Returns False print(avltree.inorder_traversal()) # Returns [10, 30] ``` # Constraints - The number of insert or delete operations is at most 10^4. - All elements are unique integers, and their values are within the range [-10^6, 10^6]. # Notes - Ensure that the tree remains balanced after each insertion and deletion operation. - Optimize the tree\'s rotation logic to maintain logarithmic height. - Thoroughly test the tree with various sequences of operations to ensure correctness. Here\'s an example implementation to get you started: ```python class TreeNode: def __init__(self, key): ... class AVLTree: def __init__(self): self.root = None def insert(self, key: int) -> None: ... def delete(self, key: int) -> None: ... def search(self, key: int) -> bool: ... def inorder_traversal(self) -> List[int]: ... ```","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self): self.root = None def insert(self, key: int) -> None: self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return TreeNode(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and key < node.left.key: return self._right_rotate(node) if balance < -1 and key > node.right.key: return self._left_rotate(node) if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def delete(self, key: int) -> None: self.root = self._delete(self.root, key) def _delete(self, node, key): if not node: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp_val = self._get_min_value_node(node.right) node.key = temp_val.key node.right = self._delete(node.right, temp_val.key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and self._get_balance(node.left) >= 0: return self._right_rotate(node) if balance < -1 and self._get_balance(node.right) <= 0: return self._left_rotate(node) if balance > 1 and self._get_balance(node.left) < 0: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and self._get_balance(node.right) > 0: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def search(self, key: int) -> bool: return self._search(self.root, key) def _search(self, node, key): if node is None: return False if node.key == key: return True elif key < node.key: return self._search(node.left, key) else: return self._search(node.right, key) def inorder_traversal(self) -> list: result = [] self._inorder_traversal(self.root, result) return result def _inorder_traversal(self, node, result): if not node: return self._inorder_traversal(node.left, result) result.append(node.key) self._inorder_traversal(node.right, result) def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _get_min_value_node(self, node): if node is None or node.left is None: return node return self._get_min_value_node(node.left)"},{"question":"# Problem Statement You are given a list of integers, and your task is to determine if the list is sorted in non-decreasing order. Implement the function `is_sorted(arr: List[int]) -> bool` that checks and returns whether the list is sorted. Input * `arr` (List[int]): a list of integers which can be of length from 0 up to (10^5). Output * The function should return a boolean value: * `True` if the list is sorted in non-decreasing order. * `False` otherwise. Example ```python >>> is_sorted([1, 2, 3, 4, 5]) True >>> is_sorted([3, 3, 3]) True >>> is_sorted([5, 4, 6, 7]) False >>> is_sorted([10]) True >>> is_sorted([]) True ``` # Constraints * The input list can contain up to (10^5) integers. * The integers in the list can be in the range from (-10^9) to (10^9). # Requirements * The function should execute in linear time, i.e., O(n). * Pay attention to edge cases, such as an empty list, which should return `True`.","solution":"def is_sorted(arr): Determines if a list is sorted in non-decreasing order. Parameters: arr (List[int]): A list of integers. Returns: bool: Returns True if the list is sorted, otherwise False. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True"},{"question":"# Coding Assessment Question Scenario: You are tasked with developing a system that validates and processes Social Security Numbers (SSNs) in a database. SSNs are critical identifiers used in various operations, and accuracy in their validation is crucial to ensure data integrity. Your task is to write a function that validates a given SSN, ensuring it follows the standard format, and then extracts certain useful information from it. Task: Write a Python function `process_ssn(ssn: str) -> dict` that: * Takes a string `ssn` representing a Social Security Number. * Validates that the SSN is in the correct format `XXX-XX-XXXX` where `X` is a digit. * Extracts the **area number** (first three digits), **group number** (next two digits), and **serial number** (last four digits). * Returns a dictionary with keys `\\"valid\\"`, `\\"area\\"`, `\\"group\\"`, and `\\"serial\\"`. # Specifications: * **Input**: A string `ssn` representing the SSN. * **Output**: A dictionary containing: - `\\"valid\\"`: A boolean indicating if the SSN is valid. - `\\"area\\"`: An integer representing the area number (if SSN is valid). - `\\"group\\"`: An integer representing the group number (if SSN is valid). - `\\"serial\\"`: An integer representing the serial number (if SSN is valid). # Constraints: * The input string `ssn` must follow the `XXX-XX-XXXX` format where `X` is a digit. * If the input does not follow the correct format, `\\"valid\\"` should be `False`, and other values should be `None`. Example Inputs and Outputs: 1. `process_ssn(\\"123-45-6789\\")` should return `{\'valid\': True, \'area\': 123, \'group\': 45, \'serial\': 6789}` 2. `process_ssn(\\"987-65-4321\\")` should return `{\'valid\': True, \'area\': 987, \'group\': 65, \'serial\': 4321}` 3. `process_ssn(\\"12345-6789\\")` should return `{\'valid\': False, \'area\': None, \'group\': None, \'serial\': None}` 4. `process_ssn(\\"12-345-678\\")` should return `{\'valid\': False, \'area\': None, \'group\': None, \'serial\': None}` # Edge Cases: 1. If the input is `\\"123-456-789\\"`, the format is incorrect and should return `{\'valid\': False, \'area\': None, \'group\': None, \'serial\': None}`. 2. If the input is `\\"A23-45-6789\\"`, the format is incorrect and should return `{\'valid\': False, \'area\': None, \'group\': None, \'serial\': None}`. 3. If the input is `\\"123-45-67890\\"`, the format is incorrect and should return `{\'valid\': False, \'area\': None, \'group\': None, \'serial\': None}`. # Example Error Handling: 1. `process_ssn(\\"123-456-789\\")` should return `{\'valid\': False, \'area\': None, \'group\': None, \'serial\': None}`. 2. `process_ssn(\\"A23-45-6789\\")` should return `{\'valid\': False, \'area\': None, \'group\': None, \'serial\': None}`. 3. `process_ssn(\\"123-45-67890\\")` should return `{\'valid\': False, \'area\': None, \'group\': None, \'serial\': None}`. # Note: Ensure the function handles all specified edge cases to maintain data integrity.","solution":"def process_ssn(ssn: str) -> dict: Validates and processes a Social Security Number (SSN). Args: ssn (str): The SSN to process in the format XXX-XX-XXXX. Returns: dict: A dictionary containing the validity of the SSN and its parts. if not isinstance(ssn, str): return {\'valid\': False, \'area\': None, \'group\': None, \'serial\': None} parts = ssn.split(\'-\') if len(parts) != 3: return {\'valid\': False, \'area\': None, \'group\': None, \'serial\': None} if len(parts[0]) != 3 or len(parts[1]) != 2 or len(parts[2]) != 4: return {\'valid\': False, \'area\': None, \'group\': None, \'serial\': None} if not (parts[0].isdigit() and parts[1].isdigit() and parts[2].isdigit()): return {\'valid\': False, \'area\': None, \'group\': None, \'serial\': None} area = int(parts[0]) group = int(parts[1]) serial = int(parts[2]) return {\'valid\': True, \'area\': area, \'group\': group, \'serial\': serial}"},{"question":"# Problem Description You have to write a Python function that determines if a given list of integers contains a pair of elements that sum up to a specific target number `k`. # Function Signature ```python def has_pair_with_sum(nums: list[int], k: int) -> bool: pass ``` # Input - `nums`: A list of integers where 0 ≤ len(nums) ≤ 10^6 and `nums[i]` is between `-10^9` and `10^9`. - `k`: An integer where `-10^9` ≤ k ≤ `10^9`. # Output - Returns a boolean value, `True` if there exists at least one pair of elements in `nums` that sum up to `k`, otherwise `False`. # Constraints - The function should run efficiently with time complexity close to O(n). # Example ```python >>> has_pair_with_sum([1, 2, 3, 4, 5], 9) True >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) False >>> has_pair_with_sum([-3, 2, 4, -1, 7], 6) True >>> has_pair_with_sum([], 0) False ```","solution":"def has_pair_with_sum(nums: list[int], k: int) -> bool: Returns True if there are two distinct elements in nums that sum up to k. seen = set() for num in nums: if k - num in seen: return True seen.add(num) return False"},{"question":"# Coding Assessment Question Context You have a list of integers representing monthly sales data for a product. You need to implement a function that identifies and returns the longest consecutive subsequence of increasing sales. This subsequence must consist of strictly increasing numbers from the input list. Task Implement a function `longest_increasing_subsequence(sales: List[int]) -> List[int]` that returns the longest consecutive subsequence of increasing sales. 1. The function should handle edge cases such as an empty list or a list with only one element. 2. If there are multiple subsequences of the same maximum length, return the first one in the list. 3. Optimize for performance to handle large lists efficiently. Input - `sales` (List[int]): A list of integers representing the sales data, where each integer could be positive, negative, or zero. Output - (List[int]): The longest consecutive subsequence of strictly increasing sales. Constraints - The input list will have at most 10,000 integers. Example ```python >>> longest_increasing_subsequence([10, 20, 30, 10, 15, 35, 40, 8, 12, 50]) [10, 15, 35, 40] >>> longest_increasing_subsequence([10, 20, 30, 5, 6, 7, 8, 9, 1, 2]) [5, 6, 7, 8, 9] >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) [5] ``` # Notes: - You may assume Python\'s built-in libraries for handling lists will be available. - Pay special attention to performance when working with large lists and test cases.","solution":"from typing import List def longest_increasing_subsequence(sales: List[int]) -> List[int]: Returns the longest consecutive subsequence of strictly increasing sales. Args: sales (List[int]): A list of integers representing the sales data. Returns: List[int]: The longest consecutive subsequence of strictly increasing sales. if not sales: return [] max_length = 0 max_start = 0 current_start = 0 current_length = 1 for i in range(1, len(sales)): if sales[i] > sales[i - 1]: current_length += 1 else: if current_length > max_length: max_length = current_length max_start = current_start current_start = i current_length = 1 if current_length > max_length: max_length = current_length max_start = current_start return sales[max_start:max_start + max_length]"},{"question":"# Question You need to implement a function that generates all possible combinations of `k` elements from a given list of `n` unique elements. The function should return the combinations in lexicographical order. Requirements 1. The function should handle input lists with up to 15 elements efficiently. 2. The combinations should be returned as a list of lists, each containing `k` elements. 3. The function should include appropriate documentation and type hints. Function Signature ```python def generate_combinations(elements: list[int], k: int) -> list[list[int]]: Generate all possible combinations of k elements from the given list of unique integers. :param elements: List of unique integers. :param k: The number of elements in each combination. :return: A list of lists, each containing k elements representing the combinations in lexicographical order. pass ``` Input - `elements`: A list of up to 15 unique integers. - `k`: An integer indicating the number of elements in each combination (0 <= k <= len(elements)). Output - Returns a list of lists, each containing `k` elements, representing all possible combinations in lexicographical order. Constraints - The function should handle lists with up to 15 elements efficiently. - The combinations should be returned in sorted (lexicographical) order. Example ```python elements = [1, 2, 3] k = 2 combinations = generate_combinations(elements, k) # Output: # combinations = [ # [1, 2], # [1, 3], # [2, 3] # ] elements = [3, 1, 4, 2] k = 3 combinations = generate_combinations(elements, k) # Output: # combinations = [ # [1, 2, 3], # [1, 2, 4], # [1, 3, 4], # [2, 3, 4] # ] elements = [5, 6, 7, 8] k = 0 combinations = generate_combinations(elements, k) # Output: # combinations = [ # [] # ] ``` Hints - You might find it useful to use a recursive approach or the `itertools.combinations` function to generate the combinations. - Pay attention to sorting the `elements` list if necessary to ensure lexicographical order of the combinations.","solution":"from itertools import combinations def generate_combinations(elements: list[int], k: int) -> list[list[int]]: Generate all possible combinations of k elements from the given list of unique integers. :param elements: List of unique integers. :param k: The number of elements in each combination. :return: A list of lists, each containing k elements representing the combinations in lexicographical order. elements.sort() return [list(comb) for comb in combinations(elements, k)]"},{"question":"# Coding Assessment Question Context In a fantasy RPG game, players gather various magical items and group them into sets to gain special bonuses. Each type of item belongs to a specific category, such as weapons, armor, or accessories. Certain items provide additional bonuses when equipped together, forming optimal sets. The goal is to find the maximum set bonus for a player given a list of items. Problem Statement Write a function `max_set_bonus(items: List[Tuple[str, int]]) -> int` that calculates the maximum set bonus a player can achieve. Each item is represented as a tuple containing the category of the item (as a string) and the bonus it provides (as an integer). A valid set contains exactly one item from each category. Function Signature ```python def max_set_bonus(items: List[Tuple[str, int]]) -> int: pass ``` Input - **items** (List[Tuple[str, int]]): A list of tuples where each tuple contains a string representing the category of the item and an integer representing the bonus value. (1 <= len(items) <= 10^5) Output - **int**: The maximum possible bonus from any valid set. Example ```python assert max_set_bonus([(\\"weapon\\", 30), (\\"armor\\", 50), (\\"weapon\\", 25), (\\"accessory\\", 20), (\\"armor\\", 45), (\\"accessory\\", 30)]) == 110 assert max_set_bonus([(\\"weapon\\", 30), (\\"armor\\", 50), (\\"weapon\\", 35), (\\"armor\\", 45)]) == 85 assert max_set_bonus([(\\"weapon\\", 30), (\\"accessory\\", 20), (\\"armor\\", 50), (\\"accessory\\", 15), (\\"armor\\", 45)]) == 100 ``` Constraints 1. Each category will contain at least one item. 2. The bonus values will range between -10^3 and 10^3 (inclusive). 3. There will be at most 30 different categories. Notes - The player can choose at most one item from each category. - Ensure the solution efficiently computes the result given the constraint on list size.MAX_SET_BONUS [max_set_bonus]: Max Set Bonus Given a list of magical items and their respective bonuses, your task is to compute the maximum bonus attainable by forming a valid set with one item from each category. This problem tests your ability to handle constraints on input size and efficiently consolidate and process the data to find an optimal solution.","solution":"from typing import List, Tuple def max_set_bonus(items: List[Tuple[str, int]]) -> int: max_bonuses = {} for category, bonus in items: if category in max_bonuses: max_bonuses[category] = max(max_bonuses[category], bonus) else: max_bonuses[category] = bonus return sum(max_bonuses.values())"},{"question":"# Sorting Squares and Cubes You are provided with a list of integers. Your task is to generate two new lists from the input list: one containing the squares and the other containing the cubes of the integers. You should then return a sorted version of both these lists. Requirements: 1. **Square List**: Implement a function `generate_square_list` that takes a list of integers and returns a sorted list of their squares. 2. **Cube List**: Implement a function `generate_cube_list` that takes a list of integers and returns a sorted list of their cubes. 3. **Sorting**: Ensure that both resultant lists are sorted in non-decreasing order. 4. **Edge Cases**: The function must correctly handle edge cases such as an empty list. Input/Output Specification: * **Input**: * `numbers`: (List of integers) A list of integers. Constraints: (0 leq text{len(numbers)} leq 100) and each integer is in the range [-100, 100]. * **Output**: * `sorted_squares`: A list containing the squares of the input numbers sorted in non-decreasing order. * `sorted_cubes`: A list containing the cubes of the input numbers sorted in non-decreasing order. Example: ```python # Example 1: numbers = [1, 2, 3, 4] sorted_squares, sorted_cubes = process_numbers(numbers) print(sorted_squares) # Expected: [1, 4, 9, 16] print(sorted_cubes) # Expected: [1, 8, 27, 64] # Example 2: numbers = [-3, -1, 0, 2] sorted_squares, sorted_cubes = process_numbers(numbers) print(sorted_squares) # Expected: [0, 1, 4, 9] print(sorted_cubes) # Expected: [-27, -1, 0, 8] ``` Code: ```python def generate_square_list(numbers: List[int]) -> List[int]: squares = [x ** 2 for x in numbers] squares.sort() return squares def generate_cube_list(numbers: List[int]) -> List[int]: cubes = [x ** 3 for x in numbers] cubes.sort() return cubes def process_numbers(numbers: List[int]) -> Tuple[List[int], List[int]]: sorted_squares = generate_square_list(numbers) sorted_cubes = generate_cube_list(numbers) return sorted_squares, sorted_cubes if __name__ == \\"__main__\\": numbers = [1, 2, 3, 4] print(process_numbers(numbers)) # Expected output should match the example 1 provided ```","solution":"from typing import List, Tuple def generate_square_list(numbers: List[int]) -> List[int]: Returns a sorted list of squares of the given numbers. squares = [x ** 2 for x in numbers] squares.sort() return squares def generate_cube_list(numbers: List[int]) -> List[int]: Returns a sorted list of cubes of the given numbers. cubes = [x ** 3 for x in numbers] cubes.sort() return cubes def process_numbers(numbers: List[int]) -> Tuple[List[int], List[int]]: Returns a tuple containing two lists: 1. A sorted list of squares of the given numbers. 2. A sorted list of cubes of the given numbers. sorted_squares = generate_square_list(numbers) sorted_cubes = generate_cube_list(numbers) return sorted_squares, sorted_cubes"},{"question":"# Scenario: You are tasked with implementing a function that finds the maximum subarray sum using the Divide and Conquer approach. This algorithm should divide the array into two halves, recursively find the maximum subarray sum in each half, and then find the maximum subarray sum that crosses the midpoint. # Requirements: 1. Implement a function `max_subarray_sum` that takes a list of integers as input and returns the maximum subarray sum. 2. The function should use the Divide and Conquer approach to find the maximum subarray sum efficiently. # Function Signature: ```python def max_subarray_sum(nums: list[int]) -> int: ``` # Input: - `nums`: A list of integers `nums` where `1 <= len(nums) <= 10^5`. # Output: - An integer representing the maximum subarray sum. # Constraints: - The list may contain both positive and negative integers. - The input list will have at least one element. # Example: ```python assert max_subarray_sum([1, -3, 2, 1, -1]) == 3 assert max_subarray_sum([3, -2, 5, -1]) == 6 assert max_subarray_sum([-2, -3, -1, -4]) == -1 assert max_subarray_sum([5, 4, -1, 7, 8]) == 23 assert max_subarray_sum([-5, -3, -1, -2]) == -1 ``` # Hints: - Consider how you can combine the results of the maximum subarrays from both halves and the cross-subarray that includes elements from both sides of the midpoint. - Remember to handle different cases, such as when the entire array is negative. # Performance Requirements: - The implementation should have a time complexity of O(n log n) due to the divide-and-conquer methodology.","solution":"def max_subarray_sum(nums: list[int]) -> int: def find_max_sum(nums, left, right): if left == right: return nums[left] mid = (left + right) // 2 left_sum = find_max_sum(nums, left, mid) right_sum = find_max_sum(nums, mid + 1, right) cross_sum = find_cross_sum(nums, left, mid, right) return max(left_sum, right_sum, cross_sum) def find_cross_sum(nums, left, mid, right): left_subsum = float(\'-inf\') current_sum = 0 for i in range(mid, left - 1, -1): current_sum += nums[i] if current_sum > left_subsum: left_subsum = current_sum right_subsum = float(\'-inf\') current_sum = 0 for i in range(mid + 1, right + 1): current_sum += nums[i] if current_sum > right_subsum: right_subsum = current_sum return left_subsum + right_subsum return find_max_sum(nums, 0, len(nums) - 1)"},{"question":"Additional Question # Power Set Calculation You are required to implement a function that calculates the power set of a given set. The power set of a set `S` is the set of all subsets of `S`, including the empty set and `S` itself. Ensure your function handles different types of inputs efficiently and correctly, returning the power set sorted in ascending order of subset length. Function Signature ```python def power_set(input_set: set) -> list: pass ``` Input and Output - **Input**: - `input_set` (`set`): A set of unique elements. - **Output**: - Returns a `list` of `sets`, representing the power set sorted by subset length. Constraints - The elements of the input set are unique and can be integers, strings, or a combination of different types. Requirements - Your function should handle sets with various types of elements. - The power set should be sorted in ascending order of subset length. Example Usage ```python >>> power_set({1, 2, 3}) [set(), {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3}] >>> power_set({\'a\', \'b\'}) [set(), {\'a\'}, {\'b\'}, {\'a\', \'b\'}] >>> power_set({42}) [set(), {42}] >>> power_set(set()) [set()] ``` Notes - Consider using recursive or iterative approaches to generate subsets. - Ensure the subsets are returned in the required sorted order. - Use appropriate data structures to handle the generation and storage of subsets.","solution":"from itertools import chain, combinations def power_set(input_set: set) -> list: Returns the power set of the given set, sorted in ascending order of subset length. # Convert the input set to a list to maintain the order of elements s = list(input_set) # Generate all combinations of the input set\'s elements power_set = list(chain.from_iterable(combinations(s, r) for r in range(len(s)+1))) # Convert each combination from tuple to set, and return the sorted list of sets return [set(subset) for subset in power_set]"},{"question":"# Prime Number Generation with Multithreading Write a function `generate_primes` that generates all prime numbers up to a given number `n`. To optimize the task, use multithreading to divide the work of checking for prime numbers among multiple threads. # Function Signature: ```python def generate_primes(n: int, num_threads: int) -> List[int]: ``` # Input: - `n`: An integer representing the upper limit (inclusive) up to which prime numbers should be generated. - `num_threads`: An integer specifying the number of threads to be used for the computation. # Output: - A list of integers containing all the prime numbers up to `n` in ascending order. # Example: ```python # Generate primes up to 30 using 3 threads primes = generate_primes(30, 3) print(primes) # Expected output: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] ``` # Constraints: - `n` will be a positive integer (1 leq n leq 10^6). - `num_threads` will be an integer (1 leq num_threads leq 100). # Notes: - Ensure that the primes are computed efficiently by distributing the workload among the specified number of threads. - Utilize Python\'s `threading` library to manage concurrent execution. - Implement a thread-safe solution to avoid race conditions and ensure correct results. # Hints: - Use the Sieve of Eratosthenes algorithm for finding prime numbers. - Divide the range 1 to `n` into equal segments that threads can work on independently. - Use a shared data structure to store the results safely across threads.","solution":"import threading from typing import List def is_prime(num: int) -> bool: if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def worker(start: int, end: int, primes: List[int], lock: threading.Lock): local_primes = [] for num in range(start, end + 1): if is_prime(num): local_primes.append(num) with lock: primes.extend(local_primes) def generate_primes(n: int, num_threads: int) -> List[int]: if n < 2: return [] step = (n // num_threads) + 1 threads = [] primes = [] lock = threading.Lock() for i in range(num_threads): start = i * step end = min((i + 1) * step - 1, n) if start > n: break thread = threading.Thread(target=worker, args=(start, end, primes, lock)) threads.append(thread) thread.start() for thread in threads: thread.join() return sorted(primes)"},{"question":"# Coding Assessment Question You are given two functions: 1. **is_balanced_tree(root: TreeNode) -> bool**: This function checks if a given binary tree is balanced. A binary tree is balanced if the height of its two subtrees never differs by more than one. 2. **longest_path(root: TreeNode) -> Tuple[int, List[int]]**: This function finds the longest path from the root to a leaf node in a binary tree and returns the length of this path along with the path itself as a list of node values. Your task is to extend the given functionality in the following ways: 1. Implement a function `deepest_nodes_sum(root: TreeNode) -> int` that takes in the root of a binary tree, finds all the nodes at the deepest level, and returns the sum of their values. 2. Ensure your function handles edge cases, such as an empty tree, properly. 3. Provide adequate tests for your solution. Function Signature: ```python def deepest_nodes_sum(root: TreeNode) -> int: pass ``` # Input: * `root`: The root node of a binary tree. # Output: * Returns an integer representing the sum of all the deepest nodes\' values in the binary tree. # Constraints: * The binary tree may contain negative values. * You can assume the existence of a `TreeNode` class with attributes `val`, `left`, and `right`. # Example: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Sample Tree for Testing # 1 # / # 2 3 # / / # 4 5 6 # / # 7 8 tree = TreeNode(1) tree.left = TreeNode(2) tree.right = TreeNode(3) tree.left.left = TreeNode(4) tree.left.left.left = TreeNode(7) tree.right.left = TreeNode(5) tree.right.right = TreeNode(6) tree.right.right.right = TreeNode(8) result = deepest_nodes_sum(tree) print(\\"Sum of Deepest Nodes:\\", result) ``` # Expected Outputs: 1. `result` should return the sum of the deepest nodes\' values. 2. For the example tree provided, the deepest nodes are `7` and `8`, so the expected output would be 15. Ensure to test your solution thoroughly and consider edge cases.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepest_nodes_sum(root: TreeNode) -> int: if not root: return 0 queue = deque([root]) while queue: level_sum = 0 level_size = len(queue) for _ in range(level_size): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum"},{"question":"# Task You are tasked with designing and implementing a function that balances a set of parentheses in a given string. The balance of parentheses is crucial in expressions to ensure their correct evaluation or functionality. # Problem Statement **Function Signature**: ```python def balance_parentheses(expression: str) -> str: \'\'\' Parameters: expression (str): A string consisting of characters which may include parentheses. Returns: str: A new string where parentheses are balanced by adding the minimum number of necessary parentheses. \'\'\' ``` Your task is to implement the `balance_parentheses` function which ensures that the given expression has balanced parentheses by adding the fewest number of parentheses. # Constraints * The input string `expression` has a length between 1 and 10000 containing only printable ASCII characters. * The function should respect the order of characters in the original string and only add necessary parentheses. # Examples Example 1: * Input: ```python expression = \\"a + (b * c) - (d / e\\" ``` * Output: ```python \\"a + (b * c) - (d / e)\\" ``` Example 2: * Input: ```python expression = \\"((a+b)\\" ``` * Output: ```python \\"((a+b))\\" ``` # Notes * Ensure your solution correctly identifies and balances nested parentheses. * The output should retain the original order of characters, only adding the necessary parentheses to achieve balance.","solution":"def balance_parentheses(expression: str) -> str: Balances the parentheses in the given expression by adding the minimum number of necessary parentheses. # To keep track of the open parentheses open_parentheses_count = 0 # List to build the corrected expression balanced_expression = [] # Iterate through each character in the input expression for char in expression: if char == \'(\': open_parentheses_count += 1 elif char == \')\': if open_parentheses_count > 0: open_parentheses_count -= 1 else: # An extra closing parenthesis is encountered balanced_expression.append(\'(\') balanced_expression.append(char) # Add the necessary number of closing parentheses at the end balanced_expression.extend(\')\' * open_parentheses_count) return \'\'.join(balanced_expression)"},{"question":"Problem Statement You are required to implement a function that calculates the length of the longest contiguous subsequence of even integers in a given list. # Requirements: 1. **Function Signature**: ```python def longest_even_subsequence_length(data: list) -> int: ``` 2. **Input**: * A list of integers (data) which can be empty or contain up to (10^6) elements. 3. **Output**: * An integer representing the length of the longest contiguous subsequence composed entirely of even numbers. 4. **Constraints**: * Aim for an efficient solution with a linear time complexity, (O(n)), where (n) is the length of the input list. * Consider edge cases such as empty lists, lists with no even numbers, and lists where all numbers are even. * Do **not** use any external libraries. # Example Cases: Example 1: * Input: `[1, 2, 4, 6, 1, 8, 10]` * Output: `3` *Explanation*: The longest contiguous sequence of even numbers is `[2, 4, 6]`, which has a length of 3. Example 2: * Input: `[1, 3, 5, 7]` * Output: `0` *Explanation*: There are no even numbers in the list. Example 3: * Input: `[8, 10, 12, 14, 16, 1]` * Output: `5` *Explanation*: The longest contiguous sequence is the entire list except the last element, with length of 5. Example 4: * Input: `[]` * Output: `0` # Edge Cases to Consider: 1. Empty list. 2. List with no even numbers. 3. List with only one even number. 4. List with all even numbers. 5. List with mixed even and odd numbers. 6. List with negative and positive integers. Implement the function `longest_even_subsequence_length` in Python to solve the problem.","solution":"def longest_even_subsequence_length(data: list) -> int: Calculate the length of the longest contiguous subsequence of even integers in the given list. Args: data (list): A list of integers. Returns: int: The length of the longest contiguous subsequence composed entirely of even numbers. max_length = 0 current_length = 0 for num in data: if num % 2 == 0: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"# Efficient List Flattening You are tasked with developing a function to flatten a nested list structure efficiently. Given a list that may contain other lists as elements, produce a flat list containing all the individual non-list elements. Task Implement a function `flatten_list` that performs the following: 1. **Recursive Flattening**: - Ensure the function can handle lists nested to any depth by using recursion. - The function should concatenate all elements in depth-first order. 2. **Element Validation**: - Check if each element is a list. If it is, apply the flattening recursively. - If the element is not a list, it should be added directly to the result. 3. **Maintaining Order**: - Ensure that elements are added to the result list in the same order they appear in the original input, respecting the nested structure. 4. **Edge Cases**: - Handle empty lists correctly without raising exceptions. - Manage lists containing other data types (e.g., integers, strings) without any issues. Example ```python def flatten_list(nested_list: list) -> list: Flattens a nested list. The function recursively traverses the nested list structure and returns a single flattened list with all the elements. Parameters: - nested_list: list : The nested list to be flattened. Returns: - list: A single flattened list with all elements from the nested structure. Example: >>> flatten_list([1, [2, [3, 4], 5], 6]) [1, 2, 3, 4, 5, 6] >>> flatten_list([[\'a\', [\'b\', \'c\'], \'d\'], \'e\']) [\'a\', \'b\', \'c\', \'d\', \'e\'] >>> flatten_list([]) [] pass ``` Additional Requirements - Write unit tests to validate your function, ensuring it handles arbitrary depths and various data types correctly. - Test for typical scenarios, deeply nested structures, and edge cases (like empty lists). Input and Output Formats - Input: `list` (a potentially nested list containing elements of various data types) - Output: `list` (a flat list containing all individual elements from the nested structure in order) --- This additional question aligns with the existing set by: - Maintaining a focus on list manipulation and recursion, a common theme in coding assessments. - Offering a comparable technical challenge that requires understanding of recursion and list operations. - Matching the length and specificity of the original sample question, ensuring clarity in the function\'s expectations and requirements.","solution":"def flatten_list(nested_list): Flattens a nested list. The function recursively traverses the nested list structure and returns a single flattened list with all the elements. Parameters: - nested_list: list : The nested list to be flattened. Returns: - list: A single flattened list with all elements from the nested structure. Example: >>> flatten_list([1, [2, [3, 4], 5], 6]) [1, 2, 3, 4, 5, 6] >>> flatten_list([[\'a\', [\'b\', \'c\'], \'d\'], \'e\']) [\'a\', \'b\', \'c\', \'d\', \'e\'] >>> flatten_list([]) [] flattened = [] for element in nested_list: if isinstance(element, list): flattened.extend(flatten_list(element)) else: flattened.append(element) return flattened"},{"question":"# Task Develop a modified version of the K-means clustering algorithm that includes an option for \\"soft\\" clustering using a fuzzy membership approach. In soft clustering, data points can belong to multiple clusters to varying degrees. # Problem Statement You need to implement a class `FuzzyKMeans` that extends the traditional `KMeans` algorithm to support fuzzy clustering. The fuzzy clustering algorithm assigns membership values to each data point for every cluster, indicating the degree of belonging. # Requirements: 1. Modify the `fit` method to compute membership values and cluster centers using fuzzy logic. 2. Implement a `predict` method to determine the fuzzy membership of new data points. 3. Ensure that the `fit` method can support both hard and fuzzy clustering based on a parameter. 4. Provide a method to visualize clusters along with their membership scores. # Class Signature ```python class FuzzyKMeans(KMeans): def __init__(self, n_clusters: int, m: float = 2.0) -> None: # Your code here def fit(self, x_train: np.ndarray, fuzzy: bool = True) -> None: # Your code here def predict(self, x_test: np.ndarray) -> np.ndarray: # Your code here def plot(self, x_data: np.ndarray) -> None: # Your code here ``` # Input and Output - `FuzzyKMeans(n_clusters: int, m: float = 2.0)`: - **n_clusters**: the number of clusters, must be a positive integer. - **m**: fuzziness coefficient, must be greater than 1; default is 2. - Raises ValueError if n_clusters <= 0 or m <= 1. - `fit(x_train: np.ndarray, fuzzy: bool = True)`: - **x_train**: input data for model training. - **fuzzy**: boolean to indicate if fuzzy clustering is enabled; default is True. - Fit the model using fuzzy K-means clustering when `fuzzy` is True, otherwise use hard K-means. - `predict(x_test: np.ndarray) -> np.ndarray`: - **x_test**: input data for prediction. - Returns the membership values of new data points with respect to each cluster when `fuzzy` is True, otherwise returns cluster labels. - `plot(x_data: np.ndarray) -> None`: - **x_data**: data points for visualization. - Plots the data points colored by their cluster membership scores (using transparency to indicate membership strength). # Constraints - Number of clusters should be a positive integer. - The fuzziness coefficient (m) should be greater than 1. - Input datasets for both training and testing should be two-dimensional numpy arrays. # Performance Requirements - The `fit` method should perform efficiently for datasets with up to 10⁶ data points. - The algorithm should effectively assign varying membership values to data points to reflect their partial belonging to clusters. Implement the classes and methods as described in the inputs and outputs for a comprehensive assessment and effective fuzzy clustering.","solution":"import numpy as np import matplotlib.pyplot as plt from sklearn.base import BaseEstimator, ClusterMixin class FuzzyKMeans(BaseEstimator, ClusterMixin): def __init__(self, n_clusters: int, m: float = 2.0): if n_clusters <= 0: raise ValueError(\\"Number of clusters must be a positive integer.\\") if m <= 1: raise ValueError(\\"Fuzziness coefficient must be greater than 1.\\") self.n_clusters = n_clusters self.m = m self.centers = None self.u = None # Membership matrix def _initialize_centers(self, X): np.random.seed(42) random_indices = np.random.choice(X.shape[0], self.n_clusters, replace=False) self.centers = X[random_indices] def _update_membership(self, X): distances = np.zeros((X.shape[0], self.n_clusters)) for i, center in enumerate(self.centers): distances[:, i] = np.linalg.norm(X - center, axis=1) with np.errstate(divide=\'ignore\'): inv_distances = 1.0 / distances inv_distances[inv_distances == np.inf] = 1000 tempU = np.power(inv_distances, 2 / (self.m - 1)) self.u = tempU / np.sum(tempU, axis=1, keepdims=True) def _update_centers(self, X): um = self.u ** self.m self.centers = (um.T @ X) / np.sum(um.T, axis=1, keepdims=True) def fit(self, X: np.ndarray, fuzzy: bool = True) -> \'FuzzyKMeans\': self._initialize_centers(X) for _ in range(100): # max iterations prev_centers = self.centers.copy() self._update_membership(X) self._update_centers(X) if np.allclose(prev_centers, self.centers): break return self def predict(self, X: np.ndarray) -> np.ndarray: if self.u is None: raise ValueError(\\"Model has not been fitted yet!\\") distances = np.zeros((X.shape[0], self.n_clusters)) for i, center in enumerate(self.centers): distances[:, i] = np.linalg.norm(X - center, axis=1) with np.errstate(divide=\'ignore\'): inv_distances = 1.0 / distances inv_distances[inv_distances == np.inf] = 1000 tempU = np.power(inv_distances, 2 / (self.m - 1)) u_predict = tempU / np.sum(tempU, axis=1, keepdims=True) return u_predict def plot(self, X: np.ndarray) -> None: if self.u is None: raise ValueError(\\"Model has not been fitted yet!\\") plt.figure() for i in range(self.n_clusters): members = self.u[:, i] plt.scatter(X[:, 0], X[:, 1], c=members, cmap=\'viridis\', label=f\'Cluster {i+1}\', alpha=0.5) plt.scatter(self.centers[:, 0], self.centers[:, 1], marker=\'x\', c=\'red\', s=200, label=\'Centers\') plt.legend() plt.title(\'Fuzzy K-Means Clustering\') plt.show()"},{"question":"# Task Description Create a function that finds the first non-repeating character in a string and returns it. If there is no non-repeating character, return an empty string. # Function Signature ```python def first_non_repeating_character(s: str) -> str: ``` # Input * A single string `s` containing only lowercase letters. # Output * A single character which is the first non-repeating character in the string. * If there is no such character, return an empty string. # Constraints * `1 <= len(s) <= 1000` # Example ```python assert first_non_repeating_character(\\"leetcode\\") == \\"l\\" assert first_non_repeating_character(\\"loveleetcode\\") == \\"v\\" assert first_non_repeating_character(\\"aabb\\") == \\"\\" assert first_non_repeating_character(\\"racecar\\") == \\"e\\" assert first_non_repeating_character(\\"abcda\\") == \\"b\\" ``` # Explanation 1. The function `first_non_repeating_character` considers the order of characters in the string. 2. It traverses the string to identify the first character that does not repeat. 3. If every character repeats at least once, return an empty string. 4. The function should handle the upper constraint efficiently. This function should iterate through the string in a way that it ensures the non-repeating character is found in linear time complexity where possible. Use auxiliary data structures if needed to keep track of character counts.","solution":"def first_non_repeating_character(s: str) -> str: Find the first non-repeating character in the string s. If there is no such character, return an empty string. from collections import Counter # Count the occurrences of each character char_count = Counter(s) # Find and return the first non-repeating character for char in s: if char_count[char] == 1: return char return \\"\\""},{"question":"# Coding Assessment Question You are tasked with implementing a binary tree class that supports fundamental tree operations. The class should include methods for inserting values, searching for a value, calculating the height of the tree, finding the minimum and maximum values, traversing the tree in pre-order, in-order, and post-order, and checking if the tree is a valid binary search tree. **Objective**: Implement the BinaryTree class with the following specifications. # BinaryTree Class Specifications: 1. **Node Class**: ```python class Node: def __init__(self, value: int) -> None: self.value = value self.left = None self.right = None ``` 2. **BinaryTree Class**: - `__init__(self) -> None`: Initializes an empty binary tree. - `insert(self, value: int) -> None`: Inserts a new value into the binary tree. - `search(self, value: int) -> bool`: Searches for a value in the binary tree and returns True if the value exists, otherwise False. - `height(self) -> int`: Returns the height of the binary tree. - `min_value(self) -> int`: Returns the minimum value stored in the binary tree. - `max_value(self) -> int`: Returns the maximum value stored in the binary tree. - `pre_order_traversal(self) -> List[int]`: Returns a list of values from the pre-order traversal of the binary tree. - `in_order_traversal(self) -> List[int]`: Returns a list of values from the in-order traversal of the binary tree. - `post_order_traversal(self) -> List[int]`: Returns a list of values from the post-order traversal of the binary tree. - `is_bst(self) -> bool`: Checks if the binary tree is a valid binary search tree and returns True if it is, otherwise False. # Input and Output Formats: - Methods should raise `ValueError` for invalid input values and provide descriptive error messages. - Tree traversals should return lists of integers. - Ensure the `is_bst` method properly validates the binary search tree structure. # Constraints: - Values within the tree will be unique integers. - The binary tree will have at most 1000 nodes for performance considerations. # Example Usage: ```python # Creating a binary tree tree = BinaryTree() # Inserting values tree.insert(15) tree.insert(10) tree.insert(20) tree.insert(8) tree.insert(12) tree.insert(17) tree.insert(25) # Searching for a value exists = tree.search(10) # True # Calculating height tree_height = tree.height() # 2 # Finding minimum and maximum values min_val = tree.min_value() # 8 max_val = tree.max_value() # 25 # Tree traversals pre_order = tree.pre_order_traversal() # [15, 10, 8, 12, 20, 17, 25] in_order = tree.in_order_traversal() # [8, 10, 12, 15, 17, 20, 25] post_order = tree.post_order_traversal() # [8, 12, 10, 17, 25, 20, 15] # Check if the tree is a valid BST is_valid_bst = tree.is_bst() # True ``` **Your task:** Implement the `BinaryTree` class as per the above specifications.","solution":"class Node: def __init__(self, value: int) -> None: self.value = value self.left = None self.right = None class BinaryTree: def __init__(self) -> None: self.root = None def insert(self, value: int) -> None: if self.root is None: self.root = Node(value) else: self._insert_rec(self.root, value) def _insert_rec(self, node: Node, value: int) -> None: if value < node.value: if node.left is None: node.left = Node(value) else: self._insert_rec(node.left, value) else: if node.right is None: node.right = Node(value) else: self._insert_rec(node.right, value) def search(self, value: int) -> bool: return self._search_rec(self.root, value) def _search_rec(self, node: Node, value: int) -> bool: if node is None: return False if value == node.value: return True elif value < node.value: return self._search_rec(node.left, value) else: return self._search_rec(node.right, value) def height(self) -> int: return self._height_rec(self.root) def _height_rec(self, node: Node) -> int: if node is None: return -1 left_height = self._height_rec(node.left) right_height = self._height_rec(node.right) return max(left_height, right_height) + 1 def min_value(self) -> int: if self.root is None: raise ValueError(\\"Tree is empty\\") return self._min_value_rec(self.root) def _min_value_rec(self, node: Node) -> int: current = node while current.left is not None: current = current.left return current.value def max_value(self) -> int: if self.root is None: raise ValueError(\\"Tree is empty\\") return self._max_value_rec(self.root) def _max_value_rec(self, node: Node) -> int: current = node while current.right is not None: current = current.right return current.value def pre_order_traversal(self) -> list: result = [] self._pre_order_rec(self.root, result) return result def _pre_order_rec(self, node: Node, result: list) -> None: if node is not None: result.append(node.value) self._pre_order_rec(node.left, result) self._pre_order_rec(node.right, result) def in_order_traversal(self) -> list: result = [] self._in_order_rec(self.root, result) return result def _in_order_rec(self, node: Node, result: list) -> None: if node is not None: self._in_order_rec(node.left, result) result.append(node.value) self._in_order_rec(node.right, result) def post_order_traversal(self) -> list: result = [] self._post_order_rec(self.root, result) return result def _post_order_rec(self, node: Node, result: list) -> None: if node is not None: self._post_order_rec(node.left, result) self._post_order_rec(node.right, result) result.append(node.value) def is_bst(self) -> bool: return self._is_bst_rec(self.root, float(\'-inf\'), float(\'inf\')) def _is_bst_rec(self, node: Node, min_val: float, max_val: float) -> bool: if node is None: return True if not (min_val < node.value < max_val): return False return (self._is_bst_rec(node.left, min_val, node.value) and self._is_bst_rec(node.right, node.value, max_val))"},{"question":"# Problem Statement In a grid-based game, a player moves from the top-left corner of an m x n grid to the bottom-right corner. At each step, the player can only move either right or down. Write a function, `unique_paths(m: int, n: int) -> int`, that calculates the number of unique paths from the top-left corner to the bottom-right corner of the grid. # Function Signature ```python def unique_paths(m: int, n: int) -> int: ``` # Input * `m` (int): The number of rows in the grid (1 <= m <= 100). * `n` (int): The number of columns in the grid (1 <= n <= 100). # Output * The function should return an integer representing the number of unique paths from the top-left to the bottom-right corner of the grid. # Constraints * The input `m` and `n` will be positive integers. * You can assume that 1 <= m, n <= 100 for reasonable execution time. # Example ```python >>> unique_paths(3, 7) 28 >>> unique_paths(3, 2) 3 >>> unique_paths(1, 1) 1 >>> unique_paths(2, 2) 2 ``` # Notes - The function should handle edge cases where `m` or `n` is equal to 1, returning 1 in such cases as there is only one path possible. - The function can leverage combinatorial mathematics to calculate the number of paths efficiently. # Further Explanation * Use either a dynamic programming approach or a combinatorial formula to derive the number of unique paths. - For instance, dynamic programming can build up a solution where paths to each cell are the sum of paths to the cell directly above it and the cell to its left.","solution":"def unique_paths(m: int, n: int) -> int: Returns the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid. # Create a 2D array `dp` where `dp[i][j]` represents the number of ways to reach cell (i, j) dp = [[0] * n for _ in range(m)] # Initialize the top row and left column to 1 for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 # Fill the rest of the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"# Processing Weather Data You are tasked with creating a function to fetch weather data for a specified city from a weather API and process the temperature data to determine the daily average temperature over a given period. Function Signature: ```python def fetch_city_weather(city: str, days: int) -> List[float]: pass ``` Requirements: 1. **Fetch Data**: Use the provided city name and days to fetch weather data from a weather API, such as OpenWeatherMap API. 2. **Extract Temperature**: Parse the JSON response to extract daily temperature data for the given number of days. 3. **Calculate Averages**: Calculate the average temperature for each day. 4. **Return Data**: Return the list of average temperatures for the specified period. Constraints: - Assume the API key is provided and valid. - The function should handle potential errors such as: - HTTP request failures. - Invalid city names. - Insufficient data availability for the specified number of days. Input and Output Format: - **Input**: - `city` - A string representing the name of the city. - `days` - An integer representing the number of days to fetch weather data for. - **Output**: - A list of floats representing the average temperature for each day over the given period. Example ```python city = \\"London\\" days = 3 result = fetch_city_weather(city, days) print(result) # Possible output given a response from the API # [15.5, 16.0, 14.5] ``` Additional Notes: - Ensure robust error handling and consider edge cases where the city name might be misspelled or data is unavailable for the requested period. - Optimize for efficient fetching and processing of data. - You may assume the temperatures are given in Celsius.","solution":"import requests from typing import List def fetch_city_weather(city: str, days: int) -> List[float]: Fetches the daily average temperature for a given city over a specified number of days. Parameters: - city (str): The name of the city. - days (int): The number of days to fetch weather data for. Returns: - List[float]: A list of average temperatures for each day. API_KEY = \'your_api_key_here\' # Replace with your actual API key URL = f\\"http://api.openweathermap.org/data/2.5/forecast/daily?q={city}&cnt={days}&appid={API_KEY}&units=metric\\" try: response = requests.get(URL) response.raise_for_status() # Raise an HTTPError if the HTTP request returned an unsuccessful status code data = response.json() if \'list\' not in data: raise ValueError(\\"Invalid response structure.\\") temperatures = [] for day in data[\'list\']: # Assuming that each day has a \'temp\' field which is a dictionary containing \'day\' temperature avg_temp = day[\'temp\'][\'day\'] temperatures.append(avg_temp) return temperatures except requests.exceptions.RequestException as e: print(f\\"Request failed: {e}\\") return [] except ValueError as ve: print(f\\"Error processing data: {ve}\\") return []"},{"question":"# Coding Assessment Question Context In this exercise, you will work with strings and devise an algorithm to discover the longest anagram substring between two given strings. An anagram is a word or phrase formed by rearranging the letters of another, using all the original letters exactly once. Problem Statement Write a function `longest_anagram_substring(s1: str, s2: str) -> str` that takes two strings as input and returns the longest substring which is an anagram present in both strings. If there are multiple substrings with the same length, return the lexicographically smallest one. If no anagram substring exists, return an empty string. Constraints * The function parameters `s1` and `s2` are non-empty strings consisting of lowercase English letters. * The length of each string will not exceed `1000`. Input * Two strings `s1` and `s2`. Output * The string value of the longest anagram substring present in both input strings. Examples * `longest_anagram_substring(\\"listen\\", \\"silent\\")` should return `\\"listen\\"` since \\"listen\\" and \\"silent\\" are anagrams. * `longest_anagram_substring(\\"abc\\", \\"def\\")` should return `\\"\\"` since no common anagram substrings exist. * `longest_anagram_substring(\\"abcdef\\", \\"fedcba\\")` should return `\\"abcdef\\"` or `\\"fedcba\\"` which are anagrams. Function Signature ```python def longest_anagram_substring(s1: str, s2: str) -> str: pass ``` Requirements * Implement a solution that efficiently finds the longest anagram substring. * Consider edge cases such as no common substrings or multiple substrings with the same length. * Optimize your approach for large input sizes while considering runtime complexity. * Include comprehensive test cases to ensure the correctness of your implementation.","solution":"from collections import Counter def is_anagram(s1, s2): return Counter(s1) == Counter(s2) def longest_anagram_substring(s1: str, s2: str) -> str: max_len = 0 longest_anagram = \\"\\" n1, n2 = len(s1), len(s2) for length in range(1, min(n1, n2) + 1): for i in range(n1 - length + 1): substr1 = s1[i:i+length] for j in range(n2 - length + 1): substr2 = s2[j:j+length] if is_anagram(substr1, substr2): if length > max_len or (length == max_len and substr1 < longest_anagram): max_len = length longest_anagram = substr1 return longest_anagram"},{"question":"# Rotate Array You are tasked with writing a function that rotates the elements of a list of integers to the right by a given number of steps. The rotation is circular, meaning that elements shifted beyond the end of the list wrap around to the beginning. # Function Signature ```python def rotate_array(nums: List[int], k: int) -> List[int]: ``` # Input - `nums` (List[int]): A list of integers to rotate. - `k` (int): The number of steps to rotate the list. If `k` is greater than the length of the list, it should wrap around accordingly. # Output - Returns a new list representing the rotated array. # Constraints - The number of elements in `nums` is between 1 and 1000. - Each element in `nums` is between `-1000` and `1000`. - `k` is a non-negative integer. # Examples ```python assert rotate_array([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] assert rotate_array([0, 0, 0], 1) == [0, 0, 0] assert rotate_array([10, 20, 30, 40], 4) == [10, 20, 30, 40] assert rotate_array([1, 2, 3], 7) == [3, 1, 2] ``` # Instructions 1. Implement the `rotate_array()` function. 2. Ensure your implementation is efficient and handles edge cases as described. 3. Verify your solution using the provided examples and any additional cases you consider relevant.","solution":"from typing import List def rotate_array(nums: List[int], k: int) -> List[int]: Rotates the elements of the list nums to the right by k steps. n = len(nums) k = k % n # Adjust k if it\'s greater than the length of nums return nums[-k:] + nums[:-k]"},{"question":"# Task: Generate and Validate ISBN Numbers Background You have been assigned to create a utility that generates and validates International Standard Book Numbers (ISBNs). The provided ISBN code snippet illustrates the structure of ISBN-10 and ISBN-13. Your task will be to validate provided ISBN numbers and generate new valid ISBN numbers based on given book information. Requirements 1. **Input**: * Book title (string) * Book author (string) * ISBN (string; either ISBN-10 or ISBN-13 format) * Example: `(\\"Example Book Title\\", \\"Author Name\\", \\"123456789X\\")` 2. **Output**: * A tuple containing: * A boolean indicating if the provided ISBN is valid. * A newly generated valid ISBN-13 for the book. * Example: `(True, \'9781234567897\')` 3. **Constraints**: * ISBN-10 is a 10-digit number where the last digit can be a digit from 0-9 or an \'X\', representing the number 10. * ISBN-13 is a 13-digit number, where the first three digits must be \'978\' or \'979\'. * Validate ISBN-10 using the formula: `sum((10 - i) * int(digit) for i, digit in enumerate(isbn[:-1])) + 10 if last_digit == \'X\' else int(last_digit) == 0` * Validate ISBN-13 using the formula: `sum((1 if i % 2 == 0 else 3) * int(digit) for i, digit in enumerate(isbn)) % 10 == 0` * Generate the ISBN-13 by concatenating \'978\' or \'979\' with a 9-digit unique identifier derived from the book\'s title and author. * Handle exceptions gracefully and ensure they do not halt the generating and validating process. * Use a consistent hashing mechanism to derive the 9-digit unique identifier part of the ISBN-13. 4. **Performance**: * The validating and generating process should be efficient and run within a reasonable time for common inputs. Function Signature ```python def validate_and_generate_isbn(title: str, author: str, isbn: str) -> (bool, str): pass ``` Example Usage ```python valid, new_isbn = validate_and_generate_isbn(\\"Example Book Title\\", \\"Author Name\\", \\"123456789X\\") print(f\\"Provided ISBN valid: {valid}\\") print(f\\"Generated ISBN-13: {new_isbn}\\") ```","solution":"import re def validate_and_generate_isbn(title: str, author: str, isbn: str): def is_valid_isbn10(isbn): if not re.match(r\'^d{9}[dX]\', isbn): return False digits = list(isbn) checksum = sum((10 - i) * (10 if digit == \'X\' else int(digit)) for i, digit in enumerate(digits)) return checksum % 11 == 0 def is_valid_isbn13(isbn): if not re.match(r\'^d{13}\', isbn): return False checksum = sum((1 if i % 2 == 0 else 3) * int(digit) for i, digit in enumerate(isbn)) return checksum % 10 == 0 def generate_isbn13(title, author): import hashlib hash_input = title + author hash_output = hashlib.md5(hash_input.encode()).hexdigest() isbn_number = \'978\' + \'\'.join(str((ord(char) % 10)) for char in hash_output[:9]) checksum = sum((1 if i % 2 == 0 else 3) * int(digit) for i, digit in enumerate(isbn_number)) check_digit = (10 - (checksum % 10)) % 10 return isbn_number + str(check_digit) is_valid = False if len(isbn) == 10: is_valid = is_valid_isbn10(isbn) elif len(isbn) == 13: is_valid = is_valid_isbn13(isbn) new_isbn = generate_isbn13(title, author) return is_valid, new_isbn"},{"question":"# Reversing a Substring in Place You are tasked with implementing a function that reverses any substring of a given string specified by the starting and ending indices. Problem Statement: Implement a function that takes a string `s` and two integers representing the starting and ending indices, and returns a new string with the specified substring reversed. The indices are inclusive. Function Signature: ```python def reverse_substring_in_place(s: str, start: int, end: int) -> str: pass ``` Input: * `s`: A string containing any ASCII characters. * `start`: An integer, the starting index of the substring (0-based). * `end`: An integer, the ending index of the substring (0-based). Output: * Returns a new string with the specified substring reversed in place. Constraints: * The string `s` has length (0 leq |s| leq 10^6). * (0 leq start leq end < |s|) * Both `start` and `end` are valid indices within the string `s`. Guidelines: 1. If the input string is empty, return it as is. 2. Ensure that the specified substring is reversed, but the rest of the string remains unchanged. 3. Be mindful of edge cases, such as `start` and `end` pointing to the same index or to the first/last characters. Example: ```python >>> reverse_substring_in_place(\\"abcdef\\", 1, 4) \'aedcbf\' >>> reverse_substring_in_place(\\"hello world\\", 0, 4) \'olleh world\' >>> reverse_substring_in_place(\\"data structures\\", 5, 14) \'data sertcurts\' ```","solution":"def reverse_substring_in_place(s: str, start: int, end: int) -> str: Returns a new string with the substring from start to end reversed. # Extract the substring to be reversed substring = s[start:end + 1] # Reverse the extracted substring reversed_substring = substring[::-1] # Concatenate the parts to form the final string return s[:start] + reversed_substring + s[end + 1:]"},{"question":"# Problem Description You are tasked to create a function that simulates a basic file system with directory creation and path resolution capabilities. The goal is to ensure proper creation of directories and resolution of absolute and relative paths. # Objective **Implement the function** `file_system` **that meets the following requirements**: - The function should manage the creation of directories in a simulated file system. - It should be able to resolve absolute and relative paths. - Able to track the current working directory and perform operations relative to it. # Function Signature ```python def file_system(operations: List[Dict[str, Union[str, List[str]]]]) -> List[str]: pass ``` # Input - `operations` (List[Dict[str, Union[str, List[str]]]]): A list of dictionaries, each representing an operation. Each dictionary has the following keys: - `\'operation\'` (str): The type of operation, which can be \'mkdir\', \'cd\', or \'pwd\'. - `\'path\'` (str): A string representing the path for \'mkdir\' and \'cd\' operations. This can be absolute or relative. - Assume the root directory is represented as \'/\' - Resolution of \'..\' should revert to the parent directory, and \'.\' should represent the current directory. # Output - The function should return a list of current working directories after each \'pwd\' operation. # Constraints - The paths contain only alphabetic characters and slashes. - Assume no file names (only directories). - The initial current working directory is the root (\'/\'). # Example ```python operations = [ {\'operation\': \'mkdir\', \'path\': \'/a/b\'}, {\'operation\': \'pwd\'}, {\'operation\': \'cd\', \'path\': \'a/b\'}, {\'operation\': \'mkdir\', \'path\': \'c/d\'}, {\'operation\': \'pwd\'}, {\'operation\': \'cd\', \'path\': \'../../\'}, {\'operation\': \'pwd\'} ] print(file_system(operations)) # Expected Output: [\'/\', \'/a/b\', \'/\'] ``` # Hints - Think about how directory paths can be normalized and how operations impact the current directory state. - Validate that directories can be created in non-existent paths correctly. - Handle edge cases for path resolution, especially for \'..\' and \'.\'. This question aims to test the ability to manage and manipulate file system paths, ensuring accurate tracking of directory state and path resolutions.","solution":"def file_system(operations): This function simulates a basic file system with directory creation and path resolution capabilities. file_structure = {\'/\': {}} current_path = [\'/\'] def normalize_path(path): new_path = [] for part in path.split(\'/\'): if part == \'\' or part == \'.\': continue elif part == \'..\': if new_path: new_path.pop() else: new_path.append(part) return new_path def traverse_to(path): directory = file_structure[\'/\'] for part in path: if part not in directory: directory[part] = {} directory = directory[part] return directory results = [] for op in operations: operation = op[\'operation\'] if operation == \'mkdir\': path = op[\'path\'] if path.startswith(\'/\'): abs_path = normalize_path(path) else: abs_path = normalize_path(\'/\'.join(current_path + [\'/\'] + [path])) traverse_to(abs_path) elif operation == \'cd\': path = op[\'path\'] if path.startswith(\'/\'): abs_path = normalize_path(path) else: abs_path = normalize_path(\'/\'.join(current_path[1:] + [path])) current_path = [\'/\'] + abs_path elif operation == \'pwd\': results.append(\'/\' + \'/\'.join(current_path[1:]) if current_path != [\'/\'] else \'/\') return results"},{"question":"# Coding Question: Implement Text Anagram Checker **Scenario**: You are tasked with developing a utility that checks if two given input strings are anagrams of each other, ignoring any non-alphabetic characters and considering case-insensitivity. An anagram is a rearrangement of the letters in one word to form another word. **Function Signature**: ```python def are_anagrams(text1: str, text2: str) -> bool: pass ``` **Expected Input and Output**: * **Input**: - `text1` (str): A string that may contain any printable characters. - `text2` (str): A string that may contain any printable characters. * **Output**: - A boolean: `True` if the strings are anagrams, otherwise `False`. **Example**: ```python >>> text1 = \\"Listen\\" >>> text2 = \\"Silent\\" >>> result = are_anagrams(text1, text2) >>> print(result) True >>> text1 = \\"The eyes\\" >>> text2 = \\"They see!\\" >>> result = are_anagrams(text1, text2) >>> print(result) True >>> text1 = \\"Hello\\" >>> text2 = \\"Ole oh\\" >>> result = are_anagrams(text1, text2) >>> print(result) False ``` **Constraints**: * The input strings `text1` and `text2` will have a length of at most 10^5 characters each. * Non-alphabetic characters should be ignored, and comparisons should be case-insensitive. # Requirements: 1. Clean the input strings by removing non-alphabetic characters and converting to lowercase. 2. Check if the cleaned versions of both strings are anagrams. 3. Return `True` if the cleaned strings are anagrams, otherwise return `False`. # Tips: * Consider using `collections.Counter` or sorted lists to compare the frequency of characters. * Remove non-alphabetic characters effectively and convert to lowercase for accurate comparison.","solution":"def are_anagrams(text1: str, text2: str) -> bool: Checks if two input strings are anagrams of each other, ignoring non-alphabetic characters and considering case-insensitivity. Args: - text1 (str): The first input string. - text2 (str): The second input string. Returns: - bool: True if the cleaned strings are anagrams, otherwise False. import re # Function to clean the input text def clean_text(text: str) -> str: # Remove non-alphabetic characters and convert to lowercase return re.sub(\'[^a-z]\', \'\', text.lower()) # Clean the input texts cleaned_text1 = clean_text(text1) cleaned_text2 = clean_text(text2) # Check if the sorted characters of both cleaned texts are equal return sorted(cleaned_text1) == sorted(cleaned_text2)"},{"question":"# Coding Assessment Question: Context: In a warehouse management system, it\'s vital to keep track of inventory and reorder items when their quantities fall below a certain threshold. This helps ensure that items are always available when needed and prevents stockouts. The task is to write a function that takes the current inventory data, checks which items need to be reordered, and generates a list of those items along with the quantities required to reach a predefined threshold. Task: Write a Python function named `generate_reorder_list` that processes the current inventory and generates a reorder list. The function should take an inventory dictionary, a minimum threshold for each item, and return a list of items that need to be reordered, along with the quantities required to meet the threshold. Function Signature: ```python def generate_reorder_list(inventory: dict, threshold: int) -> list: ``` Inputs: * **inventory**: A dictionary where the keys are item names (strings) and the values are their current quantities (integers). * **threshold**: An integer representing the minimum threshold quantity for each item. Output: * Returns a list of tuples, where each tuple contains the item name (string) and the quantity that needs to be reordered (integer). Constraints: * **Threshold Constraint**: The threshold value is always a positive integer. * **Non-Negative Quantities**: The inventory quantities are always non-negative integers. * **Reorder Quantity Calculation**: The reorder quantity for each item is calculated as the difference between the threshold and the current quantity. Example: ```python sample_inventory = { \\"item_1\\": 5, \\"item_2\\": 2, \\"item_3\\": 12, \\"item_4\\": 0 } reorder_threshold = 10 print(generate_reorder_list(sample_inventory, reorder_threshold)) # Expected output: [(\'item_1\', 5), (\'item_2\', 8), (\'item_4\', 10)] ``` After running the function, the output indicates that \\"item_1\\" needs 5 more items, \\"item_2\\" needs 8 more items, and \\"item_4\\" needs 10 more items to reach the threshold of 10. The \\"item_3\\" is already above the threshold, so it is not included in the reorder list.","solution":"def generate_reorder_list(inventory: dict, threshold: int) -> list: Generates a reorder list based on the current inventory and threshold. :param inventory: Dictionary with item names as keys and their current quantity as values. :param threshold: Minimum threshold quantity for each item. :return: List of tuples containing item names and quantities to be reordered. reorder_list = [] for item, quantity in inventory.items(): if quantity < threshold: reorder_list.append((item, threshold - quantity)) return reorder_list"},{"question":"# Pivot Index Implement the function `pivot_index(nums: List[int]) -> int` which finds the pivot index of the given list of integers. The pivot index is the index where the sum of all the numbers to the left of the index is equal to the sum of all the numbers to the right of the index. If no such index exists, return -1. If there are multiple pivot indices, return the left-most one. Input - A list of integers `nums`. Output - An integer representing the pivot index or -1 if no pivot index is found. Constraints - The input list will have at least one element and at most 10^4 elements. - The elements of the list will be in the range [-10^4, 10^4]. Performance Requirements - Target an optimal time complexity of O(n). Implementation ```python def pivot_index(nums: List[int]) -> int: Find the pivot index where the sum of the numbers to the left is equal to the sum of the numbers to the right. Example: >>> pivot_index([1, 7, 3, 6, 5, 6]) 3 >>> pivot_index([1, 2, 3]) -1 >>> pivot_index([-1, -1, -1, -1, -1, 0]) 2 >>> pivot_index([2, 1, -1]) 0 total_sum = sum(nums) left_sum = 0 for idx, num in enumerate(nums): if left_sum == (total_sum - left_sum - num): return idx left_sum += num return -1 if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` Write the implementation for the `pivot_index` function as specified, ensuring it meets the problem description and constraints. Handle edge scenarios effectively and aim for optimal performance.","solution":"from typing import List def pivot_index(nums: List[int]) -> int: Find the pivot index where the sum of the numbers to the left is equal to the sum of the numbers to the right. total_sum = sum(nums) left_sum = 0 for idx, num in enumerate(nums): # Check if left_sum is equal to the sum on the right side if left_sum == (total_sum - left_sum - num): return idx left_sum += num return -1"},{"question":"# Problem Statement You are tasked with implementing a function that checks if a string is an interleaving of two other strings. An interleaving of two strings `A` and `B` is a string that contains all the characters of `A` and `B`, and the order of all characters in `A` and `B` should be preserved. Function Signature ```python def is_interleave(s1: str, s2: str, s3: str) -> bool: ``` Input * `s1` (str): The first input string. (0 <= len(s1) <= 100) * `s2` (str): The second input string. (0 <= len(s2) <= 100) * `s3` (str): The string to check as interleaving of `s1` and `s2`. (0 <= len(s3) <= 200) Output * `bool`: Return `True` if `s3` is an interleaving of `s1` and `s2`, otherwise return `False`. Constraints 1. The inputs consist of lowercase English letters only. 2. The length of `s3` will always be equal to `len(s1) + len(s2)`. # Example ```python # Example 1 s1 = \\"aabcc\\" s2 = \\"dbbca\\" s3 = \\"aadbbcbcac\\" assert is_interleave(s1, s2, s3) == True # Example 2 s1 = \\"aabcc\\" s2 = \\"dbbca\\" s3 = \\"aadbbbaccc\\" assert is_interleave(s1, s2, s3) == False # Example 3 s1 = \\"\\" s2 = \\"\\" s3 = \\"\\" assert is_interleave(s1, s2, s3) == True # Example 4 s1 = \\"abc\\" s2 = \\"def\\" s3 = \\"adbcef\\" assert is_interleave(s1, s2, s3) == True # Example 5 s1 = \\"a\\" s2 = \\"\\" s3 = \\"a\\" assert is_interleave(s1, s2, s3) == True ``` Additional Notes * You can solve this problem using dynamic programming by creating a 2D table to keep track of which substrings of `s1` and `s2` can form the corresponding substring of `s3`. * Consider the cases where any of the strings `s1` or `s2` may be empty.","solution":"def is_interleave(s1: str, s2: str, s3: str) -> bool: # If the lengths don\'t add up, it can\'t be an interleaving if len(s3) != len(s1) + len(s2): return False # Create a 2D DP array dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)] # Base case: empty s1 and s2 results in an empty s3 dp[0][0] = True # Fill the dp array for i in range(len(s1) + 1): for j in range(len(s2) + 1): if i > 0: dp[i][j] = dp[i][j] or (dp[i-1][j] and s1[i-1] == s3[i+j-1]) if j > 0: dp[i][j] = dp[i][j] or (dp[i][j-1] and s2[j-1] == s3[i+j-1]) return dp[len(s1)][len(s2)]"},{"question":"# Minimum Difference in Sorted Array # Objective Your task is to implement a function to find the pair of adjacent elements that has the smallest absolute difference in a sorted list of integers. Additionally, adapt the function to work on a list of strings, where the difference between two strings is defined as the number of differing characters at corresponding positions between the two strings. # Problem Description Part 1: Minimum Difference for Sorted Integers Implement the `min_diff_sorted_integers` function that takes a sorted list of integers and returns the pair of adjacent elements with the smallest absolute difference. Part 2: Minimum Difference for Sorted Strings Using your `min_diff_sorted_integers` implementation as a guideline, create a function `min_diff_sorted_strings` that takes a sorted list of strings of equal length and finds the pair of adjacent strings that have the smallest difference, where the difference between two strings is defined as the number of differing characters at corresponding positions. # Function Signatures ```python def min_diff_sorted_integers(sorted_integers: List[int]) -> Tuple[int, int]: pass def min_diff_sorted_strings(sorted_strings: List[str]) -> Tuple[str, str]: pass ``` # Input/Output Specifications Part 1: Minimum Difference for Sorted Integers * **Input**: A sorted list of integers. * Example: `[1, 2, 3, 5, 8, 13]` * **Output**: A tuple containing the pair of adjacent integers with the smallest absolute difference. * Example: `(1, 2)` Part 2: Minimum Difference for Sorted Strings * **Input**: A sorted list of strings of equal length. * Example: `[\\"aaa\\", \\"aab\\", \\"aac\\", \\"aad\\", \\"aba\\"]` * **Output**: A tuple containing the pair of adjacent strings with the smallest difference. * Example: `(\\"aaa\\", \\"aab\\")` # Constraints * For Part 1, the list can have up to 10^6 elements, and the integers range from -10^6 to 10^6. The list is guaranteed to be sorted. * For Part 2, the input list can contain up to 10^6 strings, each having a length not exceeding 100 characters. The list is guaranteed to be sorted, and all strings have the same length. # Examples Part 1: Minimum Difference for Sorted Integers ```python >>> min_diff_sorted_integers([1, 2, 3, 5, 8, 13]) (1, 2) >>> min_diff_sorted_integers([4, 11, 19, 45, 50, 54]) (50, 54) >>> min_diff_sorted_integers([10]) None ``` Part 2: Minimum Difference for Sorted Strings ```python >>> min_diff_sorted_strings([\\"aaa\\", \\"aab\\", \\"aac\\", \\"aad\\", \\"aba\\"]) (\\"aaa\\", \\"aab\\") >>> min_diff_sorted_strings([\\"abc\\", \\"abd\\", \\"abe\\", \\"abf\\", \\"bcd\\"]) (\\"abc\\", \\"abd\\") >>> min_diff_sorted_strings([\\"zz\\", \\"zz\\"]) (\\"zz\\", \\"zz\\") ``` # Implementation Details * Ensure that your solutions handle empty or single-element lists gracefully. * For minimum difference in strings, use a letter-by-letter comparison to determine the differences. The goal of this question is to test your understanding of adjacent element comparison and the handling of sorted lists efficiently.","solution":"from typing import List, Tuple, Optional def min_diff_sorted_integers(sorted_integers: List[int]) -> Optional[Tuple[int, int]]: Returns the pair of adjacent integers with the smallest absolute difference in a sorted list of integers. if len(sorted_integers) < 2: return None min_diff = float(\'inf\') min_pair = (None, None) for i in range(len(sorted_integers) - 1): diff = abs(sorted_integers[i + 1] - sorted_integers[i]) if diff < min_diff: min_diff = diff min_pair = (sorted_integers[i], sorted_integers[i + 1]) return min_pair def min_diff_sorted_strings(sorted_strings: List[str]) -> Optional[Tuple[str, str]]: Returns the pair of adjacent strings with the smallest character-wise difference in a sorted list of strings. if len(sorted_strings) < 2: return None def string_diff(s1: str, s2: str) -> int: return sum(1 for a, b in zip(s1, s2) if a != b) min_diff = float(\'inf\') min_pair = (None, None) for i in range(len(sorted_strings) - 1): diff = string_diff(sorted_strings[i], sorted_strings[i + 1]) if diff < min_diff: min_diff = diff min_pair = (sorted_strings[i], sorted_strings[i + 1]) return min_pair"},{"question":"# Coding Assessment Question **Problem Statement:** You are provided with a singly linked list implementation in Python, which includes methods for adding nodes and performing basic operations. Your task is to extend the given implementation to include additional functionality. Requirements: 1. **Cycle Detection**: Implement a function `has_cycle` which detects whether the linked list contains a cycle. Use Floyd\'s Tortoise and Hare algorithm to achieve this. 2. **Cycle Removal**: Implement a function `remove_cycle` that removes a cycle in the linked list if it exists. Input: - A singly linked list of integers with the possibility of forming a cycle. Output: - A boolean value indicating whether the linked list contains a cycle. - The linked list should be free from any cycles afterward. Constraints: - The linked list will contain at most 10^3 nodes. - Node values are unique integers. Function Signature: ```python class ListNode: def __init__(self, value: int) -> None: self.value = value self.next = None class SinglyLinkedList: def __init__(self) -> None: self.head = None def add_node(self, value: int) -> None: ... def has_cycle(head: ListNode | None) -> bool: ... def remove_cycle(head: ListNode | None) -> None: ... # Example Usage: # linked_list = SinglyLinkedList() # for value in [3, 2, 0, -4]: # linked_list.add_node(value) # linked_list.head.next.next.next.next = linked_list.head.next # Creating a cycle # print(has_cycle(linked_list.head)) # Expected output: True # remove_cycle(linked_list.head) # print(has_cycle(linked_list.head)) # Expected output: False ``` --- **Example:** ```python class ListNode: def __init__(self, value: int) -> None: self.value = value self.next = None class SinglyLinkedList: def __init__(self) -> None: self.head = None def add_node(self, value: int) -> None: new_node = ListNode(value) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def has_cycle(head: ListNode | None) -> bool: slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False def remove_cycle(head: ListNode | None) -> None: if head is None or head.next is None: return slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break if slow != fast: return # No cycle slow = head while slow != fast: slow = slow.next fast = fast.next while fast.next != slow: fast = fast.next fast.next = None # Test linked_list = SinglyLinkedList() for value in [3, 2, 0, -4]: linked_list.add_node(value) linked_list.head.next.next.next.next = linked_list.head.next # Creating a cycle print(has_cycle(linked_list.head)) # Expected output: True remove_cycle(linked_list.head) print(has_cycle(linked_list.head)) # Expected output: False ``` You are expected to implement the `has_cycle` method using Floyd\'s Tortoise and Hare algorithm for cycle detection, and the `remove_cycle` method to demonstrate your understanding of cycle detection and removal in linked lists.","solution":"class ListNode: def __init__(self, value: int) -> None: self.value = value self.next = None class SinglyLinkedList: def __init__(self) -> None: self.head = None def add_node(self, value: int) -> None: new_node = ListNode(value) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def has_cycle(head: ListNode | None) -> bool: slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False def remove_cycle(head: ListNode | None) -> None: if head is None or head.next is None: return slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break if slow != fast: return # No cycle slow = head while slow != fast: slow = slow.next fast = fast.next while fast.next != slow: fast = fast.next fast.next = None"},{"question":"# Coding Assessment Question Context: You are working on an optimization problem involving a warehouse management system. The warehouse contains a grid of cells, each of which can be empty, occupied by an item, or be a wall that blocks movement. You are tasked with finding the shortest path from a starting cell to a destination cell while avoiding walls and occupied cells. Task: Implement the function `shortest_path_warehouse` to determine the minimum number of steps required to navigate from the `start` cell to the `end` cell in the warehouse grid. If no such path exists, return `-1`. Specifically, you need to: 1. Develop a solution using Breadth-First Search (BFS) algorithm to find the shortest path on the grid. 2. Ensure the algorithm handles the different types of cells appropriately (empty, occupied, wall). 3. Ensure the algorithm works efficiently even for larger grids. Function Signature ```python def shortest_path_warehouse( grid: list[list[str]], start: tuple[int, int], end: tuple[int, int] ) -> int: Determines the shortest path from start to end in a warehouse grid. Args: grid (list of list of str): 2D array representing the warehouse layout. - \\".\\" represents an empty cell. - \\"X\\" represents a cell occupied by an item. - \\"#\\" represents a wall that blocks movement. start (tuple of int): Starting cell coordinates (row, col). end (tuple of int): Ending cell coordinates (row, col). Returns: int: The minimum number of steps required to reach the end from the start, or -1 if no such path exists. ``` Expected Inputs and Outputs - Input: A 2D grid representing the warehouse, and two tuples for the start and end coordinates. - Output: An integer representing the minimum number of steps required to reach the end, or -1 if no path exists. Constraints - The grid dimensions can be up to 1000x1000 cells. - Cells are accessed using 0-indexing. - All cells and coordinates are guaranteed to be within bounds. - Ensure your implementation efficiently handles large grids with many obstacles. Example ```python grid = [ [\\".\\", \\".\\", \\".\\", \\"#\\", \\".\\"], [\\".\\", \\"X\\", \\".\\", \\"#\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\"#\\", \\"#\\", \\"X\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\"] ] start = (0, 0) end = (4, 4) result = shortest_path_warehouse(grid, start, end) # Expected output: 8 # The shortest path could be: (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) -> (2,3) -> (2,4) -> (3,4) -> (4,4) ``` Notes - You are allowed to use any helper functions if necessary. - Ensure your algorithm handles edge cases such as start or end cells being surrounded by walls. By following the guidelines of the original set questions, the question created addresses the shortest path problem with an emphasis on applying the Breadth-First Search (BFS) algorithm. This question aligns with the style, complexity, and scope of the original questions and thoroughly tests the understanding of graph traversal in a practical scenario.","solution":"from collections import deque def shortest_path_warehouse(grid, start, end): rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols and grid[x][y] == \\".\\" queue = deque([(start, 0)]) visited = set() visited.add(start) while queue: (x, y), steps = queue.popleft() if (x, y) == end: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append(((nx, ny), steps + 1)) return -1"},{"question":"# Coding Problem: K-th Largest Element in a Stream Problem Overview You are given an integer `k` and an initial list of integers, `nums`. Your task is to implement a data structure that efficiently finds and maintains the k-th largest element from a dynamically updating stream of integers. Detailed Specification 1. Implement a class `KthLargest` with the following methods: - `__init__(self, k: int, nums: List[int])`: Initialize the object with the integer `k` and the initial list of integers `nums`. - `add(self, val: int) -> int`: Append the integer `val` to the stream and return the k-th largest element in the stream. Class Definition ```python class KthLargest: def __init__(self, k: int, nums: List[int]): pass def add(self, val: int) -> int: pass ``` Input and Output * **Input**: - `__init__` initializes an instance with an integer `k` and a list of integers `nums` ((0 leq nums.size() leq 10^4), (-10^4 leq nums[i] leq 10^4)). - `add` method takes an integer `val` ((-10^4 leq val leq 10^4)). * **Output**: - `add` returns an integer representing the k-th largest element. Constraints * Initialize the instance with non-negative integer `k` ((1 leq k leq 10^4)). * The `add` method will be called at most (10^4) times. * Your solution should efficiently handle dynamic updates and maintain the k-th largest element. Example ```python stream = KthLargest(3, [4, 5, 8, 2]) print(stream.add(3)) # Output: 4 print(stream.add(5)) # Output: 5 print(stream.add(10)) # Output: 5 print(stream.add(9)) # Output: 8 print(stream.add(4)) # Output: 8 ``` Notes * Use an appropriate data structure to efficiently manage the dynamic stream and maintain the k-th largest element. * Consider optimal ways to handle insertions and keep track of the k-th largest element to ensure fast updates and queries.","solution":"import heapq class KthLargest: def __init__(self, k: int, nums: list): self.k = k self.heap = [] for num in nums: self.add(num) def add(self, val: int) -> int: if len(self.heap) < self.k: heapq.heappush(self.heap, val) elif val > self.heap[0]: heapq.heapreplace(self.heap, val) return self.heap[0]"},{"question":"# Genetic Algorithm for Function Optimization Scenario You have been given the task of optimizing a mathematical function using a genetic algorithm. Your goal is to enhance the current implementation to support various optimization functions and constraints while visualizing the convergence of the algorithm over generations. Problem Statement Implement a function `genetic_algorithm_optimizer(configs: dict) -> None` that: 1. Accepts a configuration dictionary which contains: - `\\"objective_function\\"`: a callable function to be optimized. - `\\"bounds\\"`: a list of tuples representing the bounds for each dimension. - `\\"population_size\\"`: an integer specifying the number of individuals in the population. - `\\"generations\\"`: an integer specifying the number of generations. - `\\"mutation_rate\\"`: a float representing the probability of mutation. - `\\"crossover_rate\\"`: a float representing the probability of crossover. - `\\"title\\"`: a string for the graph title. 2. Performs optimization using the genetic algorithm according to the provided parameters. 3. Plots the best fitness value over generations to show the convergence of the algorithm. Input - `configs`: A dictionary containing keys `\\"objective_function\\"`, `\\"bounds\\"`, `\\"population_size\\"`, `\\"generations\\"`, `\\"mutation_rate\\"`, `\\"crossover_rate\\"`, and `\\"title\\"`. Output - The function should not return anything. It should display a plot showing the best fitness value over the generations using `matplotlib`. Constraints - Assume the genetic algorithm functions (`initialize_population`, `evaluate_population`, `select_parents`, `crossover`, `mutate`, `generate_new_population`) are available for implementation. - Ensure the `objective_function` can handle multiple dimensions as specified by the `bounds`. - The code should handle optimization within the specified bounds for each dimension. Example ```python configs = { \\"objective_function\\": lambda x: sum((xi - 5)**2 for xi in x), \\"bounds\\": [(-10, 10), (-10, 10)], \\"population_size\\": 50, \\"generations\\": 100, \\"mutation_rate\\": 0.05, \\"crossover_rate\\": 0.7, \\"title\\": \\"Genetic Algorithm Optimization\\", } genetic_algorithm_optimizer(configs) ``` This should generate a plot that displays the best fitness value over 100 generations, demonstrating the algorithm\'s convergence behavior with the specified parameters.","solution":"import numpy as np import matplotlib.pyplot as plt def initialize_population(population_size, bounds): return np.array([ [np.random.uniform(low, high) for low, high in bounds] for _ in range(population_size) ]) def evaluate_population(population, objective_function): return np.array([objective_function(ind) for ind in population]) def select_parents(population, fitness, num_parents): selected = np.argsort(fitness)[:num_parents] return population[selected] def crossover(parents, population_size, crossover_rate): offspring = [] num_parents = len(parents) while len(offspring) < population_size: if np.random.rand() < crossover_rate: parent1, parent2 = parents[np.random.choice(num_parents, 2, replace=False)] crossover_point = np.random.randint(1, len(parents[0])) child = np.hstack((parent1[:crossover_point], parent2[crossover_point:])) else: child = parents[np.random.randint(num_parents)] offspring.append(child) return np.array(offspring) def mutate(population, bounds, mutation_rate): for i in range(len(population)): if np.random.rand() < mutation_rate: mutate_idx = np.random.randint(len(bounds)) low, high = bounds[mutate_idx] population[i][mutate_idx] = np.random.uniform(low, high) return population def genetic_algorithm_optimizer(configs): objective_function = configs[\'objective_function\'] bounds = configs[\'bounds\'] population_size = configs[\'population_size\'] generations = configs[\'generations\'] mutation_rate = configs[\'mutation_rate\'] crossover_rate = configs[\'crossover_rate\'] title = configs[\'title\'] population = initialize_population(population_size, bounds) best_fitness_over_time = [] for generation in range(generations): fitness = evaluate_population(population, objective_function) best_fitness = np.min(fitness) best_fitness_over_time.append(best_fitness) parents = select_parents(population, fitness, population_size // 2) offspring = crossover(parents, population_size, crossover_rate) population = mutate(offspring, bounds, mutation_rate) plt.plot(best_fitness_over_time) plt.title(title) plt.xlabel(\'Generation\') plt.ylabel(\'Best Fitness\') plt.show()"},{"question":"# Context A start-up is developing a new system for dynamically adjusting the brightness of screens in response to ambient light levels. The system gathers light measurements and determines the appropriate brightness level for the screen. The brightness level should increase as the ambient light level increases, but not linearly. Instead, it should follow a predefined step function to prevent frequent changes in brightness. # Task Write a function `adjust_brightness(light_level: float) -> int` that takes the ambient light level as input and returns the corresponding screen brightness level. The brightness levels are divided into several ranges: - If the light level is less than 20.0, the brightness should be 10%. - If the light level is between 20.0 (inclusive) and 50.0, the brightness should be 30%. - If the light level is between 50.0 (inclusive) and 80.0, the brightness should be 60%. - If the light level is between 80.0 (inclusive) and 100.0, the brightness should be 90%. - If the light level exceeds 100.0, the brightness should be 100%. # Input - A float value `light_level` representing the ambient light measurement. # Output - An integer value representing the screen brightness in percentage. # Constraints - The light level must be a non-negative value. If the light level is negative, raise a `ValueError` with the message \\"Light level cannot be negative\\". # Examples ```python adjust_brightness(18.5) # Expected Output: 10 adjust_brightness(35.0) # Expected Output: 30 adjust_brightness(75.0) # Expected Output: 60 adjust_brightness(85.0) # Expected Output: 90 adjust_brightness(120.0) # Expected Output: 100 ``` # Additional Note - Ensure that edge cases, such as exact boundary values, are correctly handled.","solution":"def adjust_brightness(light_level: float) -> int: Adjusts screen brightness based on the given ambient light level. Parameters: light_level (float): The ambient light measurement. Returns: int: The corresponding screen brightness in percentage. Raises: ValueError: If the light level is negative. if light_level < 0: raise ValueError(\\"Light level cannot be negative\\") elif light_level < 20.0: return 10 elif 20.0 <= light_level < 50.0: return 30 elif 50.0 <= light_level < 80.0: return 60 elif 80.0 <= light_level < 100.0: return 90 else: return 100"},{"question":"# **Question**: Optimal Subarray Sum Given an array of integers, the **optimal subarray sum** is defined as the maximum sum of any contiguous subarray within the given array. Your task is to implement a function `max_subarray_sum(arr: List[int]) -> int` that returns the sum of the optimal subarray for the given array. **Input Format** - A list `arr` of integers, which can be positive, negative, or zero. **Output Format** - An integer representing the sum of the optimal subarray. **Constraints** - If the input is not a list of integers, raise a `ValueError` with an appropriate message. - Performance considerations should handle arrays with lengths up to 10^6 elements. **Function Signature** ```python def max_subarray_sum(arr: List[int]) -> int: pass ``` **Examples** 1. `max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4])` should return `6`, because: - The subarray `[4, -1, 2, 1]` has the maximum sum of 6. 2. `max_subarray_sum([1])` should return `1`, because: - The single element `1` is the only subarray with a sum of 1. 3. `max_subarray_sum([-1, -2, -3, -4])` should return `-1`, because: - The subarray `[-1]` has the maximum sum of -1. 4. `max_subarray_sum([5, -3, 5])` should return `7`, because: - The subarray `[5, -3, 5]` has the sum of 7, and is the largest possible sum. **Note**: Assume the list provided is non-empty and contains at least one integer. Utilize Kadane\'s Algorithm for an efficient solution.","solution":"from typing import List def max_subarray_sum(arr: List[int]) -> int: if not isinstance(arr, list): raise ValueError(\\"Input should be a list of integers\\") for elem in arr: if not isinstance(elem, int): raise ValueError(\\"Each element in the array should be an integer\\") n = len(arr) if n == 0: return 0 max_so_far = arr[0] max_ending_here = arr[0] for i in range(1, n): max_ending_here = max(arr[i], max_ending_here + arr[i]) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"# Coding Assessment Question Implement a simulation of a simple deposit/withdrawal system for a group of bank accounts. Your task is to ensure the following functionalities within the simulation: 1. **Initialization**: Set up a bank system with a defined number of accounts, each initialized with a unique account number and a starting balance. 2. **Deposit Operation**: - Allow users to deposit a specified amount into a chosen account. - Ensure the balance is updated correctly and maintain transaction records. 3. **Withdrawal Operation**: - Allow users to withdraw a specified amount from a chosen account. - Ensure withdrawals do not exceed the available balance to prevent overdrawing. 4. **Transfer Operation**: - Allow users to transfer a specified amount from one account to another. - Ensure the transfer updates both accounts\' balances and maintains transaction records. 5. **Balance Inquiry**: - Provide a method to query an account\'s balance at any time. - Display the entire transaction history for an account upon request. Function Signature: ```python class BankAccount: def __init__(self, account_number: int, initial_balance: float) -> None: ... class BankSystem: def __init__(self) -> None: ... def create_account(self, initial_balance: float) -> BankAccount: ... def deposit(self, account: BankAccount, amount: float) -> None: ... def withdraw(self, account: BankAccount, amount: float) -> None: ... def transfer(self, from_account: BankAccount, to_account: BankAccount, amount: float) -> None: ... def get_balance(self, account: BankAccount) -> float: ... def get_transaction_history(self, account: BankAccount) -> List[str]: ... ``` Your Task: Implement the `BankSystem` class and corresponding `BankAccount` class. Your implementation should ensure that the banking operations adhere to the specified rules, maintain accurate account balances, and record all transactions reliably. Handle edge cases such as attempting to withdraw or transfer more than the available balance effectively. Each operation should consistently update the system\'s state and enable balance inquiries and transaction history retrieval at any point. Constraints: - Ensure account numbers are unique and sequentially generated. - Initial balance for accounts should be non-negative. - Deposit, withdrawal, and transfer amounts should be positive values. - Handle concurrency and ensure data integrity when multiple operations occur simultaneously. Given this setup, you can verify correctness by: - Ensuring account balances are updated accurately after each operation. - Confirming that transaction records reflect all operations performed. - Observing that operations adhere to constraints, particularly for withdrawals and transfers. Implement and test your simulation thoroughly to demonstrate correct and robust behavior adhering to the specified requirements.","solution":"from typing import List class BankAccount: def __init__(self, account_number: int, initial_balance: float) -> None: self.account_number = account_number self.balance = initial_balance self.transactions = [f\\"Account {account_number} created with balance {initial_balance:.2f}\\"] def deposit(self, amount: float) -> None: self.balance += amount self.transactions.append(f\\"Deposited {amount:.2f}, new balance {self.balance:.2f}\\") def withdraw(self, amount: float) -> None: if self.balance >= amount: self.balance -= amount self.transactions.append(f\\"Withdrawn {amount:.2f}, new balance {self.balance:.2f}\\") else: self.transactions.append(f\\"Withdrawal of {amount:.2f} failed due to insufficient funds\\") def transfer(self, to_account, amount: float) -> None: if self.balance >= amount: self.withdraw(amount) to_account.deposit(amount) self.transactions.append(f\\"Transferred {amount:.2f} to account {to_account.account_number}\\") to_account.transactions.append(f\\"Received transfer of {amount:.2f} from account {self.account_number}\\") else: self.transactions.append(f\\"Transfer of {amount:.2f} to account {to_account.account_number} failed due to insufficient funds\\") def get_balance(self) -> float: return self.balance def get_transaction_history(self) -> List[str]: return self.transactions class BankSystem: def __init__(self) -> None: self.accounts = {} self.next_account_number = 1 def create_account(self, initial_balance: float) -> BankAccount: account = BankAccount(self.next_account_number, initial_balance) self.accounts[self.next_account_number] = account self.next_account_number += 1 return account def deposit(self, account: BankAccount, amount: float) -> None: account.deposit(amount) def withdraw(self, account: BankAccount, amount: float) -> None: account.withdraw(amount) def transfer(self, from_account: BankAccount, to_account: BankAccount, amount: float) -> None: from_account.transfer(to_account, amount) def get_balance(self, account: BankAccount) -> float: return account.get_balance() def get_transaction_history(self, account: BankAccount) -> List[str]: return account.get_transaction_history()"},{"question":"# Coding Challenge: Implement Trie and Auto-Complete Feature **Scenario**: You are designing a predictive typing feature for a mobile application. Your job is to implement a Trie (prefix tree) data structure to facilitate efficient word auto-completion. **Objective**: Implement the `Trie` class, including methods to insert words and to perform auto-completion based on a given prefix. **Requirements**: 1. Implement the `Trie` class. 2. Implement the `insert` method to add words to the Trie. 3. Implement the `autocomplete` method that retrieves all words in the Trie that start with a given prefix. **Function Signature**: ```python class Trie: def __init__(self): ... def insert(self, word: str) -> None: ... def autocomplete(self, prefix: str) -> List[str]: ... ``` **Expected Input and Output**: - `__init__(self)`: Initializes the Trie. - `insert(self, word: str) -> None`: Inserts the word into the Trie. - `autocomplete(self, prefix: str) -> List[str]`: Returns a list of all words in the Trie that start with the given prefix. The order of words in the returned list does not matter. **Constraints**: - All words and prefixes will consist of lowercase alphabets only. - The maximum length of any word or prefix will be 100. - The number of words inserted into the Trie will be in the range [1, 20000]. **Performance Requirements**: - Inserting a word should be ( O(k) ), where ( k ) is the length of the word. - The auto-complete operation should be efficient in both time and space. **Testing**: Your implementation should be verified by the following tests: 1. Inserting multiple words and retrieving completions for various prefixes. 2. Testing auto-complete with a prefix that has no matching words. 3. Testing with an empty prefix to return all words in the Trie. 4. Ensuring that sub-prefixes correctly return all matching words. Implement the `Trie` class along with `insert` and `autocomplete` methods to meet the above requirements and pass the described tests.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def _find_words_from_node(self, node: TrieNode, prefix: str) -> list: words = [] if node.is_end_of_word: words.append(prefix) for char, child_node in node.children.items(): words.extend(self._find_words_from_node(child_node, prefix + char)) return words def autocomplete(self, prefix: str) -> list: node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] return self._find_words_from_node(node, prefix)"},{"question":"# Coding Challenge: Implement a Dynamic Programming Solution for the Knapsack Problem **Context**: You are provided with a basic implementation of a greedy algorithm to solve the Knapsack problem. However, this approach does not always yield an optimal solution due to its heuristic nature. Your task is to implement a dynamic programming-based approach to ensure an optimal solution on any given dataset. **Your Task**: Write a Python function `knapsack_dynamic(weights, values, capacity)` that solves the Knapsack problem using dynamic programming. **Input**: - `weights`: A list of integers representing the weights of the items. - `values`: A list of integers representing the values of the items. - `capacity`: An integer representing the maximum capacity of the knapsack. **Output**: - An integer representing the maximum value that can be obtained by selecting items without exceeding the knapsack\'s capacity. **Constraints**: - `1 ≤ len(weights) = len(values) ≤ 1000` - `1 ≤ weights[i] ≤ 1000` - `1 ≤ values[i] ≤ 1000` - `1 ≤ capacity ≤ 1000` **Specifications to Implement**: 1. **Optimal Substructure**: Utilize dynamic programming to build up the solution iteratively. 2. **Efficiency**: Optimize space complexity to handle the large potential input size effectively. ```python # Knapsack Problem Dynamic Programming Function def knapsack_dynamic(weights, values, capacity): Solves the Knapsack problem using dynamic programming for optimal solution. Args: weights (list): A list of item weights. values (list): A list of item values. capacity (int): The maximum weight capacity of the knapsack. Returns: int: The maximum value achievable with the given constraints. n = len(weights) dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)] for i in range(1, n + 1): for w in range(capacity + 1): if weights[i-1] <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w - weights[i-1]] + values[i-1]) else: dp[i][w] = dp[i-1][w] return dp[n][capacity] # Example usage: weights = [1, 2, 3, 4, 5] values = [10, 20, 30, 40, 50] capacity = 10 max_value = knapsack_dynamic(weights, values, capacity) print(\\"Maximum value achievable:\\", max_value) ``` **Note**: You are expected to implement the dynamic programming algorithm solely using basic Python constructs without relying on external libraries that solve the knapsack problem directly.","solution":"def knapsack_dynamic(weights, values, capacity): Solves the Knapsack problem using dynamic programming for optimal solution. Args: weights (list): A list of item weights. values (list): A list of item values. capacity (int): The maximum weight capacity of the knapsack. Returns: int: The maximum value achievable with the given constraints. n = len(weights) dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)] for i in range(1, n + 1): for w in range(capacity + 1): if weights[i-1] <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w - weights[i-1]] + values[i-1]) else: dp[i][w] = dp[i-1][w] return dp[n][capacity]"},{"question":"# Determine if Binary Tree is Symmetric You are given a binary tree, and your task is to determine if it is symmetric around its center. A binary tree is symmetric if the left and right subtrees are mirror images of each other. Function Signature: ```python def is_symmetric(root: TreeNode | None) -> bool: # Your code goes here ``` Input Format: - The input function receives a parameter `root`, which is the root node of a binary tree. - Each `TreeNode` has the following structure: ```python @dataclass class TreeNode: val: int = 0 left: TreeNode | None = None right: TreeNode | None = None ``` Output Format: - Return a boolean value indicating whether the binary tree is symmetric (`True`) or not (`False`). Constraints: - The number of nodes in the tree is within the range `[0, 10^4]`. - Each node\'s value falls within the range `[-10^4, 10^4]`. Example: **Example 1**: ```python t1 = TreeNode(1) t1.left = TreeNode(2) t1.right = TreeNode(2) t1.left.left = TreeNode(3) t1.left.right = TreeNode(4) t1.right.left = TreeNode(4) t1.right.right = TreeNode(3) print(is_symmetric(t1)) # Output: True ``` **Example 2**: ```python t2 = TreeNode(1) t2.left = TreeNode(2) t2.right = TreeNode(2) t2.left.right = TreeNode(3) t2.right.right = TreeNode(3) print(is_symmetric(t2)) # Output: False ``` In the first example, the left and right subtrees are mirrors of each other, so the tree is symmetric. In the second example, the left and right subtrees are not mirrors of each other because one subtree has an additional node that the other does not, so the tree is not symmetric. **Note**: 1. Ensure that your solution handles edge cases such as empty trees and trees with only one node. 2. Pay attention to optimizing the performance for large input sizes.","solution":"from dataclasses import dataclass from typing import Optional @dataclass class TreeNode: val: int = 0 left: Optional[\'TreeNode\'] = None right: Optional[\'TreeNode\'] = None def is_symmetric(root: Optional[TreeNode]) -> bool: if not root: return True def is_mirror(t1: Optional[TreeNode], t2: Optional[TreeNode]) -> bool: if not t1 and not t2: return True if not t1 or not t2: return False return ( t1.val == t2.val and is_mirror(t1.left, t2.right) and is_mirror(t1.right, t2.left) ) return is_mirror(root.left, root.right)"},{"question":"# Arithmetic Progression Checker An arithmetic progression (AP) is a sequence of numbers in which the difference between any two consecutive terms is always the same. For example, the sequence `[2, 4, 6, 8, 10]` is an arithmetic progression with a difference of `2`. You need to write a function `is_arithmetic_progression(numbers: List[int]) -> bool` that takes in a list of integers and returns `True` if the numbers form an arithmetic progression, and `False` otherwise. **Function Signature**: ```python def is_arithmetic_progression(numbers: List[int]) -> bool: pass ``` **Input**: - `numbers` (List[int]): A list of integers which may or may not be in sorted order, `len(numbers) > 1`. **Output**: - Returns `True` if the list of numbers forms an arithmetic progression, otherwise returns `False`. **Example**: ```python >>> is_arithmetic_progression([3, 7, 11, 15]) True >>> is_arithmetic_progression([1, 2, 4, 8]) False ``` # Detailed Requirements: Your function should: 1. Determine if the list of numbers can be rearranged to form an arithmetic progression. 2. Compute the common difference between consecutive terms if they can be rearranged into an arithmetic progression. 3. Return `True` if the numbers form an arithmetic progression and `False` otherwise. # Constraints: - The input list can contain negative and positive integers. - The length of the list will be between 2 and 10^4. # Notes: - Consider edge cases, such as lists with repeated numbers or with a small number of elements. - The solution should focus on both correctness and efficiency, especially for larger input sizes. **Hint**: Sorting the list might help in determining the common difference and verifying if all elements can form an AP.","solution":"from typing import List def is_arithmetic_progression(numbers: List[int]) -> bool: Determines if the given list of numbers forms an arithmetic progression. Parameters: numbers (List[int]): A list of integers which may or may not be in sorted order. Returns: bool: True if the numbers can be arranged to form an arithmetic progression, else False. if len(numbers) < 2: return False numbers.sort() common_difference = numbers[1] - numbers[0] for i in range(2, len(numbers)): if numbers[i] - numbers[i - 1] != common_difference: return False return True"},{"question":"# Coding Challenge: Merge Two Binary Trees # Objective Write a function that merges two binary trees by adding the values of overlapping nodes. If two nodes overlap, then sum the values of the overlapping nodes, otherwise use the non-null node as the new value of the merged tree. # Task Function Specification * **Function Name**: `merge_trees` * **Input**: * Two parameters `t1` and `t2` representing the roots of two binary trees. Each tree node has the following properties: * `val` (int): the value of the node. * `left` (TreeNode): the left child of the node. * `right` (TreeNode): the right child of the node. * **Output**: * Returns `TreeNode` - the root of the new merged binary tree. * **Constraints**: * Trees can be empty. * The node values are integers within the range (-10^9) to (10^9). Examples ```python # Example 1: # Input: # t1: [1, 3, 2, 5] # t2: [2, 1, 3, None, 4, None, 7] # Output: [3, 4, 5, 5, 4, None, 7] # Example 2: # Input: # t1: [1] # t2: [1, 2] # Output: [2, 2] # Example 3: # Input: # t1: [3, 4, 5, 1, 2] # t2: [4, 1, 2, 3, 6] # Output: [7, 5, 7, 4, 8] ``` # Definition for a binary tree node: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Additional Instructions 1. **Edge Case Considerations**: * Handle cases where either or both trees are empty. * Handle depth differences in the input trees. 2. **Validation**: Ensure the input nodes are either `TreeNode` or `None`. Implementation Notes * Use a recursive approach to traverse the trees and merge them. * Ensure all possible node pairs are considered. * Optimize your solution to avoid unnecessary recomputation. # Example Usage ```python # Creating tree nodes for t1 and t2 t1 = TreeNode(1, TreeNode(3, TreeNode(5)), TreeNode(2)) t2 = TreeNode(2, TreeNode(1, None, TreeNode(4)), TreeNode(3, None, TreeNode(7))) # Merging trees result = merge_trees(t1, t2) # The resulting tree should be decorated in a pre-order format to see the final result, # example for result: [3, 4, 5, 5, 4, None, 7] ``` Write the `merge_trees` function so that it merges two given binary trees as per the above-mentioned details.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def merge_trees(t1, t2): Merges two binary trees by summing the values of overlapping nodes. If two nodes overlap, sum the values of the overlapping nodes, otherwise use the non-null node. if not t1 and not t2: return None if not t1: return t2 if not t2: return t1 new_val = t1.val + t2.val new_node = TreeNode(new_val) new_node.left = merge_trees(t1.left, t2.left) new_node.right = merge_trees(t1.right, t2.right) return new_node"},{"question":"# Coding Task: Implement Polynomial Multiplication Using Fast Fourier Transform (FFT) Scenario You are asked to write a function that multiplies two polynomials efficiently using the Fast Fourier Transform (FFT) algorithm. This technique significantly reduces the computational complexity compared to the naive polynomial multiplication method. Task Implement a function `poly_multiply_fft` in Python which takes two lists of coefficients representing two polynomials and returns a list of coefficients representing their product. Function Signature ```python import numpy as np def poly_multiply_fft(poly1: list, poly2: list) -> list: Multiply two polynomials using Fast Fourier Transform (FFT). Args: - poly1 (list): A list of coefficients representing the first polynomial. - poly2 (list): A list of coefficients representing the second polynomial. Returns: - product (list): A list of coefficients representing the product polynomial. pass ``` # Input * `poly1`: A list of integers or floats representing the coefficients of the first polynomial. * `poly2`: A list of integers or floats representing the coefficients of the second polynomial. # Output * Return a list of integers or floats representing the coefficients of the product polynomial. # Constraints * The length of each polynomial can be up to `1000`. * Coefficients can be integers or floating-point numbers. # Example ```python poly1 = [1, 2, 3] poly2 = [4, 5, 6] product = poly_multiply_fft(poly1, poly2) print(product) # Expected output: [4, 13, 28, 27, 18] ``` # Notes 1. Utilize the Fast Fourier Transform (FFT) to efficiently multiply the polynomials, ensuring the implementation handles polynomials of different lengths. 2. Consider cases where the resulting polynomial might have trailing zero coefficients. 3. Handle floating-point precision issues where necessary. # Additional Notes The Fast Fourier Transform can be leveraged for polynomial multiplication by transforming the coefficient lists to their point-value form, performing point-wise multiplication and then applying the inverse FFT to get back the coefficient form of the product polynomial. This method has a time complexity of O(n log n), which is much faster than the O(n^2) complexity of naive multiplication for large polynomials.","solution":"import numpy as np def poly_multiply_fft(poly1: list, poly2: list) -> list: def next_power_of_2(x): return 1 if x == 0 else 2**(x - 1).bit_length() n = len(poly1) + len(poly2) - 1 m = next_power_of_2(n) poly1.extend([0] * (m - len(poly1))) poly2.extend([0] * (m - len(poly2))) fft_poly1 = np.fft.fft(poly1) fft_poly2 = np.fft.fft(poly2) fft_product = fft_poly1 * fft_poly2 product = np.fft.ifft(fft_product) product = [round(coeff.real) for coeff in product] return product[:n]"},{"question":"# Coding Assessment Question Scenario A logistics company wants to improve its route optimization software by implementing a function that can calculate the shortest path between two locations in a city grid. Each intersection in the city can be represented by coordinates on a 2D grid. Movements can only occur vertically or horizontally to adjacent intersections (up, down, left, right). Your task is to write a function that takes the grid dimensions, the starting intersection, and the destination intersection, and returns the minimum number of movements required to travel from the start to the destination. Requirements * Write a function `min_moves(grid_size: tuple, start: tuple, destination: tuple) -> int` that performs the specified calculation. * Validate the inputs to ensure they meet the following constraints: - `grid_size` must be a tuple of two positive integers, representing the dimensions of the grid (rows, columns). - `start` and `destination` must be tuples of two non-negative integers, representing valid coordinates within the grid. * You must raise appropriate exceptions if the input values do not meet the constraints. Expected Input and Output * **Input**: - `grid_size` (tuple): The dimensions of the grid (rows, columns). - `start` (tuple): Coordinates of the starting intersection (row, column). - `destination` (tuple): Coordinates of the destination intersection (row, column). * **Output**: - (int): The minimum number of movements required to travel from the start to the destination. Examples 1. `min_moves((5, 5), (0, 0), (4, 4))` should return `8`. 2. `min_moves((3, 3), (0, 0), (0, 2))` should return `2`. 3. `min_moves((3, 3), (0, 0), (2, 2))` should return `4`. 4. `min_moves((5, 5), (0, 0), (0, 0))` should return `0`. 5. `min_moves((5, 5), (0, 0), (5, 5))` should raise an `Exception` with message \\"Destination coordinates out of grid boundaries\\". Constraints * Assume the grid size will not exceed 1,000 x 1,000. * Assume the start and destination coordinates will always be within the grid dimensions. ***Write your function below:*** ```python def min_moves(grid_size: tuple, start: tuple, destination: tuple) -> int: Calculate the minimum number of movements required to travel from the start intersection to the destination in a grid. :param grid_size: The dimensions of the grid (rows, columns) :param start: coordinates of the starting intersection (row, column) :param destination: coordinates of the destination intersection (row, column) :return: The minimum number of movements required # Validate input rows, cols = grid_size if rows <= 0 or cols <= 0: raise Exception(\\"Grid dimensions must be positives\\") start_row, start_col = start dest_row, dest_col = destination if not (0 <= start_row < rows and 0 <= start_col < cols): raise Exception(\\"Start coordinates out of grid boundaries\\") if not (0 <= dest_row < rows and 0 <= dest_col < cols): raise Exception(\\"Destination coordinates out of grid boundaries\\") # Calculate Manhattan Distance as moves moves = abs(dest_row - start_row) + abs(dest_col - start_col) return moves ```","solution":"def min_moves(grid_size: tuple, start: tuple, destination: tuple) -> int: Calculate the minimum number of movements required to travel from the start intersection to the destination in a grid. :param grid_size: The dimensions of the grid (rows, columns) :param start: coordinates of the starting intersection (row, column) :param destination: coordinates of the destination intersection (row, column) :return: The minimum number of movements required # Validate input rows, cols = grid_size if rows <= 0 or cols <= 0: raise Exception(\\"Grid dimensions must be positive integers\\") start_row, start_col = start dest_row, dest_col = destination if not (0 <= start_row < rows and 0 <= start_col < cols): raise Exception(\\"Start coordinates out of grid boundaries\\") if not (0 <= dest_row < rows and 0 <= dest_col < cols): raise Exception(\\"Destination coordinates out of grid boundaries\\") # Calculate Manhattan Distance as moves moves = abs(dest_row - start_row) + abs(dest_col - start_col) return moves"},{"question":"# Fibonacci Sequence: Position Finder **Context**: You are working on a sensor data analysis project where the occurrence of certain patterns, such as the Fibonacci sequence, can be significant. You need to implement a function that determines the position of a given number in the Fibonacci sequence. **Task**: Implement a function `fibonacci_position(n: int) -> int` that returns the position of the number `n` in the Fibonacci sequence. If `n` is not in the Fibonacci sequence, the function should return `-1`. **Input Format**: - A single integer `n` representing the number to find in the Fibonacci sequence. - The number will be a non-negative integer. **Output Format**: - An integer representing the position of `n` in the Fibonacci sequence (starting from position 1). If `n` is not found in the sequence, return `-1`. **Constraints**: - You may assume the input integer will be non-negative and within the first 10,000 Fibonacci numbers. **Examples**: ```python assert fibonacci_position(1) == 1 assert fibonacci_position(5) == 5 assert fibonacci_position(13) == 7 assert fibonacci_position(21) == 8 assert fibonacci_position(4) == -1 ``` **Performance Requirements**: - Ensure the function runs efficiently, with an expected time complexity suitable for checking positions within large Fibonacci sequences. # Notes: - The Fibonacci sequence is defined as follows: F(1) = 1, F(2) = 1, F(n) = F(n-1) + F(n-2) for n > 2. - The sequence starts with 1, 1, 2, 3, 5, 8, 13, 21, ... --- Implementing this problem will help validate your understanding of sequence detection and efficiently navigating through the Fibonacci numbers.","solution":"def fibonacci_position(n): Returns the position of the number n in the Fibonacci sequence, starting from position 1. If n is not in the sequence, return -1. if n < 1: return -1 a, b = 1, 1 pos = 1 while a < n: a, b = b, a + b pos += 1 return pos if a == n else -1"},{"question":"# Problem Statement: Create a function that generates a summary report from a list of employee records. Each record contains details such as the employee\'s name, department, salary, and years of experience. Your task is to implement the following functions: 1. **`average_salary`**: Calculate the average salary for a specific department. 2. **`total_experience`**: Compute the total years of experience for all employees in a given department. 3. **`highest_earner`**: Identify the employee with the highest salary across all departments. 4. **`lowest_experience`**: Find the employee with the least years of experience in a given department. 5. **`department_summary`**: Generate a summary report for a specific department listing the number of employees, the average salary, and the total years of experience. # Function Signatures: 1. **`def average_salary(records: list[dict], department: str) -> float:`** 2. **`def total_experience(records: list[dict], department: str) -> int:`** 3. **`def highest_earner(records: list[dict]) -> dict:`** 4. **`def lowest_experience(records: list[dict], department: str) -> dict:`** 5. **`def department_summary(records: list[dict], department: str) -> dict:`** # Input: - `records`: List of dictionaries where each dictionary contains the following keys: - `\'name\'`: String representing the employee\'s name - `\'department\'`: String representing the employee\'s department - `\'salary\'`: Integer representing the employee\'s salary - `\'years_of_experience\'`: Integer representing the employee\'s years of experience - `department`: String representing the department to filter records by. # Output: - The functions should return the required statistical values or summary as described in the function signatures. # Constraints: - `records` list is not empty. - Each dictionary in the `records` list contains valid and non-null values for the specified keys. - `department` is a valid department that exists in the `records` list. - Salaries and years of experience are non-negative integers. # Example: ```python # Example employee records: records = [ {\'name\': \'Alice\', \'department\': \'HR\', \'salary\': 50000, \'years_of_experience\': 5}, {\'name\': \'Bob\', \'department\': \'IT\', \'salary\': 80000, \'years_of_experience\': 10}, {\'name\': \'Carol\', \'department\': \'IT\', \'salary\': 75000, \'years_of_experience\': 8}, {\'name\': \'David\', \'department\': \'HR\', \'salary\': 60000, \'years_of_experience\': 7}, {\'name\': \'Eve\', \'department\': \'Finance\', \'salary\': 90000, \'years_of_experience\': 12} ] # Average Salary avg_salary_it = average_salary(records, \'IT\') print(avg_salary_it) # Output: 77500.0 # Total Experience total_exp_hr = total_experience(records, \'HR\') print(total_exp_hr) # Output: 12 # Highest Earner highest_paid = highest_earner(records) print(highest_paid) # Output: {\'name\': \'Eve\', \'department\': \'Finance\', \'salary\': 90000, \'years_of_experience\': 12} # Lowest Experience least_exp_hr = lowest_experience(records, \'HR\') print(least_exp_hr) # Output: {\'name\': \'Alice\', \'department\': \'HR\', \'salary\': 50000, \'years_of_experience\': 5} # Department Summary hr_summary = department_summary(records, \'HR\') print(hr_summary) # Output: {\'number_of_employees\': 2, \'average_salary\': 55000.0, \'total_years_of_experience\': 12} ``` This is the additional question that seamlessly integrates with the original set, matching the style, complexity, and technical depth of the given sample questions.","solution":"def average_salary(records, department): Calculate the average salary for a specific department. salaries = [record[\'salary\'] for record in records if record[\'department\'] == department] return sum(salaries) / len(salaries) if salaries else 0 def total_experience(records, department): Compute the total years of experience for all employees in a given department. experiences = [record[\'years_of_experience\'] for record in records if record[\'department\'] == department] return sum(experiences) def highest_earner(records): Identify the employee with the highest salary across all departments. return max(records, key=lambda x: x[\'salary\']) def lowest_experience(records, department): Find the employee with the least years of experience in a given department. department_records = [record for record in records if record[\'department\'] == department] return min(department_records, key=lambda x: x[\'years_of_experience\']) def department_summary(records, department): Generate a summary report for a specific department listing the number of employees, the average salary, and the total years of experience. department_records = [record for record in records if record[\'department\'] == department] number_of_employees = len(department_records) avg_salary = average_salary(records, department) total_experience_years = total_experience(records, department) return { \'number_of_employees\': number_of_employees, \'average_salary\': avg_salary, \'total_years_of_experience\': total_experience_years }"},{"question":"# Coding Assessment Question One common problem in optimization and scheduling involves finding when the resource usage peaks across various overlapping intervals. Your task is to determine the maximum number of overlapping intervals within a given list of start and end times. Task: Implement the function `max_overlapping_intervals(intervals: List[Tuple[int, int]]) -> int`. This function should return the maximum number of overlapping intervals at any given time. # Input: - `intervals` (List[Tuple[int, int]]): A list of tuples where each tuple consists of two integers representing the start and end times of an interval. The start time is inclusive, and the end time is exclusive. # Output: - (int): The maximum number of overlapping intervals. # Constraints: - Assume the list of intervals will contain up to ( 100,000 ) tuples. - The start and end times will be non-negative integers. # Example: ```python assert max_overlapping_intervals([(1, 5), (2, 6), (4, 8), (5, 7)]) == 3 assert max_overlapping_intervals([(1, 3), (2, 5), (7, 9), (8, 10)]) == 2 ``` Notes: - Handle overlapping intervals efficiently to ensure performance. - Consider scenarios where some intervals may be entirely contained within others.","solution":"def max_overlapping_intervals(intervals): Returns the maximum number of overlapping intervals. events = [] for start, end in intervals: events.append((start, 1)) # Interval starts, add to overlap. events.append((end, -1)) # Interval ends, remove from overlap. # Sort events, within same times, end event should come before start event events.sort(key=lambda x: (x[0], x[1])) max_overlap = 0 current_overlap = 0 for time, event in events: current_overlap += event if current_overlap > max_overlap: max_overlap = current_overlap return max_overlap"},{"question":"Task Question Creation for Coding Assessment Objective Analyze the provided sample question and create an additional question that aligns with the existing set in terms of style, complexity, and scope. Guidelines # Question Style - Carefully examine the format and presentation of the given questions. - Maintain a consistent tone and language used in the original set. # Question Length - Ensure your new question is of comparable length to the existing ones. - If the original questions vary in length, aim for the average length among them. # Difficulty Level - Assess the cognitive and technical challenges presented in the sample questions. - Match the complexity of concepts, algorithms, or programming techniques required. # Topic Alignment - Identify the core programming concepts or domains covered in the existing questions. - Create a question that explores a related or complementary area within the same general topic. # Question Uniqueness - While maintaining similarity, ensure your new question is not a mere rephrasing of an existing one. - Introduce a novel problem or scenario that tests the same skills in a different context. Output Compose one addition question that seamlessly integrates with the existing set, adhering to all the above guidelines. Your new question should appear as if it were part of the original examination and indistinguishable in quality. Output one new question only. --- You are tasked with updating the `PasswordGenerator` class to support password generation based on dynamic constraints provided during initialization. The provided code snippet generates random passwords using predetermined rules, but it currently does not allow for custom constraints. **Objective**: Modify the `PasswordGenerator` class to accept dynamic constraints on the characters allowed in the passwords. You will enhance its functionality to allow the user to specify constraints for character types such as uppercase letters, lowercase letters, digits, and special characters. **Requirements**: 1. Add an optional parameter `constraints` to the constructor, allowing the user to specify the number of each type of character in the password. 2. If `constraints` is provided, ensure the generated password meets the specified constraints. 3. The class should dynamically adjust the pool of characters based on the constraints to ensure valid passwords are created. **Expected Input/Output**: - The `__init__` method will now take an additional optional parameter `constraints`. If not provided, it defaults to predefined rules. - Modify the `generate_password` method to use the constraints while generating the password. - Ensure that the final password meets the specified constraints. ```python import string import random class PasswordGenerator: def __init__(self, length: int = 12, constraints: dict = None) -> None: self.length = length self.constraints = constraints or { \'uppercase\': 2, \'lowercase\': 2, \'digits\': 2, \'special\': 2 } self.pool = { \'uppercase\': string.ascii_uppercase, \'lowercase\': string.ascii_lowercase, \'digits\': string.digits, \'special\': string.punctuation } def generate_password(self) -> str: password_chars = [] # Ensure constraints and remaining length are compatible remaining_length = self.length - sum(self.constraints.values()) if remaining_length < 0: raise ValueError(\\"Length too short for given constraints\\") for char_type, count in self.constraints.items(): if count > 0: password_chars.extend(random.choices(self.pool[char_type], k=count)) all_chars = \'\'.join(self.pool.values()) password_chars.extend(random.choices(all_chars, k=remaining_length)) random.shuffle(password_chars) return \'\'.join(password_chars) # Testing the new functionality def test_password_generation(constraints: dict = None) -> str: pg = PasswordGenerator(constraints=constraints) return pg.generate_password() if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` # Example ```python # Specify constraints for password constraints = { \'uppercase\': 3, \'lowercase\': 4, \'digits\': 2, \'special\': 3 } pg = PasswordGenerator(length=12, constraints=constraints) password = pg.generate_password() print(\\"Generated Password:\\", password) # Output should correctly reflect the specified constraints in the generated password. ```","solution":"import string import random class PasswordGenerator: def __init__(self, length: int = 12, constraints: dict = None) -> None: self.length = length self.constraints = constraints or { \'uppercase\': 2, \'lowercase\': 2, \'digits\': 2, \'special\': 2 } self.pool = { \'uppercase\': string.ascii_uppercase, \'lowercase\': string.ascii_lowercase, \'digits\': string.digits, \'special\': string.punctuation } def generate_password(self) -> str: password_chars = [] # Ensure constraints and remaining length are compatible remaining_length = self.length - sum(self.constraints.values()) if remaining_length < 0: raise ValueError(\\"Length too short for given constraints\\") for char_type, count in self.constraints.items(): if count > 0: password_chars.extend(random.choices(self.pool[char_type], k=count)) all_chars = \'\'.join(self.pool.values()) password_chars.extend(random.choices(all_chars, k=remaining_length)) random.shuffle(password_chars) return \'\'.join(password_chars)"},{"question":"# Coding Assessment Question Context: You are developing a text processing tool that needs to perform various string manipulations efficiently. One common task in text processing is identifying unique substrings within a given string. To demonstrate your understanding of string manipulation and data structures, you will implement a function to find all unique substrings of a given length from an input string. Task: 1. Implement a function to find all unique substrings of a specified length within a given string. 2. If the specified length is greater than the length of the input string, the function should return an empty list. 3. Write a main function to accept a string and a substring length from the user, then print the unique substrings. Requirements: 1. **Function `unique_substrings(s: str, length: int) -> List[str]`** - Receive a string `s` and an integer `length` as input and return a list of all unique substrings of the given length. - Return an empty list if `length` is greater than the length of `s`. 2. **Function `main()`** - Accept a string and a substring length as input from the user. - Call the `unique_substrings` function with the given input and print the result. Constraints: - The input string can have a maximum length of 1000 characters. - The substring length will be between 1 and the length of the input string. Example: For an input string \\"hello\\" and substring length 2: - `unique_substrings(\\"hello\\", 2)` should return `[\\"he\\", \\"el\\", \\"ll\\", \\"lo\\"]`. For an input string \\"aaaa\\" and substring length 2: - `unique_substrings(\\"aaaa\\", 2)` should return `[\\"aa\\"]`.","solution":"from typing import List def unique_substrings(s: str, length: int) -> List[str]: Returns a list of all unique substrings of the given length from the input string. if length > len(s): return [] substrings = set() for i in range(len(s) - length + 1): substring = s[i:i + length] substrings.add(substring) return list(substrings) def main(): s = input(\\"Enter a string: \\") length = int(input(\\"Enter the substring length: \\")) result = unique_substrings(s, length) print(result)"},{"question":"Write a Python function `linked_list_intersection(head1: Node, head2: Node) -> Optional[Node]` that determines the intersection point of two singly linked lists. # Requirements: 1. **Input**: - `head1`: The head node of the first singly linked list. - `head2`: The head node of the second singly linked list. 2. **Output**: The node at which the intersection of the two singly linked lists begins, or `None` if there is no intersection. 3. **Constraints**: - `0 <= number of nodes in the list <= 10^4` - Node values are not necessarily unique, but the structure is. - The two linked lists may or may not be equal in length. # Performance: - Strive for an efficient solution with respect to both time and space complexity, ideally in (O(m + n)) time where (m) and (n) are the lengths of the two linked lists. # Implementation: - Consider strategies to handle merging points where two linked lists intersect. - Ensure the solution efficiently handles varying list lengths and can determine the point of intersection, if present. # Example: ```python # Given the linked list nodes as below: # List A: 1 -> 2 -> 3 # # 6 -> 7 # / # List B: 4 -> 5 class Node: def __init__(self, x): self.value = x self.next = None # Creating the linked lists intersect_node = Node(6) intersect_node.next = Node(7) head1 = Node(1) head1.next = Node(2) head1.next.next = Node(3) head1.next.next.next = intersect_node head2 = Node(4) head2.next = Node(5) head2.next.next = intersect_node >>> linked_list_intersection(head1, head2) <Node object at some memory address representing node with value 6> # For cases with no intersection: # List A: 1 -> 2 -> 3 -> 4 # List B: 5 -> 6 -> 7 -> 8 head3 = Node(1) head3.next = Node(2) head3.next.next = Node(3) head3.next.next.next = Node(4) head4 = Node(5) head4.next = Node(6) head4.next.next = Node(7) head4.next.next.next = Node(8) >>> linked_list_intersection(head3, head4) None ``` # Special Considerations: - Handle edge cases such as when either `head1` or `head2` or both are `None`. - Assure proper memory management and avoid memory leaks if applicable.","solution":"class Node: def __init__(self, x): self.value = x self.next = None def get_length(head): length = 0 current = head while current: length += 1 current = current.next return length def linked_list_intersection(head1, head2): Determines the intersection point of two singly linked lists. If the lists intersect, returns the node at which they intersect. Otherwise, returns None. if not head1 or not head2: return None # Get lengths of both lists len1 = get_length(head1) len2 = get_length(head2) # Align both pointers to the same starting point current1 = head1 current2 = head2 if len1 > len2: for _ in range(len1 - len2): current1 = current1.next elif len2 > len1: for _ in range(len2 - len1): current2 = current2.next # Traverse both lists together to find the intersection point while current1 and current2: if current1 == current2: return current1 current1 = current1.next current2 = current2.next return None"},{"question":"# Coding Assessment Question Context You are given a class `Category` that represents a category of products in an e-commerce platform. Each `Category` object has a list of `Product` objects, and each `Product` object has a `price` attribute. The class supports various operations such as adding and removing products. Problem Statement Implement the following function: ```python def get_discountable_products(category: Category, min_price: float, max_price: float) -> List[Product]: Retrieves a list of products from the category that fall within the given price range (inclusive). Args: category (Category): The category of products. min_price (float): The minimum price of the range. max_price (float): The maximum price of the range. Returns: List[Product]: A list of products with prices within the specified range. pass ``` Definition A product is considered discountable if its price lies within the specified range `[min_price, max_price]` inclusive. Input - `category`: An instance of the `Category` class representing a category of products. - `min_price` and `max_price`: Floats representing the price range. Output - A list of `Product` instances whose prices are within the given range, otherwise an empty list. Constraints - ( 0 leq text{price} leq 1000 ) - ( 0 leq text{min_price} leq text{max_price} leq 1000 ) - The category object contains valid `Product` objects with a `price` attribute. Examples ```python # Example 1 p1 = Product(\\"Product1\\", 12.5) p2 = Product(\\"Product2\\", 9.99) p3 = Product(\\"Product3\\", 15.0) category = Category(\\"ExampleCategory\\", [p1, p2, p3]) assert get_discountable_products(category, 10.0, 15.0) == [p1, p3] # Example 2 p4 = Product(\\"Product4\\", 45.0) p5 = Product(\\"Product5\\", 55.99) category2 = Category(\\"AnotherCategory\\", [p4, p5]) assert get_discountable_products(category2, 50.0, 60.0) == [p5] ``` Notes 1. You may assume that the `Category` and `Product` classes, as well as their relevant attributes and methods, are implemented correctly. 2. Consider boundary conditions where a product\'s price is exactly equal to `min_price` or `max_price`.","solution":"from typing import List class Product: def __init__(self, name: str, price: float): self.name = name self.price = price class Category: def __init__(self, name: str, products: List[Product]): self.name = name self.products = products def get_discountable_products(category: Category, min_price: float, max_price: float) -> List[Product]: Retrieves a list of products from the category that fall within the given price range (inclusive). Args: category (Category): The category of products. min_price (float): The minimum price of the range. max_price (float): The maximum price of the range. Returns: List[Product]: A list of products with prices within the specified range. return [product for product in category.products if min_price <= product.price <= max_price]"},{"question":"# Factorial Digit Sum As part of an interview for a role in a mathematical software company, you are tasked with solving a problem that involves both mathematical computation and optimization. Your interviewer wants you to write a function that calculates the sum of the digits of the factorial of a given number. This tests both your ability to handle large numbers and your algorithmic skills. # Task You need to implement a function `factorial_digit_sum(n: int) -> int` that computes the factorial of a given number `n` and returns the sum of the digits of this factorial. # Input and Output Formats * **Input**: - `n`: an integer where ( 0 leq n leq 100 ). * **Output**: - The function should return an integer representing the sum of the digits of the factorial of `n`. # Example: ```python factorial_digit_sum(5) ``` *Output*: ``` 3 ``` **Explanation**: ( 5! = 120 ). The sum of the digits is ( 1 + 2 + 0 = 3 ). # Constraints: - Ensure that the factorial is computed efficiently given the constraints. - Handle large numbers correctly since factorials can grow very quickly. # Performance: - Use appropriate libraries to handle large integers if necessary. - Optimize the digit sum calculation for large factorial values. # Hints: 1. You can utilize Python\'s built-in `math.factorial` function to compute the factorial as Python handles large integers natively. 2. Convert the factorial result to a string to easily iterate over each digit and compute the sum. **Note**: Ensure the function handles edge cases properly, such as ( n = 0 ) and ( n = 100 ). ```python import math def factorial_digit_sum(n: int) -> int: factorial_result = math.factorial(n) digit_sum = sum(int(digit) for digit in str(factorial_result)) return digit_sum ``` # Testing: Consider writing test cases to ensure your function works for various values of ( n ), including edge cases like ( n = 0 ) and ( n = 100 ).","solution":"import math def factorial_digit_sum(n: int) -> int: Computes the sum of the digits of the factorial of a given number n. :param n: integer where 0 <= n <= 100 :return: sum of the digits of the factorial of n factorial_result = math.factorial(n) digit_sum = sum(int(digit) for digit in str(factorial_result)) return digit_sum"},{"question":"# Context Graph traversal algorithms are fundamental to many computer science problems involving network analysis, pathfinding, and search engines. One of these algorithms is Depth-First Search (DFS), which explores as far down a branch as possible before backtracking. It is useful in scenarios requiring the full exploration of all paths in a graph. # Problem Statement Implement a function `depth_first_search(graph, start_node)` that performs a Depth-First Search on a given graph represented as an adjacency list. The function should return a list of nodes in the order they are first visited. # Function Signature ```python def depth_first_search(graph: dict, start_node: int) -> list: pass ``` # Input and Output * **Input**: - `graph` (dict): A dictionary where keys are node identifiers and values are lists of neighboring node identifiers. - `start_node` (int): The node from which the DFS traversal should begin. * **Output**: - `list`: A list of nodes in the order they were first visited during the DFS. # Constraints * The graph `graph` can have between 1 and 1000 nodes. * Nodes are identified using integers 0 through 1000. * Each node can have zero or more neighboring nodes. * There are no duplicate edges (i.e., no node will appear more than once in any neighboring list). # Performance Requirements The function should be efficient, with time complexity approximately O(V + E), where V is the number of vertices and E is the number of edges in the graph. # Example ```python graph = { 0: [1, 2], 1: [0, 3, 4], 2: [0, 5, 6], 3: [1], 4: [1], 5: [2], 6: [2] } start_node = 0 result = depth_first_search(graph, start_node) print(result) # Expected output: [0, 1, 3, 4, 2, 5, 6] ``` # Implementation Notes Consider the following steps for DFS implementation: 1. Use an explicit stack to manage the nodes to be explored. 2. Keep track of visited nodes to avoid revisiting them. 3. Start from the `start_node` and iteratively explore each branch fully before backtracking. 4. Return the list of nodes in their first-visited order. Ensure the function handles edge cases such as isolated nodes and graphs with only one node.","solution":"def depth_first_search(graph: dict, start_node: int) -> list: visited = [] stack = [start_node] while stack: node = stack.pop() if node not in visited: visited.append(node) # Add neighbors in reverse order to visit them in the correct sequence stack.extend(reversed(graph.get(node, []))) return visited"},{"question":"# Prime Number Generator and Manipulations As a software developer, you are tasked with generating prime numbers and performing various manipulations on them. Task: Implement the following functions: 1. **Generate Primes**: Generate all prime numbers up to a given number `n`. 2. **Check Prime**: Check if a given number `x` is prime. 3. **Prime Factorization**: Perform prime factorization on a given number `x`. 4. **Sum of Primes**: Calculate the sum of all prime numbers less than or equal to a given number `n`. Specifications: * **Input Format**: - For Generate Primes: - Upper limit: `n` - For Check Prime: - Number to check: `x` - For Prime Factorization: - Number to factorize: `x` - For Sum of Primes: - Upper limit: `n` * **Output Format**: - **Generate Primes**: List of prime numbers up to `n`. - **Check Prime**: `True` or `False` indicating whether `x` is prime. - **Prime Factorization**: List of prime factors of `x`. - **Sum of Primes**: Sum of all prime numbers less than or equal to `n`. * **Constraints**: - 1 ≤ n ≤ 100,000 - 1 ≤ x ≤ 100,000 Additional Information: 1. For the generation of primes, an efficient algorithm such as the Sieve of Eratosthenes is recommended. 2. Ensure that your prime checking is optimized to handle large values of `x`. 3. For prime factorization, consider prime factors up to √x. 4. Handle edge cases such as non-prime inputs and very small values. Example: ```python Input: Generate primes up to 30 Output: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] Input: Check if 31 is prime Output: True Input: Prime factorize 60 Output: [2, 2, 3, 5] Input: Sum of primes up to 20 Output: 77 ```","solution":"import math def generate_primes(n): Generate all prime numbers up to n using the Sieve of Eratosthenes. if n < 2: return [] sieve = [True] * (n + 1) sieve[0] = sieve[1] = False for start in range(2, int(math.sqrt(n)) + 1): if sieve[start]: for multiple in range(start*start, n + 1, start): sieve[multiple] = False return [num for num, is_prime in enumerate(sieve) if is_prime] def is_prime(x): Check if a number x is prime. if x < 2: return False for i in range(2, int(math.sqrt(x)) + 1): if x % i == 0: return False return True def prime_factorize(x): Perform prime factorization on the given number x. if x <= 1: return [] factors = [] for i in range(2, int(math.sqrt(x)) + 1): while x % i == 0: factors.append(i) x //= i if x > 1: factors.append(x) return factors def sum_of_primes(n): Calculate the sum of all prime numbers less than or equal to n. primes = generate_primes(n) return sum(primes)"},{"question":"# Task: Implement a Simple Text Editor Context: You are developing a simple text editor that allows users to perform basic operations on a string. The editor supports operations such as inserting a character, deleting the last character, and undoing the last operation. Your task is to implement these functionalities. Task: Implement a class `TextEditor` that provides the following methods: - `insert(char: str) -> None`: Inserts the character `char` at the end of the current string. - `delete() -> None`: Deletes the last character of the current string if it exists. - `undo() -> None`: Undoes the last operation (either an insert or delete). The operations are stored in a stack to allow undoing the most recent operation. Input/Output: - The `insert` method does not return anything but modifies the internal state. - The `delete` method does not return anything but modifies the internal state. - The `undo` method does not return anything but modifies the internal state. - The class should maintain the current state of the string which can be accessed by a method `get_text() -> str` which returns the current string. Constraints: - All characters are lowercase English letters. - The number of operations performed will not exceed 100,000. - Ensure operations are optimized for performance. Example: ```python editor = TextEditor() editor.insert(\'a\') editor.insert(\'b\') print(editor.get_text()) # Output: \'ab\' editor.delete() print(editor.get_text()) # Output: \'a\' editor.undo() print(editor.get_text()) # Output: \'ab\' ``` Notes: - Use a stack data structure to keep track of operations for efficient undo functionality. - Consider edge cases such as deleting from an empty string or undoing with no operations to revert.","solution":"class TextEditor: def __init__(self): self.text = [] self.operations = [] def insert(self, char: str) -> None: self.text.append(char) self.operations.append((\'insert\', char)) def delete(self) -> None: if self.text: char = self.text.pop() self.operations.append((\'delete\', char)) def undo(self) -> None: if self.operations: last_op, char = self.operations.pop() if last_op == \'insert\': self.text.pop() elif last_op == \'delete\': self.text.append(char) def get_text(self) -> str: return \'\'.join(self.text)"},{"question":"# Scenario You are working on a system that needs to manage reservations for a set of meeting rooms. The task is to track and determine the availability of the rooms based on existing reservations. # Problem Statement Write a Python class `MeetingRooms` with the following methods: - `__init__(self, room_count: int) -> None`: Initializes the system with a given number of rooms. Each room can be identified by an index from 0 to `room_count-1`. - `reserve(self, start_time: str, end_time: str) -> bool`: Attempts to reserve any available room for the given time period, provided as strings in \\"HH:MM\\" 24-hour format (e.g., \\"09:00\\" to \\"10:30\\"). Returns `True` if the reservation was successful, otherwise returns `False`. Reservations must not overlap, meaning a room cannot be reserved if there is any overlap with an existing reservation\'s time range. # Constraints - `room_count` is a positive integer not exceeding 100. - `start_time` and `end_time` are valid times in 24-hour format with `start_time` strictly less than `end_time`. - Multiple reservations can be requested, but each successful reservation occupies only one room. # Input/Output - Class methods will be used to interact with the reservation system, as demonstrated in the example. # Example ```python mr = MeetingRooms(3) assert mr.reserve(\\"09:00\\", \\"10:00\\") == True # Reservation successful in room 0 assert mr.reserve(\\"09:30\\", \\"10:30\\") == True # Reservation successful in room 1 assert mr.reserve(\\"09:30\\", \\"10:30\\") == True # Reservation successful in room 2 assert mr.reserve(\\"09:30\\", \\"10:30\\") == False # No available room assert mr.reserve(\\"10:30\\", \\"11:30\\") == True # Reservation successful in room 0 ``` # Guidelines - Implement efficient overlap checking to ensure reservations do not conflict. - Maintain the state of room availabilities throughout the reservation requests. - Ensure that the system can handle a reasonable sequence of time-based operations.","solution":"class MeetingRooms: def __init__(self, room_count: int) -> None: self.room_count = room_count self.rooms = [[] for _ in range(room_count)] @staticmethod def time_to_minutes(time_str: str) -> int: hours, minutes = map(int, time_str.split(\\":\\")) return hours * 60 + minutes def has_conflict(self, room: list, start: int, end: int) -> bool: for reservation in room: if not (end <= reservation[0] or start >= reservation[1]): return True return False def reserve(self, start_time: str, end_time: str) -> bool: start = self.time_to_minutes(start_time) end = self.time_to_minutes(end_time) for room in self.rooms: if not self.has_conflict(room, start, end): room.append((start, end)) room.sort() return True return False"},{"question":"# Question You are required to implement a function to calculate the Nth prime number using both iterative and recursive methods as per the description. Your implementation should handle valid inputs gracefully and raise errors for invalid inputs. Function Signature ```python def nth_prime_iterative(n: int) -> int: def nth_prime_recursive(n: int) -> int: ``` Requirements: 1. **Function 1**: `nth_prime_iterative(n: int) -> int` - Use an iterative approach such as the Sieve of Eratosthenes or trial division. - Should raise `ValueError` for non-positive integer inputs. - Should provide accurate results up to at least the 10,000th prime number. 2. **Function 2**: `nth_prime_recursive(n: int) -> int` - Use a recursive approach based on a trial division method. - Should handle inputs within a reasonable range to prevent stack overflow. - Raise specific errors (`ValueError`, `RecursionError`) for invalid or out-of-bound inputs. Input - `n`: An integer representing the position of the prime number to be found. `n` is a positive integer. Output - Returns an integer which is the Nth prime number. Constraints - `n` value must be a positive integer indicating the position in the prime sequence. - Performance should be optimized to ensure efficiency for sufficiently large primes. Example ```python >>> nth_prime_iterative(5) 11 ``` ```python >>> nth_prime_recursive(10) 29 ``` Scenario Consider implementing your solution while ensuring mathematical accuracy, handling edge cases, and considering performance impacts especially for large inputs. Check for invalid input types and ensure your iterative method is optimized for large values, while the recursive method should be prepared to handle recursion limits and appropriate error raising.","solution":"def nth_prime_iterative(n: int) -> int: if not isinstance(n, int) or n <= 0: raise ValueError(\\"Input must be a positive integer.\\") primes = [] num = 2 # Start checking for primes from 2 while len(primes) < n: for i in primes: if num % i == 0: break else: primes.append(num) num += 1 return primes[-1] def nth_prime_recursive(n: int, current=2, primes=None) -> int: if not isinstance(n, int) or n <= 0: raise ValueError(\\"Input must be a positive integer.\\") if primes is None: primes = [] if len(primes) == n: return primes[-1] for i in primes: if current % i == 0: return nth_prime_recursive(n, current+1, primes) primes.append(current) return nth_prime_recursive(n, current+1, primes)"},{"question":"# Problem Statement You are tasked with implementing a class that models a simplified version of a library\'s book tracking system. This system should allow for adding new books, borrowing and returning books, and tracking which books are currently borrowed. # Task Implement a class `Library` with the following methods: 1. `add_book(title: str) -> None`: Adds a book to the library\'s collection. The book\'s title should be a non-empty string. 2. `borrow_book(title: str) -> bool`: Marks the book as borrowed if it is available. If the book was successfully borrowed, return `True`; otherwise, return `False`. 3. `return_book(title: str) -> bool`: Marks the book as returned if it was borrowed. If the book was successfully returned, return `True`; otherwise, return `False`. 4. `available_books() -> List[str]`: Returns a sorted list of titles of the books that are currently available for borrowing. # Constraints - The titles of the books are unique (i.e., no two books will have the same title). - You can assume the total number of books will not exceed 10,000. # Example ```python # Example usage: # Create the library library = Library() # Add books to the library library.add_book(\\"The Great Gatsby\\") library.add_book(\\"To Kill a Mockingbird\\") library.add_book(\\"1984\\") # Borrow a book print(library.borrow_book(\\"1984\\")) # Output: True # Try to borrow a book that is already borrowed print(library.borrow_book(\\"1984\\")) # Output: False # Return a book print(library.return_book(\\"1984\\")) # Output: True # Check available books print(library.available_books()) # Output: [\'1984\', \'The Great Gatsby\', \'To Kill a Mockingbird\'] ``` # Explanation - The `Library` class keeps track of books in three states: available, borrowed, and not in the library. - The method `add_book` adds the book title to the collection. - The method `borrow_book` allows for borrowing a book by marking it as borrowed and preventing further borrowing until it is returned. - The method `return_book` marks a borrowed book as available once it is returned. - The method `available_books` provides a sorted list of all books that are currently available to be borrowed. # Note Ensure your solution handles edge cases such as: - Borrowing a book that doesn\'t exist. - Returning a book that wasn\'t borrowed. - Adding a book that already exists (which should be a no-op). This maintains the integrity of the library\'s book tracking and ensures robust handling of dynamic states within the collection.","solution":"class Library: def __init__(self): self.available = set() self.borrowed = set() def add_book(self, title: str) -> None: if title and title not in self.available and title not in self.borrowed: self.available.add(title) def borrow_book(self, title: str) -> bool: if title in self.available: self.available.remove(title) self.borrowed.add(title) return True return False def return_book(self, title: str) -> bool: if title in self.borrowed: self.borrowed.remove(title) self.available.add(title) return True return False def available_books(self) -> list: return sorted(self.available)"},{"question":"# Problem: **String Compression and Decompression** You are tasked with implementing a pair of functions to compress and decompress strings. The compression should use a basic run-length encoding (RLE) technique. This task will assess your ability to manipulate strings, loops, and conditionals. Compression: Implement a function `compress_string` that takes a string and compresses it using RLE. The compressed string should contain characters followed by the number of occurrences of that character consecutively. Decompression: Implement a function `decompress_string` that takes a compressed string (created by the `compress_string` function) and returns the original string. # Input and Output Formats: **Compression**: - Input: A string of characters - Output: A compressed string **Decompression**: - Input: A compressed string - Output: The original string Constraints: - The input strings will contain only uppercase and lowercase alphabetical characters. - The compressed string for any character sequence will have the character directly followed by its count, so \\"aaabb\\" -> \\"a3b2\\". - Assume the decompressed string length will not exceed 10,000 characters. # Example: ```python compress_string(\\"aaabb\\") # Output: \\"a3b2\\" compress_string(\\"aabccc\\") # Output: \\"a2b1c3\\" decompress_string(\\"a3b2\\") # Output: \\"aaabb\\" decompress_string(\\"a2b1c3\\") # Output: \\"aabccc\\" ``` # Implementation Details Make sure the implementation of both `compress_string` and `decompress_string` functions is efficient and handles the given constraints properly. Code Template: ```python def compress_string(s): # implement compression logic here def decompress_string(s): # implement decompression logic here ``` Test the functions with multiple cases to ensure they produce the correct output for both typical and edge cases.","solution":"def compress_string(s): if not s: return \\"\\" compressed = [] count = 1 prev_char = s[0] for char in s[1:]: if char == prev_char: count += 1 else: compressed.append(f\\"{prev_char}{count}\\") prev_char = char count = 1 compressed.append(f\\"{prev_char}{count}\\") return \'\'.join(compressed) def decompress_string(s): decompressed = [] i = 0 while i < len(s): char = s[i] count_str = [] i += 1 while i < len(s) and s[i].isdigit(): count_str.append(s[i]) i += 1 decompressed.append(char * int(\'\'.join(count_str))) return \'\'.join(decompressed)"},{"question":"# Scenario In many software applications, generating all possible permutations of a given string can be valuable. This often involves recursion and careful handling of character positions. # Problem Statement You are tasked with generating all unique permutations of a given string that may contain duplicate characters. Write a function that takes a string as an argument and returns a sorted list of its unique permutations. # Function Signature ```python def generate_unique_permutations(s: str) -> List[str]: pass ``` # Input * `s`: A string (`1 ≤ len(s) ≤ 8`) which may contain duplicate characters. # Output * A sorted list of unique permutations of the input string. # Constraints * The permutations should be sorted lexicographically. * Ensure that permutations consider unique characters only once if they occur more than once in the string. # Examples ```python assert generate_unique_permutations(\\"abc\\") == [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] assert generate_unique_permutations(\\"aab\\") == [\\"aab\\", \\"aba\\", \\"baa\\"] assert generate_unique_permutations(\\"aaa\\") == [\\"aaa\\"] ``` # Explanation 1. For input `\\"abc\\"`, the function returns all 6 possible permutations in sorted order. 2. For input `\\"aab\\"`, the function returns 3 unique permutations considering the duplicate \'a\'. 3. For input `\\"aaa\\"`, the output is a single permutation since all characters are identical. # Note To achieve the best performance, consider using a set to eliminate duplicates and standard library functions to generate permutations and sort them.","solution":"from typing import List from itertools import permutations def generate_unique_permutations(s: str) -> List[str]: Generate all unique permutations of the given string and return them sorted. # Generate all permutations using itertools.permutations, convert each to string and add to set to remove duplicates unique_permutations = set(\'\'.join(p) for p in permutations(s)) # Convert the set back to a list and sort it return sorted(unique_permutations)"},{"question":"# Question: Implement a Circular Buffer (Ring Buffer) with Dynamic Resizing Circular buffers are fixed-size data structures that operate in a FIFO (First-In-First-Out) manner. When the buffer is full and new data is added, the oldest data is overwritten. Your task is to implement a circular buffer with dynamic resizing capabilities. # Requirements: 1. Implement methods to add elements to the buffer and retrieve elements from the buffer. 2. If the buffer is full, it should resize to accommodate additional elements by doubling its size. 3. Provide methods to get the current size of the buffer and check if the buffer is empty. # Function Signature: ```python class CircularBuffer: def __init__(self, capacity: int): pass def add(self, value: int) -> None: pass def get(self) -> int: pass def size(self) -> int: pass def is_empty(self) -> bool: pass ``` # Input: - **capacity (int):** The initial capacity of the buffer. - **value (int):** The integer value to be added to the buffer. # Output: - **add:** Adds an element to the buffer. - **get:** Retrieves and removes the oldest element from the buffer. - **size:** Returns the number of elements in the buffer. - **is_empty:** Returns True if the buffer is empty, False otherwise. # Constraints: - The capacity must be a positive integer. - If `get` is called on an empty buffer, it should raise an appropriate exception. - Ensure that adding new elements and resizing the buffer maintains the order of elements. # Example Usage: ```python buffer = CircularBuffer(3) buffer.add(1) buffer.add(2) buffer.add(3) print(buffer.size()) # Output: 3 print(buffer.get()) # Output: 1 print(buffer.size()) # Output: 2 buffer.add(4) buffer.add(5) # Buffer resizes here print(buffer.size()) # Output: 4 print(buffer.get()) # Output: 2 print(buffer.is_empty()) # Output: False ``` # Expected Output: 1. After adding three elements to a buffer of initial capacity 3, the size should be 3. 2. Retrieving an element should return the oldest element, maintaining FIFO order. 3. When adding an element to a full buffer, the buffer should resize and maintain all elements. 4. Calling `is_empty` should correctly reflect the buffer’s state.","solution":"class CircularBuffer: def __init__(self, capacity: int): if capacity <= 0: raise ValueError(\\"Capacity must be a positive integer\\") self.buffer = [None] * capacity self.capacity = capacity self.start = 0 self.end = 0 self.count = 0 def add(self, value: int) -> None: if self.count == self.capacity: self._resize() self.buffer[self.end] = value self.end = (self.end + 1) % self.capacity self.count += 1 def _resize(self) -> None: new_capacity = self.capacity * 2 new_buffer = [None] * new_capacity for i in range(self.count): new_buffer[i] = self.buffer[(self.start + i) % self.capacity] self.buffer = new_buffer self.start = 0 self.end = self.count self.capacity = new_capacity def get(self) -> int: if self.is_empty(): raise IndexError(\\"get from empty buffer\\") value = self.buffer[self.start] self.buffer[self.start] = None self.start = (self.start + 1) % self.capacity self.count -= 1 return value def size(self) -> int: return self.count def is_empty(self) -> bool: return self.count == 0"},{"question":"# Question: Sum of Digits Until Single Digit Background: In various digital root problems, you often need to repeatedly sum the digits of a number until you get a single-digit result. This operation is especially useful in digital root calculations that are applied in checksums, number theory, and certain digital signal processes. Problem Statement: Write a function `sum_of_digits_until_single_digit` which takes a non-negative integer as input and returns the single-digit result obtained by repeatedly summing its digits. Function Signature: ```python def sum_of_digits_until_single_digit(number: int) -> int: pass ``` Input: * A single integer `number` which can be any non-negative integer. Output: * An integer representing the single-digit result obtained by repeatedly summing the digits of the input number. Constraints: * The input number will be a non-negative integer (0 ≤ number ≤ 10^12). Example: ```python assert sum_of_digits_until_single_digit(0) == 0 assert sum_of_digits_until_single_digit(123) == 6 assert sum_of_digits_until_single_digit(9875) == 2 assert sum_of_digits_until_single_digit(123456789) == 9 assert sum_of_digits_until_single_digit(999999999999) == 9 ``` Edge Cases: 1. **Zero Input**: `sum_of_digits_until_single_digit(0)` should return `0`. 2. **Single Digit Input**: `sum_of_digits_until_single_digit(5)` should return `5`. Additional Notes: 1. If the input is not an integer, handle it appropriately by raising a `TypeError` with the message \\"Input value must be a \'int\' type\\". Implement the function with efficient computation, ideally avoiding using loops for large numbers by leveraging mathematical insights if possible. Write comprehensive test cases to validate your implementation.","solution":"def sum_of_digits_until_single_digit(number: int) -> int: Given a non-negative integer, repeatedly sum its digits until a single-digit result is obtained. Returns the single-digit result. if not isinstance(number, int): raise TypeError(\\"Input value must be a \'int\' type\\") if number == 0: return 0 return 1 + (number - 1) % 9 if number > 0 else 0"},{"question":"# Context You are working as a backend developer for a travel booking website. One of the features allows users to search for trips based on origin, destination, and date, and see available options. Users can also book trips and get recommendations for popular destinations. # Problem Statement Write a function `search_and_book_trip(origin: str, destination: str, date: str, seats: int) -> dict` that searches for available trips between the given origin and destination on the specified date. If seats are available, it should proceed to book those seats and return a confirmation. Function Signature ```python def search_and_book_trip(origin: str, destination: str, date: str, seats: int) -> dict: pass ``` Input - `origin` (str): The starting point of the trip. - `destination` (str): The ending point of the trip. - `date` (str): The date of travel in YYYY-MM-DD format. - `seats` (int): The number of seats to book. Output - (dict): A dictionary containing the booking confirmation details or an error message. # Requirements 1. The function should check for trip availability and seat count accurately. 2. Handle cases where no trips are found or not enough seats are available. 3. Provide clear error messages for invalid inputs or booking failures. 4. The function should handle various edge cases (e.g., past dates, invalid date formats). 5. Assume you have access to a predefined dataset or API that provides trip availability and booking capabilities. Example ```python # The mock implementation for searching and booking should produce correct and meaningful results. result = search_and_book_trip(\\"New York\\", \\"Los Angeles\\", \\"2023-11-15\\", 2) # Expected output: {\\"status\\": \\"success\\", \\"message\\": \\"Booking confirmed\\", \\"booking_id\\": \\"ABC12345\\"} ``` # Constraints - All inputs should be non-empty and within reasonable lengths (e.g., origin and destination names should not exceed 50 characters). - Date format should strictly follow YYYY-MM-DD. - Seats should be a positive integer not greater than 10. # Notes 1. Implement validation for origin, destination, and date before processing the booking. 2. Mock the trip dataset or API response to simulate availability checks and booking for unit testing. 3. Ensure to handle any exceptions or errors gracefully with meaningful feedback to the user. # Additional Considerations - Consider the impact of time zones and provide clear messaging for these cases. - Implement some form of logging for success and failure cases to aid in troubleshooting and debugging.","solution":"import datetime # Mock dataset of trips TRIPS_DATA = [ {\\"trip_id\\": \\"T001\\", \\"origin\\": \\"New York\\", \\"destination\\": \\"Los Angeles\\", \\"date\\": \\"2023-11-15\\", \\"available_seats\\": 5}, {\\"trip_id\\": \\"T002\\", \\"origin\\": \\"New York\\", \\"destination\\": \\"Los Angeles\\", \\"date\\": \\"2023-11-16\\", \\"available_seats\\": 3}, {\\"trip_id\\": \\"T003\\", \\"origin\\": \\"Chicago\\", \\"destination\\": \\"Miami\\", \\"date\\": \\"2023-11-15\\", \\"available_seats\\": 10} ] # Mock function to book seats (usually this would be a call to a database or booking API) def book_seats(trip_id: str, seats: int) -> str: for trip in TRIPS_DATA: if trip[\\"trip_id\\"] == trip_id: if trip[\\"available_seats\\"] < seats: return {\\"status\\": \\"error\\", \\"message\\": \\"Not enough seats available\\"} trip[\\"available_seats\\"] -= seats return {\\"status\\": \\"success\\", \\"message\\": \\"Booking confirmed\\", \\"booking_id\\": \\"BOOK\\" + trip_id} return {\\"status\\": \\"error\\", \\"message\\": \\"Trip not found\\"} # Function to search for trips and book seats if available def search_and_book_trip(origin: str, destination: str, date: str, seats: int) -> dict: try: # Basic validation if not origin or not destination: return {\\"status\\": \\"error\\", \\"message\\": \\"Origin and destination must not be empty.\\"} if not 0 < seats <= 10: return {\\"status\\": \\"error\\", \\"message\\": \\"Seats must be between 1 and 10.\\"} # Validate date format datetime.datetime.strptime(date, \\"%Y-%m-%d\\") # Search for available trips available_trip = None for trip in TRIPS_DATA: if trip[\\"origin\\"].lower() == origin.lower() and trip[\\"destination\\"].lower() == destination.lower() and trip[\\"date\\"] == date: if trip[\\"available_seats\\"] >= seats: available_trip = trip break if not available_trip: return {\\"status\\": \\"error\\", \\"message\\": \\"No available trips found or not enough seats.\\"} # Book the seats booking_confirmation = book_seats(available_trip[\\"trip_id\\"], seats) return booking_confirmation except ValueError: return {\\"status\\": \\"error\\", \\"message\\": \\"Invalid date format. Use YYYY-MM-DD.\\"}"},{"question":"# Problem Statement In geometric modeling, complex shapes are often composed of simpler primitives like rectangles. Your goal is to implement a function that will determine if two rectangles overlap. Such a function can be crucial in applications ranging from computer graphics to collision detection in gaming. Each rectangle is aligned with the axes and represented by its bottom-left and top-right corners. One rectangle is defined by the coordinates (x1, y1) and (x2, y2), and the other by the coordinates (x3, y3) and (x4, y4). # Function Details: **Function Name**: `do_rectangles_overlap` **Input**: - `rect1`: A tuple containing four integers (x1, y1, x2, y2) representing the first rectangle. - `rect2`: A tuple containing four integers (x3, y3, x4, y4) representing the second rectangle. **Output**: - A boolean value indicating whether the two rectangles overlap. `True` if they do overlap, `False` otherwise. **Constraints**: - All coordinates are integers within the range [-10^9, 10^9]. - The bottom-left corner will always be at a lesser coordinate than the top-right for both rectangles (i.e., x1 < x2 and y1 < y2 for rect1, and x3 < x4 and y3 < y4 for rect2). # Example: ```python def do_rectangles_overlap(rect1: tuple, rect2: tuple) -> bool: # Your implementation here pass # Example Test Cases print(do_rectangles_overlap((0, 0, 2, 2), (1, 1, 3, 3))) # Expected: True print(do_rectangles_overlap((0, 0, 1, 1), (2, 2, 3, 3))) # Expected: False print(do_rectangles_overlap((0, 0, 2, 2), (2, 2, 3, 3))) # Expected: False print(do_rectangles_overlap((0, 0, 4, 4), (2, 2, 6, 6))) # Expected: True print(do_rectangles_overlap((1, 1, 5, 5), (-1, -1, 3, 3))) # Expected: True ``` # Notes: - Two rectangles overlap if one of their projections on the x-axis and one of their projections on the y-axis intersect. - Edge cases include when rectangles just touch each other at edges or corners without overlapping.","solution":"def do_rectangles_overlap(rect1: tuple, rect2: tuple) -> bool: Determines if two rectangles overlap. Each rectangle is defined by a tuple of four integers representing the coordinates of the bottom-left and top-right corners. :param rect1: Tuple[int, int, int, int], representing the first rectangle (x1, y1, x2, y2) :param rect2: Tuple[int, int, int, int], representing the second rectangle (x3, y3, x4, y4) :return: bool, True if the rectangles overlap, False otherwise x1, y1, x2, y2 = rect1 x3, y3, x4, y4 = rect2 # Check if there is no horizontal overlap if x2 <= x3 or x4 <= x1: return False # Check if there is no vertical overlap if y2 <= y3 or y4 <= y1: return False # If both horizontal and vertical overlaps exist, rectangles overlap return True"},{"question":"# Problem Statement You are required to create a class `NumericString` that stores a string of digits. Implement the following methods for this class: 1. **Sum of Digits**: Write a method `sum_of_digits` within the `NumericString` class that returns the sum of all the digits in the string. 2. **Digit Count**: Write a method `digit_count` within the `NumericString` class that returns a dictionary where the keys are the digits (as strings) and the values are the counts of each digit in the string. # Expected Input and Output 1. **Sum of Digits**: - **Input**: None (invoked on a `NumericString` instance) - **Output**: Integer (sum of all the digits in the string) - **Example**: ```python numeric_string = NumericString(\\"123456\\") result = numeric_string.sum_of_digits() print(result) # Output: 21 ``` 2. **Digit Count**: - **Input**: None (invoked on a `NumericString` instance) - **Output**: Dictionary (counts of each digit in the string) - **Example**: ```python numeric_string = NumericString(\\"1122334455\\") result = numeric_string.digit_count() print(result) # Output: {\'1\': 2, \'2\': 2, \'3\': 2, \'4\': 2, \'5\': 2} ``` # Constraints * The string will only contain numeric digits (0-9) and will not be empty. * Implement the methods without using any built-in Python collections methods (such as `Counter`). Implement the `sum_of_digits` and `digit_count` methods in the `NumericString` class.","solution":"class NumericString: def __init__(self, numeric_string): self.numeric_string = numeric_string def sum_of_digits(self): Returns the sum of all the digits in the string. total = 0 for char in self.numeric_string: total += int(char) return total def digit_count(self): Returns a dictionary where the keys are the digits (as strings) and the values are the counts of each digit in the string. count_dict = {} for char in self.numeric_string: if char in count_dict: count_dict[char] += 1 else: count_dict[char] = 1 return count_dict"},{"question":"# Question: Implement a Financial Calculator with Different Compound Interest Methods Your task is to implement a financial calculator that can compute the future value of an investment based on different compound interest methods. Specifically, you need to support annual, semi-annual, quarterly, and monthly compounding. Implement the following requirements: 1. **Implement the `compound_interest` function** that calculates the future value for a given principal, annual interest rate, number of years, and compounding frequency. 2. **Implement the `calculate_future_value` function** that uses `compound_interest` to calculate and compare future values for different compounding frequencies. **Function Signature**: ```python def compound_interest(principal: float, rate: float, years: float, comp_freq: int) -> float: pass def calculate_future_value( principal: float, rate: float, years: float ) -> dict[str, float]: pass ``` **Input**: - `principal`: The initial amount of money invested (a positive float). - `rate`: The annual interest rate in decimal form (e.g., 0.05 for 5%). - `years`: The number of years the money is invested for (a positive float). - `comp_freq`: The number of times interest is compounded per year (integer: 1 for annual, 2 for semi-annual, 4 for quarterly, 12 for monthly). **Output**: - The `compound_interest` function returns the future value of the investment (a float). - The `calculate_future_value` function returns a dictionary with keys as compounding frequencies (\'annual\', \'semi-annual\', \'quarterly\', \'monthly\') and values as the corresponding future values. **Constraints**: - Ensure that the calculation handles typical financial values accurately and efficiently. - Validate that `principal` and `years` are positive and `rate` is a non-negative decimal. - Only allow valid compounding frequencies (1, 2, 4, 12). Example: ```python def test_calculator(): principal = 1000.0 rate = 0.05 years = 10 future_values = calculate_future_value(principal, rate, years) for freq, value in future_values.items(): print(f\\"{freq}: {value:.2f}\\") test_calculator() # Output: # annual: 1628.89 # semi-annual: 1638.62 # quarterly: 1643.62 # monthly: 1647.01 ``` Implement and test your financial calculator to ensure it provides accurate and expected results across different compounding methods.","solution":"def compound_interest(principal: float, rate: float, years: float, comp_freq: int) -> float: Calculate the future value for a given principal, annual interest rate, number of years, and compounding frequency. :param principal: The initial amount of money invested (float). :param rate: The annual interest rate in decimal form (float). :param years: The number of years the money is invested for (float). :param comp_freq: The number of times interest is compounded per year (int). :return: The future value of the investment (float). if principal <= 0 or rate < 0 or years <= 0 or comp_freq not in [1, 2, 4, 12]: raise ValueError(\\"Invalid input values\\") future_value = principal * ((1 + rate / comp_freq) ** (comp_freq * years)) return future_value def calculate_future_value(principal: float, rate: float, years: float) -> dict: Calculate and compare future values for different compounding frequencies. :param principal: The initial amount of money invested (float). :param rate: The annual interest rate in decimal form (float). :param years: The number of years the money is invested for (float). :return: A dictionary with keys as compounding frequencies and values as the corresponding future values (float). future_values = { \\"annual\\": compound_interest(principal, rate, years, 1), \\"semi-annual\\": compound_interest(principal, rate, years, 2), \\"quarterly\\": compound_interest(principal, rate, years, 4), \\"monthly\\": compound_interest(principal, rate, years, 12) } return future_values"},{"question":"# Substring Permutations Task Write a function `count_anagram_substrings(s: str, p: str) -> int` that counts how many substrings of the string `s` are anagrams of the string `p`. Two strings are anagrams if they contain the same characters in the same frequency. Specifications - **Input**: - `s`: A string `s` where `1 <= len(s) <= 10^5` - `p`: A string `p` where `1 <= len(p) <= 100` - **Output**: The number of substrings of `s` that are anagrams of `p`. - **Constraints**: - The solution should be efficient in terms of time and space complexity. - The characters in both strings are lowercase English letters. - **Performance**: - Should ideally complete within 1 second for the upper limit of input sizes. Example ```python def count_anagram_substrings(s: str, p: str) -> int: # (Implement your solution here) pass print(count_anagram_substrings(\\"cbaebabacd\\", \\"abc\\")) # Output should be 2 (anagrams: \\"cba\\", \\"bac\\") print(count_anagram_substrings(\\"abab\\", \\"ab\\")) # Output should be 3 (anagrams: \\"ab\\", \\"ba\\", \\"ab\\") print(count_anagram_substrings(\\"abcdef\\", \\"gh\\")) # Output should be 0 ``` Hints: 1. Utilize a sliding window approach to check each substring of length equal to `p`. 2. Use a frequency count array or dictionary to keep track of character counts for efficient comparison. 3. Consider how resetting or updating the frequency count per iteration can optimize performance. Provide a well-optimized solution considering the constraints and explain the core idea behind chosen optimization techniques.","solution":"def count_anagram_substrings(s: str, p: str) -> int: from collections import Counter p_count = Counter(p) window_count = Counter() p_len = len(p) count = 0 for i in range(len(s)): window_count[s[i]] += 1 if i >= p_len: if window_count[s[i - p_len]] == 1: del window_count[s[i - p_len]] else: window_count[s[i - p_len]] -= 1 if window_count == p_count: count += 1 return count"},{"question":"# Question: Temperature Conversion and Classification As a software developer for an IoT company, you are tasked with implementing functionalities for monitoring and classifying temperature readings from various sensors. You need to write two functions: 1. **celsius_to_fahrenheit(celsius)**: - **Input**: One float `celsius`, representing the temperature in Celsius. - **Output**: The temperature converted to Fahrenheit as a float. - **Example**: ```python >>> celsius_to_fahrenheit(25.0) 77.0 ``` 2. **classify_temperature(fahrenheit)**: - **Input**: One float `fahrenheit`, representing the temperature in Fahrenheit. - **Output**: A string representing the temperature classification. - Return \\"Cold\\" if the temperature is below 32°F. - Return \\"Moderate\\" if the temperature is between 32°F and 77°F (inclusive). - Return \\"Hot\\" if the temperature is above 77°F. - **Example**: ```python >>> classify_temperature(45.0) \'Moderate\' ``` # Implementation Requirements - Ensure both functions handle a range of typical temperatures accurately. - Optimize for readability and maintainability. - Consider edge cases, such as exact boundary values for classifications. # Test Cases You should test your functions with the following cases: ```python # Test Celsius to Fahrenheit conversion assert celsius_to_fahrenheit(0) == 32.0 assert celsius_to_fahrenheit(25) == 77.0 assert celsius_to_fahrenheit(-40) == -40.0 assert celsius_to_fahrenheit(100) == 212.0 # Test temperature classification in Fahrenheit assert classify_temperature(31) == \\"Cold\\" assert classify_temperature(32) == \\"Moderate\\" assert classify_temperature(45) == \\"Moderate\\" assert classify_temperature(77) == \\"Moderate\\" assert classify_temperature(78) == \\"Hot\\" ```","solution":"def celsius_to_fahrenheit(celsius): Converts a given temperature from Celsius to Fahrenheit. Parameters: celsius (float): Temperature in Celsius. Returns: float: Temperature in Fahrenheit. return celsius * 9/5 + 32 def classify_temperature(fahrenheit): Classifies the temperature in Fahrenheit into \\"Cold\\", \\"Moderate\\", or \\"Hot\\". Parameters: fahrenheit (float): Temperature in Fahrenheit. Returns: str: \\"Cold\\", \\"Moderate\\", or \\"Hot\\" based on the temperature range. if fahrenheit < 32: return \\"Cold\\" elif 32 <= fahrenheit <= 77: return \\"Moderate\\" else: return \\"Hot\\""},{"question":"# Task You are tasked with developing a function that merges two integer lists into a single list and then removes any duplicates, ensuring the list remains sorted in ascending order. # Requirements 1. **Function**: Implement a function `merge_remove_duplicates(list1: list, list2: list) -> list` that merges two lists and removes any duplicates. 2. **Input**: Two lists of integers `list1` and `list2`, where: - Each list may contain between 0 and 10^5 integers. - Integers in the lists are not necessarily sorted. 3. **Output**: A single list of integers, sorted in ascending order with all duplicates removed. 4. **Constraints**: * The solution should be efficient, considering the potentially large input size. * The function must handle both positive and negative integers, including zero. # Example ```python def merge_remove_duplicates(list1: list, list2: list) -> list: # Your implementation here # Test cases print(merge_remove_duplicates([1, 3, 5, 7], [3, 4, 6, 7])) # Output: [1, 3, 4, 5, 6, 7] print(merge_remove_duplicates([-1, -2, -3], [1, 2, 3])) # Output: [-3, -2, -1, 1, 2, 3] print(merge_remove_duplicates([], [5, 5, 5])) # Output: [5] print(merge_remove_duplicates([10, 9, 8], [-1, 0, 10])) # Output: [-1, 0, 8, 9, 10] print(merge_remove_duplicates([], [])) # Output: [] ``` # Explanation - The function should first merge the two input lists into a single list. - Then, it should remove any duplicate elements by leveraging a data structure that naturally enforces uniqueness (e.g., a set). - Finally, sort the resulting list in ascending order before returning it. Ensure that the implementation is optimized to handle the constraints effectively, maintaining clarity and efficiency.","solution":"def merge_remove_duplicates(list1, list2): Merges two lists, removes duplicates, and returns a sorted list. Parameters: list1 (list): First list of integers list2 (list): Second list of integers Returns: list: Merged list, sorted in ascending order with duplicates removed return sorted(set(list1) | set(list2))"},{"question":"# Coding Question **Context:** Character frequency analysis is a common task in many applications including text compression, cryptography, and natural language processing. It’s useful to determine how often each character appears in a string to understand its composition. **Task:** You are required to implement a function `char_frequency(text: str) -> dict` that takes a string input and returns a dictionary where the keys are characters and the values are the count of how often each character appears in the string. **Function Signature:** ```python def char_frequency(text: str) -> dict: ``` **Input:** * `text` (str): A non-empty string consisting of any printable ASCII characters. **Output:** * A dictionary with keys as individual characters from the input string and values as their frequency counts. **Examples:** ```python >>> char_frequency(\\"hello\\") {\'h\': 1, \'e\': 1, \'l\': 2, \'o\': 1} >>> char_frequency(\\"apple\\") {\'a\': 1, \'p\': 2, \'l\': 1, \'e\': 1} >>> char_frequency(\\"123321\\") {\'1\': 2, \'2\': 2, \'3\': 2} >>> char_frequency(\\"AaBbCc\\") {\'A\': 1, \'a\': 1, \'B\': 1, \'b\': 1, \'C\': 1, \'c\': 1} ``` **Constraints:** * The input string must be non-empty. * The function should handle both uppercase and lowercase characters as different characters. * All characters are printable ASCII characters. **Edge Cases:** * An empty string should raise a `ValueError`. * Handling all kinds of printable ASCII characters (letters, digits, punctuation, etc.). **Testing:** Use the following template to test your function: ```python if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"def char_frequency(text: str) -> dict: Returns a dictionary with the frequency of each character in the input text. Raises a ValueError if the input text is empty. :param text: non-empty string consisting of any printable ASCII characters :return: dictionary with character frequency if not text: raise ValueError(\\"Input text must be non-empty\\") frequency = {} for char in text: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"# Problem Statement You are given a cylindrical tank with a known fixed radius, which can be filled up to varying heights of water. Your task is to write a function to calculate the volume of water in the tank in liters using the given formula for the volume of a cylinder: [ V = pi times r^2 times h ] where ( r ) is the radius of the cylinder and ( h ) is the height to which the water has been filled. Note that the volume in cubic meters needs to be converted to liters (1 cubic meter = 1000 liters). # Function Signature ```python def calculate_water_volume(radius: float, height: float) -> float: pass ``` # Input * `radius (float)`: The radius of the tank; must be a positive number. * `height (float)`: The height to which the tank is filled with water; must be a positive number. # Output * Returns the calculated volume of water in liters as a float. # Constraints * Both `radius` and `height` will be non-negative floats. Your function must raise a `ValueError` if either `radius` or `height` is non-positive. # Requirements * Your solution must handle and validate all possible edge cases. * Performance considerations: Ensure that your solution runs in constant time. # Example ```python >>> calculate_water_volume(radius=1, height=1) 3.141592653589793 >>> calculate_water_volume(radius=3, height=7) 197.92033717615698 >>> calculate_water_volume(radius=5, height=-2) Traceback (most recent call last): ... ValueError: Both radius and height must be positive >>> calculate_water_volume(radius=0, height=1) Traceback (most recent call last): ... ValueError: Both radius and height must be positive ``` # Implementation In this task, you are asked to implement the `calculate_water_volume` function according to the provided specifications and constraints. Ensure you handle all edge cases appropriately and raise the appropriate errors as detailed. Make sure to import the necessary constants and functions from the `math` module to handle the calculations.","solution":"import math def calculate_water_volume(radius: float, height: float) -> float: Calculate the volume of water in a cylindrical tank in liters. :param radius: The radius of the tank (must be positive) :param height: The height of filled water in the tank (must be positive) :return: Volume of water in liters :raises ValueError: If either radius or height is non-positive if radius <= 0 or height <= 0: raise ValueError(\\"Both radius and height must be positive\\") volume_cubic_meters = math.pi * radius**2 * height volume_liters = volume_cubic_meters * 1000 return volume_liters"},{"question":"# Scenario A global logistics company aims to optimize their delivery routes using a minimal spanning tree (MST) algorithm. They are particularly interested in understanding different possible network configurations. Your task is to write a Python function that calculates the number of different MSTs that can be generated from a given number of points (hubs) in a fully connected graph. # Problem Statement Implement the function `mst_configurations(hub_count: int) -> int` that returns the number of different minimal spanning trees that would connect all given hubs using a combinatorial approach and Cayley\'s formula. # Function Signature ```python def mst_configurations(hub_count: int) -> int: ``` # Input - `hub_count` (int): The number of hubs (nodes) in the fully connected graph. # Output - `int`: The number of different minimal spanning trees possible in the graph. # Constraints - The input `hub_count` will be a non-negative integer, and you must handle values as large as feasible within the capabilities of Python without causing overflow or performance degradation. # Examples ```python mst_configurations(3) -> 3 mst_configurations(4) -> 16 ``` # Guidelines 1. Use Cayley\'s formula which states that the number of MSTs in a complete graph with `n` nodes is `n^(n-2)`. 2. Ensure edge cases, like zero nodes or one node, are handled appropriately. # Hints - For `hub_count = 0` or `hub_count = 1`, the expected number of MSTs should be 1 as there is either no tree or only a single node. ```python def mst_configurations(hub_count: int) -> int: if hub_count == 0 or hub_count == 1: return 1 return hub_count ** (hub_count - 2) ``` # Explanation 1. **Cayley\'s formula**: The function leverages this formula to determine the number of different MSTs. 2. **Edge case handling**: The special cases for 0 and 1 hubs ensure correct outputs without unnecessary calculations.","solution":"def mst_configurations(hub_count: int) -> int: Returns the number of different minimal spanning trees possible in a fully connected graph with a given number of hubs (nodes) using Cayley\'s formula. Parameters: hub_count (int): The number of hubs (nodes) in the fully connected graph. Returns: int: Number of different minimal spanning trees possible. if hub_count == 0 or hub_count == 1: return 1 return hub_count ** (hub_count - 2)"},{"question":"Implement a Python function `generate_safe_prime_sequence` that takes a single integer argument `terms`. The function should generate the first `terms` Safe Prime numbers. A Safe Prime is a prime number of the form `2p + 1` where `p` is also a prime. # Requirements: 1. The function should handle edge cases such as non-positive `terms`. 2. The result should be a list of Safe Prime numbers in ascending order. # Input: - `terms` (terms > 0): Integer representing how many Safe Prime numbers to generate. # Output: - A list of `terms` Safe Prime numbers. # Function Signature ```python def generate_safe_prime_sequence(terms: int) -> list[int]: pass ``` # Example ```python # Example usage: # Generate the first 5 Safe Prime numbers: print(generate_safe_prime_sequence(5)) # Output: [5, 7, 11, 23, 47] # Generate the first 3 Safe Prime numbers: print(generate_safe_prime_sequence(3)) # Output: [5, 7, 11] # Generate the first 7 Safe Prime numbers: print(generate_safe_prime_sequence(7)) # Output: [5, 7, 11, 23, 47, 59, 83] ``` # Constraints: - The terms must be a positive integer. # Notes: - You may utilize helper functions for primality testing (`is_prime`) and for generating primes (`generate_primes_up_to`). - Ensure appropriate error handling for edge cases. - Optimize the function for performance to handle reasonably large input values efficiently.","solution":"def is_prime(n): Helper function to check if a number n is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while (i * i) <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def generate_safe_prime_sequence(terms: int) -> list[int]: Generate the first `terms` Safe Prime numbers. if terms <= 0: raise ValueError(\\"Number of terms must be a positive integer\\") safe_primes = [] i = 1 while len(safe_primes) < terms: if is_prime(i) and is_prime(2 * i + 1): safe_primes.append(2 * i + 1) i += 1 return safe_primes"},{"question":"# Context: You are developing a simple physics engine for a 2D platformer game. One of the essential features you need to implement is collision detection with simple geometric shapes, such as circles and rectangles. # Task: Implement the `detect_collision` function, which checks whether a circle and a rectangle overlap. # Specification: 1. **Function Name**: `detect_collision` 2. **Parameters**: * `circle_center` (tuple of two floats): The (x, y) coordinates of the circle\'s center. * `circle_radius` (float): The radius of the circle. * `rect_bottom_left` (tuple of two floats): The (x, y) coordinates of the bottom-left vertex of the rectangle. * `rect_width` (float): The width of the rectangle. * `rect_height` (float): The height of the rectangle. 3. **Returns**: A boolean value indicating whether the circle and rectangle overlap (True) or not (False). 4. **Constraints**: * All coordinates and dimensions can be any real numbers. 5. **Input/Output**: * Example: ```python detect_collision((1, 1), 1, (2, 2), 2, 2) ``` Should return: ```python False ``` ```python detect_collision((2, 2), 2, (1, 1), 2, 2) ``` Should return: ```python True ``` # Performance Requirements: The function should ideally run in constant time O(1), relying solely on mathematical comparisons and calculations. # Edge Cases: Consider edge cases such as: 1. The circle touching the rectangle at exactly one point. 2. The circle entirely inside or entirely outside the rectangle. # Example Usage: ```python def detect_collision(circle_center: tuple[float, float], circle_radius: float, rect_bottom_left: tuple[float, float], rect_width: float, rect_height: float) -> bool: >>> detect_collision((1, 1), 1, (2, 2), 2, 2) # doctest: +NORMALIZE_WHITESPACE False >>> detect_collision((2, 2), 2, (1, 1), 2, 2) # doctest: +NORMALIZE_WHITESPACE True circle_x, circle_y = circle_center rect_x, rect_y = rect_bottom_left # Find the closest point to the circle within the rectangle closest_x = max(rect_x, min(circle_x, rect_x + rect_width)) closest_y = max(rect_y, min(circle_y, rect_y + rect_height)) # Calculate the distance between the circle\'s center and this closest point distance_x = circle_x - closest_x distance_y = circle_y - closest_y # If the distance is less than the circle\'s radius, an intersection occurs return (distance_x**2 + distance_y**2) < circle_radius**2 ```","solution":"def detect_collision(circle_center: tuple[float, float], circle_radius: float, rect_bottom_left: tuple[float, float], rect_width: float, rect_height: float) -> bool: Determine if a circle and a rectangle overlap. Parameters: - circle_center (tuple of two floats): The (x, y) coordinates of the circle\'s center. - circle_radius (float): The radius of the circle. - rect_bottom_left (tuple of two floats): The (x, y) coordinates of the bottom-left vertex of the rectangle. - rect_width (float): The width of the rectangle. - rect_height (float): The height of the rectangle. Returns: - bool: True if the circle and rectangle overlap, False otherwise. circle_x, circle_y = circle_center rect_x, rect_y = rect_bottom_left # Find the closest point to the circle within the rectangle closest_x = max(rect_x, min(circle_x, rect_x + rect_width)) closest_y = max(rect_y, min(circle_y, rect_y + rect_height)) # Calculate the distance between the circle\'s center and this closest point distance_x = circle_x - closest_x distance_y = circle_y - closest_y # If the distance is less than the circle\'s radius, an intersection occurs return (distance_x**2 + distance_y**2) < circle_radius**2"},{"question":"# Objective Design and implement functions that perform various matrix operations with considerations for input validation and efficient algorithms. The focus is to ensure both correctness in operations and robust handling of edge cases. # Question You are tasked to implement four functions: `matrix_addition`, `matrix_subtraction`, `matrix_multiplication`, and `matrix_transpose`. These functions perform addition, subtraction, multiplication, and transposition on matrices respectively. Each of these functions takes certain matrix parameters as inputs and returns the resulting matrix. `matrix_addition` This function performs the addition of two matrices and returns the resulting matrix. **Function Signature:** ```python def matrix_addition(matrix_a: List[List[float]], matrix_b: List[List[float]]) -> List[List[float]]: ``` **Input:** * `matrix_a` (List[List[float]]): the first matrix, a non-empty list of equal-length lists of floats. * `matrix_b` (List[List[float]]): the second matrix, dimensions must match those of `matrix_a`. **Output:** * Returns a matrix representing the element-wise sum of `matrix_a` and `matrix_b`. * Raises `ValueError` if matrices have different dimensions or are empty. `matrix_subtraction` This function performs the subtraction of two matrices and returns the resulting matrix. **Function Signature:** ```python def matrix_subtraction(matrix_a: List[List[float]], matrix_b: List[List[float]]) -> List[List[float]]: ``` **Input:** * `matrix_a` (List[List[float]]): the first matrix, a non-empty list of equal-length lists of floats. * `matrix_b` (List[List[float]]): the second matrix, dimensions must match those of `matrix_a`. **Output:** * Returns a matrix representing the element-wise difference of `matrix_a` and `matrix_b`. * Raises `ValueError` if matrices have different dimensions or are empty. `matrix_multiplication` This function performs the multiplication of two matrices and returns the resulting matrix. **Function Signature:** ```python def matrix_multiplication(matrix_a: List[List[float]], matrix_b: List[List[float]]) -> List[List[float]]: ``` **Input:** * `matrix_a` (List[List[float]]): the first matrix, dimensions `m x n`. * `matrix_b` (List[List[float]]): the second matrix, dimensions `n x p`. **Output:** * Returns a matrix representing the product of `matrix_a` and `matrix_b`. * Raises `ValueError` if `matrix_a` columns do not match `matrix_b` rows, or if any matrices are empty. `matrix_transpose` This function computes the transpose of a given matrix. **Function Signature:** ```python def matrix_transpose(matrix: List[List[float]]) -> List[List[float]]: ``` **Input:** * `matrix` (List[List[float]]): the input matrix, a non-empty list of equal-length lists of floats. **Output:** * Returns a matrix representing the transpose of the input `matrix`. * Raises `ValueError` if the input matrix is empty. # Example ```python # Example function calls and expected results: matrix_a = [ [1.0, 2.0, 3.0], [4.0, 5.0, 6.0] ] matrix_b = [ [7.0, 8.0, 9.0], [10.0, 11.0, 12.0] ] matrix_c = [ [1.0, 2.0], [3.0, 4.0], [5.0, 6.0] ] print(matrix_addition(matrix_a, matrix_b)) # Expected output: [[8.0, 10.0, 12.0], [14.0, 16.0, 18.0]] print(matrix_subtraction(matrix_a, matrix_b)) # Expected output: [[-6.0, -6.0, -6.0], [-6.0, -6.0, -6.0]] print(matrix_multiplication(matrix_a, matrix_c)) # Expected output: [[22.0, 28.0], [49.0, 64.0]] print(matrix_transpose(matrix_a)) # Expected output: [[1.0, 4.0], [2.0, 5.0], [3.0, 6.0]] ``` # Constraints 1. Ensure the input matrices are validated for correct dimensions as described. 2. Guarantee precision in floating-point arithmetic. 3. Aim to implement efficient algorithms with time complexities appropriate for matrix operations. 4. Use proper exception handling where specified.","solution":"from typing import List def matrix_addition(matrix_a: List[List[float]], matrix_b: List[List[float]]) -> List[List[float]]: if not matrix_a or not matrix_b or len(matrix_a) != len(matrix_b) or len(matrix_a[0]) != len(matrix_b[0]): raise ValueError(\\"Matrices are empty or have different dimensions\\") result = [] for i in range(len(matrix_a)): row = [] for j in range(len(matrix_a[0])): row.append(matrix_a[i][j] + matrix_b[i][j]) result.append(row) return result def matrix_subtraction(matrix_a: List[List[float]], matrix_b: List[List[float]]) -> List[List[float]]: if not matrix_a or not matrix_b or len(matrix_a) != len(matrix_b) or len(matrix_a[0]) != len(matrix_b[0]): raise ValueError(\\"Matrices are empty or have different dimensions\\") result = [] for i in range(len(matrix_a)): row = [] for j in range(len(matrix_a[0])): row.append(matrix_a[i][j] - matrix_b[i][j]) result.append(row) return result def matrix_multiplication(matrix_a: List[List[float]], matrix_b: List[List[float]]) -> List[List[float]]: if not matrix_a or not matrix_b or len(matrix_a[0]) != len(matrix_b): raise ValueError(\\"Matrices are empty or have incompatible dimensions for multiplication\\") result = [] for i in range(len(matrix_a)): row = [] for j in range(len(matrix_b[0])): element_sum = 0 for k in range(len(matrix_a[0])): element_sum += matrix_a[i][k] * matrix_b[k][j] row.append(element_sum) result.append(row) return result def matrix_transpose(matrix: List[List[float]]) -> List[List[float]]: if not matrix: raise ValueError(\\"Matrix is empty\\") result = [] for i in range(len(matrix[0])): row = [] for j in range(len(matrix)): row.append(matrix[j][i]) result.append(row) return result"},{"question":"# Sorting Algorithms Performance Analyzer Context You are tasked with implementing and comparing the performance of three different sorting algorithms: Quicksort, Mergesort, and Heapsort. This will help ensure comprehension of how these algorithms operate and their computational complexity. Task 1. **Implement Sorting Algorithms**: - Implement the Quicksort, Mergesort, and Heapsort algorithms in Python. - Ensure each algorithm correctly sorts a given list of integers in ascending order. 2. **Performance Measurement**: - Create a function that takes a list of integers, applies each sorting algorithm to the list, and logs the time taken by each algorithm to sort the list. Expected Function Implementation 1. **Sorting Algorithms (Quicksort, Mergesort, Heapsort)**: ```python def quicksort(arr: list) -> list: # Your code here def mergesort(arr: list) -> list: # Your code here def heapsort(arr: list) -> list: # Your code here ``` 2. **Performance Measurement**: ```python import time def measure_performance(arr: list) -> dict: start = time.time() quicksort(arr.copy()) quicksort_time = time.time() - start start = time.time() mergesort(arr.copy()) mergesort_time = time.time() - start start = time.time() heapsort(arr.copy()) heapsort_time = time.time() - start return { \'quicksort\': quicksort_time, \'mergesort\': mergesort_time, \'heapsort\': heapsort_time } ``` Input and Output **Input**: - An unsorted list of integers **Output**: - A dictionary with the sorting algorithm names as keys and the time taken to sort the list as values Constraints - The list of integers should only contain non-negative integers. - The length of the list should be between 1 and 10^6. Scenario Implement the required sorting functions and the `measure_performance` function, then use them to evaluate the performance of each algorithm on various example lists. Validate the implementation to ensure each algorithm sorts correctly and the performance metrics accurately reflect the time taken to sort.","solution":"def quicksort(arr): if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quicksort(left) + middle + quicksort(right) def mergesort(arr): if len(arr) <= 1: return arr mid = len(arr) // 2 left = mergesort(arr[:mid]) right = mergesort(arr[mid:]) return merge(left, right) def merge(left, right): result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result def heapsort(arr): def heapify(arr, n, i): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[largest] < arr[left]: largest = left if right < n and arr[largest] < arr[right]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] heapify(arr, n, largest) n = len(arr) for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i) for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] heapify(arr, i, 0) return arr import time def measure_performance(arr): arr_copy = arr.copy() start = time.time() quicksort(arr.copy()) quicksort_time = time.time() - start start = time.time() mergesort(arr.copy()) mergesort_time = time.time() - start start = time.time() heapsort(arr_copy) heapsort_time = time.time() - start return { \'quicksort\': quicksort_time, \'mergesort\': mergesort_time, \'heapsort\': heapsort_time }"},{"question":"# Problem Statement: You are tasked to implement a function `reverse_integer(n: int) -> int` that reverses the digits of a given 32-bit signed integer `n`, returning the reversed integer. However, if the reversed integer overflows (i.e., goes beyond the range of [-2^31, 2^31 - 1]), return 0 instead. # Input: * An integer `n` (-2^31 <= n < 2^31). # Output: * An integer representing the reversed digits of `n`. If the reversed integer overflows, return 0. # Constraints: * Handle negative integers as well. * Ensure that the function adheres to the 32-bit signed integer limit constraints. # Examples: ```python reverse_integer(123) -> 321 reverse_integer(-123) -> -321 reverse_integer(1534236469) -> 0 # Overflow case reverse_integer(120) -> 21 ``` # Directions: 1. Follow the provided function signature exactly. 2. Ensure your solution efficiently handles typical input values within the constraints. 3. Consider edge cases, such as positive and negative integers as well as overflow scenarios.","solution":"def reverse_integer(n: int) -> int: Reverses the digits of a given 32-bit signed integer n, returning the reversed integer. However, if the reversed integer overflows, return 0. MIN_INT, MAX_INT = -2**31, 2**31 - 1 sign = -1 if n < 0 else 1 n = abs(n) reversed_number = int(str(n)[::-1]) * sign if reversed_number < MIN_INT or reversed_number > MAX_INT: return 0 return reversed_number"},{"question":"# Question Context You are the lead developer for a project requiring data serialization and deserialization between JSON format and Python objects. You will implement a serializer and deserializer to convert between nested Python dictionaries (with potentially varying levels of depth) and their JSON string representations. Objective Write two functions: `serialize_to_json` and `deserialize_from_json` to handle the serialization and deserialization processes respectively. Function Signatures ```python def serialize_to_json(data: dict) -> str: ``` ```python def deserialize_from_json(data: str) -> dict: ``` Input **For `serialize_to_json` function**: - `data`: A nested dictionary containing primitive data types such as integers, floats, strings, and booleans. Nested dictionaries may vary in depth. **For `deserialize_from_json` function**: - `data`: A JSON string representing a nested dictionary. Output **For `serialize_to_json` function**: - A JSON formatted string representing the nested dictionary. **For `deserialize_from_json` function**: - A nested dictionary parsed from the JSON string. Constraints - The dictionaries can be arbitrarily nested but will contain only primitive data types (int, float, str, bool) or other nested dictionaries. - You can assume the inputs are always valid and do not require extensive input validation. Examples 1. Serialization: ```python data = { \\"name\\": \\"John\\", \\"age\\": 30, \\"is_student\\": False, \\"courses\\": { \\"math\\": 95.5, \\"science\\": 89 } } result = serialize_to_json(data) ``` Expected output: ```json \'{\\"name\\": \\"John\\", \\"age\\": 30, \\"is_student\\": false, \\"courses\\": {\\"math\\": 95.5, \\"science\\": 89}}\' ``` 2. Deserialization: ```python json_str = \'{\\"name\\": \\"John\\", \\"age\\": 30, \\"is_student\\": false, \\"courses\\": {\\"math\\": 95.5, \\"science\\": 89}}\' result = deserialize_from_json(json_str) ``` Expected output: ```python { \\"name\\": \\"John\\", \\"age\\": 30, \\"is_student\\": False, \\"courses\\": { \\"math\\": 95.5, \\"science\\": 89 } } ``` # Notes - You may use Python\'s `json` module for handling JSON operations. - Ensure your implementation correctly translates between nested dictionaries and their JSON string equivalents, maintaining the integrity of the data.","solution":"import json def serialize_to_json(data: dict) -> str: Serializes a nested dictionary to a JSON formatted string. Args: data (dict): Nested dictionary to be serialized. Returns: str: JSON formatted string. return json.dumps(data) def deserialize_from_json(data: str) -> dict: Deserializes a JSON formatted string to a nested dictionary. Args: data (str): JSON formatted string to be deserialized. Returns: dict: Nested dictionary. return json.loads(data)"},{"question":"# Coding Assessment Question As part of your assessments on advanced algorithms and data structures, you are tasked with implementing a function that simulates an autonomous drone\'s path planning to avoid obstacles in a 2D grid. The drone employs a simple flood fill algorithm to determine the shortest path from its starting position to its destination while avoiding obstacles. Function Signature ```python def plan_drone_path(grid, start, end): pass ``` Input/Output * **Input**: - `grid`: A 2D list of integers where a `0` represents an open cell and a `1` represents an obstacle (e.g., `[[0, 1], [0, 0]]`). - `start`: A tuple `(x, y)` representing the drone\'s start coordinates. - `end`: A tuple `(x, y)` representing the drone\'s destination coordinates. * **Output**: - Returns a list of tuples representing the path from `start` to `end`. If no path exists, return an empty list. Constraints * The grid has at least one row and one column. * `start` and `end` positions are guaranteed to be within grid bounds. * If `start` equals `end`, the path should be a list containing the `start` position `(x, y)`. * Movement is allowed in 4 directions: up, down, left, and right. Scenario Imagine you are developing a navigation system for a drone delivery service. The drone must autonomously compute a path to avoid buildings and other obstacles to deliver packages efficiently. Your task is to develop a reliable and efficient path-planning mechanism using a flood fill strategy. Example ```python # Example usage grid = [ [0, 0, 0], [1, 1, 0], [0, 0, 0] ] start = (0, 0) end = (2, 2) print(plan_drone_path(grid, start, end)) # Output: [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)] grid2 = [ [0, 1], [1, 0] ] start2 = (0, 0) end2 = (1, 1) print(plan_drone_path(grid2, start2, end2)) # Output: [] ``` Performance Requirements * Must handle grids up to 100x100 within reasonable computation times (≤ 1 second). Note Your solution should be optimized for the shortest possible path, ensuring that the drone avoids obstacles and reaches its destination as efficiently as possible.","solution":"from collections import deque def plan_drone_path(grid, start, end): if start == end: return [start] rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([start]) came_from = {start: None} while queue: current = queue.popleft() if current == end: path = [] while current: path.append(current) current = came_from[current] return path[::-1] for direction in directions: next_cell = (current[0] + direction[0], current[1] + direction[1]) if 0 <= next_cell[0] < rows and 0 <= next_cell[1] < cols and next_cell not in came_from and grid[next_cell[0]][next_cell[1]] == 0: queue.append(next_cell) came_from[next_cell] = current return []"},{"question":"# Question: Calculate Littlewood Polynomial Roots Littlewood polynomials are polynomials where each coefficient is either +1 or −1. Given a Littlewood polynomial of degree n, calculate the real and complex roots of the polynomial using numerical methods. Write a function `littlewood_roots(coefficients: List[int]) -> List[complex]` that accepts the coefficients of a Littlewood polynomial and returns a list of its roots. Ensure your method can handle polynomials up to degree 10 efficiently. **Function Signature**: ```python def littlewood_roots(coefficients: List[int]) -> List[complex]: ``` **Input**: - `coefficients`: a list of integers where each integer is either +1 or −1, representing the coefficients of the Littlewood polynomial from the highest degree to the constant term. (1 ≤ len(coefficients) ≤ 11) **Output**: - a list of complex numbers representing the roots of the polynomial. The list can include both real and complex roots. **Constraints**: - The polynomial coefficients will be either +1 or −1. - The length of `coefficients` will be at most 11. **Examples**: ```python >>> littlewood_roots([1, -1, 1, -1]) [(0.5-0.8660254037844386j), (0.5+0.8660254037844386j), (-1.0000000000000002+0j)] >>> littlewood_roots([-1, 1, -1, 1, -1]) [(0.8090169943749473-0j), (0.30901699437494723+0.9510565162951536j), (0.30901699437494723-0.9510565162951536j), (-1.6180339887498945-0j)] ``` # Context Littlewood polynomials present a fascinating class of polynomials with a simple yet highly structured form. Accurate computation of their roots requires numerical precision, given the alternating coefficient sequence. Your implementation should efficiently apply numerical methods to determine all roots, leveraging appropriate libraries and algorithms if necessary.","solution":"from typing import List import numpy as np def littlewood_roots(coefficients: List[int]) -> List[complex]: Given the coefficients of a Littlewood polynomial, returns a list of its roots. Args: coefficients (List[int]): A list of integers (either +1 or −1) representing the coefficients of the Littlewood polynomial from the highest degree to the constant term. Returns: List[complex]: A list of complex numbers representing the roots of the polynomial. # Finding the roots using numpy\'s roots function roots = np.roots(coefficients) return roots.tolist()"},{"question":"# **Prime Factors Product** You are given a positive integer `n`. Your task is to implement a function `prime_factors_product(n: int) -> int` that returns the product of all distinct prime factors of `n`. If `n` is 1, return 1. # **Input** - **n**: A positive integer such that (1 leq n leq 10^6). # **Output** Return the product of all distinct prime factors of `n`. # **Example** ```python >>> prime_factors_product(18) 6 >>> prime_factors_product(28) 14 >>> prime_factors_product(1) 1 ``` # **Constraints** - The input value `n` will be a positive integer within the range `[1, 1,000,000]`. # **Requirements** - The implementation must handle typical edge cases, including very small inputs like `n = 1`. - Efficiency is important: your solution should avoid unnecessary computations for higher values of `n`. # **Implementation Notes** Consider using the Sieve of Eratosthenes to generate prime numbers up to (sqrt{n}) efficiently. Then, determine the prime factors of `n` and compute their product. Remember to handle the case where `n` is itself a prime number or when it has multiple small prime factors.","solution":"def prime_factors_product(n: int) -> int: if n == 1: return 1 def sieve(max_num): is_prime = [True] * (max_num + 1) is_prime[0] = is_prime[1] = False for i in range(2, int(max_num**0.5) + 1): if is_prime[i]: for j in range(i * i, max_num + 1, i): is_prime[j] = False return [i for i in range(max_num + 1) if is_prime[i]] prime_factors = set() limit = int(n**0.5) + 1 primes = sieve(limit) for prime in primes: while n % prime == 0: prime_factors.add(prime) n //= prime if n == 1: break if n > 1: prime_factors.add(n) product = 1 for factor in prime_factors: product *= factor return product"},{"question":"# Task Implement a function `is_ascii_balanced(s: str) -> bool` to determine if a given string `s` has balanced ASCII values for its characters. A string is considered ASCII balanced if the average ASCII value of its characters is an integer. # Input - A string `s` consisting of between 1 and ( 10^6 ) characters. # Output - Return a boolean value: `True` if the string is ASCII balanced, and `False` otherwise. # Constraints - The solution should operate within O(n) time complexity where n is the length of the string. - Minimize additional space usage, aiming for O(1) extra space. # Example ```python >>> is_ascii_balanced(\\"abc\\") True >>> is_ascii_balanced(\\"abcd\\") False >>> is_ascii_balanced(\\"a\\") True >>> is_ascii_balanced(\\"abcdefghi\\") True ``` # Notes - Calculate the average ASCII value of the characters in the string, and check if it\'s an integer. - Consider edge cases such as single-character strings which are always balanced.","solution":"def is_ascii_balanced(s: str) -> bool: Determines if the average ASCII value of characters in the string s is an integer. if not s: return False # Return False for empty string as input constraints ensure 1 <= len(s) total_ascii_value = sum(ord(char) for char in s) return total_ascii_value % len(s) == 0"},{"question":"# Scenario You are helping a music streaming service company implement a feature that generates random playlists for their users. Your task is to write a function that selects a subset of songs from a given list such that each selected song is unique and the number of selected songs is a specified length. # Problem Statement Write a function `generate_random_playlist` that selects a specified number of unique songs from a given list of songs. # Function Signature ```python import random from typing import List def generate_random_playlist(songs: List[str], number_of_songs: int) -> List[str]: Parameters: 1. songs (List[str]): A list of available songs as strings. 2. number_of_songs (int): The number of unique songs to be selected for the playlist. Returns: List[str]: A list containing the selected unique songs. Raises: ValueError: If \'number_of_songs\' is greater than the length of \'songs\' or if \'number_of_songs\' is non-positive. ``` # Input * `songs` is a list of strings representing available songs. * `number_of_songs` is an integer representing the number of unique songs to select for the playlist. # Output * A list of strings, each representing a unique song selected for the playlist. # Constraints * Ensure `number_of_songs` is positive. * Ensure `number_of_songs` is less than or equal to the number of available songs. # Examples ```python # Example 1 songs_list = [\\"Song A\\", \\"Song B\\", \\"Song C\\", \\"Song D\\", \\"Song E\\"] playlist = generate_random_playlist(songs_list, 3) print(playlist) # Expected output (example): [\\"Song B\\", \\"Song A\\", \\"Song D\\"] # Example 2 songs_list = [\\"Song A\\", \\"Song B\\", \\"Song C\\"] playlist = generate_random_playlist(songs_list, 2) print(playlist) # Expected output (example): [\\"Song C\\", \\"Song B\\"] # Edge Case 1 try: generate_random_playlist(songs_list, 0) except ValueError as e: print(e) # Expected: The number of songs to select must be positive. # Edge Case 2 try: generate_random_playlist(songs_list, 5) except ValueError as e: print(e) # Expected: The number of songs to select must not exceed the available songs. ``` # Additional Notes You should raise appropriate exceptions for invalid inputs according to the constraints described. # Example Implementation ```python def generate_random_playlist(songs_list, number_of_songs): if number_of_songs <= 0: raise ValueError(\\"The number of songs to select must be positive.\\") if number_of_songs > len(songs_list): raise ValueError(\\"The number of songs to select must not exceed the available songs.\\") return random.sample(songs_list, number_of_songs) ```","solution":"import random from typing import List def generate_random_playlist(songs: List[str], number_of_songs: int) -> List[str]: Selects a specified number of unique songs from a given list of songs. Parameters: 1. songs (List[str]): A list of available songs as strings. 2. number_of_songs (int): The number of unique songs to be selected for the playlist. Returns: List[str]: A list containing the selected unique songs. Raises: ValueError: If \'number_of_songs\' is greater than the length of \'songs\' or if \'number_of_songs\' is non-positive. if number_of_songs <= 0: raise ValueError(\\"The number of songs to select must be positive.\\") if number_of_songs > len(songs): raise ValueError(\\"The number of songs to select must not exceed the available songs.\\") return random.sample(songs, number_of_songs)"},{"question":"# Problem Description Write a function that takes an integer `n` and returns a list of all prime factors of `n` in ascending order. # Constraints * The function should handle all integers `n` in the range `[2, 10^6]`. * You may assume that standard integer operations (addition, subtraction, multiplication, division) will be feasible within these inputs. # Input * An integer `n` (2 ≤ n ≤ 10^6). # Output * A list of integers representing the prime factors of `n` in ascending order. # Function Signature ```python def prime_factors(n: int) -> List[int]: ``` # Example ```python >>> prime_factors(28) [2, 7] >>> prime_factors(45) [3, 5] >>> prime_factors(97) [97] >>> prime_factors(100) [2, 5] >>> prime_factors(2) [2] ``` # Approach 1. Implement a helper function to check if a number is prime. 2. Iterate through potential factors starting from the smallest, and check each for primality. 3. If a factor is prime and divides `n` without a remainder, add it to the list of factors and divide `n` by this factor. 4. Repeat until `n` is reduced to 1. # Note - The function should aim for efficient computation to handle the upper limits of the input range. - Consider edge cases such as very small primes and their multiples.","solution":"def prime_factors(n): Returns the prime factors of n in ascending order. factors = [] # Handle the smallest prime number 2 separately to avoid even number checks further. while n % 2 == 0: if 2 not in factors: factors.append(2) n //= 2 # Check for other factors from 3 onwards. factor = 3 while factor * factor <= n: while n % factor == 0: if factor not in factors: factors.append(factor) n //= factor factor += 2 # If n becomes a prime number greater than 2 if n > 2: factors.append(n) return factors"},{"question":"# Question: Implement Insert and Delete Operations in a Heap Context A min heap is a complete binary tree where the value of each node is less than or equal to the values of its children. Your task is to implement functions to insert a new value into the heap and delete the minimum value from the heap. You are required to maintain the heap property after each operation. Requirements 1. **Function 1: Insert into Heap** ```python def insert(heap: list, value: int) -> list: Insert a value into the min heap and return the updated heap. \'heap\' is a list representing a min heap. \'value\' is the integer to be inserted. Example: >>> insert([3, 9, 7, 15], 6) [3, 6, 7, 15, 9] ``` 2. **Function 2: Delete Minimum from Heap** ```python def delete_min(heap: list) -> int: Delete the minimum value from the min heap and return the updated heap. \'heap\' is a list representing a min heap. Return the minimum value which was removed from the heap. Example: >>> delete_min([3, 6, 7, 15, 9]) (3, [6, 9, 7, 15]) ``` Constraints - The heap must always conform to the min heap property. - The heap is represented as a list, where the root of the heap is the first element of the list. Performance Requirements - Aim for efficient implementations where insert and delete operations maintain the logarithmic time complexity relative to the size of the heap. Edge Cases - Handle empty heaps for the delete operation appropriately. - Ensure the functions raise appropriate errors for invalid inputs. Write code that performs these operations, verifying through provided examples.","solution":"def insert(heap: list, value: int) -> list: Insert a value into the min heap and return the updated heap. Parameters: heap (list): The list representation of the min heap. value (int): The value to be inserted into the heap. Returns: list: The updated heap after insertion. # Insert the new value at the end of the heap heap.append(value) # Percolate the new value up to maintain heap property index = len(heap) - 1 while index > 0: parent_index = (index - 1) // 2 if heap[index] < heap[parent_index]: # Swap if the current node is less than the parent node heap[index], heap[parent_index] = heap[parent_index], heap[index] index = parent_index else: break return heap def delete_min(heap: list) -> int: Delete the minimum value from the min heap and return the updated heap. Parameters: heap (list): The list representation of the min heap. Returns: (int, list): The minimum value which was removed from the heap and the updated heap. if len(heap) == 0: raise IndexError(\\"Cannot delete min from an empty heap.\\") # Swap the root with the last element and remove the last element heap[0], heap[-1] = heap[-1], heap[0] min_value = heap.pop() # Percolate the new root down to maintain heap property index = 0 while True: left_child = 2 * index + 1 right_child = 2 * index + 2 smallest = index if left_child < len(heap) and heap[left_child] < heap[smallest]: smallest = left_child if right_child < len(heap) and heap[right_child] < heap[smallest]: smallest = right_child if smallest != index: heap[smallest], heap[index] = heap[index], heap[smallest] index = smallest else: break return min_value, heap"},{"question":"# Rotating a Matrix Layer by Layer You are required to implement a function that rotates a given `n x n` 2D matrix by 90 degrees clockwise, but instead of rotating the entire matrix at once, you need to rotate the matrix layer by layer. Each layer represents a concentric square starting from the outermost one. Function Signature ```python def rotate_matrix_layer_by_layer(matrix: list[list[int]]) -> list[list[int]]: Parameters: - matrix (list[list[int]]): A 2D list of integers representing the matrix to be rotated. Returns: - list[list[int]]: A 2D list representing the matrix after rotating it 90 degrees clockwise. Constraints: - The matrix must be a square (n x n). - The function should rotate the matrix layer by layer in-place. ``` Input - A square matrix `matrix` where `matrix[i][j]` is an integer and `1 <= len(matrix) <= 500`. Output - A new matrix obtained after rotating the original matrix 90 degrees clockwise. Example ```python >>> rotate_matrix_layer_by_layer([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> rotate_matrix_layer_by_layer([ ... [ 5, 1, 9, 11], ... [ 2, 4, 8, 10], ... [13, 3, 6, 7], ... [15, 14, 12, 16] ... ]) [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] >>> rotate_matrix_layer_by_layer([[1]]) [[1]] ``` Constraints - The matrix must be a square matrix with dimensions `n x n`. - The input matrix will contain only integers. - You need to handle invalid inputs, such as non-square matrices and non-integer matrix elements.","solution":"def rotate_matrix_layer_by_layer(matrix): Rotates the given n x n matrix 90 degrees clockwise layer by layer. Parameters: - matrix (list[list[int]]): A 2D list of integers representing the matrix to be rotated. Returns: - list[list[int]]: A 2D list representing the matrix after rotating it 90 degrees clockwise. if not all(isinstance(row, list) and all(isinstance(elem, int) for elem in row) for row in matrix): raise ValueError(\\"The matrix must be a 2D list of integers.\\") n = len(matrix) if any(len(row) != n for row in matrix): raise ValueError(\\"The matrix must be a square matrix.\\") for layer in range(n // 2): first = layer last = n - layer - 1 for i in range(first, last): offset = i - first top = matrix[first][i] matrix[first][i] = matrix[last - offset][first] matrix[last - offset][first] = matrix[last][last - offset] matrix[last][last - offset] = matrix[i][last] matrix[i][last] = top return matrix"},{"question":"# Scenario You are tasked with handling a sequence of operations on an array that allows for efficient prefix sum calculations after performing a series of updates. This is useful in scenarios where the data continually changes, and quick recalculations are necessary. # Task Implement a Fenwick Tree (also known as Binary Indexed Tree) that supports the following operations efficiently: 1. **Update**: Increment the value at a specific index by a given amount. 2. **Prefix Sum**: Calculate the sum of elements from the start of the array up to a given index. # Input and Output Format * **Input**: 1. `arr` - A list of integers, which represents the initial state of the array. 2. `queries` - A list of dictionary objects, each with: - `type` - Either `\'update\'` or `\'prefix_sum\'`. - Additional parameters based on `type`: - For `\'update\'`: `index` (index of the element to be updated), `value` (the amount to increment). - For `\'prefix_sum\'`: `index` (the end index for the prefix sum calculation). * **Output**: - A list of integers, each being the result of a corresponding `\'prefix_sum\'` query. # Constraints - The list `arr` will contain integers where (0 leq arr[i] leq 10^6). - The length of `arr` will be up to (10^5). - The number of queries will be up to (10^4). Your solution should prioritize efficient query handling. # Example ```python from typing import List, Dict, Union Query = Dict[str, Union[str, int]] class FenwickTree: def __init__(self, size: int): self.size = size self.tree = [0] * (size + 1) def update(self, index: int, value: int): index += 1 while index <= self.size: self.tree[index] += value index += index & -index def prefix_sum(self, index: int) -> int: sum_ = 0 index += 1 while index > 0: sum_ += self.tree[index] index -= index & -index return sum_ def fenwick_tree(queries: List[Query], arr: List[int]) -> List[int]: ft = FenwickTree(len(arr)) for i, num in enumerate(arr): ft.update(i, num) result = [] for query in queries: if query[\\"type\\"] == \\"update\\": ft.update(query[\\"index\\"], query[\\"value\\"]) elif query[\\"type\\"] == \\"prefix_sum\\": result.append(ft.prefix_sum(query[\\"index\\"])) return result # Example usage: test_array = [1, 7, 3, 0, 7, 8, 3, 2, 6, 2] test_queries = [ {\\"type\\": \\"prefix_sum\\", \\"index\\": 5}, {\\"type\\": \\"update\\", \\"index\\": 3, \\"value\\": 5}, {\\"type\\": \\"prefix_sum\\", \\"index\\": 5}, ] print(fenwick_tree(test_queries, test_array)) # Expected output: [26, 31] ``` This new question involves constructing and manipulating a Fenwick Tree for efficiently handling updates and prefix sum queries, testing skills in data structures, specifically binary indexed trees, and ensuring efficient algorithm implementation.","solution":"from typing import List, Dict, Union Query = Dict[str, Union[str, int]] class FenwickTree: def __init__(self, size: int): self.size = size self.tree = [0] * (size + 1) def update(self, index: int, value: int): index += 1 while index <= self.size: self.tree[index] += value index += index & -index def prefix_sum(self, index: int) -> int: sum_ = 0 index += 1 while index > 0: sum_ += self.tree[index] index -= index & -index return sum_ def fenwick_tree(queries: List[Query], arr: List[int]) -> List[int]: ft = FenwickTree(len(arr)) for i, num in enumerate(arr): ft.update(i, num) result = [] for query in queries: if query[\\"type\\"] == \\"update\\": ft.update(query[\\"index\\"], query[\\"value\\"]) elif query[\\"type\\"] == \\"prefix_sum\\": result.append(ft.prefix_sum(query[\\"index\\"])) return result"},{"question":"# Coding Assessment: Motion of a Projectile An object is projected from the ground at an angle `theta` to the horizontal with an initial velocity of `v_0`. The object follows a parabolic path due to gravity. Write a program to calculate various parameters of the projectile motion using the given relationships. You need to implement three core functions to complete the task: 1. **maximum_height** 2. **time_of_flight** 3. **range_of_projectile** Requirements 1. **maximum_height(v_0, theta):** - **Input**: - `v_0`: float, initial velocity of the object in meters per second (m/s). - `theta`: float, angle of projection with the horizontal in degrees. - **Output**: - Returns a float representing the maximum height `H` reached by the projectile in meters. - **Constraints**: - Raise `ValueError` if either `v_0` is non-positive or `theta` is not within the range of (0, 90) degrees. 2. **time_of_flight(v_0, theta):** - **Input**: - `v_0`: float, initial velocity of the object in meters per second (m/s). - `theta`: float, angle of projection with the horizontal in degrees. - **Output**: - Returns a float representing the total time `T` of flight of the projectile in seconds. - **Constraints**: - Raise `ValueError` if either `v_0` is non-positive or `theta` is not within the range of (0, 90) degrees. 3. **range_of_projectile(v_0, theta):** - **Input**: - `v_0`: float, initial velocity of the object in meters per second (m/s). - `theta`: float, angle of projection with the horizontal in degrees. - **Output**: - Returns a float representing the horizontal range `R` of the projectile in meters. - **Constraints**: - Raise `ValueError` if either `v_0` is non-positive or `theta` is not within the range of (0, 90) degrees. For the calculation, use the following physical relationships: - ( H = frac{v_0^2 sin^2(theta)}{2g} ) - ( T = frac{2v_0 sin(theta)}{g} ) - ( R = frac{v_0^2 sin(2theta)}{g} ) where ( g ) is the acceleration due to gravity (9.81 m/s²). Ensure your solution includes appropriate error handling as specified and follows the given mathematical relationships. Example ```python from math import sin, radians # Given initial velocity and angle of projection, calculate maximum height H = maximum_height(20, 45) # Expected: 10.204 # Given initial velocity and angle of projection, calculate time of flight T = time_of_flight(20, 45) # Expected: 2.886 # Given initial velocity and angle of projection, calculate range of projectile R = range_of_projectile(20, 45) # Expected: 40.816 ``` Use the above-mentioned function definitions to implement the required functionality.","solution":"import math def maximum_height(v_0, theta): Returns the maximum height reached by the projectile. Parameters: v_0 (float): Initial velocity in m/s theta (float): Angle of projection in degrees Returns: float: Maximum height in meters if v_0 <= 0 or not (0 < theta < 90): raise ValueError(\\"Invalid inputs: v_0 must be positive and 0 < theta < 90\\") g = 9.81 # acceleration due to gravity in m/s^2 theta_radians = math.radians(theta) H = (v_0**2 * math.sin(theta_radians)**2) / (2 * g) return H def time_of_flight(v_0, theta): Returns the total time of flight of the projectile. Parameters: v_0 (float): Initial velocity in m/s theta (float): Angle of projection in degrees Returns: float: Total time of flight in seconds if v_0 <= 0 or not (0 < theta < 90): raise ValueError(\\"Invalid inputs: v_0 must be positive and 0 < theta < 90\\") g = 9.81 # acceleration due to gravity in m/s^2 theta_radians = math.radians(theta) T = (2 * v_0 * math.sin(theta_radians)) / g return T def range_of_projectile(v_0, theta): Returns the horizontal range of the projectile. Parameters: v_0 (float): Initial velocity in m/s theta (float): Angle of projection in degrees Returns: float: Horizontal range in meters if v_0 <= 0 or not (0 < theta < 90): raise ValueError(\\"Invalid inputs: v_0 must be positive and 0 < theta < 90\\") g = 9.81 # acceleration due to gravity in m/s^2 theta_radians = math.radians(theta) R = (v_0**2 * math.sin(2 * theta_radians)) / g return R"},{"question":"**Question 2**: # Binary Search for Sorted Array of Tuples As a proficient developer, you need to come up with an efficient way to search through sorted collections. One common scenario is searching within a sorted array of tuples. Your task is to implement a binary search algorithm that finds the index of a given target value within such a collection. Function Signature ```python def binary_search_tuples(collection: list, target: int) -> int: ``` # Input - `collection` (list): A list of tuples, where each tuple contains two integers `(a, b)`, and the list is sorted in ascending order first by `a` and then by `b`. - `target` (int): An integer value that you need to search for in the tuples. The function should search for the target in the tuple\'s first element `a`. # Output - Returns the index of the tuple where the first element equals the target. If the target is not found, return `-1`. # Constraints 1. The input list of tuples will be non-empty and sorted as described. 2. Duplicate values of `a` in the tuples are allowed. 3. The target should be checked against the first element (`a`) of each tuple. # Performance Requirements - Your function should run in O(log n) time complexity by leveraging the binary search algorithm. # Example ```python print(binary_search_tuples([(1, 3), (2, 4), (5, 6), (7, 8)], 5)) # Output: 2 print(binary_search_tuples([(1, 3), (2, 4), (2, 5), (7, 8)], 2)) # Output: 1 (or possibly 2, if duplicates are present) print(binary_search_tuples([(1, 3), (2, 4), (2, 5), (7, 8)], 6)) # Output: -1 print(binary_search_tuples([(1, 3)], 1)) # Output: 0 ``` # Detailed Requirements 1. Implement the binary search algorithm to efficiently search for the target. 2. The function should handle edge cases such as: - A single tuple in the list. - The target value at the first or last position. - Duplicates for the first element in tuples. 3. Ensure to return the index of the first occurrence if duplicates are present. **Note**: You are not allowed to use built-in search functions. The goal is to use your understanding of the binary search mechanism to implement a solution that ensures logarithmic time complexity.","solution":"def binary_search_tuples(collection: list, target: int) -> int: Performs a binary search on a sorted list of tuples to find the index of the tuple where the first element equals the target. Parameters: collection (list): List of tuples, where each tuple contains two integers (a, b), sorted in ascending order first by a and then by b. target (int): The integer value to search for in the first element of the tuples. Returns: int: The index of the tuple where the first element equals the target, or -1 if the target is not found. left, right = 0, len(collection) - 1 while left <= right: mid = (left + right) // 2 mid_value = collection[mid][0] if mid_value == target: return mid elif mid_value < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Coding Assessment Question: Unique Paths in a Grid Problem Statement You are given an `m x n` grid. Write a function `unique_paths` to calculate the number of unique paths from the top-left corner of the grid (start at cell `(0, 0)`) to the bottom-right corner of the grid (end at cell `(m-1, n-1)`). You can only move either down or to the right at any point in time. Write a class `GridPathCalculator` that includes the following methods: 1. `__init__()`: Initialization method. 2. `unique_paths(self, m: int, n: int) -> int`: This method calculates the number of unique paths in an `m x n` grid. Requirements: - **Input Format**: - `m`: Number of rows in the grid (`int`). - `n`: Number of columns in the grid (`int`). - **Output Format**: - An integer representing the number of unique paths from the top-left corner to the bottom-right corner (`int`). Constraints: - The grid\'s dimensions `m` and `n` are between `1` and `100`. # Scenario Consider the following scenario to ensure clarity of the problem: You are given a grid with dimensions `3 x 7`. Your function should return `28` which is the number of unique paths from the top-left to the bottom-right corner. Here is an example of calculating unique paths in a `3 x 3` grid: ``` Total paths from (0, 0) to (2, 2): (0, 0) -> (0, 1) -> (0, 2) -> (1, 2) -> (2, 2) (0, 0) -> (0, 1) -> (1, 1) -> (1, 2) -> (2, 2) ... (0, 0) -> (1, 0) -> (2, 0) -> (2, 1) -> (2, 2) ``` You should return `6` for a `3 x 3` grid. You are encouraged to use memoization or dynamic programming to optimize the performance. You can use the provided `Grid` class below to represent the grid if necessary: ```python class Grid: A Grid has dimensions and can be traversed. def __init__(self, rows: int, cols: int) -> None: self.rows = rows self.cols = cols ``` Example Usage ```python calculator = GridPathCalculator() print(calculator.unique_paths(3, 7)) # Output: 28 print(calculator.unique_paths(3, 3)) # Output: 6 ```","solution":"class GridPathCalculator: def __init__(self): pass def unique_paths(self, m: int, n: int) -> int: # Initialize a 2D list to store the number of paths to each cell dp = [[1] * n for _ in range(m)] for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"# Coding Question Context You are working on a custom data structure that is a mix between a stack and a queue, often called a \\"dq-stack\\". A dq-stack allows for typical stack operations (push and pop) and queue operations (enqueue and dequeue) but in a way that both last-in-first-out (LIFO) and first-in-first-out (FIFO) sequences are maintained. Problem Statement Implement a class `DQStack` that supports the following methods: 1. `push` - pushes an element onto the stack. 2. `pop` - removes and returns the top element from the stack. 3. `enqueue` - enqueues an element to the queue. 4. `dequeue` - removes and returns the front element from the queue. ```python class DQStack: def __init__(self): Initializes the data structure with empty stack and queue. pass def push(self, x): Pushes an element x onto the stack. Parameters: x (int): The element to be pushed onto the stack. pass def pop(self): Removes the element on the top of the stack and returns that element. Returns: int: The element on the top of the stack. pass def enqueue(self, x): Enqueues an element x to the queue. Parameters: x (int): The element to be enqueued to the queue. pass def dequeue(self): Removes the element at the front of the queue and returns that element. Returns: int: The element at the front of the queue. pass ``` # Constraints 1. The dq-stack must efficiently support all operations. 2. Stack operations (`push` and `pop`) must operate in constant time, O(1). 3. Queue operations (`enqueue` and `dequeue`) should also operate efficiently. Example ```python dqstack = DQStack() dqstack.push(1) # Stack is [1] dqstack.push(2) # Stack is [1, 2] dqstack.enqueue(3) # Queue is [3] dqstack.enqueue(4) # Queue is [3, 4] assert dqstack.pop() == 2 # Returns 2, stack is [1] assert dqstack.pop() == 1 # Returns 1, stack is [] assert dqstack.dequeue() == 3 # Returns 3, queue is [4] assert dqstack.dequeue() == 4 # Returns 4, queue is [] ``` # Performance Requirements Ensure that the `push`, `pop`, `enqueue`, and `dequeue` methods are efficiently implemented. Utilize appropriate data structure mechanisms to maintain O(1) stack operations and aim to optimize queue operations.","solution":"class DQStack: def __init__(self): Initializes the data structure with empty stack and queue. self.stack = [] self.queue = [] def push(self, x): Pushes an element x onto the stack. Parameters: x (int): The element to be pushed onto the stack. self.stack.append(x) def pop(self): Removes the element on the top of the stack and returns that element. Returns: int: The element on the top of the stack. if not self.stack: raise IndexError(\\"pop from empty stack\\") return self.stack.pop() def enqueue(self, x): Enqueues an element x to the queue. Parameters: x (int): The element to be enqueued to the queue. self.queue.append(x) def dequeue(self): Removes the element at the front of the queue and returns that element. Returns: int: The element at the front of the queue. if not self.queue: raise IndexError(\\"dequeue from empty queue\\") return self.queue.pop(0)"},{"question":"# Task You are given a class implementation designed for basic mathematical operations on complex numbers. Your task is to enhance this class by adding a new method to compute the conjugate of a complex number and ensure that the existing addition and multiplication methods are compatible with this new method. # Additional Method to Implement: **Method Name**: `conjugate` **Purpose**: Compute the conjugate of a given complex number. The conjugate of a complex number ( a + bi ) is ( a - bi ). # Implementation Steps: 1. Add a new method `conjugate` to the `ComplexNumber` class that returns a new `ComplexNumber` instance representing the conjugate of the original. 2. Ensure that the `add` and `multiply` methods can work correctly with the conjugate method. # Input and Output: Use the following format to represent and manipulate complex numbers: * Instantiate the `ComplexNumber` object with real and imaginary parts. * Use the `conjugate` method to compute the conjugate of the complex number. * Ensure the `add` and `multiply` methods produce correct results when integrated with the new `conjugate` feature. * Verify your implementation by running the example test case provided. # Constraints: - The real and imaginary parts are integers and can be negative. - The resulting complex numbers should be of type `ComplexNumber`. # Example ```python class ComplexNumber: def __init__(self, real, imag): self.real = real self.imag = imag def add(self, other): return ComplexNumber(self.real + other.real, self.imag + other.imag) def multiply(self, other): real_part = self.real * other.real - self.imag * other.imag imag_part = self.real * other.imag + self.imag * other.real return ComplexNumber(real_part, imag_part) def conjugate(self): return ComplexNumber(self.real, -self.imag) def __str__(self): return f\\"{self.real} + {self.imag}i\\" # Example usage c1 = ComplexNumber(3, 4) c2 = ComplexNumber(1, -2) conjugate_of_c1 = c1.conjugate() sum_result = c1.add(conjugate_of_c1) product_result = c1.multiply(c2) print(\\"Conjugate of c1:\\", conjugate_of_c1) print(\\"Sum of c1 and its conjugate:\\", sum_result) print(\\"Product of c1 and c2:\\", product_result) ``` - `conjugate_of_c1` should yield `3 - 4i`. - `sum_result` should yield `6 + 0i`. - `product_result` should yield `11 + 2i`. Reference the structure and methods of the provided class code to ensure consistency. Implement as described and test thoroughly.","solution":"class ComplexNumber: def __init__(self, real, imag): self.real = real self.imag = imag def add(self, other): return ComplexNumber(self.real + other.real, self.imag + other.imag) def multiply(self, other): real_part = self.real * other.real - self.imag * other.imag imag_part = self.real * other.imag + self.imag * other.real return ComplexNumber(real_part, imag_part) def conjugate(self): return ComplexNumber(self.real, -self.imag) def __str__(self): return f\\"{self.real} + {self.imag}i\\" # Example usage c1 = ComplexNumber(3, 4) c2 = ComplexNumber(1, -2) conjugate_of_c1 = c1.conjugate() sum_result = c1.add(conjugate_of_c1) product_result = c1.multiply(c2) print(\\"Conjugate of c1:\\", conjugate_of_c1) print(\\"Sum of c1 and its conjugate:\\", sum_result) print(\\"Product of c1 and c2:\\", product_result)"},{"question":"# Inventory Management System You are tasked with implementing a Python function that manages the inventory of a store. The function will update stock levels after a sale and return the updated inventory as a dictionary. # Objective Write a function `update_inventory` that updates the inventory based on items sold and returns the updated inventory. # Function Signature ```python def update_inventory(inventory: dict, sold: dict) -> dict: pass ``` # Input - `inventory` (dict): A dictionary where keys are item names (str) and values are the current stock (int) (e.g., `{\\"apple\\": 10, \\"banana\\": 5}`). - `sold` (dict): A dictionary where keys are item names (str) and values are the quantities sold (int) (e.g., `{\\"apple\\": 2, \\"banana\\": 1}`). # Output - The function should return the updated inventory as a dictionary after subtracting the sold quantities from the corresponding items in the inventory. # Constraints - All item names will be in lowercase. - The quantities in `inventory` and `sold` will be non-negative integers. - If an item in `sold` is not present in `inventory`, ignore it. - If the sold quantity for an item exceeds the current stock, set the inventory quantity to 0 for that item. - The function should handle up to 500 items in the inventory and up to 500 sold items. # Performance - The function should efficiently handle updates to the inventory to ensure quick operations, even for the maximum input sizes. # Instructions 1. Iterate over the items in the `sold` dictionary and update the `inventory` accordingly. 2. If an item is sold but not available in the inventory, it should be ignored. 3. Update the stock accordingly, setting the value to 0 if the sold quantity exceeds the available stock. 4. Return the updated inventory. # Example Scenario Given: ```python inventory = {\\"apple\\": 10, \\"banana\\": 5, \\"orange\\": 7} sold = {\\"apple\\": 2, \\"banana\\": 1, \\"grapes\\": 4} ``` Expected output: ```python {\\"apple\\": 8, \\"banana\\": 4, \\"orange\\": 7} ``` Explanation: - \\"apple\\": 10 - 2 = 8 - \\"banana\\": 5 - 1 = 4 - \\"grapes\\" is ignored as it isn\'t in the inventory - \\"orange\\" remains unchanged as it wasn\'t sold # Notes - Write proper error handling to manage incorrect data structures or values if necessary. - Consider edge cases such as empty inventory or sold dictionaries.","solution":"def update_inventory(inventory: dict, sold: dict) -> dict: Updates the inventory based on items sold and returns the updated inventory. Parameters: inventory (dict): Dictionary with current stock levels (e.g., {\\"apple\\": 10, \\"banana\\": 5}). sold (dict): Dictionary with sold quantities (e.g., {\\"apple\\": 2, \\"banana\\": 1}). Returns: dict: Updated inventory after sales. updated_inventory = inventory.copy() for item, quantity_sold in sold.items(): if item in updated_inventory: current_stock = updated_inventory[item] updated_inventory[item] = max(0, current_stock - quantity_sold) return updated_inventory"},{"question":"# Factorial Calculation with Custom Constraints Write a Python function `custom_factorial(n: int) -> int` that: 1. Accepts an integer `n` as input. 2. Computes and returns the factorial of `n` defined as the product of all positive integers less than or equal to `n`, i.e., ( n! = n times (n-1) times (n-2) times ldots times 1 ). 3. Handles the following constraints: - If `n` is negative, an appropriate exception with a meaningful message should be raised. - If `n` is greater than 12, raise an exception indicating that the result is too large to be computed due to performance constraints. # Input * An integer representing the value for which the factorial needs to be calculated. # Output * An integer representing the factorial of the given number. # Example ```python >>> custom_factorial(5) 120 >>> custom_factorial(0) 1 >>> custom_factorial(12) 479001600 >>> custom_factorial(-3) Traceback (most recent call last): ... ValueError: The input must be a non-negative integer. >>> custom_factorial(13) Traceback (most recent call last): ... ValueError: The input is too large. Maximum allowed is 12. ``` # Constraints * (0 leq n leq 12) Create the function `custom_factorial` to meet the specifications above, ensuring to include input validation for the defined constraints.","solution":"def custom_factorial(n: int) -> int: Computes the factorial of a positive integer up to 12. Parameters: n (int): Input integer. Returns: int: Factorial of the input integer. Raises: ValueError: If n is negative or greater than 12. if n < 0: raise ValueError(\\"The input must be a non-negative integer.\\") if n > 12: raise ValueError(\\"The input is too large. Maximum allowed is 12.\\") if n == 0: return 1 result = 1 for i in range(1, n + 1): result *= i return result"},{"question":"# Scenario As part of a financial software suite, you need to develop a module that processes and analyzes transaction data. One feature you need to implement is detecting fraudulent transactions based on a simple rule set. A transaction is considered fraudulent if the amount exceeds a specified threshold and if it occurs within a short interval of time compared to the previous transaction from the same account. # Task Implement a function `detect_fraud(transactions: List[Dict[str, Any]], threshold: float, time_window: int) -> List[Dict[str, Any]]` that identifies all fraudulent transactions according to the following criteria: 1. If the transaction amount exceeds the given threshold. 2. If the transaction time is within the time window (measured in seconds) from the previous transaction of the same account. The function should return a list of all transactions that are flagged as fraudulent. # Function Signature ```python from typing import List, Dict, Any def detect_fraud(transactions: List[Dict[str, Any]], threshold: float, time_window: int) -> List[Dict[str, Any]]: pass ``` # Input * `transactions`: A list of dictionaries, where each dictionary contains: - `account_id`: a unique identifier for an account (string) - `amount`: the transaction amount (float) - `timestamp`: the transaction time as a Unix timestamp (integer) * `threshold`: the transaction amount that flags a transaction as potentially fraudulent (float) * `time_window`: the time window in seconds within which consecutive transactions from the same account are flagged as fraudulent (integer) # Output * Returns a list of dictionaries representing transactions that are flagged as fraudulent. # Examples ```python transactions = [ {\\"account_id\\": \\"acc1\\", \\"amount\\": 150.0, \\"timestamp\\": 1609459200}, {\\"account_id\\": \\"acc1\\", \\"amount\\": 200.0, \\"timestamp\\": 1609459260}, {\\"account_id\\": \\"acc2\\", \\"amount\\": 50.0, \\"timestamp\\": 1609459500}, {\\"account_id\\": \\"acc1\\", \\"amount\\": 120.0, \\"timestamp\\": 1609459800}, {\\"account_id\\": \\"acc2\\", \\"amount\\": 300.0, \\"timestamp\\": 1609459900}, ] # threshold = 100 # time_window = 300 >>> detect_fraud(transactions, 100, 300) [ {\\"account_id\\": \\"acc1\\", \\"amount\\": 200.0, \\"timestamp\\": 1609459260}, {\\"account_id\\": \\"acc1\\", \\"amount\\": 120.0, \\"timestamp\\": 1609459800}, {\\"account_id\\": \\"acc2\\", \\"amount\\": 300.0, \\"timestamp\\": 1609459900}, ] ``` # Constraints * Do not use any external libraries. * The function should handle large input sizes efficiently. * Ensure the function leads to no race conditions or incorrect detections during rapid sequential transactions within the same account.","solution":"from typing import List, Dict, Any def detect_fraud(transactions: List[Dict[str, Any]], threshold: float, time_window: int) -> List[Dict[str, Any]]: Detects fraudulent transactions based on the given threshold and time window. Parameters: - transactions: List of transaction dictionaries. - threshold: The transaction amount threshold. - time_window: The time window in seconds within which consecutive transactions from the same account are flagged as fraudulent. Returns: A list of dictionaries representing transactions that are flagged as fraudulent. fraudulent_transactions = [] last_transaction = {} for transaction in transactions: account_id = transaction[\\"account_id\\"] amount = transaction[\\"amount\\"] timestamp = transaction[\\"timestamp\\"] if amount > threshold: if(account_id in last_transaction and (timestamp - last_transaction[account_id][\\"timestamp\\"] <= time_window)): fraudulent_transactions.append(transaction) else: fraudulent_transactions.append(transaction) last_transaction[account_id] = transaction return fraudulent_transactions"},{"question":"# Find All Paths Between Nodes in a Directed Graph Problem Statement: You are given a directed graph implemented using an adjacency list. Enhance this graph class to include a method that finds all possible paths between two specified nodes. Task: 1. Implement the `find_all_paths` function within the given Graph class. 2. The function should accept two vertices, a start and an end vertex. 3. Return a list of all paths, where each path is represented as a list of vertices from the start vertex to the end vertex. 4. If there are no paths, return an empty list. Expected Function Signature: ```python def find_all_paths(self, start_vertex: int, end_vertex: int) -> list[list[int]]: ``` Example: ```python g = Graph() g.add_edge(0, 1) g.add_edge(0, 2) g.add_edge(1, 2) g.add_edge(2, 0) g.add_edge(2, 3) g.add_edge(3, 3) result = g.find_all_paths(2, 3) print(result) # Output should be [[2, 3]] ``` Constraints: 1. The graph can have up to 10^3 vertices. 2. There will be no negative vertex labels or edge weights. 3. The graph may contain self-loops and/or multiple edges. Hint: Use a recursive approach or a stack-based approach to explore all possible paths. Use backtracking to avoid revisiting nodes in the current path.","solution":"class Graph: def __init__(self): # Initialize an empty dictionary to hold adjacency list self.graph = {} def add_edge(self, u, v): # Add the edge from u to v in the adjacency list if u not in self.graph: self.graph[u] = [] self.graph[u].append(v) def find_all_paths(self, start_vertex, end_vertex): def dfs(current_vertex, end_vertex, path): path.append(current_vertex) if current_vertex == end_vertex: paths.append(path[:]) else: for neighbor in self.graph.get(current_vertex, []): if neighbor not in path: dfs(neighbor, end_vertex, path) path.pop() paths = [] dfs(start_vertex, end_vertex, []) return paths"},{"question":"# Matrix Island Counting **Context:** In many computational problems, especially those involving graphs and grids, it is critical to identify and count connected components. One such problem is identifying \\"islands\\" in a matrix, where an island is defined as a group of adjacent \'1\'s connected vertically or horizontally (not diagonally). This task is instrumental in fields like image processing, geographical plotting, and network connectivity. **Task:** Write a function to count the number of islands in a given 2D binary matrix. **Function Signature:** - `def num_islands(grid: List[List[int]]) -> int` **Specifications:** 1. **Input Constraints:** - The `grid` is a 2D list of integers where each element is either `0` or `1`. - The dimensions of the grid are `m x n`, where `1 <= m, n <= 300`. 2. **Output:** - The function should return an integer representing the number of distinct islands in the provided `grid`. **Example Usage:** ```python matrix1 = [ [1, 1, 0, 0, 0], [1, 1, 0, 0, 1], [0, 0, 0, 1, 1], [0, 0, 0, 0, 0], [0, 0, 0, 1, 1] ] print(num_islands(matrix1)) # Output: 3 matrix2 = [ [1, 0, 0, 1, 0], [1, 1, 1, 1, 0], [0, 0, 0, 0, 0], [0, 1, 0, 1, 1] ] print(num_islands(matrix2)) # Output: 2 ``` **Approach:** - Use Depth-First Search (DFS) or Breadth-First Search (BFS) to explore and mark visited cells. - Perform a search from every unvisited \'1\' cell, marking every connected \'1\' as visited, to ensure each island is counted once. **Performance Requirements:** - The algorithm should run in linear time complexity relative to the number of elements in the grid, which is `O(m * n)`. Consider edge cases such as an empty grid, a grid with all water (`0`s), or a grid with only one large island. Your solution should handle these cases effectively.","solution":"from typing import List def num_islands(grid: List[List[int]]) -> int: def dfs(grid, i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0: return grid[i][j] = 0 # Mark as visited dfs(grid, i + 1, j) # Down dfs(grid, i - 1, j) # Up dfs(grid, i, j + 1) # Right dfs(grid, i, j - 1) # Left if not grid: return 0 count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: count += 1 dfs(grid, i, j) return count"},{"question":"# Arrange Words By Length You are tasked with creating a function that rearranges the words in a given string based on the length of the words, from shortest to longest. If two words have the same length, their order should remain the same as in the input string. Function Signature ```python def arrange_words_by_length(sentence: str) -> str: Function to rearrange words in a sentence by length. :param sentence: The input string containing a sentence. :return: A new string with words rearranged by length. ``` Constraints - The sentence contains only alphabetic characters and spaces. - The sentence contains at least one word. - Words in the sentence are separated by single spaces. Example Usage ```python # Example 1: input_sentence = \\"The quick brown fox jumps over the lazy dog\\" output_sentence = arrange_words_by_length(input_sentence) print(output_sentence) # Output: \\"The fox the dog lazy over quick brown jumps\\" # Example 2: input_sentence = \\"A cat and a bat\\" output_sentence = arrange_words_by_length(input_sentence) print(output_sentence) # Output: \\"A a cat and bat\\" ``` Task 1. Implement the `arrange_words_by_length` function as described. 2. Test the function with various sentences to ensure it correctly arranges words by their lengths. # Considerations - Test with sentences that have words of varying lengths. - Ensure the function maintains the case sensitivity and word order for words of identical length. - Handle edge cases where the sentence might contain the minimum number of words (e.g., single word sentences).","solution":"def arrange_words_by_length(sentence: str) -> str: Function to rearrange words in a sentence by length. :param sentence: The input string containing a sentence. :return: A new string with words rearranged by length. words = sentence.split() words.sort(key=len) return \' \'.join(words)"},{"question":"# Problem Scenario You are working on a text processing tool that analyzes the frequency of characters in a given string and identifies the character that appears the most. In case of a tie (i.e., multiple characters having the same maximum frequency), it should return all such characters in alphabetical order as a single string. Write a function `most_frequent_chars` to find the most frequent character(s) from a given string. Function Signature ```python def most_frequent_chars(input_string: str) -> str: ``` Input - `input_string` (str): A string containing only lowercase alphabetical characters (1 ≤ `len(input_string)` ≤ 10^5). Output - Returns a string containing the most frequent character(s) in alphabetical order. Constraints - The input string will only consist of lowercase letters, ensuring no need to handle uppercase or non-alphabet characters. Examples ```python >>> most_frequent_chars(\\"aabbcc\\") \\"abc\\" >>> most_frequent_chars(\\"abbccc\\") \\"c\\" >>> most_frequent_chars(\\"xxyyzz\\") \\"xyz\\" >>> most_frequent_chars(\\"a\\") \\"a\\" ``` In this problem, you need to count the occurrences of each character and determine which ones have the highest frequency while ensuring the result is sorted alphabetically if there are multiple characters with the same maximum frequency.","solution":"def most_frequent_chars(input_string: str) -> str: from collections import Counter # Count the frequency of each character in the string char_count = Counter(input_string) # Find the maximum frequency max_frequency = max(char_count.values()) # Find the characters with the max frequency and sort them most_frequent = sorted([char for char, count in char_count.items() if count == max_frequency]) return \'\'.join(most_frequent)"},{"question":"# Coding Assessment Question Scenario You are tasked to develop a software module to aid a reservation system for a train service. The problem entails tracking the allocation of seats in such a way that a specified number of consecutive seats can be reserved together for a group of travelers. Function to Implement Implement the function `allocate_seats(seating: list, num_seats: int) -> tuple` which attempts to find and reserve the required number of consecutive seats. Input 1. `seating`: A list representing the seats in a train car, where `0` indicates an available seat and `1` indicates an already reserved seat. 2. `num_seats`: An integer representing the number of consecutive seats required. Output The function should return a tuple: 1. A boolean indicating whether it was possible to reserve the required consecutive seats (`True` if yes, otherwise `False`). 2. A list representing the seating arrangement after attempting the reservation. If the reservation is successful, the list should show the updated seating after reservation (mark the reserved seats as `1`). If not, return the original seating list. Constraints 1. The length of the `seating` list can be between 1 and 1000. 2. The `num_seats` value will be between 1 and the length of the seating list. Performance Requirements - Ensure that the function runs efficiently given the possible constraints on the input size. Example ```python seating = [0, 0, 1, 0, 0, 0, 1, 0] num_seats = 3 assert allocate_seats(seating, num_seats) == (True, [0, 0, 1, 1, 1, 1, 1, 0]) seating = [0, 1, 1, 0, 0, 1, 0, 0] num_seats = 4 assert allocate_seats(seating, num_seats) == (False, [0, 1, 1, 0, 0, 1, 0, 0]) ``` **Note**: Handle edge cases such as insufficient consecutive seats and varying positions within the seating list efficiently.","solution":"def allocate_seats(seating, num_seats): Attempts to allocate the required number of consecutive seats in the seating list. Parameters: - seating: List of integers where 0 = available, 1 = reserved. - num_seats: Integer, the number of consecutive seats required. Returns: - Tuple(Boolean, List of integers): A tuple with a boolean indicating if the seats were allocated successfully, and the list of seating after trying the allocation. n = len(seating) for i in range(n - num_seats + 1): if all(seat == 0 for seat in seating[i:i + num_seats]): for j in range(i, i + num_seats): seating[j] = 1 return (True, seating) return (False, seating)"},{"question":"# Coding Assessment Question: A company\'s customer service department wants to develop a tool that automatically categorizes incoming customer support emails into predefined categories to streamline their workflow. Your goal is to build a simple categorization script that uses keyword matching to assign emails to the correct category. Objectives: 1. **Email Parsing**: Implement a function that extracts the subject and body from an email text and returns them as a dictionary. 2. **Keyword-Based Categorization**: Develop a method that categorizes emails based on the presence of specific keywords in the subject or body of the email. 3. **Manage Multiple Categories**: Handle cases where an email may match multiple categories by defining a priority order for categories. 4. **Extendable Categorization Logic**: Ensure the categorization logic can be easily extended to add more categories and keywords in the future without altering the core logic. Function Specification: * **Expected Input and Output Formats**: - **Input**: A single email text as a string and a dictionary of categories where keys are category names and values are lists of keywords. - **Output**: A string representing the assigned category. * **Constraints and Limitations**: - Assume a non-empty string for the email text. - Categories and keywords will be provided in a dictionary with the format `{\\"category1\\": [\\"keyword1\\", \\"keyword2\\"], \\"category2\\": [\\"keyword3\\", \\"keyword4\\"]}`. - An email will always belong to one category, based on the priority order if multiple keywords are matched. * **Performance Requirements**: The categorization should be efficient, ideally processing emails in linear time relative to their length and the number of categories/keywords. Implementation Requirements: 1. Implement the function `parse_email` to: - Extract and return the subject and body of the email as a dictionary with keys \\"subject\\" and \\"body\\". 2. Implement the function `categorize_email` to: - Categorize the email into one of the predefined categories based on the provided keywords. - Ensure the function handles the case where an email matches keywords from multiple categories by returning the category with the highest priority as defined in the input dictionary. Function Signature: ```python from typing import Dict, List def parse_email(email_text: str) -> Dict[str, str]: Parse the email text to extract and return the subject and body. # Implementation goes here. def categorize_email(email: Dict[str, str], categories: Dict[str, List[str]]) -> str: Categorize the email based on keywords found in the subject or body. # Implementation goes here. ``` # Example Usage: ```python email_text = Subject: Issue with my order Body: Hi, I have an issue with the order I placed last week. The items were damaged. categories = { \\"Order Issues\\": [\\"order\\", \\"damaged\\", \\"missing\\"], \\"Technical Support\\": [\\"error\\", \\"technical\\", \\"support\\"], \\"Billing\\": [\\"invoice\\", \\"billing\\", \\"charge\\"], } parsed_email = parse_email(email_text) category = categorize_email(parsed_email, categories) print(category) # Output should be \\"Order Issues\\" due to keywords \\"order\\" and \\"damaged\\" ``` Ensure your implementation is robust, efficient, and handles various edge cases. Include appropriate documentation and comments for clarity.","solution":"from typing import Dict, List def parse_email(email_text: str) -> Dict[str, str]: Parse the email text to extract and return the subject and body. lines = email_text.strip().split(\\"n\\") subject = \\"\\" body = [] if lines: subject = lines[0].replace(\\"Subject:\\", \\"\\").strip() body = lines[1:] body = \\"n\\".join(body).replace(\\"Body:\\", \\"\\").strip() return {\\"subject\\": subject, \\"body\\": body} def categorize_email(email: Dict[str, str], categories: Dict[str, List[str]]) -> str: Categorize the email based on keywords found in the subject or body. for category, keywords in categories.items(): for keyword in keywords: if keyword.lower() in email[\\"subject\\"].lower() or keyword.lower() in email[\\"body\\"].lower(): return category return \\"Uncategorized\\" # default category when no keywords match"},{"question":"# Problem Statement: **Magical Matrix Rotation** You are given an `N x N` matrix filled with unique integers. Your task is to rotate the matrix 90 degrees clockwise in-place. The function should take the matrix as input and return the rotated matrix. # Function Signature: ```python def rotate_matrix(matrix: list) -> list: ``` # Input: - `matrix`: A list of lists of integers representing the `N x N` matrix. Each integer is unique, and `1 <= N <= 1000`. # Output: - The rotated matrix as a list of lists of integers. # Constraints: - The matrix is always square (`N x N`). - The size of `N` will be between 1 and 1000. # Example: ```python assert rotate_matrix([ [1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [ [7, 4, 1], [8, 5, 2], [9, 6, 3]] assert rotate_matrix([ [5, 1], [0, 2]]) == [ [0, 5], [2, 1]] assert rotate_matrix([[1]]) == [[1]] ``` # Implementation Requirements: 1. The function must rotate the matrix in linear time relative to the number of elements in the matrix O(N^2). 2. The function must not use any extra space proportional to the input size, i.e., should work in O(1) additional space complexity apart from the input matrix itself. 3. All matrix transformations should be performed in-place. # Scenario: Imagine you are developing a feature for a graphical application where users can manipulate images represented as matrices. Efficiently rotating these images without utilizing significant extra memory is crucial, as the application may need to handle very large images. # Constraints to Consider: - Ensure that the input matrix is square. - Handle all edge cases, including the smallest (1 x 1) and the largest (1000 x 1000) matrices.","solution":"def rotate_matrix(matrix: list) -> list: Rotates a given N x N matrix 90 degrees clockwise in-place. n = len(matrix) # Transpose the matrix (swap rows with columns) for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row to get the final rotated matrix for i in range(n): matrix[i].reverse() return matrix"},{"question":"# Question: You have been given a binary search tree (BST). Your task is to implement a method to find the kth largest element in the BST. **Function Signature**: ```python def kth_largest(root: \'TreeNode\', k: int) -> int: Returns the kth largest element in the given BST. Parameters: - root: The root node of the BST. - k: The position (1-indexed) of the largest element to be found. Returns: - The kth largest element in the BST. If the tree is empty or k is invalid, return -1. ``` # Input: * `root:` The root node of the BST. * `k (int):` The position (1-indexed) of the largest element to find in the BST. # Output: * Return the kth largest element in the BST. If the tree is empty or k is invalid, return `-1`. # Constraints: * The number of nodes in the tree will not exceed 100,000. * The value of each node will be a unique integer within a given range. * Ensure the function handles edge cases correctly (e.g., when k is greater than the number of nodes or when the tree is empty). # Example: ```python >>> root = TreeNode(5) >>> root.left = TreeNode(3) >>> root.right = TreeNode(7) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(4) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(8) >>> kth_largest(root, 1) 8 >>> kth_largest(root, 3) 6 >>> kth_largest(root, 7) 2 >>> kth_largest(root, 8) -1 ``` **Notes**: * The kth largest element is the element that would appear in the kth last position if the BST elements were sorted in ascending order. * For example, in the given BST, the elements in ascending order are [2, 3, 4, 5, 6, 7, 8], so the 3rd largest element is 6.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_largest(root: TreeNode, k: int) -> int: Returns the kth largest element in the given BST. Parameters: - root: The root node of the BST. - k: The position (1-indexed) of the largest element to be found. Returns: - The kth largest element in the BST. If the tree is empty or k is invalid, return -1. if not root or k <= 0: return -1 stack = [] current = root count = 0 while stack or current: while current: stack.append(current) current = current.right current = stack.pop() count += 1 if count == k: return current.val current = current.left return -1"},{"question":"# Problem Statement You are given a list `numbers` of integers. Your task is to write a function `find_missing_number` that finds the single missing number in an otherwise complete sequence from 1 to n. # Function Signature ```python def find_missing_number(numbers: List[int]) -> int: ``` # Input - `numbers`: A list of n-1 integers where each integer is unique and lies between 1 and n (inclusive). # Output - An integer representing the missing number in the sequence. # Constraints - The length of the list `numbers` is always n-1 and all integers lie between 1 and n (inclusive). - n is at most 1,000,000. # Example ```python numbers = [1, 2, 3, 5] print(find_missing_number(numbers)) # Output should be 4 ``` # Notes Consider using mathematical formulas or efficient algorithms to find the missing number without having to sort the list or use excessive memory. # Additional Context This problem tests your understanding of arithmetic properties, efficient iteration over lists, and algorithmic optimization. It requires solving the problem with minimal computational overhead and within acceptable time complexity constraints.","solution":"from typing import List def find_missing_number(numbers: List[int]) -> int: Finds the single missing number in an otherwise complete sequence from 1 to n. Arguments: numbers -- a list of n-1 unique integers where each integer is unique and lies between 1 and n (inclusive) Returns: An integer representing the missing number in the sequence. n = len(numbers) + 1 total_sum = n * (n + 1) // 2 actual_sum = sum(numbers) return total_sum - actual_sum"},{"question":"# Question: Split and Reverse Words Design a function `split_and_reverse(sentence: str) -> str` that takes a sentence as input and returns the sentence with each word reversed, while maintaining the original positions of the words and spaces. Function Signature: ```python def split_and_reverse(sentence: str) -> str: ``` Input: * A string `sentence` which consists of words and spaces where `1 <= len(sentence) <= 10^5`. Output: * A string where each word in the input sentence is reversed, but their order and spacing remain the same. Example Cases: 1. **Example 1:** * Input: `sentence = \\"hello world\\"` * Output: `\\"olleh dlrow\\"` * Explanation: The sentence has two words \\"hello\\" and \\"world\\", which are reversed to \\"olleh\\" and \\"dlrow\\", respectively. 2. **Example 2:** * Input: `sentence = \\"abc def ghi\\"` * Output: `\\"cba fed ihg\\"` * Explanation: Each of the words \\"abc\\", \\"def\\", and \\"ghi\\" is reversed to \\"cba\\", \\"fed\\", and \\"ihg\\". 3. **Example 3:** * Input: `sentence = \\" the sky is blue \\"` * Output: `\\" eht yks si eulb \\"` * Explanation: The words \\"the\\", \\"sky\\", \\"is\\", and \\"blue\\" are reversed, while maintaining the original spacing. Requirements: * The function should be efficient with a time complexity preferably close to (O(n)), where (n) is the length of the input string. * Ensure to handle consecutive spaces and maintain the exact spacing pattern as in the original sentence. * Implement the function to handle edge cases such as multiple consecutive spaces, leading or trailing spaces, and a single word. Objective: Your task is to implement the `split_and_reverse` function which correctly reverses each word in the sentence without altering the overall structure of whitespace.","solution":"def split_and_reverse(sentence: str) -> str: Takes a sentence as input and returns the sentence with each word reversed, while maintaining the original positions of the words and spaces. words = sentence.split(\' \') reversed_words = [word[::-1] for word in words] return \' \'.join(reversed_words)"},{"question":"# Quadratic Function Roots Calculation Problem Description You are required to calculate the roots of a quadratic equation of the form (ax^2 + bx + c = 0). The roots can be real or complex. The quadratic formula to find the roots is given by: [x = frac{-b pm sqrt{b^2 - 4ac}}{2a}] Here, - (a), (b), and (c) are coefficients of the quadratic equation. - (a neq 0). Task Requirements Implement the function `quadratic_roots(a: float, b: float, c: float) -> tuple` that takes: - `a` (coefficient of (x^2), must be non-zero) - `b` (coefficient of (x)) - `c` (constant term) The function must compute and return a tuple containing the two roots of the quadratic equation. The roots should be returned as a tuple of either two real numbers or two complex numbers, depending on the nature of the roots. Input and Output - **Input**: Three float values for the coefficients (a), (b), and (c). - **Output**: A tuple containing two roots. Constraints - The coefficient (a) must not be zero. If (a) is zero, raise a `ValueError` with the message: `\\"Coefficient \'a\' must not be 0\\"` - The coefficients (a), (b), and (c) are real numbers. Example ```python >>> quadratic_roots(1, -3, 2) (2.0, 1.0) >>> quadratic_roots(1, 2, 5) ((-1-2j), (-1+2j)) ```","solution":"import cmath def quadratic_roots(a: float, b: float, c: float) -> tuple: Calculate the roots of the quadratic equation ax^2 + bx + c = 0. Returns: A tuple with two roots (either real or complex). if a == 0: raise ValueError(\\"Coefficient \'a\' must not be 0\\") # Calculate the discriminant discriminant = b ** 2 - 4 * a * c # Calculate the roots root1 = (-b + cmath.sqrt(discriminant)) / (2 * a) root2 = (-b - cmath.sqrt(discriminant)) / (2 * a) return (root1, root2)"},{"question":"# Flatten Nested Lists You are given a nested list (a list that can contain both integers and other nested lists). Write a function `flatten_list` that takes a nested list and returns a new flattened list containing all the integers in the original nested list, preserving the order of appearance. Input * `nested_list`: A list that may contain integers and/or nested lists, where `1 <= len(nested_list) <= 10^3`. Output * A list of integers, representing the flattened version of `nested_list`. Constraints * You must handle an arbitrary level of nesting. * Aim to achieve an efficient solution using recursion or iteration. Example ```python >>> flatten_list([1, [2, 3], [4, [5, 6], 7], 8, []]) [1, 2, 3, 4, 5, 6, 7, 8] >>> flatten_list([7, [3, [8, [6, 5]], 2], 4]) [7, 3, 8, 6, 5, 2, 4] >>> flatten_list([1, 2, 3]) [1, 2, 3] >>> flatten_list([]) [] ``` Implementation Note Ensure that your solution handles edge cases such as empty lists, lists with no nesting, and different levels of nesting appropriately.","solution":"def flatten_list(nested_list): Takes a nested list and returns a new flattened list containing all the integers in the original nested list, preserving the order of appearance. result = [] def flatten(item): if isinstance(item, list): for subitem in item: flatten(subitem) else: result.append(item) flatten(nested_list) return result"},{"question":"# Coding Question: You are given two strings, `s1` and `s2`. Your task is to determine the minimum number of operations required to convert `s1` into `s2`. The allowed operations are: - Insert a character. - Delete a character. - Replace a character. * **Input Format**: - Two strings, `s1` and `s2`, which can contain any printable characters. * **Output Format**: - Return a single integer which is the minimum number of operations required to transform `s1` into `s2`. * **Constraints**: - The length of `s1` and `s2` can be up to 1000. - All characters in both strings are case-sensitive. * **Performance requirements**: - The algorithm should be able to handle the maximum constraints efficiently. # Example: Given the following inputs: - `s1 = \\"horse\\"` - `s2 = \\"ros\\"` The minimum number of operations required is 3 (replace \'h\' with \'r\', remove \'o\', remove \'e\'). # Function Signature: ```python def min_operations(s1: str, s2: str) -> int: # Your code here ``` # Example Usage: ```python s1 = \\"horse\\" s2 = \\"ros\\" assert min_operations(s1, s2) == 3 ``` *Note*: This problem is a classic example of calculating the \\"Edit Distance\\" between two strings, which is commonly solved with dynamic programming.","solution":"def min_operations(s1: str, s2: str) -> int: Determine the minimum number of operations required to convert s1 into s2. Operations allowed are: insertion, deletion, and replacement of characters. Uses dynamic programming to solve the problem efficiently. Args: - s1 (str): The source string. - s2 (str): The target string. Returns: - int: The minimum number of operations required to transform s1 into s2. m, n = len(s1), len(s2) # Create a DP table to memoize distances dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the first row and column with the number of edits required # to convert an empty string to another string for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Fill the dp table for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min(dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + 1) # Replacement return dp[m][n]"},{"question":"# Problem Statement One of the critical tasks in software engineering is to ensure efficient memory usage while dealing with large files. Given a log file which contains thousands of lines, each representing a log entry, you need to implement a function to filter and process these entries efficiently. Each log entry follows a specific format and some entries may be duplicated due to system redundancy. Implement a function that reads a log file, removes duplicate entries, and compiles a summary of the frequency of each unique log entry. The log file consists of multiple lines, where each line represents a log entry string. # Function Signature ```python def process_log_file(log_entries): Processes log entries and returns a summary of frequencies of unique entries. Arguments: log_entries -- a list of strings, where each string represents a log entry Returns: A dictionary with unique log entries as keys and their frequency counts as values. pass ``` # Input * `log_entries` (list of str): A list where each element is a string representing a log entry. # Output * Dictionary (str: int): A dictionary where each key is a unique log entry and the value is the count of that entry in the log file. # Constraints * Each log entry string length ( 1 leq text{len(entry)} leq 100 ) * The number of log entries ( 1 leq text{len(log_entries)} leq 10000 ) # Performance Requirements * Your solution should handle up to 10,000 log entries efficiently. * The processing should be optimized to minimize memory usage and execution time. # Example ```python # Define the log entries log_entries = [ \\"INFO User logged in\\", \\"ERROR Database connection failed\\", \\"INFO User logged in\\", \\"INFO User logged out\\", \\"WARNING Disk space low\\", \\"INFO User logged in\\" ] # Call the function summary = process_log_file(log_entries) # Expected output # { # \\"INFO User logged in\\": 3, # \\"ERROR Database connection failed\\": 1, # \\"INFO User logged out\\": 1, # \\"WARNING Disk space low\\": 1 # } ``` # Explanation The function removes duplicate log entries and calculates the frequency of each unique entry. The example output demonstrates how the function compiles a summary of the provided log entries, showing that \\"INFO User logged in\\" appears three times, while other entries have different frequencies.","solution":"def process_log_file(log_entries): Processes log entries and returns a summary of frequencies of unique entries. Arguments: log_entries -- a list of strings, where each string represents a log entry Returns: A dictionary with unique log entries as keys and their frequency counts as values. from collections import defaultdict frequency_dict = defaultdict(int) for entry in log_entries: frequency_dict[entry] += 1 return dict(frequency_dict)"},{"question":"# Implementing a Custom Stack Data Structure Context A stack is a fundamental data structure used in computer science, which follows the Last-In-First-Out (LIFO) principle. In this task, you will implement a custom stack data structure with additional functionalities, and then use it to solve a specific problem. Task 1. **Custom Stack Implementation**: Define a `CustomStack` class that supports the following methods: - `push(x)`: Push element `x` onto the stack. - `pop()`: Remove the element on the top of the stack and return it. - `peek()`: Return the element on the top of the stack without removing it. - `is_empty()`: Return `True` if the stack is empty, `False` otherwise. Additionally, implement a method `increment(k, val)` that increments the bottom `k` elements of the stack by `val`. If `k` exceeds the number of elements in the stack, increment all elements. 2. **Application: Minimum Element in a Custom Stack**: Extend the `CustomStack` class to include a `CustomMinStack` class that supports all the operations of `CustomStack` and includes an efficient method for retrieving the minimum element in the stack at any time. - `get_min()`: Return the minimum element in the stack in constant time. Function Signatures You are to implement the following functions: ```python class CustomStack: def __init__(self): # Initialize the stack and any additional state here ... def push(self, x: int) -> None: # Push element x onto the stack ... def pop(self) -> int: # Remove the top element from the stack and return it ... def peek(self) -> int: # Return the top element without removing it ... def is_empty(self) -> bool: # Return True if the stack is empty, otherwise False ... def increment(self, k: int, val: int) -> None: # Increment the bottom k elements of the stack by val ... class CustomMinStack(CustomStack): def push(self, x: int) -> None: # Push element x onto the stack with minimum tracking ... def pop(self) -> int: # Pop the top element from the stack with minimum tracking ... def get_min(self) -> int: # Return the minimum element in the stack ... ``` Constraints - All elements pushed into the stack will be integers. - Ensure all operations are optimized for time complexity. - The `increment` method should be efficient, avoid reprocessing all elements when possible. - The `get_min` operation should be constant time, O(1). Example ```python # Example for CustomStack: stack = CustomStack() stack.push(5) stack.push(2) stack.push(8) stack.increment(2, 3) # Stack after increment: [8, 5, 8] print(stack.pop()) # Output: 8 print(stack.peek()) # Output: 5 print(stack.is_empty()) # Output: False # Example for CustomMinStack: min_stack = CustomMinStack() min_stack.push(5) min_stack.push(2) min_stack.push(8) print(min_stack.get_min()) # Output: 2 min_stack.pop() print(min_stack.get_min()) # Output: 2 min_stack.pop() print(min_stack.get_min()) # Output: 5 ``` Ensure that your implementation of the `CustomStack` class and `CustomMinStack` class adheres to all the required specifications and handles edge cases effectively.","solution":"class CustomStack: def __init__(self): self.stack = [] def push(self, x: int) -> None: self.stack.append(x) def pop(self) -> int: return self.stack.pop() if not self.is_empty() else None def peek(self) -> int: return self.stack[-1] if not self.is_empty() else None def is_empty(self) -> bool: return len(self.stack) == 0 def increment(self, k: int, val: int) -> None: limit = min(k, len(self.stack)) for i in range(limit): self.stack[i] += val class CustomMinStack(CustomStack): def __init__(self): super().__init__() self.min_stack = [] def push(self, x: int) -> None: super().push(x) if len(self.min_stack) == 0 or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self) -> int: value = super().pop() if value == self.min_stack[-1]: self.min_stack.pop() return value def get_min(self) -> int: return self.min_stack[-1] if self.min_stack else None"},{"question":"# Evaluate Polynomial Expressions Create a function that evaluates a given polynomial expression using Horner\'s method. Function to Implement ```python def evaluate_polynomial(coeffs, x): Evaluate the value of a polynomial at a given point x using Horner\'s method. Parameters: coeffs (list): A list of coefficients of the polynomial. The i-th element represents the coefficient of x^i. x (float): The point at which to evaluate the polynomial. Returns: float: The value of the polynomial at x. pass ``` Input: * `coeffs`: A list of float numbers containing the coefficients of the polynomial, ordered from the constant term to the highest degree. * `x`: A float, representing the point at which the polynomial should be evaluated. Output: * Return the calculated value of the polynomial at the given point `x` as a float. Constraints: * The length of `coeffs` will be at least 1. * The coefficients can be positive, negative, integers, or floats. * The value of `x` can be any real number. Performance Requirements: * Time Complexity: O(degree of the polynomial) * Space Complexity: O(1) Given a polynomial represented by `p(x) = 3x^3 + 0.5x^2 - 2x + 4`, write the `evaluate_polynomial` function to compute its value at `x = 2.0`. Example: ```python coeffs = [4, -2, 0.5, 3] x = 2.0 # Using the evaluate_polynomial result = evaluate_polynomial(coeffs, x) print(f\\"Value of the polynomial at x = {x}: {result}\\") ``` *Expected Output*: `Value of the polynomial at x = 2.0: 26.0` *Note*: Please do not use any external libraries or built-in functions specifically for polynomial evaluation for this task.","solution":"def evaluate_polynomial(coeffs, x): Evaluate the value of a polynomial at a given point x using Horner\'s method. Parameters: coeffs (list): A list of coefficients of the polynomial. The i-th element represents the coefficient of x^i. x (float): The point at which to evaluate the polynomial. Returns: float: The value of the polynomial at x. result = 0 for coefficient in reversed(coeffs): result = result * x + coefficient return result"},{"question":"# Context: Managing Inventory Levels Using Segment Trees You are working on an inventory management system for a large warehouse. The system needs to handle two types of operations efficiently: updating the stock quantity of items and querying the minimum stock level within a range of items. Given the importance of quickly adjusting stock levels and responding to queries about the minimum available stock, a Segment Tree is an ideal data structure for this situation. Using the principles of Segment Trees discussed above, implement a subclass that extends the provided Segment Tree structure to support the following features: 1. **Minimum Stock Query**: Implement a method `range_minimum` that returns the minimum stock quantity of items within a specified index range [left, right). 2. **Update Stock Quantity**: Implement a method `update_quantity` that increases the stock quantity of a specific item by a given amount. # Task Requirements - Implement `range_minimum` method: This should return the minimum stock quantity within the index range [left, right). - Implement `update_quantity` method: This should increment the stock quantity of an item at a specified index by a given amount. Function Signatures: ```python class InventorySegmentTree(SegmentTree): def range_minimum(self, left: int, right: int) -> int: pass def update_quantity(self, index: int, amount: int) -> None: pass ``` Input/Output Formats: - **range_minimum**: - **Input**: Two integers `left` and `right` (range). - **Output**: Integer representing the minimum stock quantity within the specified range. - **update_quantity**: - **Input**: An integer `index` (item index) and another integer `amount` (increment). - **Output**: Updates the stock quantity of the item at the given index in the Segment Tree. Constraints: - 0 <= left < right <= self.size - 0 <= index < self.size - The Segment Tree should already be initialized with non-negative stock quantities.","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = min(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, pos, value): pos += self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = min(self.tree[2 * pos], self.tree[2 * pos + 1]) def range_query(self, l, r): l += self.n r += self.n min_value = float(\'inf\') while l < r: if l % 2: min_value = min(min_value, self.tree[l]) l += 1 if r % 2: r -= 1 min_value = min(min_value, self.tree[r]) l //= 2 r //= 2 return min_value class InventorySegmentTree(SegmentTree): def range_minimum(self, left: int, right: int) -> int: return self.range_query(left, right) def update_quantity(self, index: int, amount: int) -> None: current_quantity = self.tree[self.n + index] new_quantity = current_quantity + amount self.update(index, new_quantity)"},{"question":"# Number Classification Based on Prime Sum You are given a program that classifies numbers based on the sum of their digits. Your task is to implement a function that determines whether the sum of the digits of a given number is a prime number. Function Signature ```python def is_prime_sum(num: int) -> str: ``` # Input * `num` (int): The input number. Assume `num` is a positive integer. # Output * (str): \\"Prime\\" if the sum of the digits of `num` is a prime number, otherwise \\"Not Prime\\". # Implementation Steps 1. **Sum of Digits**: Calculate the sum of all digits in the number ( text{num} ). 2. **Prime Check**: - Determine whether the sum is a prime number. - A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. # Constraints * The input number `num` will be in the range [1, 10^9]. # Example ```python # Test case 1 num = 123 print(is_prime_sum(num)) # Expected output: \\"Prime\\" # Explanation: The sum of digits is 1+2+3 = 6. 6 is not a prime number. # Test case 2 num = 101 print(is_prime_sum(num)) # Expected output: \\"Prime\\" # Explanation: The sum of digits is 1+0+1 = 2. 2 is a prime number. # Test case 3 num = 987 print(is_prime_sum(num)) # Expected output: \\"Not Prime\\" # Explanation: The sum of digits is 9+8+7 = 24. 24 is not a prime number. ``` # Hints * To check if a number is prime, iterate through all numbers from 2 to (sqrt{text{num}}). * Use modular arithmetic to determine if the sum of the digits has any divisors.","solution":"def is_prime_sum(num: int) -> str: def sum_of_digits(n: int) -> int: return sum(int(digit) for digit in str(n)) def is_prime(n: int) -> bool: if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True digit_sum = sum_of_digits(num) return \\"Prime\\" if is_prime(digit_sum) else \\"Not Prime\\""},{"question":"# Coding Assessment Question **Title**: Implement Linked List Sorting **Objective**: Sort a singly linked list using merge sort. The task is to create functions to build the linked list from an array and sort the linked list in ascending order. **Context**: Bob has been studying linked lists and sorting algorithms in his computer science course. He is particularly interested in merge sort for sorting linked lists, as it provides O(n log n) time complexity in the worst case. Bob needs to write functions to build a singly linked list from an array of integers and sort the linked list using merge sort. **Task**: Write functions to implement a singly linked list and sort it using merge sort. You need to create three primary functions: `build_linked_list`, `sort_linked_list`, and a helper function `merge_sort`. # Requirements Node Definition and Functions ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def build_linked_list(arr: list[int]) -> ListNode: Create a linked list from an array. Args: arr (list[int]): The array to be converted into a linked list. Returns: ListNode: The head of the linked list. pass def sort_linked_list(head: ListNode) -> ListNode: Sort a linked list using merge sort. Args: head (ListNode): The head of the linked list. Returns: ListNode: The head of the sorted linked list. pass def merge_sort(head: ListNode) -> ListNode: Helper function that implements merge sort on a linked list. Args: head (ListNode): The head of the linked list to be sorted. Returns: ListNode: The head of the sorted linked list. pass ``` # Constraints and Input: 1. **Linked List**: The linked list can contain any integer values including negative numbers. 2. **Array**: The array used to build the linked list can have any positive length. Examples: **Example 1** ```python arr = [4, 1, 7, 3, 8, 2] head = build_linked_list(arr) sorted_head = sort_linked_list(head) # Traverse the sorted linked list to display the sorted values current = sorted_head sorted_values = [] while current: sorted_values.append(current.value) current = current.next print(sorted_values) # Output should be [1, 2, 3, 4, 7, 8] ``` **Example 2** ```python arr = [-3, 9, 0, -2, 5, 1] head = build_linked_list(arr) sorted_head = sort_linked_list(head) # Traverse the sorted linked list to display the sorted values current = sorted_head sorted_values = [] while current: sorted_values.append(current.value) current = current.next print(sorted_values) # Output should be [-3, -2, 0, 1, 5, 9] ``` # Performance Requirements: - The solution should efficiently handle linked lists with lengths up to 1000 nodes. # Assumptions: - You can assume valid input is provided for the functions. - Duplicates are allowed in the linked list and should be preserved in their sorted position. This question aligns with the existing set by maintaining a similar complexity level, requiring knowledge of linked lists, sorting algorithms, and merge sort specifics.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def build_linked_list(arr: list[int]) -> ListNode: Create a linked list from an array. Args: arr (list[int]): The array to be converted into a linked list. Returns: ListNode: The head of the linked list. if not arr: return None head = ListNode(arr[0]) current = head for value in arr[1:]: current.next = ListNode(value) current = current.next return head def sort_linked_list(head: ListNode) -> ListNode: Sort a linked list using merge sort. Args: head (ListNode): The head of the linked list. Returns: ListNode: The head of the sorted linked list. if not head or not head.next: return head return merge_sort(head) def merge_sort(head: ListNode) -> ListNode: Helper function that implements merge sort on a linked list. Args: head (ListNode): The head of the linked list to be sorted. Returns: ListNode: The head of the sorted linked list. if not head or not head.next: return head # Split the linked list into two halves mid = get_middle(head) left = head right = mid.next mid.next = None # Recursively sort the two halves left = merge_sort(left) right = merge_sort(right) # Merge the sorted halves return merge(left, right) def get_middle(head: ListNode) -> ListNode: slow, fast = head, head while fast.next and fast.next.next: slow = slow.next fast = fast.next.next return slow def merge(left: ListNode, right: ListNode) -> ListNode: dummy = ListNode() current = dummy while left and right: if left.value <= right.value: current.next = left left = left.next else: current.next = right right = right.next current = current.next current.next = left or right return dummy.next"},{"question":"# Question: Optimal Subarray Sum Write a function that finds the maximum sum of a subarray within a given one-dimensional array of integers. This problem is also known as the \\"Maximum Subarray Problem.\\" Function Signature ```python def max_subarray_sum(nums: list[int]) -> int: pass ``` Input * `nums`: A list of integers. (-10^5 ≤ nums[i] ≤ 10^5, 1 ≤ len(nums) ≤ 10^5) Output * Returns an integer representing the maximum sum of a subarray. Constraints * The function should run in O(n) time complexity. * The array will contain at least one positive integer. Example ```python assert max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) == 6 assert max_subarray_sum([1]) == 1 assert max_subarray_sum([-1,-2,-3,-4]) == -1 assert max_subarray_sum([5,4,-1,7,8]) == 23 assert max_subarray_sum([3,-2,5,-1]) == 6 ``` # Guidelines and Tips 1. **Kadane\'s Algorithm**: Implement the algorithm, which scans the array from left to right, keeping track of the maximum subarray sum ending at each position. 2. **Initialization**: Start your process by initializing the first element as the current maximum and global maximum. 3. **Iterative Update**: Iterate through the array updating the current maximum at each position by comparing the current element and the sum of the current element with the previous maximum subarray sum. 4. **Edge Cases**: Handle edge cases where all numbers are negative. 5. **Result**: The global maximum at the end of the iteration will be the result. The solution should demonstrate efficient linear-time traversal and the ability to handle the array\'s dynamics, ensuring that the maximum subarray sum is found accurately.","solution":"def max_subarray_sum(nums: list[int]) -> int: Returns the maximum sum of a subarray within the given list of integers. # Initialize the variables with the first element of the list. max_current = max_global = nums[0] # Traverse through the list starting from the second element for num in nums[1:]: # Update max_current max_current = max(num, max_current + num) # Update max_global if max_current is greater if max_current > max_global: max_global = max_current return max_global"},{"question":"# Scenario You are a software developer at a tech company that develops financial applications. Your team’s latest project is to create an expense tracking application. One of the key functionalities needed is to automatically categorize expenses based on the description of each transaction, to help users quickly understand their spending patterns. # Problem Statement You need to implement a feature in your expense tracking application that categorizes expenses based on the keywords in the transaction descriptions. The application must use predefined categories and keywords, and should accurately categorize each expense or mark it as \\"Uncategorized\\" if no keywords match. # Requirements You are to implement the function `categorize_expense` that takes a single string parameter: 1. `description` (str): The description of the transaction. Your function should use a predefined dictionary of categories and their corresponding keywords. It should return a string representing the category of the transaction based on the keywords found in the description. If no keywords match, return \\"Uncategorized\\". # Input - `description`: a string representing the description of the transaction (e.g., \\"Bought a coffee at Starbucks\\"). # Output - Returns a string representing the category of the expense. # Constraints - The `description` will only contain alphanumeric characters and spaces. - The input description will always be a non-empty string. - Keywords and categories are provided as: ```python CATEGORIES = { \\"Food\\": [\\"restaurant\\", \\"coffee\\", \\"grocery\\", \\"dinner\\", \\"lunch\\", \\"breakfast\\"], \\"Transportation\\": [\\"taxi\\", \\"uber\\", \\"bus\\", \\"train\\", \\"flight\\", \\"gas\\"], \\"Entertainment\\": [\\"movie\\", \\"concert\\", \\"theater\\", \\"game\\", \\"party\\"], \\"Utilities\\": [\\"electricity\\", \\"water\\", \\"internet\\", \\"rent\\", \\"mortgage\\"], \\"Health\\": [\\"gym\\", \\"doctor\\", \\"pharmacy\\", \\"dental\\", \\"optical\\"], \\"Shopping\\": [\\"clothes\\", \\"shoes\\", \\"electronics\\", \\"furniture\\", \\"books\\"] } ``` - An expense description can match more than one keyword from different categories. In such cases, return the first category found in the predefined dictionary order. # Example ```python def categorize_expense(description: str) -> str: Given an expense description, categorizes it based on predefined keywords. Parameters: description (str): The transaction description. Returns: str: The category of the expense. CATEGORIES = { \\"Food\\": [\\"restaurant\\", \\"coffee\\", \\"grocery\\", \\"dinner\\", \\"lunch\\", \\"breakfast\\"], \\"Transportation\\": [\\"taxi\\", \\"uber\\", \\"bus\\", \\"train\\", \\"flight\\", \\"gas\\"], \\"Entertainment\\": [\\"movie\\", \\"concert\\", \\"theater\\", \\"game\\", \\"party\\"], \\"Utilities\\": [\\"electricity\\", \\"water\\", \\"internet\\", \\"rent\\", \\"mortgage\\"], \\"Health\\": [\\"gym\\", \\"doctor\\", \\"pharmacy\\", \\"dental\\", \\"optical\\"], \\"Shopping\\": [\\"clothes\\", \\"shoes\\", \\"electronics\\", \\"furniture\\", \\"books\\"] } description = description.lower() for category, keywords in CATEGORIES.items(): for keyword in keywords: if keyword in description: return category return \\"Uncategorized\\" # Example usage: print(categorize_expense(\\"Bought a coffee at Starbucks\\")) # Should output: \\"Food\\" print(categorize_expense(\\"Monthly gym membership\\")) # Should output: \\"Health\\" print(categorize_expense(\\"Paid electricity bill\\")) # Should output: \\"Utilities\\" # No matching keywords, so it should output: \\"Uncategorized\\" print(categorize_expense(\\"Visited the park\\")) ```","solution":"def categorize_expense(description: str) -> str: Given an expense description, categorizes it based on predefined keywords. Parameters: description (str): The transaction description. Returns: str: The category of the expense. CATEGORIES = { \\"Food\\": [\\"restaurant\\", \\"coffee\\", \\"grocery\\", \\"dinner\\", \\"lunch\\", \\"breakfast\\"], \\"Transportation\\": [\\"taxi\\", \\"uber\\", \\"bus\\", \\"train\\", \\"flight\\", \\"gas\\"], \\"Entertainment\\": [\\"movie\\", \\"concert\\", \\"theater\\", \\"game\\", \\"party\\"], \\"Utilities\\": [\\"electricity\\", \\"water\\", \\"internet\\", \\"rent\\", \\"mortgage\\"], \\"Health\\": [\\"gym\\", \\"doctor\\", \\"pharmacy\\", \\"dental\\", \\"optical\\"], \\"Shopping\\": [\\"clothes\\", \\"shoes\\", \\"electronics\\", \\"furniture\\", \\"books\\"] } description = description.lower() for category, keywords in CATEGORIES.items(): for keyword in keywords: if keyword in description: return category return \\"Uncategorized\\""},{"question":"# Pascal\'s Triangle Row Sum Calculation Write a function that calculates the sum of the elements in the ( n )-th row of Pascal\'s Triangle. Pascal\'s Triangle is a triangular array of the binomial coefficients. The entries in each row are the coefficients in the expansion of ( (a + b)^n ). For example, the sum of the elements in the 3rd row (1, 3, 3, 1) is 8. **Function Signature**: ```python def sum_pascals_triangle_row(n: int) -> int: pass ``` # Input: * `n` (integer): A non-negative integer ( n ) where ( 0 leq n leq 10^7 ). # Output: * Returns an integer representing the sum of the elements in the ( n )-th row of Pascal\'s Triangle. # Examples: ```python >>> sum_pascals_triangle_row(3) 8 >>> sum_pascals_triangle_row(5) 32 ``` # Constraints: * The calculation must be efficient and should not require construction of the entire Pascal\'s Triangle. * Python\'s native integer type (arbitrary-precision) may be beneficial for large values of `n`. # Requirements: 1. Utilize properties and patterns of Pascal\'s Triangle to compute the sum directly. 2. Handle the edge case where ( n = 0 ) correctly. # Example Explanation: The sum of the elements in the ( n )-th row of Pascal\'s Triangle is ( 2^n ): * For `n = 3`: ( 2^3 = 8 ) * For `n = 5`: ( 2^5 = 32 ) Given this property, your task is to implement an algorithm that calculates ( 2^n ) efficiently for large values of `n`.","solution":"def sum_pascals_triangle_row(n: int) -> int: Calculates the sum of the elements in the n-th row of Pascal\'s Triangle. The sum of the elements in the n-th row of Pascal\'s Triangle is always 2^n. :param n: Non-negative integer representing the row number. :return: Sum of the elements in the n-th row of Pascal\'s Triangle. return 2 ** n"},{"question":"# Problem Statement You are tasked with writing a function `group_and_sort_elements` that takes a list of integers and groups them based on their frequency of occurrence, then sorts each group by its frequency in decreasing order, and finally, within each group, sort the elements in ascending order. # Function Signature ```python def group_and_sort_elements(arr: List[int]) -> List[List[int]]: pass ``` # Input - `arr`: A list of integers `arr` (0 <= len(arr) <= 10^5), where each element `x` (-10^6 <= x <= 10^6). # Output - A list of lists, where each sub-list contains integers grouped by their frequency, sorted first by frequency (highest to lowest) and within each group, sorted in ascending order. # Examples ```python assert group_and_sort_elements([4, 5, 6, 5, 4, 3]) == [[4, 5], [3, 6]] assert group_and_sort_elements([1, 2, 2, 3, 3, 3]) == [[3], [2], [1]] assert group_and_sort_elements([4, 4, 4, 4, 4]) == [[4]] assert group_and_sort_elements([]) == [] assert group_and_sort_elements([1, 2, 3, 4, 5]) == [[1, 2, 3, 4, 5]] ``` # Constraints - Ensure your solution is efficient and can handle large input sizes. - The list can be empty, and in such cases, the output should be an empty list. - Do not use any external libraries apart from standard Python ones. # Notes - The final output should have all groups sorted primarily by their frequency in descending order. - Within each frequency group, elements should be sorted in ascending order. - Consider edge cases such as an empty list or a list with all elements having the same frequency.","solution":"from collections import Counter from typing import List def group_and_sort_elements(arr: List[int]) -> List[List[int]]: Groups elements based on their frequency of occurrence, sorts each group by frequency in decreasing order, and within each group, the elements are sorted in ascending order. if not arr: return [] # Calculate the frequency of each element frequency = Counter(arr) # Create a dictionary where the keys are frequencies and the values are lists of elements with that frequency freq_dict = {} for num, freq in frequency.items(): if freq not in freq_dict: freq_dict[freq] = [] freq_dict[freq].append(num) # Sort the elements within each frequency group and then sort the groups by frequency in descending order result = [] for freq in sorted(freq_dict.keys(), reverse=True): result.append(sorted(freq_dict[freq])) return result"},{"question":"# Problem Statement Design an API rate limit monitor for a web service. The monitor should track API requests from users and ensure they do not exceed a predefined rate limit. If a user makes too many requests within a specific time window, further requests should be denied. You\'re tasked with creating a function `rate_limiter` that keeps track of user requests and enforces the rate limit. The rate limit is defined by the number of allowed requests and the time window in seconds. Function Signature ```python from typing import Optional def rate_limiter(user: str, timestamp: int, allowed_requests: int, time_window: int) -> Optional[str]: Track API requests from users and enforce rate limit. Args: user (str): The username of the requester. timestamp (int): The time in seconds since the epoch when the request is received. allowed_requests (int): The number of allowed requests in the given time window. time_window (int): The time window in seconds within which the allowed requests can be made. Returns: Optional[str]: A message \\"Rate limit exceeded\\" if the user exceeds the allowed requests within the time window, otherwise `None`. Example: >>> rate_limiter(\\"user1\\", 100, 3, 60) >>> rate_limiter(\\"user1\\", 120, 3, 60) >>> rate_limiter(\\"user1\\", 130, 3, 60) \'Rate limit exceeded\' pass ``` # Constraints: * `timestamp` will be a non-negative integer representing seconds since the Unix epoch. * `allowed_requests` and `time_window` will be positive integers. * The function will be called multiple times for different users and timestamps, and it should maintain the state between calls. # Requirements: * The function should return `None` if the user’s request is within the rate limit. * The function should return \\"Rate limit exceeded\\" if the user exceeds the allowed number of requests within the specified time window. * Efficiently handle up to 10,000 users and up to 1,000,000 API requests. # Example: ```python >>> rate_limiter(\\"user1\\", 100, 3, 60) >>> rate_limiter(\\"user1\\", 120, 3, 60) >>> rate_limiter(\\"user1\\", 130, 3, 60) \'Rate limit exceeded\' ```","solution":"from collections import defaultdict from typing import Optional # Global dictionary to keep track of user requests. user_requests = defaultdict(list) def rate_limiter(user: str, timestamp: int, allowed_requests: int, time_window: int) -> Optional[str]: Track API requests from users and enforce rate limit. Args: user (str): The username of the requester. timestamp (int): The time in seconds since the epoch when the request is received. allowed_requests (int): The number of allowed requests in the given time window. time_window (int): The time window in seconds within which the allowed requests can be made. Returns: Optional[str]: A message \\"Rate limit exceeded\\" if the user exceeds the allowed requests within the time window, otherwise `None`. if len(user_requests[user]) == allowed_requests: if timestamp - user_requests[user][0] < time_window: return \\"Rate limit exceeded\\" # Remove the oldest timestamp that\'s out of the time window user_requests[user].pop(0) # Add new timestamp user_requests[user].append(timestamp) return None"},{"question":"# Context Sorting algorithms are essential in computer science and often evaluated for their performance in terms of time and space complexity. Understanding and implementing various sorting algorithms can provide deeper insights into their mechanics and applications. # Problem Statement Implement the Merge Sort algorithm to sort a given list of integers in ascending order. # Requirements 1. **merge_sort(arr: List[int]) -> List[int]**: A function that takes a list of integers and returns a new list with the integers sorted in ascending order using the Merge Sort algorithm. # Input and Output Formats * **Input**: A list of integers of arbitrary length. * **Output**: A new list of integers, sorted in ascending order. # Constraints * The function must use the Merge Sort algorithm. * Consider the space complexity and optimize where possible. * Handle edge cases such as empty lists and lists with a single element. # Performance Considerations * Aim for a time complexity of O(n log n), where n is the number of elements in the list. # Example ```python # Example usage: assert merge_sort([38, 27, 43, 3, 9, 82, 10]) == [3, 9, 10, 27, 38, 43, 82] assert merge_sort([5, 2, 9, 1, 5, 6]) == [1, 2, 5, 5, 6, 9] assert merge_sort([]) == [] assert merge_sort([1]) == [1] assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] ``` # Edge Cases to Consider * An empty list. * A list with a single element. * A list that is already sorted. * A list with duplicate elements. Implement the function: ```python from typing import List def merge_sort(arr: List[int]) -> List[int]: def merge(left: List[int], right: List[int]) -> List[int]: sorted_list = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 sorted_list.extend(left[i:]) sorted_list.extend(right[j:]) return sorted_list if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) ```","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: def merge(left: List[int], right: List[int]) -> List[int]: sorted_list = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 sorted_list.extend(left[i:]) sorted_list.extend(right[j:]) return sorted_list if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right)"},{"question":"# Problem Statement Write a function `rotate_array` that takes an array of integers `arr` and an integer `k` and rotates the array to the right by `k` steps. The rotation should be performed in-place, and you should minimize the total number of operations. # Function Signature ```python def rotate_array(arr: list[int], k: int) -> None: Rotates the array to the right by k steps. Args: - arr: List[int] : List of integers to be rotated. - k: int : Number of steps to rotate the array to the right. Returns: - None: The rotation is performed in-place. Examples: - rotate_array([1,2,3,4,5,6,7], 3) => Expected Result: [5,6,7,1,2,3,4] - rotate_array([-1,-100,3,99], 2) => Expected Result: [3,99,-1,-100] - rotate_array([1,2], 3) => Expected Result: [2,1] pass ``` # Constraints and Assumptions * The array can contain both positive and negative integers. * The array will not contain any non-integer values. * `k` will always be a non-negative integer. * The function should handle an empty array gracefully. * The function should operate in-place without allocating extra space for another array. # Sample Input and Output ```python # Example 1 arr1 = [1, 2, 3, 4, 5, 6, 7] rotate_array(arr1, 3) assert arr1 == [5, 6, 7, 1, 2, 3, 4] # Example 2 arr2 = [-1, -100, 3, 99] rotate_array(arr2, 2) assert arr2 == [3, 99, -1, -100] # Example 3 arr3 = [1, 2] rotate_array(arr3, 3) assert arr3 == [2, 1] # Example 4: Rotating an empty array arr4 = [] rotate_array(arr4, 2) assert arr4 == [] # Example 5: k is 0 (no rotation) arr5 = [1, 2, 3, 4] rotate_array(arr5, 0) assert arr5 == [1, 2, 3, 4] ``` # Notes * Consider the effect of `k` being larger than the length of the array, as rotating by `k` steps where `k` is greater than the array\'s length is equivalent to rotating by `k % len(arr)` steps. * Ensure that the solution handles edge cases like an empty array or single-element arrays correctly.","solution":"def rotate_array(arr: list[int], k: int) -> None: Rotates the array to the right by k steps. Args: - arr: List[int] : List of integers to be rotated. - k: int : Number of steps to rotate the array to the right. Returns: - None: The rotation is performed in-place. if not arr: return # Early exit if the array is empty n = len(arr) k %= n # To handle cases where k is larger than the array length arr[:] = arr[-k:] + arr[:-k] # Rotate the array in-place"},{"question":"# Coding Challenge: Detecting Cycles in a Directed Graph Scenario: In some complex routing networks where nodes represent junctions and directed edges represent one-way streets, it\'s crucial to detect if there are any cycles within the system. A cycle exists if you can start from any node and return to the same node while traversing along the directed edges. Identifying such cycles can help with network optimization and avoid potential roadblocks. Task: Implement a function `detect_cycle` that takes the number of junctions (nodes) and the one-way streets (edges) as input and returns whether any cycle exists in the graph. Function Signature: ```python def detect_cycle(n: int, edges: list[tuple[int, int]]) -> bool: ``` Input: - `n` (int): The number of junctions (nodes) in the routing network. - `edges` (list of tuples of int): Each tuple (u, v) represents a directed edge from junction u to junction v. Output: - `bool`: Return `True` if there is at least one cycle in the graph, otherwise return `False`. Constraints: - `1 <= n <= 10^4` (number of nodes) - `0 <= len(edges) <= 5 * 10^4` (number of edges) - Junction IDs (nodes) are numbered from 0 to n-1. Example: ```python n = 5 edges = [(0, 1), (1, 2), (2, 3), (3, 4), (4, 2)] print(detect_cycle(n, edges)) # Expected Output: True n = 3 edges = [(0, 1), (1, 2)] print(detect_cycle(n, edges)) # Expected Output: False ``` Requirements: - Use Depth First Search (DFS) to detect cycles. - Ensure that your function runs efficiently with the provided constraints. - Write additional helper functions if necessary. Notes: - Consider edge cases like an empty graph (n = 0, edges = []) and multiple disjoint subgraphs. - Cycles involving a single node (self-loops) should also be considered.","solution":"def detect_cycle(n: int, edges: list[tuple[int, int]]) -> bool: from collections import defaultdict def dfs(node): if visited[node] == 1: return True if visited[node] == 2: return False visited[node] = 1 for neighbor in graph[node]: if dfs(neighbor): return True visited[node] = 2 return False # Create graph from edges graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Visited array visited = [0] * n # 0 = unvisited, 1 = visiting, 2 = visited # Perform DFS on each node for i in range(n): if dfs(i): return True return False"},{"question":"# Context Finding unique values in an array is a common task in data processing and analysis, used in various applications such as identifying distinct elements, filtering duplicates, and preparing sets for mathematical operations. You are tasked with implementing a function that extracts unique elements from a given list. # Objective Write a Python function `find_unique_elements` that takes a list of integers and returns a new list containing only the unique elements from the input list. The function should handle different constraints and validate inputs appropriately. # Requirements 1. The function should accept exactly one parameter: `numbers`, which must be a list of integers. 2. The function should return a list containing unique integers, maintaining the order of their first occurrence. 3. The function should handle input validation: - If the input is not a list, raise a `TypeError`. - If any element within the list is not an integer, raise a `ValueError`. # Implementation Details - Iterate through the input list and track the unique elements. - Maintain the order of first appearance for the unique elements. - Ensure input validation as specified. # Input Format - `numbers` (list): A list of integers. # Output Format - A list containing unique integers from the input list. # Examples 1. `find_unique_elements([1, 2, 2, 3, 4, 4, 5])` returns `[1, 2, 3, 4, 5]` 2. `find_unique_elements([7, 7, 7, 7])` returns `[7]` 3. `find_unique_elements([10, 20, 30, 20, 10, 40])` returns `[10, 20, 30, 40]` 4. `find_unique_elements([5, 4, 3, 3, 2, 2, 1, 1, 1])` returns `[5, 4, 3, 2, 1]` 5. `find_unique_elements([])` returns `[]` 6. `find_unique_elements([False, True, 1, 2, 3])` raises `ValueError: All elements in the list must be integers` 7. `find_unique_elements(\\"12345\\")` raises `TypeError: Input must be a list of integers` # Constraints - Ensure the function performs efficiently for typical use cases. - Input values will be within the valid range for Python integers.","solution":"def find_unique_elements(numbers): Returns a list containing only the unique integers from the input list, maintaining the order of their first occurrence. :param numbers: list of integers :return: list of unique integers if not isinstance(numbers, list): raise TypeError(\\"Input must be a list of integers\\") unique_elements = [] seen_elements = set() for num in numbers: if not isinstance(num, int): raise ValueError(\\"All elements in the list must be integers\\") if num not in seen_elements: unique_elements.append(num) seen_elements.add(num) return unique_elements"},{"question":"# Scenario As a software developer, you often need to find specific elements within a collection of data. For this task, you are to create a function that identifies the first non-repeating character in a given string. This will help in various applications, such as text processing and data analysis, where identifying unique elements is essential. # Problem Statement Write a function called `first_non_repeating_char(s: str) -> str` that takes a string `s` and returns the first non-repeating character. If all characters are repeating or the input string is empty, return an empty string. # Function Signature ```python def first_non_repeating_char(s: str) -> str: ``` # Input * `s` (string, 1 ≤ len(s) ≤ 1000): The input string to be analyzed. # Output * Returns a single character string representing the first non-repeating character in the input string. If no non-repeating character is found, return an empty string. # Examples ```python assert first_non_repeating_char(\\"swiss\\") == \\"w\\" assert first_non_repeating_char(\\"programming\\") == \\"p\\" assert first_non_repeating_char(\\"aabbcc\\") == \\"\\" assert first_non_repeating_char(\\"abcdef\\") == \\"a\\" ``` # Constraints * The function must be efficient in identifying the first non-repeating character. * Consider upper and lower case as distinct characters. # Notes * Review edge cases like an input with all repeating characters or a single non-repeating character at the end of the string. # Hints * Using a dictionary can help in counting character occurrences efficiently. * Traverse the string twice: once to build the frequency dictionary and once to find the first non-repeating character.","solution":"def first_non_repeating_char(s: str) -> str: Returns the first non-repeating character in the given string `s`. If all characters are repeating or the string is empty, returns an empty string. # Step 1: Use a dictionary to count the occurrences of each character char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Step 2: Iterate through the string to find the first non-repeating character for char in s: if char_count[char] == 1: return char # If no such character is found, return an empty string return \\"\\""},{"question":"# Bank Account Balance Calculation You are tasked with implementing a function to compute the balance of a user\'s bank account after a series of deposits and withdrawals. # Function Specification Implement the following function in Python: ```python def calculate_balance(initial_balance: float, transactions: list) -> float: Calculate the balance of a bank account after a series of deposits and withdrawals. Parameters: - initial_balance (float): The initial balance, must be non-negative. - transactions (list): A list of tuples, each containing a transaction type (str) and an amount (float). The transaction type can be either \'deposit\' or \'withdrawal\'. Returns: - float: The final balance rounded to two decimal places. Raises: - ValueError: If the initial balance is negative or if any transaction amount is negative. - ValueError: If an invalid transaction type is encountered. Example Usage: >>> calculate_balance(100.0, [(\'deposit\', 50.0), (\'withdrawal\', 25.0)]) 125.00 >>> calculate_balance(200.0, [(\'deposit\', 100.0), (\'withdrawal\', 150.0)]) 150.00 >>> calculate_balance(300.0, [(\'withdrawal\', 70.0), (\'deposit\', 50.0)]) 280.00 ``` # Input and Output - **Input**: - `initial_balance` (float): The starting balance of the account. Must be a non-negative value. - `transactions` (list): A list of tuples, where each tuple contains: - A transaction type as a string (\'deposit\' or \'withdrawal\'). - A transaction amount as a float. Must be a non-negative value. - **Output**: The function should return the final balance as a float, rounded to two decimal places. # Constraints - The initial balance must be non-negative. - Transaction amounts must be non-negative. - Transaction types must be either \'deposit\' or \'withdrawal\'. - The function must handle input validation and raise appropriate errors for non-compliant values. # Examples: ```python >>> calculate_balance(100.0, [(\'deposit\', 50.0), (\'withdrawal\', 25.0)]) 125.00 >>> calculate_balance(200.0, [(\'deposit\', 100.0), (\'withdrawal\', 150.0)]) 150.00 >>> calculate_balance(300.0, [(\'withdrawal\', 70.0), (\'deposit\', 50.0)]) 280.00 >>> calculate_balance(-100.0, [(\'deposit\', 50.0), (\'withdrawal\', 25.0)]) Traceback (most recent call last): ... ValueError: Initial balance must be non-negative. >>> calculate_balance(100.0, [(\'deposit\', -50.0)]) Traceback (most recent call last): ... ValueError: Transaction amount must be non-negative. >>> calculate_balance(100.0, [(\'withdraw\', 50.0)]) Traceback (most recent call last): ... ValueError: Invalid transaction type \'withdraw\'. ``` Implement the function according to the specification above and ensure it passes the provided test cases.","solution":"def calculate_balance(initial_balance: float, transactions: list) -> float: Calculate the balance of a bank account after a series of deposits and withdrawals. Parameters: - initial_balance (float): The initial balance, must be non-negative. - transactions (list): A list of tuples, each containing a transaction type (str) and an amount (float). The transaction type can be either \'deposit\' or \'withdrawal\'. Returns: - float: The final balance rounded to two decimal places. Raises: - ValueError: If the initial balance is negative or if any transaction amount is negative. - ValueError: If an invalid transaction type is encountered. if initial_balance < 0: raise ValueError(\\"Initial balance must be non-negative.\\") balance = initial_balance for transaction_type, amount in transactions: if amount < 0: raise ValueError(\\"Transaction amount must be non-negative.\\") if transaction_type == \'deposit\': balance += amount elif transaction_type == \'withdrawal\': balance -= amount else: raise ValueError(f\\"Invalid transaction type \'{transaction_type}\'.\\") return round(balance, 2)"},{"question":"# Scenario You are developing a software for a graph-based application where you need to analyze the connectivity of the graph. One of the requirements is to determine if the graph is connected. A connected graph is one where there is a path between any two vertices. Your task is to implement a function that checks if an undirected graph is connected. # Task Implement the function `is_connected(graph: Dict[int, List[int]]) -> bool` which determines if a given undirected graph is connected. # Function Signature ```python def is_connected(graph: Dict[int, List[int]]) -> bool: pass ``` # Input: * `graph` (Dict[int, List[int]]): A dictionary representing an undirected graph where keys are nodes, and values are lists of adjacent nodes. # Output: * Returns a boolean indicating whether the graph is connected (True) or not (False). # Constraints: * The graph can contain 0 or more nodes. * Node identifiers are non-negative integers. * The adjacency list is symmetric (if node A is connected to node B, node B is connected to node A). # Examples: 1. Input: `graph = {0: [1, 2], 1: [0, 2], 2: [0, 1]}` Output: `True` 2. Input: `graph = {0: [1], 1: [0, 2], 2: [1], 3: []}` Output: `False` 3. Input: `graph = {0: [1], 1: [0, 2], 2: [1]}` Output: `True` 4. Input: `graph = {}` Output: `True` # Note: The function should effectively check graph connectivity using Depth-First Search (DFS) or Breadth-First Search (BFS). Ensure the implementation can handle large graphs efficiently and correctly handle edge cases, such as empty graphs.","solution":"def is_connected(graph): Determines if an undirected graph is connected. Args: graph (Dict[int, List[int]]): A dictionary representation of the graph. Returns: bool: True if the graph is connected, False otherwise. if not graph: return True # Use a dictionary to track visited nodes visited = set() # Get an arbitrary starting node start_node = next(iter(graph)) # Use DFS to visit all nodes connected to the start_node def dfs(node): if node not in visited: visited.add(node) for neighbor in graph[node]: dfs(neighbor) dfs(start_node) # Check if all nodes were visited return len(visited) == len(graph)"},{"question":"# Coding Assessment Question **Context**: You are given an unweighted, undirected graph represented as an adjacency list. The challenge involves checking whether the graph is a tree. A tree is an acyclic connected graph where any two vertices are connected by exactly one path. **Task**: Write a function `is_tree(graph: Dict[int, List[int]]) -> bool` that: 1. Receives a dictionary `graph` where keys are integers representing graph nodes and values are lists of integers representing the nodes they are connected to. 2. Returns `True` if the graph is a tree, and `False` otherwise. **Input**: - A dictionary `graph` representing the adjacency list of an unweighted, undirected graph. **Output**: - A boolean value: `True` if the graph is a tree and `False` otherwise. **Constraints**: - The graph can have up to 10,000 nodes. **Example**: ```python graph1 = { 0: [1, 2], 1: [0, 3, 4], 2: [0], 3: [1], 4: [1] } print(is_tree(graph1)) # Output: True graph2 = { 0: [1, 2], 1: [0, 2], 2: [0, 1] } print(is_tree(graph2)) # Output: False graph3 = { 0: [1], 1: [0, 2], 2: [1, 3], 3: [2, 4], 4: [3] } print(is_tree(graph3)) # Output: True ``` **Function Signature**: ```python def is_tree(graph: Dict[int, List[int]]) -> bool: pass ``` To determine if the graph is a tree, you will need to: 1. Check if the graph is connected. 2. Ensure the graph does not contain any cycles.","solution":"def is_tree(graph): Returns True if the graph is a tree, otherwise False. if not graph: return True # An empty graph is a trivial tree # A helper function to perform DFS and detect cycles def dfs(node, parent): visited.add(node) for neighbor in graph[node]: if neighbor not in visited: if not dfs(neighbor, node): return False elif neighbor != parent: return False return True # Check for connectedness visited = set() start_node = next(iter(graph)) # Get an arbitrary start node if not dfs(start_node, None): return False return len(visited) == len(graph) # Check if all nodes were visited (graph is connected)"},{"question":"# Coding Assessment Question: String Manipulation and Substring Analysis You are required to implement two functions related to string manipulation: finding the longest palindrome in a given string and checking if a string is a permutation of a palindrome. - **Function 1: `longest_palindrome_substring(s: str) -> str`** - **Description**: Find the longest substring in the input string that is a palindrome. - **Input**: A string `s`. - **Output**: A string representing the longest palindromic substring. If there are multiple substrings with the same maximum length, return the first one encountered. - **Constraints**: - The input string must be non-empty. - **Edge Cases**: - Raise a `ValueError` for invalid inputs, such as empty strings or non-string inputs. - **Function 2: `is_permutation_of_palindrome(s: str) -> bool`** - **Description**: Check if the input string is a permutation of a palindrome. - **Input**: A string `s`. - **Output**: A boolean indicating if any permutation of the string forms a palindrome. - **Constraints**: - The input string can contain any characters and be of any length (including empty). - **Edge Cases**: - Handle both empty strings and strings containing special characters and spaces. Example: ```python # Example Function Call: print(longest_palindrome_substring(\\"babad\\")) # Output: \\"bab\\" or \\"aba\\" print(is_permutation_of_palindrome(\\"carerac\\")) # Output: True # Example Invalid Call: print(longest_palindrome_substring(123)) # Output: Raises ValueError # Empty string example in permutation check: print(is_permutation_of_palindrome(\\"\\")) # Output: True ``` Performance Requirement: - The `longest_palindrome_substring` function should operate in O(n^2) time complexity, where n is the length of the string. - The `is_permutation_of_palindrome` function should operate in linear time, O(n), where n is the length of the string. **Notes**: - You can assume the string will have fewer than 10^4 characters. - Use proper exception handling to deal with invalid input scenarios. Implement the functions according to the given specifications.","solution":"def longest_palindrome_substring(s: str) -> str: Finds the longest palindromic substring in the given string. Parameters: s (str): Input string Returns: str: Longest palindromic substring Raises: ValueError: If the input is not a string or if it\'s empty if not isinstance(s, str) or not s: raise ValueError(\\"Input must be a non-empty string\\") def expand_around_center(left: int, right: int) -> str: while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] longest = \\"\\" for i in range(len(s)): # Odd-length palindromes odd_palindrome = expand_around_center(i, i) if len(odd_palindrome) > len(longest): longest = odd_palindrome # Even-length palindromes even_palindrome = expand_around_center(i, i + 1) if len(even_palindrome) > len(longest): longest = even_palindrome return longest def is_permutation_of_palindrome(s: str) -> bool: Checks if the given string is a permutation of a palindrome. Parameters: s (str): Input string Returns: bool: True if any permutation of the string is a palindrome, False otherwise from collections import Counter # Count frequency of each character count = Counter(s.replace(\\" \\", \\"\\").lower()) # Assuming case insensitivity and ignoring spaces # At most one character can have an odd count in a palindrome permutation odd_count = sum(1 for freq in count.values() if freq % 2 != 0) return odd_count <= 1"},{"question":"# Context You are developing a data analysis tool that processes large datasets containing numerical values. The tool should facilitate users to calculate the moving average of a sequence of numbers over a specified window size. The moving average should be computed such that each value in the result set represents the average of the preceding numbers within the given window size. # Problem Statement Implement a function `moving_average(sequence: List[int], window_size: int) -> List[float]` that takes a list of integers `sequence` and an integer `window_size` as its parameters. This function should return a list of floating-point numbers representing the moving average of the sequence over the specified window size. # Requirements 1. The moving average at position `i` should be calculated as the average of the previous `window_size` numbers including the current number at `i`. 2. If there are fewer than `window_size` numbers before a position, calculate the average using all available preceding numbers up to the first element. 3. Ensure the output list has the same length as the input sequence. # Example ```python >>> moving_average([1, 2, 3, 4, 5], 3) [1.0, 1.5, 2.0, 3.0, 4.0] >>> moving_average([10, 20, 30, 40, 50], 2) [10.0, 15.0, 25.0, 35.0, 45.0] >>> moving_average([5, 10, 15, 20, 25], 1) [5.0, 10.0, 15.0, 20.0, 25.0] >>> moving_average([1, 2], 5) [1.0, 1.5] ``` # Constraints * The length of the input sequence will be between 1 and 10^5 elements. * The window size will be a positive integer and will not exceed the length of the sequence. Write your implementation of `moving_average(sequence: List[int], window_size: int) -> List[float]`.","solution":"from typing import List def moving_average(sequence: List[int], window_size: int) -> List[float]: if not sequence or window_size <= 0: return [] result = [] window_sum = 0 for i in range(len(sequence)): if i < window_size: window_sum += sequence[i] result.append(window_sum / (i + 1)) else: window_sum += sequence[i] - sequence[i - window_size] result.append(window_sum / window_size) return result"},{"question":"# Coding Assessment Question: Ordered Word List Manipulation Context You have been given a list of words that are initially sorted in ascending alphabetical order. You need to perform various operations on this list, including inserting new words while maintaining the order and removing specific words efficiently. Given the constraints, the operations should be optimized for performance. Task Implement a class `OrderedWordList` that supports the following methods: - `add_word(self, word: str) -> None`: Adds a new word to the list while maintaining the alphabetical order. - `remove_word(self, word: str) -> bool`: Removes the word from the list if it exists and returns `True`. If the word is not in the list, it returns `False`. Function Signature ```python class OrderedWordList: def __init__(self): Initializes an empty ordered word list. def add_word(self, word: str) -> None: Adds a new word to the list while maintaining the alphabetical order. Args: word (str): The word to be added. def remove_word(self, word: str) -> bool: Removes the specified word from the list. Args: word (str): The word to be removed. Returns: bool: True if the word was removed, False otherwise. def __str__(self) -> str: Returns a string representation of the ordered word list. ``` Input - `add_word(word: str)`: A single word to be added. - `remove_word(word: str)`: A single word to be removed. Output - `add_word(word: str)`: No output. - `remove_word(word: str)`: Returns `True` if the word was successfully removed, otherwise `False`. - `__str__()`: Returns a string representation of the ordered list. Constraints - No duplicate words will be added. - Words consist only of lowercase English letters. - The list can be empty initially. - Aim for efficient operations. Example ```python # Example 1 ol = OrderedWordList() ol.add_word(\\"apple\\") ol.add_word(\\"banana\\") print(ol) # Expected output: [\\"apple\\", \\"banana\\"] ol.add_word(\\"apricot\\") print(ol) # Expected output: [\\"apple\\", \\"apricot\\", \\"banana\\"] print(ol.remove_word(\\"banana\\")) # Expected output: True print(ol) # Expected output: [\\"apple\\", \\"apricot\\"] print(ol.remove_word(\\"banana\\")) # Expected output: False # Example 2 ol = OrderedWordList() ol.add_word(\\"cat\\") ol.add_word(\\"dog\\") print(ol) # Expected output: [\\"cat\\", \\"dog\\"] print(ol.remove_word(\\"cat\\")) # Expected output: True print(ol) # Expected output: [\\"dog\\"] ol.add_word(\\"bat\\") print(ol) # Expected output: [\\"bat\\", \\"dog\\"] ``` Additional Notes - Consider using binary search to facilitate efficient insertion and removal. - Utilize appropriate data structures to maintain order and support efficient operations.","solution":"import bisect class OrderedWordList: def __init__(self): Initializes an empty ordered word list. self.words = [] def add_word(self, word: str) -> None: Adds a new word to the list while maintaining the alphabetical order. Args: word (str): The word to be added. bisect.insort(self.words, word) def remove_word(self, word: str) -> bool: Removes the specified word from the list. Args: word (str): The word to be removed. Returns: bool: True if the word was removed, False otherwise. index = bisect.bisect_left(self.words, word) if index != len(self.words) and self.words[index] == word: self.words.pop(index) return True return False def __str__(self) -> str: Returns a string representation of the ordered word list. return str(self.words)"},{"question":"# Prime Factorization and Largest Prime Factor Problem Description: You are to implement a function that, given an integer `n`, computes the prime factorization of `n` and returns the largest prime factor of `n`. A prime factor is a prime number that divides `n` without leaving a remainder. # Input: * An integer `n` (2 ≤ `n` ≤ 10^6), which you need to factorize. # Output: * The largest prime factor of `n`. # Function Signature: ```python def largest_prime_factor(n: int) -> int: pass ``` # Constraints: * The given integer `n` will always be greater than or equal to 2. # Example: ```python largest_prime_factor(56) # Output: 7 largest_prime_factor(13195) # Output: 29 ``` # Implementation Details: 1. Identify all prime factors of the given integer `n`. 2. Return the largest prime factor. 3. Use efficient algorithms for factorization to handle the input size constraint. Good luck!","solution":"def largest_prime_factor(n: int) -> int: Returns the largest prime factor of the given integer n. def prime_factors(n): factors = [] # Check for number of 2s while n % 2 == 0: factors.append(2) n //= 2 # Check for odd factors from 3 onwards for i in range(3, int(n**0.5) + 1, 2): while n % i == 0: factors.append(i) n //= i # If n is still greater than 2, then it is a prime factor if n > 2: factors.append(n) return factors factors = prime_factors(n) return max(factors)"},{"question":"# Sorting Algorithm Optimization You are tasked with implementing a function to sort a list of integers using the Merge Sort algorithm. This function should be efficient in both time complexity and space usage. Additionally, ensure the function handles edge cases and large inputs effectively. Function Signature ```python def merge_sort(arr: list) -> list: Sort a list of integers using the Merge Sort algorithm. :param arr: A list of integers. :return: A new list containing the sorted integers. # Your code here ``` # Input * `arr`: A list of integers to be sorted. # Output * A new list with the same integers sorted in ascending order. # Constraints * The list can contain negative integers. * The function should handle lists with duplicate values correctly. * Aim for an O(n log n) time complexity. # Additional Requirements * Ensure the function raises appropriate exceptions for invalid inputs (e.g., non-list inputs). * Optimal space management should be considered especially for large lists. # Example 1. **Input**: arr = [34, 7, 23, 32, 5, 62] **Output**: [5, 7, 23, 32, 34, 62] 2. **Input**: arr = [4, 3, 2, 1] **Output**: [1, 2, 3, 4] 3. **Input**: arr = [1, 2, 3, 4] **Output**: [1, 2, 3, 4] # Implementation Note * Implement the merge sort algorithm using recursion and ensure it handles both small and large input lists effectively. * Ensure the function handles invalid inputs gracefully and raises `TypeError` when the input is not a list. ```python def merge_sort(arr: list) -> list: def merge(left, right): sorted_list = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] < right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 sorted_list.extend(left[left_index:]) sorted_list.extend(right[right_index:]) return sorted_list if not isinstance(arr, list): raise TypeError(\\"Input must be a list.\\") if len(arr) < 2: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) ```","solution":"def merge_sort(arr: list) -> list: Sort a list of integers using the Merge Sort algorithm. :param arr: A list of integers. :return: A new list containing the sorted integers. def merge(left, right): sorted_list = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] < right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 sorted_list.extend(left[left_index:]) sorted_list.extend(right[right_index:]) return sorted_list if not isinstance(arr, list): raise TypeError(\\"Input must be a list.\\") if len(arr) < 2: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right)"},{"question":"# Coding Assessment: Polynomial Root Finder Context You are given a quadratic polynomial in the form (ax^2 + bx + c = 0). Your task is to implement a function that calculates the roots of the polynomial using the quadratic formula. Problem Description Implement the function `quadratic_roots(a: float, b: float, c: float) -> tuple[float, float]` that calculates the roots of the quadratic equation (ax^2 + bx + c = 0) using the following steps: 1. Compute the discriminant (Delta = b^2 - 4ac). 2. Use the quadratic formula (frac{-b pm sqrt{Delta}}{2a}) to find the roots. 3. Return the roots in a tuple `(root1: float, root2: float)` sorted in ascending order. 4. Raise appropriate errors for cases resulting in no real roots. Input Three floats `a`, `b`, and `c` representing the coefficients of the quadratic equation: - `a` (coefficient of (x^2)) - `b` (coefficient of (x)) - `c` (constant term) Output A tuple `(root1: float, root2: float)` representing the roots sorted in ascending order. Constraints - If (a = 0), raise a ValueError with a message \\"Coefficient \'a\' cannot be zero.\\" - If the discriminant (Delta) is negative, raise a ValueError with a message \\"No real roots. (Negative discriminant)\\" Examples ```python >>> quadratic_roots(1, -3, 2) (1.0, 2.0) >>> quadratic_roots(1, 2, 1) (-1.0, -1.0) >>> quadratic_roots(1, 0, -1) (-1.0, 1.0) >>> quadratic_roots(1, 1, 1) Traceback (most recent call last): ... ValueError: No real roots. (Negative discriminant) >>> quadratic_roots(0, 2, 1) Traceback (most recent call last): ... ValueError: Coefficient \'a\' cannot be zero. ```","solution":"import math def quadratic_roots(a: float, b: float, c: float) -> tuple[float, float]: Computes the roots of a quadratic equation ax^2 + bx + c = 0. Parameters: a (float): Coefficient of x^2. b (float): Coefficient of x. c (float): Constant term. Returns: tuple: A tuple containing two roots sorted in ascending order. Raises: ValueError: If a is zero or the discriminant is negative. if a == 0: raise ValueError(\\"Coefficient \'a\' cannot be zero.\\") discriminant = b**2 - 4*a*c if discriminant < 0: raise ValueError(\\"No real roots. (Negative discriminant)\\") sqrt_discriminant = math.sqrt(discriminant) root1 = (-b - sqrt_discriminant) / (2*a) root2 = (-b + sqrt_discriminant) / (2*a) return tuple(sorted((root1, root2)))"},{"question":"**Objective**: Develop a function to analyze and validate password strength. Based on the given criteria, determine if a password meets security standards and, if not, suggest improvements. # Problem Statement You\'re tasked with creating a function `validate_password` that checks the strength of a password based on certain rules and suggests necessary improvements. # Requirements: - The password must be at least 8 characters long. - The password must contain at least one uppercase letter. - The password must contain at least one lowercase letter. - The password must contain at least one digit. - The password must contain at least one special character (e.g., `!@#%^&*()-_+=`). If the password meets all the criteria, return `True`. If any criteria are not met, return a list of strings indicating the missing criteria that need to be addressed. # Function Signature ```python def validate_password(password: str) -> Any: ``` # Input Format: - `password` (str): The password string to be validated. # Output Format: - `True` if the password meets all criteria. - A list of strings with suggestions for improvement if the password does not meet all criteria. # Constraints: - Password length is up to 256 characters. - Password can include any printable ASCII characters. # Example ```python # Example Input password = \\"Password123!\\" # Function Call print(validate_password(password)) # Expected Output True ``` # Additional Examples ```python >>> validate_password(password=\\"pass\\") [\\"Password must be at least 8 characters long\\", \\"Password must contain at least one uppercase letter\\", \\"Password must contain at least one digit\\", \\"Password must contain at least one special character\\"] >>> validate_password(password=\\"Password\\") [\\"Password must contain at least one digit\\", \\"Password must contain at least one special character\\"] >>> validate_password(password=\\"Passw0rd\\") [\\"Password must contain at least one special character\\"] >>> validate_password(password=\\"P@ssword123\\") True ``` # Notes: - Ensure input handling is case-sensitive. - The function should perform efficiently even for the maximum length password. - Prioritize clarity and detailed feedback in the returned suggestions if applicable.","solution":"import re def validate_password(password: str): Returns True if the password meets all the criteria, otherwise returns a list of missing criteria. criteria = [ (r\'.{8,}\', \\"Password must be at least 8 characters long\\"), (r\'[A-Z]\', \\"Password must contain at least one uppercase letter\\"), (r\'[a-z]\', \\"Password must contain at least one lowercase letter\\"), (r\'[0-9]\', \\"Password must contain at least one digit\\"), (r\'[!@#%^&*()-_=+]\', \\"Password must contain at least one special character\\"), ] missing_criteria = [] for regex, message in criteria: if not re.search(regex, password): missing_criteria.append(message) if not missing_criteria: return True return missing_criteria"},{"question":"Text Editor Feature Addition # Objective: Extend the functionality of a simple text editor to include a feature that can efficiently handle large documents while providing basic text operations. # Constraints: 1. The editor should handle files as large as several gigabytes without exceeding 200 MB of memory usage. 2. Support basic text operations: find, replace, and insert. 3. Optimize to minimize disk I/O while processing large documents. # Requirements: 1. Implement the `TextEditor` class to: * Load and handle sections of the file dynamically based on the operations performed. * Maintain a manageable in-memory buffer that ensures efficient access and manipulation of text. 2. Include methods in the `TextEditor` class: * `find(substr)`: Return the next occurrence of the substring within the document. * `replace(old_substr, new_substr)`: Replace all occurrences of the old substring with the new substring in the document. * `insert(position, text)`: Insert a new text at the specified position in the document. 3. Ensure robust error handling and efficient memory management throughout. # Input: - Path to the document filename as a string. # Output: - Results of the `find` operation: Position of the next occurrence of the substring. - Updated document with changes applied directly to the file for `replace` and `insert` operations. # Example: ```python editor = TextEditor(\\"large_document.txt\\") position = editor.find(\\"important\\") # Returns the position of the substring \\"important\\" in the document editor.replace(\\"old term\\", \\"new term\\") # Replaces all instances of \\"old term\\" with \\"new term\\" in the document editor.insert(1500, \\"Additional text\\") # Inserts \\"Additional text\\" at position 1500 in the document ``` # Edge Cases: 1. Empty documents or documents with only whitespace. 2. Large documents with repeated patterns or no instances of the substring being searched for. 3. Insertion or replacement near the beginning/end or in very large documents. # Performance Notes: - Use efficient data structures to manage in-memory text buffers. - Optimize file reading and writing to ensure minimal impact on performance. - Balance the read and write operations to avoid excessive memory and disk usage.","solution":"import os class TextEditor: def __init__(self, filename): self.filename = filename self.buffer_size = 10 * 1024 * 1024 # 10 MB buffer size def _read_buffer(self, position, size): with open(self.filename, \'rb\') as f: f.seek(position) return f.read(size).decode(\'utf-8\') def find(self, substr): with open(self.filename, \'rb\') as f: position = 0 while True: buffer = f.read(self.buffer_size) if not buffer: return -1 buffer_str = buffer.decode(\'utf-8\') index = buffer_str.find(substr) if index != -1: return position + index position += self.buffer_size def replace(self, old_substr, new_substr): temp_filename = self.filename + \\".tmp\\" with open(self.filename, \'rb\') as read_f, open(temp_filename, \'wb\') as write_f: buffer = read_f.read(self.buffer_size) while buffer: buffer_str = buffer.decode(\'utf-8\') buffer_str = buffer_str.replace(old_substr, new_substr) write_f.write(buffer_str.encode(\'utf-8\')) buffer = read_f.read(self.buffer_size) os.replace(temp_filename, self.filename) def insert(self, position, text): temp_filename = self.filename + \\".tmp\\" with open(self.filename, \'rb\') as read_f, open(temp_filename, \'wb\') as write_f: written = 0 buffer = read_f.read(self.buffer_size) while buffer: buffer_str = buffer.decode(\'utf-8\') if written <= position < written + len(buffer_str): relative_pos = position - written buffer_str = buffer_str[:relative_pos] + text + buffer_str[relative_pos:] write_f.write(buffer_str.encode(\'utf-8\')) written += len(buffer_str) buffer = read_f.read(self.buffer_size) os.replace(temp_filename, self.filename)"},{"question":"# Array Shuffle Coding Challenge **Objective**: Implement a function that shuffles the elements of an array randomly. Problem Description Given an array `arr`, the shuffle function should randomly shuffle the elements of the array such that each permutation of the array has an equal probability of occurring. Function Signature ```python def shuffle_array(arr: list) -> list: pass ``` Input * A single list `arr` containing integers (0 ≤ len(arr) ≤ 10^5). Output * A list with the elements of `arr` shuffled randomly. Constraints * The input `arr` must be a list. * If the input is not a list, raise a `TypeError` with the message `\\"Input value of [arr=X] must be an list\\"`. * If the input list contains non-integer elements, raise a `ValueError` with the message `\\"All elements in the list must be integers\\"`. Example ```python >>> shuffle_array([1, 2, 3, 4, 5]) [3, 1, 4, 2, 5] # Output will vary as it is shuffled >>> shuffle_array([10]) [10] >>> shuffle_array([]) [] ``` Edge Cases * Empty array input: * `shuffle_array([])` should return `[]`. * Handling non-list inputs: * `shuffle_array(123)` should raise a `TypeError`. * `shuffle_array([1, \\"two\\", 3])` should raise a `ValueError`. Additional Requirements * Ensure the shuffling process is random and efficient. * Use an in-place shuffle algorithm such as the Fisher-Yates shuffle to achieve optimal complexity. * Avoid using the built-in `random.shuffle` method directly in your solution to demonstrate understanding of the algorithm.","solution":"import random def shuffle_array(arr: list) -> list: Returns the array randomly shuffled. # Ensure the input is a list if not isinstance(arr, list): raise TypeError(f\\"Input value of [arr={arr}] must be a list\\") # Ensure all elements in the list are integers if not all(isinstance(x, int) for x in arr): raise ValueError(\\"All elements in the list must be integers\\") # Implementing Fisher-Yates Shuffle n = len(arr) for i in range(n - 1, 0, -1): j = random.randint(0, i) arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"# Balanced Bracket Subsequence Problem Background: You are given a string consisting of only the characters `(` and `)`. Your task is to implement a function that finds the longest subsequence of balanced brackets in the given string. A balanced subsequence is defined as one where every opening bracket `(` has a corresponding closing bracket `)` in the correct order. Task: Implement the `longest_balanced_subsequence` function that computes the length of the longest balanced subsequence of brackets in the given string. Function Signature: ```python def longest_balanced_subsequence(bracket_string: str) -> int: pass ``` Input: - `bracket_string`: A string consisting of only characters `(` and `)` (1 <= len(bracket_string) <= 10^5). Output: - Returns an integer representing the length of the longest balanced subsequence of brackets. Constraints: - The string will only contain characters `(` and `)`. Example: Given the following strings: - `longest_balanced_subsequence(\\"(()))(\\")` should return `4`, since the longest balanced subsequence is `\\"(())\\"` or `\\"()()\\"`. - `longest_balanced_subsequence(\\")()())\\")` should return `4`, since the longest balanced subsequence is `\\"()()\\"`. - `longest_balanced_subsequence(\\"((()\\")` should return `2`, since the longest balanced subsequence is `\\"()\\"`. Additional Information: - Students are encouraged to think about the problem in terms of counting open and close brackets and matching them appropriately. - Edge cases such as all opening or all closing brackets should be handled gracefully. Good Luck!","solution":"def longest_balanced_subsequence(bracket_string: str) -> int: Returns the length of the longest balanced subsequence of brackets in the given string. open_brackets = 0 close_brackets = 0 for char in bracket_string: if char == \'(\': open_brackets += 1 elif char == \')\': if open_brackets > 0: open_brackets -= 1 close_brackets += 1 # The longest balanced subsequence will have pairs of balanced brackets return 2 * close_brackets"},{"question":"# API Data Processing You are tasked with creating a program that integrates with a public API to retrieve real-time weather information for a given city. The goal is to implement a function that fetches data from the OpenWeatherMap API and formats it for display. Task: Implement a function `fetch_weather_data(city: str) -> dict` that fetches the current weather data for the specified city and returns a dictionary with key weather information. Requirements: 1. **Input:** `city` (string) - the name of the city to fetch the weather information for. 2. **Output:** A dictionary containing the following keys and corresponding values: * `temperature` (float) - The current temperature in Celsius. * `description` (string) - A brief description of the weather (e.g., \'clear sky\', \'rain\'). * `humidity` (int) - The current humidity percentage. * `pressure` (int) - The atmospheric pressure in hPa. * `wind_speed` (float) - The wind speed in meters per second. 3. Handle the following edge cases: * Invalid city name. * API request failures or timeouts. 4. Use appropriate error handling to manage API request errors and invalid responses. Constraints: * Use the OpenWeatherMap API (https://api.openweathermap.org/data/2.5/weather). * The API requires an API key for authentication. You can get a free API key by signing up on the OpenWeatherMap website. * Ensure that the data is fetched and processed efficiently. Example: ```python weather_data = fetch_weather_data(\\"London\\") print(weather_data) ``` This should output a dictionary similar to: ```python { \\"temperature\\": 15.67, \\"description\\": \\"clear sky\\", \\"humidity\\": 60, \\"pressure\\": 1015, \\"wind_speed\\": 3.09 } ``` Note: Ensure proper formatting and conversion of temperature from Kelvin to Celsius as provided by the API. Implement thorough error handling to manage potential issues arising from the API requests and data parsing.","solution":"import requests def fetch_weather_data(city: str) -> dict: Fetch the current weather data for the specified city and return a formatted dictionary. :param city: str - The name of the city to retrieve weather information for. :return: dict - A dictionary containing weather information. api_key = \'YOUR_API_KEY\' # Replace with your actual OpenWeatherMap API key base_url = \'https://api.openweathermap.org/data/2.5/weather\' params = {\'q\': city, \'appid\': api_key, \'units\': \'metric\'} try: response = requests.get(base_url, params=params) response.raise_for_status() data = response.json() weather_data = { \'temperature\': data[\'main\'][\'temp\'], \'description\': data[\'weather\'][0][\'description\'], \'humidity\': data[\'main\'][\'humidity\'], \'pressure\': data[\'main\'][\'pressure\'], \'wind_speed\': data[\'wind\'][\'speed\'] } except requests.exceptions.RequestException as e: print(f\\"An error occurred: {e}\\") weather_data = {} except KeyError: print(\\"An error occurred while parsing the API response.\\") weather_data = {} return weather_data"},{"question":"# Coding Assessment Question: Implementing a Custom Image Augmentation Function Context You are enhancing the data augmentation pipeline for training a convolutional neural network (CNN) on the CIFAR-10 dataset. To improve robustness and generalization, you decide to implement a custom augmentation function that randomly applies horizontal flips and contrast adjustments. Objective Write a Python function to implement a custom image augmentation that randomly applies horizontal flipping and contrast adjustments. Requirements 1. **Function Name**: `custom_image_augmentation` 2. **Input**: A numpy array `image` of shape (h, w, c) representing an RGB image. 3. **Output**: A numpy array of the same shape as the input, which has undergone random horizontal flipping and contrast adjustment. Constraints * Use numpy and the Python Imaging Library (PIL) for image adjustments. * The probability of applying a horizontal flip should be 50%. * Contrast adjustments should vary the contrast randomly by ±30%. Performance Requirements * Your function should run efficiently, considering typical image sizes in the CIFAR-10 dataset (32x32 pixels). Example ```python >>> import numpy as np >>> from PIL import Image >>> image = Image.fromarray(np.random.randint(0, 255, (32, 32, 3), dtype=np.uint8)) >>> augmented_image = custom_image_augmentation(np.array(image)) ``` Additional Task Integrate your custom image augmentation function into a data preprocessing pipeline for training a simple CNN on the CIFAR-10 dataset. The CNN should consist of: * An input layer matching the input shape of the CIFAR-10 images. * Two convolutional layers, each followed by max-pooling. * One fully connected layer followed by a softmax output layer for classification. Document your code and provide a short summary (not more than 200 words) explaining the potential benefits of custom augmentations in terms of overfitting and model generalization.","solution":"import numpy as np from PIL import Image, ImageEnhance import random def custom_image_augmentation(image): This function applies random horizontal flipping and contrast adjustment to an image. :param image: A numpy array of shape (h, w, c) representing an RGB image. :return: A numpy array of the same shape as the input after augmentation. pil_image = Image.fromarray(image) # Apply random horizontal flip if random.random() < 0.5: pil_image = pil_image.transpose(Image.FLIP_LEFT_RIGHT) # Apply random contrast adjustment enhancer = ImageEnhance.Contrast(pil_image) contrast_factor = 1 + (random.uniform(-0.3, 0.3)) pil_image = enhancer.enhance(contrast_factor) return np.array(pil_image)"},{"question":"# Coding Question: Rotated Matrix Search Your task is to write a function that searches for a specific value in a rotated 2D matrix. A rotated matrix is one that has all of its rows rotated by some number of places to the right. You will write a function, `search_in_rotated_matrix(matrix: List[List[int]], target: int) -> bool`, that will determine if the target integer is present in the matrix. Input: * The function will take a list of lists of integers `matrix`, where each inner list represents a row in the matrix. * The function will also take an integer `target`, representing the value to search for in the matrix. Output: * The function should return a boolean value `True` if the target is found, and `False` otherwise. Constraints: * The `matrix` can contain any integers. * Each row in the matrix is rotated independently. The matrix is not necessarily square. * The matrix can be empty or contain zero rows or zero columns. # Example: ```python def search_in_rotated_matrix(matrix: List[List[int]], target: int) -> bool: >>> search_in_rotated_matrix([[4, 5, 1, 2, 3], [7, 8, 9, 1, 2], [3, 6, 7, 8, 9]], 8) True >>> search_in_rotated_matrix([[4, 5, 1, 2, 3], [7, 8, 9, 1, 2], [3, 6, 7, 8, 9]], 10) False ``` # Notes: * Ensure that your function handles edge cases such as empty matrices or rows. * Optimize the search to be efficient and effective across various matrix sizes and configurations. * Assume the matrix contains no duplicate values across different rows.","solution":"from typing import List def search_in_rotated_matrix(matrix: List[List[int]], target: int) -> bool: Searches for a target value in a rotated 2D matrix. Args: matrix (List[List[int]]): The 2D matrix where each row is rotated. target (int): The target value to search for. Returns: bool: True if the target is found, otherwise False. for row in matrix: if target in row: return True return False"},{"question":"# Coding Challenge: Unique Ingredient List Merger You are developing a software for a recipe management service that helps users combine ingredients from various recipes into a unique ingredient list. Each recipe is represented as a list of ingredient names. Write a function that merges these lists into a single list of unique ingredient names, maintaining the order of their first occurrence. **Function Signature:** ```python def merge_ingredient_lists(recipes: List[List[str]]) -> List[str]: pass ``` **Input:** * A list of lists, `recipes`, where each inner list contains ingredient names as strings (`1 <= len(recipes) <= 10^3`, `1 <= len(recipes[i]) <= 10^3`). **Output:** * Return a single list containing unique ingredient names in the order of their first appearance across all recipe lists. **Constraints:** 1. Ingredient names consist only of lowercase letters and have a length of `1` to `20`. 2. The total number of ingredients across all recipes does not exceed `10^4`. **Example:** ```python >>> merge_ingredient_lists([ [\\"sugar\\", \\"flour\\", \\"eggs\\"], [\\"flour\\", \\"eggs\\", \\"butter\\"], [\\"sugar\\", \\"chocolate\\"] ]) [\'sugar\', \'flour\', \'eggs\', \'butter\', \'chocolate\'] >>> merge_ingredient_lists([ [\\"tomato\\", \\"cheese\\"], [\\"cheese\\", \\"basil\\"], [\\"tomato\\", \\"olive oil\\", \\"salt\\"] ]) [\'tomato\', \'cheese\', \'basil\', \'olive oil\', \'salt\'] >>> merge_ingredient_lists([ [\\"potato\\"], [\\"potato\\", \\"carrot\\", \\"peas\\"], [\\"onion\\", \\"peas\\"] ]) [\'potato\', \'carrot\', \'peas\', \'onion\'] ``` **Tips:** * Consider using a set to track seen ingredients and a list to maintain the order. * Iterate through each recipe and add ingredients to the unique list if they have not been previously added.","solution":"from typing import List def merge_ingredient_lists(recipes: List[List[str]]) -> List[str]: Merges multiple lists of ingredient names into a single list of unique names, maintaining the order of their first occurrence. seen = set() unique_ingredients = [] for recipe in recipes: for ingredient in recipe: if ingredient not in seen: seen.add(ingredient) unique_ingredients.append(ingredient) return unique_ingredients"},{"question":"# Problem Statement You are asked to write a function that will rotate a given matrix by 90 degrees clockwise. This operation involves re-arranging the elements within the matrix such that the rows of the original matrix become the columns in the rotated matrix, in reverse order. # Function Signature: ```python def rotate_matrix(matrix: list[list[int]]) -> list[list[int]]: ``` # Input: - `matrix` (list[list[int]]): A non-empty, square matrix (2D list) containing integers. All rows are of the same length, which is equal to the number of rows (i.e., it is an N x N matrix). # Output: - `list[list[int]]`: The resulting matrix after rotating the input matrix by 90 degrees clockwise. # Constraints: - The matrix will have dimensions N x N, where 1 <= N <= 1000. # Example: ```python >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[1, 2], [3, 4]]) [[3, 1], [4, 2]] ``` # Requirements: 1. Ensure your function rotates the matrix correctly without using extra space for another matrix of the same size (consider doing it in-place if possible). 2. Pay attention to the performance for large N x N matrices, keeping the implementation efficient in terms of both time and space complexity. 3. Consider edge cases such as the smallest possible matrix and varying integer values within the matrix. # Notes: - The rotated matrix should maintain the input matrix\'s configuration except for the rotation. - Optimized solutions that minimize additional space usage are encouraged. Good luck with your implementation!","solution":"def rotate_matrix(matrix): Rotates the given N x N matrix by 90 degrees clockwise. N = len(matrix) for layer in range(N // 2): first = layer last = N - layer - 1 for i in range(first, last): offset = i - first # save top top = matrix[first][i] # left -> top matrix[first][i] = matrix[last - offset][first] # bottom -> left matrix[last - offset][first] = matrix[last][last - offset] # right -> bottom matrix[last][last - offset] = matrix[i][last] # top -> right matrix[i][last] = top return matrix"},{"question":"# Problem Statement You are required to implement a function `find_mid_elements` that takes a list of integers and finds the two middle elements when the list is of even length, or the single middle element when the list is of odd length. If the list is empty, raise a `ValueError`. # Input - **numbers**: A list of integers which could be of any length. # Output - A list containing the middle element(s) based on the length of the input list. # Constraints - The length of the list `numbers` can range from 0 to 1000. - The elements of the list are within the range -1000 to 1000. # Examples ```python >>> find_mid_elements([1, 3, 5, 7]) [3, 5] >>> find_mid_elements([1, 3, 5]) [3] >>> find_mid_elements([1, 2, 3, 4, 5, 6]) [3, 4] >>> find_mid_elements([5]) [5] >>> find_mid_elements([]) # Raises ValueError: The list is empty ``` # Function Signature ```python def find_mid_elements(numbers: list) -> list: pass ``` # Context You are developing a feature for an application that provides detailed statistics based on a list of numbers. One crucial aspect is determining the central element(s), which helps in analyzing the core of the data distribution. This function will be an essential utility for such statistical calculations.","solution":"def find_mid_elements(numbers: list) -> list: Returns the middle element(s) of the input list. If the list is empty, raises a ValueError. If the length of the list is odd, returns a list with the single middle element. If the length of the list is even, returns a list with the two middle elements. if not numbers: raise ValueError(\\"The list is empty\\") length = len(numbers) mid_index = length // 2 if length % 2 == 0: return [numbers[mid_index - 1], numbers[mid_index]] else: return [numbers[mid_index]]"},{"question":"# Context: You are building an editing tool where users can perform text manipulations and transformations. One common operation users might want to do is toggling the casing of all alphabetic characters in a given string. # Problem Statement: Write a function `toggle_case(s: str) -> str` that takes a string and returns a new string with the case of all alphabetic characters inverted. Your implementation should: 1. Toggle uppercase alphabetical characters to lowercase. 2. Toggle lowercase alphabetical characters to uppercase. 3. Leave all non-alphabetic characters unchanged. # Input: * A string `s` (length <= 1000), which may contain uppercase letters, lowercase letters, digits, punctuation, and whitespace. # Output: * A string with the case of all alphabetic characters inverted. # Constraints: * You may assume the input will handle strings up to 1000 characters efficiently. # Examples: ```python >>> toggle_case(\\"Hello, World!\\") \\"hELLO, wORLD!\\" >>> toggle_case(\\"Python 3.8\\") \\"pYTHON 3.8\\" >>> toggle_case(\\"aBcDeF\\") \\"AbCdEf\\" ``` # Detailed Requirements: 1. Iterate through each character in the string. 2. For each character, if it is an uppercase alphabetic character, convert it to lowercase. 3. If it is a lowercase alphabetic character, convert it to uppercase. 4. Append each character to a result string (or use an equivalent data structure to build the result). 5. Return the final toggled case string.","solution":"def toggle_case(s: str) -> str: Toggles the case of all alphabetic characters in the string s. Args: s (str): The input string. Returns: str: A new string with the case of all alphabetic characters inverted. result = [] for char in s: if char.islower(): result.append(char.upper()) elif char.isupper(): result.append(char.lower()) else: result.append(char) return \'\'.join(result)"},{"question":"# Image Manipulation and Analysis Scenario You are tasked with creating a program that automates image manipulation and analyzes pixel data. This task will help demonstrate your understanding of working with image data and basic image processing using Python. Problem Statement Implement the function `process_image` that takes the path to an image file as input, converts the image to grayscale, resizes it to 100x100 pixels, and returns the mean pixel intensity of the resulting image. Function Signature ```python def process_image(image_path: str) -> float: pass ``` Input - `image_path`: A string representing the path to the image file. Output - A float representing the mean pixel intensity of the 100x100 grayscale image. Constraints - The function should handle common image file formats such as JPEG, PNG, and BMP. - You must handle exceptions for invalid file paths or unsupported image formats. - Use appropriate libraries to read, manipulate, and analyze the image data. Example ```python mean_intensity = process_image(\\"sample_image.jpg\\") print(mean_intensity) ``` This should print the mean pixel intensity of the 100x100 grayscale version of the image \\"sample_image.jpg\\". Tips - Use the `PIL` (Pillow) library to handle image reading, resizing, and conversion to grayscale. - Use numpy to calculate the mean pixel intensity. - Remember to handle exceptions gracefully for cases such as file not found or read errors.","solution":"from PIL import Image import numpy as np def process_image(image_path: str) -> float: try: # Open the image file with Image.open(image_path) as img: # Convert the image to grayscale grayscale_img = img.convert(\\"L\\") # Resize the image to 100x100 pixels resized_img = grayscale_img.resize((100, 100)) # Convert the image to a numpy array img_array = np.array(resized_img) # Calculate the mean pixel intensity mean_intensity = img_array.mean() return mean_intensity except Exception as e: print(f\\"An error occurred: {e}\\") return None"},{"question":"# Problem Statement You are tasked with writing a function that calculates the total resistance of a specific circuit configuration. # Detailed Description The total resistance, (R_t), of two resistors (R_1) and (R_2) connected in series and parallel follows these rules: - In a series circuit, the total resistance is simply the sum of the individual resistances: [ R_t(series) = R_1 + R_2 ] - In a parallel circuit, the total resistance is given by: [ frac{1}{R_t(parallel)} = frac{1}{R_1} + frac{1}{R_2} ] Simplifying, we get: [ R_t(parallel) = frac{R_1 cdot R_2}{R_1 + R_2} ] Input: * `resistor1` (float): The resistance value of the first resistor in ohms, which is a non-negative number. * `resistor2` (float): The resistance value of the second resistor in ohms, which is a non-negative number. * `connection_type` (str): A string that indicates the type of connection. It can either be `\\"series\\"` or `\\"parallel\\"`. Output: * A float indicating the total resistance of the circuit in ohms, rounded to 2 decimal places. Constraints: * Both resistances must be non-negative floats. * The connection type must either be `\\"series\\"` or `\\"parallel\\"`. # Example: ```python def total_resistance(resistor1: float, resistor2: float, connection_type: str) -> float: >>> round(total_resistance(10, 20, \\"series\\"), 2) 30.00 >>> round(total_resistance(10, 20, \\"parallel\\"), 2) 6.67 >>> round(total_resistance(0, 20, \\"series\\"), 2) 20.00 >>> round(total_resistance(0, 20, \\"parallel\\"), 2) 0.00 >>> round(total_resistance(10, -5, \\"series\\"), 2) Traceback (most recent call last): ... ValueError: Resistance values must be non-negative >>> round(total_resistance(10, 20, \\"series-parallel\\"), 2) Traceback (most recent call last): ... ValueError: Connection type must be either \'series\' or \'parallel\' if resistor1 < 0 or resistor2 < 0: raise ValueError(\\"Resistance values must be non-negative\\") if connection_type not in [\\"series\\", \\"parallel\\"]: raise ValueError(\\"Connection type must be either \'series\' or \'parallel\'\\") if connection_type == \\"series\\": return round(resistor1 + resistor2, 2) elif connection_type == \\"parallel\\": if resistor1 == 0 or resistor2 == 0: return 0.00 return round((resistor1 * resistor2) / (resistor1 + resistor2), 2) ``` # Task: Implement the `total_resistance` function which takes `resistor1`, `resistor2`, and `connection_type` as input arguments and returns the total resistance of the circuit as per the connection type specified.","solution":"def total_resistance(resistor1: float, resistor2: float, connection_type: str) -> float: Calculate the total resistance of two resistors based on their connection type. :param resistor1: Resistance of the first resistor in ohms (must be non-negative). :param resistor2: Resistance of the second resistor in ohms (must be non-negative). :param connection_type: Type of connection (\\"series\\" or \\"parallel\\"). :return: Total resistance of the circuit in ohms, rounded to 2 decimal places. if resistor1 < 0 or resistor2 < 0: raise ValueError(\\"Resistance values must be non-negative\\") if connection_type not in [\\"series\\", \\"parallel\\"]: raise ValueError(\\"Connection type must be either \'series\' or \'parallel\'\\") if connection_type == \\"series\\": return round(resistor1 + resistor2, 2) elif connection_type == \\"parallel\\": if resistor1 == 0 or resistor2 == 0: return 0.00 return round((resistor1 * resistor2) / (resistor1 + resistor2), 2)"},{"question":"# Text File Compression Task Your task is to implement a text file compression utility based on Huffman Coding. Extend the provided framework to read a text file, create a Huffman tree and generate the compressed binary output. Objectives: 1. **Huffman Tree Construction**: - Read textual data from a file. - Calculate the frequency of each character and build a Huffman Tree based on these frequencies. - Generate a Huffman Code for each character. 2. **Compression and Decompression**: - Implement functions to compress the text content into a binary format using the generated Huffman Codes. - Implement functions to decompress the binary format back to the original text using the Huffman Tree. 3. **Implementation Requirements**: - Implement a class **HuffmanNode** to represent tree nodes. - Implement a **HuffmanCoding** class to handle file reading, tree building, encoding, and decoding. - Ensure your code can handle standard ASCII characters. 4. **Input and Output Formats**: - **Input**: * Path to a text file containing data to compress. - **Output**: * Compressed binary file. * Decompressed text file that matches the original content. 5. **Data Constraints**: - The text file size ≤ 1 MB - The text file contains only printable ASCII characters (code points 32-126). 6. **Performance Requirement**: - Your implementation should efficiently compress and decompress text files up to the specified size within a reasonable time frame (few seconds). Context: You are developing a file compression utility to reduce disk space usage. Extend the basic functionality to read a text file, compress its content based on Huffman Coding, and then decompress it back to ensure data integrity. Example Usage: ```python # HuffmanNode class class HuffmanNode: def __init__(self, freq, char=None, left=None, right=None): self.char = char self.freq = freq self.left = left self.right = right # HuffmanCoding class class HuffmanCoding: def __init__(self): self.heap = [] self.codes = {} self.reverse_mapping = {} def build_frequency_dict(self, text): frequency = {} for char in text: if not char in frequency: frequency[char] = 0 frequency[char] += 1 return frequency def build_heap(self, frequency): for key in frequency: node = HuffmanNode(frequency[key], key) heapq.heappush(self.heap, node) def merge_nodes(self): while len(self.heap) > 1: node1 = heapq.heappop(self.heap) node2 = heapq.heappop(self.heap) merged = HuffmanNode(node1.freq + node2.freq, left=node1, right=node2) heapq.heappush(self.heap, merged) def make_codes_helper(self, root, current_code): if root is None: return if root.char is not None: self.codes[root.char] = current_code self.reverse_mapping[current_code] = root.char return self.make_codes_helper(root.left, current_code + \\"0\\") self.make_codes_helper(root.right, current_code + \\"1\\") def make_codes(self): root = heapq.heappop(self.heap) current_code = \\"\\" self.make_codes_helper(root, current_code) def get_encoded_text(self, text): encoded_text = \\"\\" for char in text: encoded_text += self.codes[char] return encoded_text def compress(self, file_path): with open(file_path, \'r\') as file: text = file.read() frequency = self.build_frequency_dict(text) self.build_heap(frequency) self.merge_nodes() self.make_codes() encoded_text = self.get_encoded_text(text) output_path = file_path.replace(\\".txt\\", \\".bin\\") with open(output_path, \'wb\') as output: binary_format = bytearray() for i in range(0, len(encoded_text), 8): byte = encoded_text[i:i+8] binary_format.append(int(byte, 2)) output.write(binary_format) return output_path def decompress(self, file_path): compressed_file_path = file_path.replace(\\".txt\\", \\".bin\\") with open(compressed_file_path, \'rb\') as file: bit_string = \\"\\" byte = file.read(1) while byte: byte = ord(byte) # oooooooo bits = bin(byte)[2:].rjust(8, \'0\') bit_string += bits byte = file.read(1) encoded_text = bit_string current_code = \\"\\" decoded_text = \\"\\" for bit in encoded_text: current_code += bit if current_code in self.reverse_mapping: character = self.reverse_mapping[current_code] decoded_text += character current_code = \\"\\" decompressed_file_path = file_path.replace(\\".txt\\", \\"_decompressed.txt\\") with open(decompressed_file_path, \'w\') as output: output.write(decoded_text) return decompressed_file_path import heapq # Example execution of compression and decompression. huffman = HuffmanCoding() compressed_file = huffman.compress(\\"example.txt\\") decompressed_file = huffman.decompress(\\"example.txt\\") print(f\'Compressed File Path: {compressed_file}\') print(f\'Decompressed File Path: {decompressed_file}\') ``` Make sure to test your functions for various text inputs to ensure correctness.","solution":"import heapq class HuffmanNode: def __init__(self, freq, char=None, left=None, right=None): self.char = char self.freq = freq self.left = left self.right = right def __lt__(self, other): return self.freq < other.freq class HuffmanCoding: def __init__(self): self.heap = [] self.codes = {} self.reverse_mapping = {} def build_frequency_dict(self, text): frequency = {} for char in text: if char not in frequency: frequency[char] = 0 frequency[char] += 1 return frequency def build_heap(self, frequency): for key in frequency: node = HuffmanNode(frequency[key], key) heapq.heappush(self.heap, node) def merge_nodes(self): while len(self.heap) > 1: node1 = heapq.heappop(self.heap) node2 = heapq.heappop(self.heap) merged = HuffmanNode(node1.freq + node2.freq, left=node1, right=node2) heapq.heappush(self.heap, merged) def make_codes_helper(self, root, current_code): if root is None: return if root.char is not None: self.codes[root.char] = current_code self.reverse_mapping[current_code] = root.char return self.make_codes_helper(root.left, current_code + \\"0\\") self.make_codes_helper(root.right, current_code + \\"1\\") def make_codes(self): root = heapq.heappop(self.heap) current_code = \\"\\" self.make_codes_helper(root, current_code) def get_encoded_text(self, text): encoded_text = \\"\\" for char in text: encoded_text += self.codes[char] return encoded_text def compress(self, input_text): frequency = self.build_frequency_dict(input_text) self.build_heap(frequency) self.merge_nodes() self.make_codes() encoded_text = self.get_encoded_text(input_text) padding = 8 - len(encoded_text) % 8 encoded_text = f\\"{padding:08b}\\" + \'0\' * padding + encoded_text binary_format = bytearray() for i in range(0, len(encoded_text), 8): byte = encoded_text[i:i + 8] binary_format.append(int(byte, 2)) return binary_format def decompress(self, binary_format): padded_info = format(binary_format[0], \'08b\') padding = int(padded_info, 2) bit_string = \\"\\" for byte in binary_format[1:]: byte = format(byte, \'08b\') bit_string += byte encoded_text = bit_string[padding:] current_code = \\"\\" decoded_text = \\"\\" for bit in encoded_text: current_code += bit if current_code in self.reverse_mapping: character = self.reverse_mapping[current_code] decoded_text += character current_code = \\"\\" return decoded_text"},{"question":"# Coding Question: Distribute Candies Evenly Background You are given a certain number of candies and a group of children. Your goal is to distribute the candies as evenly as possible among the children such that the difference between the child with the most candies and the child with the least candies is minimized. Objective Write a function `distribute_candies(candies: int, children: int) -> list` that returns a list representing how many candies each child gets. The length of the list should be equal to the number of children, and the sum of the list should equal the total number of candies. Input * An integer representing the total number of candies. * An integer representing the number of children. Output * Return a list of integers representing the distribution of candies among the children. Constraints * candies is a non-negative integer. * children is a positive integer. Example ```python >>> distribute_candies(10, 3) [3, 3, 4] >>> distribute_candies(7, 4) [1, 2, 2, 2] ``` Notes * The function should ensure that the difference between the number of candies any two children get is at most 1. * Consider edge cases where: * There are zero candies to distribute. * There is only one child. * Distribute the excess candies starting from the first child if there is a remainder when dividing candies by the number of children. Edge Cases * If candies is zero, return a list of zeros of length `children`. * If children is one, return a list containing the number of candies. Validation Ensure your solution runs efficiently for a large number of candies and children (up to 10^6).","solution":"def distribute_candies(candies: int, children: int) -> list: Distributes the candies as evenly as possible among the children. Parameters: - candies: int, the total number of candies. - children: int, the number of children. Returns: - list of int, representing the number of candies each child gets. base_candies = candies // children extra_candies = candies % children distribution = [base_candies] * children for i in range(extra_candies): distribution[i] += 1 return distribution"},{"question":"# Question: Implement a Basic Recommender System Context You have been given a dataset representing user ratings for a selection of movies. Your task is to create a basic item-based collaborative filtering recommender system. This system will recommend movies to users based on the movies they have already rated and how similar those movies are to others in the dataset. Task Implement a function `train_recommender(user_item_matrix)` that establishes similarities between items (movies) based on user ratings, and another function `recommend_movies(user_id, top_n)` that recommends the top `n` movies for a given user based on these similarities. Classes and Methods 1. **RecommenderSystem** - **Constructor**: - `__init__(self, user_item_matrix: np.ndarray) -> None`: Initializes the system with a user-item ratings matrix. - **Similarity Matrix**: - `_calculate_similarity_matrix() -> np.ndarray`: Computes the cosine similarity between all pairs of items. - **Fit Model**: - `fit(self) -> None`: Fits the recommender system by calculating item similarities. - **Recommend Movies**: - `recommend(self, user_id: int, top_n: int) -> List[int]`: Recommends the top `n` movies for the given user based on the calculated item similarities. Input and Output Format - **Function: `train_recommender`** - **Input**: - `user_item_matrix`: 2D `np.ndarray` where rows represent users and columns represent items (movies), with values indicating ratings. - **Output**: - Returns an instance of `RecommenderSystem` fitted to the user-item matrix. - **Function: `recommend_movies`** - **Input**: - `model`: Instance of `RecommenderSystem` class. - `user_id`: Integer representing the user we want to recommend movies to. - `top_n`: Integer representing the number of top recommendations to provide. - **Output**: - Returns a list of `top_n` recommended movie indices for the given user. Example Usage ```python import numpy as np def train_recommender(user_item_matrix): model = RecommenderSystem(user_item_matrix) model.fit() return model def recommend_movies(model, user_id, top_n): return model.recommend(user_id, top_n) # Example Data user_item_matrix = np.array([ [5, 3, 0, 0], [4, 0, 0, 2], [1, 1, 0, 4], [0, 0, 5, 4], [2, 0, 4, 0] ]) # Fit model model = train_recommender(user_item_matrix) # Recommendations for user with ID 1 top_movies = recommend_movies(model, 1, 2) print(top_movies) # Output: List of top 2 recommended movie indices for user ID 1 ``` Constraints - Ensure the `user_item_matrix` is a 2D numpy array. - `user_id` must be a valid index within the rows of the `user_item_matrix`. - `top_n` must be a positive integer.","solution":"import numpy as np from sklearn.metrics.pairwise import cosine_similarity class RecommenderSystem: def __init__(self, user_item_matrix: np.ndarray) -> None: self.user_item_matrix = user_item_matrix self.item_similarity_matrix = None def _calculate_similarity_matrix(self) -> np.ndarray: # Compute cosine similarity between columns (items) self.item_similarity_matrix = cosine_similarity(self.user_item_matrix.T) return self.item_similarity_matrix def fit(self) -> None: self._calculate_similarity_matrix() def recommend(self, user_id: int, top_n: int) -> list: user_ratings = self.user_item_matrix[user_id, :] user_prediction_scores = user_ratings @ self.item_similarity_matrix recommended_items_indices = np.argsort(user_prediction_scores)[::-1] # Filter out the items already rated by the user unrated_items_indices = [i for i in recommended_items_indices if user_ratings[i] == 0] return unrated_items_indices[:top_n] def train_recommender(user_item_matrix): model = RecommenderSystem(user_item_matrix) model.fit() return model def recommend_movies(model, user_id, top_n): return model.recommend(user_id, top_n)"},{"question":"# Coding Assessment Question: Spiral Order of a 2D Matrix Context You are developing a feature that analyzes structured data represented as 2D matrices. As part of this analysis, you need to traverse these matrices in a specific order to extract insights. Task Write a function `spiral_order(matrix: list[list[int]]) -> list[int]` that takes a 2D array (a list of lists) and returns a list of its elements in spiral order, starting from the top-left corner and moving right, then down, then left, and then up, repeating until all elements are covered. Specifications * `spiral_order(matrix: list[list[int]]) -> list[int]` * **Input**: * `matrix`: A 2D array represented as a list of lists of integers. * **Output**: * A 1D list containing all elements of the 2D array in spiral order. Constraints * All rows in the input 2D array have the same number of columns. * The input 2D matrix is non-empty. Examples * Example 1: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] result = spiral_order(matrix) assert result == [1, 2, 3, 6, 9, 8, 7, 4, 5] ``` * Example 2: ```python matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] result = spiral_order(matrix) assert result == [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] ``` * Example 3: ```python matrix = [ [1] ] result = spiral_order(matrix) assert result == [1] ``` Notes * Ensure robustness by handling all edge cases such as single-row or single-column matrices gracefully.","solution":"def spiral_order(matrix): result = [] while matrix: # append the first row result += matrix.pop(0) # append the last element of each remaining row if matrix and matrix[0]: for row in matrix: result.append(row.pop()) # append the last row in reverse if matrix: result += matrix.pop()[::-1] # append the first element of each remaining row in reverse if matrix and matrix[0]: for row in matrix[::-1]: result.append(row.pop(0)) return result"},{"question":"# Coding Assessment: Enhance and Refactor String Parsing Function Context You have learned about string manipulation and parsing techniques commonly used in software development and data processing. You are provided with a function that parses a string and extracts useful information based on a specific format. Your task is to improve this function to handle edge cases, provide input validation, and refactor the code for better readability and maintainability. Problem Statement Enhance the function `parse_employee_data` to handle edge cases, validate inputs, and refactor the code to improve clarity and efficiency. Function to Be Enhanced ```python def parse_employee_data(data: str) -> dict: Parses a string containing employee information and returns a dictionary. The input string is expected to be in the format: \\"Name: {name}, Age: {age}, Department: {department}\\" >>> parse_employee_data(\\"Name: John Doe, Age: 30, Department: HR\\") {\'name\': \'John Doe\', \'age\': 30, \'department\': \'HR\'} >>> parse_employee_data(\\"Name: Jane Smith, Age: 25, Department: Engineering\\") {\'name\': \'Jane Smith\', \'age\': 25, \'department\': \'Engineering\'} parts = data.split(\',\') return { \'name\': parts[0].split(\':\')[1].strip(), \'age\': int(parts[1].split(\':\')[1].strip()), \'department\': parts[2].split(\':\')[1].strip() } ``` Requirements 1. **Input Validation**: - Ensure the input string matches the expected format. - Raise a `ValueError` with an appropriate message for invalid inputs. 2. **Edge Case Handling**: - Handle missing fields and ensure all three fields (Name, Age, Department) are present. - Validate and handle non-integer age values appropriately by raising a `ValueError`. 3. **Code Refactor**: - Improve code readability by breaking down the parsing logic into smaller helper functions. - Update the docstring for better clarity. Input/Output Format * **Input**: - `data`: A string in the format \\"Name: {name}, Age: {age}, Department: {department}\\". * **Output**: - A dictionary containing the keys: \'name\', \'age\', and \'department\' with appropriate parsed values. Constraints 1. The input string must follow the specified format. 2. Age must be a positive integer. 3. Each field must be present in the string. Example ```python try: print(parse_employee_data(\\"Name: John Doe, Age: 30, Department: HR\\")) # Outputs: {\'name\': \'John Doe\', \'age\': 30, \'department\': \'HR\'} print(parse_employee_data(\\"Name: Jane Smith, Age: 25, Department: Engineering\\")) # Outputs: {\'name\': \'Jane Smith\', \'age\': 25, \'department\': \'Engineering\'} print(parse_employee_data(\\"Name: Mark, Age: twenty, Department: R&D\\")) # Raises ValueError except ValueError as ve: print(f\\"ValueError: {ve}\\") ``` Updated Function Implementation ```python def parse_employee_data(data: str) -> dict: Parses a string containing employee information and returns a dictionary. The input string is expected to be in the format: \\"Name: {name}, Age: {age}, Department: {department}\\" :param data: str, input string containing employee information :return: dict, parsed employee information Raises ValueError for invalid input format or missing fields. Examples: >>> parse_employee_data(\\"Name: John Doe, Age: 30, Department: HR\\") {\'name\': \'John Doe\', \'age\': 30, \'department\': \'HR\'} >>> parse_employee_data(\\"Name: Jane Smith, Age: 25, Department: Engineering\\") {\'name\': \'Jane Smith\', \'age\': 25, \'department\': \'Engineering\'} def extract_field(field: str) -> str: try: return field.split(\':\')[1].strip() except IndexError: raise ValueError(\\"Invalid format in field extraction\\") fields = data.split(\',\') if len(fields) != 3: raise ValueError(\\"Input must include Name, Age, and Department\\") name = extract_field(fields[0]) age = extract_field(fields[1]) department = extract_field(fields[2]) if not age.isdigit(): raise ValueError(\\"Age must be a positive integer\\") return { \'name\': name, \'age\': int(age), \'department\': department } ```","solution":"def parse_employee_data(data: str) -> dict: Parses a string containing employee information and returns a dictionary. The input string is expected to be in the format: \\"Name: {name}, Age: {age}, Department: {department}\\" :param data: str, input string containing employee information :return: dict, parsed employee information Raises ValueError for invalid input format or missing fields. Examples: >>> parse_employee_data(\\"Name: John Doe, Age: 30, Department: HR\\") {\'name\': \'John Doe\', \'age\': 30, \'department\': \'HR\'} >>> parse_employee_data(\\"Name: Jane Smith, Age: 25, Department: Engineering\\") {\'name\': \'Jane Smith\', \'age\': 25, \'department\': \'Engineering\'} def extract_field(field: str) -> str: try: return field.split(\':\')[1].strip() except IndexError: raise ValueError(\\"Invalid format in field extraction\\") fields = data.split(\',\') if len(fields) != 3: raise ValueError(\\"Input must include Name, Age, and Department\\") name = extract_field(fields[0]) age = extract_field(fields[1]) department = extract_field(fields[2]) if not age.isdigit(): raise ValueError(\\"Age must be a positive integer\\") return { \'name\': name, \'age\': int(age), \'department\': department }"},{"question":"# Coding Assessment Question **Objective**: Implement a function to perform matrix multiplication using Strassen\'s algorithm. **Scenario**: You are tasked with implementing a matrix multiplication function using Strassen\'s algorithm within a class called `StrassenMatrixMultiplier`. Strassen\'s algorithm is an optimized matrix multiplication algorithm that reduces the complexity from (O(n^3)) to approximately (O(n^{2.81})). **Algorithm Overview**: Strassen\'s algorithm divides each of the matrices into four sub-matrices. Suppose (A) and (B) are the input matrices, each of size (2^k times 2^k). The matrices (A) and (B) are divided into smaller sub-matrices as follows: [ A = begin{bmatrix} A_{11} & A_{12} A_{21} & A_{22} end{bmatrix} quad and quad B = begin{bmatrix} B_{11} & B_{12} B_{21} & B_{22} end{bmatrix} ] Strassen\'s algorithm computes the product of two matrices using the following steps: 1. Compute the seven products: - (M_1 = (A_{11} + A_{22})(B_{11} + B_{22})) - (M_2 = (A_{21} + A_{22})B_{11}) - (M_3 = A_{11}(B_{12} - B_{22})) - (M_4 = A_{22}(B_{21} - B_{11})) - (M_5 = (A_{11} + A_{12})B_{22}) - (M_6 = (A_{21} - A_{11})(B_{11} + B_{12})) - (M_7 = (A_{12} - A_{22})(B_{21} + B_{22})) 2. Compute the resulting sub-matrices: - (C_{11} = M_1 + M_4 - M_5 + M_7) - (C_{12} = M_3 + M_5) - (C_{21} = M_2 + M_4) - (C_{22} = M_1 - M_2 + M_3 + M_6) 3. Combine the sub-matrices into a single result matrix (C). **Task**: - Implement the `strassen_multiply` method within the `StrassenMatrixMultiplier` class. - Ensure that input matrices (A) and (B) are square matrices of size (2^k times 2^k). - Implement recursive division for matrix sizes greater than (2 times 2). **Constraints**: - Input matrices (A) and (B) will always be square and their sizes will be powers of 2. - Use the specified formula directly to compute the product matrices using Strassen\'s algorithm. **Expected Behavior**: - If the matrices are not of the same dimension, raise a `ValueError` stating \\"Matrices must have the same dimensions.\\" - Ensure that all calculations are done within the constraints of the algorithm\'s structure and recursion depth. **Function Signature**: ```python def strassen_multiply(self, A: np.ndarray, B: np.ndarray) -> np.ndarray: pass ``` **Examples**: ```python >>> import numpy as np >>> A = np.array([[1, 2], [3, 4]]) >>> B = np.array([[5, 6], [7, 8]]) >>> C = StrassenMatrixMultiplier().strassen_multiply(A, B) >>> C.tolist() [[19, 22], [43, 50]] >>> A = np.array([[2, 3], [4, 1]]) >>> B = np.array([[1, 0], [0, 1]]) >>> C = StrassenMatrixMultiplier().strassen_multiply(A, B) >>> C.tolist() [[2, 3], [4, 1]] ```","solution":"import numpy as np class StrassenMatrixMultiplier: def strassen_multiply(self, A: np.ndarray, B: np.ndarray) -> np.ndarray: if A.shape != B.shape: raise ValueError(\\"Matrices must have the same dimensions.\\") n = A.shape[0] if n == 1: return A * B elif n % 2 != 0: raise ValueError(\\"Matrix dimensions must be a power of 2.\\") # Divide the matrices into sub-matrices mid = n // 2 A11, A12, A21, A22 = A[:mid, :mid], A[:mid, mid:], A[mid:, :mid], A[mid:, mid:] B11, B12, B21, B22 = B[:mid, :mid], B[:mid, mid:], B[mid:, :mid], B[mid:, mid:] # Compute the seven products M1 = self.strassen_multiply(A11 + A22, B11 + B22) M2 = self.strassen_multiply(A21 + A22, B11) M3 = self.strassen_multiply(A11, B12 - B22) M4 = self.strassen_multiply(A22, B21 - B11) M5 = self.strassen_multiply(A11 + A12, B22) M6 = self.strassen_multiply(A21 - A11, B11 + B12) M7 = self.strassen_multiply(A12 - A22, B21 + B22) # Compute the resulting sub-matrices C11 = M1 + M4 - M5 + M7 C12 = M3 + M5 C21 = M2 + M4 C22 = M1 - M2 + M3 + M6 # Combine the sub-matrices into a single result matrix C = np.vstack(( np.hstack((C11, C12)), np.hstack((C21, C22)) )) return C"},{"question":"# Question: Design a function `find_shortest_path` that determines the shortest path between two nodes in an unweighted, undirected graph. The function should return the path as a list of nodes. **Function Signature**: ```python def find_shortest_path(graph: Dict[int, List[int]], start: int, goal: int) -> List[int]: # implement the function ``` # Requirements: 1. **Input Format**: - `graph`: A dictionary where the keys are node integers, and the values are lists of adjacent node integers. - `start`: An integer representing the starting node. - `goal`: An integer representing the goal node. 2. **Output Format**: - A list of integers representing the nodes in the shortest path from `start` to `goal`. # Constraints: - The number of nodes in the graph will be in the range `1` to `10^5`. - It is guaranteed that there is at least one path between `start` and `goal`. # Performance Requirements: - The algorithm should run efficiently for large input sizes, ideally using a Breadth-First Search (BFS) approach for optimal performance. # Example: ```python graph = { 0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2, 4], 4: [3] } shortest_path = find_shortest_path(graph, 0, 4) print(shortest_path) # Output: [0, 1, 3, 4] or [0, 2, 3, 4] ``` # Function Behavior: 1. Use BFS to explore the graph from the `start` node. 2. Track the path taken to reach each node and stop when the `goal` node is reached. 3. Construct and return the path from `start` to `goal`. # Additional Notes: - Ensure to handle large graphs efficiently without hitting performance bottlenecks. - Consider edge cases where the start and goal nodes are the same. # Hints: * Use a queue to implement the BFS efficiently. * Maintain a dictionary to backtrack and construct the shortest path once the goal is reached.","solution":"from collections import deque from typing import Dict, List def find_shortest_path(graph: Dict[int, List[int]], start: int, goal: int) -> List[int]: Determines the shortest path between two nodes in an unweighted, undirected graph. The function returns the path as a list of nodes. :param graph: Dictionary representing the adjacency list of the graph. :param start: Starting node. :param goal: Goal node. :return: List of nodes in the shortest path from start to goal. if start == goal: return [start] queue = deque([start]) came_from = {start: None} while queue: current = queue.popleft() if current == goal: break for neighbor in graph[current]: if neighbor not in came_from: queue.append(neighbor) came_from[neighbor] = current path = [] cur_node = goal while cur_node is not None: path.append(cur_node) cur_node = came_from[cur_node] path.reverse() return path"},{"question":"# Minimum Edit Distance Question You are given two words `word1` and `word2`. Your task is to calculate the minimum number of operations required to convert `word1` into `word2`. You can perform the following three operations: 1. Insert a character, 2. Delete a character, or 3. Replace a character. # Function Signature ```python def min_distance(word1: str, word2: str) -> int: ``` # Input - `word1` (str): A string consisting of lowercase English letters (1 ≤ `len(word1)` ≤ 500) - `word2` (str): A string consisting of lowercase English letters (1 ≤ `len(word2)` ≤ 500) # Output - Returns (int): The minimum number of operations required to convert `word1` into `word2`. # Constraints - All characters in the strings are lowercase English letters. # Example ```python def test_min_distance(): assert min_distance(\\"horse\\", \\"ros\\") == 3 assert min_distance(\\"intention\\", \\"execution\\") == 5 assert min_distance(\\"abc\\", \\"yabd\\") == 2 assert min_distance(\\"abcd\\", \\"abcd\\") == 0 assert min_distance(\\"\\", \\"a\\") == 1 test_min_distance() ``` # Description 1. Implement the `min_distance` function to take in two words and return the minimum number of operations required to convert the first word into the second. 2. Use a dynamic programming approach where you track the minimum edit distance for all prefixes of the two words in a 2D table. 3. Include appropriate checks to handle errors and edge cases. # Hint Use a matrix where `dp[i][j]` represents the minimum edit distance between the first `i` characters of `word1` and the first `j` characters of `word2`. Start with base cases where either string is empty, and build up the solution from there. The time complexity should be O(m * n), where `m` and `n` are the lengths of `word1` and `word2`, respectively.","solution":"def min_distance(word1: str, word2: str) -> int: Calculate the minimum number of operations required to convert word1 into word2. Args: word1: A string consisting of lowercase English letters word2: A string consisting of lowercase English letters Returns: int: The minimum number of operations required to convert word1 into word2. m, n = len(word1), len(word2) # Create a table to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the table for the base cases for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Fill the table using the recurrence relation for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Delete dp[i][j - 1], # Insert dp[i - 1][j - 1] # Replace ) return dp[m][n]"},{"question":"# Problem Statement: You have been tasked with creating a system to manage the to-do lists of multiple users. Each user can have multiple to-do lists, and each list can have multiple tasks. Each task is defined by a title, description, priority (low, medium, high), and due date. You are to implement a class `ToDoManager` with the following capabilities: 1. Add a user. 2. Create a new to-do list for a user. 3. Add a task to a user\'s to-do list. 4. Delete a task from a user\'s to-do list. 5. Retrieve all tasks from a user\'s to-do list based on due date ordering or priority ordering. Implement the `ToDoManager` class with the following methods: ```python class ToDoManager: def __init__(self): Initializes the ToDoManager with an empty dictionary for managing users and their to-do lists. pass def add_user(self, username: str) -> None: Adds a new user to the system. :param username: The name of the user to add. pass def create_todo_list(self, username: str, list_name: str) -> None: Creates a new to-do list for an existing user. :param username: The name of the user. :param list_name: The name of the to-do list to create. pass def add_task(self, username: str, list_name: str, title: str, description: str, priority: str, due_date: str) -> None: Adds a new task to the specified user\'s to-do list. :param username: The name of the user. :param list_name: The name of the to-do list. :param title: The title of the task. :param description: The description of the task. :param priority: The priority of the task (\'low\', \'medium\', \'high\'). :param due_date: The due date of the task (in \'YYYY-MM-DD\' format). pass def delete_task(self, username: str, list_name: str, title: str) -> bool: Deletes a task from the specified user\'s to-do list. :param username: The name of the user. :param list_name: The name of the to-do list. :param title: The title of the task to delete. :return: True if the task was successfully deleted, False otherwise. pass def get_tasks(self, username: str, list_name: str, order_by: str = \\"due_date\\") -> list: Retrieves all tasks from a user\'s to-do list, ordered by either due date or priority. :param username: The name of the user. :param list_name: The name of the to-do list. :param order_by: The criteria to order the tasks by (\'due_date\' or \'priority\'). :return: A list of tasks sorted based on the specified ordering criteria. pass ``` Constraints * The priority can only be \'low\', \'medium\', or \'high\'. * The due date should be in the format \'YYYY-MM-DD\'. * Each task should have a unique title within a given to-do list. * Handle cases where users or lists may not exist gracefully, by appropriately logging errors but not crashing. * The lists and tasks should be stored in-memory, i.e., usage of external databases is not allowed. Example Usage: ```python manager = ToDoManager() manager.add_user(\\"john_doe\\") manager.create_todo_list(\\"john_doe\\", \\"work_tasks\\") manager.add_task(\\"john_doe\\", \\"work_tasks\\", \\"Finish report\\", \\"Complete the annual report\\", \\"high\\", \\"2023-11-01\\") manager.add_task(\\"john_doe\\", \\"work_tasks\\", \\"Meeting with team\\", \\"Monthly team meeting\\", \\"medium\\", \\"2023-10-20\\") tasks_by_due_date = manager.get_tasks(\\"john_doe\\", \\"work_tasks\\", order_by=\\"due_date\\") tasks_by_priority = manager.get_tasks(\\"john_doe\\", \\"work_tasks\\", order_by=\\"priority\\") manager.delete_task(\\"john_doe\\", \\"work_tasks\\", \\"Finish report\\") ``` In this example, the `tasks_by_due_date` list might return the tasks ordered by their due dates, whereas the `tasks_by_priority` list might return them ordered by priority.","solution":"from datetime import datetime class ToDoManager: def __init__(self): Initializes the ToDoManager with an empty dictionary for managing users and their to-do lists. self.users = {} def add_user(self, username: str) -> None: Adds a new user to the system. if username not in self.users: self.users[username] = {} def create_todo_list(self, username: str, list_name: str) -> None: Creates a new to-do list for an existing user. if username in self.users: if list_name not in self.users[username]: self.users[username][list_name] = [] def add_task(self, username: str, list_name: str, title: str, description: str, priority: str, due_date: str) -> None: Adds a new task to the specified user\'s to-do list. if username in self.users and list_name in self.users[username]: task = { \\"title\\": title, \\"description\\": description, \\"priority\\": priority, \\"due_date\\": due_date } self.users[username][list_name].append(task) def delete_task(self, username: str, list_name: str, title: str) -> bool: Deletes a task from the specified user\'s to-do list. :return: True if the task was successfully deleted, False otherwise. if username in self.users and list_name in self.users[username]: tasks = self.users[username][list_name] for task in tasks: if task[\\"title\\"] == title: tasks.remove(task) return True return False def get_tasks(self, username: str, list_name: str, order_by: str = \\"due_date\\") -> list: Retrieves all tasks from a user\'s to-do list, ordered by either due date or priority. if username in self.users and list_name in self.users[username]: tasks = self.users[username][list_name] if order_by == \\"due_date\\": tasks_sorted = sorted(tasks, key=lambda x: datetime.strptime(x[\\"due_date\\"], \'%Y-%m-%d\')) elif order_by == \\"priority\\": priority_order = {\\"low\\": 1, \\"medium\\": 2, \\"high\\": 3} tasks_sorted = sorted(tasks, key=lambda x: priority_order[x[\\"priority\\"]]) return tasks_sorted return [] manager = ToDoManager() manager.add_user(\\"john_doe\\") manager.create_todo_list(\\"john_doe\\", \\"work_tasks\\") manager.add_task(\\"john_doe\\", \\"work_tasks\\", \\"Finish report\\", \\"Complete the annual report\\", \\"high\\", \\"2023-11-01\\") manager.add_task(\\"john_doe\\", \\"work_tasks\\", \\"Meeting with team\\", \\"Monthly team meeting\\", \\"medium\\", \\"2023-10-20\\") tasks_by_due_date = manager.get_tasks(\\"john_doe\\", \\"work_tasks\\", order_by=\\"due_date\\") tasks_by_priority = manager.get_tasks(\\"john_doe\\", \\"work_tasks\\", order_by=\\"priority\\") manager.delete_task(\\"john_doe\\", \\"work_tasks\\", \\"Finish report\\")"},{"question":"# Largest Subarray with Sum K You are given a list of integers and a target integer `k`. Write a program to find the length of the largest subarray with a sum equal to `k`. Input * A list of integers `arr` where `arr[i]` is an element of the array. * An integer `k` representing the target sum. Output * An integer representing the length of the largest subarray with sum equal to `k`. If no such subarray exists, return `0`. Constraints * `1 ≤ len(arr) ≤ 10^5` * `-10^9 ≤ arr[i] ≤ 10^9` * `-10^9 ≤ k ≤ 10^9` Example ```python # Input arr = [1, -1, 5, -2, 3] k = 3 # Output 4 ``` Explanation Here, the largest subarray with sum equal to 3 is `[1, -1, 5, -2]` which has a length of 4. Implement the function `largest_subarray_with_sum_k(arr: List[int], k: int) -> int`: ```python def largest_subarray_with_sum_k(arr, k): # Implement here pass ```","solution":"def largest_subarray_with_sum_k(arr, k): Function to find the length of the largest subarray with sum equal to k. Parameters: arr (List[int]): The array of integers. k (int): The target sum. Returns: int: The length of the largest subarray with sum equal to k. sum_map = {} current_sum = 0 max_len = 0 for i in range(len(arr)): current_sum += arr[i] if current_sum == k: max_len = i + 1 if current_sum - k in sum_map: max_len = max(max_len, i - sum_map[current_sum - k]) if current_sum not in sum_map: sum_map[current_sum] = i return max_len"},{"question":"# Balanced Parentheses Checker with Custom Rules Problem Statement You are asked to implement a parser for checking if a string containing different types of parentheses (`{}`, `[]`, `()`, `<>`) is balanced. A string is considered balanced if every opening parenthesis has a corresponding closing parenthesis in the correct order, and the types of parentheses are correctly nested. # Function Definitions 1. `is_balanced(expression: str) -> bool` - Checks if the given expression is balanced. - **Input**: A string `expression` containing the characters `{}`, `[]`, `()`, and `<>`. - **Output**: A boolean value indicating whether the expression is balanced. 2. `is_match(opening: str, closing: str) -> bool` - Determines if the given opening parenthesis matches the closing parenthesis. - **Input**: Two characters, `opening` and `closing`. - **Output**: A boolean value indicating whether `opening` and `closing` form a valid pair. # Constraints - The input string will only consist of the characters `{`, `}`, `[`, `]`, `(`, `)`, `<`, `>`. # Example ```python is_balanced(\\"{[()<>]}\\") # Expected output: True is_balanced(\\"{[(<>)]}\\") # Expected output: True is_balanced(\\"{[()<>]\\") # Expected output: False is_match(\'(\', \')\') # Expected output: True is_match(\'(\', \'}\') # Expected output: False ``` # Notes - Implement a stack-based approach to solve the problem. - You may not use any external libraries. - Ensure that your solution efficiently handles edge cases and large strings.","solution":"def is_match(opening, closing): Returns True if the opening and closing parenthesis are a matching pair. matches = { \'(\': \')\', \'{\': \'}\', \'[\': \']\', \'<\': \'>\' } return matches.get(opening) == closing def is_balanced(expression): Returns True if the input string with parentheses is balanced. stack = [] for char in expression: if char in \\"({[<\\": stack.append(char) elif char in \\")}]>\\": if not stack or not is_match(stack.pop(), char): return False return len(stack) == 0"},{"question":"# Matrix Transposition with Summed Diagonals In this task, you are given a square matrix and asked to transpose the matrix while also summing the elements of both the main diagonals, including the elements that lie on both diagonals (in the case of an odd-sized matrix). Input * A 2D list, `matrix`, representing the square matrix, where `matrix[i][j]` denotes the element at the `i-th` row and `j-th` column. The size of the matrix is `n x n` where `1 <= n <= 100`. Output * A tuple containing: - The transposed matrix. - The sum of the elements in both the main diagonals. Function Signature ```python def transpose_and_sum_diagonals(matrix: List[List[int]]) -> Tuple[List[List[int]], int]: Transpose the given square matrix and return the matrix along with the sum of the elements in both main diagonals. Parameters: matrix (List[List[int]]): The input square matrix. Returns: Tuple[List[List[int]], int]: A tuple containing the transposed matrix and the sum of the diagonal elements. ``` Requirements * The transposed matrix should be returned as a new 2D list. * The diagonal sum should include elements lying on both diagonals, counted only once if they overlap. * The algorithm\'s time complexity should be O(n^2), where n is the size of the matrix. Example Usage: ```python # Sample matrix matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Transpose the matrix and calculate diagonal sums. transposed_matrix, diagonal_sum = transpose_and_sum_diagonals(matrix) print(transposed_matrix) # Output should be: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] print(diagonal_sum) # Output should be 25 (1 + 5 + 9 + 3 + 7) ```","solution":"from typing import List, Tuple def transpose_and_sum_diagonals(matrix: List[List[int]]) -> Tuple[List[List[int]], int]: n = len(matrix) # Transpose the matrix transposed_matrix = [[matrix[j][i] for j in range(n)] for i in range(n)] # Calculate the sum of both diagonals diagonal_sum = 0 for i in range(n): diagonal_sum += matrix[i][i] # Main diagonal if i != n - i - 1: # Check to avoid double-counting the center element in case of odd-sized matrix diagonal_sum += matrix[i][n - i - 1] # Anti diagonal return transposed_matrix, diagonal_sum"},{"question":"# Problem Statement You are given a list of integers, and you need to detect whether the list contains any duplicate elements. If there are duplicates, return `True`. If no duplicates are present, return `False`. # Function Signature ```python def contains_duplicates(nums: List[int]) -> bool: pass ``` # Input * `nums (List[int])`: A list of integers, which can be of variable length. The integers can be positive, negative, or zero. # Output * Returns a boolean `True` if there are duplicate elements in the list, otherwise returns `False`. # Constraints * The list `nums` will contain up to `10^6` elements. * The integers in `nums` will be in the range `[-10^9, 10^9]`. # Requirements * Your solution should efficiently handle large lists. * Aim for a time complexity of O(n) and a space complexity of O(n). # Example ```python >>> contains_duplicates([1, 2, 3, 4, 5]) False >>> contains_duplicates([1, 2, 3, 4, 4]) True >>> contains_duplicates([10, -2, 3, -2]) True >>> contains_duplicates([]) False >>> contains_duplicates([99]) False ``` # Implementation In this task, you are required to implement the `contains_duplicates` function according to the provided specifications and constraints. Ensure your solution efficiently handles the upper limits of input size.","solution":"from typing import List def contains_duplicates(nums: List[int]) -> bool: Returns True if the list contains any duplicate elements, otherwise False. seen = set() for num in nums: if num in seen: return True seen.add(num) return False"},{"question":"# Problem Statement You are tasked with implementing a function that performs matrix multiplication for two given matrices. The matrices will be represented as a list of lists, where each sublist represents a row of the matrix. Ensure your implementation handles edge cases such as incompatible matrix dimensions and returns appropriate responses. Write a function `matrix_multiplication` that multiplies two matrices and returns the resulting matrix. Function Signature ```python def matrix_multiplication(matrix1: List[List[float]], matrix2: List[List[float]]) -> List[List[float]]: ... ``` Input - `matrix1`: A list of M lists, each containing K float elements, representing an MxK matrix. - `matrix2`: A list of K lists, each containing N float elements, representing a KxN matrix. Output - Returns a list of M lists, each containing N float elements, representing the resulting MxN matrix after multiplication. Constraints - 1 ≤ M, N, K ≤ 500 (dimensions of the matrices) - The elements of the matrices will be within the range of floating-point precision constraints. Performance Requirements - The solution should handle relatively large matrices within the given constraints. - Consider using efficient matrix multiplication techniques to improve performance. # Example Example 1 ```python matrix1 = [[1, 2, 3], [4, 5, 6]] matrix2 = [[7, 8], [9, 10], [11, 12]] assert matrix_multiplication(matrix1, matrix2) == [[58, 64], [139, 154]] ``` Example 2 ```python matrix1 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]] matrix2 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] assert matrix_multiplication(matrix1, matrix2) == [[1, 2, 3], [4, 5, 6], [7, 8, 9]] ``` # Notes - **Matrix Multiplication Rule**: For two matrices to be multiplied, the number of columns in the first matrix must be equal to the number of rows in the second matrix. - Handle cases where matrices cannot be multiplied by returning an empty list or raising an appropriate error. - Optimize the implementation to work efficiently within the specified constraints even for matrices at the upper limit of allowed dimensions.","solution":"def matrix_multiplication(matrix1, matrix2): Multiplies two matrices. Parameters: matrix1: List[List[float]] - The first matrix of dimensions MxK. matrix2: List[List[float]] - The second matrix of dimensions KxN. Returns: List[List[float]] - The resulting matrix of dimensions MxN after multiplication. # Check if multiplication is possible if len(matrix1[0]) != len(matrix2): raise ValueError(\\"Incompatible matrix dimensions for multiplication\\") M = len(matrix1) K = len(matrix1[0]) N = len(matrix2[0]) # Initialize the resulting matrix with zeros result = [[0] * N for _ in range(M)] # Perform matrix multiplication for i in range(M): for j in range(N): for k in range(K): result[i][j] += matrix1[i][k] * matrix2[k][j] return result"},{"question":"# Coding Assessment Question: Binary Tree Vertical Order Traversal You are provided with a binary tree and your task is to perform a vertical order traversal. The vertical order traversal of a binary tree is a traversal that groups nodes together if they are located in the same vertical line. Nodes having the same horizontal distance from the root have the same group and should be printed from top to bottom. # Task Write a function `verticalOrder(root)` in Python that takes the root of a binary tree and returns a list of lists where each sublist represents nodes grouped vertically in order from leftmost to rightmost. # Details * **Input**: The input is the root of a binary tree where each node is an instance of `TreeNode` class. * **Output**: The output should be a list of lists, where each sublist contains integer values of nodes grouped vertically from top to bottom. * **Constraints**: - The binary tree will have at most 10,000 nodes. - Node values are integers and can be negative or positive. # Example **Input**: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) ``` **Output**: ```plaintext [ [9], [3, 15], [20], [7] ] ``` # Implementation Requirements 1. Define the function `verticalOrder(root)` that navigates through the binary tree. 2. Use any approach (DFS or BFS) to process the nodes and group them according to their vertical distances. 3. Ensure the grouped nodes are output in the correct order from leftmost to rightmost group. Each group should list nodes from top to bottom within the vertical line.","solution":"from collections import defaultdict, deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def verticalOrder(root): if not root: return [] column_table = defaultdict(list) queue = deque([(root, 0)]) # (node, column_index) while queue: node, column = queue.popleft() if node is not None: column_table[column].append(node.val) queue.append((node.left, column - 1)) queue.append((node.right, column + 1)) # Sort by column index and return the corresponding values sorted_columns = sorted(column_table.keys()) return [column_table[col] for col in sorted_columns]"},{"question":"# Coding Assessment Question Scenario You are developing a file system that needs to manage and compress strings of characters to save space. One common operation is to encode a long string by counting consecutive characters and storing them along with the characters themselves in a compressed format. Task Write a function `compress_string(s)` that takes a string as input and returns a compressed version of the string using the run-length encoding algorithm. If the compressed string is not smaller than the original string, return the original string instead. Input * `s`: A string consisting of alphanumeric characters with a length between 1 and 1000 inclusive. Output * A string representing the compressed version of the input string or the original string if the compressed version is not smaller in size. Constraints * The characters in the string will be only alphanumeric (both uppercase and lowercase letters and digits). * The compressed version should display the character followed by the count of consecutive occurrences. Example Input ```python s = \\"aaabbbbccddddd\\" ``` Example Output ```python \\"a3b4c2d5\\" ``` In this example, the compressed form \\"a3b4c2d5\\" is shorter than the original string \\"aaabbbbccddddd\\". Additional Instructions Your solution should handle edge cases, such as strings with all unique characters or strings already in a compressed-like format where compression does not reduce the string size. Hint To construct the compressed string: 1. Traverse through the original string while counting consecutive characters. 2. Build the compressed string by appending the character followed by its count. 3. Compare the lengths of the original and compressed strings before returning the result. Example edge case: Input: `\\"abcd\\"` Output: `\\"abcd\\"` (Since the compressed version \\"a1b1c1d1\\" is longer, return the original string instead).","solution":"def compress_string(s): Compress the string using run-length encoding. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) # add the last character and its count compressed_str = \'\'.join(compressed) # Return the original string if the compressed string is not shorter if len(compressed_str) >= len(s): return s return compressed_str"},{"question":"# Problem Statement: You are required to implement a function that encodes a given string using Run-Length Encoding (RLE). Run-Length Encoding is a basic form of data compression in which consecutive occurrences of the same character are replaced with a single character followed by the number of occurrences. # Function Signature: ```python def run_length_encode(s: str) -> str: pass ``` # Input: * A string `s` (0 <= len(s) <= 10^6) composed of ASCII characters. # Output: * A string representing the run-length encoded version of the input string. # Example Test Cases: ```python assert run_length_encode(\\"\\") == \\"\\" assert run_length_encode(\\"aaa\\") == \\"a3\\" assert run_length_encode(\\"aabbbccc\\") == \\"a2b3c3\\" assert run_length_encode(\\"abcd\\") == \\"a1b1c1d1\\" assert run_length_encode(\\"wwwwaaadexxxxxxywww\\") == \\"w4a3d1e1x6y1w3\\" ``` # Constraints: 1. The function should handle strings of length up to 10^6 efficiently. 2. The function should be case-sensitive. 3. Non-repeated characters should still have \'1\' appended (e.g., \\"a1\\" for single \'a\'). # Performance Requirements: Your solution should operate in linear time O(n) with respect to the length of the input string and use constant additional space.","solution":"def run_length_encode(s: str) -> str: Encodes a given string using Run-Length Encoding (RLE). if not s: return \\"\\" encoded_string = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: encoded_string.append(f\\"{current_char}{count}\\") current_char = char count = 1 encoded_string.append(f\\"{current_char}{count}\\") return \'\'.join(encoded_string)"},{"question":"# Question You are developing a system to help manage and analyze network logs from different devices within a company. Each log is stored in a JSON file and is tagged with specific metadata including the device ID and timestamp. Your task is to implement a function `summarize_logs_by_device` that summarizes the logs for each device by providing the count of logs and the timestamp of the most recent log entry. Your function should: 1. Traverse the given directory and collect all JSON log files. 2. Extract the `device_id` and `timestamp` from each log file. 3. Aggregate the log count and most recent timestamp for each device. 4. Return a dictionary summarizing this information. **Function Signature:** ```python def summarize_logs_by_device(directory: pathlib.Path) -> dict[str, dict[str, Union[int, datetime.datetime]]]: pass ``` # Input: - `directory`: A `pathlib.Path` object pointing to the directory containing JSON log files. # Output: - Returns a dictionary where the keys are device IDs, and values are dictionaries containing: - `log_count`: The count of logs for that device. - `most_recent`: A `datetime.datetime` object representing the timestamp of the most recent log. # Constraints: - Assume each JSON log file has the fields `device_id` (string) and `timestamp` (ISO 8601 string). - Raise appropriate errors if critical issues occur, e.g., invalid file structure or missing fields. # Example: Given a directory structure with log files: **Directory Structure**: ``` logs/ ├── log_001.json ├── log_002.json ├── log_003.json ``` **Sample Log File Content (log_001.json, log_002.json, log_003.json)**: ```json { \\"device_id\\": \\"device_a\\", \\"timestamp\\": \\"2023-09-01T12:00:00Z\\" } ``` ```json { \\"device_id\\": \\"device_a\\", \\"timestamp\\": \\"2023-09-02T15:00:00Z\\" } ``` ```json { \\"device_id\\": \\"device_b\\", \\"timestamp\\": \\"2023-09-01T08:00:00Z\\" } ``` ```python # Example Usage: from pathlib import Path import datetime result = summarize_logs_by_device(Path(\\"logs\\")) print(result) # Output: # { # \\"device_a\\": {\\"log_count\\": 2, \\"most_recent\\": datetime.datetime(2023, 9, 2, 15, 0)}, # \\"device_b\\": {\\"log_count\\": 1, \\"most_recent\\": datetime.datetime(2023, 9, 1, 8, 0)} # } ```","solution":"import pathlib import json from datetime import datetime from typing import Union, Dict def summarize_logs_by_device(directory: pathlib.Path) -> Dict[str, Dict[str, Union[int, datetime]]]: logs_summary = {} for file_path in directory.glob(\\"*.json\\"): with open(file_path, \'r\') as log_file: log_data = json.load(log_file) device_id = log_data.get(\\"device_id\\") timestamp_string = log_data.get(\\"timestamp\\") if not device_id or not timestamp_string: raise ValueError(\\"Invalid log data: missing \'device_id\' or \'timestamp\'\\") timestamp = datetime.fromisoformat(timestamp_string.replace(\'Z\', \'+00:00\')) if device_id not in logs_summary: logs_summary[device_id] = { \\"log_count\\": 1, \\"most_recent\\": timestamp } else: logs_summary[device_id][\\"log_count\\"] += 1 if timestamp > logs_summary[device_id][\\"most_recent\\"]: logs_summary[device_id][\\"most_recent\\"] = timestamp return logs_summary"},{"question":"# Problem Statement You have to implement a cache memory that stores the results of a computationally expensive function. The cache should be able to handle both insertions of new results and lookups of existing results efficiently. The cache should use a Least Recently Used (LRU) eviction policy to manage space when it reaches its limit. # Objectives 1. Implement a class `LRUCache` with the following methods: - `__init__(self, capacity: int) -> None`: Initialize the cache with a given capacity. - `get(self, key: int) -> int`: Return the value of the key if the key exists in the cache, otherwise return -1. - `put(self, key: int, value: int) -> None`: Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the cache exceeds its capacity, it should invalidate the least recently used item before inserting a new item. # Function Signature ```python class LRUCache: def __init__(self, capacity: int) -> None: # Implementation def get(self, key: int) -> int: # Implementation def put(self, key: int, value: int) -> None: # Implementation ``` # Input - `capacity`: An integer representing the maximum number of items the cache can hold. - `key`: An integer key for the cache. - `value`: An integer value associated with the key. # Output - `get` method should return the value if the key exists in the cache, otherwise return -1. - `put` method does not return anything. # Constraints - The input key and value will always be integers. - The capacity will be a positive integer. - The get and put methods should run in O(1) average time complexity. # Example ```python >>> cache = LRUCache(2) >>> cache.put(1, 1) >>> cache.put(2, 2) >>> assert cache.get(1) == 1 >>> cache.put(3, 3) # evicts key 2 >>> assert cache.get(2) == -1 >>> cache.put(4, 4) # evicts key 1 >>> assert cache.get(1) == -1 >>> assert cache.get(3) == 3 >>> assert cache.get(4) == 4 ``` # Guidelines 1. Use a combination of a hashmap (dictionary) and a doubly linked list to implement the LRU cache. 2. The hashmap will store the keys and values, while the doubly linked list will keep track of the order of usage. 3. The least recently used element should be kept at the front of the list, and the most recently used element should be kept at the end. 4. When inserting a new element, add it to the end of the list. 5. When retrieving an element, move it to the end of the list to mark it as the most recently used.","solution":"class Node: def __init__(self, key: int, value: int): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int) -> None: self.capacity = capacity self.cache = {} self.head = Node(0, 0) self.tail = Node(0, 0) self.head.next = self.tail self.tail.prev = self.head def _remove(self, node: Node) -> None: prev = node.prev next = node.next prev.next = next next.prev = prev def _add(self, node: Node) -> None: prev = self.tail.prev prev.next = node self.tail.prev = node node.prev = prev node.next = self.tail def get(self, key: int) -> int: if key in self.cache: node = self.cache[key] self._remove(node) self._add(node) return node.value return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self._remove(self.cache[key]) node = Node(key, value) self._add(node) self.cache[key] = node if len(self.cache) > self.capacity: lru = self.head.next self._remove(lru) del self.cache[lru.key]"},{"question":"# Coding Assessment Question Question: Detect Cycles in a Directed Graph You are required to implement the function `detect_cycles`. Given a directed graph represented as an adjacency list, the function should return `True` if there is a cycle in the graph, and `False` otherwise. Function Signature ```python def detect_cycles(graph: dict) -> bool: ``` Input - `graph` (dict of list of int): A dictionary where the keys are integers representing nodes and the values are lists of integers representing directed edges from the key node. Output - returns: `True` if there is a cycle in the graph, `False` otherwise. Constraints - The input graph can have up to (10^3) nodes. - Each node can have up to (10^3) outgoing edges. - Nodes are represented by non-negative integers. Examples ```python assert detect_cycles({ 0: [1], 1: [2], 2: [0] }) == True assert detect_cycles({ 0: [1], 1: [2], 2: [] }) == False assert detect_cycles({ 0: [1], 1: [2, 3], 2: [3], 3: [1] }) == True assert detect_cycles({ 0: [], 1: [2], 2: [] }) == False ``` # Scenario Consider you are working with a directed graph where detecting cycles is an essential task in applications like dependency resolution or task scheduling. Implementing a robust cycle detection function will help ensure the correctness and reliability of these types of applications.","solution":"def detect_cycles(graph: dict) -> bool: Detects if there is a cycle in a given directed graph. Args: graph (dict): A dictionary where the keys are integers representing nodes and the values are lists of integers representing directed edges. Returns: bool: True if there is a cycle in the graph, False otherwise. visited = set() recStack = set() def dfs(node): if node in recStack: return True if node in visited: return False visited.add(node) recStack.add(node) for neighbor in graph.get(node, []): if dfs(neighbor): return True recStack.remove(node) return False for node in graph: if dfs(node): return True return False"},{"question":"# Coding Challenge: Distinct Bag Combinations **Objective**: Write a function to calculate the number of distinct combinations of items in a bag that can be formed by selecting a given number of items. **Function Signature**: ```python def count_distinct_combinations(n: int, k: int) -> int: ``` **Input**: * **n** (*integer*): The total number of distinct items in the bag. (1 <= n <= 50) * **k** (*integer*): The number of items to be selected. (1 <= k <= n) **Output**: * **result** (*integer*): The number of distinct combinations possible. **Constraints**: * The calculation must account for combinatorial properties (order doesn\'t matter, no duplicates). * The function should leverage mathematical combinatorial tools to ensure efficiency. **Scenario**: Given a bag with a set number of distinct items, you need to calculate the number of ways to select a specific number of items from the bag. This task involves combinatorics, specifically using combinations (n choose k) to determine the total number of possible combinations when selecting items. **Example**: ```python # Example 1 print(count_distinct_combinations(5, 2)) # Output: 10 # Example 2 print(count_distinct_combinations(10, 3)) # Output: 120 ``` **Explanation**: 1. For `n` = 5 and `k` = 2, there are (binom{5}{2} = 10) distinct ways to choose 2 items from 5. 2. For `n` = 10 and `k` = 3, there are (binom{10}{3} = 120) distinct ways to choose 3 items from 10. Develop the function `count_distinct_combinations` to ensure it returns the correct count of distinct combinations based on these example inputs.","solution":"from math import comb def count_distinct_combinations(n: int, k: int) -> int: Returns the number of distinct combinations of k items that can be formed from n distinct items. return comb(n, k)"},{"question":"# Problem Statement: You are given an array of integers and a target integer `k`. The task requires you to determine whether there are two distinct elements in the array that add up to `k`. # Function Signature: ```python def has_pair_with_sum(arr: list, k: int) -> bool: ``` # Input: - A list `arr` of integers where the number of elements ( 0 leq len(arr) leq 10^5 ). - An integer `k`. # Output: - A boolean value `True` if there are two distinct elements in `arr` that add up to `k`, otherwise `False`. # Constraints: - You are guaranteed that all elements in `arr` are integers. - Time complexity must be O(n) where n is the length of the array. # Examples: 1. `has_pair_with_sum([10, 15, 3, 7], 17)` should return `True` 2. `has_pair_with_sum([1, 2, 3, 4], 8)` should return `False` 3. `has_pair_with_sum([], 1)` should return `False` 4. `has_pair_with_sum([1, 1, 1, 1], 2)` should return `True` # Explanation: In example 1: - Array: `[10, 15, 3, 7]`, Target: `17` - Pairs that sum to `17`: `(10, 7)`, so the function returns `True`. In example 3: - Empty array, no pairs can be formed, so the function returns `False`. # Approach: - Use a set to store the unique elements as you iterate through the array. - For each element, check if the difference (`k - element`) exists in the set. - If it exists, return `True`, else add the element to the set and continue. - If no pairs are found by the end of the array, return `False`.","solution":"def has_pair_with_sum(arr: list, k: int) -> bool: Checks if there are two distinct elements in the array that add up to k. Parameters: arr (list): List of integers. k (int): Target sum. Returns: bool: True if there are two distinct elements in the array that add up to k, False otherwise. seen = set() for num in arr: if k - num in seen: return True seen.add(num) return False"},{"question":"# Context Regex (Regular Expressions) are a powerful tool used for pattern matching and text manipulation. Many programming tasks require precise string matching and extraction, such as validating email addresses or parsing formatted text. # Problem Statement Write a function `extract_emails` that, given a block of text, returns a list of all unique email addresses found within the text. Email addresses are defined as sequences of characters that follow the pattern `[local-part]@[domain-part]` where: - `local-part` can contain letters, digits, dots (`.`), underscores (`_`), and hyphens (`-`). - `domain-part` can contain letters, digits, hyphens (`-`), and dots (`.`). - There must be at least one dot in the domain part, and the domain part must end with an alphabetic top-level domain (e.g., \'.com\', \'.net\', \'.org\'). # Function Signature ```python import re from typing import List def extract_emails(text: str) -> List[str]: Extracts and returns a list of unique email addresses from the given text. :param text: A string containing the text to search for email addresses. :return: A list of unique email addresses found in the text. ``` # Input * `text` (str): A string containing the text to search for email addresses. # Output * A list of unique email addresses found in the text, sorted in the order they first appear. # Constraints * Email addresses are case-sensitive. * The text can contain any printable characters, including spaces. * The function should return an empty list if no valid email addresses are found. # Examples ```python >>> extract_emails(\\"Contact us at support@example.com or sales@example.com.\\") [\'support@example.com\', \'sales@example.com\'] >>> extract_emails(\\"No emails here!\\") [] >>> extract_emails(\\"Send an email to john.doe@company.co.uk or ping jane-doe@company.com\\") [\'john.doe@company.co.uk\', \'jane-doe@company.com\'] >>> extract_emails(\\"Emails: test.email+filter@example.com, hr@company.com, and hr@company.com\\") [\'test.email+filter@example.com\', \'hr@company.com\'] ``` # Note * Ensure the function uses an efficient regex pattern to match email addresses. * The function should handle typical email formats but does not need to conform to every possible edge case in the email specification. * Carefully handle cases where special characters or similar patterns may not constitute valid emails by typical standards.","solution":"import re from typing import List def extract_emails(text: str) -> List[str]: Extracts and returns a list of unique email addresses from the given text. :param text: A string containing the text to search for email addresses. :return: A list of unique email addresses found in the text. email_pattern = r\'b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+.[A-Za-z]{2,}b\' emails = re.findall(email_pattern, text) unique_emails = list(dict.fromkeys(emails)) # Removes duplicates while preserving order return unique_emails"},{"question":"# Problem Statement Design and implement a function that computes various statistical measures from a list of numbers, including mean, median, mode(s), variance, and standard deviation. Ensure that your implementation handles different edge cases such as empty lists and lists with multiple modal values properly. # Function Signature ```python def basic_statistics(numbers: list[float]) -> dict: pass ``` # Input 1. `numbers`: A list of floating-point numbers. # Output Returns a dictionary with the following keys: ``` { \\"mean\\": float, \\"median\\": float, \\"mode\\": list[float], \\"variance\\": float, \\"std_dev\\": float } ``` Where: - `\\"mean\\"`: The average value of the list. - `\\"median\\"`: The median value of the list. If the list has an even length, it is the average of the two central numbers. - `\\"mode\\"`: A list of the most frequently occurring value(s). If there are multiple modes, list all of them. - `\\"variance\\"`: The variance of the list. - `\\"std_dev\\"`: The standard deviation of the list. # Constraints * If `numbers` is an empty list, all values in the dictionary should be `None`. # Examples 1. Input: ```python numbers = [1, 2, 2, 3, 4] ``` Output: ```python { \\"mean\\": 2.4, \\"median\\": 2, \\"mode\\": [2], \\"variance\\": 1.3, \\"std_dev\\": 1.140175425099138 } ``` 2. Input: ```python numbers = [] ``` Output: ```python { \\"mean\\": None, \\"median\\": None, \\"mode\\": None, \\"variance\\": None, \\"std_dev\\": None } ``` # Hints 1. For computing the mean, use the sum of the numbers divided by the count. 2. The median can be found by sorting the list and finding the middle value or the average of the two central values. 3. The mode(s) can be found by creating a frequency distribution of the numbers. 4. Variance and Standard Deviation can be computed using standard statistical formulas.","solution":"import statistics def basic_statistics(numbers: list[float]) -> dict: Computes various statistical measures from a list of numbers. if not numbers: return { \\"mean\\": None, \\"median\\": None, \\"mode\\": None, \\"variance\\": None, \\"std_dev\\": None } mean = statistics.mean(numbers) median = statistics.median(numbers) mode = statistics.multimode(numbers) if len(numbers) > 1: variance = statistics.variance(numbers) std_dev = statistics.stdev(numbers) else: variance, std_dev = 0.0, 0.0 return { \\"mean\\": mean, \\"median\\": median, \\"mode\\": mode, \\"variance\\": variance, \\"std_dev\\": std_dev }"},{"question":"# Flight Reservation System You are tasked with implementing a system for managing reservations on flights. The system should be able to reserve seats and check if a seat is available on a particular flight. Function Signatures ```python class FlightReservationSystem: def __init__(self): pass def add_flight(self, flight_number: str, num_seats: int) -> None: pass def reserve_seat(self, flight_number: str, seat_number: int) -> bool: pass def is_seat_available(self, flight_number: str, seat_number: int) -> bool: pass ``` Objectives 1. Implement a class `FlightReservationSystem` with the following methods: - `add_flight(flight_number: str, num_seats: int) -> None`: Adds a new flight with the given number of seats. - `reserve_seat(flight_number: str, seat_number: int) -> bool`: Reserves a seat on the flight if it is available. Returns `True` if the reservation is successful, `False` otherwise. - `is_seat_available(flight_number: str, seat_number: int) -> bool`: Returns `True` if the seat is available and `False` otherwise. Inputs - `flight_number` (str): The unique identifier for the flight. - `num_seats` (int): The number of seats available on the flight. (1 <= num_seats <= 1000) - `seat_number` (int): The seat number to be reserved or checked. Constraints - Seat numbers are 1-indexed. - If the given seat number exceeds the number of seats on that flight, methods should handle gracefully by returning `False`. Example ```python frs = FlightReservationSystem() frs.add_flight(\\"AA123\\", 100) assert frs.is_seat_available(\\"AA123\\", 1) == True assert frs.reserve_seat(\\"AA123\\", 1) == True assert frs.is_seat_available(\\"AA123\\", 1) == False assert frs.reserve_seat(\\"AA123\\", 1) == False assert frs.reserve_seat(\\"AA123\\", 101) == False ``` # Notes * Your implementation should be efficient, ensuring that operations are performed within reasonable time limits even with large numbers of seats and multiple flights. * Focus on edge cases such as seat numbers out of range and handling non-existent flights gracefully. Good luck!","solution":"class FlightReservationSystem: def __init__(self): self.flights = {} def add_flight(self, flight_number: str, num_seats: int) -> None: self.flights[flight_number] = [False] * num_seats def reserve_seat(self, flight_number: str, seat_number: int) -> bool: if flight_number not in self.flights: return False if seat_number < 1 or seat_number > len(self.flights[flight_number]): return False if self.flights[flight_number][seat_number-1] == True: return False self.flights[flight_number][seat_number-1] = True return True def is_seat_available(self, flight_number: str, seat_number: int) -> bool: if flight_number not in self.flights: return False if seat_number < 1 or seat_number > len(self.flights[flight_number]): return False return not self.flights[flight_number][seat_number-1]"},{"question":"# Problem Context In many scenarios within computer science, it is crucial to assess whether a given sequence of numbers satisfies specific properties. One common task is to determine if a sequence follows a strictly increasing pattern, where each subsequent number is greater than the previous one. This can be useful in algorithms involving sorting, searching, or validating data sequences. # Problem Statement You need to write a function `is_strictly_increasing(lst: list) -> bool` that takes a list of integers and returns a boolean indicating whether the list is strictly increasing. # Function Signature ```python def is_strictly_increasing(lst: list) -> bool: # your code here ``` # Input - A list of integers `lst` where `0 <= len(lst) <= 10^5` and each element in the list is an integer. # Output - A boolean value `True` if the list is strictly increasing, `False` otherwise. # Constraints - The length of the list is given as `0 <= len(lst) <= 10^5`. - Each element in the list is an integer. - An empty list is considered strictly increasing. # Examples ```python assert is_strictly_increasing([1, 2, 3, 4, 5]) == True assert is_strictly_increasing([5, 4, 3, 2, 1]) == False assert is_strictly_increasing([1, 2, 2, 3, 4]) == False assert is_strictly_increasing([10, 20, 30, 40]) == True assert is_strictly_increasing([]) == True ``` # Edge Cases to Consider 1. When the list is empty, the result should be `True`. 2. When the list contains only one element, the result should be `True`. 3. Consider scenarios where the list contains negative numbers or large numbers up to `10^9`. 4. When the list contains consecutive duplicate numbers, ensure the result is `False`.","solution":"def is_strictly_increasing(lst): Returns True if the list \'lst\' is strictly increasing, False otherwise. # An empty list or a list with a single element is considered strictly increasing if len(lst) <= 1: return True # Iterate over the list and check if each element is strictly # greater than the previous one for i in range(1, len(lst)): if lst[i] <= lst[i - 1]: return False return True"},{"question":"**Context**: You are tasked with creating a simple task scheduler that efficiently schedules tasks based on their dependencies. Each task can only start when all its prerequisite tasks are completed. **Task**: Implement a `TaskScheduler` class that uses a Directed Acyclic Graph (DAG) to manage task dependencies and determine the order in which tasks should be executed. Your implementation should include functions to `add_task`, `add_dependency`, and `schedule_tasks`. # Function Signature ```python class TaskScheduler: def __init__(self): pass def add_task(self, task_id: int) -> None: pass def add_dependency(self, task1: int, task2: int) -> None: pass def schedule_tasks(self) -> List[int]: pass ``` # Requirements 1. **Constructor**: Initialize an empty task scheduler. 2. **Add Task Function**: Add a new task identified by `task_id` to the scheduler. 3. **Add Dependency Function**: Add a dependency whereby `task1` must be completed before `task2`. 4. **Schedule Tasks Function**: Return a list of task IDs in the order they should be executed. If tasks can\'t be completed due to a cyclic dependency, return an empty list. # Constraints - Task IDs are integers. - A valid task schedule does not contain any cycles in the dependency graph. - The number of tasks and dependencies entered during the lifetime of the scheduler does not exceed 10^3. # Example ```python # Create a task scheduler scheduler = TaskScheduler() # Add tasks scheduler.add_task(1) scheduler.add_task(2) scheduler.add_task(3) scheduler.add_task(4) # Add dependencies: 1 -> 2, 1 -> 3, 3 -> 4 scheduler.add_dependency(1, 2) scheduler.add_dependency(1, 3) scheduler.add_dependency(3, 4) # Schedule tasks assert scheduler.schedule_tasks() == [1, 3, 4, 2] # 1 must be before 2 and 3, and 3 must be before 4 ``` **Note**: The `schedule_tasks` function should handle detecting cycles and return an empty list in such cases. Ensure your implementation efficiently manages dependencies and determines the correct order for task execution.","solution":"from collections import defaultdict, deque from typing import List class TaskScheduler: def __init__(self): self.graph = defaultdict(list) self.tasks = set() self.in_degree = defaultdict(int) def add_task(self, task_id: int) -> None: if task_id not in self.tasks: self.tasks.add(task_id) self.in_degree[task_id] = 0 def add_dependency(self, task1: int, task2: int) -> None: if task1 in self.tasks and task2 in self.tasks: self.graph[task1].append(task2) self.in_degree[task2] += 1 def schedule_tasks(self) -> List[int]: zero_in_degree_queue = deque([task for task in self.tasks if self.in_degree[task] == 0]) scheduled_tasks = [] while zero_in_degree_queue: current_task = zero_in_degree_queue.popleft() scheduled_tasks.append(current_task) for dependent in self.graph[current_task]: self.in_degree[dependent] -= 1 if self.in_degree[dependent] == 0: zero_in_degree_queue.append(dependent) if len(scheduled_tasks) == len(self.tasks): return scheduled_tasks # All tasks have been scheduled else: return [] # Cycle detected, return an empty list"},{"question":"# Coding Assessment Question You need to assist in evaluating the performance of a research institute by analyzing the scores of research papers published by its researchers. Each paper is rated on a scale from 0 to 100. Your task is to calculate the H-index of the researchers. The H-index is defined as follows: - A researcher has an index H if H of their papers have at least H citations each, and the other papers have no more than H citations each. # Requirements Implement the function `calculate_h_index(citations)` which takes: 1. `citations`: A list of integers representing the number of citations for each paper. # Expected Function Signature ```python def calculate_h_index(citations: List[int]) -> int: ``` # Constraints - The `citations` list is not empty and contains non-negative integers. - The function should not use additional libraries or constructs other than standard Python. - Length of citations list will not exceed 1000. # Example ```python >>> calculate_h_index([6, 5, 3, 1, 0]) 3 >>> calculate_h_index([10, 8, 5, 4, 3]) 4 ``` # Performance Expectations - The function should run in O(n log n) time complexity, where n is the length of `citations`. # Explanation - In the first example, the researcher has 3 papers with at least 3 citations each: [6, 5, 3]. - In the second example, the researcher has 4 papers with at least 4 citations each: [10, 8, 5, 4].","solution":"from typing import List def calculate_h_index(citations: List[int]) -> int: Calculate the H-index for a list of citation counts. :param citations: List of non-negative integers representing citation counts :return: The H-index value # Sort citations in descending order citations.sort(reverse=True) h_index = 0 for i, citation in enumerate(citations): if citation >= i + 1: h_index = i + 1 else: break return h_index"},{"question":"Given the following scenario about sequencing tasks with prerequisites, write a program to determine the order in which tasks should be completed. Ensure to handle invalid scenarios and potential cycles in the dependency graph. # Scenario Imagine you are managing a series of tasks where some tasks must be completed before others. Your goal is to find a valid order to complete all tasks, respecting the provided dependencies. # Function Signature ```python def find_task_order(tasks: list, dependencies: list) -> list: pass ``` # Input * `tasks`: A list of strings representing the task identifiers. * `dependencies`: A list of tuples, where each tuple `(a, b)` indicates that task `a` must be completed before task `b`. # Output * `find_task_order` should return a list of strings representing a valid order to complete the tasks. If no valid order exists, return an empty list. # Constraints * The `tasks` list contains unique task identifiers. * The `dependencies` list can be empty, indicating no prerequisites. * Each task identifier in `dependencies` is guaranteed to be present in `tasks`. # Performance Requirements * Aim for a solution that has time complexity of `O(V + E)` where `V` is the number of tasks and `E` is the number of dependencies. * Space complexity should be kept to `O(V + E)`. # Notes 1. Raise a `ValueError` if a cycle is detected in the dependencies, rendering the tasks unorderable. 2. Tasks without prerequisites can be completed in any sequence. 3. Handle cases where there are multiple valid orderings correctly. # Example ```python tasks = [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] dependencies = [(\\"a\\", \\"b\\"), (\\"b\\", \\"c\\"), (\\"a\\", \\"c\\")] # Possible Outputs: [\'a\', \'b\', \'c\', \'d\'], [\'a\', \'c\', \'b\', \'d\'] print(find_task_order(tasks, dependencies)) # Output: [\'a\', \'b\', \'c\', \'d\'] or another valid topological order ``` # Edge Cases 1. If `tasks` is empty, the expected output is an empty list. 2. If there are no `dependencies`, the expected output can be any permutation of `tasks`. 3. Handle scenarios where multiple dependencies form complex graphs, ensuring correct task order. Implement the `find_task_order` function and ensure that your solution passes the provided test cases.","solution":"from collections import defaultdict, deque def find_task_order(tasks: list, dependencies: list) -> list: Finds a valid order to complete the given tasks respecting the provided dependencies. If no valid order exists (because of a cycle), return an empty list. # Initialize the graph and indegree structures graph = defaultdict(list) indegree = {task: 0 for task in tasks} # Build the graph for parent, child in dependencies: graph[parent].append(child) indegree[child] += 1 # Queue for tasks with no prerequisites queue = deque([task for task in tasks if indegree[task] == 0]) order = [] while queue: current_task = queue.popleft() order.append(current_task) # Decrease the indegree of the connected tasks for neighbor in graph[current_task]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) if len(order) == len(tasks): return order else: # Cycle detected or not all tasks are reachable return []"},{"question":"# Longest Increasing Subsequence You are given an array of integers and need to find the length of the longest increasing subsequence (LIS). A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Function Signature: ```python def length_of_LIS(nums: list[int]) -> int: ``` Input: - **nums**: A list of integers representing the input sequence. Output: - An integer representing the length of the longest increasing subsequence in the input list. Constraints: - The length of the input list `nums` will be between 1 and 2500. - The value of each integer in `nums` will be between -10^4 and 10^4. Examples: ```python # Example 1 nums = [10, 9, 2, 5, 3, 7, 101, 18] assert length_of_LIS(nums) == 4 # The LIS is [2, 3, 7, 101] # Example 2 nums = [0, 1, 0, 3, 2, 3] assert length_of_LIS(nums) == 4 # The LIS is [0, 1, 2, 3] # Example 3 nums = [7, 7, 7, 7, 7, 7, 7] assert length_of_LIS(nums) == 1 # The LIS is any one element [7] ``` Scenario: You are developing a feature in a software that involves tracking the progress of a user\'s skill development over time. Given an array that records the skill levels of a user at different time points, your task is to determine the length of the longest period during which the user\'s skill level has been consistently increasing. This will help identify periods of sustained growth and inform recommendations for further studies or practices.","solution":"def length_of_LIS(nums: list[int]) -> int: Return the length of the longest increasing subsequence in nums. if not nums: return 0 # Initialize the dp array, where dp[i] will be the length of the LIS ending at index i dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"# Question You are tasked with creating a simplified file system simulation that supports basic file operations such as creating files, reading files, and updating file contents. The file system should also support creating directories to organize the files and include functionality to navigate through the directories. # Problem Statement: Implement a `FileSystem` class to simulate a basic file system with the following operations: - `mkdir(path: str)`: Creates a new directory at the specified `path`. If the `path` already exists, do nothing. - `add_file(file_path: str, content: str = \\"\\")`: Creates a new file at the specified `file_path` with the given `content`. If the file already exists, overwrite its content. - `read_file(file_path: str) -> str`: Returns the content of the file at the specified `file_path`. If the file does not exist, return an empty string. - `cd(path: str)`: Changes the current working directory to the specified `path`. If the `path` does not exist, do nothing. You may assume that every valid `path` starts with \\"/\\". # Input and Output: **Input**: - A set of file system operations as described above. **Output**: - Results of the `read_file` operations. # Constraints: - The length of any given `path` or `file_path` is at most 100. - Each `path` is an absolute path starting from the root (\\"/\\"). - The number of operations received will not exceed 1000. # Example: ```python # Sample usage fs = FileSystem() fs.mkdir(\\"/a/b/c\\") fs.add_file(\\"/a/b/c/file.txt\\", \\"Hello, World!\\") print(fs.read_file(\\"/a/b/c/file.txt\\")) # Output: \\"Hello, World!\\" fs.mkdir(\\"/a/b/c\\") fs.cd(\\"/a/b\\") fs.add_file(\\"d/file2.txt\\", \\"File System Simulations\\") print(fs.read_file(\\"/a/b/d/file2.txt\\")) # Output: \\"File System Simulations\\" print(fs.read_file(\\"/a/b/c/file.txt\\")) # Output: \\"Hello, World!\\" ``` Implement the `FileSystem` class accordingly. Ensure thorough testing and include edge cases.","solution":"class FileSystem: def __init__(self): self.fs = {\\"/\\": {\\"directories\\": {}, \\"files\\": {}}} self.cwd = \\"/\\" def mkdir(self, path: str): dirs = path.strip(\\"/\\").split(\\"/\\") current = self.fs[\\"/\\"] for d in dirs: if d not in current[\\"directories\\"]: current[\\"directories\\"][d] = {\\"directories\\": {}, \\"files\\": {}} current = current[\\"directories\\"][d] def add_file(self, file_path: str, content: str = \\"\\"): dirs, file_name = file_path.strip(\\"/\\").rsplit(\\"/\\", 1) current = self.fs[\\"/\\"] for d in dirs.split(\\"/\\") if dirs else []: if d in current[\\"directories\\"]: current = current[\\"directories\\"][d] else: current[\\"directories\\"][d] = {\\"directories\\": {}, \\"files\\": {}} current = current[\\"directories\\"][d] current[\\"files\\"][file_name] = content def read_file(self, file_path: str) -> str: dirs, file_name = file_path.strip(\\"/\\").rsplit(\\"/\\", 1) current = self.fs[\\"/\\"] for d in dirs.split(\\"/\\") if dirs else []: if d in current[\\"directories\\"]: current = current[\\"directories\\"][d] else: return \\"\\" return current[\\"files\\"].get(file_name, \\"\\") def cd(self, path: str): dirs = path.strip(\\"/\\").split(\\"/\\") current = self.fs[\\"/\\"] for d in dirs: if d in current[\\"directories\\"]: current = current[\\"directories\\"][d] else: return self.cwd = path"},{"question":"Scenario You are developing a feature for a data analysis platform that includes implementing an efficient method to calculate correlation coefficients between different datasets. One requirement is to compute the Pearson correlation coefficient for two datasets. The goal is to measure the linear relationship between the datasets, helping users to identify trends and correlations in their data. Problem Statement Write a function `pearson_correlation` that, given two lists of numbers representing the datasets, returns the Pearson correlation coefficient between them. # Function Signature ```python def pearson_correlation(x: List[float], y: List[float]) -> float: ``` # Input * Two lists `x` and `y`, each containing `n` floating-point numbers: * `x` represents the values of the first dataset. * `y` represents the values of the second dataset. # Output * The function should return a single floating-point number that represents the Pearson correlation coefficient between the datasets `x` and `y`. # Constraints * 2 <= n <= 1000 * -1000 <= x[i], y[i] <= 1000 # Example ```python x = [10.0, 20.0, 30.0, 40.0, 50.0] y = [12.0, 24.0, 36.0, 48.0, 60.0] result = pearson_correlation(x, y) # This should return the Pearson correlation coefficient, which in this example is 1.0 ``` # Additional Information * The Pearson correlation coefficient, `r`, is calculated using the formula: [ r = frac{sum{(x_i - overline{x})(y_i - overline{y})}}{sqrt{sum{(x_i - overline{x})^2} sum{(y_i - overline{y})^2}}} ] where ( overline{x} ) and ( overline{y} ) are the means of the lists `x` and `y` respectively. * You must handle cases where the lists are constant (i.e., all elements are the same) to avoid division by zero errors. In such cases, return 0.0 as the correlation coefficient because a constant dataset does not vary and cannot have a meaningful correlation with another dataset. The function should be efficient and handle the upper limits of the input size gracefully.","solution":"from typing import List import math def pearson_correlation(x: List[float], y: List[float]) -> float: if len(x) != len(y): raise ValueError(\\"Lists x and y must have the same length.\\") n = len(x) if n < 2: raise ValueError(\\"Lists must contain at least two elements.\\") mean_x = sum(x) / n mean_y = sum(y) / n numerator = sum((xi - mean_x) * (yi - mean_y) for xi, yi in zip(x, y)) sum_x_squared = sum((xi - mean_x)**2 for xi in x) sum_y_squared = sum((yi - mean_y)**2 for yi in y) denominator = math.sqrt(sum_x_squared * sum_y_squared) if denominator == 0: return 0.0 # This means there is no variation in either x or y return numerator / denominator"},{"question":"# Problem Statement You are asked to implement a function that calculates the determinant of a given square matrix using recursive expansion by minors. The function should return the determinant of the matrix as an integer or a floating-point number. Task: `calculate_determinant(matrix: List[List[float]]) -> float` - **Input**: - `matrix`: A list of lists representing a square matrix (n x n), where each inner list is a row of the matrix and contains floating-point numbers. - **Output**: - Returns the determinant of the matrix as a float. Requirements and Constraints 1. **Assumptions**: - The input matrix is always a valid, non-empty square matrix where n ≥ 1. 2. **Constraints**: - Matrix elements will be real numbers (integers or floating-point). - Matrix dimensions n x n will not exceed 10 x 10 due to the computational complexity of the determinant calculation. Implementation Details - Implement the function recursively by expanding along the first row of the matrix. - Handle the base case where the matrix is 1x1 directly. - For larger matrices, calculate determinants of the (n-1) x (n-1) minor matrices. - Optimize for performance, but prioritize correctness and clarity. - Avoid using built-in determinant functions from numerical libraries to ensure understanding of the process. # Example ```python from typing import List def calculate_determinant(matrix: List[List[float]]) -> float: # Implementation here # Example usage: matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] det = calculate_determinant(matrix) # Expected output should be 0.0 since this matrix\'s determinant is zero matrix2 = [ [3, 8], [4, 6] ] det2 = calculate_determinant(matrix2) # Expected output should be -14.0 ``` Note: - Your solution should include proper validation and error handling for malformed input. - Include test cases to demonstrate the functionality and validate the correctness of your function.","solution":"from typing import List def calculate_determinant(matrix: List[List[float]]) -> float: def get_minor(matrix: List[List[float]], i: int, j: int) -> List[List[float]]: return [row[:j] + row[j + 1:] for k, row in enumerate(matrix) if k != i] n = len(matrix) if n == 1: return matrix[0][0] determinant = 0.0 for c in range(n): determinant += ((-1) ** c) * matrix[0][c] * calculate_determinant(get_minor(matrix, 0, c)) return determinant"},{"question":"# CamelCase String Splitter **Context**: CamelCase is the practice of writing compound words or phrases where each word begins with a capital letter, and spaces between words are eliminated. For example, \\"CamelCaseString\\" or \\"ThisIsAnExample\\". Splitting such strings into individual words can be useful for various text processing tasks. **Objective**: Write a function that takes a CamelCase formatted string and splits it into individual words. # Function Signature ```python def camel_case_splitter(text: str) -> list: Split a given CamelCase formatted string into individual words. Parameters: - text (str): A CamelCase formatted string. Returns: - list: A list of words obtained by splitting the CamelCase string. Examples: >>> camel_case_splitter(\\"CamelCaseString\\") [\'Camel\', \'Case\', \'String\'] >>> camel_case_splitter(\\"ThisIsAnExample\\") [\'This\', \'Is\', \'An\', \'Example\'] >>> camel_case_splitter(\\"AnotherExampleHere\\") [\'Another\', \'Example\', \'Here\'] >>> camel_case_splitter(\\"One\\") [\'One\'] >>> camel_case_splitter(\\"\\") [] pass ``` # Constraints * The input string will only contain alphabetic characters. * There will be no spaces, numbers, or punctuation. * The input string will contain at least one character or be empty. * Maintain time complexity O(n) where n is the length of the input string. # Requirements * Complete the `camel_case_splitter(text: str) -> list` function to achieve the objectives as described. * Ensure the function correctly handles both uppercase and lowercase transitions to form words.","solution":"def camel_case_splitter(text: str) -> list: Split a given CamelCase formatted string into individual words. Parameters: - text (str): A CamelCase formatted string. Returns: - list: A list of words obtained by splitting the CamelCase string. if not text: return [] words = [] start_index = 0 for i in range(1, len(text)): if text[i].isupper(): words.append(text[start_index:i]) start_index = i words.append(text[start_index:]) return words"},{"question":"# Problem Statement You are tasked with implementing a function that sorts a list of integers into ascending order using the Merge Sort algorithm. Your implementation should divide the list into smaller sublists and merge them back together in sorted order. # Function Specifications **Function Name**: `merge_sort` **Input**: A list of integers `arr` of length `n` (0 <= n <= 1000) **Output**: A new list of integers sorted in ascending order. # Constraints - The input list `arr` may be empty or contain up to 1000 integers, including both positive and negative values. - The merge sort algorithm should be implemented recursively. - Avoid modification of the original input list `arr`. # Performance Requirements - The time complexity should be O(n log n), which is expected of the merge sort algorithm. - The space complexity should be O(n) due to the additional space needed for the temporary sublists. # Examples ```python >>> merge_sort([]) [] >>> merge_sort([3]) [3] >>> merge_sort([3, 1, 2]) [1, 2, 3] >>> merge_sort([5, 3, 8, 4, 2]) [2, 3, 4, 5, 8] >>> merge_sort([-1, 3, -5, 2, 6]) [-5, -1, 2, 3, 6] ``` # Notes - Ensure that the merge process is done efficiently. - Focus on maintaining clean and readable code. - Do not use any built-in sort functions.","solution":"def merge_sort(arr): Sorts a list of integers into ascending order using the Merge Sort algorithm. if len(arr) <= 1: return arr # Finding the middle of the array mid = len(arr) // 2 # Dividing the elements into two halves left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) # Merging the sorted halves return merge(left_half, right_half) def merge(left, right): Merges two sorted lists into one sorted list. merged_list = [] i = 0 j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: merged_list.append(left[i]) i += 1 else: merged_list.append(right[j]) j += 1 # Collecting the remaining elements while i < len(left): merged_list.append(left[i]) i += 1 while j < len(right): merged_list.append(right[j]) j += 1 return merged_list"},{"question":"# Context: You are building a weather monitoring system that aggregates temperature data from various sensors. Occasionally, the data from some sensors are in Fahrenheit, and you need to convert those to Celsius for consistency in your database. # Problem Statement: Write a function `fahrenheit_to_celsius(fahrenheit_string: str) -> float` that converts a temperature value from Fahrenheit to Celsius. Your implementation should: 1. Remove any leading or trailing whitespace. 2. Detect if the input contains a valid floating-point number. 3. Raise `ValueError` with a descriptive message when: * The string is empty. * The string contains any invalid characters that do not form a valid floating-point number. 4. Convert the valid Fahrenheit value to Celsius using the formula: ((F - 32) times frac{5}{9}), where (F) is the Fahrenheit value. # Input: * A string `fahrenheit_string` (length <= 100), which may contain leading and trailing whitespace and be a valid positive or negative floating-point number. # Output: * A float representing the Celsius equivalent of the Fahrenheit input. # Constraints: * You may assume the input will not contain extremely large or small values and will handle up to 100 characters efficiently. # Examples: ```python >>> fahrenheit_to_celsius(\\" 32 \\") 0.0 >>> fahrenheit_to_celsius(\\"-40\\") -40.0 >>> fahrenheit_to_celsius(\\"212\\") 100.0 >>> fahrenheit_to_celsius(\\"invalid\\") Traceback (most recent call last): ... ValueError: Invalid Fahrenheit value ``` # Detailed Requirements: 1. Remove leading/trailing whitespace. 2. Check if the string is empty after trimming and raise `ValueError(\\"Empty string was passed to the function\\")` if true. 3. Validate that the string represents a valid floating-point number, raising `ValueError(\\"Invalid Fahrenheit value\\")` if not. 4. Convert the validated Fahrenheit value to Celsius using the formula: ((F - 32) times frac{5}{9}). 5. Return the resulting Celsius value as a float.","solution":"def fahrenheit_to_celsius(fahrenheit_string: str) -> float: Converts a temperature value from Fahrenheit to Celsius. :param fahrenheit_string: a string representing the Fahrenheit temperature :return: a float representing the Celsius equivalent # Strip leading and trailing whitespace fahrenheit_string = fahrenheit_string.strip() # Check if the string is empty after stripping if not fahrenheit_string: raise ValueError(\\"Empty string was passed to the function\\") # Validate that the string is a valid float number try: fahrenheit_value = float(fahrenheit_string) except ValueError: raise ValueError(\\"Invalid Fahrenheit value\\") # Convert Fahrenheit to Celsius celsius_value = (fahrenheit_value - 32) * 5.0 / 9.0 return celsius_value"},{"question":"# Problem Description You are given a binary tree implemented as a Python class. Your task is to implement a method named `invert_tree(self) -> None` in the `BinaryTree` class that inverts the tree by swapping the left and right children of every node. # Requirements - The function only modifies the binary tree; it does not return a new tree. - Your solution should work recursively and non-recursively. - Handle edge cases such as the tree being empty. # Input - The binary tree is defined within the `BinaryTree` class. # Output - The binary tree should be modified in place, inverting left and right child nodes. # Constraints - The number of nodes in the binary tree is between 0 and 10^4. # Examples Example 1: ```python from binary_tree import BinaryTree # Create a binary tree binary_tree = BinaryTree() binary_tree.insert(4) binary_tree.insert(2) binary_tree.insert(7) binary_tree.insert(1) binary_tree.insert(3) binary_tree.insert(6) binary_tree.insert(9) print(binary_tree.to_list()) # Output before invert_tree: [4, 2, 1, 3, 7, 6, 9] binary_tree.invert_tree() print(binary_tree.to_list()) # Output after invert_tree: [4, 7, 9, 6, 2, 3, 1] ``` Example 2: ```python from binary_tree import BinaryTree # Create a binary tree binary_tree = BinaryTree() binary_tree.insert(1) binary_tree.insert(2) print(binary_tree.to_list()) # Output before invert_tree: [1, 2] binary_tree.invert_tree() print(binary_tree.to_list()) # Output after invert_tree: [1, 2] ``` # Notes - Consider an auxiliary method for inverting the tree. - Ensure your implementation handles all edge cases gracefully. [End of Question]","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self): self.root = None def insert(self, value): if not self.root: self.root = TreeNode(value) else: self._insert_recursively(self.root, value) def _insert_recursively(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert_recursively(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._insert_recursively(node.right, value) def invert_tree(self): self._invert_tree_recursively(self.root) def _invert_tree_recursively(self, node): if node: node.left, node.right = node.right, node.left self._invert_tree_recursively(node.left) self._invert_tree_recursively(node.right) def to_list(self): result = [] self._in_order_traversal(self.root, result) return result def _in_order_traversal(self, node, result): if node: self._in_order_traversal(node.left, result) result.append(node.value) self._in_order_traversal(node.right, result)"},{"question":"# Problem Statement: You are tasked with implementing a function to simulate the working of a basic Minesweeper game. Minesweeper is a puzzle game where the player has to locate mines hidden in a grid. The player is given a grid with some squares containing mines (indicated by \'*\') and the others are empty (indicated by \'E\'). The goal is to display numbers in each empty square to indicate how many mines are adjacent to it (including diagonally adjacent cells). # Your Task: Implement the following function: 1. `update_minesweeper_board(board: List[List[str]]) -> List[List[str]]`: This function takes a two-dimensional grid representing the Minesweeper board and returns a modified grid where each empty cell is replaced by the number of adjacent mines. # Specifications: 1. **Input Format:** - The input is a list of lists where each sub-list represents a row in the Minesweeper board. - Each element of the sub-list is either \'*\' (a mine) or \'E\' (an empty cell). 2. **Output Format:** - The output should be a list of lists of the same dimensions where each \'E\' is replaced by a number indicating the count of adjacent mines unless it\'s re-rendering a mine location which should stay \'*\' as in the original grid. 3. **Constraints:** - The size of the board (number of rows and columns) can range from 1 to 100. - The board must contain at least one mine. # Example: ```python def update_minesweeper_board(board: List[List[str]]) -> List[List[str]]: n, m = len(board), len(board[0]) directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] def count_mines(x, y): count = 0 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and board[nx][ny] == \'*\': count += 1 return count new_board = [[\'E\' for _ in range(m)] for _ in range(n)] for i in range(n): for j in range(m): if board[i][j] == \'*\': new_board[i][j] = \'*\' else: new_board[i][j] = str(count_mines(i, j)) return new_board ``` Example Input: ```python board = [ [\'E\', \'E\', \'E\', \'E\'], [\'E\', \'*\', \'E\', \'E\'], [\'E\', \'E\', \'E\', \'E\'], [\'E\', \'E\', \'E\', \'E\'] ] print(update_minesweeper_board(board)) # Expected Output: # [ # [\'1\', \'1\', \'1\', \'0\'], # [\'1\', \'*\', \'1\', \'0\'], # [\'1\', \'1\', \'1\', \'0\'], # [\'0\', \'0\', \'0\', \'0\'] # ] ``` # Hints: - Consider using a helper function to count the number of mines around a given cell. - Make sure to check for edge cases, such as cells at the corners and edges of the board. - Test your function on different board configurations to ensure accuracy and robustness.","solution":"from typing import List def update_minesweeper_board(board: List[List[str]]) -> List[List[str]]: Takes a Minesweeper board and returns a modified board where each empty cell (\'E\') is replaced by the number of adjacent mines. n, m = len(board), len(board[0]) directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] def count_mines(x, y): count = 0 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and board[nx][ny] == \'*\': count += 1 return count new_board = [[\'E\' for _ in range(m)] for _ in range(n)] for i in range(n): for j in range(m): if board[i][j] == \'*\': new_board[i][j] = \'*\' else: new_board[i][j] = str(count_mines(i, j)) return new_board"},{"question":"# Matrix Element Multiplication You are tasked with implementing a function that takes an integer matrix and multiplies each element based on its position (i.e., multiply the element by its row index and column index). **Objective**: Write a Python function named `multiply_elements_by_indices` that accepts a matrix (a list of lists) and returns a new matrix where each element has been multiplied by its row index and column index. **Function Signature**: ```python def multiply_elements_by_indices(matrix: List[List[int]]) -> List[List[int]]: pass ``` **Input**: - `matrix` (List[List[int]]): A 2D list representing the integer matrix `A` of dimensions m x n (1 ≤ m, n ≤ 1000). **Output**: - Returns a new 2D list (matrix) of the same dimensions where each element `matrix[i][j]` is replaced with `matrix[i][j] * i * j`. **Example**: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] result = multiply_elements_by_indices(matrix) print(result) # Output: [ # [0, 0, 0], # [0, 5, 12], # [0, 16, 36] # ] ``` **Constraints**: - Input matrix can contain both positive and negative integers. - Ensure efficient handling of large matrices. **Performance**: - The time complexity should be O(m * n), where m and n are the dimensions of the matrix. - Space complexity should be O(m * n) for the output matrix. **Python Libraries**: - Standard libraries may be used, but no external libraries are needed. # Context: Manipulating matrices is a fundamental operation in various fields such as computer graphics, data analysis, and scientific computing. This exercise tests your understanding of iterating over 2D data structures and applying element-wise operations.","solution":"from typing import List def multiply_elements_by_indices(matrix: List[List[int]]) -> List[List[int]]: Multiplies each element in the matrix by its row and column indices. Parameters: matrix (List[List[int]]): A list of lists representing the integer matrix. Returns: List[List[int]]: A 2D list where each element is multiplied by its row and column indices. result_matrix = [] for i, row in enumerate(matrix): result_row = [] for j, value in enumerate(row): result_row.append(value * i * j) result_matrix.append(result_row) return result_matrix"},{"question":"# Problem Statement In accordance with FizzBuzz problem adaptation, you are required to create a custom function which processes a list of numbers transforming it according to specific rules related to divisibility. The aim of this task is to develop the function `processed_fizz_buzz` which outputs a list of strings based on the divisibility rules provided. **Function: processed_fizz_buzz** - **Input**: A list of integers `numbers` and a dictionary `rules` where the key is an integer representing the divisor and the value is a string to be appended if the number is divisible by this integer. - **Output**: A list of strings that is transformed according to the rules similar to FizzBuzz. - **Constraints**: - The list `numbers` will contain integers within the range `1 <= numbers[i] <= 10^5`. - The `rules` dictionary will contain at least one key-value pair, and all values will be non-empty strings. **Function Logic**: - For each number in the input list, create a string result starting as an empty string. - For each key-value pair in the `rules` dictionary: - If the number is divisible by the key, append the corresponding value to the result string. - If the result string is empty (i.e., the number is not divisible by any keys in `rules`), append the original number as a string to the result list. - Return the list of transformed strings. # Example ```python def processed_fizz_buzz(numbers, rules): # Your implementation here pass # Example Usage numbers = [1, 2, 3, 4, 5, 6, 15] rules = {3: \\"Fizz\\", 5: \\"Buzz\\"} output = processed_fizz_buzz(numbers, rules) print(output) # [\'1\', \'2\', \'Fizz\', \'4\', \'Buzz\', \'Fizz\', \'FizzBuzz\'] numbers = [10, 20, 30, 40] rules = {2: \\"Even\\", 5: \\"Multiple of Five\\"} output = processed_fizz_buzz(numbers, rules) print(output) # [\'Multiple of FiveEven\', \'EvenMultiple of Five\', \'FizzBuzzEven\', \'EvenMultiple of Five\'] # Test Cases assert processed_fizz_buzz([3, 5, 15], {3: \\"Three\\", 5: \\"Five\\"}) == [\'Three\', \'Five\', \'ThreeFive\'] assert processed_fizz_buzz([1, 2], {2: \\"Two\\"}) == [\'1\', \'Two\'] assert processed_fizz_buzz([7, 14, 21, 28], {7: \\"Seven\\", 2: \\"Even\\"}) == [\'Seven\', \'SevenEven\', \'Seven\', \'SevenEven\'] ``` **Scenario**: Imagine you are a part of a team developing a custom logging system. Your team needs to generate log messages that include specific tags depending on various rules related to the conditions of events. The function you are to implement helps determine the appropriate tags for each event. **Edge Cases**: - Handling of input list with only one number. - Correctly appending multiple tags when a number meets several rule conditions. - Ensuring that if no conditions apply, the original number is correctly converted to a string and added to the result list.","solution":"def processed_fizz_buzz(numbers, rules): Transforms the list of numbers according to the rules specified in the dictionary. Parameters: numbers (list of int): List of integers to be processed. rules (dict): A dictionary where keys are integers (divisors) and values are strings to be appended. Returns: list of str: List of strings with the processed results according to the rules. result = [] for number in numbers: transformed = \\"\\" for div, word in rules.items(): if number % div == 0: transformed += word if not transformed: transformed = str(number) result.append(transformed) return result"},{"question":"# Context: As part of a data analysis project, you need to group a list of integer numbers by their frequencies and then sort these groups by the frequency of occurrences. This will help in identifying common patterns in data. # Problem Statement: Implement a function `group_and_sort_by_frequency` that takes a list of integers and returns a list of lists, where each sublist contains numbers that have the same frequency. The sublists should be sorted in descending order based on their frequency. If two sublists have the same frequency, sort them in ascending order based on their values. # Function Signature: ```python def group_and_sort_by_frequency(num_list: list) -> list: pass ``` # Input: * `num_list`: A list of integers (0 <= length of num_list <= 10^5). # Output: * List of lists where each sublist contains integers with the same frequency, sorted in descending order of frequency. If frequencies are equal, sublists should be sorted in ascending order of integer values. # Constraints: * All integers will be within the range -10^7 to 10^7. * Your implementation should handle lists with varying lengths efficiently. # Examples: ```python assert group_and_sort_by_frequency([4,4,4,2,2,3,1,1,1,1,5]) == [[1], [4], [2], [3, 5]] assert group_and_sort_by_frequency([10,20,10,30,20,30,30,20,10,40]) == [[10, 20, 30], [40]] assert group_and_sort_by_frequency([]) == [] assert group_and_sort_by_frequency([7]) == [[7]] ``` # Additional Notes: * Consider using helper functions to make your code more readable and modular. * Ensure you handle edge cases such as an empty list and lists with one element. # Evaluation: Your solution will be evaluated based on: * Correctness * Efficiency * Clarity and readability of the code * Handling of edge cases","solution":"from collections import defaultdict def group_and_sort_by_frequency(num_list): Groups the integers by their frequencies and sorts them by the frequency of occurrences. if not num_list: return [] # Calculate frequencies freq_dict = defaultdict(int) for num in num_list: freq_dict[num] += 1 # Group by frequency freq_group = defaultdict(list) for num, freq in freq_dict.items(): freq_group[freq].append(num) # Sort each group and then sort groups by frequency result = [] for freq in sorted(freq_group.keys(), reverse=True): group = sorted(freq_group[freq]) result.append(group) return result"},{"question":"# Polynomial Coefficient Extraction Context A polynomial is an expression consisting of variables and coefficients that involves only the operations of addition, subtraction, multiplication, and non-negative integer exponentiation. Given a polynomial, you may be required to extract the coefficient of a specific term. Problem Statement You are required to implement a function `extract_coefficient` that extracts the coefficient of the term with a given power from a polynomial represented as a string. Function Signature ```python def extract_coefficient(polynomial: str, term_power: int) -> int: pass ``` Parameters - `polynomial` (str): A string representing the polynomial in the form of \\"ax^n + bx^(n-1) + ... + cx + d\\", where coefficients may be positive or negative integers, and variables may have no exponent if their power is 1. Each term is represented as `ax^n`, where `a` is the coefficient and `n` is the power, unless the power is 1 or 0 (e.g., `x` or `d`). - `term_power` (int): The power of the term whose coefficient needs to be extracted. Can be any non-negative integer. Returns - int: The coefficient of the term with the given power in the polynomial. If the term does not exist, return 0. Constraints - The polynomial string will be well-formed and contain only valid polynomial terms. - `term_power` will be a non-negative integer. Examples ```python >>> extract_coefficient(\\"3x^2 + 5x - 6\\", 2) 3 >>> extract_coefficient(\\"3x^2 + 5x - 6\\", 1) 5 >>> extract_coefficient(\\"3x^2 + 5x - 6\\", 0) -6 >>> extract_coefficient(\\"3x^2 + 5x - 6\\", 3) 0 >>> extract_coefficient(\\"7x^5 - 2x^3 + x + 1\\", 3) -2 >>> extract_coefficient(\\"7x^5 - 2x^3 + x + 1\\", 5) 7 ``` Notes - Implement the algorithm using string parsing techniques. - Consider edge cases, such as missing terms and polynomials with only constant terms. - Ensure your implementation efficiently handles polynomials with a high degree and multiple terms.","solution":"def extract_coefficient(polynomial: str, term_power: int) -> int: import re # Prepare the regex pattern to match individual terms term_pattern = re.compile(r\'([+-]?[^-+]+)\') # Split polynomial into terms terms = term_pattern.findall(polynomial.replace(\' \', \'\')) for term in terms: if \'x\' in term: parts = term.split(\'x\') if \'^\' in parts[1]: power = int(parts[1].replace(\'^\', \'\')) else: power = 1 if parts[0] in (\'+\', \'-\', \'\'): coefficient = int(parts[0] + \'1\') else: coefficient = int(parts[0]) else: power = 0 coefficient = int(term) if power == term_power: return coefficient return 0"},{"question":"# Problem Statement You are given a string consisting of lowercase English letters. Your task is to determine whether the string is a palindrome, considering only alphabetical characters and ignoring cases. Function Signature ```python def is_palindrome(s: str) -> bool: ``` Input - A string `s` (0 ≤ len(s) ≤ 100) Output - A boolean `True` if the string is a palindrome ignoring case, `False` otherwise. # Performance Requirements - Your solution should handle the input size efficiently within the given constraints. # Example **Input**: `\\"A man, a plan, a canal: Panama\\"` **Output**: `True` **Input**: `\\"race a car\\"` **Output**: `False` # Constraints 1. The length of the string `s` will be between 0 and 100 (both inclusive). 2. The string will consist of printable ASCII characters. # Implementation Notes - Ignore non-alphabetical characters while checking for palindrome. - Convert all characters to the same case (lowercase) for uniformity. - Ensure to handle edge cases like empty string or single-character string correctly. Implement the `is_palindrome` function based on the above problem statement.","solution":"def is_palindrome(s: str) -> bool: This function checks if the given string is a palindrome, ignoring non-alphabetical characters and cases. # Filter out non-alphabetical characters and convert to lowercase filtered_chars = [c.lower() for c in s if c.isalpha()] # Check if the filtered list is a palindrome return filtered_chars == filtered_chars[::-1]"},{"question":"# Efficient Matrix Transposition Scenario: You are tasked with implementing a function to transpose a given non-empty 2D matrix. Transposing a matrix involves swapping the rows and columns of the matrix. For example, given an `m x n` matrix, the result should be an `n x m` matrix where the value at position `(i, j)` in the original matrix is moved to position `(j, i)` in the transposed matrix. Task: Implement a function `transpose_matrix` to compute the transpose of a given 2D matrix (list of lists). Ensure that the function handles edge cases like 1x1, rectangular matrices, and square matrices properly. Function Signature: ```python def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: Transpose the given 2D matrix. :param list[list[int]] matrix: Input non-empty 2D matrix to transpose. :return list[list[int]]: The transposed 2D matrix. Example: >>> transpose_matrix([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose_matrix([[1]]) [[1]] >>> transpose_matrix([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] >>> transpose_matrix([[7, 8], [9, 10]]) [[7, 9], [8, 10]] # Your implementation goes here ``` Constraints: - The input matrix will be a non-empty 2D list with integer elements. - Aim for the solution to be efficient with respect to both time and space complexity. Performance Requirement: - The solution should have a time complexity of (O(m times n)), where `m` is the number of rows and `n` is the number of columns in the input matrix. - The space complexity should be (O(m times n)) for the resulting transposed matrix. Test your implementation with provided examples and additional test cases to ensure its correctness and performance.","solution":"def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: Transpose the given 2D matrix. :param list[list[int]] matrix: Input non-empty 2D matrix to transpose. :return list[list[int]]: The transposed 2D matrix. return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]"},{"question":"# Problem: Unique Character Concatenation You are provided with two strings `s1` and `s2`. Your task is to implement a function `uniqueCharacterConcatenation` that returns a new string which is the concatenation of `s1` and `s2` but only includes the characters that are unique to either `s1` or `s2`. # Function Signature ```python def uniqueCharacterConcatenation(s1: str, s2: str) -> str: pass ``` # Input - `s1` and `s2`: Non-empty strings composed of lowercase English letters. # Output - Return a string that contains characters from the concatenation of `s1` and `s2`, but excludes any character that appears in both strings. # Constraints & Requirements - **Performance**: Your solution should efficiently handle strings up to length 10^3. - **Validation**: Ensure input is valid: - `s1` and `s2` must be non-empty strings. - Raise `ValueError` with appropriate messages if input is invalid. # Example ```python print(uniqueCharacterConcatenation(\\"apple\\", \\"pen\\")) # \\"aln\\" print(uniqueCharacterConcatenation(\\"cats\\", \\"dogs\\")) # \\"catdog\\" print(uniqueCharacterConcatenation(\\"abc\\", \\"def\\")) # \\"abcdef\\" ``` # Explanation - In the first example, \\"apple\\" and \\"pen\\" share the common character \\"p\\", which is excluded. The result is \\"aln\\". - In the second example, there are no common characters between \\"cats\\" and \\"dogs\\". The result is \\"catdog\\". - In the third example, \\"abc\\" and \\"def\\" share no common characters. The result is \\"abcdef\\". # Note Your implementation should efficiently determine the uniqueness of characters and construct the resulting string accordingly.","solution":"def uniqueCharacterConcatenation(s1: str, s2: str) -> str: if not s1 or not s2: raise ValueError(\\"Both s1 and s2 must be non-empty strings.\\") set_s1 = set(s1) set_s2 = set(s2) unique_chars = (set_s1 - set_s2) | (set_s2 - set_s1) result = [char for char in s1+s2 if char in unique_chars] return \'\'.join(result)"},{"question":"# Problem Statement: You are given a list of integers where some integers appear twice and others appear once. Your task is to write a function `find_unique_numbers` that returns a list of integers that appear exactly once in the list, preserving the original order of their first appearance. # Function Signature: ```python def find_unique_numbers(nums: List[int]) -> List[int]: pass ``` # Input: * `nums`: A list of integers where each integer can appear once or twice. (1 <= len(nums) <= 10^5, -10^9 <= nums[i] <= 10^9) # Output: * A list of integers that appear exactly once in `nums`, preserving their original order of appearance. # Example: ```python assert find_unique_numbers([4, 3, 2, 7, 8, 2, 3, 1]) == [4, 7, 8, 1] assert find_unique_numbers([1, 2, 1, 2, 3]) == [3] assert find_unique_numbers([2, 2, 3, 3]) == [] assert find_unique_numbers([1, 2, 3, 1, 2, 4]) == [3, 4] ``` # Note: * The order of the output list should be the same as the first appearance of the integers in the input list. * Consider using an auxiliary data structure to keep track of occurrences of each number.","solution":"def find_unique_numbers(nums): from collections import Counter # Count the occurrences of each number in the list. counter = Counter(nums) # Extract the elements that appear exactly once. unique_numbers = [num for num in nums if counter[num] == 1] return unique_numbers"},{"question":"# File Metadata Reader **Objective**: Implement a function to read and interpret metadata from a series of files, returning the relevant metadata in a structured format. **Scenario**: In a project where you need to manage and catalog files based on their metadata, create a function that reads specific metadata from files and returns it in a structured manner. The metadata includes the file\'s size, creation date, modification date, and type. **Requirements**: - Define a function `fetch_file_metadata(filepaths: list) -> dict` that: - Takes a list of file paths (strings). - Returns a dictionary with the following structure: - Key: File path (string) - Value: Dictionary with the following keys: - `\\"size\\"`: Size of the file in bytes (integer) - `\\"creation_date\\"`: Creation date of the file (string in ISO 8601 format) - `\\"modification_date\\"`: Last modification date of the file (string in ISO 8601 format) - `\\"type\\"`: File type (string, e.g., \\"text\\", \\"image\\", \\"video\\", etc.) - Handle invalid file paths gracefully by returning an appropriate message. - If a file path is empty or None, skip it and continue with the next file. **Function Signature**: ```python def fetch_file_metadata(filepaths: list) -> dict: pass ``` **Constraints**: - The input list contains valid file paths (strings), with a maximum length of 50 paths. **Examples**: 1. `fetch_file_metadata([\\"/path/to/file1.txt\\", \\"/path/to/nonexistentfile\\", \\"/path/to/file2.jpg\\"])` - Might return: ```python { \\"/path/to/file1.txt\\": { \\"size\\": 1024, \\"creation_date\\": \\"2023-01-15T08:30:25Z\\", \\"modification_date\\": \\"2023-05-10T14:12:01Z\\", \\"type\\": \\"text\\" }, \\"/path/to/file2.jpg\\": { \\"size\\": 2048, \\"creation_date\\": \\"2022-11-09T17:45:00Z\\", \\"modification_date\\": \\"2023-04-22T19:24:45Z\\", \\"type\\": \\"image\\" }, \\"/path/to/nonexistentfile\\": \\"File not found or inaccessible.\\" } ``` 2. `fetch_file_metadata([\\"\\"])` - Should return: ```python {} ``` 3. `fetch_file_metadata([\\"/path/to/file3.mp4\\", None])` - Should return: ```python { \\"/path/to/file3.mp4\\": { \\"size\\": 5000000, \\"creation_date\\": \\"2021-12-01T12:05:00Z\\", \\"modification_date\\": \\"2023-01-15T09:10:10Z\\", \\"type\\": \\"video\\" } } ```","solution":"import os import mimetypes from datetime import datetime def fetch_file_metadata(filepaths: list) -> dict: def get_file_metadata(filepath): if not os.path.exists(filepath): return \\"File not found or inaccessible.\\" try: size = os.path.getsize(filepath) creation_date = datetime.utcfromtimestamp(os.path.getctime(filepath)).isoformat() + \'Z\' modification_date = datetime.utcfromtimestamp(os.path.getmtime(filepath)).isoformat() + \'Z\' file_type, _ = mimetypes.guess_type(filepath) file_type = file_type.split(\'/\')[0] if file_type else \'unknown\' return { \\"size\\": size, \\"creation_date\\": creation_date, \\"modification_date\\": modification_date, \\"type\\": file_type } except Exception as e: return f\\"Error reading file: {e}\\" metadata_dict = {} for filepath in filepaths: if filepath: metadata_dict[filepath] = get_file_metadata(filepath) return metadata_dict"},{"question":"# Coding Question **Objective**: Write a function to compute the result of Multiple AND operations. # Problem Statement You are given a list of lists, where each inner list contains several binary integers representing the inputs for an AND operation. Your task is to write a function `compute_and_operations(inputs: List[List[int]]) -> List[int]` that takes this nested list as input and returns a list of outputs corresponding to each set of AND operations. # Input Format - A list of lists, where each inner list contains binary integers (0 or 1). - Example: `[[1, 1, 0], [1, 1, 1], [0, 0, 0], [1, 0, 1], [1]]` # Output Format - A list of integers (0 or 1) corresponding to the AND operation on each inner list. - Example: `[0, 1, 0, 0, 1]` # Constraints - Each integer in the inner lists will be either 0 or 1. - The outer list can be empty, in which case the output should also be an empty list. - Inner lists can contain from 1 to any reasonable number of elements. # Example ```python assert compute_and_operations([[1, 1, 0], [1, 1, 1], [0, 0, 0], [1, 0, 1], [1]]) == [0, 1, 0, 0, 1] assert compute_and_operations([]) == [] assert compute_and_operations([[0], [1], [1, 1]]) == [0, 1, 1] ``` # Requirements - You must write the core logic to perform the AND operation for each list. - Ensure that your implementation is efficient and handles all edge cases.","solution":"from typing import List def compute_and_operations(inputs: List[List[int]]) -> List[int]: This function takes a list of lists of binary integers and returns a list of results where each result is the AND operation of the corresponding inner list. results = [] for inner_list in inputs: and_result = 1 for num in inner_list: and_result &= num results.append(and_result) return results"},{"question":"**Calculating Page Views from Web Server Logs** # Problem Description You are given logs of web server activity, and each record indicates an access to a specific page. Your task is to write a Python function that calculates the total number of views for each page. Each log entry consists of a timestamp, an IP address, and the page accessed. The function will return a dictionary with page paths as keys and their respective view counts as values. # Function Specification Write a function `count_page_views(logs: List[str]) -> Dict[str, int]` which takes in a list of strings representing the logs and returns a dictionary with the count of views for each page. Input - `logs` (List[str]): A list of strings where each string is a log entry in the format `\\"timestamp IP_address page_path\\"`. The `timestamp` is in the format `YYYY-MM-DDThh:mm:ss`, `IP_address` is from the IPv4 address space, and `page_path` is a URL path starting with `/`. Output - A dictionary with the page paths as keys and their view counts as values. Constraints - Assume the list of logs contains valid entries, all following the specified format. - The `page_path` will only include alphanumeric characters, dashes, and slashes. # Example ```python from typing import List, Dict def count_page_views(logs: List[str]) -> Dict[str, int]: # Implement here logs = [ \\"2023-10-01T12:34:56 192.168.1.1 /home\\", \\"2023-10-01T12:35:56 192.168.1.2 /about\\", \\"2023-10-01T12:36:56 192.168.1.3 /home\\", \\"2023-10-01T12:37:56 192.168.1.4 /contact\\", \\"2023-10-01T12:38:56 192.168.1.1 /home\\", ] print(count_page_views(logs)) # Output: {\'/home\': 3, \'/about\': 1, \'/contact\': 1} ``` # Requirements - Efficiently handle large log files with potentially thousands of entries. - Ensure the output dictionary is accurate and contains an entry for every unique page path present in the logs. - Consider edge cases, such as multiple accesses to the same page by the same or different IP addresses, and variation in the number of logs. Good luck!","solution":"from typing import List, Dict def count_page_views(logs: List[str]) -> Dict[str, int]: page_views = {} for log in logs: parts = log.split() page_path = parts[2] if page_path in page_views: page_views[page_path] += 1 else: page_views[page_path] = 1 return page_views"},{"question":"# Question You are given a collection of files represented in a nested directory structure. Each directory contains a list of all files and subdirectories it hosts. Your task is to determine the depth of the deepest directory in the structure. Write a function `deepest_directory_depth(directory_structure: dict) -> int` that takes as input a nested dictionary where each key is a directory name and its value is a list consisting of file names (strings) or nested directories (dictionaries). The function should return the depth of the deepest directory. # Input - A dictionary `directory_structure` representing the nested directory structure. # Output - An integer representing the depth of the deepest directory. The root level has a depth of 1. # Constraints - Each entry in the dictionary corresponds to either a string (representing a file) or another dictionary (representing a subdirectory). - Every directory (including the root) is counted in the depth. # Example ```python >>> directory_structure = { \\"root\\": [ \\"file1.txt\\", { \\"subdir1\\": [ \\"file2.txt\\", { \\"subdir2\\": [ \\"file3.txt\\", \\"file4.txt\\", { \\"subdir3\\": [ \\"file5.txt\\" ] } ] } ] } ] } >>> deepest_directory_depth(directory_structure) 4 ``` # Notes - The root directory has a depth of 1. - Consider directories with no subdirectories to have a depth of 1. - Ensure to handle nested structures efficiently and avoid infinite recursion through proper checks.","solution":"def deepest_directory_depth(directory_structure: dict, current_depth=1) -> int: Returns the depth of the deepest directory in a nested dictionary structure. max_depth = current_depth for item in directory_structure.values(): if isinstance(item, list): for sub_item in item: if isinstance(sub_item, dict): for sub_dir in sub_item: max_depth = max(max_depth, deepest_directory_depth(sub_item, current_depth + 1)) return max_depth"},{"question":"# Problem Statement Write a function that identifies the longest increasing sub-sequence (LIS) within a given list of integers and returns the length of this sequence. The longest increasing sub-sequence is defined as the longest sequence in which each element is followed by a greater element. # Input - A list of integers representing the sequence, which we\'ll refer to as `numbers`. # Output - An integer representing the length of the longest increasing sub-sequence in the given list. # Constraints - The length of the input list `numbers` can be up to 10,000. - Each integer in the list can be any value within the range of the signed 32-bit integer. # Complexity Requirements - The function should aim for a time complexity better than O(n^2), ideally O(n log n). # Function Signature ```python def length_of_LIS(numbers: List[int]) -> int: pass ``` # Example Your implementation should produce the following output for the provided input: ```python print(length_of_LIS([10, 9, 2, 5, 3, 7, 101, 18])) ``` Expected Output: ```python 4 ``` # Explanation In the example, one of the longest increasing sub-sequences is [2, 3, 7, 101], which has a length of 4. # Notes - Multiple increasing sub-sequences may exist, but only the length of one such sequence needs to be returned.","solution":"from typing import List import bisect def length_of_LIS(numbers: List[int]) -> int: Returns the length of the longest increasing sub-sequence (LIS) in the list of integers. if not numbers: return 0 tails = [] # tails[i] will be the smallest ending number of an increasing subsequence of length i+1 for num in numbers: # Use binary search to find the insertion point of num in tails index = bisect.bisect_left(tails, num) # If num is greater than any element in tails, add it if index == len(tails): tails.append(num) else: # Otherwise, replace the first element in tails that is greater than or equal to num tails[index] = num return len(tails)"},{"question":"# Coding Assessment Question Scenario: Optimizing File Storage with Custom Compression You are tasked with developing a file storage system that optimizes space usage by compressing files. While standard compression algorithms like gzip or zip are useful, your task is to implement a custom compression algorithm that handles a specific type of data efficiently. Specifically, the files you will be dealing with contain long sequences of repeated characters. Task Implement a function `custom_compress(data)` that compresses a string using the following custom compression algorithm: 1. If a character repeats consecutively, replace the sequence with the character followed by the count of repetitions. 2. If a character does not repeat, it should remain as is in the compressed string. For example, `aaabbcdddd` should be compressed to `a3b2cd4`. Function Signature ```python def custom_compress(data: str) -> str: Compresses the input string using the custom compression algorithm. Parameters: data (str): The string to compress. Returns: str: The compressed string. ``` Input - `data`: A string of length N (1 <= N <= 10^6) Output - A compressed string as described above. Constraints - Handle strings with mixed characters (letters, digits, special characters, etc.). - Ensure the function handles edge cases such as empty strings, strings with no repeating characters, and strings where all characters are the same. - Optimize for both time and space complexity to handle large inputs efficiently. - The function should produce an output that is guaranteed to be the same or shorter in length than the original string. Example ```python from typing import List # Example function call data = \\"aaabbcdddd\\" compressed_data = custom_compress(data) print(compressed_data) # Output: \\"a3b2cd4\\" ``` Guidelines - Consider using efficient looping and string manipulation techniques to minimize the time complexity. - Avoid unnecessary space usage by considering in-place modifications if possible. - Ensure that the final code is easy to read and maintain, with clear documentation for the implemented algorithm. - Test your function with a variety of input cases to ensure its robustness and correctness.","solution":"def custom_compress(data: str) -> str: Compresses the input string using the custom compression algorithm. Parameters: data (str): The string to compress. Returns: str: The compressed string. if not data: return data compressed = [] count = 1 prev_char = data[0] for char in data[1:]: if char == prev_char: count += 1 else: compressed.append(prev_char) if count > 1: compressed.append(str(count)) prev_char = char count = 1 # Append the final character and its count compressed.append(prev_char) if count > 1: compressed.append(str(count)) return \'\'.join(compressed)"},{"question":"# Question: Program to Simulate Elevator System You are tasked with writing a program that simulates a simple elevator system in a building with `N` floors. The elevator should be able to handle requests to move to different floors and must provide the optimal path for serving all pending requests. Requirements: 1. **Initialization**: The elevator starts at floor 1 (ground floor). 2. **Requests**: The system should handle multiple requests at once, adding new requests dynamically. 3. **Movement**: The elevator should minimize the total distance traveled by serving the nearest floor request first. 4. **Input/Output**: - Requests are given as a list of floor numbers to which the elevator should move. - The output should be the sequence of floors the elevator will visit to serve all requests optimally. # Example: ```python # Initial state with elevator at floor 1 requests = [5, 2, 8, 3] elevator_sequence = simulate_elevator(requests) assert elevator_sequence == [2, 3, 5, 8] ``` # Implementation: Define the following function to complete this task: 1. `simulate_elevator(requests: list[int]) -> list[int]` Function Specs: 1. `simulate_elevator`: - Args: `requests` (list[int]): List of floor requests. - Returns: `list[int]`: Sequence of floors the elevator will visit in an optimal order serving all requests. ```python def simulate_elevator(requests: list[int]) -> list[int]: # Start at the ground floor current_floor = 1 # List to track sequence of visited floors visited_floors = [] while requests: # Find the nearest floor to the current floor nearest_floor = min(requests, key=lambda x: abs(current_floor - x)) # Move to the nearest floor visited_floors.append(nearest_floor) # Update the current floor current_floor = nearest_floor # Remove the served request from the list requests.remove(nearest_floor) return visited_floors ``` In this question, the elevator serves all floor requests in the minimum possible distance, providing an efficient path for handling the given requests. This simulates a real-world elevator system in terms of hierarchical traversal and decision-making.","solution":"def simulate_elevator(requests: list[int]) -> list[int]: # Start at the ground floor current_floor = 1 # List to track sequence of visited floors visited_floors = [] while requests: # Find the nearest floor to the current floor nearest_floor = min(requests, key=lambda x: abs(current_floor - x)) # Move to the nearest floor visited_floors.append(nearest_floor) # Update the current floor current_floor = nearest_floor # Remove the served request from the list requests.remove(nearest_floor) return visited_floors"},{"question":"# Coding Assessment Question Scenario In many software applications, it is often necessary to verify that a list of numbers follows a specific mathematical pattern. One common pattern is the \\"exclusive or\\" (XOR) sequence, where each number is the result of applying the XOR operation to the previous number with some constant value. Task Write a Python function named `is_xor_sequence` that determines if a given list of integers follows an XOR sequence based on a given initial value and a constant XOR value. Function Signature ```python def is_xor_sequence(initial_value: int, xor_value: int, sequence: list) -> bool: pass ``` Input - `initial_value`: An integer representing the starting point of the sequence. - `xor_value`: An integer representing the constant XOR value to be applied at each step. - `sequence`: A list of integers that needs to be verified. Output - A boolean value: `True` if the sequence follows the XOR pattern from the initial value and XOR value, otherwise `False`. Examples ```python print(is_xor_sequence(1, 2, [1, 3, 1, 3])) # Should return True print(is_xor_sequence(5, 7, [5, 2, 5, 2])) # Should return True print(is_xor_sequence(0, 1, [0, 1, 2, 3])) # Should return False print(is_xor_sequence(4, 4, [4, 0, 4, 0])) # Should return True print(is_xor_sequence(10, 15, [10, 5, 10, 5])) # Should return True ``` Explanation - For the first example, starting from `1` and alternately applying XOR with `2`, the sequence [1, 3, 1, 3] is obtained. - For the second example, starting from `5` and alternately applying XOR with `7`, the sequence [5, 2, 5, 2] is obtained. - For the third example, starting from `0` and alternately applying XOR with `1`, the expected sequence [0, 1, 0, 1] does not match [0, 1, 2, 3]. - The final example sequences similarly verify the correct application of XOR operations. Constraints - The list of integers will have a length of at least 1 and at most (10^6). - All integers in the input will be in the range of (-10^9) to (10^9).","solution":"def is_xor_sequence(initial_value: int, xor_value: int, sequence: list) -> bool: Determine if the given list follows an XOR sequence pattern based on the initial value and the xor_value. current_value = initial_value for number in sequence: if number != current_value: return False current_value ^= xor_value return True"},{"question":"# Problem: Distinct Subsequences Counter Given two strings `s` and `t`, count the number of distinct subsequences of `s` which equals `t`. A subsequence of a string is a new string generated from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., \\"ACE\\" is a subsequence of \\"ABCDE\\" while \\"AEC\\" is not). Implement a function `num_distinct` that: - Accepts two strings `s` and `t`. - Returns the number of distinct subsequences of `s` which equals `t`. # Input Format: - A string `s` (1 ≤ |s| ≤ 1000). - A string `t` (1 ≤ |t| ≤ 1000). # Output Format: - An integer representing the number of distinct subsequences of `s` which equals `t`. # Function Signature ```python def num_distinct(s: str, t: str) -> int: pass ``` # Example: ```python assert num_distinct(\\"rabbbit\\", \\"rabbit\\") == 3 assert num_distinct(\\"babgbag\\", \\"bag\\") == 5 ``` # Explanation: - For `s = \\"rabbbit\\"` and `t = \\"rabbit\\"`, there are 3 distinct subsequences of s which equals t: - \\"rabbbit\\" -> \\"rabbit\\" by removing the third \'b\'. - \\"rabbbit\\" -> \\"rabbit\\" by removing the second \'b\'. - \\"rabbbit\\" -> \\"rabbit\\" by removing the first \'b\'. - For `s = \\"babgbag\\"` and `t = \\"bag\\"`, there are 5 distinct subsequences of s which equals t: - \\"babgbag\\" -> \\"bag\\" by removing the second \'b\' and \'g\'. - \\"babgbag\\" -> \\"bag\\" by removing the second \'b\' and the last \'g\'. - \\"babgbag\\" -> \\"bag\\" by removing \'a\' and \'b\'. - \\"babgbag\\" -> \\"bag\\" by removing \'a\' and the first \'g\'. - \\"babgbag\\" -> \\"bag\\" by removing \'b\' and \'b\'. # Constraints: - Use dynamic programming to ensure efficiency. - Pay attention to edge cases where lengths of `s` and `t` are very different. # Additional Notes: - The solution should handle cases where there are overlapping characters and different combinations maximally.","solution":"def num_distinct(s: str, t: str) -> int: m, n = len(s), len(t) # Create a 2D DP array with (m+1) x (n+1) dimensions dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize dp[i][0] to 1 for all i because an empty t can be a subsequence of any prefix of s for i in range(m + 1): dp[i][0] = 1 # Fill the dp array by checking each character of s against each character of t for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == t[j - 1]: # If characters match, include it and exclude it dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] else: # If characters don\'t match, exclude it dp[i][j] = dp[i - 1][j] return dp[m][n]"},{"question":"# Question: Implement a Matrix Transposition Function Context You are working on a data processing application that frequently needs to transpose matrices. Transposition is a common operation in various computational problems, where the rows of a matrix are swapped with its columns. Requirements 1. **Function: Transpose Matrix** ```python def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: Take in a matrix represented as a list of lists. \'matrix\' is a 2D list where each inner list represents a row of the matrix. Return the transposed matrix, where each row is converted into a column. Example: >>> transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] ``` Constraints - The input matrix can have varying dimensions but will always be a well-formed 2D list (i.e., each row will have the same number of columns). - Implement the solution without using any external libraries that directly handle matrix operations. Performance Requirements - Aim for efficient implementations with linear time complexity relative to the number of elements in the matrix. Edge Cases - Handle cases where the matrix has 0 rows or 0 columns. - Ensure the function can handle non-square matrices correctly. Write code that performs this operation, verifying it against the provided example. ```python def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: if not matrix or not matrix[0]: return [] return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))] # Example usage: transposed_matrix = transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) print(transposed_matrix) ```","solution":"def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: Take in a matrix represented as a list of lists. \'matrix\' is a 2D list where each inner list represents a row of the matrix. Return the transposed matrix, where each row is converted into a column. Example: >>> transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] if not matrix or not matrix[0]: return [] return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))] # Example usage: transposed_matrix = transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) print(transposed_matrix)"},{"question":"Write a function to evaluate a mathematical expression represented as a string and compute its result. The string can contain integers, \'+\', \'-\', \'*\', \'/\', and parentheses \'()\'. Ensure to handle precedence and associativity correctly according to standard mathematical rules. # Function Signature ```python def evaluate_expression(expression: str) -> int: pass ``` # Input * `expression`: A string representing a valid mathematical expression. It contains non-negative integers, operations (\'+\', \'-\', \'*\', \'/\'), and parentheses \'()\'. # Output * `evaluate_expression` should return an integer, representing the computed result of the given expression. # Constraints * The expression will have no variables and will only consist of non-negative integers and the operators mentioned. * There will be no spaces in the expression. * Division is integer division, discarding any fractional part. * You can assume the input expression is always valid and built correctly according to the constraints. # Performance Requirements * Aim for a solution that operates with a time complexity of `O(n)` and space complexity of `O(n)`, where `n` is the length of the expression. # Example ```python expression = \\"3+2*2\\" # Expected Output: 7 (as multiplication has higher precedence over addition) print(evaluate_expression(expression)) # Output: 7 ``` # Additional Examples ```python expression = \\"3/2\\" # Expected Output: 1 (integer division) print(evaluate_expression(expression)) # Output: 1 ``` ```python expression = \\"2*(5+5*2)/3+(6/2+8)\\" # Expected Output: 21 print(evaluate_expression(expression)) # Output: 21 ``` # Edge Cases 1. If the input is an empty string, return 0. 2. Handle cases where parentheses create nested expressions correctly. 3. Consider cases with operator precedence closely (e.g., `2+3*2` should return 8 not 10). Implement the `evaluate_expression` function and ensure that your solution passes the provided test cases.","solution":"def evaluate_expression(expression: str) -> int: def helper(expr, index): def update(stack, op, val): if op == \'+\': stack.append(val) elif op == \'-\': stack.append(-val) elif op == \'*\': stack.append(stack.pop() * val) elif op == \'/\': stack.append(int(stack.pop() / val)) # Truncate towards zero stack = [] num = 0 op = \'+\' while index < len(expr): ch = expr[index] if ch.isdigit(): num = num * 10 + int(ch) elif ch in \'+-*/\': update(stack, op, num) num, op = 0, ch elif ch == \'(\': num, index = helper(expr, index + 1) elif ch == \')\': update(stack, op, num) return sum(stack), index index += 1 update(stack, op, num) return sum(stack), index return helper(expression, 0)[0]"},{"question":"# Scenario You are part of a development team for a music streaming service. To enhance the user experience, you need to implement a feature that calculates the average rating of songs from user reviews. The reviews are stored as a list of dictionaries, where each dictionary contains the song title and its rating. You need to ensure that the function can handle a variable number of reviews per song and produce the correct average rating for each song. # Task Write a function `compute_average_ratings(reviews: list[dict]) -> dict`, that processes a list of review dictionaries to calculate the average rating for each unique song. Your function should: - Iterate through the list of review dictionaries. - Extract the song title and its rating from each dictionary. - Accumulate the ratings for each song. - Calculate the average rating for each unique song. - Return a dictionary with song titles as keys and their average ratings as values. # Input - `reviews`: A list of dictionaries, where each dictionary contains: - `title`: A string representing the song title. - `rating`: A float representing the rating of the song, which ranges from 0.0 to 5.0. # Output - A dictionary with songs as keys and their average ratings as values. # Constraints - The list of reviews will contain at least one review. - Each song title will be a non-empty string. - Ratings will be within the range [0.0, 5.0]. # Example ```python reviews = [ {\\"title\\": \\"Song A\\", \\"rating\\": 4.5}, {\\"title\\": \\"Song B\\", \\"rating\\": 3.0}, {\\"title\\": \\"Song A\\", \\"rating\\": 5.0}, {\\"title\\": \\"Song B\\", \\"rating\\": 4.0}, {\\"title\\": \\"Song A\\", \\"rating\\": 3.5}, ] # Expected output: # {\\"Song A\\": 4.333333333333333, \\"Song B\\": 3.5} ``` Implement the `compute_average_ratings` function: ```python def compute_average_ratings(reviews: list[dict]) -> dict: rating_sum = {} rating_count = {} for review in reviews: title = review[\'title\'] rating = review[\'rating\'] if title in rating_sum: rating_sum[title] += rating rating_count[title] += 1 else: rating_sum[title] = rating rating_count[title] = 1 average_ratings = {title: rating_sum[title] / rating_count[title] for title in rating_sum} return average_ratings ```","solution":"def compute_average_ratings(reviews: list[dict]) -> dict: rating_sum = {} rating_count = {} for review in reviews: title = review[\'title\'] rating = review[\'rating\'] if title in rating_sum: rating_sum[title] += rating rating_count[title] += 1 else: rating_sum[title] = rating rating_count[title] = 1 average_ratings = {title: rating_sum[title] / rating_count[title] for title in rating_sum} return average_ratings"},{"question":"# Coding Exercise: Find the Missing Number in a Sequence Context Suppose you are helping to develop a function for a software system that tracks sequences of numbers. In a given list of unique numbers, exactly one number is missing from the range of 0 to n. Problem Write a function `find_missing_number(nums: List[int]) -> int` that finds the missing number in a given list `nums` where `nums` contains unique numbers from the range 0 to n (inclusive). There should be exactly one number missing from this range in the list. Input & Output Format * **Input**: A list of integers `nums` (0 <= len(nums) <= 10^5) where: - `nums` contains unique integers. - Each integer is in the range from 0 to len(nums) inclusive (0 to n). * **Output**: An integer representing the missing number from the given list. Constraints * The function should have a time complexity of O(n) and a space complexity of O(1). Examples ```python find_missing_number([3, 0, 1]) -> 2 find_missing_number([0, 1]) -> 2 find_missing_number([9,6,4,2,3,5,7,0,1]) -> 8 find_missing_number([0]) -> 1 find_missing_number([1]) -> 0 ``` Additional Instructions * Use optimal methods that would ensure linear time complexity and constant space complexity. * Consider edge cases such as the smallest and largest possible values of `n` and how they impact the solution. * Ensure the solution is efficient and works within the provided constraints.","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: n = len(nums) expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) return expected_sum - actual_sum"},{"question":"# **Problem Statement:** You are required to develop functions to perform various operations on a 2D matrix, often referred to as a grid. The goal is to rotate the grid clockwise, rotate it counterclockwise, and transpose the grid. # **Function Specification:** 1. **`rotate_clockwise(matrix: list[list[int]]) -> list[list[int]]`** * **Input**: `matrix` (a 2D list of integers). * **Output**: A 2D list of integers representing the matrix rotated 90 degrees clockwise. Example: ```python >>> rotate_clockwise([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` 2. **`rotate_counterclockwise(matrix: list[list[int]]) -> list[list[int]]`** * **Input**: `matrix` (a 2D list of integers). * **Output**: A 2D list of integers representing the matrix rotated 90 degrees counterclockwise. Example: ```python >>> rotate_counterclockwise([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) [ [3, 6, 9], [2, 5, 8], [1, 4, 7] ] ``` 3. **`transpose(matrix: list[list[int]]) -> list[list[int]]`** * **Input**: `matrix` (a 2D list of integers). * **Output**: A 2D list of integers representing the transposition of the input matrix. Example: ```python >>> transpose([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] ``` # **Implementation Notes:** * For `rotate_clockwise`, the transformation is equivalent to taking the transpose of the matrix and then reversing each row. * For `rotate_counterclockwise`, the transformation is equivalent to taking the transpose of the matrix and then reversing each column. * For `transpose`, ensure that the new matrix contains the rows as columns and vice versa. # **Constraints:** * 1 ≤ number of rows in `matrix` ≤ 100 * 1 ≤ number of columns in `matrix` ≤ 100 * `matrix` contains integers in the range of -1000 to 1000. # **Performance Requirements:** * Ensure that the operations complete efficiently within the given constraints. Good luck!","solution":"def rotate_clockwise(matrix: list[list[int]]) -> list[list[int]]: Returns the matrix rotated 90 degrees clockwise. return [[matrix[row][col] for row in reversed(range(len(matrix)))] for col in range(len(matrix[0]))] def rotate_counterclockwise(matrix: list[list[int]]) -> list[list[int]]: Returns the matrix rotated 90 degrees counterclockwise. return [[matrix[row][col] for row in range(len(matrix))] for col in reversed(range(len(matrix[0])))] def transpose(matrix: list[list[int]]) -> list[list[int]]: Returns the transposed matrix. return [[matrix[row][col] for row in range(len(matrix))] for col in range(len(matrix[0]))]"},{"question":"# Problem Statement A financial services company wants to develop a software utility to compare the performance of different stocks over a given period. The data is provided as a list of tuples, where each tuple contains the stock name and its corresponding performance as a percentage change. The company\'s analysts need a function to sort these stocks either by their names alphabetically or by their performance in ascending or descending order, based on the analyst\'s requirements. Function Signature ```python def sort_stocks(stocks: list[tuple[str, float]], by: str, reverse: bool = False) -> list[tuple[str, float]]: Sorts a list of stocks based on the specified criteria. :param stocks: List of tuples where each tuple contains a stock name (string) and a performance (float). :param by: Criteria to sort by, either \\"name\\" or \\"performance\\". :param reverse: If True, sort in descending order, otherwise sort in ascending order. :return: Sorted list of stocks based on the given criteria. ``` Input - `stocks`: A list of tuples where each tuple contains a stock name (string) and its performance as a percentage change (float). - `by`: A string indicating the criteria to sort by, either \\"name\\" or \\"performance\\". - `reverse`: A Boolean flag to indicate the sorting order. True for descending, False for ascending. Output - A list of tuples sorted according to the specified criteria and order. Constraints - The list can contain up to (10^4) stocks. - Stock names are non-empty strings and unique. - Performance values are floating-point numbers. Example ```python stocks = [(\\"Apple\\", 5.34), (\\"Microsoft\\", 2.67), (\\"Google\\", 7.89), (\\"Amazon\\", -1.23)] assert sort_stocks(stocks, \\"name\\", False) == [ (\\"Amazon\\", -1.23), (\\"Apple\\", 5.34), (\\"Google\\", 7.89), (\\"Microsoft\\", 2.67) ] assert sort_stocks(stocks, \\"performance\\", True) == [ (\\"Google\\", 7.89), (\\"Apple\\", 5.34), (\\"Microsoft\\", 2.67), (\\"Amazon\\", -1.23) ] ``` Write an efficient implementation of the `sort_stocks` function. Ensure it handles large datasets and edge cases appropriately.","solution":"def sort_stocks(stocks, by, reverse=False): Sorts a list of stocks based on the specified criteria. :param stocks: List of tuples where each tuple contains a stock name (string) and a performance (float). :param by: Criteria to sort by, either \\"name\\" or \\"performance\\". :param reverse: If True, sort in descending order, otherwise sort in ascending order. :return: Sorted list of stocks based on the given criteria. if by == \\"name\\": return sorted(stocks, key=lambda x: x[0], reverse=reverse) elif by == \\"performance\\": return sorted(stocks, key=lambda x: x[1], reverse=reverse) else: raise ValueError(\\"Invalid sort criteria. Use \'name\' or \'performance\'.\\") # Examples: stocks = [(\\"Apple\\", 5.34), (\\"Microsoft\\", 2.67), (\\"Google\\", 7.89), (\\"Amazon\\", -1.23)] print(sort_stocks(stocks, \\"name\\", False)) print(sort_stocks(stocks, \\"performance\\", True))"},{"question":"# Scenario As a software developer, you are developing a feature for a digital library management system to organize books based on the year of publication. Due to recent changes in regulations, the library must now support efficient lookups for books published within a specific year range. The books in the library database are represented as objects containing various attributes such as title, author, and year of publication. # Task Implement a class `Library` that provides functionalities to add books and efficiently find books published within a given year range. # Class Design Design the `Library` class with the following methods: - `add_book(title: str, author: str, year: int) -> None`: Adds a new book to the library. - `find_books_by_year_range(start_year: int, end_year: int) -> list`: Returns a list of books published within the specified year range, inclusive. # Class Signature ```python class Library: def add_book(self, title: str, author: str, year: int) -> None: Adds a new book to the library. :param title: The title of the book. :param author: The author of the book. :param year: The year of publication of the book. :return: None def find_books_by_year_range(self, start_year: int, end_year: int) -> list: Finds all books published within the specified year range. :param start_year: The starting year of the range. :param end_year: The ending year of the range. :return: List of books published within the year range. ``` # Input - For `add_book`: `title` is a string representing the title of the book, `author` is a string representing the author of the book, and `year` is an integer representing the year of publication. - For `find_books_by_year_range`: `start_year` and `end_year` are integers representing the start and end years of the range, respectively. # Output - For `add_book`: This method does not return anything. - For `find_books_by_year_range`: This method returns a list of books published within the specified year range, where each book is represented as a dictionary with keys `\\"title\\"`, `\\"author\\"`, and `\\"year\\"`. # Constraints - The library can contain up to 10^5 books. - Book titles and authors are non-empty strings consisting of alphabetic characters and spaces. - Years are represented as integers within the range 1500 to 2100. - Your implementation should be efficient in terms of both time and space, particularly for the `find_books_by_year_range` method. # Example ```python library = Library() library.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960) library.add_book(\\"1984\\", \\"George Orwell\\", 1949) library.add_book(\\"A Brave New World\\", \\"Aldous Huxley\\", 1932) library.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 1925) books_in_20th_century = library.find_books_by_year_range(1900, 1999) print(books_in_20th_century) # Output: [{\'title\': \'To Kill a Mockingbird\', \'author\': \'Harper Lee\', \'year\': 1960}, # {\'title\': \'1984\', \'author\': \'George Orwell\', \'year\': 1949}, # {\'title\': \'A Brave New World\', \'author\': \'Aldous Huxley\', \'year\': 1932}, # {\'title\': \'The Great Gatsby\', \'author\': \'F. Scott Fitzgerald\', \'year\': 1925}] ``` # Notes - Think about the data structures you can use to ensure efficient lookups and insertions. - Make sure to include error handling for edge cases such as empty ranges or non-existent years.","solution":"class Library: def __init__(self): # Store books as a list of dictionaries self.books = [] def add_book(self, title: str, author: str, year: int) -> None: Adds a new book to the library. :param title: The title of the book. :param author: The author of the book. :param year: The year of publication of the book. :return: None self.books.append({\\"title\\": title, \\"author\\": author, \\"year\\": year}) def find_books_by_year_range(self, start_year: int, end_year: int) -> list: Finds all books published within the specified year range. :param start_year: The starting year of the range. :param end_year: The ending year of the range. :return: List of books published within the year range. # Filter books that fall within the range provided return [book for book in self.books if start_year <= book[\\"year\\"] <= end_year]"},{"question":"# Coding Assessment Question: Implementing Advanced Data Structures Objective You are tasked with implementing a `PriorityQueue` class with enhanced features including merging of queues and iterative level-order traversal of the priority queue represented as a binary heap. Requirements 1. **Basic Operations**: Implement standard priority queue operations like insertion and extraction with correct heap property maintenance. 2. **Merge Queues**: Implement a method to merge another priority queue into the current one, maintaining heap properties. 3. **Level-Order Traversal**: Implement a method to perform a level-order traversal of the priority queue. Method Specifications - **Standard Methods**: 1. `insert(val: int) -> None`: Insert an integer into the priority queue. 2. `extract_max() -> int`: Remove and return the maximum element from the priority queue. - **Enhanced Methods**: 1. `merge(other: \'PriorityQueue\') -> None`: Merge another priority queue into the current one. 2. `level_order() -> List[int]`: Perform a level-order traversal and return the values in a list. # Input and Output Formats - **Input**: The `PriorityQueue` will be operated on through method calls as specified. - **Output**: The methods should return appropriate values or perform necessary modifications as specified. # Constraints - The priority queue will handle values within the range [-10^6, 10^6]. - The number of operations on the priority queue will be within the range [1, 10^4]. # Performance Requirements - All operations including merge and level-order traversal should be optimized to handle the maximum input size efficiently. - The `extract_max` and `insert` method should adhere to the properties of a binary heap. # Function Signature ```python class PriorityQueue: def __init__(self): pass def insert(self, val: int) -> None: pass def extract_max(self) -> int: pass def merge(self, other: \'PriorityQueue\') -> None: pass def level_order(self) -> List[int]: pass ``` # Example Usage: ```python pq1 = PriorityQueue() pq2 = PriorityQueue() # Inserting elements into the priority queues pq1.insert(10) pq1.insert(20) pq2.insert(15) pq2.insert(5) # Extracting max element from pq1 print(pq1.extract_max()) # Output should be 20 # Merging pq2 into pq1 pq1.merge(pq2) # Performing level-order traversal of pq1 print(pq1.level_order()) # Output should be the elements of the heap in level-order # Expected Output might be [15, 10, 5] or similar representation maintaining heap property. ```","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] def insert(self, val: int) -> None: heapq.heappush(self.heap, -val) def extract_max(self) -> int: if not self.heap: raise IndexError(\\"extract_max from an empty PriorityQueue\\") return -heapq.heappop(self.heap) def merge(self, other: \'PriorityQueue\') -> None: for val in other.heap: heapq.heappush(self.heap, val) other.heap = [] def level_order(self) -> list: size = len(self.heap) return [-self.heap[i] for i in range(size)]"},{"question":"# Problem Description You are given a list of positive integers called `num_list`. Your task is to write a function `convert_to_binary_string` that takes this list and returns a new list where each integer is converted to its binary representation as a string. # Input * `num_list` (list): A list of positive integers. # Output * The function should return a list of strings representing the binary form of each integer from the input list. # Constraints * Each integer in the input list is a non-negative integer. * The list can be empty. # Example ```python >>> convert_to_binary_string([1, 2, 3, 4, 5]) [\'1\', \'10\', \'11\', \'100\', \'101\'] >>> convert_to_binary_string([7, 8, 16, 31]) [\'111\', \'1000\', \'10000\', \'11111\'] >>> convert_to_binary_string([0, 1, 10, 100]) [\'0\', \'1\', \'1010\', \'1100100\'] >>> convert_to_binary_string([]) [] ``` # Requirements * Implement the function `convert_to_binary_string` that meets the specifications. * Ensure the code handles input efficiently and correctly converts each integer to a binary string.","solution":"def convert_to_binary_string(num_list): Converts a list of positive integers to a list of their binary string representations. Args: num_list (list): A list of positive integers. Returns: list: A list of strings, where each string is the binary representation of the corresponding integer in the input list. return [bin(num)[2:] for num in num_list]"},{"question":"# Coding Assessment Question Scenario You\'re developing a file processing tool that needs to identify and parse structured data from text files. The tool must locate and verify sections within the file and extract pertinent data from those sections. Each text file contains multiple sections demarcated by specific tags that start and end each section. Task Implement a function `extract_section_data` that reads a text file, identifies a specific section by its start and end tags, and returns the extracted section data as a list of lines. Function Signature ```python def extract_section_data(file_path: str, start_tag: str, end_tag: str) -> List[str]: ``` Input - `file_path (str)`: The path to the text file that needs to be processed. - `start_tag (str)`: The tag indicating the beginning of the section. - `end_tag (str)`: The tag indicating the end of the section. Output - Returns a `list` of strings representing the lines within the specified section. - If the `start_tag` is not found, raise a `ValueError` with the message \\"Start tag not found.\\" - If the `end_tag` is not found, raise a `ValueError` with the message \\"End tag not found.\\" Constraints - The text file is guaranteed to be well-formed with appropriate sections. - The start and end tags will appear on separate lines and will not contain additional text. Example ```python The content of example.txt is as follows: # Section A Start Item1: Data1 Item2: Data2 # Section A End # Section B Start Item3: Data3 Item4: Data4 # Section B End The function call to extract the section between \'# Section B Start\' and \'# Section B End\' should return: [ \\"Item3: Data3\\", \\"Item4: Data4\\" ] data = extract_section_data(\\"example.txt\\", \\"# Section B Start\\", \\"# Section B End\\") print(data) # Output should be [\\"Item3: Data3\\", \\"Item4: Data4\\"] ``` Notes - Your implementation should handle large files efficiently. - Ensure to handle cases where the section tags are missing or out of order. - Pay attention to edge cases such as an empty section or multiple sections with the same tags.","solution":"from typing import List def extract_section_data(file_path: str, start_tag: str, end_tag: str) -> List[str]: Reads a text file, identifies a specific section by its start and end tags, and returns the extracted section data as a list of lines. section_data = [] in_section = False found_start_tag = False with open(file_path, \'r\') as file: for line in file: line = line.strip() if line == start_tag: in_section = True found_start_tag = True continue if in_section and line == end_tag: in_section = False break if in_section: section_data.append(line) if not found_start_tag: raise ValueError(\\"Start tag not found.\\") if in_section and not line == end_tag: raise ValueError(\\"End tag not found.\\") return section_data"},{"question":"# Problem Scenario You are designing a simulation for a simplified traffic management system. One of the essential aspects that need to be implemented is to manage the traffic lights at an intersection. Each traffic light should follow a predefined cycle consisting of the colors: green, yellow, red, each lasting for a specified duration. # Task: Implement a class `TrafficLight` that controls the cycle of a traffic light. Your implementation should allow defining the durations for each color and be able to advance the light to the next stage in the cycle based on the duration elapsed. # Key Requirements: 1. Initialize the traffic light with specific durations for each color. 2. Advance the traffic light to the next stage based on the elapsed time. # Specifications: 1. **Class**: `TrafficLight` 2. **Methods**: * `__init__(self, green_duration: int, yellow_duration: int, red_duration: int)`: Initializes the traffic light with the specified durations for green, yellow, and red lights. * `get_current_color(self) -> str`: Returns the current color of the traffic light. * `update(self, elapsed_time: int)`: Advances the traffic light based on the time elapsed since the last update. 3. **Input/Output**: * The `__init__` method takes three integers representing the durations in seconds for the green, yellow, and red lights respectively. * The `get_current_color` method returns the string \\"green\\", \\"yellow\\", or \\"red\\" indicating the current color of the traffic light. * The `update` method takes an integer `elapsed_time` representing the time in seconds since the last update, and it updates the light state according to the passed time. # Constraints: * The durations for green, yellow, and red must be positive integers. # Example: ```python # Example Usage traffic_light = TrafficLight(green_duration=10, yellow_duration=5, red_duration=15) print(traffic_light.get_current_color()) # Output: \\"green\\" traffic_light.update(10) print(traffic_light.get_current_color()) # Output: \\"yellow\\" traffic_light.update(5) print(traffic_light.get_current_color()) # Output: \\"red\\" traffic_light.update(20) print(traffic_light.get_current_color()) # Output: \\"green\\" ``` # Notes: * The traffic light starts with the green light. * Ensure the system correctly cycles through the colors in the correct order. * Make sure to handle cases where the elapsed time can advance through multiple stages (e.g., `update(20)`). This new problem still requires implementing a class and handling sequential operations, similar to the original problem set, while exploring traffic signal control as a complementary area.","solution":"class TrafficLight: def __init__(self, green_duration, yellow_duration, red_duration): self.green_duration = green_duration self.yellow_duration = yellow_duration self.red_duration = red_duration self.cycle_duration = green_duration + yellow_duration + red_duration self.current_time = 0 self.current_color = \'green\' def get_current_color(self): return self.current_color def update(self, elapsed_time): self.current_time = (self.current_time + elapsed_time) % self.cycle_duration if self.current_time < self.green_duration: self.current_color = \'green\' elif self.current_time < self.green_duration + self.yellow_duration: self.current_color = \'yellow\' else: self.current_color = \'red\'"},{"question":"# **Problem Statement:** You are charged with writing functions to preprocess, transform, and validate email addresses based on predefined rules. The goal is to create a standardized format for a list of email addresses, and to determine the validity of each based on specific criteria. # **Function Specification:** 1. **`clean_email(email: str) -> str`** * **Input**: `email` (a string representing an email address). * **Output**: A string with all characters in the email address lowercased and all leading/trailing whitespace removed. Example: ```python >>> clean_email(\' Example@Domain.COM \') \'example@domain.com\' ``` 2. **`parse_email(email: str) -> (str, str)`** * **Input**: `email` (a cleaned string representing an email address). * **Output**: A tuple containing the local part and the domain part of the email address. Example: ```python >>> parse_email(\'example@domain.com\') (\'example\', \'domain.com\') ``` 3. **`validate_email(email: str) -> bool`** * **Input**: `email` (a cleaned string representing an email address). * **Output**: A boolean value indicating whether the email address is valid or not based on defined criteria. Email Validation Criteria: - Must have one and only one `@` symbol. - The domain part must contain at least one `.` and at least one character before and after each dot. - The local part and domain should not be empty. Example: ```python >>> validate_email(\'example@domain.com\') True >>> validate_email(\'invalidemail@domaincom\') False ``` 4. **`standardize_emails(emails: list[str]) -> list[dict]`** * **Input**: `emails` (a list of strings representing email addresses). * **Output**: A list of dictionaries, each containing the keys `cleaned_email`, `local`, `domain`, and `valid` with corresponding values following the rules above. Example: ```python >>> emails = [ \'EXAMPLE@domain.com\', \' user@domain.co.in \' ] >>> standardize_emails(emails) [ { \'cleaned_email\': \'example@domain.com\', \'local\': \'example\', \'domain\': \'domain.com\', \'valid\': True }, { \'cleaned_email\': \'user@domain.co.in\', \'local\': \'user\', \'domain\': \'domain.co.in\', \'valid\': True } ] ``` # **Implementation Notes:** * The `clean_email` function should remove all inevitable whitespace and convert the string to lowercase. * For `parse_email`, split the cleaned email address at the `@` symbol to obtain the local and domain parts. * For `validate_email`, ensure it checks the email format according to specified criteria. * `standardize_emails` should apply all the previous functions to each email address in the list and compile results in the specified format. # **Constraints:** * 1 ≤ length of each email address ≤ 254 * The input list can contain up to 100 email addresses * Each email string can include alphabetic characters, digits, dots, underscores, and dashes. # **Performance Requirements:** * Ensure that each operation is efficient and completes within a reasonable time frame considering the constraints. Good luck!","solution":"def clean_email(email: str) -> str: This function returns the email after lowercasing and trimming leading/trailing spaces. return email.strip().lower() def parse_email(email: str) -> (str, str): This function splits the cleaned email into local and domain parts. local, domain = email.split(\'@\') return local, domain def validate_email(email: str) -> bool: This function validates an email based on the specified criteria. if email.count(\'@\') != 1: return False local, domain = email.split(\'@\') if not local or not domain: return False if \'.\' not in domain or domain.startswith(\'.\') or domain.endswith(\'.\'): return False if any(part == \'\' for part in domain.split(\'.\')): return False return True def standardize_emails(emails: list) -> list: This function returns a list of dictionaries with standardized email information. result = [] for email in emails: cleaned_email = clean_email(email) local, domain = parse_email(cleaned_email) valid = validate_email(cleaned_email) result.append({ \'cleaned_email\': cleaned_email, \'local\': local, \'domain\': domain, \'valid\': valid }) return result"},{"question":"# Coding Assessment Question Scenario You\'re tasked with manipulating and analyzing strings for various properties. One particular interesting task involves palindromes and substring identification. You need to create an efficient solution that works with long strings. Problem Statement Implement a function `longest_even_palindrome(s: str) -> str` that finds the longest even-length palindrome within a given string `s`. If there are multiple palindromes of the same maximum length, return the one which appears first. A palindrome is a string that reads the same backward as forward, and an even-length palindrome has an even number of characters. Input - A string `s` composed of lowercase English alphabet characters (`a-z`) where (1 leq |s| leq 10^5). Output - Returns the longest even-length palindrome substring in `s`. If no even-length palindrome exists, return an empty string. Constraints - The solution should be optimized to handle the input efficiently given the string length can be up to 100,000 characters. - Focus on avoiding unnecessary recalculations and utilize appropriate algorithms for substring identification and palindrome validation. Example ```python assert longest_even_palindrome(\\"abccba\\") == \\"abccba\\" # \\"abccba\\" is an even-length palindrome assert longest_even_palindrome(\\"efghracecaraaa\\") == \\"racecar\\" # \\"racecar\\" is an odd-length palindrome but \\"cec\\" is the longest even-length one assert longest_even_palindrome(\\"abbacdcba\\") == \\"abba\\" # \\"abba\\" is the longest even-length palindrome assert longest_even_palindrome(\\"abcdefg\\") == \\"\\" # no even-length palindrome ``` Notes - Consider using dynamic programming or a sliding window approach to optimize performance. - Carefully handle edge cases such as strings with a single character or no even-length palindromes.","solution":"def longest_even_palindrome(s: str) -> str: def expand_around_center(left: int, right: int) -> str: while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] max_palindrome = \\"\\" for i in range(len(s) - 1): # For even-length palindromes pal = expand_around_center(i, i + 1) if len(pal) > len(max_palindrome): max_palindrome = pal return max_palindrome"},{"question":"# Problem Statement Implement the `decode_roman_numeral` function which converts a Roman numeral string to its corresponding integer value. The function should handle the standard Roman numeral characters: \'I\', \'V\', \'X\', \'L\', \'C\', \'D\', and \'M\'. Roman numerals are typically written in descending order from left to right to represent numbers. However, there are certain cases where a smaller numeral appears in front of a larger numeral to represent subtraction. For example, \'IV\' means 4, and \'IX\' means 9. # Function Signature ```python def decode_roman_numeral(s: str) -> int: ``` # Input * **s**: A string representing a Roman numeral. (1 ≤ len(s) ≤ 15) # Output * Returns the integer value corresponding to the Roman numeral string. # Constraints * The input string will only contain valid Roman numerals. * The input string is non-empty and will not exceed 15 characters in length. * Roman numeral values to consider: - \'I\' = 1 - \'V\' = 5 - \'X\' = 10 - \'L\' = 50 - \'C\' = 100 - \'D\' = 500 - \'M\' = 1000 # Examples 1. `decode_roman_numeral(\\"III\\")` returns `3` 2. `decode_roman_numeral(\\"IV\\")` returns `4` 3. `decode_roman_numeral(\\"IX\\")` returns `9` 4. `decode_roman_numeral(\\"LVIII\\")` returns `58` 5. `decode_roman_numeral(\\"MCMXCIV\\")` returns `1994` # Notes * You should handle both simple and complex Roman numeral conversions and consider cases with subtractive notation properly. * Optimize for readability and clarity in implementation while ensuring performance is acceptable for the input limits. * Be mindful of potential cases that might be overlooked, such as consecutive numerals invoking subtraction rather than addition. Implement the `decode_roman_numeral` function.","solution":"def decode_roman_numeral(s: str) -> int: roman_to_int = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } total = 0 prev_value = 0 for char in reversed(s): value = roman_to_int[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"# Coding Assessment Question Context In many algorithmic problems, it\'s crucial to quickly determine the presence of a value within a collection. One efficient way to handle such queries is by using binary search, which significantly reduces the search time compared to linear search. Your task is to implement a binary search function that can find the position of a target value within a sorted list. If the target value isn\'t found, the function should return the position where the target value can be inserted while maintaining the sorted order. Task Implement a function `binary_search_insert_position(nums: List[int], target: int) -> int` that does the following: 1. Searches for the `target` in the sorted list `nums`. 2. Returns the index of the `target` if found. 3. If the `target` is not found, returns the index where the `target` should be inserted to keep the list sorted. Input - `nums` (List[int]): A list of integers sorted in non-decreasing order. - `target` (int): The target value to search for in the list. Output - (int): The index of the `target` if found or the index where it should be inserted to maintain the sorted order. Constraints - The length of `nums` will be between 1 and 10^5. - The values in `nums` will be between -10^6 and 10^6. - The target value will be an integer within the same range as `nums`. Example ```python >>> binary_search_insert_position([1, 3, 5, 6], 5) 2 >>> binary_search_insert_position([1, 3, 5, 6], 2) 1 >>> binary_search_insert_position([1, 3, 5, 6], 7) 4 >>> binary_search_insert_position([1, 3, 5, 6], 0) 0 ``` # Notes: - You are required to implement the binary search algorithm. - Avoid using Python\'s built-in functions that directly solve the problem, like `bisect`. - Ensure the solution handles large input efficiently.","solution":"def binary_search_insert_position(nums, target): Searches for the target in the sorted list nums. Returns the index of the target if found. If the target is not found, returns the index where it should be inserted to maintain the sorted order. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return left"},{"question":"# Task You are working on a feature for a communication platform that detects certain patterns in messages. Specifically, you need to find and return the longest substring of a given message where at most `k` distinct characters are used. # Requirements 1. Implement a function that identifies the longest substring with at most `k` distinct characters. 2. Optimize for performance to handle large strings efficiently. 3. Consider edge cases with very short or empty strings, and scenarios where `k` is zero or large relative to the string length. 4. Include proper error handling for invalid inputs. # Function Signature ```python def longest_substring_k_distinct(s: str, k: int) -> str: Finds the longest substring with at most k distinct characters. Parameters: s (str): The input string to evaluate. k (int): Maximum number of distinct characters allowed in the substring. Returns: str: The longest substring containing at most k distinct characters. Examples: >>> longest_substring_k_distinct(\\"eceba\\", 2) \\"ece\\" >>> longest_substring_k_distinct(\\"aa\\", 1) \\"aa\\" # Your implementation here ``` # Constraints - Ensure `s` is a string and `k` is a non-negative integer. Raise a `TypeError` if types are incorrect. - Return an empty string if `k` is zero. - Optimize the function to handle strings of length up to 10,000 characters efficiently. # Testing 1. Validate the implementation with strings of varying lengths, including edge cases with very large input strings. 2. Test scenarios where `k` exceeds the number of unique characters in the string. 3. Don\'t forget to include unit tests to verify the correctness of the function.","solution":"def longest_substring_k_distinct(s: str, k: int) -> str: Finds the longest substring with at most k distinct characters. Parameters: s (str): The input string to evaluate. k (int): Maximum number of distinct characters allowed in the substring. Returns: str: The longest substring containing at most k distinct characters. if not isinstance(s, str): raise TypeError(\\"Input s must be a string.\\") if not isinstance(k, int) or k < 0: raise TypeError(\\"Input k must be a non-negative integer.\\") if k == 0: return \\"\\" n = len(s) if n == 0 or k >= n: return s start = 0 max_len = 0 max_substring = \\"\\" char_map = {} for end in range(n): char = s[end] char_map[char] = char_map.get(char, 0) + 1 while len(char_map) > k: char_map[s[start]] -= 1 if char_map[s[start]] == 0: del char_map[s[start]] start += 1 if end - start + 1 > max_len: max_len = end - start + 1 max_substring = s[start:end + 1] return max_substring"},{"question":"# Question: Tic-Tac-Toe Game Simulation with Minimax Algorithm Context You are required to implement a simplified version of the Tic-Tac-Toe game with an AI opponent. The AI will use the Minimax algorithm to make its moves, ensuring an optimal strategy against any opponent. Task Implement the following functions within a Python class `TicTacToe`: 1. `make_move(self, position, player)`: - Place the player\'s mark (\'X\' or \'O\') on the specified position on the board. - Input: - `position`: Tuple of two integers (row, column). - `player`: Character, either \'X\' or \'O\'. - Output: Boolean indicating whether the move was successful. 2. `check_winner(self)`: - Check the current board state for a winner. - Input: None. - Output: Character (\'X\' or \'O\') if there\'s a winner, otherwise `None`. 3. `minimax(self, is_maximizing)`: - Implement the Minimax algorithm to evaluate board states recursively and return the best possible move for the AI. - Input: Boolean `is_maximizing` indicating if the current turn is maximizing or minimizing. - Output: Tuple of (score, position). 4. `best_move(self)`: - Determine and return the optimal move for the AI using the Minimax algorithm. - Input: None. - Output: Tuple of two integers (row, column) representing the AI\'s move. Constraints - Assume the board is a 3x3 grid. - Ensure all methods handle invalid input cases appropriately. - The game starts with an empty board and \'X\' making the first move. - Use `-1` for \'X\', `1` for \'O\', and `0` for empty spaces in the internal board representation for ease of calculation. # Solution Outline ```python class TicTacToe: def __init__(self): self.board = [[0]*3 for _ in range(3)] self.current_winner = None def make_move(self, position, player): row, col = position if self.board[row][col] == 0: self.board[row][col] = -1 if player == \'X\' else 1 return True return False def check_winner(self): for row in range(3): if abs(sum(self.board[row])) == 3: self.current_winner = \'X\' if self.board[row][0] == -1 else \'O\' return self.current_winner for col in range(3): col_sum = sum(self.board[row][col] for row in range(3)) if abs(col_sum) == 3: self.current_winner = \'X\' if self.board[0][col] == -1 else \'O\' return self.current_winner diag1_sum = sum(self.board[i][i] for i in range(3)) if abs(diag1_sum) == 3: self.current_winner = \'X\' if self.board[0][0] == -1 else \'O\' return self.current_winner diag2_sum = sum(self.board[i][2-i] for i in range(3)) if abs(diag2_sum) == 3: self.current_winner = \'X\' if self.board[0][2] == -1 else \'O\' return self.current_winner return None def minimax(self, is_maximizing): winner = self.check_winner() if winner: return (-1, None) if winner == \'X\' else (1, None) if all(all(cell != 0 for cell in row) for row in self.board): return (0, None) if is_maximizing: best_score = -float(\'inf\') best_move = None for row in range(3): for col in range(3): if self.board[row][col] == 0: self.board[row][col] = 1 score, _ = self.minimax(False) self.board[row][col] = 0 if score > best_score: best_score = score best_move = (row, col) return (best_score, best_move) else: best_score = float(\'inf\') best_move = None for row in range(3): for col in range(3): if self.board[row][col] == 0: self.board[row][col] = -1 score, _ = self.minimax(True) self.board[row][col] = 0 if score < best_score: best_score = score best_move = (row, col) return (best_score, best_move) def best_move(self): _, move = self.minimax(True) return move # Sample usage: game = TicTacToe() game.make_move((0, 0), \'X\') game.make_move((1, 1), \'O\') game.best_move() ```","solution":"class TicTacToe: def __init__(self): self.board = [[0]*3 for _ in range(3)] self.current_winner = None def make_move(self, position, player): row, col = position if self.board[row][col] == 0: self.board[row][col] = -1 if player == \'X\' else 1 return True return False def check_winner(self): for row in range(3): if abs(sum(self.board[row])) == 3: self.current_winner = \'X\' if self.board[row][0] == -1 else \'O\' return self.current_winner for col in range(3): col_sum = sum(self.board[row][col] for row in range(3)) if abs(col_sum) == 3: self.current_winner = \'X\' if self.board[0][col] == -1 else \'O\' return self.current_winner diag1_sum = sum(self.board[i][i] for i in range(3)) if abs(diag1_sum) == 3: self.current_winner = \'X\' if self.board[0][0] == -1 else \'O\' return self.current_winner diag2_sum = sum(self.board[i][2-i] for i in range(3)) if abs(diag2_sum) == 3: self.current_winner = \'X\' if self.board[0][2] == -1 else \'O\' return self.current_winner return None def minimax(self, is_maximizing): winner = self.check_winner() if winner: return (-1 if winner == \'X\' else 1, None) if all(all(cell != 0 for cell in row) for row in self.board): return (0, None) if is_maximizing: best_score = -float(\'inf\') best_move = None for row in range(3): for col in range(3): if self.board[row][col] == 0: self.board[row][col] = 1 score, _ = self.minimax(False) self.board[row][col] = 0 if score > best_score: best_score = score best_move = (row, col) return (best_score, best_move) else: best_score = float(\'inf\') best_move = None for row in range(3): for col in range(3): if self.board[row][col] == 0: self.board[row][col] = -1 score, _ = self.minimax(True) self.board[row][col] = 0 if score < best_score: best_score = score best_move = (row, col) return (best_score, best_move) def best_move(self): _, move = self.minimax(True) return move # Sample usage: # game = TicTacToe() # game.make_move((0, 0), \'X\') # game.make_move((1, 1), \'O\') # move = game.best_move() # print(move)"},{"question":"# Graph Depth-First Search (DFS) Pathfinding Challenge Overview: You are given a directed graph represented as an adjacency list. Your task is to implement a Depth-First Search (DFS) algorithm to find if there exists a path between two given nodes. If such a path exists, return it as a list of nodes in the order they are visited; otherwise, return an empty list. Function Signature: ```python def find_path_dfs(graph: Dict[int, List[int]], start: int, end: int) -> List[int]: ``` Input: - `graph`: A dictionary where the keys are node identifiers (integers) and the values are lists of integers representing the nodes directly reachable from the key node. - `start`: An integer representing the starting node for the search. - `end`: An integer representing the destination node for the search. Output: - A list of integers representing the path from the start node to the end node if such a path exists. If no such path exists, return an empty list. Constraints: - All node identifiers are unique integers. - The graph may be disconnected, and cycles may be present. - The graph can have up to 10^4 nodes and 10^5 edges. Example: ```python input: graph = { 0: [1, 2], 1: [2, 3], 2: [3], 3: [4], 4: [5], 5: [] }, start = 0, end = 5 output: [0, 1, 2, 3, 4, 5] input: graph = { 0: [1, 2], 1: [3], 2: [3], 3: [4], 4: [] }, start = 0, end = 4 output: [0, 1, 3, 4] input: graph = { 0: [1, 2], 1: [2, 3], 2: [0, 3], 3: [4], 4: [5], 5: [] }, start = 0, end = 6 output: [] ``` Requirements: 1. Write a helper function to perform the Depth-First Search from the start node, tracking the path. 2. Ensure the DFS function detects cycles and does not revisit nodes within a single search path. 3. Modify the DFS function to return the discovered path if the end node is reached. 4. Implement the main function to handle input and output requirements as described. Scenario: A logistics company is trying to determine the feasibility of delivering goods between various locations in their network. Each location is represented as a node, and direct paths between locations are edges. Given a starting location and a destination, your task is to find a viable delivery path using DFS, ensuring that the goods can be shipped from the start location to the end location following the paths defined in the graph.","solution":"def find_path_dfs(graph, start, end): Perform DFS to find a path between start and end nodes in a directed graph. Parameters: - graph (dict): Adjacency list representing the graph. - start (int): Start node. - end (int): End node. Returns: - List[int]: Path from start to end if exists, else an empty list. def dfs(current_node, path): # Add current node to the path path.append(current_node) # If the current node is the end node, return True to signal that a path is found if current_node == end: return True # Recur for all neighbors of the current node for neighbor in graph.get(current_node, []): if neighbor not in path: # Check to avoid revisiting nodes if dfs(neighbor, path): return True # Backtrack: remove current node from the path path.pop() return False path = [] if dfs(start, path): return path return []"},{"question":"# Problem Statement **Matrix Diagonal Sum** Given a square matrix of dimensions `n x n` (where `n` is an odd integer), create a function `calculate_diagonal_sum(matrix: List[List[int]]) -> int` that calculates the sum of elements along both the main diagonal and the secondary diagonal. Ensure that the center element (which is part of both diagonals in an odd-dimensional matrix) is only counted once in the total sum. **Constraints**: - `1 <= n <= 101` - `-100 <= matrix[i][j] <= 100` Input - `matrix` (List[List[int]]): A 2D list representing the square matrix with odd dimensions. Output - `int`: The sum of the elements along both diagonals, counting the center element only once. Example ```python def calculate_diagonal_sum(matrix: List[List[int]]) -> int: n = len(matrix) total_sum = 0 for i in range(n): total_sum = total_sum + matrix[i][i] + matrix[i][n-i-1] center_element = matrix[n//2][n//2] total_sum = total_sum - center_element return total_sum # Example Test Case example_matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(calculate_diagonal_sum(example_matrix)) # Output should be 25 ``` Notes - The function should handle matrices of odd dimensions efficiently. - Ensure the center element is not double-counted. - The input matrix will always have odd dimensions. Performance Requirements - The function should run efficiently for matrix dimensions up to 101x101 within reasonable time constraints.","solution":"from typing import List def calculate_diagonal_sum(matrix: List[List[int]]) -> int: Calculates the sum of the main and secondary diagonals in a square matrix with odd dimensions, counting the center element only once. Parameters: matrix (List[List[int]]): A square matrix of odd dimensions. Returns: int: The sum of the elements along both diagonals, minus the double-counted center element. n = len(matrix) total_sum = 0 for i in range(n): total_sum += matrix[i][i] # Main diagonal total_sum += matrix[i][n - i - 1] # Secondary diagonal # Subtract the center element as it is double counted center_element = matrix[n // 2][n // 2] total_sum -= center_element return total_sum"},{"question":"# Question You have been provided with a partially implemented **Trie (Prefix Tree)** in Python. Your task is to complete the implementation by adding an additional method called `starts_with_prefix`. This method should retrieve all words in the Trie that start with a given prefix. **Function Signature**: ```python def starts_with_prefix(self, prefix: str) -> List[str]: pass ``` # Instructions 1. **Function Details**: - **Input**: A string `prefix` representing the prefix to search for. - **Output**: Returns a list of all words in the Trie that start with the given prefix. If no words match the prefix, return an empty list. - **Constraints**: - The words in the returned list should be unique and should be in a lexicographical order. 2. **Examples**: ```python # Example 1 trie = Trie() trie.insert(\'apple\') trie.insert(\'app\') trie.insert(\'ape\') assert trie.starts_with_prefix(\'ap\') == [\'ape\', \'app\', \'apple\'] assert trie.starts_with_prefix(\'app\') == [\'app\', \'apple\'] assert trie.starts_with_prefix(\'apple\') == [\'apple\'] assert trie.starts_with_prefix(\'b\') == [] # Example 2 trie = Trie() trie.insert(\'bat\') trie.insert(\'ball\') trie.insert(\'barn\') trie.insert(\'bag\') assert trie.starts_with_prefix(\'ba\') == [\'bag\', \'ball\', \'barn\', \'bat\'] assert trie.starts_with_prefix(\'bat\') == [\'bat\'] assert trie.starts_with_prefix(\'bal\') == [\'ball\'] assert trie.starts_with_prefix(\'bd\') == [] ``` 3. **Guidelines**: - Make use of the `TrieNode` class. - Ensure that your implementation does not affect the existing functionalities of the Trie. # Additional Notes: - Focus on achieving accurate functionality within the specified constraints. - Make sure to handle edge cases, such as when no words match the given prefix. Implement the `starts_with_prefix` method in the `Trie` class: # Code to Implement ```python class TrieNode: def __init__(self): self.children = {} self.end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.end_of_word def starts_with(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True def starts_with_prefix(self, prefix: str) -> List[str]: # Your code here pass ```","solution":"from typing import List class TrieNode: def __init__(self): self.children = {} self.end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.end_of_word def starts_with(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True def _find_words_from_node(self, node, prefix): Helper method to recursively find all words starting from a given node. results = [] if node.end_of_word: results.append(prefix) for char in sorted(node.children.keys()): results.extend(self._find_words_from_node(node.children[char], prefix + char)) return results def starts_with_prefix(self, prefix: str) -> List[str]: Retrieves all words in the Trie that start with the given prefix. node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] return self._find_words_from_node(node, prefix)"},{"question":"# Problem Statement You are tasked with implementing a function that calculates the factorial of a given non-negative integer recursively. A factorial of a non-negative integer n is the product of all positive integers less than or equal to n and is denoted by n!. # Functional Requirements Implement a function `recursive_factorial(n: int) -> int` that: - Computes the factorial of the given non-negative integer `n` using recursion. - Takes the following parameter: * `n` (int): A non-negative integer. Must be non-negative. # Constraints - The input integer `n` must be non-negative. # Error Handling - If `n` is negative, raise a `ValueError` with the message \\"Input must be a non-negative integer\\". # Example ```python def recursive_factorial(n: int) -> int: if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") if n == 0 or n == 1: return 1 else: return n * recursive_factorial(n - 1) # Test cases print(recursive_factorial(5)) # 120 print(recursive_factorial(0)) # 1 print(recursive_factorial(3)) # 6 # print(recursive_factorial(-1)) # Raises ValueError: Input must be a non-negative integer print(recursive_factorial(10)) # 3628800 print(recursive_factorial(1)) # 1 ``` # Your Task Implement the `recursive_factorial` function according to the specifications above. Ensure proper error handling and validate the input before performing calculations. **Note**: Use the provided test cases to verify your implementation.","solution":"def recursive_factorial(n: int) -> int: Computes the factorial of a given non-negative integer recursively. Parameters: n (int): A non-negative integer Returns: int: The factorial of the given integer Raises: ValueError: If the input integer is negative if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") if n == 0 or n == 1: return 1 else: return n * recursive_factorial(n - 1)"},{"question":"# Coding Assessment Question Question: You have been tasked with implementing a word frequency counter that will read a large paragraph of text and return the most frequent words along with their counts. The function should ignore common stopwords. 1. **Input**: - A string `text` representing the paragraph of text. - An integer `top_n` representing the number of top frequent words to return. - A list of strings `stopwords` containing common words to be ignored in the count. 2. **Output**: - A list of tuples where each tuple contains a word and its frequency, sorted by frequency in descending order. If two words have the same frequency, they should be sorted alphabetically. 3. **Constraints**: - The length of `text` will not exceed 10^6 characters. - `0 <= top_n <= 100` - The length of `stopwords` will not exceed 1000. - The words in `text` are case-insensitive but should be handled as lower-case for counting. - Punctuation should be ignored in the word counts. 4. **Performance Requirements**: - Optimize the function to handle large text inputs efficiently. - Ensure all stopwords are properly excluded from the frequency count. Implementation: Write a function `word_frequency_counter` in Python that takes the above inputs and outputs a list of the top `top_n` frequent words along with their counts. Function signature: ```python def word_frequency_counter(text: str, top_n: int, stopwords: List[str]) -> List[Tuple[str, int]]: ``` Example: ```python # Input text = \\"Hello world! This is a test. Hello, hello, world: this is only a test.\\" top_n = 3 stopwords = [\\"is\\", \\"a\\", \\"this\\", \\"only\\"] # Output [ (\\"hello\\", 3), (\\"world\\", 2), (\\"test\\", 2) ] ``` Description: Implement the word frequency counter as described. The function should count occurrences of each word in `text`, ignoring case and punctuation. It should exclude any words listed in `stopwords` from the count. Finally, it should return the `top_n` most frequent words along with their counts, sorted primarily by frequency (descending order) and secondarily by alphabetical order.","solution":"from collections import Counter import re from typing import List, Tuple def word_frequency_counter(text: str, top_n: int, stopwords: List[str]) -> List[Tuple[str, int]]: # Convert text to lower case text = text.lower() # Remove punctuation text = re.sub(r\'[^ws]\', \' \', text) # Tokenize the text by splitting on whitespace words = text.split() # Filter out stopwords words = [word for word in words if word not in stopwords] # Count word frequencies word_counts = Counter(words) # Get the most common words sorted by frequency and alphabetically most_common_words = word_counts.most_common() sorted_most_common_words = sorted(most_common_words, key=lambda x: (-x[1], x[0])) # Return top_n words return sorted_most_common_words[:top_n]"},{"question":"# Coding Question Context You have been assigned to enhance a logging system for a web application. The current logging system writes logs to a single file, which can become quite large over time, making it difficult to manage and analyze. The goal is to split the log files into smaller, more manageable pieces based on file size. Task Write a function `enhanced_logger` that manages the logging process and splits log files when they exceed a specified size limit. Ensure that the function handles edge cases and implements performance optimizations. Function Signature ```python def enhanced_logger(log_message: str, log_dir: str = \\".\\", max_size: int = 1024) -> None: pass ``` Requirements 1. **Input**: * `log_message` (str): The message to be logged. * `log_dir` (str): The directory where log files are stored. * `max_size` (int): The maximum size (in bytes) for a log file before it is split. 2. **Output**: None 3. **Constraints**: * Create a new log file named `log_X.txt` where `X` is an incrementing number (e.g., `log_1.txt`, `log_2.txt`) each time a log file exceeds `max_size`. * Ensure that log messages are appended to the current log file until the size limit is reached. * Implement proper error handling (e.g., directory does not exist, insufficient permissions). * Efficiently handle file I/O to prevent performance bottlenecks. 4. **Performance**: * Aim for minimal overhead in managing file splits. * Ensure the solution can handle frequent logging without significant delays. Example: ```python if __name__ == \\"__main__\\": enhanced_logger(\\"This is a test log message.\\") ``` Notes: * Ensure that log files are named sequentially and new log entries are correctly appended to the appropriate file. * Write clean and readable code with adequate comments. * Implement logging for error conditions and file operations.","solution":"import os def enhanced_logger(log_message: str, log_dir: str = \\".\\", max_size: int = 1024) -> None: Writes a log message to the latest log file and splits the log files when they exceed the specified size limit. :param log_message: The message to be logged. :param log_dir: The directory where log files are stored. :param max_size: The maximum size (in bytes) for a log file before it is split. if not os.path.exists(log_dir): raise FileNotFoundError(f\\"The directory {log_dir} does not exist.\\") if not os.access(log_dir, os.W_OK): raise PermissionError(f\\"Insufficient permissions to write to the directory {log_dir}.\\") base_filename = \\"log_\\" extension = \\".txt\\" # Function to get the next log file number def get_next_log_number(directory, base_name, ext): existing_files = [name for name in os.listdir(directory) if name.startswith(base_name) and name.endswith(ext)] if not existing_files: return 1 else: numbers = [int(name[len(base_name):-len(ext)]) for name in existing_files] return max(numbers) + 1 current_log_number = get_next_log_number(log_dir, base_filename, extension) - 1 current_log_file = os.path.join(log_dir, f\\"{base_filename}{current_log_number}{extension}\\") # Check if the current log file exists and its size if not os.path.exists(current_log_file) or os.path.getsize(current_log_file) >= max_size: current_log_number += 1 current_log_file = os.path.join(log_dir, f\\"{base_filename}{current_log_number}{extension}\\") with open(current_log_file, \\"a\\") as log_file: log_file.write(log_message + \\"n\\")"},{"question":"# Problem Statement You are given a `LinkedList` class that supports basic linked list operations such as insertion, deletion, and traversal. Your task is to extend this functionality by adding a new method to reverse the linked list. # Function Signature ```python class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def insert(self, data): This method inserts a new node with the provided data at the end of the linked list. pass def delete(self, key): This method deletes the first occurrence of a node with the provided data from the linked list. pass def traverse(self): This method returns a list containing all the elements in the linked list. pass def reverse(self): This method should reverse the linked list in place and return the reversed linked list. pass ``` # Input & Output - **Input**: - No input parameters are required for the `reverse` method. The method will utilize the internal state of the linked list. - **Output**: - The `reverse` method should modify the linked list in-place and return the `LinkedList` object itself. # Examples 1. **Example 1**: ```python l = LinkedList() l.insert(1) l.insert(2) l.insert(3) l.reverse() print(l.traverse()) ``` **Output**: ``` [3, 2, 1] ``` 2. **Example 2**: ```python l = LinkedList() l.insert(5) l.reverse() print(l.traverse()) ``` **Output**: ``` [5] ``` 3. **Example 3**: ```python l = LinkedList() l.insert(4) l.insert(3) l.insert(2) l.insert(1) l.reverse() print(l.traverse()) ``` **Output**: ``` [1, 2, 3, 4] ``` # Constraints - The linked list will contain at most 10<sup>5</sup> nodes. # Notes - You may assume that the class `LinkedList` and the nested `Node` class are defined as above. - The traversal method should return the elements in the order they appear in the linked list. Implement the `reverse` method in the `LinkedList` class.","solution":"class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def insert(self, data): new_node = Node(data) if not self.head: self.head = new_node return temp = self.head while temp.next: temp = temp.next temp.next = new_node def delete(self, key): temp = self.head if temp is not None: if temp.data == key: self.head = temp.next temp = None return prev = None while temp is not None: if temp.data == key: break prev = temp temp = temp.next if temp == None: return prev.next = temp.next temp = None def traverse(self): elems = [] temp = self.head while temp: elems.append(temp.data) temp = temp.next return elems def reverse(self): prev = None current = self.head while current: next_node = current.next current.next = prev prev = current current = next_node self.head = prev return self"},{"question":"# Second Maximum in List Write a function `second_maximum(numbers: List[int]) -> int` that takes a list of integers and returns the second highest number in the list. The list will contain at least two distinct integers. Input - `numbers`: A list of integers with length at least 2. Output - An integer representing the second highest number in the list. Constraints - The list will contain at least two distinct integers. - All integers in the list are within the range ([-10^5, 10^5]). # Examples ```python >>> second_maximum([10, 20, 4, 45, 99]) 45 >>> second_maximum([12, 35, 1, 10, 34, 1]) 34 >>> second_maximum([-10, -5, -20, -8]) -8 ``` Notes - You should not use any pre-built library functions specifically for finding the second maximum (e.g., `heapq.nlargest`). - Consider performance and edge cases, such as lists with repeated elements or all negative values.","solution":"from typing import List def second_maximum(numbers: List[int]) -> int: Finds the second highest number in a list of integers. Arguments: numbers -- List of integers with a minimum length of 2. Returns: The second largest integer in the list. # Initialize the maximum and second maximum values. first_max = float(\'-inf\') second_max = float(\'-inf\') for num in numbers: if num > first_max: # Update both first and second max when a new max is found. second_max = first_max first_max = num elif num > second_max and num < first_max: # Update the second max if the current number is between the first and second max. second_max = num return second_max"},{"question":"# Grocery Store Inventory Management System You are tasked with creating a simple inventory management system for a grocery store. The system should allow for adding, updating, and querying products in the inventory. Each product has a name, quantity, and price. Task Requirements 1. **Class Product**: - Create a class `Product` that includes the product\'s name, quantity, and price. 2. **Class Inventory**: - Implement the class `Inventory` that should support the following methods: - `add_product(name: str, quantity: int, price: float) -> None` - `update_product(name: str, quantity: int, price: float) -> None` - `query_product(name: str) -> Tuple[int, float]` - `list_products() -> List[Tuple[str, int, float]]` 3. **Main Logic**: - Initialize an inventory and perform a series of add, update, and query operations. - Print a summary of all products in the inventory after the operations. Function Signatures You should implement the following classes and methods: 1. `class Product:` - `__init__(self, name: str, quantity: int, price: float) -> None` 2. `class Inventory:` - `__init__(self) -> None` - `add_product(self, name: str, quantity: int, price: float) -> None` - `update_product(self, name: str, quantity: int, price: float) -> None` - `query_product(self, name: str) -> Tuple[int, float]` - `list_products(self) -> List[Tuple[str, int, float]]` Input & Output Format - **Input**: No direct input. Actions are performed within the main execution. - **Output**: Print the inventory products and their details after modifications. Example ```python class Product: def __init__(self, name, quantity, price): self.name = name self.quantity = quantity self.price = price class Inventory: def __init__(self): self.products = {} def add_product(self, name, quantity, price): if name in self.products: raise ValueError(\\"Product already exists\\") self.products[name] = Product(name, quantity, price) def update_product(self, name, quantity, price): if name not in self.products: raise ValueError(\\"Product does not exist\\") self.products[name].quantity = quantity self.products[name].price = price def query_product(self, name): if name not in self.products: raise ValueError(\\"Product does not exist\\") product = self.products[name] return (product.quantity, product.price) def list_products(self): return [(product.name, product.quantity, product.price) for product in self.products.values()] def main(): inventory = Inventory() # Adding products inventory.add_product(\\"Apples\\", 50, 0.5) inventory.add_product(\\"Bananas\\", 100, 0.2) # Updating a product inventory.update_product(\\"Apples\\", 60, 0.45) # Querying a product quantity, price = inventory.query_product(\\"Apples\\") print(f\\"Query Apples: Quantity={quantity}, Price={price:.2f}\\") # Listing all products products = inventory.list_products() for name, quantity, price in products: print(f\\"{name} - Quantity: {quantity}, Price: {price:.2f}\\") if __name__ == \\"__main__\\": main() ``` Constraints - Ensure to handle cases where product names are duplicated or not found. - Validate the product\'s attributes (quantity should be non-negative, price should be non-negative, etc.). - The system should handle up to 1000 products efficiently.","solution":"class Product: def __init__(self, name: str, quantity: int, price: float) -> None: self.name = name self.quantity = quantity self.price = price class Inventory: def __init__(self) -> None: self.products = {} def add_product(self, name: str, quantity: int, price: float) -> None: if name in self.products: raise ValueError(\\"Product already exists\\") if quantity < 0 or price < 0: raise ValueError(\\"Quantity and price must be non-negative\\") self.products[name] = Product(name, quantity, price) def update_product(self, name: str, quantity: int, price: float) -> None: if name not in self.products: raise ValueError(\\"Product does not exist\\") if quantity < 0 or price < 0: raise ValueError(\\"Quantity and price must be non-negative\\") self.products[name].quantity = quantity self.products[name].price = price def query_product(self, name: str) -> tuple: if name not in self.products: raise ValueError(\\"Product does not exist\\") product = self.products[name] return (product.quantity, product.price) def list_products(self) -> list: return [(product.name, product.quantity, product.price) for product in self.products.values()]"},{"question":"# Coding Challenge: Simple E-Commerce Inventory System Your task is to create a Python class that manages an inventory system for an e-commerce platform. The inventory system will keep track of different product categories, their respective items, and stock levels. Your implementation should provide methods to add new product categories, add items to categories, update stock levels, and fetch details of a specific item or category. Class Definition ```python class InventorySystem: A class representing an inventory system for an e-commerce platform. def __init__(self): Initialize the inventory with an empty dictionary. pass def add_category(self, category_name: str) -> None: Add a new product category to the inventory with the given name. Args: category_name (str): The name of the product category to add. Returns: None pass def add_item(self, category_name: str, item_name: str, stock: int) -> None: Add a new item to a given category with the specified stock level. Args: category_name (str): The name of the category to add the item to. item_name (str): The name of the item to add. stock (int): The initial stock level of the item. Returns: None pass def update_stock(self, category_name: str, item_name: str, stock: int) -> None: Update the stock level of an existing item in a given category. Args: category_name (str): The name of the category containing the item. item_name (str): The name of the item to update. stock (int): The new stock level of the item. Returns: None pass def get_item(self, category_name: str, item_name: str) -> dict: Fetch the details of a specific item in a given category. Args: category_name (str): The name of the category containing the item. item_name (str): The name of the item to fetch. Returns: dict: A dictionary containing the item\'s details such as stock level. An error message if the category or item does not exist. pass def get_category(self, category_name: str) -> dict: Fetch the details of a specific category and its items. Args: category_name (str): The name of the category to fetch. Returns: dict: A dictionary containing the category details and its items. An error message if the category does not exist. pass ``` # Instructions 1. **Category Management**: - Implement the `add_category` method to add new product categories. - Ensure categories are unique and provide appropriate error handling if a duplicate category is added. 2. **Item Management**: - Implement the `add_item` method to add new items to an existing category. - Ensure items within a category are unique and update stock levels if item already exists. - Implement the `update_stock` method to update stock levels of an existing item. 3. **Data Retrieval**: - Implement the `get_item` method to fetch details (e.g., stock level) of a specific item from a category. - Implement the `get_category` method to fetch details of all items within a specific category. 4. **Error Handling**: - Include meaningful error messages for the following scenarios: - Adding a duplicate category. - Adding an item to a non-existent category. - Updating stock or fetching details of a non-existent item or category. - Handling input validation for negative stock levels. 5. **Testing**: - Write tests covering various scenarios, including adding categories, adding/updating items, fetching item/category details, and handling error cases. # Constraints - Use Python 3.6 or later. - You can utilize dictionaries or other relevant data structures for implementing the inventory system. - The initial inventory is empty. ```python class InventorySystem: def __init__(self): self.inventory = {} def add_category(self, category_name: str) -> None: if category_name in self.inventory: raise ValueError(f\\"Category \'{category_name}\' already exists.\\") self.inventory[category_name] = {} def add_item(self, category_name: str, item_name: str, stock: int) -> None: if stock < 0: raise ValueError(\\"Stock cannot be negative.\\") if category_name not in self.inventory: raise ValueError(f\\"Category \'{category_name}\' does not exist.\\") if item_name in self.inventory[category_name]: self.inventory[category_name][item_name] += stock else: self.inventory[category_name][item_name] = stock def update_stock(self, category_name: str, item_name: str, stock: int) -> None: if stock < 0: raise ValueError(\\"Stock cannot be negative.\\") if category_name not in self.inventory or item_name not in self.inventory[category_name]: raise ValueError(f\\"Item \'{item_name}\' in category \'{category_name}\' does not exist.\\") self.inventory[category_name][item_name] = stock def get_item(self, category_name: str, item_name: str) -> dict: if category_name not in self.inventory or item_name not in self.inventory[category_name]: return {\\"error\\": f\\"Item \'{item_name}\' in category \'{category_name}\' does not exist.\\"} return {item_name: self.inventory[category_name][item_name]} def get_category(self, category_name: str) -> dict: if category_name not in self.inventory: return {\\"error\\": f\\"Category \'{category_name}\' does not exist.\\"} return self.inventory[category_name] if __name__ == \\"__main__\\": # Sample usage inv = InventorySystem() inv.add_category(\\"Electronics\\") inv.add_item(\\"Electronics\\", \\"Laptop\\", 10) inv.add_item(\\"Electronics\\", \\"Smartphone\\", 5) print(inv.get_item(\\"Electronics\\", \\"Laptop\\")) print(inv.get_category(\\"Electronics\\")) inv.update_stock(\\"Electronics\\", \\"Laptop\\", 7) print(inv.get_item(\\"Electronics\\", \\"Laptop\\")) ``` # Example ```python >>> inv = InventorySystem() >>> inv.add_category(\\"Books\\") >>> inv.add_item(\\"Books\\", \\"Python 101\\", 50) >>> inv.get_item(\\"Books\\", \\"Python 101\\") {\'Python 101\': 50} >>> inv.get_category(\\"Books\\") {\'Python 101\': 50} >>> inv.update_stock(\\"Books\\", \\"Python 101\\", 30) >>> inv.get_item(\\"Books\\", \\"Python 101\\") {\'Python 101\': 30} ``` Ensure your class handles the specified requirements and is tested efficiently.","solution":"class InventorySystem: def __init__(self): self.inventory = {} def add_category(self, category_name: str) -> None: if category_name in self.inventory: raise ValueError(f\\"Category \'{category_name}\' already exists.\\") self.inventory[category_name] = {} def add_item(self, category_name: str, item_name: str, stock: int) -> None: if stock < 0: raise ValueError(\\"Stock cannot be negative.\\") if category_name not in self.inventory: raise ValueError(f\\"Category \'{category_name}\' does not exist.\\") self.inventory[category_name][item_name] = self.inventory[category_name].get(item_name, 0) + stock def update_stock(self, category_name: str, item_name: str, stock: int) -> None: if stock < 0: raise ValueError(\\"Stock cannot be negative.\\") if category_name not in self.inventory or item_name not in self.inventory[category_name]: raise ValueError(f\\"Item \'{item_name}\' in category \'{category_name}\' does not exist.\\") self.inventory[category_name][item_name] = stock def get_item(self, category_name: str, item_name: str) -> dict: if category_name not in self.inventory or item_name not in self.inventory[category_name]: return {\\"error\\": f\\"Item \'{item_name}\' in category \'{category_name}\' does not exist.\\"} return {item_name: self.inventory[category_name][item_name]} def get_category(self, category_name: str) -> dict: if category_name not in self.inventory: return {\\"error\\": f\\"Category \'{category_name}\' does not exist.\\"} return self.inventory[category_name]"},{"question":"Problem Statement You are given an array of integers and an integer `threshold`. Write a function that determines the minimum length of a contiguous subarray, of which the sum is greater than or equal to the given `threshold`. If there is no such subarray, return 0 instead. # Function Signature ```python def min_subarray_length(nums: List[int], threshold: int) -> int: ``` # Input - `nums`: A list of integers representing the array. - `threshold`: An integer representing the target sum for the subarray. # Output - Return an integer representing the minimum length of the contiguous subarray whose sum is greater than or equal to the threshold. If no such subarray exists, return 0. # Constraints - The length of `nums` is in the range [0, 100000]. - `-10^5 <= nums[i] <= 10^5` - `-10^9 <= threshold <= 10^9` # Example Consider the below array and threshold: ```python nums = [2, 3, 1, 2, 4, 3] threshold = 7 assert min_subarray_length(nums, threshold) == 2 # The subarray [4,3] has the minimum length nums = [1, 4, 4] threshold = 4 assert min_subarray_length(nums, threshold) == 1 # The subarray [4] has the minimum length nums = [1, 1, 1, 1] threshold = 4 assert min_subarray_length(nums, threshold) == 4 # The subarray [1,1,1,1] is the only subarray with the sum >= 4 ``` # Notes - Consider edge cases including an empty array scenario or when all elements are negative. - Be aware of the performance of your solution and try to achieve the most optimal time complexity.","solution":"from typing import List def min_subarray_length(nums: List[int], threshold: int) -> int: n = len(nums) if n == 0: return 0 min_length = float(\'inf\') current_sum = 0 start_index = 0 for end_index in range(n): current_sum += nums[end_index] while current_sum >= threshold: min_length = min(min_length, end_index - start_index + 1) current_sum -= nums[start_index] start_index += 1 return 0 if min_length == float(\'inf\') else min_length"},{"question":"# Unique Binary Trees with N Nodes You are tasked with writing a function that calculates the number of unique Binary Search Trees (BSTs) that can be formed using `n` distinct nodes. This is a classic problem in combinatorial mathematics, which relates to the Catalan numbers. Function Signature ```python def num_trees(n: int) -> int: Parameters: - n (int): The number of distinct nodes. Returns: - int: The number of unique BSTs that can be formed. Constraints: - Handle edge cases effectively. - Ensure the solution is efficient enough for large values of n. ``` Input - A single integer `n` representing the number of distinct nodes. Output - An integer representing the number of unique BSTs that can be formed using `n` distinct nodes. Example ```python >>> num_trees(3) 5 >>> num_trees(1) 1 >>> num_trees(0) 1 >>> num_trees(5) 42 ``` Explanation - For `n = 0`, the number of unique BSTs is 1 (an empty tree). - For `n = 1`, the number of unique BSTs is 1 (a single node). - For `n = 3`, the number of unique BSTs is 5. The possible BSTs are `[1, 2, 3]`, `[1, 3, 2]`, `[2, 1, 3]`, `[2, 3, 1]`, and `[3, 1, 2]`. Constraints - `0 <= n <= 20` - You should handle invalid inputs, such as non-integer types and negative integers. Note: The general solution involves using a dynamic programming approach to compute the nth Catalan number, which represents the number of unique BSTs with `n` nodes. The nth Catalan number can be calculated using the formula: [ C(n) = frac{(2n)!}{(n+1)!n!} ]","solution":"def num_trees(n: int) -> int: Returns the number of unique Binary Search Trees (BSTs) that can be formed using `n` distinct nodes. Parameters: - n (int): The number of distinct nodes. Returns: - int: The number of unique BSTs that can be formed. if n < 0: raise ValueError(\\"n must be a non-negative integer\\") # Base case if n == 0 or n == 1: return 1 # DP array to store the number of unique BSTs for each count of nodes dp = [0] * (n + 1) dp[0] = dp[1] = 1 # Fill the dp array for nodes in range(2, n + 1): for root in range(1, nodes + 1): dp[nodes] += dp[root - 1] * dp[nodes - root] return dp[n]"},{"question":"# List/Array Manipulations Given a list of integers, complete the following tasks to demonstrate your understanding of list manipulations. Implement the specified methods and ensure they function correctly within the context provided. Task 1: Remove Duplicates Implement a function `remove_duplicates(lst)` that removes all duplicate values from the list while preserving the original order of elements. ```python def remove_duplicates(lst: List[int]) -> List[int]: This function removes duplicate values from the list while maintaining the original order. >>> remove_duplicates([1, 2, 2, 3, 4, 4, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([4, 5, 4, 5, 6, 7, 6]) [4, 5, 6, 7] ``` Task 2: Rotate List Implement a function `rotate_list(lst, k)` that rotates the list to the right by `k` steps. For example, rotating the list [1, 2, 3, 4, 5] by 2 steps would result in [4, 5, 1, 2, 3]. ```python def rotate_list(lst: List[int], k: int) -> List[int]: This function rotates the list to the right by k steps. >>> rotate_list([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_list([1, 2], 3) [2, 1] ``` Task 3: Find Intersection Implement a function `find_intersection(lst1, lst2)` that finds and returns the intersection of two lists. The intersection should contain only unique values that are present in both lists. ```python def find_intersection(lst1: List[int], lst2: List[int]) -> List[int]: This function finds and returns the intersection of two lists with unique values. >>> find_intersection([1, 2, 3, 4], [3, 4, 5, 6]) [3, 4] >>> find_intersection([1, 2, 2, 3], [2, 2, 3, 3]) [2, 3] ``` Input and Output * **Input**: * For remove_duplicates(lst): A list of integers. * For rotate_list(lst, k): A list of integers and an integer `k`. * For find_intersection(lst1, lst2): Two lists of integers. * **Output**: * For remove_duplicates(lst): Returns a list with duplicates removed. * For rotate_list(lst, k): Returns a list rotated by `k` steps to the right. * For find_intersection(lst1, lst2): Returns a list containing the intersection of the two input lists. Ensure correctness and efficiency in your implementations. Consider edge cases like empty lists, lists with one element, etc.","solution":"from typing import List def remove_duplicates(lst: List[int]) -> List[int]: This function removes duplicate values from the list while maintaining the original order. seen = set() result = [] for item in lst: if item not in seen: seen.add(item) result.append(item) return result def rotate_list(lst: List[int], k: int) -> List[int]: This function rotates the list to the right by k steps. if not lst: return lst k = k % len(lst) # Handle cases where k is larger than the length of the list return lst[-k:] + lst[:-k] def find_intersection(lst1: List[int], lst2: List[int]) -> List[int]: This function finds and returns the intersection of two lists with unique values. set1 = set(lst1) set2 = set(lst2) return list(set1 & set2)"},{"question":"# Domains and Depths in a Graph Given an undirected graph with `n` nodes and `m` edges, you need to find out the maximum depth of each connected component in the graph. The depth of a node in a component is the maximum distance from that node to any other node in the same component. Implement a function: ```python def find_max_depths(n: int, edges: List[Tuple[int, int]]) -> List[int]: pass ``` **Input**: - `n` (int): The number of nodes in the graph. - `edges` (List[Tuple[int, int]]): A list of `m` edges, where each edge is represented as a tuple `(u, v)`, indicating an undirected edge between nodes `u` and `v`. **Output**: - Return a list of integers where each integer represents the maximum depth of the connected component to which the respective node belongs. The output list should be of length `n`, where the `i-th` element corresponds to the maximum depth for the connected component of node `i`. **Example**: ```python assert find_max_depths(5, [(0, 1), (1, 2), (3, 4)]) == [2, 2, 2, 1, 1] assert find_max_depths(6, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)]) == [5, 5, 5, 5, 5, 5] ``` **Constraints**: - The nodes are 0-indexed and each node number will be in the range `[0, n-1]`. - It is guaranteed that there are no self-loops and no repeated edges. # Detail: 1. For each connected component in the graph, determine the node with the maximum depth. 2. For each node in the component, calculate the maximum distance to any other node. 3. Return the depth for each node in the corresponding index of the output list. Your solution should efficiently determine the connected components and calculate the maximum depths for each one.","solution":"from typing import List, Tuple from collections import defaultdict, deque def bfs_max_depth(start, graph): Perform BFS to find the farthest node and its distance from the start node visited = set() queue = deque([(start, 0)]) farthest_node, max_distance = start, 0 while queue: node, distance = queue.popleft() if node not in visited: visited.add(node) if distance > max_distance: max_distance = distance farthest_node = node for neighbor in graph[node]: if neighbor not in visited: queue.append((neighbor, distance + 1)) return farthest_node, max_distance def find_max_depths(n: int, edges: List[Tuple[int, int]]) -> List[int]: # Build the graph using adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) max_depths = [-1] * n # Initialize the result list with -1 to indicate unvisited nodes visited_nodes = set() for i in range(n): if i not in visited_nodes: # Find one node (A) in the component and the farthest node from it farthest_node_a, _ = bfs_max_depth(i, graph) # Find the farthest node (B) from this farthest node (A) to get the maximum depth farthest_node_b, max_depth = bfs_max_depth(farthest_node_a, graph) component_nodes = set() # Second BFS to collect all nodes in this component and propagate max depth queue = deque([farthest_node_a]) while queue: node = queue.popleft() if node not in component_nodes: component_nodes.add(node) for neighbor in graph[node]: if neighbor not in component_nodes: queue.append(neighbor) # Set the max depth for all nodes in this component for node in component_nodes: max_depths[node] = max_depth visited_nodes.add(node) return max_depths"},{"question":"# Coding Assessment Question Handling Duplicates in a Sorted Array You are given a sorted array of integers where the array may contain duplicate elements. Your task is to create a function that removes all duplicates in place and returns the new length of the array. Additionally, the function should modify the array such that the first part of the array contains only the unique elements in sorted order. # Problem Statement Function: remove_duplicates Write a function `remove_duplicates` that: - Takes as input a sorted list `nums` of integers. - Modifies the input list in place to remove all duplicate elements. - Returns an integer representing the new length of the modified list with unique elements. Constraints: 1. Do not use any extra space for another array; you must do this in place with constant memory. 2. Array `nums` should be modified such that the first few positions reflect the unique elements in sorted order. 3. The remaining elements beyond the new length are irrelevant. Specifications: - Input: A sorted list of integers `nums`. - Output: An integer representing the new length of the array with unique elements. Example Scenario Given the sorted list `nums = [1, 1, 2, 2, 3, 3, 4]`: ```python new_length = remove_duplicates(nums) print(new_length) # Output should be 4 print(nums[:new_length]) # Output should be [1, 2, 3, 4] ``` This demonstrates an example where duplicates are removed from the array. The array `[1, 1, 2, 2, 3, 3, 4]` is modified in place to `[1, 2, 3, 4, _, _, _]` with a new length of 4. # Note: - You should not allocate extra space or create another array for this task. The function should work with the original array passed as an argument. Write your implementation in a function `remove_duplicates` based on the logic of modifying the array in place.","solution":"def remove_duplicates(nums): Removes duplicates from a sorted list of integers in place. Returns the new length of the list with unique elements. :param nums: List[int] - A sorted list of integers. :return: int - The new length of the list with unique elements. if not nums: return 0 unique_index = 0 for i in range(1, len(nums)): if nums[i] != nums[unique_index]: unique_index += 1 nums[unique_index] = nums[i] return unique_index + 1"},{"question":"# Coding Assessment Question **Scenario**: You are working on a text processing system aimed at enhancing search functionalities. One of your tasks is to implement an efficient solution that can preprocess a large string and subsequently support fast pattern matching queries. You decide that a Suffix Array would be an ideal data structure for this purpose. **Task**: Implement a Suffix Array to preprocess the string and support efficient pattern matching queries. **Requirements**: 1. **Initialization**: - Provide a class `SuffixArray` that initializes with a given string. 2. **Search Operation**: - Implement a `search` method to find and return the starting index of all occurrences of a given pattern in the string. 3. **Suffix Array Construction**: - The constructor should build the suffix array for the string in `O(n log n)` time complexity where `n` is the length of the string. # Function Details - **Class**: `SuffixArray` - **Constructor**: - `__init__(self, text: str) -> None` - Initializes the suffix array and any necessary auxiliary data structures. - **Methods**: - `search(self, pattern: str) -> List[int]` - Returns a list of starting indices of all occurrences of the pattern in the string. **Constraints**: - The length of the string `n` where `1 <= n <= 10^5`. - The length of the pattern `p` where `1 <= p <= 10^3`. - The string contains only lowercase English letters. # Input Format: - The initial string followed by multiple pattern search queries. - Example: `text = \\"banana\\"` # Output Format: - For each `search` operation, output the list of starting indices where the pattern is found. # Example: ```python text = \\"banana\\" sa = SuffixArray(text) print(sa.search(\\"ana\\")) # Output: [1, 3] print(sa.search(\\"nan\\")) # Output: [2] print(sa.search(\\"ban\\")) # Output: [0] print(sa.search(\\"apple\\")) # Output: [] ``` Note: The search operation should return the results in sorted order of indices. If the pattern does not occur in the string, return an empty list.","solution":"from typing import List class SuffixArray: def __init__(self, text: str) -> None: self.text = text self.suffix_array = self.build_suffix_array(text) def build_suffix_array(self, text: str) -> List[int]: suffixes = [(text[i:], i) for i in range(len(text))] sorted_suffixes = sorted(suffixes) suffix_array = [suffix[1] for suffix in sorted_suffixes] return suffix_array def search(self, pattern: str) -> List[int]: l, r = 0, len(self.suffix_array) - 1 result = [] # Find the first occurrence using binary search while l <= r: mid = (l + r) // 2 if self.text[self.suffix_array[mid]:].startswith(pattern): # Find lower bound start = mid while start > 0 and self.text[self.suffix_array[start - 1]:].startswith(pattern): start -= 1 # Find upper bound end = mid while end < len(self.suffix_array) - 1 and self.text[self.suffix_array[end + 1]:].startswith(pattern): end += 1 result.extend(self.suffix_array[i] for i in range(start, end + 1)) break elif self.text[self.suffix_array[mid]:] < pattern: l = mid + 1 else: r = mid - 1 return sorted(result)"},{"question":"# Coding Assessment Question Weather Pattern Analysis **Scenario:** Your new assignment is to analyze weather patterns in various cities to predict future temperature trends. One of the key tasks is to identify and isolate days with extreme temperatures in a given temperature dataset. **Task:** Create a function to identify heatwave days from a given list of daily temperatures recorded for a specific city over a period of time. **Requirements:** 1. Implement the function `identify_heatwave_days(temperatures: list[float], threshold: float, consecutive_days: int) -> list[int]` that computes and returns the indices of the days that are part of a heatwave. 2. Ensure that your function efficiently processes data, even for a lengthy list of temperatures. **Implementation Details:** 1. **Input:** * `temperatures` (list of `float`): The list of daily temperatures recorded over a period of time. * `threshold` (float): The temperature value above which days are considered hot. * `consecutive_days` (int): The number of consecutive hot days required to classify as a heatwave. 2. **Output:** * A list of integers representing the indices of the days that are part of a heatwave. 3. **Requirements:** * Your function should appropriately handle cases where the consecutive hot days span across the beginning or the end of the dataset. * Provide a brief explanation showcasing the efficiency of your approach. **Constraints:** * The `temperatures` list will have at least one day and up to 365 days of data. * The `threshold` will be a positive float representing the temperature. * The `consecutive_days` parameter will be a positive integer (1 <= consecutive_days <= 10). Here is a starter template to help you get started: ```python def identify_heatwave_days(temperatures: list[float], threshold: float, consecutive_days: int) -> list[int]: heatwave_indices = [] count = 0 for i, temp in enumerate(temperatures): if temp > threshold: count += 1 if count >= consecutive_days: if not heatwave_indices or heatwave_indices[-1] != i - consecutive_days + 1: heatwave_indices.extend(range(i - consecutive_days + 1, i + 1)) else: count = 0 return heatwave_indices # Example usage if __name__ == \\"__main__\\": example_temperatures = [32.5, 33.6, 35.1, 36.8, 37.2, 36.5, 34.3, 33.0, 35.2, 36.5, 37.1] threshold_temperature = 35.0 required_consecutive_days = 3 heatwave_days = identify_heatwave_days(example_temperatures, threshold_temperature, required_consecutive_days) print(\\"Heatwave days indices:\\", heatwave_days) ``` **Explanation:** - The function `identify_heatwave_days` iterates through the temperature list, checking if the current day\'s temperature exceeds the threshold. - If the count of consecutive hot days reaches the required number, indices of those days are added to the list, ensuring no duplicates. - The provided example usage should be tested with different datasets to ensure robustness and correctness. Ensure the correctness of your implementation with several test cases and provide corresponding results.","solution":"def identify_heatwave_days(temperatures: list[float], threshold: float, consecutive_days: int) -> list[int]: heatwave_indices = [] count = 0 for i, temp in enumerate(temperatures): if temp > threshold: count += 1 if count >= consecutive_days: for j in range(i - consecutive_days + 1, i + 1): if j not in heatwave_indices: heatwave_indices.append(j) else: count = 0 return heatwave_indices # Example usage if __name__ == \\"__main__\\": example_temperatures = [32.5, 33.6, 35.1, 36.8, 37.2, 36.5, 34.3, 33.0, 35.2, 36.5, 37.1] threshold_temperature = 35.0 required_consecutive_days = 3 heatwave_days = identify_heatwave_days(example_temperatures, threshold_temperature, required_consecutive_days) print(\\"Heatwave days indices:\\", heatwave_days)"},{"question":"# Problem Statement You are given a grid-based maze with dimensions `m x n`. The task is to implement a function that finds the number of distinct paths from the top-left corner to the bottom-right corner of the maze, considering that the maze contains some blocked cells that cannot be part of any path. # Requirements Write a function `count_paths(maze: List[List[int]]) -> int` that: - Takes a 2D integer list `maze` where `0` represents a free cell, and `1` represents a blocked cell. - Returns the number of distinct paths from the top-left corner (0,0) to the bottom-right corner (m-1,n-1). You can only move right or down from a free cell. # Constraints - The dimensions of the maze `m` (rows) and `n` (columns) will be between `1` and `100`, inclusive. - If the starting cell (0,0) or the destination cell (m-1, n-1) is blocked, return `0` as no path is possible. # Function Signature ```python def count_paths(maze: List[List[int]]) -> int: pass ``` # Example ```python >>> count_paths([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> count_paths([[0, 1], [0, 0]]) 1 >>> count_paths([[1, 0], [0, 0]]) 0 ``` # Explanation - In the first example, there are two possible paths avoiding the blocked cell at `(1,1)`. The paths are: right -> right -> down -> down, and down -> down -> right -> right. - In the second example, there is only one possible path avoiding the blocked cell at `(0,1)`. The path is: down -> right. - In the third example, the starting cell `(0,0)` is blocked, thus no path is available. Hence the count is `0`. # Additional Context: The problem is related to dynamic programming and valid pathfinding in grids. Utilize these principles to solve the problem accurately while considering blocked cells.","solution":"def count_paths(maze): Finds the number of distinct paths from the top-left to bottom-right in a grid-based maze. # If start or end point is blocked, return 0 m, n = len(maze), len(maze[0]) if maze[0][0] == 1 or maze[m-1][n-1] == 1: return 0 # Create a DP table to store path counts dp = [[0] * n for _ in range(m)] # Initialize the starting point dp[0][0] = 1 # Fill the DP table for i in range(m): for j in range(n): if maze[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"# Problem Statement You are working with strings and need to perform two specific operations: reversing the words in a sentence and checking if a string is a palindrome. You are required to implement the following two tasks: 1. **Reverse Words in a Sentence**: Write a function named `reverse_words` that takes a string as input and returns a new string with the words in reversed order. Words are defined as sequences of characters separated by spaces. If the input is not a string or is an empty string, your function should raise a `ValueError`. 2. **Check if a String is a Palindrome**: Write a function named `is_palindrome` that takes a string as input and returns a boolean indicating whether the string is a palindrome. A palindrome is a string that reads the same backward as forward, ignoring case, spaces, and punctuation. If the input is not a string or is an empty string, your function should raise a `ValueError`. # Requirements * Implement the functions as per the provided function prototypes: ```python def reverse_words(sentence: str) -> str: # Your code here def is_palindrome(text: str) -> bool: # Your code here ``` * **Input Constraints**: * `sentence` and `text` are strings. * A valid input `sentence` or `text` is at least one character long. * The `reverse_words` function should handle multiple spaces and maintain capitalization and punctuation within the words themselves. # Examples The `reverse_words` function should work as follows: * `reverse_words(\\"hello world\\")` should return \\"world hello\\". * `reverse_words(\\"The quick brown fox\\")` should return \\"fox brown quick The\\". * `reverse_words(\\" space at ends \\")` should return \\"ends at space\\". The `is_palindrome` function should work as follows: * `is_palindrome(\\"A man a plan a canal Panama\\")` should return `True`. * `is_palindrome(\\"Hello\\")` should return `False`. * `is_palindrome(\\"No lemon, no melon\\")` should return `True`. # Notes: * Ensure that your code efficiently handles edge cases, such as strings with various types of white space and punctuation. * Use appropriate error handling to manage invalid inputs. * The `is_palindrome` function should ignore case, spaces, and punctuation when determining if a string is a palindrome.","solution":"import re def reverse_words(sentence: str) -> str: Returns a new string with the words in reversed order. if not isinstance(sentence, str) or not sentence.strip(): raise ValueError(\\"Input must be a non-empty string\\") words = sentence.split() reversed_sentence = \' \'.join(reversed(words)) return reversed_sentence def is_palindrome(text: str) -> bool: Returns True if text is a palindrome, False otherwise. Ignores case, spaces, and punctuation. if not isinstance(text, str) or not text.strip(): raise ValueError(\\"Input must be a non-empty string\\") # Remove non-alphanumeric characters, convert to lowercase clean_text = re.sub(r\'[^A-Za-z0-9]\', \'\', text).lower() reversed_text = clean_text[::-1] return clean_text == reversed_text"},{"question":"# Context Sorting algorithms are fundamental concepts in computer science used to arrange data systematically. Knowing the inner workings of different sorting approaches enhances one\'s understanding of algorithm design. # Problem Statement Given an unsorted list of integers, write a function `quick_sort` that sorts the list using the QuickSort algorithm. The implementation should be efficient in terms of time complexity. # Function Signature ```python def quick_sort(arr: List[int]) -> List[int]: Sorts the given list of integers using the QuickSort algorithm. :param arr: List[int] - the list of unsorted integers. :return: List[int] - a new list of integers sorted in ascending order. ``` # Input * `arr` (List[int]): A list of integers that need to be sorted. # Output * A list of integers sorted in ascending order. # Constraints * The function should handle lists containing up to 10^4 integers. * The integers can be positive, negative, or zero. * The function should be able to handle lists with repeated elements. # Examples ```python >>> quick_sort([34, 7, 23, 32, 5, 62]) [5, 7, 23, 32, 34, 62] >>> quick_sort([3, -2, 5, 0, -1, 2, 1]) [-2, -1, 0, 1, 2, 3, 5] >>> quick_sort([1, 1, 1, 1]) [1, 1, 1, 1] ``` # Note * The implementation should ideally be done with an in-place partitioning method. * Ensure the function handles edge cases like an empty list or a list with a single element correctly without errors.","solution":"from typing import List def quick_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr else: pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right)"},{"question":"**Problem Statement:** Write a function `add_complex_numbers(lst)` that takes a list `lst` of tuples, where each tuple contains two integers representing the real and imaginary parts of a complex number. The function should return a tuple containing the sum of all the complex numbers in the format (real_part, imaginary_part). # Function Signature ```python def add_complex_numbers(lst: list) -> tuple: ``` # Input: * **lst (list)**: A list of tuples, where each tuple consists of two integers representing the real and imaginary parts of a complex number. The list will contain 1 to 1000 tuples. # Output: * **tuple**: A tuple containing two integers representing the real and imaginary parts of the sum of all complex numbers. # Constraints: * The integers within each tuple will be in the range [-10^6, 10^6]. # Example: ```python assert add_complex_numbers([(1, 2), (3, 4), (-1, -2)]) == (3, 4) assert add_complex_numbers([(5, -2), (-3, 4), (0, 0)]) == (2, 2) ``` # Implementation Requirements: Create a program that: 1. Iterates through the list of tuples. 2. Separately sums up the real and imaginary parts of the complex numbers. 3. Returns a tuple containing the total sum of real parts and the total sum of imaginary parts.","solution":"def add_complex_numbers(lst): Returns the sum of all complex numbers in the list. real_sum = 0 imaginary_sum = 0 for real, imaginary in lst: real_sum += real imaginary_sum += imaginary return (real_sum, imaginary_sum)"},{"question":"**Question:** You are developing a management system for an online retail store where frequent queries about the inventory are made. To efficiently handle stock updates and range sum queries on the inventory items, you decide to use a Segment Tree data structure for its capability to process such requests quickly. **TASK**: Create a class called `InventoryManager` that includes the following methods: 1. `__init__(self, stock: List[int])`: Initializes the class with a given list of inventory stock quantities. 2. `update_stock(self, index: int, quantity: int)`: Updates the stock at the given index with a new quantity. 3. `get_stock(self, index: int) -> int`: Retrieves the stock quantity at the given index. 4. `get_total_stock_in_interval(self, start: int, end: int) -> int`: Returns the sum of stock quantities within the interval `[start, end)` (inclusive of start, exclusive of end). **Function Signature**: ```python class InventoryManager: def __init__(self, stock: List[int]): pass def update_stock(self, index: int, quantity: int): pass def get_stock(self, index: int) -> int: pass def get_total_stock_in_interval(self, start: int, end: int) -> int: pass ``` **Constraints**: - 0 <= index < len(stock) - start <= end <= len(stock) **Performance Requirements**: - All operations should handle high frequency of updates and queries efficiently (hint: aim for O(log N) complexity for update and query operations). **Example**: ```python stock = [5, 10, 15, 20, 25, 30] im = InventoryManager(stock) # Update inventory stock im.update_stock(3, 22) # Retrieve a stock quantity print(im.get_stock(3)) # Output: 22 # Sum of stock in interval [1, 4) print(im.get_total_stock_in_interval(1, 4)) # Output: 47 (10 + 15 + 22) ``` Write your solution below:","solution":"class InventoryManager: def __init__(self, stock): self.n = len(stock) self.tree = [0] * (2 * self.n) self.build(stock) def build(self, stock): for i in range(self.n): self.tree[self.n + i] = stock[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def update_stock(self, index, quantity): pos = index + self.n self.tree[pos] = quantity while pos > 1: pos //= 2 self.tree[pos] = self.tree[pos * 2] + self.tree[pos * 2 + 1] def get_stock(self, index): return self.tree[self.n + index] def get_total_stock_in_interval(self, start, end): result = 0 start += self.n end += self.n while start < end: if start % 2 == 1: result += self.tree[start] start += 1 if end % 2 == 1: end -= 1 result += self.tree[end] start //= 2 end //= 2 return result"},{"question":"# Sum of Unique Digits Scenario: You are tasked with building a function for an educational tool that evaluates numbers. Students will input numbers, and your function will return the sum of all unique digits in the given numbers. This helps to understand digit manipulations and unique value calculations. Task: Write a function `sum_of_unique_digits` that determines the sum of all unique digits in a given integer. If a digit occurs more than once in the integer, it should only be considered once in the sum. # Function Signature: ```python def sum_of_unique_digits(number: int) -> int: pass ``` # Input: 1. `number` (int): A non-negative integer. # Output: - Returns an integer that is the sum of all unique digits in the given number. # Constraints: - The number is a non-negative integer. - 0 ≤ number ≤ 10^18 # Example: ```python # Example 1 assert sum_of_unique_digits(12345) == 15 # 1+2+3+4+5 # Example 2 assert sum_of_unique_digits(11111) == 1 # Only 1 is unique # Example 3 assert sum_of_unique_digits(91234934) == 19 # 9+1+2+3+4 # Example 4 assert sum_of_unique_digits(0) == 0 # Only 0 is unique ``` # Notes: - Only the unique occurrence of digits should be considered. - The function should handle large integers efficiently. - Ensure that duplicates are disregarded in the summation.","solution":"def sum_of_unique_digits(number: int) -> int: Returns the sum of all unique digits in the given number. :param number: A non-negative integer. :return: An integer that is the sum of all unique digits in the given number. unique_digits = set(str(number)) return sum(int(digit) for digit in unique_digits)"},{"question":"# Network Latency Optimizer Imagine you are developing a network latency optimizer, where you need to find the shortest path for data to travel between servers in a network. The network is represented as a directed weighted graph, where nodes represent servers and edges represent the time (in milliseconds) it takes for data to travel from one server to another. Your task is to implement the function `find_shortest_path` that takes the following parameters: 1. `servers` (List of strings): A list of server names. 2. `latencies` (Dict of tuple of strings to float): A dictionary where keys are tuples representing an edge between two servers (source, destination), and values are the latencies (weights) of these edges. 3. `start_server` (string): The name of the starting server. 4. `end_server` (string): The name of the destination server. Your function should return a tuple containing the shortest path as a list of servers (including the start and end servers) and the total latency as a float. # Function Signature ```python def find_shortest_path( servers: list, latencies: dict, start_server: str, end_server: str ) -> tuple: ``` # Input Constraints * All lists and dictionaries are non-empty. * All entries in `servers` are strings. * `latencies` dictionary contains valid server pairs. * `start_server` and `end_server` are both strings and are present in the `servers` list. * There is at least one valid path from `start_server` to `end_server`. # Example ```python servers = [\\"A\\", \\"B\\", \\"C\\", \\"D\\"] latencies = { (\\"A\\", \\"B\\"): 1.0, (\\"A\\", \\"C\\"): 4.0, (\\"B\\", \\"C\\"): 2.0, (\\"B\\", \\"D\\"): 6.0, (\\"C\\", \\"D\\"): 1.0 } start_server = \\"A\\" end_server = \\"D\\" find_shortest_path(servers, latencies, start_server, end_server) # Expected Output: ([\'A\', \'B\', \'C\', \'D\'], 4.0) ``` # Implementation Details - Use Dijkstra\'s algorithm to find the shortest path. - Handle edge cases, such as negative latencies (if applicable). - Validate input to ensure that all parameters are correctly formatted and that the starting and ending servers exist within the list of servers. - Use efficient data structures to maintain performance for larger networks.","solution":"import heapq from typing import List, Dict, Tuple def find_shortest_path( servers: List[str], latencies: Dict[Tuple[str, str], float], start_server: str, end_server: str ) -> Tuple[List[str], float]: def dijkstra(graph, start, goal): queue = [] heapq.heappush(queue, (0, start)) distances = {server: float(\'inf\') for server in servers} previous_nodes = {server: None for server in servers} distances[start] = 0 while queue: current_distance, current_node = heapq.heappop(queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node].items(): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance previous_nodes[neighbor] = current_node heapq.heappush(queue, (distance, neighbor)) # Reconstruct the shortest path path = [] current = goal while previous_nodes[current] is not None: path.insert(0, current) current = previous_nodes[current] if path: path.insert(0, start) return path, distances[goal] # Create graph representation graph = {server: {} for server in servers} for (src, dst), latency in latencies.items(): graph[src][dst] = latency return dijkstra(graph, start_server, end_server)"},{"question":"# Anagram Check You are given two strings and need to determine if one string is an anagram of the other. An anagram is a word formed by rearranging the letters of another word, using all the original letters exactly once. This problem will test your ability to manipulate and compare sets of characters. Function Signature ```python def are_anagrams(str1: str = \\"\\", str2: str = \\"\\") -> bool: ``` Input and Output Formats * **Input**: Two strings `str1` and `str2`. * **Constraints**: * The strings can contain alphanumeric characters and spaces. * Their lengths can range from zero to 1000 each. * **Output**: A boolean value `True` if `str1` and `str2` are anagrams of each other, otherwise `False`. Example ```python # Example 1 assert are_anagrams(\\"listen\\", \\"silent\\") == True # Example 2 assert are_anagrams(\\"triangle\\", \\"integral\\") == True # Example 3 assert are_anagrams(\\"apple\\", \\"pale\\") == False # Example 4 assert are_anagrams(\\"\\", \\"\\") == True # Example 5 assert are_anagrams(\\"School master\\", \\"The classroom\\") == True ``` Explanation 1. \\"listen\\" and \\"silent\\" use exactly the same characters with the same frequency. 2. \\"triangle\\" and \\"integral\\" are anagrams since their characters match perfectly. 3. \\"apple\\" and \\"pale\\" do not have the same quantity of characters (e.g., \'p\' appears twice in \\"apple\\" and only once in \\"pale\\"). 4. Two empty strings are trivially anagrams. 5. After normalizing the case and removing spaces, \\"School master\\" and \\"The classroom\\" can be rearranged to form the same sequence of characters. Instructions 1. Implement the function according to the provided signature. 2. Normalize the input by turning it into lowercase and ignoring whitespace. 3. Analyze the frequency of each character. 4. Compare the character frequencies of both strings to determine if they are anagrams.","solution":"def are_anagrams(str1: str = \\"\\", str2: str = \\"\\") -> bool: Determines if the two provided strings are anagrams of each other. Args: str1 (str): The first string. str2 (str): The second string. Returns: bool: True if str1 and str2 are anagrams, otherwise False. # Normalize by converting to lowercase and removing spaces normalized_str1 = \'\'.join(sorted(str1.replace(\\" \\", \\"\\").lower())) normalized_str2 = \'\'.join(sorted(str2.replace(\\" \\", \\"\\").lower())) # Compare the sorted versions of the normalized strings return normalized_str1 == normalized_str2"},{"question":"# Matrix Transformation with Fixed Constraints You are tasked with transforming a matrix such that for any cell in the matrix, if its value is zero, all elements in its row and column are set to zero as well, except for the given cell. # Task Implement a function `transform_matrix` that takes a 2-dimensional matrix as input and returns the transformed matrix as specified. # Function Signature ```python def transform_matrix(matrix: List[List[int]]) -> List[List[int]]: pass ``` # Input - **matrix**: A list of lists of integers representing the 2D matrix. The matrix will have dimensions `m x n` where `1 <= m, n <= 1000`. # Output - Returns a list of lists of integers representing the transformed matrix with the dimensions `m x n`. # Constraints - The matrix will contain only integer values. - Values could be positive, negative, or zero. # Example ```python matrix = [ [1, 2, 3, 4], [5, 0, 7, 8], [9, 10, 11, 12], [13, 14, 15, 0] ] result = transform_matrix(matrix) print(result) # Expected output: # [ # [1, 0, 3, 0], # [0, 0, 0, 0], # [9, 0, 11, 0], # [0, 0, 0, 0] # ] ``` # Explanation: 1. **Locate all zeros within the matrix** and record their positions. 2. **Transform the matrix** based on the recorded positions by setting all elements in the row and column of each zero to zero, except for the zero itself. # Note: Ensure that the matrix transformation is conducted efficiently, especially considering the potential size of the matrix (up to 1000x1000). Make necessary use of auxiliary storage to handle the transformation without impacting the input matrix during intermediate steps.","solution":"from typing import List def transform_matrix(matrix: List[List[int]]) -> List[List[int]]: m, n = len(matrix), len(matrix[0]) rows_to_zero = set() cols_to_zero = set() # First pass: identify all rows and columns that need to be zeroed for i in range(m): for j in range(n): if matrix[i][j] == 0: rows_to_zero.add(i) cols_to_zero.add(j) # Second pass: zero out identified rows for row in rows_to_zero: for j in range(n): if matrix[row][j] != 0: matrix[row][j] = 0 # Third pass: zero out identified columns for col in cols_to_zero: for i in range(m): if matrix[i][col] != 0: matrix[i][col] = 0 return matrix"},{"question":"# Question: Currency Converter You are required to create a function that converts an amount of money from one currency to another using exchange rates from two different APIs: ExchangeRate-API and CurrencyLayer. The function should handle cases where no valid API keys are provided, or the APIs return invalid data or mismatched rates. Function Signature: ```python def convert_currency(amount: float, from_currency: str, to_currency: str) -> float: Converts an amount from one currency to another using exchange rates from ExchangeRate-API and CurrencyLayer. Args: amount (float): The amount of money to convert. from_currency (str): The currency code of the initial currency (e.g., \'USD\'). to_currency (str): The currency code to convert to (e.g., \'EUR\'). Returns: float: The equivalent amount in the target currency. Raises: ValueError: If no API keys are provided or if valid exchange rates are not returned from any API. ``` Input & Output Formats: - **Input**: A float for the amount, and two strings representing the from and to currency codes. - **Output**: A float representing the converted amount in the target currency. Constraints: - You must use the `requests` library to make API calls. - If no valid API keys or responses are provided, raise a `ValueError` with the message \\"No API keys provided or valid data returned.\\" - Assume the provided helper constants and base URLs: ```python EXCHANGERATE_API_KEY = \\"\\" CURRENCY_LAYER_API_KEY = \\"\\" EXCHANGERATE_URL_BASE = \\"https://v6.exchangerate-api.com/v6/{key}/latest/{from_currency}\\" CURRENCY_LAYER_URL_BASE = \\"http://api.currencylayer.com/live?access_key={key}&currencies={to_currency}&source={from_currency}\\" ``` Sample Usage: ```python # Assuming valid API keys are set in the constants converted_amount = convert_currency(100, \'USD\', \'EUR\') print(converted_amount) # Expected output format: # 98.75 # This should be the converted amount based on the fetched exchange rates. ``` **Notes**: Both ExchangeRate-API and CurrencyLayer return JSON responses with current exchange rates, but the structure might differ. Your implementation should handle these differences appropriately while calculating the equivalent amount.","solution":"import requests EXCHANGERATE_API_KEY = \\"your_exchangerate_api_key\\" CURRENCY_LAYER_API_KEY = \\"your_currency_layer_api_key\\" EXCHANGERATE_URL_BASE = \\"https://v6.exchangerate-api.com/v6/{key}/latest/{from_currency}\\" CURRENCY_LAYER_URL_BASE = \\"http://api.currencylayer.com/live?access_key={key}&currencies={to_currency}&source={from_currency}\\" def fetch_exchange_rate_exchangerate_api(from_currency: str, to_currency: str) -> float: url = EXCHANGERATE_URL_BASE.format(key=EXCHANGERATE_API_KEY, from_currency=from_currency) response = requests.get(url) if response.status_code == 200: data = response.json() if \'conversion_rates\' in data: return data[\'conversion_rates\'].get(to_currency, None) return None def fetch_exchange_rate_currency_layer(from_currency: str, to_currency: str) -> float: url = CURRENCY_LAYER_URL_BASE.format(key=CURRENCY_LAYER_API_KEY, from_currency=from_currency, to_currency=to_currency) response = requests.get(url) if response.status_code == 200: data = response.json() if \'quotes\' in data: key = f\\"{from_currency}{to_currency}\\" return data[\'quotes\'].get(key, None) return None def convert_currency(amount: float, from_currency: str, to_currency: str) -> float: if not EXCHANGERATE_API_KEY and not CURRENCY_LAYER_API_KEY: raise ValueError(\\"No API keys provided or valid data returned.\\") exchange_rate = fetch_exchange_rate_exchangerate_api(from_currency, to_currency) if exchange_rate is None: exchange_rate = fetch_exchange_rate_currency_layer(from_currency, to_currency) if exchange_rate is not None: return amount * exchange_rate else: raise ValueError(\\"No valid exchange rates returned from any API.\\")"},{"question":"# Problem Statement You are given a string `s` and a list of words `words`. Your task is to determine if you can form the string `s` by concatenating any subset of the words in `words`, each word at most once. Return `true` if it is possible to form `s`, otherwise return `false`. Input Format 1. A string `s` representing the target string. 2. An integer `n` representing the number of words. 3. `n` strings representing the words in the list `words`. Output Format Print `true` if it is possible to form the string `s` by concatenating any subset of the words in `words`, each word at most once. Otherwise, print `false`. Constraints - (1 leq n leq 15) - (1 leq text{length of each word} leq 10) - (1 leq text{length of } s leq 150) Example **Input** ``` \\"leetcode\\" 5 \\"leet\\" \\"code\\" \\"leetco\\" \\"de\\" \\"co\\" ``` **Output** ``` true ``` **Input** ``` \\"applepie\\" 4 \\"pie\\" \\"apple\\" \\"pear\\" \\"pl\\" ``` **Output** ``` true ``` **Input** ``` \\"catsandog\\" 5 \\"cats\\" \\"dog\\" \\"sand\\" \\"and\\" \\"cat\\" ``` **Output** ``` false ``` Task Implement the following function: ```python def canFormString(s: str, words: List[str]) -> bool: # Your implementation here ``` In this function, `s` is the target string, `n` is the number of words, and `words` is the list of words. The implementation should use dynamic programming to solve the problem efficiently.","solution":"from typing import List def canFormString(s: str, words: List[str]) -> bool: # Use a dynamic programming approach to solve the problem dp = [False] * (len(s) + 1) dp[0] = True # Empty string can be formed by using no words for i in range(1, len(s) + 1): for word in words: if i >= len(word) and s[i - len(word):i] == word: dp[i] = dp[i] or dp[i - len(word)] return dp[-1]"},{"question":"You are given a singly linked list class with a method to add elements to the list. Implement a function `reverse_k_group` in the `LinkedList` class that reverses the nodes of the list k at a time and returns its modified list. If the number of nodes is not a multiple of k then the remaining nodes should remain as is. **Requirements**: 1. Implement `reverse_k_group` method in the `LinkedList` class. 2. Expected Time Complexity: O(N), where N is the number of nodes in the list. 3. Expected Space Complexity: O(1) additional space. **Function Signature**: ```python class Node: def __init__(self, value=0): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def add(self, value): new_node = Node(value) new_node.next = self.head self.head = new_node def reverse_k_group(self, k: int) -> \'Node\': # Your implementation here pass ``` **Input/Output**: - Input: An integer k (the group size). - Output: The head node of the modified linked list. **Constraints**: - The list contains positive integers. - k is a positive integer. - The linked list may contain up to 10^5 nodes. - The input k is within the range [1, 1000]. **Examples**: ```python ll = LinkedList() ll.add(5) ll.add(4) ll.add(3) ll.add(2) ll.add(1) # Linked list is 1 -> 2 -> 3 -> 4 -> 5 new_head = ll.reverse_k_group(2) Reversed linked list in groups of 2: 2 -> 1 -> 4 -> 3 -> 5 ll = LinkedList() ll.add(6) ll.add(5) ll.add(4) ll.add(3) ll.add(2) ll.add(1) # Linked list is 1 -> 2 -> 3 -> 4 -> 5 -> 6 new_head = ll.reverse_k_group(3) Reversed linked list in groups of 3: 3 -> 2 -> 1 -> 6 -> 5 -> 4 ``` Hint: Think about how you can reverse the k nodes and then link them back to the remaining part of the list.","solution":"class Node: def __init__(self, value=0): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def add(self, value): new_node = Node(value) new_node.next = self.head self.head = new_node def reverse_k_group(self, k: int) -> \'Node\': def reverse_linked_list(head, k): prev = None current = head next = None count = 0 # Keep track of the original head original_head = head # Reverse first k nodes of the linked list while current is not None and count < k: next = current.next current.next = prev prev = current current = next count += 1 # Return the new head (prev) and the next pointer (current) return prev, original_head, next count = 0 current = self.head # Count the number of nodes in the linked list while current is not None: count += 1 current = current.next # If the list is empty or k is greater than the length of the list if self.head is None or k > count: return self.head # Create a dummy node dummy = Node(0) dummy.next = self.head group_prev = dummy while count >= k: new_head, original_tail, next_node = reverse_linked_list(group_prev.next, k) group_prev.next = new_head original_tail.next = next_node group_prev = original_tail count -= k return dummy.next"},{"question":"# Problem Statement A company has an internal messaging system where messages are sent between employees. Each message is represented by a tuple containing the sender\'s ID, the receiver\'s ID, and the timestamp of when the message was sent. Given a list of such messages, implement a function `most_active_employee` that returns the ID of the employee who sent the most messages in a given time period. # Function Signature ```python def most_active_employee(messages: list[tuple[int, int, str]], start_time: str, end_time: str) -> int: pass ``` # Input - `messages`: A list of tuples (sender_id: int, receiver_id: int, timestamp: str). Each element represents a message; `1 <= len(messages) <= 10^5`. - `start_time`: A string representing the start time in the format \\"YYYY-MM-DD HH:MM:SS\\". - `end_time`: A string representing the end time in the format \\"YYYY-MM-DD HH:MM:SS\\". # Output - Returns the ID of the sender who sent the most messages in the specified time period. # Constraints - The timestamp of each message is in the format \\"YYYY-MM-DD HH:MM:SS\\". - If two employees sent the same number of messages, return the one with the smallest ID. - Raise appropriate exceptions for invalid inputs such as improper timestamps or start_time greater than end_time. # Example ```python messages = [ (1, 2, \\"2022-10-01 10:00:00\\"), (2, 1, \\"2022-10-01 10:05:00\\"), (1, 3, \\"2022-10-01 11:00:00\\"), (3, 1, \\"2022-10-01 12:00:00\\"), (1, 4, \\"2022-10-01 13:00:00\\"), (2, 1, \\"2022-10-01 14:00:00\\") ] start_time = \\"2022-10-01 10:00:00\\" end_time = \\"2022-10-01 12:00:00\\" print(most_active_employee(messages, start_time, end_time)) # Output: 1 # Explanation: # Within the period from \\"2022-10-01 10:00:00\\" to \\"2022-10-01 12:00:00\\", employee 1 sent three messages, employee 2 sent two messages, and employee 3 sent one message. Thus, employee 1 is the most active. ``` # Requirements - Ensure the solution efficiently handles up to 100,000 message records. - Implement clear error handling for invalid inputs. - Optimize the performance for large datasets and stringent time constraints.","solution":"from datetime import datetime from collections import defaultdict def most_active_employee(messages: list[tuple[int, int, str]], start_time: str, end_time: str) -> int: Returns the ID of the employee who sent the most messages in the given time period. start_time_dt = datetime.strptime(start_time, \\"%Y-%m-%d %H:%M:%S\\") end_time_dt = datetime.strptime(end_time, \\"%Y-%m-%d %H:%M:%S\\") if start_time_dt > end_time_dt: raise ValueError(\\"Start time must be earlier than end time\\") active_count = defaultdict(int) for sender_id, _, timestamp in messages: timestamp_dt = datetime.strptime(timestamp, \\"%Y-%m-%d %H:%M:%S\\") if start_time_dt <= timestamp_dt <= end_time_dt: active_count[sender_id] += 1 if not active_count: raise ValueError(\\"No messages sent in the given time period\\") most_active = max(sorted(active_count.items()), key=lambda x: (x[1], -x[0])) return most_active[0]"},{"question":"# Coding Assessment Question: String Permutation Checker Context: In many applications, it is necessary to determine if two strings are permutations of each other. A string permutation is another string that contains the same characters in a different order. Checking for string permutations is a fundamental problem in computer science and has a variety of applications, including anagrams and various string matching algorithms. Problem Statement: You are required to implement the following functions: 1. **is_permutation**: - **Input**: Two strings `string1` and `string2`. - **Output**: A boolean value `True` if `string1` and `string2` are permutations of each other, otherwise `False`. - **Constraints**: The function must handle the case of `None` or empty input strings. 2. **all_permutations**: - **Input**: A string `string`. - **Output**: A list of all possible permutations of the input string. - **Constraints**: The function should avoid generating duplicate permutations. 3. **permutation_index**: - **Input**: Two strings `string` and `permutation`. - **Output**: The lexicographical index of the `permutation` if it is a valid permutation of `string`, otherwise return -1. - **Constraints**: Both inputs must be valid strings. Requirements: - Functions should check for input validity. - Ensure optimal performance and consider edge cases such as `None` input, empty strings, and strings of different lengths. - Avoid using built-in library functions that directly solve these problems. Example Usage: ```python # Two strings and permutation string1 = \\"abc\\" string2 = \\"bca\\" string3 = \\"abcd\\" # Check if strings are permutations of each other print(is_permutation(string1, string2)) # Output: True print(is_permutation(string1, string3)) # Output: False # Generate all permutations perms = all_permutations(\\"abc\\") print(perms) # Output: [\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'] # Find permutation index index = permutation_index(\\"abc\\", \\"bca\\") print(index) # Output: 2 index = permutation_index(\\"abc\\", \\"abcd\\") print(index) # Output: -1 ``` Solution Guidelines: - Use appropriate data structures to ensure efficient computation. - Keep the function interfaces consistent and easy to understand. - Document the code with appropriate comments explaining the logic used.","solution":"def is_permutation(string1, string2): Checks if two strings are permutations of each other. Input: string1 (str): The first string. string2 (str): The second string. Output: bool: True if the strings are permutations of each other, False otherwise. if string1 is None or string2 is None: return False if len(string1) != len(string2): return False return sorted(string1) == sorted(string2) from itertools import permutations def all_permutations(string): Generates all distinct permutations of a given string. Input: string (str): The input string. Output: list: A list of all distinct permutations. if string is None: return [] return sorted(set([\'\'.join(p) for p in permutations(string)])) def permutation_index(string, permutation): Finds the lexicographical index of a permutation of a given string. Input: string (str): The original string. permutation (str): The permutation to check. Output: int: The index of the permutation if it is valid, -1 otherwise. if string is None or permutation is None: return -1 if sorted(string) != sorted(permutation): return -1 perms = all_permutations(string) try: index = perms.index(permutation) except ValueError: return -1 return index"},{"question":"# Find the Longest Substring with Unique Characters You are developing a utility for text analysis which includes finding the longest substring that contains only unique characters. This is useful in various applications such as data compression and encoding algorithms. Task Implement a function: `find_longest_unique_substring(s: str) -> str` # Input - `s`: A string consisting of uppercase and lowercase English letters (string). # Output - The longest substring of `s` that contains only unique characters (string). # Constraints - The length of the input string `s` will not exceed 1000 characters. - If there are multiple substrings of the same maximum length, return the one that appears first. # Examples ```python assert find_longest_unique_substring(\\"abcabcbb\\") == \\"abc\\" assert find_longest_unique_substring(\\"bbbbb\\") == \\"b\\" assert find_longest_unique_substring(\\"pwwkew\\") == \\"wke\\" assert find_longest_unique_substring(\\"\\") == \\"\\" assert find_longest_unique_substring(\\"abcdef\\") == \\"abcdef\\" ``` # Notes Ensure your implementation handles: - Efficient traversing and checking for unique characters within substrings. - Optimal performance to handle the upper constraint of string length. - Proper consideration of input edge cases, such as empty strings. # Implementation Hints - Use a sliding window technique to efficiently find and expand potential unique substrings. - Keep track of seen characters using a set or a dictionary for quick lookup operations.","solution":"def find_longest_unique_substring(s: str) -> str: Finds the longest substring with unique characters. Parameters: - s: input string consisting of uppercase and lowercase English letters. Returns: - A string representing the longest substring with unique characters. # Initialize start of window, max length, and result substring start = 0 max_length = 0 max_substr = \\"\\" seen = {} for end in range(len(s)): if s[end] in seen: # Move the start index to right of last occurrence of current character start = max(start, seen[s[end]] + 1) # Update the latest index of the character seen[s[end]] = end # Check if current window length is the largest found so far if (end - start + 1) > max_length: max_length = end - start + 1 max_substr = s[start:end + 1] return max_substr"},{"question":"# Problem Statement You are provided with two utility functions: one to check if a given list of numbers contains unique elements (`contains_unique_elements`), and another to sort a list of numbers in non-decreasing order (`sort_list`). Your task is to extend this functionality by implementing a new function `find_and_sort_unique_lists` which processes a list of lists and returns a list of lists, where each sublist is sorted in non-decreasing order and contains only unique elements from the original input. # Requirements Function Signature ```python def find_and_sort_unique_lists(lists: list) -> list: ``` Input * `lists`: A list of lists, where each sublist contains numerical values. Output * A list of lists, where each sublist is sorted in non-decreasing order and contains unique elements from the original input. Constraints * You may assume that the sublists contain at least one numerical value. * If a sublist contains repeated elements, ensure only unique elements are included in the output. # Example ```python >>> find_and_sort_unique_lists([[2, 4, 6, 2], [3, 6, 12, 6], [1, 3, 1, 5], [10, 15, 10, 20, 25]]) [[2, 4, 6], [3, 6, 12], [1, 3, 5], [10, 15, 20, 25]] >>> find_and_sort_unique_lists([[5, 15, 25, 5], [3]]) [[5, 15, 25], [3]] >>> find_and_sort_unique_lists([[1, 2, 4, 2], [4, 8, 12, 12]]) [[1, 2, 4], [4, 8, 12]] ``` # Caveats * Ensure your function efficiently handles incorrect input types by raising appropriate exceptions, similar to the helper functions.","solution":"def find_and_sort_unique_lists(lists: list) -> list: Takes a list of lists and returns a new list of lists where each sublist is sorted in non-decreasing order and contains only unique elements from the input. # Resultant list of lists result = [] for sublist in lists: # Removing duplicates by converting to set, then back to list and sorting unique_sorted = sorted(set(sublist)) result.append(unique_sorted) return result"},{"question":"# Problem Statement Create a Python function that generates the first `n` square numbers. A square number for an integer `k` is defined as `k²`. Write a Python function `square_numbers(n: int) -> list[int]` that accepts an integer `n` and returns a list of the first `n` square numbers. # Function Signature ```python def square_numbers(n: int) -> list[int]: ``` # Input * `n` (int): The number of square numbers to be generated. Must be a non-negative integer. # Output * list of ints: A list of the first `n` square numbers. # Constraints * `n` must be a non-negative integer (≥ 0). # Examples ```python >>> square_numbers(5) [0, 1, 4, 9, 16] >>> square_numbers(0) [] >>> square_numbers(1) [0] >>> square_numbers(7) [0, 1, 4, 9, 16, 25, 36] >>> square_numbers(-1) Traceback (most recent call last): ... ValueError: Input must be a non-negative integer. >>> square_numbers(3.5) Traceback (most recent call last): ... ValueError: Input must be a non-negative integer. ``` # Notes * Ensure your function raises a `ValueError` with the message \\"Input must be a non-negative integer.\\" if the input does not meet the required constraints. * You are not allowed to use libraries for generating the sequence.","solution":"def square_numbers(n: int) -> list[int]: Returns a list of the first n square numbers. Parameters: n (int): The number of square numbers to generate. Returns: list[int]: A list of the first n square numbers. Raises: ValueError: If n is not a non-negative integer. if not isinstance(n, int) or n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") return [i ** 2 for i in range(n)]"},{"question":"# Problem Statement You are given a string consisting of lowercase English letters and a set of operations to perform on this string. Your task is to implement a function that returns the maximum length of a substring with no repeating characters after performing exactly `k` operations. Each operation allows you to replace one character in the string with any other lowercase English letter. # Function Signature ```python def max_substring_length_with_k_operations(s: str, k: int) -> int: pass ``` # Input Format * A string `s` consisting of lowercase English letters. * An integer `k` representing the number of operations allowed. # Output Format * Return an integer representing the maximum length of a substring with no repeating characters after performing exactly `k` operations. # Constraints * The length of the string `s` will be between 1 and 1000. * `s` will consist only of lowercase English letters (\'a\' - \'z\'). * `0 <= k <= |s|`. # Example ```python # Example 1 s = \\"abcba\\" k = 2 # After 2 operations you can transform the string to \\"abcde\\" where \\"abcde\\" is the longest substring with no repeating characters. # Therefore, the function should return: 5 # Example 2 s = \\"aabaa\\" k = 1 # After 1 operation you can transform the string to \\"aabca\\" where \\"abc\\" is the longest substring with no repeating characters. # Therefore, the function should return: 3 ``` # Notes * If no operations are required to achieve the longest substring with no repeating characters, the solution should still correctly identify this. * Consider edge cases such as `k` being 0 or `k` being equal to the length of the string.","solution":"def max_substring_length_with_k_operations(s: str, k: int) -> int: n = len(s) max_len = 0 for start in range(n): frequency = {} unique_count = 0 max_possible_len = 0 for end in range(start, n): if s[end] not in frequency: frequency[s[end]] = 0 frequency[s[end]] += 1 if frequency[s[end]] == 1: unique_count += 1 while unique_count + k < (end - start + 1): frequency[s[start]] -= 1 if frequency[s[start]] == 0: unique_count -= 1 start += 1 max_possible_len = end - start + 1 max_len = max(max_len, min(max_possible_len, unique_count + k)) return max_len"},{"question":"# Question: Implement a Path Finder in a Graph Given a `Graph` class representing an unweighted undirected graph through its adjacency list, your task is to enhance this class to include a method that finds if there exists a path between two nodes. **Definition**: A path between two nodes is a sequence of edges that connect the nodes. The task is broken down as follows: 1. Implement a method `has_path` in the `Graph` class that takes two nodes (start and end) as inputs and returns `True` if there is a path between the nodes and `False` otherwise. 2. Ensure your implementation is efficient and runs in O(V + E) time complexity, where V is the number of vertices and E is the number of edges. **Expected Input and Output**: * Input: Two nodes (start, end). * Output: Boolean (True if there is a path between the nodes, False otherwise). **Constraints**: * The graph can be empty, in which case the output should be `False`. * Both nodes can be the same, in which case the output should be `True` as there is a trivial path. # Example ```python # Example of usage: graph = Graph() graph.add_edge(\'A\', \'B\') graph.add_edge(\'B\', \'C\') graph.add_edge(\'C\', \'D\') print(graph.has_path(\'A\', \'D\')) # Expected output: True print(graph.has_path(\'A\', \'E\')) # Expected output: False print(graph.has_path(\'A\', \'A\')) # Expected output: True ``` # Performance Requirements Your method should run in O(V + E) time complexity and use O(V) space complexity due to the stack/queue used for the traversal and the storage of visited nodes. Your task: 1. Enhance the `Graph` class as per the requirements. 2. Write appropriate test cases to validate the solution.","solution":"from collections import defaultdict, deque class Graph: def __init__(self): self.graph = defaultdict(list) def add_edge(self, node1, node2): self.graph[node1].append(node2) self.graph[node2].append(node1) def has_path(self, start, end): if start not in self.graph or end not in self.graph: return False if start == end: return True visited = set() queue = deque([start]) while queue: current_node = queue.popleft() if current_node == end: return True if current_node not in visited: visited.add(current_node) for neighbor in self.graph[current_node]: if neighbor not in visited: queue.append(neighbor) return False"},{"question":"Array Sorting and Filtering Challenge Write a function that sorts an array of integers and then removes all elements that do not fall within a specified range. The function should return the sorted array with elements exclusively within the given range. # Function Signature ```python def filter_and_sort(arr: list[int], lower: int, upper: int) -> list[int]: ``` # Input 1. `arr` (list of int): The list of integers to be sorted and filtered. 2. `lower` (int): The lower bound (inclusive) of the range. 3. `upper` (int): The upper bound (inclusive) of the range. # Output * A list of integers that are sorted in ascending order and fall between the lower and upper bounds (inclusive). # Constraints * The values of the array, `arr`, may range from `-10^6` to `10^6`. * The number of elements in the array, `arr`, will not exceed `10^5`. * The input range is guaranteed to be valid where `lower <= upper`. # Example Usage ```python assert filter_and_sort([10, 5, 2, 8, -3, 15, 7], 2, 10) == [2, 5, 7, 8, 10] assert filter_and_sort([1, 3, 5, 7, 9], 4, 8) == [5, 7] assert filter_and_sort([-10, 0, 10, -20, 20], -15, 15) == [-10, 0, 10] assert filter_and_sort([100, 200, 300], 150, 250) == [200] ``` # Notes * Ensure the function sorts the array first, and then proceeds to filter out elements not within the specified range. * Consider edge cases such as empty arrays or arrays where no elements fall within the specified range. * Efficiency is key – aim for optimal performance to handle the upper bounds of input size.","solution":"def filter_and_sort(arr: list[int], lower: int, upper: int) -> list[int]: Sorts the input array and returns elements exclusively within the given range [lower, upper]. :param arr: list of integers to be sorted and filtered :param lower: the lower bound of the range (inclusive) :param upper: the upper bound of the range (inclusive) :return: sorted list of integers within the specified range sorted_arr = sorted(arr) return [x for x in sorted_arr if lower <= x <= upper]"},{"question":"# Question You are tasked with finding the smallest prime number greater than or equal to a given integer. A prime number is defined as a number greater than 1 that has no positive divisors other than 1 and itself. Problem Statement Write a function `find_smallest_prime(n: int) -> int` that returns the smallest prime number greater than or equal to the given integer `n`. Input * `n` (integer): A single integer representing the starting point to search for the prime number. Output * Returns an integer indicating the smallest prime number that is greater than or equal to `n`. Constraints - `1 <= n <= 1,000,000` Example ```python >>> find_smallest_prime(10) 11 >>> find_smallest_prime(15) 17 >>> find_smallest_prime(17) 17 >>> find_smallest_prime(1) 2 ``` Note * You may need to implement a method to check for prime numbers efficiently. * Consider performance implications, especially for larger values of `n`.","solution":"def is_prime(num): Helper function to check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def find_smallest_prime(n): Returns the smallest prime number greater than or equal to the given integer n. while not is_prime(n): n += 1 return n"},{"question":"# File Manipulation: Character Frequency Analysis Problem Statement: You are tasked with writing a Python program that analyzes the frequency of each character in a text file. This type of analysis is useful in cryptography, text processing, and data compression algorithms. You are required to implement two functions, `read_file` and `character_frequency`, adhering to the following specifications: 1. `read_file(file_path: str) -> str`: This function should take the path of the text file as input, read the entire content of the file, and return it as a single string. Raise a `FileNotFoundError` if the file does not exist. 2. `character_frequency(content: str) -> dict`: This function should take the text content as input and return a dictionary where the keys are characters and the values are their respective frequencies in the text. Input and Output 1. `read_file(file_path: str) -> str` - **Input**: `file_path` (a string, representing the path to the text file) - **Output**: A string containing the entire content of the file. 2. `character_frequency(content: str) -> dict` - **Input**: `content` (a string, representing the text content) - **Output**: A dictionary with characters as keys and their frequency counts as values. Constraints - Assume the text file exists and is readable if not checking for `FileNotFoundError`. - Non-alphabetic characters (spaces, punctuation, digits) should also be counted. - The analysis should be case-sensitive (treat \'A\' and \'a\' as different characters). Examples ```python # Example usage: # Assume \'sample.txt\' contains \\"Hello World!\\" content = read_file(\'sample.txt\') print(content) # Expected output: \\"Hello World!\\" freq = character_frequency(content) print(freq) # Expected output: {\'H\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \' \': 1, \'W\': 1, \'r\': 1, \'d\': 1, \'!\': 1} # Testing non-existent file print(read_file(\'non_existent.txt\')) # Expected output: FileNotFoundError ``` ```python # Implementation of functions def read_file(file_path: str) -> str: try: with open(file_path, \'r\') as file: return file.read() except FileNotFoundError: raise FileNotFoundError(f\\"The file at {file_path} does not exist.\\") def character_frequency(content: str) -> dict: frequency_dict = {} for char in content: if char in frequency_dict: frequency_dict[char] += 1 else: frequency_dict[char] = 1 return frequency_dict ``` This new question aligns with the existing set by maintaining the style, length, and complexity, and it explores a related area in file manipulation and text analysis.","solution":"def read_file(file_path: str) -> str: try: with open(file_path, \'r\', encoding=\'utf-8\') as file: return file.read() except FileNotFoundError: raise FileNotFoundError(f\\"The file at {file_path} does not exist.\\") def character_frequency(content: str) -> dict: frequency_dict = {} for char in content: if char in frequency_dict: frequency_dict[char] += 1 else: frequency_dict[char] = 1 return frequency_dict"},{"question":"# Problem Statement Create a function that checks if a given string is a palindrome. A palindrome is a word, number, phrase, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization). Implement three different methods: 1. Simple comparison. 2. Using recursion. 3. Using a two-pointer technique. # Function Signatures ```python def is_palindrome(s: str) -> bool: Check if a given string is a palindrome using simple comparison. def is_palindrome_recursion(s: str) -> bool: Check if a given string is a palindrome using recursion. def is_palindrome_two_pointer(s: str) -> bool: Check if a given string is a palindrome using a two-pointer technique. ``` # Input - A string `s` which can contain letters (both uppercase and lowercase), numbers, spaces, and punctuation. # Output - A boolean value: `True` if `s` is a palindrome, `False` otherwise. # Constraints - The string `s` can be of any length, including an empty string. # Requirements - Normalize the string by converting to lowercase and removing non-alphanumeric characters. - Ensure each method handles typical edge cases, such as empty strings, single characters, and complex scenarios with punctuation and spaces. # Example ```python >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome_recursion(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome_recursion(\\"racecar\\") True >>> is_palindrome_recursion(\\"hello\\") False >>> is_palindrome_two_pointer(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome_two_pointer(\\"racecar\\") True >>> is_palindrome_two_pointer(\\"hello\\") False ``` # Explanation 1. **Function Definitions**: - `is_palindrome(s: str) -> bool`: Normalize the string and check if it reads the same forwards and backwards. - `is_palindrome_recursion(s: str) -> bool`: Normalize the string and use recursion to check for palindrome properties. - `is_palindrome_two_pointer(s: str) -> bool`: Normalize the string and use a two-pointer technique to compare characters from both ends moving towards the center.","solution":"import re def normalize_string(s: str) -> str: Normalize the string by converting to lowercase and removing non-alphanumeric characters. return re.sub(r\'[^A-Za-z0-9]\', \'\', s.lower()) def is_palindrome(s: str) -> bool: Check if a given string is a palindrome using simple comparison. normalized = normalize_string(s) return normalized == normalized[::-1] def is_palindrome_recursion(s: str) -> bool: Check if a given string is a palindrome using recursion. normalized = normalize_string(s) def helper(sub_s: str, left: int, right: int) -> bool: if left >= right: return True if sub_s[left] != sub_s[right]: return False return helper(sub_s, left + 1, right - 1) return helper(normalized, 0, len(normalized) - 1) def is_palindrome_two_pointer(s: str) -> bool: Check if a given string is a palindrome using a two-pointer technique. normalized = normalize_string(s) left, right = 0, len(normalized) - 1 while left < right: if normalized[left] != normalized[right]: return False left += 1 right -= 1 return True"},{"question":"# Problem Statement You are given a linked list, where each node contains an integer value. Your task is to write a function, `reverse_linked_list(head: ListNode) -> ListNode`, which reverses the linked list and returns the head of the reversed list. # Input * `head`: A `ListNode` object representing the head of the linked list. Each `ListNode` object has two properties: - `val`: An integer value. - `next`: A reference to the next node in the linked list, or `None` if it is the last node. # Output * A `ListNode` object representing the head of the reversed linked list. # Constraints * The linked list can contain zero or more nodes. * The nodes can contain any integer value. * If the input is `None`, the function should return `None`. # Example ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def print_list(head: ListNode): res = [] while head: res.append(head.val) head = head.next return res # Example 1 head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) reversed_head = reverse_linked_list(head) print(print_list(reversed_head)) # Output: [5, 4, 3, 2, 1] # Example 2 head = ListNode(1, ListNode(2)) reversed_head = reverse_linked_list(head) print(print_list(reversed_head)) # Output: [2, 1] # Example 3 reversed_head = reverse_linked_list(None) print(print_list(reversed_head)) # Output: [] ``` # Notes * Ensure that your function correctly handles an empty linked list (`None` input).","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head: ListNode) -> ListNode: prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev def print_list(head: ListNode): res = [] while head: res.append(head.val) head = head.next return res"},{"question":"# Rearranging Array Elements to Form the Largest Number **Scenario**: You are working on a feature that displays the largest number possible by reordering elements in an array of non-negative integers. Your task is to implement an algorithm to achieve this. **Problem**: Given an array of non-negative integers, arrange them such that they form the largest possible number. **Function Signature**: ```python def largest_number(nums: List[int]) -> str: Function to arrange numbers to form the largest possible number. Args: nums (List[int]): A list of non-negative integers. Returns: str: The largest number formed by arranging the input integers. ``` **Input**: - `nums`: A list of non-negative integers. **Output**: - A string representing the largest number that can be formed by the integers in `nums`. **Constraints**: - The length of the `nums` list will not exceed 100. - Each integer in `nums` is within the range 0 to 10^9. **Examples**: ```python >>> largest_number([10, 2]) \'210\' >>> largest_number([3, 30, 34, 5, 9]) \'9534330\' >>> largest_number([1]) \'1\' >>> largest_number([10]) \'10\' ``` **Note**: The solution should handle cases where numbers have different lengths and considers concatenation orders, ensuring that the resulting string is the largest possible number. Leading zeros in the final output should be avoided (e.g., \\"00\\" should be \\"0\\").","solution":"from functools import cmp_to_key from typing import List def largest_number(nums: List[int]) -> str: Function to arrange numbers to form the largest possible number. Args: nums (List[int]): A list of non-negative integers. Returns: str: The largest number formed by arranging the input integers. def compare(x, y): # Custom comparator function if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Convert all numbers to strings for custom comparison strs = list(map(str, nums)) # Sort using the custom comparator strs.sort(key=cmp_to_key(compare)) # Join the result to form the largest number largest_num = \'\'.join(strs) # Handle the case where we have only zeros return largest_num if largest_num[0] != \'0\' else \'0\'"},{"question":"# Merge K Sorted Linked Lists Objective: Implement a function that merges `k` sorted linked lists into one single sorted linked list using a min-heap (priority queue) for efficient merging. Problem Statement: Write a function `merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]` that takes a list of `k` sorted linked lists and merges them into one sorted linked list. Function Signature: ```python from typing import List, Optional import heapq class ListNode: def __init__(self, val: int=0, next: Optional[\'ListNode\']=None): self.val = val self.next = next def merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: pass ``` Inputs: * `lists` (List[Optional[ListNode]]): A list of `k` linked lists, where each linked list is sorted in ascending order. Each linked list is defined by the class `ListNode`. Output: * The function should return a single linked list that merges all the `k` input linked lists in sorted order. Example: ```python # Helper function to create a linked list from a list of values def create_linked_list(values): if not values: return None head = ListNode(values[0]) current = head for value in values[1:]: current.next = ListNode(value) current = current.next return head # Helper function to convert a linked list to a list of values def linked_list_to_list(node): values = [] while node: values.append(node.val) node = node.next return values # Example usage lists = [ create_linked_list([1, 4, 5]), create_linked_list([1, 3, 4]), create_linked_list([2, 6]) ] merged_head = merge_k_sorted_lists(lists) print(linked_list_to_list(merged_head)) # Output: [1, 1, 2, 3, 4, 4, 5, 6] ``` Constraints: * Do not use built-in array sorting functions directly. * Use a min-heap for efficient merging. * Ensure your solution handles edge cases, such as dealing with empty lists or lists with one single node. * The total number of nodes across all linked lists does not exceed `10^4`.","solution":"from typing import List, Optional import heapq class ListNode: def __init__(self, val: int=0, next: Optional[\'ListNode\']=None): self.val = val self.next = next def __lt__(self, other: \'ListNode\'): return self.val < other.val def merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: heap = [] for l in lists: if l: heapq.heappush(heap, l) dummy = ListNode(0) current = dummy while heap: node = heapq.heappop(heap) current.next = node current = current.next if node.next: heapq.heappush(heap, node.next) return dummy.next"},{"question":"# Task You are provided with a function that needs to identify and extract the domain name from email addresses. The current implementation can handle simple cases, but it does not account for various edge cases such as subdomains, internationalized domain names, and email address standards. Your task is to improve the function to handle all these scenarios. # Requirements 1. **Function**: Implement a function `extract_domain(email: str) -> str` that extracts the domain name from a given email address. 2. **Input**: A string `email` which is a valid email address. 3. **Output**: A string representing the domain name of the email address. 4. **Constraints**: * The input string `email` will be a valid email address with a maximum length of 320 characters, as per RFC 5321. * You cannot use any third-party libraries to perform the extraction. # Example ```python def extract_domain(email: str) -> str: # Your implementation here # Test case print(extract_domain(\\"user@example.com\\")) # Output: \'example.com\' print(extract_domain(\\"name.surname@sub.mail.co.uk\\")) # Output: \'sub.mail.co.uk\' print(extract_domain(\\"firstname.lastname@hostname\\")) # Output: \'hostname\' print(extract_domain(\\"user@中文域名.cn\\")) # Output: \'中文域名.cn\' print(extract_domain(\\"admin@hostname.com\\")) # Output: \'hostname.com\' ``` # Explanation - The function should correctly parse and extract the domain part from the given email address. - It should handle different scenarios including subdomains and internationalized domain names. - Ensure the solution adheres to the validation rules as per the email address standards, without using any external libraries. Remember, the goal is to implement the extraction logic yourself to demonstrate your ability to handle string manipulation and parsing efficiently.","solution":"def extract_domain(email: str) -> str: Extracts the domain name from a given email address. Parameters: email (str): A string representing a valid email address. Returns: str: The domain name extracted from the email address. # Split the email address at the \'@\' symbol parts = email.split(\'@\') # Return the part after the \'@\' symbol which is the domain return parts[1]"},{"question":"# Question: # Determining Minimum Steps in a Matrix from Start to Target **Context**: You are developing a pathfinding algorithm that navigates through a 2D grid (matrix). Each cell in the grid can either be walkable (represented by 0) or blocked (represented by 1). You need to determine the minimum number of steps required to reach a target position from a start position, if it is possible to do so. Your task is to write a function that achieves this using the Breadth-First Search (BFS) algorithm to ensure the shortest path is found due to its unweighted nature. **Task**: Write a Python function `min_steps_matrix` that computes the minimum number of steps needed to get from a start position to a target position in a 2D grid. # Input: - A 2D list `grid` of integers where each element is either `0` (walkable) or `1` (blocked). - A tuple `(start_x, start_y)` representing the starting coordinates. - A tuple `(target_x, target_y)` representing the target coordinates. # Output: - An integer representing the minimum number of steps required to reach the target from the start position. If the target is unreachable, return `-1`. # Constraints: - The dimensions of the grid will be between `1x1` and `100x100` inclusive. - Grid cells and coordinates are valid and within bounds. - Movement is possible in four directions: up, down, left, and right. # Expected Performance: - The solution should be efficient in terms of both time and space complexity. - Use the BFS algorithm to ensure the shortest path is found. # Example: ```python grid = [ [0, 0, 1, 0], [0, 0, 0, 1], [1, 0, 1, 0], [0, 0, 0, 0] ] start = (0, 0) target = (3, 3) min_steps_matrix(grid, start, target) # Output: 6 ``` # Additional Requirements: - Include detailed comments explaining the steps of your implementation. - Handle edge cases where the start or target position is blocked or out of bounds. - Ensure the function maintains robustness and optimal performance even with maximum grid size.","solution":"from collections import deque def min_steps_matrix(grid, start, target): Returns the minimum number of steps required to reach the target position from the start position in a 2D grid. If the target is unreachable, return -1. rows, cols = len(grid), len(grid[0]) start_x, start_y = start target_x, target_y = target # Early exit if start or target positions are blocked if grid[start_x][start_y] == 1 or grid[target_x][target_y] == 1: return -1 # Initialize BFS queue = deque([(start_x, start_y, 0)]) # (x, y, steps) visited = set((start_x, start_y)) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right while queue: x, y, steps = queue.popleft() # If we\'ve reached the target, return the step count if (x, y) == target: return steps # Explore all valid neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) # If we exit the loop without having found the target, it is unreachable return -1"},{"question":"# Coding Challenge: Path Sum in a Binary Tree Scenario: You are tasked with evaluating a binary tree to determine if there exists a root-to-leaf path where the sum of the node values equals a specific target sum. This kind of path analysis can be used in various applications, such as financial portfolio analysis where each node represents an investment, and you\'re looking for a combination that equals a specific target amount. Task: Implement a function to determine if there is a root-to-leaf path in a given binary tree where the sum of the node values matches a given target sum. Input: - A binary tree represented by its root node. - An integer `targetSum` representing the target sum to find in the binary tree. Output: - A boolean value: `True` if such a path exists, otherwise `False`. Constraints: - The tree consists of nodes with integer values. - The number of nodes in the tree is between 1 and 5000. - Node values range from -1000 to 1000. - The tree is non-empty, and `targetSum` is an integer. Example: ``` # Example 1: Input: root = [5, 4, 8, 11, None, 13, 4, 7, 2, None, None, None, 1] targetSum = 22 Output: True # Example 2: Input: root = [1, 2, 3] targetSum = 5 Output: False # Example 3: Input: root = [1, 2] targetSum = 2 Output: False ``` Explanation: In Example 1, the path 5 -> 4 -> 11 -> 2 equals 22. Therefore, the output is True. In Example 2 and Example 3, there is no such path, so the output is False. Implementation Details: - Define a function `hasPathSum(root: TreeNode, targetSum: int) -> bool` to perform the task. - Ensure the function adheres to the provided input and output formats. - Use appropriate tree traversal methods to ensure efficiency. ```python from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def hasPathSum(root: Optional[TreeNode], targetSum: int) -> bool: if not root: return False if not root.left and not root.right: # if leaf node return targetSum == root.val targetSum -= root.val return hasPathSum(root.left, targetSum) or hasPathSum(root.right, targetSum) # Example usage: if __name__ == \\"__main__\\": # Test case 1 root = TreeNode(5) root.left = TreeNode(4) root.right = TreeNode(8) root.left.left = TreeNode(11) root.left.left.left = TreeNode(7) root.left.left.right = TreeNode(2) root.right.left = TreeNode(13) root.right.right = TreeNode(4) root.right.right.right = TreeNode(1) targetSum = 22 print(hasPathSum(root, targetSum)) # Output should be True ```","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def hasPathSum(root: Optional[TreeNode], targetSum: int) -> bool: if not root: return False if not root.left and not root.right: # if leaf node return targetSum == root.val targetSum -= root.val return hasPathSum(root.left, targetSum) or hasPathSum(root.right, targetSum)"},{"question":"# Longest Increasing Subsequence in 2D Grid You are given a 2D grid of integers. Your task is to find the length of the longest increasing subsequence from any cell. The sequence should be strictly increasing, and you can move to the adjacent cells in four possible directions: up, down, left, and right. # Input Format - An integer `M` representing the number of rows in the grid. - An integer `N` representing the number of columns in the grid. - A 2D list `grid` of size `MxN`, where each element represents an integer in the grid. # Output Format - An integer representing the length of the longest increasing subsequence in the grid. # Constraints - 1 ≤ M, N ≤ 1000 - -10^9 ≤ grid[i][j] ≤ 10^9 # Function Signature ```python def longest_increasing_path(grid: List[List[int]]) -> int: ``` # Example ```python # Example 1 M = 3 N = 3 grid = [ [1, 2, 3], [6, 5, 4], [7, 8, 9] ] assert longest_increasing_path(grid) == 9 # Example 2 M = 3 N = 3 grid = [ [9, 9, 4], [6, 6, 8], [2, 1, 1] ] assert longest_increasing_path(grid) == 4 ``` # Notes 1. Analyze various paths in the grid to ensure you find the globally longest increasing path. 2. Optimize your solution to handle the maximum constraint efficiently. 3. Consider memoization or dynamic programming techniques to avoid redundant calculations. 4. Assume the grid is sufficiently large and test for both small and large cases.","solution":"from typing import List def longest_increasing_path(grid: List[List[int]]) -> int: M = len(grid) N = len(grid[0]) if M == 0 or N == 0: return 0 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] dp = [[-1 for _ in range(N)] for _ in range(M)] def dfs(x, y): if dp[x][y] != -1: return dp[x][y] max_length = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < M and 0 <= ny < N and grid[nx][ny] > grid[x][y]: length = 1 + dfs(nx, ny) max_length = max(max_length, length) dp[x][y] = max_length return dp[x][y] max_path = 0 for i in range(M): for j in range(N): max_path = max(max_path, dfs(i, j)) return max_path"},{"question":"# Problem Description You are required to implement a function to simulate the Least Recently Used (LRU) Cache Replacement Algorithm. The LRU algorithm removes the least recently used item from the cache when it is full. # Task * Implement a class `LRUCache` that models an LRU cache with the following methods: - `__init__(self, capacity: int)` - Initializes the LRU cache with a given capacity. - `get(self, key: int) -> int` - Returns the value of the key if present in the cache. Otherwise, returns -1. - `put(self, key: int, value: int) -> None` - Updates or inserts the value if the key is not already present in the cache. If the cache reaches its capacity, it should invalidate the least recently used item before inserting a new item. # Input - The capacity of the cache is a positive integer. - The keys and values are non-negative integers. # Output - `get` method will return an integer value. - `put` method will not return any value. # Constraints - Capacity will be between 1 and 1000. - The number of operations will be between 1 and 10,000. - Keys and values will be non-negative integers less than or equal to 10^5. # Example ```python class LRUCache: def __init__(self, capacity: int): # Your code here def get(self, key: int) -> int: # Your code here def put(self, key: int, value: int) -> None: # Your code here # Example Usage lru_cache = LRUCache(2) lru_cache.put(1, 1) lru_cache.put(2, 2) print(lru_cache.get(1)) # Example output: 1 lru_cache.put(3, 3) # This operation will make key 2 invalid print(lru_cache.get(2)) # Example output: -1 (not found) lru_cache.put(4, 4) # This operation will make key 1 invalid print(lru_cache.get(1)) # Example output: -1 (not found) print(lru_cache.get(3)) # Example output: 3 print(lru_cache.get(4)) # Example output: 4 ``` # Explanation The LRU cache operations `put(1, 1)` and `put(2, 2)` add two items to the cache. The next `get(1)` operation returns 1 because the key 1 is in the cache. The `put(3, 3)` operation adds a new item and makes the least recently used key (key 2) invalid. Thus, `get(2)` returns -1 as it\'s not found. Similarly, `put(4, 4)` invalidates the least recently used key (key 1), making `get(1)` return -1. Ensure that the `LRUCache` class handles edge cases correctly, such as consecutive `put` operations reaching the cache capacity or repetitive `get` operations for non-existent keys. Efficient handling using data structures like linked lists and hash maps is encouraged to optimize operation time complexity.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 self.cache.move_to_end(key) return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False)"},{"question":"# Sorting Tweets by Retweet Count You are tasked with building a function to sort a list of tweets by their retweet count in descending order. Each tweet is represented by a dictionary containing the text of the tweet and its retweet count. Function Signature: ```python def sort_tweets_by_retweet(tweets: List[Dict[str, Any]]) -> List[Dict[str, Any]]: pass ``` Requirements: 1. **Sort List**: Use the provided list of tweet dictionaries and sort them by the \'retweets\' key values in descending order. 2. **Input Format**: The input is a list of dictionaries, where each dictionary contains: - `\'text\'`: a string representing the text of the tweet. - `\'retweets\'`: an integer representing the number of retweets. 3. **Output Format**: The function should return a new list of dictionaries sorted by the retweet count in descending order. Constraints: - The number of tweets in the input list can be up to 10,000. - Each tweet text will be a non-empty string with a maximum length of 280 characters. - Retweet counts will be non-negative integers. Example: ```python tweets = [ {\\"text\\": \\"This is tweet one\\", \\"retweets\\": 10}, {\\"text\\": \\"This is tweet two\\", \\"retweets\\": 50}, {\\"text\\": \\"This is tweet three\\", \\"retweets\\": 20} ] sorted_tweets = sort_tweets_by_retweet(tweets) print(sorted_tweets) # Expected output: # [ # {\\"text\\": \\"This is tweet two\\", \\"retweets\\": 50}, # {\\"text\\": \\"This is tweet three\\", \\"retweets\\": 20}, # {\\"text\\": \\"This is tweet one\\", \\"retweets\\": 10} # ] ``` Additional Notes: - Ensure the original input list is not modified. - Utilize Python\'s built-in sorting capabilities effectively to handle the potential size of the input list. - Maintain the order of tweets with the same retweet count as they appear in the input list.","solution":"from typing import List, Dict, Any def sort_tweets_by_retweet(tweets: List[Dict[str, Any]]) -> List[Dict[str, Any]]: Sorts a list of tweets by their retweet count in descending order. return sorted(tweets, key=lambda tweet: tweet[\'retweets\'], reverse=True)"},{"question":"# Scenario: You are part of a development team for an online learning platform. The platform allows users to access various courses and track their progress. Management wants to identify users who are not making significant progress and may need additional support or intervention. # Question: Implement a function `identify_low_engagement_users` that evaluates user progress based on the percentage of course completion over time. The function should use a progress detection mechanism and define outlier users who exhibit low engagement. ```python from typing import Dict, List, Tuple def identify_low_engagement_users(users_data: Dict[str, List[Tuple[str, float]]], threshold_percentage: float) -> List[str]: Identify users who are not making significant progress in their courses. Parameters: - users_data: Dictionary where the key is the user ID (str), and the value is a list of tuples containing course IDs (str) and completion percentages (float). - threshold_percentage: A float, the minimum average completion percentage required to consider a user as engaged. Returns: - List of user IDs (str) who have an average course completion below the threshold. pass ``` # Requirements: - The function should calculate the average course completion percentage for each user. - If the average completion percentage for a user is below the specified threshold, the user should be identified as low engagement. - Return a list of user IDs who are considered low engagement. # Input and Output: - **Input**: - `users_data`: A dictionary mapping user IDs to lists of tuples. Each tuple contains a course ID and the user\'s completion percentage for that course. - `threshold_percentage`: A float indicating the minimum average completion percentage for engaged users. - **Output**: - A list of user IDs who are considered to have low engagement based on the threshold. # Example: - Input: ``` users_data = { \\"user1\\": [(\\"course1\\", 20.0), (\\"course2\\", 30.0)], \\"user2\\": [(\\"course1\\", 60.0), (\\"course2\\", 70.0)], \\"user3\\": [(\\"course1\\", 40.0), (\\"course2\\", 45.0)] } threshold_percentage = 50.0 ``` - Output: `[\\"user1\\", \\"user3\\"]`","solution":"from typing import Dict, List, Tuple def identify_low_engagement_users(users_data: Dict[str, List[Tuple[str, float]]], threshold_percentage: float) -> List[str]: Identify users who are not making significant progress in their courses. Parameters: - users_data: Dictionary where the key is the user ID (str), and the value is a list of tuples containing course IDs (str) and completion percentages (float). - threshold_percentage: A float, the minimum average completion percentage required to consider a user as engaged. Returns: - List of user IDs (str) who have an average course completion below the threshold. low_engagement_users = [] for user_id, courses in users_data.items(): if courses: average_completion = sum(completion for _, completion in courses) / len(courses) if average_completion < threshold_percentage: low_engagement_users.append(user_id) return low_engagement_users"},{"question":"# Problem Statement Implement a function to perform string segmentation into a histogram of word frequencies from a text input. The function should be capable of handling text strings containing letters, digits, punctuations, and whitespace. # Requirements Implement the following function: 1. **word_histogram(text: str) -> Dict[str, int]** - Function to generate a frequency histogram of words in the text input. - Input: A string containing the text to be analyzed. - Output: A dictionary where the keys are the words from the text and the values are the frequencies of those words. # Constraints - The input string can contain letters (case-insensitive), digits, punctuations, and white spaces. - Words should be considered case-insensitively (e.g., \\"Dog\\" and \\"dog\\" should be considered the same word). - Punctuation should be ignored when segmenting the text into words. - The words should only contain alphanumeric characters. - The order of keys in the output dictionary does not matter. # Example ```python def test_word_histogram(): assert word_histogram(\\"Hello, world! Hello.\\") == {\\"hello\\": 2, \\"world\\": 1} assert word_histogram(\\"This is a test. This test is simple.\\") == {\\"this\\": 2, \\"is\\": 2, \\"a\\": 1, \\"test\\": 2, \\"simple\\": 1} assert word_histogram(\\"Numbers 123, 123, and 456!\\") == {\\"numbers\\": 1, \\"123\\": 2, \\"and\\": 1, \\"456\\": 1} assert word_histogram(\\"\\") == {} test_word_histogram() ``` # Notes * Ensure your function handles empty input strings gracefully, returning an empty dictionary. * The function should be insensitive to any leading, trailing, or excessive whitespace between words. * Consider using regular expressions for efficient text segmentation and cleaning. * Handle typical edge cases such as numeric strings, mixed case input, and punctuation adjacency. This problem requires you to demonstrate string manipulation, regular expressions, and dictionary handling in Python. Ensure your implementation optimizes for both clarity and efficiency.","solution":"import re from collections import defaultdict from typing import Dict def word_histogram(text: str) -> Dict[str, int]: Generates a word frequency histogram from the input text. # Convert the text to lowercase text = text.lower() # Use regular expressions to find all words words = re.findall(r\'bw+b\', text) # Use a defaultdict to count the word frequencies histogram = defaultdict(int) for word in words: histogram[word] += 1 return dict(histogram)"},{"question":"# Context You are given a list of integers where each integer appears exactly twice, except for one integer which appears only once. # Problem Statement Write a function `find_single_number(nums)` that finds the integer which appears only once in the list. Your algorithm should run in linear time and use constant extra space. # Input - `nums`: A list of integers. # Output - An integer which is the single number in the list. # Constraints - The length of `nums` will be in the range [1, 2 * 10^4]. - Each integer in `nums` will be in the range [-3 * 10^4, 3 * 10^4]. # Example ```python >>> find_single_number([2, 2, 1]) 1 >>> find_single_number([4, 1, 2, 1, 2]) 4 >>> find_single_number([1]) 1 ``` # Implementation ```python def find_single_number(nums): single_number = 0 for num in nums: single_number ^= num return single_number ``` # Explanation: - The xor operation has a property where a number xor-ed with itself is zero. Thus, when you xor all the numbers in the list, pairs will cancel each other, and you will be left with the single number that appears once.","solution":"def find_single_number(nums): Returns the single number that appears only once in the list. Args: nums (list of int): List of integers where each integer appears twice except for one. Returns: int: The integer that appears only once in the list. single_number = 0 for num in nums: single_number ^= num return single_number"},{"question":"# Problem Statement: **Zero-Sum Subarray Detection** You are given an array of integers and your task is to determine if there exists a contiguous subarray that sums up to zero. Implement a function that returns a boolean value indicating whether such a subarray exists. # Function Signature: ```python def has_zero_sum_subarray(nums: list) -> bool: ``` # Input: - `nums`: A list of integers, possibly containing both positive and negative values. # Output: - A boolean value: `True` if there exists at least one contiguous subarray whose sum is zero, otherwise `False`. # Constraints: - The length of the array will be between 1 and 10^5. - Each element of the array will be in the range of -10^5 to 10^5. # Example: ```python assert has_zero_sum_subarray([1, 2, -3, 3, 2]) == True assert has_zero_sum_subarray([1, 2, 3, -1, -2]) == True assert has_zero_sum_subarray([1, 2, 3]) == False assert has_zero_sum_subarray([-1, 1]) == True assert has_zero_sum_subarray([0]) == True ``` # Implementation Requirements: 1. The function must run in linear time O(n). 2. The function should not use extra space proportional to the input size beyond a constant factor (i.e., should work in O(n) space complexity due to the use of a hash map). # Scenario: Imagine you are working on a financial application where you need to analyze transaction records and identify periods where cumulative transactions sum up to zero. This could help in detecting potential fraudulent activity or accounting errors. This problem tests your ability to use efficient algorithms and data structures to solve real-world problems with constraints on time and space complexity. # Constraints to Consider: - Ensure that the input validation is robust and handles cases like an array of all positive numbers, all negative numbers, and arrays with zeros appropriately. - The solution should efficiently handle large input sizes up to the given constraints. --- This question is designed to seamlessly integrate with the example question on Dutch National Flag Sorting by maintaining a similar structure and level of complexity. It also tests a different, yet fundamental, programming concept (prefix sums and hash maps) to ensure a well-rounded assessment.","solution":"def has_zero_sum_subarray(nums): Determines if there exists a contiguous subarray that sums to zero. Args: nums (list): List of integers Returns: bool: True if such a subarray exists, False otherwise prefix_sum = 0 seen_sums = set() for num in nums: prefix_sum += num if prefix_sum == 0 or prefix_sum in seen_sums: return True seen_sums.add(prefix_sum) return False"},{"question":"# Binary Search Tree Implementation with Duplicate Handling Problem Statement: You are tasked with implementing a binary search tree (BST) that supports insertion, deletion, and search operations. Additionally, your BST should handle duplicate values by maintaining a count of each value within the nodes. Requirements: 1. **Function Signature**: ```python class TreeNode: def __init__(self, value: int) -> None: self.value: int = value self.count: int = 1 self.left: Optional[TreeNode] = None self.right: Optional[TreeNode] = None class BST: def __init__(self) -> None: def insert(self, value: int) -> None: def delete(self, value: int) -> None: def search(self, value: int) -> bool: def in_order_traversal(self) -> List[int]: def __repr__(self) -> str: ``` 2. **Input and Output Format**: - `insert(self, value: int)`: Inserts a value into the BST. If the value already exists, increments its count. - `delete(self, value: int)`: Decreases the count of a value. If the count becomes zero, removes the node. - `search(self, value: int)`: Searches for a value in the BST and returns `True` if found, otherwise `False`. - `in_order_traversal(self)`: Performs an in-order traversal and returns a list of values in sorted order, including duplicates. - `__repr__(self)`: Returns a string representation of the BST. 3. **Constraints**: - Value type is restricted to integers. - Ensure that insertions, deletions, and searches maintain the BST properties. - Handle duplicates by maintaining count within the nodes. 4. **Performance Requirements**: - Average case operations for insertion, deletion, and search should be logarithmic time O(log n). Example Usage: ```python # Initializing BST bst = BST() # Inserting elements bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(3) # Searching for elements print(bst.search(3)) # Output: True print(bst.search(6)) # Output: False # Deleting elements bst.delete(3) print(bst.search(3)) # Output: True bst.delete(3) print(bst.search(3)) # Output: False # In-order traversal print(bst.in_order_traversal()) # Output: [5, 7] # String representation of BST print(bst) # Output: BST(5:1, 7:1) ``` Implement the `BST` class to fulfill the above specifications.","solution":"class TreeNode: def __init__(self, value: int) -> None: self.value: int = value self.count: int = 1 self.left: \'TreeNode\' = None self.right: \'TreeNode\' = None class BST: def __init__(self) -> None: self.root: TreeNode = None def insert(self, value: int) -> None: if self.root is None: self.root = TreeNode(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node: TreeNode, value: int) -> None: if value == node.value: node.count += 1 elif value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert_recursive(node.left, value) else: # value > node.value if node.right is None: node.right = TreeNode(value) else: self._insert_recursive(node.right, value) def delete(self, value: int) -> None: self.root = self._delete_recursive(self.root, value) def _delete_recursive(self, node: TreeNode, value: int) -> TreeNode: if not node: return node if value < node.value: node.left = self._delete_recursive(node.left, value) elif value > node.value: node.right = self._delete_recursive(node.right, value) else: if node.count > 1: node.count -= 1 else: if not node.left: return node.right elif not node.right: return node.left temp = self._min_value_node(node.right) node.value = temp.value node.count = temp.count temp.count = 1 node.right = self._delete_recursive(node.right, temp.value) return node def _min_value_node(self, node: TreeNode) -> TreeNode: current = node while current.left is not None: current = current.left return current def search(self, value: int) -> bool: return self._search_recursive(self.root, value) def _search_recursive(self, node: TreeNode, value: int) -> bool: if node is None: return False if value == node.value: return True elif value < node.value: return self._search_recursive(node.left, value) else: # value > node.value return self._search_recursive(node.right, value) def in_order_traversal(self) -> list: result = [] self._in_order_traversal_recursive(self.root, result) return result def _in_order_traversal_recursive(self, node: TreeNode, result: list) -> None: if node: self._in_order_traversal_recursive(node.left, result) result.extend([node.value] * node.count) self._in_order_traversal_recursive(node.right, result) def __repr__(self) -> str: elements = [] self._in_order_traversal_repr(self.root, elements) return \\"BST(\\" + \\", \\".join(f\\"{val}:{cnt}\\" for val, cnt in elements) + \\")\\" def _in_order_traversal_repr(self, node: TreeNode, elements: list) -> None: if node: self._in_order_traversal_repr(node.left, elements) elements.append((node.value, node.count)) self._in_order_traversal_repr(node.right, elements)"},{"question":"# Unique Triplets Sum to Zero Given an array of integers, write a function to find all unique triplets in the array which sum to zero. The solution should avoid duplicate triplets. # Objective Implement an algorithm that efficiently finds all unique triplets (i.e., triplets that do not contain the same combination of numbers) in the provided array which sum to zero. # Requirements 1. Implement a function `find_unique_triplets(nums: list[int]) -> list[list[int]]` that returns a list of unique triplets that sum to zero. 2. The solution should handle possible duplicates in the input array and return only unique triplets. 3. Ensure the function handles edge cases such as arrays with less than three elements, arrays where no triplets can be found, and arrays with all identical elements efficiently. # Input A list of integers, `nums`, which may include positive, negative, and zero values. # Output A list of lists, where each inner list represents a triplet that sums to zero. # Constraints * The array length can vary between 1 and 3000 elements. * The elements within the array are in the range of -10^4 to 10^4. * The solution must not include duplicate triplets in the output. # Example ```python >>> find_unique_triplets([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] >>> find_unique_triplets([]) [] >>> find_unique_triplets([0, 0, 0]) [[0, 0, 0]] >>> find_unique_triplets([-2, 0, 1, 1, 2]) [[-2, 0, 2], [-2, 1, 1]] ``` # Performance Requirements * The function should aim to run in O(n^2) time complexity for an optimal solution, although O(n^3) is acceptable for simplicity. * The implementation should leverage sorting and two-pointer technique to efficiently find triplets while avoiding duplicates. # Note This problem is designed to test your ability to handle combinations and optimize nested loops for better performance.","solution":"def find_unique_triplets(nums): Returns all unique triplets in the array which sum to zero. Args: nums : list[int] List of integers. Returns: list[list[int]] List of unique triplets that sum to zero. nums.sort() res = [] for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, len(nums) - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total < 0: left += 1 elif total > 0: right -= 1 else: res.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 return res"},{"question":"# Problem Statement You are tasked with implementing a function that calculates all possible subsets (the power set) of a given list of integers. The solution should avoid using recursion and should handle moderately-sized lists efficiently. # Function Signature ```python def calculate_power_set(arr: list) -> list: ``` # Input * `arr` (list of int): A list of integers. The length of the list `n` can be up to 10. # Output * `list of lists`: A list containing all possible subsets of the input list. # Constraints 1. The input list can be empty or contain up to 10 integers. 2. The integers can be negative, zero, or positive. # Examples 1. `calculate_power_set([])` should return `[[]]` 2. `calculate_power_set([1])` should return `[[], [1]]` 3. `calculate_power_set([1, 2])` should return `[[], [1], [2], [1, 2]]` 4. `calculate_power_set([1, 2, 3])` should return `[[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]` # Requirements 1. The solution should be efficient and avoid redundant calculations. 2. Consider edge cases and handle them appropriately: - Empty list - List with identical elements (even though results will not differ for unique subsets) 3. The function should not use any recursive approach. # Scenario Imagine you are developing a game where you need to generate all possible combinations of in-game items that a player can hold. Knowing the power set helps in creating various inventory configurations for testing and gameplay balancing. Implement the function to facilitate this process.","solution":"def calculate_power_set(arr): Given a list of integers, returns all possible subsets (the power set) of the list. power_set = [[]] for num in arr: new_subsets = [subset + [num] for subset in power_set] power_set.extend(new_subsets) return power_set"},{"question":"# Problem Statement A warehouse has a set of packages, each with a distinct weight. Your task is to implement a function that determines the heaviest package that can be shipped without exceeding a given weight limit. The warehouse can only ship one package at a time. # Function Signature ```python def find_heaviest_package(packages: List[int], weight_limit: int) -> int: pass ``` # Input * A list of integers `packages` (1 ≤ len(packages) ≤ 10^5), where each integer represents the weight of a package. * A single integer `weight_limit` (1 ≤ weight_limit ≤ 10^6), which represents the maximum allowable shipping weight. # Output * A single integer representing the weight of the heaviest package that can be shipped without exceeding the weight limit. * If no package can be shipped, the function should return -1. # Example ```python print(find_heaviest_package([10, 15, 45, 30, 50, 25], 40)) # Should output 30 print(find_heaviest_package([10, 20, 30, 40, 50], 25)) # Should output 20 print(find_heaviest_package([100, 200, 300], 50)) # Should output -1 ``` # Constraints * The input list will always contain positive integers. * The weight limit is guaranteed to be a positive integer. * If multiple packages have the same weight and are the heaviest under the limit, any of them can be considered as the result. # Performance Requirements Your implementation should be optimized to handle the upper limits of the input size efficiently.","solution":"from typing import List def find_heaviest_package(packages: List[int], weight_limit: int) -> int: max_weight = -1 for weight in packages: if weight <= weight_limit and weight > max_weight: max_weight = weight return max_weight"},{"question":"# JSON Data Validator and Extractor Objective: Craft a Python function to validate JSON data and extract specific information, emphasizing common data manipulation techniques and familiarity with JSON structures. Problem Description: You are required to write a function `validate_and_extract(json_string: str) -> dict` that takes a JSON string, confirms its validity, extracts certain fields, and returns them in a simplified dictionary format. This task will evaluate your ability to handle JSON parsing, data validation, and manipulation. Input: - `json_string`: A string representing a JSON object. Output: - A dictionary containing specific extracted fields or a validation error message. Constraints: - The JSON input can be assumed to represent typical nested data structures. - The function should handle various field types including strings, integers, and nested objects. - If the JSON is invalid, the function should return a dictionary with an error message: `{\\"error\\": \\"Invalid JSON\\"}`. Requirements: 1. Parse the JSON string and confirm its validity. 2. Extract the following fields: `name`, `age`, and `city` assuming they are present in a nested structure under the `person` field. 3. If any of the required fields are missing, return the dictionary without that field. 4. Include appropriate error handling for JSON parsing. 5. The solution must handle edge cases such as missing fields and incorrect data types gracefully. Example Input: ```json {\\"person\\": {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"Wonderland\\"}, \\"additional_info\\": {\\"hobbies\\": [\\"reading\\", \\"chess\\"]}} ``` Example Output: ```python { \\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"Wonderland\\" } ``` Example Usage: ```python data = \'{\\"person\\": {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"Wonderland\\"}, \\"additional_info\\": {\\"hobbies\\": [\\"reading\\", \\"chess\\"]}}\' result = validate_and_extract(data) print(result) # Output should be {\'name\': \'Alice\', \'age\': 30, \'city\': \'Wonderland\'} ``` Implementation Strategy: 1. Parse the input JSON string and check for validity. 2. Traverse the nested structure to extract the `name`, `age`, and `city` fields. 3. Construct and return the resulting dictionary. 4. Implement error handling to manage invalid JSON and handle missing fields gracefully. ```python import json def validate_and_extract(json_string: str) -> dict: Validate JSON string and extract specific fields. :param json_string: The JSON string to validate and extract from. :return: A dictionary with extracted fields or an error message. try: # Parse the JSON string data = json.loads(json_string) person = data.get(\\"person\\", {}) # Extract required fields extracted_data = { \\"name\\": person.get(\\"name\\"), \\"age\\": person.get(\\"age\\"), \\"city\\": person.get(\\"city\\") } return {k: v for k, v in extracted_data.items() if v is not None} except json.JSONDecodeError: return {\\"error\\": \\"Invalid JSON\\"} # Example usage if __name__ == \\"__main__\\": data = \'{\\"person\\": {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"Wonderland\\"}, \\"additional_info\\": {\\"hobbies\\": [\\"reading\\", \\"chess\\"]}}\' print(validate_and_extract(data)) # Output should be {\'name\': \'Alice\', \'age\': 30, \'city\': \'Wonderland\'} ```","solution":"import json def validate_and_extract(json_string: str) -> dict: Validate JSON string and extract specific fields. :param json_string: The JSON string to validate and extract from. :return: A dictionary with extracted fields or an error message. try: # Parse the JSON string data = json.loads(json_string) person = data.get(\\"person\\", {}) # Extract required fields extracted_data = { \\"name\\": person.get(\\"name\\"), \\"age\\": person.get(\\"age\\"), \\"city\\": person.get(\\"city\\") } return {k: v for k, v in extracted_data.items() if v is not None} except json.JSONDecodeError: return {\\"error\\": \\"Invalid JSON\\"}"},{"question":"# Problem Description You are given a list of integers `heights` representing the heights of a series of adjacent buildings. Each building has a width of 1. The buildings form a histogram where the width of each bar is 1. Write a function `largest_rectangle_area(heights: List[int]) -> int` that computes the area of the largest rectangle contained within the histogram. # Input * `heights`: A list of integers representing the heights of the buildings (0 ≤ heights[i] ≤ 10^4). The length of the list will not exceed 10^5. # Output * Returns an integer representing the area of the largest rectangle within the histogram. # Constraints * The list `heights` will always have at least one element. # Example ```python heights = [2, 1, 5, 6, 2, 3] print(largest_rectangle_area(heights)) # Output: 10 heights = [2, 4] print(largest_rectangle_area(heights)) # Output: 4 ``` # Note To solve this problem efficiently, you can use a stack to keep track of histogram indices. The goal is to find the largest rectangle that can be formed by the buildings. By iterating through the list and maintaining the stack of indices with increasing building heights, you can compute the maximum area by popping the stack when a smaller height is encountered. # Steps to Solve 1. Initialize an empty stack and a variable to store the maximum area. 2. Iterate through the `heights` list. 3. For each building, maintain the stack such that the indices of the buildings in the stack are in increasing order of their heights. 4. When a building height is less than the height of the building indexed at the top of the stack, pop the stack and compute the area of the rectangle with the popped height as the smallest (bounding) height. 5. Continue this process until the end of the list. 6. Ensure to handle any remaining heights in the stack to compute possible maximum areas.","solution":"from typing import List def largest_rectangle_area(heights: List[int]) -> int: Computes the area of the largest rectangle contained within the histogram. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"Array Element Count Histogram # Context You are required to write a function that generates a histogram-like count of elements in an array. This task is useful in data analysis scenarios where summarizing the frequency of elements helps in understanding the distribution within the data set. # Task Implement a function `generate_histogram` that takes a list of integers and returns a dictionary with each unique integer as keys and their counts as values. The function should: 1. Handle an empty list input gracefully and return an empty dictionary. 2. Ensure the keys in the resulting dictionary are the unique elements from the list. 3. Ensure that the values represent the correct count of each unique element from the list. # Function Signature ```python def generate_histogram(arr: list) -> dict: pass ``` # Inputs and Outputs - **Input**: - `arr`: A list of integers which may include repetitions. - **Output**: - A dictionary with integers as keys and their respective counts as values. # Constraints - The list `arr` will contain integers in the range from `-10^6` to `10^6`. - The list `arr` can be of length from 0 to `10^6`. # Example Usage ```python assert generate_histogram([1, 2, 2, 3, 3, 3, 4]) == {1: 1, 2: 2, 3: 3, 4: 1} assert generate_histogram([5, 5, 5, 5]) == {5: 4} assert generate_histogram([]) == {} assert generate_histogram([-1, -2, -2, -1, -1]) == {-1: 3, -2: 2} ``` # Notes 1. You can utilize Python\'s collections module or regular dictionary operations. 2. Ensure the function performs efficiently even on large lists by considering appropriate data structures.","solution":"def generate_histogram(arr: list) -> dict: Generates a histogram-like count of elements in an array. Parameters: arr (list): A list of integers which may include repetitions. Returns: dict: A dictionary with integers as keys and their respective counts as values. histogram = {} for num in arr: if num in histogram: histogram[num] += 1 else: histogram[num] = 1 return histogram"},{"question":"# Context: You have been hired by a company developing a geometric shapes library. One of the essential features they want to include is the ability to dynamically compute the area of various regular polygons given the side length and the number of sides. # Task: Extend the `RegularPolygon` class to support dynamic area calculation for any regular polygon based on its side length and the number of sides. # Requirements: 1. **Class Implementation:** - Add a method `calculate_area` to the `RegularPolygon` class which returns the area of the polygon. - Ensure that the class handles polygons with any number of sides (greater than 2). 2. **Mathematical Calculation:** - Use the formula for the area of a regular polygon: [ text{Area} = frac{n cdot s^2}{4 cdot tan(pi/n)} ] where ( n ) is the number of sides and ( s ) is the length of each side. 3. **Edge Case Handling:** - Ensure the method returns a valid result for large numbers of sides. - Handle the case where the number of sides ( n leq 2 ) gracefully. 4. **Testing:** - Demonstrate the correctness of your implementation with several test cases. **Input and Output formats:** - **Input:** An instance of `RegularPolygon` with side length and number of sides. - **Output:** The correct area of the polygon. **Constraints:** - Use sufficient precision for calculations, consider using numpy for mathematical operations. - Assume the `RegularPolygon` class is defined as follows: ```python class RegularPolygon: def __init__(self, side_length, num_sides): self.side_length = side_length self.num_sides = num_sides ``` # Example: ```python import numpy as np class RegularPolygon: def __init__(self, side_length, num_sides): self.side_length = side_length self.num_sides = num_sides def calculate_area(self): if self.num_sides <= 2: raise ValueError(\\"Number of sides must be greater than 2\\") return (self.num_sides * self.side_length ** 2) / (4 * np.tan(np.pi / self.num_sides)) # Example Usage: triangle = RegularPolygon(3, 3) assert np.isclose(triangle.calculate_area(), 3.897114317029974) square = RegularPolygon(4, 4) assert np.isclose(square.calculate_area(), 16.0) hexagon = RegularPolygon(2, 6) assert np.isclose(hexagon.calculate_area(), 10.392304845413264) ``` **Note:** Make sure to handle edge cases and import necessary modules for mathematical calculations.","solution":"import numpy as np class RegularPolygon: def __init__(self, side_length, num_sides): self.side_length = side_length self.num_sides = num_sides def calculate_area(self): if self.num_sides <= 2: raise ValueError(\\"Number of sides must be greater than 2\\") return (self.num_sides * self.side_length ** 2) / (4 * np.tan(np.pi / self.num_sides))"},{"question":"# Find the Longest Increasing Subsequence You are designing a performance review tool that analyzes employee performance metrics over time. One key feature is to identify the longest span of continuous improvement for an employee. Write the `longest_increasing_subsequence` function that takes a list of integers where each integer represents a performance score recorded in chronological order. This function should return the length of the longest subsequence of these scores that is strictly increasing. # Implementation Details: - **Input**: - `scores` (list of integers): A list of performance scores. - **Output**: - `int`: The length of the longest increasing subsequence. - **Constraints**: - 1 <= len(scores) <= 1000 - All scores are between 0 and 10000 inclusive # Examples ```python >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 # The longest increasing subsequence is [2, 3, 7, 101] >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 # The longest increasing subsequence is [0, 1, 2, 3] >>> longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) 1 # The longest increasing subsequence is [7] ``` # Implementation Hints 1. Use dynamic programming to keep track of the longest increasing subsequence up to each position in the list. 2. Create a list `dp` where `dp[i]` represents the length of the longest increasing subsequence that ends with the element at index `i`. 3. Initialize `dp` with 1s since the minimum possible length for any subsequence is 1. 4. Iterate through the list and update `dp` values by comparing each element with all previous elements.","solution":"def longest_increasing_subsequence(scores): Returns the length of the longest strictly increasing subsequence of performance scores. if not scores: return 0 n = len(scores) dp = [1] * n for i in range(1, n): for j in range(i): if scores[i] > scores[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"# Scenario You are developing a utility for a data processing application that needs to merge and sort data records from multiple sources. The input is a list of lists, where each inner list represents a set of sorted records from a source. The task is to merge all these sorted lists into a single sorted list while maintaining the sorted order. This utility should be efficient and able to handle large datasets. # Objective Implement a function that merges multiple sorted lists into a single sorted list. # Function Signature ```python def merge_sorted_lists(lists: List[List[int]]) -> List[int]: pass ``` # Input * `lists`: A list of lists, where each inner list contains integers sorted in ascending order. # Output * A single list containing all the integers from the input lists, sorted in ascending order. # Constraints * The total number of integers in all lists combined does not exceed 100,000. * Each inner list is individually sorted in ascending order. * The input lists may be of varying lengths, including some that may be empty. # Example ```python assert merge_sorted_lists([[1, 3, 5], [2, 4, 6], [0, 7, 8]]) == [0, 1, 2, 3, 4, 5, 6, 7, 8] assert merge_sorted_lists([[], [1, 2, 3], [4, 5], [6, 7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert merge_sorted_lists([[10, 20], [5, 15], [1, 25]]) == [1, 5, 10, 15, 20, 25] assert merge_sorted_lists([[]]) == [] ```","solution":"from heapq import heappush, heappop from typing import List def merge_sorted_lists(lists: List[List[int]]) -> List[int]: Merges multiple sorted lists into a single sorted list. min_heap = [] result = [] # Push the first element from each list along with the index of the list and index of the element in the list for i, lst in enumerate(lists): if lst: heappush(min_heap, (lst[0], i, 0)) while min_heap: value, list_index, element_index = heappop(min_heap) result.append(value) next_element_index = element_index + 1 if next_element_index < len(lists[list_index]): heappush(min_heap, (lists[list_index][next_element_index], list_index, next_element_index)) return result"},{"question":"# Problem Statement You have been provided with a partially implemented `MinAugmentedBST` class designed to efficiently support insertions and minimum value queries in a binary search tree structure. Your task is to complete the implementation of this class. The class should support the following operations: * **Initialization**: Create an empty augmented BST. * **`insert(value: int) -> None`**: Insert a new node with the given `value` into the BST. * **`get_min() -> int`**: Return the minimum value stored in the BST. # Function Signature Here\'s the function signature you should implement: ```python class MinAugmentedBST: def __init__(self) -> None: pass def insert(self, value: int) -> None: pass def get_min(self) -> int: pass ``` # Input/Output Format * The constructor initializes an empty MinAugmentedBST. * The `insert` method takes an integer `value`, inserting a new node with that value into the BST. * The `get_min` method returns the minimum value currently stored in the BST. # Constraints * The BST can contain at most `100000` nodes. * The value of nodes is within the range `-10^9 <= value <= 10^9`. # Examples ```python # Example 1 bst = MinAugmentedBST() bst.insert(10) print(bst.get_min()) # Output: 10 bst.insert(5) print(bst.get_min()) # Output: 5 bst.insert(15) print(bst.get_min()) # Output: 5 # Example 2 bst.insert(-5) print(bst.get_min()) # Output: -5 bst.insert(-10) print(bst.get_min()) # Output: -10 bst.insert(0) print(bst.get_min()) # Output: -10 ``` **Performance Requirement** Your solution should aim to maintain efficient operations, specifically ensuring that both the insertion and minimum value retrieval operate within logarithmic time complexity on average (`O(log N)` for insertions and `O(1)` for `get_min()`).","solution":"class MinAugmentedBST: class Node: def __init__(self, value: int): self.value = value self.left = None self.right = None def __init__(self) -> None: self.root = None self.min_value = None def insert(self, value: int) -> None: if self.root is None: self.root = self.Node(value) self.min_value = value else: self._insert(self.root, value) self.min_value = min(self.min_value, value) def _insert(self, node, value): if value < node.value: if node.left is None: node.left = self.Node(value) else: self._insert(node.left, value) else: if node.right is None: node.right = self.Node(value) else: self._insert(node.right, value) def get_min(self) -> int: if self.min_value is not None: return self.min_value else: raise ValueError(\\"The BST is empty, no minimum value available.\\")"},{"question":"# Coding Question: String Compression and Verification Objective: You are given two functions: one that compresses a string and another that verifies the compression. Your task is to enhance these functions and write a new function that uses both to solve a given problem. Problem Statement: Write a function `compress_and_verify(input_string: str, verify_against: str) -> bool` that takes as input two strings: `input_string` and `verify_against`. This function should: 1. Compress the `input_string` using the provided string compression method. 2. Verify if the compressed string matches the `verify_against` string. The compression method transforms the string by reducing consecutive repeating characters to the character followed by the count of repetitions. For instance, \\"aaabb\\" would be compressed to \\"a3b2\\". Function Signature: ```python def compress_and_verify(input_string: str, verify_against: str) -> bool: pass ``` Expected Input and Output: - **Input**: Two strings `input_string` and `verify_against` (e.g., \\"a3b2\\" and \\"a3b2\\") - **Output**: A boolean value indicating whether the compressed version of `input_string` matches the `verify_against` string. Constraints: - `input_string` will contain only lowercase alphabetical characters. - `verify_against` will be a valid compressed string or an empty string. Performance Requirements: - Time complexity should be O(n) - Space complexity should be O(1) Example: ```python >>> compress_and_verify(\\"aaabb\\", \\"a3b2\\") True >>> compress_and_verify(\\"aaabbc\\", \\"a3b2c\\") True >>> compress_and_verify(\\"aabccc\\", \\"a2b1c3\\") True >>> compress_and_verify(\\"aabb\\", \\"a2b3\\") False ``` Additional Requirements: - Reuse and enhance the provided functions `compress_string` and `verify_compression`. - Handle improper input by raising an appropriate ValueError with a descriptive message. ```python # Provided Functions def compress_string(input_string: str) -> str: Compresses the input string by reducing consecutive repeating characters to the character followed by the count of repetitions. Example: \\"aaabb\\" -> \\"a3b2\\" if not input_string: return \\"\\" compressed = [] current_char = input_string[0] count = 1 for char in input_string[1:]: if char == current_char: count += 1 else: compressed.append(f\\"{current_char}{count}\\") current_char = char count = 1 compressed.append(f\\"{current_char}{count}\\") return \'\'.join(compressed) def verify_compression(compressed_string: str, verify_against: str) -> bool: Verifies if the compressed string matches the given \'verify_against\' string. return compressed_string == verify_against # You are now required to implement the function \'compress_and_verify\' def compress_and_verify(input_string: str, verify_against: str) -> bool: Compress the input_string and verify if it matches the verify_against string. compressed_string = compress_string(input_string) return verify_compression(compressed_string, verify_against) ```","solution":"def compress_string(input_string: str) -> str: Compresses the input string by reducing consecutive repeating characters to the character followed by the count of repetitions. Example: \\"aaabb\\" -> \\"a3b2\\" if not input_string: return \\"\\" compressed = [] current_char = input_string[0] count = 1 for char in input_string[1:]: if char == current_char: count += 1 else: compressed.append(f\\"{current_char}{count}\\") current_char = char count = 1 compressed.append(f\\"{current_char}{count}\\") return \'\'.join(compressed) def verify_compression(compressed_string: str, verify_against: str) -> bool: Verifies if the compressed string matches the given \'verify_against\' string. return compressed_string == verify_against def compress_and_verify(input_string: str, verify_against: str) -> bool: Compress the input_string using the provided compression method and verify if it matches the verify_against string. Args: input_string (str): The string to compress. verify_against (str): The string to verify against the compression result. Returns: bool: True if the compressed input_string matches the verify_against string. False otherwise. compressed_string = compress_string(input_string) return verify_compression(compressed_string, verify_against)"},{"question":"# Binary Search Tree - Insertion, Search and In-Order Traversal You have been provided with a skeleton for a Binary Search Tree class that supports insertion of nodes and in-order traversal. Your task is to extend the Binary Search Tree (BST) class to support searching for a value within the tree and deleting a node from the tree. Requirements: 1. **Implement a `search` method**: This method should search for a given value in the BST and return `True` if the value is found, otherwise `False`. 2. **Implement a `delete_node` method**: This method should delete a node with a given value from the BST and ensure that the BST properties are maintained after the deletion. # Input: 1. **Input for Insertion**: A list of integers to be inserted into the BST. 2. **Input for Search**: A single integer to be searched within the BST. 3. **Input for Deletion**: A single integer representing the value to be deleted from the BST. # Output: 1. **Output for Search**: A boolean indicating whether the value is found in the BST. 2. **Output for Deletion**: Nothing. The BST should update internally. # Constraints: - All values used for insertion, search, and deletion are unique and within the range of -10^4 to 10^4. - Maximum number of nodes in the BST is 10^4. Example: ```python bst = BinarySearchTree() values_to_insert = [50, 30, 70, 20, 40, 60, 80] for value in values_to_insert: bst.insert(value) print(bst.search(40)) # Output: True print(bst.search(100)) # Output: False bst.delete_node(20) bst.delete_node(30) bst.delete_node(50) # Perform in-order traversal to check the remaining nodes print(bst.in_order_traversal()) # Output: [40, 60, 70, 80] ``` Use the provided BinarySearchTree class skeleton and extend its functionality. Ensure your implementation is efficient and handles edge cases properly.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.value = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert_recursive(self.root, key) def _insert_recursive(self, node, key): if key < node.value: if node.left is None: node.left = TreeNode(key) else: self._insert_recursive(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert_recursive(node.right, key) def search(self, key): return self._search_recursive(self.root, key) def _search_recursive(self, node, key): if node is None: return False if node.value == key: return True elif key < node.value: return self._search_recursive(node.left, key) else: return self._search_recursive(node.right, key) def delete_node(self, key): self.root = self._delete_node_recursive(self.root, key) def _delete_node_recursive(self, node, key): if node is None: return node if key < node.value: node.left = self._delete_node_recursive(node.left, key) elif key > node.value: node.right = self._delete_node_recursive(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self._min_value_node(node.right) node.value = temp.value node.right = self._delete_node_recursive(node.right, temp.value) return node def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def in_order_traversal(self): return self._in_order_recursive(self.root, []) def _in_order_recursive(self, node, vals): if node: self._in_order_recursive(node.left, vals) vals.append(node.value) self._in_order_recursive(node.right, vals) return vals"},{"question":"# Question: Design a Scalable Logging System You are to design and implement a scalable logging system that supports the following features: 1. **Log Insertion**: A function to log messages tagged with severity levels. 2. **Log Retrieval by Range of Timestamps**: A function that retrieves logs within a specified time range. 3. **Log Statistics**: A function to retrieve the count of logs by their severity levels. The logging system should handle large volumes of logs efficiently and provide a mechanism to manage the storage and retrieval operations. Function Specifications: 1. **Log Insertion**: * Function Name: `log` * Input: `message` (a string), `timestamp` (an integer), and `severity` (a string that can be \\"INFO\\", \\"WARNING\\", or \\"ERROR\\"). * Output: None 2. **Log Retrieval by Range of Timestamps**: * Function Name: `get_logs_in_range` * Input: Start timestamp (`start_ts`), End timestamp (`end_ts`). * Output: A list of tuples, each containing `timestamp`, `severity`, and `message`, for all logs within the inclusive range `[start_ts, end_ts]`, sorted by timestamp. 3. **Log Statistics**: * Function Name: `get_log_statistics` * Output: A dictionary where keys are severity levels (\\"INFO\\", \\"WARNING\\", \\"ERROR\\") and values are counts of corresponding logs. Constraints: - Timestamps are unique and increase monotonically. - The system should be optimized for both insert and retrieval operations. - Ensure the system is capable of handling millions of log entries efficiently. Example Usage: ```python # Initialize logging system log_system = LoggingSystem() # Insert log messages log_system.log(\\"System initialized\\", 1, \\"INFO\\") log_system.log(\\"User login failed\\", 2, \\"ERROR\\") log_system.log(\\"Warning: CPU usage high\\", 3, \\"WARNING\\") log_system.log(\\"User login successful\\", 4, \\"INFO\\") # Retrieve logs in range print(log_system.get_logs_in_range(2, 4)) # Expected Output: [(2, \\"ERROR\\", \\"User login failed\\"), (3, \\"WARNING\\", \\"Warning: CPU usage high\\"), (4, \\"INFO\\", \\"User login successful\\")] # Get log statistics print(log_system.get_log_statistics()) # Expected Output: {\\"INFO\\": 2, \\"ERROR\\": 1, \\"WARNING\\": 1} ``` Implement the `LoggingSystem` class with the described functionalities. Ensure the solution is capable of handling large volumes of data efficiently.","solution":"from collections import defaultdict class LoggingSystem: def __init__(self): self.logs = [] self.log_counts = defaultdict(int) def log(self, message, timestamp, severity): self.logs.append((timestamp, severity, message)) self.log_counts[severity] += 1 def get_logs_in_range(self, start_ts, end_ts): result = [log for log in self.logs if start_ts <= log[0] <= end_ts] return sorted(result, key=lambda x: x[0]) def get_log_statistics(self): return dict(self.log_counts)"},{"question":"# Question: Calculate the Factorial Sum You are tasked with calculating the sum of factorials for all integers from 1 to n. Task Write a function `factorial_sum(n: int) -> int` that returns the sum of factorials of all integers from 1 to n. Function Signature ```python def factorial_sum(n: int) -> int: pass ``` Input - `n` (int): The end value of the range to calculate the sum of factorials. Must be a non-negative integer. Output - (int): The sum of factorials from 1 to n. Constraints - `0 <= n <= 100` (Ensure the accuracy and performance given the constraint) - Raise a `ValueError` for any input value of `n` that is negative. Examples ```python >>> factorial_sum(1) 1 >>> factorial_sum(3) 1 + 2 + 6 = 9 >>> factorial_sum(5) 1 + 2 + 6 + 24 + 120 = 153 >>> factorial_sum(0) 0 >>> factorial_sum(-5) Traceback (most recent call last): ... ValueError: param `n` must be non-negative ``` Performance Requirements Given the constraint, your function should handle calculations efficiently within reasonable time limits. --- # Solution Approach - Calculate factorials iteratively or recursively. - Accumulate the sum of factorials from 1 through the given `n`. - Handle edge cases such as `n = 0` and negative input values by raising appropriate errors.","solution":"def factorial_sum(n: int) -> int: Calculate the sum of factorials for all integers from 1 to n. Args: n (int): The end value of the range to calculate the sum of factorials. Must be a non-negative integer. Returns: int: The sum of factorials from 1 to n. Raises: ValueError: If `n` is negative. if n < 0: raise ValueError(\\"param `n` must be non-negative\\") # Function to calculate factorial iteratively def factorial(x): result = 1 for i in range(1, x + 1): result *= i return result total_sum = 0 for i in range(1, n + 1): total_sum += factorial(i) return total_sum"},{"question":"# Coding Assessment Question Problem Statement You are given a dictionary representing an organization\'s hierarchy. Each key is an employee ID, and its value is a list of IDs representing the employees directly managed by that employee. Your task is to write a function to find the highest number of levels in the hierarchy. Function Definition You need to implement the following function: ```python def find_highest_levels(hierarchy: dict) -> int: Finds the highest number of levels in the organization\'s hierarchy. :param hierarchy: A dictionary where keys are employee IDs and values are lists of IDs managed by the key employee. :return: An integer representing the highest number of levels in the hierarchy. pass ``` Input - A dictionary `hierarchy` where: - Keys are integers representing employee IDs. - Values are lists of integers representing the IDs of employees directly managed by the key. Output - An integer representing the highest number of levels in the hierarchy. Example ```python # Example 1 hierarchy = { 1: [2, 3], 2: [4, 5], 3: [], 4: [], 5: [] } print(find_highest_levels(hierarchy)) # Output: 3 # Example 2 hierarchy = { 1: [2], 2: [3], 3: [4], 4: [] } print(find_highest_levels(hierarchy)) # Output: 4 # Example 3 hierarchy = { 1: [] } print(find_highest_levels(hierarchy)) # Output: 1 ``` Constraints - The hierarchy dictionary is non-empty. - The dictionary represents a valid hierarchy (i.e., a tree structure with a single CEO who has no manager). - Employee IDs are unique. - The number of employees will not exceed 1000. Notes - Treat the root of the hierarchy (CEO) as level 1. - The input is guaranteed to form a proper tree structure (no cycles). Edge Cases - Handle the case where an employee has no subordinates correctly by considering it as a leaf node. - Consider scenarios where the hierarchy has multiple nested levels of management. Performance Requirements - The solution should traverse the entire dictionary efficiently. - The implementation should aim for a time complexity of O(n), where n is the number of employees.","solution":"def find_highest_levels(hierarchy: dict) -> int: def dfs(employee): if not hierarchy[employee]: # if no subordinates return 1 max_depth = 0 for subordinate in hierarchy[employee]: max_depth = max(max_depth, dfs(subordinate)) return max_depth + 1 # Assuming the root (CEO) is the one without manager, let\'s find it. # An employee is the root if it\'s a key but never appears in any value list all_subordinates = {sub for subs in hierarchy.values() for sub in subs} root = next(emp for emp in hierarchy if emp not in all_subordinates) return dfs(root)"},{"question":"# Problem Statement You are given a string `s` consisting of lowercase alphabets. Your task is to implement a function `reorganize_string(s: str) -> str` that rearranges the characters in the string such that no two adjacent characters are the same. If no such arrangement is possible, return an empty string. Input and Output Formats: * **Input**: - `s`: A string of lowercase alphabets. * **Output**: - Returns a string with rearranged characters or an empty string if no valid arrangement exists. Constraints: * The length of the string may be up to 10^4. * The string consists of only lowercase English letters (`a` to `z`). Example: 1. `reorganize_string(\\"aab\\")` should return `\\"aba\\"`. 2. `reorganize_string(\\"aaab\\")` should return `\\"\\"`. Performance Requirements: * The solution should be efficient enough to handle the largest possible input size within reasonable time limits.","solution":"import heapq from collections import Counter def reorganize_string(s: str) -> str: Reorganizes the string such that no two adjacent characters are the same. Returns the rearranged string or an empty string if not possible. # Count the frequency of each character freq = Counter(s) max_heap = [] # Push all characters along with their frequencies into a max heap for char, count in freq.items(): heapq.heappush(max_heap, (-count, char)) prev_char, prev_freq = None, 0 result = [] # Until the heap is empty, try to rearrange the string while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) # If there\'s a previous character to be reinserted, do so now if prev_char and prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) # Update the previous character and frequency prev_char = char prev_freq = freq + 1 # Increment frequency because we\'re using a max heap # Return the result if it\'s the same length as the input string, otherwise it\'s invalid return \'\'.join(result) if len(result) == len(s) else \\"\\""},{"question":"# Subsequence Palindrome Search: Optimal Identification Engine **Scenario**: An artificial intelligence research group is developing a text processing engine to identify the longest palindromic subsequence within a given string. This subsequence must be identified efficiently even for large input strings due to real-time performance constraints. **Task**: Write a program that takes a single string (composed of lowercase letters) and returns the length of the longest palindromic subsequence within that string. A subsequence is defined as a sequence derived by deleting some or no elements without changing the order of the remaining elements. **Input**: - A single string `s` (1 <= len(s) <= 1000). **Output**: - An integer representing the length of the longest palindromic subsequence. **Constraints**: - The string will only contain lowercase English letters. **Performance Requirements**: - Ensure the solution can handle up to the maximum input length efficiently. **Function Signature**: ```python def longest_palindromic_subsequence(s: str) -> int: pass ``` **Example**: ```python # Test with different strings s = \\"bbbab\\" print(longest_palindromic_subsequence(s)) # Output: 4 s = \\"cbbd\\" print(longest_palindromic_subsequence(s)) # Output: 2 ```","solution":"def longest_palindromic_subsequence(s: str) -> int: This function returns the length of the longest palindromic subsequence in the given string. n = len(s) # Create a 2D array to store the length of longest palindromic subsequence dp = [[0] * n for _ in range(n)] # Palindromes of single length are 1 for i in range(n): dp[i][i] = 1 # Fill the table for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1]"},{"question":"# Problem Statement You are given a list of integers representing the heights of buildings along a street. Your task is to determine the \\"skyline\\" silhouette formed by these buildings when viewed from a distance. Specifically, you need to find the critical points where the height of the skyline changes, returning a list of tuples where each tuple represents a critical point `(x, height)`. A building is represented by a tuple `[left, right, height]` where: - `left` is the x-coordinate of the left edge of the building - `right` is the x-coordinate of the right edge of the building - `height` is the height of the building The skyline is a collection of rectangular strips. The result should be a list of tuples representing the x-coordinates where the height changes in the skyline and the new height after the change. # Input and Output Format - **Input**: A list of tuples, where each tuple represents a building in the form `[left, right, height]`. - The list is non-empty and contains between 1 and 1000 buildings. - Coordinates, heights, and the number of buildings will always be non-negative integers. - **Output**: A list of tuples representing the skyline\'s critical points. Each tuple contains two integers `(x, height)`. # Constraints - The number of buildings is in the range [1, 1000]. - All building coordinates and heights are non-negative integers. # Performance Requirements - The algorithm must have a time complexity of O(n log n). - A priority queue (heap) or a similar data structure might be needed to efficiently determine the critical points in the skyline. # Task Implement a function `get_skyline(buildings: List[List[int]]) -> List[Tuple[int, int]]` to determine the skyline silhouette for the given list of buildings. **Example 1:** ``` Input: [[2, 9, 10], [3, 7, 15], [5, 12, 12], [15, 20, 10], [19, 24, 8]] Output: [(2, 10), (3, 15), (7, 12), (12, 0), (15, 10), (20, 8), (24, 0)] ``` **Example 2:** ``` Input: [[1, 5, 3], [2, 4, 4], [3, 7, 5]] Output: [(1, 3), (2, 4), (3, 5), (7, 0)] ```","solution":"from heapq import heappop, heappush from typing import List, Tuple def get_skyline(buildings: List[List[int]]) -> List[Tuple[int, int]]: # Generate events for all building points events = [] for left, right, height in buildings: events.append((left, -height, right)) # Start of building events.append((right, 0, 0)) # End of building # Sort events by the x coordinate, and by height secondarily events.sort() # Result list result = [] # Current live buildings in a heap (priority queue) live_buildings = [(0, float(\'inf\'))] # (height, end) for x, neg_height, end in events: while live_buildings[0][1] <= x: heappop(live_buildings) if neg_height: heappush(live_buildings, (neg_height, end)) max_height = -live_buildings[0][0] if not result or result[-1][1] != max_height: result.append((x, max_height)) return result"},{"question":"# Question: Implement an Efficient Data Structure for Least Frequently Used (LFU) Cache You are tasked with implementing an LFU Cache data structure to manage a set of integer keys and their corresponding integer values. Your LFU Cache must support efficient insertion, value retrieval, and removal operations based on the least frequently used policy. Your implementation should include the following functions: 1. **`put(key: int, value: int) -> None`**: This function should add a key-value pair to the cache. If the cache is already at capacity, it should remove the least frequently used item before adding the new pair. If multiple items have the same frequency, remove the least recently added one. 2. **`get(key: int) -> int`**: This function should return the value associated with the specified key if it exists in the cache. If the key does not exist, return -1. The access should update the frequency count of the key. 3. **`remove(key: int) -> None`**: This function should remove the key-value pair associated with the specified key from the cache if it exists. Input and Output Formats - The **`put`** function should take an integer key and an integer value, insert or update the key-value pair in the LFU Cache. - The **`get`** function should take an integer key and return the integer value associated with it, or -1 if the key does not exist in the cache. - The **`remove`** function should take an integer key and remove the key-value pair associated with it from the cache. Constraints - The cache should have a specified maximum capacity. - You may assume all keys and values are non-negative integers. - The functions should run in O(1) average time complexity. Example Usage ```python # Create an LFU Cache with capacity of 2 cache = LFUCache(2) # Put values cache.put(1, 1) cache.put(2, 2) # Retrieve values print(cache.get(1)) # Expected Output: 1 # Exceed capacity and ensure LFU item is removed cache.put(3, 3) # The key 2 was the least frequently used, so it should be removed print(cache.get(2)) # Expected Output: -1 # Retrieve remaining values print(cache.get(3)) # Expected Output: 3 # Put another value and ensure proper LRU removal cache.put(4, 4) # The key 1 was removed, so it should now return -1 print(cache.get(1)) # Expected Output: -1 print(cache.get(3)) # Expected Output: 3 print(cache.get(4)) # Expected Output: 4 # Remove a key cache.remove(4) # The key 4 was removed, so it should now return -1 print(cache.get(4)) # Expected Output: -1 ``` Make sure to handle edge cases and ensure your implementation efficiently maintains the LFU policy.","solution":"class Node: def __init__(self, key, value): self.key = key self.value = value self.freq = 1 class LFUCache: def __init__(self, capacity: int): self.capacity = capacity self.min_freq = 0 self.key_to_node = {} self.freq_to_keys = {} self.size = 0 def _update_freq(self, node): # Remove node from the current frequency list freq = node.freq self.freq_to_keys[freq].remove(node) if not self.freq_to_keys[freq]: del self.freq_to_keys[freq] if self.min_freq == freq: self.min_freq += 1 # Update node\'s frequency and add back to the frequency list node.freq += 1 freq = node.freq if freq not in self.freq_to_keys: self.freq_to_keys[freq] = [] self.freq_to_keys[freq].append(node) def put(self, key: int, value: int) -> None: if self.capacity == 0: return if key in self.key_to_node: node = self.key_to_node[key] node.value = value self._update_freq(node) else: if self.size == self.capacity: # Evict the least frequently used key to_evict = self.freq_to_keys[self.min_freq].pop(0) if not self.freq_to_keys[self.min_freq]: del self.freq_to_keys[self.min_freq] del self.key_to_node[to_evict.key] self.size -= 1 # Insert the new key node = Node(key, value) self.key_to_node[key] = node if 1 not in self.freq_to_keys: self.freq_to_keys[1] = [] self.freq_to_keys[1].append(node) self.min_freq = 1 self.size += 1 def get(self, key: int) -> int: if key not in self.key_to_node: return -1 node = self.key_to_node[key] self._update_freq(node) return node.value def remove(self, key: int) -> None: if key in self.key_to_node: node = self.key_to_node[key] self.freq_to_keys[node.freq].remove(node) if not self.freq_to_keys[node.freq]: del self.freq_to_keys[node.freq] del self.key_to_node[key] self.size -= 1"},{"question":"# Problem Statement Implement a function to perform basic string manipulations: removing vowels, reversing the string, and replacing spaces with underscores. 1. **Remove Vowels**: Create a function that removes all vowels from a given string. - **Input**: A string `s`. - **Output**: A string with all vowels (a, e, i, o, u, both lowercase and uppercase) removed. - **Examples**: ```python >>> remove_vowels(\\"Hello World\\") \'Hll Wrld\' >>> remove_vowels(\\"AEIOUaeiou\\") \'\' >>> remove_vowels(\\"The quick brown fox jumps over the lazy dog\\") \'Th qck brwn fx jmps vr th lzy dg\' ``` 2. **Reverse String**: Create a function that reverses a given string. - **Input**: A string `s`. - **Output**: A string that is the reverse of the input string. - **Examples**: ```python >>> reverse_string(\\"Hello World\\") \'dlroW olleH\' >>> reverse_string(\\"Palindrome\\") \'emordnilaP\' >>> reverse_string(\\"Python\\") \'nohtyP\' ``` 3. **Replace Spaces**: Create a function that replaces all spaces in a given string with underscores. - **Input**: A string `s`. - **Output**: A string with all spaces replaced by underscores. - **Examples**: ```python >>> replace_spaces(\\"Hello World\\") \'Hello_World\' >>> replace_spaces(\\"Python is fun\\") \'Python_is_fun\' >>> replace_spaces(\\" \\") \'____\' ``` Constraints - The input string for each function can include any printable characters. - Consider edge cases such as empty strings or strings with no vowels/spaces. - Ensure to preserve the original spacing and punctuation for the reverse and remove vowels operations. Write Python functions for each of the above operations and provide a comprehensive test suite to validate your solution.","solution":"def remove_vowels(s): Removes all vowels from the input string. :param s: The input string :return: String with all vowels removed vowels = \\"aeiouAEIOU\\" return \'\'.join(char for char in s if char not in vowels) def reverse_string(s): Reverses the input string. :param s: The input string :return: Reversed string return s[::-1] def replace_spaces(s): Replaces all spaces in the input string with underscores. :param s: The input string :return: String with spaces replaced by underscores return s.replace(\\" \\", \\"_\\")"},{"question":"# Problem Statement You are tasked with writing a function `weather_statistics` that will analyze the provided weather data. Your function should return the average temperature, the highest temperature, and the day(s) with the highest temperature for a given list of daily temperatures recorded over a month. # Input - **temperatures**: A list of tuples where each tuple contains a string representing the day (e.g., `\\"01-01-2023\\"`) and an integer representing the temperature on that day in degrees Celsius. # Output - A tuple containing three elements: 1. The average temperature for the month rounded to 2 decimal places. 2. The highest temperature recorded. 3. A list of strings representing the day(s) with the highest temperature. # Constraints - The length of the list will be between 28 and 31 (inclusive), representing the number of days in a month. - Temperatures can range from -50°C to 50°C. - The date string will be in the format `\\"DD-MM-YYYY\\"`. # Examples ```python >>> weather_statistics([(\\"01-01-2023\\", 20), (\\"02-01-2023\\", 25), (\\"03-01-2023\\", 22), (\\"04-01-2023\\", 25)]) (23.00, 25, [\\"02-01-2023\\", \\"04-01-2023\\"]) >>> weather_statistics([(\\"01-01-2023\\", -10), (\\"02-01-2023\\", -5), (\\"03-01-2023\\", 0), (\\"04-01-2023\\", -3)]) (-4.50, 0, [\\"03-01-2023\\"]) >>> weather_statistics([(\\"01-01-2023\\", 15), (\\"02-01-2023\\", 18), (\\"03-01-2023\\", 20), (\\"04-01-2023\\", 18)]) (17.75, 20, [\\"03-01-2023\\"]) ``` # Function Signature ```python def weather_statistics(temperatures: list[tuple[str, int]]) -> tuple[float, int, list[str]]: pass ``` # Context Imagine you work for a weather forecasting company. Your task is to summarize the monthly weather data for your users, providing them with key statistics such as the average temperature, the highest temperature, and the day(s) when the highest temperature was recorded. This helps users better understand the weather trends over the month.","solution":"def weather_statistics(temperatures): Analyze weather data to return average temperature, highest temperature, and the day(s) with the highest temperature. Parameters: temperatures (list of tuples): List of tuples where each tuple contains a string (date) and an integer (temperature) Returns: tuple: Containing average temperature (rounded to 2 decimal places), highest temperature, and list of days with highest temperature. if not temperatures: return (0.0, 0, []) total_temp = 0 max_temp = float(\'-inf\') days_with_max_temp = [] for day, temp in temperatures: total_temp += temp if temp > max_temp: max_temp = temp days_with_max_temp = [day] elif temp == max_temp: days_with_max_temp.append(day) average_temp = round(total_temp / len(temperatures), 2) return (average_temp, max_temp, days_with_max_temp)"},{"question":"Task Write a function to perform a certain operation on a set of integers, using a specific algorithmic approach. This function should follow the provided analysis and address potential edge cases. # Scenario Imagine you are a software engineer tasked with implementing a function that computes the product of all elements in a list, except the element at the current index, without using division. Each required product operation must consider all elements except the one at the current index. # Function Signature ```python def product_except_self(nums: list) -> list: pass ``` # Input * `nums`: A list of integers where each integer is non-negative. # Output * `product_except_self` should return a list of integers, where each integer at index `i` represents the product of all elements in the input list except for the element at index `i`. # Constraints * The `nums` list length is between 0 and 10^4. * Each integer in `nums` is between -30 and 30. * You must solve it without using division. # Performance Requirements * Aim for a solution with time complexity of `O(n)` and space complexity of `O(n)`. # Notes 1. Raise a `ValueError` if any integer in `nums` is not between -30 and 30. 2. If the list is empty, return an empty list. 3. Handle cases where the list has only one element correctly. # Example ```python nums = [1, 2, 3, 4] # Expected Output: [24, 12, 8, 6] print(product_except_self(nums)) # Output: [24, 12, 8, 6] ``` # Edge Cases 1. If the list is empty, the expected output is an empty list. 2. If the list contains only one element, the expected output is `[1]` since there are no other elements. 3. Handle cases where the list contains zero appropriately. Implement the `product_except_self` function and ensure that your solution passes the provided test cases.","solution":"def product_except_self(nums: list) -> list: Returns a list such that, for each index i in the input list, the resultant list contains the product of all elements except the one at index i. # Constraints check for num in nums: if num < -30 or num > 30: raise ValueError(\\"All integers in the input list must be between -30 and 30\\") n = len(nums) if n == 0: return [] if n == 1: return [1] # Initialize two lists to keep track of products left_products = [1] * n right_products = [1] * n output = [1] * n # Calculate left products for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] # Calculate right products for i in range(n-2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Calculate output based on left and right products for i in range(n): output[i] = left_products[i] * right_products[i] return output"},{"question":"# Problem Statement You are working on a project that involves calculating the edit distance (Levenshtein distance) between two strings. The edit distance is defined as the minimum number of operations required to transform one string into another, where the allowed operations are: - Insertion of a character - Deletion of a character - Substitution of a character Your task is to optimize the computation of the edit distance for large strings. # Function Signature ```python def edit_distance(str1: str, str2: str) -> int: ``` # Constraints * ( 0 leq text{len(str1)}, text{len(str2)} leq 10^6 ) * `str1` and `str2` are non-empty strings consisting of lowercase English letters. # Example ```python # Example 1 print(edit_distance(\\"kitten\\", \\"sitting\\")) # should return 3 # Example 2 print(edit_distance(\\"flaw\\", \\"lawn\\")) # should return 2 ``` # Requirements 1. **Optimization**: Use dynamic programming with space optimization techniques to handle large input sizes efficiently. 2. **Validation**: Ensure input strings are within the given constraints and handle edge cases (e.g., one or both strings being empty).","solution":"def edit_distance(str1: str, str2: str) -> int: Computes the Levenshtein distance between two strings. # Check for empty input cases if not str1: return len(str2) if not str2: return len(str1) # Use dynamic programming with space optimization n, m = len(str1), len(str2) # Previous and current row of the DP table prev_row = list(range(m + 1)) for i in range(1, n + 1): current_row = [i] * (m + 1) for j in range(1, m + 1): if str1[i - 1] == str2[j - 1]: current_row[j] = prev_row[j - 1] else: current_row[j] = min(prev_row[j] + 1, # Deletion current_row[j - 1] + 1, # Insertion prev_row[j - 1] + 1) # Substitution prev_row = current_row return prev_row[-1]"},{"question":"# Problem: Implement a Scheduler for Repeating Tasks You are tasked with implementing a basic scheduler that can manage and execute periodic tasks. The scheduler should handle tasks that repeat at a fixed interval, specified in seconds. Your goal is to create two functions: `add_task` and `run_scheduler`. 1. The `add_task` function should take a task name (str), an interval in seconds (int), and a function to execute (`callable`) as inputs and: * Add the task to an internal schedule for later execution. * Return `True` if the task is added successfully, or `False` if a task with the same name already exists. 2. The `run_scheduler` function should take an integer `runtime` (in seconds) as input and: * Execute the scheduler, running the tasks according to their intervals for the given duration. * Print \\"Executing {task_name}\\" each time a task is executed. * Ensure tasks are executed as close to their scheduled intervals as possible. Function Signatures ```python def add_task(task_name: str, interval: int, action: Callable[[], None]) -> bool: pass def run_scheduler(runtime: int) -> None: pass ``` Example ```python # Example usage and expected results def task1(): print(\\"Task 1 executed\\") def task2(): print(\\"Task 2 executed\\") # Adding tasks add_task(\\"task1\\", 3, task1) # Task 1 runs every 3 seconds add_task(\\"task2\\", 5, task2) # Task 2 runs every 5 seconds # Running the scheduler for 10 seconds would produce the following output: run_scheduler(10) # Output: # Executing task1 # Executing task2 # Executing task1 # Executing task1 # Executing task2 ``` Constraints * Task names will be unique strings. * The interval will be a positive integer. * The runtime will be a positive integer and will ensure the scheduler runs for at least one complete cycle of the longest interval task. * The functions should handle at most 10 tasks for simplicity. * The `action` function will always be a callable that takes no arguments. --- Ensure your implementation accurately schedules and executes the tasks, respecting their intervals and the provided runtime.","solution":"import time from typing import Callable, Dict, Tuple # Storage for tasks tasks: Dict[str, Tuple[int, Callable[[], None]]] = {} def add_task(task_name: str, interval: int, action: Callable[[], None]) -> bool: if task_name in tasks: return False tasks[task_name] = (interval, action) return True def run_scheduler(runtime: int) -> None: start_time = time.time() last_executed = {task_name: start_time for task_name in tasks} while (current_time := time.time()) - start_time < runtime: for task_name, (interval, action) in tasks.items(): if current_time - last_executed[task_name] >= interval: print(f\\"Executing {task_name}\\") action() last_executed[task_name] = current_time time.sleep(0.1)"},{"question":"# Coding Assessment Question Optimizing Network Packet Routing with Dijkstra\'s Algorithm As a network engineer at a telecommunications company, you are tasked with optimizing the routing of data packets through a network. To ensure the shortest path between the starting node and all other nodes in the network, you will use Dijkstra\'s Algorithm. # Problem Statement Implement a function `dijkstra_shortest_path` in Python to find the shortest paths from a source node to all other nodes in the network. The network topology will be provided in a file that specifies the connections between nodes and their respective distances. # Input Your function will read from a file with the following format: ``` node1 node2 distance node1 node3 distance ... ``` For example: ``` A B 4 A C 2 B C 5 B D 10 C D 3 D E 4 E F 1 C F 12 ``` # Function Signature ```python def dijkstra_shortest_path(file_path: str, start_node: str) -> Tuple[Dict[str, int], Dict[str, str]]: pass ``` # Parameters - `file_path`: Path to the file containing the network topology. - `start_node`: The node from which the shortest paths are to be calculated. # Output * Returns a tuple: 1. A dictionary where the keys are nodes and the values are the shortest distance from the `start_node`. 2. A dictionary for the previous node in the shortest path, useful for path reconstruction. # Constraints * All nodes are uniquely identifiable strings. * Distances are positive integers. * The maximum number of nodes is 1000. # Performance Requirements * The solution should handle input files with up to 1000 nodes efficiently. * Optimize the algorithm to run within a reasonable time frame for the full input size. # Example For the input file with the following distances: ``` A B 4 A C 2 B C 5 B D 10 C D 3 D E 4 E F 1 C F 12 ``` And the function call `dijkstra_shortest_path(\'input.txt\', \'A\')`, a possible output could be: ```python ({\'A\': 0, \'B\': 4, \'C\': 2, \'D\': 5, \'E\': 9, \'F\': 10}, {\'B\': \'A\', \'C\': \'A\', \'D\': \'C\', \'E\': \'D\', \'F\': \'E\'}) ``` This indicates the shortest distances from node \'A\' to all other nodes, and the previous node for each node in the shortest path. # Additional Instructions * Ensure your implementation handles file reading errors gracefully. * Document your code with comments explaining the key parts. * You are encouraged to write helper functions to break down different parts of the algorithm (e.g., updating distances, selecting the next node). This question aims to test your ability to implement and understand graph algorithms, along with handling input and output operations efficiently.","solution":"import heapq from typing import Dict, Tuple def dijkstra_shortest_path(file_path: str, start_node: str) -> Tuple[Dict[str, int], Dict[str, str]]: # Read the file and create the graph graph = {} with open(file_path, \'r\') as file: for line in file: node1, node2, distance = line.strip().split() distance = int(distance) if node1 not in graph: graph[node1] = [] if node2 not in graph: graph[node2] = [] graph[node1].append((node2, distance)) graph[node2].append((node1, distance)) # Dijkstra\'s algorithm initialization shortest_distances = {node: float(\'inf\') for node in graph} previous_nodes = {node: None for node in graph} shortest_distances[start_node] = 0 priority_queue = [(0, start_node)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > shortest_distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < shortest_distances[neighbor]: shortest_distances[neighbor] = distance previous_nodes[neighbor] = current_node heapq.heappush(priority_queue, (distance, neighbor)) return shortest_distances, previous_nodes"},{"question":"# Reversing Linked List Segments Context: A linked list is a data structure where each element contains a reference to the next element in the sequence. Sometimes, you may want to reverse specific segments of the linked list. For instance, given a linked list and two indices, you might need to reverse all the elements between those two indices. Task: Write a function that reverses a segment of a singly linked list. You are given the head of the linked list and two integers, `m` and `n`, representing the start and end positions (1-indexed) of the segment to be reversed. The function should return the head of the modified linked list. Requirements: 1. **Input**: - `head` (ListNode): the head of the singly linked list. - `m` (int): the start position of the segment to reverse (inclusive, 1-indexed). - `n` (int): the end position of the segment to reverse (inclusive, 1-indexed). 2. **Output**: - The head of the modified linked list after the specified segment has been reversed. Constraints: - `1 <= m <= n <= length of the linked list` - The linked list will have at least one element. Function Signature: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_between(head: ListNode, m: int, n: int) -> ListNode: pass ``` Example: Given the linked list: 1 -> 2 -> 3 -> 4 -> 5, and `m = 2`, `n = 4`: **Input**: ```python head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(3) head.next.next.next = ListNode(4) head.next.next.next.next = ListNode(5) m = 2 n = 4 ``` **Output**: ```python 1 -> 4 -> 3 -> 2 -> 5 ``` **Explanation**: The linked list segment from position 2 to position 4 (2 -> 3 -> 4) is reversed to (4 -> 3 -> 2).","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_between(head: ListNode, m: int, n: int) -> ListNode: if not head or m == n: return head # Dummy node to handle edge cases where m = 1 dummy = ListNode(0) dummy.next = head prev = dummy # Move prev to the node before the start of the segment to reverse for _ in range(m - 1): prev = prev.next # start is the first node of the segment to reverse start = prev.next then = start.next # Reverse the segment from m to n for _ in range(n - m): start.next = then.next then.next = prev.next prev.next = then then = start.next return dummy.next"},{"question":"# Coding Assessment Question Context As part of your role in developing a data analysis tool, you need to implement functionality to manipulate and analyze strings. One common requirement is to determine the frequency of characters in a given string and return the result as a dictionary. The characters should be considered case-sensitive. Task Implement a function `char_frequency(s: str) -> dict` that calculates the frequency of each character in the input string. The function takes one parameter: 1. `s`: A string (1 <= len(s) <= 1000), which can contain any printable ASCII characters. Ensure the function creates a dictionary where the keys are characters and the values are their corresponding counts in the string. Input and Output Format **Input**: * `s`: string - a string of length between 1 and 1000 characters. **Output**: * dict - a dictionary with characters as keys and their corresponding counts as values. Constraints * `1 <= len(s) <= 1000` Examples ```python # Example 1 s = \\"hello\\" char_frequency(s) # Expected Output: {\'h\': 1, \'e\': 1, \'l\': 2, \'o\': 1} # Example 2 s = \\"data analysis\\" char_frequency(s) # Expected Output: {\'d\': 1, \'a\': 4, \'t\': 1, \' \': 1, \'n\': 1, \'l\': 1, \'y\': 1, \'s\': 2, \'i\': 1} # Example 3 s = \\"Python3.8!\\" char_frequency(s) # Expected Output: {\'P\': 1, \'y\': 1, \'t\': 1, \'h\': 1, \'o\': 1, \'n\': 1, \'3\': 1, \'.\': 1, \'8\': 1, \'!\': 1} ``` Ensure that your implementation handles all edge cases, such as string containing spaces, special characters, and digits, and provides an accurate frequency count for any valid input.","solution":"def char_frequency(s: str) -> dict: Calculate the frequency of each character in the input string. :param s: string - input string with length between 1 and 1000 :return: dict - dictionary with character frequencies freq = {} for char in s: if char in freq: freq[char] += 1 else: freq[char] = 1 return freq"},{"question":"# Scenario A company needs an efficient way to evaluate the number of distinct integers present in a list of numbers. This helps them in analyzing data redundancy and creating unique identifiers. # Problem Statement Write a function `count_distinct_integers(arr: List[int]) -> int` that takes a list of integers `arr` and returns the number of distinct integers in the list. # Input/Output Format * **Input**: * A list of integers `arr` where `1 <= len(arr) <= 10^5` and each integer `1 <= arr[i] <= 10^9`. * **Output**: * An integer representing the number of distinct integers in the list. # Constraints * Ensure your algorithm is efficient and executes within a reasonable time for the upper limit. * Consider how you handle a situation where the input list is empty. # Example ```python >>> count_distinct_integers([1, 2, 3, 4, 5]) 5 >>> count_distinct_integers([1, 2, 2, 3, 3, 3]) 3 >>> count_distinct_integers([7, 8, 9, 7, 8, 7]) 3 >>> count_distinct_integers([1]) 1 >>> count_distinct_integers([]) 0 ``` # Guidance Consider the most efficient data structures for tracking unique values. Aim for a time complexity of O(n) by making use of set operations provided by Python or other equivalent mechanisms in different programming languages.","solution":"from typing import List def count_distinct_integers(arr: List[int]) -> int: Returns the number of distinct integers in the list `arr`. return len(set(arr))"},{"question":"# String Manipulation and Pattern Matching In this programming task, you will work with a custom `StringAnalyzer` class that supports various string operations. Your goal is to implement a specific method and verify its correctness. Problem Statement You are given the `StringAnalyzer` class with its current functionalities as defined in the code snippet provided. Implement the following additional feature: # Method: `longest_palindromic_substring()` Calculate the longest palindromic substring within the given string and return the result as a new string. # Expected Input and Output Formats * **Input**: The method will be called on a `StringAnalyzer` instance initialized with a string. * **Output**: A string representing the longest palindromic substring within the original string. # Constraints and Limitations: 1. The input string will contain only ASCII characters and will not exceed length 1000. 2. If there are multiple longest palindromic substrings of the same length, return the one which appears first. 3. Handle edge cases such as an empty string or a string with no palindromic substrings. Example Scenario ```python >>> s_analyzer = StringAnalyzer(\\"babad\\") >>> longest_palindrome = s_analyzer.longest_palindromic_substring() >>> longest_palindrome \'bab\' # or \'aba\' >>> s_analyzer = StringAnalyzer(\\"cbbd\\") >>> longest_palindrome = s_analyzer.longest_palindromic_substring() >>> longest_palindrome \'bb\' ``` Use this function implementation to verify the correctness of your calculations. # Implementation Complete the following method within the `StringAnalyzer` class: ```python class StringAnalyzer: def __init__(self, string: str): self.string = string def longest_palindromic_substring(self) -> str: # Your code here ``` Ensure your tested implementation takes into account various edge cases like an empty string or strings with no palindromic substrings. Evaluation Criteria * **Correctness**: The function should return the correct longest palindromic substring. * **Efficiency**: The solution should handle the given constraints. * **Readability**: The code should be clean, and well-documented.","solution":"class StringAnalyzer: def __init__(self, string: str): self.string = string def longest_palindromic_substring(self) -> str: def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] if not self.string: return \\"\\" longest_palindrome = \\"\\" for i in range(len(self.string)): # Odd length palindromes (single character center) odd_palindrome = expand_around_center(self.string, i, i) if len(odd_palindrome) > len(longest_palindrome): longest_palindrome = odd_palindrome # Even length palindromes (two character center) even_palindrome = expand_around_center(self.string, i, i + 1) if len(even_palindrome) > len(longest_palindrome): longest_palindrome = even_palindrome return longest_palindrome"},{"question":"# Question: Implement an Optimized Trie Data Structure Context: Tries, also known as prefix trees, are a type of search tree used to store associative data structures. A common application of tries is storing a predictive text or autocomplete dictionary. In this task, you will enhance the provided `Trie` class to include more advanced functionalities that ensure it can handle larger datasets more efficiently. Task: Extend the `Trie` class to include additional operations and optimizations as outlined below: Requirements: 1. **Predictive Search**: Implement a method `predict(prefix: str) -> List[str]` that returns a list of all words in the trie that start with the given prefix. - Ensure the results are returned in lexicographical order. 2. **Deletion of Words**: Implement a method `delete(word: str) -> None` that removes a word from the trie if it exists. - Ensure that deleting a word does not affect other words that share the same prefix. 3. **Word Count**: Implement a method `word_count() -> int` that returns the total number of words currently stored in the trie. Implementations: - Update the `Trie` class to include your new methods. - Add doctests or unit tests to validate the functionality of the new methods. - Ensure the existing functionality and new functionality do not interfere. Constraints: - The prefix for the `predict` method should only consist of lowercase alphabetical characters. - The `delete` method should handle cases where the word to be deleted does not exist in the trie. - `word_count` should return 0 if there are no words in the trie. Here is the starter skeleton for your updated class: ```python class TrieNode: def __init__(self): self.children = {} self.end_of_word = False class Trie: def __init__(self): self.root = TrieNode() self._word_count = 0 def insert(self, word: str) -> None: Insert a word into the trie. Args: word: The word to be inserted. Example: >>> trie = Trie() >>> trie.insert(\\"hello\\") >>> trie.word_count() 1 node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] if not node.end_of_word: node.end_of_word = True self._word_count += 1 def predict(self, prefix: str) -> List[str]: Predict and return all words that start with the given prefix. Args: prefix: The prefix to search for. Returns: A list of words that start with the given prefix in lexicographical order. Example: >>> trie = Trie() >>> trie.insert(\\"apple\\") >>> trie.insert(\\"app\\") >>> trie.insert(\\"apricot\\") >>> trie.predict(\\"app\\") [\'app\', \'apple\'] pass def delete(self, word: str) -> None: Remove a word from the trie. Args: word: The word to be removed. Example: >>> trie = Trie() >>> trie.insert(\\"hello\\") >>> trie.delete(\\"hello\\") >>> trie.word_count() 0 pass def word_count(self) -> int: Return the total number of words currently stored in the trie. Returns: The total number of words in the trie. Example: >>> trie = Trie() >>> trie.insert(\\"hello\\") >>> trie.word_count() 1 return self._word_count ``` Input and Output Format: - The input format for the `predict` method is a string representing the prefix. - The `delete` method should accept a string representing the word to be removed. - The `word_count` method does not require any inputs and returns an integer. Constraints: - The trie should efficiently handle common operations, even with a large number of words. - Ensure that the methods are robust and handle edge cases appropriately. Good luck!","solution":"class TrieNode: def __init__(self): self.children = {} self.end_of_word = False class Trie: def __init__(self): self.root = TrieNode() self._word_count = 0 def insert(self, word: str) -> None: Insert a word into the trie. Args: word: The word to be inserted. Example: >>> trie = Trie() >>> trie.insert(\\"hello\\") >>> trie.word_count() 1 node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] if not node.end_of_word: node.end_of_word = True self._word_count += 1 def predict(self, prefix: str) -> list: Predict and return all words that start with the given prefix. Args: prefix: The prefix to search for. Returns: A list of words that start with the given prefix in lexicographical order. Example: >>> trie = Trie() >>> trie.insert(\\"apple\\") >>> trie.insert(\\"app\\") >>> trie.insert(\\"apricot\\") >>> trie.predict(\\"app\\") [\'app\', \'apple\'] def _dfs(node, path, results): if node.end_of_word: results.append(\'\'.join(path)) for char in sorted(node.children): path.append(char) _dfs(node.children[char], path, results) path.pop() node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] results = [] _dfs(node, list(prefix), results) return results def delete(self, word: str) -> None: Remove a word from the trie. Args: word: The word to be removed. Example: >>> trie = Trie() >>> trie.insert(\\"hello\\") >>> trie.delete(\\"hello\\") >>> trie.word_count() 0 def _delete(node, word, depth): if depth == len(word): if node.end_of_word: node.end_of_word = False self._word_count -= 1 return not bool(node.children) char = word[depth] if char in node.children: can_delete_child = _delete(node.children[char], word, depth + 1) if can_delete_child: del node.children[char] return not bool(node.children) and not node.end_of_word return False _delete(self.root, word, 0) def word_count(self) -> int: Return the total number of words currently stored in the trie. Returns: The total number of words in the trie. Example: >>> trie = Trie() >>> trie.insert(\\"hello\\") >>> trie.word_count() 1 return self._word_count"},{"question":"Scenario: You are working on a data processing system that needs to categorize and count unique elements in a large dataset. The system must efficiently support frequent updates to the data and produce counts rapidly. # Question: Implement a data structure that allows insertions of elements and provides the number of distinct elements encountered so far. The data structure should allow frequent updates and efficiently handle querying the number of distinct elements. # Function Signature: * **class name**: `DistinctCounter` * **methods**: - `__init__(self)`: Initialize the data structure. - `insert(self, element: int)`: Insert an element into the data structure. - `count_distinct(self) -> int`: Return the number of distinct elements in the data structure. # Constraints: 1. Elements are non-negative integers. 2. The number of insert operations will be between 1 and (10^6). 3. The data structure should be optimized for both time and space. # Example: ```python # Example usage dc = DistinctCounter() dc.insert(1) dc.insert(2) print(dc.count_distinct()) # Output: 2 dc.insert(2) print(dc.count_distinct()) # Output: 2 dc.insert(3) print(dc.count_distinct()) # Output: 3 ``` # Additional Notes: - Focus on optimizing both the insertion and counting operations. - Ensure the data structure can handle large volumes of inserts efficiently. - Handle potential duplicates gracefully and correctly maintain the count of distinct elements. This question aims at testing the candidate\'s understanding of data structure design, efficient updating, and counting, reflecting the complexity of handling real-time data streams.","solution":"class DistinctCounter: def __init__(self): self.elements_set = set() def insert(self, element: int): self.elements_set.add(element) def count_distinct(self) -> int: return len(self.elements_set)"},{"question":"# Coding Assessment Question Scenario: You are developing a control system for a robotic arm that must follow a specific path defined by a series of waypoints in 2D space. The arm\'s movement should be smooth and efficient, minimizing both the distance traveled and the time taken. Task: Write a function named `calculate_trajectory` that uses cubic spline interpolation to generate the smooth trajectory of the robotic arm passing through the specified waypoints. Function Signature: ```python def calculate_trajectory(waypoints: List[Tuple[float, float]], num_points: int) -> np.ndarray: Calculate the smooth trajectory of a robotic arm using cubic spline interpolation. Parameters: waypoints (List[Tuple[float, float]]): A list of (x, y) coordinates representing the waypoints. num_points (int): The number of points to generate along the interpolated trajectory. Returns: np.ndarray: An array with shape (num_points, 2) containing the interpolated trajectory coordinates. ``` Constraints: * `len(waypoints)` >= 2 * `num_points` > 0 Example Usage: 1. Define the waypoints for the desired path: ```python waypoints = [(0, 0), (1, 2), (3, 5), (6, 1)] ``` 2. Calculate the trajectory that smoothly passes through these waypoints with 100 points: ```python trajectory = calculate_trajectory(waypoints, 100) print(trajectory) ``` This should return an array of shape (100, 2) representing the smooth trajectory of the robotic arm. Testing: - Ensure that the function generates a smooth path passing through all given waypoints. - Validate the trajectory against known analytical or empirical data for simple geometric paths, such as straight lines or curves. - Test edge cases, such as minimal number of waypoints and varying number of generated points. Notes: - Use a library like `scipy.interpolate.CubicSpline` for the interpolation. - Ensure the returned trajectory has the correct number of points and smoothly transitions from one waypoint to the next.","solution":"import numpy as np from scipy.interpolate import CubicSpline from typing import List, Tuple def calculate_trajectory(waypoints: List[Tuple[float, float]], num_points: int) -> np.ndarray: Calculate the smooth trajectory of a robotic arm using cubic spline interpolation. Parameters: waypoints (List[Tuple[float, float]]): A list of (x, y) coordinates representing the waypoints. num_points (int): The number of points to generate along the interpolated trajectory. Returns: np.ndarray: An array with shape (num_points, 2) containing the interpolated trajectory coordinates. if len(waypoints) < 2: raise ValueError(\\"At least two waypoints are required.\\") if num_points <= 0: raise ValueError(\\"Number of points must be greater than zero.\\") waypoints = np.array(waypoints) x = waypoints[:, 0] y = waypoints[:, 1] cs_x = CubicSpline(np.arange(len(x)), x) cs_y = CubicSpline(np.arange(len(y)), y) t = np.linspace(0, len(waypoints) - 1, num_points) trajectory = np.vstack((cs_x(t), cs_y(t))).T return trajectory"},{"question":"# Coding Assessment Question Context You are working on a project that involves monitoring system resources, and your task is to analyze and process a list of usage percentages to derive key statistics. Problem Statement Given a list of CPU utilization percentages recorded at regular intervals, write a function that returns the maximum utilization, minimum utilization, and the average utilization formatted to two decimal places. Write a function `usage_statistics` that computes these values. Function Signature ```python def usage_statistics(usages: List[float]) -> Tuple[float, float, float]: Returns the maximum, minimum, and average CPU utilization percentages from the provided list. Args: usages : List[float] : a list of CPU utilizations recorded at regular intervals. Returns: Tuple[float, float, float]: A tuple containing the maximum utilization, the minimum utilization, and the average utilization formatted to two decimal places. pass ``` Constraints - The input list `usages` will contain at least one and up to ( 10^5 ) CPU utilization percentages. - Each utilization percentage will be a float between 0.0 to 100.0 inclusive. - The function should handle large lists efficiently with a linear time complexity O(n). Examples ```python # Example 1 print(usage_statistics([55.5, 67.7, 48.3, 70.2, 65.1])) # Output: (70.2, 48.3, 61.36) # Example 2 print(usage_statistics([99.9, 99.8, 99.7, 99.6])) # Output: (99.9, 99.6, 99.75) # Example 3 print(usage_statistics([10.0])) # Output: (10.0, 10.0, 10.00) ``` **Note**: Ensure to use Python\'s built-in functions and list comprehensions to optimize the implementation.","solution":"from typing import List, Tuple def usage_statistics(usages: List[float]) -> Tuple[float, float, float]: Returns the maximum, minimum, and average CPU utilization percentages from the provided list. Args: usages : List[float] : a list of CPU utilizations recorded at regular intervals. Returns: Tuple[float, float, float]: A tuple containing the maximum utilization, the minimum utilization, and the average utilization formatted to two decimal places. max_usage = max(usages) min_usage = min(usages) avg_usage = round(sum(usages) / len(usages), 2) return (max_usage, min_usage, avg_usage)"},{"question":"# Problem Statement You are required to implement a simple logging mechanism to keep track of operations performed on a bounded stack data structure. A bounded stack has a fixed maximum size, and any push operation beyond this limit should fail gracefully by raising an appropriate exception. Additionally, the logging mechanism should maintain a history of all operations executed. # Task 1. Implement the BoundedStack class with a fixed maximum size. 2. Add exception handling for operations that exceed the stack’s capacity or operate on an empty stack. 3. Implement a logging mechanism that records each operation (`push`, `pop`, `top`, `is_empty`) along with a timestamp. 4. Ensure all stack operations and logging functionality are thoroughly tested. # Requirements - Initialize the `BoundedStack` class with a maximum size. - Modify the `push`, `pop`, and `top` methods to raise exceptions when they fail. - Implement logging for each method (`push`, `pop`, `top`, `is_empty`) to record the operation and a timestamp. - Provide a `get_log` method that returns all logged events in chronological order. - Validate functionality with provided sample inputs. # Example Cases Here are some cases demonstrating the expected behavior of your BoundedStack with logging: ```python import datetime stack = BoundedStack(max_size=3) try: stack.pop() except IndexError: print(\\"Exception caught: Pop from an empty stack\\") stack.push(1) stack.push(2) stack.push(3) try: stack.push(4) except OverflowError: print(\\"Exception caught: Push to a full stack\\") assert stack.top() == 3 assert stack.is_empty() == False stack.pop() stack.pop() stack.pop() try: stack.top() except IndexError: print(\\"Exception caught: Top from an empty stack\\") log = stack.get_log() for entry in log: print(entry[\\"time\\"], entry[\\"op\\"], entry[\\"value\\"]) ``` Expected output should show timestamps and operations such as: ``` <timestamp> push 1 <timestamp> push 2 <timestamp> push 3 <timestamp> push - failed (overflow) <timestamp> top 3 <timestamp> pop 3 <timestamp> pop 2 <timestamp> pop 1 <timestamp> top - failed (empty stack) ``` Create the `BoundedStack` class to meet the above requirements. # Expected Function Signatures ```python from typing import Generic, List, Optional, TypeVar import datetime T = TypeVar(\'T\') class BoundedStack(Generic[T]): def __init__(self, max_size: int) -> None: ... def push(self, data: T) -> None: ... def pop(self) -> T | None: ... def top(self) -> T | None: ... def is_empty(self) -> bool: ... def get_log(self) -> List[dict]: ... ``` # Constraints - Handle integer elements in the stack. - Focus on code efficiency and handle potential edge cases robustly regarding stack boundaries and operation logging.","solution":"from typing import Generic, List, TypeVar, Union import datetime T = TypeVar(\'T\') class BoundedStack(Generic[T]): def __init__(self, max_size: int) -> None: self.max_size = max_size self.stack = [] self.log = [] def _log_operation(self, op: str, value: Union[T, str]) -> None: self.log.append({ \\"time\\": datetime.datetime.now().isoformat(), \\"op\\": op, \\"value\\": value }) def push(self, data: T) -> None: if len(self.stack) < self.max_size: self.stack.append(data) self._log_operation(\\"push\\", data) else: self._log_operation(\\"push - failed\\", \\"overflow\\") raise OverflowError(\\"Push to a full stack\\") def pop(self) -> T: if self.stack: value = self.stack.pop() self._log_operation(\\"pop\\", value) return value else: self._log_operation(\\"pop - failed\\", \\"empty stack\\") raise IndexError(\\"Pop from an empty stack\\") def top(self) -> T: if self.stack: value = self.stack[-1] self._log_operation(\\"top\\", value) return value else: self._log_operation(\\"top - failed\\", \\"empty stack\\") raise IndexError(\\"Top from an empty stack\\") def is_empty(self) -> bool: empty = len(self.stack) == 0 self._log_operation(\\"is_empty\\", empty) return empty def get_log(self) -> List[dict]: return self.log"},{"question":"# Scenario You are a software engineer working on a logging system for a large-scale distributed application. One of your tasks is to create a function that identifies and counts error codes that appear consecutively in the log data. This functionality helps to detect potential problems and patterns in the logs. # Problem Statement Write a function `count_consecutive_errors(log: List[int]) -> int` that returns the count of distinct error codes which appear consecutively in the log data. # Function Signature ```python def count_consecutive_errors(log: List[int]) -> int: ``` # Input * `log` (List[int]): A list of integers representing the sequence of error codes in the log. # Output * An integer representing the count of distinct error codes that appear consecutively at least once. # Constraints 1. The length of `log` will be in the range `[1, 10^5]`. 2. Each error code in `log` will be in the range `[0, 10^5]`. # Examples ```python assert count_consecutive_errors([1, 1, 2, 3, 3, 3, 4, 5, 5]) == 3 assert count_consecutive_errors([7, 8, 9, 10]) == 0 assert count_consecutive_errors([4, 4, 4, 4, 4, 4]) == 1 ``` # Note * The function should efficiently handle large lists due to the possible input size. * Consecutive appearances imply that the same error code appears back-to-back at least once. # Performance Requirements * Your solution should complete within a reasonable time for the maximum input constraints. # Additional Context The function should iterate through the log and keep track of consecutive error codes efficiently. Ensure to handle edge cases such as very small or very large log sizes appropriately.","solution":"from typing import List def count_consecutive_errors(log: List[int]) -> int: Counts the distinct error codes which appear consecutively in the log. consecutive_errors = set() previous_code = None for i in range(1, len(log)): if log[i] == log[i-1]: consecutive_errors.add(log[i]) return len(consecutive_errors)"},{"question":"# Coding Assessment Question Scenario: You are developing a software tool that integrates with financial systems, focused on transaction processing. A common task involves categorizing and summing up the transactions by category, ensuring the process is efficient even for large datasets. Task: Implement a function `categorize_transactions` that processes a list of transactions, each represented by a tuple containing the transaction amount and its category. The function should return a dictionary where each key is a category, and the corresponding value is the sum of all transaction amounts in that category. # Requirements: 1. Implement the function `categorize_transactions(transactions: List[Tuple[float, str]]) -> Dict[str, float]`. 2. Your function should handle edge cases such as an empty list of transactions or transactions containing negative amounts. 3. Ensure that the solution is optimized for performance with large datasets. # Input Format: - A list of tuples where each tuple consists of a float (transaction amount) and a string (category). # Output Format: - A dictionary where each key is a category, and the value is the sum of transaction amounts in that category. # Constraints: - The number of transactions (n leq 10^5). - Each transaction amount is a float. - Categories are non-empty strings and can be repeated. # Code: ```python from typing import List, Tuple, Dict def categorize_transactions(transactions: List[Tuple[float, str]]) -> Dict[str, float]: result = {} for amount, category in transactions: if category in result: result[category] += amount else: result[category] = amount return result ``` # Example: ```python # Example usage transactions = [ (100.0, \\"Groceries\\"), (200.0, \\"Utilities\\"), (50.0, \\"Groceries\\"), (-20.0, \\"Refund\\"), ] print(categorize_transactions(transactions)) # Output: {\'Groceries\': 150.0, \'Utilities\': 200.0, \'Refund\': -20.0} ``` # Explanation: - **Input**: A list of transactions, each as a tuple with the amount and the category. - **Process**: Sum transaction amounts by category. - **Output**: A dictionary where keys are categories, and values are the summed amounts for those categories.","solution":"from typing import List, Tuple, Dict def categorize_transactions(transactions: List[Tuple[float, str]]) -> Dict[str, float]: result = {} for amount, category in transactions: if category in result: result[category] += amount else: result[category] = amount return result"},{"question":"# Coding Question Objective Your task is to implement a function that determines the final velocity of an object after a given time has elapsed, given its initial velocity and constant acceleration. Function Signature ```python def calculate_final_velocity(initial_velocity: float, acceleration: float, time: float) -> float: ``` Inputs - `initial_velocity (float)`: The initial velocity of the object in meters per second. (-10^5 ≤ initial_velocity ≤ 10^5) - `acceleration (float)`: The constant acceleration of the object in meters per second squared. (-10^5 ≤ acceleration ≤ 10^5) - `time (float)`: The time elapsed in seconds. (0 ≤ time ≤ 10^5) Outputs - Returns `final_velocity (float)`: The final velocity of the object in meters per second. Assumptions - The initial velocity, acceleration, and time values given are valid numbers. - Final velocity can be a positive or negative value depending on the direction of acceleration and initial velocity. Requirements - Implement the calculations using the formula: `final_velocity = initial_velocity + (acceleration * time)` - Handle edge cases where `time` is zero and return the `initial_velocity` in such cases. - Ensure the calculations handle floating-point operations correctly. Example ```python >>> calculate_final_velocity(10, 2, 5) 20.0 >>> calculate_final_velocity(-5, -3, 2) -11.0 >>> calculate_final_velocity(0, 9.8, 5) 49.0 ``` Constraints 1. You must write the implementation from scratch. Built-in functions that solve the entire problem are not allowed. 2. Ensure your solution handles edge cases properly.","solution":"def calculate_final_velocity(initial_velocity: float, acceleration: float, time: float) -> float: Calculates the final velocity of an object after a given time has elapsed. Parameters: initial_velocity (float): The initial velocity of the object in meters per second. acceleration (float): The constant acceleration of the object in meters per second squared. time (float): The time elapsed in seconds. Returns: float: The final velocity of the object in meters per second. final_velocity = initial_velocity + acceleration * time return final_velocity"},{"question":"Task You are provided with a simplified version of a matrix multiplication function. Your task is to complete the `strassen_matrix_multiplication` function using Strassen\'s algorithm for matrix multiplication to achieve more efficient O(n^2.81) time complexity compared to conventional O(n^3) matrix multiplication. ```python import numpy as np def conventional_matrix_multiplication(A: np.ndarray, B: np.ndarray) -> np.ndarray: return np.dot(A, B) def add_matrix(A: np.ndarray, B: np.ndarray) -> np.ndarray: return A + B def subtract_matrix(A: np.ndarray, B: np.ndarray) -> np.ndarray: return A - B def split_matrix(A: np.ndarray) -> tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: row, col = A.shape row2, col2 = row // 2, col // 2 return A[:row2, :col2], A[:row2, col2:], A[row2:, :col2], A[row2:, col2:] def strassen_matrix_multiplication(A: np.ndarray, B: np.ndarray) -> np.ndarray: assert A.shape == B.shape n = A.shape[0] if n == 1: return A * B elif n <= 2: return conventional_matrix_multiplication(A, B) else: A11, A12, A21, A22 = split_matrix(A) B11, B12, B21, B22 = split_matrix(B) M1 = strassen_matrix_multiplication(add_matrix(A11, A22), add_matrix(B11, B22)) M2 = strassen_matrix_multiplication(add_matrix(A21, A22), B11) M3 = strassen_matrix_multiplication(A11, subtract_matrix(B12, B22)) M4 = strassen_matrix_multiplication(A22, subtract_matrix(B21, B11)) M5 = strassen_matrix_multiplication(add_matrix(A11, A12), B22) M6 = strassen_matrix_multiplication(subtract_matrix(A21, A11), add_matrix(B11, B12)) M7 = strassen_matrix_multiplication(subtract_matrix(A12, A22), add_matrix(B21, B22)) C11 = add_matrix(subtract_matrix(add_matrix(M1, M4), M5), M7) C12 = add_matrix(M3, M5) C21 = add_matrix(M2, M4) C22 = add_matrix(subtract_matrix(add_matrix(M1, M3), M2), M6) C = np.empty((n, n)) row2, col2 = n // 2, n // 2 C[:row2, :col2] = C11 C[:row2, col2:] = C12 C[row2:, :col2] = C21 C[row2:, col2:] = C22 return C # Test cases A = np.array([[1, 2], [3, 4]]) B = np.array([[5, 6], [7, 8]]) print(strassen_matrix_multiplication(A, B)) # Output should be: # [[19 22] # [43 50]] ``` # Task Implement the `strassen_matrix_multiplication` function using Strassen\'s algorithm for matrix multiplication. **Input**: - `A`: A square numpy array representing the first matrix. - `B`: A square numpy array representing the second matrix. **Output**: - Returns the result of matrix multiplication of A and B using Strassen\'s method. **Constraints**: - Assume matrices A and B are either both 1x1 or have dimensions that are powers of 2 (i.e., 2x2, 4x4, etc.). - Use recursive division for implementing Strassen\'s algorithm. # Example ```python A = np.array([[1, 2], [3, 4]]) B = np.array([[5, 6], [7, 8]]) print(strassen_matrix_multiplication(A, B)) # Output should be: # [[19 22] # [43 50]] ```","solution":"import numpy as np def conventional_matrix_multiplication(A: np.ndarray, B: np.ndarray) -> np.ndarray: return np.dot(A, B) def add_matrix(A: np.ndarray, B: np.ndarray) -> np.ndarray: return A + B def subtract_matrix(A: np.ndarray, B: np.ndarray) -> np.ndarray: return A - B def split_matrix(A: np.ndarray) -> tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: row, col = A.shape row2, col2 = row // 2, col // 2 return A[:row2, :col2], A[:row2, col2:], A[row2:, :col2], A[row2:, col2:] def strassen_matrix_multiplication(A: np.ndarray, B: np.ndarray) -> np.ndarray: assert A.shape == B.shape n = A.shape[0] if n == 1: return A * B elif n <= 2: return conventional_matrix_multiplication(A, B) else: A11, A12, A21, A22 = split_matrix(A) B11, B12, B21, B22 = split_matrix(B) M1 = strassen_matrix_multiplication(add_matrix(A11, A22), add_matrix(B11, B22)) M2 = strassen_matrix_multiplication(add_matrix(A21, A22), B11) M3 = strassen_matrix_multiplication(A11, subtract_matrix(B12, B22)) M4 = strassen_matrix_multiplication(A22, subtract_matrix(B21, B11)) M5 = strassen_matrix_multiplication(add_matrix(A11, A12), B22) M6 = strassen_matrix_multiplication(subtract_matrix(A21, A11), add_matrix(B11, B12)) M7 = strassen_matrix_multiplication(subtract_matrix(A12, A22), add_matrix(B21, B22)) C11 = add_matrix(subtract_matrix(add_matrix(M1, M4), M5), M7) C12 = add_matrix(M3, M5) C21 = add_matrix(M2, M4) C22 = add_matrix(subtract_matrix(add_matrix(M1, M3), M2), M6) C = np.empty((n, n)) row2, col2 = n // 2, n // 2 C[:row2, :col2] = C11 C[:row2, col2:] = C12 C[row2:, :col2] = C21 C[row2:, col2:] = C22 return C"},{"question":"# Problem Statement You are given a string containing only the characters \'a\' and \'b\'. You need to determine the length of the longest substring that contains at most two different characters. This question tests your ability to work with strings and sliding window technique efficiently. Write a function `find_longest_substring` to perform the following tasks: - Given a string, find and return the length of the longest contiguous substring that contains at most two different characters. # Input * A string `s` consisting of characters \'a\' and \'b\' only (1 ≤ length of s ≤ 1000). # Output * An integer representing the length of the longest substring that contains at most two different characters. # Constraints - The string consists only of the characters \'a\' and \'b\'. - The input string will be non-empty. # Example For example, for the string \\"aabacbebebe\\": - The longest substring with at most two different characters is \\"bebebe\\" which has a length of 6. ```python def find_longest_substring(s: str) -> int: Returns the length of the longest substring with at most two different characters. >>> find_longest_substring(\\"aabacbebebe\\") Returns 6 # Your code here. pass ``` # Explanation Your implementation should utilize the sliding window technique to efficiently compute the longest substring. As you iterate over the string, you will maintain a window of characters and adjust its size as necessary while keeping track of the maximum length found. Consider edge cases such as the entire string fitting the criteria and test different configurations robustly.","solution":"def find_longest_substring(s: str) -> int: Returns the length of the longest substring with at most two different characters. n = len(s) if n == 0: return 0 left = 0 right = 0 max_len = 0 char_count = {} while right < n: if s[right] in char_count: char_count[s[right]] += 1 else: char_count[s[right]] = 1 while len(char_count) > 2: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len"},{"question":"# Title: Compute the Force Exerted by an Elastic Spring # Description: Hooke\'s Law describes the behavior of an elastic spring when it is stretched or compressed by an external force. The force exerted by the spring ( F ) is given by the equation: [ F = -k cdot x ] Here: - ( k ) is the spring constant (measured in Newtons per meter). - ( x ) is the displacement from the spring\'s equilibrium position (measured in meters). Write a Python function `spring_force(spring_constant: float, displacement: float) -> float` that computes the force exerted by the spring using Hooke\'s Law. # Input: * A float `spring_constant` representing the spring constant of the spring. * A float `displacement` representing the displacement from the equilibrium position. # Output: * A float representing the force exerted by the spring. # Constraints: * `spring_constant` must be a positive float. * `displacement` can be any float value. # Examples: ```python # Example function calls: print(spring_force(100, 0.5)) # Output: -50.0 print(spring_force(200, -0.25)) # Output: 50.0 ``` # Notes: * If the `spring_constant` is zero or negative, raise a `ValueError`. * The function should correctly compute and return the force, taking into consideration the sign convention (negative indicates displacement direction).","solution":"def spring_force(spring_constant: float, displacement: float) -> float: Computes the force exerted by an elastic spring using Hooke\'s Law. Parameters: - spring_constant (float): The spring constant (must be positive). - displacement (float): The displacement from the equilibrium position. Returns: - float: The force exerted by the spring. Raises: - ValueError: If the spring_constant is not positive. if spring_constant <= 0: raise ValueError(\\"Spring constant must be a positive float.\\") return -spring_constant * displacement"},{"question":"# Problem: Rotate Image You are given an `n x n` 2D matrix `matrix` representing an image. Write a function `rotate_image(matrix: list[list[int]]) -> None` to rotate the image by 90 degrees (clockwise). The rotation should be done in place without allocating another 2D matrix. # Function Signature ```python def rotate_image(matrix: list[list[int]]) -> None: pass ``` # Input * `matrix`: A 2D list of integers representing the image. It is guaranteed to have the same number of rows and columns (i.e., `n x n` matrix) with `n` between 1 and 100. # Output * The function does not return anything. It modifies the `matrix` in place to represent the rotated image. # Example ```python import copy matrix_1 = [[1,2,3],[4,5,6],[7,8,9]] expected_1 = [[7,4,1],[8,5,2],[9,6,3]] rotate_image(copy.deepcopy(matrix_1)) assert matrix_1 == expected_1 matrix_2 = [[1,2],[3,4]] expected_2 = [[3,1],[4,2]] rotate_image(copy.deepcopy(matrix_2)) assert matrix_2 == expected_2 ``` # Constraints - The function should efficiently handle in-place modification. - Consider edge cases such as the smallest size of the matrix (`1 x 1`). # Notes - You can assume the matrix only contains integers. - Think about simple algorithms that achieve the rotation using minimal extra space.","solution":"def rotate_image(matrix: list[list[int]]) -> None: Rotates the given n x n matrix by 90 degrees clockwise. The rotation is done in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Question: Optimized Merge of Two Sorted Linked Lists in Python **Scenario:** You are building an advanced sorting algorithm that requires an efficient merge operation on linked lists. The current implementation uses a simple merge of arrays but needs an optimization to work directly with linked lists, avoiding the overhead of arrays. **Task:** Implement a function `merge_sorted_linked_lists` that merges two sorted singly linked lists into one sorted singly linked list. Your implementation should efficiently handle the merging process without using additional arrays or lists. **Data Structures Provided:** ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next ``` **Function Signature:** ```python def merge_sorted_linked_lists(l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]: pass ``` **Input:** - `l1` (Optional[ListNode]): The head node of the first sorted linked list. - `l2` (Optional[ListNode]): The head node of the second sorted linked list. **Output:** - (Optional[ListNode]): The head node of the merged sorted linked list. **Constraints:** - Each linked list\'s nodes contain integer values. - The nodes in each linked list are sorted in ascending order. - The linked lists do not contain cycles. **Example:** ```python >>> # Linked list 1: 1 -> 3 -> 5 >>> l1 = ListNode(1) >>> l1.next = ListNode(3) >>> l1.next.next = ListNode(5) >>> # Linked list 2: 2 -> 4 -> 6 >>> l2 = ListNode(2) >>> l2.next = ListNode(4) >>> l2.next.next = ListNode(6) >>> merged_list = merge_sorted_linked_lists(l1, l2) >>> # To print the merged linked list >>> current = merged_list >>> while current: >>> print(current.value, end=\\" -> \\") >>> current = current.next 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> ``` **Explanation:** Your function `merge_sorted_linked_lists` should take the head nodes of two sorted linked lists, `l1` and `l2`, and produce a new linked list that merges the elements in a sorted manner. The resulting linked list should also be sorted, combining the values from both input linked lists while maintaining their order.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def merge_sorted_linked_lists(l1, l2): Merges two sorted linked lists into one sorted linked list. :param l1: ListNode, the head of the first sorted linked list :param l2: ListNode, the head of the second sorted linked list :return : ListNode, the head of the merged sorted linked list # Create a dummy node to form the new linked list dummy = ListNode() current = dummy # Continue until either l1 or l2 becomes None while l1 is not None and l2 is not None: if l1.value < l2.value: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next # If any of l1 or l2 is still remaining, append it to the result if l1 is not None: current.next = l1 else: current.next = l2 return dummy.next"},{"question":"Task Question Creation for Coding Assessment Create an additional question that aligns with the given example in terms of style, complexity, and scope. **Given Example:** # [Question 1]: # Sumset Calculation - Programming Question You are provided with two sets of integers. Your task is to implement a function that calculates the sumset of these two sets. The sumset is defined as the set of all possible sums obtained by adding one integer from the first set to one integer from the second set. **Function Signature**: ```python def sumset(set_a: set, set_b: set) -> set: :param set_a: set of integers :param set_b: set of integers :return: A set containing the sums of every pair of elements from set_a and set_b >>> sumset({1, 2, 3}, {4, 5, 6}) {5, 6, 7, 8, 9} >>> sumset({1, 2, 3}, {4, 5, 6, 7}) {5, 6, 7, 8, 9, 10} >>> sumset({1, 2, 3, 4}, set()) set() >>> sumset({1, 2, 3}, 3) Traceback (most recent call last): ... AssertionError: The input value of [set_b=3] is not a set pass ``` # Constraints: 1. Both inputs must be of set type containing integers. 2. The resultant set should have unique sums. 3. If input is not of set type, the function should raise an assertion error with a specific message. # Edge Cases to Consider: - One or both input sets are empty. - Large sets with considerable number of elements. - Non-integer values within the sets. # Inputs: - `set_a` and `set_b`: Two sets of integers. # Outputs: - A set containing all unique sums possible from adding each element of `set_a` with each element of `set_b`. Implement the function `sumset` to compute the result based on the provided template and constraints. --- # [Question 2]: # Common Factors - Programming Question You are given two positive integers. Your task is to implement a function that computes the set of common factors between the two given integers. A common factor is a number that divides both integers without leaving a remainder. **Function Signature**: ```python def common_factors(a: int, b: int) -> set: :param a: first positive integer :param b: second positive integer :return: A set containing all the common factors of a and b >>> common_factors(12, 18) {1, 2, 3, 6} >>> common_factors(7, 13) {1} >>> common_factors(100, 100) {1, 2, 4, 5, 10, 20, 25, 50, 100} >>> common_factors(7, -13) Traceback (most recent call last): ... ValueError: Inputs must be positive integers pass ``` # Constraints: 1. Both inputs must be positive integers. 2. If either input is not a positive integer, the function should raise a ValueError with a specific message. # Edge Cases to Consider: - One or both inputs are 1. - One input is a prime number. - Extremely large integer values. # Inputs: - `a` and `b`: Two positive integers. # Outputs: - A set containing all common factors of the two input integers. Implement the function `common_factors` to compute the result based on the provided template and constraints.","solution":"def sumset(set_a: set, set_b: set) -> set: Calculates the sumset of two sets of integers. :param set_a: set of integers :param set_b: set of integers :return: A set containing the sums of every pair of elements from set_a and set_b >>> sumset({1, 2, 3}, {4, 5, 6}) {5, 6, 7, 8, 9} >>> sumset({1, 2, 3}, {4, 5, 6, 7}) {5, 6, 7, 8, 9, 10} >>> sumset({1, 2, 3, 4}, set()) set() >>> sumset({1, 2, 3}, 3) Traceback (most recent call last): ... AssertionError: The input value of [set_b=3] is not a set if not isinstance(set_a, set): raise AssertionError(f\\"The input value of [set_a={set_a}] is not a set\\") if not isinstance(set_b, set): raise AssertionError(f\\"The input value of [set_b={set_b}] is not a set\\") return {a + b for a in set_a for b in set_b}"},{"question":"# Sorting Tweets by Popularity You are tasked with creating a function that sorts a list of tweets based on their popularity. The popularity of a tweet is defined by a combination of the number of retweets and likes it has received. # Function Signature ```python def sort_tweets(tweets: List[Dict[str, int]]) -> List[Dict[str, int]]: pass ``` # Input * `tweets`: A list of dictionaries where each dictionary represents a tweet. Each dictionary has the following keys: - `\\"retweets\\"`: An integer representing the number of retweets. - `\\"likes\\"`: An integer representing the number of likes. # Output * A list of dictionaries representing the tweets, sorted by their popularity in descending order. If two tweets have the same popularity, they should retain their relative order from the input (i.e., stable sort). # Example ```python tweets = [ {\\"retweets\\": 10, \\"likes\\": 50}, {\\"retweets\\": 20, \\"likes\\": 30}, {\\"retweets\\": 30, \\"likes\\": 10}, {\\"retweets\\": 15, \\"likes\\": 50} ] result = sort_tweets(tweets) ``` Expected Output: ```python [ {\\"retweets\\": 15, \\"likes\\": 50}, {\\"retweets\\": 10, \\"likes\\": 50}, {\\"retweets\\": 20, \\"likes\\": 30}, {\\"retweets\\": 30, \\"likes\\": 10} ] ``` # Explanation The function ranks tweets by a combined metric of retweets and likes. In the given example, the popularity of each tweet can be calculated as: 1. tweet1: 10 retweets + 50 likes = 60 2. tweet2: 20 retweets + 30 likes = 50 3. tweet3: 30 retweets + 10 likes = 40 4. tweet4: 15 retweets + 50 likes = 65 After sorting by popularity in descending order, the output correctly ranks the tweets as shown. # Constraints & Edge Cases * Ensure the function handles empty lists appropriately. * Take into account tweets with zero retweets and likes. * Consider the edge case when all tweets have the same popularity. # Performance * The solution should efficiently handle a large number of tweets, aiming for a time complexity of O(n log n) due to the sorting operation. Write your implementation of the `sort_tweets` function:","solution":"from typing import List, Dict def sort_tweets(tweets: List[Dict[str, int]]) -> List[Dict[str, int]]: Sorts a list of tweets based on their popularity (sum of retweets and likes) in descending order. :param tweets: List of dictionaries, each dictionary contains \'retweets\' and \'likes\' as keys. :return: List of dictionaries sorted by combined retweets and likes in descending order. return sorted(tweets, key=lambda tweet: tweet[\'retweets\'] + tweet[\'likes\'], reverse=True)"},{"question":"# Graph Traversal Challenge Problem Statement You are given a connected undirected graph represented by an adjacency list. Your task is to implement two functions `dfs` and `bfs` to perform Depth-First Search (DFS) and Breadth-First Search (BFS) traversals starting from a given node. Implement the following functions: ```python def dfs(graph: dict, start_node: int) -> list: Perform a Depth-First Search on the graph starting from start_node. Parameters: - graph (dict): The adjacency list representing the graph. - start_node (int): The node from which to start the traversal. Returns: - list: A list of nodes in the order they are visited by DFS. pass def bfs(graph: dict, start_node: int) -> list: Perform a Breadth-First Search on the graph starting from start_node. Parameters: - graph (dict): The adjacency list representing the graph. - start_node (int): The node from which to start the traversal. Returns: - list: A list of nodes in the order they are visited by BFS. pass ``` - **Input**: - `graph` (type: `dict`): An adjacency list where keys are node identifiers and values are lists of adjacent nodes. - `start_node` (type: `int`): The node from which to start the traversal. - **Output**: - A list of nodes in the order they are visited by each respective traversal algorithm. Constraints - The graph is connected and undirected. - The graph has up to 1000 nodes. - Nodes are identified by integers ranging from 0 to 999. Examples ```python graph = { 0: [1, 2], 1: [0, 3, 4], 2: [0, 5], 3: [1], 4: [1], 5: [2] } assert dfs(graph, 0) == [0, 1, 3, 4, 2, 5] assert bfs(graph, 0) == [0, 1, 2, 3, 4, 5] ``` Note 1. For DFS, you can use either a recursive approach or an iterative approach using a stack. 2. For BFS, an iterative approach using a queue is required.","solution":"def dfs(graph: dict, start_node: int) -> list: Perform a Depth-First Search on the graph starting from start_node. Parameters: - graph (dict): The adjacency list representing the graph. - start_node (int): The node from which to start the traversal. Returns: - list: A list of nodes in the order they are visited by DFS. visited = [] stack = [start_node] while stack: node = stack.pop() if node not in visited: visited.append(node) stack.extend(reversed(graph[node])) # Add nodes in reverse for correct order return visited def bfs(graph: dict, start_node: int) -> list: Perform a Breadth-First Search on the graph starting from start_node. Parameters: - graph (dict): The adjacency list representing the graph. - start_node (int): The node from which to start the traversal. Returns: - list: A list of nodes in the order they are visited by BFS. visited = [] queue = [start_node] while queue: node = queue.pop(0) if node not in visited: visited.append(node) queue.extend(graph[node]) # Add nodes in natural order for BFS return visited"},{"question":"# Subject: Sorting and Searching Algorithms In this task, you are required to combine sorting and binary search techniques. Given a list of integers and a target value, you need to find out if any two numbers in the list sum up to the target value. You will also need to return the indices of these two numbers. # Description You are given an unsorted list of integers and a target sum value. Your task is to determine if there are two different numbers in the list that add up to the target sum. If such a pair exists, return their respective indices. The indices should be in increasing order. If no such pair exists, return `None`. # Implementation Functions 1. **`two_sum_indices(arr: list, target: int) -> list`**: - **Input**: A list of integers (where (0 leq |arr| leq 10^5)) and an integer target (where (|target| leq 10^9)). - **Output**: Returns a list of two integers representing the indices of the two numbers that add up to the target sum, in increasing order. If no such indices exist, return `None`. # Function Definition ```python def two_sum_indices(arr: list, target: int) -> list: Find two indices in the list where the values sum up to the target. Args: arr (list): The list of integers. target (int): The target sum. Returns: list: The indices of the two numbers that add up to target, in increasing order, or None if no such pair exists. pass ``` # Requirements - Optimize your solution to work within reasonable time and space limits, given the size constraints. - Assume the input list can be modified within the function. - The function should handle edge cases, such as the list being empty or containing fewer than two elements. # Examples ```python # Example 1 print(two_sum_indices([2, 7, 11, 15], 9)) # Should return [0, 1] # Example 2 print(two_sum_indices([3, 2, 4], 6)) # Should return [1, 2] # Example 3 print(two_sum_indices([3, 3], 6)) # Should return [0, 1] # Example 4 print(two_sum_indices([1, 2, 3, 4, 5], 10)) # Should return None ``` # Constraints - Aim for an efficient solution that runs in (O(n log n)) time if possible. - Your solution should cleanly handle edge cases and large input sizes. - Ensure to return indices in increasing order. # Explanation - In Example 1, the indices 0 and 1 sum up to 9. - In Example 2, the indices 1 and 2 sum up to 6. - In Example 3, the indices 0 and 1 sum up to 6. - In Example 4, there are no two numbers in the list that sum up to the target value. Write your solution considering both sorting and search algorithms to achieve the required efficiency.","solution":"def two_sum_indices(arr, target): Find two indices in the list where the values sum up to the target. Args: arr (list): The list of integers. target (int): The target sum. Returns: list: The indices of the two numbers that add up to target, in increasing order, or None if no such pair exists. if len(arr) < 2: return None indexed_arr = list(enumerate(arr)) indexed_arr.sort(key=lambda x: x[1]) left = 0 right = len(indexed_arr) - 1 while left < right: current_sum = indexed_arr[left][1] + indexed_arr[right][1] if current_sum == target: return sorted([indexed_arr[left][0], indexed_arr[right][0]]) elif current_sum < target: left += 1 else: right -= 1 return None"},{"question":"# Coding Exercise: Find the Longest Substring Without Repeating Characters Given a string, find the length of the longest substring without repeating characters. Implement the function `length_of_longest_substring(s: str) -> int` that returns the length of the longest substring of `s` where no character repeats. Input * `s` (0 ≤ |s| ≤ 10^5): A string consisting of only uppercase and lowercase English letters. Output * An integer representing the length of the longest substring without repeating characters. # Example ```python def length_of_longest_substring(s: str) -> int: # Write your code here. # Example Usage s = \\"abcabcbb\\" print(length_of_longest_substring(s)) # Expected Output: 3 (Explanation: The answer is \\"abc\\", with the length of 3.) s = \\"bbbbb\\" print(length_of_longest_substring(s)) # Expected Output: 1 (Explanation: The answer is \\"b\\", with the length of 1.) s = \\"pwwkew\\" print(length_of_longest_substring(s)) # Expected Output: 3 (Explanation: The answer is \\"wke\\", with the length of 3.) ``` # Hints 1. **Sliding Window Technique**: Utilize a sliding window approach to efficiently find the longest substring. 2. **HashMap or Set**: Consider using a hashmap or set to keep track of characters and their indices. 3. **Two Pointers**: Use two pointers to represent the current window and move them to expand or shrink the window while checking for repeat characters. 4. **Time Complexity**: Aim for an O(n) solution where `n` is the length of the string.","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. char_index_map = {} longest = 0 start = 0 for end, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = end longest = max(longest, end - start + 1) return longest"},{"question":"# Question: Implementing a Simple Echo Effect Context You are developing a basic audio processing tool, and one of the features you need to implement is an audio effect. Specifically, your task is to create a simple echo effect processor. The echo effect must add a repeated, delayed signal to the original audio input, simulating an echo. Task 1. Implement an `EchoEffect` class that adheres to the `EffectType` Protocol. The class must have: - An `__init__` method to initialize delay time and echo amplitude. - A `process()` method that takes a single sample as input and returns a sample with the echo effect applied. 2. Use the `apply_effect()` and `plot_waveform()` functions to apply your echo effect to an audio signal and visualize the waveform. Requirements * **Effect Specification**: Implement an echo effect with specified delay and amplitude. * **Input/Output**: - The `EchoEffect` class will take the delay time (in samples) and echo amplitude as input during initialization. - The `process()` method will output the audio sample with the echo effect applied. * **Constraints**: - Maximum delay time: 5000 samples. - Echo amplitude must be between 0.0 and 1.0. * **Performance**: - The implementation should handle real-time processing of audio signals efficiently. - The waveform plot should clearly illustrate the echo effect. # Example ```python class EchoEffect: def __init__(self, delay: int, amplitude: float) -> None: self.delay = delay self.amplitude = amplitude self.buffer = [0] * delay def process(self, sample: float) -> float: delayed_sample = self.buffer.pop(0) output = sample + self.amplitude * delayed_sample self.buffer.append(sample) return output # Create an echo effect with a delay of 1000 samples and an echo amplitude of 0.5 echo = EchoEffect(1000, 0.5) # Apply the effect to an input signal and visualize input_signal = [0.0] * 1000 + [1.0] + [0.0] * 1000 # An impulse input signal output_signal = [echo.process(sample) for sample in input_signal] plot_waveform(input_signal, output_signal) ``` In this task, you will enhance the audio signal processing tool with an echo effect by implementing the `EchoEffect` class and visualizing its impact on an example input signal.","solution":"class EchoEffect: def __init__(self, delay: int, amplitude: float) -> None: Initializes the EchoEffect with a given delay and amplitude. Parameters: delay (int): The delay time in samples. Must be between 0 and 5000. amplitude (float): The echo amplitude. Must be between 0.0 and 1.0. if not (0 <= delay <= 5000): raise ValueError(\\"Delay must be between 0 and 5000 samples.\\") if not (0.0 <= amplitude <= 1.0): raise ValueError(\\"Amplitude must be between 0.0 and 1.0.\\") self.delay = delay self.amplitude = amplitude self.buffer = [0.0] * delay def process(self, sample: float) -> float: Processes a single audio sample and returns the sample with echo effect applied. Parameters: sample (float): The input audio sample. Returns: float: The processed audio sample with echo effect applied. delayed_sample = self.buffer.pop(0) output = sample + self.amplitude * delayed_sample self.buffer.append(sample) return output def plot_waveform(input_signal, output_signal): Plots the waveform of the input and output audio signals. Parameters: input_signal (list of float): The input audio signal. output_signal (list of float): The output audio signal with effects applied. import matplotlib.pyplot as plt plt.figure(figsize=(12, 6)) plt.plot(input_signal, label=\'Input Signal\') plt.plot(output_signal, label=\'Output Signal with Echo\', linestyle=\'--\') plt.legend() plt.title(\\"Waveform of Input and Output Signals\\") plt.xlabel(\\"Sample\\") plt.ylabel(\\"Amplitude\\") plt.show()"},{"question":"# Frequency of Most Frequent Element in a Subarray In this task, you need to implement a function to find the frequency of the most frequent element in any subarray of a given array. The subarray with the highest frequency of any element needs to be identified and the frequency of that element returned. # Function Signature ```python def most_frequent_element(arr: List[int], k: int) -> int: ``` # Input - A list of integers `arr` ( 1 leq |arr| leq 10^5 ): the array in which to find the subarray. - An integer `k` ( 1 leq k leq 10^5 ): the maximum size of the subarray. # Output - An integer representing the highest frequency of any single element in a subarray of `arr` with size up to `k`. # Constraints - The function should handle the upper limit efficiently considering the time and space complexities. # Example ```python print(most_frequent_element([1, 3, 3, 2, 1, 4, 1], 3)) # Output: 2 print(most_frequent_element([2, 2, 1, 2, 2, 1, 1], 4)) # Output: 3 ``` # Notes 1. In `most_frequent_element([1, 3, 3, 2, 1, 4, 1], 3)`, the most frequent element in a subarray of size up to 3 is `1`. The subarray [1, 4, 1] contains two occurrences of 1. 2. In `most_frequent_element([2, 2, 1, 2, 2, 1, 1], 4)`, the most frequent element in a subarray of size up to 4 is `2`. The subarray [2, 2, 1, 2] contains three occurrences of 2. # Tips - Consider using sliding window techniques to efficiently calculate the frequency of elements in the subarray. - Handle edge cases such as when `k` is larger than the length of the array, or when all elements are distinct.","solution":"from collections import defaultdict def most_frequent_element(arr, k): Finds the frequency of the most frequent element in any subarray of a given array, with the maximum subarray size up to k. n = len(arr) max_freq = 0 freq_map = defaultdict(int) left = 0 for right in range(n): freq_map[arr[right]] += 1 while (right - left + 1) > k: freq_map[arr[left]] -= 1 if freq_map[arr[left]] == 0: del freq_map[arr[left]] left += 1 current_max_freq = max(freq_map.values()) max_freq = max(max_freq, current_max_freq) return max_freq"},{"question":"# Implement a Hash Map You are tasked with implementing a simplified hash map, a fundamental data structure in computer science, which allows quick insertion, deletion, and lookup of key-value pairs. The hash map will use a list of fixed size arrays (buckets) to store the pairs and will handle collisions using chaining (linked lists). Function Signature ```python class MyHashMap: def __init__(self, bucket_size: int): pass def put(self, key: int, value: int) -> None: pass def get(self, key: int) -> int: pass def remove(self, key: int) -> None: pass ``` Input * **bucket_size**: An integer representing the number of buckets in the hash map. * **put** parameters: `key` (integer), `value` (integer) - key-value pair to add or update in the hash map. * **get** parameter: `key` (integer) - key whose value should be retrieved. * **remove** parameter: `key` (integer) - key whose key-value pair should be removed from the hash map. Output * **put**: No output. Adds or updates the key-value pair in the hash map. * **get**: Returns the value corresponding to the key, or `-1` if the key does not exist. * **remove**: No output. Deletes the key-value pair associated with the key if it exists. Implementation Requirements: 1. **Hash Function**: Implement a hash function to convert the key to an index in the bucket array. 2. **Chaining**: Handle collisions by storing key-value pairs in a linked list within each bucket. 3. **Put Operation**: Insert a new key-value pair or update the value if the key already exists in the hash map. 4. **Get Operation**: Retrieve the value for a given key, or return `-1` if the key is not found. 5. **Remove Operation**: Delete the key-value pair corresponding to the key if it exists. Constraints * Assume the keys and values are non-negative integers. * The bucket size will be a positive integer. * Methods will be called in a way that ensures hash map size does not exceed manageable limits for efficiency. # Example ```python # Example usage of MyHashMap hash_map = MyHashMap(bucket_size=10) # Add key-value pairs hash_map.put(1, 10) hash_map.put(2, 20) # Retrieve values print(hash_map.get(1)) # Output: 10 print(hash_map.get(3)) # Output: -1 (not found) # Update key-value pair hash_map.put(2, 21) print(hash_map.get(2)) # Output: 21 # Remove key-value pair hash_map.remove(2) print(hash_map.get(2)) # Output: -1 (not found) ``` You are required to implement the complete `MyHashMap` class with the specified functionalities.","solution":"class MyHashMap: def __init__(self, bucket_size: int): Initialize the hash map with the given number of buckets. self.bucket_size = bucket_size self.buckets = [[] for _ in range(bucket_size)] def _hash(self, key: int) -> int: Generate a hash for the given key. return key % self.bucket_size def put(self, key: int, value: int) -> None: Insert a new key-value pair or update the value if the key already exists. index = self._hash(key) for pair in self.buckets[index]: if pair[0] == key: pair[1] = value return self.buckets[index].append([key, value]) def get(self, key: int) -> int: Retrieve the value for the given key, or return -1 if the key is not found. index = self._hash(key) for pair in self.buckets[index]: if pair[0] == key: return pair[1] return -1 def remove(self, key: int) -> None: Delete the key-value pair corresponding to the key if it exists. index = self._hash(key) for pair in self.buckets[index]: if pair[0] == key: self.buckets[index].remove(pair) return"},{"question":"# Question: You are responsible for creating a utility that processes text data by transforming and analyzing strings. Your task is to implement two functions: one for counting distinct words and another for replacing specific words in a text. Task: 1. **Function 1: `count_distinct_words(text: str) -> dict`** - Input: - `text`: A string of arbitrary length containing words separated by whitespace. - Output: - A dictionary where the keys are distinct words (converted to lowercase) in the input text, and the values are the counts of occurrences of each word. - Implementation details: - Treat words as case-insensitive. - Ignore punctuation marks (e.g., commas, periods). - Handle edge cases with empty strings appropriately. 2. **Function 2: `replace_words(text: str, words_to_replace: dict) -> str`** - Input: - `text`: A string of arbitrary length containing words separated by whitespace. - `words_to_replace`: A dictionary where keys are words to be replaced (in lowercase) and values are the corresponding words to replace with. - Output: - A new string with the specified replacements made. - Implementation details: - Replacement is case-insensitive. - Replace whole words only (not substrings). - Maintain the original capitalization of words wherever possible. Examples: - Count Distinct Words: ```python count_distinct_words(\\"Hello, hello world! World of Python.\\") # Output: {\'hello\': 2, \'world\': 2, \'of\': 1, \'python\': 1} count_distinct_words(\\"This is a test. This test is simple.\\") # Output: {\'this\': 2, \'is\': 2, \'a\': 1, \'test\': 2, \'simple\': 1} ``` - Replace Words: ```python replace_words(\\"Hello world! This is a test.\\", {\\"hello\\": \\"hi\\", \\"test\\": \\"exam\\"}) # Output: \\"Hi world! This is a exam.\\" replace_words(\\"The quick brown fox jumps over the lazy dog.\\", {\\"quick\\": \\"slow\\", \\"brown\\": \\"black\\", \\"lazy\\": \\"active\\"}) # Output: \\"The slow black fox jumps over the active dog.\\" ``` Ensure your solution efficiently handles the input, accurately processes with case_insensitivity where needed, and achieves the expected output format. Handle edge cases such as punctuations and empty strings appropriately.","solution":"import re from collections import Counter def count_distinct_words(text: str) -> dict: Returns a dictionary of distinct words (in lowercase) and their counts in the text. # Remove punctuation and convert text to lowercase text = re.sub(r\'[^ws]\', \'\', text).lower() words = text.split() # Count words using Counter word_counts = Counter(words) return dict(word_counts) def replace_words(text: str, words_to_replace: dict) -> str: Replace words in the text according to the words_to_replace dictionary, maintaining original capitalization where possible. def replace_word(match): word = match.group(0) lower_word = word.lower() if lower_word in words_to_replace: replacement = words_to_replace[lower_word] if word[0].isupper(): replacement = replacement.capitalize() return replacement return word # Using regex to replace with whole word matching pattern = re.compile(r\'bw+b\') replaced_text = pattern.sub(replace_word, text) return replaced_text"},{"question":"# Problem Statement Write a function to determine if two arrays are equal despite having been rotated at some point. Given two arrays of integers, determine if one array is a rotation (cyclic permutation) of the other. # Requirements 1. **Input**: Two lists of integers, `arr1` and `arr2`, both having the same length ( n ). 2. **Output**: A boolean value - `True` if one array is a rotation of the other, and `False` otherwise. 3. **Constraints**: - ( 1 leq n leq 10^5 ) - The elements of the arrays are integers and may include negative numbers. # Usage Example ```python print(are_rotations([1, 2, 3, 4, 5], [3, 4, 5, 1, 2])) # Output: True print(are_rotations([1, 2, 3, 4, 5], [4, 3, 5, 1, 2])) # Output: False ``` # Additional Information - A rotation means that elements have been shifted in a circular manner. - For example, `[1, 2, 3, 4, 5]` rotated by 2 positions results in `[3, 4, 5, 1, 2]`. # Performance Requirements - Your solution should run in ( O(n) ) time complexity. # Implementation Implement the function `are_rotations`: ```python def are_rotations(arr1: list[int], arr2: list[int]) -> bool: Determines whether one array is a rotation of the other. Args: arr1 (list of int): The first array. arr2 (list of int): The second array. Returns: bool: True if one array is a rotation of the other, False otherwise. pass ```","solution":"def are_rotations(arr1: list[int], arr2: list[int]) -> bool: Determines whether one array is a rotation of the other. Args: arr1 (list of int): The first array. arr2 (list of int): The second array. Returns: bool: True if one array is a rotation of the other, False otherwise. if len(arr1) != len(arr2): return False if len(arr1) == 0 and len(arr2) == 0: return True concatenated = arr1 + arr1 for i in range(len(arr1)): if concatenated[i:i+len(arr2)] == arr2: return True return False"},{"question":"Matrix Spiral Order Traversal In this task, you will implement a function that returns the elements of a matrix in spiral order. The spiral order starts from the top-left corner of the matrix and proceeds in a clockwise direction. Function Signature ```python def spiral_order(matrix: List[List[int]]) -> List[int]: pass ``` # Input * `matrix`: A 2D list (a list of lists) of integers representing the matrix. Assume the matrix: * Is non-empty. * Has `m` rows and `n` columns (1 <= m, n <= 100). # Output * A list of integers representing the matrix elements in spiral order. # Constraints * The matrix elements will be integers between -10^5 and 10^5. # Example ```python matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Output: [1, 2, 3, 6, 9, 8, 7, 4, 5] print(spiral_order(matrix1)) matrix2 = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] # Output: [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] print(spiral_order(matrix2)) ``` # Explanation 1. In the first example, the matrix is traversed in the following order: - First row: 1, 2, 3 - Last column: 6, 9 - Last row (reversed): 8, 7 - First column (reversed): 4, 5 2. In the second example, the matrix is traversed in the following order: - First row: 1, 2, 3, 4 - Last column: 8, 12 - Last row (reversed): 11, 10, 9 - First column: none (already covered) - Second row: 5, 6, 7","solution":"def spiral_order(matrix): Returns the elements of the matrix in spiral order. if not matrix: return [] spiral = [] top, bottom, left, right = 0, len(matrix) - 1, 0, len(matrix[0]) - 1 while top <= bottom and left <= right: # Traverse from left to right along the top row for i in range(left, right + 1): spiral.append(matrix[top][i]) top += 1 # Traverse from top to bottom along the right column for i in range(top, bottom + 1): spiral.append(matrix[i][right]) right -= 1 if top <= bottom: # Traverse from right to left along the bottom row for i in range(right, left - 1, -1): spiral.append(matrix[bottom][i]) bottom -= 1 if left <= right: # Traverse from bottom to top along the left column for i in range(bottom, top - 1, -1): spiral.append(matrix[i][left]) left += 1 return spiral"},{"question":"# Problem Statement Implement a text autocompletion system for a given list of words. Your system will take a list of words as the dictionary and a prefix string. It will return all words from the dictionary that start with the given prefix, sorted in lexicographical order. Input - A list of strings `words` representing the dictionary, where each string is a word consisting of lowercase English letters. - A string `prefix` representing the prefix to search for. Output - A list of strings containing all the words in the dictionary that start with the given prefix, sorted in lexicographical order. Function Signature ```python def autocomplete(words: List[str], prefix: str) -> List[str]: # Implementation here ``` # Constraints 1. The number of words in the dictionary will be between `1` and `10000`. 2. The length of each word in the dictionary and the prefix will be between `1` and `100`. # Example Input ```python words = [\\"apple\\", \\"app\\", \\"apricot\\", \\"banana\\", \\"bat\\", \\"ball\\", \\"batman\\"] prefix = \\"ap\\" ``` Output ```python [\\"app\\", \\"apple\\", \\"apricot\\"] ``` # Additional Information To get the correct result: 1. Filter the words to find only those that start with the given prefix. 2. Sort the resulting list of words in lexicographical order before returning it.","solution":"from typing import List def autocomplete(words: List[str], prefix: str) -> List[str]: Returns a list of words from the dictionary that start with the given prefix, sorted lexicographically. matching_words = [word for word in words if word.startswith(prefix)] return sorted(matching_words)"},{"question":"# Detect Palindrome in Linked List You are provided with a singly linked list and tasked to determine if the elements in the list form a palindrome. To demonstrate your understanding of linked lists and palindrome detection, you must implement this functionality without converting the linked list into another data structure (like a list or an array). # Scenario Given a singly linked list where each node contains a single character, create a function to check if the sequence of characters forms a palindrome. For instance, a linked list with elements \'r\' -> \'a\' -> \'c\' -> \'e\' -> \'c\' -> \'a\' -> \'r\' should return `True`, while \'h\' -> \'e\' -> \'l\' -> \'l\' -> \'o\' should return `False`. # Task Write a function `is_palindrome` that verifies whether the given linked list forms a palindrome. # Function Signature ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_palindrome(head: ListNode) -> bool: pass ``` # Input - `head` (ListNode): The head node of the linked list. # Output - Returns `True` if the elements of the linked list form a palindrome. - Returns `False` otherwise. # Constraints - The linked list can have at most 10,000 nodes. - The value of each node is a lower case English letter. - You must operate in O(n) time complexity and O(1) space complexity (excluding the space for input data). # Example **Input** ```python # Create linked list: \'r\' -> \'a\' -> \'c\' -> \'e\' -> \'c\' -> \'a\' -> \'r\' head = ListNode(\'r\') head.next = ListNode(\'a\') head.next.next = ListNode(\'c\') head.next.next.next = ListNode(\'e\') head.next.next.next.next = ListNode(\'c\') head.next.next.next.next.next = ListNode(\'a\') head.next.next.next.next.next.next = ListNode(\'r\') print(is_palindrome(head)) ``` **Output** ```python True ``` # Hints and Approach 1. Use the fast and slow pointer technique to find the middle of the linked list. 2. Reverse the second half of the linked list. 3. Compare the first half and the reversed second half node by node. 4. Restore the reversed half and return the result. Implementing this way ensures the solution is efficient and adheres to the constraints provided.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_palindrome(head: ListNode) -> bool: if not head or not head.next: return True # Find the middle of the linked list slow = fast = head while fast and fast.next: slow = slow.next fast = fast.next.next # Reverse the second half of the linked list prev = None current = slow while current: nxt = current.next current.next = prev prev = current current = nxt # Compare the first half and the reversed second half node by node left, right = head, prev while right: # We only need to compare till right ends if left.val != right.val: return False left = left.next right = right.next return True"},{"question":"Implementing a Min-Priority Queue using a Min-Heap You are tasked with creating a min-priority queue data structure using a min-heap. Your implementation should include methods to insert an element, extract the minimum element, and decrease the priority of a specified element. You will also need to write test cases to demonstrate the functionality of your min-priority queue. Function Signature ```python class MinPriorityQueue: def __init__(self) -> None: Initialize an empty min-priority queue using a min-heap. pass def insert(self, key: int) -> None: Insert a new key into the min-priority queue. pass def extract_min(self) -> int: Extract and return the minimum key in the min-priority queue. pass def decrease_key(self, old_key: int, new_key: int) -> None: Decrease the key value of a specified element in the min-priority queue. pass def is_empty(self) -> bool: Check if the min-priority queue is empty. pass ``` Requirements 1. **Initialization**: - Initialize an empty min-heap to represent the min-priority queue. 2. **Insert**: - Implement the `insert` method to add a new key to the min-heap. 3. **Extract Min**: - Implement the `extract_min` method to remove and return the minimum key from the min-heap. 4. **Decrease Key**: - Implement the `decrease_key` method to decrease the value of a specified key in the min-heap. - Ensure the new key is smaller than the current key value. 5. **Utility Function**: - Implement the `is_empty` method to check if the priority queue is empty. 6. **Demonstration**: - Provide test cases to demonstrate the functionality of the min-priority queue, including edge cases such as: - Extracting from an empty queue - Decreasing a key\'s value when there are duplicates in the heap Example ```python # Create an instance of the MinPriorityQueue pq = MinPriorityQueue() # Insert elements into the priority queue pq.insert(10) pq.insert(5) pq.insert(20) pq.insert(3) # Extract the minimum element print(pq.extract_min()) # Expected output: 3 # Decrease the key of the element 20 to 4 pq.decrease_key(20, 4) # Extract the minimum element print(pq.extract_min()) # Expected output: 4 # Check if the priority queue is empty print(pq.is_empty()) # Expected output: False # Extract remaining elements print(pq.extract_min()) # Expected output: 5 print(pq.extract_min()) # Expected output: 10 # Check if the priority queue is empty again print(pq.is_empty()) # Expected output: True ```","solution":"import heapq class MinPriorityQueue: def __init__(self) -> None: Initialize an empty min-priority queue using a min-heap. self.heap = [] self.entries = {} def insert(self, key: int) -> None: Insert a new key into the min-priority queue. heapq.heappush(self.heap, key) self.entries[key] = key def extract_min(self) -> int: Extract and return the minimum key in the min-priority queue. if self.is_empty(): raise IndexError(\\"extract_min(): empty priority queue\\") min_elem = heapq.heappop(self.heap) self.entries.pop(min_elem) return min_elem def decrease_key(self, old_key: int, new_key: int) -> None: Decrease the key value of a specified element in the min-priority queue. if old_key not in self.entries: raise KeyError(\\"decrease_key(): key not found in the priority queue\\") if new_key >= old_key: raise ValueError(\\"decrease_key(): new key must be smaller than old key\\") # Remove the old key value self.heap.remove(old_key) heapq.heapify(self.heap) # Add the new key value heapq.heappush(self.heap, new_key) self.entries.pop(old_key) self.entries[new_key] = new_key def is_empty(self) -> bool: Check if the min-priority queue is empty. return len(self.heap) == 0"},{"question":"# Scenario You are developing a route optimization module for a ride-sharing app that helps users find the quickest route between two locations in a city. The city’s road network is represented as a weighted directed graph where intersections are nodes, and roads are edges with weights representing the travel time. # Task Implement the Shortest Path algorithm using Dijkstra\'s algorithm to find the quickest route between two given locations in the city. Your solution should handle the following functionalities: 1. **Graph Construction:** Accept a list of edges and construct the graph. 2. **Shortest Path Query:** Find the shortest travel time between two nodes. 3. **Path Reconstruction:** Output the path that provides the shortest travel time between two nodes. # Specifications 1. **Input:** * **Edges:** A list of tuples where each tuple represents an edge with three elements `(start_node, end_node, travel_time)`. * **Queries:** A list of tuples where each tuple represents a query with two elements `(start_node, end_node)`. 2. **Output:** * A list of results for each query. Each result should be a tuple containing the total travel time and the list of nodes representing the path. 3. **Query Types:** * **Shortest Path Query:** `(start_node, end_node)` - returns the shortest travel time and the path from `start_node` to `end_node`. # Constraints * 1 ≤ number of nodes ≤ 10,000 * 1 ≤ number of edges ≤ 50,000 * 0 ≤ travel_time ≤ 1,000 * `start_node` and `end_node` are integers representing node indices in the graph. * The graph is connected, meaning there is at least one path between any two nodes. # Requirements 1. Implement the graph construction. 2. Implement Dijkstra\'s algorithm to find the shortest travel time between nodes. 3. Implement a function to reconstruct the path from the start node to the end node. 4. Ensure your solution efficiently handles the specified constraints. # Example ```python edges = [ (0, 1, 4), (0, 2, 2), (1, 2, 5), (1, 3, 10), (2, 4, 3), (4, 3, 4) ] queries = [ (0, 3), (2, 3) ] results = shortest_path_queries(edges, queries) print(results) # Output should be [(9, [0, 2, 4, 3]), (7, [2, 4, 3])] ``` # Note Make sure to handle edge cases such as non-existent nodes, no available path between the nodes, and ensure your solution prioritizes performance and scalability for large graphs.","solution":"import heapq from collections import defaultdict, deque def construct_graph(edges): graph = defaultdict(list) for start, end, travel_time in edges: graph[start].append((end, travel_time)) graph[end].append((start, travel_time)) # Assuming bidirectional travel return graph def dijkstra(graph, start, end): heap = [(0, start, [])] visited = set() while heap: (current_time, current_node, path) = heapq.heappop(heap) if current_node in visited: continue path = path + [current_node] visited.add(current_node) if current_node == end: return (current_time, path) for neighbor, travel_time in graph[current_node]: if neighbor not in visited: heapq.heappush(heap, (current_time + travel_time, neighbor, path)) return (float(\\"inf\\"), []) def shortest_path_queries(edges, queries): graph = construct_graph(edges) results = [] for start, end in queries: travel_time, path = dijkstra(graph, start, end) if travel_time == float(\\"inf\\"): results.append((None, [])) else: results.append((travel_time, path)) return results"},{"question":"# Problem Statement: You need to implement a function that calculates the n-th Fibonacci number using matrix exponentiation. Matrix exponentiation is an efficient way to compute Fibonacci numbers in (O(log n)) time complexity, making it suitable for large values of (n). # Function Signature: ```python def fibonacci_matrix_exponentiation(n: int) -> int: pass ``` # Input: * `n` (int): The position in the Fibonacci sequence to calculate, where (n geq 0). # Output: * Returns an `int`, the n-th Fibonacci number. # Constraints: * (0 leq n leq 10^9) # Example: ```python def fibonacci_matrix_exponentiation(n: int) -> int: def matrix_mult(A, B): return [ [A[0][0]*B[0][0] + A[0][1]*B[1][0], A[0][0]*B[0][1] + A[0][1]*B[1][1]], [A[1][0]*B[0][0] + A[1][1]*B[1][0], A[1][0]*B[0][1] + A[1][1]*B[1][1]] ] def matrix_pow(matrix, power): result = [[1, 0], [0, 1]] base = matrix while power: if power % 2 == 1: result = matrix_mult(result, base) base = matrix_mult(base, base) power //= 2 return result F = [[1, 1], [1, 0]] if n == 0: return 0 elif n == 1: return 1 else: result = matrix_pow(F, n-1) return result[0][0] # Example Usage print(fibonacci_matrix_exponentiation(10)) # Output: 55 print(fibonacci_matrix_exponentiation(50)) # Output: 12586269025 ``` # Requirements: 1. Implement the function `fibonacci_matrix_exponentiation` using matrix exponentiation for efficient calculation. 2. Ensure the function handles edge cases, such as `n = 0` and `n = 1` correctly. 3. Test the function with a wide range of values, especially large ones to ensure performance constraints. # Hints: 1. The Fibonacci sequence can be represented by the transformation matrix `[[1, 1], [1, 0]]`. 2. Utilize matrix multiplication and exponentiation techniques for optimal performance.","solution":"def fibonacci_matrix_exponentiation(n: int) -> int: Calculates the n-th Fibonacci number using matrix exponentiation. Args: n: The position in the Fibonacci sequence to compute. Returns: An integer, the n-th Fibonacci number. def matrix_mult(A, B): return [ [A[0][0]*B[0][0] + A[0][1]*B[1][0], A[0][0]*B[0][1] + A[0][1]*B[1][1]], [A[1][0]*B[0][0] + A[1][1]*B[1][0], A[1][0]*B[0][1] + A[1][1]*B[1][1]] ] def matrix_pow(matrix, power): result = [[1, 0], [0, 1]] # Identity matrix base = matrix while power: if power % 2 == 1: result = matrix_mult(result, base) base = matrix_mult(base, base) power //= 2 return result F = [[1, 1], [1, 0]] if n == 0: return 0 elif n == 1: return 1 else: result = matrix_pow(F, n-1) return result[0][0]"},{"question":"# Summing Leaves of a Binary Tree Objective Implement a function `sum_of_leaves(root)` which takes the root of a binary tree and returns the sum of all the leaf nodes\' values. Function Signature ```python def sum_of_leaves(root: Optional[Node]) -> int: ``` Input - `root`: The root node of a binary tree (Node), where Node is a class that has: - An `int` value. - A `Node` reference to the left child. - A `Node` reference to the right child. Output - The sum of the values of all the leaf nodes in the binary tree (int). Example ```python # Implement Node class according to the given definition # Example usage: # Create a binary tree root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) root.right.left = Node(6) root.right.right = Node(7) # Function call total_leaves_sum = sum_of_leaves(root) # The leaf nodes are: 4, 5, 6, 7 # Their sum is: 4 + 5 + 6 + 7 = 22 # So the function should return: 22 ``` Constraints - The number of nodes in the tree can be up to 10^4. - The values of the nodes are between -1000 and 1000. - Assume that the node values are distinct. Performance Requirements - Time complexity should be O(n), where n is the number of nodes in the tree. - Space complexity should consider the call stack for recursion. Notes - Implement the `Node` class as per the given definition. - Ensure to handle edge cases such as empty trees or trees with a single node.","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def sum_of_leaves(root): if root is None: return 0 if root.left is None and root.right is None: return root.value return sum_of_leaves(root.left) + sum_of_leaves(root.right)"},{"question":"# Scenario: You are tasked with developing a navigation system for an autonomous robot operating within a 2D grid. The robot should be able to find the shortest path from its starting position to a target position while avoiding obstacles. # Task: Implement a pathfinding algorithm using the A* search algorithm to determine the shortest path on a 2D grid. The robot can move vertically and horizontally but not diagonally. The grid contains obstacles that the robot cannot pass through. # Requirements: 1. **Initialization**: Initialize the grid with a given size and obstacles. 2. **Methods**: * `find_path(start, end)`: Calculate and return the shortest path from the start position to the end position as a list of coordinates, or an empty list if no path exists. 3. **Constraints**: * The `start` and `end` coordinates are within the grid boundaries. * The grid size is represented by `rows` and `columns`. * Obstacles are represented as a list of tuples, with each tuple representing the coordinates of an obstacle. # Input Format: - Initialization parameters: * `rows`: Number of rows in the grid. * `columns`: Number of columns in the grid. * `obstacles`: List of tuples representing the coordinates of obstacles. - For `find_path` method: * `start`: Tuple representing the starting coordinates `(row, column)` of the robot. * `end`: Tuple representing the target coordinates `(row, column)` for the robot. # Output Format: - `find_path`: List of coordinates representing the shortest path from `start` to `end`, or an empty list if no path exists. # Example: ```python # Initializing the grid with 5 rows, 5 columns, and obstacles at coordinates (1,1) and (3,3) grid_nav = GridNavigator(5, 5, [(1,1), (3,3)]) # Finding the shortest path from (0,0) to (4,4) path = grid_nav.find_path((0,0), (4,4)) # Expected output: A list of coordinates representing the path, e.g., [(0,0), (0,1), (1,1), ..., (4,4)] print(path) ``` Implement the `GridNavigator` class in Python with the above specifications.","solution":"import heapq class GridNavigator: def __init__(self, rows, columns, obstacles): self.rows = rows self.columns = columns self.obstacles = set(obstacles) self.directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right def heuristic(self, a, b): Calculate the Manhattan distance heuristic. return abs(a[0] - b[0]) + abs(a[1] - b[1]) def in_bounds(self, position): Check if a position is within the grid bounds. r, c = position return 0 <= r < self.rows and 0 <= c < self.columns def passable(self, position): Check if a position is not an obstacle. return position not in self.obstacles def neighbors(self, position): Generate valid neighboring positions. r, c = position results = [] for dr, dc in self.directions: neighbor = (r + dr, c + dc) if self.in_bounds(neighbor) and self.passable(neighbor): results.append(neighbor) return results def find_path(self, start, end): Find the shortest path from start to end using A* algorithm. frontier = [(0, start)] heapq.heapify(frontier) came_from = {start: None} cost_so_far = {start: 0} while frontier: current_priority, current = heapq.heappop(frontier) if current == end: break for next in self.neighbors(current): new_cost = cost_so_far[current] + 1 if next not in cost_so_far or new_cost < cost_so_far[next]: cost_so_far[next] = new_cost priority = new_cost + self.heuristic(end, next) heapq.heappush(frontier, (priority, next)) came_from[next] = current if end not in came_from: return [] path = [] current = end while current: path.append(current) current = came_from[current] path.reverse() return path"},{"question":"# Given Context You are developing a file processing script that processes log files produced during the execution of various services in a microservices architecture. Each log file contains multiple log entries in JSON format, each with a timestamp and a message indicating the status of the service. Your task is to implement a function that processes these log files to extract specific information. # Task 1. Implement a function `extract_errors_with_retry` that processes log files and extracts all log entries with a status of \\"error\\". 2. The function should implement retry logic to handle any FileNotFoundError, retrying up to three times with a delay of 2 seconds between each attempt before logging an error and returning an empty list. 3. Ensure the function handles JSON decoding errors gracefully, skipping over malformed log entries while continuing to process the valid entries. # Input and Output Formats * **Function to implement**: * `extract_errors_with_retry` - This function takes a list of file paths as input and returns a list of log entries with a status of \\"error\\". * **Constraints**: * Must retry up to three times for FileNotFoundError. * Must log an error if all retries fail, without crashing the script. * Use a delay of 2 seconds between retries. * Handle JSON decoding errors by skipping malformed log entries. # Example Scenario Assume you have a set of log files that occasionally might not exist due to intermittent file system issues. The script should retry reading these files and extract the \\"error\\" status log entries from the files, skipping malformed entries and continuing processing valid ones. # Starter Code ```python import json import time from typing import List def extract_errors_with_retry(file_paths: List[str]) -> List[dict]: error_entries = [] for file_path in file_paths: for attempt in range(3): try: with open(file_path, \'r\') as file_handle: log_entries = file_handle.readlines() for entry in log_entries: try: log_entry = json.loads(entry) if log_entry.get(\'status\') == \'error\': error_entries.append(log_entry) except json.JSONDecodeError: print(f\\"Skipping malformed log entry: {entry}\\") # Successful read and processing, break out of retry loop. break except FileNotFoundError as e: if attempt < 2: time.sleep(2) else: print(f\\"Error reading file {file_path}: {e}\\") return error_entries # Example usage file_paths = [\\"logfile1.txt\\", \\"logfile2.txt\\"] error_logs = extract_errors_with_retry(file_paths) print(f\\"Extracted error logs: {error_logs}\\") ``` # Explanation This script reads log files from the provided list of file paths and extracts log entries with a status of \\"error\\". If a FileNotFoundError occurs, it retries up to three times with a 2-second delay between attempts before logging an error and moving to the next file. It handles JSON decoding errors gracefully by skipping over malformed log entries and continuing to process the remaining entries.","solution":"import json import time import logging from typing import List # Setup logging logging.basicConfig(level=logging.ERROR) logger = logging.getLogger(__name__) def extract_errors_with_retry(file_paths: List[str]) -> List[dict]: Extracts all log entries with a status of \\"error\\" from the provided list of file paths. Retries up to 3 times for each file if a FileNotFoundError occurs, with a 2-second delay between retries. Skips malformed JSON entries gracefully. error_entries = [] for file_path in file_paths: for attempt in range(3): try: with open(file_path, \'r\') as file_handle: log_entries = file_handle.readlines() for entry in log_entries: try: log_entry = json.loads(entry) if log_entry.get(\'status\') == \'error\': error_entries.append(log_entry) except json.JSONDecodeError: logger.error(f\\"Skipping malformed log entry: {entry}\\") # Successful read and processing, break out of retry loop. break except FileNotFoundError as e: if attempt < 2: time.sleep(2) else: logger.error(f\\"Error reading file {file_path} after 3 attempts: {e}\\") return error_entries"},{"question":"# Coding Assessment Question Background & Context You are developing a web application that includes a feature allowing users to upload images. To improve performance and reduce storage requirements, you need to implement an image optimization tool that employs run-length encoding (RLE) for compressing images. RLE is a simple form of lossless data compression where consecutive occurrences of the same value (runs) are stored as a single value and a count. Task Write a function `compress_image` that takes the path of an image file encoded in a simple grayscale format (each pixel value represented by a single byte) and compresses it using run-length encoding. The compressed data should be written to the specified destination file in a format where each run is represented as a tuple of the value and its count. Function Signature ```python def compress_image(source_path: str, destination_path: str) -> None: Compresses the grayscale image at source_path using run-length encoding and writes the compressed data to destination_path. :param source_path: str, path of the grayscale image file to be compressed :param destination_path: str, path of the file where compressed data will be written ``` Input and Output Format * **Input**: - `source_path` (str): Path to the grayscale image file. - `destination_path` (str): Path where compressed data should be written. * **Output**: - Writes the run-length encoded image data to the specified destination file (in binary format). Constraints * The image is encoded as a sequence of bytes, with each byte representing a pixel value in the range [0, 255]. * Ensure efficient handling of runs and proper termination of the output format. * Consider the file format when reading and writing the image data, ensuring no data loss occurs. Example Suppose the image file at `source_path` contains the following byte data: ``` [255, 255, 255, 0, 0, 255, 100, 100, 100, 100] ``` Your `compress_image` function should generate compressed data and write it to `destination_path` as: ``` [(255, 3), (0, 2), (255, 1), (100, 4)] ``` Notes * You may use Python\'s `open` function to read from and write to files in binary mode. * Focus on accurately identifying runs and ensuring proper format for compressed data. * Consider edge cases such as varying run lengths and single occurrences. We hope you find this problem enjoyable and challenging. Good luck!","solution":"def compress_image(source_path: str, destination_path: str) -> None: Compresses the grayscale image at source_path using run-length encoding and writes the compressed data to destination_path. :param source_path: str, path of the grayscale image file to be compressed :param destination_path: str, path of the file where compressed data will be written with open(source_path, \'rb\') as source_file: image_data = source_file.read() compressed_data = [] if image_data: current_value = image_data[0] count = 1 for byte in image_data[1:]: if byte == current_value: count += 1 else: compressed_data.append((current_value, count)) current_value = byte count = 1 compressed_data.append((current_value, count)) with open(destination_path, \'wb\') as dest_file: for value, count in compressed_data: dest_file.write(bytes([value])) dest_file.write(count.to_bytes(4, \'big\')) # Write count as a 4-byte integer"},{"question":"# Problem Statement You are given a list of strings, where each string represents a binary number. Your task is to determine the minimum number of changes needed to make all the binary numbers in the list equal. # Function Signature ```python def min_changes_to_equal_binary(numbers: List[str]) -> int: Determine the minimum number of changes needed to make all binary numbers in the list equal. Parameters: numbers (List[str]): A list of binary strings. Returns: int: The minimum number of changes needed. ``` # Input 1. **numbers (List[str])**: A list of binary strings. # Output * **return (int)**: The minimum number of changes needed to make all binary numbers in the list equal. # Constraints * `1 <= len(numbers) <= 100` * Each string in `numbers` will have the same length, `1 <= length of string <= 100` # Example ```python assert min_changes_to_equal_binary([\\"101\\", \\"111\\", \\"001\\"]) == 2 assert min_changes_to_equal_binary([\\"110\\", \\"110\\", \\"011\\", \\"100\\"]) == 3 ``` # Notes - A \\"change\\" means flipping a \'0\' to \'1\' or a \'1\' to \'0\' in one of the binary strings. - The goal is to minimize the total number of individual bit changes across all strings to make every string in the list identical. - Consider calculating the optimal binary string at each bit position to minimize the number of changes overall.","solution":"from typing import List def min_changes_to_equal_binary(numbers: List[str]) -> int: Determine the minimum number of changes needed to make all binary numbers in the list equal. Parameters: numbers (List[str]): A list of binary strings. Returns: int: The minimum number of changes needed. if not numbers: return 0 num_bits = len(numbers[0]) total_changes = 0 for i in range(num_bits): bit_count = {\'0\': 0, \'1\': 0} for number in numbers: bit_count[number[i]] += 1 # We choose to change the less frequent bit total_changes += min(bit_count[\'0\'], bit_count[\'1\']) return total_changes"},{"question":"# Coding Assessment Question Context You are given a class `Polygon` that represents a convex polygon in a 2D plane. The class supports various operations such as calculating the perimeter, area, and checking if a point is inside the polygon. Problem Statement Implement the following function: ```python def is_point_inside(polygon: Polygon, point: Tuple[int, int]) -> bool: Determines whether a given point lies inside, on the edge, or outside the polygon. Args: polygon (Polygon): The polygon described by a list of vertices given in clockwise or counterclockwise order. point (Tuple[int, int]): The point represented as a tuple (x, y). Returns: bool: True if the point lies inside or on the edge of the polygon, else False. pass ``` Definition To determine whether a point (P) is inside a polygon, we can use the ray-casting algorithm which counts the number of times a ray starting from the point crosses the edges of the polygon. If the count is odd, the point is inside. If even, the point is outside. Input - `polygon`: An instance of the `Polygon` class with its vertices defined as a list of tuples [(x1, y1), (x2, y2), ..., (xn, yn)]. - `point`: A tuple `(x, y)` representing the coordinates of the point to be checked. Output - A boolean indicating if the point is inside or on the edge of the polygon. Constraints - The number of vertices ( n ) of the polygon is at least 3 and does not exceed 100. - The coordinates of the vertices and the point are integers. - The polygon is always convex and simple (no self-intersections). Examples ```python # Example 1 polygon = Polygon([(0, 0), (5, 0), (5, 5), (0, 5)]) point = (3, 3) assert is_point_inside(polygon, point) == True # Example 2 polygon = Polygon([(0, 0), (5, 0), (5, 5), (0, 5)]) point = (5, 5) assert is_point_inside(polygon, point) == True # Example 3 polygon = Polygon([(0, 0), (5, 0), (5, 5), (0, 5)]) point = (6, 5) assert is_point_inside(polygon, point) == False ``` Notes 1. You may utilize helper methods in the `Polygon` class for calculating geometric properties. 2. Consider boundary conditions such as the point being exactly on a vertex or an edge of the polygon.","solution":"from typing import List, Tuple class Polygon: def __init__(self, vertices: List[Tuple[int, int]]): self.vertices = vertices def is_point_inside(polygon: Polygon, point: Tuple[int, int]) -> bool: Determines whether a given point lies inside, on the edge, or outside the polygon. Args: polygon (Polygon): The polygon described by a list of vertices given in clockwise or counterclockwise order. point (Tuple[int, int]): The point represented as a tuple (x, y). Returns: bool: True if the point lies inside or on the edge of the polygon, else False. x, y = point n = len(polygon.vertices) inside = False px0, py0 = polygon.vertices[0] for i in range(n + 1): px1, py1 = polygon.vertices[i % n] if min(py0, py1) < y <= max(py0, py1): if x <= max(px0, px1): if py0 != py1: x_intersect = (y - py0) * (px1 - px0) / (py1 - py0) + px0 if px0 == px1 or x <= x_intersect: inside = not inside if y == py0 and x == px0: return True px0, py0 = px1, py1 return inside"},{"question":"# Cache System using Least Recently Used (LRU) Algorithm **Scenario**: You are designing a caching system for a web server to store the results of expensive article queries. To maximize efficiency and ensure quick access to frequently requested articles, the server cache should operate with a Least Recently Used (LRU) eviction policy. This means when the cache reaches its capacity, it should evict the least recently accessed article to make room for the new one. **Task**: Create a class `LRUCache` with the following methods: 1. **put(key, value)**: Inserts the key-value pair into the cache. If the cache reaches its capacity, it should evict the least recently used item before inserting the new item. 2. **get(key)**: Retrieves the value associated with the key from the cache. Moves the accessed key to the most recently used position. Returns `None` if the key is not found. 3. **delete(key)**: Removes the key and its associated value from the cache. No action is taken if the key is not found. 4. **exists(key)**: Returns `True` if the key is present in the cache, otherwise `False`. 5. **size()**: Returns the number of items currently stored in the cache. The cache should maintain a fixed size specified at initialization. **Constraints**: - The keys and values can be of any data type. - The LRU eviction policy should be implemented efficiently in terms of both time and space complexity. - Handle edge cases such as accessing or deleting a non-existent key without crashing. **Example Usage**: ```python cache = LRUCache(2) cache.put(\'a\', 1) cache.put(\'b\', 2) print(cache.get(\'a\')) # 1 cache.put(\'c\', 3) # Evicts key \'b\' print(cache.get(\'b\')) # None print(cache.exists(\'b\')) # False print(cache.get(\'c\')) # 3 cache.delete(\'a\') print(cache.exists(\'a\')) # False cache.put(\'d\', 4) print(cache.size()) # 2 print(cache.get(\'d\')) # 4 print(cache.get(\'c\')) # 3 ``` **Implementation**: Complete the implementation by filling in the missing methods for the `LRUCache` class. Ensure your methods handle all specified operations correctly, capturing edge cases and performance constraints as discussed. Use appropriate data structures to achieve an efficient LRU mechanism.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = OrderedDict() def put(self, key, value): if key in self.cache: del self.cache[key] elif len(self.cache) >= self.capacity: self.cache.popitem(last=False) self.cache[key] = value def get(self, key): if key not in self.cache: return None value = self.cache.pop(key) self.cache[key] = value return value def delete(self, key): if key in self.cache: del self.cache[key] def exists(self, key) -> bool: return key in self.cache def size(self) -> int: return len(self.cache)"},{"question":"# Coding Assessment Question Scenario You have been engaged in developing a tool that filters and manipulates text. One of the features required is the identification and processing of \'happy numbers.\' A happy number is defined as a number which eventually reaches 1 when replaced by the sum of the square of each digit. If a number cannot reach 1 after multiple iterations, it is considered an unhappy number. Your task is to implement a method to determine whether a given number is happy without falling into infinite loops for numbers that are not happy. Task Implement a function `is_happy_number(n: int) -> bool` that determines if `n` is a happy number. Requirements * **Input**: An integer `n` (1 ≤ n ≤ 10^6) * **Output**: Return `True` if `n` is a happy number, otherwise return `False`. Constraints * Ensure the input value `n` is a positive integer. * Handle edge cases where `n` is not within the specified range. * Optimize the function to avoid infinite loops and performance issues for larger values of `n`. Example ```python is_happy_number(19) # Output: True is_happy_number(2) # Output: False is_happy_number(100) # Output: True ``` Notes * You may consider using a loop to track seen numbers to detect and avoid cycles. * Validate the input to ensure it meets the specified constraints. * The function should handle inputs efficiently, even for large numbers close to 10^6.","solution":"def is_happy_number(n): Determines if a given number n is a happy number. Parameters: n (int): The number to check for happiness. Returns: bool: True if n is a happy number, False otherwise. def get_next(number): total_sum = 0 while number > 0: digit = number % 10 total_sum += digit * digit number //= 10 return total_sum seen = set() while n != 1 and n not in seen: seen.add(n) n = get_next(n) return n == 1"},{"question":"Question # Problem Statement You are tasked with writing a Python function that implements a basic version of the HashMap data structure using a list. Your function should be able to perform two operations: insert a key-value pair and retrieve the value for a given key. # Function Signature ```python def hashmap(operations: List[Tuple[str, Any, Any]]) -> List[Any]: Implement a basic HashMap with insert and get operations. :param operations: A list of operations to be performed on the HashMap. Each operation is represented as a tuple where the first element is a string indicating the operation type (\'insert\' or \'get\'), the second element is the key, and the third element is the value (only for \'insert\' operations). :return: A list of results for all \'get\' operations. Examples: >>> hashmap([(\'insert\', \'a\', 1), (\'insert\', \'b\', 2), (\'get\', \'a\', None), (\'get\', \'b\', None)]) [1, 2] >>> hashmap([(\'insert\', \'a\', 1), (\'insert\', \'a\', 2), (\'get\', \'a\', None)]) [2] >>> hashmap([(\'get\', \'unknown\', None)]) [None] >>> hashmap([(\'insert\', \'x\', 42), (\'get\', \'x\', None), (\'insert\', \'x\', 84), (\'get\', \'x\', None)]) [42, 84] ``` # Constraints 1. The `operations` list contains tuples of operations where: - The first element is a string `str` and it will be either \'insert\' or \'get\'. - The second element is the key `str`. - The third element is the value `Any` for \'insert\' operations. 2. When performing a \'get\' operation on a key that does not exist, the result should be `None`. 3. Assume the keys are strings and values can be of any type. 4. The `operations` list will contain at least one operation and at most 10^4 operations. # Task Implement the `hashmap` function so that it correctly performs the \'insert\' and \'get\' operations based on the provided input list of operations, returning a list of results for all \'get\' operations.","solution":"def hashmap(operations): Implement a basic HashMap with insert and get operations. :param operations: A list of operations to be performed on the HashMap. Each operation is represented as a tuple where the first element is a string indicating the operation type (\'insert\' or \'get\'), the second element is the key, and the third element is the value (only for \'insert\' operations). :return: A list of results for all \'get\' operations. hmap = {} results = [] for operation in operations: if operation[0] == \'insert\': hmap[operation[1]] = operation[2] elif operation[0] == \'get\': results.append(hmap.get(operation[1], None)) return results"},{"question":"# Question You are provided with an array of integers. Your task is to design an efficient function that returns all possible unique subsets of the array where each subset\'s elements are sorted in non-descending order. **Core Concepts**: A subset of a given set is a list containing some or none of the elements from the original set, where the order of elements does not matter. The output must include the empty subset and should not contain duplicate subsets. # Input - A list of integers `nums` representing the array. # Output - A list of lists, where each inner list represents a unique subset of `nums`. Each subset\'s elements should be sorted in ascending order, and the list of subsets should also be sorted and not contain duplicate subsets. # Constraints - 0 ≤ len(nums) ≤ 10 (number of elements in the array) - -10 ≤ nums[i] ≤ 10 (value of each element in the array) # Example ```python nums = [1, 2, 2] print(find_unique_subsets(nums)) ``` Output: ```python [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]] ``` # Implementation Function signature: ```python def find_unique_subsets(nums: list[int]) -> list[list[int]]: pass ``` # Steps to Solve: 1. Sort the input array to handle duplicates easily. 2. Use a backtracking approach to explore all possible subsets. 3. Handle duplicates by ensuring that each selection or skipping of an element respects the sorted order and avoids creating the same subset more than once. 4. Collect and return all unique subsets. **Additional Information**: Your implementation should efficiently handle all possible permutations of the array elements, while ensuring to eliminate duplicate subsets by utilizing sorting and a systematic subset generation technique. Consider edge cases like an empty array or arrays with all duplicate elements.","solution":"def find_unique_subsets(nums): Returns all unique subsets of the provided integer array, sorted in ascending order. def backtrack(start, path): # Add the current subset to the results res.append(path) for i in range(start, len(nums)): # If the current element is the same as the previous one, skip it to avoid duplicates if i > start and nums[i] == nums[i - 1]: continue # Recurse with the new element added to the current subset path backtrack(i + 1, path + [nums[i]]) nums.sort() # Sort the array to handle duplicates and maintain order res = [] backtrack(0, []) return res"},{"question":"# Problem Statement You are given the task of designing a web service that processes multiple HTTP request logs and aggregates important metrics. Each log entry contains an HTTP method, URL endpoint, and response time in milliseconds. Objective Write a function `aggregate_http_logs(logs: List[str]) -> Dict[str, Dict[str, Union[float, int]]]` to aggregate metrics from the HTTP logs. Input * `logs`: A list of strings where each string represents an HTTP request log entry. Each log entry follows the format: \\"METHOD ENDPOINT RESPONSE_TIME\\". Output * A dictionary where each key is an endpoint, and the value is another dictionary with the following metrics: * `requests`: The total number of requests received for the endpoint. * `avg_response_time`: The average response time in milliseconds for the endpoint. Constraints * The input method names (e.g., \\"GET\\", \\"POST\\") and endpoints are case-insensitive. * Each `RESPONSE_TIME` is a non-negative integer. * Length of `logs` is between 1 and 10^6 inclusive. * You can assume valid input format across logs. Requirements 1. Implement `aggregate_http_logs` such that it processes each log entry, aggregates the data in constant time, leading to an overall linear time complexity O(n), where n is the number of log entries. # Example ```python aggregate_http_logs([\\"GET /api/users 100\\", \\"POST /api/users 200\\", \\"GET /api/users 150\\", \\"GET /home 100\\"]) # Output: {\\"/api/users\\": {\\"requests\\": 3, \\"avg_response_time\\": 150.0}, \\"/home\\": {\\"requests\\": 1, \\"avg_response_time\\": 100.0}} aggregate_http_logs([\\"POST /login 300\\", \\"POST /login 400\\", \\"GET /login 200\\"]) # Output: {\\"/login\\": {\\"requests\\": 3, \\"avg_response_time\\": 300.0}} aggregate_http_logs([\\"GET /data 500\\"]) # Output: {\\"/data\\": {\\"requests\\": 1, \\"avg_response_time\\": 500.0}} ```","solution":"from typing import List, Dict, Union def aggregate_http_logs(logs: List[str]) -> Dict[str, Dict[str, Union[float, int]]]: Aggregates metrics from the HTTP logs. Parameters: logs (List[str]): List of HTTP log entries in \\"METHOD ENDPOINT RESPONSE_TIME\\" format. Returns: Dict[str, Dict[str, Union[float, int]]]: Aggregated metrics for each endpoint. metrics = {} for log in logs: parts = log.split() method, endpoint, response_time = parts[0].upper(), parts[1], int(parts[2]) if endpoint not in metrics: metrics[endpoint] = {\'requests\': 0, \'total_response_time\': 0} metrics[endpoint][\'requests\'] += 1 metrics[endpoint][\'total_response_time\'] += response_time for endpoint in metrics: total_requests = metrics[endpoint][\'requests\'] total_response_time = metrics[endpoint][\'total_response_time\'] avg_response_time = total_response_time / total_requests metrics[endpoint][\'avg_response_time\'] = avg_response_time del metrics[endpoint][\'total_response_time\'] return metrics"},{"question":"# Coding Challenge In competitive programming, it\'s often useful to quickly determine if an array can be segmented into two subarrays with equal sums. Your task is to implement an efficient solution that checks if a given array meets this criteria. Objective You need to create a function `can_partition` which determines if the input list can be partitioned into two subarrays such that the sum of elements in both subarrays is equal. Requirements - Implement the `can_partition` function. - You must use dynamic programming to solve this problem efficiently. Function Signature ```python def can_partition(nums: List[int]) -> bool: pass ``` Input - `nums`: A list of integers, can be both positive and negative. - Example: [1, 5, 11, 5] Output - Returns `True` if the array can be partitioned into two subarrays with equal sum, otherwise returns `False`. Constraints - The sum of the array elements must be an even number; otherwise, it\'s impossible to partition it into two equal parts. - The solution should be optimal with time and space complexity in mind. Example Here is an example of how your function should work: ```python >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False >>> can_partition([-3, 1, 2, 3, -1, 5]) False >>> can_partition([1, 2, 3, 4, 5, 5]) True ``` Code Template Use the following template to start your implementation: ```python from typing import List def can_partition(nums: List[int]) -> bool: total_sum = sum(nums) if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) dp = [False] * (target + 1) dp[0] = True for num in nums: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target] if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"from typing import List def can_partition(nums: List[int]) -> bool: total_sum = sum(nums) if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) dp = [False] * (target + 1) dp[0] = True for num in nums: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"# Coding Assessment Question Context You work for a software company that develops advanced mathematical computation tools. Your team is working on a function that needs to process a list of numbers and find the second largest unique number in the list. Your task is to implement this feature. Task Write a Python function `second_largest_unique` that performs the following operations: 1. Identify all unique numbers in the input list. 2. Find and return the second largest number among the unique numbers. Function Signature ```python def second_largest_unique(numbers: List[int]) -> int: ``` Input * `numbers` (a list of integers): A list of integers where you need to identify the second largest unique number. Output * An integer that represents the second largest unique number in the list, or -1 if no such number exists. Constraints 1. The input list `numbers` will have at most `10000` elements. 2. Each element in the list will be in the range `[-10^6, 10^6]`. 3. If there are fewer than two unique numbers, return -1. Example ```python # Example numbers = [3, 1, 4, 1, 5, 9, 3, 4, 5, 9] print(second_largest_unique(numbers)) # Output: 5 numbers = [7, 7, 7] print(second_largest_unique(numbers)) # Output: -1 numbers = [1, 2] print(second_largest_unique(numbers)) # Output: 1 ``` Notes * You can assume that the input list is non-empty. * Ensure that your function handles edge cases, such as when there are not enough unique numbers to determine the second largest.","solution":"from typing import List def second_largest_unique(numbers: List[int]) -> int: Returns the second largest unique number from the list. If there are fewer than two unique numbers, it returns -1. unique_numbers = set(numbers) if len(unique_numbers) < 2: return -1 sorted_unique_numbers = sorted(unique_numbers, reverse=True) return sorted_unique_numbers[1]"},{"question":"# Problem Statement: Sorted Array from Binary Search Tree You are tasked with implementing a Python function that takes the root of a Binary Search Tree (BST) and returns a list of its elements in ascending order. Function Signature ```python def bst_to_sorted_list(root: \'TreeNode\') -> list: pass ``` Input - `root` (`TreeNode`): The root node of a binary search tree (BST). Output - Returns a list of elements sorted in ascending order, representing an in-order traversal of the BST. Constraints - Each node in the BST has an integer value. - The tree node class `TreeNode` is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Example ```python # Example 1: # Input: root = [4, 2, 6, 1, 3, 5, 7] # 4 # / # 2 6 # / / # 1 3 5 7 # Output: [1, 2, 3, 4, 5, 6, 7] # Example 2: # Input: root = [3, 1, 4, None, 2] # 3 # / # 1 4 # # 2 # Output: [1, 2, 3, 4] root1 = TreeNode(4) root1.left = TreeNode(2, TreeNode(1), TreeNode(3)) root1.right = TreeNode(6, TreeNode(5), TreeNode(7)) print(bst_to_sorted_list(root1)) # Output: [1, 2, 3, 4, 5, 6, 7] root2 = TreeNode(3, TreeNode(1, right=TreeNode(2)), TreeNode(4)) print(bst_to_sorted_list(root2)) # Output: [1, 2, 3, 4] ``` Instructions 1. Implement an in-order traversal to retrieve the elements of the BST. 2. Ensure the solution handles the base case where the BST is empty (i.e., `root` is `None`). The function should return an empty list in this case. 3. The function should expect to receive a well-formed BST and should not need to validate the BST properties during execution. Note - The tree is defined using a `TreeNode` class. Implement the in-order traversal by visiting the left subtree, then the root node, and finally the right subtree. - Consider the potential for deep recursive calls in your design, ensuring it handles large input sizes gracefully.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bst_to_sorted_list(root: TreeNode) -> list: Convert BST to a sorted list using in-order traversal. :param root: TreeNode - The root node of the binary search tree. :return: list - List of elements in the BST sorted in ascending order. def in_order_traversal(node, elements): if node: in_order_traversal(node.left, elements) elements.append(node.val) in_order_traversal(node.right, elements) sorted_elements = [] in_order_traversal(root, sorted_elements) return sorted_elements"},{"question":"# Problem Statement You are given an array of integers where each element appears twice except for one element which appears only once. Your task is to write a function to find the single element that appears only once. The solution should have a linear runtime complexity and should not use extra memory. Write a function called `find_single_number` that takes in the array and returns the single number that appears only once. # Function Signature ```python def find_single_number(nums: list[int]) -> int: pass ``` # Input * `nums` (List): A list of integers where 1 ≤ len(nums) ≤ 10^5 and all elements except one appear twice. # Output * Returns an integer representing the element that appears only once. # Constraints * The solution should have a linear runtime complexity O(n). * The solution should not use extra memory. # Example ```python assert find_single_number([2, 2, 1]) == 1 assert find_single_number([4, 1, 2, 1, 2]) == 4 assert find_single_number([1]) == 1 assert find_single_number([2, 2, 3, 4, 3, 4, 5]) == 5 ``` # Additional Notes Consider solving this problem by utilizing the properties of XOR: 1. XOR of a number with itself is 0: `a ^ a = 0` 2. XOR of a number with 0 is the number itself: `a ^ 0 = a` 3. XOR is commutative and associative: `a ^ b ^ c = a ^ c ^ b` These properties can be used to find the single number in linear time without extra memory: 1. Initialize a variable `result` to 0. 2. Iterate through the array and perform XOR operation on each element with `result`. 3. At the end, `result` will hold the value of the single number.","solution":"def find_single_number(nums: list[int]) -> int: This function takes a list of integers where every element appears twice except for one, and returns the element that appears only once. result = 0 for num in nums: result ^= num return result"},{"question":"# Question: Phone Keypad Word Suggestion Background On a standard phone keypad, each key represents multiple characters: - 2: [\'a\', \'b\', \'c\'] - 3: [\'d\', \'e\', \'f\'] - 4: [\'g\', \'h\', \'i\'] - 5: [\'j\', \'k\', \'l\'] - 6: [\'m\', \'n\', \'o\'] - 7: [\'p\', \'q\', \'r\', \'s\'] - 8: [\'t\', \'u\', \'v\'] - 9: [\'w\', \'x\', \'y\', \'z\'] Given a sequence of digits, you are to return all possible valid words that could be formed, based on a provided dictionary of words. Task Write a function `word_suggestions(digits: str, dictionary: List[str]) -> List[str]` that takes in a sequence of digits and a dictionary of valid words, and returns a list of valid words that match the sequence. Input * A string of digits `digits` (1 ≤ len(digits) ≤ 7, digits from 2 to 9 only) * A list `dictionary` containing strings of valid words (1 ≤ len(dictionary) ≤ 1000, 1 ≤ len(word) ≤ 7) Output * Returns a list of strings representing valid words from the dictionary that match the sequence of digits. Example ```python def word_suggestions(digits: str, dictionary: List[str]) -> List[str]: # Your code here # Example usage: dictionary = [\\"dog\\", \\"fish\\", \\"fan\\", \\"sad\\", \\"fog\\"] print(word_suggestions(\\"364\\", dictionary)) # Expected output: [\'dog\', \'fog\'] ``` Constraints 1. Each word in the dictionary contains only lowercase letters. 2. The sequence of digits will only contain digits from 2 to 9. Hints 1. Construct a mapping from digits to their possible characters as on the phone keypad. 2. Check each word in the dictionary to see if it matches the possible characters for each digit in the sequence.","solution":"from typing import List def word_suggestions(digits: str, dictionary: List[str]) -> List[str]: digit_to_char = { \'2\': [\'a\', \'b\', \'c\'], \'3\': [\'d\', \'e\', \'f\'], \'4\': [\'g\', \'h\', \'i\'], \'5\': [\'j\', \'k\', \'l\'], \'6\': [\'m\', \'n\', \'o\'], \'7\': [\'p\', \'q\', \'r\', \'s\'], \'8\': [\'t\', \'u\', \'v\'], \'9\': [\'w\', \'x\', \'y\', \'z\'] } def is_valid_word(word): if len(word) != len(digits): return False for i in range(len(digits)): if word[i] not in digit_to_char[digits[i]]: return False return True suggestions = [word for word in dictionary if is_valid_word(word)] return suggestions"},{"question":"# Question: Prime Number Sieve You are tasked with writing a function to generate all prime numbers up to a given number `n` using the Sieve of Eratosthenes algorithm. This algorithm is efficient for finding all prime numbers less than a specified integer. Task Write a function `sieve_of_eratosthenes(n: int) -> List[int]` that returns a list of all prime numbers up to and including `n`. Function Signature ```python def sieve_of_eratosthenes(n: int) -> List[int]: pass ``` Input - `n` (int): The upper limit (inclusive) to generate prime numbers. Must be a non-negative integer. Output - List of all prime numbers up to and including `n`. Constraints - `0 <= n <= 10^6` (Consider efficient handling for large values of `n`) - Raise a `ValueError` for any input value of `n` that is negative. Examples ```python >>> sieve_of_eratosthenes(10) [2, 3, 5, 7] >>> sieve_of_eratosthenes(30) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] >>> sieve_of_eratosthenes(1) [] >>> sieve_of_eratosthenes(-5) Traceback (most recent call last): ... ValueError: param `n` must be non-negative ``` Performance Requirements Your function should operate in O(n log log n) time complexity.","solution":"from typing import List def sieve_of_eratosthenes(n: int) -> List[int]: if n < 0: raise ValueError(\\"param `n` must be non-negative\\") if n < 2: return [] is_prime = [True] * (n + 1) is_prime[0] = is_prime[1] = False p = 2 while p * p <= n: if is_prime[p]: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 primes = [p for p, prime in enumerate(is_prime) if prime] return primes"},{"question":"# Problem: Sum of Unique Elements Scenario You are given a list of integers. Some of these integers may be duplicated multiple times. You need to identify the unique integers (elements that appear exactly once in the list) and compute their sum. Task Write a function `sum_of_unique_elements(numbers: List[int]) -> int` that calculates the sum of all unique elements in the given list of integers. Input * A list of integers `numbers` (1 ≤ len(numbers) ≤ 100,000): The list of integers which may contain repeated elements. Output * The function should return an integer: the sum of all unique elements in the list. Example ```python # Example 1 assert sum_of_unique_elements([1, 2, 3, 2, 1]) == 3 # Example 2 assert sum_of_unique_elements([4, 5, 6, 7, 5, 6, 4]) == 7 ``` Constraints * Consider edge cases where the list might have no unique elements. * Ensure your implementation handles large lists efficiently.","solution":"from typing import List def sum_of_unique_elements(numbers: List[int]) -> int: Returns the sum of unique elements in the list. elements_count = {} # Count the occurrences of each element for number in numbers: if number in elements_count: elements_count[number] += 1 else: elements_count[number] = 1 # Sum up the elements that occur exactly once unique_sum = sum(number for number, count in elements_count.items() if count == 1) return unique_sum"},{"question":"# Coding Assessment Question Scenario An online bookstore wants to enhance its inventory management system by developing a function that calculates the total cost for an order, taking into account discounts on bulk purchases. Your task is to write a function that computes the total price after applying discounts based on the quantity of books ordered. Requirements * Write a function `calculate_total_price(price_per_book: float, quantity: int) -> float` that performs the specified calculation. * Validate the inputs to ensure they meet the following constraints: - The price per book must be greater than 0. - The quantity must be a non-negative integer. * You must raise appropriate exceptions if the input values do not meet the constraints. * The discount structure is as follows: - If 10 or more books are ordered, a 10% discount is applied. - If 20 or more books are ordered, a 20% discount is applied. Expected Input and Output * **Input**: - `price_per_book` (float): The price of a single book. - `quantity` (int): The number of books ordered. * **Output**: - (float): The total price after applying the appropriate discount. Examples 1. `calculate_total_price(100, 5)` should return `500.0` 2. `calculate_total_price(100, 10)` should return `900.0` 3. `calculate_total_price(100, 20)` should return `1600.0` 4. `calculate_total_price(100, 0)` should return `0.0` 5. `calculate_total_price(-10, 5)` should raise an `Exception` with message \\"Price per book must be > 0\\" 6. `calculate_total_price(100, -5)` should raise an `Exception` with message \\"Quantity must be a non-negative integer\\" Constraints * All floating-point results should have a precision of up to 2 decimal places. ***Write your function below:*** ```python def calculate_total_price(price_per_book: float, quantity: int) -> float: Calculate the total price for an order of books after applying bulk purchase discounts. :param price_per_book: The price of a single book :param quantity: The number of books ordered :return: The total price after discounts # Validate input if price_per_book <= 0: raise Exception(\\"Price per book must be > 0\\") if quantity < 0 or not isinstance(quantity, int): raise Exception(\\"Quantity must be a non-negative integer\\") # Calculate total price total_price = price_per_book * quantity # Apply discount based on quantity if quantity >= 20: total_price *= 0.8 # 20% discount elif quantity >= 10: total_price *= 0.9 # 10% discount return round(total_price, 2) # Examples print(calculate_total_price(100, 5)) # Output: 500.0 print(calculate_total_price(100, 10)) # Output: 900.0 print(calculate_total_price(100, 20)) # Output: 1600.0 print(calculate_total_price(100, 0)) # Output: 0.0 ```","solution":"def calculate_total_price(price_per_book: float, quantity: int) -> float: Calculate the total price for an order of books after applying bulk purchase discounts. :param price_per_book: The price of a single book :param quantity: The number of books ordered :return: The total price after discounts # Validate input if price_per_book <= 0: raise Exception(\\"Price per book must be > 0\\") if quantity < 0 or not isinstance(quantity, int): raise Exception(\\"Quantity must be a non-negative integer\\") # Calculate total price total_price = price_per_book * quantity # Apply discount based on quantity if quantity >= 20: total_price *= 0.8 # 20% discount elif quantity >= 10: total_price *= 0.9 # 10% discount return round(total_price, 2)"},{"question":"# Question: Function to Implement: `find_root` Context: Finding the root (or zero) of a function is a common problem in numerical analysis. One of the classic methods for finding roots is the Bisection Method. The Bisection Method works on the principle that a continuous function (f(x)), which has opposite signs at two points (a) and (b), must have at least one root between (a) and (b). Your goal is to implement a function that uses the Bisection Method to find the root of a given continuous function within a specified interval to a certain degree of accuracy. Bisection Method: 1. Check the signs of (f(a)) and (f(b)). If they are the same, raise a ValueError. 2. Compute the midpoint (c = frac{a + b}{2}). 3. Check the sign of (f(c)): - If (f(c) = 0), (c) is the root. - If (f(a)) and (f(c)) have opposite signs, repeat the process with the interval ([a, c]). - If (f(b)) and (f(c)) have opposite signs, repeat the process with the interval ([c, b]). 4. Repeat until the interval ([a, b]) is sufficiently small or until a maximum number of iterations is reached. Task: You need to implement the function `find_root`: ```python from typing import Callable def find_root(func: Callable[[float], float], a: float, b: float, tol: float = 1e-7, max_iter: int = 1000) -> float: Input Parameters ---------------- func : a continuous function a : starting point of the interval b : end point of the interval tol : tolerance value for stopping criterion max_iter : maximum number of iterations allowed Returns ------- root : the root of the function within the interval up to a specified tolerance The function returns the root of the function within the given interval and tolerance. ``` Examples: 1. `find_root(lambda x: x**2 - 4, 0, 3)` should return a value close to `2.0`. 2. `find_root(lambda x: x**3 - x - 2, 1, 2)` should return a value close to `1.521`. 3. `find_root(lambda x: x - 5, 0, 10)` should return a value close to `5.0`. 4. `find_root(lambda x: x**2 + 1, -1, 1)` should raise `ValueError(\\"Function has the same signs at the endpoints\\")`. Constraints: * The input function `func` must be continuous in the interval `[a, b]`. * (a) and (b) must be such that (f(a)) and (f(b)) have opposite signs, i.e., (a) root lies between them. * Raise an appropriate `ValueError` if the signs of (f(a)) and (f(b)) are the same. * Ensure the root is found within a maximum number of iterations. Edge Cases: * The function (f) is not continuous within the interval. * The interval provided does not change signs, indicating no root within the interval. * The maximum number of iterations is reached before the desired tolerance is achieved.","solution":"from typing import Callable def find_root(func: Callable[[float], float], a: float, b: float, tol: float = 1e-7, max_iter: int = 1000) -> float: # Check if f(a) and f(b) have opposite signs fa = func(a) fb = func(b) if (fa > 0 and fb > 0) or (fa < 0 and fb < 0): raise ValueError(\\"Function has the same signs at the endpoints\\") iter_count = 0 while abs(b - a) > tol and iter_count < max_iter: c = (a + b) / 2 fc = func(c) if fc == 0: return c if (fa > 0 and fc < 0) or (fa < 0 and fc > 0): b = c fb = fc else: a = c fa = fc iter_count += 1 return (a + b) / 2"},{"question":"String Permutation Checker In the realm of text-based data processing and analysis, it is often necessary to determine whether two given strings are permutations of each other. In other words, you need to verify if one string can be rearranged to form the other. You are tasked with implementing a function that checks whether two given strings are permutations of one another. The function should ignore case and disregard any non-alphabetic characters. **Function Signature**: ```python def are_permutations(str1: str, str2: str) -> bool: ``` **Input**: * `str1`: (String) The first input string to be checked. * `str2`: (String) The second input string to be checked. **Output**: * A boolean value `True` if `str1` and `str2` are permutations of each other, otherwise `False`. **Constraints**: * 0 ≤ len(str1), len(str2) ≤ 1000 * The strings may contain any printable ASCII characters **Example**: ```python >>> are_permutations(\\"Listen!\\", \\"Silent\\") True >>> are_permutations(\\"Hello, World!\\", \\"World Hello!\\") True >>> are_permutations(\\"Hello\\", \\"Olehl\\") True >>> are_permutations(\\"Hello\\", \\"Ola\\") False ``` **Important Considerations**: * The function should ignore case by converting all characters to lowercase before processing. * All non-alphabetic characters should be disregarded (e.g., punctuation, spaces, numbers). * The implementation should be efficient and handle edge cases such as empty strings and fully non-alphabetic strings. Implement the `are_permutations` function: Good luck!","solution":"def are_permutations(str1: str, str2: str) -> bool: # Helper function to filter and lower case the string def filter_alpha_lower(s): return \'\'.join(c.lower() for c in s if c.isalpha()) # Filter strings to keep only alphabetic characters and convert to lowercase filtered_str1 = filter_alpha_lower(str1) filtered_str2 = filter_alpha_lower(str2) # Compare sorted versions of the filtered strings return sorted(filtered_str1) == sorted(filtered_str2)"},{"question":"# Sequence Compression You are given an array of integers representing a sequence. Your task is to compress the sequence by replacing consecutive occurrences of the same number with that number followed by the count of its occurrences. If a number appears only once, it should not be followed by its count. # Requirements 1. Implement a function `compress_sequence(sequence: list[int]) -> list[int]` that takes an array of integers and returns a compressed form of this sequence. 2. `sequence`: A list of integers representing the input sequence to be compressed. 3. The function should return the compressed sequence as a list of integers. # Constraints 1. The `sequence` list will contain at least one element. 2. The values in the `sequence` will be between -1000 and 1000, inclusive. # Example ```python sequence = [3, 3, 3, 1, 1, 2, 2, 2, 2, 4] compressed_sequence = compress_sequence(sequence) print(compressed_sequence) # Example Output: [3, 3, 1, 1, 2, 4, 4] ``` **Hint**: Traverse the input sequence and keep track of the current number and its count. Append the number and its count to the compressed sequence when a different number is encountered or the end of the array is reached.","solution":"def compress_sequence(sequence): Compress the sequence by replacing consecutive occurrences of the same number with that number followed by the count of its occurrences if greater than 1. Args: sequence (list of int): The input sequence to be compressed. Returns: list of int: The compressed sequence. if not sequence: # Handle edge case for empty input return [] compressed = [] current_num = sequence[0] count = 1 for num in sequence[1:]: if num == current_num: count += 1 else: compressed.append(current_num) if count > 1: compressed.append(count) current_num = num count = 1 # Add the last group compressed.append(current_num) if count > 1: compressed.append(count) return compressed"},{"question":"# Traffic Light Simulation Background You are tasked with creating a simple traffic light simulation program. A traffic light cycles through three stages: \\"Green\\", \\"Yellow\\", and \\"Red\\". Each stage lasts for a fixed number of seconds before transitioning to the next stage. The program should simulate the traffic light\'s state over a given period. # Problem Statement: Write a program that simulates the behavior of a traffic light over a specified number of seconds. The traffic light starts at the \\"Green\\" stage. Each stage has the following durations: - Green: 60 seconds - Yellow: 5 seconds - Red: 55 seconds Implement two functionalities: 1. `current_light_state(seconds: int) -> str`: Given an integer `seconds`, return the current state of the traffic light at that point in time. The return value should be one of the strings: \\"Green\\", \\"Yellow\\", or \\"Red\\". 2. `run_simulation(total_seconds: int) -> List[str]`: Given an integer `total_seconds`, return a list representing the traffic light\'s state at each second from `0` to `total_seconds-1`. # Implementation Details: * **Function Signatures**: - `def current_light_state(seconds: int) -> str:` - `def run_simulation(total_seconds: int) -> List[str]:` * **Input/Output**: - For `current_light_state(seconds)`, `seconds` is a non-negative integer representing the number of seconds elapsed since the start of the simulation. - For `run_simulation(total_seconds)`, `total_seconds` is a positive integer representing the total number of seconds to simulate. - The output for `current_light_state(seconds)` should be a single string, either \\"Green\\", \\"Yellow\\", or \\"Red\\". - The output for `run_simulation(total_seconds)` should be a list of strings where each string represents the traffic light\'s state at each second. # Example Usage: ```python assert current_light_state(0) == \\"Green\\" assert current_light_state(59) == \\"Green\\" assert current_light_state(60) == \\"Yellow\\" assert current_light_state(65) == \\"Red\\" assert current_light_state(120) == \\"Green\\" assert run_simulation(5) == [\\"Green\\", \\"Green\\", \\"Green\\", \\"Green\\", \\"Green\\"] assert run_simulation(65) == [\\"Green\\"] * 60 + [\\"Yellow\\"] * 5 assert run_simulation(121) == [\\"Green\\"] * 60 + [\\"Yellow\\"] * 5 + [\\"Red\\"] * 55 + [\\"Green\\"] ``` # Constraints: * Assume `seconds` and `total_seconds` will not exceed 10,000. * Optimize for clarity and simplicity in code.","solution":"def current_light_state(seconds: int) -> str: Returns the current state of the traffic light at the given time in seconds. # The total cycle time for Green, Yellow, and Red lights cycle_time = 60 + 5 + 55 # Calculate the position within one cycle cycle_position = seconds % cycle_time if cycle_position < 60: return \\"Green\\" elif cycle_position < 60 + 5: return \\"Yellow\\" else: return \\"Red\\" def run_simulation(total_seconds: int) -> list[str]: Simulates the traffic light for the provided total number of seconds and returns a list of states. states = [] for second in range(total_seconds): states.append(current_light_state(second)) return states"},{"question":"# Smallest Subarray with Greater Sum Scenario: Given an array of positive integers and a positive integer `S`, find the length of the smallest continuous subarray, the sum of which is greater than or equal to `S`. If no such subarray exists, return 0 instead. Task: Implement a function `smallest_subarray_with_given_sum(S: int, arr: list[int]) -> int` to find the length of the smallest subarray with a sum greater than or equal to `S`. Input: * An integer `S` which is the target sum. * A list of positive integers `arr`. Output: * An integer representing the length of the smallest subarray. If no such subarray exists, return 0. Constraints: * The elements in `arr` are positive integers. * The length of `arr` is at least 1. Performance Requirements: * The function should run in O(n) time complexity. Examples: ```python >>> smallest_subarray_with_given_sum(7, [2, 1, 5, 2, 3, 2]) 2 # The subarray [5, 2] has the smallest length with sum >= 7 >>> smallest_subarray_with_given_sum(7, [2, 1, 5, 2, 8]) 1 # The subarray [8] is the smallest in this case with sum >= 7 >>> smallest_subarray_with_given_sum(8, [3, 4, 1, 1, 6]) 3 # The subarray [3, 4, 1] or [4, 1, 1, 6] have the smallest length with sum >= 8 >>> smallest_subarray_with_given_sum(15, [1, 2, 3, 4, 5]) 5 # The entire array sum is exactly 15 >>> smallest_subarray_with_given_sum(100, [1, 2, 3, 4, 5]) 0 # No subarray has a sum of at least 100 ``` Use the sliding window technique to implement an efficient solution that adheres to the given constraints.","solution":"def smallest_subarray_with_given_sum(S, arr): Finds the length of the smallest subarray with the sum greater than or equal to S. window_sum = 0 min_length = float(\'inf\') left = 0 for right in range(len(arr)): window_sum += arr[right] while window_sum >= S: min_length = min(min_length, right - left + 1) window_sum -= arr[left] left += 1 return min_length if min_length != float(\'inf\') else 0"},{"question":"# Question: Breadth-First Search (BFS) Level Order Traversal Given a binary tree, implement the level order traversal of the tree using Breadth-First Search (BFS) algorithm and return the values of the nodes in each level as a list of lists. Function Signature: ```python def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: pass ``` Input: * `root`: The root node of the binary tree. Output: * A list of lists, where each inner list contains the node values at that particular level from left to right. Constraints: * The binary tree contains at most (10^5) nodes. * Node values are integers and can be positive, negative, or zero. * The tree can be any binary tree, including unbalanced trees. Example: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) print(level_order_traversal(root)) # Output: [[1], [2, 3], [4, 5, 6, 7]] ``` Implement the `level_order_traversal` function to perform the level order traversal on the given binary tree and return the node values level by level.","solution":"from typing import List, Optional import collections class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: if root is None: return [] result = [] queue = collections.deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"# Question: Implement a Custom Sorting Function You are required to implement a custom sorting function that sorts a list of tuples based on multiple attributes. The tuples contain three elements: a string representing the name, an integer representing the age, and a float representing the height. The sorting should be done in the following order: first by name in ascending order, then by age in descending order, and finally by height in ascending order. # Function Signature ```python def custom_sort(data: list) -> list: Arguments: data: A list of tuples, where each tuple contains a string (name), an integer (age), and a float (height). Returns: A list of tuples sorted based on the specified criteria. ``` # Expected Input and Output * **Input**: * `data`: A list of tuples where each tuple is of the form (name, age, height). * **Output**: * A list of tuples sorted first by name (ascending), then by age (descending), and finally by height (ascending). * **Constraints**: * Each tuple in the list will contain a name (non-empty string), age (positive integer), and height (positive float). # Example ```python >>> data = [(\\"Alice\\", 30, 5.5), (\\"Bob\\", 25, 6.0), (\\"Alice\\", 28, 5.4), (\\"Bob\\", 25, 5.8)] >>> custom_sort(data) [(\'Alice\', 30, 5.5), (\'Alice\', 28, 5.4), (\'Bob\', 25, 5.8), (\'Bob\', 25, 6.0)] ``` # Performance Your implementation should be able to handle inputs with sizes up to 10^5 efficiently. # Notes * Describe the algorithmic steps in your function. * Ensure your implementation correctly handles edge cases, such as duplicate names or ages, and adheres to input constraints.","solution":"def custom_sort(data: list) -> list: Sorts a list of tuples based on multiple attributes. Arguments: data: A list of tuples, where each tuple contains a string (name), an integer (age), and a float (height). Returns: A list of tuples sorted based on the specified criteria: - by name in ascending order - then by age in descending order - finally by height in ascending order return sorted(data, key=lambda x: (x[0], -x[1], x[2]))"},{"question":"# Maximal Product Subarray Context You are developing a financial data analysis tool that provides insights based on historical price movements. One challenging task is to identify the period during which the product of daily returns is maximized. Given an array of daily returns, you need to find the contiguous subarray (containing at least one number) which has the largest product. Objective Write a function `maximal_product_subarray(arr: List[float]) -> float` that computes the maximal product of a contiguous subarray. Input * `arr`: A list of floats where each element represents the daily return. The list will have at least one element and no more than 10,000 elements. Output * Returns a float representing the maximal product of a contiguous subarray. Constraints * The array will contain both positive and negative numbers. * The array will have a minimum length of 1 and a maximum length of 10,000. * The maximal product will be no smaller than -10^8 and no larger than 10^8. Example ```python def maximal_product_subarray(arr: List[float]) -> float: # Your code here # Example usage: arr = [2.5, -3.0, 4.0, -1.0] print(maximal_product_subarray(arr)) # Output: 30.0 ``` Explanation For the given example, the subarray with the maximum product is [2.5, -3.0, 4.0], which results in the product 2.5 * -3.0 * 4.0 = -30.0. However, considering the entire array [2.5, -3.0, 4.0, -1.0] results in the product 30. This returns the maximum product subarray as 30.","solution":"from typing import List def maximal_product_subarray(arr: List[float]) -> float: if not arr: return 0 max_product = min_product = result = arr[0] for num in arr[1:]: if num < 0: max_product, min_product = min_product, max_product max_product = max(num, max_product * num) min_product = min(num, min_product * num) result = max(result, max_product) return result"},{"question":"# Implement a Custom Sorting Algorithm and Measure Performance In this coding problem, you will implement a custom sorting algorithm to sort a given list of integers and compare its performance with Python\'s built-in Timsort algorithm. Problem Description You are given a list of integers and are required to implement a custom merge sort algorithm to sort the list. You must then compare the performance (in terms of execution time) of your custom sort with Python\'s built-in Timsort (the sorting algorithm used by Python\'s `sorted()` function and list\'s `.sort()` method). Functions to Implement 1. **`merge_sort`**: ```python def merge_sort(lst: List[int]) -> List[int]: ``` - **Input Parameters**: - `lst`: A list of integers to be sorted. - **Output**: - Returns a new list of integers sorted in non-decreasing order. 2. **`compare_sorting_algorithms`**: ```python def compare_sorting_algorithms(lst: List[int]) -> Tuple[float, float]: ``` - **Input Parameters**: - `lst`: A list of integers to be sorted. - **Output**: - Returns a tuple containing two float values: the time taken by your custom `merge_sort` and the time taken by Python\'s built-in Timsort. Constraints - You need to sort the list in non-decreasing order. - The input list `lst` can have up to 100,000 integers. - You may assume that the integers in the list will fit within the standard integer range. Example Usage 1. Sorting a list using custom merge sort: ```python sorted_list = merge_sort([4, 3, 5, 1, 2]) print(sorted_list) # Should output [1, 2, 3, 4, 5] ``` 2. Comparing performance: ```python import random lst = random.sample(range(1000000), 1000) # A random list of 1000 unique integers custom_time, timsort_time = compare_sorting_algorithms(lst) print(f\\"Custom Merge Sort Time: {custom_time} seconds\\") print(f\\"Timsort Time: {timsort_time} seconds\\") ``` Implementation Details 1. **Merge Sort**: - Implement the classic merge sort algorithm which recursively divides the list into halves and then merges them back in sorted order. 2. **Performance Measurement**: - Use the Python `time` module to measure the execution time of sorting algorithms. Measure the time taken for your custom merge sort and Python\'s built-in Timsort using `sorted()` and return the results in seconds. Your task is to implement the provided function signatures correctly and provide a complete solution to the problem described above.","solution":"from typing import List, Tuple import time def merge_sort(lst: List[int]) -> List[int]: if len(lst) <= 1: return lst mid = len(lst) // 2 left = merge_sort(lst[:mid]) right = merge_sort(lst[mid:]) return merge(left, right) def merge(left: List[int], right: List[int]) -> List[int]: merged = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] < right[right_index]: merged.append(left[left_index]) left_index += 1 else: merged.append(right[right_index]) right_index += 1 merged.extend(left[left_index:]) merged.extend(right[right_index:]) return merged def compare_sorting_algorithms(lst: List[int]) -> Tuple[float, float]: lst_copy = lst.copy() start_time = time.time() merge_sort(lst_copy) custom_sort_duration = time.time() - start_time start_time = time.time() sorted(lst) timsort_duration = time.time() - start_time return custom_sort_duration, timsort_duration"},{"question":"Problem Statement You are required to write a function that checks if a given integer array can represent the preorder traversal of a Binary Search Tree (BST). # Function Signature ```python def is_preorder_traversal_bst(arr: List[int]) -> bool: pass ``` # Input - A list of integers `arr` (0 ≤ len(arr) ≤ 10^4) representing the preorder traversal sequence of a binary tree. # Output - Returns `True` if the given list can represent the preorder traversal of a BST, otherwise return `False`. # Constraints - The function should handle edge cases where the list is empty or has only one element. # Example ```python >>> is_preorder_traversal_bst([5, 2, 1, 3, 6]) True >>> is_preorder_traversal_bst([5, 2, 6, 1, 3]) False >>> is_preorder_traversal_bst([]) True >>> is_preorder_traversal_bst([1]) True ``` # Notes - A given list represents the preorder traversal of a BST if, for every node, all the elements to the right which are smaller are part of the left subtree and elements greater are part of the right subtree. - Pay special attention to scenarios with edge cases including but not limited to empty lists and single-element lists. - Consider an optimal approach that uses stack data structures to verify the validity of the preorder traversal.","solution":"from typing import List def is_preorder_traversal_bst(arr: List[int]) -> bool: Check if the given list can represent the preorder traversal of a BST. if not arr: return True stack = [] root = float(\'-inf\') for value in arr: if value < root: return False while stack and stack[-1] < value: root = stack.pop() stack.append(value) return True"},{"question":"# Problem Statement: You are required to implement a function that determines the longest path in a binary tree. The path may or may not pass through the root node, and it may span any two nodes in the tree. # Function Signature: ```python def longest_path(root: \'Optional[TreeNode]\') -> int: pass ``` # Input: - `root`: The root node of the binary tree. A `TreeNode` is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` - Each node\'s value (`val`) will be an integer. # Output: - Returns an integer representing the length (number of edges) of the longest path in the binary tree. # Constraints: - The number of nodes in the tree is in the range `[1, 10^4]`. - The value of each node is a unique integer. # Example: ```plaintext root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) longest_path(root) # Output: 3 ``` # Explanation: The longest path is from node 4 -> 2 -> 5 (3 edges). # Other Considerations: - Handle basic edge cases, such as a single node (length of the path is 0). - Consider the tree structure and how the longest path can span across different sub-trees.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_path(root): def helper(node): nonlocal max_len if not node: return 0 left_depth = helper(node.left) right_depth = helper(node.right) # The potential longest path at this node max_len = max(max_len, left_depth + right_depth) # Return the depth of this node return 1 + max(left_depth, right_depth) max_len = 0 helper(root) return max_len"},{"question":"# Prime Number Retrieval Challenge Problem Statement You are tasked with implementing a function to find and return all prime numbers less than a given integer ( n ). Your implementation should ensure efficient computation and handle large values of ( n ) effectively. Function Specifications ```python def is_prime(num: int) -> bool: Determines if a given integer is a prime number. :param num: An integer to check for primality :return: True if the number is prime, otherwise False # To be implemented by the student pass def get_primes_less_than(n: int) -> list: Returns a list of all prime numbers less than the given integer n. :param n: An integer specifying the upper limit for prime number retrieval :return: A list of prime numbers less than n pass # To be implemented by the student ``` Input and Output * **Input**: An integer ( n ) where ( n > 1 ). * **Output**: A list of integers representing all prime numbers less than ( n ). Constraints * The integer ( n ) is greater than 1. * The function should efficiently handle values of ( n ) up to ( 10^6 ). Example ```python >>> get_primes_less_than(10) [2, 3, 5, 7] >>> get_primes_less_than(20) [2, 3, 5, 7, 11, 13, 17, 19] ``` Edge Cases 1. Small values of ( n ) such as 2 or 3. 2. High values of ( n ) up to ( 10^6 ) to test computational efficiency. 3. Validations for non-integer or invalid inputs. Notes 1. Ensure your program handles edge cases gracefully and avoids performance bottlenecks. 2. Consider using efficient primality test algorithms to achieve best performance. 3. Provide appropriate exception handling to manage invalid inputs and other anomalies.","solution":"def is_prime(num: int) -> bool: Determines if a given integer is a prime number. :param num: An integer to check for primality :return: True if the number is prime, otherwise False if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def get_primes_less_than(n: int) -> list: Returns a list of all prime numbers less than the given integer n. :param n: An integer specifying the upper limit for prime number retrieval :return: A list of prime numbers less than n primes = [] for i in range(2, n): if is_prime(i): primes.append(i) return primes"},{"question":"# Problem: Rotational Cipher Implementation You are tasked with implementing a rotational cipher, also known as the Caesar cipher, which encrypts a given string by rotating its characters. The rotation value `n` will determine how many positions each character in the string should be shifted. Implement a class `RotationalCipher` that includes a method `encrypt` which performs the encryption based on the specified rotation value. Ensure the method handles incorrect inputs gracefully and operates within acceptable ciphertext constraints. # Class Definition ```python class RotationalCipher: def __init__(self, n: int): # Your code here def encrypt(self, text: str) -> str: # Your implementation here ``` # Method Specification The `encrypt` method should: - **Constructor Input**: An integer `n` where `0 <= n <= 25`. - **Input**: A string `text` containing upper and lower case letters and spaces only. - **Output**: The encrypted string. # Constraints - The method should handle non-integer rotation values and negative rotation values by raising a ValueError with an appropriate message. - The `encrypt` method should handle non-string inputs by raising a ValueError with an appropriate message. # Example ```python cipher = RotationalCipher(4) print(cipher.encrypt(\\"Hello World\\")) # Output: \\"Lipps Asvph\\" print(cipher.encrypt(\\"ABC xyz\\")) # Output: \\"EFG bcd\\" # Handling incorrect inputs try: cipher = RotationalCipher(\'five\') except ValueError as e: print(e) # Output: \\"Rotation value should be an integer between 0 and 25.\\" try: cipher.encrypt(12345) except ValueError as e: print(e) # Output: \\"Text to encrypt should be a string.\\" ``` # Additional Requirements - Include proper error handling for edge cases. - Ensure that the method correctly encrypts both upper and lower case letters while leaving spaces unchanged.","solution":"class RotationalCipher: def __init__(self, n: int): if not isinstance(n, int) or n < 0 or n > 25: raise ValueError(\\"Rotation value should be an integer between 0 and 25.\\") self.n = n def encrypt(self, text: str) -> str: if not isinstance(text, str): raise ValueError(\\"Text to encrypt should be a string.\\") encrypted_text = [] for char in text: if \'a\' <= char <= \'z\': new_char = chr((ord(char) - ord(\'a\') + self.n) % 26 + ord(\'a\')) elif \'A\' <= char <= \'Z\': new_char = chr((ord(char) - ord(\'A\') + self.n) % 26 + ord(\'A\')) else: new_char = char encrypted_text.append(new_char) return \'\'.join(encrypted_text)"},{"question":"# Binary Search Tree Node Insertion You are given a class `BinarySearchTree` which represents a Binary Search Tree (BST). Your task is to enhance the functionality of this class by implementing a method that inserts a new integer to the tree while maintaining the BST property. Method to Implement ```python class BinarySearchTree: class Node: def __init__(self, value): self.value = value self.left = None self.right = None def __init__(self): self.root = None def insert(self, value: int) -> None: pass ``` # Input You do not need to modify the constructor or any existing methods of the `BinarySearchTree` class. You must implement the `insert` method which takes an integer `value` as input. # Output The method does not return anything. It inserts the given value into the BST while maintaining the BST properties. # Example ```python bst = BinarySearchTree() bst.insert(10) bst.insert(5) bst.insert(20) bst.insert(15) # The BST now looks like this: # 10 # / # 5 20 # / # 15 ``` # Constraints * The number of insertions will be at most `10^4`. * All inserted values will be unique integers in the range `[-10^5, 10^5]`. # Note 1. Ensure that your insertion algorithm maintains the properties of the binary search tree. 2. Consider edge cases, such as inserting into an empty tree or inserting values that require balancing the tree structure.","solution":"class BinarySearchTree: class Node: def __init__(self, value): self.value = value self.left = None self.right = None def __init__(self): self.root = None def insert(self, value: int) -> None: if self.root is None: self.root = self.Node(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node, value): if value < node.value: if node.left is None: node.left = self.Node(value) else: self._insert_recursive(node.left, value) elif value > node.value: if node.right is None: node.right = self.Node(value) else: self._insert_recursive(node.right, value) def _in_order_traversal(self, node, values): if node: self._in_order_traversal(node.left, values) values.append(node.value) self._in_order_traversal(node.right, values) def to_list(self): values = [] self._in_order_traversal(self.root, values) return values"},{"question":"# Question: Implement a Function to Normalize Text and Count Unique Words Context: As part of a text analysis tool, you need to implement a function to normalize a given text and count the unique words. The function should convert the text to lowercase, remove punctuation, and then count the occurrences of each unique word. # Function Signature ```python def normalize_and_count(text: str) -> dict: pass ``` # Requirements 1. **Input**: A single string (`text`) representing the text to be analyzed. 2. **Output**: A dictionary where the keys are unique words (in lowercase and without punctuation), and the values are the counts of these words in the text. 3. **Constraints**: - The input text must be a non-null string. - Punctuation marks to be removed include: `.,!?;:()[]{}\\"` # Error Handling 1. If the input `text` is not a string, raise a `TypeError` with the message \\"Expected a string as input\\". 2. If the input `text` is None, raise a `ValueError` with the message \\"Missing input text\\". # Examples ```python >>> normalize_and_count(\\"Hello, World!\\") {\'hello\': 1, \'world\': 1} >>> normalize_and_count(\\"Python is great. Python is fun!\\") {\'python\': 2, \'is\': 2, \'great\': 1, \'fun\': 1} >>> normalize_and_count(\\"Text, text: TEXT!\\") {\'text\': 3} >>> normalize_and_count(\\"\\") {} >>> normalize_and_count(None) Traceback (most recent call last): ... ValueError: Missing input text >>> normalize_and_count(123) Traceback (most recent call last): ... TypeError: Expected a string as input ``` # Additional Notes - The text normalization should be done in a case-insensitive manner. - Make sure to thoroughly test the function with various edge cases, such as text with mixed case, different punctuation marks, and empty strings.","solution":"import string def normalize_and_count(text: str) -> dict: if text is None: raise ValueError(\\"Missing input text\\") if not isinstance(text, str): raise TypeError(\\"Expected a string as input\\") # Convert text to lowercase text = text.lower() # Remove punctuation text = text.translate(str.maketrans(\'\', \'\', string.punctuation)) # Split text into words words = text.split() # Count occurrences of each unique word word_count = {} for word in words: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 return word_count"},{"question":"# Coding Assessment Question You are a software engineer developing a ticket reservation system for a theater. The theater has multiple rows of seats, and patrons should be seated such that they leave at least one empty seat between each other to adhere to social distancing guidelines. # Problem Statement Implement a function `seat_allocation` that takes in a list of seat preferences for each patron and a number of rows with a fixed number of seats in each row, and allocates the seats according to the preferences while maintaining social distancing. # Function Signature ```python def seat_allocation(preferences: list[list[int]], rows: int, seats_per_row: int) -> list[list[int]]: pass ``` # Input * `preferences`: A list of lists where each sub-list represents the preferred seats of a patron in the following format: `[row, seat]`. * `rows`: An integer representing the number of rows in the theater. * `seats_per_row`: An integer representing the number of seats in each row of the theater. # Output * A list of lists representing the final seating arrangement where `1` represents a taken seat and `0` represents an empty seat. # Constraints * `1 <= rows <= 50` * `1 <= seats_per_row <= 50` * Each patron list contains pairs of `[row, seat]` values, where `0 <= row < rows` and `0 <= seat < seats_per_row`. # Examples ```python preferences1 = [ [0, 0], [0, 2], [1, 1], [1, 3], [2, 0], [2, 2] ] rows1 = 3 seats_per_row1 = 4 assert seat_allocation(preferences1, rows1, seats_per_row1) == [ [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0] ] preferences2 = [ [0, 0], [0, 1], [0, 4], [1, 0], [1, 5] ] rows2 = 2 seats_per_row2 = 6 assert seat_allocation(preferences2, rows2, seats_per_row2) == [ [1, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 1] ] ``` # Notes * Patrons should be seated in the order that their preferences are received. * If a patron\'s preferred seat is already taken or cannot be allocated due to social distancing, skip that preference. The above examples show successful seating plans adhering to social distancing guidelines.","solution":"def seat_allocation(preferences: list[list[int]], rows: int, seats_per_row: int) -> list[list[int]]: seating_arrangement = [[0] * seats_per_row for _ in range(rows)] for pref in preferences: row, seat = pref if seating_arrangement[row][seat] == 0: left_check = (seat == 0) or (seating_arrangement[row][seat-1] == 0) right_check = (seat == seats_per_row-1) or (seating_arrangement[row][seat+1] == 0) if left_check and right_check: seating_arrangement[row][seat] = 1 return seating_arrangement"},{"question":"# Context You are developing a task management system where tasks need to be organized based on their priority. Each task is represented by an object containing its name and priority level. You want to implement a function to sort these tasks in descending order of priority. # Task Implement a function `sort_tasks(tasks: list) -> list` that sorts the tasks based on their priority in descending order. If two tasks have the same priority, they should be sorted by their name in ascending order. # Input and Output * **Input**: * `tasks` (list): A list of dictionaries where each dictionary represents a task with the following structure: - `name` (str): The name of the task. - `priority` (int): The priority level of the task. * **Output**: * A list of tasks sorted by priority in descending order. If two tasks have the same priority, they should be sorted by their name in ascending order. # Constraints * The priority level will be a non-negative integer. * Task names will be unique and will contain only alphanumeric characters. # Example ```python tasks = [ {\\"name\\": \\"Task1\\", \\"priority\\": 2}, {\\"name\\": \\"Task2\\", \\"priority\\": 1}, {\\"name\\": \\"Task3\\", \\"priority\\": 3}, {\\"name\\": \\"Task4\\", \\"priority\\": 2} ] print(sort_tasks(tasks)) # Expected Output: # [ # {\\"name\\": \\"Task3\\", \\"priority\\": 3}, # {\\"name\\": \\"Task1\\", \\"priority\\": 2}, # {\\"name\\": \\"Task4\\", \\"priority\\": 2}, # {\\"name\\": \\"Task2\\", \\"priority\\": 1} # ] tasks = [ {\\"name\\": \\"Clean\\", \\"priority\\": 2}, {\\"name\\": \\"Cook\\", \\"priority\\": 2}, {\\"name\\": \\"Wash\\", \\"priority\\": 1} ] print(sort_tasks(tasks)) # Expected Output: # [ # {\\"name\\": \\"Clean\\", \\"priority\\": 2}, # {\\"name\\": \\"Cook\\", \\"priority\\": 2}, # {\\"name\\": \\"Wash\\", \\"priority\\": 1} # ] ``` # Performance Requirements The function should be designed to handle up to 10,000 tasks efficiently. # Note You do not need to handle input validation. Assume all input provided will be valid according to the constraints.","solution":"def sort_tasks(tasks): Sort the given list of tasks by priority in descending order. If two tasks have the same priority, sort by their name in ascending order. Args: tasks (list): List of dictionaries where each dictionary represents a task with \'name\' and \'priority\'. Returns: list: Sorted list of tasks. return sorted(tasks, key=lambda x: (-x[\'priority\'], x[\'name\']))"},{"question":"# Sum of Distinct Powers Problem Statement Given a number `n`, your task is to determine the smallest set of distinct integer powers that sum up to `n`. Task Write a function `sum_of_distinct_powers` that returns a list of integers such that each integer in the list represents a power of 2 (i.e., a number of the form 2^i) and their sum equals `n`. # Function Signature ```python def sum_of_distinct_powers(n: int) -> List[int]: ``` Parameters - `n` (int): The target sum (1 ≤ n ≤ 10^9). Returns - `List[int]`: A list of integers representing powers of 2 that sum up to `n`, sorted in ascending order. Example ```python assert sum_of_distinct_powers(13) == [1, 4, 8] assert sum_of_distinct_powers(23) == [1, 2, 4, 16] assert sum_of_distinct_powers(31) == [1, 2, 4, 8, 16] ``` Constraints - The sum of the numbers in the output list must be exactly `n`. - Each number in the list must be a power of 2. - The numbers in the list should be in ascending order. Scenario You are implementing a feature in a utility optimizer application where certain tasks need to be decomposed into a set of activities that operate at distinct power levels for efficiency. To achieve this, you need to break down a given power requirement into distinct smaller power levels that sum up to the requested power while ensuring no two tasks operate at the same power level simultaneously.","solution":"from typing import List def sum_of_distinct_powers(n: int) -> List[int]: Returns a list of distinct powers of 2 that sum up to n. powers = [] power = 1 while n > 0: if n & 1: powers.append(power) power <<= 1 n >>= 1 return powers"},{"question":"You are given a string representing an arithmetic expression containing integers, addition (`+`), subtraction (`-`), multiplication (`*`), and division (`/`). The expression may contain parentheses to denote precedence. Calculate the result of the expression following the standard operator precedence and associativity rules. Write a function `evaluate_expression` to find the result. # Function Signature ```python def evaluate_expression(expression: str) -> int: pass ``` # Input - A single string `expression` containing up to 10^5 characters. The expression may contain spaces. # Output - Return an integer representing the result of evaluating the arithmetic expression. # Constraints - The input will be a valid arithmetic expression. - Division by zero will not occur in the input expression. - The result of the expression will fit within the bounds of a 32-bit signed integer. # Example ```python assert evaluate_expression(\\"3+2*2\\") == 7 assert evaluate_expression(\\" 3/2 \\") == 1 assert evaluate_expression(\\"(2-1)*3\\") == 3 assert evaluate_expression(\\"2 + 3 * 4 - 5 / 5 + 1\\") == 14 print(\\"All test cases passed\\") ``` # Edge Cases to Consider - Empty string or string with only spaces. - Expressions with minimal length (e.g., just one number). - Expressions with nested parentheses. - Spaces in various places within the expression. # Scenario Your team is working on a new scientific calculator application. As part of the core functionality, you need to accurately evaluate user-provided arithmetic expressions. Handling operator precedence and respecting parentheses are crucial to ensuring the correct result calculation.","solution":"def evaluate_expression(expression: str) -> int: Evaluates a given arithmetic expression while considering operator precedence and parentheses. def precedence(op): if op == \'+\' or op == \'-\': return 1 if op == \'*\' or op == \'/\': return 2 return 0 def apply_operator(operands, operator): rhs = operands.pop() lhs = operands.pop() if operator == \'+\': operands.append(lhs + rhs) elif operator == \'-\': operands.append(lhs - rhs) elif operator == \'*\': operands.append(lhs * rhs) elif operator == \'/\': operands.append(int(lhs / rhs)) def evaluate(tokens): operands = [] operators = [] i = 0 while i < len(tokens): if tokens[i] == \' \': i += 1 continue if tokens[i] == \'(\': operators.append(tokens[i]) elif tokens[i].isdigit(): val = 0 while (i < len(tokens) and tokens[i].isdigit()): val = val * 10 + int(tokens[i]) i += 1 operands.append(val) i -= 1 elif tokens[i] == \')\': while len(operators) != 0 and operators[-1] != \'(\': apply_operator(operands, operators.pop()) operators.pop() else: while (len(operators) != 0 and precedence(operators[-1]) >= precedence(tokens[i])): apply_operator(operands, operators.pop()) operators.append(tokens[i]) i += 1 while len(operators) != 0: apply_operator(operands, operators.pop()) return operands[-1] return evaluate(expression)"},{"question":"# Problem Statement Given a 2D matrix where each cell is labeled as either \'1\' (representing land) or \'0\' (representing water), your task is to calculate the number of distinct islands in the matrix. An island is defined as a group of \'1\'s connected horizontally or vertically (not diagonally), and is completely surrounded by \'0\'s. Write a function `num_islands(grid: List[List[str]]) -> int` to count the number of islands in the given matrix. Input * A 2D matrix `grid` with dimensions `m x n` (1 ≤ m, n ≤ 300), where each element is \'1\' or \'0\'. Output * An integer representing the number of distinct islands in the matrix. Example ``` Input: grid = [ [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"1\\", \\"1\\"] ] Output: 3 ``` In this example: - There are 3 distinct islands. - The first island is formed by the first two rows of \'1\'s in the first two columns. - The second island is a single \'1\' in the third row and third column. - The third island consists of two connected \'1\'s in the fourth row. Constraints * You must achieve a time complexity of `O(m * n)`. * Use of depth-first search (DFS) or breadth-first search (BFS) is allowed. * Assume that all four sides of the matrix are surrounded by water. Implement the function `num_islands(grid: List[List[str]]) -> int` that adheres to these requirements.","solution":"from typing import List def num_islands(grid: List[List[str]]) -> int: if not grid: return 0 def dfs(r, c): if r < 0 or c < 0 or r >= len(grid) or c >= len(grid[0]) or grid[r][c] == \'0\': return grid[r][c] = \'0\' # Mark the cell as visited by sinking the island to water. # Call DFS recursively for all the four adjacent cells. dfs(r + 1, c) dfs(r - 1, c) dfs(r, c + 1) dfs(r, c - 1) num_of_islands = 0 for row in range(len(grid)): for col in range(len(grid[0])): if grid[row][col] == \'1\': # Start a DFS from this cell num_of_islands += 1 dfs(row, col) return num_of_islands"},{"question":"# Task: Your task is to implement a function that finds the shortest path in a weighted, directed graph from a given start node to a given end node. If there is no path between the nodes, the function should return -1. # Function Signature: ```python def shortest_path(graph: Dict[int, List[Tuple[int, int]]], start: int, end: int) -> int: pass ``` # Input: - `graph` (Dict[int, List[Tuple[int, int]]]): A dictionary representing the graph where keys are node integers, and values are lists of tuples (neighbor, weight) indicating directed edges and their weights. - `start` (int): The start node. - `end` (int): The end node. # Output: - An integer representing the shortest path distance from the start node to the end node, or -1 if no path exists. # Sample Usage: ```python graph = { 0: [(1, 4), (2, 3)], 1: [(3, 2)], 2: [(1, 1)], 3: [] } print(shortest_path(graph, 0, 3)) # Prints: 6 print(shortest_path(graph, 0, 2)) # Prints: 3 print(shortest_path(graph, 0, 4)) # Prints: -1 ``` # Constraints: - The graph contains between 1 and 10,000 nodes. - Each weight is a positive integer. - The graph may not be connected. # Implementation Tips: - Use Dijkstra\'s algorithm to efficiently find the shortest path. - Use a priority queue (heap) to keep track of the minimum distance nodes. - Keep track of visited nodes to avoid cycles. - Handle edge cases where the start or end nodes are not present in the graph.","solution":"import heapq from typing import Dict, List, Tuple def shortest_path(graph: Dict[int, List[Tuple[int, int]]], start: int, end: int) -> int: Finds the shortest path in a weighted directed graph from start node to end node. If there is no path between the nodes, the function returns -1. # Priority queue to keep track of the minimum distance nodes pq = [(0, start)] # Dictionary to keep track of the minimum distance to each node distances = {start: 0} while pq: current_distance, current_node = heapq.heappop(pq) # If we reached the end node, return its distance if current_node == end: return current_distance # Process each neighbor of the current node for neighbor, weight in graph.get(current_node, []): distance = current_distance + weight # Only consider this new path if it is better if distance < distances.get(neighbor, float(\'inf\')): distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) # If we finished processing the priority queue without finding the end node return -1"},{"question":"# Question You are given a 2D matrix representing an image, where each value in the matrix is an integer representing pixel intensity. Your task is to implement an algorithm to rotate the image 90 degrees clockwise. Use the guidelines below to implement your solution. Function Signature ```python def rotate_image(matrix: list[list[int]]) -> list[list[int]]: pass ``` Input * matrix: a list of lists of integers, where 0 ≤ len(matrix) ≤ 1000 and 0 ≤ len(matrix[i]) ≤ 1000 for all valid i. It is guaranteed that the matrix is square (i.e., len(matrix) == len(matrix[i])). Output * A list of lists of integers representing the rotated image. Constraints * You must implement an in-place algorithm for rotating the matrix 90 degrees clockwise. * The algorithm must have O(1) auxiliary space usage, not counting the input matrix. Example ```python assert rotate_image([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotate_image([ [1] ]) == [ [1] ] assert rotate_image([ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ]) == [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] ``` Explanation In this task, you are required to rotate the given n x n matrix 90 degrees clockwise in-place. Ensure your code handles edge cases like a 1x1 matrix and larger matrices correctly.","solution":"def rotate_image(matrix: list[list[int]]) -> list[list[int]]: Rotate the given n x n matrix 90 degrees clockwise in-place. if not matrix or not matrix[0]: return matrix n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"# Problem Description You have been assigned to create a simple In-Memory Key-Value Store that supports basic operations such as setting a key-value pair, retrieving the value of a key, and deleting a key from the store. # Requirements - Implement a Key-Value Store class that supports operations: `set(key, value)`, `get(key)`, and `delete(key)`. - Ensure that the Key-Value Store can handle multiple types of keys and values, including integers and strings. - Implement error handling for operations involving non-existent keys. # Constraints - Keys will be either integers or strings. - Values will be either integers or strings. - The store can handle up to 10<sup>4</sup> unique keys. # Input The input will be a sequence of commands in the form of a list of tuples. Each tuple represents an operation with its arguments: - **Set operation**: `(\\"set\\", key, value)` -- sets the key to the specified value. - **Get operation**: `(\\"get\\", key)` -- retrieves the value for the specified key. - **Delete operation**: `(\\"delete\\", key)` -- removes the key from the store. For example: ``` [ (\\"set\\", 1, \\"a\\"), (\\"set\\", \\"b\\", 2), (\\"get\\", 1), (\\"delete\\", \\"b\\"), (\\"get\\", \\"b\\") ] ``` # Output The output should be a list of results for the \\"get\\" operations, maintaining the order as they appear in the input. If a \\"get\\" operation requests a value for a non-existent key, the result should be `None`. For example: ``` [\\"a\\", None] ``` # Example Given the input sequence of commands: ``` [ (\\"set\\", 1, \\"a\\"), (\\"set\\", \\"b\\", 2), (\\"get\\", 1), (\\"delete\\", \\"b\\"), (\\"get\\", \\"b\\") ] ``` The output will be: ``` [\\"a\\", None] ``` # Implementation Details 1. **KeyValueStore Class**: - Implement methods: `set`, `get`, and `delete`. # Code Template ```python from typing import Any, List, Tuple class KeyValueStore: def __init__(self): self.store = {} def set(self, key: Any, value: Any) -> None: self.store[key] = value def get(self, key: Any) -> Any: return self.store.get(key) def delete(self, key: Any) -> None: if key in self.store: del self.store[key] def execute_commands(commands: List[Tuple[str, Any, Any]]) -> List[Any]: kv_store = KeyValueStore() results = [] for command in commands: if command[0] == \\"set\\": kv_store.set(command[1], command[2]) elif command[0] == \\"get\\": results.append(kv_store.get(command[1])) elif command[0] == \\"delete\\": kv_store.delete(command[1]) return results # Example usage: # commands = [(\\"set\\", 1, \\"a\\"), (\\"set\\", \\"b\\", 2), (\\"get\\", 1), (\\"delete\\", \\"b\\"), (\\"get\\", \\"b\\")] # output = execute_commands(commands) # Output: [\\"a\\", None] ``` Now you have a problem description for constructing an In-Memory Key-Value Store with basic operations, and the implementation is specified along the lines of the existing question set.","solution":"from typing import Any, List, Tuple class KeyValueStore: def __init__(self): self.store = {} def set(self, key: Any, value: Any) -> None: self.store[key] = value def get(self, key: Any) -> Any: return self.store.get(key) def delete(self, key: Any) -> None: if key in self.store: del self.store[key] def execute_commands(commands: List[Tuple[str, Any, Any]]) -> List[Any]: kv_store = KeyValueStore() results = [] for command in commands: if command[0] == \\"set\\": kv_store.set(command[1], command[2]) elif command[0] == \\"get\\": results.append(kv_store.get(command[1])) elif command[0] == \\"delete\\": kv_store.delete(command[1]) return results"},{"question":"# Problem Statement: You are given a binary search tree (BST) implementation, and you need to extend the BST class with the following functionalities: 1. **is_balanced()**: Implement a method to check whether the BST is balanced. A BST is balanced if the height difference between the left and right subtrees of any node is at most 1. The method should return `True` if the BST is balanced and `False` otherwise. 2. **find_lca(n1, n2)**: Implement a method to find the Lowest Common Ancestor (LCA) of two given nodes in the BST. The LCA of two nodes `n1` and `n2` is the lowest node in the BST that has both `n1` and `n2` as descendants (where we allow a node to be a descendant of itself). If either of the nodes does not exist in the BST, return `-1`. # Expected Input and Output Formats: * For `is_balanced()`: The method returns either `True` or `False`. * For `find_lca(n1, n2)`: * **Input**: * `n1` (int): The first node\'s value. * `n2` (int): The second node\'s value. * **Output**: * Returns the value of the LCA node. If the LCA does not exist, return `-1`. # Constraints: 1. The values for the nodes in the BST are unique. 2. The number of nodes in the BST can be up to `N = 10^4`. # Example: ```python bst = BST() bst.insert(20) bst.insert(10) bst.insert(30) bst.insert(5) bst.insert(15) bst.insert(25) bst.insert(35) print(bst.is_balanced()) # True print(bst.find_lca(5, 15)) # 10 print(bst.find_lca(5, 40)) # -1 (since 40 does not exist in the tree) ``` # Solution Template: You may start with the provided code snippet and extend the class as described in the task. ```python class Node: def __init__(self, key): self.data = key self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, key): if not self.root: self.root = Node(key) else: self._insert_rec(self.root, key) def _insert_rec(self, root, key): if key < root.data: if root.left is None: root.left = Node(key) else: self._insert_rec(root.left, key) else: if root.right is None: root.right = Node(key) else: self._insert_rec(root.right, key) def is_balanced(self): # Implement the method to check if the BST is balanced pass def find_lca(self, n1, n2): # Implement the method to find the LCA of two given nodes pass def _is_balanced_helper(self, node): if node is None: return 0, True left_height, left_balanced = self._is_balanced_helper(node.left) right_height, right_balanced = self._is_balanced_helper(node.right) height = max(left_height, right_height) + 1 balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return height, balanced def is_balanced(self): _, balanced = self._is_balanced_helper(self.root) return balanced def _find_lca_helper(self, node, n1, n2): if not node: return None if node.data > n1 and node.data > n2: return self._find_lca_helper(node.left, n1, n2) if node.data < n1 and node.data < n2: return self._find_lca_helper(node.right, n1, n2) return node def find_lca(self, n1, n2): node1 = self._find_node(self.root, n1) node2 = self._find_node(self.root, n2) if node1 and node2: lca = self._find_lca_helper(self.root, n1, n2) return lca.data if lca else -1 return -1 def _find_node(self, root, key): if root is None or root.data == key: return root if key < root.data: return self._find_node(root.left, key) return self._find_node(root.right, key) # You can run your tests here bst = BST() bst.insert(20) bst.insert(10) bst.insert(30) bst.insert(5) bst.insert(15) bst.insert(25) bst.insert(35) print(bst.is_balanced()) # Expected: True print(bst.find_lca(5, 15)) # Expected: 10 print(bst.find_lca(5, 40)) # Expected: -1 ``` This new question introduces problems related to balanced binary trees and finding the Lowest Common Ancestor (LCA), which complement the original set\'s focus on graph functionality. It maintains a consistent style, complexity, and scope similar to the existing question.","solution":"class Node: def __init__(self, key): self.data = key self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, key): if not self.root: self.root = Node(key) else: self._insert_rec(self.root, key) def _insert_rec(self, root, key): if key < root.data: if root.left is None: root.left = Node(key) else: self._insert_rec(root.left, key) else: if root.right is None: root.right = Node(key) else: self._insert_rec(root.right, key) def _is_balanced_helper(self, node): if node is None: return 0, True left_height, left_balanced = self._is_balanced_helper(node.left) right_height, right_balanced = self._is_balanced_helper(node.right) height = max(left_height, right_height) + 1 balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return height, balanced def is_balanced(self): _, balanced = self._is_balanced_helper(self.root) return balanced def _find_lca_helper(self, node, n1, n2): if not node: return None if node.data > n1 and node.data > n2: return self._find_lca_helper(node.left, n1, n2) if node.data < n1 and node.data < n2: return self._find_lca_helper(node.right, n1, n2) return node def find_lca(self, n1, n2): node1, node2 = self._find_node(self.root, n1), self._find_node(self.root, n2) if node1 and node2: lca = self._find_lca_helper(self.root, n1, n2) return lca.data if lca else -1 return -1 def _find_node(self, root, key): if root is None or root.data == key: return root if key < root.data: return self._find_node(root.left, key) return self._find_node(root.right, key)"},{"question":"# Determine the Cycle Length in Collatz Conjecture The Collatz Conjecture is a mathematical sequence that hypothesizes that starting with any positive integer, the sequence will always eventually reach 1. The sequence follows these rules: 1. Start with a positive integer `n`. 2. Give the next number in the sequence as: - `n / 2` if `n` is even. - `3n + 1` if `n` is odd. 3. Repeat the process with the new value of `n`. Your task is to write a Python function that determines the length of the Collatz sequence for any given positive integer `n` until it reaches 1. **Your task** is to implement the function `collatz_cycle_length(n: int) -> int`, which returns the length of the cycle for a given positive integer `n`. Function Definition and Arguments: - `collatz_cycle_length(n: int) -> int`: - `n`: a positive integer for which you need to determine the cycle length. Requirements: 1. The function should keep dividing `n` by 2 if `n` is even. 2. If `n` is odd, multiply it by 3 and add 1. 3. Continue the process until `n` becomes 1. 4. Return the total number of steps required to reach 1, including the final step. Constraints: - `n` will be a positive integer less than 1,000,000. Examples: ```python # Example 1 assert collatz_cycle_length(1) == 1 # The sequence: 1 # Example 2 assert collatz_cycle_length(6) == 9 # The sequence: 6 → 3 → 10 → 5 → 16 → 8 → 4 → 2 → 1 # Example 3 assert collatz_cycle_length(19) == 21 # The sequence: 19 → ... → 1 ``` **Notes**: - Consider edge cases such as the smallest and largest possible values of `n`. - The function should be efficient to handle larger values of `n` within the constraints.","solution":"def collatz_cycle_length(n: int) -> int: Returns the length of the Collatz cycle for a given positive integer n until n reaches 1. count = 1 while n != 1: if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 count += 1 return count"},{"question":"# Background In a photo-sharing application, users can upload pictures and view their image gallery. To improve the performance of rendering the gallery and reduce the load time, you need to implement a function that generates thumbnail images of user-uploaded pictures. # Problem Statement Write a function named `generate_thumbnail` in Python that accomplishes the following: 1. Accepts the path to an image file. 2. Generates a thumbnail of the image maintaining the aspect ratio. 3. Saves the thumbnail in the specified directory with a maximum width and height of 128 pixels. 4. Returns the path to the thumbnail image. # Function Signature ```python def generate_thumbnail(image_path: str, thumbnail_dir: str) -> str: # your code here ``` # Input - `image_path` (string): A string representing the file path to the original image. - `thumbnail_dir` (string): A string representing the directory path where the thumbnail should be saved. # Output - (string): The file path to the generated thumbnail image. # Constraints - You must use the `PIL` (Pillow) library. - Handle different image formats like JPEG, PNG, GIF, etc. - Ensure robust handling of possible edge cases, such as invalid image paths or unsaveable directories. - Return an empty string if any error occurs during processing. # Example Usage ```python thumb_path = generate_thumbnail(\\"/path/to/image.jpg\\", \\"/path/to/thumbnails/\\") print(thumb_path) # Output: File path to the generated thumbnail, e.g., \\"/path/to/thumbnails/image_thumbnail.jpg\\" ``` # Notes - Ensure the thumbnail maintains the original aspect ratio of the image. - You should replace the original file extension with \'_thumbnail\' before the extension for the thumbnail file name. - Ensure the function handles permission issues gracefully and provides error messages where appropriate.","solution":"from PIL import Image import os def generate_thumbnail(image_path: str, thumbnail_dir: str) -> str: try: # Open the image file with Image.open(image_path) as img: # Generate the thumbnail img.thumbnail((128, 128)) # Prepare the thumbnail file name base_name = os.path.basename(image_path) name, ext = os.path.splitext(base_name) thumbnail_name = f\\"{name}_thumbnail{ext}\\" thumbnail_path = os.path.join(thumbnail_dir, thumbnail_name) # Ensure the directory exists os.makedirs(thumbnail_dir, exist_ok=True) # Save the thumbnail img.save(thumbnail_path) return thumbnail_path except Exception as e: print(f\\"Error generating thumbnail: {e}\\") return \\"\\""},{"question":"# Scenario A team of developers is working on a project that involves processing and analyzing a large collection of text documents. One essential task is to extract keywords with their respective frequencies from these documents to facilitate better search functionality and data insights. They want to ensure the keywords exclude common English stopwords. # Problem Statement Implement a function `extract_keywords(text: str, stopwords: List[str]) -> Dict[str, int]` that takes a string `text` and a list of common `stopwords`, and returns a dictionary where keys are the keywords (words excluding stopwords) and values are their respective frequencies in the text. # Function Signature ```python def extract_keywords(text: str, stopwords: List[str]) -> Dict[str, int]: ``` # Input - `text` (str): A string representing the text document to be processed. - `stopwords` (List[str]): A list of common stopwords to exclude from the keyword extraction. # Output - `Dict[str, int]`: A dictionary where keys are keywords and values are their frequencies in the text. # Constraints - The input `text` can be an arbitrary length but generally will not exceed several thousand characters. - The `stopwords` list will contain common English stopwords. - Words are considered case-insensitive. - Punctuation should be removed, and words should be considered alphabetic sequences only. # Examples ```python extract_keywords(\\"Hello, world! Programming in Python is fun. Python is easy to learn.\\", [\\"is\\", \\"in\\", \\"to\\"]) -> {\'hello\': 1, \'world\': 1, \'programming\': 1, \'python\': 2, \'fun\': 1, \'easy\': 1, \'learn\': 1} extract_keywords(\\"This is a test. This test is simple.\\", [\\"is\\", \\"a\\"]) -> {\'this\': 2, \'test\': 2, \'simple\': 1} ``` # Guidelines 1. Normalize the text by converting it to lower case. 2. Remove any punctuation. 3. Split the text into words and filter out the stopwords. 4. Count the frequency of each remaining word and return the result as a dictionary. # Hints - Use Python\'s `str` methods to handle case normalization and punctuation removal. - Consider using a `Counter` from the `collections` module to simplify the frequency count. # Notes - For simplicity, assume that the `stopwords` list and the text will be provided in a standardized format without additional punctuation or special characters within words.","solution":"import re from collections import Counter from typing import List, Dict def extract_keywords(text: str, stopwords: List[str]) -> Dict[str, int]: Extract keywords with their frequencies from the provided text, excluding the given stopwords. # Normalize the text to lowercase text = text.lower() # Remove punctuation text = re.sub(r\'W+\', \' \', text) # Split the text into words words = text.split() # Filter out stopwords keywords = [word for word in words if word not in stopwords] # Count the frequency of each keyword keyword_counter = Counter(keywords) return dict(keyword_counter)"},{"question":"# Task Description You are provided with a dataset containing various attributes about a group of individuals and their corresponding labels indicating whether they have a certain medical condition (binary: 0 or 1). Your task is to implement a Support Vector Machine (SVM) classifier to predict the labels based on the attributes. The dataset is provided in a CSV file format. # Function to Implement `svm_classifier(filename: str)` * **Input**: - `filename` (str): Path to the CSV file containing the dataset. * **Output**: - Returns the accuracy of the classifier on a randomly selected 20% test set. # CSV Format The CSV file is guaranteed to follow the format: ``` attribute1,attribute2,attribute3,...,attributeN,label value1,value2,value3,...,valueN,0 value1,value2,value3,...,valueN,1 ``` * Assume `3 <= number_of_attributes <= 50`. * Assume `100 <= number_of_rows <= 10000`. # Requirements 1. Implement the `svm_classifier` function that: - Reads the dataset from the specified CSV file. - Splits the data into features and labels. - Divides the data into a training set (80%) and a test set (20%). - Trains an SVM classifier using the training set. - Predicts the labels for the test set. - Calculates and returns the accuracy of the classifier on the test set. 2. Optimize the SVM hyperparameters for best performance. 3. Ensure the implementation can handle possible data anomalies such as missing values or incorrect types. # Example ```python # Example usage of the svm_classifier function accuracy = svm_classifier(\\"medical_data.csv\\") print(f\\"Accuracy of the classifier: {accuracy:.2f}\\") ``` # Notes * You may use libraries such as scikit-learn to implement the SVM classifier. * Ensure your implementation adheres to best practices in data preprocessing and model evaluation. * The accuracy should be calculated as the ratio of correctly predicted labels to the total number of labels in the test set.","solution":"import pandas as pd from sklearn.model_selection import train_test_split from sklearn.svm import SVC from sklearn.metrics import accuracy_score from sklearn.impute import SimpleImputer from sklearn.preprocessing import StandardScaler def svm_classifier(filename: str) -> float: # Read the dataset data = pd.read_csv(filename) # Separate features and labels X = data.iloc[:, :-1] y = data.iloc[:, -1] # Handle possible missing values imputer = SimpleImputer(strategy=\'mean\') X = imputer.fit_transform(X) # Split the dataset into training and test sets (80% training, 20% testing) X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.20, random_state=42) # Standardize the features scaler = StandardScaler() X_train = scaler.fit_transform(X_train) X_test = scaler.transform(X_test) # Initialize the SVM classifier with some hyperparameters svm = SVC(C=1.0, kernel=\'rbf\', gamma=\'scale\', random_state=42) # Train the classifier svm.fit(X_train, y_train) # Predict the labels for the test set y_pred = svm.predict(X_test) # Calculate and return the accuracy accuracy = accuracy_score(y_test, y_pred) return accuracy"},{"question":"# Anagram Grouping You are tasked with creating a function that takes a list of words and groups them into lists of anagrams. Two words are considered anagrams if they contain the same characters with the exact same frequency. Function Signature: ```python def group_anagrams(words: List[str]) -> List[List[str]]: pass ``` Input: * `words` (List[str]): A list of words (strings). Output: * List[List[str]]: A list where each element is a list of words that are anagrams of each other. Constraints: * The input list can be empty. * Each word will contain only lowercase alphabets. * Words can vary in length. Example: ```python >>> group_anagrams([\'bat\', \'tab\', \'cat\', \'dog\', \'god\', \'act\']) [[\'bat\', \'tab\'], [\'cat\', \'act\'], [\'dog\', \'god\']] >>> group_anagrams([\'hello\', \'world\']) [[\'hello\'], [\'world\']] >>> group_anagrams([]) [] ``` Scenario: You are developing a text analysis tool that requires the identification and grouping of anagrams from text data. Your function will be part of a processing pipeline to detect and analyze word patterns. The results will be used in further linguistic research and natural language processing tasks.","solution":"from collections import defaultdict from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: anagram_map = defaultdict(list) for word in words: sorted_word = \'\'.join(sorted(word)) anagram_map[sorted_word].append(word) return list(anagram_map.values())"},{"question":"# Pyramid Frequency Analysis Scenario You are building an application that needs to analyze the occurrences of characters in various levels of a pyramid structure of strings. Each level of the pyramid contains exactly one more string than the previous level, starting with one string at the first level. Your goal is to create a function that counts the frequency of characters in each level of the pyramid and returns a summary of this frequency. Problem Statement Implement a function, `pyramid_frequency_analysis(pyramid: List[List[str]]) -> List[Dict[str, int]]`, that: 1. Takes a list of lists of strings, where each inner list represents one level of the pyramid. 2. Each level contains exactly one more string than the previous level. 3. Counts the frequency of each character found in the strings for each level of the pyramid. 4. Returns a list of dictionaries, where each dictionary corresponds to a level in the pyramid and contains the frequency count of characters for that level. Input - `pyramid`: A list of lists of strings, where each inner list represents one level of the pyramid. Output - A list of dictionaries, each containing the character frequency counts for each corresponding level in the pyramid. Constraints - The pyramid will contain at least one level. - Strings consist of lowercase alphabetical characters only. Example ```python pyramid = [ [\\"aabbcc\\"], # Level 1 [\\"abc\\", \\"def\\"], # Level 2 [\\"a\\", \\"bb\\", \\"cc\\"] # Level 3 ] result = pyramid_frequency_analysis(pyramid) print(result) ``` This should output: ```python [ {\'a\': 2, \'b\': 2, \'c\': 2}, # Level 1 {\'a\': 1, \'b\': 1, \'c\': 1, \'d\': 1, \'e\': 1, \'f\': 1}, # Level 2 {\'a\': 1, \'b\': 2, \'c\': 2} # Level 3 ] ``` # Solution You need to write the function `pyramid_frequency_analysis` based on the given problem statement and example provided. ```python def pyramid_frequency_analysis(pyramid: List[List[str]]) -> List[Dict[str, int]]: result = [] for level in pyramid: level_frequency = {} for string in level: for char in string: if char in level_frequency: level_frequency[char] += 1 else: level_frequency[char] = 1 result.append(level_frequency) return result ```","solution":"from typing import List, Dict def pyramid_frequency_analysis(pyramid: List[List[str]]) -> List[Dict[str, int]]: result = [] for level in pyramid: level_frequency = {} for string in level: for char in string: if char in level_frequency: level_frequency[char] += 1 else: level_frequency[char] = 1 result.append(level_frequency) return result"},{"question":"# Dynamic Array Implementation and Testing Your task is to implement a dynamic array (similar to Python\'s list) and extend it with additional functionalities. Ensure efficient handling of memory and provide necessary methods to manipulate the array. Objectives: 1. **Dynamic Array Design**: - Develop a **DynamicArray** class that supports dynamic resizing. - Implement support for standard array operations: **append**, **insert**, **delete**, **get**, **set**. 2. **Implementation Requirements**: - Implement a private method to handle array resizing (doubling size when the array is full, and halving when it is less than a quarter full). - Implement an **iterator** to allow iteration over the elements in the array. - Implement methods to return the **current capacity** of the array and the **number of elements** it contains. 3. **Input and Output Formats**: - **Input**: * Series of operations on the dynamic array, including: - `append(item)`: Add item to the end. - `insert(index, item)`: Insert item at index. - `delete(index)`: Delete item at index. - `get(index)`: Get item at index. - `set(index, item)`: Set item at index to a new value. - **Output**: * Updated dynamic array after each operation. 4. **Data Constraints**: - Number of operations ≤ 1000 - Indices and items are integers. 5. **Performance Requirement**: - The operations should be efficient, with average time complexity of O(1) for append and O(n) for insert/delete. - The array should resize correctly to maintain performance and memory efficiency. Context: You are building a simplified custom implementation of a dynamic array to understand how Python\'s internal list operations work. Ensure your dynamic array can handle a variety of operations efficiently. You do not need to handle input/output beyond demonstrating the dynamic array operations via a series of method calls. Focus on the core functionalities and ensure the array resizes as expected while maintaining proper operation performance. Example Usage: ```python # Example Usage of DynamicArray # Initialize dynamic array dynamic_array = DynamicArray() # Append items dynamic_array.append(10) dynamic_array.append(20) dynamic_array.append(30) # Insert item at index dynamic_array.insert(1, 15) # Get item at index print(dynamic_array.get(2)) # Output: 20 # Set item at index dynamic_array.set(0, 5) # Delete item at index dynamic_array.delete(3) # Iterate over items for item in dynamic_array: print(item) # Output Current Capacity print(\\"Current Capacity:\\", dynamic_array.capacity()) # Output Number of Elements print(\\"Number of Elements:\\", dynamic_array.size()) ``` # Dynamic Array Unit Test Example ```python import unittest class TestDynamicArray(unittest.TestCase): def test_dynamic_array(self): da = DynamicArray() # Testing append and size da.append(1) da.append(2) self.assertEqual(da.size(), 2) self.assertEqual(da.get(0), 1) self.assertEqual(da.get(1), 2) # Testing insert da.insert(1, 1.5) self.assertEqual(da.get(1), 1.5) self.assertEqual(da.get(2), 2) # Testing delete da.delete(1) self.assertEqual(da.get(1), 2) # Testing set da.set(0, 10) self.assertEqual(da.get(0), 10) # Testing capacity adjustment initial_capacity = da.capacity() for i in range(da.capacity()): da.append(i) self.assertGreater(da.capacity(), initial_capacity) da.delete(0) da.delete(0) self.assertLess(da.capacity(), initial_capacity*2) if __name__ == \\"__main__\\": unittest.main() ```","solution":"class DynamicArray: def __init__(self): self._data = [None] * 1 self._n = 0 self._capacity = 1 def _resize(self, new_capacity): new_data = [None] * new_capacity for i in range(self._n): new_data[i] = self._data[i] self._data = new_data self._capacity = new_capacity def append(self, item): if self._n == self._capacity: self._resize(2 * self._capacity) self._data[self._n] = item self._n += 1 def insert(self, index, item): if index < 0 or index > self._n: raise IndexError(\\"Index out of bounds\\") if self._n == self._capacity: self._resize(2 * self._capacity) for i in range(self._n, index, -1): self._data[i] = self._data[i-1] self._data[index] = item self._n += 1 def delete(self, index): if index < 0 or index >= self._n: raise IndexError(\\"Index out of bounds\\") for i in range(index, self._n - 1): self._data[i] = self._data[i + 1] self._data[self._n - 1] = None self._n -= 1 if 0 < self._n < self._capacity // 4: self._resize(self._capacity // 2) def get(self, index): if index < 0 or index >= self._n: raise IndexError(\\"Index out of bounds\\") return self._data[index] def set(self, index, item): if index < 0 or index >= self._n: raise IndexError(\\"Index out of bounds\\") self._data[index] = item def size(self): return self._n def capacity(self): return self._capacity def __iter__(self): for i in range(self._n): yield self._data[i]"},{"question":"# Coding Question You are required to implement a quad-tree data structure for efficient spatial indexing and querying of point data. This structure should support dynamic insertion of points and querying for points within a given rectangular region. # Problem Statement Write a Python class `QuadTree` that constructs a quad-tree to manage a collection of 2D points. The class should support operations to insert points into the tree and to query points within a specific rectangular region. # Class Signature ```python class QuadTree: def __init__(self, boundary, capacity): Initialize the QuadTree with a specific boundary and capacity. Arguments: boundary -- a tuple of four values (x_min, y_min, x_max, y_max) representing the rectangular boundary of the quad tree. capacity -- the maximum number of points a node can hold before it has to subdivide. pass def insert(self, point): Insert a 2D point into the QuadTree. Arguments: point -- a tuple (x, y) representing the point to be inserted. Returns: True if the point was inserted successfully, False otherwise. pass def query(self, region): Query all points within a given rectangular region. Arguments: region -- a tuple of four values (x_min, y_min, x_max, y_max) representing the region to query. Returns: A list of tuples, each representing a point within the queried region. pass ``` # Input & Output * **Input (Constructor)**: - `boundary`: A tuple (x_min, y_min, x_max, y_max) representing the rectangular boundary of the quad-tree. - `capacity`: The maximum number of points a node can hold before it needs to subdivide. * **Input (Methods)**: - `insert`: A tuple (x, y) representing a 2D point. - `query`: A tuple (x_min, y_min, x_max, y_max) representing the region to query within. * **Output**: - `insert`: Returns True if the point was successfully inserted, False otherwise. - `query`: Returns a list of tuples, where each tuple is a point (x, y) within the queried region. # Constraints - The class should use a subdivide approach once capacity is exceeded. - The query operation should efficiently return all points within the given region. - You may assume the points and rectangular regions are defined within reasonable numerical limits for floating-point arithmetic. # Example Insert multiple points into the quad tree and query for points within a specific region: ```python # Define the boundary for the quad tree boundary = (0, 0, 100, 100) capacity = 4 qt = QuadTree(boundary, capacity) # Points to insert points = [(10, 10), (20, 20), (30, 30), (40, 40), (25, 25)] for point in points: qt.insert(point) # Query region query_region = (15, 15, 35, 35) result = qt.query(query_region) print(result) # Expected output: [(20, 20), (30, 30), (25, 25)] ```","solution":"class QuadTree: def __init__(self, boundary, capacity): self.boundary = boundary self.capacity = capacity self.points = [] self.divided = False self.northwest = None self.northeast = None self.southwest = None self.southeast = None def insert(self, point): (x_min, y_min, x_max, y_max) = self.boundary if not (x_min <= point[0] <= x_max and y_min <= point[1] <= y_max): return False if len(self.points) < self.capacity: self.points.append(point) return True else: if not self.divided: self.subdivide() return (self.northwest.insert(point) or self.northeast.insert(point) or self.southwest.insert(point) or self.southeast.insert(point)) def subdivide(self): (x_min, y_min, x_max, y_max) = self.boundary mid_x = (x_min + x_max) / 2 mid_y = (y_min + y_max) / 2 self.northwest = QuadTree((x_min, y_min, mid_x, mid_y), self.capacity) self.northeast = QuadTree((mid_x, y_min, x_max, mid_y), self.capacity) self.southwest = QuadTree((x_min, mid_y, mid_x, y_max), self.capacity) self.southeast = QuadTree((mid_x, mid_y, x_max, y_max), self.capacity) self.divided = True def query(self, region): found_points = [] (x_min, y_min, x_max, y_max) = region (qx_min, qy_min, qx_max, qy_max) = self.boundary if (qx_min > x_max or qx_max < x_min or qy_min > y_max or qy_max < y_min): return found_points for point in self.points: if x_min <= point[0] <= x_max and y_min <= point[1] <= y_max: found_points.append(point) if self.divided: found_points.extend(self.northwest.query(region)) found_points.extend(self.northeast.query(region)) found_points.extend(self.southwest.query(region)) found_points.extend(self.southeast.query(region)) return found_points"},{"question":"**Context**: Sorting algorithms are a fundamental part of computer science, with applications ranging from database indexing to search engines and beyond. One notable family of sorting algorithms is the merge sort, which follows a divide-and-conquer approach. However, variations of merge sort can involve comparing more than two elements at a time, or merging more than two sorted lists. **Problem Statement**: You are given `k` sorted arrays, each containing `n` integer elements. Your task is to implement the function `multi_merge_sort(arrays: List[List[int]]) -> List[int]` which merges these `k` sorted arrays into a single sorted output array. # Function Signature: ```python def multi_merge_sort(arrays: List[List[int]]) -> List[int]: pass ``` # Input: - a list `arrays` of `k` sorted lists, where each list has `n` integer elements (1 ≤ k, n ≤ 1,000). # Output: - a single sorted list containing all the elements from the input lists. # Constraints: - The number of lists `k` and the number of elements `n` in each list will always be within the given range. - Optimize the function to handle the maximum limits efficiently. - Elements in each array are not necessarily unique. # Example: ```python arrays = [ [1, 4, 7, 10], [2, 5, 8, 11], [3, 6, 9, 12] ] assert multi_merge_sort(arrays) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] ``` # Note: - You can use a min-heap to efficiently merge the sorted arrays. - Ensure proper handling of edge cases.","solution":"import heapq from typing import List def multi_merge_sort(arrays: List[List[int]]) -> List[int]: Merges k sorted arrays into a single sorted array. :param arrays: List of k sorted lists of integers :return: A single sorted list containing all the elements from the input lists min_heap = [] result = [] # Initialize the heap with the first element of each array along with their indices for i, array in enumerate(arrays): if array: # Check if the array is not empty heapq.heappush(min_heap, (array[0], i, 0)) while min_heap: value, array_index, element_index = heapq.heappop(min_heap) result.append(value) next_element_index = element_index + 1 if next_element_index < len(arrays[array_index]): next_element = arrays[array_index][next_element_index] heapq.heappush(min_heap, (next_element, array_index, next_element_index)) return result"},{"question":"# Context Sorting is a crucial task in many computing problems, especially when dealing with large datasets. One of the less common but still interesting sorting algorithms is the Comb sort, which is an improvement on Bubble sort. It attempts to eliminate small values near the end of the list since Bubble sort exhibits the worst-case scenario when small values are at the end. Your task is to implement this sorting algorithm understanding its unique approach to improve efficiency. # Problem Statement Implement a function `comb_sort` that sorts a given list of integers using the Comb sort algorithm. # Requirements 1. **Function Signature**: ```python def comb_sort(arr: list[int]) -> list[int]: ``` 2. **Input**: - `arr` (list of integers): A list of integers that need to be sorted. 3. **Output**: - Returns a list of integers sorted in ascending order. 4. **Constraints**: - You may not use any built-in Python sorting functions. - The algorithm needs to handle both positive and negative integers. - The function should work efficiently for a reasonably large number of elements (e.g., up to 10,000). 5. **Algorithm Steps**: - Initialize the gap size to the length of the list. - Reduce the gap by a shrink factor of 1.3 each iteration. - Perform a Bubble sort-like comparison and swapping with the current gap. - Continue until the gap is 1, and the list is sorted. 6. **Error Handling**: - Raise `TypeError` with an appropriate message if the input is not a list. - Raise `ValueError` if elements of the list are not integers. # Examples ```python >>> comb_sort([5, 3, 8, 4, 2]) [2, 3, 4, 5, 8] >>> comb_sort([1, -2, 3, -1, 0]) [-2, -1, 0, 1, 3] >>> comb_sort([4]) [4] >>> comb_sort([]) [] >>> comb_sort([9, 7, 5, 3, 1, 2, 4, 6, 8, 0]) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] >>> comb_sort([5, \'a\', 3]) Traceback (most recent call last): ... ValueError: All elements of the list must be integers. >>> comb_sort(\\"not a list\\") Traceback (most recent call last): ... TypeError: Input must be a list of integers. ``` # Notes - Ensure the code efficiently handles the sorting and proper gap reduction. - Make use of standard programming practices to manage edge cases and validate inputs.","solution":"def comb_sort(arr: list[int]) -> list[int]: if not isinstance(arr, list): raise TypeError(\\"Input must be a list of integers.\\") for item in arr: if not isinstance(item, int): raise ValueError(\\"All elements of the list must be integers.\\") n = len(arr) gap = n shrink = 1.3 sorted = False while not sorted: gap = int(gap // shrink) if gap <= 1: gap = 1 sorted = True for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False return arr"},{"question":"# Coding Assessment Question **Context:** In data science and software development, parsing and processing arrays of data is a common task. One frequently encountered problem is identifying patterns within given arrays, such as finding the longest consecutive sequence of equal elements. This type of problem is essential in preparing data for further analysis, diagnostics, or visualization. **Task:** Write a function named `longest_consecutive_subarray` in Python to find the longest consecutive subarray where all elements are the same. The function should return the length of this subarray. **Function Signature:** ```python def longest_consecutive_subarray(arr: List[int]) -> int: ``` **Input:** - `arr`: A list of integers representing the array to be analyzed. **Output:** - An integer representing the length of the longest consecutive subarray with identical elements. **Constraints:** - The input array will have at least one element. - All elements in the input array are integers. **Example:** ```python >>> longest_consecutive_subarray([1, 1, 2, 2, 2, 3]) 3 >>> longest_consecutive_subarray([4, 4, 4, 4, 4, 4, 4]) 7 >>> longest_consecutive_subarray([1, 2, 3, 4, 5]) 1 >>> longest_consecutive_subarray([2, 2, 3, 3, 3, 2, 2, 2, 2]) 4 ``` **Note:** - Ensure your function handles edge cases, such as when the array consists of the same element repeated multiple times or when no consecutive elements are the same beyond length one. - Optimize for efficiency with respect to both time and space complexity.","solution":"from typing import List def longest_consecutive_subarray(arr: List[int]) -> int: if not arr: return 0 # Though we are asked to assume there is always at least one element, including this check for robust code. max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] == arr[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) # Final check in case the longest subarray ends at the last element. return max_length"},{"question":"# Problem Statement: You are developing a feature for a book repository system that allows users to search for books by title and author. Implement the `search_books` function that will search through a provided list of books and return a list of matching books based on the given search criteria. # Function Signature: ```python def search_books(books: List[Dict[str, str]], query: str) -> List[Dict[str, str]]: pass ``` # Requirements: 1. **Inputs**: - `books`: A list of dictionaries, where each dictionary represents a book with the fields \'title\' and \'author\'. (1 ≤ len(books) ≤ 1000) - `query`: A string representing the search query which could partially or fully match the book title or author. (1 ≤ len(query) ≤ 100) 2. **Outputs**: - A list of dictionaries representing the books that match the search query in either title or author. The result should be case-insensitive. 3. **Constraints**: - Each dictionary in the books list will always contain the keys \'title\' and \'author\'. - The matching should be case-insensitive, meaning the search should not differentiate between uppercase and lowercase letters. - The order of the books in the result should be the same as in the input list. 4. **Performance Consideration**: - The function should efficiently handle up to 1000 books and queries up to 100 characters long. # Example: ```python books = [ {\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\"}, {\\"title\\": \\"A Brief History of Time\\", \\"author\\": \\"Stephen Hawking\\"}, {\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\"}, {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\"} ] query = \\"scOtt\\" search_books(books, query) ``` *Expected Output*: ```python [ {\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\"} ] ``` **Note**: - The function should ignore letter case when matching the query with the book titles or authors. - Ensure the function returns the correct set of books that match the query string, maintaining the original order from the input list.","solution":"from typing import List, Dict def search_books(books: List[Dict[str, str]], query: str) -> List[Dict[str, str]]: Searches for books by title or author that match the given query. Args: - books: A list of dictionaries, where each dictionary represents a book with the fields \'title\' and \'author\'. - query: A string representing the search query. Returns: - A list of dictionaries representing the books that match the search query. query_lower = query.lower() return [book for book in books if query_lower in book[\'title\'].lower() or query_lower in book[\'author\'].lower()]"},{"question":"# Coding Assessment Question **Context:** In software development, handling exceptions and ensuring robust error-checking are crucial for building reliable applications. You\'ll often need to validate inputs and manage cases where the inputs don\'t meet the expected criteria. **Task:** Write a function named `validate_and_calculate` in Python to perform the addition of two numbers. The function should first validate the inputs to ensure they are numeric (either integers or floats). If either of the inputs is not numeric, the function should raise a `ValueError` with an appropriate error message. **Function Signature:** ```python def validate_and_calculate(num1: Union[int, float], num2: Union[int, float]) -> Union[int, float]: ``` **Input:** - `num1`: A numeric value (integer or float). - `num2`: A numeric value (integer or float). **Output:** - A single numeric value representing the sum of `num1` and `num2`. **Constraints:** - If either of the inputs is not numeric, the function should raise a `ValueError` with the message \\"Inputs must be numeric.\\" **Example:** ```python >>> validate_and_calculate(5, 10) 15 >>> validate_and_calculate(2.5, 3.5) 6.0 >>> validate_and_calculate(5, \'10\') ValueError: Inputs must be numeric. >>> validate_and_calculate(\'a\', 1) ValueError: Inputs must be numeric. ``` **Note:** - Ensure your function handles edge cases and raises exceptions where appropriate. - Do not use any external libraries; only built-in Python functions and types should be utilized.","solution":"from typing import Union def validate_and_calculate(num1: Union[int, float], num2: Union[int, float]) -> Union[int, float]: Validates the inputs to ensure they are numeric (ints or floats) and returns their sum. Raises a ValueError if any of the inputs is not numeric. if not (isinstance(num1, (int, float)) and isinstance(num2, (int, float))): raise ValueError(\\"Inputs must be numeric.\\") return num1 + num2"},{"question":"# Implement Trie Data Structure Objective Implement a Trie (prefix tree) to effectively support insert and search operations. This task evaluates your understanding of tree data structures and efficient algorithms for string manipulation and search. Scenario You are developing a text autocomplete feature for a search engine. To enhance the efficiency of the queries, you need to build a Trie that allows quick insertion and retrieval of words. Implement the essential functions to support this data structure. Instructions 1. Implement the following classes and methods: * `TrieNode` class to model the nodes in the Trie. * Attributes: * `children` (dict): A dictionary mapping characters to TrieNode. * `is_end_of_word` (bool): Indicates if the node represents the end of a word. * Method: * `__init__(self)`: Initialize the TrieNode with an empty dictionary for children and `is_end_of_word` set to False. * `Trie` class to model the Trie. * Methods: * `__init__(self)`: Initialize the Trie with a root TrieNode. * `insert(self, word)`: * Input: * `word` (str): The word to be added to the Trie. * Output: * `None`: The word is inserted into the Trie. * `search(self, word)`: * Input: * `word` (str): The word to search for in the Trie. * Output: * `bool`: Returns True if the word is found, False otherwise. * `starts_with(self, prefix)`: * Input: * `prefix` (str): The prefix to search for in the Trie. * Output: * `bool`: Returns True if there is any word in the Trie that starts with the given prefix, False otherwise. Constraints * Assume all input strings contain only lowercase English letters (\'a\' - \'z\'). * Insert and search operations run in O(m) time complexity, where m is the length of the word or prefix. Example ```python # Example of how to use the Trie trie = Trie() trie.insert(\\"hello\\") print(trie.search(\\"hello\\")) # Output: True print(trie.search(\\"hell\\")) # Output: False print(trie.starts_with(\\"hell\\")) # Output: True trie.insert(\\"hell\\") print(trie.search(\\"hell\\")) # Output: True ``` Implement the above functions to efficiently handle the operations of inserting and searching words within the Trie data structure.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word): node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix): node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"**Manhattan Distance Calculation** You are tasked with writing a function to calculate the Manhattan distance between two points on a 2D plane. The Manhattan distance between two points (x1, y1) and (x2, y2) is defined as |x1 - x2| + |y1 - y2|. **Function Signature**: ```python def manhattan_distance(point1: tuple[int, int], point2: tuple[int, int]) -> int: pass ``` **Input**: - `point1`: A tuple of two integers representing the coordinates of the first point (x1, y1). - `point2`: A tuple of two integers representing the coordinates of the second point (x2, y2). **Output**: - An integer representing the Manhattan distance between the two given points. **Constraints**: - Both tuples contain exactly two integers. - The integer values range from -10^6 to 10^6. **Example**: ```python >>> manhattan_distance((1, 2), (4, 6)) 7 >>> manhattan_distance((-1, -5), (3, 9)) 18 ``` **Explanation**: 1. For the first example: - The first point is (1, 2) and the second point is (4, 6). - The Manhattan distance is calculated as |1 - 4| + |2 - 6| = 3 + 4 = 7. 2. For the second example: - The first point is (-1, -5) and the second point is (3, 9). - The Manhattan distance is calculated as |-1 - 3| + |-5 - 9| = 4 + 14 = 18. Ensure correctness through handling different signs and large values well within the given constraints, while also accounting for edge cases with zero distances when points coincide or lie on the same line.","solution":"def manhattan_distance(point1: tuple[int, int], point2: tuple[int, int]) -> int: Calculate the Manhattan distance between two points on a 2D plane. Args: point1 (tuple[int, int]): Coordinates of the first point (x1, y1). point2 (tuple[int, int]): Coordinates of the second point (x2, y2). Returns: int: The Manhattan distance between the two points. x1, y1 = point1 x2, y2 = point2 return abs(x1 - x2) + abs(y1 - y2)"},{"question":"# Problem Statement You are developing a software that schedules tasks for multiple servers. Each server can handle one task at a time and has a predefined capacity. The capacity is defined as the maximum value of task difficulty that the server can handle. Given an array of task difficulties and an array of server capacities, implement a function `schedule_tasks` that assigns each task to a server such that the maximum task assigned to any server does not exceed its capacity. If there are tasks that cannot be assigned to any server, the function should return `False`. Otherwise, the function should return `True` indicating that all tasks can be assigned. # Function Signature ```python def schedule_tasks(tasks: list[int], capacities: list[int]) -> bool: pass ``` # Input - `tasks`: a list of integers representing the difficulties of the tasks, where (1 le text{len(tasks)} leq 10^4) and (0 le text{tasks}[i] leq 10^9). - `capacities`: a list of integers representing the capacities of the servers, where (1 le text{len(capacities)} leq 10^4) and (0 le text{capacities}[i] leq 10^9). # Output - Returns a boolean value `True` if all tasks can be assigned to servers without exceeding their corresponding capacities, otherwise `False`. # Constraints - Each task must be assigned to exactly one server. - The number of tasks and the number of servers are both between 1 and (10^4). - Each task difficulty and server capacity is a non-negative integer not exceeding (10^9). # Example ```python >>> schedule_tasks([3, 2, 1], [3, 2]) True >>> schedule_tasks([4, 5, 6], [3, 3, 3]) False >>> schedule_tasks([1, 2, 3, 4], [4, 3, 2, 1]) True ``` # Notes - Make sure the function handles varying lengths of `tasks` and `capacities` lists efficiently. - Optimize the function to work within the provided constraints.","solution":"def schedule_tasks(tasks, capacities): # Sort both tasks and capacities in non-decreasing order tasks.sort() capacities.sort() j = 0 # Pointer for capacities # Iterate through each task for task in tasks: # Find the first server that can handle this task while j < len(capacities) and capacities[j] < task: j += 1 # If no server can handle the task if j == len(capacities): return False # Assign the server to this task and move to the next server j += 1 return True"},{"question":"# Matrix Rotation You have a square matrix of integers, and you need to rotate it 90 degrees clockwise in place. This means you cannot use any additional memory for another matrix; you must perform the rotation within the matrix given as input. Function Definition Write a function `rotate_matrix(matrix: List[List[int]]) -> None` that takes a square matrix represented as a list of lists of integers and rotates it 90 degrees clockwise in place. Input * `matrix` (List[List[int]]): A 2D list representing an NxN matrix, where each element is an integer. Output * The function returns `None` but modifies the input matrix in place to achieve the rotation. Constraints * The size of the matrix, N, will be in the range [1, 100]. Examples ```python matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix1) assert matrix1 == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] matrix2 = [ [5, 1], [2, 9] ] rotate_matrix(matrix2) assert matrix2 == [ [2, 5], [9, 1] ] ``` Explanation 1. In the first example, the original 3x3 matrix is rotated 90 degrees clockwise to produce the resulting matrix. 2. In the second example, the 2x2 matrix is rotated 90 degrees clockwise similarly. Performance Requirements The solution must work efficiently within the given constraints, particularly ensuring the in-place rotation without using any additional storage apart from a few local variables.","solution":"def rotate_matrix(matrix): Rotates an NxN matrix by 90 degrees clockwise in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Coding Question: Determine the Winner of a Tic-Tac-Toe Game Write a function to determine the winner of a Tic-Tac-Toe game given a 3x3 board represented as a list of lists. Each cell is either `\'X\'`, `\'O\'`, or an empty string `\'\'` representing an unfilled cell. Your task is to implement the function `tictactoe_winner(board: List[List[str]]) -> str` that determines the result of the game. Function Signature: ```python def tictactoe_winner(board: List[List[str]]) -> str: ``` Parameters: * **board** (List[List[str]]): A 3x3 list of lists where each element is `\'X\'`, `\'O\'`, or `\'\'`. Returns: * **str**: The winner of the game: `\'X\'`, `\'O\'`, or `\'Draw\'` if there is no winner and the board is full, or `\'Pending\'` if the game is not yet finished. Constraints: * The board will always be a 3x3 grid of the strings `\'X\'`, `\'O\'`, or `\'\'`. * No invalid characters or dimensions will be provided. Example: ```python assert tictactoe_winner([[\\"X\\", \\"O\\", \\"X\\"], [\\"O\\", \\"X\\", \\"O\\"], [\\"O\\", \\"X\\", \\"X\\"]]) == \\"X\\" assert tictactoe_winner([[\\"X\\", \\"O\\", \\"\\"], [\\"O\\", \\"X\\", \\"O\\"], [\\"O\\", \\"X\\", \\"X\\"]]) == \\"Pending\\" assert tictactoe_winner([[\\"X\\", \\"O\\", \\"\\"], [\\"O\\", \\"\\", \\"O\\"], [\\"O\\", \\"X\\", \\"X\\"]]) == \\"Pending\\" assert tictactoe_winner([[\\"X\\", \\"O\\", \\"X\\"], [\\"O\\", \\"X\\", \\"O\\"], [\\"O\\", \\"X\\", \\"O\\"]]) == \\"Draw\\" ``` # Additional Notes: * Consider different winning conditions: rows, columns, and both diagonals. * If no one has won and there are empty cells, return `\'Pending\'`. * If the board is full and there is no winner, return `\'Draw\'`.","solution":"from typing import List def tictactoe_winner(board: List[List[str]]) -> str: # Check rows for winner for row in board: if row[0] == row[1] == row[2] and row[0] != \'\': return row[0] # Check columns for winner for col in range(3): if board[0][col] == board[1][col] == board[2][col] and board[0][col] != \'\': return board[0][col] # Check diagonals for winner if board[0][0] == board[1][1] == board[2][2] and board[0][0] != \'\': return board[0][0] if board[0][2] == board[1][1] == board[2][0] and board[0][2] != \'\': return board[0][2] # Check for pending state for row in board: if \'\' in row: return \'Pending\' return \'Draw\'"},{"question":"# Problem Statement In a game of Tictactoe, a player can win by placing three of their marks in a horizontal, vertical, or diagonal row on a 3x3 grid. Write a function `tictactoe_winner` that determines the winner of a completed Tic-Tac-Toe game. Task You need to write a function `tictactoe_winner` that accepts a 3x3 list representing the game board and returns the winner (\'X\' or \'O\') or \'Draw\' if there is no winner. Function Signature ```python def tictactoe_winner(board: List[List[str]]) -> str: ``` Input * `board` (List[List[str]]): A 3x3 list where each element is a string (\'X\', \'O\', or an empty space \' \'). Output * Returns a string: * \'X\' if player X wins. * \'O\' if player O wins. * \'Draw\' if there is no winner. Constraints * The input represents a completed game, i.e., all cells are filled. * The board is always a 3x3 grid and contains valid characters (\'X\', \'O\', \' \'). Example Usage ```python >>> tictactoe_winner([[\'X\', \'O\', \'X\'], [\'O\', \'X\', \'O\'], [\'O\', \'X\', \'X\']]) \'X\' >>> tictactoe_winner([[\'O\', \'O\', \'O\'], [\'X\', \'X\', \'O\'], [\'X\', \'O\', \'X\']]) \'O\' >>> tictactoe_winner([[\'X\', \'O\', \'X\'], [\'X\', \'O\', \'O\'], [\'O\', \'X\', \'O\']]) \'Draw\' ``` Notes - A player wins if they have three of their marks in a horizontal, vertical, or diagonal row. - In the case of a tie where no one has won, return \'Draw\'. Performance Requirements - The function should determine the winner efficiently with a time complexity of O(1) since the board size is constant (3x3). Solution Approach - Check all rows, columns, and both diagonals for a winning combination. - If any of these conditions is met by \'X\' or \'O\', return the respective winner. - If no winning condition is met, return \'Draw\'. This new question matches the style, complexity, and scope of the provided sample question, ensuring it aligns well with the set.","solution":"def tictactoe_winner(board): This function determines the winner of a completed Tic-Tac-Toe game. Parameters: board (List[List[str]]): A 3x3 list representing the game board. Returns: str: \'X\' if player X wins, \'O\' if player O wins, \'Draw\' if there is no winner. # Check rows and columns for a winner for i in range(3): if board[i][0] == board[i][1] == board[i][2] != \' \': return board[i][0] if board[0][i] == board[1][i] == board[2][i] != \' \': return board[0][i] # Check diagonals for a winner if board[0][0] == board[1][1] == board[2][2] != \' \': return board[0][0] if board[0][2] == board[1][1] == board[2][0] != \' \': return board[0][2] # If no winner, return \'Draw\' return \'Draw\'"},{"question":"# Word Ladder Path Finder Context: A word ladder is a sequence of words where only one letter changes at each step from the previous word to the next. The objective is to transform a start word into an end word using the shortest possible sequence of valid words where each intermediate word differs from the previous one by exactly one letter. Task: You need to write a function `word_ladder(start: str, end: str, word_list: list) -> list` that finds the shortest transformation from the word `start` to the word `end` using the words in `word_list`. The `end` word must be reachable from the `start` word using words from `word_list`, and only one letter can change at a time. Requirements: 1. The start and end words must be included in the word ladder path. 2. Each intermediate word in the word ladder path must exist in the `word_list`. 3. If no valid transformation is possible, return an empty list. 4. Raise a `TypeError` with a message `\\"Inputs must be valid strings\\"` if `start` or `end` are not strings or `word_list` is not a list of strings. Input: * A string `start` representing the start word. * A string `end` representing the end word. * A list of strings `word_list` containing the allowable intermediate words. Output: * A list of strings representing the shortest transformation path from `start` to `end`. If no such path exists, return an empty list. Constraints: * Each word has the same length. * Only lower-case English letters are used. * The length of `word_list` is between 1 and 500. * All words in the input have a length between 1 and 10. Examples: ```python word_ladder(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"]) # Output: [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\"] word_ladder(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\"]) # Output: [] word_ladder(\\"hit\\", \\"lot\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"]) # Output: [\\"hit\\", \\"hot\\", \\"lot\\"] word_ladder(\\"start\\", \\"end\\", []) # Output: [] word_ladder(\\"apple\\", \\"appla\\", [\\"appla\\", \\"apply\\", \\"appls\\"]) # Output: [\\"apple\\", \\"appla\\"] word_ladder(123, \\"end\\", [\\"end\\", \\"edt\\", \\"ent\\", \\"end\\"]) # Raises: TypeError: Inputs must be valid strings ``` In this new question, I aimed to match the style, complexity, and length of the provided sample question while introducing a novel problem revolving around string transformation and pathfinding in a constrained environment. The task involves validation, error handling, and an understanding of graph traversal algorithms, ensuring that it tests similar skills and concepts as the original question.","solution":"from collections import deque def word_ladder(start: str, end: str, word_list: list) -> list: if not isinstance(start, str) or not isinstance(end, str) or not isinstance(word_list, list): raise TypeError(\\"Inputs must be valid strings\\") for word in word_list: if not isinstance(word, str): raise TypeError(\\"Inputs must be valid strings\\") word_set = set(word_list) if end not in word_set: return [] def get_neighbors(word): neighbors = [] for i in range(len(word)): for char in \'abcdefghijklmnopqrstuvwxyz\': possible_word = word[:i] + char + word[i+1:] if possible_word != word and possible_word in word_set: neighbors.append(possible_word) return neighbors queue = deque([(start, [start])]) visited = set([start]) while queue: current_word, path = queue.popleft() for neighbor in get_neighbors(current_word): if neighbor == end: return path + [end] if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, path + [neighbor])) return []"},{"question":"# Problem Statement **Context**: You are a software engineer designing a utility for processing log files. Part of your task involves parsing a string containing multiple log records and extracting specific information. Task Write a Python function `extract_error_messages` that processes a multiline string of log entries and extracts all error messages. Each log entry is on a new line, and error messages are identified with the prefix \\"ERROR:\\". Requirements: * The function should accept a string containing multiple lines. * The function should return a list of strings, where each string is an error message without the \\"ERROR:\\" prefix. * If there are no error messages, the function should return an empty list. Function Signature ```python def extract_error_messages(logs: str) -> List[str]: pass ``` # Input * `logs`: A multiline string where each line is a log entry. Each entry can either be regular information or an error message. Error messages start with the prefix \\"ERROR:\\". # Output * A list of strings, where each element is an error message extracted from the logs. # Constraints * The length of `logs` will be between `0` and `10^6` characters. * Each line in `logs` can be up to `10^4` characters long. # Example ```python >>> logs = INFO: Started process INFO: Running operation ERROR: Failed to open file INFO: Operation completed ERROR: Missing configuration INFO: Shutting down >>> extract_error_messages(logs) [\'Failed to open file\', \'Missing configuration\'] ``` # Note * The function should only extract messages that start with \\"ERROR:\\" and return them without the \\"ERROR:\\" prefix.","solution":"from typing import List def extract_error_messages(logs: str) -> List[str]: Extracts error messages from the log entries. Parameters: logs (str): A multiline string of log entries. Returns: List[str]: A list containing all error messages without the \\"ERROR:\\" prefix. error_prefix = \\"ERROR:\\" error_messages = [] for line in logs.splitlines(): if line.startswith(error_prefix): error_messages.append(line[len(error_prefix):].strip()) return error_messages"},{"question":"# Problem Statement Write a Python function to parse and analyze a collection of log files generated by a web server. Your task is to identify and report the top IP addresses that frequent the server most often, which can help in understanding traffic patterns and potential issues. # Requirements Implement a Python function `top_ip_addresses` that takes two parameters: 1. `log_dir: str`: A string representing the directory path containing log files. 2. `top_n: int`: An integer representing the number of top IP addresses to return. The function should: 1. Read all log files (with `.log` extension) in the specified directory. 2. Extract and count the occurrences of each IP address in the files. 3. Return a list of tuples with the top `top_n` IP addresses and their respective counts, sorted in descending order of their counts. # Constraints * Ignore lines that do not contain a valid IP address. * If `top_n` is greater than the total unique IP addresses, return all available IP addresses sorted by their counts. * Assume valid log entries follow the format: `\\"[timestamp] IP_address - - [request] ...\\"` # Input and Output Formats * **Input**: * `log_dir: str`: A string representing the directory path of the log files. * `top_n: int`: An integer representing the number of top IP addresses to return. * **Output**: * `List[Tuple[str, int]]`: A list of tuples with IP addresses and their counts. # Performance Requirements * Handle directories with up to 10,000 log files efficiently. * Implement the function to minimize memory usage while processing large files. # Example ```python def top_ip_addresses(log_dir: str, top_n: int) -> list[tuple[str, int]]: # Your implementation here # Example usage result = top_ip_addresses(\\"/path/to/log/files\\", 5) print(result) ``` # Notes * You may use any built-in Python libraries and modules. * Ensure efficient file handling and error handling for non-readable log entries. # Example Log Entry ``` [2023-01-01 12:00:00] 192.168.1.1 - - [GET /index.html HTTP/1.1] 200 123 [2023-01-01 12:01:00] 192.168.1.2 - - [POST /submit HTTP/1.1] 404 234 ```","solution":"import os import re from collections import Counter def top_ip_addresses(log_dir: str, top_n: int): Reads log files from the specified directory and returns the top `top_n` IP addresses by occurrence count. Parameters: log_dir (str): Path to the directory containing log files. top_n (int): Number of top IP addresses to return. Returns: List[Tuple[str, int]]: A list of tuples with IP addresses and their counts. ip_pattern = re.compile(r\'bd{1,3}.d{1,3}.d{1,3}.d{1,3}b\') ip_counter = Counter() for filename in os.listdir(log_dir): if filename.endswith(\\".log\\"): filepath = os.path.join(log_dir, filename) with open(filepath, \'r\') as file: for line in file: match = ip_pattern.search(line) if match: ip_counter[match.group()] += 1 return ip_counter.most_common(top_n)"},{"question":"# String Permutation Detector # Problem Description: You are required to write a function that determines whether two given strings are permutations of each other. A permutation of a string is another string that contains the same characters, only the order of characters can be different. The function should be efficient and work well for large inputs. # Requirements: 1. Implement a function `is_permutation(str1: str, str2: str) -> bool` that returns `True` if `str1` is a permutation of `str2`, otherwise `False`. 2. Optimize your solution to work efficiently with strings up to 100,000 characters in length. Input: * `str1` and `str2` (1 <= len(str1), len(str2) <= 100000): Two strings to be compared. Output: * A boolean value: `True` if the strings are permutations of each other, otherwise `False`. Constraints: * The function should handle large inputs efficiently. * Consider edge cases such as strings of different lengths or strings with special characters and spaces. # Example: ```python # Example 1 assert is_permutation(\\"abc\\", \\"bca\\") == True # Both strings contain the same characters [a, b, c]. # Example 2 assert is_permutation(\\"123456\\", \\"654321\\") == True # Both strings contain the same characters [1, 2, 3, 4, 5, 6]. # Example 3 assert is_permutation(\\"hello\\", \\"bello\\") == False # The strings have different sets of characters. # Example 4 assert is_permutation(\\"aabbcc\\", \\"abcabc\\") == True # Both strings contain the characters [a, a, b, b, c, c]. # Example 5 assert is_permutation(\\"xyz\\", \\"xyz \\") == False # A space character makes the strings different. ``` # Performance: - Your implementation should run in O(n) time complexity, where `n` is the length of the longer string. # Tips: 1. Consider different strategies for checking if two strings are permutations. Sorting both strings and comparing them might be one approach. 2. Alternatively, you could use a frequency count of characters in both strings and compare them. 3. Make sure your function handles various edge cases such as empty strings or strings with differing lengths promptly. # Implementation: Your task is to fill in the implementation of the following function: ```python def is_permutation(str1: str, str2: str) -> bool: # Your implementation here pass ``` Ensure to test your function thoroughly using the provided examples and additional edge cases you can think of.","solution":"def is_permutation(str1: str, str2: str) -> bool: Determine if two strings are permutations of each other. if len(str1) != len(str2): return False count1 = {} count2 = {} for ch in str1: if ch in count1: count1[ch] += 1 else: count1[ch] = 1 for ch in str2: if ch in count2: count2[ch] += 1 else: count2[ch] = 1 return count1 == count2"},{"question":"# Coding Assessment Question Context: You are working as a developer for a financial software company. Your current task involves enhancing the application\'s ability to process and analyze stock prices. One common analysis is finding the maximum profit that can be achieved by buying and selling a single share over a given period. Your solution needs to handle large datasets efficiently. Task: Write a Python function named `max_profit` that accepts a list of daily stock prices and returns the maximum profit that could be achieved by buying on one day and selling on another day. If no profit can be achieved, return 0. Specifications: - **Function Name**: `max_profit` - **Parameters**: - `prices` (list[int]): A list of integers representing the stock prices on consecutive days. - **Returns**: An integer representing the maximum profit. # Constraints: 1. The list of prices is non-negative and can be very large. 2. The function should run in linear time complexity, i.e., O(n). 3. Handle the edge cases such as when the list is empty or contains just one price. # Example: ```python assert max_profit([7, 1, 5, 3, 6, 4]) == 5 assert max_profit([7, 6, 4, 3, 1]) == 0 assert max_profit([1, 2, 3, 4, 5]) == 4 assert max_profit([10, 9, 8, 2, 1, 10]) == 9 assert max_profit([3, 3]) == 0 ```","solution":"def max_profit(prices): Calculate the maximum profit that can be achieved from buying and selling a single share given a list of daily stock prices. :param prices: List of integers representing stock prices. :return: Maximum profit that can be made. If no profit can be made, return 0. if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: if price < min_price: min_price = price else: max_profit = max(max_profit, price - min_price) return max_profit"},{"question":"# Question: Implementing a Robust Dijkstra\'s Algorithm Context: You\'ve been asked to enhance the implementation of Dijkstra\'s algorithm to handle a variety of graphs and output the shortest paths from a source node to all other nodes. Your task is to consider edge cases such as disconnected graphs and ensure the implementation is both efficient and robust. Problem Statement: Write a Python function `enhanced_dijkstra(graph: Dict[int, List[Tuple[int, float]]], source: int) -> Dict[int, float]:` which computes the shortest paths from the specified source node to all other nodes in the graph using Dijkstra\'s algorithm. Your function should: 1. Take as input a dictionary `graph` where keys are node identifiers and values are lists of tuples (representing the neighboring node and the edge weight). 2. Handle graphs with disconnected components gracefully. 3. Ensure efficient performance, taking into account the potential size of the graph. Input: * `graph`: A dictionary where each key is an integer representing a node, and the value is a list of tuples, with each tuple containing a neighboring node and the weight of the edge connecting them. * `source`: An integer representing the source node from which shortest paths are calculated. Output: * A dictionary where the keys are the node identifiers and the values are the shortest distances from the source node. If a node is not reachable, its distance should be represented as `float(\'inf\')`. Constraints: - The weights of the edges are non-negative. - The graph can be directed or undirected. Example: ```python # Example Input graph = { 0: [(1, 2), (2, 4)], 1: [(2, 1), (3, 7)], 2: [(4, 3)], 3: [(4, 2)], 4: [] } source = 0 # Expected Output result = enhanced_dijkstra(graph, source) print(result) # {0: 0, 1: 2, 2: 3, 3: 9, 4: 6} ``` Implement the complete function `enhanced_dijkstra` to solve the given problem.","solution":"import heapq from typing import Dict, List, Tuple def enhanced_dijkstra(graph: Dict[int, List[Tuple[int, float]]], source: int) -> Dict[int, float]: Computes the shortest paths from the source node to all other nodes in the graph. Parameters: graph (Dict[int, List[Tuple[int, float]]]): The input graph. source (int): The source node. Returns: Dict[int, float]: The shortest distance from the source node to each node. Nodes not reachable from the source will have a distance of float(\'inf\'). # Initialize distances with infinity distances = {node: float(\'inf\') for node in graph} distances[source] = 0 # Priority queue to hold nodes to explore priority_queue = [(0, source)] # (distance, node) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If the distance for the current node is already greater than known, skip it if current_distance > distances[current_node]: continue # Explore neighbors for neighbor, weight in graph.get(current_node, []): distance = current_distance + weight # Only consider this new path if it\'s better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Coding Assessment Question Scenario You are in charge of developing a utility for processing and analyzing log files from a server. One of the frequent operations is determining the most frequent log entry within a specified range of lines. You decide to use a Segment Tree to perform these frequency queries. Task Implement the `build_segment_tree` and `query` functions to construct a Segment Tree for a given list of log entries and efficiently retrieve the most frequent log entry within specified ranges. Function Definitions 1. **build_segment_tree**: * **Input**: A list of strings representing log entries. * **Output**: A Segment Tree (represented as a list of nodes, each containing a dictionary with log entries and their frequencies). * **Constraints**: - The input list may contain duplicate entries. - The list may be empty. 2. **query**: * **Input**: - A Segment Tree generated from `build_segment_tree`. - Two integers (`left_bound`, `right_bound`) representing the range for the query. * **Output**: The most frequent log entry in the range `[left_bound, right_bound]`. If there is a tie, return any one of the most frequent log entries. * **Constraints**: - Ensure the bounds are within the valid range. - Handle cases where the bounds are invalid. Sample Usage ```python segment_tree = build_segment_tree([\\"INFO\\", \\"WARN\\", \\"ERROR\\", \\"INFO\\", \\"INFO\\", \\"ERROR\\", \\"WARN\\", \\"ERROR\\"]) assert query(segment_tree, 0, 4) == \\"INFO\\" assert query(segment_tree, 3, 7) in [\\"INFO\\", \\"ERROR\\"] segment_tree = build_segment_tree([\\"DEBUG\\", \\"DEBUG\\", \\"INFO\\"]) assert query(segment_tree, 0, 2) == \\"DEBUG\\" assert query(segment_tree, 1, 1) == \\"DEBUG\\" ``` # Requirements * Implement the core algorithm as described. * Validate inputs to ensure error handling for edge cases such as empty lists and invalid query bounds. * Use efficient and optimal methods to achieve the desired performance. Constraints * Maximum length of the list ( n leq 10^5 ). * Ensure your implementation handles both small and large inputs effectively.","solution":"class SegmentTree: def __init__(self, log_entries): self.n = len(log_entries) self.tree = [{} for _ in range(2 * self.n)] self.build(log_entries) def build(self, log_entries): # Initialize leaves with log entries for i in range(self.n): self.tree[self.n + i] = {log_entries[i]: 1} # Build the tree by calculating parent nodes for i in range(self.n - 1, 0, -1): self.tree[i] = self.combine_nodes(self.tree[2 * i], self.tree[2 * i + 1]) def combine_nodes(self, left_node, right_node): combined = left_node.copy() for key in right_node: if key in combined: combined[key] += right_node[key] else: combined[key] = right_node[key] return combined def query(self, left_bound, right_bound): left_bound += self.n right_bound += self.n + 1 result = {} while left_bound < right_bound: if left_bound % 2 == 1: result = self.combine_nodes(result, self.tree[left_bound]) left_bound += 1 if right_bound % 2 == 1: right_bound -= 1 result = self.combine_nodes(result, self.tree[right_bound]) left_bound //= 2 right_bound //= 2 # Find the most frequent log entry in the combined result most_frequent_entry = max(result, key=result.get) return most_frequent_entry def build_segment_tree(log_entries): return SegmentTree(log_entries) def query(segment_tree, left_bound, right_bound): return segment_tree.query(left_bound, right_bound)"},{"question":"# Question: Implementing a Custom Queue Using Two Stacks Context Implement a custom queue (FIFO) data structure using two stacks. This queue should support standard queue operations: `enqueue` to add an element to the back of the queue and `dequeue` to remove and return the front element. By utilizing two stacks, you will simulate the behavior of a queue. Task Create a class `QueueUsingStacks` that implements the following methods: `enqueue` to add an element, `dequeue` to remove an element, `peek` to return the front element without removing it, and `is_empty` to check if the queue is empty. Classes and Methods 1. **QueueUsingStacks** - **Constructor**: - `__init__(self) -> None`: Initializes two stacks, represented as lists. - **Add Element (Enqueue)**: - `enqueue(self, x: int) -> None`: Adds the element `x` to the back of the queue. - **Remove Element (Dequeue)**: - `dequeue(self) -> int`: Removes and returns the front element from the queue. If the queue is empty, it raises an `IndexError` with the message \\"Queue is empty\\". - **Peek Element**: - `peek(self) -> int`: Returns the front element of the queue without removing it. If the queue is empty, it raises an `IndexError` with the message \\"Queue is empty\\". - **Check if Empty**: - `is_empty(self) -> bool`: Returns `True` if the queue is empty, otherwise `False`. Input and Output Format - **Class: `QueueUsingStacks`** - **Method: `enqueue`** - **Input**: - `x`: Integer value to add to the queue. - **Output**: - None - **Method: `dequeue`** - **Input**: - None - **Output**: - Integer value of the removed front element. - **Method: `peek`** - **Input**: - None - **Output**: - Integer value of the front element. - **Method: `is_empty`** - **Input**: - None - **Output**: - Boolean indicating whether the queue is empty. Implementation Example ```python class QueueUsingStacks: def __init__(self) -> None: self.stack1 = [] self.stack2 = [] def enqueue(self, x: int) -> None: self.stack1.append(x) def dequeue(self) -> int: if self.is_empty(): raise IndexError(\\"Queue is empty\\") if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop() def peek(self) -> int: if self.is_empty(): raise IndexError(\\"Queue is empty\\") if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2[-1] def is_empty(self) -> bool: return not self.stack1 and not self.stack2 # Example Usage queue = QueueUsingStacks() queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) print(queue.dequeue()) # Output: 1 print(queue.peek()) # Output: 2 print(queue.is_empty()) # Output: False ``` Constraints - The queue methods should work efficiently, particularly ensuring the amortized time complexity for enqueue and dequeue operations is O(1). - Assume all integer inputs are within the range [-10^6, 10^6].","solution":"class QueueUsingStacks: def __init__(self) -> None: self.stack1 = [] self.stack2 = [] def enqueue(self, x: int) -> None: self.stack1.append(x) def dequeue(self) -> int: if self.is_empty(): raise IndexError(\\"Queue is empty\\") if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop() def peek(self) -> int: if self.is_empty(): raise IndexError(\\"Queue is empty\\") if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2[-1] def is_empty(self) -> bool: return not self.stack1 and not self.stack2 # Example Usage queue = QueueUsingStacks() queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) print(queue.dequeue()) # Output: 1 print(queue.peek()) # Output: 2 print(queue.is_empty()) # Output: False"},{"question":"**Binary Tree Inorder Traversal** Background: Binary trees are a fundamental data structure in computer science. Traversing a binary tree means visiting all the nodes in a specific order. An inorder traversal visits nodes in the following order: left subtree, root node, right subtree. # Problem Statement You are required to implement the inorder traversal of a binary tree. Given the root of a binary tree, your task is to return a list of values representing the inorder traversal of the tree\'s nodes. # Function Signature ```python def inorder_traversal(root: Optional[TreeNode]) -> List[int]: ``` # Input * `root`: A `TreeNode` representing the root of the binary tree. A `TreeNode` is defined as: ```python class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right ``` # Output * Returns a `List[int]` representing the inorder traversal of the binary tree\'s nodes. # Constraints * The number of nodes in the tree is in the range `[0, 100]`. * `-100 <= Node.val <= 100`. # Performance Requirements * The implementation should traverse the tree efficiently (time complexity of O(n) where n is the number of nodes). # Example ```python # Example 1 # Input: [1, None, 2, 3] # 1 # # 2 # / # 3 root = TreeNode(1, None, TreeNode(2, TreeNode(3))) assert inorder_traversal(root) == [1, 3, 2] # Example 2 # Input: [0] root = TreeNode(0) assert inorder_traversal(root) == [0] ``` # Notes * You can use either recursive or iterative methods to perform the inorder traversal. * Ensure you handle edge cases such as an empty tree where the root is `None`.","solution":"from typing import Optional, List class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right def inorder_traversal(root: Optional[TreeNode]) -> List[int]: Perform inorder traversal of a binary tree and return the values in a list. :param root: The root node of the binary tree. :return: List of node values in inorder traversal. def inorder(node: Optional[TreeNode], result: List[int]): if node: inorder(node.left, result) result.append(node.val) inorder(node.right, result) result = [] inorder(root, result) return result"},{"question":"# Problem Description You are provided with a list of integers where every element appears twice except for one. Implement a function to find that single one. Your solution should utilize bitwise operations to achieve optimal space and time complexity. # Function Signature ```python def find_single_number(nums: list[int]) -> int: ``` # Input * `nums` (list[int]): A non-empty list of integers where every element appears exactly twice, except for one element which appears exactly once. # Output * Returns an integer representing the single element that appears only once. # Constraints * The list `nums` is non-empty and contains at least one element. * The space complexity of the solution should be O(1). * The time complexity of the solution should be O(n). # Example ```python assert find_single_number([4, 1, 2, 1, 2]) == 4 assert find_single_number([2, 2, 1]) == 1 assert find_single_number([1]) == 1 ``` # Edge Cases * **Edge Case 1**: The list contains only one element. * **Edge Case 2**: Every element except one appears exactly twice in no particular order.","solution":"def find_single_number(nums: list[int]) -> int: Find the single number that appears only once in a list where all other numbers appear exactly twice. Args: nums (list[int]): The input list of integers. Returns: int: The single number that appears only once. single_number = 0 for num in nums: single_number ^= num # XOR each number with the result. return single_number"},{"question":"# Problem Description You have been given the task of creating a function that simulates the increment and decrement operations for a variable representing a counter. Your function will take a sequence of strings, where each string is either \\"inc\\" (indicating an increment operation) or \\"dec\\" (indicating a decrement operation). The objective is to apply these operations to the counter, which starts from zero, and return the final value of the counter. # Function Specification **Function Name**: `simulate_counter` **Input**: - `operations`: A list of strings, where ( 1 leq text{len}(operations) leq 10^5 ). Each string will be either \\"inc\\" or \\"dec\\". **Output**: - The function should return an integer which is the final value of the counter after performing all the operations. **Constraints**: - Assume the input list contains only the strings \\"inc\\" and \\"dec\\". - The operations list can include repeated increment and decrement operations. # Example ```python def simulate_counter(operations): >>> ops = [\\"inc\\", \\"inc\\", \\"dec\\", \\"inc\\"] >>> print(simulate_counter(ops)) 2 >>> ops = [\\"dec\\", \\"dec\\", \\"inc\\"] >>> print(simulate_counter(ops)) -1 >>> ops = [\\"inc\\", \\"inc\\", \\"inc\\", \\"dec\\", \\"dec\\", \\"inc\\"] >>> print(simulate_counter(ops)) 2 ``` # Requirements - Your function should handle the list of operations efficiently. - Consider edge cases such as an empty list or long sequences of the same operation. - Aim for a time complexity of O(n), where n is the number of operations in the list, and a constant space complexity O(1). # Notes - You are NOT allowed to use any external libraries for the operations. - Ensure that the function correctly handles scenarios with a mix of \\"inc\\" and \\"dec\\" operations and returns the expected counter value.","solution":"def simulate_counter(operations): Simulates a counter that can be incremented and decremented based on a list of operations. :param operations: List of strings, where each string is either \\"inc\\" or \\"dec\\" :return: The final value of the counter after performing all the operations Example: >>> ops = [\\"inc\\", \\"inc\\", \\"dec\\", \\"inc\\"] >>> simulate_counter(ops) 2 >>> ops = [\\"dec\\", \\"dec\\", \\"inc\\"] >>> simulate_counter(ops) -1 >>> ops = [\\"inc\\", \\"inc\\", \\"inc\\", \\"dec\\", \\"dec\\", \\"inc\\"] >>> simulate_counter(ops) 2 counter = 0 for operation in operations: if operation == \\"inc\\": counter += 1 elif operation == \\"dec\\": counter -= 1 return counter"},{"question":"# Scenario You have recently joined a software development team working on a text-editor application. One of the features requested by users is the ability to replace all occurrences of certain words with a specific new word. This has to be done efficiently even for large documents. # Problem Statement Write a function called `replace_words(text: str, word_list: List[str], replacement: str) -> str` that takes a string `text`, a list of words `word_list`, and a string `replacement`. The function should replace all exact occurrences of each word in `word_list` with the `replacement` string in the given `text`. The matching should be case-sensitive. # Function Signature ```python from typing import List def replace_words(text: str, word_list: List[str], replacement: str) -> str: ``` # Input * `text` (string, 1 ≤ len(text) ≤ 10000): The input string containing the text to be processed. * `word_list` (list of strings, 1 ≤ len(word_list) ≤ 1000): The list of words to be replaced. * `replacement` (string, 1 ≤ len(replacement) ≤ 100): The string that will replace each word in the `word_list`. # Output * Returns the modified string where each word from `word_list` has been replaced by `replacement`. # Examples ```python assert replace_words(\\"Hello world, welcome to the world of Python.\\", [\\"world\\", \\"Python\\"], \\"programming\\") == \\"Hello programming, welcome to the programming of programming.\\" assert replace_words(\\"The quick brown fox jumps over the lazy dog\\", [\\"quick\\", \\"lazy\\"], \\"nimble\\") == \\"The nimble brown fox jumps over the nimble dog\\" assert replace_words(\\"She sells sea shells by the sea shore.\\", [\\"sea\\", \\"shells\\"], \\"ocean\\") == \\"She sells ocean ocean by the ocean shore.\\" ``` # Constraints * Ensure the function replaces only exact matches of words from `word_list`. * The matching should be case-sensitive. * Non-alphabetic characters like punctuation and spaces should be left unchanged. # Notes * Think about how to efficiently search and replace words in the text. * Consider the performance implications for large `text` inputs and long `word_list`. # Hints * Using regular expressions (from the `re` module) can help match and replace whole words. * Iterating through the text and performing replacements might affect performance; think about efficient ways to handle this.","solution":"from typing import List import re def replace_words(text: str, word_list: List[str], replacement: str) -> str: Replaces all occurrences of each word in word_list with the replacement string in the given text. # Use regex to replace each word in the list with the replacement for word in word_list: # b is word boundary, ensuring full word replacement text = re.sub(rf\'b{word}b\', replacement, text) return text"},{"question":"# Divisible Sum Pairs Context: You are given an array of integers and a positive integer, k. Your task is to count the number of pairs (i, j) where i < j and the sum of arr[i] + arr[j] is divisible by k. Problem Statement: Write a function `divisible_sum_pairs` that takes in an array of integers and an integer k, then returns the number of (i, j) pairs where i < j and (arr[i] + arr[j]) % k == 0. Requirements: 1. Iterate through the given array to find all pairs (i, j). 2. Count the number of pairs whose sum is divisible by k. 3. Return the count of such pairs. Input: * A list of integers `arr` where 1 ≤ len(arr) ≤ 10^3. * An integer `k` where 1 ≤ k ≤ 100. Output: * An integer representing the number of pairs whose sum is divisible by k. Example: ```python arr = [1, 2, 3, 4, 5, 6] k = 3 print(divisible_sum_pairs(arr, k)) # Output should be 5 ``` Explanation: - The pairs (i, j) are: (0, 2) -> (1 + 3 = 4), (1, 4) -> (2 + 5 = 7), (2, 5) -> (3 + 6 = 9), (3, 5) -> (4 + 6 = 10), (4, 5) -> (5 + 6 = 11). Function Signature: ```python def divisible_sum_pairs(arr: list, k: int) -> int: # Implement the function to count pairs as described. ```","solution":"def divisible_sum_pairs(arr, k): Returns the number of pairs (i, j) where i < j and (arr[i] + arr[j]) % k == 0. count = 0 n = len(arr) # Go through each pair (i, j) for i in range(n): for j in range(i + 1, n): if (arr[i] + arr[j]) % k == 0: count += 1 return count"},{"question":"# Matrix Transposition Context Matrix transposition is a common operation in many fields including mathematics, computer science, and data analysis. It involves flipping a matrix over its diagonal, swapping the row and column indices of each element. Problem Statement Implement a Python function `transpose_matrix(matrix: list) -> list` that takes a 2D list representing a matrix and returns its transpose. The transpose of a matrix is obtained by swapping rows with columns. Function Signature: ```python def transpose_matrix(matrix: list) -> list: pass ``` Input: - `matrix` (list of list of integers): a 2D matrix of size `m x n` where `1 ≤ m, n ≤ 1000`. Output: - A 2D list representing the transposed matrix. Constraints: - The input matrix can have a different number of rows and columns. - The values in the matrix will be integers. - You are not allowed to use in-built functions for matrix transposition. Performance Requirements: - The solution should efficiently handle the matrix of maximum size 1000 x 1000. Examples: ```python >>> transpose_matrix([[1]]) [[1]] >>> transpose_matrix([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose_matrix([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] >>> transpose_matrix([[5, 8, -20], [9, 7, 3]]) [[5, 9], [8, 7], [-20, 3]] ``` Use the provided test cases to validate your solution.","solution":"def transpose_matrix(matrix: list) -> list: if not matrix: return [] rows = len(matrix) cols = len(matrix[0]) transpose = [[0] * rows for _ in range(cols)] for i in range(rows): for j in range(cols): transpose[j][i] = matrix[i][j] return transpose"},{"question":"# Coding Question Context You are asked to write a function that will compute the product of all prime numbers up to a given integer `n`. Prime numbers are those greater than 1 that have no divisors other than 1 and themselves. Problem Statement Write a function called `prime_product` that takes one argument: 1. `n` (an integer): The upper bound of the range (inclusive). Your function should return the product of all prime numbers less than or equal to `n`. Input Format * `n` (2 <= n <= 10^6): An integer specifying the upper limit (inclusive). Output Format * An integer representing the product of all prime numbers less than or equal to `n`. Example * Example 1: ```python prime_product(10) # Should return 210 ``` Explanation: The prime numbers <= 10 are [2, 3, 5, 7], and their product is 2*3*5*7 = 210. * Example 2: ```python prime_product(5) # Should return 30 ``` Explanation: The prime numbers <= 5 are [2, 3, 5], and their product is 2*3*5 = 30. Constraints and Performance Requirements - Ensure your solution efficiently handles the upper limit. - Use optimal algorithms to identify prime numbers such as the Sieve of Eratosthenes.","solution":"def prime_product(n): Returns the product of all prime numbers up to and including `n`. if n < 2: return 1 sieve = [True] * (n + 1) sieve[0] = sieve[1] = False for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n+1, start): sieve[multiple] = False product = 1 for number in range(2, n+1): if sieve[number]: product *= number return product"},{"question":"# Coding Assessment Question Scenario As a software developer, you need to perform various operations on strings frequently. One common task is identifying the longest substring within a given string that consists of non-repeating characters. This operation is crucial for optimizing search functionalities and enhancing user experience. Problem Statement Implement a function `find_longest_unique_substring(s: str) -> str` that takes a string `s` as input and returns the longest substring without repeating characters. If there are multiple substrings of the same maximum length, return the one that appears first. # Input: * A string `s` consisting of lowercase English letters. # Output: * A string representing the longest substring with all unique characters. # Constraints: * (1 leq text{length of } s leq 10^5) # Example: ```python s1 = \\"abcabcbb\\" assert find_longest_unique_substring(s1) == \\"abc\\" s2 = \\"bbbbb\\" assert find_longest_unique_substring(s2) == \\"b\\" s3 = \\"pwwkew\\" assert find_longest_unique_substring(s3) == \\"wke\\" ``` Function Signature ```python def find_longest_unique_substring(s: str) -> str: pass ``` # Notes: * The solution should efficiently handle large strings and ensure correct memory usage for optimal performance. * Use a sliding window approach to find the longest substring without repeating characters efficiently.","solution":"def find_longest_unique_substring(s: str) -> str: Function to find the longest substring without repeating characters. start = 0 max_length = 0 max_substring = \\"\\" used_chars = {} for end in range(len(s)): if s[end] in used_chars: start = max(start, used_chars[s[end]] + 1) used_chars[s[end]] = end current_length = end - start + 1 if current_length > max_length: max_length = current_length max_substring = s[start:end+1] return max_substring"},{"question":"# Coding Assessment Question You are tasked with writing a Python function that demonstrates the understanding of both list manipulation and dictionary operations to parse and analyze student grades, then generate a summary report. Specifically, you will be creating a function that processes a list of dictionaries containing student grades and calculates the class average, highest scoring student, and lowest scoring student. Requirements * Write a function `summarize_grades(student_grades: List[Dict[str, Union[str, float]]]) -> Dict[str, Union[float, Dict[str, float]]]` that takes a list of dictionaries representing student grades and returns a summary dictionary. * Each dictionary in the input list contains two keys: - `\'name\'` (str): The student\'s name. - `\'grade\'` (float): The student\'s grade (0.0 to 100.0). * The summary dictionary should contain: - `\'class_average\'` (float): The average grade of the class. - `\'highest_score\'` (dict): A dictionary with the student\'s name and grade who scored the highest. - `\'lowest_score\'` (dict): A dictionary with the student\'s name and grade who scored the lowest. Input * `student_grades` (List[Dict[str, Union[str, float]]]): A list of dictionaries containing student names and their respective grades. Output * A dictionary with the class average, highest scoring student, and lowest scoring student. Constraints * The function should handle cases where there are no grades gracefully. * Ensure to handle a variety of grade inputs, including edge cases such as all students having the same grade. Example ```python student_grades = [ {\'name\': \'Alice\', \'grade\': 88.5}, {\'name\': \'Bob\', \'grade\': 91.0}, {\'name\': \'Charlie\', \'grade\': 79.5}, {\'name\': \'David\', \'grade\': 85.3} ] summary = summarize_grades(student_grades) print(summary) ``` Expected Output: ```python { \'class_average\': 86.075, \'highest_score\': {\'name\': \'Bob\', \'grade\': 91.0}, \'lowest_score\': {\'name\': \'Charlie\', \'grade\': 79.5} } ``` Submission Please submit a Python file containing the implementation of the `summarize_grades` function. Include appropriate error handling, comments explaining important sections of your code, and any assumptions you\'ve made.","solution":"from typing import List, Dict, Union def summarize_grades(student_grades: List[Dict[str, Union[str, float]]]) -> Dict[str, Union[float, Dict[str, float]]]: This function processes a list of dictionaries containing student grades and returns a summary that includes the class average, the student with the highest grade, and the student with the lowest grade. :param student_grades: List[Dict[str, Union[str, float]]] - A list of dictionaries containing \'name\' and \'grade\' :return: Dict[str, Union[float, Dict[str, float]]] - A dictionary with keys \'class_average\', \'highest_score\', and \'lowest_score\' if not student_grades: return { \'class_average\': 0.0, \'highest_score\': {\'name\': \'\', \'grade\': 0.0}, \'lowest_score\': {\'name\': \'\', \'grade\': 0.0} } total_grade = 0.0 highest_score = {\\"name\\": \\"\\", \\"grade\\": float(\'-inf\')} lowest_score = {\\"name\\": \\"\\", \\"grade\\": float(\'inf\')} for student in student_grades: name, grade = student[\'name\'], student[\'grade\'] total_grade += grade if grade > highest_score[\'grade\']: highest_score = {\\"name\\": name, \\"grade\\": grade} if grade < lowest_score[\'grade\']: lowest_score = {\\"name\\": name, \\"grade\\": grade} class_average = total_grade / len(student_grades) return { \'class_average\': class_average, \'highest_score\': highest_score, \'lowest_score\': lowest_score }"},{"question":"# Coding Assessment Question Context Having learned various ways to manipulate arrays and optimize operations on them, it’s crucial now to apply that knowledge in a practical scenario. Your task is to implement an algorithm that finds the longest increasing subsequence in an array. The Task Using the knowledge of dynamic programming, implement an efficient algorithm to find the length of the longest increasing subsequence in a given array of integers `arr`. Input A single list of integers `arr` where `1 ≤ len(arr) ≤ 10^5` and `-10^9 ≤ arr[i] ≤ 10^9` for all elements `arr[i]`. Output An integer representing the length of the longest increasing subsequence in the array. Performance Requirements - Your solution should be efficient: aim for O(n log(n)) time complexity. # Implementation Guide 1. Implement the main function `longest_increasing_subsequence(arr: List[int]) -> int`: * Use binary search to maintain a dynamic array that helps in finding the length efficiently. * Handle edge cases where `arr` is empty. * Iterate through the array and update the dynamic array based on the current element. * Return the length of the dynamic array representing the longest increasing subsequence. 2. Test your implementation with various inputs to ensure correctness. # Example Usage ```python def longest_increasing_subsequence(arr: List[int]) -> int: # Your code here # Example usage: print(longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18])) # Output: 4 print(longest_increasing_subsequence([0, 1, 0, 3, 2, 3])) # Output: 4 print(longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7])) # Output: 1 ```","solution":"from typing import List import bisect def longest_increasing_subsequence(arr: List[int]) -> int: Returns the length of the longest increasing subsequence in arr. if not arr: return 0 # Dynamic array to store the increasing subsequence dp = [] for num in arr: idx = bisect.bisect_left(dp, num) if idx < len(dp): dp[idx] = num else: dp.append(num) return len(dp)"},{"question":"# Coding Assessment Question Context In programming, it\'s often useful to manipulate strings in various ways. One common operation is to encode or decode strings based on specific rules. A well-known example is run-length encoding (RLE), where sequences of the same character are stored as a single character followed by the count of repetitions. Task Implement the `run_length_encode` function that performs run-length encoding on an input string. If the function encounters characters that repeat more than once consecutively, it should compress them into the character followed by the number of repetitions. Function Signature ```python def run_length_encode(input_str: str) -> str: Encodes the input string using run-length encoding. @param input_str: a string to be encoded using RLE @return: the run-length encoded string ``` Input and Output - **Input**: A single string `input_str` that can contain any printable characters. - **Output**: A string which is the run-length encoded version of `input_str`. Constraints - The input string can be empty or very large. - The encoded string should only contain printable characters. Performance - Optimize the function for clarity and efficiency. - Aim for a linear time complexity relative to the length of the input string. Example Use Cases ```python print(run_length_encode(\\"aaabccddd\\")) # Output: \\"a3bc2d3\\" print(run_length_encode(\\"hello\\")) # Output: \\"hel2o\\" print(run_length_encode(\\"wwwwaaad\\")) # Output: \\"w4a3d\\" print(run_length_encode(\\"a\\")) # Output: \\"a\\" print(run_length_encode(\\"\\")) # Output: \\"\\" ``` Error Handling - Assume that the input will always be a valid string. This question integrates seamlessly with the original set by maintaining a similar level of complexity and style, focusing on string manipulation rather than numerical properties. It assesses the candidate\'s ability to implement encoding algorithms efficiently.","solution":"def run_length_encode(input_str: str) -> str: if not input_str: return \\"\\" encoded = [] prev_char = input_str[0] count = 1 for i in range(1, len(input_str)): if input_str[i] == prev_char: count += 1 else: if count > 1: encoded.append(f\\"{prev_char}{count}\\") else: encoded.append(prev_char) prev_char = input_str[i] count = 1 if count > 1: encoded.append(f\\"{prev_char}{count}\\") else: encoded.append(prev_char) return \'\'.join(encoded)"},{"question":"# Problem Statement Your task is to create a Python function that calculates the salary details for employees based on their hourly rate and the number of hours worked. Additionally, you need to handle overtime pay, which is paid at 1.5 times the regular hourly rate for any hours worked beyond 40 hours per week. # Requirements 1. **Function Name**: `calculate_salary` 2. **Input**: - `hourly_rate` (float): The employee\'s hourly wage. - `hours_worked` (float): The total number of hours worked in the week. 3. **Output**: - A dictionary containing three keys: - `base_pay` (float): The pay for the first 40 hours. - `overtime_pay` (float): The pay for any hours worked beyond 40. - `total_pay` (float): The total pay for the week. 4. **Constraints**: - Overtime hours are any hours worked beyond 40 hours in a week. - Overtime pay rate is 1.5 times the regular hourly rate. - Assume valid inputs; no need to handle negative values or non-numeric inputs. # Function Signature ```python def calculate_salary(hourly_rate: float, hours_worked: float) -> dict[str, float]: pass ``` # Example Suppose the hourly rate is 20 and the employee worked 45 hours, the expected output should be: ```python { \\"base_pay\\": 800.0, # 40 * 20 \\"overtime_pay\\": 150.0, # 5 * 20 * 1.5 \\"total_pay\\": 950.0 # 800 + 150 } ``` # Notes - Break down the hours worked into regular hours (up to 40 hours) and overtime hours (beyond 40 hours). - Calculate the base pay, overtime pay, and total pay accordingly. - Use appropriate data types for your calculations to ensure accurate financial computations. # Testing - Test your function with various inputs to ensure it handles regular and overtime calculations correctly. - Consider edge cases, such as exactly 40 hours worked and zero hours worked.","solution":"def calculate_salary(hourly_rate: float, hours_worked: float) -> dict[str, float]: Calculates the salary details for the given hourly rate and hours worked, including base pay, overtime pay, and total pay. Args: - hourly_rate (float): Employee\'s hourly wage. - hours_worked (float): Total hours worked in the week. Returns: - dict: Contains base pay, overtime pay, and total pay. base_hours = min(40, hours_worked) overtime_hours = max(0, hours_worked - 40) base_pay = base_hours * hourly_rate overtime_pay = overtime_hours * hourly_rate * 1.5 total_pay = base_pay + overtime_pay return { \\"base_pay\\": base_pay, \\"overtime_pay\\": overtime_pay, \\"total_pay\\": total_pay }"},{"question":"# Context You are building a simple text processing library and need a function to count the occurrences of each word in a given string. The function should ignore case, remove any punctuation, and return a dictionary with words as keys and their counts as values. # Task Implement a function `word_count` that counts the occurrences of each word in a given string after normalizing the case and removing punctuation. # Requirements * Your function should take one parameter: a string `text`. * Normalize the input string to lowercase. * Remove punctuation from the input string. * Return a dictionary where the keys are words and the values are their counts in the string. * Add a docstring and appropriate error handling as seen in the provided code snippets. # Function Signature ```python def word_count(text: str) -> dict: pass ``` # Example Usage ```python >>> word_count(\\"Hello, world! Hello!!\\") {\'hello\': 2, \'world\': 1} >>> word_count(\\"Python\'s standard library is immense; Python\'s capabilities are vast.\\") {\'pythons\': 2, \'standard\': 1, \'library\': 1, \'is\': 1, \'immense\': 1, \'capabilities\': 1, \'are\': 1, \'vast\': 1} >>> word_count(\\"Easy come, easy go.\\") {\'easy\': 2, \'come\': 1, \'go\': 1} ``` # Constraints and Considerations * Assume words are separated by whitespace and/or punctuation. * Use the `re` module for efficient removal of punctuation. * Ensure your solution handles the input string in a case-insensitive manner and correctly counts word occurrences regardless of original case or punctuation presence.","solution":"import re from collections import defaultdict def word_count(text: str) -> dict: Counts the occurrences of each word in a given string after normalizing the case and removing punctuation. Parameters: text (str): The input string to process. Returns: dict: A dictionary with words as keys and their counts as values. # Normalize the string to lowercase text = text.lower() # Remove punctuation using regex text = re.sub(r\'[^ws]\', \'\', text) # Split the text into words words = text.split() # Count occurrences of each word word_counts = defaultdict(int) for word in words: word_counts[word] += 1 return dict(word_counts)"},{"question":"# Question: Generating Fibonacci Numbers Using a Generator You are tasked with generating Fibonacci numbers using Python\'s generator functionality. A Fibonacci sequence starts with 0 and 1, with each subsequent number being the sum of the previous two. Your job is to implement a generator function that yields an indefinite number of Fibonacci numbers. Function Signature ```python def fibonacci_generator() -> \'generator\': ``` Output - A generator that yields Fibonacci numbers indefinitely. Constraints - The generator function should be designed to support generating an infinite sequence of Fibonacci numbers. - It should efficiently compute each term in the sequence without unnecessary recomputation of previous terms. Example ```python >>> fib_gen = fibonacci_generator() >>> next(fib_gen) 0 >>> next(fib_gen) 1 >>> next(fib_gen) 1 >>> next(fib_gen) 2 >>> next(fib_gen) 3 >>> next(fib_gen) 5 >>> next(fib_gen) 8 ``` Performance Requirements - Ensure the generator runs efficiently and generates each Fibonacci number in constant time (O(1) for generating the next number). - The implementation should be memory efficient, storing only the minimum necessary state required to generate the sequence. # Additional Guidelines - Use comments to explain the logic of your generator, especially how it maintains state across iterations. - Handle potential edge cases gracefully, ensuring the generator starts from the beginning of the Fibonacci sequence. ```python def fibonacci_generator(): a, b = 0, 1 while True: yield a a, b = b, a + b # Example usage fib_gen = fibonacci_generator() print(next(fib_gen)) # 0 print(next(fib_gen)) # 1 print(next(fib_gen)) # 1 print(next(fib_gen)) # 2 print(next(fib_gen)) # 3 ```","solution":"def fibonacci_generator(): A generator function that yields Fibonacci numbers indefinitely. Fibonacci sequence starts with 0 and 1, and each subsequent number is the sum of the previous two. a, b = 0, 1 while True: yield a a, b = b, a + b # Example usage # fib_gen = fibonacci_generator() # print(next(fib_gen)) # 0 # print(next(fib_gen)) # 1 # print(next(fib_gen)) # 1 # print(next(fib_gen)) # 2 # print(next(fib_gen)) # 3"},{"question":"# Problem: Evaluate Postfix Expressions Context: A postfix expression (also known as Reverse Polish Notation) is a mathematical notation in which every operator follows all of its operands. This notation is useful for computing expressions in computer science without the need for parentheses to denote operator precedence. Your task is to evaluate postfix expressions using a stack-based approach. Task: Write a function `evaluate_postfix(expression: str) -> int` that evaluates a given postfix expression and returns the result as an integer. Function Signature: ```python def evaluate_postfix(expression: str) -> int: ``` Input: * `expression`: A string representing a valid postfix expression. The string is non-empty and consists of integers (positive or negative) and the operators `+`, `-`, `*`, and `/`. Operands and operators are separated by a single space. Output: * Returns the result of evaluating the postfix expression as an integer. Constraints: * The input expression is valid and the input integers can fit within the limits of a standard 32-bit signed integer. Example: ```python >>> evaluate_postfix(\\"3 4 +\\") 7 >>> evaluate_postfix(\\"5 1 2 + 4 * + 3 -\\") 14 >>> evaluate_postfix(\\"7 8 + 3 2 + /\\") 3 ``` Additional Notes: * Division in this function should be an integer division, i.e., it should truncate toward zero. * The function should handle expressions with negative integers correctly. * Use a stack-based approach to evaluate the postfix expression.","solution":"def evaluate_postfix(expression: str) -> int: Evaluate a given postfix expression and return the result as an integer. stack = [] tokens = expression.split() for token in tokens: if token in \\"+-*/\\": b = stack.pop() a = stack.pop() if token == \'+\': stack.append(a + b) elif token == \'-\': stack.append(a - b) elif token == \'*\': stack.append(a * b) elif token == \'/\': stack.append(int(a / b)) # Perform integer division else: stack.append(int(token)) return stack[0]"},{"question":"# Question Objective Develop a function to compute the Euclidean Norm (L2 Norm) of a vector. This is a common operation in various domains such as machine learning, physics, and computer graphics. Scenario Given a vector of numeric values, compute its Euclidean Norm which is defined as the square root of the sum of the squared values of its components. Function Signature ```python def euclidean_norm(vector: np.ndarray) -> float: ``` # Input - `vector`: A 1D numpy array of numeric values. # Output - Return a single float value representing the Euclidean Norm of the input vector. # Constraints - The input vector length can be up to (10^6) elements. - The vector can contain both positive and negative numbers. # Examples ```python >>> vector = np.array([3, 4]) >>> euclidean_norm(vector) 5.0 >>> vector = np.array([1, 2, 2]) >>> euclidean_norm(vector) 3.0 ``` # Detailed Breakdown 1. **Vector Input**: Process the input vector to compute the Euclidean Norm. 2. **Computing Norm**: - Square each component of the vector. - Sum all the squared values. - Take the square root of the sum to get the Euclidean Norm. Your implementation should be efficient and handle large vectors as specified in the constraints.","solution":"import numpy as np def euclidean_norm(vector: np.ndarray) -> float: Computes the Euclidean Norm (L2 Norm) of a given vector. Parameters: vector (np.ndarray): Input 1D numpy array of numeric values. Returns: float: Euclidean Norm of the vector. return np.sqrt(np.sum(vector ** 2))"},{"question":"# Coding Assessment Question Scenario You are developing an analytics tool that performs various statistical operations on a set of numbers. Given a list of integers, your tool should be able to calculate the mean, median, mode, and variance of the numbers. Problem Statement Implement functions to calculate the mean, median, mode, and variance of a list of integers. Function Requirements and Constraints 1. **Function Signature** ```python def calculate_mean(numbers: List[int]) -> float def calculate_median(numbers: List[int]) -> float def calculate_mode(numbers: List[int]) -> List[int] def calculate_variance(numbers: List[int]) -> float ``` 2. **Parameters**: * `numbers` - a list of integers. 3. **Return Values**: * For `calculate_mean`: the mean of the list as a float. * For `calculate_median`: the median of the list as a float. * For `calculate_mode`: a list of integers representing the mode(s) of the list. If there are multiple modes, return all of them in ascending order. * For `calculate_variance`: the variance of the list as a float. Example Cases * `calculate_mean([1, 2, 3, 4, 5])` should return `3.0` * `calculate_median([1, 2, 3, 4, 5])` should return `3.0` * `calculate_median([1, 2, 3, 4, 5, 6])` should return `3.5` * `calculate_mode([1, 2, 2, 3, 4, 4, 4, 5])` should return `[4]` * `calculate_mode([1, 1, 2, 2, 3, 3])` should return `[1, 2, 3]` * `calculate_variance([1, 2, 3, 4, 5])` should return `2.5` # Function Descriptions 1. **Function: `calculate_mean(numbers: List[int]) -> float`** - Calculates the mean (average) of the list by summing all the elements and dividing by the number of elements. 2. **Function: `calculate_median(numbers: List[int]) -> float`** - Calculates the median by sorting the list and returning the middle element if the list length is odd, or the average of the two middle elements if the list length is even. 3. **Function: `calculate_mode(numbers: List[int]) -> List[int]** - Calculates the mode(s) by finding the number(s) that appear most frequently in the list. If there are multiple modes, return them in ascending order. 4. **Function: `calculate_variance(numbers: List[int]) -> float`** - Calculates the variance by finding the average of the squared differences from the mean. Use the given examples to test your functions, and ensure you handle edge cases like empty lists and lists with all identical elements.","solution":"from typing import List from collections import Counter import numpy as np def calculate_mean(numbers: List[int]) -> float: if not numbers: return 0.0 return sum(numbers) / len(numbers) def calculate_median(numbers: List[int]) -> float: if not numbers: return 0.0 numbers.sort() n = len(numbers) mid = n // 2 if n % 2 == 0: return (numbers[mid - 1] + numbers[mid]) / 2.0 else: return numbers[mid] def calculate_mode(numbers: List[int]) -> List[int]: if not numbers: return [] frequency = Counter(numbers) max_count = max(frequency.values()) return sorted([num for num, count in frequency.items() if count == max_count]) def calculate_variance(numbers: List[int]) -> float: if not numbers: return 0.0 mean_val = calculate_mean(numbers) return sum((x - mean_val) ** 2 for x in numbers) / len(numbers)"},{"question":"# Task Implement a function to find the length of the longest contiguous subarray with an equal number of 0s and 1s in a given binary array. # Requirements: - **Input**: A binary numpy array consisting of 0s and 1s. - **Output**: An integer representing the length of the longest contiguous subarray. # Constraints: - The length of the numpy array will be between (1) and (10^5). # Function Signature: ```python def find_max_length(nums: np.ndarray) -> int: pass ``` # Example: ```python import numpy as np # Example 1 input_array = np.array([0, 1, 0]) # Expected output: 2 (because the subarray [0, 1] contains equal number of 0s and 1s) # Example 2 input_array = np.array([0, 1, 0, 1, 1, 0, 0]) # Expected output: 6 (because the subarray [0, 1, 0, 1, 1, 0] contains equal number of 0s and 1s) ``` # Implementation Notes: 1. Use an efficient algorithm to ensure the function handles the upper limit of the input size within acceptable performance constraints. 2. Consider using a hashmap to store the cumulative sum at each index. # Test Cases: You should include test cases in your implementation to verify the correctness of your function. The function should pass provided example test cases as well as additional edge cases like an array with all 0s or all 1s.","solution":"import numpy as np def find_max_length(nums: np.ndarray) -> int: max_length = 0 cumulative_sum = 0 sum_to_index = {0: -1} # Initialize with 0 sum at index -1 to handle full array case for i in range(len(nums)): if nums[i] == 0: cumulative_sum -= 1 else: cumulative_sum += 1 if cumulative_sum in sum_to_index: length = i - sum_to_index[cumulative_sum] max_length = max(max_length, length) else: sum_to_index[cumulative_sum] = i return max_length"},{"question":"# Unique Character Count **Objective**: Implement a function that takes a string input and returns the number of unique characters in the string, disregarding case and ignoring non-alphanumeric characters. **Function Signature**: ```python def count_unique_characters(text: str) -> int: Counts the number of unique alphanumeric characters in the given text. Args: text (str): A string containing the input text. Returns: int: The number of unique alphanumeric characters in the text. ``` **Input**: - A string `text` (1 ≤ len(text) ≤ 10^5) that may contain letters, digits, whitespace, and punctuation. **Output**: - An integer representing the number of unique alphanumeric characters in the input text. **Constraints**: - Characters are case-insensitive (i.e., \'A\' and \'a\' should be considered the same). - Ignore non-alphanumeric characters such as punctuation and whitespace. **Example**: ```python text = \\"Hello, World! 123\\" result = count_unique_characters(text) # Expected Output: 10 (Unique characters: h, e, l, o, w, r, d, 1, 2, 3) ``` **Scenario**: You are developing a feature for a text analysis tool where it\'s necessary to determine the diversity of characters in the text input. This involves normalizing the input by case sensitivity and filtering out any non-alphanumeric characters before counting. **Performance Requirement**: - The solution should efficiently handle the input size up to the specified limit within a reasonable runtime and memory usage. **Testing**: 1. Given text with various upper and lower case letters to ensure correct case insensitivity. 2. Text including a mix of alphanumeric characters and special characters. 3. Text with significant whitespace or punctuation placed between characters.","solution":"def count_unique_characters(text: str) -> int: Counts the number of unique alphanumeric characters in the given text. Args: text (str): A string containing the input text. Returns: int: The number of unique alphanumeric characters in the text. # Convert the text to lowercase and filter out non-alphanumeric characters filtered_text = \'\'.join(char.lower() for char in text if char.isalnum()) # Use a set to keep track of unique characters unique_characters = set(filtered_text) # Return the number of unique characters return len(unique_characters)"},{"question":"# Question: Finding Shortest Path in a Weighted Grid You are given a weighted grid where each cell represents the cost to step on that cell. Your task is to find the minimum cost to travel from the top-left corner to the bottom-right corner of the grid. You can only move right or down. Function Signature ```python def min_path_cost(grid: List[List[int]]) -> int: pass ``` # Input: - `grid`: A list of lists of integers representing a 2D grid where `grid[i][j]` is the cost to step on the cell `(i, j)`. # Output: - An integer representing the minimum cost to travel from the top-left to the bottom-right of the grid. # Constraints: - The grid will have at most 500 rows and 500 columns. - Each cell will have a cost between 1 and 1000. # Examples: **Example 1:** ```python grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert min_path_cost(grid) == 7 ``` **Example 2:** ```python grid = [ [1, 2, 5], [3, 2, 1] ] assert min_path_cost(grid) == 6 ``` # Instructions: 1. Use dynamic programming to build up the minimum cost to each cell. 2. Initialize the cost at the top-left corner as the starting point. 3. Iterate through each cell, update the cost to reach that cell from either the left cell or the cell above it. 4. Keep track of the minimum cost required to reach each cell. 5. Return the minimum cost to reach the bottom-right corner of the grid. 6. Ensure your solution is optimal in terms of both time and space complexity.","solution":"from typing import List def min_path_cost(grid: List[List[int]]) -> int: Calculate the minimum cost to travel from the top-left to the bottom-right corner of the grid. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) # Create a 2D dp array to store the minimum cost to reach each cell dp = [[0]*cols for _ in range(rows)] dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the dp array for i in range(1, rows): for j in range(1, cols): dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) return dp[rows-1][cols-1]"},{"question":"# LRU Cache Implementation with Cache Miss Count Objective: Implement an LRU (Least Recently Used) Cache and count the cache miss events. Description: You are required to design and implement an LRU Cache class. The cache should store a fixed number of key-value pairs and evict the least recently used entries when the capacity exceeds. Additionally, implement a function to count how many cache miss events have occurred. Requirements: * Define the LRU Cache structure and initialize it with a given capacity. * Implement functions to: * Get the value of a key from the cache. * Put a key-value pair into the cache. * Retrieve the number of cache miss events. Function Signatures: ```python class LRUCache: def __init__(self, capacity: int) -> None: Initialize the LRU cache with the given capacity. pass def get(self, key: int) -> int: Retrieve the value of the key if it exists in the cache, otherwise return -1. pass def put(self, key: int, value: int) -> None: Insert or update the key with the given value. If the cache exceeds its capacity, it should invalidate the least recently used item. pass def get_miss_count(self) -> int: Return the number of cache miss events that have occurred. pass ``` Example: ```python # Initializing the LRU cache with a capacity of 2 cache = LRUCache(2) # Putting key-value pairs into the cache cache.put(1, 1) cache.put(2, 2) # Getting the value of key 1 assert cache.get(1) == 1 # returns 1 # Getting the value of key 3, which is not in the cache, so it returns -1 (cache miss) assert cache.get(3) == -1 # Adding another key-value pair, causing the least recently used key (2) to be evicted cache.put(3, 3) # Getting the value of key 2, which has been evicted, so it returns -1 (cache miss) assert cache.get(2) == -1 # Retrieving the number of cache miss events assert cache.get_miss_count() == 2 # two cache misses (for keys 3 and 2) ``` Constraints: * The maximum capacity of the cache will be between 1 and 10^4. * The keys and values will be positive integers. * The cache operations (`get` and `put`) should be performed in constant time (O(1)).","solution":"class LRUCache: def __init__(self, capacity: int) -> None: self.capacity = capacity self.cache = {} self.order = [] self.miss_count = 0 def get(self, key: int) -> int: if key in self.cache: self.order.remove(key) self.order.append(key) return self.cache[key] else: self.miss_count += 1 return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self.order.remove(key) elif len(self.cache) >= self.capacity: least_used_key = self.order.pop(0) del self.cache[least_used_key] self.cache[key] = value self.order.append(key) def get_miss_count(self) -> int: return self.miss_count"},{"question":"# Problem Statement Given a string `s` and a list of words `dictionary`, your task is to find the longest word in `dictionary` that can be formed by deleting some (possibly zero) characters of the string `s` without reordering the remaining characters. If there are multiple possible results, return the longest word with the smallest lexicographical order. # Function Signature ```python def find_longest_word(s: str, dictionary: List[str]) -> str: pass ``` # Input: - `s` (str): A string from which you will be deleting characters. - `dictionary` (List[str]): A list of words to be checked against the string `s`. # Output: - Returns the longest word that can be formed from the string `s` by deleting characters. If there are multiple, return the lexicographically smallest one. # Example: ```python >>> find_longest_word(\\"abpcplea\\", [\\"ale\\", \\"apple\\", \\"monkey\\", \\"plea\\"]) \\"apple\\" >>> find_longest_word(\\"abpcplea\\", [\\"a\\", \\"b\\", \\"c\\"]) \\"a\\" ``` # Constraints: - The input string `s` length will be in the range [1, 1000]. - The length of `dictionary` will be in the range [1, 1000]. - The length of each word in `dictionary` will be in the range [1, 100]. # Requirements: - Ensure the solution is efficient even with the largest bounds. # Notes: - The characters of the words are always lowercase letters. - If no word from the dictionary can be formed, return an empty string. This problem requires you to work with string manipulation and requires efficient checking of subsequences.","solution":"from typing import List def find_longest_word(s: str, dictionary: List[str]) -> str: def is_subsequence(x): it = iter(s) return all(c in it for c in x) dictionary.sort(key = lambda x: (-len(x), x)) for word in dictionary: if is_subsequence(word): return word return \\"\\""},{"question":"# Scenario Bob is developing a game where the player needs to jump across a series of platforms. He wants to find out the minimum number of jumps needed to reach the end of the platform sequence. Each platform has a certain jump length value, which determines the maximum number of platforms the player can directly jump forward to from that platform. # Coding Task Write a function `min_jumps(plat: list) -> int` that takes a list of integers representing the platforms and their respective jump lengths and returns the minimum number of jumps needed to reach the last platform. If the last platform is not reachable, return `-1`. # Input and Output Format - **Input**: - `plat` (a list of integers, length 1 ≤ len(plat) ≤ 1000) - **Output**: - An integer representing the minimum number of jumps to reach the end of the platform list, or `-1` if the end is not reachable. # Constraints and Assumptions: - Each integer in the `plat` list indicates the maximum number of platforms one can jump forward to from that position. - The list will always contain at least one platform. - If a platform has a jump length of 0 and the player is forced to jump from that platform when it\'s not the last platform, the end will not be reachable, and the function should return `-1`. # Example - Example 1: - `plat = [2, 3, 1, 1, 4]` - Output: `2` (optimal jumps are from index 0 to index 1, then from index 1 to index 4) - Example 2: - `plat = [2, 1, 1, 0, 4]` - Output: `-1` (it is not possible to reach the last platform) **Note**: The function should handle scenarios where the list is precisely tailored so that reaching the last platform just barely requires the optimal number of jumps considering the constraints of each platform\'s maximum jump length.","solution":"def min_jumps(plat: list) -> int: if len(plat) == 1: return 0 jumps = 0 current_end = 0 farthest = 0 for i in range(len(plat)): farthest = max(farthest, i + plat[i]) if farthest >= len(plat) - 1: jumps += 1 break if i == current_end: if current_end == farthest: return -1 jumps += 1 current_end = farthest return jumps"},{"question":"# Scenario You are developing a simple reservation system for a small airline where customers can book flights. Each booking contains a customer name and a flight number. You need to implement a function that tracks bookings and returns the list of flight numbers that have multiple bookings. # Task Write a function `find_multiple_bookings` to solve this problem. The function should take a list of tuples representing bookings and return a list of flight numbers that have more than one booking. # Input/Output - **Input**: A list of tuples where each tuple contains a string representing the customer\'s name and an integer representing the flight number. - **Output**: The function should return a list of integers representing flight numbers with multiple bookings, sorted in ascending order. # Constraints - Assume there can be at most 1000 bookings. - Flight numbers and customer names are case-insensitive when checking for multiple bookings. # Function Signature ```python def find_multiple_bookings(bookings: List[Tuple[str, int]]) -> List[int]: ``` # Example ```python bookings = [ (\\"Alice\\", 101), (\\"Bob\\", 202), (\\"Alice\\", 101), (\\"Charlie\\", 303), (\\"Alice\\", 202), (\\"David\\", 202), ] print(find_multiple_bookings(bookings)) # Output: [101, 202] ``` # Notes - Use appropriate data structures to count the occurrences of each flight number. - Ensure the output is sorted in ascending order. - Consider edge cases such as an empty list of bookings or all bookings being unique.","solution":"from typing import List, Tuple def find_multiple_bookings(bookings: List[Tuple[str, int]]) -> List[int]: Returns a list of flight numbers that have multiple bookings. flight_count = {} # Count the number of bookings for each flight for _, flight_number in bookings: if flight_number in flight_count: flight_count[flight_number] += 1 else: flight_count[flight_number] = 1 # Gather flight numbers that have more than one booking multiple_bookings = [flight for flight, count in flight_count.items() if count > 1] # Return the list sorted in ascending order return sorted(multiple_bookings)"},{"question":"# Problem Statement You have been assigned the task of writing a function that calculates the maximum depth of a binary tree. The depth of a binary tree is determined by the number of nodes along the longest path from the root node down to the farthest leaf node. # Function Signature ```python def max_depth(root: Optional[TreeNode]) -> int: ... ``` # Input * A root node of a binary tree (`root`), which may be `None` (representing an empty tree). # Output * An integer representing the maximum depth of the binary tree. # Constraints * The number of nodes in the tree is in the range `[0, 1000]`. * The values of the nodes are unique integers. # Requirements * The function must be implemented using a depth-first search (DFS) approach. # Examples Example 1 Input: ``` root = [3, 9, 20, None, None, 15, 7] ``` Output: ``` 3 ``` Explanation: The tree structure is as follows: ``` 3 / 9 20 / 15 7 ``` The longest path is: 3 -> 20 -> 15 or 3 -> 20 -> 7 (both have a length of 3). Example 2 Input: ``` root = [1, None, 2] ``` Output: ``` 2 ``` Explanation: The tree structure is as follows: ``` 1 2 ``` The longest path is: 1 -> 2 (with a length of 2). # Notes * You may define and use a helper function that recursively computes the depth of the binary tree. * Handle edge cases such as empty trees or trees with only one node. * Ensure the solution efficiently handles the upper limit of tree size. # Hint You might consider a helper function that traverses the tree and keeps track of the depth at each node, returning the maximum depth encountered.","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth(root: Optional[TreeNode]) -> int: if root is None: return 0 left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"# Binary Tree Diameter You are given the root of a binary tree. Your task is to write a Python function that computes the diameter of the binary tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. Input - The input will be provided as the root of a binary tree. Output - Your function should return an integer representing the diameter of the binary tree. Constraints - The number of nodes in the tree will be between 1 and 10,000 (inclusive). - The value of each node is a unique integer. Example Given the following binary tree: ``` 1 / 2 3 / 4 5 ``` Your function should return `3` (the path is [4, 2, 1, 3] or [5, 2, 1, 3]). Implementation Requirements - The function should be named `tree_diameter(root: TreeNode) -> int`. - You may assume you have the class definition of `TreeNode` as follows: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` ```python def tree_diameter(root: TreeNode) -> int: def dfs(node: TreeNode): nonlocal diameter if not node: return 0 left_height = dfs(node.left) right_height = dfs(node.right) diameter = max(diameter, left_height + right_height) return max(left_height, right_height) + 1 diameter = 0 dfs(root) return diameter # Example usage: # tree = TreeNode(1) # tree.left = TreeNode(2) # tree.right = TreeNode(3) # tree.left.left = TreeNode(4) # tree.left.right = TreeNode(5) # print(tree_diameter(tree)) # Output: 3 ```","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def tree_diameter(root: TreeNode) -> int: def dfs(node: TreeNode): nonlocal diameter if not node: return 0 left_height = dfs(node.left) right_height = dfs(node.right) diameter = max(diameter, left_height + right_height) return max(left_height, right_height) + 1 diameter = 0 dfs(root) return diameter"},{"question":"# Closest Pair of Points in 2D Plane You are tasked with finding the closest pair of points in a 2D plane from a given set of points. The distance between two points ( (x_1, y_1) ) and ( (x_2, y_2) ) is calculated using the Euclidean distance formula: [ text{distance} = sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2} ] # Function Requirements You need to implement the function `closest_pair_of_points(points: list[tuple[int, int]]) -> tuple[tuple[int, int], tuple[int, int]]` following these requirements: 1. **Input**: - `points` (list of tuples): A list of tuples where each tuple represents the coordinates of a point in the 2D plane. Each tuple is of the form `(x, y)`. 2. **Output**: - A tuple containing two tuples, each representing the coordinates of the closest pair of points. # Steps: 1. **Pre-sort the Points**: - Sort the given list of points based on their x-coordinates. 2. **Recursive Divide and Conquer**: - Implement a recursive divide-and-conquer algorithm to find the closest pair of points. - For a given set of points, divide it into two halves and solve the problem for each half recursively. - Combine the results from the two halves and compare the minimum distances to account for pairs spanning both halves. 3. **Combine Step**: - In the combine step, compute the minimum distance across the dividing line by checking points within the strip of width equal to the smallest distance found in the recursive steps. 4. **Distance Calculation**: - For efficiency, calculate the square of the distances to avoid unnecessary computation of square roots. # Constraints: - The function should handle **n** points efficiently, leveraging the divide-and-conquer approach to achieve ( O(n log n) ) time complexity. - You should not use any third-party libraries for sorting or distance calculations beyond the standard Python library. # Example: ```python >>> points = [(2, 3), (12, 30), (40, 50), (5, 1), (12, 10), (3, 4)] >>> closest_pair_of_points(points) ((2, 3), (3, 4)) ``` # Implementation: Write your solution as a function in Python. ```python def closest_pair_of_points(points: list[tuple[int, int]]) -> tuple[tuple[int, int], tuple[int, int]]: import math def distance(p1, p2): return (p1[0] - p2[0])**2 + (p1[1] - p2[1])**2 def closest_pair_recursive(points_sorted_x, points_sorted_y): n = len(points_sorted_x) if n <= 3: min_dist = float(\'inf\') min_pair = (None, None) for i in range(n): for j in range(i+1, n): d = distance(points_sorted_x[i], points_sorted_x[j]) if d < min_dist: min_dist = d min_pair = (points_sorted_x[i], points_sorted_x[j]) return min_pair, min_dist mid = n // 2 left_x = points_sorted_x[:mid] right_x = points_sorted_x[mid:] midpoint = points_sorted_x[mid][0] left_y = [] right_y = [] for p in points_sorted_y: if p[0] <= midpoint: left_y.append(p) else: right_y.append(p) (pair_left, dist_left) = closest_pair_recursive(left_x, left_y) (pair_right, dist_right) = closest_pair_recursive(right_x, right_y) if dist_left < dist_right: min_dist = dist_left min_pair = pair_left else: min_dist = dist_right min_pair = pair_right strip_y = [p for p in points_sorted_y if abs(p[0] - midpoint) < math.sqrt(min_dist)] strip_min_dist = min_dist strip_min_pair = min_pair for i in range(len(strip_y)): for j in range(i+1, min(i + 7, len(strip_y))): d = distance(strip_y[i], strip_y[j]) if d < strip_min_dist: strip_min_dist = d strip_min_pair = (strip_y[i], strip_y[j]) return strip_min_pair, strip_min_dist points_sorted_x = sorted(points, key=lambda x: x[0]) points_sorted_y = sorted(points, key=lambda x: x[1]) result, _ = closest_pair_recursive(points_sorted_x, points_sorted_y) return result ``` Provide accompanying explanations for critical parts and document any assumptions or constraints.","solution":"def closest_pair_of_points(points: list[tuple[int, int]]) -> tuple[tuple[int, int], tuple[int, int]]: import math def distance(p1, p2): return (p1[0] - p2[0])**2 + (p1[1] - p2[1])**2 # squared distance to avoid computing sqrt repeatedly def closest_pair_recursive(points_sorted_x, points_sorted_y): n = len(points_sorted_x) # Base case: if there are 3 or fewer points, compute the distance directly if n <= 3: min_dist = float(\'inf\') min_pair = (None, None) for i in range(n): for j in range(i + 1, n): d = distance(points_sorted_x[i], points_sorted_x[j]) if d < min_dist: min_dist = d min_pair = (points_sorted_x[i], points_sorted_x[j]) return min_pair, min_dist mid = n // 2 # Find the midpoint left_x = points_sorted_x[:mid] right_x = points_sorted_x[mid:] midpoint = points_sorted_x[mid][0] left_y = [] right_y = [] for p in points_sorted_y: if p[0] <= midpoint: left_y.append(p) else: right_y.append(p) (pair_left, dist_left) = closest_pair_recursive(left_x, left_y) (pair_right, dist_right) = closest_pair_recursive(right_x, right_y) if dist_left < dist_right: min_dist = dist_left min_pair = pair_left else: min_dist = dist_right min_pair = pair_right strip_y = [p for p in points_sorted_y if abs(p[0] - midpoint) < math.sqrt(min_dist)] strip_min_dist = min_dist strip_min_pair = min_pair for i in range(len(strip_y)): for j in range(i + 1, min(i + 7, len(strip_y))): # Only need to check up to 7 points ahead d = distance(strip_y[i], strip_y[j]) if d < strip_min_dist: strip_min_dist = d strip_min_pair = (strip_y[i], strip_y[j]) return strip_min_pair, strip_min_dist points_sorted_x = sorted(points, key=lambda x: x[0]) points_sorted_y = sorted(points, key=lambda x: x[1]) result, _ = closest_pair_recursive(points_sorted_x, points_sorted_y) return result"},{"question":"String Manipulation: Reverse Words in a Sentence Problem Statement You need to write a function that takes a string consisting of several words separated by spaces and returns a new string where the order of words is reversed. Each word should remain in its original order, but the sequence of words should be reversed. Function Signature ```python def reverse_words(sentence: str) -> str: pass ``` Input - A string `sentence` (0 <= len(sentence) <= 10^4), containing only alphabet letters and spaces. Output - A new string with the words in reversed order. Example ```python # Example 1 reverse_words(\\"hello world\\") -> \\"world hello\\" # Example 2 reverse_words(\\"the sky is blue\\") -> \\"blue is sky the\\" # Example 3 reverse_words(\\"\\") -> \\"\\" # Example 4 reverse_words(\\"a\\") -> \\"a\\" ``` Constraints - The input string may contain leading or trailing spaces, but the output string should not. - Consecutive spaces in the input string should be treated as a single space. - Aim for O(n) time complexity and O(n) space complexity (where n is the length of the input string). Additional Information - Make sure to handle empty input correctly. - The function should be case-sensitive, keeping the original casing of each word. - Split the input string by spaces, reverse the resulting list of words, and join them with a single space. Ensure you test your function with various edge cases, including sentences with multiple spaces, uppercase and lowercase letters, and punctuation.","solution":"def reverse_words(sentence: str) -> str: Return a new string where the order of words in the input sentence is reversed. # Split the sentence into words based on spaces words = sentence.split() # Reverse the list of words words = words[::-1] # Join the reversed words with a single space and return return \' \'.join(words)"},{"question":"# Problem Statement You are required to implement a system that helps manage a hypothetical library inventory. In particular, your task involves developing a function to keep track of borrowed books and inventory status. The library has a collection of books initially identified by their unique IDs. Patrons can borrow and return books, and you need to monitor the availability of each book based on these transactions. # Requirements: 1. Implement a class `Library` with the following methods: - `__init__(self, books: List[int])`: Initializes the library with a list of book IDs. - `borrow_book(self, book_id: int) -> bool`: Allows a book to be borrowed given its ID. Returns `True` if the book could be borrowed (i.e., it was available), otherwise returns `False`. - `return_book(self, book_id: int)`: Allows a book to be returned given its ID. - `get_available_books(self) -> List[int]`: Returns a sorted list of available book IDs. # Constraints: - The list `books` will contain unique book IDs ranging from 1 to 10^6. - Operations of borrowing and returning a book, as well as querying available books, must be efficient in terms of time complexity. # Input: - List of book IDs during the initialization. - Subsequent calls to `borrow_book` and `return_book` methods with single integer inputs representing book IDs. - Call to `get_available_books` method with no parameters. # Output: - For `borrow_book`: Boolean result indicating the success of the borrowing operation. - For `return_book`: No return value. - For `get_available_books`: A sorted list of integers representing the available book IDs. # Example: ```python # Initialization with a list of book IDs library = Library([1, 2, 3, 4, 5]) # Borrowing books print(library.borrow_book(3)) # True print(library.borrow_book(3)) # False (already borrowed) # Returning books library.return_book(3) print(library.borrow_book(3)) # True (can be borrowed again) # Getting available books print(library.get_available_books()) # [1, 2, 3, 4, 5] ``` # Performance Note: - Ensure that your implementation is efficient in handling the operations, especially with frequent calling of borrow and return methods. # Edge Cases to Consider: - Borrowing a book that does not exist in the inventory. - Multiple return attempts for the same book. - Large inventory (up to 1,000,000 books). # Implementation Hint: - Consider using data structures like sets and lists to maintain efficient book inventory management and querying. class Library: def __init__(self, books: List[int]): self.available_books = set(books) self.borrowed_books = set() def borrow_book(self, book_id: int) -> bool: if book_id in self.available_books: self.available_books.remove(book_id) self.borrowed_books.add(book_id) return True return False def return_book(self, book_id: int): if book_id in self.borrowed_books: self.borrowed_books.remove(book_id) self.available_books.add(book_id) def get_available_books(self) -> List[int]: return sorted(self.available_books)","solution":"class Library: def __init__(self, books): self.available_books = set(books) self.borrowed_books = set() def borrow_book(self, book_id): if book_id in self.available_books: self.available_books.remove(book_id) self.borrowed_books.add(book_id) return True return False def return_book(self, book_id): if book_id in self.borrowed_books: self.borrowed_books.remove(book_id) self.available_books.add(book_id) def get_available_books(self): return sorted(self.available_books)"},{"question":"# Binary String Toggle You are required to write a function that takes a binary string as input and returns a new binary string in which \'0\'s are replaced by \'1\'s and \'1\'s are replaced by \'0\'s. Function Signature ```python def toggle_binary_string(binary_str: str) -> str: ``` Input - `binary_str` (str): A string consisting of only \'0\' and \'1\' characters. Constraints: (1 leq text{len}(binary_str) leq 10^5) Output - (str): A new binary string with each \'0\' replaced by \'1\' and each \'1\' replaced by \'0\'. Constraints - Your function should raise a `ValueError` if the input string contains characters other than \'0\' and \'1\'. - Ensure that the function works efficiently for the maximum input size. Examples ```python print(toggle_binary_string(\\"0\\")) # Output: \\"1\\" print(toggle_binary_string(\\"1\\")) # Output: \\"0\\" print(toggle_binary_string(\\"10101\\")) # Output: \\"01010\\" print(toggle_binary_string(\\"111000\\")) # Output: \\"000111\\" print(toggle_binary_string(\\"0000000000\\")) # Output: \\"1111111111\\" print(toggle_binary_string(\\"0101010101\\")) # Output: \\"1010101010\\" print(toggle_binary_string(\\"1100110011\\")) # Output: \\"0011001100\\" print(toggle_binary_string(\\"1111111111\\")) # Output: \\"0000000000\\" ``` Notes - Handle invalid inputs by raising a `ValueError`. - Consider edge cases such as alternating patterns and uniform long strings. - Aim for efficient execution even with the upper limit of input size (10^5 characters).","solution":"def toggle_binary_string(binary_str: str) -> str: Toggles each character in the binary string. Args: binary_str (str): A string consisting only of \'0\' and \'1\'. Returns: str: A new binary string with each \'0\' replaced by \'1\' and each \'1\' replaced by \'0\'. Raises: ValueError: If the input string contains any characters other than \'0\' or \'1\'. if not all(c in \'01\' for c in binary_str): raise ValueError(\\"Invalid input: The string must contain only \'0\' and \'1\' characters.\\") return \'\'.join(\'1\' if c == \'0\' else \'0\' for c in binary_str)"},{"question":"# Decision Tree Classifier for Spam Detection You are working on a project to create a spam detection system that can classify emails as spam or not spam. You will use a Decision Tree Classifier to accomplish this task. Your task involves the following steps: 1. **Implement Decision Tree Classifier**: Write a function `train_and_predict_spam(X, y, test_data)` that: * Takes as input: * `X`, a list of training input samples (each sample itself a list of feature values). * `y`, a list of training labels (binary values 0 for not spam, 1 for spam). * `test_data`, a list of input samples to be used for testing the trained model. * Returns: * A list of predicted labels (0 for not spam, 1 for spam) for the input `test_data`. 2. **Use appropriate Decision Tree settings**: The Decision Tree should use the following settings: * Criterion: \'entropy\' * Maximum depth: 5 * Random state: 42 (to ensure reproducibility) 3. **Performance Requirements**: Your model should be able to handle small datasets efficiently, ensuring that training and prediction are performed optimally. **Input and Output Format:** Input: ```python X = [[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.1], [0.5, 0.4, 0.6]] y = [0, 1, 0, 1] test_data = [[0.2, 0.3, 0.4], [0.6, 0.5, 0.7]] ``` Output: ```python [0, 1] ``` Ensure your implementation meets these constraints and performs the required operations efficiently. ```python from sklearn.tree import DecisionTreeClassifier def train_and_predict_spam(X, y, test_data): Train a Decision Tree classifier with given data and return predictions on test data. Args: X (list of list of float): Training input samples. y (list of int): Training labels. test_data (list of list of float): Test input samples. Returns: list of int: Predicted labels for the test data. # Your implementation here clf = DecisionTreeClassifier(criterion=\'entropy\', max_depth=5, random_state=42) clf.fit(X, y) predictions = clf.predict(test_data) return predictions # Example usage (you can use this for testing your function): X = [[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.1], [0.5, 0.4, 0.6]] y = [0, 1, 0, 1] test_data = [[0.2, 0.3, 0.4], [0.6, 0.5, 0.7]] predictions = train_and_predict_spam(X, y, test_data) print(predictions) # Expected output: [0, 1] ```","solution":"from sklearn.tree import DecisionTreeClassifier def train_and_predict_spam(X, y, test_data): Train a Decision Tree classifier with given data and return predictions on test data. Args: X (list of list of float): Training input samples. y (list of int): Training labels. test_data (list of list of float): Test input samples. Returns: list of int: Predicted labels for the test data. clf = DecisionTreeClassifier(criterion=\'entropy\', max_depth=5, random_state=42) clf.fit(X, y) predictions = clf.predict(test_data) return list(predictions)"},{"question":"# Problem Description You are required to design a function that generates a complex Mandelbrot fractal visualization. The function should be able to handle different types of complex transformations, efficiently support high-resolution grids, and optimize performance using parallel processing techniques. # Function Specification Write a function `generate_mandelbrot_fractal` with the following signature: ```python def generate_mandelbrot_fractal(transform: Callable[[complex], complex], max_iter: int, escape_radius: float, real_range: Tuple[float, float], imag_range: Tuple[float, float], nb_pixels: int) -> None: ``` Input: - `transform`: A callable function that takes a single complex number and returns a complex number (the transformation to apply at each iteration). - `max_iter`: An integer indicating the maximum number of iterations for the transformation. - `escape_radius`: A float defining the radius at which a point is considered to have escaped the Mandelbrot set. - `real_range`: A tuple of floats specifying the range of real values for the grid (min_real, max_real). - `imag_range`: A tuple of floats specifying the range of imaginary values for the grid (min_imag, max_imag). - `nb_pixels`: An integer for the size of the grid (nb_pixels x nb_pixels). Output: - Displays a plot visualizing the Mandelbrot fractal where points within the set are marked differently from those that escape. # Constraints: - Utilize parallel processing to optimize computation for grids larger than 500x500 pixels. - Handle numerical issues appropriately to avoid overflow and precision errors. # Example Usage ```python import numpy as np from matplotlib import pyplot as plt def basic_transformation(z): return z**2 + 0.355 + 0.355j generate_mandelbrot_fractal(basic_transformation, 1000, 2.0, (-2.0, 1.0), (-1.5, 1.5), 1000) ``` This should display a plot of the Mandelbrot fractal for the provided `basic_transformation`. # Performance Requirements - Ensure the solution leverages parallel processing to enhance performance for large grid sizes. - Carefully manage memory to avoid unnecessary duplications during computation.","solution":"import numpy as np import matplotlib.pyplot as plt from multiprocessing import Pool from typing import Callable, Tuple def mandelbrot_point(c: complex, transform: Callable[[complex], complex], max_iter: int, escape_radius: float) -> int: z = c for i in range(max_iter): z = transform(z) if abs(z) > escape_radius: return i return max_iter def compute_row(args): real_range, imag, nb_pixels, transform, max_iter, escape_radius = args row = [] real_min, real_max = real_range for x in np.linspace(real_min, real_max, nb_pixels): c = complex(x, imag) row.append(mandelbrot_point(c, transform, max_iter, escape_radius)) return row def generate_mandelbrot_fractal(transform: Callable[[complex], complex], max_iter: int, escape_radius: float, real_range: Tuple[float, float], imag_range: Tuple[float, float], nb_pixels: int) -> None: real_min, real_max = real_range imag_min, imag_max = imag_range imag_values = np.linspace(imag_min, imag_max, nb_pixels) args = [(real_range, imag, nb_pixels, transform, max_iter, escape_radius) for imag in imag_values] if nb_pixels > 500: with Pool() as pool: results = pool.map(compute_row, args) else: results = list(map(compute_row, args)) fractal = np.array(results) plt.imshow(fractal.T, extent=(real_min, real_max, imag_min, imag_max), cmap=\'hot\', aspect=\'auto\') plt.colorbar() plt.title(\\"Mandelbrot Fractal\\") plt.xlabel(\\"Re\\") plt.ylabel(\\"Im\\") plt.show()"},{"question":"# Coding Challenge **Context**: You are tasked with developing a feature for an e-commerce platform that helps customers determine the optimal way to combine their purchases into packages based on weight limits. **Objective**: Write a function `package_items(weights, max_weight)` that takes a list of integers representing the weights of individual items and a single integer representing the maximum allowable weight for a package. The function should return a list of packages, where each package is represented as a list of item weights, such that each package does not exceed the maximum allowable weight. Function Signature ```python def package_items(weights: List[int], max_weight: int) -> List[List[int]]: ... ``` # Input * `weights` (List[int]): A list of positive integers representing the weights of the items (e.g., [5, 10, 20]). * `max_weight` (int): A positive integer representing the maximum allowable weight for a package. # Output * A list of packages, where each package is represented as a list of item weights, and the sum of the weights in each package does not exceed `max_weight`. # Constraints * All weights in the input list will be positive integers. * The maximum allowable weight `max_weight` will be a positive integer. * There will always be at least one item in the `weights` list. # Examples ```python assert package_items([4, 8, 1, 4, 2, 6], 10) == [[4, 4, 1], [8, 2], [6]] assert package_items([10, 15, 7, 5, 1], 20) == [[10, 7, 1], [15, 5]] assert package_items([3, 8, 6, 5], 10) == [[3, 6], [8], [5]] ``` # Guidelines 1. Ensure that the function distributes items into packages such that no package exceeds the `max_weight`. 2. Optimize for a minimal number of packages. 3. Avoid any built-in functions or libraries that solve the problem directly as the goal is to implement the logic manually. 4. Consider edge cases, such as when items exactly match the `max_weight` or when items cannot be perfectly combined. **Note**: The solution should aim for clarity and efficiency in both time and space complexity.","solution":"from typing import List def package_items(weights: List[int], max_weight: int) -> List[List[int]]: Distributes the items into packages such that no package exceeds the max_weight. # Sort weights in descending order for easier packaging weights.sort(reverse=True) packages = [] for weight in weights: placed = False for package in packages: if sum(package) + weight <= max_weight: package.append(weight) placed = True break if not placed: # Start a new package if it couldn\'t be placed in existing ones packages.append([weight]) return packages"},{"question":"# Scenario You are developing a text editor with advanced functionality. One of the features required is to count the number of occurrences of each unique word in a given block of text. This will help implement a real-time word frequency analysis tool. # Task Implement a function `word_frequency` that calculates the frequencies of unique words in a given block of text. For simplicity, words are defined as sequences of characters separated by spaces, and the function should be case-insensitive. # Function Signature ```python def word_frequency(text: str) -> Dict[str, int]: Counts the frequency of each unique word in the given text. :param text: A string representing the block of text to analyze. :return: A dictionary where keys are unique words and values are their respective frequencies. pass ``` # Input - A string `text` containing a block of text consisting of words separated by spaces. Words are case-insensitive. # Output - A dictionary where keys are unique words (converted to lowercase) and values are the frequencies of these words in the given text. # Constraints - The length of the text will not exceed (10^6) characters. - The words are case-insensitive, and punctuation should be ignored (i.e., treat `hello,` and `hello` as the same word). # Examples Example 1: ```python text = \\"Hello world! Hello everyone.\\" print(word_frequency(text)) # Output: {\\"hello\\": 2, \\"world\\": 1, \\"everyone\\": 1} ``` Example 2: ```python text = \\"Test the function: test, test, TEST!\\" print(word_frequency(text)) # Output: {\\"test\\": 4, \\"the\\": 1, \\"function\\": 1} ``` # Additional Requirements - Your solution should efficiently handle the case where the input text length is up to (10^6) characters. - Ensure that the solution appropriately normalizes the case of words and handles punctuation.","solution":"import re from collections import defaultdict from typing import Dict def word_frequency(text: str) -> Dict[str, int]: Counts the frequency of each unique word in the given text. :param text: A string representing the block of text to analyze. :return: A dictionary where keys are unique words and values are their respective frequencies. # Convert the text to lowercase to make the function case-insensitive text = text.lower() # Use a regular expression to extract words (ignoring punctuation) words = re.findall(r\'bw+b\', text) # Create a dictionary to store word frequencies frequency = defaultdict(int) for word in words: frequency[word] += 1 return dict(frequency)"},{"question":"# Context You have been hired by a logistics company to develop an algorithm that optimizes the way trucks are loaded with packages. The trucks have a weight limit, and the goal is to maximize the total weight of packages loaded without exceeding the limit. The packages cannot be split and must be loaded entirely or not at all. This is a classic example of the 0/1 Knapsack Problem. # Problem Statement Create a function `knapsack` which takes the following arguments: 1. `weights`: a list of integers, where each integer represents the weight of a package. 2. `values`: a list of integers, where each integer represents the value (profit) of the corresponding package. 3. `capacity`: an integer representing the maximum weight capacity of the truck. The function should return an integer representing the maximum total value of packages that can be loaded into the truck without exceeding the weight capacity. # Input - `weights`: List of integers `[w1, w2, ..., wn]` (0 ≤ weights[i] ≤ 1000) where `0 < n ≤ 100` indicates the weight of each package. - `values`: List of integers `[v1, v2, ..., vn]` (0 ≤ values[i] ≤ 1000) for each package i. - `capacity`: Integer `c` (0 ≤ capacity ≤ 1000) indicating the maximum weight capacity of the truck. # Output - Returns an integer representing the maximum total value of packages that can be loaded into the truck without exceeding the weight capacity. # Constraints Ensure your function is efficient and handles multiple edge cases, including: - When the capacity is zero. - When all packages are too heavy to be loaded. - Handling cases where multiple packages have the same weight or value. # Example ```python weights = [10, 20, 30] values = [60, 100, 120] capacity = 50 knapsack(weights, values, capacity) # Expected Output: 220 ``` # Notes - Make sure your implementation is optimized for performance, ideally running in O(n * capacity) time complexity. - Test your implementation with various edge cases to ensure it correctly handles all possible scenarios.","solution":"def knapsack(weights, values, capacity): n = len(weights) # Initialize dp array, where dp[j] represents the maximum value achievable with weight j dp = [0] * (capacity + 1) for i in range(n): for j in range(capacity, weights[i] - 1, -1): dp[j] = max(dp[j], dp[j - weights[i]] + values[i]) return dp[capacity]"},{"question":"# Scenario: You\'ve been tasked with building a shopping cart management system for an e-commerce platform. Your job is to implement a function that calculates the total cost of items in the cart considering the quantities and the price of each item. Additionally, allow the option to apply a discount if a specified discount code is valid. # Task: Implement a function `shopping_cart` that performs the following: 1. Compute the total cost of items in the cart considering their quantities and prices. 2. Apply a discount to the total cost if a valid discount code is provided. 3. Return the final amount after applying any discounts. # Specifications: 1. `shopping_cart(cart: dict, discount_code: str = \\"\\") -> float` - **Parameters**: - `cart (dict)`: A dictionary where keys are item names and values are tuples `(price_per_unit: float, quantity: int)`. - `discount_code (str)`: A string representing the discount code. If no code is provided, the total is calculated without any discount. - **Returns**: A float representing the final total cost after any applicable discount. 2. The function should validate and ensure: - Prices per unit and quantities are non-negative. - Discount codes, if provided, are checked against a predefined set of valid codes. 3. **Output**: - Return the final total cost after applying any discount. # Example: ```python cart = { \\"apple\\": (2.00, 3), \\"banana\\": (1.50, 6), \\"milk\\": (3.00, 1) } valid_discounts = { \\"SAVE10\\": 0.10, # 10% discount \\"HALFOFF\\": 0.50, # 50% discount } discount_code = \\"SAVE10\\" print(shopping_cart(cart, discount_code)) discount_code = \\"INVALID\\" print(shopping_cart(cart, discount_code)) ``` **Expected Output**: ``` Total cost after discount: 12.60 # SAVE10 applied Total cost after discount: 15.00 # No discount applied ``` # Constraints: - Assume item names are unique strings. - Assume the provided discount codes are stored in a predefined dictionary `valid_discounts`. - The function should handle cases where no discount code is provided or the provided code is invalid. - Focus on readability, maintainability, and correctness of the code.","solution":"def shopping_cart(cart, discount_code=\\"\\"): Calculate the total cost of the shopping cart and apply discount if valid. Parameters: cart (dict): A dictionary where keys are item names and values are tuples (price_per_unit: float, quantity: int). discount_code (str): A string representing the discount code. Returns: float: The final total cost after any applicable discount. # Predefined set of valid discount codes valid_discounts = { \\"SAVE10\\": 0.10, # 10% discount \\"HALFOFF\\": 0.50, # 50% discount } # Calculate the total cost of the items in the cart total_cost = 0.0 for item, (price_per_unit, quantity) in cart.items(): if price_per_unit < 0 or quantity < 0: raise ValueError(\\"Price per unit and quantity should be non-negative.\\") total_cost += price_per_unit * quantity # Apply discount if the discount code is valid if discount_code in valid_discounts: discount = valid_discounts[discount_code] total_cost *= (1 - discount) return total_cost"},{"question":"# Frequency of Digits Calculation You are given a list of integers. Your task is to analyze the list and return a dictionary where each key is a digit from 0 to 9, and each value is the frequency of that digit appearing in any position in any number in the list. # Instructions 1. Iterate through each integer in the list. 2. Convert the integer to a string to extract each digit. 3. Count the occurrences of each digit (0 through 9) across all integers in the list. 4. Return the counts in the form of a dictionary. # Example For instance, if the list of integers is `[123, 456, 789, 101]`: - The frequency of \'0\' is 2. - The frequency of \'1\' is 3. - The frequency of \'2\' is 1. - The frequency of \'3\' is 1. - The frequency of \'4\' is 1. - The frequency of \'5\' is 1. - The frequency of \'6\' is 1. - The frequency of \'7\' is 1. - The frequency of \'8\' is 1. - The frequency of \'9\' is 1. # Objective Write a Python function `digit_frequency` that receives a list of integers and returns a dictionary with the frequency of each digit from 0 to 9. ```python def digit_frequency(number_list: list) -> dict: Calculate the frequency of each digit in the given list of integers. :param number_list: List of integers to be analyzed. :return: Dictionary with digit frequencies. # Your implementation goes here. pass # Example usage: # result = digit_frequency([123, 456, 789, 101]) # print(result) # Expected output: {\'0\': 2, \'1\': 3, \'2\': 1, \'3\': 1, \'4\': 1, \'5\': 1, \'6\': 1, \'7\': 1, \'8\': 1, \'9\': 1} ``` # Constraints 1. The input list will contain at least one integer. 2. Integers in the list can be positive, negative, or zero. 3. The function should handle large lists efficiently. 4. The integers can have any number of digits.","solution":"def digit_frequency(number_list: list) -> dict: Calculate the frequency of each digit in the given list of integers. :param number_list: List of integers to be analyzed. :return: Dictionary with digit frequencies. frequencies = {str(digit): 0 for digit in range(10)} for number in number_list: for digit in str(abs(number)): frequencies[digit] += 1 return frequencies"},{"question":"# Problem Statement Design a function to simulate a variation of the classic Tetris game, focusing on the line-clearing mechanic without graphical output. The function should determine how many lines are cleared after a piece is placed on the board. Requirements: 1. **Function Name**: `tetris_lines_cleared` 2. **Input**: - `board`: A 2D list of characters (\' \', \'X\') representing the current state of the Tetris board. Rows are horizontal lines, and columns are vertical lines. - `piece`: A list of 2D tuples where each tuple represents the relative coordinates (row, column) of the piece to be placed on the board. The piece will be placed in the grid starting from the top-left corner (0,0). - `position`: A tuple of two integers representing the top-left corner (row, column) where the piece should be placed on the board. 3. **Output**: - An integer representing the number of lines cleared after the piece is placed. 4. **Constraints**: - The board will be a 10x20 grid (standard Tetris dimensions). - The piece and position will always be valid inputs. - The piece must be placed fully within the bounds of the board, meaning no part of the piece will go outside the board. Scenario You\'re tasked with implementing an analysis tool for a simplified Tetris game. The tool should focus purely on determining how many lines will be cleared when a piece is placed on the game board. The purpose of this tool is to help the game AI make intelligent decisions about piece placement to maximize the number of lines cleared. Implement the function with the signature: ```python def tetris_lines_cleared(board: list[list[str]], piece: list[tuple[int, int]], position: tuple[int, int]) -> int: pass ``` Considerations: - The character \'X\' represents a filled cell, and the space character \' \' represents an empty cell on the board. - The piece is represented by a list of tuples with relative coordinates, and it must be translated to the board using the given position for placement. - After placing the piece, you should calculate how many lines are completely filled and return that count. Example: ```python board = [ [\' \', \' \', \' \', \' \', \' \', \' \', \' \', \' \', \' \', \' \'], [\' \', \' \', \' \', \' \', \' \', \' \', \' \', \' \', \' \', \' \'], [\' \', \' \', \' \', \' \', \' \', \' \', \' \', \' \', \' \', \' \'], [\' \', \' \', \' \', \' \', \' \', \' \', \' \', \' \', \' \', \' \'], [\' \', \' \', \' \', \' \', \' \', \' \', \' \', \' \', \' \', \' \'], [\' \', \' \', \' \', \' \', \' \', \' \', \' \', \' \', \' \', \' \'], [\' \', \' \', \' \', \'X\', \'X\', \' \', \' \', \' \', \' \', \' \'], [\' \', \' \', \' \', \'X\', \'X\', \' \', \' \', \' \', \' \', \' \'], [\' \', \' \', \' \', \'X\', \'X\', \' \', \' \', \' \', \' \', \' \'], [\' \', \' \', \' \', \'X\', \'X\', \' \', \' \', \' \', \' \', \' \'], [\'X\', \'X\', \'X\', \'X\', \'X\', \'X\', \'X\', \'X\', \'X\', \'X\'], [\'X\', \'X\', \'X\', \'X\', \'X\', \'X\', \'X\', \'X\', \'X\', \'X\'] ] piece = [(0,0), (0,1), (1,0), (1,1)] position = (8, 4) print(tetris_lines_cleared(board, piece, position)) # Output should be 2 ```","solution":"def tetris_lines_cleared(board, piece, position): rows, cols = 20, 10 # Tetris board dimensions # Place the piece on the board for (dr, dc) in piece: r, c = position[0] + dr, position[1] + dc board[r][c] = \'X\' # Check for row completions complete_rows = 0 for row in board: if all(cell == \'X\' for cell in row): # If a row is completely filled complete_rows += 1 return complete_rows"},{"question":"# Coding Challenge # Problem Statement You are given a 2D grid filled with non-negative integers, where each cell represents the cost of stepping into that cell. Your task is to find a path from the top-left corner to the bottom-right corner that minimizes the cost. You can only move either down or right at any point in time. # Input - A string representation of the grid where each row is a line of space-separated integers. - Guarantee: The grid will have between 1 and 100 rows and each row will have between 1 and 100 columns. # Output - An integer representing the minimum cost path sum from the top-left to the bottom-right corner. # Example Input ``` 1 3 1 1 5 1 4 2 1 ``` Output ``` 7 ``` # Explanation For the given example, the minimum cost path is 1->3->1->1->1 = 7. # Function Signature ```python def min_path_sum(grid_str: str) -> int: pass ``` # Constraints - 1 ≤ number of rows, columns ≤ 100 - All grid values are non-negative integers between 0 and 1000. # Scenario You are tasked with developing a navigation system for a robot that must traverse a grid with varying costs for each cell. The robot must find the least expensive path from the top-left corner to the bottom-right corner while adhering to the constraints of movement. Use principles of dynamic programming to efficiently determine the minimum cost path in the provided environment, considering grid constraints for optimal performance.","solution":"def min_path_sum(grid_str: str) -> int: Calculates the minimum cost path sum from the top-left corner to the bottom-right corner of the grid. :param grid_str: Grid represented as a string of space-separated integers. :return: Minimum cost path sum. # Convert grid string to a 2D list of integers grid = [list(map(int, row.split())) for row in grid_str.strip().split(\'n\')] rows = len(grid) cols = len(grid[0]) # Using dynamic programming to store the minimum path sums dp = [[0] * cols for _ in range(rows)] # Initialize the first cell dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for col in range(1, cols): dp[0][col] = dp[0][col - 1] + grid[0][col] # Fill the first column (can only come from above) for row in range(1, rows): dp[row][0] = dp[row - 1][0] + grid[row][0] # Fill the rest of the dp table for row in range(1, rows): for col in range(1, cols): dp[row][col] = min(dp[row - 1][col], dp[row][col - 1]) + grid[row][col] return dp[-1][-1]"},{"question":"# Word Pattern Validation You are given a list of words and a pattern. Your task is to determine if the pattern matches the list of words. A pattern matches the list of words if there is a bijection (one-to-one correspondence) between letters in the pattern and words in the list, such that given the same letter, it always maps to the same word and vice versa. Detailed Instructions: 1. Write a function `word_pattern_matcher` with the following parameters: - `pattern`: A non-empty string containing only lowercase letters. - `words`: A list of non-empty strings. 2. The function should perform the following tasks: - Validate that the length of the `pattern` matches the length of the `words` list. - Determine if there is a one-to-one correspondence between the letters in the `pattern` and the words in the `words` list. - Return `True` if the pattern matches the list of words, and `False` otherwise. Constraints: - Do not use any additional libraries or modules. - Handle possible input errors gracefully by raising an appropriate ValueError. - Assume the inputs are always non-empty and contain only valid string characters. Function Signature: ```python def word_pattern_matcher(pattern: str, words: list[str]) -> bool: ``` Example: ```python # Example 1: pattern = \\"abba\\" words = [\\"dog\\", \\"cat\\", \\"cat\\", \\"dog\\"] print(word_pattern_matcher(pattern, words)) # Output: True # Example 2: pattern = \\"abba\\" words = [\\"dog\\", \\"cat\\", \\"cat\\", \\"fish\\"] print(word_pattern_matcher(pattern, words)) # Output: False # Example 3: pattern = \\"aaaa\\" words = [\\"dog\\", \\"dog\\", \\"dog\\", \\"dog\\"] print(word_pattern_matcher(pattern, words)) # Output: True # Example 4: pattern = \\"abba\\" words = [\\"dog\\", \\"dog\\", \\"dog\\", \\"dog\\"] print(word_pattern_matcher(pattern, words)) # Output: False ```","solution":"def word_pattern_matcher(pattern: str, words: list[str]) -> bool: Determines if there is a bijection between letters in the pattern and words in the list. :param pattern: A string pattern containing only lowercase letters. :param words: A list of words. :return: True if the pattern matches the list of words, else False. if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False else: char_to_word[char] = word if word in word_to_char: if word_to_char[word] != char: return False else: word_to_char[word] = char return True"},{"question":"# Problem Statement: Minimum Cost to Reach the End Objective You are given an array `costs` where `costs[i]` represents the cost of stepping on the `i-th` step of a staircase. You can either advance 1 step or 2 steps from your current position. Your task is to write a function `min_cost_to_end(costs)` that calculates the minimum cost required to reach the end of the staircase. Function Signature ```python def min_cost_to_end(costs: list[int]) -> int: ``` Input * `costs` (1 ≤ len(costs) ≤ 10^5): an array of integers in the range [0, 10^4] representing the cost of each step. Output * An integer representing the minimum cost to reach the end of the staircase. Example ```python print(min_cost_to_end([10, 15, 20])) # Output: 15 print(min_cost_to_end([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])) # Output: 6 print(min_cost_to_end([0, 0, 0, 0])) # Output: 0 ``` Constraints * The length of the input array `costs` will always be between 1 and 100,000. * The values in the `costs` array will each be between 0 and 10,000. Requirements 1. Your solution should have a time complexity of O(n) and space complexity of O(1). 2. Use an iterative approach to handle large input efficiently. Notes - You can start from either the first or second step. This means that the minimum cost to start at either `[0]` or `[1]`. - You can only advance 1 step or 2 steps at a time, and you need to factor in the cost of each step when calculating your total. - Ensure your solution handles edge cases such as arrays with minimal length or containing values of 0 effectively. Plan To deviate from the start step scenarios, you can either start from the 0th or 1st index. At each current step, calculate the minimum cost of stepping to that step, then update and carry forward the minimum cost for the next step and so on until the end of the array. Write the function according to the provided constraints and requirements, making sure it handles edge cases gracefully.","solution":"def min_cost_to_end(costs: list[int]) -> int: n = len(costs) if n == 1: return costs[0] # Initialize dp variables for the previous two minimum costs prev1, prev2 = costs[0], costs[1] for i in range(2, n): current = costs[i] + min(prev1, prev2) prev1, prev2 = prev2, current return min(prev1, prev2)"},{"question":"# Validate and Sum Integers from List You are tasked with developing a function that verifies each element in a list of integers to determine whether they are non-negative whole numbers. If all elements meet this criterion, the function should return the sum of all elements; otherwise, it should return `None`. Implement the function `validated_sum(integer_list: list) -> int` that: * Takes a list of integers as input. * Returns the sum of the integers if all are non-negative. * Returns `None` if any of the integers is negative. Function Signature ```python def validated_sum(integer_list: list) -> int: pass ``` # Input * `integer_list`: A list of integers. # Output * Returns the sum of the integers if all elements are non-negative. * Returns `None` if any element in the list is negative. # Examples Here are some sample test cases for your implementation: ```python assert validated_sum([1, 2, 3, 4, 5]) == 15 assert validated_sum([0, 0, 0, 0]) == 0 assert validated_sum([-1, 2, 3, 4, 5]) == None assert validated_sum([100, 200, 300, 400]) == 1000 assert validated_sum([1, -1, 2]) == None assert validated_sum([]) == 0 ``` This question assesses the candidate\'s ability to work with list traversal and conditional validation, aligning with programming concepts similar to those examined in the provided sample questions.","solution":"def validated_sum(integer_list: list) -> int: Validates a list of integers to check if all elements are non-negative. If all elements are non-negative, returns the sum of the integers; otherwise, returns None. Parameters: integer_list (list): A list of integers. Returns: int: The sum of the integers if all are non-negative, or None if any integer is negative. for num in integer_list: if num < 0: return None return sum(integer_list)"},{"question":"# Problem Statement: You are given a list of integers, and your task is to sort the list in ascending order but with a twist. If any number in the list is even, it should appear after all the odd numbers, maintaining their relative order. Implement this sorting algorithm as a single function. Function Specifications: 1. **Sort List with Twisted Order** ```python def sort_twist(arr: list[int]) -> list[int]: Sorts the list such that all odd numbers come before all even numbers, maintaining their relative order. :param arr: A list of integers. :return: A list of integers sorted with all odds first and evens after (both maintaining original order). :raises ValueError: If the input is not a list of integers. ``` Example: ```python >>> sort_twist([3, 1, 2, 4, 7, 8, 5]) [3, 1, 7, 5, 2, 4, 8] >>> sort_twist([10, 21, 22, 9, 4, 18]) [21, 9, 10, 22, 4, 18] >>> sort_twist([1, 11, 3, 7, 9]) [1, 11, 3, 7, 9] >>> sort_twist([2, 4, 6, 8]) [2, 4, 6, 8] >>> sort_twist([]) [] >>> sort_twist(\\"string input\\") Traceback (most recent call last): ... ValueError: the value of input must be a list of integers ``` Constraints: * The list can contain any amount of integers, including zero. * Sorting should be stable, meaning the relative order of odd and even integers should be preserved as in the input list. * Your function should raise a `ValueError` if the input is not a list of integers. # Requirements: * Carefully handle edge cases, such as empty lists and lists containing only odd or only even numbers. * Benchmark and ensure the solution handles larger lists efficiently. * Thoroughly document your code to explain the approach and logic used in the algorithm.","solution":"def sort_twist(arr): Sorts the list such that all odd numbers come before all even numbers, maintaining their relative order. :param arr: A list of integers. :return: A list of integers sorted with all odds first and evens after (both maintaining original order). :raises ValueError: If the input is not a list of integers. if not isinstance(arr, list) or not all(isinstance(x, int) for x in arr): raise ValueError(\\"the value of input must be a list of integers\\") odds = [x for x in arr if x % 2 != 0] evens = [x for x in arr if x % 2 == 0] return odds + evens"},{"question":"# Student Grades Analyzer You are given the task of analyzing student grades for a particular course. Each student has grades for multiple assignments, and you need to determine the overall grade for each student based on specific rules. The overall grade is calculated as follows: 1. **Average**: Compute the average of all assignment grades. 2. **Drop Lowest**: Drop the lowest grade of each student and compute the average of the remaining grades. - If the student has only one grade, that grade is used as the average. - If the student has no grades, the average is 0. Implement a function to compute these overall grades. Function Signature ```python def calculate_overall_grades(grades: List[List[int]]) -> List[float]: ``` Input - **grades**: A 2D list of integers where `grades[i][j]` represents the grade of the `j`-th assignment of the `i`-th student. Output - Returns a list of floats where each float represents the overall grade of the respective student after applying the rules mentioned above. Constraints - The number of students (N) is between 1 and 100. - The number of assignments per student can vary from 0 to 100. - Each grade is an integer between 0 and 100. Example ```python grades = [ [85, 90, 78], # Average 84.0 after dropping 78 [100], # Average 100.0 as it\'s the only grade [70, 80, 90, 60], # Average 80.0 after dropping 60 [], # No grades, average 0.0 ] assert calculate_overall_grades(grades) == [84.0, 100.0, 80.0, 0.0] ``` Notes - Ensure accurate handling of various edge cases such as students with no grades or only one grade, and proper floating-point arithmetic. - Consider using helper functions to handle specific parts of the logic to maintain code clarity and reusability. Write the function `calculate_overall_grades` to implement the above functionality.","solution":"from typing import List def calculate_overall_grades(grades: List[List[int]]) -> List[float]: Calculate the overall grades for each student. Parameters: grades (List[List[int]]): A 2D list of integers where each sublist contains grades for a student. Returns: List[float]: A list of floats representing the overall grades of the respective students. overall_grades = [] for student_grades in grades: if not student_grades: overall_grades.append(0.0) else: if len(student_grades) > 1: student_grades.remove(min(student_grades)) overall_grades.append(sum(student_grades) / len(student_grades)) return overall_grades"},{"question":"# Problem Statement You are given a binary tree where each node contains an integer value. Design an algorithm to determine if a binary tree is a Binary Search Tree (BST). A BST is defined as follows: - The left subtree of a node contains only nodes with values less than the node\'s value. - The right subtree of a node contains only nodes with values greater than the node\'s value. - Both the left and right subtrees must also be binary search trees. # Task 1. **BST Verification Algorithm (Core Algorithm)**: - Implement the `is_bst` function that takes the root node of the binary tree and returns `True` if the tree is a BST, and `False` otherwise. - Use a helper function to validate the BST property by recursively ensuring that all nodes respect the binary search tree properties given their lower and upper bounds. 2. **Ensure Input/Output Specifications (Integration)**: - The binary tree node class is provided and should be used for constructing the tree. - Your function should only return either `True` or `False`. # Constraints - The number of nodes in the binary tree will be between 1 and (10^4). - Node values will be between (-10^5) and (10^5). # Performance Requirements - Time Complexity: O(n) where n is the number of nodes in the tree. - Space Complexity: O(h) where h is the height of the binary tree. # Function Signature ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_bst(root: TreeNode) -> bool: pass ``` # Example Input ```python root = TreeNode(2) root.left = TreeNode(1) root.right = TreeNode(3) ``` Output ```python True ``` # Implementation Details - Initialize a helper function `validate(node, low, high)` starting with the entire range of possible values. - Check that the current node\'s value is within the valid range [low, high]. - Recursively validate the left subtree ensuring all values are less than the current node\'s value. - Recursively validate the right subtree ensuring all values are greater than the current node\'s value. - Handle edge cases such as an empty tree or single-node tree correctly.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_bst(root): def validate(node, low = float(\'-inf\'), high = float(\'inf\')): if not node: return True if node.val <= low or node.val >= high: return False return (validate(node.left, low, node.val) and validate(node.right, node.val, high)) return validate(root)"},{"question":"# Calculate Average Age and Grade In this task, you\'ll extend a given collection of student records functionality by implementing a system to calculate the average age and the average grade of a group of students. The student records are stored in a list of dictionaries, each representing a student. Requirements: - Implement a function that takes in a list of student dictionaries and returns the average age and average grade of the students. - Each student dictionary contains name, age, and grade keys. - Handle cases with empty lists gracefully by returning appropriate messages. Function Signature: ```python def calculate_averages(students: list) -> tuple: Calculate the average age and average grade of students. Parameters: students (list): List of dictionaries where each dictionary represents a student with \'name\', \'age\', and \'grade\' keys. Returns: tuple: A tuple containing the average age and average grade as floats or appropriate messages for empty input. ``` Constraints: - Each student dictionary is formatted as follows: {\'name\': str, \'age\': int, \'grade\': float}. - Age is a positive integer greater than 0. - Grade is a float ranging from 0.0 to 100.0. - If the input list is empty, return (\\"No students\\", \\"No students\\"). Example Usage: ```python students = [ {\'name\': \'Alice\', \'age\': 20, \'grade\': 85.5}, {\'name\': \'Bob\', \'age\': 22, \'grade\': 92.0}, {\'name\': \'Charlie\', \'age\': 21, \'grade\': 78.0} ] # Call the function with the students list print(calculate_averages(students)) ``` Expected output for the above example: ```python (21.0, 85.17) ``` Performance Requirements: - The function should efficiently handle large lists of student records. - Ensure the calculations are accurate to at least two decimal places.","solution":"def calculate_averages(students: list) -> tuple: Calculate the average age and average grade of students. Parameters: students (list): List of dictionaries where each dictionary represents a student with \'name\', \'age\', and \'grade\' keys. Returns: tuple: A tuple containing the average age and average grade as floats or appropriate messages for empty input. if not students: return (\\"No students\\", \\"No students\\") total_age = 0 total_grade = 0.0 num_students = len(students) for student in students: total_age += student[\'age\'] total_grade += student[\'grade\'] average_age = total_age / num_students average_grade = total_grade / num_students return (round(average_age, 2), round(average_grade, 2))"},{"question":"# Coding Challenge: Generate Prime Numbers Background A prime number is a natural number greater than 1 that is not a product of two smaller natural numbers. In other words, it has no positive divisors other than 1 and itself. Task Write a function `generate_primes(n: int) -> List[int]` that generates all prime numbers less than or equal to a given integer `n`. Input - A single integer `n` (2 <= n <= 10^5). Output - Return a list of all prime numbers less than or equal to `n`. Examples ```python assert generate_primes(10) == [2, 3, 5, 7] assert generate_primes(20) == [2, 3, 5, 7, 11, 13, 17, 19] assert generate_primes(5) == [2, 3, 5] assert generate_primes(1) == [] assert generate_primes(2) == [2] assert generate_primes(0) == [] ``` # Constraints - The input will always be a single integer. - You must handle inputs within the range [2, 100000]. - Your solution should be optimized for performance, ideally using the Sieve of Eratosthenes algorithm.","solution":"def generate_primes(n): Returns a list of all prime numbers less than or equal to n using Sieve of Eratosthenes. if n < 2: return [] sieve = [True] * (n + 1) sieve[0] = sieve[1] = False # 0 and 1 are not primes for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n + 1, start): sieve[multiple] = False return [num for num, is_prime in enumerate(sieve) if is_prime]"},{"question":"# String Transformation and Pattern Matching Context You are designing a text processing tool that helps in transforming and evaluating strings based on specific patterns. The tool should be capable of transforming a given string based on a series of transformation rules and then checking if the transformed string matches a given pattern. Objective Write two functions: 1. `apply_transformations(s: str, transformations: list) -> str`: This function applies a list of transformation rules to a given string. 2. `pattern_match(s: str, pattern: str) -> bool`: This function checks if the given string matches a specific pattern. Detailed Requirements 1. **Function 1: apply_transformations** * **Input**: - A string `s`. - A list of tuples `transformations`, where each tuple consists of two strings `(old, new)`. * **Output**: A transformed string. * **Constraints**: - The string `s` and all elements in `transformations` should be non-empty strings. - Raise a `ValueError` for invalid input (non-string `s`, or empty strings in `transformations`). * **Description**: - The function should sequentially apply each transformation `(old, new)` by replacing occurrences of `old` in the string `s` with `new`. - Return the final transformed string after applying all transformations. 2. **Function 2: pattern_match** * **Input**: A string `s` and a pattern string `pattern`. * **Output**: A boolean value. * **Constraints**: - Both the string `s` and the pattern should be non-empty strings. - Raise a `ValueError` for invalid input (non-string or empty strings). * **Description**: - The function checks whether the string `s` matches the given pattern. - The pattern can include wildcards: * `?` matches any single character. * `*` matches any sequence of characters (including the empty sequence). - Return `True` if the string matches the pattern, `False` otherwise. Example Usage ```python # Applying transformations print(apply_transformations(\\"hello world\\", [(\\"hello\\", \\"hi\\"), (\\"world\\", \\"everyone\\")])) # \\"hi everyone\\" print(apply_transformations(\\"abcabc\\", [(\\"a\\", \\"x\\"), (\\"b\\", \\"y\\"), (\\"c\\", \\"z\\")])) # \\"xyzxyz\\" # Checking pattern match print(pattern_match(\\"hi everyone\\", \\"h*e\\")) # True print(pattern_match(\\"abcdefg\\", \\"a?c*fg\\")) # True print(pattern_match(\\"hello\\", \\"h?ello\\")) # False ``` Constraints * You must handle edge cases such as input containing invalid types or empty strings. * Ensure the performance and accuracy of the implementation. * The solution should be self-contained without any additional libraries. Good luck!","solution":"def apply_transformations(s: str, transformations: list) -> str: Applies a list of transformation rules to a given string. if not isinstance(s, str) or not s: raise ValueError(\\"Input string must be a non-empty string.\\") for old, new in transformations: if not isinstance(old, str) or not isinstance(new, str) or not old: raise ValueError(\\"Transformation rules must be non-empty strings.\\") s = s.replace(old, new) return s def pattern_match(s: str, pattern: str) -> bool: Checks if the given string matches a specific pattern. The pattern can include: - `?` matches any single character. - `*` matches any sequence of characters (including empty sequence). if not isinstance(s, str) or not isinstance(pattern, str) or not s or not pattern: raise ValueError(\\"Both string and pattern must be non-empty strings.\\") def match_helper(s, pattern, s_idx, p_idx): if p_idx == len(pattern): return s_idx == len(s) if pattern[p_idx] == \'*\': return match_helper(s, pattern, s_idx, p_idx + 1) or (s_idx < len(s) and match_helper(s, pattern, s_idx + 1, p_idx)) if s_idx < len(s) and (s[s_idx] == pattern[p_idx] or pattern[p_idx] == \'?\'): return match_helper(s, pattern, s_idx + 1, p_idx + 1) return False return match_helper(s, pattern, 0, 0)"},{"question":"# Coding Question: Stock Price Aggregator You are required to write a Python function that retrieves historical stock prices from an API and computes various metrics. One such API is Alpha Vantage, which provides daily stock data. # Function: `get_stock_analysis` Input: - `symbol` (string) representing the stock ticker symbol. - `start_date` (string) representing the start date in the format \'YYYY-MM-DD\'. - `end_date` (string) representing the end date in the format \'YYYY-MM-DD\'. Output: A dictionary containing the following metrics or an error message if the request fails or data is invalid: ```python { \\"Symbol\\": str, \\"Start Date\\": str, \\"End Date\\": str, \\"Average Closing Price\\": float, \\"Highest Closing Price\\": float, \\"Lowest Closing Price\\": float, \\"Total Volume\\": int, } ``` Constraints: 1. The `symbol` will always be a valid stock symbol string. 2. The `start_date` and `end_date` will be in \'YYYY-MM-DD\' format and valid. 3. Ensure proper handling of Alpha Vantage’s API rate-limiting and network errors. 4. Optimize for minimal API calls by retrieving all necessary data in a single call if possible. Note: - Use the actual API endpoint (with your own API key): `https://www.alphavantage.co/query?function=TIME_SERIES_DAILY&symbol={symbol}&apikey=YOUR_API_KEY` - The time series data is returned under the key `\\"Time Series (Daily)\\"`. - The function should handle any exceptions and return relevant error messages. - API key management should be handled outside the given code for security purposes. # Example: ```python def get_stock_analysis(symbol: str, start_date: str, end_date: str) -> dict: # Implement the function here pass # Running the function with specific symbol and dates should give results like: print(get_stock_analysis(\\"AAPL\\", \\"2022-01-01\\", \\"2022-01-31\\")) # Expected Output { \\"Symbol\\": \\"AAPL\\", \\"Start Date\\": \\"2022-01-01\\", \\"End Date\\": \\"2022-01-31\\", \\"Average Closing Price\\": 175.23, \\"Highest Closing Price\\": 182.94, \\"Lowest Closing Price\\": 167.83, \\"Total Volume\\": 547830000 } ```","solution":"import requests import datetime def get_stock_analysis(symbol: str, start_date: str, end_date: str) -> dict: # Define the API endpoint and your API key API_KEY = \'your_alpha_vantage_api_key\' URL = f\'https://www.alphavantage.co/query?function=TIME_SERIES_DAILY&symbol={symbol}&apikey={API_KEY}\' try: # Fetch the data from the API response = requests.get(URL) data = response.json() if \'Error Message\' in data: return {\\"error\\": \\"Invalid API call. Please check your API key and symbol.\\"} time_series = data[\\"Time Series (Daily)\\"] # Convert string dates to datetime objects for comparison start_date_obj = datetime.datetime.strptime(start_date, \'%Y-%m-%d\') end_date_obj = datetime.datetime.strptime(end_date, \'%Y-%m-%d\') closing_prices = [] volumes = [] for date, metrics in time_series.items(): date_obj = datetime.datetime.strptime(date, \'%Y-%m-%d\') if start_date_obj <= date_obj <= end_date_obj: closing_prices.append(float(metrics[\\"4. close\\"])) volumes.append(int(metrics[\\"5. volume\\"])) if not closing_prices: return {\\"error\\": \\"No data available for the given date range.\\"} average_close = sum(closing_prices) / len(closing_prices) highest_close = max(closing_prices) lowest_close = min(closing_prices) total_volume = sum(volumes) return { \\"Symbol\\": symbol, \\"Start Date\\": start_date, \\"End Date\\": end_date, \\"Average Closing Price\\": round(average_close, 2), \\"Highest Closing Price\\": highest_close, \\"Lowest Closing Price\\": lowest_close, \\"Total Volume\\": total_volume } except requests.exceptions.RequestException as e: return {\\"error\\": str(e)} except KeyError as e: return {\\"error\\": f\\"Unexpected response format: {str(e)}\\"}"},{"question":"# Question **Problem Statement**: You are given a string and a target word. Implement a function to find all starting indices in the string where the target word is found. The function should return the list of indices. Function Signature: ```python def find_word_indices(text: str, target_word: str) -> list[int]: pass ``` Input: - `text`: A string representing the text in which to search for the target word. `str`. - `target_word`: A string representing the word to search for in the text. `str`. Output: - Return a list of starting indices where the `target_word` is found in the `text`. If the word is not found, return an empty list. Constraints: - Assume the length of the text does not exceed (10^5). - The `target_word` does not contain spaces. Examples: - `find_word_indices(\\"hello world, hello universe\\", \\"hello\\")` should return `[0, 13]`. - `find_word_indices(\\"abracadabra\\", \\"abra\\")` should return `[0, 7]`. - `find_word_indices(\\"abracadabra\\", \\"cad\\")` should return `[4]`. - `find_word_indices(\\"aaaaa\\", \\"aa\\")` should return `[0, 1, 2, 3]`. Notes: - Overlapping occurrences should be considered. For example, in the text \\"aaaaa\\" searching for \\"aa\\" should return multiple overlapping indices `[0, 1, 2, 3]`. - Consider edge cases like an empty string or the target word being longer than the text. - Optimize the function for both time and space complexity. **Hint**: - Use a sliding window technique to compare slices of the text with the target word. Good luck!","solution":"def find_word_indices(text: str, target_word: str) -> list[int]: Returns a list of starting indices where the target_word is found in the text. :param text: str: The text in which to search for the target word. :param target_word: str: The word to search for in the text. :return: list[int]: List of starting indices where the target_word is found. indices = [] target_len = len(target_word) text_len = len(text) # Iterate through the text while checking for match with target_word for i in range(text_len - target_len + 1): if text[i:i + target_len] == target_word: indices.append(i) return indices"},{"question":"# Question: Efficient Fibonacci Computation The Fibonacci sequence is defined as follows: the first two terms are 0 and 1, and each subsequent term is the sum of the previous two terms. The sequence commonly goes 0, 1, 1, 2, 3, 5, 8, and so on. The direct computation of Fibonacci numbers using recursion can be very inefficient for large indices due to exponential time complexity. **Task**: Write a Python function that computes the nth Fibonacci number using an iterative approach to ensure efficient computation. Input: - An integer `n`, where `0 <= n <= 10^6`. Output: - An integer representing the nth Fibonacci number. Function Signature: ```python def efficient_fibonacci(n: int) -> int: pass ``` Constraints: - Your solution should handle large values of `n` efficiently. - Avoid recursive approaches to prevent stack overflow and high time complexity. - Consider utilizing constant space if possible. Example: ```python >>> efficient_fibonacci(0) 0 >>> efficient_fibonacci(1) 1 >>> efficient_fibonacci(10) 55 >>> efficient_fibonacci(100) 354224848179261915075 ``` **Hint**: Use iteration and keep track of only the last two Fibonacci numbers to compute the next one in linear time.","solution":"def efficient_fibonacci(n: int) -> int: Computes the nth Fibonacci number using an iterative approach. :param n: An integer representing the index of the Fibonacci number to compute. :return: The nth Fibonacci number. if n == 0: return 0 elif n == 1: return 1 prev, curr = 0, 1 for _ in range(2, n + 1): prev, curr = curr, prev + curr return curr"},{"question":"# Smallest Subarray with Given Sum You are given an array of positive integers and a target sum `S`. Implement an algorithm to find the smallest contiguous subarray whose sum is greater than or equal to `S`. Output the length of this shortest subarray. **Function Signature**: `def smallest_subarray_with_given_sum(arr: Sequence[int], S: int) -> int` **Inputs**: 1. `arr` (Sequence[int]): An array of positive integers. 2. `S` (int): The target sum that the subarray\'s sum should meet or exceed. **Outputs**: - An integer representing the length of the smallest subarray whose sum is greater than or equal to `S`. If no such subarray exists, return `0`. **Constraints**: - The array length will not exceed 10^5. - Each element in the array will not exceed 10^4. **Examples**: 1. `smallest_subarray_with_given_sum([2, 1, 5, 2, 3, 2], 7)` should return `2` (subarray `[5, 2]` has the smallest length with sum >= 7) 2. `smallest_subarray_with_given_sum([2, 1, 5, 2, 8], 7)` should return `1` (subarray `[8]` is the smallest subarray with sum >= 7) 3. `smallest_subarray_with_given_sum([3, 4, 1, 1, 6], 8)` should return `3` (subarray `[3, 4, 1]` or `[4, 1, 3]` or `[1, 1, 6]`) Implement the function `smallest_subarray_with_given_sum`.","solution":"from typing import Sequence def smallest_subarray_with_given_sum(arr: Sequence[int], S: int) -> int: window_sum = 0 min_length = float(\'inf\') window_start = 0 for window_end in range(len(arr)): window_sum += arr[window_end] while window_sum >= S: min_length = min(min_length, window_end - window_start + 1) window_sum -= arr[window_start] window_start += 1 return min_length if min_length != float(\'inf\') else 0"},{"question":"# Generate All Substrings Objective Write a function that generates all possible non-empty substrings of a given string. Ensure all substrings are unique. Function Signature ```python def unique_substrings(input_str: str) -> List[str]: ``` Parameters * `input_str` (str): The input string from which to generate substrings. Example: `\\"abc\\"` Returns * `List[str]`: A list containing all unique non-empty substrings of `input_str`. Constraints 1. `input_str` is guaranteed to be a valid string composed of lowercase alphabetic characters. 2. The length of `input_str` will be between 1 and 100 inclusive. Examples ```python >>> unique_substrings(\\"abc\\") [\'a\', \'ab\', \'abc\', \'b\', \'bc\', \'c\'] >>> unique_substrings(\\"aaa\\") [\'a\', \'aa\', \'aaa\'] >>> unique_substrings(\\"ab\\") [\'a\', \'ab\', \'b\'] ``` Edge Cases * Input string being a single character, e.g., `\\"a\\"`. * Input string having repeated characters, e.g., `\\"aaaaa\\"`. * Input string being a palindrome, e.g., `\\"madam\\"`. Instructions 1. Implement `unique_substrings` adhering to the function signature above. 2. Use efficient string operations to generate substrings. 3. Ensure the list maintains unique substrings only (no duplicates). Testing Use the provided examples and edge cases to validate your implementation.","solution":"from typing import List def unique_substrings(input_str: str) -> List[str]: Returns all unique non-empty substrings of the given input string. substrings = set() n = len(input_str) # Generate all possible substrings for i in range(n): for j in range(i + 1, n + 1): substrings.add(input_str[i:j]) return list(substrings)"}]'),S={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:N,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},O={class:"search-container"},F={class:"card-container"},L={key:0,class:"empty-state"},R=["disabled"],P={key:0},z={key:1};function Y(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",O,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",F,[(n(!0),i(b,null,w(a.displayedPoems,(o,f)=>(n(),v(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",L,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",z,"Loading...")):(n(),i("span",P,"See more"))],8,R)):u("",!0)])}const D=h(S,[["render",Y],["__scopeId","data-v-0c939e0f"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/16.md","filePath":"drive/16.md"}'),j={name:"drive/16.md"},U=Object.assign(j,{setup(r){return(e,l)=>(n(),i("div",null,[x(D)]))}});export{B as __pageData,U as default};
