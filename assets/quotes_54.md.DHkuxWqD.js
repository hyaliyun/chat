import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},E={class:"review-title"},A={class:"review-content"};function I(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",E,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",A,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const C=c(k,[["render",I],["__scopeId","data-v-448f25a2"]]),S=JSON.parse('[{"question":"# Evaluate Loan Eligibility Based on Credit Score and Income Problem Description: You are tasked with creating a function to determine loan eligibility based on the applicant\'s credit score and annual income. Criteria: 1. A credit score of 700 or above is required for consideration. 2. A minimum annual income of 30,000 is required. 3. If both conditions are met, the applicant is eligible for the loan. Otherwise, they are not. Function Signature: ```python def is_loan_eligible(credit_score: int, annual_income: float) -> bool: pass ``` Input: * An integer `credit_score` representing the applicant\'s credit score. (0 <= credit_score <= 850) * A float `annual_income` representing the applicant\'s annual income in dollars. (0 <= annual_income <= 1,000,000) Output: * A boolean `True` if the applicant meets both conditions, otherwise `False`. Constraints: * `credit_score` must be between 0 and 850 inclusive. * `annual_income` must be between 0 and 1,000,000 dollars inclusive. Examples: * **Example 1**: ```python is_loan_eligible(credit_score=750, annual_income=45000) ``` **Output**: ```python True ``` * **Example 2**: ```python is_loan_eligible(credit_score=680, annual_income=55000) ``` **Output**: ```python False ``` * **Example 3**: ```python is_loan_eligible(credit_score=720, annual_income=25000) ``` **Output**: ```python False ``` * **Example 4**: ```python is_loan_eligible(credit_score=815, annual_income=95000) ``` **Output**: ```python True ``` Notes: * The function should raise a `ValueError` if either `credit_score` or `annual_income` is outside the given range. Implement the `is_loan_eligible` function to evaluate loan eligibility according to the specified criteria.","solution":"def is_loan_eligible(credit_score: int, annual_income: float) -> bool: Determines loan eligibility based on credit score and annual income. Args: - credit_score (int): The applicant\'s credit score. - annual_income (float): The applicant\'s annual income. Returns: - bool: True if eligible, otherwise False. # Validate input ranges if not (0 <= credit_score <= 850): raise ValueError(\\"Credit score must be between 0 and 850.\\") if not (0 <= annual_income <= 1_000_000): raise ValueError(\\"Annual income must be between 0 and 1,000,000 dollars.\\") # Check loan eligibility criteria return credit_score >= 700 and annual_income >= 30_000"},{"question":"# Binary Search Tree Implementation with Balancing Problem Statement: You are tasked with implementing a Binary Search Tree (BST) that supports dynamic balancing using the AVL tree rotation techniques. The tree should maintain its height-balanced property with every insertion and deletion operation to ensure efficient execution of lookup, insert, and delete operations. Requirements: 1. **Function Signature**: ```python class AVLTree: def __init__(self) -> None: def insert(self, key: int) -> None: def delete(self, key: int) -> None: def find(self, key: int) -> bool: def inorder_traversal(self) -> List[int]: def __repr__(self) -> str: ``` 2. **Input and Output Format**: - `insert(self, key: int)`: Inserts a given key into the AVL tree while ensuring the tree remains balanced. - `delete(self, key: int)`: Removes a given key from the AVL tree while ensuring the tree remains balanced. - `find(self, key: int)`: Returns `True` if the key is present in the AVL tree, otherwise `False`. - `inorder_traversal(self)`: Returns a list of keys in the AVL tree in in-order traversal. - `__repr__(self)`: Returns a string representation of the AVL tree. 3. **Constraints**: - Key type is an integer. - Ensure the AVL tree maintains its balance property (i.e., for any node, the heights of the left and right subtrees differ by at most one). - Implement the necessary tree rotation mechanisms (left rotation, right rotation, left-right rotation, and right-left rotation) to keep the tree balanced. 4. **Performance Requirements**: - Ensure the AVL tree operations (insert, delete, and find) have a logarithmic time complexity of O(log n). Example Usage: ```python # Initializing AVL tree avl_tree = AVLTree() # Inserting elements avl_tree.insert(10) avl_tree.insert(20) avl_tree.insert(5) avl_tree.insert(4) avl_tree.insert(6) # Checking tree balance print(avl_tree) # Output: AVLTree(In-order: [4, 5, 6, 10, 20]) # In order traversal print(avl_tree.inorder_traversal()) # Output: [4, 5, 6, 10, 20] # Finding elements print(avl_tree.find(10)) # Output: True print(avl_tree.find(15)) # Output: False # Deleting an element avl_tree.delete(20) # Checking tree balance print(avl_tree) # Output: AVLTree(In-order: [4, 5, 6, 10]) ``` Implement the `AVLTree` class to fulfill the above specifications.","solution":"class AVLTreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self): self.root = None def insert(self, key): if not self.root: self.root = AVLTreeNode(key) else: self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return AVLTreeNode(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return self._balance(node) def delete(self, key): if not self.root: return else: self.root = self._delete(self.root, key) def _delete(self, node, key): if not node: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp = self._get_min_value_node(node.right) node.key = temp.key node.right = self._delete(node.right, temp.key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return self._balance(node) def find(self, key): return self._find(self.root, key) def _find(self, node, key): if not node: return False if key == node.key: return True elif key < node.key: return self._find(node.left, key) else: return self._find(node.right, key) def inorder_traversal(self): result = [] self._inorder_traversal(self.root, result) return result def _inorder_traversal(self, node, result): if not node: return self._inorder_traversal(node.left, result) result.append(node.key) self._inorder_traversal(node.right, result) def __repr__(self): return f\\"AVLTree(In-order: {self.inorder_traversal()})\\" def _balance(self, node): balance_factor = self._get_balance(node) if balance_factor > 1: if self._get_balance(node.left) < 0: node.left = self._rotate_left(node.left) return self._rotate_right(node) if balance_factor < -1: if self._get_balance(node.right) > 0: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def _rotate_right(self, y): x = y.left T2 = x.right x.right = y y.left = T2 y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) return x def _rotate_left(self, x): y = x.right T2 = y.left y.left = x x.right = T2 x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_min_value_node(self, node): current = node while current.left: current = current.left return current def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right)"},{"question":"Implementing a Basic Priority Queue You are tasked to design and implement a basic Priority Queue data structure using a binary heap in Python. This priority queue will allow for elements to be added and removed based on their priority, with the highest priority element being removed first. Priorities are defined using integer values, where a smaller integer indicates a higher priority. Description Implement a class `PriorityQueue` that supports the following methods: 1. `insert`: Inserts an element into the priority queue with an associated priority. 2. `remove`: Removes and returns the element with the highest priority. 3. `peek`: Retrieves, without removing, the element with the highest priority. 4. `is_empty`: Checks if the priority queue is empty. Requirements - Elements are stored in a binary heap where the element with the smallest priority value is always at the root. - Use a list to implement the binary heap, with the root element at index 0. - Ensure all methods adhere to the time complexity constraints of binary heap operations. Class Signature ```python class PriorityQueue: def __init__(self): pass def insert(self, element: Any, priority: int) -> None: pass def remove(self) -> Any: pass def peek(self) -> Any: pass def is_empty(self) -> bool: pass ``` Parameters: - The `element` parameter in the `insert` method can be of any type (`Any`). - The `priority` parameter in the `insert` method is an `int`. - `remove` and `peek` methods return the element with the highest priority. - `is_empty` method returns `True` if the priority queue is empty and `False` otherwise. Example Use Case: ```python >>> pq = PriorityQueue() >>> pq.insert(\'task1\', 3) >>> pq.insert(\'task2\', 1) >>> pq.insert(\'task3\', 2) >>> pq.peek() \'task2\' >>> pq.remove() \'task2\' >>> pq.remove() \'task3\' >>> pq.is_empty() False >>> pq.remove() \'task1\' >>> pq.is_empty() True ``` Constraints: - Each method in the class must operate within O(log n) time complexity for insert and remove methods due to heap operations. - `peek` and `is_empty` methods should operate in O(1) time complexity. This question assesses the candidate\'s ability to implement a fundamental data structure and utilize binary heap properties effectively.","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] def insert(self, element, priority): heapq.heappush(self.heap, (priority, element)) def remove(self): if self.is_empty(): raise IndexError(\\"remove from empty priority queue\\") return heapq.heappop(self.heap)[1] def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty priority queue\\") return self.heap[0][1] def is_empty(self): return len(self.heap) == 0"},{"question":"# Question: Implement a Cache with Expiration Policy You are tasked with creating a simple in-memory cache that supports basic operations like insertion, retrieval, and deletion of entries, along with an automatic expiration policy for cache entries. **Function Signatures:** ```python class Cache: def __init__(self): # Your code here def set(self, key: str, value: Any, ttl: int) -> None: # Your code here def get(self, key: str) -> Any: # Your code here def delete(self, key: str) -> None: # Your code here ``` # Input Format - The `set` function accepts three parameters: a string `key`, a value of any type, and an integer `ttl` (time-to-live in seconds). - The `get` function accepts a single string `key` and returns the corresponding value if it exists and has not expired; otherwise, it returns `None`. - The `delete` function accepts a single string `key` and removes the entry from the cache. # Constraints - Ensure the expired entries are not retrievable. - Manage the cache efficiently, updating entries\' expiration statuses appropriately. # Example ```python cache = Cache() cache.set(\\"a\\", 1, 10) # Set key \\"a\\" with value 1 and TTL of 10 seconds import time time.sleep(5) assert cache.get(\\"a\\") == 1 # Value is still valid time.sleep(6) assert cache.get(\\"a\\") is None # Value has expired cache.set(\\"b\\", 2, 5) # Set key \\"b\\" with value 2 and TTL of 5 seconds time.sleep(3) cache.delete(\\"b\\") assert cache.get(\\"b\\") is None # Key \\"b\\" was deleted before expiration ``` # Notes - Implement the cache using any efficient data structures of your choice. - Handle edge cases such as setting values with zero or negative TTLs appropriately (e.g., consider them as immediate expiration). This question tests your ability to handle stateful data structures, time-based policies, and efficient data access patterns in addition to typical insertion and deletion operations.","solution":"import time from typing import Any, Dict, Optional class Cache: def __init__(self): # Dictionary to hold the cache data self.store: Dict[str, Any] = {} # Dictionary to hold the expiration times self.expirations: Dict[str, float] = {} def set(self, key: str, value: Any, ttl: int) -> None: Sets a key with a given value and time-to-live (ttl). self.store[key] = value # Set the expiration time as current time + ttl self.expirations[key] = time.time() + ttl def get(self, key: str) -> Optional[Any]: Retrieves the value for a given key if it exists and has not expired. Returns None if the key does not exist or has expired. if key in self.store: if time.time() < self.expirations.get(key, 0): return self.store[key] else: # Item has expired, remove it self.delete(key) return None else: return None def delete(self, key: str) -> None: Deletes a given key from the cache. if key in self.store: del self.store[key] if key in self.expirations: del self.expirations[key]"},{"question":"# Problem: You are tasked with building a function that validates and formats phone numbers. The function should support phone numbers from three specific countries: the United States, the United Kingdom, and India. The function will validate the format of the input phone number and convert it into a standardized format. The expected formats are as follows: - United States: +1-XXX-XXX-XXXX - United Kingdom: +44-XXXX-XXXXXX - India: +91-XXXXX-XXXXX # Function Signature: ```python def format_phone_number(phone_number: str, country: str) -> str: Validate and format a phone number based on the given country\'s standard format. :param phone_number: The phone number as a string (str). :param country: The country of the phone number (str). Valid values are \\"United States\\", \\"United Kingdom\\", \\"India\\". :return: The phone number formatted to the target country\'s standard (str). :raises ValueError: if an invalid phone number or country is provided. ``` # Input: * `phone_number`: A string representing the phone number to validate and format. * `country`: A string representing the country of the phone number (`\\"United States\\"`, `\\"United Kingdom\\"`, `\\"India\\"`). # Output: * A string representing the formatted phone number in the target country\'s standard format. # Constraints: * `phone_number` should be a valid phone number string. * `country` should be one of `\\"United States\\"`, `\\"United Kingdom\\"`, `\\"India\\"`. # Example Usage: ```python >>> format_phone_number(\\"1234567890\\", \\"United States\\") \'+1-123-456-7890\' >>> format_phone_number(\\"0712345678\\", \\"United Kingdom\\") \'+44-0712-345678\' >>> format_phone_number(\\"9876543210\\", \\"India\\") \'+91-98765-43210\' ``` # Notes: * Handle invalid phone numbers or unsupported country values by raising a `ValueError` with a descriptive message. * Ensure that valid phone numbers in their raw form can be parsed and formatted correctly according to the specified country\'s format. * Consider edge cases such as phone numbers with different lengths or invalid characters, and manage those appropriately by raising a `ValueError`. * You can assume that any country not listed is unsupported and should result in a `ValueError`.","solution":"import re def format_phone_number(phone_number: str, country: str) -> str: Validate and format a phone number based on the given country\'s standard format. :param phone_number: The phone number as a string (str). :param country: The country of the phone number (str). Valid values are \\"United States\\", \\"United Kingdom\\", \\"India\\". :return: The phone number formatted to the target country\'s standard (str). :raises ValueError: if an invalid phone number or country is provided. if country == \\"United States\\": if re.fullmatch(r\'d{10}\', phone_number): return f\\"+1-{phone_number[:3]}-{phone_number[3:6]}-{phone_number[6:]}\\" else: raise ValueError(\\"Invalid phone number format for the United States.\\") elif country == \\"United Kingdom\\": if re.fullmatch(r\'d{10}\', phone_number): return f\\"+44-{phone_number[:4]}-{phone_number[4:]}\\" else: raise ValueError(\\"Invalid phone number format for the United Kingdom.\\") elif country == \\"India\\": if re.fullmatch(r\'d{10}\', phone_number): return f\\"+91-{phone_number[:5]}-{phone_number[5:]}\\" else: raise ValueError(\\"Invalid phone number format for India.\\") else: raise ValueError(\\"Unsupported country.\\")"},{"question":"# Background In graph theory, a strongly connected component (SCC) of a directed graph is a maximal strongly connected subgraph. The Kosaraju\'s algorithm is a popular way to find all SCCs in a given directed graph. # Problem Statement Write a function `find_scc(graph: Dict[int, List[int]]) -> List[List[int]]` that takes a directed graph and returns all its strongly connected components. # Input - `graph`: A dictionary where keys are node identifiers (integers) and values are lists of integers representing the nodes that are accessible from the key node. # Output - A list of lists, where each inner list represents a strongly connected component of the graph. Each node identifier should appear exactly once across all lists. # Constraints - The graph nodes are numbered from 0 to n-1 for some integer n. - The graph can have at most 5000 nodes and 10000 edges. - Graph edges are directed and there can be self-loops or multiple edges between nodes. # Example ```python graph = { 0: [1], 1: [2], 2: [0, 3], 3: [4], 4: [5, 7], 5: [6], 6: [4], 7: [8], 8: [7] } result = find_scc(graph) # Example output # [[0, 1, 2], [3], [4, 5, 6], [7, 8]] ``` # Notes - You may use Kosaraju\'s algorithm, Tarjan\'s algorithm, or any other method to find SCCs. - The order of nodes in the output does not matter, nor does the order of SCCs. - Ensure that your function runs efficiently for the input size. # Hints - Kosaraju\'s algorithm involves two passes of depth-first search (DFS). The first pass is used to record the postorder of nodes. The second pass processes nodes in the order of decreasing postorder. # Solution Sketch 1. Perform DFS on the original graph to get the finishing times of each node. 2. Reverse the graph (i.e., reverse the direction of all edges). 3. Perform DFS on the reversed graph, processing nodes in decreasing order of their finishing times. 4. Each tree in the forest formed in the second DFS pass is a strongly connected component.","solution":"def find_scc(graph): def dfs_first_pass(node, visited, stack): visited.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: dfs_first_pass(neighbor, visited, stack) stack.append(node) def dfs_second_pass(node, visited, component, reversed_graph): visited.add(node) component.append(node) for neighbor in reversed_graph.get(node, []): if neighbor not in visited: dfs_second_pass(neighbor, visited, component, reversed_graph) # Step 1: Perform the first DFS pass to get the finishing times visited = set() stack = [] for node in graph: if node not in visited: dfs_first_pass(node, visited, stack) # Step 2: Reverse the graph reversed_graph = {} for node in graph: for neighbor in graph[node]: if neighbor not in reversed_graph: reversed_graph[neighbor] = [] reversed_graph[neighbor].append(node) # Step 3: Perform the second DFS pass on the reversed graph visited = set() sccs = [] while stack: node = stack.pop() if node not in visited: component = [] dfs_second_pass(node, visited, component, reversed_graph) sccs.append(component) return sccs"},{"question":"# Asynchronous Data Processing with Event-Driven Architecture You are tasked with designing a system that processes data asynchronously using an event-driven architecture. The system should handle network requests, process the incoming data, and store the results in a database. Your objective is to implement the data processing worker that manages these tasks. Function Specification: Implement the function `process_data(event_loop: Any, data_queue: asyncio.Queue, db: Any) -> None`. This function should: 1. Continuously monitor the `data_queue` for incoming data packets. 2. Use an asynchronous HTTP client to send requests to a remote server. 3. Upon receiving responses, process the response data to extract meaningful information. 4. Store the processed information in the provided database interface. 5. Implement error handling to manage network errors, data processing errors, and database interaction errors gracefully. 6. Ensure the function can handle termination signals to shut down cleanly. Input: - `event_loop` (Any): The asynchronous event loop that the function will use for running tasks. - `data_queue` (asyncio.Queue): An asyncio queue that holds the data packets to be processed. - `db` (Any): A database interface object with an `insert_data(data: dict)` method to store the processed information. Constraints: - The data queue may have data packets of varying size and complexity. - Ensure efficient asynchronous network operations using aiohttp or a similar library. - The system should be robust to handle intermittent network failures and retry failed requests. - Pay attention to performance and error handling. - The database interface is a simplified abstraction, you do not need to implement the actual database connection, but the function should interact with it as specified. Example Usage: ```python import asyncio import aiohttp from database_interface import DatabaseInterface async def main(): event_loop = asyncio.get_event_loop() data_queue = asyncio.Queue() db = DatabaseInterface() # Simulated data generation await data_queue.put({\\"id\\": 1, \\"payload\\": \\"data1\\"}) await data_queue.put({\\"id\\": 2, \\"payload\\": \\"data2\\"}) # Start the data processing worker await process_data(event_loop, data_queue, db) if __name__ == \\"__main__\\": asyncio.run(main()) ``` Notes: - You may assume the `DatabaseInterface` provides the necessary methods for interacting with the database. - Consider using `asyncio.Queue` for inter-task communication between the data producer and the data processing worker. - Ensure proper logging of events such as data receipt, processing, storage, and errors for monitoring the system. - The function should terminate gracefully when it receives a shutdown signal (e.g., SIGINT).","solution":"import asyncio import aiohttp import logging async def process_data(event_loop, data_queue: asyncio.Queue, db): async with aiohttp.ClientSession() as session: while True: try: data_packet = await data_queue.get() if data_packet is None: # Termination signal break # Send async HTTP request async with session.post(\'http://example.com/endpoint\', json=data_packet) as response: if response.status == 200: response_data = await response.json() # Process response data processed_data = extract_data(response_data) # Insert processed data into the database db.insert_data(processed_data) else: logging.error(f\\"Failed to process data_packet {data_packet}: {response.status}\\") except aiohttp.ClientError as e: logging.error(f\\"Network error: {e}\\") # Retry logic could be added here except Exception as e: logging.error(f\\"Error processing data_packet {data_packet}: {e}\\") finally: data_queue.task_done() def extract_data(response_data): # Placeholder function to process the response data # Assuming we extract some meaningful information from the response return {\\"processed_data\\": response_data} # Example DatabaseInterface for testing purposes class DatabaseInterface: def insert_data(self, data: dict): logging.info(f\\"Data inserted to DB: {data}\\")"},{"question":"# Coding Assessment Question Context Develop a function to simulate the management of a bookstore. In this bookstore, books can be added, removed, and their information can be retrieved. Each book is represented by a title (string), an author (string), and a number of copies available (integer). Task Implement a class named `Bookstore` that contains the following methods: 1. `add_book(title: str, author: str, copies: int) -> None`: Adds a new book to the store. If the book already exists, it updates the number of copies available. 2. `remove_book(title: str) -> None`: Removes a book from the store by its title. If the book does not exist, it raises a `ValueError`. 3. `get_book_info(title: str) -> dict[str, str | int]`: Retrieves the information of a book as a dictionary. If the book does not exist, it raises a `ValueError`. Class Signature ```python class Bookstore: def __init__(self): pass def add_book(self, title: str, author: str, copies: int) -> None: pass def remove_book(self, title: str) -> None: pass def get_book_info(self, title: str) -> dict[str, str | int]: pass ``` Input Format * `title` (str): The title of the book. * `author` (str): The author of the book. * `copies` (int): The number of copies available. Output Format * The `get_book_info` method should return a dictionary with the book\'s title, author, and the number of copies available. Constraints * `title` and `author` should be non-empty strings. * `copies` should be a non-negative integer. * If `title` does not exist in the bookstore for `remove_book` or `get_book_info`, raise a `ValueError` with the message \\"Book not found\\". Examples ```python >>> bookstore = Bookstore() >>> bookstore.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 3) >>> bookstore.get_book_info(\\"The Great Gatsby\\") {\'title\': \'The Great Gatsby\', \'author\': \'F. Scott Fitzgerald\', \'copies\': 3} >>> bookstore.add_book(\\"1984\\", \\"George Orwell\\", 5) >>> bookstore.remove_book(\\"The Great Gatsby\\") >>> bookstore.get_book_info(\\"The Great Gatsby\\") Traceback (most recent call last): ... ValueError: Book not found >>> bookstore.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 2) >>> bookstore.get_book_info(\\"To Kill a Mockingbird\\") {\'title\': \'To Kill a Mockingbird\', \'author\': \'Harper Lee\', \'copies\': 2} ``` Additional Notes * Ensure your implementation handles various edge cases, such as updating the number of copies for an existing book. * The methods should perform efficiently even if the bookstore has a large collection of books.","solution":"class Bookstore: def __init__(self): self.books = {} def add_book(self, title: str, author: str, copies: int) -> None: if title in self.books: self.books[title][\'copies\'] += copies else: self.books[title] = {\'title\': title, \'author\': author, \'copies\': copies} def remove_book(self, title: str) -> None: if title not in self.books: raise ValueError(\\"Book not found\\") del self.books[title] def get_book_info(self, title: str) -> dict: if title not in self.books: raise ValueError(\\"Book not found\\") return self.books[title]"},{"question":"# Context: In graph theory, a graph traversal technique often used is the Breadth-First Search (BFS). BFS is used to explore the nodes of a graph or tree level by level, starting from a specified starting node. This can be particularly useful for finding the shortest path from one node to another in an unweighted graph. # Task: Write a function `bfs_shortest_path(graph: dict, start: str, end: str) -> list` that computes the shortest path between two nodes in an undirected graph using the BFS algorithm. # Input: * A dictionary `graph` where keys are node identifiers (strings) and values are lists of adjacent nodes (also identified by strings). * Two strings `start` and `end` representing the starting node and the target node, respectively. # Output: * A list of nodes representing the shortest path from the `start` node to the `end` node. * If no path exists, return an empty list. # Constraints: * The function should handle cases where the graph is empty or the start and end nodes are not in the graph. * Assume the graph is connected and undirected. # Requirements: * Validate input to ensure that the start and end nodes exist in the graph. * Ensure the implementation is robust against cycles and large graphs. * Handle edge cases gracefully, such as when start and end nodes are the same. Example Usage: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } print(bfs_shortest_path(graph, \'A\', \'F\')) # Expected output: [\'A\', \'C\', \'F\'] print(bfs_shortest_path(graph, \'A\', \'D\')) # Expected output: [\'A\', \'B\', \'D\'] print(bfs_shortest_path(graph, \'A\', \'A\')) # Expected output: [\'A\'] (start and end are the same) print(bfs_shortest_path(graph, \'A\', \'G\')) # Expected output: [] (end node not in graph) ```","solution":"from collections import deque def bfs_shortest_path(graph, start, end): Computes the shortest path between two nodes in an undirected graph using BFS. :param graph: dictionary representing the graph where keys are nodes and values are lists of adjacent nodes. :param start: the starting node for the search. :param end: the target node for the search. :return: a list of nodes representing the shortest path from start to end. if start not in graph or end not in graph: return [] if start == end: return [start] queue = deque([[start]]) visited = set() while queue: path = queue.popleft() node = path[-1] if node not in visited: neighbours = graph[node] for neighbour in neighbours: new_path = list(path) new_path.append(neighbour) queue.append(new_path) if neighbour == end: return new_path visited.add(node) return []"},{"question":"# Matrix Diagonal Manipulation Scenario An innovative matrix operation requires modifying a square matrix by zeroing out all the elements in its anti-diagonal. In a square matrix, the anti-diagonal runs from the bottom-left to the top-right of the matrix. Task Write a function `zero_anti_diagonal` that sets all elements in the anti-diagonal of a given n x n matrix to zero. Function Signature ```python def zero_anti_diagonal(matrix: List[List[int]]) -> List[List[int]]: Zeroes out the anti-diagonal elements in a square matrix. :param matrix: A list of lists representing an n x n matrix. :returns: The modified matrix with anti-diagonal elements set to zero. Examples: >>> zero_anti_diagonal([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) [ [1, 2, 0], [4, 0, 6], [0, 8, 9] ] >>> zero_anti_diagonal([ [2, 4, 6, 8], [3, 5, 7, 9], [1, 0, 2, 3], [4, 3, 6, 7] ]) [ [2, 4, 6, 0], [3, 5, 0, 9], [1, 0, 2, 3], [0, 3, 6, 7] ] ``` Input and Output Format - **Input**: - `matrix`: A square matrix represented as a list of lists, where each inner list represents a row of the matrix. - **Output**: - A list of lists where the elements in the anti-diagonal of the matrix are set to zero, while the rest of the matrix remains unchanged. Constraints - The matrix will be a square matrix (( n times n )) with ( 1 leq n leq 1000 ). - The matrix elements will be integers. Example ```python assert zero_anti_diagonal([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) == [ [1, 2, 0], [4, 0, 6], [0, 8, 9] ] assert zero_anti_diagonal([ [2, 4, 6, 8], [3, 5, 7, 9], [1, 0, 2, 3], [4, 3, 6, 7] ]) == [ [2, 4, 6, 0], [3, 5, 0, 9], [1, 0, 2, 3], [0, 3, 6, 7] ] ```","solution":"from typing import List def zero_anti_diagonal(matrix: List[List[int]]) -> List[List[int]]: Zeroes out the anti-diagonal elements in a square matrix. :param matrix: A list of lists representing an n x n matrix. :returns: The modified matrix with anti-diagonal elements set to zero. n = len(matrix) for i in range(n): matrix[i][n - 1 - i] = 0 return matrix"},{"question":"# Question You are given a square matrix of integers where each element represents the cost of traveling through that cell. You want to reach the bottom-right corner of the matrix starting from the top-left corner with the minimum cost. You can only move right or down from a cell. Implement a function to find the minimum cost to traverse from the top-left to the bottom-right of the matrix. # Requirements * **Function Signature**: `def min_path_cost(matrix: list[list[int]]) -> int:` * **Parameters**: - `matrix`: A 2D list of integers where the outer list contains `n` nested lists each containing `n` integers (`n >= 1`). * **Returns**: An integer representing the minimum cost to reach the bottom-right corner from the top-left corner. # Constraints 1. The matrix will always be a square matrix (i.e., the number of rows and columns will be equal). 2. The integers in the matrix will be non-negative. # Example ```python matrix = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(min_path_cost(matrix)) # Output should be 7 matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(min_path_cost(matrix)) # Output should be 21 ``` # Implementation Guidelines * Use dynamic programming to solve the problem efficiently. * Create a 2D list `dp` where `dp[i][j]` represents the minimum cost to reach cell `(i, j)`. * Initialize `dp[0][0]` with the value of `matrix[0][0]`. * Formulate the recurrence relation to fill out the `dp` table based on the valid moves (right and down). * Finally, return the value in `dp[n-1][n-1]`.","solution":"def min_path_cost(matrix: list[list[int]]) -> int: if not matrix or not matrix[0]: return 0 n = len(matrix) # Initialize the dp table with the same dimensions as matrix dp = [[0] * n for _ in range(n)] # Base case dp[0][0] = matrix[0][0] # Fill the first row, can only come from the left for i in range(1, n): dp[0][i] = dp[0][i - 1] + matrix[0][i] # Fill the first column, can only come from above for i in range(1, n): dp[i][0] = dp[i - 1][0] + matrix[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, n): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j] # Return the value in the bottom right corner return dp[-1][-1]"},{"question":"# Context In computer graphics, colors are often represented in the RGB color model. In this model, each color is described by three components - red, green, and blue - each ranging from 0 to 255. A common task in image processing is to adjust the brightness of an image, which can be done by modifying these RGB components. # Problem You are required to implement a function `adjust_brightness(image: list[list[tuple[int, int, int]]], factor: float) -> list[list[tuple[int, int, int]]]` that accepts a 2D list representing an image and a brightness adjustment factor. The function should return the adjusted image. # Detailed Requirements 1. **Input Format**: - `image`: A 2D list where each element is a tuple representing an RGB color (i.e., `(red, green, blue)`), with values in the range [0, 255]. - `factor`: A float representing the factor by which to adjust the brightness. A factor > 1 increases brightness, while a factor < 1 decreases brightness. 2. **Adjustment Calculation**: - Adjust each RGB component by multiplying it with the factor. - Ensure that the adjusted values are clamped within the [0, 255] range. 3. **Edge Case Handling**: - If the input `image` is empty, return an empty list. 4. **Return Value**: The function returns a 2D list representing the adjusted image. # Function Signature ```python def adjust_brightness(image: list[list[tuple[int, int, int]]], factor: float) -> list[list[tuple[int, int, int]]]: ``` # Example ```python >>> adjust_brightness(image=[[(100, 100, 100), (50, 50, 50)], [(200, 200, 200), (25, 25, 25)]], factor=1.2) [[(120, 120, 120), (60, 60, 60)], [(240, 240, 240), (30, 30, 30)]] >>> adjust_brightness(image=[[(255, 255, 255), (0, 0, 0)], [(128, 128, 128), (64, 64, 64)]], factor=0.5) [[(127, 127, 127), (0, 0, 0)], [(64, 64, 64), (32, 32, 32)]] >>> adjust_brightness(image=[[(255, 128, 64)]], factor=2.0) [[(255, 255, 128)]] >>> adjust_brightness(image=[], factor=1.5) [] >>> adjust_brightness(image=[[(10, 20, 30), (40, 50, 60)]], factor=0.0) [[(0, 0, 0), (0, 0, 0)]] ``` # Constraints 1. The input 2D list (`image`) will have dimensions at most 500x500. 2. Each RGB component in the image tuples will be an integer within the range [0, 255]. 3. The brightness factor (`factor`) will be a non-negative float. # Notes - Be mindful of performance as the function may need to handle large images. - Ensure the function is robust and handles clamping the RGB values correctly.","solution":"def clamp(value, min_value, max_value): return max(min_value, min(value, max_value)) def adjust_brightness(image, factor): if not image: return [] adjusted_image = [] for row in image: adjusted_row = [] for (red, green, blue) in row: adjusted_red = clamp(int(red * factor), 0, 255) adjusted_green = clamp(int(green * factor), 0, 255) adjusted_blue = clamp(int(blue * factor), 0, 255) adjusted_row.append((adjusted_red, adjusted_green, adjusted_blue)) adjusted_image.append(adjusted_row) return adjusted_image"},{"question":"# Coding Assessment Question **Problem Statement:** Design a class to manage a limited-size logging system. Your task is to implement methods to add a log message, retrieve the most recent log messages, and check if a specific log message exists. The logging system should only keep the last `n` log messages, where `n` is a positive integer provided at the system\'s initialization. **Class Definition**: ```python class LogSystem: def __init__(self, size: int): # Initialize with a maximum size for the log system. def add_log(self, log: str) -> None: # Adds a new log message to the system. def get_recent_logs(self, count: int) -> List[str]: # Retrieves the most recent `count` log messages. def contains_log(self, log: str) -> bool: # Checks if a specific log message exists in the system. ``` **Function Signatures**: ```python class LogSystem: def __init__(self, size: int): def add_log(self, log: str) -> None: def get_recent_logs(self, count: int) -> List[str]: def contains_log(self, log: str) -> bool: ``` **Expected Input/Output**: - The constructor initializes the log system with a specified maximum size. - `add_log(self, log: str) -> None`: Adds a new log message to the system. - If the number of logs exceeds the maximum size, the oldest log is removed. - `get_recent_logs(self, count: int) -> List[str]`: Returns the most recent `count` log messages in order from the newest to the oldest. - If `count` exceeds the number of logs present, return all logs. - `contains_log(self, log: str) -> bool`: Returns `True` if the specified log message exists in the system, otherwise returns `False`. **Constraints**: - The log system size will be between 1 and 1000. - Each log message is a non-empty string with a maximum length of 255 characters. - The operations `add_log`, `get_recent_logs`, and `contains_log` must be efficient to handle at least 100,000 operations quickly. **Example**: ```python log_system = LogSystem(3) log_system.add_log(\\"error: failed to connect to database\\") log_system.add_log(\\"info: connected to database\\") log_system.add_log(\\"warn: low memory\\") log_system.add_log(\\"info: storing data\\") # Most recent logs (order: newest to oldest) assert log_system.get_recent_logs(2) == [\\"info: storing data\\", \\"warn: low memory\\"] # Check if a specific log exists assert log_system.contains_log(\\"info: connected to database\\") == False assert log_system.contains_log(\\"error: failed to connect to database\\") == False assert log_system.contains_log(\\"info: storing data\\") == True ``` **Note**: - Ensure the methods handle edge cases such as adding logs beyond the maximum size, and requesting more logs than available. - Optimize the data structure for efficient addition and retrieval of logs. - Consider using appropriate built-in data structures to maintain the integrity and performance of the log system.","solution":"from collections import deque from typing import List class LogSystem: def __init__(self, size: int): self.size = size self.logs = deque() def add_log(self, log: str) -> None: if len(self.logs) == self.size: self.logs.popleft() self.logs.append(log) def get_recent_logs(self, count: int) -> List[str]: return list(self.logs)[-count:][::-1] def contains_log(self, log: str) -> bool: return log in self.logs"},{"question":"# Question: Binary Tree Level Order Traversal with Zigzag Pattern You are required to implement a binary tree traversal algorithm, specifically a zigzag level order traversal. In this traversal, the nodes at each level of the tree are traversed from left to right, then from right to left for the next level, and this pattern continues alternately. # Task: 1. **Implement the Binary Tree Node and Zigzag Level Order Traversal**: - Create a class `TreeNode` to represent nodes in the binary tree. - Create a function `zigzagLevelOrder` that: - Accepts the root of a binary tree. - Returns a list of lists, where each sublist contains the values of nodes at that level, traversed in the alternating left-to-right and right-to-left order. # Specifications: - **`TreeNode` Class**: - `__init__(self, value: int, left: TreeNode | None = None, right: TreeNode | None = None)`: Initialize a tree node with a value, a left child, and a right child. - **Function**: - `zigzagLevelOrder(root: TreeNode | None) -> list[list[int]]`: Traverse the binary tree in a zigzag level order and return the values of nodes at each level accordingly. # Input and Output - **Input**: - A binary tree rooted at `root`. - **Output**: - A list of lists, each containing the values of the nodes at each level in zigzag order. # Constraints: - The number of nodes in the tree will be in the range [0, 2000]. - -100 <= Node.val <= 100 # Example: ```python class TreeNode: def __init__(self, value: int, left: TreeNode | None = None, right: TreeNode | None = None): self.value = value self.left = left self.right = right def zigzagLevelOrder(root: TreeNode | None) -> list[list[int]]: if not root: return [] result = [] current_level = [root] left_to_right = True while current_level: level_values = [node.value for node in current_level] if not left_to_right: level_values.reverse() result.append(level_values) next_level = [] for node in current_level: if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) current_level = next_level left_to_right = not left_to_right return result # Example Binary Tree: # 3 # / # 9 20 # / / # None None 15 7 root = TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))) print(zigzagLevelOrder(root)) # Output: [[3], [20, 9], [15, 7]] ``` # Deliverables: - The complete implementation of `TreeNode` and `zigzagLevelOrder`. - Analysis of the implemented algorithm regarding its time and space complexity. - Unittests to validate the correct operation of the zigzag level order traversal for edge cases and general cases.","solution":"class TreeNode: def __init__(self, value: int, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.value = value self.left = left self.right = right def zigzagLevelOrder(root: TreeNode | None) -> list[list[int]]: if not root: return [] result = [] current_level = [root] left_to_right = True while current_level: level_values = [node.value for node in current_level] if not left_to_right: level_values.reverse() result.append(level_values) next_level = [] for node in current_level: if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) current_level = next_level left_to_right = not left_to_right return result"},{"question":"# Question: Array Rotation Checker Implement a function `is_rotated_array(original: List[int], rotated: List[int]) -> bool` that checks if the `rotated` array is a rotation of the `original` array. Function Signature: ```python def is_rotated_array(original: List[int], rotated: List[int]) -> bool: pass ``` # Input: * Two lists of integers `original` and `rotated` where the length of both lists is the same: `0 <= len(original), len(rotated) <= 10^5`. # Output: * A boolean indicating whether `rotated` is a rotation of `original`. # Constraints: * The function should perform efficiently even for the upper limits of the input size. # Example: ```python assert is_rotated_array([1, 2, 3, 4, 5], [3, 4, 5, 1, 2]) == True assert is_rotated_array([1, 2, 3, 4, 5], [4, 5, 1, 2, 3]) == True assert is_rotated_array([1, 2, 3, 4, 5], [2, 3, 4, 5, 6]) == False assert is_rotated_array([1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) == True assert is_rotated_array([], []) == True assert is_rotated_array([1], [1]) == True assert is_rotated_array([1, 2, 3], [3, 1, 2]) == True ``` # Performance Requirements: * The function must run in O(n) time complexity where n is the length of the arrays. **Hint**: Consider concatenating the original array to itself when searching for the rotated array within it. # Scenario: Consider you are building a system where order and rotation of data sequences matter, and you need a method to verify if one representation of data is simply a rotated version of another. This could apply to scenarios in data processing, sequence analysis, and array manipulations at large data scales. Optimize your solution for performance, especially for the largest possible inputs.","solution":"from typing import List def is_rotated_array(original: List[int], rotated: List[int]) -> bool: Checks if the \'rotated\' array is a rotation of the \'original\' array. if len(original) != len(rotated): return False if not original and not rotated: return True # Concatenate the original list with itself and check if the rotated list is a subsequence of it doubled = original + original for i in range(len(original)): if doubled[i:i+len(rotated)] == rotated: return True return False"},{"question":"# Scenario: You are part of a development team that is optimizing the performance of a webpage. One aspect of this task involves minimizing the number of HTTP requests by consolidating multiple images into a single \\"sprite\\" image. You now need to implement a function that generates the CSS rules necessary to display individual images from the sprite. # Task: Implement a Python function `generate_sprite_css(image_positions: Dict[str, Tuple[int, int]]) -> Dict[str, str]` that: 1. Accepts a dictionary where: - The keys are the image names. - The values are tuples representing the x and y coordinates of the top-left corner of each image within the sprite. 2. Generates the CSS rules to display each individual image from the sprite. 3. Returns a dictionary where the keys are the image names and the values are strings containing the corresponding CSS rules. # Input: - `image_positions` (Dict[str, Tuple[int, int]]): A dictionary with image names as keys and (x, y) coordinates as values. # Output: - (Dict[str, str]): A dictionary with image names as keys and the corresponding CSS rules as values. # Example: ```python image_positions = { \\"logo\\": (0, 0), \\"button\\": (50, 50), \\"icon\\": (100, 100) } result = generate_sprite_css(image_positions) # Expected result: # { # \\"logo\\": \\"background: url(\'sprite.png\') 0px 0px no-repeat;\\", # \\"button\\": \\"background: url(\'sprite.png\') -50px -50px no-repeat;\\", # \\"icon\\": \\"background: url(\'sprite.png\') -100px -100px no-repeat;\\" # } ``` # Constraints: - The image names will be non-empty strings. - The coordinates will be non-negative integers. # Notes: - Ensure that the generated CSS rules follow the correct syntax. - Assume the file name of the sprite is \\"sprite.png\\". - Negative offsets should be properly formatted in the CSS rules (e.g., \\"-50px\\" instead of \\"50px\\"). # Solution: Implement the `generate_sprite_css` function to generate the required CSS rules based on the image positions provided. ```python def generate_sprite_css(image_positions): css_rules = {} for img_name, (x, y) in image_positions.items(): css_rules[img_name] = f\\"background: url(\'sprite.png\') -{x}px -{y}px no-repeat;\\" return css_rules # Example usage: image_positions = { \\"logo\\": (0, 0), \\"button\\": (50, 50), \\"icon\\": (100, 100) } result = generate_sprite_css(image_positions) print(result) ```","solution":"from typing import Dict, Tuple def generate_sprite_css(image_positions: Dict[str, Tuple[int, int]]) -> Dict[str, str]: Generates the CSS rules necessary to display individual images from the sprite based on their positions. Args: image_positions (Dict[str, Tuple[int, int]]): A dictionary with image names as keys and (x, y) coordinates as values. Returns: Dict[str, str]: A dictionary with image names as keys and the corresponding CSS rules as values. css_rules = {} for img_name, (x, y) in image_positions.items(): css_rules[img_name] = f\\"background: url(\'sprite.png\') -{x}px -{y}px no-repeat;\\" return css_rules"},{"question":"# Sentence Reversal with Constraints Context: Reversing words in a sentence is a common problem in string manipulation exercises. This advanced variation introduces constraints that make the problem more complex. You will need to reverse the words in the sentence while preserving the positions of the punctuation marks and spaces. Problem Statement: Write a function `reverse_sentence_with_constraints(sentence: str) -> str` that reverses the words in the given sentence while keeping the punctuation marks and spaces in their original positions. * You must maintain the original position of every punctuation character (e.g., period, comma, exclamation mark, etc.) and every space within the sentence. * Only the actual words (sequences of alphabetical characters) will be reversed. Input: * `sentence` - a string containing words, spaces, and punctuation marks. Output: * A string with the words reversed, but punctuation marks and spaces in their original positions. Example: ```python sentence = \\"Hello, world! Check out this new feature.\\" reverse_sentence_with_constraints(sentence) ``` Expected Output: ```python \\"olleH, dlrow! kcehC tuo siht wen erutaef.\\" ``` Constraints: 1. The sentence will only contain printable ASCII characters. 2. There will be no leading or trailing spaces. 3. Words are separated by single spaces, and words can be preceded or followed by punctuation marks. 4. The length of the sentence does not exceed 1000 characters. Function Signature: ```python def reverse_sentence_with_constraints(sentence: str) -> str: pass ``` Notes: * Consider edge cases such as sentences with no words or sentences where punctuation and spaces are in close proximity. * Your solution should maintain optimal time complexity.","solution":"def reverse_word(word): Helper function to reverse a single word, ignoring non-alphabetical characters. return word[::-1] def reverse_sentence_with_constraints(sentence: str) -> str: Reverses words in a sentence while preserving the positions of punctuation marks and spaces. import re # Extract the words using regex and keep their positions. words = re.findall(r\'bw+b\', sentence) reversed_words = [reverse_word(word) for word in words] # Create an iterator for the reversed words. reversed_words_iterator = iter(reversed_words) # Reconstruct the sentence. result = [] word_boundary = re.compile(r\'bw+b\') start = 0 while start < len(sentence): match = word_boundary.search(sentence, start) if not match: result.append(sentence[start:]) break # Append the part before the word if start < match.start(): result.append(sentence[start:match.start()]) # Append the reversed word result.append(next(reversed_words_iterator)) # Move the start index past this word start = match.end() return \'\'.join(result)"},{"question":"# Objective You have to implement a function that finds all the root-to-leaf paths in a given binary tree where each path\'s sum equals a given number. # Problem Statement Given a binary tree and a sum, you need to find all root-to-leaf paths where each path\'s sum equals the given number. A root-to-leaf path is defined as a path starting from the root node and ending at any leaf node without backtracking. # Function Signature ```python def path_sum(root: Node, target_sum: int) -> List[List[int]]: pass ``` # Input * `root` (Node): The root node of the binary tree. It is guaranteed to be a valid binary tree node instance. * `target_sum` (int): The target sum to find for the root-to-leaf paths. # Output * Return a list of lists, where each inner list contains the node values from the root to a leaf node, making the sum `target_sum`. # Constraints * The number of nodes in the tree is between `1` and `10^4`. * The target sum is between `-10^9` and `10^9`. # Performance Requirements * The function should run in `O(n)` time complexity and use `O(h)` space complexity, where `n` is the number of nodes and `h` is the height of the tree. # Example Example 1 Constructed binary tree is: ``` 5 / 4 8 / / 11 13 4 / 7 2 1 ``` * **Input**: `root = Node(5)`, `target_sum = 22` * After setting up the tree, `root.left = Node(4)`, `root.right = Node(8)`, `root.left.left = Node(11)`, `root.left.left.left = Node(7)`, `root.left.left.right = Node(2)`, `root.right.left = Node(13)`, `root.right.right = Node(4)`, `root.right.right.right = Node(1)`. * **Output**: `[[5, 4, 11, 2]]`, as the path `5 -> 4 -> 11 -> 2` sums to 22. Example 2 Constructed binary tree is: ``` 1 / 2 3 ``` * **Input**: `root = Node(1)`, `target_sum = 5` * After setting up the tree, `root.left = Node(2)`, `root.right = Node(3)`. * **Output**: `[]`, as there is no path with sum 5. # Additional Notes * Efficient handling of recursive calls is crucial to meet the performance requirements. * Pay attention to edge cases like negative values and trees with a single node. * Consider backtracking mechanism to explore all possible root-to-leaf paths and sum calculations.","solution":"from typing import List, Optional class Node: def __init__(self, val: int): self.val = val self.left: Optional[Node] = None self.right: Optional[Node] = None def path_sum(root: Node, target_sum: int) -> List[List[int]]: def dfs(node, current_path, current_sum): if not node: return current_path.append(node.val) current_sum += node.val if not node.left and not node.right and current_sum == target_sum: paths.append(current_path[:]) dfs(node.left, current_path, current_sum) dfs(node.right, current_path, current_sum) current_path.pop() current_sum -= node.val paths = [] dfs(root, [], 0) return paths"},{"question":"# Question: Rotate a 2D Grid Write a function that rotates a given NxN 2D grid 90 degrees clockwise. # Function Signature ```python def rotate_2d_grid(grid: List[List[int]]) -> List[List[int]]: pass ``` # Input 1. `grid`: A 2D list of integers representing the NxN grid to be rotated. # Output * Return the rotated 2D grid as a list of lists. # Constraints * The input grid will always be a square matrix of size N x N, where 1 <= N <= 1000. # Performance Requirements * Ensure that the function efficiently handles grids of the maximum size within reasonable time limits. # Example ```python grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotated_grid = rotate_2d_grid(grid) print(rotated_grid) ``` # Expected Output ```python [[7, 4, 1], [8, 5, 2], [9, 6, 3]] ``` # Notes * The rotation should be done in place if possible to optimize for memory usage. * You can use auxiliary storage if necessary, but strive for in-place rotation. * Handle all edge cases, including the smallest grid (1x1). # Hints * You can consider rotating layer by layer, starting from the outermost layer progressing to the innermost layer. * Think of how the elements of each layer move to their new positions after the rotation.","solution":"from typing import List def rotate_2d_grid(grid: List[List[int]]) -> List[List[int]]: Rotates an NxN 2D grid 90 degrees clockwise. N = len(grid) # Create a new grid to store the rotated result new_grid = [[0] * N for _ in range(N)] for i in range(N): for j in range(N): new_grid[j][N - 1 - i] = grid[i][j] return new_grid"},{"question":"# Question: Validate and Transform Matrix Indices Given a 2D matrix and a list of indices representing elements in the matrix, write a Python function that validates the indices and returns the values of the elements at the specified indices. If an index is invalid (i.e., out of the matrix bounds), replace it with `None` in the output list. # Function Signature: ```python def get_matrix_elements(matrix: list[list[int]], indices: list[tuple[int, int]]) -> list[any]: pass ``` # Input: - `matrix` (list[list[int]]): A 2D matrix of integers. - `indices` (list[tuple[int, int]]): A list of tuples, where each tuple contains two integers representing the row and column indices of the matrix. # Output: - A list of elements from the matrix at the specified indices. If an index is invalid, the corresponding position in the output list should be `None`. # Constraints: - The dimensions of the matrix will be between 1x1 and 100x100. - Indices in `indices` list can include negative values or values beyond matrix bounds. # Example: ```python >>> matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] >>> indices = [(0, 0), (1, 2), (3, 1), (-1, 0)] >>> get_matrix_elements(matrix, indices) [1, 6, None, None] ``` # Notes: - Ensure your implementation efficiently checks the validity of each index. - If an index is valid, retrieve the element from the matrix; otherwise, return `None` for that position in the result list. - Consider edge cases where indices might be outside the negative bounds or beyond the positive bounds of the matrix dimensions. This question evaluates the candidate\'s ability to work with matrices, understand and handle boundary conditions, and use list comprehensions or other iteration mechanisms efficiently.","solution":"def get_matrix_elements(matrix, indices): This function returns the values of the elements at the specified indices. If an index is invalid (i.e., out of the matrix bounds), it replaces the value with None. Parameters: matrix (list[list[int]]): A 2D matrix of integers. indices (list[tuple[int, int]]): A list of tuples representing row and column indices. Returns: list[any]: A list of elements from the matrix at the specified indices or None if the index is invalid. rows = len(matrix) cols = len(matrix[0]) if rows > 0 else 0 def is_valid_index(i, j): return 0 <= i < rows and 0 <= j < cols result = [] for (i, j) in indices: if is_valid_index(i, j): result.append(matrix[i][j]) else: result.append(None) return result"},{"question":"# Robot Movement on a Grid You are given a grid of size `m x n` where each cell represents a possible position for a robot. The robot starts at the top-left corner of the grid (0, 0) and needs to reach the bottom-right corner (m-1, n-1). The robot can only move down or to the right. Write a function `count_paths(m: int, n: int) -> int` that returns the number of unique paths the robot can take to reach the bottom-right corner of the grid. # Input: - `m` (int): the number of rows in the grid. (1 <= m <= 50) - `n` (int): the number of columns in the grid. (1 <= n <= 50) # Output: - (int): The number of unique paths. # Example: ```python # Example Case # Input: m = 3, n = 7 # Output: 28 # Example Case # Input: m = 50, n = 50 # Output: number of unique paths for m = 50, n = 50 ``` # Constraints: - The robot can only move down (to the next row) or right (to the next column). - Ensure your algorithm runs efficiently for the maximum input size (m = 50, n = 50). # Hints: 1. Consider using dynamic programming to store the number of paths to each cell. 2. As you iterate through the grid, calculate the number of ways to reach each cell based on the cells above and to the left of it. Write your function implementation below: ```python def count_paths(m: int, n: int) -> int: if m == 0 or n == 0: return 0 grid = [[0 for _ in range(n)] for _ in range(m)] for i in range(m): grid[i][0] = 1 for j in range(n): grid[0][j] = 1 for i in range(1, m): for j in range(1, n): grid[i][j] = grid[i - 1][j] + grid[i][j - 1] return grid[m - 1][n - 1] # Testing the function print(count_paths(3, 7)) # Output: 28 print(count_paths(50, 50)) # Output: number of unique paths for m = 50, n = 50 ```","solution":"def count_paths(m: int, n: int) -> int: if m == 0 or n == 0: return 0 # Initialize a 2D list with 1 at the starting point dp = [[1] * n for _ in range(m)] # Fill the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i - 1][j] + dp[i][j - 1] return dp[m - 1][n - 1]"},{"question":"# Movie Rating Data Analysis You are required to write a function that analyzes movie rating data and returns the top n movies by average rating. This requires handling a large dataset efficiently and ensuring that the data is processed correctly. Problem Statement Implement the function `top_n_movies_by_rating(movies: List[Dict[str, Any]], n: int) -> List[str]` which will: 1. Take a list of movie data, where each movie is represented as a dictionary with the keys `title` (string) and `ratings` (list of integers). 2. Calculate the average rating for each movie. 3. Return a list of the top n movies sorted by their average rating, in descending order. If two movies have the same average rating, they should be sorted by their title in alphabetical order. Input and Output Formats * **Input**: * `movies` (List[Dict[str, Any]]): A list of dictionaries, where each dictionary contains: * `title` (string): The title of the movie. * `ratings` (list of integers): A list of ratings for the movie. * `n` (int): The number of top-rated movies to return. * **Output**: * A list of strings, where each string is the title of a top-ranked movie. Constraints: * The number of movies in the list can be large (up to 10^5). * Each movie will have at least one rating. * n will be a positive integer less than or equal to the number of movies. * Ratings will be between 1 and 5 inclusive. Example ```python # Example usage movies = [ {\\"title\\": \\"A Star is Born\\", \\"ratings\\": [5, 5, 4, 3, 4]}, {\\"title\\": \\"Bohemian Rhapsody\\", \\"ratings\\": [4, 5, 4, 5, 5]}, {\\"title\\": \\"Green Book\\", \\"ratings\\": [3, 4, 2, 4, 5]}, {\\"title\\": \\"Roma\\", \\"ratings\\": [5, 5, 5, 5, 5]}, ] top_movies = top_n_movies_by_rating(movies, 2) print(top_movies) # Output: [\'Roma\', \'Bohemian Rhapsody\'] ```","solution":"from typing import List, Dict, Any def top_n_movies_by_rating(movies: List[Dict[str, Any]], n: int) -> List[str]: Returns the top n movies by average rating. Parameters: movies (list): A list of dictionaries, where each dictionary contains \'title\' (str) and \'ratings\' (list of integers). n (int): The number of top-rated movies to return. Returns: list: A list of titles of the top n movies by average rating. # Calculate the average rating for each movie and store it in a list. average_ratings = [(movie[\'title\'], sum(movie[\'ratings\']) / len(movie[\'ratings\'])) for movie in movies] # Sort the list first by average rating in descending order, then by title in alphabetical order. sorted_movies = sorted(average_ratings, key=lambda x: (-x[1], x[0])) # Extract the top n movie titles. top_n_titles = [title for title, _ in sorted_movies[:n]] return top_n_titles"},{"question":"# Problem Statement Write a function `common_elements` that takes two lists of integers and returns a sorted list containing the common elements of the two lists, without duplicates. # Input and Output Formats Input: * `list_a` (list): A list of integers. * `list_b` (list): Another list of integers. Output: * A sorted list containing the common elements of `list_a` and `list_b`. # Constraints: * Both `list_a` and `list_b` will contain only integers (positive, negative, and zero). * The maximum length of each list is (10^4). # Performance Requirements: * The implementation should be optimized for performance given the constraints. # Examples: ```python >>> common_elements([1, 2, 2, 3, 4], [2, 3, 5]) [2, 3] >>> common_elements([4, 5, 6], [4, 4, 4, 7, 8]) [4] ``` # Additional Test Case: ```python >>> common_elements([1, 1, 1, 2, 2], [2, 2, 3, 3]) [2] ``` # Edge Cases: 1. One or both lists are empty: ```python >>> common_elements([], [1, 2, 3]) [] >>> common_elements([1, 2, 3], []) [] >>> common_elements([], []) [] ``` # Implementation Requirements: * Ensure the input types are lists, otherwise raise an `AssertionError`. * Handle the case where inputs might be empty.","solution":"def common_elements(list_a, list_b): Returns a sorted list of the common elements in list_a and list_b without duplicates. assert isinstance(list_a, list), \\"Input list_a must be a list.\\" assert isinstance(list_b, list), \\"Input list_b must be a list.\\" set_a = set(list_a) set_b = set(list_b) common = set_a & set_b return sorted(common)"},{"question":"# Context You have been working with various data structures to efficiently store and query data. One such structure is the Trie (prefix tree), which is particularly useful for tasks involving prefix matching. You are required to implement a function involving Trie to meet specific requirements. # Problem Statement Given a list of strings `words`, write a function `longest_common_prefix(words: List[str]) -> str` that returns the longest common prefix among the input strings. If there is no common prefix, return an empty string. # Input * `words` - A list of strings consisting of characters `[a-zA-Z]`. (1 <= len(words) <= 10^4, 1 <= len(words[i]) <= 100) # Output * Returns the longest common prefix among the provided words. # Constraints * The solution must be efficient with a time complexity better than O(n * m) where n is the number of words and m is the length of the longest word. # Example ```python words = [\\"flower\\", \\"flow\\", \\"flight\\"] print(longest_common_prefix(words)) # Output: \\"fl\\" words = [\\"dog\\", \\"racecar\\", \\"car\\"] print(longest_common_prefix(words)) # Output: \\"\\" ``` # Function Signature ```python def longest_common_prefix(words: List[str]) -> str: pass ``` # Hints 1. Consider using a Trie to build a prefix tree that can be traversed to find the common prefix efficiently. 2. You may also explore other string processing techniques that might help in achieving the desired time complexity.","solution":"from typing import List class TrieNode: def __init__(self): self.children = {} self.end_of_word = False class Trie: def __init__(self): self.root = TrieNode() self.size = 0 def insert(self, word: str): current = self.root for char in word: if char not in current.children: current.children[char] = TrieNode() current = current.children[char] current.end_of_word = True self.size += 1 def longest_common_prefix(self) -> str: prefix = [] current = self.root while current and not current.end_of_word and len(current.children) == 1: char = next(iter(current.children)) prefix.append(char) current = current.children[char] return \'\'.join(prefix) def longest_common_prefix(words: List[str]) -> str: if not words: return \\"\\" trie = Trie() for word in words: trie.insert(word) return trie.longest_common_prefix()"},{"question":"# Coding Question Write a function that can solve the \\"Trapped Rain Water\\" problem. The function should determine the amount of rainwater that can be trapped between the bars in a given list of non-negative integers, where each integer represents the height of a bar. # Function Signature ```python def trap_rain_water(heights: list) -> int: pass ``` # Input - `heights` (list of int): A list of non-negative integers representing the heights of bars. The length of this list is `n`. # Output - The total amount of rainwater trapped between the bars as an integer. # Constraints - The length of the `heights` list, `n`, is such that `0 ≤ n ≤ 10^4`. - Each height in the list is an integer in the range `[0, 1000]`. # Example ```python print(trap_rain_water([0,1,0,2,1,0,1,3,2,1,2,1])) # Output: 6 print(trap_rain_water([4,2,0,3,2,5])) # Output: 9 print(trap_rain_water([0])) # Output: 0 print(trap_rain_water([2,0,2])) # Output: 2 print(trap_rain_water([])) # Output: 0 ``` # Description The `trap_rain_water` function calculates the total amount of trapped rainwater between the bars. The function should consider the heights of the bars and calculate the trapped water in each segment, sum it up, and return the total amount. Handling of edge cases such as an empty list or a single bar should be ensured for correctness.","solution":"def trap_rain_water(heights: list) -> int: Calculate the total amount of rainwater trapped between the bars. Parameters: heights (list of int): A list of non-negative integers representing the heights of bars. Returns: int: The total amount of trapped rainwater. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the water trapped for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"# Linked List Reversal and Middle Element Scenario You are given a singly linked list and tasked with implementing two functions: one to reverse the linked list and another to find and return the middle element of the list. Understanding linked list manipulation is crucial for optimized data processing, and these tasks will assess your ability to handle standard linked list operations. Input and Output * Input: * A singly linked list represented by a `ListNode` class where each node contains an integer value and a reference to the next node. * Output: * For the reverse function: * The head node of the reversed linked list. * For the middle element function: * The value of the middle element of the linked list. If the list has an even number of elements, return the second of the two middle elements. Constraints * You must implement both functions within the same class. * The linked list will always contain at least one element. * The linked list may contain up to 10,000 elements. * The value of the elements can be any integer within the range [-10^5, 10^5]. Functions Definition ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next class LinkedListOperations: def reverse_linked_list(self, head: ListNode) -> ListNode: Reverses the linked list. Args: head (ListNode): Head node of the linked list. Returns: ListNode: Head node of the reversed linked list. # Implementation goes here def find_middle_element(self, head: ListNode) -> int: Finds the middle element of the linked list. Args: head (ListNode): Head node of the linked list. Returns: int: Value of the middle element. # Implementation goes here ``` Implement the above methods to manage linked list operations efficiently. Example ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next class LinkedListOperations: def reverse_linked_list(self, head: ListNode) -> ListNode: prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev def find_middle_element(self, head: ListNode) -> int: slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next return slow.val # Example usage: # Example 1: head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) operations = LinkedListOperations() reversed_head = operations.reverse_linked_list(head) middle_element = operations.find_middle_element(reversed_head) print(middle_element) # Output: 3 # Example 2: head = ListNode(10, ListNode(20, ListNode(30, ListNode(40, ListNode(50, ListNode(60)))))) reversed_head = operations.reverse_linked_list(head) middle_element = operations.find_middle_element(reversed_head) print(middle_element) # Output: 40 ``` Implement both of these methods to handle linked list operations within the given constraints.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next class LinkedListOperations: def reverse_linked_list(self, head: ListNode) -> ListNode: Reverses the linked list. Args: head (ListNode): Head node of the linked list. Returns: ListNode: Head node of the reversed linked list. prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev def find_middle_element(self, head: ListNode) -> int: Finds the middle element of the linked list. Args: head (ListNode): Head node of the linked list. Returns: int: Value of the middle element. slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next return slow.val"},{"question":"# Find the Minimum Number of Coins Given a list of coin denominations and a target amount, write a function `min_coins(coins: List[int], amount: int) -> int` that calculates the minimum number of coins required to make up the given amount. If it is not possible to make the amount with the given coin denominations, return -1. Input: * A list of integers `coins` (1 ≤ len(coins) ≤ 1000) representing the coin denominations. * An integer `amount` (1 ≤ amount ≤ 10000), the target amount to be made with the coins. Output: * An integer representing the minimum number of coins required to make up the `amount`. If not possible, return -1. Constraints: * The solution should aim for a time complexity of O(n * m) where `n` is the length of the `coins` list and `m` is the `amount`. Example: ```python assert min_coins([1, 2, 5], 11) == 3 # [5, 5, 1] assert min_coins([2], 3) == -1 assert min_coins([1], 0) == 0 assert min_coins([1, 5, 10, 25], 30) == 2 # [25, 5] ``` # Implementation: * Use dynamic programming to create an array `dp` where `dp[i]` represents the minimum number of coins needed to make the amount `i`. * Initialize the `dp` array with a large value (infinity) except for the zero-th index which should be zero (because zero coins are needed to make amount 0). * Iterate through each coin and for each coin, update the `dp` array. * At the end, check the value at `dp[amount]`. If it is still set to infinity, return -1 as it\'s not possible to make that amount. Otherwise, return the value at `dp[amount]`.","solution":"from typing import List def min_coins(coins: List[int], amount: int) -> int: Calculate the minimum number of coins required to make up the given amount. If it is not possible to make the amount with the given coin denominations, return -1. # Initialize dp array where dp[i] is the minimum number of coins needed for amount i dp = [float(\'inf\')] * (amount + 1) dp[0] = 0 # Base case: 0 coins needed for amount 0 # Iterate through each coin for coin in coins: # Update dp array for all amounts that can be reached with the current coin for x in range(coin, amount + 1): if dp[x - coin] != float(\'inf\'): dp[x] = min(dp[x], dp[x - coin] + 1) # If dp[amount] is still infinity, it means it is not possible to make that amount return dp[amount] if dp[amount] != float(\'inf\') else -1"},{"question":"# Question # Question You are tasked with implementing a `StringManipulator` class that provides enhanced string manipulation capabilities. This class should handle common string operations, but with a special focus on efficient handling of very large strings and accommodating frequent concatenations and substrings extractions. # Requirements Write a new class `StringManipulator` that supports efficient operations on strings. The class should: 1. **Store the string** in a way that supports efficient concatenations and slicing. 2. **Provide methods** for concatenating other strings and extracting substrings. # Class Methods - `__init__(self, initial_string: str)` - Initialize the object with a given string. - `append(self, new_string: str) -> None` - Append a new string to the current string. - `substring(self, start: int, end: int) -> str` - Efficiently extract a substring from the current string. # Constraints 1. Strings can be very large (up to 1e6 characters). 2. Append operations and substring extractions should be optimized for performance. 3. `start` and `end` for the `substring` method will always be valid indices within the current string length. # Example ```python >>> sm = StringManipulator(\\"Hello\\") >>> sm.append(\\" World\\") >>> sm.substring(0, 5) \'Hello\' >>> sm.substring(6, 11) \'World\' >>> sm.append(\\"!\\") >>> sm.substring(0, 12) \'Hello World!\' ``` # Assumptions 1. The class works with valid string inputs only. 2. The indices for `substring` operations are always within the valid range of the string length. 3. Performance optimization should leverage efficient data structures like `deque` for handling frequent concatenations.","solution":"from collections import deque class StringManipulator: def __init__(self, initial_string: str): Initialize the object with a given string. self._strings = deque([initial_string]) self._length = len(initial_string) def append(self, new_string: str) -> None: Append a new string to the current string. self._strings.append(new_string) self._length += len(new_string) def substring(self, start: int, end: int) -> str: Efficiently extract a substring from the current string. if start < 0 or end > self._length or start > end: raise ValueError(\\"Invalid start or end indices\\") substring_list = [] current_index = 0 for s in self._strings: if end <= current_index: break if start < current_index + len(s): # The part of the string we\'re interested in starts somewhere within s start_in_s = max(0, start - current_index) end_in_s = min(len(s), end - current_index) substring_list.append(s[start_in_s:end_in_s]) current_index += len(s) return \'\'.join(substring_list)"},{"question":"# Substring Manipulation: Maximum Unique Substrings **Context:** You are tasked with developing a substring manipulation system to handle and analyze a given string. The goal is to find the maximum number of unique substrings of a given length `k` within the string. **Problem:** Write a function, `max_unique_substrings(s: str, k: int) -> int`, to find the maximum number of unique substrings of length `k` in the string. **Requirements:** * **Function:** * **Input:** - `s` (str): The input string. - `k` (int): The length of the substrings to be considered. * **Output:** - The number of unique substrings of length `k` as an integer. **Constraints:** * `s` will have a length between 1 and 1000. * `k` is an integer greater than 0 and less than or equal to the length of `s`. **Example:** ```python def max_unique_substrings(s: str, k: int) -> int: # Your implementation here pass # Example input and output s1 = \\"abacab\\" k1 = 2 print(max_unique_substrings(s1, k1)) # Output: 4 (\\"ab\\", \\"ba\\", \\"ac\\", \\"ca\\") s2 = \\"aaa\\" k2 = 1 print(max_unique_substrings(s2, k2)) # Output: 1 (\\"a\\") s3 = \\"abcdefg\\" k3 = 3 print(max_unique_substrings(s3, k3)) # Output: 5 (\\"abc\\", \\"bcd\\", \\"cde\\", \\"def\\", \\"efg\\") # Test your solution with the example and additional cases ``` # Notes: Ensure your solution handles: * Efficient substring extraction and uniqueness verification. * Handling of different string lengths and varying substring lengths `k`. Good Luck!","solution":"def max_unique_substrings(s: str, k: int) -> int: Returns the maximum number of unique substrings of length k in the given string s. if k > len(s) or k <= 0: return 0 unique_substrings = set() for i in range(len(s) - k + 1): substring = s[i:i+k] unique_substrings.add(substring) return len(unique_substrings)"},{"question":"# Problem Statement **Adjacent Product Maximum** You work for the data analysis team of Ahead Inc., where you are analyzing a list of sensor readings. Your objective is to find the maximum product of two adjacent elements in a list of integers. Write a Python function `max_adjacent_product(arr: list) -> int` that calculates the maximum product of two adjacent elements in the provided list. **Input Format:** - A list of integers `arr` representing the sensor readings. The list will have at least two elements. **Output Format:** - Returns an integer which is the maximum product of two adjacent elements. **Constraints:** - The list must contain at least two integers. - The function should handle incorrect input types by raising a `ValueError` with an appropriate message. **Examples:** ```python >>> max_adjacent_product([3, 6, -2, -5, 7, 3]) 21 >>> max_adjacent_product([5, 11, -1, 8, 9, -10]) 72 >>> max_adjacent_product([-1, -2, -3, -4, -5]) 20 >>> max_adjacent_product([1, 2]) 2 >>> max_adjacent_product([]) Traceback (most recent call last): ... ValueError: The array must have at least two elements >>> max_adjacent_product([7]) Traceback (most recent call last): ... ValueError: The array must have at least two elements >>> max_adjacent_product(\\"sensor data\\") Traceback (most recent call last): ... ValueError: Input must be a list of integers >>> max_adjacent_product([3.5, 2]) Traceback (most recent call last): ... ValueError: Input must be a list of integers ``` Implement the function ensuring it adheres to the constraints provided.","solution":"def max_adjacent_product(arr): Returns the maximum product of two adjacent elements in the provided list. Parameters: arr (list): A list of integers. Returns: int: The maximum product of two adjacent elements. Raises: ValueError: If the input is not a list of integers or the list has fewer than two elements. if not isinstance(arr, list): raise ValueError(\\"Input must be a list of integers\\") if len(arr) < 2: raise ValueError(\\"The array must have at least two elements\\") for num in arr: if not isinstance(num, int): raise ValueError(\\"Input must be a list of integers\\") max_product = arr[0] * arr[1] for i in range(1, len(arr) - 1): product = arr[i] * arr[i + 1] if product > max_product: max_product = product return max_product"},{"question":"# Coding Assessment Question Scenario You have been working for a company that specializes in digital image processing. One of your tasks is to design a function to calculate the average brightness of an image. Brightness for an image is calculated as the average value of its pixel intensities. Pixel intensity is a value from 0 to 255. Task Write a function `average_brightness(image: List[List[int]]) -> float` to calculate the average brightness of a given 2D list representing the image, where each element of the list is an integer value representing the pixel intensity. Function Signature ```python def average_brightness(image: List[List[int]]) -> float: ``` Input - `image` (List[List[int]]): A 2D list, where each element is an integer ranging from 0 to 255 representing the pixel intensity. (1 <= len(image) <= 1000, 1 <= len(image[0]) <= 1000) Output - Returns the average brightness of the image as a float. Constraints - Each pixel intensity is an integer in the range [0, 255]. - The dimensions of the image (rows and columns) will be between 1 and 1000 inclusive. Example ```python >>> image = [ ... [10, 20, 30], ... [40, 50, 60], ... [70, 80, 90] ... ] >>> average_brightness(image) 50.0 >>> image = [ ... [255, 255], ... [255, 255] ... ] >>> average_brightness(image) 255.0 >>> image = [ ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ] >>> average_brightness(image) 0.0 ``` Notes - Make sure to handle the full range of possible input sizes and values. - Consider edge cases where the image might have minimum (0) and maximum (255) brightness values.","solution":"from typing import List def average_brightness(image: List[List[int]]) -> float: Calculate the average brightness of an image represented by a 2D list of pixel intensities. :param image: A 2D list of integers representing pixel intensities (0-255) :return: The average brightness of the image as a float total_pixels = 0 total_brightness = 0 for row in image: for intensity in row: total_brightness += intensity total_pixels += 1 return total_brightness / total_pixels"},{"question":"# Matrix Determinant Calculation **Context**: As a software engineer, you are tasked with writing a function that computes the determinant of a square matrix. The determinant is a scalar value that is computed from the elements of a square matrix and has many applications in linear algebra, including solving linear systems, finding matrix inverses, and understanding geometric properties. **Objective**: Write a function that takes a square matrix (list of lists) as input and returns the determinant of the matrix. Your function should be able to handle any size of square matrix efficiently. **Function Signature**: ```python def matrix_determinant(matrix: List[List[int]]) -> int: pass ``` **Input**: * `matrix`: A 2D list of integers representing a square matrix (n x n). **Output**: * An integer representing the determinant of the matrix. **Constraints**: * The matrix dimensions `n x n` are such that `1 <= n <= 10`. * Elements of the matrix are integers in the range [-100, 100]. **Example**: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] result = matrix_determinant(matrix) assert result == 0 matrix = [ [1, 2], [3, 4] ] result = matrix_determinant(matrix) assert result == -2 ``` **Additional Notes**: * Use appropriate algorithms to compute determinants for larger matrices efficiently, such as Laplace expansion or using LU decomposition. * Ensure that your implementation handles edge cases, such as 1x1 matrices and singular matrices (matrices with a determinant of zero).","solution":"from typing import List def matrix_cofactor(matrix: List[List[int]], i: int, j: int) -> List[List[int]]: Helper function to calculate the cofactor matrix return [row[:j] + row[j+1:] for row in (matrix[:i] + matrix[i+1:])] def matrix_determinant(matrix: List[List[int]]) -> int: Returns the determinant of a square matrix. n = len(matrix) # Base case for 1x1 matrix if n == 1: return matrix[0][0] # Base case for 2x2 matrix if n == 2: return matrix[0][0]*matrix[1][1] - matrix[0][1]*matrix[1][0] det = 0 for c in range(n): cofactor_matrix = matrix_cofactor(matrix, 0, c) det += ((-1)**c) * matrix[0][c] * matrix_determinant(cofactor_matrix) return det"},{"question":"# Question: Design a Tic-Tac-Toe Game Scenario Create a game logic for a simplified version of Tic-Tac-Toe that can be used for a backend service. The board is `n x n` in size, and two players take turns marking the cells. The objective is to determine the winner after each move. Task Implement a class `TicTacToe` with the following methods: 1. **`__init__(self, n: int):`** * Initializes the board size to `n x n` and sets up the necessary data structures. 2. **`move(self, row: int, col: int, player: int) -> int:`** * Marks the cell `(row, col)` with the player\'s symbol (1 for player 1 and 2 for player 2). * Returns: * `0` if no one wins the game after this move. * `1` if player 1 wins after this move. * `2` if player 2 wins after this move. Constraints * `1 <= n <= 1000` * `player` is either `1` or `2`. * `0 <= row, col < n` * Moves are guaranteed to be valid and placed on empty cells. Example ```python # Initialize a TicTacToe board of size 3x3 tic_tac_toe = TicTacToe(3) # Player 1 makes a move to (0, 0) print(tic_tac_toe.move(0, 0, 1)) # returns 0 (no one wins) # Player 2 makes a move to (0, 1) print(tic_tac_toe.move(0, 1, 2)) # returns 0 (no one wins) # Player 1 makes a move to (1, 1) print(tic_tac_toe.move(1, 1, 1)) # returns 0 (no one wins) # Player 2 makes a move to (1, 2) print(tic_tac_toe.move(1, 2, 2)) # returns 0 (no one wins) # Player 1 makes a move to (2, 2) print(tic_tac_toe.move(2, 2, 1)) # returns 1 (Player 1 wins with a diagonal) ``` This problem ensures you can manage the logical flow of a classic game and handle the win conditions efficiently.","solution":"class TicTacToe: def __init__(self, n: int): Initializes the TicTacToe board. self.n = n self.rows = [[0] * n for _ in range(2)] self.cols = [[0] * n for _ in range(2)] self.diagonal = [0, 0] self.anti_diagonal = [0, 0] def move(self, row: int, col: int, player: int) -> int: Player makes a move at (row, col). player -= 1 self.rows[player][row] += 1 self.cols[player][col] += 1 if row == col: self.diagonal[player] += 1 if row + col == self.n - 1: self.anti_diagonal[player] += 1 if (self.rows[player][row] == self.n or self.cols[player][col] == self.n or self.diagonal[player] == self.n or self.anti_diagonal[player] == self.n): return player + 1 return 0"},{"question":"# Problem Description One common problem when managing a large set of data files is to ensure that files with the same content are not stored multiple times. A file deduplication system can help by identifying and keeping only one copy of identical files. For this problem, you will write a function that checks for duplicate files based on their content and keeps track of unique files. # Function Definition Define a function `deduplicate_files(file_contents: List[str]) -> List[int]` that takes a list of strings, where each string represents the content of a file, and returns a list of indices representing unique files. Each index corresponds to the position of the file in the input list. # Input * **file_contents** (`List[str]`): A list of strings where each string represents the content of a file. Each file content is a non-empty string with a length up to 10^6 characters. # Output * **List[int]**: A list of integers representing the indices of unique files in the order they were first encountered. # Constraints * `1 <= len(file_contents) <= 10^4` * Each string\'s length does not exceed 10^6 characters. * The return list should have indices in ascending order. # Examples Example 1: **Input**: ```python file_contents = [\\"hello world\\", \\"foo bar\\", \\"hello world\\", \\"foo\\"] ``` **Output**: ```python [0, 1, 3] ``` **Explanation**: \\"hello world\\" appears twice in the input list, so the second occurrence is a duplicate and its index (2) is not included in the output list. Similarly, \\"foo bar\\" and \\"foo\\" are unique. Example 2: **Input**: ```python file_contents = [\\"abc\\", \\"xyz\\", \\"abc\\", \\"123\\", \\"xyz\\"] ``` **Output**: ```python [0, 1, 3] ``` **Explanation**: \\"abc\\" and \\"xyz\\" each appear twice, so their indices (2 and 4) are not included in the output list. The remaining files (\\"abc\\", \\"xyz\\", and \\"123\\") are unique. # Notes - Handle edge cases such as an empty list or list with only one element. - Ensure the solution is efficient in terms of both time and space complexity given the constraints. Implementation Details You may leverage the existing `hash_file` helper function in your implementation, which can be used to generate unique hashes for file contents to efficiently compare them. Note that this helper function has been tailored for large file contents and designed to minimize collisions.","solution":"from typing import List def deduplicate_files(file_contents: List[str]) -> List[int]: Returns a list of indices representing unique files based on their content. seen_contents = {} unique_indices = [] for index, content in enumerate(file_contents): if content not in seen_contents: seen_contents[content] = index unique_indices.append(index) return unique_indices"},{"question":"# String Transformation Using Minimum Operations Problem Statement: You are given two strings, `start` and `target`. Your goal is to transform the string `start` into the string `target` using a minimum number of operations. You can use the following operations: 1. **Insert** a character at any position in the string. 2. **Delete** a character from any position in the string. 3. **Replace** a character at any position in the string with another character. Implement the following function: 1. **min_operations_to_transform(start, target)** - **Input**: - `start`: A string representing the starting string. - `target`: A string representing the target string. - **Output**: - Returns an integer representing the minimum number of operations required to transform `start` into `target`. Constraints: - Both `start` and `target` will consist of lowercase English letters only. - The lengths of `start` and `target` will be at most 1000. Example: ```python start = \\"kitten\\" target = \\"sitting\\" # Function Call min_operations = min_operations_to_transform(start, target) # Expected Output min_operations should be 3 # Explanation # The minimum operations to transform \\"kitten\\" into \\"sitting\\" are: # 1. Replace \'k\' with \'s\' -> \\"sitten\\" # 2. Replace \'e\' with \'i\' -> \\"sittin\\" # 3. Insert \'g\' at the end -> \\"sitting\\" ``` Notes: - Your implementation should use dynamic programming to achieve efficient computation. - Make sure to cover edge cases such as empty strings or already equal strings. - Test your implementation thoroughly to ensure its correctness and efficiency.","solution":"def min_operations_to_transform(start, target): Returns the minimum number of operations required to transform the string start into the string target. m, n = len(start), len(target) # Create a DP table to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp[][] in a bottom-up manner for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If start is empty, all insertions are needed elif j == 0: dp[i][j] = i # If target is empty, all deletions are needed elif start[i - 1] == target[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no new operation needed else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Delete dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"# Problem Statement Given a list of positive integers `arr`, return the length of the longest subsequence such that each successive element in the subsequence is either a multiple of the previous element or the previous element is a multiple of the current one. # Requirements * **Input**: - `arr` (1 <= len(arr) <= 5000, 1 <= arr[i] <= 10^9): A list of positive integers. * **Output**: - An integer representing the length of the longest subsequence meeting the criteria. # Function Signature ```python def longest_multiple_subsequence(arr: List[int]) -> int: ``` # Examples *Example 1*: ```python print(longest_multiple_subsequence([1, 2, 4, 8])) # Output: 4 ``` *Example 2*: ```python print(longest_multiple_subsequence([6, 3, 9, 18, 72])) # Output: 4 ``` *Example 3*: ```python print(longest_multiple_subsequence([7, 14, 10, 5, 20, 25, 50])) # Output: 3 ``` # Constraints 1. Consider using dynamic programming or other efficient techniques to handle the possible large size of the input array. 2. The solution should handle arrays containing large integers up to `10^9` efficiently.","solution":"def longest_multiple_subsequence(arr): n = len(arr) if n <= 1: return n # Sort the array to ensure we can process in a sensible order arr.sort() # dp array where dp[i] will store the length of the longest subsequence ending with arr[i] dp = [1] * n for i in range(1, n): for j in range(i): if arr[i] % arr[j] == 0 or arr[j] % arr[i] == 0: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"# Task Description Design and implement a function that detects plateaus in a numerical list and returns the start and end indices of the longest plateau. A plateau is defined as a contiguous subarray where all elements are the same. # Problem Statement Given a list of integers, you are to find the longest contiguous subarray (plateau) consisting of identical elements. If there are multiple plateaus of the same length, return the one that starts first. The function should return a tuple with two integers representing the start and end indices of the longest plateau. # Function Signature ```python def find_longest_plateau(nums: List[int]) -> Tuple[int, int]: Finds the start and end indices of the longest plateau in the input list of integers. ``` # Input * `nums` (List[int]): A list of integers where a plateau is to be identified. # Output * A tuple of two integers representing the starting and ending indices of the longest plateau. # Constraints * The input list will have at least one element and no more than (10^6) elements. * The input list will contain integers between (-10^9) and (10^9). # Examples ```python >>> find_longest_plateau([1, 2, 2, 2, 3, 3, 2, 2]) (1, 3) >>> find_longest_plateau([1, 1, 1, 2, 2, 2, 2, 1]) (3, 6) >>> find_longest_plateau([5]) (0, 0) >>> find_longest_plateau([4, 4, 4, 4, 2, 2, 2, 3, 3, 3, 3]) (0, 3) ``` # Additional Requirements 1. The function should handle large lists efficiently. 2. Avoid using excessive memory allocation beyond the input list and necessary variables. 3. Ensure the solution checks for plateaus correctly and identifies the longest one with consideration for ties. # Scenario Your task is to identify the longest block of identical numbers. This could be useful in data analysis where extended similar values might indicate trends or necessary adjustments. The solution should consider both performance and correctness.","solution":"from typing import List, Tuple def find_longest_plateau(nums: List[int]) -> Tuple[int, int]: n = len(nums) if n == 0: return (0, 0) longest_start = 0 longest_end = 0 max_length = 1 current_start = 0 current_length = 1 for i in range(1, n): if nums[i] == nums[i-1]: current_length += 1 else: if current_length > max_length: max_length = current_length longest_start = current_start longest_end = i - 1 current_start = i current_length = 1 # Final check for the last plateau if current_length > max_length: longest_start = current_start longest_end = n - 1 return (longest_start, longest_end)"},{"question":"# Coding Assessment Question You need to implement a function `k_nearest_neighbors` that performs classification using the k-Nearest Neighbors algorithm on a given dataset. # Function Signature ```python def k_nearest_neighbors(train_data: np.ndarray, train_labels: np.ndarray, test_data: np.ndarray, k: int) -> np.ndarray: pass ``` # Input * `train_data` (np.ndarray): A MxN matrix where M is the number of training samples and N is the number of features per sample. * `train_labels` (np.ndarray): A Mx1 vector containing labels for the training samples. * `test_data` (np.ndarray): A PxN matrix where P is the number of test samples and N is the number of features per sample. * `k` (int): The number of nearest neighbors to consider for classification. # Output * Returns a Px1 vector denoting the predicted labels for the test samples. # Constraints * Ensure the input dimensions are compatible (i.e., `train_data` and `test_data` should have the same number of features). * `k` should be a positive integer less than or equal to the number of training samples. * The input data should not contain missing values. # Performance Requirements * The function should efficiently handle large datasets. * Utilize an appropriate distance metric (e.g., Euclidean distance) for computing nearest neighbors. # Example ```python import numpy as np train_data = np.array([ [1, 2], [2, 3], [3, 4], [5, 6], [6, 7] ]) train_labels = np.array([0, 0, 1, 1, 0]) test_data = np.array([ [1, 1], [5, 5] ]) k = 3 result = k_nearest_neighbors(train_data, train_labels, test_data, k) print(result) ``` Expected output (approximately): ```python [0, 1] ``` # Note * Ensure to handle ties in nearest neighbors by any logical strategy (e.g., majority vote). * Implement error handling for situations like invalid inputs and unexpected errors.","solution":"import numpy as np from collections import Counter def k_nearest_neighbors(train_data: np.ndarray, train_labels: np.ndarray, test_data: np.ndarray, k: int) -> np.ndarray: Classifies the test data using the k-Nearest Neighbors algorithm. Parameters: train_data (np.ndarray): MxN matrix of training data where M is the number of samples and N is the number of features. train_labels (np.ndarray): Mx1 vector of training labels. test_data (np.ndarray): PxN matrix of test data where P is the number of samples and N is the number of features. k (int): Number of nearest neighbors to consider. Returns: np.ndarray: Px1 vector of predicted labels for the test data. if k <= 0 or k > len(train_data): raise ValueError(\\"k must be a positive integer less than or equal to the number of training samples\\") if train_data.shape[1] != test_data.shape[1]: raise ValueError(\\"Number of features in train and test data must be the same\\") predicted_labels = [] # Compute distances between each test point and all train points for test_point in test_data: distances = np.sqrt(((train_data - test_point) ** 2).sum(axis=1)) # Get the indices of the k nearest neighbors k_nearest_indices = distances.argsort()[:k] # Get the labels of the k nearest neighbors k_nearest_labels = train_labels[k_nearest_indices] # Determine the most common label among the k nearest neighbors most_common_label = Counter(k_nearest_labels).most_common(1)[0][0] predicted_labels.append(most_common_label) return np.array(predicted_labels)"},{"question":"# Coding Assessment: Find the Missing Number Context You are given an array containing `n` distinct numbers taken from the range `0` to `n`. Since the numbers are distinct and from a continuous range, one number is missing. Your task is to find the missing number using an optimal algorithm that utilizes arithmetic properties to achieve efficient performance. Problem Statement Write a function `find_missing_number(arr: List[int]) -> int` that finds the single missing number from the array. Function Signature ```python def find_missing_number(arr: List[int]) -> int: ``` Inputs - `arr`: A list of integers of length `n` containing distinct numbers from the range `0` to `n` except for one missing number. Outputs - Return the missing number as an integer. Constraints - `n` will be a positive integer such that 1 <= n <= 10^5. - Each number in `arr` will be a unique integer within the range `[0, n]`. Performance Requirements - The solution should have time complexity O(n). - The solution should have space complexity O(1). Example ```python arr = [3, 0, 1] print(find_missing_number(arr)) # Output should be 2 arr = [9,6,4,2,3,5,7,0,1] print(find_missing_number(arr)) # Output should be 8 ``` Hint - Utilize the arithmetic sum formula to compute the expected sum of the numbers from 0 to `n` and subtract the sum of elements in the array. Notes - Ensure your implementation handles edge cases such as when the minimum or maximum number in the range is missing. - Avoid using additional data structures as it will increase space complexity. The provided problem should test the candidate\'s ability to implement efficient algorithms using simple arithmetic operations and control structures, similar to the style and complexity found in the original question.","solution":"from typing import List def find_missing_number(arr: List[int]) -> int: Finds the single missing number from the array. n = len(arr) expected_sum = n * (n + 1) // 2 actual_sum = sum(arr) return expected_sum - actual_sum"},{"question":"# Background You are developing a software that analyzes social network connections. In this network, users are represented as nodes, and friendships are represented as edges between the nodes. You need to determine the shortest path between two users, allowing the user to specify whether direct or indirect friendships (friends of friends, etc.) should be considered. # Task Implement a function `find_shortest_path` that determines the shortest path between two users in the network while considering the possibility of intermediate friends. The function should allow the option to only consider direct friendships or also include friends of friends. Function Signature ```python def find_shortest_path( network: dict[str, list[str]], start: str, end: str, allow_indirect: bool ) -> list[str]: pass ``` Input * `network`: A dictionary where keys are user names (strings), and values are lists of direct friends\' user names (strings). * `start`: A string representing the starting user\'s name. * `end`: A string representing the target user\'s name. * `allow_indirect`: A boolean determining if indirect friendships should be considered. Output * Returns a list of user names representing the shortest path from the start user to the end user. * If multiple shortest paths exist, return any one of them. * If no path exists, return an empty list. Constraints * The network will not contain more than 1000 users. * All user names are unique. * The network is represented as an undirected graph. * There will be no self-referential friendships (no user is friends with themselves). Examples ```python network1 = { \'Alice\': [\'Bob\', \'Charlie\'], \'Bob\': [\'Alice\', \'David\'], \'Charlie\': [\'Alice\'], \'David\': [\'Bob\'] } network2 = { \'Alice\': [\'Bob\'], \'Bob\': [\'Alice\', \'Charlie\', \'Eve\'], \'Charlie\': [\'Bob\', \'David\'], \'David\': [\'Charlie\'], \'Eve\': [\'Bob\'] } print(find_shortest_path(network1, \'Alice\', \'David\', False)) # Output: [\'Alice\', \'Bob\', \'David\'] print(find_shortest_path(network1, \'Alice\', \'David\', True)) # Output: [\'Alice\', \'Bob\', \'David\'] print(find_shortest_path(network2, \'Alice\', \'David\', False)) # Output: [] print(find_shortest_path(network2, \'Alice\', \'David\', True)) # Output: [\'Alice\', \'Bob\', \'Charlie\', \'David\'] ``` These example cases should help you to test and validate your implementation.","solution":"from collections import deque def find_shortest_path(network, start, end, allow_indirect): Determines the shortest path between two users in a social network. :param network: Dictionary representing the network where keys are user names, and values are lists of friends. :param start: Username representing the starting user. :param end: Username representing the target user. :param allow_indirect: Boolean determining if indirect friendships should be considered. :return: List of user names representing the shortest path from start to end. Returns an empty list if no path exists. if start == end: return [start] visited = set() queue = deque([[start]]) while queue: path = queue.popleft() node = path[-1] if node not in visited: neighbours = network.get(node, []) for neighbour in neighbours: new_path = list(path) new_path.append(neighbour) queue.append(new_path) if neighbour == end: return new_path visited.add(node) return []"},{"question":"# Context In recent projects, you\'ve been required to work with string manipulation and pattern matching. This question focuses on assessing your ability to handle regular expressions and efficiently process text data. # Problem Statement Write a Python function called `extract_emails` that takes a string `text` as input and returns a list of all email addresses found within the string. Email addresses in the input will follow the general format `username@domain.extension` with no spaces. # Input - A string `text` that can contain multiple lines and assorted characters. The size of `text` can be very large (up to 10^6 characters). # Output - A list of email addresses extracted from the input string. If no email addresses are found, return an empty list. # Function Signature ```python def extract_emails(text: str) -> list: pass ``` # Constraints - The function should handle edge cases where there are no email addresses or the string is empty. - Be mindful of the performance, especially with large input sizes. # Example ```python assert extract_emails(\\"Please contact us at support@example.com for further information.\\") == [\\"support@example.com\\"] assert extract_emails(\\"Emails: first.email@example.com, second.email@example.org.\\") == [\\"first.email@example.com\\", \\"second.email@example.org\\"] assert extract_emails(\\"No emails here!\\") == [] assert extract_emails(\\"\\") == [] assert extract_emails(\\"Reach out at john.doe@example.com and jane_doe123@something.io!\\") == [\\"john.doe@example.com\\", \\"jane_doe123@something.io\\"] ``` # Guidelines 1. Use Python\'s `re` module to craft a regular expression that matches the general structure of an email address. 2. Make sure to account for common valid characters used in emails, such as periods (`.`), underscores (`_`), and alphanumeric characters. 3. Implement your function to scan through the input string and extract all matching patterns. 4. Return a list containing all matched email addresses. Your function will be tested on various examples, including texts with no emails, texts with numerous emails, and very long texts to ensure correctness and efficiency.","solution":"import re def extract_emails(text: str) -> list: This function takes a string as input and returns a list of all email addresses found within the string. # Define a regex pattern for matching email addresses email_pattern = r\'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,}\' # Use re.findall to find all matches of the pattern in the text emails = re.findall(email_pattern, text) # Return the list of matched email addresses return emails"},{"question":"# Problem Statement Context You are developing a module for a library management system. One of the key features is to allow the library staff to efficiently search for books based on their titles. This requires implementing an algorithm that can search for substrings within a list of book titles. Task Implement a function that finds all indices in a list of book titles where a given search term appears as a substring. The input will be a list of strings (book titles) and a search term, and the output should be a list of indices where the search term is found within the titles. Function Signature ```python def search_books(titles: list, search_term: str) -> list: pass ``` Input Format - A list `titles` of strings where: * `1 <= len(titles) <= 10^4` * `1 <= len(titles[i]) <= 10^2` - A string `search_term` where: * `1 <= len(search_term) <= 50` Output Format - A list of integers representing the indices in `titles` where `search_term` appears as a substring. Constraints - The function should be case-sensitive (i.e., \'Book\' is different from \'book\'). - Consider the output order to be the same as the order of occurrence. Example ```python assert search_books([\\"The Great Gatsby\\", \\"Great Expectations\\", \\"The Grapes of Wrath\\"], \\"Great\\") == [0, 1] assert search_books([\\"To Kill a Mockingbird\\", \\"1984\\", \\"Brave New World\\"], \\"world\\") == [2] assert search_books([\\"Moby Dick\\", \\"War and Peace\\", \\"The Catcher in the Rye\\"], \\"and\\") == [1] ``` Requirements - Make sure to handle edge cases such as an empty search term or a search term that does not appear in any of the titles. - Return an empty list if the search term does not appear in any titles. Notes - Assume that the list of titles and the search term contain only printable ASCII characters. - Optimize your function to handle a large number of book titles efficiently.","solution":"def search_books(titles: list, search_term: str) -> list: Finds all indices in a list of book titles where a given search term appears as a substring. Parameters: titles (list): A list of strings representing book titles. search_term (str): The search term to look for in the titles. Returns: list: A list of indices where the search term appears as a substring in the titles. if not search_term: return [] result = [] for index, title in enumerate(titles): if search_term in title: result.append(index) return result"},{"question":"# Objective Design a function to determine if a given array can be partitioned into two subarrays with equal sum. The goal is to evaluate your understanding of dynamic programming techniques and your ability to handle optimization problems. # Problem Statement Write a Python function `can_partition(nums: List[int]) -> bool` that determines if the `nums` array can be partitioned into two subsets such that the sum of elements in both subsets is equal. Input: 1. `nums` (List[int]): a list of integers. Output: Returns `True` if the array can be partitioned into two subsets with equal sum, and `False` otherwise. Constraints: 1. The length of the array will be in the range `[1, 200]`. 2. Each element of the array will be a positive integer not exceeding `100`. # Performance Requirements 1. The solution should have a time complexity of O(n * s), where `n` is the number of elements in `nums` and `s` is the sum of `nums` divided by 2. # Example ```python from typing import List nums = [1, 5, 11, 5] print(can_partition(nums)) # Expected output: True nums = [1, 2, 3, 5] print(can_partition(nums)) # Expected output: False ``` Write the function `can_partition` that implements the above problem statement.","solution":"from typing import List def can_partition(nums: List[int]) -> bool: total_sum = sum(nums) # If the total sum is odd, we can\'t partition it into two equal parts if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Initialize a DP array with False dp = [False] * (target + 1) dp[0] = True # Base case: a subset with sum zero is always possible for num in nums: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"# Problem Statement You have been tasked with developing a system to track the popularity of different hashtags on a simulated social media platform. Hashtags are used in posts, and you need to simulate the increase in popularity of each hashtag based on a provided set of posts. Each post is represented by a list of hashtags used in that post. # Requirements 1. **Function Implementation**: Implement the function `track_hashtag_popularity(posts: list[list[str]]) -> dict[str, int]` that tracks the frequency of each hashtag. - **Parameters**: - `posts`: A `list` of `list`s where each inner list contains `str` elements representing hashtags used in a single post. - **Return**: A `dict` where keys are hashtag names (starting with `#`) and values are the number of times each hashtag was used across all posts. 2. **Constraints**: - Each post contains between 1 and 10 hashtags. - Hashtags are case-sensitive. - A hashtag can appear multiple times within the same post, which should be counted each time. 3. **Example**: ```python posts = [ [\'#fun\', \'#summer\', \'#vacation\'], [\'#summer\', \'#sun\', \'#beach\'], [\'#fun\', \'#sun\', \'#fun\'], [\'#coding\', \'#python\', \'#fun\'] ] result = track_hashtag_popularity(posts) print(result) # Output might look like {\'#fun\': 4, \'#summer\': 2, \'#vacation\': 1, \'#sun\': 2, \'#beach\': 1, \'#coding\': 1, \'#python\': 1} ``` 4. **Edge Cases**: - Posts with the same hashtag repeated multiple times. - Hashtags that are only used once across all posts. - An empty list of posts. # Hints - Use a dictionary to keep track of the count of each hashtag. - Loop through each post and each hashtag within the post to update counts in the dictionary.","solution":"def track_hashtag_popularity(posts): Tracks the frequency of each hashtag from a list of posts. Parameters: posts (list of list of str): A list of posts, each containing a list of hashtags. Returns: dict of str: int: A dictionary with hashtags as keys and their frequency as values. hashtag_count = {} for post in posts: for hashtag in post: if hashtag in hashtag_count: hashtag_count[hashtag] += 1 else: hashtag_count[hashtag] = 1 return hashtag_count"},{"question":"# Coding Question: String Manipulation and Dynamic Programming You are provided with a function `edit_distance` to calculate the minimum number of operations required to transform one string into another. These operations can include insertions, deletions, or substitutions of characters. Your task is to implement this function using dynamic programming. # Requirements: - Implement the function `edit_distance(s1: str, s2: str) -> int` that returns the minimum number of operations needed. - Use dynamic programming to optimize the solution. - Handle empty strings and ensure robust performance for longer strings. # Input: - `s1`: A string of length (0 leq text{len}(s1) leq 1000). - `s2`: A string of length (0 leq text{len}(s2) leq 1000). # Output: - An integer representing the minimum number of operations required to convert `s1` into `s2`. # Constraints: - The solution must run efficiently with appropriate time and space complexity. - Handle special cases such as both strings being empty. # Example: ```python def edit_distance(s1: str, s2: str) -> int: # Your implementation here. pass # Example Usages: print(edit_distance(\\"kitten\\", \\"sitting\\")) # Example Output: 3 print(edit_distance(\\"flaw\\", \\"lawn\\")) # Example Output: 2 print(edit_distance(\\"\\", \\"abc\\")) # Example Output: 3 print(edit_distance(\\"intention\\", \\"execution\\")) # Example Output: 5 print(edit_distance(\\"abcd\\", \\"abcd\\")) # Example Output: 0 print(edit_distance(\\"\\", \\"\\")) # Example Output: 0 ``` # Additional Context: This assessment will test your understanding of string manipulation and dynamic programming techniques. Ensure your solution includes efficient handling of edge cases and provides optimal performance for large input sizes.","solution":"def edit_distance(s1: str, s2: str) -> int: Calculate the minimum number of operations required to convert s1 into s2. The allowed operations are insertions, deletions, and substitutions. len_s1, len_s2 = len(s1), len(s2) # Create a 2D list to store the edit distances between substrings of s1 and s2 dp = [[0] * (len_s2 + 1) for _ in range(len_s1 + 1)] # Initialize the base cases: # dp[i][0] = i (the cost of deleting all characters from s1 to match an empty s2) # dp[0][j] = j (the cost of inserting all characters from s2 to match an empty s1) for i in range(len_s1 + 1): dp[i][0] = i for j in range(len_s2 + 1): dp[0][j] = j # Compute the minimum edit distance for each substring pair of s1 and s2 for i in range(1, len_s1 + 1): for j in range(1, len_s2 + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no extra cost else: dp[i][j] = min( dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + 1 # Substitution ) return dp[len_s1][len_s2]"},{"question":"# Coding Assessment Question Context: In combinatorial mathematics, the problem of generating all possible subsets (the power set) of a set is a common task. This becomes especially interesting when considering sets with a constraint that all subsets should be of a specific length. Task: Write a function `generate_subsets(elements, length)` that generates all possible subsets of a given list of `elements` such that each subset is of the specified `length`. Requirements: 1. Implement a function `generate_subsets(elements: List[Any], length: int) -> List[List[Any]]`. 2. The function should: - Raise a `ValueError` if `length` is negative or greater than the number of elements in the input list. - Accept a list of any hashable elements. 3. The solution should generate and return all possible subsets of the given length. Input: - `elements` (List[Any]): The list of elements to create subsets from. - `length` (int): The length of each subset. Output: - Returns a list of all subsets each having the specified length. Constraints: - Elements in the subsets should maintain their order as in the original list where applicable. - Use efficient combinatorial algorithms to generate the subsets. Example: ```python >>> generate_subsets([1, 2, 3, 4], 2) [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]] >>> generate_subsets([\'a\', \'b\', \'c\'], 1) [[\'a\'], [\'b\'], [\'c\']] >>> generate_subsets([1, 2, 3], 3) [[1, 2, 3]] >>> generate_subsets([1, 2, 3], 0) [[]] ``` Edge Cases: - `length` greater than the size of `elements` should raise a `ValueError`. - Non-list `elements` input should be handled appropriately. - Empty list input should return an empty list of subsets for any positive length, or a list containing an empty list for length 0.","solution":"from itertools import combinations from typing import List, Any def generate_subsets(elements: List[Any], length: int) -> List[List[Any]]: Generate all subsets of the given list of elements with the specified length. Parameters: elements (List[Any]): The input list of elements. length (int): The length of each subset. Returns: List[List[Any]]: A list of all subsets of the specified length. Raises: ValueError: If length is negative or greater than the number of elements. if length < 0 or length > len(elements): raise ValueError(\\"length must be non-negative and less than or equal to the number of elements\\") return [list(subset) for subset in combinations(elements, length)]"},{"question":"# Net Profit Margin Calculation - Function Implementation Problem Statement In the field of finance and accounting, the net profit margin (NPM) is a metric used to measure a company\'s profitability. The NPM ratio is calculated by dividing net profit by revenue. Your task is to implement a function which calculates and returns any one of the three values: net profit margin, net profit, or revenue, when the other two values are provided. You should complete the Python function `compute_net_profit_margin` that follows this signature: ```python def compute_net_profit_margin(npm: Optional[float], net_profit: Optional[float], revenue: Optional[float]) -> Tuple[str, float]: pass ``` - **npm**: Net profit margin (float) provided or `None`. - **net_profit**: Net profit (float) provided or `None`. - **revenue**: Revenue (float) provided or `None`. The function should return a tuple containing: - The name of the calculated parameter (`\'npm\'`, `\'net_profit\'`, or `\'revenue\'`). - The calculated value (float). # Constraints - You should ensure that exactly one of the three inputs is `None`, while the other two are positive values. - Net profit margin, net profit, and revenue will always be non-negative. - If any input violates these constraints, your function must raise a `ValueError` with a suitable error message. # Examples ```python >>> compute_net_profit_margin(npm=0.25, net_profit=50, revenue=None) (\'revenue\', 200.0) >>> compute_net_profit_margin(npm=None, net_profit=80, revenue=400) (\'npm\', 0.2) >>> compute_net_profit_margin(npm=0.1, net_profit=None, revenue=1500) (\'net_profit\', 150.0) >>> compute_net_profit_margin(npm=0.3, net_profit=90, revenue=200) Traceback (most recent call last): ... ValueError: You must provide exactly two non-None values ``` # Requirements - **Input/output format**: As specified above. - **Performance**: The solution should have a constant time complexity, O(1). - **Errors**: Handle invalid inputs with appropriate error messages.","solution":"from typing import Optional, Tuple def compute_net_profit_margin(npm: Optional[float], net_profit: Optional[float], revenue: Optional[float]) -> Tuple[str, float]: # Check that exactly one of the input values is None if [npm, net_profit, revenue].count(None) != 1: raise ValueError(\\"You must provide exactly two non-None values\\") # If npm needs to be calculated if npm is None: if revenue == 0: raise ValueError(\\"Revenue cannot be zero when calculating npm\\") npm = net_profit / revenue return \'npm\', npm # If net_profit needs to be calculated if net_profit is None: net_profit = npm * revenue return \'net_profit\', net_profit # If revenue needs to be calculated if revenue is None: if npm == 0: raise ValueError(\\"Net profit margin cannot be zero when calculating revenue\\") revenue = net_profit / npm return \'revenue\', revenue"},{"question":"# Coding Assessment Question Scenario You are developing a file management system to organize a directory of documents based on word frequency analysis. Each document contains text in English and needs to be preprocessed and analyzed to find the most common words. Additionally, documents should be ranked based on the similarity in their word frequency distributions compared to a query document. Task Write a function `organize_documents` that accepts a directory path containing text files, a query document filename, and a value `n`. The function will: 1. Read and preprocess each document to remove punctuation and convert all text to lowercase. 2. Count the frequency of each word in all documents. 3. Compare the word frequency distribution of the query document to all other documents using the Cosine similarity measure. 4. Return a list of document names sorted by their similarity to the query document. # Function Signature ```python def organize_documents(directory: str, query_doc: str, n: int) -> list[str]: ``` # Input * `directory`: Directory path containing the text documents (string). * `query_doc`: Name of the query document within the directory (string). * `n`: The number of top most frequent words to consider in the analysis (int). # Output * A list of document filenames sorted by their similarity to the query document (list of strings). # Constraints * Ensure documents are preprocessed correctly by removing punctuation and converting texts to lowercase. * Accurately count word frequencies and handle large corpuses efficiently. * Compute the Cosine similarity measure correctly and sort the documents based on the obtained scores. * Handle edge cases such as empty documents or those containing non-alphabetic characters only. # Example ```python directory = \\"documents\\" query_doc = \\"doc1.txt\\" n = 10 sorted_docs = organize_documents(directory, query_doc, n) print(sorted_docs) ``` This should print the list of document filenames sorted based on their similarity to `doc1.txt`, considering the top `n` most frequent words.","solution":"import os import string from collections import Counter from math import sqrt from typing import List def preprocess(text: str) -> List[str]: Preprocess the text by removing punctuation and converting to lowercase. translator = str.maketrans(\'\', \'\', string.punctuation) return text.translate(translator).lower().split() def word_frequencies(text: str, n: int) -> Counter: Count the frequency of each word in the text and return the top `n` most common words as a Counter object. words = preprocess(text) return Counter(words).most_common(n) def cosine_similarity(freq1: Counter, freq2: Counter) -> float: Compute the cosine similarity between two word frequency distributions. intersection = set(freq1.keys()) & set(freq2.keys()) numerator = sum([freq1[word] * freq2[word] for word in intersection]) sum1 = sum([freq1[word] ** 2 for word in freq1.keys()]) sum2 = sum([freq2[word] ** 2 for word in freq2.keys()]) denominator = sqrt(sum1) * sqrt(sum2) if not denominator: return 0.0 else: return float(numerator) / denominator def read_file(filepath: str) -> str: Read the content of the file at the given filepath. with open(filepath, \'r\', encoding=\'utf-8\') as file: return file.read() def organize_documents(directory: str, query_doc: str, n: int) -> List[str]: Organize documents in the `directory` by their similarity to the given `query_doc` based on word frequency analysis. documents = [f for f in os.listdir(directory) if f.endswith(\'.txt\')] query_path = os.path.join(directory, query_doc) query_text = read_file(query_path) query_freq = Counter(dict(word_frequencies(query_text, n))) similarity_scores = [] for doc in documents: if doc == query_doc: continue doc_path = os.path.join(directory, doc) doc_text = read_file(doc_path) doc_freq = Counter(dict(word_frequencies(doc_text, n))) similarity = cosine_similarity(query_freq, doc_freq) similarity_scores.append((doc, similarity)) similarity_scores.sort(key=lambda x: x[1], reverse=True) return [doc for doc, score in similarity_scores]"},{"question":"# Dijkstra’s Shortest Path Algorithm Implementation You are tasked with implementing Dijkstra’s algorithm to find the shortest paths from a given source vertex to all other vertices in a weighted graph. Requirements: 1. **Class Definition**: Implement a class `Dijkstra`. 2. **Initialization**: The class should be initialized with a graph represented as an adjacency list. 3. **Shortest Path Method**: Implement a method `shortest_path` that takes a source vertex and calculates the shortest path from the source to all other vertices using Dijkstra\'s algorithm. 4. **Utility Method**: Implement a utility method `get_path` that reconstructs the shortest path from the source to a given target node. # Constraints: * The number of vertices (V) is between 1 and 1000. * The number of edges (E) is between 1 and 10000. * Edge weights are positive integers. * The graph may be disconnected. # Input: * A dictionary `graph` where keys are vertex identifiers, and values are lists of tuples `(neighbor, weight)` representing the vertex\'s neighbors and the weights of the edges connecting them. * A source vertex `src`. # Output: * A dictionary where keys are vertices of the graph and values are the shortest distances from the source vertex to those vertices. * A method to get the shortest path from the source vertex to a given target vertex as a list of vertices. # Example: ```python # Example input graph = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'A\', 1), (\'C\', 2), (\'D\', 5)], \'C\': [(\'A\', 4), (\'B\', 2), (\'D\', 1)], \'D\': [(\'B\', 5), (\'C\', 1)] } src = \'A\' target = \'D\' dijkstra = Dijkstra(graph) distances = dijkstra.shortest_path(src) # Expected output # Shortest distances from source to all vertices # {\'A\': 0, \'B\': 1, \'C\': 3, \'D\': 4} print(distances) # Expected output # Shortest path from source to target # [\'A\', \'B\', \'C\', \'D\'] path = dijkstra.get_path(target) print(path) ``` Write the complete code including the class definition and the required methods.","solution":"import heapq class Dijkstra: def __init__(self, graph): self.graph = graph def shortest_path(self, src): This method finds the shortest path from the source node to all other nodes in the graph. self.distances = {vertex: float(\'infinity\') for vertex in self.graph} self.distances[src] = 0 self.previous_nodes = {vertex: None for vertex in self.graph} priority_queue = [(0, src)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > self.distances[current_vertex]: continue for neighbor, weight in self.graph[current_vertex]: distance = current_distance + weight if distance < self.distances[neighbor]: self.distances[neighbor] = distance self.previous_nodes[neighbor] = current_vertex heapq.heappush(priority_queue, (distance, neighbor)) return self.distances def get_path(self, target): This method reconstructs the shortest path from the source node to the target node. path = [] current_vertex = target while current_vertex is not None: path.insert(0, current_vertex) current_vertex = self.previous_nodes[current_vertex] return path"},{"question":"Problem Statement You are given a list of strings where each string is a sequence of lowercase alphabetical characters. Your task is to implement a function that: 1. Finds and returns the string with the maximum number of unique characters (`max_unique` function). 2. Finds and returns the string with the minimum number of unique characters using an optimized approach (`min_unique_optimized` function). You must implement both functions with the following specifications: # Function Signature ```python def max_unique(lst: list[str]) -> str: # Your implementation here def min_unique_optimized(lst: list[str]) -> str: # Your implementation here ``` # Input - `lst`: A list of strings. You may assume that the list is not extremely large (typical input size <= 10^5). # Output - `max_unique(lst)`: Returns the string with the maximum number of unique characters. - `min_unique_optimized(lst)`: Returns the string with the minimum number of unique characters using an efficient way to count unique characters. # Constraints - The list is non-empty. - If there are multiple strings with the same number of unique characters for maximum or minimum, return any of them. - Only use built-in functions and operations for string manipulations and unique character counting. # Performance Requirements - The `max_unique` function should run in O(n * m) time, where n is the length of the list and m is the length of the longest string. - The `min_unique_optimized` function should also run in O(n * m) time without unnecessary repetition of operations. # Example ```python >>> max_unique([\\"banana\\", \\"apple\\", \\"cherry\\"]) \\"cherry\\" >>> max_unique([\\"abc\\", \\"de\\", \\"xyz\\"]) \\"abc\\" >>> min_unique_optimized([\\"banana\\", \\"apple\\", \\"cherry\\"]) \\"apple\\" >>> min_unique_optimized([\\"abc\\", \\"de\\", \\"xyz\\"]) \\"de\\" ``` # Additional Information For both functions, consider the cases where strings have the same number of unique characters or contain completely unique or duplicate characters repetitively.","solution":"def max_unique(lst: list[str]) -> str: max_str = lst[0] max_unique_chars = len(set(lst[0])) for s in lst[1:]: unique_chars = len(set(s)) if unique_chars > max_unique_chars: max_str = s max_unique_chars = unique_chars return max_str def min_unique_optimized(lst: list[str]) -> str: min_str = lst[0] min_unique_chars = len(set(lst[0])) for s in lst[1:]: unique_chars = len(set(s)) if unique_chars < min_unique_chars: min_str = s min_unique_chars = unique_chars return min_str"},{"question":"Problem Statement You are given a list of integers representing the heights of students in a class. The class teacher wants to rearrange the students so that no student can see the teacher if there is a taller or equally tall student standing in front of them. Your task is to write a function `rearrange_students` that takes a list of integers and returns the heights of the students in the rearranged order from the back row to the front row. # Input * `heights` (list of integers): The list representing the heights of students. (1 leq text{len}(heights) leq 10^5). # Output * A list of integers representing the rearranged heights such that each student except the frontmost one has a strictly taller student in front of them. # Examples ```python rearrange_students([150, 160, 165, 155, 170, 160]) # Expected output: [170, 165, 160, 155, 150] rearrange_students([120, 130, 125, 130, 135, 140]) # Expected output: [140, 135, 130, 125, 120] rearrange_students([100, 105, 103, 107, 106]) # Expected output: [107, 106, 105, 103, 100] ``` # Constraints * Ensure the function rearranges the list such that no two students of the same height are next to each other. If it\'s impossible to rearrange following the constraints, return an empty list. # Note * The input list may contain duplicate heights. Ensure the function maintains the order while satisfying the given constraints.","solution":"def rearrange_students(heights): Rearranges the list of student heights so that no student can see the teacher if there is a taller or equally tall student standing in front of them. Parameters: - heights: List[int]. A list of heights of students. Returns: - List[int]. A list of heights rearranged such that the tallest student is at the front and each subsequent student is shorter than the one before. # Sort the heights in descending order heights_sorted = sorted(heights, reverse=True) return heights_sorted"},{"question":"# Coding Challenge: Word Ladder Transformation Path Scenario: You are designing software for a word game that requires finding the shortest transformation sequence from a start word to an end word. The transformation must follow specific rules: - Only one letter can be changed at a time. - Each transformed word must exist in a given dictionary. Your task is to implement a function to find the shortest transformation path. Task: Implement an algorithm to find the shortest transformation sequence from a start word to an end word, given a set of allowed dictionary words. If no such transformation sequence exists, return an empty list. Input: * A string `beginWord` representing the start word. * A string `endWord` representing the target word. * A list of strings `wordList` representing the allowed dictionary words. Output: A list of strings representing the shortest transformation path from `beginWord` to `endWord`, inclusive. If no such path exists, return an empty list. Constraints: * All words consist of lowercase English letters. * The length of `beginWord`, `endWord`, and all words in `wordList` is the same. * (1 leq beginWord.length = endWord.length = word.length leq 10) * (1 leq wordList.length leq 5000) * `beginWord` and `endWord` are not empty. * `beginWord` is not equal to `endWord`. Example: Input: ``` beginWord = \\"hit\\" endWord = \\"cog\\" wordList = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"] ``` Output: ``` [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\"] ``` Implementation Details: - Define a function `find_ladder_path(beginWord: str, endWord: str, wordList: List[str]) -> List[str]` to perform the task. - Ensure your function adheres to the provided input and output formats. - Use appropriate algorithms such as BFS for shortest path discovery. ```python from collections import deque, defaultdict from typing import List def find_ladder_path(beginWord: str, endWord: str, wordList: List[str]) -> List[str]: if endWord not in wordList: return [] wordList = set(wordList) queue = deque([[beginWord]]) visited = set() while queue: path = queue.popleft() word = path[-1] if word == endWord: return path for i in range(len(word)): for c in \'abcdefghijklmnopqrstuvwxyz\': next_word = word[:i] + c + word[i+1:] if next_word in wordList and next_word not in visited: visited.add(next_word) queue.append(path + [next_word]) return [] # Example usage: if __name__ == \\"__main__\\": beginWord = \\"hit\\" endWord = \\"cog\\" wordList = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"] print(find_ladder_path(beginWord, endWord, wordList)) ```","solution":"from collections import deque from typing import List def find_ladder_path(beginWord: str, endWord: str, wordList: List[str]) -> List[str]: if endWord not in wordList: return [] wordList = set(wordList) queue = deque([[beginWord]]) visited = set() while queue: path = queue.popleft() word = path[-1] if word == endWord: return path for i in range(len(word)): for c in \'abcdefghijklmnopqrstuvwxyz\': next_word = word[:i] + c + word[i+1:] if next_word in wordList and next_word not in visited: visited.add(next_word) queue.append(path + [next_word]) return []"},{"question":"**Scenario**: You are part of a team developing an automated financial analysis tool. One of the core functionalities of this tool is to predict future trends based on historical stock prices. Specifically, you need to implement an algorithm that can detect the shortest path in a directed graph representing stock price changes over time. This functionality will help the tool suggest the best times to buy and sell stocks. # Problem Statement You are required to implement a function with the following specifications: # Function Signature ```python def shortest_path(graph: dict, start: str, end: str) -> int: pass ``` # Input Format 1. **graph (dict)**: A dictionary representing a directed graph where the keys are node identifiers (strings) and the values are dictionaries. The nested dictionaries have keys that are node identifiers adjacent to the outer key node and integer values representing the weight (cost or time) of the edge between these nodes. 2. **start (str)**: The node identifier (string) representing the starting node. 3. **end (str)**: The node identifier (string) representing the destination node. # Output Format **Returns (int)**: The length (weight) of the shortest path from the start node to the end node. If there\'s no valid path, return -1. # Constraints - The graph will have at least 2 nodes. - Node identifiers will be strings. - Edge weights will be non-negative integers. - The start and end nodes will always exist in the graph. - There may be multiple paths from the start node to the end node, but you need to return the shortest one. # Performance Requirements - Your function should be efficient to handle graphs with up to 1000 nodes and 10,000 edges. # Examples ```python # Example 1 graph = { \\"A\\": {\\"B\\": 1, \\"C\\": 4}, \\"B\\": {\\"C\\": 2, \\"D\\": 5}, \\"C\\": {\\"D\\": 1}, \\"D\\": {} } start = \\"A\\" end = \\"D\\" assert shortest_path(graph, start, end) == 4 # Path A -> B -> C -> D # Example 2 graph = { \\"A\\": {\\"B\\": 1}, \\"B\\": {\\"C\\": 2}, \\"C\\": {\\"D\\": 1}, \\"D\\": {} } start = \\"A\\" end = \\"D\\" assert shortest_path(graph, start, end) == 4 # Path A -> B -> C -> D # Example 3 graph = { \\"A\\": {\\"B\\": 1}, \\"B\\": {\\"C\\": 2}, \\"C\\": {}, \\"D\\": {} } start = \\"A\\" end = \\"D\\" assert shortest_path(graph, start, end) == -1 # No path from A to D ``` You are required to implement the given function according to the above specifications, ensuring to handle all the edge cases and input constraints properly.","solution":"import heapq def shortest_path(graph: dict, start: str, end: str) -> int: Returns the length of the shortest path from the start node to the end node in a directed graph represented as a dictionary. Uses Dijkstra\'s algorithm. # The priority queue, starting with the start node at distance 0 pq = [(0, start)] # Dictionary to store the shortest distance to reach a node distances = {node: float(\'inf\') for node in graph} distances[start] = 0 while pq: current_distance, current_node = heapq.heappop(pq) # If we reached the destination node, return the distance if current_node == end: return current_distance # If a node\'s distance is not equal to the current distance in the priority queue, skip it if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node].items(): distance = current_distance + weight # Only consider this new path if it\'s better (shorter) if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) # If there is no path from start to end return -1"},{"question":"# Coding Challenge: Find Adjacent Duplicates Background: In data processing, it is often necessary to identify consecutive duplicate elements within a list to either process them separately or remove them for cleaner data. Detecting these duplicates is a common task in data cleaning and preprocessing phases. Objective: Write a function to detect and return the first occurrence of adjacent duplicates in a list of integers. If there are no such duplicates, return `None`. Task: Implement the function `find_adjacent_duplicates(data: List[int]) -> Union[Tuple[int, int], None]` that: - Takes a single list of integers `data` as an argument. - Returns a tuple containing the first pair of adjacent duplicate elements if any, otherwise `None`. Input: - A list `data` of integers such that ( 0 leq text{len(data)} leq 10^6 ). Output: - Returns a tuple of two integers (the first pair of adjacent duplicates) or `None` if there are no adjacent duplicates. Constraints: - If the list is empty or has only one element, the function should return `None`. Examples: ```python >>> find_adjacent_duplicates([]) None >>> find_adjacent_duplicates([1]) None >>> find_adjacent_duplicates([1, 2, 3, 4, 5]) None >>> find_adjacent_duplicates([1, 2, 2, 3, 4]) (2, 2) >>> find_adjacent_duplicates([3, 3, 3, 1, 1]) (3, 3) >>> find_adjacent_duplicates([7, 8, 9, 9, 10]) (9, 9) ``` Requirements: 1. The function should handle large lists efficiently. 2. Ensure edge cases are thoroughly handled, such as empty lists or lists with no duplicates. 3. The solution should be optimized for performance where possible. # Notes: - Consider using a loop to traverse the list and check for adjacent duplicate elements to ensure a linear time complexity solution, O(n).","solution":"from typing import List, Union, Tuple def find_adjacent_duplicates(data: List[int]) -> Union[Tuple[int, int], None]: Returns the first occurrence of adjacent duplicates in the list. If no adjacent duplicates are found, return None. for i in range(len(data) - 1): if data[i] == data[i + 1]: return (data[i], data[i]) return None"},{"question":"# Question: Implement a Memory-Optimized BFS Algorithm **Context**: You have been assigned to enhance a standard Breadth-First Search (BFS) algorithm for pathfinding in a tree structure. The primary objective is to minimize memory usage while ensuring that the algorithm can handle large trees efficiently. In addition, the paths are weighted, but you need to find the shortest path based purely on the number of edges (unweighted). **Function to Implement**: Implement the following function: ```python def optimized_bfs(tree, start, goal): Implementation of a memory-optimized BFS algorithm. Parameters: tree : A dictionary representing the tree, where keys are node identifiers, and values are lists of tuples (neighbor_node, weight). start : The identifier of the starting node. goal : The identifier of the goal node. Returns: path : List of node identifiers representing the shortest path from start to goal, inclusive. If no path is found, return an empty list. ``` **Input/Output**: - **Input**: - `tree`: A dictionary where keys are node identifiers and values are lists of tuples. Each tuple contains a neighbor node identifier and the weight of the edge connecting them. - `start`: An identifier for the starting node. - `goal`: An identifier for the goal node. - **Output**: - `path`: A list of node identifiers that represent the shortest path from `start` to `goal`. If no path exists, return an empty list. **Constraints**: - The tree may have up to 10,000 nodes. - The tree structure ensures there are no cycles. - The BFS should minimize memory usage, predominantly concerning the breadth of the tree. **Requirements**: 1. Implement BFS in a way that minimizes memory usage. 2. Ensure the search only stores necessary information to find the shortest path without extra overhead. 3. Avoid using recursive strategies that can lead to high memory usage with deep trees. **Performance Considerations**: - Make sure the memory footprint is minimized by only storing essential information for nodes at each level. - The algorithm should run efficiently for the maximum constraint size.","solution":"from collections import deque def optimized_bfs(tree, start, goal): Implementation of a memory-optimized BFS algorithm. Parameters: tree : A dictionary representing the tree, where keys are node identifiers, and values are lists of tuples (neighbor_node, weight). start : The identifier of the starting node. goal : The identifier of the goal node. Returns: path : List of node identifiers representing the shortest path from start to goal, inclusive. If no path is found, return an empty list. if start == goal: return [start] queue = deque([(start, [start])]) visited = set([start]) while queue: current_node, path = queue.popleft() for neighbor, _ in tree.get(current_node, []): if neighbor == goal: return path + [neighbor] if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, path + [neighbor])) return []"},{"question":"# Scenario You are a software engineer working on a web application that processes large datasets. One of the requirements is to implement an efficient method for compressing a given string, which consists of only lowercase English letters, by using a modified Run-Length Encoding (RLE) technique. This compression method works by replacing sequences of the same character with that character followed by the number of repetitions, but only if the sequence length is greater than 1. # Problem Statement Write a function called `compress_string` that takes a string as input and returns its compressed form using the described modified RLE technique. # Function Signature ```python def compress_string(input_string: str) -> str: pass ``` # Input - `input_string` (str): A string consisting of only lowercase English letters. # Output - Returns a string representing the compressed form according to the modified RLE technique. # Constraints - The length of `input_string` is between 0 and 10^6. - The function should handle empty strings gracefully and return an empty string in such cases. - Aim for a time complexity of O(n). # Examples ```python >>> compress_string(\\"aabcccccaaa\\") \\"a2bc5a3\\" >>> compress_string(\\"abcd\\") \\"abcd\\" >>> compress_string(\\"aa\\") \\"a2\\" >>> compress_string(\\"\\") \\"\\" ``` # Notes Ensure your implementation efficiently compresses the string by minimizing the number of traversals and using appropriate data structures.","solution":"def compress_string(input_string: str) -> str: if not input_string: return \\"\\" compressed_string = [] count = 1 for i in range(1, len(input_string)): if input_string[i] == input_string[i - 1]: count += 1 else: compressed_string.append(input_string[i - 1]) if count > 1: compressed_string.append(str(count)) count = 1 compressed_string.append(input_string[-1]) if count > 1: compressed_string.append(str(count)) return \'\'.join(compressed_string)"},{"question":"# Coding Question: Partition Labels Problem You are given a string `s` of lowercase English letters. Your task is to write a function that partitions the string into as many parts as possible so that each letter appears in at most one part. Return a list of integers representing the size of these parts. Function Signature ```python def partition_labels(s: str) -> list[int]: Given a string `s`, partitions the string into as many parts as possible so that each letter appears in at most one part, and returns a list of integers representing the sizes of these parts. Parameters: s (str): A string consisting of lowercase English letters. Returns: list: A list of integers representing the sizes of the partitions. Example: >>> s = \\"ababcbacadefegdehijhklij\\" >>> partition_labels(s) [9, 7, 8] ``` Input * A single string `s` consisting of lowercase English letters. Output * A list of integers representing the sizes of the partitions. Constraints * `1 <= len(s) <= 10^4` * `s` consists of lowercase English letters only. Example ```python # Example 1: s = \\"ababcbacadefegdehijhklij\\" print(partition_labels(s)) # Output: [9, 7, 8] # Example 2: s = \\"eccbbbbdec\\" print(partition_labels(s)) # Output: [10] ``` Explanation In the first example, the string \\"ababcbacadefegdehijhklij\\" is partitioned into [\\"ababcbaca\\", \\"defegde\\", \\"hijhklij\\"], where each letter appears in only one part.","solution":"def partition_labels(s: str) -> list[int]: Given a string `s`, partitions the string into as many parts as possible so that each letter appears in at most one part, and returns a list of integers representing the sizes of these parts. Parameters: s (str): A string consisting of lowercase English letters. Returns: list: A list of integers representing the sizes of the partitions. Example: >>> s = \\"ababcbacadefegdehijhklij\\" >>> partition_labels(s) [9, 7, 8] last_occurrence = {char: idx for idx, char in enumerate(s)} j = anchor = 0 result = [] for i, char in enumerate(s): j = max(j, last_occurrence[char]) if i == j: result.append(i - anchor + 1) anchor = i + 1 return result"},{"question":"Challenge: Efficient String Matching with the KMP Algorithm Background String matching is a classic problem in computer science. The Knuth-Morris-Pratt (KMP) algorithm is an efficient string matching algorithm that searches for occurrences of a \\"pattern\\" string within a \\"text\\" string. It runs in O(n + m) time complexity, where n is the length of the text and m is the length of the pattern, making it much more efficient than the naive string matching approach. Task You are required to implement the KMP algorithm to find all occurrences of a pattern string within a given text string. Input and Output * **Input**: Two strings, `text` and `pattern`. * **Output**: A list of starting indices where the pattern string is found within the text string. If the pattern is not found, return an empty list. Constraints 1. The text and pattern strings can only contain lowercase English letters. 2. The length of the text can be up to 10^6 characters. 3. The length of the pattern can be up to 10^5 characters. Requirements - Implement the KMP string matching algorithm. - Ensure that the implementation efficiently handles large input sizes within the provided constraints. Performance - Your implementation should aim for a time complexity of O(n + m). # Function Signature ```python def kmp_search(text: str, pattern: str) -> list[int]: pass ``` # Example ```python >>> kmp_search(\\"abracadabra\\", \\"abra\\") [0, 7] >>> kmp_search(\\"hello\\", \\"ll\\") [2] >>> kmp_search(\\"abcd\\", \\"ef\\") [] ```","solution":"def compute_lps(pattern): lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps def kmp_search(text, pattern): if not pattern: return [] lps = compute_lps(pattern) result = [] i = 0 j = 0 while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): result.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"# Question: Implement an Efficient Prime Check with Caching Context: You are developing an application that frequently needs to check whether numbers are prime. To improve efficiency, you decide to implement a caching mechanism that stores previously computed results. Task: Write a class `PrimeChecker` that implements a method `is_prime(n)` with the following features: 1. **Caching**: Store the results of prime checks to avoid redundant computations for the same number in subsequent calls. 2. **Prime Checking**: Efficiently check whether the given number is prime. 3. **Result Retrieval**: Return `True` if the number is prime, otherwise `False`. Input: * `n`: An integer to be checked for primality. Output: * A boolean value indicating whether `n` is a prime number (`True`) or not (`False`). Examples: ```python >>> prime_checker = PrimeChecker() >>> prime_checker.is_prime(2) True >>> prime_checker.is_prime(4) False >>> prime_checker.is_prime(17) True >>> prime_checker.is_prime(17) # Cached result should be used True >>> prime_checker.is_prime(18) False ``` Constraints: * The `is_prime` function should work efficiently for integers up to (10^6). * The caching mechanism should store results in an appropriate data structure to ensure quick lookup. * You must implement the prime-checking logic manually without using built-in prime-checking functions. # Implementation Notes: - **Prime Checking Algorithm**: A common way to check for primality is to test divisibility up to the square root of the number. - **Caching Strategy**: Use a dictionary or a similar data structure for caching results.","solution":"import math class PrimeChecker: def __init__(self): self.cache = {} def is_prime(self, n): # Check if result is already cached if n in self.cache: return self.cache[n] # Handle base cases if n <= 1: self.cache[n] = False return False if n <= 3: self.cache[n] = True return True if n % 2 == 0 or n % 3 == 0: self.cache[n] = False return False # Check primality i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: self.cache[n] = False return False i += 6 self.cache[n] = True return True"},{"question":"# Coding Assessment Question Problem Statement You are given a matrix representing the cost of traveling between cities where the matrix[i][j] represents the cost to travel from city i to city j. You must implement the Bellman-Ford algorithm to find the shortest path from a given source city to all other cities in the matrix. Your function should return a list where the value at index i is the shortest path cost from the source city to city i. If there is no path from the source city to a city, the cost should be denoted as `float(\'inf\')`. Function Signature ```python def bellman_ford(matrix, source): Determines the shortest path cost from the source city to all other cities using the Bellman-Ford algorithm. Parameters: matrix (List[List[int]]): A 2D list where matrix[i][j] represents the travel cost from city i to city j. Costs are non-negative integers, with matrix[i][i] = 0 for all i. source (int): An integer representing the source city. Returns: List[float]: A list where the value at index i is the shortest path cost from the source city to city i. If no path exists to city i, the cost should be `float(\'inf\')`. # your code here ``` Input Format - `matrix`: A 2D list where matrix[i][j] represents the cost of traveling from city i to city j. Costs are non-negative integers, with matrix[i][i] = 0 for all i. - `source`: An integer representing the source city. Output Format - A list of floating-point numbers where the value at index `i` represents the shortest path cost from the source city to city `i`. If no path exists, the cost should be `float(\'inf\')`. Constraints - The number of cities ( n ) (1 ≤ n ≤ 100). - The travel costs are non-negative integers. Example Given the matrix: ```python cost_matrix = [ [0, 6, float(\'inf\'), float(\'inf\'), 7], [float(\'inf\'), 0, 5, -4, 8], [float(\'inf\'), -2, 0, float(\'inf\'), float(\'inf\')], [2, float(\'inf\'), 7, 0, -1], [float(\'inf\'), float(\'inf\'), -3, 9, 0] ] ``` with `source = 0`, calling `bellman_ford(cost_matrix, 0)` should return: ``` [0, 2, 4, -2, 7] ``` # Requirements 1. Initialize the distance to the source city as 0 and to all other cities as `float(\'inf\')`. 2. Perform relaxation for all edges ( V-1 ) times, where ( V ) is the number of cities. 3. After the relaxation steps, check for negative-weight cycles. If a cycle exists, return an indication of the cycle.","solution":"def bellman_ford(matrix, source): n = len(matrix) dist = [float(\'inf\')] * n dist[source] = 0 for _ in range(n-1): for u in range(n): for v in range(n): if dist[u] != float(\'inf\') and matrix[u][v] != float(\'inf\') and dist[u] + matrix[u][v] < dist[v]: dist[v] = dist[u] + matrix[u][v] for u in range(n): for v in range(n): if dist[u] != float(\'inf\') and matrix[u][v] != float(\'inf\') and dist[u] + matrix[u][v] < dist[v]: raise Exception(\\"Negative weight cycle detected\\") return dist"},{"question":"# File Compression and Archival Utility You are tasked with creating a file compression and archival utility that can compress files into a zip archive and then extract them. The goal is to demonstrate your understanding of file handling, the zipfile module, and iterating through directories. # Functional Requirements: 1. **Compression**: Create a zip archive from a given directory, including all files and subdirectories. 2. **Extraction**: Extract the contents of a zip archive into a specified directory. 3. **Listing**: Provide a way to list all files within a zip archive without extracting them. # Input and Output Formats: - **Input**: 1. Path to the directory to be compressed. 2. Path to the zip file to be created. 3. Path to the zip file to be extracted. 4. Path to the directory where the zip archive should be extracted. - **Output**: 1. A function that compresses the directory and returns the path to the created zip file. 2. A function that extracts the zip file and returns a list of extracted file paths. 3. A function that lists all files contained in the zip archive and returns the list of file names. # Constraints: 1. Ensure that the compression process includes all files and subdirectories of the given directory. 2. Implement error handling for common issues such as invalid paths and permission errors. 3. Allow specifying compression levels for the zip archive. # Implementation Scenario: You are required to implement the following functions: - `compress_directory(directory_path: str, zip_file_path: str, compression_level: int = 5)` - `extract_zip(zip_file_path: str, extract_to_path: str)` - `list_files_in_zip(zip_file_path: str)` ```python import os import zipfile def compress_directory(directory_path: str, zip_file_path: str, compression_level: int = 5): # Implement function to compress directory into a zip file pass def extract_zip(zip_file_path: str, extract_to_path: str): # Implement function to extract contents of a zip file pass def list_files_in_zip(zip_file_path: str): # Implement function to list all files within a zip archive without extracting pass ``` *Note*: The full solution should handle traversing directory paths, applying compression levels, and managing file paths appropriately.","solution":"import os import zipfile def compress_directory(directory_path: str, zip_file_path: str, compression_level: int = 5): Compresses the given directory into a zip file. :param directory_path: Path to the directory to compress. :param zip_file_path: Path where the zip file will be created. :param compression_level: Compression level (0-9, default is 5). :return: Path to the created zip file. # Define the compression mode compress_type = zipfile.ZIP_DEFLATED if compression_level else zipfile.ZIP_STORED with zipfile.ZipFile(zip_file_path, \'w\', compress_type, compresslevel=compression_level) as zipf: for root, _, files in os.walk(directory_path): for file in files: file_path = os.path.join(root, file) arcname = os.path.relpath(file_path, directory_path) zipf.write(file_path, arcname) return zip_file_path def extract_zip(zip_file_path: str, extract_to_path: str): Extracts the contents of a zip file into a specified directory. :param zip_file_path: Path to the zip file to extract. :param extract_to_path: Path where the contents should be extracted. :return: List of extracted file paths. extracted_paths = [] with zipfile.ZipFile(zip_file_path, \'r\') as zipf: zipf.extractall(extract_to_path) extracted_paths = [os.path.join(extract_to_path, name) for name in zipf.namelist()] return extracted_paths def list_files_in_zip(zip_file_path: str): Lists all files contained in a zip archive without extracting. :param zip_file_path: Path to the zip file. :return: List of file names in the zip archive. with zipfile.ZipFile(zip_file_path, \'r\') as zipf: return zipf.namelist()"},{"question":"# Implementing Cosine Similarity Context In the field of machine learning and information retrieval, cosine similarity is a measure of similarity between two non-zero vectors of an inner product space. This metric is often used to compare the similarity of text documents by treating each as a vector of term frequencies. Task Write a function `cosine_similarity(vec1: List[float], vec2: List[float]) -> float` that returns the cosine similarity between two vectors represented as lists of floats. Input - `vec1`: A list of float numbers, representing the first vector. - `vec2`: A list of float numbers, representing the second vector. Output - A float number representing the cosine similarity between `vec1` and `vec2`. Constraints - The lengths of `vec1` and `vec2` will be equal. - The elements of the vectors will be in the range [-100, 100]. - The length of the vectors will not exceed 10^6. - The vectors may contain zero values, but both vectors will not be entirely zero. Example ```python >>> cosine_similarity([1, 2, 3], [4, 5, 6]) 0.9746318461970762 >>> cosine_similarity([-1, 0, 1], [1, 0, -1]) -1.0 ``` Instructions 1. Implement the function `cosine_similarity(vec1: List[float], vec2: List[float]) -> float`. 2. Ensure to handle edge cases such as vectors containing all zeros except one non-zero element. 3. Use efficient list operations to ensure the function can handle large inputs within the provided constraints. 4. Thoroughly test your function to handle a variety of scenarios, including positive, negative, and mixed values.","solution":"import math from typing import List def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: Returns the cosine similarity between two vectors represented as lists of floats. dot_product = sum(v1 * v2 for v1, v2 in zip(vec1, vec2)) magnitude_vec1 = math.sqrt(sum(v1 * v1 for v1 in vec1)) magnitude_vec2 = math.sqrt(sum(v2 * v2 for v2 in vec2)) if magnitude_vec1 == 0 or magnitude_vec2 == 0: return 0.0 return dot_product / (magnitude_vec1 * magnitude_vec2)"},{"question":"# Problem Statement In this problem, you are tasked with implementing a function to analyze a text file and identify the most frequently occurring word. The function should read the contents of the file, preprocess the text to remove punctuation, convert all words to lowercase, and then count the occurrences of each word to determine the most frequent one. # Requirements * Write a function `most_frequent_word` that takes in: 1. A string `filename` representing the name of the text file. * The function should return a string representing the most frequently occurring word in the file. # Constraints * Ignore the case when counting word frequencies. * Remove any punctuation marks (.,!?;:\'). * In case of a tie (multiple words with the same highest frequency), return the word that appeared first in the text. * The text file will contain at most 100,000 words. # Input ```python most_frequent_word(filename: str) -> str ``` # Output A string representing the most frequently occurring word. # Example Suppose the content of \'sample.txt\' is: ``` Hello world! This is a sample text. This text is simple. ``` Running the function: ```python result = most_frequent_word(\'sample.txt\') print(result) # Output should be \\"this\\" ``` # Notes * Consider using the `collections.Counter` for efficient counting of words. * Ensure the function handles large text files efficiently within the given constraints. * Think about edge cases such as an empty file or a file with only punctuation.","solution":"import string from collections import Counter def most_frequent_word(filename: str) -> str: Analyzes a text file and returns the most frequently occurring word. with open(filename, \'r\') as file: text = file.read() # Remove punctuation and convert to lowercase translator = str.maketrans(\'\', \'\', string.punctuation) text = text.translate(translator).lower() # Split text into words words = text.split() # Use Counter to count word frequencies word_counts = Counter(words) # Find the most frequent word most_frequent = \\"\\" max_count = -1 for word in words: if word_counts[word] > max_count: most_frequent = word max_count = word_counts[word] return most_frequent"},{"question":"# Binary Search Algorithm on a Rotated Sorted Array Context You are working on a search tool that needs to efficiently locate elements in a rotated sorted array. Task Write a function called `rotated_binary_search` that performs a binary search on a rotated sorted array to find a target value. Your function should return the index of the target value if present in the array, otherwise return `-1`. Function Signature ```python def rotated_binary_search(arr: list[int], target: int) -> int: pass ``` Input * `arr` (list[int]): A rotated sorted array of distinct integers. * `target` (int): The integer value to search for in the array. Output * `index` (int): The index of the target value if present in the array, otherwise return -1. Constraints * The array can have up to (10^5) elements. * Array elements are distinct integers within the range of ( -10^6 ) to ( 10^6 ). * Time complexity should be ( O(log n) ). Example ```python def test_rotated_binary_search(): arr = [4, 5, 6, 7, 0, 1, 2] assert rotated_binary_search(arr, 0) == 4 assert rotated_binary_search(arr, 3) == -1 arr = [6, 7, 8, 9, 1, 2, 3, 4, 5] assert rotated_binary_search(arr, 2) == 5 assert rotated_binary_search(arr, 10) == -1 arr = [30, 40, 50, 10, 20] assert rotated_binary_search(arr, 10) == 3 assert rotated_binary_search(arr, 25) == -1 print(\\"All tests passed!\\") test_rotated_binary_search() ``` You should also consider writing additional test cases to cover edge cases, such as an array where the rotation point is at the beginning or end of the array, as well as cases where the array has a single element.","solution":"def rotated_binary_search(arr: list[int], target: int) -> int: Performs binary search in a rotated sorted array to find target. Args: arr (list[int]): A rotated sorted array of distinct integers. target (int): The integer value to search for in the array. Returns: int: The index of the target value if present in the array, otherwise -1. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid # Determine which side is properly sorted if arr[left] <= arr[mid]: # Left side is sorted if arr[left] <= target < arr[mid]: right = mid - 1 else: left = mid + 1 else: # Right side is sorted if arr[mid] < target <= arr[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# String Transformation Problem You are given two strings, `start` and `target`, both consisting of lowercase English letters. You need to determine the minimum number of operations required to transform `start` into `target`. The operations allowed are: 1. Insert a character at any position. 2. Delete a character from any position. 3. Replace a character with another character. Write a function `min_operations(start, target)` that returns the minimum number of operations required. Function Signature ```python def min_operations(start: str, target: str) -> int: ``` Input * `start`: A string of lowercase English letters (0 <= len(start) <= 1000). * `target`: A string of lowercase English letters (0 <= len(target) <= 1000). Output * An integer representing the minimum number of operations required to transform `start` into `target`. Constraints * All inputs are valid strings within the given constraints. Example ```python >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"flaw\\", \\"lawn\\") 2 >>> min_operations(\\"intention\\", \\"execution\\") 5 >>> min_operations(\\"\\", \\"abc\\") 3 >>> min_operations(\\"abc\\", \\"\\") 3 ``` Additional Context: This problem is a classic example of finding the Levenshtein distance between two strings. A dynamic programming approach is typically used to build a 2D array where each cell `(i, j)` represents the minimum number of operations to transform the first `i` characters of `start` into the first `j` characters of `target`. Ensure to handle edge cases, including empty strings and completely different strings.","solution":"def min_operations(start: str, target: str) -> int: Returns the minimum number of operations (insertions, deletions, substitutions) required to transform the start string into the target string. m, n = len(start), len(target) # Initialize a table to store the minimum operations at each step dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill out the first column and the first row for i in range(1, m + 1): dp[i][0] = i for j in range(1, n + 1): dp[0][j] = j # Fill out the dp table for i in range(1, m + 1): for j in range(1, n + 1): if start[i - 1] == target[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1]) # Replacement # The answer is in the bottom-right cell of the matrix return dp[m][n]"},{"question":"Problem Statement You are required to write a function that takes a non-empty list of integers and returns a list of the same integers, but each integer should be replaced by the sum of itself and its immediate neighbors. If an integer has only one neighbor (i.e., it is at the beginning or end of the list), then the function should sum the integer with that single neighbor. # Function Signature: ```python def sum_with_neighbors(arr: List[int]) -> List[int]: ``` # Input * `arr` - A non-empty list of integers, with a length of at most 1000. # Output * Return a list of integers where each element is the sum of the original element and its neighbors, according to the rules described above. # Example ```python >>> sum_with_neighbors([1, 2, 3, 4]) [3, 6, 9, 7] >>> sum_with_neighbors([10, 20, 30]) [30, 60, 50] ``` # Constraints 1. The input list will have at least one element and at most 1000 elements. 2. For list elements at the beginning and end, only consider existing neighbors. 3. Ensure that the function has a time complexity of O(n) where n is the length of the list.","solution":"from typing import List def sum_with_neighbors(arr: List[int]) -> List[int]: Returns a list where each element is the sum of the original element and its immediate neighbors. n = len(arr) if n == 1: return arr res = [] # Handle the first element res.append(arr[0] + arr[1]) # Handle the elements in the middle for i in range(1, n-1): res.append(arr[i-1] + arr[i] + arr[i+1]) # Handle the last element res.append(arr[n-1] + arr[n-2]) return res"},{"question":"# Question Description You are required to implement a function that checks if a given list of integers contains any duplicates. This exercise will validate your understanding of data structures and efficient search algorithms. # Function Signature ```python def contains_duplicates(numbers: list[int]) -> bool: # Your code goes here ``` # Input - A list of integers `numbers` (0 <= len(numbers) <= 10^5, -10^9 <= numbers[i] <= 10^9 for all i) # Output - A boolean `True` if there are any duplicate elements in the list, and `False` if all elements are unique. # Constraints - The function should execute efficiently for all inputs within the given range. - You may not use any additional libraries or modules that directly solve the problem. # Example ```python # Example 1: print(contains_duplicates([1, 2, 3, 4, 5])) # Output: False # Example 2: print(contains_duplicates([1, 2, 3, 2, 5])) # Output: True # Example 3: print(contains_duplicates([])) # Output: False # Example 4: print(contains_duplicates([7, 7, 7, 7, 7])) # Output: True # Example 5: print(contains_duplicates([-1, -2, -3, -4, -4])) # Output: True ``` # Notes * Ensure your function passes all provided test cases. * Focus on optimizing the time complexity to handle large lists efficiently. * The use of additional data structures such as sets or dictionaries is allowed to achieve the desired performance.","solution":"def contains_duplicates(numbers: list[int]) -> bool: Checks if the list contains any duplicates. :param numbers: List of integers :return: True if there are duplicates, False otherwise seen = set() for num in numbers: if num in seen: return True seen.add(num) return False"},{"question":"# Coding Assessment Question: Implementing a Priority Queue with a Heap **Scenario**: You are responsible for managing a set of tasks in a project management application. To ensure tasks are handled efficiently, you need to implement a priority queue, where tasks with higher priority are processed before lower priority ones. A task\'s priority is an integer, with a higher integer indicating a higher priority. **Problem Statement**: Write a class `PriorityQueue` that implements a priority queue using a heap. The class should support the following operations: 1. `insert(task: str, priority: int) -> None`: Insert a task with a given priority into the priority queue. 2. `extract_max() -> str`: Remove and return the task with the highest priority from the priority queue. 3. `peek_max() -> str`: Return the task with the highest priority without removing it from the priority queue. 4. `is_empty() -> bool`: Return `True` if the priority queue is empty, otherwise `False`. **Input**: - Tasks are provided as strings and priorities as integers when inserting them into the priority queue. **Output**: - Methods should return the appropriate result based on their functionality defined above. **Constraints**: - Task names are unique strings. - Priorities are integers. - The class should handle a large number of tasks efficiently using a heap data structure for priority management. **Performance Requirements**: - Insertions and deletions should work in `O(log n)` time, where `n` is the number of tasks in the queue. - Peek and is_empty operations should work in `O(1)` time. **Example**: ```python pq = PriorityQueue() pq.insert(\\"Task1\\", 3) pq.insert(\\"Task2\\", 5) pq.insert(\\"Task3\\", 1) print(pq.peek_max()) # Output: \\"Task2\\" print(pq.extract_max()) # Output: \\"Task2\\" print(pq.is_empty()) # Output: False print(pq.extract_max()) # Output: \\"Task1\\" print(pq.peek_max()) # Output: \\"Task3\\" print(pq.is_empty()) # Output: False print(pq.extract_max()) # Output: \\"Task3\\" print(pq.is_empty()) # Output: True ``` **Additional Notes**: - Utilize Python’s `heapq` module to manage the heap operations. - Ensure the heap maintains the max-heap property. - Handle edge cases such as attempting to extract or peek in an empty queue without causing errors. --- By following this structure and adhering to the guidelines, the added question should integrate seamlessly with the original set, providing a consistent and comprehensive coding assessment experience.","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] self.entry_finder = {} self.REMOVED = \'<removed-task>\' self.counter = 0 def insert(self, task: str, priority: int) -> None: if task in self.entry_finder: self.remove_task(task) count = self.counter entry = [-priority, count, task] self.entry_finder[task] = entry heapq.heappush(self.heap, entry) self.counter += 1 def remove_task(self, task: str) -> None: entry = self.entry_finder.pop(task) entry[-1] = self.REMOVED def extract_max(self) -> str: while self.heap: priority, count, task = heapq.heappop(self.heap) if task is not self.REMOVED: del self.entry_finder[task] return task raise KeyError(\'pop from an empty priority queue\') def peek_max(self) -> str: while self.heap: priority, count, task = self.heap[0] if task is self.REMOVED: heapq.heappop(self.heap) else: return task raise KeyError(\'peek from an empty priority queue\') def is_empty(self) -> bool: return not self.entry_finder"},{"question":"# Scenario In this task, you will enhance a data processing script to handle large CSV files efficiently. The current script reads a CSV file containing user data and calculates the average age within specified groups. However, it performs poorly with large files and lacks some essential features like handling missing values and providing detailed logging. # Objective Improve the given script by implementing the following features: 1. **Efficient Data Processing**: Optimize the script to handle large CSV files using efficient data processing techniques. 2. **Handling Missing Values**: Ensure the script can handle missing values gracefully and exclude incomplete entries from the calculations. 3. **Detailed Logging**: Implement detailed logging to track the processing stages and any issues encountered. 4. **Grouping and Averaging**: Calculate the average age for user-defined groups (e.g., by city, occupation). # Instructions 1. Ensure the function `process_user_data`: * Takes a file path (`csv_file_path`) and a grouping column name (`group_by_column`) as input. * Returns a dictionary with group names as keys and the average age of users in each group as values. ```python def process_user_data(csv_file_path, group_by_column): pass ``` 2. Use libraries like `pandas` for efficient data processing. 3. Implement logging using the built-in `logging` module to track processing steps and potential issues. 4. Handle missing values by excluding rows with missing age or grouping column entries. # Expected Input and Output - **Input**: File path to a CSV (`\\"users_data.csv\\"`), Grouping column name (`\\"city\\"`) - **Output**: A dictionary with group names and their corresponding average ages # Constraints - The CSV file can be very large, so optimize the solution to process data in chunks if necessary. - Log the start and end of the processing, and any errors or warnings encountered during execution. # Example Usage ```python if __name__ == \\"__main__\\": file_path = \\"users_data.csv\\" group_by = \\"city\\" result = process_user_data(file_path, group_by) for group, avg_age in result.items(): print(f\\"Average age in {group}: {avg_age}\\") ``` # Performance Requirements - Efficiently read and process large CSV files without running out of memory. - Provide clear and detailed logs for monitoring the processing workflow and debugging. # Additional Notes - Ensure the script can handle a variety of edge cases such as missing values, empty files, and incorrect file paths gracefully. - Provide informative error messages to guide the user in case of incorrect inputs or execution issues.","solution":"import pandas as pd import logging def process_user_data(csv_file_path, group_by_column): Process user data from a CSV file and calculate average age for specified groups. Parameters: csv_file_path (str): Path to the CSV file containing user data. group_by_column (str): Column name to group by for average age calculation. Returns: dict: A dictionary with group names and their corresponding average ages. # Setting up logging logging.basicConfig(level=logging.INFO, format=\'%(asctime)s - %(levelname)s - %(message)s\') try: # Start processing logging.info(\'Starting to process the CSV file.\') # Initialize an empty DataFrame df_list = [] # Read the CSV file in chunks chunksize = 10000 # adjust based on system capability for chunk in pd.read_csv(csv_file_path, chunksize=chunksize): df_list.append(chunk) df = pd.concat(df_list, axis=0) # Handle missing values: exclude rows with missing age or grouping column if \'age\' not in df.columns or group_by_column not in df.columns: raise ValueError(f\\"CSV file must contain \'age\' and \'{group_by_column}\' columns.\\") df = df.dropna(subset=[\'age\', group_by_column]) # Convert age to numeric, forcing non-numeric to NaN and then drop again df[\'age\'] = pd.to_numeric(df[\'age\'], errors=\'coerce\') df = df.dropna(subset=[\'age\']) # Calculate the average age for each group result = df.groupby(group_by_column)[\'age\'].mean().to_dict() # Logging the completion of processing logging.info(\'Finished processing the CSV file.\') return result except FileNotFoundError: logging.error(f\\"File not found: {csv_file_path}\\") except pd.errors.EmptyDataError: logging.error(\\"No data: The CSV file is empty.\\") except Exception as e: logging.error(f\\"An error occurred: {str(e)}\\")"},{"question":"# Problem Statement You are tasked with developing a function that validates a given string pattern according to specific rules. The function checks if the input string can qualify as a valid identifier in a programming language. This function can be essential for syntax validation processes in compilers or interpreters. # Requirements Function Signature ```python def is_valid_identifier(input_str: str) -> bool: ``` Functionality Description - The function should accept one parameter: * `input_str` (str): The string to be validated as an identifier. - The function should return a boolean indicating whether the `input_str` is a valid identifier or not based on the following rules: * The string must start with a letter (a-z, A-Z) or an underscore (_). * The subsequent characters can be letters (a-z, A-Z), digits (0-9), or underscores (_). * The string must be at least one character long. # Constraints 1. The `input_str` must be a string. # Error Handling 1. Raise a `ValueError` if `input_str` is not a string. # Performance Requirements - Implement the function such that it operates with linear time complexity, O(n), where n is the length of `input_str`. # Example Usage ```python >>> is_valid_identifier(\\"variable1\\") True >>> is_valid_identifier(\\"1variable\\") False >>> is_valid_identifier(\\"_variable\\") True >>> is_valid_identifier(\\"variable_name\\") True >>> is_valid_identifier(\\"variable-name\\") False >>> is_valid_identifier(\\"\\") False ``` In addition, ensure that the function properly raises exceptions on incorrect argument types: ```python >>> is_valid_identifier(123) Traceback (most recent call last): ... ValueError: Expected string as input, found <class \'int\'> ```","solution":"def is_valid_identifier(input_str: str) -> bool: if not isinstance(input_str, str): raise ValueError(f\\"Expected string as input, found {type(input_str)}\\") if len(input_str) == 0: return False if not (input_str[0].isalpha() or input_str[0] == \'_\'): return False for char in input_str[1:]: if not (char.isalnum() or char == \'_\'): return False return True"},{"question":"# Coding Assessment Question Context: You are developing a feature in a music streaming application that involves analyzing user playlists. A common task in this feature is to identify patterns and sequences in the playlist, such as finding the longest sequence of songs by the same artist. Given the need for optimized solutions due to potentially very large playlists, your task is to leverage efficient data structures to solve the problem. Task: 1. Implement a function `longest_artist_streak(playlist: list[tuple[str, str]]) -> tuple[str, int]` that takes a playlist as a list of tuples. Each tuple contains a song title and the artist\'s name. The function should return a tuple containing the artist\'s name and the length of the longest consecutive streak of songs by that artist in the playlist. 2. Write a function `artist_streaks(playlist: list[tuple[str, str]]) -> dict[str, list[int]]` that returns a dictionary where the keys are artist names and the values are lists of the lengths of all their streaks in the playlist. Constraints: * The length of the playlist can be up to 100,000 songs. * Ensure that your solution optimizes for both time and space. * Avoid recomputation and use efficient data structures where possible. Example Input and Output: ```python >>> playlist = [ (\\"song1\\", \\"artistA\\"), (\\"song2\\", \\"artistA\\"), (\\"song3\\", \\"artistB\\"), (\\"song4\\", \\"artistA\\"), (\\"song5\\", \\"artistA\\"), (\\"song6\\", \\"artistA\\"), (\\"song7\\", \\"artistB\\"), (\\"song8\\", \\"artistB\\") ] >>> longest_artist_streak(playlist) (\'artistA\', 3) >>> artist_streaks(playlist) {\'artistA\': [2, 3], \'artistB\': [1, 2]} ``` Notes: * Ensure to handle edge cases such as empty playlists and playlists with only one artist. * Optimize your code to minimize time complexity, especially when dealing with large playlists. * Ensure that your implementation efficiently tracks and records streaks without unnecessary computations. This question requires you to implement efficient data processing techniques and ensures that you can work with lists and dictionaries effectively in Python.","solution":"def longest_artist_streak(playlist): if not playlist: return (\\"\\", 0) max_streak_artist = \\"\\" max_streak_len = 0 current_artist = \\"\\" current_streak_len = 0 for song, artist in playlist: if artist == current_artist: current_streak_len += 1 else: current_artist = artist current_streak_len = 1 if current_streak_len > max_streak_len: max_streak_artist = artist max_streak_len = current_streak_len return (max_streak_artist, max_streak_len) def artist_streaks(playlist): streaks = {} if not playlist: return streaks current_artist = \\"\\" current_streak_len = 0 for song, artist in playlist: if artist == current_artist: current_streak_len += 1 else: if current_artist: if current_artist in streaks: streaks[current_artist].append(current_streak_len) else: streaks[current_artist] = [current_streak_len] current_artist = artist current_streak_len = 1 if current_artist: if current_artist in streaks: streaks[current_artist].append(current_streak_len) else: streaks[current_artist] = [current_streak_len] return streaks"},{"question":"# Scenario: You are responsible for designing a search engine for an e-commerce platform. Your task is to implement a basic search algorithm that can find products based on user queries. Each product in the database has certain attributes like id, name, description, and tags. # Task: Implement a search function that takes a user query and returns a list of product ids that match the query based on their name and description. You will use simple string matching to determine if a product is relevant to the query. # Instructions: 1. **Database Preparation**: * Create a sample product database containing at least 10 products with attributes: id, name, description, and tags. * Store the product database as a list of dictionaries. 2. **Search Implementation**: Implement the search algorithm to find products whose name or description contains all words from the user\'s query. 3. **Searching Products**: Create a function `search_products(query)` that: - Takes a string query as input. - Returns a list of product ids that match the query. 4. **Testing the Function**: Ensure that your function works correctly by running it on various queries. # Constraints: * Each product name and description are strings with a maximum length of 255 characters. * The query is a string with a maximum length of 50 characters. * Match query words case-insensitively and ignore common punctuation. # Expected Functions: You need to implement the function `search_products(query)` which: - Prepares a sample product database. - Searches for products matching the query. - Returns a list of product ids that match the query. # Example: Suppose your product database is: ```python products = [ {\'id\': 1, \'name\': \'Laptop Dell\', \'description\': \'A high-performance laptop\', \'tags\': [\'electronics\', \'laptop\']}, {\'id\': 2, \'name\': \'Smartphone Samsung\', \'description\': \'A top-tier smartphone\', \'tags\': [\'electronics\', \'phone\']}, # Add more products ] ``` For the query `Laptop high-performance`, `search_products(\\"Laptop high-performance\\")` would return: ```python [1] ``` # Additional Requirements: * Ensure that the function is case-insensitive. * Filter out common punctuation from both the query and the product attributes when matching. * Provide examples demonstrating the functionality for different sample queries. ```python def search_products(query): # Prepare a sample product database products = [ {\'id\': 1, \'name\': \'Laptop Dell\', \'description\': \'A high-performance laptop\', \'tags\': [\'electronics\', \'laptop\']}, {\'id\': 2, \'name\': \'Smartphone Samsung\', \'description\': \'A top-tier smartphone\', \'tags\': [\'electronics\', \'phone\']}, # Add more products ] # Your code to search for products # Return the list of matching product ids return matching_product_ids ``` --- The newly designed question keeps consistency in complexity, topic alignment, and structure with the provided dataset and machine learning problem, focusing on an essential software development skill: search algorithms in e-commerce platforms. The scope is comparable, and the task complexity matches real-world scenarios, ensuring it integrates seamlessly into the examination set.","solution":"import string def search_products(query): # Prepare a sample product database products = [ {\'id\': 1, \'name\': \'Laptop Dell\', \'description\': \'A high-performance laptop\', \'tags\': [\'electronics\', \'laptop\']}, {\'id\': 2, \'name\': \'Smartphone Samsung\', \'description\': \'A top-tier smartphone\', \'tags\': [\'electronics\', \'phone\']}, {\'id\': 3, \'name\': \'Headphones Bose\', \'description\': \'Noise-cancelling headphones\', \'tags\': [\'electronics\', \'audio\']}, {\'id\': 4, \'name\': \'Camera Canon\', \'description\': \'8K UHD Camera with advanced features\', \'tags\': [\'electronics\', \'camera\']}, {\'id\': 5, \'name\': \'Tablet Apple\', \'description\': \'iPad Tablet with Retina Display\', \'tags\': [\'electronics\', \'tablet\']}, {\'id\': 6, \'name\': \'Printer HP\', \'description\': \'All-in-one wireless printer\', \'tags\': [\'electronics\', \'printer\']}, {\'id\': 7, \'name\': \'Monitor LG\', \'description\': \'4K Ultra HD Monitor\', \'tags\': [\'electronics\', \'monitor\']}, {\'id\': 8, \'name\': \'Keyboard Logitech\', \'description\': \'Mechanical keyboard with RGB lighting\', \'tags\': [\'electronics\', \'keyboard\']}, {\'id\': 9, \'name\': \'Mouse Microsoft\', \'description\': \'Ergonomic wireless mouse\', \'tags\': [\'electronics\', \'mouse\']}, {\'id\': 10, \'name\': \'Speaker JBL\', \'description\': \'Portable Bluetooth speaker\', \'tags\': [\'electronics\', \'speaker\']} ] def clean_text(s): Lowercase and remove punctuation from a string. return s.translate(str.maketrans(\'\', \'\', string.punctuation)).lower() # Clean query and split into words query_clean = clean_text(query).split() # List to store matching product ids matching_product_ids = [] # Check each product for product in products: name_clean = clean_text(product[\'name\']) description_clean = clean_text(product[\'description\']) # Check if all words in query are in the product name or description if all(word in name_clean or word in description_clean for word in query_clean): matching_product_ids.append(product[\'id\']) return matching_product_ids"},{"question":"# Context: You are tasked to implement a variant of the classic LRU (Least Recently Used) Cache. The LRU Cache should support fast insertion, update, and retrieval operations. The key aspect of an LRU Cache is that when the cache exceeds its capacity, it should evict the least recently used item. To manage this, you decide to use a combination of a hashmap for fast data access and a doubly linked list to maintain the order of use. # Task: Your task is to complete the LRU Cache class with the necessary functions `get` and `put` from the template provided. Below is the given class outline: ```python class ListNode: def __init__(self, key: int = 0, value: int = 0): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): # Implementation details def get(self, key: int) -> int: # To be implemented by students def put(self, key: int, value: int) -> None: # To be implemented by students ``` # Requirements: - Implement the `get` function to retrieve the value associated with the given key. If the key does not exist, return -1. - Implement the `put` function to insert or update the value associated with the given key and maintain the LRU order. If the cache exceeds its capacity, evict the least recently used item. # Constraints: - 1 ≤ capacity ≤ 10^5 - -10^6 ≤ key, value ≤ 10^6 - The number of get and put operations will fit within reasonable space and time needs for competitive programming. # Examples: ```python cache = LRUCache(2) cache.put(1, 1) # cache: {1=1} cache.put(2, 2) # cache: {1=1, 2=2} print(cache.get(1)) # returns 1 cache.put(3, 3) # LRU key 2 is evicted, cache: {1=1, 3=3} print(cache.get(2)) # returns -1 (not found) cache.put(4, 4) # LRU key 1 is evicted, cache: {4=4, 3=3} print(cache.get(1)) # returns -1 (not found) print(cache.get(3)) # returns 3 print(cache.get(4)) # returns 4 ```","solution":"class ListNode: def __init__(self, key: int = 0, value: int = 0): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.head = ListNode() self.tail = ListNode() self.head.next = self.tail self.tail.prev = self.head def _remove_node(self, node): prev = node.prev next = node.next prev.next = next next.prev = prev def _add_to_head(self, node): node.prev = self.head node.next = self.head.next self.head.next.prev = node self.head.next = node def _move_to_head(self, node): self._remove_node(node) self._add_to_head(node) def _pop_tail(self): res = self.tail.prev self._remove_node(res) return res def get(self, key: int) -> int: node = self.cache.get(key) if not node: return -1 self._move_to_head(node) return node.value def put(self, key: int, value: int) -> None: node = self.cache.get(key) if not node: newNode = ListNode(key, value) self.cache[key] = newNode self._add_to_head(newNode) if len(self.cache) > self.capacity: tail = self._pop_tail() del self.cache[tail.key] else: node.value = value self._move_to_head(node)"},{"question":"# Find First Unique Character in a String You are tasked with finding the first unique character in a given string. A unique character is one that appears exactly once in the string. If there is no such unique character, you should return `None`. # Function Signature ```python def first_unique_char(s: str) -> str: pass ``` # Input: - `s` (str): A string consisting of lowercase alphabets. # Output: - Return the first unique character as a single-character string. If no unique character exists, return `None`. # Constraints: - The length of input string `s` will be between `1` and `10^5`. - The string `s` will contain only lowercase alphabets. # Implementation Notes: 1. Utilize an efficient approach to ensure the function runs in linear time. 2. Consider using data structures like dictionaries to track the frequency and position of characters. # Example Usage: ```python first_unique_char(\\"leetcode\\") # => \\"l\\" first_unique_char(\\"loveleetcode\\") # => \\"v\\" first_unique_char(\\"aabb\\") # => None ``` # Unit Testing: Ensure your solution is thoroughly tested with the following sample cases as well as edge cases: - `first_unique_char(\\"leetcode\\")` should return `\\"l\\"`. - `first_unique_char(\\"aabbcc\\")` should return `None`. - `first_unique_char(\\"loveleetcode\\")` should return `\\"v\\"`. - `first_unique_char(\\"a\\")` should return `\\"a\\"`. - `first_unique_char(\\"aabbccddeeffgghhii\\")` should return `None`. - `first_unique_char(\\"abcd\\")` should return `\\"a\\"`.","solution":"def first_unique_char(s: str) -> str: Finds the first unique character in the string. Parameters: s (str): Input string consisting of lowercase alphabets. Returns: str: The first unique character if exists, otherwise `None`. # Dictionary to keep count of each character char_count = {} # Count the frequency of each character in the string for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first character with a count of 1 for char in s: if char_count[char] == 1: return char return None"},{"question":"# Programming Question **Scenario** As part of a hospital management system, you need to simulate the patient admission process. Patients arrive at the hospital and are assigned to rooms based on their condition for better management and monitoring. **Problem Statement** Implement a function `assign_patient_to_room` that assigns a patient to the correct room based on their medical condition. The hospital has the following rooms categorized by condition: | Condition | Room Number | |--------------------|-------------| | Critical | 1 | | Serious | 2 | | Stable | 3 | | Observation | 4 | **Function Signature** ```python def assign_patient_to_room(patient_name: str, condition: str) -> str: pass ``` **Input** - `patient_name` (str): The name of the patient. - `condition` (str): The medical condition of the patient. **Output** - (str): A string indicating which room the patient has been assigned to. Format: \\"Patient {patient_name} has been assigned to room {room_number}.\\" **Constraints** - The input `condition` is always a valid string from the given conditions. - The function should be case-insensitive for condition inputs. **Examples** ```python # Example 1 # Assign a patient named \\"John Doe\\" with a \\"Critical\\" condition print(assign_patient_to_room(\\"John Doe\\", \\"Critical\\")) # Output: \\"Patient John Doe has been assigned to room 1\\" # Example 2 # Assign a patient named \\"Jane Smith\\" with a \\"Serious\\" condition print(assign_patient_to_room(\\"Jane Smith\\", \\"Serious\\")) # Output: \\"Patient Jane Smith has been assigned to room 2\\" # Example 3 # Assign a patient named \\"Emily Davis\\" with a \\"Stable\\" condition print(assign_patient_to_room(\\"Emily Davis\\", \\"Stable\\")) # Output: \\"Patient Emily Davis has been assigned to room 3\\" # Example 4 # Assign a patient named \\"Michael Johnson\\" with an \\"Observation\\" condition print(assign_patient_to_room(\\"Michael Johnson\\", \\"Observation\\")) # Output: \\"Patient Michael Johnson has been assigned to room 4\\" ``` **Notes** - Ensure that the assignment correctly handles mixed-case inputs (e.g., \\"CriTiCaL\\" should be treated the same as \\"critical\\"). - Consider using a dictionary to map the conditions to their corresponding room numbers for easier lookup.","solution":"def assign_patient_to_room(patient_name: str, condition: str) -> str: Assigns a patient to a room based on their medical condition. condition_to_room = { \\"critical\\": 1, \\"serious\\": 2, \\"stable\\": 3, \\"observation\\": 4 } condition_lower = condition.lower() room_number = condition_to_room.get(condition_lower) return f\\"Patient {patient_name} has been assigned to room {room_number}\\""},{"question":"# Prime Factorization: Finding All Prime Factors # Scenario You have been tasked with developing a function to determine all the prime factors of a given integer. # Task Write a Python function `prime_factors` that takes an integer `n` and returns a list of all prime factors of `n` in ascending order. # Function Signature ```python def prime_factors(n: int) -> List[int] ``` # Input * `n` (int): The integer for which to find the prime factors. # Output * Returns a `List[int]` representing the prime factors of the given integer in ascending order. # Constraints 1. `n` > 1 # Example ```python # Find prime factors of 60 result = prime_factors(60) print(result) # Expected output: [2, 2, 3, 5] # Find prime factors of 13195 result = prime_factors(13195) print(result) # Expected output: [5, 7, 13, 29] # Find prime factors of 17 (which is a prime number itself) result = prime_factors(17) print(result) # Expected output: [17] ``` # Notes * This problem involves determining the prime factors iteratively by starting with the smallest prime (2) and working upwards. * Ensure that the solution is efficient and works well even for larger values of `n`. * Focus on correctness and handling edge cases like prime numbers which have only one prime factor (the number itself). # Performance Requirement * The implemented solution should aim for an efficient factorization process, ideally utilizing trial division up to √n for optimal performance. * Space complexity should be constrained to storing the list of factors and minimal extra space for calculations. # Additional Test Case ```python # Find prime factors of 1009 (which is a prime number itself) result = prime_factors(1009) print(result) # Expected output: [1009] ```","solution":"from typing import List def prime_factors(n: int) -> List[int]: factors = [] # Divide by 2 until n is no longer even while n % 2 == 0: factors.append(2) n //= 2 # Check for odd factors from 3 upwards factor = 3 while factor * factor <= n: while n % factor == 0: factors.append(factor) n //= factor factor += 2 # If remaining n is a prime factor greater than 2 if n > 2: factors.append(n) return factors"},{"question":"# Matrix Rotation Challenge You are given a `rotate_matrix` function that rotates a square matrix by 90 degrees clockwise. Your task is to enhance this function to support dynamic rotation degrees. The matrix should be able to rotate by 90, 180, 270, or 360 degrees clockwise based on the user\'s input. Function Signature ```python def rotate_matrix(matrix: List[List[int]], degrees: int) -> List[List[int]]: Rotates the given square matrix by the specified degrees clockwise. Parameters: - matrix (List[List[int]]): A 2D list representing the square matrix. - degrees (int): The degree to rotate the matrix by (must be one of 90, 180, 270, 360). Returns: - List[List[int]]: The rotated matrix. ``` Additional Constraints and Information: 1. **Input Validation**: - `matrix` must be a non-empty 2D list with equal row and column sizes (i.e., square matrix). - `degrees` must be one of the following: 90, 180, 270, 360. If not, raise an error. 2. **Edge Cases**: - Handling non-square matrices should raise an error. - Invalid `degrees` should raise an error. 3. **Performance Requirements**: - Aim for an efficient in-place solution with O(n^2) time complexity where possible for each rotation type. Examples: ```python >>> rotate_matrix([[1, 2], [3, 4]], 90) [[3, 1], [4, 2]] >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 180) [[9, 8, 7], [6, 5, 4], [3, 2, 1]] >>> rotate_matrix([[1]], 360) [[1]] >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 450) Traceback (most recent call last): ... ValueError: \'degrees\' must be one of [90, 180, 270, 360]. >>> rotate_matrix([[1, 2, 3], [4, 5, 6]], 90) Traceback (most recent call last): ... ValueError: \'matrix\' must be a square matrix (equal number of rows and columns). ``` Write the enhanced `rotate_matrix` function in Python as per the described requirements.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]], degrees: int) -> List[List[int]]: Rotates the given square matrix by the specified degrees clockwise. Parameters: - matrix (List[List[int]]): A 2D list representing the square matrix. - degrees (int): The degree to rotate the matrix by (must be one of 90, 180, 270, 360). Returns: - List[List[int]]: The rotated matrix. if not matrix or not all(len(row) == len(matrix) for row in matrix): raise ValueError(\\"\'matrix\' must be a square matrix (equal number of rows and columns).\\") if degrees not in [90, 180, 270, 360]: raise ValueError(\\"\'degrees\' must be one of [90, 180, 270, 360].\\") n = len(matrix) def rotate_90(mat): return [[mat[n - j - 1][i] for j in range(n)] for i in range(n)] num_rotations = degrees // 90 for _ in range(num_rotations): matrix = rotate_90(matrix) return matrix"},{"question":"# Question Overview You are provided with a list of integers and a positive integer `k`. Your task is to find the `k` smallest unique integers in the list in ascending order. If there are fewer than `k` unique integers in the list, return all of them in ascending order. # Problem Statement **Function Signature**: ```python def k_smallest_unique_integers(arr: List[int], k: int) -> List[int]: pass ``` **Input**: - A list of integers `arr` (`1 ≤ len(arr) ≤ 10^6`, `-10^6 ≤ arr[i] ≤ 10^6`). - A positive integer `k` (`1 ≤ k ≤ 10^6`). **Output**: - A list of the `k` smallest unique integers in ascending order. # Constraints - If `k` is greater than the number of unique integers in the list, return all unique integers sorted in ascending order. - The solution should be efficient both in terms of time and space complexity to handle the maximum input size. # Hints - Use a set to eliminate duplicate integers. - Consider sorting the unique integers and then slicing the first `k` elements. # Additional Requirements - Include meaningful comments in your code explaining each step. - Ensure your solution passes the following test cases: ```python assert k_smallest_unique_integers([4, 5, 1, 2, 2, 3, 5], 3) == [1, 2, 3] assert k_smallest_unique_integers([1, 2, 3, 4], 5) == [1, 2, 3, 4] assert k_smallest_unique_integers([10, 8, 12, 6, 8, 3, 7], 2) == [3, 6] assert k_smallest_unique_integers([], 3) == [] assert k_smallest_unique_integers([8, 8, 8], 1) == [8] assert k_smallest_unique_integers([1, 3, 2, 4, 2, 3, 1, 4, 5], 4) == [1, 2, 3, 4] ``` # Performance Testing - Your solution should perform well on lists with up to `10^6` elements and handle various values within the specified range.","solution":"def k_smallest_unique_integers(arr, k): Returns the k smallest unique integers in ascending order. If there are fewer than k unique integers, return all of them in ascending order. # Use a set to eliminate duplicates unique_integers = set(arr) # Convert the set back to a list and sort it sorted_unique_integers = sorted(unique_integers) # Return the first k elements of the sorted list return sorted_unique_integers[:k]"},{"question":"# Binary Search Tree (BST): Validate BST Context: A Binary Search Tree (BST) is a tree data structure in which each node has at most two children referred to as the left child and the right child. For each node, the values of all the nodes in the left subtree are less than or equal to the value of the current node, and the values of all the nodes in the right subtree are greater than the value of the current node. Problem Statement: Given a binary tree, determine if it is a valid binary search tree (BST). Input: - The input will be a binary tree represented by nodes with values and their respective left and right children. - The binary tree will be provided in a serialized format where a node is represented as `(val, left, right)`. Here, `val` is the node value, `left` is the subtree rooted at the left child and `right` is the subtree rooted at the right child. - If a node does not have a left or right child, it is represented as `null`. Output: - Return `True` if the given tree is a valid BST, otherwise return `False`. Constraints: - Each node\'s value will be an integer. - The total number of nodes will not exceed 10,000. Example: **Input:** ``` (2, (1, null, null), (3, null, null)) ``` **Output:** ``` True ``` **Input:** ``` (5, (1, null, null), (4, (3, null, null), (6, null, null))) ``` **Output:** ``` False ``` # Implementation Requirements: - You need to implement the main method `is_valid_BST(root)` that accepts the root of the tree and returns a boolean indicating if the tree is a valid BST. - You may assume a function `Node(val, left=None, right=None)` to create the tree nodes. - Handle all edge cases, e.g., an empty tree, a tree with one node, and larger trees with varying structures. Good luck!","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_valid_BST(root): def validate(node, low=-float(\'inf\'), high=float(\'inf\')): if not node: return True if not (low < node.val < high): return False return (validate(node.left, low, node.val) and validate(node.right, node.val, high)) return validate(root)"},{"question":"# Question You need to solve a problem that involves linked list data structures with various operations. Problem Statement Given a singly linked list where each node contains an integer value, implement a function `rotate_linked_list` that rotates the linked list to the right by `k` places. Here, k is a non-negative integer. Function Signature ```python def rotate_linked_list(head: ListNode | None, k: int) -> ListNode | None: ``` Input - `head` (ListNode | None): The head node of the linked list. It can be `None` if the list is empty. - `k` (int): The number of places to rotate the list to the right. Output - `ListNode | None`: The head of the list after the rotation. Constraints 1. The number of nodes in the list is in the range [0, 500]. 2. Each node\'s value is in the range [-1000, 1000]. 3. 0 <= k <= 2 * 10^9. Example ```python # Linked list structure: 1 -> 2 -> 3 -> 4 -> 5 -> None, rotate by k=2 # Result: 4 -> 5 -> 1 -> 2 -> 3 -> None # Creating linked list head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(3) head.next.next.next = ListNode(4) head.next.next.next.next = ListNode(5) print_linked_list(rotate_linked_list(head, 2)) # Output: 4 -> 5 -> 1 -> 2 -> 3 -> None # Linked list structure: 0 -> 1 -> 2 -> None, rotate by k=4 # Result: 2 -> 0 -> 1 -> None # Creating linked list head = ListNode(0) head.next = ListNode(1) head.next.next = ListNode(2) print_linked_list(rotate_linked_list(head, 4)) # Output: 2 -> 0 -> 1 -> None ``` Requirements - Implement the `rotate_linked_list` function ensuring it handles edge cases like an empty list, a list with one node, and rotation values larger than the length of the list. - Optimize for performance, considering that k can be very large and thus rotating the list repeatedly may be inefficient. Note - A helper function `print_linked_list` is assumed to exist for display purposes; it is not required to implement as part of the solution. - ListNode class definition: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Ensure your `rotate_linked_list` function adheres to standard singly linked list operations and efficiently manages the rotation.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotate_linked_list(head: ListNode | None, k: int) -> ListNode | None: if not head or not head.next or k == 0: return head # Find the length of the linked list length = 1 tail = head while tail.next: tail = tail.next length += 1 # Effective k since rotating length times brings list to original state k %= length if k == 0: return head # Find the new tail (length - k - 1)th node new_tail = head for _ in range(length - k - 1): new_tail = new_tail.next # The new head is the next node after new_tail new_head = new_tail.next # Break the connection new_tail.next = None # Attach the old tail to the old head tail.next = head return new_head"},{"question":"# Question Context Managing data structures efficiently is fundamental to writing optimized algorithms. One common data structure is the linked list, where each element points to the next, allowing for dynamic memory allocation and flexible insertion and deletion operations. Task Write a function `remove_duplicates` that removes all duplicate elements from an unsorted singly linked list, retaining only the first occurrence of each element. Function Signature ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head: ListNode) -> ListNode: ``` Input * `head` – The head node of an unsorted singly linked list. Output * Return the head node of the linked list after removing all duplicates. Constraints * The length of the linked list will not exceed `10^4`. * The values in the linked list will be integers in the range of `-10^5` to `10^5`. Examples ```python # Example 1 # Input: 1 -> 3 -> 2 -> 3 -> 4 -> 4 -> 2 -> None # Output: 1 -> 3 -> 2 -> 4 -> None # Example 2 # Input: 5 -> 5 -> 5 -> 5 -> None # Output: 5 -> None # Example 3 # Input: 0 -> -1 -> -1 -> 2 -> 3 -> None # Output: 0 -> -1 -> 2 -> 3 -> None ``` Explanation * In Example 1, if the input list is `1 -> 3 -> 2 -> 3 -> 4 -> 4 -> 2 -> None`, the function should return `1 -> 3 -> 2 -> 4 -> None` as we keep the first occurrence of each number and remove the duplicates. * In Example 2, the input list `5 -> 5 -> 5 -> 5 -> None` is reduced to a single element list `5 -> None`. * In Example 3, `0 -> -1 -> -1 -> 2 -> 3 -> None` becomes `0 -> -1 -> 2 -> 3 -> None` after removing duplicate occurrences of `-1`. Use a set to keep track of seen elements as you iterate through the linked list, ensuring that only the first occurrence of each element is retained.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head: ListNode) -> ListNode: if not head: return head seen = set() current = head seen.add(current.val) while current and current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next return head"},{"question":"**Recursive Permutations Generator** # Background: Generating permutations of a collection of items is a common problem in computer science, particularly in algorithm design and combinatorial optimization. With recursion, we can elegantly explore all possible arrangements of a given set of elements. # Problem Statement: You are required to implement a function that generates all possible permutations of a given list of distinct integers and returns them as a list of lists. The permutations should be generated using recursion. # Function Signature: ```python def permute(nums: List[int]) -> List[List[int]]: :param nums: A list of distinct integers. :return: A list of lists containing all permutations of the input list. ``` # Requirements: 1. Implement the `permute` function that: - Recursively generates all permutations of the input list. - Returns a list containing all permutations, where each permutation is represented as a list of integers. 2. Ensure that the function handles lists of varying lengths efficiently. 3. The function should not use any external libraries for permutation generation, relying solely on recursion. # Constraints: - The length of `nums` will be between 1 and 8. - All elements in `nums` are distinct and within the range [-10, 10]. # Example: ```python print(permute([1, 2, 3])) # Output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] print(permute([0, -1, 2])) # Output: [[0, -1, 2], [0, 2, -1], [-1, 0, 2], [-1, 2, 0], [2, 0, -1], [2, -1, 0]] ``` # Note: * A recursive approach is essential for this problem. * The implementation should be efficient enough to handle the input size within the given constraints. * Carefully consider the base cases and recursive cases to ensure correctness of the generated permutations. This function should take a list of distinct integers, recursively generate all possible permutations, and return them as a list of lists.","solution":"from typing import List def permute(nums: List[int]) -> List[List[int]]: Returns all possible permutations of the given list of distinct integers. if len(nums) == 0: return [[]] result = [] for i in range(len(nums)): rest = nums[:i] + nums[i+1:] rest_permutations = permute(rest) for perm in rest_permutations: result.append([nums[i]] + perm) return result"},{"question":"You are required to write a function that calculates the area under the curve of a given function `fnc` over an interval `[x_start, x_end]` using the trapezoidal rule for numerical integration. To check your understanding of numerical integration methods, ensure your function follows these specifications: # Function Signature ```python def trapezoidal_area( fnc: Callable[[float], float], x_start: float, x_end: float, num_intervals: int = 1000 ) -> float: ``` # Input - `fnc`: A function representing the curve. - `x_start`: A float indicating the start of the interval. - `x_end`: A float indicating the end of the interval. - `num_intervals`: The number of intervals to divide the area into for the trapezoidal rule (default 1000). # Output - Returns a float representing the approximate area under the curve. # Constraints - The function `fnc` should be continuous within the interval `[x_start, x_end]`. - Ensure the number of intervals is large enough to produce a reasonable approximation, but handle cases where `num_intervals` might be too low. # Example ```python import math def f(x): return math.cos(x) print(trapezoidal_area(f, 0, math.pi)) ``` Expected output should be a float representing the area under the curve of `f(x) = cos(x)` from `0` to `π`. **Note**: Make sure your implementation is efficient and accurate, especially with larger intervals or functions with significant changes in curvature.","solution":"from typing import Callable def trapezoidal_area( fnc: Callable[[float], float], x_start: float, x_end: float, num_intervals: int = 1000 ) -> float: Calculates the area under the curve of a given function `fnc` over an interval `[x_start, x_end]` using the trapezoidal rule. Args: fnc: A function representing the curve. x_start: A float indicating the start of the interval. x_end: A float indicating the end of the interval. num_intervals: The number of intervals to divide the area into for the trapezoidal rule (default 1000). Returns: A float representing the approximate area under the curve. # Calculate the width of each small interval interval_width = (x_end - x_start) / num_intervals # Calculate the area using the trapezoidal rule total_area = 0.5 * (fnc(x_start) + fnc(x_end)) for i in range(1, num_intervals): x_i = x_start + i * interval_width total_area += fnc(x_i) total_area *= interval_width return total_area"},{"question":"# Coding Assessment Question: Context and Scenario: You are working on a new feature for an online retail platform that handles a large inventory of products. For efficient management, products need to be categorized based on their prices. The list of product prices is sorted in ascending order and often requires efficient lookups and range queries to recommend products within specific price brackets. Task: 1. **Function 1: Sorted Insertion** Write a function `sorted_insertion(prices, price)` that inserts a `price` into a sorted list of `prices` such that the order is maintained. The function should be implemented without using Python’s built-in sorting functions or bisect module. ```python def sorted_insertion(prices: list[float], price: float) -> None: Insert a price into the sorted list while maintaining sort order. :param prices: A list of floats representing product prices in ascending order. :param price: The float price to be inserted. pass ``` **Example:** ```python prices = [19.99, 24.99, 39.99, 49.99] sorted_insertion(prices, 29.99) print(prices) # Output: [19.99, 24.99, 29.99, 39.99, 49.99] ``` 2. **Function 2: Range Query** Write a function `price_range_query(prices, low, high)` that returns a list of prices that fall within a specific inclusive range [low, high] from `prices` sorted list. Ensure efficient retrieval to handle large datasets. ```python def price_range_query(prices: list[float], low: float, high: float) -> list[float]: Fetch a list of prices within the specified [low, high] range. :param prices: A list of floats representing product prices in ascending order. :param low: The lower bound of the price range. :param high: The upper bound of the price range. :return: A list of prices within the range [low, high]. pass ``` **Example:** ```python prices = [19.99, 24.99, 39.99, 49.99, 59.99] result = price_range_query(prices, 20.00, 50.00) print(result) # Output: [24.99, 39.99, 49.99] result = price_range_query(prices, 50.00, 60.00) print(result) # Output: [49.99, 59.99] ``` Constraints: - `prices` list contains float values representing product prices. - Ensure the `prices` list remains sorted after insertion. - Queries should be handled efficiently for large datasets (up to ( 10^6 ) elements). - Handle edge cases like an empty list, single-element list, and ranges that do not include any prices. Performance Requirements: - The sorted insertion should be implemented in linear time complexity and range query retrieval should be handled efficiently in logarithmic time complexity.","solution":"def sorted_insertion(prices: list[float], price: float) -> None: Insert a price into the sorted list while maintaining sort order. :param prices: A list of floats representing product prices in ascending order. :param price: The float price to be inserted. for i in range(len(prices)): if prices[i] >= price: prices.insert(i, price) return prices.append(price) def price_range_query(prices: list[float], low: float, high: float) -> list[float]: Fetch a list of prices within the specified [low, high] range. :param prices: A list of floats representing product prices in ascending order. :param low: The lower bound of the price range. :param high: The upper bound of the price range. :return: A list of prices within the range [low, high]. result = [] for price in prices: if low <= price <= high: result.append(price) return result"},{"question":"# Interval List Intersections You are given two lists of closed intervals. Each list represents a collection of intervals merged according to their pairwise overlaps. Write a function to find the intersection of these intervals, i.e., the common intervals present in both lists. Function Signature ```python def interval_intersection(list1: list[tuple[int, int]], list2: list[tuple[int, int]]) -> list[tuple[int, int]]: ``` # Input * Two lists of tuples where each tuple `(a, b)` represents a closed interval `[a, b]`. - The intervals within each list are disjoint and sorted in increasing order. - The lists contain `n` and `m` intervals respectively (1 ≤ n, m ≤ 10^4). # Output * Return a list of tuples representing the intersections of the intervals in both lists. The intersections should also be sorted in increasing order. # Constraints * The intervals within each list are non-overlapping. * The start and end points of the intervals will be integers in the range -10^9 to 10^9. # Example ```python print(interval_intersection([(1, 3), (5, 9)], [(2, 5), (6, 8)])) # Output: [(2, 3), (5, 5), (6, 8)] print(interval_intersection([(1, 6)], [(2, 4)])) # Output: [(2, 4)] print(interval_intersection([(1, 2), (4, 6), (7, 8)], [(2, 3), (5, 7)])) # Output: [(2, 2), (5, 6), (7, 7)] ``` # Edge Cases to Consider * Intervals that do not overlap: The result should be an empty list. * Identical intervals overlap completely, with an output exactly the same as these intervals. * Only partial overlaps, where the intersection is a subset of an original interval from either list. * One interval list is significantly longer or shorter than the other.","solution":"def interval_intersection(list1, list2): i, j = 0, 0 intersections = [] while i < len(list1) and j < len(list2): start1, end1 = list1[i] start2, end2 = list2[j] # Find the intersection between intervals list1[i] and list2[j] inter_start = max(start1, start2) inter_end = min(end1, end2) if inter_start <= inter_end: intersections.append((inter_start, inter_end)) # Move to the next interval in the list that has the smallest endpoint if end1 < end2: i += 1 else: j += 1 return intersections"},{"question":"# Coding Assessment Question Recursive Fibonacci Sequence Calculation You are given an implementation of the Fibonacci sequence using an iterative approach. Your task is to create a recursive function that computes the nth Fibonacci number. # Problem Statement Function: fibonacci_recursive Write a function `fibonacci_recursive` that: - Takes as input a single integer `n`. - Returns the nth Fibonacci number, where the sequence is defined as: - `F(0) = 0` - `F(1) = 1` - For `n > 1`, `F(n) = F(n-1) + F(n-2)` - Uses a recursive approach to compute the result. Constraints: 1. Input `n` will be a non-negative integer. 2. The function should be optimized for small values of `n` due to the nature of recursion (complexity constraints). Specifications: - Input: Integer `n`. - Output: Integer representing the nth Fibonacci number. Example Scenario Given `n = 5`: ```python result = fibonacci_recursive(5) print(result) # Output should be 5 ``` This demonstrates an example where the Fibonacci sequence is `0, 1, 1, 2, 3, 5`, and the 5th Fibonacci number is `5`. # Note: Handle edge cases such as: - `n = 0` should return `0`. - `n = 1` should return `1`. Write your implementation in a function `fibonacci_recursive` adhering to the principles defined above.","solution":"def fibonacci_recursive(n): Returns the nth Fibonacci number using a recursive approach. if n <= 0: return 0 elif n == 1: return 1 else: return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)"},{"question":"# Context You are building an e-commerce system and need to implement functionality to manage and overlay pricing rules for different types of discounts. # Problem Statement Write a Python class `PricingRules` that supports the following functionalities: 1. **Initialization**: Should initialize with a base price. 2. **Add Discount Rule**: Implement a method to add various discount rules (percentage and fixed amount). 3. **Remove Discount Rule**: Implement a method to remove a specific discount rule. 4. **Calculate Final Price**: Implement a method to compute the final price after applying all discount rules in the order they were added. Additionally, implement a unit test suite to validate these functionalities. Ensure to handle edge cases and different ordering scenarios. # Implementation Details 1. **Initialization**: ```python class PricingRules: def __init__(self, base_price: float) -> None: ... ``` 2. **Add Discount Rule**: ```python def add_discount_rule(self, rule_type: str, value: float) -> None: Add a discount rule. - rule_type: \\"percentage\\" or \\"fixed\\" - value: the value of the discount (20 for 20% or 50 for 50) ... ``` 3. **Remove Discount Rule**: ```python def remove_discount_rule(self, rule_type: str, value: float) -> None: Remove a specific discount rule. - rule_type: \\"percentage\\" or \\"fixed\\" - value: the value of the discount to be removed ... ``` 4. **Calculate Final Price**: ```python def final_price(self) -> float: Compute and return the final price after applying all discount rules in order. ... ``` # Constraints - The base price is guaranteed to be a positive float. - Percentage discounts are applied sequentially, affecting the current price per rule. - The system should gracefully handle attempts to remove non-existing discount rules. # Unit Tests Create a test class `TestPricingRules` using `unittest` to validate the implementation. Ensure to cover edge cases like zero discounts, large discounts, and multiple discount combinations. # Example ```python initial_price = 100.0 pricing = PricingRules(initial_price) # Add discount rules pricing.add_discount_rule(\\"percentage\\", 10) # 10% discount pricing.add_discount_rule(\\"fixed\\", 5) # 5 discount pricing.add_discount_rule(\\"percentage\\", 20) # 20% discount # Calculate final price print(pricing.final_price()) # Should apply discounts in order and return final price # Remove a discount rule pricing.remove_discount_rule(\\"fixed\\", 5) # Calculate final price after removing the 5 discount print(pricing.final_price()) # Should return price after remaining discounts ```","solution":"class PricingRules: def __init__(self, base_price: float) -> None: Initializes the PricingRules object with a base price. self.base_price = base_price self.discount_rules = [] def add_discount_rule(self, rule_type: str, value: float) -> None: Adds a discount rule. - rule_type: \\"percentage\\" or \\"fixed\\" - value: the value of the discount (20 for 20% or 50 for 50) self.discount_rules.append((rule_type, value)) def remove_discount_rule(self, rule_type: str, value: float) -> None: Removes a specific discount rule. - rule_type: \\"percentage\\" or \\"fixed\\" - value: the value of the discount to be removed if (rule_type, value) in self.discount_rules: self.discount_rules.remove((rule_type, value)) def final_price(self) -> float: Computes and returns the final price after applying all discount rules in order. final_price = self.base_price for rule_type, value in self.discount_rules: if rule_type == \\"percentage\\": final_price -= final_price * (value / 100) elif rule_type == \\"fixed\\": final_price -= value return max(0, final_price) # Ensure that price does not go negative"},{"question":"# Problem Statement Implement a `find_disjoint_sets` function that takes an undirected graph represented as an adjacency list and returns a list of disjoint sets where each set contains the nodes of a connected component of the graph. Function Signature ```python def find_disjoint_sets(graph: dict[int, list[int]]) -> list[list[int]]: pass ``` # Input * `graph`: A dictionary where the key is an integer representing a node, and the value is a list of integers representing adjacent nodes. # Output * Return a list of lists, where each inner list contains integers representing the nodes that form a connected component in the graph. # Constraints * The graph might be disconnected, so it can have multiple connected components. * Node identifiers are non-negative integers. * The graph is undirected, so each edge is represented in both connecting nodes\' adjacency lists. # Example ```python # Example 1: graph = {0: [1, 2], 1: [0, 2], 2: [0, 1], 3: [4], 4: [3]} assert find_disjoint_sets(graph) == [[0, 1, 2], [3, 4]] # Example 2: graph = {0: [1, 2], 1: [0, 2], 2: [0, 1], 3: [], 4: [5], 5: [4]} assert find_disjoint_sets(graph) == [[0, 1, 2], [3], [4, 5]] # Example 3: graph = {} assert find_disjoint_sets(graph) == [] # Example 4: graph = {0: []} assert find_disjoint_sets(graph) == [[0]] ``` # Additional Information * You can use Depth-First Search (DFS) or Breadth-First Search (BFS) to implement this functionality. * Ensure your solution handles potential edge cases such as an empty graph or a graph with isolated nodes. * Be mindful of performance and optimize for large graphs if possible.","solution":"def find_disjoint_sets(graph: dict[int, list[int]]) -> list[list[int]]: def dfs(node, component): stack = [node] while stack: current = stack.pop() if current not in visited: visited.add(current) component.append(current) stack.extend(graph[current]) visited = set() disjoint_sets = [] for node in graph: if node not in visited: component = [] dfs(node, component) disjoint_sets.append(component) return disjoint_sets"},{"question":"# Directed Graph Cycle Detection Context You are asked to determine if a given directed graph contains any cycles. A cycle in a directed graph is a path that starts at a vertex and returns to the same vertex via a sequence of directed edges. Requirements Write a function `has_cycle(graph: dict) -> bool` that checks if there is a cycle in the given directed graph. The graph is represented as an adjacency list, where the keys are vertices and the values are lists of vertices that can be reached from the key vertex. Input and Output * **Input**: * The function should accept a dictionary `graph`, where each key is a string representing a vertex, and each value is a list of strings representing the vertices to which there are directed edges. * **Output**: * The function should return `True` if there is at least one cycle in the graph, `False` otherwise. Constraints * The graph can have up to (10^4) vertices and (10^5) edges. * Vertex names are non-empty strings with at most 50 characters. * The graph may be disconnected, meaning it could have more than one component. Example ```python graph1 = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"C\\", \\"D\\"], \\"C\\": [\\"E\\"], \\"D\\": [\\"A\\"], \\"E\\": [] } assert has_cycle(graph1) == True graph2 = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [] } assert has_cycle(graph2) == False graph3 = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [\\"A\\"] } assert has_cycle(graph3) == True graph4 = { \\"A\\": [\\"B\\"], \\"B\\": [\\"A\\"], \\"C\\": [\\"D\\"], \\"D\\": [] } assert has_cycle(graph4) == True graph5 = { \\"A\\": [], \\"B\\": [], \\"C\\": [] } assert has_cycle(graph5) == False ``` # Explanation This problem requires you to use graph traversal techniques such as Depth First Search (DFS) or other algorithms to detect cycles in a directed graph. You\'ll need to keep track of visited nodes and maintain recursion stack to detect back edges, which indicate cycles. The function should handle graphs of varying sizes and configurations, including those with multiple disconnected components.","solution":"def has_cycle(graph): Returns whether the given directed graph has a cycle or not. visited = set() rec_stack = set() def dfs(vertex): Depth First Search helper function to detect cycles. if vertex in rec_stack: # Cycle detected return True if vertex in visited: return False visited.add(vertex) rec_stack.add(vertex) for neighbor in graph.get(vertex, []): if dfs(neighbor): return True rec_stack.remove(vertex) return False for node in graph: if node not in visited: if dfs(node): return True return False"},{"question":"# Min Stack Implementation ***Scenario:*** You are assigned the task of developing an enhanced stack data structure to support constant-time retrieval of the minimum element while maintaining standard stack operations. This extended functionality is essential for optimizing algorithms in applications such as stock price analysis or computing span queries. # Problem Statement Implement a class `MinStack` that supports the following operations: - `push(int val)`: Pushes the integer `val` onto the stack. - `pop()`: Removes the element on the top of the stack. - `top()`: Gets the top element of the stack. - `get_min()`: Retrieves the minimum element in the stack. # Class Signature ```python class MinStack: def __init__(self): pass def push(self, val: int) -> None: pass def pop(self) -> None: pass def top(self) -> int: pass def get_min(self) -> int: pass ``` # Methods 1. `__init__()`: Initializes the stack object. 2. `push(int val)`: Adds a new element `val` to the stack. 3. `pop()`: Removes the top element from the stack. 4. `top()`: Returns the top element. 5. `get_min()`: Returns the minimum element in the stack. # Constraints or Considerations * All operations must have O(1) time complexity. * You are allowed to use additional data structures to achieve the desired performance. * The stack can store multiple identical elements. # Examples ```python min_stack = MinStack() min_stack.push(-2) min_stack.push(0) min_stack.push(-3) print(min_stack.get_min()) # Output: -3 min_stack.pop() print(min_stack.top()) # Output: 0 print(min_stack.get_min()) # Output: -2 ``` # Additional Notes - Ensure robust handling of edge cases, such as performing operations on an empty stack. - Aim for elegant and readable code with appropriate comments and documentation. - Consider the implications of space complexity and strive for an optimal solution.","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, val: int) -> None: self.stack.append(val) if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: if self.stack: val = self.stack.pop() if val == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: if self.stack: return self.stack[-1] return None def get_min(self) -> int: if self.min_stack: return self.min_stack[-1] return None"},{"question":"# Password Strength Assessment You are required to implement a function that evaluates the strength of a given password. The function should return `True` if the password is deemed strong, and `False` otherwise. Follow the constraints and rules outlined below. **Function Signature**: ```python def is_strong_password(password: str) -> bool: pass ``` # Constraints and Rules 1. **Length Requirement**: - The password must be at least 8 characters long and at most 20 characters long. 2. **Character Requirements**: - The password must contain at least one uppercase Latin letter (A-Z). - The password must contain at least one lowercase Latin letter (a-z). - The password must contain at least one digit (0-9). - The password must contain at least one special character from the set: !@#%^&*()-+. 3. **Repetition Requirement**: - The password must not contain three or more consecutive identical characters. # Expected Input and Output Formats **Input**: - A string `password` representing the password to be evaluated. **Output**: - A boolean value `True` if the password is strong, otherwise `False`. # Example ```python assert is_strong_password(\\"Strong@123\\") == True assert is_strong_password(\\"weakpassword\\") == False assert is_strong_password(\\"12345678\\") == False assert is_strong_password(\\"Aa1!\\") == False assert is_strong_password(\\"StrongPassAa1!\\") == True ```","solution":"def is_strong_password(password: str) -> bool: if len(password) < 8 or len(password) > 20: return False has_upper = has_lower = has_digit = has_special = False special_characters = \\"!@#%^&*()-+\\" for i in range(len(password)): if password[i].isupper(): has_upper = True elif password[i].islower(): has_lower = True elif password[i].isdigit(): has_digit = True elif password[i] in special_characters: has_special = True if i >= 2: if password[i] == password[i-1] == password[i-2]: return False return has_upper and has_lower and has_digit and has_special"},{"question":"# Problem Description Given a grid of integers `grid`, where each integer represents the height of the terrain at that point, write a function `trap_rainwater(grid: List[List[int]]) -> int` that computes the total amount of rainwater that can be trapped after it rains. You can assume that water only gets trapped in the dips and valleys and does not spill over the edges of the grid. # Input * `grid`: A 2D list of integers representing the heights of the units of the terrain (1 ≤ grid[i][j] ≤ 1000). The grid has `m` rows and `n` columns (1 ≤ m, n ≤ 100). # Output * Returns an integer representing the total amount of rainwater trapped. # Constraints * The grid is guaranteed to have at least one row and one column. # Example ```python grid = [ [1, 4, 3, 1, 3, 2], [3, 2, 1, 3, 2, 4], [2, 3, 3, 2, 3, 1] ] print(trap_rainwater(grid)) # Output: 4 grid = [ [5, 5, 5, 1], [5, 1, 1, 5], [5, 1, 5, 5], [5, 2, 5, 8] ] print(trap_rainwater(grid)) # Output: 3 ``` # Note You need to handle the scenario where the grid forms multiple depressions and calculate the trapped water accordingly. # Steps to Solve 1. Initialize a priority queue and add all the boundary cells to it. 2. Use a matrix to mark visited cells. 3. For each cell, from the boundary, find the minimum height needed to trap water and propagate this information to its neighbors until the entire grid is processed. 4. Sum up the trapped water in all cells according to their heights and the heights of their neighbors.","solution":"from typing import List import heapq def trap_rainwater(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] pq = [] for i in range(m): heapq.heappush(pq, (grid[i][0], i, 0)) heapq.heappush(pq, (grid[i][n-1], i, n-1)) visited[i][0] = True visited[i][n-1] = True for j in range(n): heapq.heappush(pq, (grid[0][j], 0, j)) heapq.heappush(pq, (grid[m-1][j], m-1, j)) visited[0][j] = True visited[m-1][j] = True directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] trapped_water = 0 while pq: height, x, y = heapq.heappop(pq) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: trapped_water += max(0, height - grid[nx][ny]) heapq.heappush(pq, (max(height, grid[nx][ny]), nx, ny)) visited[nx][ny] = True return trapped_water"},{"question":"# Scheduling Tasks with Deadlines and Durations You are to implement a scheduling algorithm that determines the maximum number of non-overlapping tasks that can be completed before their respective deadlines. Task: Scheduling Algorithm Write a function, `max_tasks(tasks: list[tuple[int, int]]) -> int`, that finds the maximum number of tasks you can perform without missing their deadlines. Each task is represented by a tuple, where the first element is the deadline by which the task needs to be completed, and the second element is the duration it takes to complete the task. Input: 1. A list of `n` tasks, `tasks: list[tuple[int, int]]`, where each task is a tuple `(deadline, duration)`. Output: 1. Return an integer representing the maximum number of non-overlapping tasks that can be completed within their deadlines. Example: ```python # Given tasks tasks = [ (4, 2), (4, 1), (2, 1), (3, 2) ] # Find the maximum number of tasks max_completed_tasks = max_tasks(tasks) # Output: The maximum number of tasks that can be completed, e.g., 3 ``` Constraints: - The number of tasks `n` will be such that `1 ≤ n ≤ 1000`. - The deadlines and durations will be positive integers. Performance Requirements: - Aim for an efficient solution that sorts the tasks based on deadlines and selects the maximal number of non-overlapping tasks. # Solution Planning: - Sort tasks by their deadline. - Utilize a greedy algorithm to select tasks in the order of their deadlines, ensuring each selection\'s duration fits within the cumulative time before the deadline. This approach will operate efficiently within the constraints and ensures the tasks can be scheduled optimally.","solution":"def max_tasks(tasks): Returns the maximum number of non-overlapping tasks that can be completed without missing their deadlines. Args: tasks (list of tuple): List of tuples where each tuple contains deadline and duration of a task. Returns: int: The maximum number of tasks that can be completed. # Sort tasks by their deadlines first tasks.sort(key=lambda x: x[0]) current_time = 0 count = 0 for deadline, duration in tasks: if current_time + duration <= deadline: current_time += duration count += 1 return count"},{"question":"# Coding Question Problem Statement You are given a list of integers `numbers`. Your task is to write a Python function called `is_valid_sequence` that determines whether the given list can be considered a \\"valid sequence.\\" A list is deemed a \\"valid sequence\\" if each element is exactly one greater than the preceding element. If the list is empty or contains only one element, it should be considered a valid sequence. Your function should raise a `ValueError` with the message \\"Input must be a list of integers\\" if the input is not a list of integers. Requirements - Function Signature: `def is_valid_sequence(numbers: list) -> bool:` - **Input**: A list of integers `numbers`. - **Output**: A boolean value `True` if the list is a valid sequence, otherwise `False`. - **Constraints**: The list can contain an arbitrary number of elements. Example ```python >>> is_valid_sequence([1, 2, 3, 4]) True >>> is_valid_sequence([5, 6, 7, 8, 9]) True >>> is_valid_sequence([2, 4, 5, 6]) False >>> is_valid_sequence([]) True >>> is_valid_sequence([10]) True >>> is_valid_sequence([\'a\', 2, 3]) Traceback (most recent call last): ... ValueError: Input must be a list of integers >>> is_valid_sequence(1234) Traceback (most recent call last): ... ValueError: Input must be a list of integers >>> is_valid_sequence([1, 2, \'three\']) Traceback (most recent call last): ... ValueError: Input must be a list of integers ``` Constraints - The function should handle input errors by raising `ValueError` with the message \\"Input must be a list of integers\\". - The function should be efficient and handle lists of various lengths accurately. Additional Notes - Ensure that your input validation checks are comprehensive. - Consider the implications of an empty list or a single-element list in your implementation. - Optimize for clarity and maintainability in your code design.","solution":"def is_valid_sequence(numbers): Determines if the provided list of integers is a valid sequence where each element is exactly one greater than the preceding element. Args: numbers (list): List of integers. Returns: bool: True if the list is a valid sequence, False otherwise. Raises: ValueError: If the input is not a list of integers. # Check if the input is a list if not isinstance(numbers, list): raise ValueError(\\"Input must be a list of integers\\") # Check if all elements in the list are integers if not all(isinstance(item, int) for item in numbers): raise ValueError(\\"Input must be a list of integers\\") # An empty list or a single element list is considered a valid sequence if len(numbers) <= 1: return True # Check if each element is one greater than the preceding element for i in range(1, len(numbers)): if numbers[i] != numbers[i - 1] + 1: return False return True"},{"question":"# Problem Statement You are given a task to develop a simple inventory management system for a small warehouse. This system should be able to handle different types of inventory operations, including adding new items, updating quantities, and fetching the current list of items in the inventory. Your task is to implement three functions: `add_item`, `update_quantity`, and `get_inventory`. Each function should perform specified operations on a global inventory dictionary. # Global Data Structure * **Global Dictionary**: `inventory` * Keys are item names (strings). * Values are item quantities (integers). ```python inventory = {} ``` # Input and Output Format Function 1: `add_item(item_name: str, quantity: int) -> None` * **Input**: * `item_name` (str): The name of the item to be added to the inventory. * `quantity` (int): The initial quantity of the item. * **Output**: * No return. Updates the `inventory` dictionary. * **Assumptions**: * If the item already exists in the inventory, raise a `ValueError` with the message \\"Item already exists\\". Function 2: `update_quantity(item_name: str, quantity: int) -> None` * **Input**: * `item_name` (str): The name of the item whose quantity is to be updated. * `quantity` (int): The quantity to be added (positive) or removed (negative) from the item. * **Output**: * No return. Updates the `inventory` dictionary. * **Assumptions**: * If updating the quantity results in a negative total, raise a `ValueError` with the message \\"Insufficient quantity\\". * If the item does not exist in the inventory, raise a `ValueError` with the message \\"Item not found\\". Function 3: `get_inventory() -> dict` * **Input**: * No input. * **Output**: * Returns a dictionary representing the current state of the inventory. # Requirements 1. Use the global `inventory` dictionary for all operations. 2. Implement proper error handling for invalid operations as specified. 3. Ensure that item names are treated case-sensitively. # Example ```python # Initialize the inventory for the example inventory = {} # Add new items add_item(\\"apple\\", 50) add_item(\\"banana\\", 100) # Update quantities update_quantity(\\"apple\\", 20) # New quantity: 70 update_quantity(\\"banana\\", -50) # New quantity: 50 # Retrieve the current inventory state current_inventory = get_inventory() # current_inventory should be: {\\"apple\\": 70, \\"banana\\": 50} # Error handling try: add_item(\\"apple\\", 30) except ValueError as e: print(e) # Output: Item already exists try: update_quantity(\\"banana\\", -60) except ValueError as e: print(e) # Output: Insufficient quantity try: update_quantity(\\"grape\\", 10) except ValueError as e: print(e) # Output: Item not found ``` # Constraints * `item_name` will always be a string with a maximum length of 100 characters. * `quantity` will always be an integer in the range (-10000, 10000). Implement these functions in Python, ensuring correctness and efficiency.","solution":"# Global inventory dictionary inventory = {} def add_item(item_name: str, quantity: int) -> None: Adds a new item to the inventory. If the item already exists, raises a ValueError. if item_name in inventory: raise ValueError(\\"Item already exists\\") inventory[item_name] = quantity def update_quantity(item_name: str, quantity: int) -> None: Updates the quantity of an existing item in the inventory. If the item does not exist, raises a ValueError. If the resulting quantity is negative, raises a ValueError. if item_name not in inventory: raise ValueError(\\"Item not found\\") if inventory[item_name] + quantity < 0: raise ValueError(\\"Insufficient quantity\\") inventory[item_name] += quantity def get_inventory() -> dict: Returns the current state of the inventory. return inventory"},{"question":"# Problem Statement Sorting algorithms play a vital role in computer science, with various types tailored to specific needs and performance requirements. One such algorithm is the Selection Sort, which is a simple comparison-based sorting algorithm that works by repeatedly selecting the minimum element from the unsorted part and putting it at the beginning. Task Your task is to implement a function `selection_sort` that sorts a list of integers in ascending order using the Selection Sort algorithm. You must also handle and raise appropriate exceptions for invalid inputs. Function Signature ```python def selection_sort(arr: list) -> list: ``` Input * `arr` (list): A list of integers to be sorted. The list may be empty. Output * Returns a list of integers sorted in ascending order. Constraints * If `arr` is not a list, raise a `TypeError` with the message \\"Input must be a list\\". * If any element in `arr` is not an integer, raise a `ValueError` with the message \\"All elements must be integers\\". Performance Requirements * The function should run with a time complexity of O(n^2) where n is the number of elements in the list. Example Usage ```python >>> selection_sort([64, 25, 12, 22, 11]) [11, 12, 22, 25, 64] >>> selection_sort([3, -2, 5, 1, 6]) [-2, 1, 3, 5, 6] >>> selection_sort([]) [] >>> selection_sort(\'not a list\') Traceback (most recent call last): ... TypeError: Input must be a list >>> selection_sort([4, 3, \'not an integer\']) Traceback (most recent call last): ... ValueError: All elements must be integers ``` Notes - Ensure your function provides correct results and handles all edge cases effectively. - Assume all integer comparisons and operations are performed in a valid integer range.","solution":"def selection_sort(arr): Sorts a list of integers in ascending order using the Selection Sort algorithm. Parameters: arr (list): A list of integers to be sorted. Returns: list: A list of integers sorted in ascending order. Raises: TypeError: If the input is not a list. ValueError: If any element in the list is not an integer. if not isinstance(arr, list): raise TypeError(\\"Input must be a list\\") for element in arr: if not isinstance(element, int): raise ValueError(\\"All elements must be integers\\") n = len(arr) for i in range(n): # Find the minimum element in remaining unsorted array min_idx = i for j in range(i+1, n): if arr[j] < arr[min_idx]: min_idx = j # Swap the found minimum element with the first element arr[i], arr[min_idx] = arr[min_idx], arr[i] return arr"},{"question":"# Coding Assessment Question: URL Shortening Service As a software engineer at a tech startup, you have been assigned the task to develop a basic URL shortening service using Python. **Context:** URL shortening is a technique used on the Internet in which a long URL can be made substantially shorter and still direct users to the desired page. This is extremely useful for making links more manageable and easier to share, especially on platforms with character limits. # Task: Implement a class `URLShortener` that provides methods to shorten URLs and retrieve the original URLs using a shortened version. # Specifications: 1. **Class: URLShortener** ```python class URLShortener: ``` - **Attributes**: - `url_mapping` (dict): A dictionary that stores the mapping from the shortened URLs to the original URLs. - `counter` (int): A counter to generate unique keys for the shortened URLs. 2. **Method 1: Shortening a URL** ```python def shorten_url(self, original_url: str) -> str: ``` - **Input**: `original_url` (str) - The original URL that needs to be shortened. - **Output**: A unique shortened URL (str). - **Constraints**: - Ensure the same original URL always gets the same shortened URL. - The mapping should be stored in `url_mapping`. - Use a simple incrementing counter and base62 encoding to generate keys for shortened URLs. 3. **Method 2: Retrieving the Original URL** ```python def retrieve_url(self, short_url: str) -> str: ``` - **Input**: `short_url` (str) - The shortened URL. - **Output**: The original URL (str). - **Constraints**: - Return the original URL corresponding to the `short_url`. - If the shortened URL does not exist, return an error message. # Sample Input & Output: ```python shortener = URLShortener() # Original URL original_url = \\"https://www.example.com\\" # Shorten the URL short_url = shortener.shorten_url(original_url) print(short_url) # Output: \'http://short.url/1\' # Retrieve the original URL from the shortened URL retrieved_url = shortener.retrieve_url(short_url) print(retrieved_url) # Output: \'https://www.example.com\' ``` # Example Usage: ```python shortener = URLShortener() # Shortening multiple URLs short_url1 = shortener.shorten_url(\\"https://www.example1.com\\") short_url2 = shortener.shorten_url(\\"https://www.example2.com\\") # Retrieving the URLs print(shortener.retrieve_url(short_url1)) # Output: \'https://www.example1.com\' print(shortener.retrieve_url(short_url2)) # Output: \'https://www.example2.com\' ``` # Performance Requirements: - Aim for optimal time complexity for both shortening and retrieving URLs. - Use a space-efficient method to store and manage the URL mappings. # Testing: - Write unit tests to ensure your implementation handles typical scenarios and edge cases, such as shortening the same URL multiple times or retrieving a URL that does not exist. Good luck!","solution":"class URLShortener: def __init__(self): self.url_mapping = {} self.counter = 1 self.base_url = \\"http://short.url/\\" def shorten_url(self, original_url: str) -> str: for existing_short_url, url in self.url_mapping.items(): if url == original_url: return self.base_url + existing_short_url short_key = str(self.counter) self.url_mapping[short_key] = original_url self.counter += 1 return self.base_url + short_key def retrieve_url(self, short_url: str) -> str: short_key = short_url.replace(self.base_url, \\"\\") if short_key in self.url_mapping: return self.url_mapping[short_key] else: return \\"Error: Short URL not found\\""},{"question":"**Problem Statement:** You are tasked with implementing and testing a Min Heap from scratch in Python. The Min Heap should have the following functionalities: 1. `__init__(self)`: Initializes an empty Min Heap. 2. `insert(self, key: int) -> None`: Inserts a new key into the heap. 3. `extract_min(self) -> int`: Extracts and returns the minimum element from the heap. Raises an `Exception` with the message `\\"Heap is empty\\"` if the heap is empty. 4. `get_min(self) -> int`: Returns the minimum element without removing it. Raises an `Exception` with the message `\\"Heap is empty\\"` if the heap is empty. 5. `is_empty(self) -> bool`: Returns `True` if the heap is empty, `False` otherwise. # Input and Output Format: * **Input**: * The `insert` method takes one argument which is the key to be added to the heap. * The `extract_min` and `get_min` methods do not take any arguments. * **Output**: * The `insert` method does not return any value. * The `get_min` and `extract_min` methods return the minimum element in the heap. If the heap is empty, these functions should raise an `Exception` with the message `\\"Heap is empty\\"`. # Constraints: * The heap must be implemented using a list where the root of the heap is at index 0. * Ensure that you handle edge cases gracefully such as attempting to extract the minimum from an empty heap or find the minimum in an empty heap. # Example: ```python heap = MinHeap() heap.insert(3) heap.insert(2) assert heap.get_min() == 2 assert not heap.is_empty() heap.insert(15) heap.insert(5) heap.insert(4) heap.insert(45) assert heap.extract_min() == 2 assert heap.get_min() == 3 assert heap.extract_min() == 3 assert heap.get_min() == 4 assert heap.extract_min() == 4 heap.extract_min() heap.extract_min() try: heap.extract_min() except Exception as e: assert str(e) == \\"Heap is empty\\" try: heap.get_min() except Exception as e: assert str(e) == \\"Heap is empty\\" ``` Implement the `MinHeap` class in Python with the methods specified above.","solution":"class MinHeap: def __init__(self): self.heap = [] def insert(self, key: int) -> None: self.heap.append(key) self._heapify_up(len(self.heap) - 1) def extract_min(self) -> int: if self.is_empty(): raise Exception(\\"Heap is empty\\") min_val = self.heap[0] self.heap[0] = self.heap[-1] self.heap.pop() self._heapify_down(0) return min_val def get_min(self) -> int: if self.is_empty(): raise Exception(\\"Heap is empty\\") return self.heap[0] def is_empty(self) -> bool: return len(self.heap) == 0 def _heapify_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._heapify_up(parent_index) def _heapify_down(self, index): left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 smallest = index if left_child_index < len(self.heap) and self.heap[left_child_index] < self.heap[smallest]: smallest = left_child_index if right_child_index < len(self.heap) and self.heap[right_child_index] < self.heap[smallest]: smallest = right_child_index if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._heapify_down(smallest)"},{"question":"# Problem Statement Write a function that takes a list of integers and a target integer. Your goal is to find a pair of integers from the list that adds up to the target integer and return their indices. If there are multiple pairs that satisfy the condition, return the indices of the first such pair found. If no pair exists, return `[-1, -1]`. # Function Signature ```python def find_pair(nums: list, target: int) -> list: pass ``` # Input - `nums` (1 ≤ len(nums) ≤ 10^5): A list of integers. - `target` (-10^9 ≤ target ≤ 10^9): An integer representing the target sum. # Output - A list of two integers representing the indices of the pair of integers in the input list that add up to the target integer. If no such pair exists, return `[-1, -1]`. # Example - Input: `nums = [2, 7, 11, 15], target = 9` - Output: `[0, 1]` - Explanation: The numbers at index 0 and 1 (2 + 7) add up to the target 9. - Input: `nums = [1, 2, 3, 4], target = 8` - Output: `[-1, -1]` - Explanation: There are no pairs that add up to the target 8. # Constraints - The solution should run efficiently for large lists, considering the constraints. # Notes - The indices in the output should be in ascending order as found in the list. - You can assume that each input will have at most one unique pair that sums to the target.","solution":"def find_pair(nums: list, target: int) -> list: Finds indices of the first pair of numbers in the list that add up to the target. Args: nums (list): A list of integers. target (int): The target sum integer. Returns: list: A list of two integers representing the indices of the pair that sums to the target. If no such pair exists, returns [-1, -1]. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return [-1, -1]"},{"question":"# Binary Search Tree - Implementation and Range Query Background: A Binary Search Tree (BST) is a node-based data structure where each node has at most two children, referred to as the left child and the right child. The nodes are organized such that for any given node, its left descendants are less than the node and the right descendants are greater. It supports efficient range queries to find all elements within a specified range. Task: 1. **Implement a BST**: Write code to construct a BST from a given list of integer values. 2. **Implement Range Query**: Write a function to find and return all elements within a specified range [low, high] in the BST. Function Signatures: 1. `insert_into_bst(root: BSTNode, value: int) -> BSTNode` * **Input**: * `root` - The root node of the BST. * `value` - The value to be inserted into the BST. * **Output**: * The root node of the updated BST. 2. `range_query_bst(root: BSTNode, low: int, high: int) -> list[int]` * **Input**: * `root` - The root node of the BST. * `low` - The lower bound of the range query. * `high` - The upper bound of the range query. * **Output**: * A list of all values within the range [low, high] in the BST, sorted in ascending order. Constraints: * All values will be unique. * The number of values `n` is moderate (e.g., n ≤ 10^4). * The range [low, high] will always be valid such that low <= high. Example: ```python # Define the BSTNode class as given above. # Example values and range query values = [10, 5, 1, 7, 15, 12, 18] range_low, range_high = 5, 15 bst_root = None for value in values: bst_root = insert_into_bst(bst_root, value) range_result = range_query_bst(bst_root, range_low, range_high) print(range_result) # Output should be [5, 7, 10, 12, 15] ``` Notes: * You are required to implement the `insert_into_bst` and `range_query_bst` functions. * Ensure consideration of edge cases such as empty BST and ranges that do not include any values. * Optimize for both time and space complexity where possible.","solution":"class BSTNode: def __init__(self, value): self.value = value self.left = None self.right = None def insert_into_bst(root: BSTNode, value: int) -> BSTNode: Inserts a value into the BST and returns the root. if root is None: return BSTNode(value) if value < root.value: root.left = insert_into_bst(root.left, value) else: root.right = insert_into_bst(root.right, value) return root def range_query_bst(root: BSTNode, low: int, high: int) -> list[int]: Returns all elements within the specified range [low, high] in the BST. result = [] def inorder_range_query(node): if node is None: return # Check left subtree if there could be values within the range if node.value > low: inorder_range_query(node.left) # Check the current node if low <= node.value <= high: result.append(node.value) # Check right subtree if there could be values within the range if node.value < high: inorder_range_query(node.right) inorder_range_query(root) return result"},{"question":"# Background A binary heap is a complete binary tree which satisfies the heap property. The heap could be implemented as a list where for any element at index `i`, the children are located at indices `2*i + 1` and `2*i + 2`, and the parent is located at index `(i - 1) // 2`. There are two types of binary heaps - Min-Heap and Max-Heap. In a Min-Heap, for any given node I, the value of I is less than or equal to the values of its children. In a Max-Heap, for any given node I, the value of I is greater than or equal to the values of its children. # Problem Statement Write a class `MinHeap` which supports the following operations: - `__init__(self, arr: List[int]) -> None`: Initialize the heap with the given list of integers and transform it into a valid Min-Heap. - `insert(self, val: int) -> None`: Insert an element into the Min-Heap. - `get_min(self) -> int`: Return the minimum element from the Min-Heap (the root of the heap). - `extract_min(self) -> int`: Remove and return the minimum element from the Min-Heap and restore the heap property. # Example ```python heap = MinHeap([4, 7, 8, 3, 2, 6, 5]) print(heap.get_min()) # Output: 2 heap.insert(1) print(heap.get_min()) # Output: 1 print(heap.extract_min()) # Output: 1 print(heap.extract_min()) # Output: 2 print(heap.get_min()) # Output: 3 ``` # Constraints - The list of integers used to initialize the heap can have up to 10^4 elements. - The integer values can be between -10^6 and 10^6. # Notes - You may use the `heapq` module for heap operations to simplify the implementation. - Ensure the class maintains Min-Heap properties after each operation. # Hints - Heapify the input list in the constructor to build the initial heap. - Use sift-up and sift-down operations for insertions and extractions to maintain the heap property.","solution":"import heapq class MinHeap: def __init__(self, arr): Initialize the MinHeap with the given list of integers and transform it into a valid Min-Heap. self.heap = arr heapq.heapify(self.heap) def insert(self, val): Insert an element into the Min-Heap. heapq.heappush(self.heap, val) def get_min(self): Return the minimum element from the Min-Heap (the root of the heap). return self.heap[0] if self.heap else None def extract_min(self): Remove and return the minimum element from the Min-Heap and restore the heap property. if not self.heap: return None return heapq.heappop(self.heap)"},{"question":"# Binary Tree Maximum Path Sum Given a binary tree, write a function `max_path_sum` that computes the maximum path sum. A path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections and includes at least one node. Function Signature ```python def max_path_sum(root: Optional[TreeNode]) -> int: ``` # Input - `root`: The root node of the binary tree which is of type `TreeNode`. The tree may contain both positive and negative values, and it is guaranteed that there will be at least one node in the tree. # Output - An integer representing the maximum path sum. # Constraints - If the tree is empty (`root` is `None`), return `0`. # Examples ```python assert max_path_sum(TreeNode(1, TreeNode(2), TreeNode(3))) == 6 assert max_path_sum(TreeNode(-10, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))) == 42 assert max_path_sum(TreeNode(2, TreeNode(-1), TreeNode(-2))) == 2 assert max_path_sum(TreeNode(-3)) == -3 assert max_path_sum(None) == 0 ``` # Explanation 1. The function `max_path_sum(TreeNode(1, TreeNode(2), TreeNode(3)))` should return `6` because the maximum path sum is `2 -> 1 -> 3`. 2. The function `max_path_sum(TreeNode(-10, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))` should return `42` because the maximum path sum is `15 -> 20 -> 7`. 3. The function `max_path_sum(TreeNode(2, TreeNode(-1), TreeNode(-2)))` should return `2` because the maximum path is just the root node itself. 4. The function `max_path_sum(TreeNode(-3))` should return `-3` as there is only one node. 5. The function should handle an empty tree explicitly returning `0`. # TreeNode Definition Assume that `TreeNode` is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Performance Requirements - Your solution should handle large binary trees efficiently. # Notes 1. Consider both left and right subtrees when computing the maximum path sum. 2. Recursive approaches could be employed to handle the tree traversal and calculation of maximum sums effectively.","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root: Optional[TreeNode]) -> int: if root is None: return 0 def helper(node: TreeNode) -> int: nonlocal max_sum if not node: return 0 left_gain = max(helper(node.left), 0) right_gain = max(helper(node.right), 0) current_path_sum = node.val + left_gain + right_gain max_sum = max(max_sum, current_path_sum) return node.val + max(left_gain, right_gain) max_sum = float(\'-inf\') helper(root) return max_sum"},{"question":"# Question: Implement a Function to Calculate the F1 Score You are tasked with implementing a function to compute the F1 score of a binary classification model. The F1 score is the harmonic mean of precision and recall, providing a balance between the two metrics, especially useful when the data is imbalanced. # Function Signature ```python def f1_score(true_labels: list, predicted_labels: list) -> float: Arguments: true_labels: A list of true binary labels (0 or 1). predicted_labels: A list of predicted binary labels (0 or 1). Returns: A floating-point number representing the F1 score. ``` # Expected Input and Output * **Input**: * `true_labels`: A list of actual binary labels (length n). * `predicted_labels`: A list of predicted binary labels (length n). * **Output**: * A float representing the F1 score (between 0 and 1). # Constraints * The length of both input lists will be the same. * Both lists will contain binary values, either 0 or 1. # Example ```python >>> true_labels = [1, 0, 1, 1, 0, 1, 0] >>> predicted_labels = [0, 0, 1, 1, 0, 1, 1] >>> f1_score(true_labels, predicted_labels) 0.8 ``` # Performance Your implementation should handle input sizes efficiently up to 10^6. # Notes * Describe the algorithmic steps in your function. * Ensure your implementation handles common edge cases effectively, such as lists with no positives, and adheres to input constraints. Algorithm Steps: 1. Count the true positives (TP), false positives (FP), and false negatives (FN). 2. Compute precision as (precision = frac{TP}{TP + FP}) (account for division by zero). 3. Compute recall as (recall = frac{TP}{TP + FN}) (account for division by zero). 4. Compute the F1 score as (F1 = 2 times frac{precision times recall}{precision + recall}). Good luck!","solution":"def f1_score(true_labels: list, predicted_labels: list) -> float: Compute the F1 score of the binary classification. Arguments: true_labels: A list of true binary labels (0 or 1). predicted_labels: A list of predicted binary labels (0 or 1). Returns: A floating-point number representing the F1 score. TP = sum(1 for tl, pl in zip(true_labels, predicted_labels) if tl == 1 and pl == 1) FP = sum(1 for tl, pl in zip(true_labels, predicted_labels) if tl == 0 and pl == 1) FN = sum(1 for tl, pl in zip(true_labels, predicted_labels) if tl == 1 and pl == 0) if TP + FP == 0 or TP + FN == 0: return 0.0 precision = TP / (TP + FP) recall = TP / (TP + FN) if precision + recall == 0: return 0.0 f1 = 2 * (precision * recall) / (precision + recall) return f1"},{"question":"# Problem Statement You are required to implement a function `merge_and_sort` that takes two sorted lists as input and returns a single sorted list that contains all the elements from both input lists. # Requirements 1. The function should merge two pre-sorted lists into a new sorted list. 2. It should handle lists with integer elements. 3. The function should be efficient and maintain a time complexity of O(n + m), where n and m are the lengths of the input lists. # Function Signature ```python def merge_and_sort(list1: list, list2: list) -> list: pass ``` # Input - `list1` (list of int): The first sorted list of integers. - `list2` (list of int): The second sorted list of integers. # Output - `result` (list of int): A new sorted list containing all elements from both `list1` and `list2`. # Constraints - The input lists can contain up to 10^5 integers each. - The input lists are guaranteed to be sorted in ascending order. - Both input lists may contain duplicate elements. # Examples 1. `merge_and_sort([1, 3, 5], [2, 4, 6])` should return `[1, 2, 3, 4, 5, 6]` 2. `merge_and_sort([1, 2, 3], [1, 2, 3])` should return `[1, 1, 2, 2, 3, 3]` 3. `merge_and_sort([], [1, 3, 5])` should return `[1, 3, 5]` # Implementation Requirements - Implement the function using an iterative approach without using Python\'s built-in sorting functions. - Ensure that the function correctly handles edge cases such as empty lists.","solution":"def merge_and_sort(list1, list2): Merge two sorted lists into one sorted list. :param list1: A sorted list of integers. :param list2: Another sorted list of integers. :return: A new sorted list containing all elements from list1 and list2. i, j = 0, 0 merged_list = [] while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"# Problem Statement: You are working on a data-processing application that involves various transformations of numerical sequences. For one of the features, you need to implement a system that efficiently transforms lists of integers based on a sequence of operations provided by the user. These operations include addition, subtraction, multiplication, and division. Your task is to create a function that takes a list of integers and a list of operations, then applies the operations sequentially to transform the list. # Requirements: 1. **Implement the `process_operations` function** that performs the following operations on a list of integers: - `\\"add X\\"`: Adds X to every element in the list. - `\\"subtract X\\"`: Subtracts X from every element in the list. - `\\"multiply X\\"`: Multiplies every element in the list by X. - `\\"divide X\\"`: Divides every element in the list by X (use floor division for integer results). 2. **Handle edge cases** such as: - Dividing by zero: Return the original list unmodified. - Empty operations list: Return the original list unmodified. - Negative and non-integer values in the list (for operations: `subtract`, `multiply`, and `divide`). - Operations with non-integer values are not allowed. - Multiple operations: Apply them in the given sequence. # Function Signature: ```python def process_operations(nums: list, operations: list) -> list: ``` # Input: - **nums**: A list of integers, with length up to 1000. - **operations**: A list of strings, each representing an operation as described above, with length up to 100. # Output: - Returns a transformed list of integers after applying the operations sequentially. # Constraints: - The elements in the nums list will be between -10^6 and 10^6. # Examples: ```python assert process_operations([1, 2, 3], [\\"add 2\\", \\"multiply 3\\"]) == [9, 12, 15] assert process_operations([10, -5, 7], [\\"subtract 3\\", \\"divide 2\\"]) == [3, -4, 2] assert process_operations([8, 15, 22], [\\"divide 0\\"]) == [8, 15, 22] # Handling division by zero assert process_operations([], [\\"add 5\\"]) == [] # Empty list case assert process_operations([1, 2, 3], []) == [1, 2, 3] # No operations case ``` # Notes: - Ensure you handle all the edge cases and constraints properly. - The solution should be optimized for both runtime and space complexity. - Do not alter the function signature but you can create helper functions if needed to keep the code clean and maintainable.","solution":"def process_operations(nums: list, operations: list) -> list: def apply_operation(nums, operation): op, val_str = operation.split() val = int(val_str) if op == \\"add\\": return [num + val for num in nums] elif op == \\"subtract\\": return [num - val for num in nums] elif op == \\"multiply\\": return [num * val for num in nums] elif op == \\"divide\\": if val == 0: return nums # Do not modify the list if division by zero return [num // val for num in nums] else: raise ValueError(f\\"Invalid operation: {operation}\\") for operation in operations: nums = apply_operation(nums, operation) return nums"},{"question":"# Compute the Longest Increasing Subsequence Objective This task involves writing a function to find the length of the longest strictly increasing subsequence from a given list of integers. Scenario You are designing an algorithm for an automated grading system. One of the requirements is to evaluate a sequence of scores and determine the longest trend of improvement in the scores. Function Signature ```python def longest_increasing_subsequence(nums: Sequence[int] | None = None) -> int: ``` Input and Output - **Input**: A single parameter, `nums`, which is a sequence of integers. If `nums` is None or an empty sequence, the function should raise a `ValueError` with the message \\"Input sequence should not be empty\\". - **Output**: Returns an integer representing the length of the longest strictly increasing subsequence in the input list. Constraints - The sequence can include both positive and negative integers. - The function should aim to have a time complexity of O(n log n). Examples 1. `longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18])` should return `4` because the longest increasing subsequence is `[2, 3, 7, 101]`. 2. `longest_increasing_subsequence([0, 1, 0, 3, 2, 3])` should return `4` because the longest increasing subsequence is `[0, 1, 2, 3]`. 3. `longest_increasing_subsequence([])` should raise a `ValueError` with the message \\"Input sequence should not be empty\\". Instructions 1. Implement the `longest_increasing_subsequence` function. 2. The implementation must handle edge cases such as empty arrays and arrays with all identical elements. 3. The implementation should pass the provided examples and other edge cases effectively. Testing - Ensure to test your implementation with the provided examples. - Evaluate other potential edge cases to ensure robustness.","solution":"from typing import Sequence import bisect def longest_increasing_subsequence(nums: Sequence[int] | None = None) -> int: if nums is None or len(nums) == 0: raise ValueError(\\"Input sequence should not be empty\\") dp = [] for num in nums: pos = bisect.bisect_left(dp, num) if pos == len(dp): dp.append(num) else: dp[pos] = num return len(dp)"},{"question":"# Scenario You are developing a simple text editor and need to implement a feature that finds the most frequently occurring word in a given document. The document is represented as a single string, and words are separated by spaces. Punctuation marks are considered part of the word. If multiple words tie for most frequent, return any one of them. # Task Write a function `find_most_frequent_word(document)` that: 1. Takes a single input string `document` and returns the word that appears most frequently. 2. Treats case variations (like \\"Word\\" and \\"word\\") as identical, ignoring case. 3. Returns any highest frequency word in case of a tie. 4. Uses a space to separate words in the document. # Input and Output Formats Input * `document` (string): A string of words separated by spaces. Output * A single string representing the most frequent word. # Function Signature ```python def find_most_frequent_word(document: str) -> str: ``` # Example ```python # Example 1 # Document contains words with various frequencies. print(find_most_frequent_word(\\"apple banana apple orange banana orange apple\\")) # Output: \\"apple\\" # Example 2 # All words have the same frequency, any of them can be returned. print(find_most_frequent_word(\\"cat dog bird cat dog bird\\")) # Output: \\"cat\\" or \\"dog\\" or \\"bird\\" # Example 3 # Different cases of the same word should be considered identical. print(find_most_frequent_word(\\"Apple apple APPLE\\")) # Output: \\"apple\\" ``` # Constraints * The document will have at least one word. * Words are separated by spaces only. * Input is case-insensitive and should be treated accordingly. # Notes * Ensure that the solution handles large inputs effectively. **Complete the implementation in Python.**","solution":"def find_most_frequent_word(document: str) -> str: from collections import Counter # Convert the document to lower case to make it case-insensitive document = document.lower() # Split the document into words words = document.split() # Use Counter to count the frequency of each word word_counts = Counter(words) # Find the word with the highest frequency most_frequent_word = word_counts.most_common(1)[0][0] return most_frequent_word"},{"question":"# Problem Statement Implement a function that formats a given string such that each word\'s first letter is capitalized, and all other letters are in lowercase. This process is sometimes referred to as \'Title Case\'. Ignore any special characters or digits; only modify alphabetic characters. **Function Signature:** ```python def title_case(input_string: str) -> str: Formats the input string to Title Case. :param input_string: A string that needs to be formatted. :return: A new string where each word starts with an uppercase letter followed by lowercase letters. ``` # Input: - A string `input_string`. # Output: - Return a new string formatted in Title Case. # Constraints: 1. The input string can contain alphabets, digits, and special characters. 2. The function should handle strings containing multiple spaces, tabs, and new lines gracefully. # Example: ```python >>> title_case(\\"hello world\\") \'Hello World\' >>> title_case(\\" multiple SPACES here \\") \' Multiple Spaces Here \' >>> title_case(\\"123 programming is fun!\\") \'123 Programming Is Fun!\' >>> title_case(\\"\\") \'\' ``` # Notes: 1. The function should not change the spacing or positions of non-alphabet characters in the input string. 2. Preserve the input string\'s original spacing. If there are leading, trailing, or multiple spaces/tabs, they should be maintained in the output. 3. Include detailed docstrings and comments to explain critical parts of your code.","solution":"def title_case(input_string: str) -> str: Formats the input string to Title Case. :param input_string: A string that needs to be formatted. :return: A new string where each word starts with an uppercase letter followed by lowercase letters. import re def capitalize_word(word): if word: return word[0].upper() + word[1:].lower() return word # Pattern to identify words words = re.split(r\'(W+)\', input_string) transformed_words = [capitalize_word(word) for word in words] return \'\'.join(transformed_words)"},{"question":"# Question: Generating Paschal Pattern Using Nested Loops Context Generating patterns using nested loops is a fundamental exercise in understanding iteration structures and control flow. One of the classic patterns is the Paschal Triangle, a triangular array of binomial coefficients. Problem Write a function `generate_paschal_pattern(n: int) -> List[List[int]]` that takes an integer `n` representing the number of levels in the Paschal Triangle and outputs a nested list representing the pattern. Input and Output Format - **Input**: - An integer `n` representing the number of levels in the Paschal Triangle. - **Output**: - A nested list where each inner list represents a level of the Paschal Triangle composed of binomial coefficients. Constraints - The number of levels `n` will range from 1 to 10 due to display and complexity constraints. Example ```python from typing import List def generate_paschal_pattern(n: int) -> List[List[int]]: # Your implementation here # Example Usage n = 5 print(generate_paschal_pattern(n)) # Output: # [[1], # [1, 1], # [1, 2, 1], # [1, 3, 3, 1], # [1, 4, 6, 4, 1]] ``` Clarify that the function should: - Initialize the first level of the triangle with a single `1`. - Iteratively compute the next level using the previous level. - Use the binomial coefficient formula to generate each coefficient in a level. Ensure your function handles edge cases, such as `n = 1`, and is performant for the given constraints.","solution":"from typing import List def generate_paschal_pattern(n: int) -> List[List[int]]: Generate the Paschal Triangle with the given number of levels `n`. if n <= 0: return [] paschal_triangle = [] for i in range(n): level = [1] * (i + 1) for j in range(1, i): level[j] = paschal_triangle[i-1][j-1] + paschal_triangle[i-1][j] paschal_triangle.append(level) return paschal_triangle"},{"question":"# Python Expression Evaluator **Scenario:** You are tasked with creating a function that evaluates mathematical expressions provided as strings. The expressions will include integers and the basic arithmetic operators: addition (`+`), subtraction (`-`), multiplication (`*`), and division (`/`). Parentheses may be used to alter the order of operations. The function should respect the standard operator precedence rules and support integer division. **Function Specification:** ```python def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression and returns the integer result. Parameters: expression (str): The mathematical expression to be evaluated. Returns: int: The result of the evaluated expression. Raises: TypeError: If the input is not a string. ValueError: If the expression is invalid. Example: >>> evaluate_expression(\\"2+3*4\\") 14 >>> evaluate_expression(\\"(2+3)*4\\") 20 >>> evaluate_expression(\\"10/2\\") 5 >>> evaluate_expression(\\"10/(2+3)\\") 2 >>> evaluate_expression(\\"10/(2-2)\\") Traceback (most recent call last): ... ZeroDivisionError: division by zero ``` **Requirements:** 1. The function should accept one parameter `expression`, which is expected to be a string representing the mathematical expression. 2. The function should follow the order of operations: parentheses, multiplication and division, addition and subtraction. 3. Integer division should be used for the division operator. 4. The function should raise a `TypeError` if the input is not a string. 5. The function should raise a `ValueError` if the expression is invalid (e.g., unmatched parentheses, invalid characters). 6. The function should raise a `ZeroDivisionError` when division by zero is encountered. **Constraints:** - The input expression will contain only non-negative integers and the operators: `+`, `-`, `*`, `/`, and parentheses `(` and `)`. - The input expression will not contain any floating-point numbers. - Division results should be floored (e.g., `5 / 2` should result in `2`). # Examples: ```python assert evaluate_expression(\\"3+5*2\\") == 13 assert evaluate_expression(\\"(8-2)/3\\") == 2 assert evaluate_expression(\\"(2+3)*6\\") == 30 assert evaluate_expression(\\"7+(3*4)-2\\") == 17 assert evaluate_expression(\\"8/(4-2)\\") == 4 assert evaluate_expression(\\"10/0\\") == ZeroDivisionError assert evaluate_expression(\\"*2+3\\") == ValueError assert evaluate_expression(\\"2+(3\\") == ValueError assert evaluate_expression(12345) == TypeError ```","solution":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression and returns the integer result. Parameters: expression (str): The mathematical expression to be evaluated. Returns: int: The result of the evaluated expression. Raises: TypeError: If the input is not a string. ValueError: If the expression is invalid. ZeroDivisionError: If there is a division by zero. if not isinstance(expression, str): raise TypeError(\\"Input must be a string\\") try: # Replace division symbol with floor division expression = expression.replace(\\"/\\", \\"//\\") # Evaluate the expression result = eval(expression) except ZeroDivisionError: raise ZeroDivisionError(\\"division by zero\\") except Exception as e: raise ValueError(\\"Invalid expression\\") from e return result"},{"question":"# Context You are building a system to manage a library of books which allows for various operations on books. Each book has a title, an author, and a publication year. Users should be able to add new books, find books by a specific author, and retrieve the details of the most recently published book. # Task Implement a class `Library` to manage the collection of books. The library should support the following operations: 1. **Add a book**: Given a title, author, and publication year, add a book to the library. 2. **Find books by author**: Given an author\'s name, return a list of books written by that author. 3. **Get the most recent book**: Retrieve the details of the book with the most recent publication year. Books are represented as dictionaries with keys \'title\', \'author\', and \'year\'. Implement methods with the following signatures: ```python class Library: def add_book(self, title: str, author: str, year: int) -> None: pass def find_books_by_author(self, author: str) -> list: pass def get_most_recent_book(self) -> dict: pass ``` # Requirements 1. The methods should ensure efficient storage and retrieval of books: - `add_book` should run in O(1) time. - `find_books_by_author` should run in O(n) time, where n is the number of books. - `get_most_recent_book` should run in O(1) time. 2. Handle cases where the library is empty. # Constraints * The title and author strings have a maximum length of 100 characters. * The publication year is an integer within the range [0, 9999]. # Example ```python library = Library() library.add_book(\\"The Catcher in the Rye\\", \\"J.D. Salinger\\", 1951) library.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960) library.add_book(\\"1984\\", \\"George Orwell\\", 1949) print(library.find_books_by_author(\\"George Orwell\\")) # Output: [{\'title\': \'1984\', \'author\': \'George Orwell\', \'year\': 1949}] print(library.get_most_recent_book()) # Output: {\'title\': \'To Kill a Mockingbird\', \'author\': \'Harper Lee\', \'year\': 1960} ``` Submission Submit a class `Library` implemented in Python, with the specified methods to manage a collection of books as described. Ensure the methods handle the requirements efficiently.","solution":"class Library: def __init__(self): self.books = [] self.most_recent_book = None def add_book(self, title: str, author: str, year: int) -> None: new_book = {\'title\': title, \'author\': author, \'year\': year} self.books.append(new_book) if self.most_recent_book is None or year > self.most_recent_book[\'year\']: self.most_recent_book = new_book def find_books_by_author(self, author: str) -> list: return [book for book in self.books if book[\'author\'] == author] def get_most_recent_book(self) -> dict: return self.most_recent_book"},{"question":"**Problem Statement:** You are working on a system that computes the shortest route in a city grid, where each intersection has a specific cost associated with moving through it. Your goal is to find the minimal cost path from the top-left corner to the bottom-right corner of the grid using dynamic programming. # Specifications: 1. Implement the function `minimal_cost_path`. - **Input**: A 2D list `grid` of integers, where `grid[i][j]` represents the cost of crossing the intersection at row `i` and column `j`. The dimensions of `grid` are `m x n` (1 ≤ m, n ≤ 100). The cost at any intersection is a non-negative integer (0 ≤ grid[i][j] ≤ 100). - **Output**: An integer representing the minimal cost required to travel from the top-left corner (0,0) to the bottom-right corner (m-1, n-1). **Example:** ```python >>> grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] >>> minimal_cost_path(grid) 7 ``` - Explanation: - The path with the minimal cost is 1 -> 3 -> 1 -> 1 -> 1. - The total cost is 1 + 3 + 1 + 1 + 1 = 7. # Notes: - You can only move right or down from each cell. - You should handle edge cases such as when the grid has only one row or one column. - Aim to construct a solution with a time complexity of O(m * n). Implement your solution to ensure it appropriately handles all edge cases and efficiently computes the minimal cost path.","solution":"def minimal_cost_path(grid): Computes the minimal cost path from the top-left to the bottom-right corner of the grid. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize a dp array with the same dimensions as grid dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"**Context**: You are developing a functionality that requires generating all possible unique subsets of a given set. The solution should not use built-in libraries which directly compute subsets but should manually compute and return them. **Coding Task**: Write a function named `generate_subsets` that takes one parameter: * `elements` (a list of unique integers). Your function should return a list of lists, where each inner list is a subset of the input `elements`. The subsets should be returned in a lexicographically sorted order based on their content. # Input * The function will be called as: `generate_subsets(elements: List[int]) -> List[List[int]]` * `elements` (a list of unique integers): The list of unique integers from which to generate subsets (0 ≤ len(elements) ≤ 16, -10^6 ≤ elements[i] ≤ 10^6) # Output * Return a list of lists, each representing a subset of the input list `elements`. The subsets should be sorted in lexicographical order. # Constraints * Do not use libraries that directly provide subsets functionality. * The algorithm should handle the complexity of subset generation efficiently considering the size constraints. # Example ```python def generate_subsets(elements: List[int]) -> List[List[int]]: # Your implementation here # Example usage print(generate_subsets([1, 2, 3])) # Output: [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]] print(generate_subsets([0])) # Output: [[], [0]] ``` # Explanation * In the first example, the input list is [1, 2, 3]. The function returns all possible unique subsets sorted lexicographically. * In the second example, the input list is [0]. The function returns two subsets: the empty subset and the subset containing the single element, sorted accordingly.","solution":"def generate_subsets(elements): Generate all unique subsets of the given list of unique integers. Each subset should be sorted lexicographically. def backtrack(start, path): result.append(path) for i in range(start, len(elements)): backtrack(i + 1, path + [elements[i]]) elements.sort() result = [] backtrack(0, []) return result"},{"question":"# Problem Statement You have an array of integers which represent points scored by each participant in a game. The array may contain zero or negative values which represent participants who did not score or had penalty deductions. Your task is to determine the top `k` participants with the highest scores. If multiple participants have the same score, they should be ranked in the order they appear in the array. # Function Specifications You need to implement the following function: ```python def top_k_scores(scores: List[int], k: int) -> List[int]: Return the indices of the top \'k\' participants with the highest scores. Parameters: scores (List[int]): A list of integers representing the scores of participants. k (int): The number of top scores to retrieve. Returns: List[int]: A list of indices representing the positions of top \'k\' participants. pass ``` # Input The function `top_k_scores` takes two parameters: * **scores (**`List[int]`**)**: A list of integers (1 <= len(scores) <= 1000) representing the scores of participants. * **k (**`int`**)**: The number of top scores to retrieve (1 <= k <= len(scores)). # Output The function should return a list of integers: * The list of indices of the top `k` participants with the highest scores, in descending order. If scores are tied, maintain their original order from the input list. # Example Example 1: ```python print(top_k_scores([50, 30, 60, 70, 60], 3)) # Output: [3, 2, 4] # Participant at index 3 has the highest score (70), # followed by participants at indices 2 and 4 both scoring 60. ``` Example 2: ```python print(top_k_scores([10, 10, 10, 10], 2)) # Output: [0, 1] # All participants have the same score, but indices 0 and 1 come first. ``` # Constraints * The function should efficiently handle the input size within the given constraints. * In case of ties (same scores), the participant who appears first in the input list should be given priority. # Commentary The task involves sorting the participants based on their scores and keeping track of their original indices to maintain the correct order for tied scores. The output must be a list of indices, not the scores themselves.","solution":"from typing import List def top_k_scores(scores: List[int], k: int) -> List[int]: Return the indices of the top \'k\' participants with the highest scores. Parameters: scores (List[int]): A list of integers representing the scores of participants. k (int): The number of top scores to retrieve. Returns: List[int]: A list of indices representing the positions of top \'k\' participants. indexed_scores = list(enumerate(scores)) indexed_scores.sort(key=lambda x: (-x[1], x[0])) top_indices = [indexed_scores[i][0] for i in range(k)] return top_indices"},{"question":"**String Permutation Validator** # Problem Statement You are provided with two strings, `s1` and `s2`. Your task is to determine if `s1` is a permutation of `s2`. A string is a permutation of another if it contains the same characters, only the order of characters can be different. # Function Signature ```python def is_permutation(s1: str, s2: str) -> bool: pass ``` # Input * Two strings, `s1` and `s2` (0 ≤ len(s1), len(s2) ≤ 10^4). # Output * Return `True` if `s1` is a permutation of `s2`, otherwise `False`. # Constraints * The strings may contain any ASCII characters. # Performance Requirements * Your solution should aim for a linear time complexity of O(n), where n is the length of the longer string. # Examples ```python assert is_permutation(\\"abc\\", \\"bca\\") == True assert is_permutation(\\"abc\\", \\"abcd\\") == False assert is_permutation(\\"123\\", \\"321\\") == True assert is_permutation(\\"aabb\\", \\"bbaa\\") == True assert is_permutation(\\"\\", \\"\\") == True ``` Good luck!","solution":"def is_permutation(s1: str, s2: str) -> bool: Determine if s1 is a permutation of s2. Params: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if s1 is a permutation of s2, False otherwise. if len(s1) != len(s2): return False from collections import Counter return Counter(s1) == Counter(s2)"},{"question":"# Matrix Rotation Coding Assessment Given a 2D matrix, rotate it 90 degrees clockwise in place. Your task is to implement the following function: 1. **`rotate_matrix(matrix: list[list[int]]) -> None`**: This function should rotate the input `matrix` 90 degrees clockwise. The rotation must be done in place, meaning you are not allowed to use any extra space for another matrix. # Requirements - **Input Format**: - `matrix`: A list of lists where each sub-list represents a row in the matrix. The matrix will always be square (i.e., the number of rows and columns are equal). - **Output Format**: - The function returns `None`, but the input `matrix` should be modified in place to reflect the 90-degree clockwise rotation. - **Constraints**: - The matrix will have a size of `n x n` where `1 ≤ n ≤ 1000`. - **Performance**: - The solution should run efficiently within the given constraints. # Example ```python # Given the matrix matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) # Expected output (matrix should be modified in place) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` Implement the specified function ensuring correctness and optimal performance.","solution":"def rotate_matrix(matrix: list[list[int]]) -> None: Rotates the input matrix 90 degrees clockwise in place. n = len(matrix) # As it\'s a square matrix # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Scenario You are developing a text processing utility for a document editor, and one of the tasks is to identify and count the number of unique words in a given document. A word is defined as a sequence of alphabetical characters, and words are case-insensitive. # Task Implement a function `count_unique_words` that calculates the number of unique words in a given string. The function should ignore case differences and treat words with different cases as the same word. # Function Signature ```python def count_unique_words(document: str) -> int: Counts the number of unique words in a document. :param document: A string representing the document. :return: An integer representing the count of unique words. pass ``` # Input - A string `document` containing the document text. The length of the string will be at most (10^6) characters. # Output - An integer representing the number of unique words in the document. # Constraints - A word is defined as a sequence of alphabetical characters (a to z, A to Z). - The function is case-insensitive. - Non-alphabetical characters are considered as delimiters and should not be part of any word. - The document length will be at most (10^6) characters. # Examples Example 1: ```python document = \\"Hello world! Hello Python.\\" print(count_unique_words(document)) # Output: 3 ``` Explanation: There are three unique words: \\"hello\\", \\"world\\", \\"python\\". Example 2: ```python document = \\"A quick brown fox jumps over a lazy dog.\\" print(count_unique_words(document)) # Output: 8 ``` Explanation: All words are unique except for \\"a\\", which appears twice, so there are 8 unique words. # Additional Requirements - Your solution should efficiently handle the document length up to (10^6) characters. - Utilize appropriate data structures to ensure minimal time complexity for processing the document.","solution":"def count_unique_words(document: str) -> int: Counts the number of unique words in a document. :param document: A string representing the document. :return: An integer representing the count of unique words. import re # Use regex to find all words and set them all to lower case words = re.findall(r\'b[a-zA-Z]+b\', document.lower()) # Use a set to find unique words unique_words = set(words) return len(unique_words)"},{"question":"Fibonacci Sequence Optimized Calculation Question Scenario: You have been assigned to optimize a feature in a financial application that frequently involves calculating Fibonacci numbers for given indexes. The calculations are expected to be highly efficient due to the real-time nature of the financial data processing. Question: Implement a function `fibonacci(n: int) -> int` that calculates the nth Fibonacci number using an optimized approach. Provide solutions using both dynamic programming and matrix exponentiation techniques for optimal performance. # Function Specification: Input: 1. `n` (`int`): The index in the Fibonacci sequence. Output: Should return the nth Fibonacci number (`int`). # Constraints: - The input value `n` will be between 0 and (10^5). - The Fibonacci sequence is defined as: - (F(0) = 0) - (F(1) = 1) - (F(n) = F(n-1) + F(n-2)) for (n > 1) # Example: ```python def fibonacci(n: int) -> int: # Dynamic Programming approach if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b # Example Usage index = 10 result = fibonacci(index) print(f\\"The {index}th Fibonacci number is {result}\\") # Output: The 10th Fibonacci number is 55 def fibonacci_matrix(n: int) -> int: # Matrix Exponentiation approach if n == 0: return 0 def multiply_matrices(m1, m2): return [ [m1[0][0] * m2[0][0] + m1[0][1] * m2[1][0], m1[0][0] * m2[0][1] + m1[0][1] * m2[1][1]], [m1[1][0] * m2[0][0] + m1[1][1] * m2[1][0], m1[1][0] * m2[0][1] + m1[1][1] * m2[1][1]], ] def matrix_power(matrix, power): result = [[1, 0], [0, 1]] # Identity matrix base = matrix while power > 0: if power % 2 == 1: result = multiply_matrices(result, base) base = multiply_matrices(base, base) power //= 2 return result base_matrix = [[1, 1], [1, 0]] result_matrix = matrix_power(base_matrix, n-1) return result_matrix[0][0] # Example Usage index = 10 result = fibonacci_matrix(index) print(f\\"The {index}th Fibonacci number is {result}\\") # Output: The 10th Fibonacci number is 55 ``` **Note:** Ensure your implementation is efficient enough to handle the maximum constraint of `n = 10^5` and consider edge cases such as when `n` is 0. Provide both implementations (dynamic programming and matrix exponentiation) within your solution.","solution":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number using dynamic programming. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b def fibonacci_matrix(n: int) -> int: Returns the nth Fibonacci number using matrix exponentiation. if n == 0: return 0 def multiply_matrices(m1, m2): return [ [m1[0][0] * m2[0][0] + m1[0][1] * m2[1][0], m1[0][0] * m2[0][1] + m1[0][1] * m2[1][1]], [m1[1][0] * m2[0][0] + m1[1][1] * m2[1][0], m1[1][0] * m2[0][1] + m1[1][1] * m2[1][1]], ] def matrix_power(matrix, power): result = [[1, 0], [0, 1]] # Identity matrix base = matrix while power > 0: if power % 2 == 1: result = multiply_matrices(result, base) base = multiply_matrices(base, base) power //= 2 return result base_matrix = [[1, 1], [1, 0]] result_matrix = matrix_power(base_matrix, n-1) return result_matrix[0][0]"},{"question":"Task Write a new question for Coding Assessment. # Objective Design a function that determines the shortest path for a robot in a warehouse to the target location while avoiding obstacles. Your solution should demonstrate your understanding of pathfinding algorithms and data structures. # Function Signature ```python def find_shortest_path( warehouse: List[List[int]], start: Tuple[int, int], target: Tuple[int, int] ) -> List[Tuple[int, int]]: ``` # Input 1. `warehouse` (List[List[int]]): A 2D grid representing the warehouse layout. 0s represent free space, and 1s represent obstacles. 2. `start` (Tuple[int, int]): A tuple representing the starting coordinates of the robot. 3. `target` (Tuple[int, int]): A tuple representing the target coordinates where the robot should go. # Output * List[Tuple[int, int]]: A list of coordinates representing the shortest path from the start to the target. If no path is found, return an empty list. # Constraints * The dimensions of the warehouse grid are between 1x1 and 100x100. * The start and target positions will always be within the warehouse grid and on free spaces (0s). * There is no guarantee that a valid path exists between the start and the target. # Example ```python >>> warehouse = [ ... [0, 0, 0, 0, 1], ... [0, 1, 1, 0, 1], ... [0, 1, 0, 0, 0], ... [0, 0, 0, 1, 0], ... [1, 1, 0, 0, 0] ... ] >>> start = (0, 0) >>> target = (4, 4) >>> find_shortest_path(warehouse, start, target) [(0, 0), (1, 0), (2, 0), (3, 0), (3, 1), (3, 2), (2, 2), (1, 2), (1, 3), (2, 3), (3, 3), (4, 3), (4, 4)] >>> start = (0, 0) >>> target = (0, 4) >>> find_shortest_path(warehouse, start, target) [] ``` # Notes 1. Implement a pathfinding algorithm such as Breadth-First Search (BFS) or A* for efficiency. 2. Ensure to validate input and handle edge cases appropriately. 3. The function should return an empty list if no path is found between the start and the target position. # Hints 1. Consider using a queue to facilitate the exploration of the grid in a breadth-first manner. 2. Keep track of visited nodes to avoid processing the same node multiple times. 3. Take into account the movement constraints (up, down, left, right) and ensure that the robot does not step out of the grid boundaries or into obstacles.","solution":"from collections import deque from typing import List, Tuple def find_shortest_path( warehouse: List[List[int]], start: Tuple[int, int], target: Tuple[int, int] ) -> List[Tuple[int, int]]: Returns a list representing the shortest path from start to target in the warehouse, avoiding obstacles. If no path exists, returns an empty list. if not warehouse or not warehouse[0]: return [] rows, cols = len(warehouse), len(warehouse[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols and warehouse[x][y] == 0 queue = deque([(start, [start])]) visited = set() visited.add(start) while queue: (x, y), path = queue.popleft() if (x, y) == target: return path for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append(((nx, ny), path + [(nx, ny)])) return []"},{"question":"# Question: Implement Hangman Game Context Hangman is a classic word-guessing game where players try to guess a word by suggesting letters within a certain number of guesses. Your task is to implement a simplified version of the Hangman game. Objective Write a class `Hangman` with methods to initialize the game with a secret word, to guess letters, and to check the game\'s status. Methods to Implement * `__init__(self, secret_word: str)`: Initializes the Hangman game with a secret word. * `guess(self, letter: str) -> str`: Takes a single letter as input and returns the current guessed word state. * `get_status(self) -> str`: Returns the current status of the game. The status can be \\"won\\", \\"lost\\", or \\"ongoing\\". Input and Output * **Input**: * For `__init__`: A string representing the secret word. * For `guess`: A single letter to guess. * For `get_status`: No input. * **Outputs**: * For `__init__`: No output. * For `guess`: A string representing the current guessed state of the word with guessed letters revealed and unguessed letters as underscores (\\"_\\"). * For `get_status`: A string representing the current game status (\\"won\\", \\"lost\\", \\"ongoing\\"). Rules * Players have a maximum of 6 incorrect guesses. * The game status is \\"won\\" if all letters in the word are guessed correctly. * The game status is \\"lost\\" if the player exceeds 6 incorrect guesses. * The game status is \\"ongoing\\" if neither of the above conditions is met. Constraints * The secret word contains only lowercase English letters. * The guessed letter is a single lowercase English letter. * All inputs are valid and within expected bounds. Examples ```python game = Hangman(\\"apple\\") assert game.guess(\'a\') == \'a____\' assert game.guess(\'e\') == \'a___e\' assert game.guess(\'x\') == \'a___e\' assert game.get_status() == \'ongoing\' # After 6 incorrect guesses for letter in [\'b\', \'c\', \'d\', \'f\', \'g\']: game.guess(letter) assert game.guess(\'h\') == \'a___e\' assert game.get_status() == \'lost\' # Winning scenario game = Hangman(\\"banana\\") for letter in [\'b\', \'a\', \'n\']: game.guess(letter) assert game.get_status() == \'won\' ```","solution":"class Hangman: def __init__(self, secret_word: str): self.secret_word = secret_word self.guessed_letters = set() self.remaining_attempts = 6 def guess(self, letter: str) -> str: if letter in self.guessed_letters or self.get_status() != \\"ongoing\\": return self._get_current_guessed_state() self.guessed_letters.add(letter) if letter not in self.secret_word: self.remaining_attempts -= 1 return self._get_current_guessed_state() def _get_current_guessed_state(self) -> str: return \'\'.join([letter if letter in self.guessed_letters else \'_\' for letter in self.secret_word]) def get_status(self) -> str: if all(letter in self.guessed_letters for letter in self.secret_word): return \\"won\\" if self.remaining_attempts <= 0: return \\"lost\\" return \\"ongoing\\""},{"question":"# Average Temperature Calculation Function Context In environmental science and meteorology, monitoring and calculating average temperatures over a period is essential for understanding climate patterns and trends. A function that can take multiple temperature readings and compute their average can be particularly useful in various analyses and predictions. Problem Statement Create a function `compute_average_temperature` which will compute and return the average temperature from a given list of daily temperature readings. The function should efficiently handle the inputs and raise appropriate exceptions for invalid data. Function Signature ```python def compute_average_temperature( temperatures: list[float] ) -> float: ``` Input - `temperatures`: (list of float) A list containing temperature readings in degrees Celsius. Output - Returns a float representing the average temperature calculated from the input list. Constraints - The input list must have at least one temperature reading. - All temperature readings should be realistic values between -273.15°C (absolute zero) and 1000°C. Error Handling Raise a `ValueError` in case of: - The input list being empty. - Any temperature reading being out of the realistic range specified. Examples ```python >>> compute_average_temperature([22.5, 25.0, 19.0, 23.5, 21.0]) 22.2 >>> compute_average_temperature([15.5, 18.2, 17.0]) 16.9 >>> compute_average_temperature([30.0, 32.0, 28.0, 35.5]) 31.375 >>> compute_average_temperature([]) ValueError: The temperature list cannot be empty >>> compute_average_temperature([25.0, -300.0, 20.0]) ValueError: Temperature values must be between -273.15 and 1000 degrees Celsius ``` Explanation: 1. **General case**: The function computes the average by summing all the values and dividing by the number of readings. 2. **Empty list**: The function should raise a `ValueError` indicating that the input list cannot be empty. 3. **Out-of-range values**: If any temperature value in the list is outside the realistic bounds (less than -273.15 or more than 1000), the function should raise a `ValueError`. This question tests the candidate\'s ability to handle lists, compute averages, and manage errors effectively, aligning well with the complexity and scope of the existing question set.","solution":"def compute_average_temperature(temperatures): Computes and returns the average temperature from a given list of daily temperature readings. Args: temperatures (list of float): A list containing temperature readings in degrees Celsius. Returns: float: The average temperature. Raises: ValueError: If the list is empty or contains temperatures out of the realistic range. if not temperatures: raise ValueError(\\"The temperature list cannot be empty\\") for temp in temperatures: if temp < -273.15 or temp > 1000: raise ValueError(\\"Temperature values must be between -273.15 and 1000 degrees Celsius\\") return sum(temperatures) / len(temperatures)"},{"question":"# Coding Question: Longest Repeating Subsequence Context Given a string, a subsequence is derived by deleting some or no characters from the string while keeping the remaining characters in their original order. Two subsequences are considered repeating if they are the same and appear more than once in the string. The goal is to find and return the length of the longest repeating subsequence in the given string. Objective You are tasked to write a function that computes the length of the longest repeating subsequence in the given string. Function Signature ```python def longest_repeating_subsequence(s: str) -> int: pass ``` Input - `s` (str): A string consisting of lowercase English letters only. The length of the string is (1 ≤ len(s) ≤ 1000). Output - Returns an integer which is the length of the longest repeating subsequence. Constraints - No two subsequence positions should overlap. Example - `longest_repeating_subsequence(\\"aab\\")` should return `1` because \\"a\\" is the longest repeating subsequence. - `longest_repeating_subsequence(\\"aabb\\")` should return `2` because \\"ab\\" is the longest repeating subsequence. Additional Notes - Thoroughly test with strings of various lengths. - Ensure the function handles edge cases effectively, considering minimal and maximal length constraints.","solution":"def longest_repeating_subsequence(s: str) -> int: This function returns the length of the longest repeating subsequence in the given string. n = len(s) # Create and initialize DP table dp = [[0 for j in range(n+1)] for i in range(n+1)] # Fill the dp table for i in range(1, n+1): for j in range(1, n+1): # If characters match and the indices are different if s[i-1] == s[j-1] and i != j: dp[i][j] = 1 + dp[i-1][j-1] else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return dp[n][n]"},{"question":"# Objective You are to implement a script that rearranges a string such that no two adjacent characters are the same. This task assesses your understanding of string manipulation, character frequency analysis, and efficient sorting and heap implementation. # Problem Statement Write a Python function `rearrange_string(s: str) -> str` that takes a string ( s ) and rearranges its characters such that no two adjacent characters are the same. If such an arrangement is not possible, return an empty string. # Input and Output: * **Input**: A string ( s ) consisting of lowercase alphabets. * **Output**: A rearranged string such that no two adjacent characters are the same. If no valid rearrangement exists, return an empty string. # Constraints: 1. ( 1 leq text{len}(s) leq 10^4 ). 2. String ( s ) will contain only lowercase English letters. # Function Signature: ```python def rearrange_string(s: str) -> str: ``` # Example Input and Output * Input: `s = \\"aabb\\"` * Output: `\\"abab\\"` or `\\"baba\\"` * Input: `s = \\"aaab\\"` * Output: `\\"\\"` * Input: `s = \\"aabc\\"` * Output: `\\"abac\\"` or `\\"baca\\"` or `\\"acba\\"` # Constraints and Considerations: 1. **Edge Cases**: * Inputs where all characters are unique. * Inputs where a single character appears more than half the length of the string. 2. **Performance**: * Efficiently handle time complexity with the potential need for sorting and reorganizing characters using a heap or priority queue. * Minimize redundant operations and ensure scalability for longer strings. # Approach: 1. Verify and handle the initial edge cases and constraints. 2. Use a frequency counter to count occurrences of each character. 3. Use a max-heap (priority queue) to rearrange characters based on frequencies. 4. Alternately place characters with the highest frequency while ensuring no two same characters are adjacent. 5. If a valid arrangement cannot be achieved, return an empty string. 6. Validate and construct the output string from the rearranged characters in a feasible order.","solution":"import heapq from collections import Counter def rearrange_string(s: str) -> str: Rearranges a string such that no two adjacent characters are the same. If such arrangement is not possible, return an empty string. if not s: return \\"\\" # Count the frequency of each character in the input string freq_map = Counter(s) # Convert the frequency map to a max heap (use negative frequencies for max heap) max_heap = [(-freq, ch) for ch, freq in freq_map.items()] heapq.heapify(max_heap) prev_freq, prev_char = 0, \'\' result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) # If there was a previous character to add back to max heap if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_freq = freq + 1 # Decrement the frequency prev_char = char # If the result length is not equal to the input string length, return empty string if len(result) != len(s): return \\"\\" return \\"\\".join(result)"},{"question":"# Task: Implement a function named `temperature_conversion` to convert temperature units. The function should support the following units: - Celsius (C) - Fahrenheit (F) - Kelvin (K) # Requirements: - The function should take three parameters: - `value` (float): the numeric value to convert. - `from_type` (str): the unit of the input value. - `to_type` (str): the unit of the desired output value. - The function should return the converted value as a float. # Constraint: - The function should handle different cases and pluralizations of unit names. - If an invalid unit is provided, the function should raise a `ValueError` with a descriptive error message listing acceptable units. # Examples: ```python >>> temperature_conversion(0, \'C\', \'F\') 32.0 >>> temperature_conversion(273.15, \'K\', \'C\') 0.0 >>> temperature_conversion(32, \'F\', \'K\') 273.15 >>> temperature_conversion(100, \'C\', \'invalid_unit\') Traceback (most recent call last): ... ValueError: Invalid \'to_type\' value: \'invalid_unit\'. Conversion units are: C, F, K. ```","solution":"def temperature_conversion(value, from_type, to_type): Converts temperature from one unit to another. Parameters: value (float): the numeric value to convert. from_type (str): the unit of the input value. to_type (str): the unit of the desired output value. Returns: float: converted value. Raises: ValueError: if from_type or to_type is invalid. from_type = from_type.upper() to_type = to_type.upper() if from_type not in [\'C\', \'F\', \'K\']: raise ValueError(f\\"Invalid \'from_type\' value: \'{from_type}\'. Conversion units are: C, F, K.\\") if to_type not in [\'C\', \'F\', \'K\']: raise ValueError(f\\"Invalid \'to_type\' value: \'{to_type}\'. Conversion units are: C, F, K.\\") if from_type == to_type: return float(value) # Convert from source to Celsius if from_type == \'F\': celsius = (value - 32) * 5.0/9.0 elif from_type == \'K\': celsius = value - 273.15 else: celsius = value # Convert from Celsius to destination if to_type == \'F\': return celsius * 9.0/5.0 + 32 elif to_type == \'K\': return celsius + 273.15 else: return celsius"},{"question":"Swap Case in a Sentence You are to write a function that swaps the case of each letter in a given sentence. If the character is in uppercase, you should convert it to lowercase, and vice versa. Non-alphabetical characters should remain unchanged. # Function Signature ```python def swap_case(sentence: str) -> str: pass ``` # Input - `sentence` (str): A string containing any printable characters, including spaces. # Output - Returns a new string where the case of each letter has been swapped. # Constraints - The input string length will be between 1 and 1000 characters. # Examples ```python assert swap_case(\\"Hello World!\\") == \\"hELLO wORLD!\\" assert swap_case(\\"This is a Test\\") == \\"tHIS IS A tEST\\" assert swap_case(\\"12345\\") == \\"12345\\" assert swap_case(\\"Python3.8\\") == \\"pYTHON3.8\\" ``` # Context This question aims to assess your ability to manipulate strings and understand basic character encoding principles. It ensures you can handle mixed types within strings and apply transformations accurately.","solution":"def swap_case(sentence: str) -> str: Returns a new string where the case of each letter in the given sentence is swapped. Uppercase letters become lowercase and vice versa. Non-alphabetical characters remain unchanged. return sentence.swapcase()"},{"question":"# Problem Statement You are tasked with implementing a function `flatten_nested_list` that takes a nested list (i.e., a list that contains other lists, which in turn might contain lists themselves) and returns a new flattened list containing all the elements from the nested structure in the order they appear. # Requirements * Your function should expect a single input and validate that it is indeed a list. * The result should be a single-level list containing all elements from the nested input list, preserving the order. # Function Signature ```python def flatten_nested_list(nested_list: list) -> list: ``` # Input * `nested_list` (list): A list that may contain elements of any type, including other lists. (0 <= len(nested_list) <= 10^3) # Output * (list): A single-level list containing all elements from the nested structure. # Constraints * If the input list is empty, the function should return an empty list. * The input must be a list. The function should assert this as part of its validation process. * Ensure your implementation handles edge cases and optimizes performance where feasible. # Examples ```python >>> flatten_nested_list([1, [2, [3, 4], 5], 6]) [1, 2, 3, 4, 5, 6] >>> flatten_nested_list([[\'a\', \'b\'], [\'c\', [\'d\', \'e\']]]) [\'a\', \'b\', \'c\', \'d\', \'e\'] >>> flatten_nested_list([]) [] ``` # Notes * Ensure the function raises an error if the input is not a list: * Example: `flatten_nested_list(123)` should raise an assertion error.","solution":"def flatten_nested_list(nested_list): Flattens a nested list into a single-level list. :param nested_list: List of arbitrarily nested lists :return: A flattened list # Validate input assert isinstance(nested_list, list), \\"Input must be a list\\" def flatten(l): result = [] for item in l: if isinstance(item, list): result.extend(flatten(item)) else: result.append(item) return result return flatten(nested_list)"},{"question":"# Question: Implement a Circular Queue Using a Fixed-Size Array Context You are tasked with building an efficient circular queue class for a plural of arithmetic expression evaluations. This data structure should allow for enqueuing new elements at the rear and dequeuing elements from the front while maintaining a fixed maximum size. If the queue is empty or full, appropriate methods should handle these conditions gracefully. Task 1. Implement the `CircularQueue` class with the following methods: - `__init__(self, max_size: int) -> None`: Initializes the queue with a fixed size `max_size`. - `enqueue(self, value: int) -> bool`: Adds `value` to the rear of the queue. Returns `True` if the operation is successful. Returns `False` if the queue is full. - `dequeue(self) -> Union[int, None]`: Removes and returns the value at the front of the queue. Returns `None` if the queue is empty. - `is_empty(self) -> bool`: Returns `True` if the queue is empty, otherwise `False`. - `is_full(self) -> bool`: Returns `True` if the queue is full, otherwise `False`. Implementation Constraints - Your implementation must use a fixed-size array (list) to store elements. - Ensure that all operations (enqueue, dequeue, is_empty, is_full) run in O(1) time complexity. Input and Output - **Input**: - `max_size`: an integer representing the maximum size of the queue. - `value`: an integer representing the value to be enqueued. - **Output**: - `enqueue`: boolean indicating if enqueuing was successful or not. - `dequeue`: the dequeued element or `None` if the queue is empty. - `is_empty`: boolean indicating if the queue is empty. - `is_full`: boolean indicating if the queue is full. Examples ```python # Create a circular queue with a size of 3 cq = CircularQueue(3) assert cq.is_empty() == True assert cq.is_full() == False assert cq.enqueue(1) == True assert cq.enqueue(2) == True assert cq.is_full() == False assert cq.enqueue(3) == True assert cq.is_full() == True assert cq.enqueue(4) == False # Queue is full assert cq.dequeue() == 1 assert cq.dequeue() == 2 assert cq.is_empty() == False assert cq.dequeue() == 3 assert cq.is_empty() == True assert cq.dequeue() == None # Queue is empty ``` Notes 1. Carefully handle the wrapping mechanism for both the front and rear pointers. 2. Ensure the class correctly identifies when the queue is empty or full. 3. Write thorough unit tests to check boundary conditions and typical use cases.","solution":"class CircularQueue: def __init__(self, max_size: int) -> None: self.max_size = max_size self.queue = [None] * max_size self.front = -1 self.rear = -1 def enqueue(self, value: int) -> bool: if self.is_full(): return False if self.front == -1: self.front = 0 self.rear = (self.rear + 1) % self.max_size self.queue[self.rear] = value return True def dequeue(self) -> int: if self.is_empty(): return None result = self.queue[self.front] if self.front == self.rear: self.front = self.rear = -1 else: self.front = (self.front + 1) % self.max_size return result def is_empty(self) -> bool: return self.front == -1 def is_full(self) -> bool: return (self.rear + 1) % self.max_size == self.front"},{"question":"# Sum of Leaf Nodes in Binary Tree **Problem Statement**: Given the root of a binary tree, write a function to return the sum of all leaf nodes. A leaf node is a node with no children. **Function Signature**: ```python def sum_of_leaf_nodes(root: Optional[TreeNode]) -> int: ``` **Input**: - `root`: The root node of the binary tree. `TreeNode` is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` - The tree can have between 0 and 10^4 nodes. - The values of the tree nodes are integers and can range between [-10^4, 10^4]. **Output**: - Return the sum of all leaf nodes in the binary tree. If the tree is empty, return 0. **Constraints**: - The function should run in O(n) time complexity, where `n` is the number of nodes in the binary tree. - The space complexity should be O(h), where `h` is the height of the binary tree, due to the call stack in recursive implementations. **Examples**: ```python # Example 1: # Input: root = [1, 2, 3, 4, 5] # Tree structure: # 1 # / # 2 3 # / # 4 5 assert sum_of_leaf_nodes(TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3))) == 12 # Example 2: # Input: root = [1, null, 2, 3] # Tree structure: # 1 # # 2 # / # 3 assert sum_of_leaf_nodes(TreeNode(1, None, TreeNode(2, TreeNode(3), None))) == 3 # Example 3: # Input: root = [] # Tree structure: None assert sum_of_leaf_nodes(None) == 0 # Example 4: # Input: root = [3, 9, 20, null, null, 15, 7] # Tree structure: # 3 # / # 9 20 # / # 15 7 assert sum_of_leaf_nodes(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))) == 31 ``` **Note**: - Ensure that your function handles all cases such as trees with varying depths. - Optimize for time and space constraints where possible, and utilize proper tree traversal techniques to efficiently compute the sum of leaf nodes. Good luck!","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_of_leaf_nodes(root: Optional[TreeNode]) -> int: if not root: return 0 # Helper function to determine if a node is a leaf def is_leaf(node: TreeNode) -> bool: return node.left is None and node.right is None # Initialize sum of leaf nodes leaf_sum = 0 # Stack for depth-first traversal stack = [root] while stack: node = stack.pop() # If current node is a leaf, add its value to leaf_sum if is_leaf(node): leaf_sum += node.val # Otherwise, add its children to the stack for further exploration if node.right: stack.append(node.right) if node.left: stack.append(node.left) return leaf_sum"},{"question":"# Distance Between Two Points Scenario: You are building a mapping application that involves calculating the distance between two points on a 2D plane. This feature is necessary to compute routes and paths within the application. The user will input the coordinates of two points, and your task is to calculate the straight-line distance between them using the Euclidean distance formula. # Task Write a Python function that calculates the distance between two points on a 2D plane. The function should correctly handle edge cases and validate input parameters. Function Signature ```python def distance_between_points(x1: float, y1: float, x2: float, y2: float) -> float: pass ``` Input * `x1` (float): The x-coordinate of the first point. * `y1` (float): The y-coordinate of the first point. * `x2` (float): The x-coordinate of the second point. * `y2` (float): The y-coordinate of the second point. Output * Returns the straight-line distance between the two points (float). Constraints * Coordinates can be any real numbers. Examples ```python >>> distance_between_points(1, 1, 4, 5) 5.0 >>> distance_between_points(-1, -1, 2, 3) 5.0 >>> distance_between_points(0, 0, 0, 0) 0.0 ``` Validation and Error Handling Your function should raise appropriate exceptions for the following conditions: * If any of the coordinates are not float or int types, raise `Exception: All coordinates must be real numbers`.","solution":"import math def distance_between_points(x1: float, y1: float, x2: float, y2: float) -> float: Calculates the Euclidean distance between two points on a 2D plane. Args: x1 (float): The x-coordinate of the first point. y1 (float): The y-coordinate of the first point. x2 (float): The x-coordinate of the second point. y2 (float): The y-coordinate of the second point. Returns: float: The straight-line distance between the two points. # Input validation if not all(isinstance(coord, (int, float)) for coord in [x1, y1, x2, y2]): raise Exception(\\"All coordinates must be real numbers\\") # Calculate the Euclidean distance return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)"},{"question":"Frequency of Words You are asked to create a function that processes a given text and returns the frequency of each unique word in the text. The function should ignore any punctuation and treat words in a case-insensitive manner. Function Signature ```python def word_frequency(text: str) -> dict: Calculates the frequency of each unique word in the given text. Args: text: A string containing the text to analyze. Returns: A dictionary where the keys are unique words and the values are their frequencies. Example: >>> word_frequency(\\"Hello, world! Hello, everyone.\\") {\'hello\': 2, \'world\': 1, \'everyone\': 1} >>> word_frequency(\\"Python is great. Python is versatile.\\") {\'python\': 2, \'is\': 2, \'great\': 1, \'versatile\': 1} # Your code goes here ``` Input and Output * **Input**: * `text` (str): A string containing the text to analyze. The text can be of any length and will contain only printable characters. * **Output**: - Return a dictionary with the frequency of each unique word. The keys of the dictionary should be the words in lowercase, and the values should be the corresponding frequencies. Constraints * The input text will contain only printable ASCII characters. * Words are considered as sequences of characters separated by whitespace. Performance Requirements * The function should process the text efficiently, with a time complexity of O(n), where n is the number of characters in the input text.","solution":"import re from collections import defaultdict def word_frequency(text: str) -> dict: Calculates the frequency of each unique word in the given text. Args: text: A string containing the text to analyze. Returns: A dictionary where the keys are unique words and the values are their frequencies. text = text.lower() words = re.findall(r\'bw+b\', text) frequency = defaultdict(int) for word in words: frequency[word] += 1 return dict(frequency)"},{"question":"# Scenario You have been asked to write a function to solve a unique word transformation problem often encountered in text processing tasks. This problem will test your ability to manipulate strings and understand character sequencing. # Problem Statement You need to write a function `find_transformed_words(word_list: List[str], transform_word: str) -> List[str]` that returns a list of words from `word_list` that can be transformed into the `transform_word` through sorting their characters. Two words are considered a match if sorting their letters results in exactly the same sequence. # Function Signature ```python def find_transformed_words(word_list: List[str], transform_word: str) -> List[str]: pass ``` # Input Constraints - `1 <= len(word_list) <= 1000` - Each word in the word_list and the transform_word will have a length between 1 and 100. - All words consist of lowercase English letters. # Output - A list of strings from `word_list` that can be transformed into `transform_word` by sorting their characters. The order of words in the returned list should be the same as they appeared in `word_list`. - If no such words exist, return an empty list. # Example ```python assert find_transformed_words([\\"listen\\", \\"silent\\", \\"enlists\\", \\"google\\", \\"inlets\\", \\"banana\\"], \\"enlist\\") == [\\"listen\\", \\"silent\\", \\"inlets\\"] assert find_transformed_words([\\"apple\\", \\"pale\\", \\"plea\\"], \\"leap\\") == [\\"pale\\"] assert find_transformed_words([\\"dog\\", \\"god\\", \\"cat\\"], \\"log\\") == [] ``` # Notes - **Edge Cases**: - If the `word_list` contains empty strings or strings that do not match the length of `transform_word`. - Handling a large list of words efficiently. - The input words should be compared by sorting their characters and checking for equality with the sorted characters of `transform_word`. # Performance Requirements The implementation should efficiently handle the upper constraints of the input sizes, ensuring that sorting and comparing are done within reasonable time limits.","solution":"from typing import List def find_transformed_words(word_list: List[str], transform_word: str) -> List[str]: Returns a list of words from word_list that can be transformed into the transform_word through sorting their characters. sorted_transform_word = \'\'.join(sorted(transform_word)) result = [] for word in word_list: if \'\'.join(sorted(word)) == sorted_transform_word: result.append(word) return result"},{"question":"# Simulate a 1D Random Walk In this problem, you need to simulate a one-dimensional random walk and compute how far you get from the starting position after n steps. In a random walk, at each step, you move either one unit to the right (+1) or one unit to the left (-1) with equal probability. Function Signature ```python def random_walk(n: int) -> int: Simulate a 1D random walk and return the distance from the starting position after n steps. Arguments: n -- an integer representing the number of steps Returns: distance -- an integer representing the distance from the starting position ``` Input - `n`: an integer representing the number of steps in the random walk (1 ≤ n ≤ 10^6). Output - Returns an integer representing the distance from the starting position after `n` steps. Example ```python print(random_walk(10)) # Output could be any integer between 0 to 10, since it\'s random. print(random_walk(1)) # Output could be either -1 or 1. ``` Detailed Requirements 1. Simulate the random walk by starting at position 0 and making `n` steps. 2. Each step should be either +1 or -1 with equal probability. 3. Correctly compute the final position after `n` steps and return the absolute distance from the starting point. 4. Use random module or numpy to generate random steps. **Note:** The result should be based on true randomness, so the result can differ on each run for the same input. Ensure to handle any edge cases, such as small or large values of `n`.","solution":"import random def random_walk(n: int) -> int: Simulate a 1D random walk and return the distance from the starting position after n steps. Arguments: n -- an integer representing the number of steps Returns: distance -- an integer representing the distance from the starting position position = 0 for _ in range(n): step = random.choice([-1, 1]) position += step return abs(position)"},{"question":"# Problem Description Create a function that rearranges the given string into the lexicographically smallest string by performing exactly one swap of two different characters. # Inputs and Outputs * **Input**: - A single string `s` composed of lowercase English letters (`a` to `z`) with length between 1 and 10^5 inclusive. * **Output**: - A new string that is the lexicographically smallest string achievable by swapping exactly two different characters in the input string `s`. # Constraints - The length of the string is between 1 and 10^5 inclusive. - The string contains only lowercase English letters. # Requirements You need to: 1. Identify the optimal pair of characters to swap to achieve the lexicographically smallest string. 2. Perform the swap and return the resulting string. # Example Sample Input and Output Pairs: ```python # Example 1: # Input s = \\"dcba\\" # Output \\"acbd\\" # Example 2: # Input s = \\"abba\\" # Output \\"aabb\\" ``` # Function Signature ```python def lexicographically_smallest_string(s: str) -> str: pass # Example usage: result = lexicographically_smallest_string(\\"dcba\\") print(result) # Output: \\"acbd\\" ``` # Note - The form of the function should be directly callable and return the desired result. - Your implementation should consider edge cases such as when the string is already the lexicographically smallest or there are no possible swaps that make the string smaller.","solution":"def lexicographically_smallest_string(s: str) -> str: Rearranges the given string into the lexicographically smallest string by performing exactly one swap of two different characters. n = len(s) s_list = list(s) # Trying to find the smallest character for any given position for i in range(n): min_char = min(s_list[i+1:], default=s_list[i]) if min_char < s_list[i]: min_pos = s_list[i+1:].index(min_char) + (i + 1) s_list[i], s_list[min_pos] = s_list[min_pos], s_list[i] break return \'\'.join(s_list)"},{"question":"# Coding Assessment Question **Context**: You are working with a dataset containing customer transaction details from a retail store. The objective is to predict the customer\'s total spending for the next month based on various features. **Objective**: Implement a function `train_random_forest` that trains a Random Forest Regressor on the provided dataset. After training, evaluate the model using Root Mean Squared Error (RMSE) and return the RMSE score. **Function Signature**: ```python def train_random_forest(features: np.ndarray, target: np.ndarray, n_estimators: int, max_depth: int, test_size: float) -> float: Parameters: - features: np.ndarray, Training feature dataset. Shape (n_samples, n_features) - target: np.ndarray, Target values corresponding to the feature dataset. Shape (n_samples,) - n_estimators: int, The number of trees in the forest. - max_depth: int, The maximum depth of the trees. - test_size: float, The proportion of the dataset to include in the test split. Returns: - float: The RMSE score of the model on the test set. ``` **Input**: * `features`: A numpy array containing the features of the dataset. Shape (n_samples, n_features). * `target`: A numpy array containing the target values. Shape (n_samples,). * `n_estimators`: An integer specifying the number of trees in the forest. * `max_depth`: An integer specifying the maximum depth of the trees. * `test_size`: A float specifying the proportion of the data to use for testing. **Output**: * Return the RMSE score of the model on the test set. **Constraints**: * Use sklearn\'s `RandomForestRegressor` for training the model. * Use `train_test_split` to split the dataset into training and testing sets. * Optimize for performance efficiency. **Additional Information**: Assume the dataset and labels have already been preprocessed. The primary goal is to implement the `train_random_forest` function and verify its output by computing the RMSE score. **Example**: ```python import numpy as np from sklearn.ensemble import RandomForestRegressor from sklearn.metrics import mean_squared_error from sklearn.model_selection import train_test_split def train_random_forest(features: np.ndarray, target: np.ndarray, n_estimators: int, max_depth: int, test_size: float) -> float: X_train, X_test, y_train, y_test = train_test_split(features, target, test_size=test_size, random_state=42) rf_model = RandomForestRegressor(n_estimators=n_estimators, max_depth=max_depth, random_state=42) rf_model.fit(X_train, y_train) y_pred = rf_model.predict(X_test) rmse = np.sqrt(mean_squared_error(y_test, y_pred)) return rmse # Dataset preparation (example mock dataset) features = np.random.rand(200, 10) target = np.random.rand(200) n_estimators = 100 max_depth = 5 test_size = 0.2 # Running the function rmse = train_random_forest(features, target, n_estimators, max_depth, test_size) print(rmse) # Example output: 0.27 ``` **Note**: Ensure to test the function with a provided customer transaction dataset and verify the RMSE score for effective model performance.","solution":"import numpy as np from sklearn.ensemble import RandomForestRegressor from sklearn.metrics import mean_squared_error from sklearn.model_selection import train_test_split def train_random_forest(features: np.ndarray, target: np.ndarray, n_estimators: int, max_depth: int, test_size: float) -> float: Trains a Random Forest Regressor on the provided dataset and evaluates the model using RMSE. Parameters: - features: np.ndarray, Training feature dataset. Shape (n_samples, n_features) - target: np.ndarray, Target values corresponding to the feature dataset. Shape (n_samples,) - n_estimators: int, The number of trees in the forest. - max_depth: int, The maximum depth of the trees. - test_size: float, The proportion of the dataset to include in the test split. Returns: - float: The RMSE score of the model on the test set. # Split the dataset into training and testing sets X_train, X_test, y_train, y_test = train_test_split(features, target, test_size=test_size, random_state=42) # Initialize and train the Random Forest Regressor rf_model = RandomForestRegressor(n_estimators=n_estimators, max_depth=max_depth, random_state=42) rf_model.fit(X_train, y_train) # Make predictions on the test set y_pred = rf_model.predict(X_test) # Calculate RMSE rmse = np.sqrt(mean_squared_error(y_test, y_pred)) return rmse"},{"question":"# Problem Statement You are developing a text processing library, and one of the features needed is to clean and standardize the text data. This includes removing punctuation, converting to lowercase, and ensuring no extra spaces are present between words. # Requirements Implement a function `clean_text` that takes a string and returns a cleaned and standardized version of the string according to the specified requirements. Function Signature: ```python def clean_text(text: str) -> str: pass ``` Input: * `text` (str): A string containing the text to be cleaned. Output: * `cleaned_text` (str): The cleaned and standardized string. # Constraints: * The given text can contain any printable characters. * The output string should not contain any punctuation, all characters should be in lowercase, and there should be a single space between words with no leading or trailing spaces. # Examples: ```python >>> clean_text(\\"Hello, World!\\") \'hello world\' >>> clean_text(\\" This is a test. \\") \'this is a test\' >>> clean_text(\\"Python\'s ability to handle strings effectively is vital!\\") \'pythons ability to handle strings effectively is vital\' >>> clean_text(\\"Cleantthis.tntExcessive spaces or punctuation!\\") \'clean this excessive spaces or punctuation\' ``` # Hints: 1. Use the `string` module to identify and remove punctuation. 2. Consider using regular expressions for removing punctuation and handling multiple spaces. 3. Ensure the string is converted to lowercase as part of the cleaning process.","solution":"import re import string def clean_text(text: str) -> str: Returns a cleaned and standardized version of the input text. This includes: - Removing punctuation - Converting to lowercase - Removing extra spaces between words # Remove punctuation text = text.translate(str.maketrans(\\"\\", \\"\\", string.punctuation)) # Convert to lowercase text = text.lower() # Remove extra spaces text = re.sub(r\'s+\', \' \', text).strip() return text"},{"question":"# Problem: Longest Distinct Subarray **Objective**: Write a function `longest_distinct_subarray` that takes a sequence of integers as input and returns the length of the longest subarray that contains distinct elements. **Constraints**: - The input sequence will contain at most (10^5) elements. - Each element of the sequence will be an integer within the range ([-10^6, 10^6]). **Function Signature**: ```python def longest_distinct_subarray(nums: Sequence[int]) -> int: pass ``` **Input**: - A sequence of integers `nums`. **Output**: - An integer representing the length of the longest subarray with distinct elements. **Examples**: 1. Given the sequence [1, 2, 3, 1, 2, 3], the function should return 3. 2. Given the sequence [1, 2, 2, 3, 4, 5], the function should return 4. 3. Given the sequence [0, -1, -2, 1, 2], the function should return 5. # Hints: - Consider using a sliding window technique to efficiently find the longest subarray with distinct elements. - Use a set or a dictionary to track the elements in the current window and their indices for quick lookups and updates.","solution":"from typing import Sequence def longest_distinct_subarray(nums: Sequence[int]) -> int: Returns the length of the longest subarray that contains distinct elements. element_index_map = {} max_length = 0 start = 0 for end, value in enumerate(nums): if value in element_index_map: start = max(start, element_index_map[value] + 1) element_index_map[value] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"CSV Column Fetcher Objective Write a function to fetch a specified column from a CSV string. Function Signature ```python def fetch_csv_column(csv_data: str, column_index: int) -> list: ``` Input * `csv_data` (str): A string representing the CSV data where rows are separated by newlines (`n`) and columns are separated by commas (`,`). * `column_index` (int): An integer representing the 0-based index of the column to fetch. Output * Returns a list containing all the values from the specified column. Constraints * Both `csv_data` and `column_index` will be valid and within reasonable limits. * The CSV string may have varying numbers of rows, but all rows will have the same number of columns. * The CSV data is well-formed, which means no missing columns or rows. # Examples ```python >>> fetch_csv_column(\\"a,b,cn1,2,3n4,5,6\\", 0) [\'a\', \'1\', \'4\'] >>> fetch_csv_column(\\"name,age,citynAlice,30,New YorknBob,25,Los AngelesnCharlie,35,Boston\\", 2) [\'city\', \'New York\', \'Los Angeles\', \'Boston\'] >>> fetch_csv_column(\\"apple,orange,bananan3,5,2n4,7,1n5,6,0\\", 1) [\'orange\', \'5\', \'7\', \'6\'] >>> fetch_csv_column(\\"x,y,zn100,200,300n400,500,600n700,800,900\\", 3) IndexError: list index out of range ``` # Requirements 1. Do not use any third-party CSV parsing libraries. 2. Handle typical use cases where the CSV string is of manageable length (up to 1000 rows and 100 columns). 3. Perform input validation and raise appropriate exceptions if the `column_index` is out of range. 4. Assume that the input string will not contain any quoted commas which can serve as CSV delimiters. # Hints - Use string operations to split the input into rows and then into individual columns. - Ensure to handle edge cases, such as an out-of-range `column_index`.","solution":"def fetch_csv_column(csv_data: str, column_index: int) -> list: Fetches the specified column from a CSV string. Parameters: csv_data (str): A string representing the CSV data where rows are separated by newlines (`n`) and columns are separated by commas (`,`). column_index (int): An integer representing the 0-based index of the column to fetch. Returns: list: A list containing all the values from the specified column. Raises: IndexError: If column_index is out of range for the given CSV data. rows = csv_data.strip().split(\'n\') result = [] for row in rows: columns = row.split(\',\') if column_index >= len(columns): raise IndexError(\\"column_index out of range\\") result.append(columns[column_index]) return result"},{"question":"# Question You are given a class `ListNode` representing a node in a singly linked list. In addition, you need to implement a function that takes the head of a linked list and removes all nodes that have duplicate values, leaving only distinct values in the list. The function should return the new head of the linked list. # Function Signature ```python def remove_duplicates(head: ListNode) -> ListNode: pass ``` # Input - `head`: A `ListNode` object representing the head of the singly linked list. # Output - A `ListNode` object representing the head of the linked list with all duplicates removed. # Example ```python class ListNode: def __init__(self, data): self.data = data self.next = None # Example 1: # Original list: 1 -> 2 -> 3 -> 2 -> 4 -> 1 # New list: 3 -> 4 head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(3) head.next.next.next = ListNode(2) head.next.next.next.next = ListNode(4) head.next.next.next.next.next = ListNode(1) new_head = remove_duplicates(head) result = [] current = new_head while current: result.append(current.data) current = current.next print(result) # Output: [3, 4] # Example 2: # Original list: 1 -> 1 -> 1 -> 1 -> 1 # New list: [] head = ListNode(1) head.next = ListNode(1) head.next.next = ListNode(1) head.next.next.next = ListNode(1) head.next.next.next.next = ListNode(1) new_head = remove_duplicates(head) result = [] current = new_head while current: result.append(current.data) current = current.next print(result) # Output: [] ``` # Constraints - The number of nodes in the linked list will not exceed `10^4`. - The values of the nodes will be in the range `[-10^5, 10^5]`. # Requirements - Ensure that the function correctly identifies and removes all duplicate nodes. - Utilize appropriate data structures to manage and detect duplicates efficiently. - Handle edge cases such as an empty list or a list with all unique values.","solution":"class ListNode: def __init__(self, data): self.data = data self.next = None def remove_duplicates(head: ListNode) -> ListNode: # Step 1: Traverse the list and count occurrences of each value current = head value_counts = {} while current: if current.data in value_counts: value_counts[current.data] += 1 else: value_counts[current.data] = 1 current = current.next # Step 2: Create a dummy node to help with easier list modifications dummy = ListNode(0) dummy.next = head # Step 3: Remove duplicates prev = dummy current = head while current: if value_counts[current.data] > 1: prev.next = current.next else: prev = current current = current.next return dummy.next"},{"question":"You are required to implement a function that simulates a simplified traffic light system using finite state machines (FSM). The traffic light has three states: Green, Yellow, and Red. The system receives a command input (\'timer\', \'emergency\', \'reset\') to transition between states: - Green (G): If the command is \'timer\', go to Yellow (Y). If the command is \'emergency\', go to Red (R). - Yellow (Y): If the command is \'timer\', go to Red (R). If the command is \'emergency\' or \'reset\', go to Red (R). - Red (R): If the command is \'timer\', go to Green (G). If the command is \'reset\', stay in Red (R). # Function Signature: ```python def traffic_light(current_state: str, command: str) -> str: Simulate the transition of a traffic light system based on the current state and command. ``` # Inputs: - `current_state`: A string representing the current state of the traffic light, one of \'G\', \'Y\', \'R\'. - `command`: A string representing the command input, one of \'timer\', \'emergency\', \'reset\'. # Output: - Returns a string representing the next state of the traffic light. # Example: ```python >>> traffic_light(\'G\', \'timer\') \'Y\' >>> traffic_light(\'Y\', \'timer\') \'R\' >>> traffic_light(\'R\', \'reset\') \'R\' >>> traffic_light(\'G\', \'emergency\') \'R\' >>> traffic_light(\'Y\', \'emergency\') \'R\' >>> traffic_light(\'R\', \'timer\') \'G\' ``` # Constraints: - The `current_state` is guaranteed to be one of \'G\', \'Y\', or \'R\'. - The `command` is guaranteed to be one of \'timer\', \'emergency\', or \'reset\'. # Performance Requirements: - The function should perform transitions in constant time O(1). # Note: - Ensure to handle all valid states and commands properly according to the described FSM transitions.","solution":"def traffic_light(current_state: str, command: str) -> str: Simulate the transition of a traffic light system based on the current state and command. state_transition = { \'G\': {\'timer\': \'Y\', \'emergency\': \'R\', \'reset\': \'G\'}, \'Y\': {\'timer\': \'R\', \'emergency\': \'R\', \'reset\': \'R\'}, \'R\': {\'timer\': \'G\', \'emergency\': \'R\', \'reset\': \'R\'} } return state_transition[current_state].get(command, current_state)"},{"question":"# Logistic Regression from Scratch **Scenario**: You are tasked with developing a binary classification model to predict whether a customer will make a purchase based on their online behavior data. To achieve this, you decide to implement logistic regression from scratch using gradient descent for optimization. **Task**: Implement a Logistic Regression class in Python which fits a logistic model using gradient descent. The class should perform the following tasks: 1. Initialize model parameters. 2. Perform gradient descent to fit the model parameters. 3. Predict the probability that a given instance belongs to the positive class. 4. Classify a new instance based on the learned model. **Function Signature**: ```python class LogisticRegression: def __init__(self, learning_rate: float = 0.01, num_iterations: int = 1000) -> None: pass @staticmethod def _sigmoid(z: np.ndarray) -> np.ndarray: pass def fit(self, x_train: np.ndarray, y_train: np.ndarray) -> None: pass def predict_proba(self, data: np.ndarray) -> np.ndarray: pass def predict(self, data: np.ndarray) -> np.ndarray: pass ``` # Constraints: 1. **Inputs**: - `x_train`: 2-D numpy array of shape (N, M) with predictor values. - `y_train`: 1-D numpy array of shape (N,) with response values (0 or 1). - `learning_rate`: Float, the learning rate for gradient descent. - `num_iterations`: Integer, the number of iterations for gradient descent. - Predictor values for prediction should be provided as a 2-D numpy array. 2. **Outputs**: - Fitted model parameters as a 1-D numpy array. - Predicted probabilities for a given set of predictor values. - Predicted class labels for a given set of predictor values. **Example**: ```python # Examples of fitting and prediction: import numpy as np x_train = np.array([[0, 0], [1, 0], [0, 1], [1, 1]]) y_train = np.array([0, 1, 1, 0]) log_reg = LogisticRegression(learning_rate=0.1, num_iterations=1000) log_reg.fit(x_train, y_train) # Check fitted parameters print(log_reg.params) # Output might be array close to [.., ..] # Predict probabilities x_predict = np.array([[0, 0], [1, 0], [0, 1], [1, 1]]) predictions_proba = log_reg.predict_proba(x_predict) print(predictions_proba) # Expected output: probabilities close to [.., .., .., ..] # Predict classes predictions = log_reg.predict(x_predict) print(predictions) # Expected output: labels close to [0, 1, 1, 0] # Ensure raising errors for invalid cases try: LogisticRegression(learning_rate=-0.1) except ValueError as e: print(e) # Expected: \\"Learning rate must be positive\\" # Ensure fitting with mismatched dimensions raises ValueError x_train_mismatched = np.array([[0, 0], [1, 0]]) y_train_mismatched = np.array([0, 1, 0]) try: log_reg_mismatched = LogisticRegression() log_reg_mismatched.fit(x_train_mismatched, y_train_mismatched) except ValueError as e: print(e) # Expected: \\"x_train and y_train must have compatible dimensions\\" ``` # Performance Requirements: 1. Ensure the implementation handles numerical stability during gradient descent. 2. Optimize the convergence rate of gradient descent by effectively selecting the learning rate and number of iterations. 3. Ensure the model is capable of handling moderately large datasets efficiently.","solution":"import numpy as np class LogisticRegression: def __init__(self, learning_rate: float = 0.01, num_iterations: int = 1000) -> None: if learning_rate <= 0: raise ValueError(\\"Learning rate must be positive\\") self.learning_rate = learning_rate self.num_iterations = num_iterations @staticmethod def _sigmoid(z: np.ndarray) -> np.ndarray: return 1 / (1 + np.exp(-z)) def fit(self, x_train: np.ndarray, y_train: np.ndarray) -> None: if x_train.shape[0] != y_train.shape[0]: raise ValueError(\\"x_train and y_train must have compatible dimensions\\") self.params = np.zeros(x_train.shape[1] + 1) x_train = np.c_[np.ones(x_train.shape[0]), x_train] # Add intercept term for _ in range(self.num_iterations): linear_model = np.dot(x_train, self.params) predictions = self._sigmoid(linear_model) errors = y_train - predictions gradient = np.dot(x_train.T, errors) / len(y_train) self.params += self.learning_rate * gradient def predict_proba(self, data: np.ndarray) -> np.ndarray: data = np.c_[np.ones(data.shape[0]), data] # Add intercept term linear_model = np.dot(data, self.params) return self._sigmoid(linear_model) def predict(self, data: np.ndarray) -> np.ndarray: probabilities = self.predict_proba(data) return np.where(probabilities >= 0.5, 1, 0)"},{"question":"Write a function that takes a list of integers and returns a list of the same numbers, but shifted to the right by one position. The last item of the list should be moved to the front. # Function Signature ```python def shift_right(lst: list[int]) -> list[int]: ``` # Input * A list of integers `lst`. # Output * A list of integers that has been shifted to the right by one position. # Constraints * The input list will not be empty and will contain only integers. * Ensure your function handles lists of all lengths efficiently. # Examples 1. **Input**: `shift_right([1, 2, 3, 4])` **Output**: `[4, 1, 2, 3]` 2. **Input**: `shift_right([7, 8, 9])` **Output**: `[9, 7, 8]` 3. **Input**: `shift_right([10])` **Output**: `[10]` 4. **Input**: `shift_right([5, -3, 2, 8, 0])` **Output**: `[0, 5, -3, 2, 8]` # Notes * The function should handle lists with only one element, where the input and output would be the same list. * Efficiency is important, so avoid unnecessary computations or copies of the list.","solution":"def shift_right(lst: list[int]) -> list[int]: Shifts the elements of the list `lst` to the right by one position. The last element of the list is moved to the front. Parameters: lst (list of int): The list of integers to be shifted. Returns: list of int: A new list with elements shifted to the right by one position. if not lst: return lst return [lst[-1]] + lst[:-1]"},{"question":"# Problem Statement You are tasked with designing an enhanced version of the temperature conversion function provided. While the current implementation converts between \\"Celsius\\", \\"Fahrenheit\\", and \\"Kelvin\\", it has several limitations such as no support for additional units like \\"Rankine\\" and lacks scalability. # Objectives 1. **Enhance the unit conversion function to support a broader range of temperature units**. 2. **Improve robustness by adding comprehensive validation and error handling**. 3. **Optimize for both performance and scalability while maintaining the accuracy of conversions**. # Requirements 1. Implement the function `enhanced_convert_temperature` which accepts the following parameters: * `temperature` (float): The temperature value to convert. * `unit_from` (str): The unit of the input temperature value. * `unit_to` (str): The unit to which the temperature needs to be converted. * `conversion_functions` (dict): A dictionary containing conversion functions from one unit to another. 2. Validate the input parameters: * Ensure `unit_from` and `unit_to` are keys in the `conversion_functions`. * Ensure `temperature` is a valid float value. * Raise appropriate error messages for invalid inputs. 3. Calculate the conversion using the provided conversion functions: * Utilize both direct and intermediate conversion functions as needed. 4. Return the converted temperature value rounded to two decimal places. # Input Format * `temperature`: A float representing the temperature value. * `unit_from`: A string denoting the input temperature unit. * `unit_to`: A string denoting the output temperature unit. * `conversion_functions`: A dictionary mapping temperature units to their conversion functions. # Output Format A float representing the converted temperature value rounded to two decimal places. # Example ```python conversion_functions = { (\\"Celsius\\", \\"Fahrenheit\\"): lambda c: c * 9 / 5 + 32, (\\"Fahrenheit\\", \\"Celsius\\"): lambda f: (f - 32) * 5 / 9, (\\"Celsius\\", \\"Kelvin\\"): lambda c: c + 273.15, (\\"Kelvin\\", \\"Celsius\\"): lambda k: k - 273.15, (\\"Fahrenheit\\", \\"Kelvin\\"): lambda f: (f - 32) * 5 / 9 + 273.15, (\\"Kelvin\\", \\"Fahrenheit\\"): lambda k: (k - 273.15) * 9 / 5 + 32, (\\"Celsius\\", \\"Rankine\\"): lambda c: (c + 273.15) * 9 / 5, (\\"Rankine\\", \\"Celsius\\"): lambda r: (r - 491.67) * 5 / 9, (\\"Fahrenheit\\", \\"Rankine\\"): lambda f: f + 459.67, (\\"Rankine\\", \\"Fahrenheit\\"): lambda r: r - 459.67, (\\"Kelvin\\", \\"Rankine\\"): lambda k: k * 9 / 5, (\\"Rankine\\", \\"Kelvin\\"): lambda r: r * 5 / 9, } enhanced_convert_temperature(100, \\"Celsius\\", \\"Fahrenheit\\", conversion_functions) # Output: 212.00 enhanced_convert_temperature(32, \\"Fahrenheit\\", \\"Kelvin\\", conversion_functions) # Output: 273.15 enhanced_convert_temperature(500, \\"Rankine\\", \\"Celsius\\", conversion_functions) # Output: -28.89 ``` # Constraint * Your solution should efficiently handle the conversion with a maximum time complexity of O(1).","solution":"def enhanced_convert_temperature(temperature, unit_from, unit_to, conversion_functions): Converts temperature from one unit to another using the provided conversion functions. Parameters: - temperature (float): The temperature value to convert. - unit_from (str): The unit of the input temperature. - unit_to (str): The unit to which the temperature needs to be converted. - conversion_functions (dict): A dictionary containing conversion functions mapped by (unit_from, unit_to). Returns: - float: The converted temperature rounded to two decimal places. # Validate input temperature if not isinstance(temperature, (int, float)): raise ValueError(\\"Temperature must be a numeric value.\\") # Validate units if not (unit_from, unit_to) in conversion_functions: raise ValueError(f\\"Conversion from {unit_from} to {unit_to} is not supported.\\") # Convert the temperature conversion_function = conversion_functions[(unit_from, unit_to)] converted_temperature = conversion_function(temperature) return round(converted_temperature, 2)"},{"question":"# Coding Assessment Question Context: Bob is working on a system that needs to manage and manipulate large amounts of user records efficiently. One of the tasks involves calculating the most frequent value in a list of integers. If multiple values have the same highest frequency, the smallest value should be returned. # Objective: Write a Python function `most_frequent_value(numbers: list) -> int` that takes as input a list of integers and returns the integer with the highest frequency. If there are ties, return the smallest integer among the most frequent ones. # Input and Output Formats: - **Input**: A list `numbers` containing integers. - **Output**: An integer which is the most frequent value in the list `numbers`. # Constraints: - The length of `numbers` is between 0 and 100,000. - The integers in `numbers` are between -1,000,000 and 1,000,000 inclusive. # Example: ```python def most_frequent_value(numbers: list) -> int: pass # Example usage print(most_frequent_value([1, 3, 2, 1, 4, 1])) # 1 print(most_frequent_value([1, 2, 2, 3, 3])) # 2 print(most_frequent_value([4, 5, 6, 6, 5, 4])) # 4 print(most_frequent_value([10])) # 10 print(most_frequent_value([])) # None or appropriate handling for empty list ``` # Criteria: - The function should efficiently handle lists with up to 100,000 elements. - Consider using Python’s `collections.Counter` or a similar approach to count frequencies. # Additional Notes: - Ensure proper handling for an empty list by returning `None` or an appropriate value. - Account for both positive and negative integers in the input list. - Aim for a solution with O(n) time complexity for optimal performance.","solution":"from collections import Counter def most_frequent_value(numbers: list) -> int: Returns the most frequent value in a list of integers. In case of a tie, returns the smallest value. Parameters: numbers (list): A list of integers. Returns: int: The most frequent integer in the list, or the smallest one among the most frequent in case of a tie. if not numbers: return None counter = Counter(numbers) # Get the highest frequency max_frequency = max(counter.values()) # Filter numbers with the highest frequency most_frequent_numbers = [num for num, freq in counter.items() if freq == max_frequency] # Return the smallest one among the most frequent return min(most_frequent_numbers)"},{"question":"# Coding Challenge: Unique Characters Counter in Strings Objective: You are provided a list of strings. Your task is to determine how many strings in the list contain all unique characters and return this count. Detailed Task Description: 1. **Function Implementation**: - Implement `has_all_unique_characters(s: str) -> bool`: This function should take a string as input and return True if the string contains all unique characters, and False otherwise. 2. **Main Function**: - Implement `count_unique_character_strings(strings: List[str]) -> int`: This function should take a list of strings, utilize the `has_all_unique_characters` function to check each string for uniqueness, and count how many strings meet this criteria. Finally, return the count. Input: - A list of strings. Output: - An integer representing the number of strings that contain all unique characters. Constraints: - Each string in the list will have a maximum length of 100 characters. - The total number of strings in the list will not exceed 1000. - Strings will consist of lowercase English letters only. Example: Suppose the input list is: ``` [\\"apple\\", \\"orange\\", \\"banana\\", \\"unique\\", \\"character\\", \\"test\\", \\"code\\"] ``` Running the function, we find: - `apple` -> contains duplicate \'p\', so not all unique (`False`) - `orange` -> all unique characters (`True`) - `banana` -> contains duplicate \'a\' and \'n\', so not all unique (`False`) - `unique` -> contains duplicate \'u\', so not all unique (`False`) - `character` -> contains duplicate \'c\' and \'a\', so not all unique (`False`) - `test` -> contains duplicate \'t\', so not all unique (`False`) - `code` -> all unique characters (`True`) Thus, the count of strings with all unique characters would be 2. Function Signatures: - has_all_unique_characters(s: str) -> bool - count_unique_character_strings(strings: List[str]) -> int","solution":"from typing import List def has_all_unique_characters(s: str) -> bool: Returns True if the string contains all unique characters, False otherwise. return len(set(s)) == len(s) def count_unique_character_strings(strings: List[str]) -> int: Takes a list of strings and counts how many strings contain all unique characters. return sum(1 for s in strings if has_all_unique_characters(s))"},{"question":"# Coding Assessment Question Objective You are tasked with generating all possible valid expressions by adding the binary operators `+`, `-`, and/or `*` between the digits of a given string of numbers, ensuring that the final expression evaluates to a target integer. Implement a function that receives a string of digits and a target integer, and returns a list of all valid expressions. Function Signature ```python def add_operators(num: str, target: int) -> List[str]: :param num: str, a string representing a sequence of digits. :param target: int, the target result for the expressions. :return: List[str], a list of valid expressions that evaluate to the target integer. Constraints: 1 <= len(num) <= 10 num consists of digits only. Target can be any integer within the range of [-2**31, 2**31 - 1]. Example: >>> add_operators(\\"123\\", 6) [\\"1+2+3\\", \\"1*2*3\\"] >>> add_operators(\\"232\\", 8) [\\"2*3+2\\", \\"2+3*2\\"] >>> add_operators(\\"105\\", 5) [\\"1*0+5\\", \\"10-5\\"] >>> add_operators(\\"00\\", 0) [\\"0+0\\", \\"0-0\\", \\"0*0\\"] >>> add_operators(\\"3456237490\\", 9191) [] ``` Guidelines 1. **Core Requirements**: - Generate all possible valid expressions by inserting `+`, `-`, and/or `*` between the digits in `num`. - Ensure each expression evaluates to the given `target`. 2. **Expected Input/Output**: - Input: A string `num` consisting of digits and an integer `target`. - Output: A list of strings where each string is a valid expression reaching the `target`. 3. **Performance**: - The solution should handle the constraints efficiently, using recursion for generating expressions and correctly evaluating them. 4. **Edge Cases**: - Handle cases where `num` results in leading zeros within segments. - Ensure that an empty `num` string or `num` with invalid characters does not lead to errors (though constraints guarantee valid input). 5. **Error Handling**: - Appropriately manage invalid input scenarios as per the constraints. Good Luck!","solution":"from typing import List def add_operators(num: str, target: int) -> List[str]: def backtrack(index: int, path: str, value: int, prev: int): if index == len(num): if value == target: results.append(path) return for i in range(index, len(num)): substr = num[index:i + 1] if len(substr) > 1 and substr[0] == \'0\': continue current = int(substr) if index == 0: backtrack(i + 1, substr, current, current) else: backtrack(i + 1, path + \'+\' + substr, value + current, current) backtrack(i + 1, path + \'-\' + substr, value - current, -current) backtrack(i + 1, path + \'*\' + substr, value - prev + prev * current, prev * current) results = [] backtrack(0, \'\', 0, 0) return results"},{"question":"# String Pattern Matcher Objective Create a `PatternMatcher` class that allows users to add string patterns and search for occurrences of these patterns within a text. The class should support adding multiple patterns, finding all matches of each pattern in a given text, and providing a summary of the results. Instructions 1. **Class Definition**: Write a class `PatternMatcher` that: - Maintains a list of string patterns. - Provides methods to add new string patterns. - Contains methods to search for all occurrences of the patterns in a given text. - Returns the list of positions for each pattern found in the text. 2. **Class Methods**: - `add_pattern(pattern: str) -> None`: Adds a string pattern to the list. - `find_matches(text: str) -> dict[str, list[int]]`: Searches for all patterns in the given text and returns a dictionary where the keys are the patterns and the values are lists of starting positions where each pattern is found. 3. **Search Algorithm**: - Use the Knuth-Morris-Pratt (KMP) string matching algorithm or any other efficient algorithm to find matches. 4. **Summary Method**: - `describe_matches(matches: dict[str, list[int]]) -> str`: Returns a summary string describing the number of occurrences and the starting positions of each pattern in the text. # Example Here\'s an example of how your `PatternMatcher` can be used: ```python matcher = PatternMatcher() matcher.add_pattern(\\"abc\\") matcher.add_pattern(\\"xyz\\") text = \\"abcxyzabcxyzabc\\" matches = matcher.find_matches(text) summary = matcher.describe_matches(matches) print(\\"Matches:\\", matches) print(\\"Summary:n\\", summary) ``` **Expected Output:** ``` Matches: {\'abc\': [0, 6, 12], \'xyz\': [3, 9]} Summary: Pattern \'abc\' found 3 times at positions [0, 6, 12] Pattern \'xyz\' found 2 times at positions [3, 9] ``` Constraints - Patterns and text are non-empty strings consisting of lowercase English letters. - Assume the maximum length of text is 10^4 characters. - Assume the maximum number of patterns is 100, and each pattern has a maximum length of 100 characters.","solution":"class PatternMatcher: def __init__(self): self.patterns = [] def add_pattern(self, pattern: str) -> None: Adds a string pattern to the list. self.patterns.append(pattern) def find_matches(self, text: str) -> dict[str, list[int]]: Searches for all patterns in the given text and returns a dictionary where the keys are the patterns and the values are lists of starting positions where each pattern is found. matches = {} for pattern in self.patterns: matches[pattern] = self._find_pattern_positions(text, pattern) return matches def _find_pattern_positions(self, text: str, pattern: str) -> list[int]: Finds all starting positions of the pattern in the text using a simple sliding window approach. positions = [] pattern_length = len(pattern) for i in range(len(text) - pattern_length + 1): if text[i:i + pattern_length] == pattern: positions.append(i) return positions def describe_matches(self, matches: dict[str, list[int]]) -> str: Returns a summary string describing the number of occurrences and the starting positions of each pattern in the text. summary_lines = [] for pattern, positions in matches.items(): summary_lines.append(f\\"Pattern \'{pattern}\' found {len(positions)} times at positions {positions}\\") return \\"n\\".join(summary_lines)"},{"question":"# Question You are tasked with writing a function `closest_ancestor` to find the lowest common ancestor in a binary search tree (BST) for two given nodes. The BST and the nodes will be provided in a specific format. Specifications - Function: `closest_ancestor(root: dict, node1: int, node2: int) -> int` - **Input**: - `root`: A dictionary representing the root node of a BST. Each node has two children represented as keys \'left\' and \'right\'. A `null` value indicates no child. - `node1`: The first node\'s value. - `node2`: The second node\'s value. - **Output**: - The value of the lowest common ancestor of `node1` and `node2`. Constraints - Each node value will be unique. - The BST will contain at least 3 nodes. - `node1` and `node2` are guaranteed to exist within the BST. Example ```python >>> bst = { ... \\"value\\": 20, ... \\"left\\": { ... \\"value\\": 10, ... \\"left\\": {\\"value\\": 5, \\"left\\": None, \\"right\\": None}, ... \\"right\\": {\\"value\\": 15, \\"left\\": None, \\"right\\": None} ... }, ... \\"right\\": { ... \\"value\\": 30, ... \\"left\\": {\\"value\\": 25, \\"left\\": None, \\"right\\": None}, ... \\"right\\": {\\"value\\": 35, \\"left\\": None, \\"right\\": None} ... } ... } >>> closest_ancestor(bst, 5, 15) 10 ``` Notes - In a BST, the lowest common ancestor for two nodes `p` and `q` is defined as the deepest node that has both `p` and `q` as descendants (where we allow a node to be a descendant of itself).","solution":"def closest_ancestor(root, node1, node2): Finds the lowest common ancestor in a BST for the given two nodes. current = root while current: if node1 < current[\\"value\\"] and node2 < current[\\"value\\"]: current = current[\\"left\\"] elif node1 > current[\\"value\\"] and node2 > current[\\"value\\"]: current = current[\\"right\\"] else: return current[\\"value\\"]"},{"question":"# Most Frequent Element in a Stream You are tasked with building a function that can dynamically track and return the most frequent element in a continuous stream of integers. The function should maintain efficient insertions and be able to provide the most frequent element in constant time. **Function Signature**: ```python class StreamProcessor: def __init__(self): pass def insert(self, value: int) -> None: pass def get_most_frequent(self) -> int: pass ``` # Input * The method `insert` is called with an integer value. This method adds the value to the stream. * The method `get_most_frequent` is called to retrieve the most frequent integer currently in the stream. # Output * The `get_most_frequent` method returns the integer that has the highest frequency in the stream. If there is a tie, return any of the most frequent elements. # Constraints * Both methods should have an average time complexity of O(1). * You can assume that the integer values are non-negative. # Example ```python >>> sp = StreamProcessor() >>> sp.insert(1) >>> sp.insert(2) >>> sp.insert(1) >>> sp.get_most_frequent() 1 >>> sp.insert(2) >>> sp.get_most_frequent() 1 # or 2 since they now have the same frequency >>> sp.insert(3) >>> sp.insert(3) >>> sp.insert(3) >>> sp.get_most_frequent() 3 ```","solution":"from collections import defaultdict class StreamProcessor: def __init__(self): self.frequency = defaultdict(int) self.max_frequency = 0 self.most_frequent_element = None def insert(self, value: int) -> None: self.frequency[value] += 1 if self.frequency[value] > self.max_frequency: self.max_frequency = self.frequency[value] self.most_frequent_element = value def get_most_frequent(self) -> int: return self.most_frequent_element"},{"question":"Problem Statement Write a function `find_lonely_number` that takes an integer list and returns the number which appears only once in the list, while every other number appears exactly twice. # Function Signature ```python def find_lonely_number(nums: List[int]) -> int: pass ``` # Input * `nums` (List[int]): A list of integers where all integers except one appear exactly twice. * 1 <= len(nums) <= 10^5 * -10^9 <= nums[i] <= 10^9 # Output * The function should return a single integer, the lonely number that appears only once. # Example Input ```python nums = [2, 3, 5, 4, 5, 3, 4] ``` Output ```python 2 ``` # Scenario Michael is cleaning up data logs and notices some numbers are erroneously duplicated. He needs a function to identify the single unique number hidden among the duplicates. # Constraints * You should ensure your solution efficiently handles the upper constraints. * Leverage appropriate algorithmic approaches to achieve optimal time complexity. # Example Test Cases ```python assert find_lonely_number([2, 3, 5, 4, 5, 3, 4]) == 2 assert find_lonely_number([1, 1, 2]) == 2 assert find_lonely_number([4, 4, 6, 2, 2]) == 6 assert find_lonely_number([17]) == 17 ```","solution":"from typing import List def find_lonely_number(nums: List[int]) -> int: This function returns the number which appears only once in the list, while every other number appears exactly twice. lonely_number = 0 for num in nums: lonely_number ^= num return lonely_number"},{"question":"```markdown # Coding Assessment Question You are given a sentence as a string, and your task is to implement a function `longest_unique_substring(s: str) -> str` that returns the longest substring without repeating characters. Input * A string `s` where (1 <= len(s) <= 10^5). Output * A string representing the longest substring without repeating characters. Example ```python assert longest_unique_substring(\\"abcabcbb\\") == \\"abc\\" assert longest_unique_substring(\\"bbbbb\\") == \\"b\\" assert longest_unique_substring(\\"pwwkew\\") == \\"wke\\" ``` Constraints * You may assume that the string contains only ASCII characters. * The function should handle edge cases like an empty string or a string where all characters are unique. * The function should be optimized for performance to handle the upper range of input length efficiently. Function Signature ```python def longest_unique_substring(s: str) -> str: pass ``` Notes 1. Ensure to handle edge cases like the given string being empty, or all characters in the string being the same. 2. While the primary focus is on correctness, attempt to optimize the solution to handle large inputs efficiently. ```","solution":"def longest_unique_substring(s: str) -> str: Returns the longest substring without repeating characters. Args: s (str): The input string. Returns: str: The longest substring without repeating characters. n = len(s) if n == 0: return \\"\\" char_map = {} max_length = 0 max_start = 0 start = 0 for end in range(n): if s[end] in char_map and char_map[s[end]] >= start: start = char_map[s[end]] + 1 char_map[s[end]] = end if end - start + 1 > max_length: max_length = end - start + 1 max_start = start return s[max_start:max_start + max_length]"},{"question":"# Coding Question: Duplicate Remover with Minimal Memory Usage You are given a list of integers that may contain duplicates. Your task is to remove the duplicates in-place, without using any additional data structures (e.g., sets or dictionaries) to ensure minimal memory usage. After removing the duplicates, return the length of the list with unique elements. Maintain the order of the first occurrence of each element. # Function Signature ```python def remove_duplicates_in_place(nums: list) -> int: pass ``` # Inputs and Outputs - **Input**: A list of integers, `nums`, which can contain zero or more integers, both positive and negative. - **Output**: An integer representing the number of unique elements in `nums`. # Constraints: - The function should work in-place and handle lists of sizes up to 10^5 elements efficiently. - Memory usage should be minimized. - Return the number of unique elements in the modified list. # Example ```python >>> nums = [1, 1, 2] >>> length = remove_duplicates_in_place(nums) >>> length 2 >>> nums[:length] [1, 2] >>> nums = [0, 0, 0, 1, 1, 2, 2, 3, 3, 4] >>> length = remove_duplicates_in_place(nums) >>> length 5 >>> nums[:length] [0, 1, 2, 3, 4] >>> nums = [] >>> length = remove_duplicates_in_place(nums) >>> length 0 >>> nums[:length] [] >>> nums = [1, 1, 1] >>> length = remove_duplicates_in_place(nums) >>> length 1 >>> nums[:length] [1] >>> nums = [1, 2, 3, 4, 5] >>> length = remove_duplicates_in_place(nums) >>> length 5 >>> nums[:length] [1, 2, 3, 4, 5] ``` You should focus on modifying the original list directly while ensuring the solution is efficient both in time and space complexity. Check edge cases such as empty lists, lists with only one element, and lists where all elements are identical.","solution":"def remove_duplicates_in_place(nums: list) -> int: Removes duplicates in-place from the list and returns the length of the list with unique elements. if not nums: return 0 unique_index = 0 for i in range(1, len(nums)): if nums[i] != nums[unique_index]: unique_index += 1 nums[unique_index] = nums[i] return unique_index + 1"},{"question":"# Coding Assessment Question: Optimized Price Tracker You are tasked to create a function called `track_price` that fetches and tracks the prices of a list of items from an online store\'s API. The function will perform the following tasks: 1. **Input Parameters and Constraints**: - `product_ids` (list of str): List of product IDs to fetch prices for. The list can contain up to 50 product IDs. - `currency` (str): The desired currency for the prices (e.g., \\"USD\\", \\"EUR\\", \\"GBP\\"). Default is \\"USD\\". - The function should use a default API endpoint variable `store_api_url`. 2. **Function Output**: - Should return a dictionary with product IDs as keys and their corresponding prices in the desired currency as values. 3. **Error Handling**: - Properly handle network failures and timeouts. - Handle invalid input parameters (e.g., product IDs that do not exist). - Raise appropriate exceptions or return informative error messages. 4. **Performance Considerations**: - Implement error handling for API rate limits or large response sizes. - Introduce batching for API requests if necessary to handle the list efficiently. - Consider implementing caching mechanisms for repeated queries if needed. # Function Signature ```python def track_price(product_ids: list, currency: str = \\"USD\\") -> dict: ``` # Example Usage ```python # Example call to the function product_prices = track_price([\\"12345\\", \\"67890\\"], currency=\\"EUR\\") for product_id, price in product_prices.items(): print(f\\"Product ID: {product_id}, Price: {price} {currency}\\") ``` # Example Output ```python # Example output of the function { \\"12345\\": 29.99, \\"67890\\": 45.50 } ``` # Notes - Use the `requests` library for HTTP requests. - Refer to the store API documentation for more details on available parameters and response structure. - Optimize the function to handle larger lists more efficiently while adhering to API constraints.","solution":"import requests from typing import List, Dict store_api_url = \\"https://example.com/api/products\\" def track_price(product_ids: List[str], currency: str = \\"USD\\") -> Dict[str, float]: Fetches and tracks the prices of a list of items from an online store\'s API. Args: - product_ids (List[str]): List of product IDs to fetch prices for (up to 50). - currency (str): The desired currency for the prices. Default is \\"USD\\". Returns: - dict: A dictionary with product IDs as keys and their corresponding prices in the desired currency as values. if not isinstance(product_ids, list) or not all(isinstance(id, str) for id in product_ids): raise ValueError(\\"product_ids must be a list of strings\\") if len(product_ids) > 50: raise ValueError(\\"The list of product_ids should not exceed 50 items\\") prices = {} for product_id in product_ids: try: response = requests.get(f\\"{store_api_url}/{product_id}\\", params={\\"currency\\": currency}, timeout=10) response.raise_for_status() data = response.json() if \\"price\\" in data: prices[product_id] = data[\\"price\\"] else: raise ValueError(f\\"Invalid response format for product_id: {product_id}\\") except requests.RequestException as e: raise ConnectionError(f\\"Network request failed for product_id: {product_id}\\") from e except ValueError as e: raise ValueError(f\\"Error fetching price for product_id: {product_id}: {e}\\") return prices"},{"question":"# Scenario You are working on a natural language processing project that involves text preprocessing. One of the tasks requires you to count the frequency of each word in a given text document after converting all words to lowercase and removing punctuation. # Task Implement the function `word_frequency(text: str) -> dict` which processes the text and returns a dictionary containing the frequency of each word. # Function Signature ```python def word_frequency(text: str) -> dict: pass ``` # Input: * `text` (str): A string representing the input text document. # Output: * Returns a dictionary where keys are words in lowercase without punctuation and values are their corresponding frequencies in the text. # Constraints: * The text can be an empty string or contain up to 10^6 characters. * Words are defined as sequences of alphanumeric characters (a-z, A-Z, 0-9). * Punctuation includes any characters that are not alphanumeric. # Examples: 1. Input: `text = \\"Hello, world! Hello universe.\\"` Output: `{\'hello\': 2, \'world\': 1, \'universe\': 1}` 2. Input: `text = \\"Python is great. Python, Python, Python.\\"` Output: `{\'python\': 4, \'is\': 1, \'great\': 1}` # Note: The implementation should handle the preprocessing efficiently, considering the potential size of the input text. Each word should be case-insensitive, and punctuation characters should be removed before counting the frequencies.","solution":"import re from collections import defaultdict def word_frequency(text: str) -> dict: Processes the text and returns a dictionary containing the frequency of each word. Words are converted to lowercase and punctuation is removed. # Convert the text to lowercase text = text.lower() # Remove punctuation using regex text = re.sub(r\'[^ws]\', \'\', text) # Split the text into words words = text.split() # Initialize a default dictionary to store word frequency frequency = defaultdict(int) for word in words: frequency[word] += 1 return dict(frequency)"},{"question":"# Coding Challenge: Matrix Transposition You are tasked with creating a function that takes a two-dimensional matrix and returns its transpose. A transpose of a matrix is obtained by swapping rows with columns. Function Signature ```python def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: # Your implementation here ``` Input 1. `matrix` (List[List[int]]): A two-dimensional list containing integers where `matrix[i][j]` is the element in the `i-th` row and `j-th` column. Output - Returns a two-dimensional list which is the transpose of the input matrix. Constraints - Each row in the matrix must have the same number of elements. - The matrix must have at least one row and one column. Examples 1. `transpose_matrix([[1, 2, 3], [4, 5, 6]])` should return `[[1, 4], [2, 5], [3, 6]]`. 2. `transpose_matrix([[1]])` should return `[[1]]`. 3. `transpose_matrix([[1, 2], [3, 4], [5, 6]])` should return `[[1, 3, 5], [2, 4, 6]]`. Error Handling 1. If the input is not a list of lists or any row doesn\'t have the same number of elements, raise a `ValueError` with a message indicating the expected format. Example Usage ```python try: print(transpose_matrix([[1, 2, 3], [4, 5, 6]])) # Should output: [[1, 4], [2, 5], [3, 6]] print(transpose_matrix([[1]])) # Should output: [[1]] print(transpose_matrix([[1, 2], [3, 4], [5, 6]])) # Should output: [[1, 3, 5], [2, 4, 6]] except ValueError as e: print(str(e)) ``` Implement the `transpose_matrix` function according to the given requirements.","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Returns the transpose of a given two-dimensional matrix. Args: matrix (List[List[int]]): A two-dimensional list containing integers. Returns: List[List[int]]: The transpose of the input matrix. Raises: ValueError: If the input is not a list of lists or any row doesn\'t have the same number of elements. if not matrix or not all(isinstance(row, list) for row in matrix): raise ValueError(\\"Input should be a list of lists\\") row_length = len(matrix[0]) for row in matrix: if len(row) != row_length: raise ValueError(\\"All rows must have the same number of elements\\") transposed = [[matrix[row][col] for row in range(len(matrix))] for col in range(row_length)] return transposed"},{"question":"# Question: Circular Queue Implementation Implement a circular queue or circular buffer data structure which supports the following operations with their respective time complexities: 1. `enqueue(data)`: Insert an element at the rear of the queue. Time Complexity: O(1) 2. `dequeue()`: Remove and return the element at the front of the queue. Time Complexity: O(1) 3. `is_full()`: Check if the queue is full. Time Complexity: O(1) 4. `is_empty()`: Check if the queue is empty. Time Complexity: O(1) 5. `peek()`: Return the element at the front of the queue without removing it. Time Complexity: O(1) The circular queue should be implemented using a fixed-size list to hold the elements, and you should manage the head (front) and tail (rear) indexes to maintain the queue\'s state throughout the operations. # Input * The initial size of the queue as an integer `size`. * A series of method calls with their respective arguments. # Output * For `enqueue(data)`, the method should return `True` if the element was successfully added or `False` if the queue was full. * For `dequeue()`, return the dequeued data or `None` if the queue is empty. * For `peek()`, return the front element or `None` if the queue is empty. * For `is_full()` and `is_empty()`, return `True` or `False`. # Example ```python cq = CircularQueue(3) print(cq.enqueue(1)) # True print(cq.enqueue(2)) # True print(cq.enqueue(3)) # True print(cq.enqueue(4)) # False (queue is full) print(cq.dequeue()) # 1 print(cq.dequeue()) # 2 print(cq.enqueue(4)) # True print(cq.is_full()) # False print(cq.is_empty()) # False print(cq.peek()) # 3 print(cq.dequeue()) # 3 print(cq.dequeue()) # 4 print(cq.is_empty()) # True ``` # Constraints * Ensure that your implementation handles up to 1,000,000 operations efficiently. * Assume that all data elements are integers within the range `-10^6` to `10^6`. # Implementation ```python class CircularQueue: def __init__(self, size: int): self.size = size self.queue = [None] * size self.head = -1 self.tail = -1 def enqueue(self, data: int) -> bool: if self.is_full(): return False if self.head == -1: self.head = 0 self.tail = (self.tail + 1) % self.size self.queue[self.tail] = data return True def dequeue(self) -> int: if self.is_empty(): return None data = self.queue[self.head] if self.head == self.tail: self.head = -1 self.tail = -1 else: self.head = (self.head + 1) % self.size return data def is_full(self) -> bool: return (self.tail + 1) % self.size == self.head def is_empty(self) -> bool: return self.head == -1 def peek(self) -> int: if self.is_empty(): return None return self.queue[self.head] ```","solution":"class CircularQueue: def __init__(self, size: int): self.size = size self.queue = [None] * size self.head = -1 self.tail = -1 def enqueue(self, data: int) -> bool: if self.is_full(): return False if self.head == -1: self.head = 0 self.tail = (self.tail + 1) % self.size self.queue[self.tail] = data return True def dequeue(self) -> int: if self.is_empty(): return None data = self.queue[self.head] if self.head == self.tail: self.head = -1 self.tail = -1 else: self.head = (self.head + 1) % self.size return data def is_full(self) -> bool: return (self.tail + 1) % self.size == self.head def is_empty(self) -> bool: return self.head == -1 def peek(self) -> int: if self.is_empty(): return None return self.queue[self.head]"},{"question":"# String Permutations Checker Description You are building a text analysis tool and need to implement a function to check if two strings are permutations of each other. A permutation is a rearrangement of letters. The comparison should be case-sensitive, meaning \\"a\\" and \\"A\\" are considered different characters. Task Implement the `are_permutations` function to check if two given strings are permutations of each other. Function Signature ```python def are_permutations(str1: str, str2: str) -> bool: pass ``` Input - `str1 (str)`: The first string. - `str2 (str)`: The second string. Output - `bool`: Return `True` if `str1` and `str2` are permutations of each other, else return `False`. Constraints - The length of both strings will be between 1 and 1000. You need to ensure that the function correctly identifies permutations by comparing the count of each character in both strings. Example ```python # Example 1 str1 = \\"listen\\" str2 = \\"silent\\" result = are_permutations(str1, str2) assert result == True # \\"listen\\" is a permutation of \\"silent\\" # Example 2 str1 = \\"hello\\" str2 = \\"bello\\" result = are_permutations(str1, str2) assert result == False # \\"hello\\" is not a permutation of \\"bello\\" # Example 3 str1 = \\"ABC\\" str2 = \\"CBA\\" result = are_permutations(str1, str2) assert result == True # \\"ABC\\" is a permutation of \\"CBA\\" # Example 4 str1 = \\"abc\\" str2 = \\"ABC\\" result = are_permutations(str1, str2) assert result == False # \\"abc\\" is not a permutation of \\"ABC\\" (case-sensitive) ``` Demonstrate through the provided examples and constraint conditions that the function works effectively to determine if the two given strings are permutations of each other.","solution":"def are_permutations(str1: str, str2: str) -> bool: Checks if two strings are permutations of each other. Args: str1: The first string. str2: The second string. Returns: True if the two strings are permutations of each other, False otherwise. if len(str1) != len(str2): return False from collections import Counter return Counter(str1) == Counter(str2)"},{"question":"# Queue Implementation with Circular Array You are tasked with implementing a queue using a circular array. The queue needs to support the following operations: enqueue, dequeue, and is_empty. Task Implement a class named `CircularQueue` with the following methods: - `__init__(self, k: int)`: Initializes the queue to be of size `k`. - `enqueue(self, value: int) -> bool`: Adds an element `value` to the queue. Returns `True` if the operation is successful, `False` otherwise. - `dequeue(self) -> int`: Removes and returns the front element from the queue. Returns `-1` if the queue is empty. - `is_empty(self) -> bool`: Returns `True` if the queue is empty, `False` otherwise. Input * The `__init__` method takes an integer `k` which represents the size of the queue. * The `enqueue` method takes an integer `value`. * The `dequeue` method does not take any parameters. * The `is_empty` method does not take any parameters. Output * The `enqueue` method returns `True` if the value was successfully added to the queue, `False` otherwise. * The `dequeue` method returns the front element if the queue is not empty, `-1` otherwise. * The `is_empty` method returns `True` if the queue is empty, `False` otherwise. Constraints * The size of the queue, `k`, will be a positive integer (1 ≤ k ≤ 1000). * The values to be enqueued will be integers within the range of 32-bit signed integers. Examples ```python cq = CircularQueue(3) print(cq.enqueue(1)) # Output: True print(cq.enqueue(2)) # Output: True print(cq.enqueue(3)) # Output: True print(cq.enqueue(4)) # Output: False print(cq.dequeue()) # Output: 1 print(cq.is_empty()) # Output: False print(cq.dequeue()) # Output: 2 print(cq.dequeue()) # Output: 3 print(cq.dequeue()) # Output: -1 print(cq.is_empty()) # Output: True ``` Implementation ```python class CircularQueue: def __init__(self, k: int): self.size = k self.queue = [None] * k self.head = -1 self.tail = -1 def enqueue(self, value: int) -> bool: if (self.tail + 1) % self.size == self.head: return False if self.head == -1: self.head = 0 self.tail = (self.tail + 1) % self.size self.queue[self.tail] = value return True def dequeue(self) -> int: if self.head == -1: return -1 value = self.queue[self.head] if self.head == self.tail: self.head, self.tail = -1, -1 else: self.head = (self.head + 1) % self.size return value def is_empty(self) -> bool: return self.head == -1 ```","solution":"class CircularQueue: def __init__(self, k: int): Initializes the queue to be of size k. self.size = k self.queue = [None] * k self.head = -1 self.tail = -1 def enqueue(self, value: int) -> bool: Adds an element \'value\' to the queue. Returns True if the operation is successful, False otherwise. if (self.tail + 1) % self.size == self.head: return False if self.head == -1: self.head = 0 self.tail = (self.tail + 1) % self.size self.queue[self.tail] = value return True def dequeue(self) -> int: Removes and returns the front element from the queue. Returns -1 if the queue is empty. if self.head == -1: return -1 value = self.queue[self.head] if self.head == self.tail: self.head, self.tail = -1, -1 else: self.head = (self.head + 1) % self.size return value def is_empty(self) -> bool: Returns True if the queue is empty, False otherwise. return self.head == -1"},{"question":"Title: Validate Brackets in a String # Description You are required to write a function that validates whether an input string has balanced brackets. The brackets considered are `()`, `{}`, and `[]`. The function must return `True` if the string has balanced brackets, and `False` otherwise. Your function should handle cases where the input is not a string by raising a `ValueError` with the message \\"Input must be a string.\\" # Function Signature ```python def validate_brackets(input_string: str) -> bool: pass ``` # Input * `input_string` (str): A string containing characters, which may include the brackets `()`, `{}`, and `[]`. # Output * Returns `True` if the brackets in the input string are balanced, and `False` otherwise. # Constraints * The function should only accept strings. * If the input `input_string` is not a string, raise a `ValueError` with the message \\"Input must be a string\\". * The function should handle empty strings as balanced. # Examples ```python validate_brackets(\\"()\\") # returns True validate_brackets(\\"({[()]})\\") # returns True validate_brackets(\\"{[(])}\\") # returns False validate_brackets(\\"{[}\\") # returns False validate_brackets(\\"[{}{}]\\") # returns True validate_brackets(\\"\\") # returns True validate_brackets(123) # raises ValueError: Input must be a string validate_brackets(\\"([)]\\") # returns False ``` # Notes * For an input string to have balanced brackets, each opening bracket must have a corresponding and correctly ordered closing bracket. * Make sure to test the function with edge cases such as an empty string, strings without any brackets, and incorrect data types. * Consider using a stack data structure to efficiently validate the brackets.","solution":"def validate_brackets(input_string: str) -> bool: Validates whether the input string has balanced brackets. Parameters: input_string (str): The string to be checked for balanced brackets. Returns: bool: True if the string has balanced brackets, False otherwise. Raises: ValueError: If the input is not a string. if not isinstance(input_string, str): raise ValueError(\\"Input must be a string\\") stack = [] bracket_map = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in input_string: if char in bracket_map.values(): stack.append(char) elif char in bracket_map: if stack == [] or bracket_map[char] != stack.pop(): return False return stack == []"},{"question":"# Coding Assessment Question: Implement a data structure that supports insertion of integers and retrieving the maximum integer present in it in (O(1)) time complexity. Design and implement this data structure using standard Python list operations. **Function Specifications**: - **insert(item: int) -> None**: Inserts an element into the data structure. - **get_max() -> int**: Retrieves the maximum element in the data structure. Raises a `ValueError` if the data structure is empty. **Requirements**: - The `insert` function should have (O(1)) average time complexity. - The `get_max` function should have (O(1)) time complexity. - Handle edge scenarios, such as calling `get_max` on an empty structure, gracefully. **Constraints**: - The maximum number of elements inserted won\'t exceed (10^5). - All elements are integers within the range ([-10^6, 10^6]). **Example**: ```python >>> max_data_struct = MaxDataStructure() >>> max_data_struct.insert(1) >>> max_data_struct.insert(5) >>> max_data_struct.insert(3) >>> max_data_struct.get_max() 5 >>> max_data_struct.insert(10) >>> max_data_struct.get_max() 10 >>> max_data_struct.insert(7) >>> max_data_struct.get_max() 10 >>> # After removing 10, the maximum becomes 7 >>> max_data_struct.remove(10) >>> max_data_struct.get_max() 7 >>> # Removing remaining elements >>> max_data_struct.remove(7) >>> max_data_struct.remove(5) >>> max_data_struct.remove(3) >>> max_data_struct.remove(1) >>> max_data_struct.get_max() Traceback (most recent call last): ... ValueError: data structure is empty ``` You should design the data structure efficiently to handle both insertion and retrieval operations as per the time complexity requirements. The implementation should ensure the correctness of the returned maximum value while maintaining an acceptable performance for the insertions and deletions.","solution":"class MaxDataStructure: def __init__(self): self.data = [] self.max_data = [] def insert(self, item: int) -> None: self.data.append(item) # keep max_data up to date if not self.max_data or item >= self.max_data[-1]: self.max_data.append(item) else: self.max_data.append(self.max_data[-1]) def get_max(self) -> int: if not self.data: raise ValueError(\\"data structure is empty\\") return self.max_data[-1]"},{"question":"# Problem Statement You are given a string and a dictionary of words. Your task is to find the minimum number of characters in the string that need to be replaced with \'*\' so that no word from the dictionary is a substring of the modified string. # Function Signature ```python def min_replacements_to_remove_substrings(s: str, words: list[str]) -> int: ``` # Input * **s** (*str*): The input string (1 <= len(s) <= 10^5). * **words** (*List[str]*): The list of dictionary words (1 <= len(words) <= 10^4, 1 <= len(words[i]) <= len(s)). # Output * **int**: The minimum number of characters to replace with \'*\'. # Constraints * The length of the input string will not exceed 10^5. * The length of each dictionary word will not exceed the length of the input string. * Handle edge cases where the words list may contain overlapping or repeating dictionary words. # Example ```python >>> min_replacements_to_remove_substrings(\\"abcdeabc\\", [\\"abc\\", \\"de\\"]) 3 >>> min_replacements_to_remove_substrings(\\"aaaaaaa\\", [\\"aaa\\"]) 3 >>> min_replacements_to_remove_substrings(\\"abcdef\\", [\\"ghi\\"]) 0 ``` # Requirements * **Performance**: Your solution should be efficient enough to handle large inputs within the constraints. * **Handling Overlapping Words**: Properly manage cases where words in the dictionary overlap within the string.","solution":"def min_replacements_to_remove_substrings(s: str, words: list[str]) -> int: # Initialize a list to mark the positions to replace with \'*\' n = len(s) replace = [0] * n # Mark the positions to be replaced for each word in the list for word in words: start = 0 while start <= n - len(word): pos = s.find(word, start) if pos == -1: break for i in range(pos, pos + len(word)): replace[i] = 1 start = pos + 1 # Count how many positions are marked for replacement return sum(replace)"},{"question":"# Question: Design and Implement a Simple Blockchain You are given a basic implementation outline of a Blockchain class. Your task is to complete the implementation of this class by defining the following methods: 1. `add_block(self, transactions: list[list[int | float]]) -> None`: This method should create a new block using the provided list of transactions and add it to the blockchain. Each transaction is a list containing integers or floats. 2. `validate_chain(self) -> bool`: This method should validate the entire blockchain, verifying that each block’s hash is correct and each block points to the previous one correctly. Inputs: - `transactions`: A list of new transactions to be added in the new block. Each transaction is a list of integers or floats. Outputs: - The method `validate_chain` should return a boolean indicating whether the blockchain is valid. Block Structure: The basic structure of a block should include: - `index`: The position of the block in the blockchain. - `timestamp`: The timestamp when the block was created. - `transactions`: The list of transactions contained in the block. - `previous_hash`: The hash of the previous block in the blockchain. - `hash`: The hash of the current block. Constraints: - Assume the `hashlib` library is available for generating hashes. - Each block’s hash should be generated using the SHA-256 algorithm applied to a string that includes the index, timestamp, transactions, and previous hash. # Example Usage: ```python import hashlib import time class Block: def __init__(self, index, timestamp, transactions, previous_hash): self.index = index self.timestamp = timestamp self.transactions = transactions self.previous_hash = previous_hash self.hash = self.hash_block() def hash_block(self): sha = hashlib.sha256() sha.update((str(self.index) + str(self.timestamp) + str(self.transactions) + str(self.previous_hash)).encode(\'utf-8\')) return sha.hexdigest() class Blockchain: def __init__(self): self.chain = [self.create_genesis_block()] def create_genesis_block(self): return Block(0, time.time(), [], \\"0\\") def add_block(self, transactions: list[list[int | float]]) -> None: # Your implementation here def validate_chain(self) -> bool: # Your implementation here # Example usage: # Create the Blockchain object bc = Blockchain() # Add blocks to the blockchain bc.add_block([[1.0, 2.2], [3.1, 4.5]]) bc.add_block([[0.5, 1.2], [1.1, 3.3]]) # Validate the blockchain print(bc.validate_chain()) ``` # Additional Details: - Ensure the `validate_chain` method correctly verifies that each block is properly linked to its previous block by comparing hashes. - The `add_block` method should accurately record the index, timestamp, and previous block hash for the new block, then compute its hash and append it to the chain.","solution":"import hashlib import time class Block: def __init__(self, index, timestamp, transactions, previous_hash): self.index = index self.timestamp = timestamp self.transactions = transactions self.previous_hash = previous_hash self.hash = self.hash_block() def hash_block(self): sha = hashlib.sha256() sha.update((str(self.index) + str(self.timestamp) + str(self.transactions) + str(self.previous_hash)).encode(\'utf-8\')) return sha.hexdigest() class Blockchain: def __init__(self): self.chain = [self.create_genesis_block()] def create_genesis_block(self): return Block(0, time.time(), [], \\"0\\") def add_block(self, transactions: list[list[int | float]]) -> None: previous_block = self.chain[-1] new_block = Block( index=len(self.chain), timestamp=time.time(), transactions=transactions, previous_hash=previous_block.hash ) self.chain.append(new_block) def validate_chain(self) -> bool: for i in range(1, len(self.chain)): current_block = self.chain[i] previous_block = self.chain[i - 1] if current_block.previous_hash != previous_block.hash: return False if current_block.hash != current_block.hash_block(): return False return True"},{"question":"# Problem: Evaluate Sums of Unique Prime Factors You are given a file containing several lines, each with a single positive integer. Your task is to write a program that reads these integers and calculates the sum of the unique prime factors for each integer. Input * A string `filename` which denotes the path to the file containing the integer data. The file will contain one integer per line, formatted as: ``` number ``` Output * A list of integers where each integer is the sum of the unique prime factors of the corresponding input integer. Constraints * All integers in the file will be within the range 2 ≤ number ≤ 10^6. * The file will contain exactly 1000 lines. Example Given this sample text file `test_numbers.txt`: ``` 28 50 19 ``` Your function should return `[10, 7, 19]` because: * The unique prime factors of 28 are {2, 7}, and their sum is 9. * The unique prime factors of 50 are {2, 5}, and their sum is 7. * The unique prime factors of 19 are {19}, and their sum is 19. Function Signature ```python def sum_unique_prime_factors(filename: str) -> List[int]: ``` # Notes * Use an efficient algorithm to factorize each number and identify its unique prime factors. * Ensure to handle file reading and processing efficiently.","solution":"from typing import List, Set def prime_factors(n: int) -> Set[int]: Helper function to find the unique prime factors of a given number factors = set() # Check for number of 2s in n while n % 2 == 0: factors.add(2) n //= 2 # Check for odd factors from 3 upwards for i in range(3, int(n**0.5) + 1, 2): while n % i == 0: factors.add(i) n //= i # Add the remaining prime factor if n > 2 if n > 2: factors.add(n) return factors def sum_unique_prime_factors(filename: str) -> List[int]: result = [] with open(filename, \'r\') as file: for line in file: number = int(line.strip()) unique_factors = prime_factors(number) result.append(sum(unique_factors)) return result"},{"question":"# Roman Numeral to Integer Conversion You are tasked with implementing a function to convert a Roman numeral string into its corresponding integer value. The function should handle a single string input representing the Roman numeral and return the integer value. Function Signature: ```python def roman_to_integer(s: str) -> int: pass ``` Function Description: The function must convert the given Roman numeral string `s` to its corresponding integer value. Input: - `s`: A string `s` (1 <= len(s) <= 15), which is the Roman numeral to be converted. Output: - An integer, which is the integer value corresponding to the Roman numeral. # Constraints: - The input string `s` is guaranteed to be a valid Roman numeral representing an integer in the range from 1 to 3999 inclusive. # Examples: ```python >>> roman_to_integer(\\"III\\") 3 >>> roman_to_integer(\\"IV\\") 4 >>> roman_to_integer(\\"IX\\") 9 >>> roman_to_integer(\\"LVIII\\") 58 >>> roman_to_integer(\\"MCMXCIV\\") 1994 ``` # Notes: - Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five, we subtract it making four. - The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used: - I can be placed before V (5) and X (10) to make 4 and 9. - X can be placed before L (50) and C (100) to make 40 and 90. - C can be placed before D (500) and M (1000) to make 400 and 900. Write your implementation of the function `roman_to_integer(s: str) -> int` below:","solution":"def roman_to_integer(s: str) -> int: Convert a Roman numeral to an integer. roman_to_int_map = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } total = 0 prev_value = 0 for char in reversed(s): current_value = roman_to_int_map[char] if current_value < prev_value: total -= current_value else: total += current_value prev_value = current_value return total"},{"question":"**Question**: You are tasked with implementing a function that simulates the operation of a simple pocket calculator to evaluate arithmetic expressions containing the four basic operators: addition, subtraction, multiplication, and division. The expressions may include any number of whitespace characters, which should be ignored during evaluation. Write a function `evaluate_expression` that takes a string `expression` as input and returns the result of the evaluated arithmetic expression as a float. # Function Signature ```python def evaluate_expression(expression: str) -> float: ``` # Input * `expression`: A string containing the arithmetic expression to be evaluated. The expression can include integers, floats, the operators `+`, `-`, `*`, `/`, and arbitrary whitespace. # Output * Returns a float representing the result of the evaluated expression. # Constraints * Division by zero should raise a ZeroDivisionError. * The expression is guaranteed to be valid and well-formed. * The length of the expression will not exceed 200 characters. # Example ```python >>> evaluate_expression(\\"3 + 5\\") 8.0 >>> evaluate_expression(\\"10 + 2 * 6\\") 22.0 >>> evaluate_expression(\\"100 * 2 + 12\\") 212.0 >>> evaluate_expression(\\"100 * ( 2 + 12 )\\") 1400.0 >>> evaluate_expression(\\"100 * ( 2 + 12 ) / 14\\") 100.0 >>> evaluate_expression(\\"3.5 + 2.5 * 2\\") 8.5 ``` # Notes * Handle floating-point arithmetic carefully, especially with division to maintain precision. * Make sure that your implementation effectively parses and evaluates the expression while correctly handling operator precedence and associativity. * You may assume that all operators and operands are separated by at least one space for clarity in the input strings.","solution":"def evaluate_expression(expression: str) -> float: Evaluates an arithmetic expression containing +, -, *, / while ignoring arbitrary whitespace. # Remove any whitespace characters expression = expression.replace(\\" \\", \\"\\") # Evaluate the expression, catch division by zero error if it occurs try: result = float(eval(expression)) except ZeroDivisionError: raise ZeroDivisionError(\\"division by zero is not allowed\\") return result"},{"question":"# Problem Statement You are asked to implement a function that simulates a simplified version of the A* algorithm to find the shortest path in a weighted directed graph. The graph contains nodes identified by strings, and the edges have positive weights. # Function Signature ```python def a_star_shortest_path(graph: Dict[str, List[Tuple[str, int]]], start: str, goal: str, heuristic: Callable[[str, str], int]) -> List[str]: Finds the shortest path in a weighted directed graph using a simplified A* algorithm. :param graph: A dictionary representing the graph, where keys are node identifiers and values are lists of tuples. Each tuple contains a neighboring node and the weight of the edge connecting to it. :param start: The starting node identifier. :param goal: The goal node identifier. :param heuristic: A callable function that estimates the cost from a given node to the goal node. :return: A list of node identifiers representing the shortest path from start to goal. ``` # Input - `graph`: A dictionary where keys are node identifiers (`str`) and values are lists of tuples (`List[Tuple[str, int]]`). Each tuple consists of a neighboring node identifier and the weight of the edge (`int`) connecting to it. - `start`: A string representing the starting node. - `goal`: A string representing the goal node. - `heuristic`: A callable function that takes two node identifiers and returns an integer estimate of the cost from the first node to the second. # Output - Returns a list of node identifiers representing the shortest path from `start` to `goal`. # Constraints - The graph contains no more than 1000 nodes and each node can have up to 10 neighbors. - The weights of the edges are positive integers. - The heuristic function is admissible, meaning it never overestimates the true cost. - If there is no path from `start` to `goal`, return an empty list. # Example ```python from typing import Dict, List, Tuple, Callable def a_star_shortest_path(graph: Dict[str, List[Tuple[str, int]]], start: str, goal: str, heuristic: Callable[[str, str], int]) -> List[str]: # To be implemented pass # Example usage: graph = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'A\', 1), (\'C\', 2), (\'D\', 5)], \'C\': [(\'A\', 4), (\'B\', 2), (\'D\', 1)], \'D\': [(\'B\', 5), (\'C\', 1)] } heuristic_fn = lambda x, y: 1 if x != y else 0 # Example: Find shortest path from A to D print(a_star_shortest_path(graph, \'A\', \'D\', heuristic_fn)) # Output: [\'A\', \'B\', \'C\', \'D\'] ``` # Implementation Tips - Use priority queues (e.g., a heap queue) to manage the frontier of the search. - Maintain a dictionary to track the shortest known distance from the start to each node. - Keep track of the predecessor of each node to reconstruct the shortest path once the goal is reached. - Ensure efficient handling of nodes and edges to meet performance requirements for larger graphs.","solution":"from typing import Dict, List, Tuple, Callable import heapq def a_star_shortest_path(graph: Dict[str, List[Tuple[str, int]]], start: str, goal: str, heuristic: Callable[[str, str], int]) -> List[str]: Finds the shortest path in a weighted directed graph using a simplified A* algorithm. :param graph: A dictionary representing the graph, where keys are node identifiers and values are lists of tuples. Each tuple contains a neighboring node and the weight of the edge connecting to it. :param start: The starting node identifier. :param goal: The goal node identifier. :param heuristic: A callable function that estimates the cost from a given node to the goal node. :return: A list of node identifiers representing the shortest path from start to goal. # Priority queue to store (cost, current_node) open_set = [(0 + heuristic(start, goal), 0, start)] heapq.heapify(open_set) # Dictionary to store the cost to reach each node g_score = {start: 0} # Dictionary to store the path taken to reach each node came_from = {} while open_set: current_f_score, current_cost, current_node = heapq.heappop(open_set) # If we reached the goal, reconstruct the path and return it if current_node == goal: path = [] while current_node in came_from: path.append(current_node) current_node = came_from[current_node] path.append(start) return path[::-1] for neighbor, weight in graph.get(current_node, []): tentative_g_score = g_score[current_node] + weight # If this path to the neighbor is better, record it if tentative_g_score < g_score.get(neighbor, float(\'inf\')): came_from[neighbor] = current_node g_score[neighbor] = tentative_g_score f_score = tentative_g_score + heuristic(neighbor, goal) heapq.heappush(open_set, (f_score, tentative_g_score, neighbor)) return []"},{"question":"# Optimal Path in a Directed Acyclic Graph (DAG) You are given a weighted directed acyclic graph (DAG) where each edge has a non-negative weight. Your task is to find the shortest path from a given start node to an end node. Implement the function `shortest_path_dag` which takes in the following parameters: 1. `num_nodes` (int): The number of nodes in the graph. 2. `edges` (List of tuples): Each tuple represents an edge and is of the form `(u, v, weight)` where `u` is the starting node, `v` is the ending node, and `weight` is the non-negative weight of the edge. 3. `start_node` (int): The node from which the path starts. 4. `end_node` (int): The node at which the path ends. Your function should return the shortest path as a list of nodes from the start node to the end node. If there is no path from the start node to the end node, return an empty list. # Function Signature ```python def shortest_path_dag( num_nodes: int, edges: list, start_node: int, end_node: int ) -> list: ``` # Input Constraints * `num_nodes` is a positive integer. * `edges` is a list of tuples, and each tuple contains three integers `(u, v, weight)` where `0 <= u, v < num_nodes` and `weight >= 0`. * `start_node` and `end_node` are valid nodes within the range `0` to `num_nodes-1`. # Example ```python num_nodes = 6 edges = [ (0, 1, 5), (0, 2, 3), (1, 3, 6), (1, 2, 2), (2, 4, 4), (2, 5, 2), (2, 3, 7), (3, 4, -1), (4, 5, -2) ] start_node = 0 end_node = 5 shortest_path_dag(num_nodes, edges, start_node, end_node) # Expected Output: [0, 2, 5] ``` # Implementation Details - Use topological sorting to order the nodes in a way that ensures that for every directed edge u → v, u comes before v. - Initialize an array for storing the shortest distances from the start node to all other nodes. - Traverse the graph using the topologically sorted order, and calculate the shortest path from the start node to each node. - Backtrack through the shortest path distances to construct the optimal path from the start node to the end node.","solution":"from collections import defaultdict, deque def shortest_path_dag(num_nodes, edges, start_node, end_node): def topological_sort(num_nodes, edges): Helper function to generate a topological sort of the graph. in_degree = [0] * num_nodes adj_list = defaultdict(list) for u, v, weight in edges: adj_list[u].append((v, weight)) in_degree[v] += 1 zero_in_degree = deque([i for i in range(num_nodes) if in_degree[i] == 0]) topo_order = [] while zero_in_degree: node = zero_in_degree.popleft() topo_order.append(node) for neighbor, _ in adj_list[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree.append(neighbor) return topo_order def initialize_distances_and_predecessors(start_node, num_nodes): distances = [float(\'inf\')] * num_nodes predecessors = [-1] * num_nodes distances[start_node] = 0 return distances, predecessors # Topological sort topo_order = topological_sort(num_nodes, edges) distances, predecessors = initialize_distances_and_predecessors(start_node, num_nodes) adj_list = defaultdict(list) for u, v, weight in edges: adj_list[u].append((v, weight)) for node in topo_order: for neighbor, weight in adj_list[node]: if distances[node] + weight < distances[neighbor]: distances[neighbor] = distances[node] + weight predecessors[neighbor] = node # Reconstruct the shortest path from start_node to end_node if distances[end_node] == float(\'inf\'): return [] # No path exists path = [] current_node = end_node while current_node != -1: path.append(current_node) current_node = predecessors[current_node] path.reverse() return path"},{"question":"# Sum Of Distinct Positive Integers **Context**: Given an integer array, you are to calculate the sum of all distinct positive integers in the array. Duplicate positive integers should only be summed once, and negative integers or zeros should be ignored. **Objective**: Write a function that processes an integer array and returns the sum of all distinct positive integers. # Function Signature ```python def sum_of_distinct_positives(arr: list) -> int: Calculate the sum of all distinct positive integers in the given array. Parameters: - arr (list): A list of integers which may contain duplicates, negatives, and zeros. Returns: - int: The sum of distinct positive integers in the array. Examples: >>> sum_of_distinct_positives([1, 2, 2, 3, 4, 4, 5, -1, 0, 6]) 21 >>> sum_of_distinct_positives([10, 20, 30, -10, 10, 20, -30, 0, 40]) 100 >>> sum_of_distinct_positives([-1, -2, -3, -4, -5]) 0 >>> sum_of_distinct_positives([1, 1, 1, 1, 1]) 1 >>> sum_of_distinct_positives([]) 0 pass ``` # Constraints * Array length: 0 <= len(arr) <= 10^5 * Array elements: -10^9 <= arr[i] <= 10^9 * The function should handle the input efficiently, aiming for linear time complexity O(n) where n is the number of elements in the array. # Requirements * Complete the `sum_of_distinct_positives(arr)` function to achieve the objectives as described. * Ensure your implementation is clean and avoids using excessive memory.","solution":"def sum_of_distinct_positives(arr: list) -> int: Calculate the sum of all distinct positive integers in the given array. Parameters: - arr (list): A list of integers which may contain duplicates, negatives, and zeros. Returns: - int: The sum of distinct positive integers in the array. # Using a set to store distinct positive integers distinct_positives = set() # Iterate over the array and add positive integers to the set for num in arr: if num > 0: distinct_positives.add(num) # Return the sum of all integers in the set return sum(distinct_positives)"},{"question":"# Question You are required to implement a data structure that supports the following operations efficiently: 1. Insert an integer. 2. Remove an integer. 3. Return the median of the integer list. The median is defined as the middle value in a list of numbers. If the size of the list is even, the median is the average of the two middle numbers. # Function Requirements insert * **Input**: An integer `num` that should be added to the data structure. * **Output**: None. remove * **Input**: An integer `num` that should be removed from the data structure. * **Output**: None. * **Constraint**: If the integer `num` is not present in the data structure, ignore the removal request. find_median * **Input**: None. * **Output**: The median of the elements in the data structure as a float. # Constraints * The maximum possible number of elements in the data structure will not exceed `10^5`. * All elements will be within the range of `[-10^6, 10^6]`. * It is guaranteed that there will always be at least one element in the data structure when `find_median` is called. # Example ```python # Example structure usage # Create the data structure instance data_structure = MedianDataStructure() # Insert elements data_structure.insert(10) data_structure.insert(20) data_structure.insert(30) # Find the median median = data_structure.find_median() print(median) # Output should be 20.0 # Remove an element data_structure.remove(20) # Find the median again median = data_structure.find_median() print(median) # Output should be 20.0 (since there\'s only one element left) ``` # Implementation Notes: * An efficient data structure (e.g., two heaps - max-heap and min-heap) is expected to manage the operations. * Ensure the operations are optimized for large numbers of elements. * Handle edge cases like duplicate insertions or removals gracefully.","solution":"import heapq class MedianDataStructure: def __init__(self): self.max_heap = [] # Max-heap to store the lower half of the numbers self.min_heap = [] # Min-heap to store the upper half of the numbers def insert(self, num): # Invert the number to effectively simulate a max-heap using heapq if len(self.max_heap) == 0 or num <= -self.max_heap[0]: heapq.heappush(self.max_heap, -num) else: heapq.heappush(self.min_heap, num) self._balance_heaps() def remove(self, num): try: if num <= -self.max_heap[0]: index = self.max_heap.index(-num) self.max_heap[index] = self.max_heap[-1] self.max_heap.pop() if index < len(self.max_heap): heapq._siftup(self.max_heap, index) heapq._siftdown(self.max_heap, 0, index) else: index = self.min_heap.index(num) self.min_heap[index] = self.min_heap[-1] self.min_heap.pop() if index < len(self.min_heap): heapq._siftup(self.min_heap, index) heapq._siftdown(self.min_heap, 0, index) self._balance_heaps() except ValueError: pass # Ignore if the number is not in the structure def find_median(self): if len(self.max_heap) > len(self.min_heap): return float(-self.max_heap[0]) return (-self.max_heap[0] + self.min_heap[0]) / 2.0 def _balance_heaps(self): if len(self.max_heap) > len(self.min_heap) + 1: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) elif len(self.min_heap) > len(self.max_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap))"},{"question":"# Scenario You are a software engineer working on a system that models a fleet of delivery trucks. Each truck has a set of delivery jobs it can take up on any given day, but no truck can handle jobs that overlap in time. To optimize the allocation of delivery jobs, you need to determine the maximum number of non-overlapping jobs a truck can handle. # Task Write a function `max_non_overlapping_jobs(jobs: List[Tuple[int, int]]) -> int` that takes a list of jobs, represented as tuples of start and end times, and returns the maximum number of non-overlapping jobs that can be assigned to a single truck. # Input * **jobs**: A list of tuples where each tuple contains two integers `(start, end)` representing the start and end times of a job. `1 <= start < end <= 10^9` * The length of the list `jobs` will be at most `100,000`. # Output * Return an integer representing the maximum number of non-overlapping jobs that can be assigned to a single truck. # Function Signature ```python def max_non_overlapping_jobs(jobs: List[Tuple[int, int]]) -> int: pass ``` # Examples * `max_non_overlapping_jobs([(1, 3), (2, 5), (3, 6), (6, 8)])` should return `3`. * `max_non_overlapping_jobs([(1, 2), (2, 3), (3, 4), (4, 5)])` should return `4`. # Constraints * Your implementation should handle the upper limits efficiently, considering that the maximum length of the jobs list is `100,000` and each time value can be as large as `10^9`. # Notes * To achieve an optimal solution, consider using a greedy algorithm to select the maximum number of non-overlapping intervals. * Ensure that your solution efficiently handles the sorting and selection process to maintain performance within acceptable limits for big inputs.","solution":"from typing import List, Tuple def max_non_overlapping_jobs(jobs: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping jobs that can be assigned to a single truck. # Sort the jobs by ending time jobs.sort(key=lambda x: x[1]) # Initialize variables to keep track of the count of non-overlapping jobs count = 0 last_end_time = 0 # Iterate through sorted jobs and select non-overlapping jobs greedily for job in jobs: start, end = job if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"# Problem Statement Write a function `rotation_index` that determines the index at which a sorted, rotated array was rotated. A sorted, rotated array is an array that has been sorted in ascending order and then rotated some number of times (from 0 to n - 1, where n is the length of the array). The function should return -1 if the array is not rotated. # Input and Output Formats Input: * `nums` (list): A list of integers representing the rotated array. Output: * An integer representing the index at which the array was rotated. If the array is not rotated, return -1. # Constraints: * The array will contain at least one and at most (10^5) elements. * All elements in the array are unique. # Performance Requirements: * Your implementation should be optimized for performance, with a goal of O(log n) time complexity. # Examples: ```python >>> rotation_index([4, 5, 6, 7, 0, 1, 2]) 4 >>> rotation_index([0, 1, 2, 3, 4]) -1 >>> rotation_index([1]) 0 ``` # Additional Test Case: ```python >>> rotation_index([30, 40, 50, 10, 20]) 3 ``` # Edge Cases: 1. Empty array (although the minimum constraint is 1 element): ```python >>> rotation_index([]) -1 ``` 2. No rotation in a single element array: ```python >>> rotation_index([1]) 0 ``` # Implementation Requirements: * Handle the case where the array is empty by returning -1. * Ensure optimal performance by using a modified binary search to find the rotation index.","solution":"def rotation_index(nums): Determines the index at which a sorted, rotated array was rotated. Parameters: nums (list): A list of integers representing the rotated array. Returns: int: The index at which the array was rotated. If the array is not rotated, return -1. if not nums or len(nums) == 1: return 0 if nums else -1 low, high = 0, len(nums) - 1 # If the array is not rotated at all if nums[low] < nums[high]: return -1 while low <= high: mid = (low + high) // 2 if nums[mid] > nums[mid + 1]: return mid + 1 elif nums[mid] < nums[low]: high = mid - 1 else: low = mid + 1 return -1"},{"question":"Given a list of integers, write a function `smallest_missing_positive(nums: List[int]) -> int` that finds the smallest positive integer that is missing from the list. # Input: * A list of integers, where ( 1 leq text{len}(nums) leq 10^6 ). * The integers in the list can range from (-10^6) to (10^6) and are not necessarily sorted. # Output: * Single integer representing the smallest positive integer missing from the list. # Function Signature: ```python def smallest_missing_positive(nums: List[int]) -> int: pass ``` # Example: ```python >>> smallest_missing_positive([1, 2, 0]) 3 >>> smallest_missing_positive([3, 4, -1, 1]) 2 >>> smallest_missing_positive([7, 8, 9, 11, 12]) 1 ``` # Note: * The input list may contain negative numbers and duplicates. * The smallest positive integer is defined as the first missing integer greater than 0. # Explanation: * In the first example, the list contains ( 1 ) and ( 2 ), so the smallest positive integer missing is ( 3 ). * In the second example, the list does not contain ( 2 ) even though it has ( 1 ) and ( 3 ), so the function returns ( 2 ). * In the third example, the list does not contain any numbers less than or equal to ( 7 ), so the function returns ( 1 ).","solution":"from typing import List def smallest_missing_positive(nums: List[int]) -> int: nums = set(nums) smallest_positive = 1 while smallest_positive in nums: smallest_positive += 1 return smallest_positive"},{"question":"# Dijkstra\'s Shortest Path Algorithm Problem Statement You are given a directed graph represented as an adjacency list and a starting vertex. Your task is to implement Dijkstra\'s algorithm to find the shortest path from the starting vertex to all other vertices in the graph. If a vertex is unreachable from the starting vertex, the shortest path distance should be represented as infinity (`float(\'inf\')`). Function Signature ```python def dijkstra(graph: dict[str, list[tuple[str, int]]], start: str) -> dict[str, float]: pass ``` Expected Input and Output - **Input**: - A dictionary representing the adjacency list of a directed graph. Nodes are strings and edges are represented as a list of tuples with each tuple containing a node name and an integer weight, e.g., `{\'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'C\', 2), (\'D\', 5)], \'C\': [(\'D\', 1)], \'D\': []}`. - A string representing the starting vertex. - **Output**: A dictionary where the keys are the graph\'s nodes and the values are the shortest path distances from the starting vertex to each node. If a node is unreachable, its value is `float(\'inf\')`. Constraints - **Constraints**: - The graph will have no more than 100 nodes. - Each node name is a non-empty string. - The graph is connected, but some nodes may not be reachable from the starting vertex. Example ```python graph = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'C\', 2), (\'D\', 5)], \'C\': [(\'D\', 1)], \'D\': [] } start = \'A\' print(dijkstra(graph, start)) # Output: {\'A\': 0, \'B\': 1, \'C\': 3, \'D\': 4} ``` In this example, you should return the shortest path distances from the starting vertex \'A\' to all other vertices in the graph. If there is no path to a vertex, the distance should be `float(\'inf\')`. Performance Requirements - Implement the algorithm efficiently, with a preference for a time complexity of (O(E log V)), where (E) is the number of edges and (V) is the number of vertices. - Ensure the implementation handles cases where some vertices are unreachable from the starting point by correctly representing distances as `float(\'inf\')`.","solution":"import heapq def dijkstra(graph, start): Implement Dijkstra\'s algorithm to find the shortest path from the start node to all other nodes in a directed graph represented by an adjacency list. # Initialize the minimum distances dictionary distances = {vertex: float(\'inf\') for vertex in graph} distances[start] = 0 # Priority queue to manage the min heap for the current shortest paths priority_queue = [(0, start)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) # If the distance is greater than the recorded distance, continue if current_distance > distances[current_vertex]: continue # Explore the neighbors of the current vertex for neighbor, weight in graph[current_vertex]: distance = current_distance + weight # If a shorter path is found if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Problem Description You have been assigned to create a function that processes a list of integers to generate a new list that only contains the numbers which are both prime numbers and greater than 10. The function should gracefully handle any invalid input, such as non-integer elements or non-iterable input. # Function to Implement Write a Python function `filter_primes_over_ten(numbers: Any) -> Union[str, List[int]]:` that: 1. Validates the input: * If the input is not a list or contains non-integer elements, return the string \\"Error: Input should be a list of integers\\". 2. If the input is valid: * Filter out the primes greater than 10 from the list. * Return the filtered list. # Example ```python def filter_primes_over_ten(numbers: Any) -> Union[str, List[int]]: # Your implementation here # Example Usage print(filter_primes_over_ten([11, 12, 13, 4, 5, 19])) # Expected: [11, 13, 19] print(filter_primes_over_ten(\'12345\')) # Expected: \\"Error: Input should be a list of integers\\" print(filter_primes_over_ten([2, 3, \'a\', 17])) # Expected: \\"Error: Input should be a list of integers\\" ``` # Input * `numbers` (Any): Expected to be a list of integers. # Output * If the input is invalid, the function should return: * \\"Error: Input should be a list of integers\\" * If the input is valid, the function should return: * A list of integers containing only the prime numbers that are greater than 10. # Constraints * Use a helper function to check for prime numbers. * Prime numbers are greater than 1 and only divisible by 1 and themselves. * Edge cases and efficient handling of large lists should be considered. * The function should ensure proper input validation, filtering, and output without altering the original list.","solution":"from typing import Any, Union, List def is_prime(n: int) -> bool: Check if an integer n is prime. if n <= 1: return False if n == 2 or n == 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes_over_ten(numbers: Any) -> Union[str, List[int]]: Filter out the primes greater than 10 from the list of numbers. if not isinstance(numbers, list) or not all(isinstance(x, int) for x in numbers): return \\"Error: Input should be a list of integers\\" return [num for num in numbers if is_prime(num) and num > 10]"},{"question":"# Problem Statement You are given a list of words, and your task is to find the longest word in the list that can be constructed by utilizing other words from the list. Each word must be used exactly once to form the longest word. If there are multiple words of the same length, return the one that appears first in the list. # Function Signature ```python def longest_compound_word(words: List[str]) -> str: pass ``` # Input - `words` (List[str]): A list of distinct strings representing words. # Output - A string representing the longest word that can be constructed by concatenating other words from the list. # Constraints - 1 ≤ len(words) ≤ 10^4 - 1 ≤ len(words[i]) ≤ 100 - All words consist of lowercase English letters only. # Example ```python longest_compound_word([\\"cat\\", \\"cats\\", \\"catsdogcats\\", \\"dog\\", \\"dogs\\", \\"dogcatsdog\\"]) # Output: \\"catsdogcats\\" longest_compound_word([\\"rat\\", \\"ratcat\\", \\"cat\\", \\"ate\\", \\"rate\\", \\"ratcatdog\\", \\"dog\\"]) # Output: \\"ratcatdog\\" longest_compound_word([\\"a\\", \\"aa\\", \\"aaa\\", \\"aaaa\\"]) # Output: \\"aaaa\\" ``` # Notes 1. If no word can be formed by concatenating other words from the list, return an empty string. 2. The function should raise a `ValueError` if the input list is empty. 3. Ensure the function efficiently handles large inputs and checks all possible concatenations reliably.","solution":"def longest_compound_word(words): if not words: raise ValueError(\\"Input list should not be empty\\") word_set = set(words) def can_form(word, word_set): if word in word_set: return True for i in range(1, len(word)): if word[:i] in word_set and can_form(word[i:], word_set): return True return False compound_words = [] for word in words: word_set.remove(word) if can_form(word, word_set): compound_words.append(word) word_set.add(word) return max(compound_words, key=len, default=\'\') # Test cases for manual verification print(longest_compound_word([\\"cat\\", \\"cats\\", \\"catsdogcats\\", \\"dog\\", \\"dogs\\", \\"dogcatsdog\\"])) # Output: \\"catsdogcats\\" print(longest_compound_word([\\"rat\\", \\"ratcat\\", \\"cat\\", \\"ate\\", \\"rate\\", \\"ratcatdog\\", \\"dog\\"])) # Output: \\"ratcatdog\\" print(longest_compound_word([\\"a\\", \\"aa\\", \\"aaa\\", \\"aaaa\\"])) # Output: \\"aaaa\\""},{"question":"# Context You are given an implementation of a Binary Search Tree (BST) that enables efficient insertion, deletion, and search operations. This structure is essential for maintaining a dynamically ordered dataset. You are tasked with utilizing this structure, along with an understanding of its properties, to solve a related coding problem. # Problem Statement Given a Binary Search Tree (BST), write a function `find_kth_smallest_element(root: TreeNode, k: int) -> int` that returns the k-th smallest element in the BST. If k is out of bounds, raise an appropriate exception. # Input * `root` - The root node of the Binary Search Tree. * `k` - An integer representing the k-th position # Output * Returns the k-th smallest element in the BST. # Constraints * The BST is non-empty and contains at most 10^5 nodes. * The value of `k` is between 1 and the number of nodes in the tree. # Example ```python # Example tree: # 3 # / # 1 4 # # 2 root = TreeNode(3, TreeNode(1, None, TreeNode(2)), TreeNode(4)) print(find_kth_smallest_element(root, 1)) # Output: 1 print(find_kth_smallest_element(root, 2)) # Output: 2 print(find_kth_smallest_element(root, 3)) # Output: 3 print(find_kth_smallest_element(root, 4)) # Output: 4 ``` # Function Signature ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_kth_smallest_element(root: TreeNode, k: int) -> int: pass ``` # Hints 1. Consider an in-order traversal of the BST to get elements in sorted order, and then find the k-th smallest. 2. Alternatively, use an iterative approach with a stack to avoid recursion limits on large trees. 3. Ensure robust handling of edge cases, such as invalid k values.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_kth_smallest_element(root: TreeNode, k: int) -> int: Finds the k-th smallest element in the BST. def in_order_traversal(root): if not root: return [] # Traverse the left subtree, visit the root, then the right subtree return in_order_traversal(root.left) + [root.val] + in_order_traversal(root.right) # Perform in-order traversal and get the sorted elements sorted_elements = in_order_traversal(root) # k is 1-based, so k-1 will give the correct index if k < 1 or k > len(sorted_elements): raise ValueError(\\"k is out of bounds\\") return sorted_elements[k-1]"},{"question":"Implement a Simple Neural Network with PyTorch You are required to implement a simple fully connected neural network using PyTorch. The network should be capable of performing a binary classification task. The input data consists of feature vectors, and the output should be a binary classification result (0 or 1). # Function Signature ```python def simple_neural_network(train_data: np.ndarray, train_labels: np.ndarray, test_data: np.ndarray, input_dim: int, hidden_dim: int, output_dim: int, epochs: int, learning_rate: float) -> np.ndarray: ``` # Input * `train_data`: A numpy array of shape (m, d) representing the training data where `m` is the number of training samples and `d` is the dimensionality of each sample. * `train_labels`: A numpy array of shape (m,) representing the binary labels (0 or 1) for the training data. * `test_data`: A numpy array of shape (n, d) representing the test data where `n` is the number of test samples. * `input_dim`: An integer representing the number of input features (`d`). * `hidden_dim`: An integer representing the number of neurons in the hidden layer. * `output_dim`: An integer representing the number of output neurons (for binary classification, this should be 1). * `epochs`: An integer representing the number of epochs for training. * `learning_rate`: A float representing the learning rate for the optimizer. # Output * Returns a numpy array of shape (n,) where each element is the predicted binary label for the corresponding test data sample. # Constraints * `1 <= m <= 10000` * `1 <= n <= 10000` * `1 <= d <= 100` * `1 <= hidden_dim <= 1000` * `output_dim = 1` * `1 <= epochs <= 100` * `0.0001 <= learning_rate <= 1.0` # Example ```python import numpy as np train_data = np.array([[0.5, 1.0], [1.5, 2.0], [1.0, 1.5], [0.0, 0.5]]) train_labels = np.array([0, 1, 1, 0]) test_data = np.array([[0.5, 1.5], [1.0, 2.0]]) input_dim = 2 hidden_dim = 4 output_dim = 1 epochs = 10 learning_rate = 0.01 predictions = simple_neural_network(train_data, train_labels, test_data, input_dim, hidden_dim, output_dim, epochs, learning_rate) print(\\"Predictions:n\\", predictions) ``` # Expected Output ``` Predictions: [0, 1] ``` # Performance Requirements * The neural network should be able to handle datasets with sizes up to 10,000 training samples and 10,000 test samples efficiently. * The training process should complete in a reasonable time for large inputs. # Additional Notes * PyTorch 1.x should be used. * Use appropriate loss function for binary classification (e.g., Binary Cross Entropy Loss). * Use an appropriate optimizer for training (e.g., Adam or SGD). * Ensure that the network has one hidden layer with the specified number of neurons. * Apply appropriate activation functions, such as ReLU for hidden layers and Sigmoid for the output layer. * Handle the edge cases gracefully, ensuring the network is robust to variations in input parameters and dataset sizes.","solution":"import torch import torch.nn as nn import torch.optim as optim import numpy as np def simple_neural_network(train_data: np.ndarray, train_labels: np.ndarray, test_data: np.ndarray, input_dim: int, hidden_dim: int, output_dim: int, epochs: int, learning_rate: float) -> np.ndarray: # Define the neural network class SimpleNN(nn.Module): def __init__(self, input_dim, hidden_dim, output_dim): super(SimpleNN, self).__init__() self.fc1 = nn.Linear(input_dim, hidden_dim) self.relu = nn.ReLU() self.fc2 = nn.Linear(hidden_dim, output_dim) self.sigmoid = nn.Sigmoid() def forward(self, x): x = self.fc1(x) x = self.relu(x) x = self.fc2(x) x = self.sigmoid(x) return x # Convert inputs to tensors train_data_tensor = torch.FloatTensor(train_data) train_labels_tensor = torch.FloatTensor(train_labels).unsqueeze(1) test_data_tensor = torch.FloatTensor(test_data) # Initialize the model, loss function, and optimizer model = SimpleNN(input_dim, hidden_dim, output_dim) criterion = nn.BCELoss() optimizer = optim.Adam(model.parameters(), lr=learning_rate) # Train the model for epoch in range(epochs): model.train() # Forward pass outputs = model(train_data_tensor) loss = criterion(outputs, train_labels_tensor) # Backward pass and optimization optimizer.zero_grad() loss.backward() optimizer.step() # Test the model model.eval() with torch.no_grad(): predicted = model(test_data_tensor) predictions = (predicted.numpy() > 0.5).astype(int).flatten() return predictions"},{"question":"# Coding Question Task: You are given an array of positive integers representing the heights of buildings in a row. Each building can trap water after it rains. You need to calculate how much water can be trapped between the buildings. Write a function that takes an array of integers representing the heights and returns the total amount of trapped rainwater. Function Signature: ```python def trap_rainwater(heights: List[int]) -> int: pass ``` Input: * `heights` (List[int]): A list of integers where each integer represents the height of a building. Output: * The function should return an integer which is the total amount of trapped rainwater. Constraints: * `0 <= len(heights) <= 10^5` * `0 <= heights[i] <= 10^9` for each building height `heights[i]` Example: ```python print(trap_rainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])) ``` Expected Output: ``` 6 ``` Additional Example: ```python print(trap_rainwater([4, 2, 0, 3, 2, 5])) ``` Expected Output: ``` 9 ``` Performance Requirements: The solution should be optimized for both time and space complexity. Hints: 1. Use two pointers to traverse the array from both ends towards the center. 2. Accumulate water by finding the difference between the current building height and the minimum of the maximum heights to the left and right. 3. Think about how to efficiently keep track of the maximum heights from both ends.","solution":"from typing import List def trap_rainwater(heights: List[int]) -> int: if not heights: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] total_water = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, heights[left]) total_water += max(0, left_max - heights[left]) else: right -= 1 right_max = max(right_max, heights[right]) total_water += max(0, right_max - heights[right]) return total_water"},{"question":"# Implement Depth-First Search (DFS) on a Graph Given the adjacency list representation of an undirected graph, implement a function that performs a Depth-First Search (DFS) starting from a specified node. The function should return the nodes in the order they are visited during the search. # Input Format * An integer `n` indicating the number of nodes (0 ≤ n ≤ 1000). * A list of tuples representing the edges of the graph, each tuple contains two integers `(u, v)` indicating an undirected edge between nodes `u` and `v` (0 ≤ u, v < n). * An integer `start` indicating the starting node for the DFS (0 ≤ start < n). # Output Format * A list of integers representing the nodes in the order they are visited during the DFS. # Constraints * There will be no self-loops or multiple edges between any two nodes. * The graph may be disconnected, but the DFS should only visit nodes connected to the `start` node. # Example ```python def dfs(n, edges, start): from collections import defaultdict # Create the adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Helper function to perform DFS def dfs_util(node, visited): visited.append(node) for neighbor in sorted(graph[node]): # Visit neighbors in a sorted order for consistent output if neighbor not in visited: dfs_util(neighbor, visited) visited = [] dfs_util(start, visited) return visited # Example Usage: n = 5 edges = [(0, 1), (0, 2), (1, 3), (1, 4)] start = 0 print(dfs(n, edges, start)) # Output: [0, 1, 3, 4, 2] ``` # Notes - Ensure the implementation visits nodes in a consistent (e.g., sorted) manner to match the expected output. - Handle edge cases such as an empty graph or a graph where the start node has no connections.","solution":"def dfs(n, edges, start): from collections import defaultdict # Create the adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Helper function to perform DFS def dfs_util(node, visited, visited_set): visited.append(node) visited_set.add(node) for neighbor in sorted(graph[node]): # Visit neighbors in a sorted order for consistent output if neighbor not in visited_set: dfs_util(neighbor, visited, visited_set) visited = [] visited_set = set() dfs_util(start, visited, visited_set) return visited"},{"question":"# Problem Statement Given a string s, you are to implement a function `first_unique_letter(s)` which returns the first non-repeating character in the string. If all characters repeat or the string is empty, return an empty string. The function should ignore spaces, but they should not be considered as non-repeating letters. # Implementation Details Implement the following function: ```python def first_unique_letter(s: str) -> str: Find the first non-repeating character in a string ignoring spaces. Args: s (str): The input string. Returns: str: The first non-repeating character or an empty string if none exist. Examples: >>> first_unique_letter(\\"swiss\\") \'w\' >>> first_unique_letter(\\"hello world\\") \'h\' >>> first_unique_letter(\\"aabbcc\\") \'\' >>> first_unique_letter(\\"\\") \'\' pass ``` Input * `s`: A string, the input string (0 ≤ len(s) ≤ 1000) Output * A string, the first non-repeating character or an empty string if none exist. Constraints * The string `s` will contain only printable ASCII characters. * Spaces should be ignored in determining the first non-repeating character but will be present in the output string as part of the original input structure. # Points to Consider * Consider edge cases such as empty strings and strings where all characters repeat. * Ensure that spaces are ignored in checks but preserved in the output\'s structure when needed. * Optimize for performance, especially when `s` is closer to the upper limit of the allowed length. Performance Requirements * The function should complete in a reasonable time for any input size within constraints (0 ≤ len(s) ≤ 1000).","solution":"def first_unique_letter(s: str) -> str: Find the first non-repeating character in a string ignoring spaces. Args: s (str): The input string. Returns: str: The first non-repeating character or an empty string if none exist. Examples: >>> first_unique_letter(\\"swiss\\") \'w\' >>> first_unique_letter(\\"hello world\\") \'h\' >>> first_unique_letter(\\"aabbcc\\") \'\' >>> first_unique_letter(\\"\\") \'\' # Convert the input string into a list of characters to count frequencies while ignoring spaces char_counts = {} for char in s: if char != \' \': if char in char_counts: char_counts[char] += 1 else: char_counts[char] = 1 # Traverse again to find the first character with count 1 for char in s: if char != \' \' and char_counts.get(char, 0) == 1: return char # Return empty string if there is no non-repeating character return \'\'"},{"question":"# Generate Permutations of a String Background Permutation generation is a common computational problem that involves generating all possible arrangements of a set of elements, in this case, the characters of a given string. Task Implement a function `generate_string_permutations` that generates all unique permutations of a given string. This is crucial for applications requiring exhaustive generation of sequences, such as in solving puzzles or generating test cases. Requirements 1. Validate the input to ensure it is a non-empty string consisting of unique characters. 2. Implement the function `generate_string_permutations` to produce all possible unique permutations of the input string. 3. Return the permutations sorted lexicographically for consistency and to match expected outputs. Function Signature ```python def generate_string_permutations(s: str) -> List[str]: ``` Parameters * `s` (str): The input string consisting of unique alphabetical characters. Constraints * The input string will have a length of at most 8 characters. * The input will only contain uppercase or lowercase English letters. Example Usage ```python # Generate all permutations of the string \\"abc\\" permutations = generate_string_permutations(\\"abc\\") print(permutations) # Output: [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] # Generate all permutations of the string \\"abcd\\" permutations = generate_string_permutations(\\"abcd\\") print(permutations) # Output: [\\"abcd\\", \\"abdc\\", \\"acbd\\", \\"acdb\\", \\"adbc\\", \\"adcb\\", \\"bacd\\", \\"badc\\", \\"bcad\\", \\"bcda\\", \\"bdac\\", \\"bdca\\", # \\"cabd\\", \\"cadb\\", \\"cbad\\", \\"cbda\\", \\"cdab\\", \\"cdba\\", \\"dabc\\", \\"dacb\\", \\"dbac\\", \\"dbca\\", \\"dcab\\", \\"dcba\\"] ```","solution":"from itertools import permutations from typing import List def generate_string_permutations(s: str) -> List[str]: Generates all unique permutations of a given string. Parameters: s (str): The input string consisting of unique alphabetical characters. Returns: List[str]: A sorted list of all unique permutations of the input string. if not s or not s.isalpha() or len(s) != len(set(s)): raise ValueError(\\"Input must be a non-empty string of unique alphabetical characters.\\") perm = permutations(s) perm_list = sorted([\'\'.join(p) for p in perm]) return perm_list"},{"question":"# Task: You are tasked with writing a function to find the longest sequence of unique characters in a given string. The sequence should be contiguous and should contain no repeating characters. # Function Specification: ```python def longest_unique_sequence(text: str) -> str: Finds the longest contiguous sequence of unique characters in the given string and returns it. Parameters: text (str): The input string to search within. Returns: str: The longest sequence of unique characters. Examples: >>> longest_unique_sequence(\'abcabcbb\') \'abc\' >>> longest_unique_sequence(\'bbbbb\') \'b\' >>> longest_unique_sequence(\'pwwkew\') \'wke\' >>> longest_unique_sequence(\'\') \'\' >>> longest_unique_sequence(\'abcdabcdefghh\') \'abcdefgh\' # Your code here ``` # Requirements: 1. **Input**: - A string which can be of any length including zero. 2. **Output**: - The longest contiguous sequence of unique characters from the input string. 3. **Constraints**: - Handle varying input lengths efficiently. - Ensure the order of characters in the output matches their appearance in the input. 4. **Error Handling**: - If the input string is empty, return an empty string. # Scenario: In a software application, identifying the longest sequence of unique characters from a given string provides valuable insights for tasks such as password strength evaluation, data analysis, and pattern recognition. It is essential for ensuring reliability and security in user inputs and internal data processing. # Hint: Consider utilizing a sliding window approach to efficiently find the longest sequence of unique characters without resorting to checking every possible substring.","solution":"def longest_unique_sequence(text: str) -> str: Finds the longest contiguous sequence of unique characters in the given string and returns it. Parameters: text (str): The input string to search within. Returns: str: The longest sequence of unique characters. n = len(text) if n == 0: return \\"\\" max_len = 0 start = 0 max_start = 0 last_seen = {} for i, char in enumerate(text): if char in last_seen and last_seen[char] >= start: start = last_seen[char] + 1 last_seen[char] = i if i - start + 1 > max_len: max_len = i - start + 1 max_start = start return text[max_start:max_start + max_len]"},{"question":"# Vector Norm Implementation **Problem Statement:** As a software engineer, you often work with various mathematical computations, which include operations on vectors. One fundamental operation is calculating the norm of a vector. Your task is to implement a function that computes the Lp-Norm of a given vector. **Requirements:** 1. Implement a function `vector_norm` that takes as input a vector `vec` and a norm type `p`. 2. The function should return the Lp-Norm of the vector. 3. The function should handle edge cases such as zero vectors and different values of `p` including `p = 1`, `p = 2`, and `p = np.inf`. **Function Signature:** ```python def vector_norm(vec: np.ndarray, p: int) -> float: ... ``` **Input:** - `vec` : (N,) input vector. - `p` : An integer or np.inf, defining the type of norm to compute. **Output:** - Lp-Norm : A float representing the Lp-Norm of the vector `vec`. **Constraints:** - The input vector `vec` will have at least one element. - The value of `p` will be a positive integer or `np.inf`. **Example:** ```python import numpy as np vec1 = np.array([3, 4]) norm1 = vector_norm(vec1, 2) print(norm1) # Expected output: 5.0 (since it\'s the Euclidean norm) vec2 = np.array([1, 2, 3]) norm2 = vector_norm(vec2, 1) print(norm2) # Expected output: 6.0 (since it’s the sum of absolute values) vec3 = np.array([1, -1, 2, -2]) norm3 = vector_norm(vec3, np.inf) print(norm3) # Expected output: 2.0 (since it\'s the maximum absolute value) ``` **Note:** - Use NumPy for vector operations. - Ensure the function handles various input dimensions and different types of norms accurately. **Hints:** - For `p = 1`, the norm is the sum of the absolute values of the elements. - For `p = 2`, the norm is the square root of the sum of the squares of the elements (Euclidean norm). - For `p = np.inf`, the norm is the maximum absolute value among the elements.","solution":"import numpy as np def vector_norm(vec: np.ndarray, p: int) -> float: Computes the Lp-Norm of the given vector. Parameters: vec (np.ndarray): Input vector. p (int or float): Norm type, can be a positive integer or np.inf. Returns: float: The Lp-Norm of the vector. if p == 1: return np.sum(np.abs(vec)) elif p == 2: return np.sqrt(np.sum(vec**2)) elif p == np.inf: return np.max(np.abs(vec)) else: return np.sum(np.abs(vec)**p)**(1/p)"},{"question":"# Objective You have to implement a function that performs level-order traversal of a given binary tree and returns the result as a list of lists. Each sublist should represent the nodes at each level of the tree from top to bottom. # Problem Statement Level-order traversal of a binary tree visits all the nodes at each level from left to right, starting from the root. You are given a binary tree, and you need to write a function to return its level-order traversal. # Function Signature ```python def level_order_traversal(root: Node) -> List[List[int]]: pass ``` # Input * `root` (Node): The root node of the binary tree. It is guaranteed to be a valid binary tree node instance. # Output * Return the level-order traversal as a list of lists, where each sublist contains the values of the nodes at that level. # Constraints * The number of nodes in the tree is between `1` and `10^4`. # Performance Requirements * The function should run in `O(n)` time complexity and use `O(n)` space complexity, where `n` is the number of nodes in the tree. # Example Example 1 Constructed binary tree is: ``` 1 / 2 3 / 4 5 ``` * **Input**: `root = Node(1)` * After setting up the tree, `root.left = Node(2)`, `root.right = Node(3)`, `root.left.left = Node(4)`, `root.left.right = Node(5)`. * **Output**: `[[1], [2, 3], [4, 5]]` Example 2 Constructed binary tree is: ``` 1 / 2 / 3 ``` * **Input**: `root = Node(1)` * After setting up the tree, `root.left = Node(2)`, `root.left.left = Node(3)`. * **Output**: `[[1], [2], [3]]` # Additional Notes * Use a queue to facilitate the level-order traversal efficiently. * Consider edge cases like single-node trees and skewed trees to ensure the function handles them correctly. * Ensure that the function is both space and time-efficient to handle the upper limit of the constraints effectively.","solution":"from typing import List, Optional from collections import deque class Node: def __init__(self, val: int, left: \'Node\' = None, right: \'Node\' = None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[Node]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"# Coding Question: Packing Trucks with Pallets You are given a list of pallets with specific weights and a list of trucks, each with a particular weight capacity. Your task is to determine if it is possible to load all the pallets into the trucks such that no truck exceeds its weight capacity. You do not need to optimize for the minimum number of trucks used; simply check if all pallets can be assigned to trucks without exceeding their individual capacities. **Function Signature**: `def can_pack_pallets(pallets: List[int], trucks: List[int]) -> bool:` # Input: - A list of integers `pallets` representing the weight of each pallet. - A list of integers `trucks` representing the weight capacity of each truck. # Output: - A boolean: `True` if it is possible to pack all the pallets into the trucks without exceeding their weight capacities, `False` otherwise. # Example: ```python >>> can_pack_pallets([4, 8, 1, 4], [10, 10]) True >>> can_pack_pallets([4, 8, 1, 4], [8, 8]) False >>> can_pack_pallets([5, 5, 5, 5], [10, 10, 10, 10]) True ``` # Constraints: - All weights in `pallets` and `trucks` are positive integers. - The length of `pallets` and `trucks` can vary, but the total number of pallets and trucks will not exceed 10,000. - The algorithm should efficiently handle the constraints of up to 10,000 pallets and trucks combined.","solution":"from typing import List def can_pack_pallets(pallets: List[int], trucks: List[int]) -> bool: pallets.sort(reverse=True) trucks.sort(reverse=True) i, j = 0, 0 while i < len(pallets) and j < len(trucks): if pallets[i] <= trucks[j]: trucks[j] -= pallets[i] i += 1 else: j += 1 return i == len(pallets)"},{"question":"# Problem Statement You have been given the task to implement the `matrix_transpose` function, which receives a matrix (a list of lists) and returns its transpose. The transpose of a matrix is another matrix whose rows are the columns of the original. # Function Signature ```python def matrix_transpose(matrix: list[list[int]]) -> list[list[int]]: ``` # Input 1. `matrix` (list[list[int]]): A two-dimensional list representing the original matrix with `n` rows and `m` columns where `0 <= n, m <= 1000`. # Output A two-dimensional list representing the transposed matrix. # Constraints - The matrix contains integers. - The integers in the matrix will be in the range of `[-10^6, 10^6]`. # Example ```python assert matrix_transpose([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[1, 4, 7], [2, 5, 8], [3, 6, 9]] assert matrix_transpose([[2, 4], [6, 8], [10, 12]]) == [[2, 6, 10], [4, 8, 12]] assert matrix_transpose([[1], [2], [3]]) == [[1, 2, 3]] assert matrix_transpose([[1, 2, 3]]) == [[1], [2], [3]] ``` # Explanation 1. In the first example, the matrix `[[1, 2, 3], [4, 5, 6], [7, 8, 9]]` becomes `[[1, 4, 7], [2, 5, 8], [3, 6, 9]]`, where each row of the input matrix becomes each column of the output matrix. 2. In the second example, the input matrix `[[2, 4], [6, 8], [10, 12]]` has 3 rows and 2 columns, and the output matrix `[[2, 6, 10], [4, 8, 12]]` has 2 rows and 3 columns. 3. The third example provides a column vector `[[1], [2], [3]]`, which when transposed, becomes a row vector `[[1, 2, 3]]`. 4. The fourth example transposes a row vector `[[1, 2, 3]]` to a column vector `[[1], [2], [3]]`. # Implementation Note 1. Ensure that the function efficiently handles the matrix transformation without unnecessary computations. 2. The simplistic nature of the transpose operation should be reflected in a clear and concise implementation.","solution":"def matrix_transpose(matrix: list[list[int]]) -> list[list[int]]: Returns the transposed version of the input matrix. :param matrix: A list of lists where each inner list represents a row in the matrix. :return: A new list of lists representing the transposed matrix. if not matrix: return [] # Transpose the matrix return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]"},{"question":"Palindrome Number Check Scenario You are creating a utility for an educational application that helps students understand the concept of palindromes. Specifically, you need to check if a given integer is a palindrome when considering its digits. Task Implement the function `is_palindrome` that checks whether a given integer is a palindrome. Function Signature ```python def is_palindrome(number: int) -> bool: ``` Input * **number** (int): The integer to be checked. Output * **bool**: Return `True` if the integer is a palindrome, `False` otherwise. Constraints * The integer can be negative; a negative integer is never a palindrome. * The integer can be very large (up to 10^9). * Do not convert the integer to a string to determine if it is a palindrome. * Handle edge cases such as single-digit numbers and large positive integers. Example ```python number = 121 assert is_palindrome(number) == True number = -121 assert is_palindrome(number) == False number = 123 assert is_palindrome(number) == False number = 12321 assert is_palindrome(number) == True ```","solution":"def is_palindrome(number: int) -> bool: Checks whether a given integer is a palindrome. if number < 0: return False original_number = number reversed_number = 0 while number > 0: digit = number % 10 reversed_number = reversed_number * 10 + digit number = number // 10 return original_number == reversed_number"},{"question":"# Coding Assessment Question **Scenario**: You have been tasked with developing functionality for a text processing application that includes a feature to normalize string inputs. Part of this involves creating a function to remove all digits from a given string, ensuring that the resultant string contains only alphabetic characters and special characters. **Task**: Write a function `remove_digits` that: - Takes a single argument, `text`, which is a string. - Returns a new string where all digits (0-9) have been removed from the original `text`. **Input**: - A single string, `text`, which may contain alphabetic characters, digits, and special characters. **Output**: - A new string with all digits removed from the original `text`. **Constraints**: - The length of the input string `text` will not exceed 10^5 characters. - The removal of digits should be handled in O(n) time complexity. **Function Signature**: ```python def remove_digits(text: str) -> str: ``` **Examples**: ```python remove_digits(\\"abc123\\") # Expected output: \\"abc\\" remove_digits(\\"hello123world!\\") # Expected output: \\"helloworld!\\" remove_digits(\\"2021 is the year\\") # Expected output: \\" is the year\\" remove_digits(\\"no_digits_here\\") # Expected output: \\"no_digits_here\\" remove_digits(\\"394857!\\") # Expected output: \\"!\\" remove_digits(\\"1234567890\\") # Expected output: \\"\\" ``` Write comprehensive test cases to verify the correctness of your implementation. The function should pass all provided example cases, ensuring appropriate removal of digits while preserving all other characters.","solution":"def remove_digits(text: str) -> str: Removes all digits from the given string and returns the resultant string. Parameters: text (str): The input string which may contain alphabetic characters, digits, and special characters. Returns: str: A new string with all digits removed from the original string. return \'\'.join([char for char in text if not char.isdigit()])"},{"question":"# Find the Missing Number in an Arithmetic Progression You are given a list of integers that forms an arithmetic progression (AP) except for one missing number. An arithmetic progression is a sequence of numbers in which the difference between any two consecutive numbers is the same. Your task is to find the missing number in the sequence. Task: Write a function `find_missing_number(ap_sequence: List[int]) -> int` that takes a single argument as input: - `ap_sequence` (List[int]): The list of integers representing the arithmetic progression with one missing number. The function should return the missing number in the arithmetic progression. Input: - The input list will contain at least 3 integers and at most 1000 integers. - It is guaranteed that the list will have a valid arithmetic progression with exactly one number missing. Output: - Return an integer representing the missing number in the arithmetic progression. Examples: ```python >>> find_missing_number([2, 4, 8, 10]) 6 >>> find_missing_number([5, 10, 20, 25]) 15 >>> find_missing_number([1, 3, 7]) 5 >>> find_missing_number([10, 20, 40]) 30 >>> find_missing_number([100, 200, 400]) 300 ``` Constraints: - The function should handle different step sizes in the arithmetic progression. - Ensure the solution is efficient for handling lists with a length up to 1000 integers.","solution":"from typing import List def find_missing_number(ap_sequence: List[int]) -> int: This function takes a list of integers that forms an arithmetic progression except for one missing number. It returns the missing number in the sequence. :param ap_sequence: List[int] - List of integers representing an arithmetic progression with one number missing. :return: int - The missing number in the sequence. n = len(ap_sequence) # Sum of first n+1 terms of an arithmetic progression with step size d total_sum = (n + 1) * (ap_sequence[0] + ap_sequence[-1]) // 2 actual_sum = sum(ap_sequence) missing_number = total_sum - actual_sum return missing_number"},{"question":"# Coding Assessment Question: Managing a Custom Cache System Context: In a high-traffic web application, optimizing data retrieval efficiency is crucial. One common technique is implementing a caching mechanism that stores recently accessed data for quick retrieval. The task is to implement a Least Recently Used (LRU) Cache which evicts the least recently used item when the cache reaches its capacity. Your Task: Write a class called `LRUCache` that: 1. Has a constructor taking a single integer `capacity` as a parameter, representing the maximum number of items the cache can hold. 2. Provides two methods: - `get(key: int) -> int`: Returns the value of the key if it exists in the cache, otherwise returns -1. - `put(key: int, value: int) -> None`: Updates the value of the key if it already exists; otherwise, adds the key-value pair to the cache. If the cache is full, it should evict the least recently used item before adding the new pair. Constraints: * All keys and values are non-negative integers. * The capacity cannot be less than 1 or more than 10,000. * The number of `get` and `put` calls will not exceed 100,000. Function Signature: ```python class LRUCache: def __init__(self, capacity: int): Initializes the LRU cache with a given capacity. :param capacity: A positive integer specifying the maximum number of items the cache can hold. self.cache = {} # You may use other structures to assist you def get(self, key: int) -> int: Returns the value of the cache item associated with the given key, or -1 if the key is not present in the cache. :param key: The key to look up in the cache. :return: An integer representing the value of the key or -1 if the key is not found. # Implement this function def put(self, key: int, value: int) -> None: Inserts or updates the value of the key-value pair in the cache. If the cache reaches its capacity, it evicts the least recently used item. :param key: The key to insert/update in the cache. :param value: The value to associate with the key. :return: None # Implement this function ``` Example Usage: ```python # Initialize the LRU cache with capacity 2 cache = LRUCache(2) # Add keys and values to the cache cache.put(1, 1) cache.put(2, 2) # Retrieve values from the cache assert cache.get(1) == 1 # returns 1 # Overwrite or insert key-value pair cache.put(3, 3) # evicts key 2 # Retrieve values from the cache assert cache.get(2) == -1 # returns -1 (not found) assert cache.get(3) == 3 # returns 3 ``` # Notes: - Please ensure your implementation is efficient and handles edge cases like full capacity and empty cache appropriately. - Aim for an O(1) time complexity for both `get` and `put` operations. This problem emphasizes understanding of data structures (dictionaries, linked lists) and efficient algorithm design, aligning with the cognitive and technical challenges presented in the other coding assessment questions.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): Initializes the LRU cache with a given capacity. :param capacity: A positive integer specifying the maximum number of items the cache can hold. self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: Returns the value of the cache item associated with the given key, or -1 if the key is not present in the cache. :param key: The key to look up in the cache. :return: An integer representing the value of the key or -1 if the key is not found. if key not in self.cache: return -1 else: self.cache.move_to_end(key) return self.cache[key] def put(self, key: int, value: int) -> None: Inserts or updates the value of the key-value pair in the cache. If the cache reaches its capacity, it evicts the least recently used item. :param key: The key to insert/update in the cache. :param value: The value to associate with the key. :return: None if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False)"},{"question":"# Scenario: You are part of a development team that delivers dynamic data reports. Your task is to implement a data processing pipeline that handles numeric data streams by providing a running median of the numbers received. # Task: Write a Python class named `RunningMedian` that maintains a stream of numbers and allows for the retrieval of the median of the numbers seen so far. # Class Definition: 1. **RunningMedian()** - Initializes the object to manage the data stream. 2. **add_number(num: float) -> None** - Adds a new number to the stream. 3. **get_median() -> float** - Returns the median of the numbers added. # Input and Output Formats: - **Input**: - `num` (float): The number to be added to the stream. - **Output**: - After each call to `get_median`, returns a float representing the median. # Constraints: 1. Assume `num` can be an integer or float. 2. The class must handle dynamic, real-time updates efficiently. 3. Raises appropriate exceptions for invalid inputs. # Examples: - **Example 1**: ```python rm = RunningMedian() rm.add_number(1) rm.add_number(2) print(rm.get_median()) # Output: 1.5 rm.add_number(3) print(rm.get_median()) # Output: 2.0 ``` - **Example 2**: ```python rm = RunningMedian() rm.add_number(5) rm.add_number(10) rm.add_number(15) print(rm.get_median()) # Output: 10.0 ```","solution":"import heapq class RunningMedian: def __init__(self): self.low = [] # max heap to maintain the lower half elements self.high = [] # min heap to maintain the higher half elements def add_number(self, num: float) -> None: if len(self.low) == 0 or num <= -self.low[0]: heapq.heappush(self.low, -num) # use negative to simulate max heap else: heapq.heappush(self.high, num) # Balance the heaps if necessary if len(self.low) > len(self.high) + 1: heapq.heappush(self.high, -heapq.heappop(self.low)) elif len(self.high) > len(self.low): heapq.heappush(self.low, -heapq.heappop(self.high)) def get_median(self) -> float: if len(self.low) > len(self.high): return float(-self.low[0]) return (-self.low[0] + self.high[0]) / 2.0"},{"question":"# Coding Assessment Question: Imagine you are given the task to work with strings and detect patterns within them, using concepts of hashing and substring search. **Problem Statement:** You are provided with a long string. Your task is to find the longest substring that appears at least twice within the given string. To efficiently find such substrings, you need to implement a rolling hash mechanism. Your function should return the longest duplicated substring from the given string. If there are multiple substrings of the same maximum length, return any one of them. If no such substring exists, return an empty string. **Requirements:** 1. **longest_dup_substring(s: str) -> str**: Finds the longest duplicated substring in the given string. - Input: A string `s` containing lowercase English letters. - Output: The longest duplicated substring or an empty string if no such substring exists. **Input/Output Format:** - The `longest_dup_substring` function should return a string representing the longest duplicated substring. - If no such substring exists, the function should return an empty string. **Example:** ```python def longest_dup_substring(s): # Your implementation here # Example use cases assert longest_dup_substring(\\"banana\\") == \\"ana\\" assert longest_dup_substring(\\"abcd\\") == \\"\\" assert longest_dup_substring(\\"abcabc\\") == \\"abc\\" ``` **Constraints/Limitations:** - The length of the input string `s` will be between 1 and 10^5. - The input string `s` will contain only lowercase English letters (`a`-`z`).","solution":"def longest_dup_substring(s: str) -> str: def search(k): Search for a duplicate substring of length k using rolling hash. MOD = 2**63 - 1 BASE = 26 # Rolling hash with base 26 h = 0 for i in range(k): h = (h * BASE + ord(s[i]) - ord(\'a\')) % MOD # Set to store seen hashes seen = {h} power = pow(BASE, k, MOD) # BASE^k % MOD for i in range(1, len(s) - k + 1): h = (h * BASE + ord(s[i + k - 1]) - ord(\'a\')) % MOD h = (h - (ord(s[i - 1]) - ord(\'a\')) * power) % MOD if h in seen: return i seen.add(h) return -1 # Binary search for the length of the longest duplicate substring left, right = 1, len(s) start = -1 while left <= right: mid = (left + right) // 2 pos = search(mid) if pos != -1: start = pos left = mid + 1 else: right = mid - 1 return s[start:start + left - 1] if start != -1 else \\"\\""},{"question":"# Coding Assessment Question You need to implement a file system utility function for an operating system simulation project. The function should take paths as input and return the resolved absolute path, handling different cases like symbolic links, relative paths, and redundant elements like `..` and `.`. # Objective Write a function that takes a list of directory commands and returns the resultant absolute path in a simulated file system. Your program should handle symbolic links, special commands (like `..` and `.`), and absolute as well as relative paths. # Requirements 1. **Input**: - `commands` (List[str]): A list of directory commands. 2. **Output**: - Returns the absolute path (str). - If a command is invalid (e.g., trying to go up from the root directory or invalid syntax), raise a `ValueError` with an appropriate error message. 3. **Constraints**: - Assume the root directory is represented as `/`. - Symbolic links and special commands should be processed correctly to resolve the path. - Path components are case-sensitive. # Example Usage ```python >>> resolve_path([\\"/home/\\", \\"user/\\", \\"../docs/\\", \\"./\\", \\"file.txt\\"]) \'/home/docs/file.txt\' >>> resolve_path([\\"/home/user/docs\\", \\"../../var/log\\", \\".\\", \\"syslog\\"]) \'/var/log/syslog\' >>> resolve_path([\\"/\\", \\"..\\", \\"etc/\\", \\"hosts\\"]) ValueError: Invalid path: trying to go up from the root directory ``` # Implementation Requirements 1. Create a function `resolve_path(commands: List[str]) -> str`. 2. Handle the concatenation and normalization of path elements. 3. Support symbolic links and special path components, ensuring the final path is absolute and correctly resolved. 4. Raise appropriate errors for invalid commands or path navigation attempts. 5. Include several test cases to validate your implementation.","solution":"def resolve_path(commands): Resolves a list of directory commands to an absolute path. Args: commands (List[str]): A list of directory commands. Returns: str: The resolved absolute path. Raises: ValueError: If an invalid path is encountered. path_stack = [] for command in commands: # Process each part of the path considering it might contain multiple components directories = command.split(\'/\') for dir in directories: if dir == \'\' or dir == \'.\': # Ignore empty components or no-op components continue elif dir == \'..\': if not path_stack: raise ValueError(\'Invalid path: trying to go up from the root directory\') path_stack.pop() else: path_stack.append(dir) # Join the components to form the absolute path resolved_path = \'/\' + \'/\'.join(path_stack) return resolved_path"},{"question":"# Coding Assessment Question Scenario: A delivery drone needs to distribute packages across a city represented as a 2D grid. The drone can only move in the four cardinal directions (up, down, left, right) and must avoid no-fly zones. Each move has a uniform cost, and the goal is to deliver packages to specified locations in the least amount of time possible. Implement the Dijkstra\'s algorithm to find the shortest path from the starting point to each delivery location. Problem Statement: Develop an efficient implementation of Dijkstra\'s shortest path algorithm to navigate the drone from its starting location to each delivery point in the grid, considering no-fly zones. The algorithm should compute and return the shortest paths from the initial position to each goal position specified. Function Signature: ```python def dijkstra_delivery_routes( grid: list[list[int]], init: tuple[int, int], deliveries: list[tuple[int, int]], cost: int ) -> dict[tuple[int, int], list[tuple[int, int]]]: ... ``` Input: 1. **`grid` (list[list[int]]):** A 2D grid represented as a list of lists, where `0` indicates a free path, and `1` indicates a no-fly zone. 2. **`init` (tuple[int, int]):** A tuple representing the initial position `(x, y)` of the drone on the grid. 3. **`deliveries` (list[tuple[int, int]]):** A list of tuples where each tuple represents a delivery location `(x, y)` that the drone needs to reach. 4. **`cost` (int):** An integer representing the cost of moving from one cell to an adjacent free cell. Output: 1. **`routes` (dict[tuple[int, int], list[tuple[int, int]]]):** A dictionary where each key is a delivery location `(x, y)` and the corresponding value is a list of coordinates representing the shortest path from `init` to that delivery location. Constraints: * The grid only contains entries `0` and `1`. * The drone can only move to adjacent cells (left, right, up, down) that are free paths. * There may be multiple delivery locations to optimize routes for. * Handle edge cases such as unreachable delivery locations due to obstruction. * The function should handle grids of varying dimensions without assuming fixed sizes. Example Usage: ```python grid = [[0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0]] init = (0, 0) deliveries = [(4, 4), (2, 2), (3, 0)] cost = 1 routes = dijkstra_delivery_routes(grid, init, deliveries, cost) # Expected Output # routes = {(4, 4): [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (3, 4), (4, 4)], # (2, 2): [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)], # (3, 0): [(0, 0), (1, 0), (2, 0), (2, 1), (3, 1), (3, 2), (3, 0)]} ```","solution":"from heapq import heappop, heappush import sys def dijkstra_delivery_routes(grid, init, deliveries, cost): rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def dijkstra(start): heap = [(0, start)] distances = {start: 0} previous = {start: None} while heap: cur_cost, (x, y) = heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 0: next_cost = cur_cost + cost if (nx, ny) not in distances or next_cost < distances[(nx, ny)]: distances[(nx, ny)] = next_cost previous[(nx, ny)] = (x, y) heappush(heap, (next_cost, (nx, ny))) return previous def get_path(previous, target): path = [] while target is not None: path.append(target) target = previous[target] path.reverse() return path previous = dijkstra(init) routes = {} for target in deliveries: if target in previous: routes[target] = get_path(previous, target) else: routes[target] = None return routes"},{"question":"# Coding Assessment Question: Find the Odd Occurrence Number using XOR **Context**: In an array of integers, every integer except one will appear an even number of times. The goal is to identify the integer that appears an odd number of times using efficient computation. **Objective**: Write a function `find_odd_occurrence(numbers: List[int]) -> int` that returns the integer that appears an odd number of times in the given list `numbers`. **Function Signature**: ```python def find_odd_occurrence(numbers: List[int]) -> int: pass ``` # Input: - A list of integers `numbers` where each integer can range from `-10^6` to `10^6` and the length of the list can be up to `10^5`. # Output: - An integer that appears an odd number of times in the list. # Constraints: - There will always be exactly one integer that appears an odd number of times. - You must use the XOR operation to solve this problem efficiently. # Examples: ```python >>> find_odd_occurrence([1, 2, 3, 2, 3, 1, 3]) 3 >>> find_odd_occurrence([10, 20, 20, 10, 10]) 10 >>> find_odd_occurrence([4, 4, 4]) 4 >>> find_odd_occurrence([0, 0, 0, 1, 1]) 0 >>> find_odd_occurrence([-1, -1, -1, 2, 2]) -1 ``` # Additional Notes: 1. XOR operation properties can be utilized here: `a ^ a = 0` and `a ^ 0 = a`. 2. Iterate through the list and apply XOR operation to find the number appearing an odd number of times, utilizing its properties to cancel out even occurrences.","solution":"from typing import List def find_odd_occurrence(numbers: List[int]) -> int: This function takes a list of integers and returns the integer that appears an odd number of times using the XOR operator. result = 0 for number in numbers: result ^= number return result"},{"question":"# Matrix Exponentiation Matrix exponentiation is a useful technique in various fields, including computer graphics, physics simulations, and solving linear recurrences. Implement a function that raises a given square matrix to a specified integer power efficiently using matrix exponentiation. # Function Signature ```python def matrix_exponentiation(matrix: List[List[int]], power: int) -> List[List[int]]: pass ``` # Input - `matrix`: A list of lists of integers representing a square matrix. Each element of the list `matrix[i][j]` is the element in the i-th row and j-th column of the matrix. - `power`: An integer representing the exponent to which the matrix should be raised. # Output - A list of lists of integers representing the resulting matrix after raising the input matrix to the specified power. # Constraints - The size of the matrix (number of rows/columns) will be at most 50. - The exponent `power` will be a non-negative integer and can be as large as 10^9. - The matrix elements will be integers in the range `[-10^9, 10^9]`. # Example ```python # Example input matrix = [ [1, 1], [1, 0] ] power = 5 # Expected output result = matrix_exponentiation(matrix, power) # Result should be: [[8, 5], [5, 3]] ``` # Note - The implementation should be efficient to handle large exponents and matrix sizes. - Use techniques such as matrix multiplication and exponentiation by squaring to achieve the optimal time complexity. - Handle edge cases such as when the exponent is zero (which should return the identity matrix).","solution":"def matrix_exponentiation(matrix, power): def matrix_multiply(A, B): n = len(A) C = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): for k in range(n): C[i][j] += A[i][k] * B[k][j] return C def matrix_identity(n): identity = [[0] * n for _ in range(n)] for i in range(n): identity[i][i] = 1 return identity def matrix_pow(matrix, power): if power == 0: return matrix_identity(len(matrix)) elif power == 1: return matrix elif power % 2 == 0: half_pow = matrix_pow(matrix, power // 2) return matrix_multiply(half_pow, half_pow) else: return matrix_multiply(matrix, matrix_pow(matrix, power - 1)) return matrix_pow(matrix, power)"},{"question":"# LRU Cache Implementation An **LRU (Least Recently Used) Cache** is a type of data structure that maintains the most recently used items while discarding the least recently used ones when the capacity is reached. It provides efficient O(1) operations for both retrieving and adding items through the use of a combination of a doubly linked list and a hash map. Task Your task is to implement an LRU cache class and use it to manage caching of key-value pairs. Specifically, write a Python class `LRUCache` which can handle both `get` and `put` operations with the following requirements: - **get(key)**: Fetch the value corresponding to the key if present in the cache. If the key does not exist, return -1. - **put(key, value)**: Insert or update the value. If the capacity is reached, remove the least recently used item before inserting the new item. # Input 1. An integer `capacity` which represents the maximum number of items the cache can hold. 2. A list of operations in the form of tuples. Each tuple will be either `(\\"put\\", key, value)` or `(\\"get\\", key)`. # Output * For each \\"get\\" operation, output the value corresponding to the key or -1 if the key is not found. * No output for \\"put\\" operations. # Constraints * 1 ≤ capacity ≤ 1000 * -10^4 ≤ key, value ≤ 10^4 * Up to 10^5 operations # Example ```python cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) print(cache.get(1)) # Output: 1 cache.put(3, 3) print(cache.get(2)) # Output: -1 cache.put(4, 4) print(cache.get(1)) # Output: -1 print(cache.get(3)) # Output: 3 print(cache.get(4)) # Output: 4 ``` # Function Signature ```python class LRUCache: def __init__(self, capacity: int): # Your implementation here def get(self, key: int) -> int: # Your implementation here def put(self, key: int, value: int) -> None: # Your implementation here # Example usage: # cache = LRUCache(capacity) # Perform operations with cache.put() and cache.get() ``` # Notes * The LRUCache class should handle the internals such that it always adheres to the least recently used policy when adding/removing elements. * Utilize an appropriate data structure to ensure both `get` and `put` operations are optimized to run in O(1) time complexity.","solution":"class Node: def __init__(self, key, value): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.head = Node(0, 0) self.tail = Node(0, 0) self.head.next = self.tail self.tail.prev = self.head def _remove(self, node): prev_node = node.prev next_node = node.next prev_node.next = next_node next_node.prev = prev_node def _add(self, node): prev_node = self.tail.prev prev_node.next = node node.prev = prev_node node.next = self.tail self.tail.prev = node def get(self, key: int) -> int: if key in self.cache: node = self.cache[key] self._remove(node) self._add(node) return node.value return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self._remove(self.cache[key]) node = Node(key, value) self._add(node) self.cache[key] = node if len(self.cache) > self.capacity: lru = self.head.next self._remove(lru) del self.cache[lru.key]"},{"question":"# Fibonacci Sequence with Memoization Context: You are tasked with implementing a function to generate the n-th Fibonacci number. The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. Due to the exponential time complexity of the naive recursive approach, it\'s essential to use memoization to achieve efficient computation. Task: Write a function `fibonacci(n: int) -> int` that computes the n-th Fibonacci number using memoization. The function should store previously computed Fibonacci numbers to avoid redundant calculations. Input: * An integer `n` representing the position in the Fibonacci sequence (0-indexed). Output: * An integer representing the n-th Fibonacci number. Example: ```python def fibonacci(n: int) -> int: Example usage: >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(5) 5 >>> fibonacci(10) 55 ``` Constraints: * The input `n` will be a non-negative integer (`0 ≤ n ≤ 30`). **Edge Cases to consider**: * If `n` is 0, the function should return 0. * If `n` is 1, the function should return 1. Requirements: * Make sure your function correctly handles all valid and edge case inputs. * Use memoization to ensure the function runs efficiently for the given range of `n`.","solution":"def fibonacci(n): memo = {} def fib(m): if m in memo: return memo[m] if m <= 1: return m memo[m] = fib(m - 1) + fib(m - 2) return memo[m] return fib(n)"},{"question":"# Scenario You are developing a text processing tool that includes functionality for identifying and extracting hashtags from social media posts. Hashtags in these posts always start with a \'#\' symbol and consist of a sequence of alphanumeric characters. # Task Implement a function `extract_hashtags` that extracts all hashtags from a given list of strings. The function should return a list of unique hashtags found in the input, preserving the order of their first occurrence. # Function Signature ```python def extract_hashtags(posts: List[str]) -> List[str]: Extracts unique hashtags from a list of social media posts. :param posts: List of strings representing social media posts. :return: List of unique hashtags in the order of their first occurrence. pass ``` # Input - A list of strings, `posts`, where each string is a social media post containing alphanumeric characters and possibly hashtags. # Output - A list of unique strings, each string being a hashtag without the \'#\' symbol, in the order they first appeared in the posts. # Constraints - Each string in the input list will have a length of at most (10^3) characters. - The list of social media posts will have at most (10^4) posts. # Examples Example 1: ```python posts = [\\"#hello world\\", \\"This is a #test post\\", \\"#hello again\\"] print(extract_hashtags(posts)) # Output: [\'hello\', \'test\'] ``` Example 2: ```python posts = [\\"#fun #coding\\", \\"Let\'s do some #coding\\", \\"#fun times!\\"] print(extract_hashtags(posts)) # Output: [\'fun\', \'coding\'] ``` # Additional Requirements - Your solution should handle up to (10^4) posts efficiently. - Ensure that the extraction and de-duplication operations are optimized for performance.","solution":"import re from typing import List def extract_hashtags(posts: List[str]) -> List[str]: Extracts unique hashtags from a list of social media posts. :param posts: List of strings representing social media posts. :return: List of unique hashtags in the order of their first occurrence. hashtag_set = set() unique_hashtags = [] hashtag_pattern = re.compile(r\'#(w+)\') for post in posts: hashtags_in_post = hashtag_pattern.findall(post) for hashtag in hashtags_in_post: if hashtag not in hashtag_set: unique_hashtags.append(hashtag) hashtag_set.add(hashtag) return unique_hashtags"},{"question":"# Coding Question: Determine Rotational Inertia You are given the task of implementing a function that calculates the rotational inertia (moment of inertia) for a given solid object. The rotational inertia depends on the geometry of the object and the distribution of its mass. For a solid cylinder, the rotational inertia `I` can be calculated as: I = 0.5 * m * r^2 * (h / L) Where: - `m`: Mass of the cylinder (positive float). - `r`: Radius of the cylinder (positive float). - `h`: Height of the cylinder (positive float). - `L`: Total length of the cylinder\'s axis (positive float). Your task is to implement the function `rotational_inertia(mass, radius, height, length)` which calculates and returns the rotational inertia `I`. # Function Signature ```python def rotational_inertia(mass: float, radius: float, height: float, length: float) -> float: pass ``` # Input - `mass` (float): The mass of the cylinder (positive). - `radius` (float): The radius of the cylinder (positive). - `height` (float): The height of the cylinder (positive). - `length` (float): The total length of the cylinder\'s axis (positive). # Output - Returns a single float: The rotational inertia in kg·m^2. # Constraints - All numeric values will be provided within a physically meaningful range. # Edge Cases - Handle cases where the input parameters are invalid (e.g., negative values for mass, radius, height, or length) by raising a `ValueError` with an appropriate error message. # Example ```python >>> rotational_inertia(2, 0.5, 1, 2) 0.125 >>> rotational_inertia(4, 1, 2, 3) 1.3333333333333333 >>> rotational_inertia(10, 0.4, 1, 1) 0.8 >>> rotational_inertia(-5, 0.5, 1, 2) Traceback (most recent call last): ... ValueError: mass, radius, height, and length must all be positive. ```","solution":"def rotational_inertia(mass: float, radius: float, height: float, length: float) -> float: if mass <= 0 or radius <= 0 or height <= 0 or length <= 0: raise ValueError(\\"mass, radius, height, and length must all be positive.\\") return 0.5 * mass * radius * radius * (height / length)"},{"question":"**Context**: You are developing a feature for an online bookstore to help customers find books effectively. This feature will allow customers to filter books based on a combination of genres and author preferences. Each book can belong to multiple genres, and customers have different author preferences. **Task**: Implement a function to filter books based on a list of preferred genres and a list of preferred authors. The function will return a list of book titles that match at least one genre from the preferred genres list and exactly match the preferred author. # Requirements: - Implement a function named `filter_books` in Python. - The inputs will be: - `books`: A list of dictionaries where each dictionary represents a book with the following keys: - `title` (str): The title of the book. - `genres` (list of str): A list of genres the book belongs to. - `author` (str): The author of the book. - `preferred_genres`: A list of strings representing the preferred genres. - `preferred_authors`: A list of strings representing the preferred authors. # Function Signature: ```python def filter_books( books: list[dict], preferred_genres: list[str], preferred_authors: list[str] ) -> list[str]: pass ``` # Example: ```python >>> books = [ ... {\\"title\\": \\"Book A\\", \\"genres\\": [\\"Fiction\\", \\"Fantasy\\"], \\"author\\": \\"Author 1\\"}, ... {\\"title\\": \\"Book B\\", \\"genres\\": [\\"Non-Fiction\\", \\"History\\"], \\"author\\": \\"Author 2\\"}, ... {\\"title\\": \\"Book C\\", \\"genres\\": [\\"Romance\\", \\"Fiction\\"], \\"author\\": \\"Author 1\\"}, ... {\\"title\\": \\"Book D\\", \\"genres\\": [\\"Sci-Fi\\", \\"Adventure\\"], \\"author\\": \\"Author 3\\"}, ... ] >>> preferred_genres = [\\"Fiction\\", \\"Sci-Fi\\"] >>> preferred_authors = [\\"Author 1\\", \\"Author 3\\"] >>> filter_books(books, preferred_genres, preferred_authors) [\\"Book A\\", \\"Book C\\", \\"Book D\\"] >>> preferred_genres = [\\"Non-Fiction\\"] >>> preferred_authors = [\\"Author 2\\"] >>> filter_books(books, preferred_genres, preferred_authors) [\\"Book B\\"] ``` # Additional Constraints: - A book must match at least one of the genres in `preferred_genres`. - A book must exactly match one of the authors in `preferred_authors`. - Return the book titles in the order they appear in the input list of books.","solution":"def filter_books(books, preferred_genres, preferred_authors): Filters books based on preferred genres and authors. Args: books: list of dictionaries, where each dictionary has following keys: - title (str): The title of the book - genres (list of str): A list of genres the book belongs to - author (str): The author of the book preferred_genres: list of str, genres preferred by the user preferred_authors: list of str, authors preferred by the user Returns: list of str : titles of books that match the criteria filtered_books = [] for book in books: if book[\'author\'] in preferred_authors and any(genre in preferred_genres for genre in book[\'genres\']): filtered_books.append(book[\'title\']) return filtered_books"},{"question":"# Coding Challenge: Memorize Dynamic Programming Paths Context In computer science, dynamic programming (DP) is a method for solving complex problems by breaking them down into simpler subproblems. It is applicable when the problem can be divided into overlapping subproblems that can be stored or \\"memorized\\" to avoid redundant calculations. Task Implement the `DPPathsCounter` class to solve a path-counting problem using dynamic programming. You will complete the following key methods: 1. **`count_paths`** - This counts the number of ways to reach the bottom-right corner of an `m x n` grid starting from the top-left corner, moving only right or down. 2. **`valid_input`** - Validates that the grid size parameters are positive integers. 3. **Helper Methods**: - `initialize_dp_table` - Initializes the DP table with base cases. - `compute_paths` - Fills in the DP table based on the recursive formula. Requirements 1. **Function Signatures**: - `count_paths`: `(self, m: int, n: int) -> int` - `valid_input`: `(self, m: int, n: int) -> bool` 2. **Input/Output**: - Input: Dimensions of the grid `m` (rows) and `n` (columns). - Output: The number of unique paths from the top-left to the bottom-right of the grid. 3. **Performance**: - Ensure that the solution efficiently uses memory and reduces unnecessary computations through DP. Example ```python dp_counter = DPPathsCounter() print(dp_counter.count_paths(3, 3)) # Output expected: 6 print(dp_counter.count_paths(4, 4)) # Output expected: 20 ``` ```python class DPPathsCounter: def __init__(self): pass def valid_input(self, m: int, n: int) -> bool: Check if the input values for the grid size are valid (i.e., positive integers) return m > 0 and n > 0 def initialize_dp_table(self, m: int, n: int) -> list[list[int]]: Initialize the DP table with base cases. The first row and the first column should be set to 1 since there is only one way to reach any cell in the first row or first column. dp = [[1] * n for _ in range(m)] return dp def compute_paths(self, dp: list[list[int]], m: int, n: int) -> int: Fill in the dp table using the formula: dp[i][j] = dp[i-1][j] + dp[i][j-1] for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1] def count_paths(self, m: int, n: int) -> int: Count the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid. if not self.valid_input(m, n): raise ValueError(\\"Invalid grid dimensions\\") dp = self.initialize_dp_table(m, n) return self.compute_paths(dp, m, n) if __name__ == \\"__main__\\": import doctest dp_counter = DPPathsCounter() print(dp_counter.count_paths(3, 3)) # Output expected: 6 print(dp_counter.count_paths(4, 4)) # Output expected: 20 doctest.testmod() ```","solution":"class DPPathsCounter: def __init__(self): pass def valid_input(self, m: int, n: int) -> bool: Check if the input values for the grid size are valid (i.e., positive integers) return m > 0 and n > 0 def initialize_dp_table(self, m: int, n: int) -> list[list[int]]: Initialize the DP table with base cases. The first row and the first column should be set to 1 since there is only one way to reach any cell in the first row or first column. dp = [[1] * n for _ in range(m)] return dp def compute_paths(self, dp: list[list[int]], m: int, n: int) -> int: Fill in the dp table using the formula: dp[i][j] = dp[i-1][j] + dp[i][j-1] for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1] def count_paths(self, m: int, n: int) -> int: Count the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid. if not self.valid_input(m, n): raise ValueError(\\"Invalid grid dimensions\\") dp = self.initialize_dp_table(m, n) return self.compute_paths(dp, m, n)"},{"question":"# Array Rotation Problem Statement: Write a function `rotate_array` that rotates the elements of an array to the right by `n` positions. Elements that are shifted beyond the length of the array are wrapped around to the beginning. Input: - A list of integers, `arr` (0 ≤ len(arr) ≤ 10^5), representing the array to be rotated. - An integer `n` (0 ≤ n ≤ 10^5), representing the number of positions to rotate the array. Output: - The list of integers after rotation. Constraints: - The input list `arr` can be empty. - The value of `n` can be greater than the length of the array. - The solution should be efficient in terms of time and space complexity. Example: **Input:** ```python [1, 2, 3, 4, 5], 2 ``` **Output:** ```python [4, 5, 1, 2, 3] ``` **Input:** ```python [1, 2, 3], 0 ``` **Output:** ```python [1, 2, 3] ``` Notes: - A rotation by `n` positions means that each element of the array is moved `n` positions to the right. - If `n` is 0 or a multiple of the length of the array, the array should remain unchanged. - Consider edge cases like empty arrays and when `n` exceeds the length of the array.","solution":"def rotate_array(arr, n): Rotates the array `arr` to the right by `n` positions. if not arr: return arr n = n % len(arr) return arr[-n:] + arr[:-n]"},{"question":"# Question Context: You are working with sequences of numbers and need to manipulate them to find a specific sum. The problem you must solve involves creating a sequence of natural numbers such that the sequence meets specific criteria and the sum of its elements achieves a target value. Task: Write a Python function `find_sequence(target: int, length: int) -> List[int]` that receives two integers: `target` and `length`. The function should return a list of length `length` whose elements are natural numbers such that the sum of the elements is equal to `target`. Input: - `target` (int): An integer representing the desired sum of the sequence. (0 ≤ `target` ≤ 10,000) - `length` (int): An integer representing the length of the sequence. (1 ≤ `length` ≤ 100) Output: - Return a list of integers of length `length` whose sum equals `target`. If there are multiple valid sequences, you can return any one of them. If no valid sequence exists, return an empty list. Constraints: - The sequence should consist of natural numbers (1, 2, 3, ...). Example: ```python assert find_sequence(15, 5) == [3, 3, 3, 3, 3] # or any other valid sequence that sums to 15 assert find_sequence(10, 2) == [5, 5] assert find_sequence(7, 3) == [1, 2, 4] assert find_sequence(100, 50) # multiple correct answers possible ``` Note: The function should ensure that natural numbers are used to form the sequence and it should attempt to balance the values in the sequence as much as possible.","solution":"from typing import List def find_sequence(target: int, length: int) -> List[int]: if target < length: return [] base_value = target // length remainder = target % length sequence = [base_value + 1] * remainder + [base_value] * (length - remainder) return sequence"},{"question":"# Problem Statement You are required to implement a function `transpose_matrix_diagonal` that takes a square matrix and returns the matrix obtained by transposing it along its diagonal. In a diagonal transpose, the element at position `(i, j)` swaps places with the element at position `(j, i)`. # Function Signature ```python def transpose_matrix_diagonal(matrix: List[List[int]]) -> List[List[int]]: pass ``` # Input * A square matrix ( text{matrix} ) represented as a list of lists of integers, where ( 1 leq |matrix|, |matrix[i]| leq 500 ) and each sublist has the same length as the outer list, i.e., the rows and columns are equal. # Output * The transposed matrix. # Constraints * You must transpose the matrix in place. * Do not use Python\'s built-in transpose functions or utilities. # Example ```python assert transpose_matrix_diagonal([[1, 2], [3, 4]]) == [[1, 3], [2, 4]] assert transpose_matrix_diagonal([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[1, 4, 7], [2, 5, 8], [3, 6, 9]] assert transpose_matrix_diagonal([[5]]) == [[5]] assert transpose_matrix_diagonal([[7, 8], [-3, 4]]) == [[7, -3], [8, 4]] assert transpose_matrix_diagonal([[12, 24, 35], [46, 57, 68], [79, 80, 91]]) == [[12, 46, 79], [24, 57, 80], [35, 68, 91]] ``` # Explanation * The function `transpose_matrix_diagonal` should swap the elements at positions `(i, j)` and `(j, i)` for all ( i leq j ) to ensure the transposition along the diagonal. * Given the square matrix properties, the function will traverse half of the matrix elements to perform the swap, thus achieving the desired transposition in place. * This process ensures an efficient transformation of the matrix into its diagonally transposed form.","solution":"from typing import List def transpose_matrix_diagonal(matrix: List[List[int]]) -> List[List[int]]: n = len(matrix) for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] return matrix"},{"question":"# Coding Assessment Question You are tasked with writing a Python function that demonstrates the understanding of dictionary manipulation and string formatting to generate a summary report from a list of dictionaries representing sales data. Specifically, you will be creating a report that summarizes the total quantity sold for each unique product. Requirements * Write a function `generate_sales_report(sales_data: List[Dict[str, Any]]) -> str` that takes a list of dictionaries and returns a formatted string as the sales report. * Each dictionary in the list will contain the following keys: - `product` (str): The name of the product. - `quantity` (int): The number of units sold. * The function should aggregate the total quantity sold for each unique product and generate a summary report. Input * `sales_data` (List[Dict[str, Any]]): A list of dictionaries, where each dictionary represents a sale record. Output * A formatted string representing the summary report. Each line in the report should have the product name and its total quantity sold, separated by a colon. Constraints * The function should handle cases where the sales data list is empty, returning an appropriate message like \\"No sales data available.\\" * Ensure proper handling of invalid data, such as negative quantities. Performance Requirements * The function should be efficient enough to handle lists with up to 10,000 sale records without significant delays. Example ```python sales_data = [ {\\"product\\": \\"apple\\", \\"quantity\\": 10}, {\\"product\\": \\"banana\\", \\"quantity\\": 5}, {\\"product\\": \\"apple\\", \\"quantity\\": 7}, {\\"product\\": \\"orange\\", \\"quantity\\": 3} ] report = generate_sales_report(sales_data) print(report) ``` Expected Output: ``` apple: 17 banana: 5 orange: 3 ``` Submission Please submit a Python file containing the implementation of the `generate_sales_report` function. Include appropriate error handling, comments explaining important sections of your code, and any assumptions you\'ve made.","solution":"from typing import List, Dict, Any def generate_sales_report(sales_data: List[Dict[str, Any]]) -> str: # Check for empty sales data if not sales_data: return \\"No sales data available.\\" # Dictionary to store aggregated quantities of each product product_totals = {} # Iterate through each sale record in the list for sale in sales_data: product = sale.get(\\"product\\") quantity = sale.get(\\"quantity\\", 0) # Validate data: Ensure product is a string and quantity is a non-negative integer if not isinstance(product, str) or not isinstance(quantity, int) or quantity < 0: return \\"Invalid sales data encountered.\\" # Accumulate quantity for each product if product in product_totals: product_totals[product] += quantity else: product_totals[product] = quantity # Generate report string report_lines = [f\\"{product}: {quantity}\\" for product, quantity in product_totals.items()] return \\"n\\".join(report_lines)"},{"question":"Task: Develop a CSV Data Anonymizer Scenario You are tasked with creating a tool that anonymizes certain columns of a CSV file. The script should replace data in specified columns with anonymized values such as hashed strings. This is crucial for maintaining privacy when sharing datasets. Requirements 1. **Function Implementation**: Implement the function `anonymize_csv(input_file: str, output_file: str, columns_to_anonymize: List[str]) -> None` - **Input**: - `input_file`: A string representing the path to the input CSV file. - `output_file`: A string representing the path to the output CSV file. - `columns_to_anonymize`: A list of column names (List[str]) that should be anonymized. - **Output**: None. The function should write the anonymized data to a new CSV file specified by `output_file`. 2. **Constraints**: - Use SHA-256 hashing algorithm for anonymization. - Handle edge cases such as missing columns in the input CSV file, empty cells, and very large datasets. - Ensure the output CSV has the same structure as the input but with anonymized data in specified columns. 3. **Performance Requirements**: - The function should efficiently handle large CSV files. - Minimize memory usage to avoid excessive resource consumption. Example Usage ```python input_file = \\"data.csv\\" output_file = \\"anonymized_data.csv\\" columns_to_anonymize = [\\"email\\", \\"phone_number\\"] anonymize_csv(input_file, output_file, columns_to_anonymize) # The output file \'anonymized_data.csv\' will have its \'email\' and \'phone_number\' columns anonymized. ``` # Additional Considerations - Ensure that the original format of the CSV (e.g., delimiter, header presence) is preserved in the anonymized output. - Testing with various types and sizes of CSV files, including corner cases such as missing or empty columns, to ensure robust performance. - Appropriate error handling to inform the user of any issues during the execution. This new question maintains the same complexity and depth as the sample questions, requiring the understanding of file handling, data processing, and security considerations. This makes it a fitting addition to the original set.","solution":"import csv import hashlib from typing import List def anonymize_csv(input_file: str, output_file: str, columns_to_anonymize: List[str]) -> None: Anonymizes specified columns in a CSV file by hashing their values. Parameters: input_file (str): Path to the input CSV file. output_file (str): Path to the output CSV file. columns_to_anonymize (List[str]): List of column names to be anonymized. with open(input_file, mode=\'r\') as infile, open(output_file, mode=\'w\', newline=\'\') as outfile: reader = csv.DictReader(infile) writer = csv.DictWriter(outfile, fieldnames=reader.fieldnames) writer.writeheader() for row in reader: for column in columns_to_anonymize: if column in row and row[column]: # Hash the value of the column row[column] = hashlib.sha256(row[column].encode(\'utf-8\')).hexdigest() writer.writerow(row)"},{"question":"# Introduction An anagram is a word formed by rearranging the letters of another, such as \\"listen\\" and \\"silent\\". However, an interesting variant is to form an anagram with at most one odd character count. # Task Write a function named `can_form_palindromic_anagram(string: str) -> bool` that checks if the given string can be rearranged to form a palindromic anagram. A palindromic anagram is an anagram that can also be a palindrome when rearranged. # Requirements * **Function Signature**: `def can_form_palindromic_anagram(string: str) -> bool` * **Input**: A single string `string` containing any lowercase and uppercase alphabetic characters with optional surrounding whitespace. * **Output**: A boolean indicating whether the string can be rearranged to form a palindromic anagram. # Constraints 1. Leading or trailing spaces should be ignored. 2. Return `False` if the input string is an empty string or contains only spaces. 3. The check should be case-insensitive (i.e., \\"Level\\" and \\"level\\" should be treated the same). 4. If the initial string is `None`, return `False`. 5. Consider only alphabetic inputs. 6. Do not use any external libraries for string manipulations. # Examples ```python >>> can_form_palindromic_anagram(\\"civic\\") True >>> can_form_palindromic_anagram(\\"ivicc\\") True >>> can_form_palindromic_anagram(\\"hello\\") False >>> can_form_palindromic_anagram(\\"AaBbCc\\") True >>> can_form_palindromic_anagram(\\"Taco cat\\") True >>> can_form_palindromic_anagram(\\" \\") False >>> can_form_palindromic_anagram(None) False ``` # Additional Notes * Test your function thoroughly with various test cases including edge cases for a robust solution. * Assume the caller will pass strings that are only alphabetic, so validation of content is not necessary beyond handling the described edge cases.","solution":"def can_form_palindromic_anagram(string: str) -> bool: if string is None: return False # Remove leading and trailing spaces string = string.strip() # Return False if the string is empty after stripping spaces if not string: return False # Convert to lower case to make the check case insensitive string = string.lower() # Count the frequency of each character char_count = {} for char in string: if char.isalpha(): if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Check the number of characters with odd counts odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 # For a string to be rearranged to form a palindromic anagram, # there should be at most one character with an odd count return odd_count <= 1"},{"question":"**Array Partitioning for Equal Sums** You are given an integer array `nums` containing `n` distinct elements. Write a function to determine if it is possible to partition the array into two subsets such that the sum of elements in both subsets is equal. Implement the function `can_partition(nums: List[int]) -> bool` that returns `True` if you can partition the array into two subsets with equal sum, otherwise return `False`. # Constraints: - 1 ≤ n ≤ 200 - 1 ≤ nums[i] ≤ 1000 # Input: A list `nums` with `n` integers representing the array elements. # Output: A boolean value representing whether it\'s possible to partition the array into two subsets with equal sum. # Example: ```python def can_partition(nums: List[int]) -> bool: Determine if it\'s possible to partition the array into two subsets with equal sum. Args: nums (List[int]): The list of integers. Returns: bool: True if partitioning is possible, otherwise False. # Your code here ``` # Test Cases: ```python assert can_partition([1, 5, 11, 5]) == True # [1, 5, 5] and [11] assert can_partition([1, 2, 3, 5]) == False # No possible partition assert can_partition([4, 4, 4, 4]) == True # [4, 4] and [4, 4] assert can_partition([2, 2, 1, 1]) == True # [2, 1] and [2, 1] assert can_partition([1, 1, 1, 1, 1, 1, 1]) == False # No possible partition to make equal sum subsets ``` # Explanation: - For `nums = [1, 5, 11, 5]`, the array can be partitioned into subsets `[1, 5, 5]` and `[11]`, both summing to 11. - For `nums = [1, 2, 3, 5]`, it is not possible to partition the array into subsets with equal sum as no such subset exists. - For `nums = [4, 4, 4, 4]`, the array can be partitioned into `[4, 4]` and `[4, 4]`, both summing to 8. - For `nums = [2, 2, 1, 1]`, the array can be partitioned into `[2, 1]` and `[2, 1]`, both summing to 3. You may assume that the input array can be processed for this partitioning within reasonable runtime limits. Consider edge cases and performance implications of your algorithm.","solution":"from typing import List def can_partition(nums: List[int]) -> bool: Determine if it\'s possible to partition the array into two subsets with equal sum. Args: nums (List[int]): The list of integers. Returns: bool: True if partitioning is possible, otherwise False. total_sum = sum(nums) # If total sum is odd, it\'s not possible to partition into two equal sum subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # DP array to track which sums are possible with subsets so far dp = [False] * (target + 1) dp[0] = True for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]"},{"question":"# Prime Number Matrix Objective Create a function that identifies the largest prime number in each row of a given matrix and replaces all other elements in that row with zero. Problem Statement Given a matrix of integers, write a function to find the largest prime number in each row. Replace all non-prime numbers and smaller prime numbers in that row with zeros, keeping only the largest prime number. Input and Output * **Input Format**: - An integer (M) denoting the number of rows in the matrix. - An integer (N) denoting the number of columns in the matrix. - An (M times N) matrix of integers. * **Output Format**: - An (M times N) matrix with only the largest prime number retained in each row. Constraints 1. (1 leq M, N leq 100) 2. Matrix elements will be non-negative integers. Requirements * **Function**: - `prime_matrix(matrix: list[list[int]]) -> list[list[int]]` Example ```python matrix = [ [2, 4, 6, 8], [3, 5, 10, 15], [1, 2, 3, 4] ] # Output after processing the matrix result = prime_matrix(matrix) print(result) # Should output: # [ # [2, 0, 0, 0], # [0, 5, 0, 0], # [0, 0, 3, 0] # ] ``` # Hints 1. Implement a helper function to check if a number is prime. 2. Traverse each row to find the largest prime number. 3. Replace all elements except the largest prime number in the row with zeros. Solution ```python def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def prime_matrix(matrix): for i in range(len(matrix)): max_prime = -1 for j in range(len(matrix[i])): if is_prime(matrix[i][j]) and matrix[i][j] > max_prime: max_prime = matrix[i][j] for j in range(len(matrix[i])): if matrix[i][j] != max_prime: matrix[i][j] = 0 return matrix ```","solution":"def is_prime(n): Function to check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def prime_matrix(matrix): Function to replace all elements in each row of the matrix with zero except the largest prime number in that row. for i in range(len(matrix)): max_prime = -1 for j in range(len(matrix[i])): if is_prime(matrix[i][j]) and matrix[i][j] > max_prime: max_prime = matrix[i][j] if max_prime == -1: # No primes found in the row continue for j in range(len(matrix[i])): if matrix[i][j] != max_prime: matrix[i][j] = 0 return matrix"},{"question":"# Coding Assessment Question: Implementing and Using a Radix Sort Algorithm Context You are tasked with improving the performance of a data processing pipeline that involves sorting large lists of non-negative integers. While the default sorting algorithms perform well in general, you identify that a specialized sorting algorithm, Radix Sort, may be more efficient for this specific use case. Objective Write a Python function to implement the Radix Sort algorithm and test it with a sample list of non-negative integers. Requirements 1. **Function Name**: `radix_sort` 2. **Input**: A list of non-negative integers `arr`. 3. **Output**: A new list that contains the integers from `arr` sorted in ascending order. Constraints * You should not use Python\'s built-in sorting functions (`sort()`, `sorted()`, etc.). * Assume that all integers in the list are non-negative. * Consider that the list can be very large; aim for an efficient implementation. Performance Requirements * Your implementation should have an average time complexity of O(d*(n+k)), where `d` is the number of digits in the largest number, `n` is the number of elements in the list, and `k` is the range of the input. * The space complexity should be O(n + k), primarily used by the auxiliary arrays. Example ```python >>> arr = [170, 45, 75, 90, 802, 24, 2, 66] >>> radix_sort(arr) [2, 24, 45, 66, 75, 90, 170, 802] ``` Additional Task After implementing the Radix Sort function, write a brief comparison (not more than 200 words) of Radix Sort versus QuickSort for different types of input data and when Radix Sort may be preferred over QuickSort. Include practical considerations such as input characteristics and real-world application cases.","solution":"def counting_sort(arr, exp): A function to do counting sort of arr[] according to the digit represented by exp. n = len(arr) output = [0] * n # output array count = [0] * 10 # count array to store occurrences of digits (0 to 9) # Store count of occurrences in count[] for i in range(n): index = arr[i] // exp count[index % 10] += 1 # Change count[i] such that count[i] contains actual position of this digit in output[] for i in range(1, 10): count[i] += count[i - 1] # Build the output array i = n - 1 while i >= 0: index = arr[i] // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 i -= 1 # Copy the output array to arr[], so that arr now contains sorted numbers according to the current digit for i in range(n): arr[i] = output[i] def radix_sort(arr): A function to implement radix sort. if len(arr) == 0: return arr # Find the maximum number to know number of digits max1 = max(arr) # Do counting sort for every digit. Note that instead of passing the digit number, the exp (10^i) is passed. exp = 1 while max1 // exp > 0: counting_sort(arr, exp) exp *= 10 return arr # Brief Comparison: \'\'\' Radix Sort vs QuickSort: - Radix Sort: - Time Complexity: O(d*(n+k)), where d is the number of digits, n is the number of elements, and k is the range of input. - Space Complexity: O(n + k) for auxiliary arrays. - Stable sort, works well for large integers with a relatively small range of digits. - Good choice for cases where the number of digits (d) is much less than the number of elements (n). - QuickSort: - Time Complexity: Average O(n log n), Worst O(n^2). - Space Complexity: O(log n) due to stack space for recursion. - Not stable by default, but can be made stable with modifications. - Versatile, works well for various types of data, and often the default choice for general-purpose sorting. When to prefer Radix Sort: Radix Sort is more efficient than QuickSort when dealing with large lists of non-negative integers with a limited range of digits. It is particularly useful in scenarios like sorting IP addresses, phone numbers, or other numerical data where the key length (number of digits) is much smaller than the dataset size. \'\'\'"},{"question":"# Background A company wants to manage its employee records and keep track of various details such as names, ages, and departments. They have started using a new system to store these records but need some additional functionality. You are tasked with developing a class that can manage employee records effectively. # Problem Statement Write a class named `EmployeeManager` in Python that accomplishes the following: 1. Initializes with an empty list to store employees. 2. Allows adding a new employee record with `add_employee` method which accepts name (string), age (int), and department (string). 3. Allows fetching all employee records with `get_all_employees` method. 4. Allows finding employees by department with `get_employees_by_department` method which accepts a department name and returns a list of employee records in that department. 5. Ensures robust handling of edge cases and optimizes performance for larger datasets. # Class Signature ```python class EmployeeManager: def __init__(self): # your code here def add_employee(self, name: str, age: int, department: str) -> None: # your code here def get_all_employees(self) -> list: # your code here def get_employees_by_department(self, department: str) -> list: # your code here ``` # Methods - `add_employee(name: str, age: int, department: str) -> None`: Adds a new employee to the records. - `get_all_employees() -> list`: Returns a list of all employee records. - `get_employees_by_department(department: str) -> list`: Returns a list of employee records for the specified department. # Input - `name` (string): Non-empty name of the employee. - `age` (int): Age of the employee, must be a positive integer. - `department` (string): Non-empty name of the department. # Output - `None` for `add_employee` method. - List of employee records for `get_all_employees` and `get_employees_by_department` methods. # Constraints - Ensure all methods are efficient and can handle large datasets. - Handle edge cases such as empty lists or departments with no employees. - Employee records should be stored in a meaningful data structure. # Example Usage ```python manager = EmployeeManager() manager.add_employee(\\"John Doe\\", 30, \\"Engineering\\") manager.add_employee(\\"Jane Smith\\", 25, \\"Marketing\\") manager.add_employee(\\"Alice Johnson\\", 28, \\"Engineering\\") all_employees = manager.get_all_employees() print(all_employees) # Output: [{\'name\': \'John Doe\', \'age\': 30, \'department\': \'Engineering\'}, {\'name\': \'Jane Smith\', \'age\': 25, \'department\': \'Marketing\'}, {\'name\': \'Alice Johnson\', \'age\': 28, \'department\': \'Engineering\'}] engineering_employees = manager.get_employees_by_department(\\"Engineering\\") print(engineering_employees) # Output: [{\'name\': \'John Doe\', \'age\': 30, \'department\': \'Engineering\'}, {\'name\': \'Alice Johnson\', \'age\': 28, \'department\': \'Engineering\'}] ``` # Notes - Consider using dictionaries or other efficient data structures for storing employee records. - Include error handling to manage invalid inputs gracefully.","solution":"class EmployeeManager: def __init__(self): self.employees = [] def add_employee(self, name: str, age: int, department: str) -> None: if not name or not isinstance(name, str): raise ValueError(\\"Invalid Name\\") if not isinstance(age, int) or age <= 0: raise ValueError(\\"Invalid Age\\") if not department or not isinstance(department, str): raise ValueError(\\"Invalid Department\\") employee_record = {\'name\': name, \'age\': age, \'department\': department} self.employees.append(employee_record) def get_all_employees(self) -> list: return self.employees def get_employees_by_department(self, department: str) -> list: if not department or not isinstance(department, str): raise ValueError(\\"Invalid Department\\") return [employee for employee in self.employees if employee[\'department\'] == department]"},{"question":"# Coding Assessment Question Context In this exercise, you will identify prime numbers that remain prime when their digits are rearranged in any permutation. Such prime numbers can be fascinating, and often involve exploring permutations and primality testing. Problem Statement Write a function `find_n_prime_permutation(n: int) -> int` that returns the nth term in the sequence of prime numbers where any permutation of the digits is also a prime number. Constraints * The function parameter `n` represents the term index in the sequence and is a positive integer. * You may assume `n` is small enough to not encounter performance issues with inherent prime checking methods (e.g., n < 100). Input * An integer `n`. Output * The integer value of the nth term in the sequence. Examples * `find_n_prime_permutation(1)` should return `2`. * `find_n_prime_permutation(3)` should return `11`. * `find_n_prime_permutation(5)` should return `37`. Function Signature ```python def find_n_prime_permutation(n: int) -> int: pass ``` Requirements * Ensure that the code can handle edge cases like very small or symmetrically repeating digits. * Utilize an efficient method to generate and check permutations for primality. * Include appropriate test cases to verify correctness of your implementation.","solution":"import itertools def is_prime(num): Check if a number is a prime number. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def has_all_prime_permutations(prime): Check if all permutations of the digits of prime are also prime. str_prime = str(prime) permutations = set(itertools.permutations(str_prime)) for perm in permutations: if perm[0] == \'0\': # To handle leading zeros in permutations continue perm_number = int(\'\'.join(perm)) if not is_prime(perm_number): return False return True def find_n_prime_permutation(n): Return the nth term in the sequence of prime numbers where any permutation of the digits is also a prime number. count, candidate = 0, 2 # Starting from the smallest prime number while True: if is_prime(candidate) and has_all_prime_permutations(candidate): count += 1 if count == n: return candidate candidate += 1"},{"question":"You are working on a problem that involves compressing sequences of integers by finding and encoding patterns. The goal is to compress the sequence using Run-Length Encoding (RLE). # Task: Write a function `run_length_encoding` that takes a list of integers and returns a compressed version of the list using Run-Length Encoding. Function Signature: ```python def run_length_encoding(nums: List[int]) -> List[Tuple[int, int]]: pass ``` # Input: 1. `nums` (List[int]): A list of integers representing the sequence to be compressed (1 ≤ |nums| ≤ 1000). # Output: - A list of tuples where each tuple represents a value from the input list and its corresponding frequency in consecutive order. # Examples: ```python # Example 1: nums = [1, 1, 2, 3, 3, 3, 4, 4, 4, 4] # Expected output: [(1, 2), (2, 1), (3, 3), (4, 4)] # Example 2: nums = [5, 5, 5, 5, 5] # Expected output: [(5, 5)] # Example 3: nums = [1, 2, 3, 4, 5, 6] # Expected output: [(1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1)] ``` # Constraints: - The input list will only contain integers. - The function should be able to handle both small and large sequences efficiently. # Notes: - Run-Length Encoding (RLE) is a simple form of data compression where sequences of the same data value are stored as a single data value and count. - Ensure your implementation correctly handles edge cases such as an empty list or a list with only one unique integer. Good luck!","solution":"from typing import List, Tuple def run_length_encoding(nums: List[int]) -> List[Tuple[int, int]]: if not nums: return [] result = [] current_value = nums[0] count = 1 for num in nums[1:]: if num == current_value: count += 1 else: result.append((current_value, count)) current_value = num count = 1 result.append((current_value, count)) # append the last accumulated tuple return result"},{"question":"# Employee Salary Adjustment You are developing a human resources application that handles employee salary adjustments based on their performance ratings. You need to implement a function `adjust_salaries` that takes a list of tuples representing employees\' salaries and their performance ratings. The function should update each salary based on the performance rating using the following rules: - If the rating is \'A\', increase the salary by 10%. - If the rating is \'B\', increase the salary by 5%. - If the rating is \'C\', leave the salary unchanged. - If the rating is \'D\', decrease the salary by 5%. Ensure that the input values are validated and the function handles invalid ratings appropriately by raising a `ValueError`. Function Signature: ```python def adjust_salaries(employees: List[Tuple[float, str]]) -> List[float]: pass ``` Input: - `employees`: A list of tuples where each tuple contains a float and a string. The float represents the salary (in dollars), and the string represents the performance rating. Output: - Returns a list of float values where each value is the adjusted salary of the corresponding employee. Constraints: - (0 leq text{salary} leq 1,000,000) - The performance rating must be one of \'A\', \'B\', \'C\', or \'D\'. - The function should handle invalid ratings by raising a `ValueError`. Example: ```python >>> adjust_salaries([(50000, \'A\'), (60000, \'C\'), (70000, \'B\'), (80000, \'D\')]) [55000.0, 60000.0, 73500.0, 76000.0] ``` # Explanation: 1. For the first employee with a salary of 50,000 and a performance rating \'A\', the adjusted salary is (50000 times 1.10 = 55000.0). 2. For the second employee with a salary of 60,000 and a performance rating \'C\', the salary remains unchanged at 60,000. 3. For the third employee with a salary of 70,000 and a performance rating \'B\', the adjusted salary is (70000 times 1.05 = 73500.0). 4. For the fourth employee with a salary of 80,000 and a performance rating \'D\', the adjusted salary is (80000 times 0.95 = 76000.0). Implement the `adjust_salaries` function to ensure it considers all edge cases and input constraints, and raises a `ValueError` for any invalid performance ratings.","solution":"from typing import List, Tuple def adjust_salaries(employees: List[Tuple[float, str]]) -> List[float]: Adjusts salaries based on performance ratings. Args: employees (List[Tuple[float, str]]): A list of tuples where each tuple contains a float (salary) and a string (performance rating). Returns: List[float]: A list of adjusted salaries. Raises: ValueError: If any performance rating is not \'A\', \'B\', \'C\', or \'D\'. adjusted_salaries = [] for salary, rating in employees: if rating == \'A\': adjusted_salary = salary * 1.10 elif rating == \'B\': adjusted_salary = salary * 1.05 elif rating == \'C\': adjusted_salary = salary elif rating == \'D\': adjusted_salary = salary * 0.95 else: raise ValueError(f\\"Invalid performance rating: {rating}\\") adjusted_salaries.append(round(adjusted_salary, 2)) return adjusted_salaries"},{"question":"# Coding Challenge: Finding Shortest Path in a Weighted Graph Scenario: You are given a road network represented as a weighted, undirected graph. Each node represents a city, and each edge represents a road connecting two cities with a given length. You need to determine the shortest path from a starting city to all other cities in the network, returning the minimum distances to each city. Task: Implement a function `shortest_paths` that takes the number of cities (nodes), the roads between them (edges), and the starting city as input, and returns the shortest distances from the starting city to all other cities. Function Signature: ```python def shortest_paths(n: int, edges: list[tuple[int, int, int]], start: int) -> list[int]: ``` Input: - `n` (int): The number of cities (nodes) in the network. - `edges` (list of tuples of int): Each tuple (u, v, w) represents an undirected edge between city u and city v with a distance of w. - `start` (int): The starting city\'s ID. Output: - `list of int`: A list representing the shortest distances from the starting city to each city. If a city is unreachable from the starting city, return `-1` for that city. Constraints: - `1 <= n <= 300` (number of nodes) - `0 <= len(edges) <= n * (n - 1) / 2` (number of edges) - User IDs (nodes) are numbered from 0 to n-1. Example: ```python n = 5 edges = [(0, 1, 10), (1, 2, 5), (2, 3, 15), (1, 3, 20), (3, 4, 25)] start = 0 print(shortest_paths(n, edges, start)) # Expected Output: [0, 10, 15, 30, 55] ``` Requirements: - Use Dijkstra\'s algorithm to find the shortest paths. - Ensure that your function runs efficiently with the provided constraints. - Write additional helper functions if necessary. Notes: - Consider edge cases like an empty road network (n = 0, edges = []), and isolated cities. - The output should be a list where the position represents the city ID, and the value represents the shortest distance to that city. - If a city is unreachable, return `-1` for that city in the output list.","solution":"import heapq def shortest_paths(n: int, edges: list[tuple[int, int, int]], start: int) -> list[int]: # Create adjacency list graph = [[] for _ in range(n)] for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Initialize distances with infinity distances = [float(\'inf\')] * n distances[start] = 0 # Create a priority queue and add the start node queue = [(0, start)] while queue: current_distance, u = heapq.heappop(queue) if current_distance > distances[u]: continue for v, weight in graph[u]: distance = current_distance + weight if distance < distances[v]: distances[v] = distance heapq.heappush(queue, (distance, v)) # Replace inf with -1 to indicate unreachable nodes return [d if d != float(\'inf\') else -1 for d in distances]"},{"question":"# Scenario You are tasked with developing a simplified version of the famous game \\"Tic-Tac-Toe\\" in Python. The game board is represented by a 3x3 grid, and players take turns placing their markers (\'X\' or \'O\') on the grid. You need to implement a class to handle the game logic, including setting the board, checking the game status, and determining the winner. # Task Write a class `TicTacToe` with the following methods: - `__init__(self)`: Initializes an empty 3x3 board. - `play_move(self, row: int, col: int, player: str) -> str`: Places the player\'s marker (\'X\' or \'O\') on the board at the specified row and column. After each move, it returns the game status: \'Continue\' if the game should continue, \'Draw\' if the game is a draw, or the marker (\'X\' or \'O\') of the player who won. # Constraints - The `row` and `col` parameters will be integers between 0 and 2, inclusive. - The `player` parameter will be either \'X\' or \'O\'. - You can assume valid input for `row` and `col` (no repeated moves or moves out of range). # Example ```python game = TicTacToe() print(game.play_move(0, 0, \'X\')) # Output: \'Continue\' print(game.play_move(1, 1, \'O\')) # Output: \'Continue\' print(game.play_move(0, 1, \'X\')) # Output: \'Continue\' print(game.play_move(1, 0, \'O\')) # Output: \'Continue\' print(game.play_move(0, 2, \'X\')) # Output: \'X\' ``` Implement the `TicTacToe` class: ```python class TicTacToe: def __init__(self): self.board = [[\'\' for _ in range(3)] for _ in range(3)] self.moves = 0 def play_move(self, row: int, col: int, player: str) -> str: self.board[row][col] = player self.moves += 1 if self.check_winner(player): return player if self.moves == 9: return \'Draw\' return \'Continue\' def check_winner(self, player: str) -> bool: # Check rows for i in range(3): if all(self.board[i][j] == player for j in range(3)): return True # Check columns for j in range(3): if all(self.board[i][j] == player for i in range(3)): return True # Check diagonals if all(self.board[i][i] == player for i in range(3)): return True if all(self.board[i][2-i] == player for i in range(3)): return True return False ``` - Initialize a 3x3 board. - Place the player\'s marker on the board and increment the number of moves. - Check if the current player has won or if the game is a draw. - Return the appropriate game status.","solution":"class TicTacToe: def __init__(self): self.board = [[\'\' for _ in range(3)] for _ in range(3)] self.moves = 0 def play_move(self, row: int, col: int, player: str) -> str: self.board[row][col] = player self.moves += 1 if self.check_winner(player): return player if self.moves == 9: return \'Draw\' return \'Continue\' def check_winner(self, player: str) -> bool: # Check rows for i in range(3): if all(self.board[i][j] == player for j in range(3)): return True # Check columns for j in range(3): if all(self.board[i][j] == player for i in range(3)): return True # Check diagonals if all(self.board[i][i] == player for i in range(3)): return True if all(self.board[i][2-i] == player for i in range(3)): return True return False"},{"question":"# Coding Assessment Question Objective Extend the basic functionalities of string manipulation to categorize and extract specific data from a structured string with delimiters. Problem Statement Write a Python function `extract_and_categorize(data: List[str]) -> Dict[str, Dict[str, Any]]` that takes a list of strings. Each string represents a record with fields separated by commas. Structures a dictionary to categorize the records based on a specific category field and perform additional processing on numerical fields. Each record string contains the fields: 1. `id` (unique identifier) 2. `category` (categorizes the records) 3. `value1` (a numerical value) 4. `value2` (a numerical value) The function should: 1. Parse each record string into its respective fields. 2. Group the records based on the `category` field. 3. For each category, calculate the sum of `value1`, the minimum of `value2`, and store all `id`s. Return a dictionary where the keys are the unique categories, and the values are a nested dictionary with the calculated sum, minimum value, and list of IDs. # Input * `data`: A list of strings (1 <= len(data) <= 1000) where each string is in the format \\"id,category,value1,value2\\". # Output * A dictionary where each key is a category and the value is another dictionary with keys: - `\'sum_value1\'`: the sum of \'value1\' for all records in that category. - `\'min_value2\'`: the minimum of \'value2\' for all records in that category. - `\'ids\'`: a list of \'id\'s for all records in that category. # Constraints * You can assume that all strings are properly formatted according to the given specification. * All `value1` and `value2` are guaranteed to be integers. * `category` is a non-empty string. # Example ```python from typing import List, Dict, Any def extract_and_categorize(data: List[str]) -> Dict[str, Dict[str, Any]]: result = {} for record in data: id, category, value1, value2 = record.split(\',\') value1, value2 = int(value1), int(value2) if category not in result: result[category] = {\'sum_value1\': value1, \'min_value2\': value2, \'ids\': [id]} else: result[category][\'sum_value1\'] += value1 result[category][\'min_value2\'] = min(result[category][\'min_value2\'], value2) result[category][\'ids\'].append(id) return result # Example Usage data = [ \\"101,A,10,5\\", \\"102,B,20,3\\", \\"103,A,30,2\\", \\"104,B,10,1\\", \\"105,A,15,8\\" ] print(extract_and_categorize(data)) # Output: # { # \'A\': {\'sum_value1\': 55, \'min_value2\': 2, \'ids\': [\'101\', \'103\', \'105\']}, # \'B\': {\'sum_value1\': 30, \'min_value2\': 1, \'ids\': [\'102\', \'104\']} # } ``` # Requirements 1. Ensure the function handles large inputs efficiently. 2. Properly test the function with edge cases like input with very large values, or categories with only one record. Notes: * Carefully manage the dictionary construction to ensure that no records are skipped or improperly categorized. * Ensure robustness in your implementation to handle possible variations within the constraints.","solution":"from typing import List, Dict, Any def extract_and_categorize(data: List[str]) -> Dict[str, Dict[str, Any]]: result = {} for record in data: id, category, value1, value2 = record.split(\',\') value1, value2 = int(value1), int(value2) if category not in result: result[category] = {\'sum_value1\': value1, \'min_value2\': value2, \'ids\': [id]} else: result[category][\'sum_value1\'] += value1 result[category][\'min_value2\'] = min(result[category][\'min_value2\'], value2) result[category][\'ids\'].append(id) return result"},{"question":"# Coding Assessment Question **Title**: Merge Intervals and Find Gaps **Task**: Using the provided dataset of intervals, implement a function to merge overlapping intervals and then find the gaps between these intervals. The function should return a list of the merged intervals and another list of the gaps. **Background**: Given a list of intervals where each interval is a tuple of two integers representing the start and end points, your task is to merge all overlapping intervals and identify the gaps between the merged intervals. **Function Specification**: **Function Name**: `merge_intervals_and_find_gaps` **Input**: - `intervals` (List[Tuple[int, int]]): A list of tuples where each tuple represents an interval in the form `(start, end)`. **Output**: - `merged_intervals` (List[Tuple[int, int]]): A list of tuples representing the merged intervals. - `gaps` (List[Tuple[int, int]]): A list of tuples representing the gaps between the merged intervals. **Constraints**: - All intervals are represented as tuples of two integers where the first integer is less than or equal to the second. - The intervals are not guaranteed to be sorted. **Requirements**: - Sort the intervals based on the starting point. - Merge overlapping intervals. - Identify and list the gaps between the merged intervals. **Example**: Assume the input is `intervals = [(1, 3), (5, 6), (2, 4), (8, 10), (7, 8)]`. ```python merged_intervals, gaps = merge_intervals_and_find_gaps([(1, 3), (5, 6), (2, 4), (8, 10), (7, 8)]) ``` Expected Output: - `merged_intervals` should be: `[(1, 4), (5, 6), (7, 10)]` - `gaps` should be: `[(4, 5), (6, 7)]` **Skeleton Code**: ```python from typing import List, Tuple def merge_intervals_and_find_gaps(intervals: List[Tuple[int, int]]) -> Tuple[List[Tuple[int, int]], List[Tuple[int, int]]]: if not intervals: return [], [] # Sort intervals by the starting point intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current in intervals[1:]: last_merged = merged_intervals[-1] if current[0] <= last_merged[1]: # Overlapping intervals, merge them merged_intervals[-1] = (last_merged[0], max(last_merged[1], current[1])) else: # Non-overlapping interval, add it to the list merged_intervals.append(current) # Find gaps gaps = [] for i in range(1, len(merged_intervals)): start_gap = merged_intervals[i-1][1] end_gap = merged_intervals[i][0] if start_gap != end_gap: gaps.append((start_gap, end_gap)) return merged_intervals, gaps # Example usage if __name__ == \\"__main__\\": intervals = [(1, 3), (5, 6), (2, 4), (8, 10), (7, 8)] merged_intervals, gaps = merge_intervals_and_find_gaps(intervals) print(\\"Merged Intervals:\\", merged_intervals) print(\\"Gaps:\\", gaps) ```","solution":"from typing import List, Tuple def merge_intervals_and_find_gaps(intervals: List[Tuple[int, int]]) -> Tuple[List[Tuple[int, int]], List[Tuple[int, int]]]: if not intervals: return [], [] # Sort intervals by the starting point intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current in intervals[1:]: last_merged = merged_intervals[-1] if current[0] <= last_merged[1]: # Overlapping intervals, merge them merged_intervals[-1] = (last_merged[0], max(last_merged[1], current[1])) else: # Non-overlapping interval, add it to the list merged_intervals.append(current) # Find gaps gaps = [] for i in range(1, len(merged_intervals)): start_gap = merged_intervals[i-1][1] end_gap = merged_intervals[i][0] if start_gap != end_gap: gaps.append((start_gap, end_gap)) return merged_intervals, gaps"},{"question":"# Coding Assessment Question Context You are creating a tool that will assist with scheduling meetings based on participants\' availability. The tool should find the earliest common slot that is at least 30 minutes long. Task Create a function `find_earliest_meeting_slot(schedule: List[Tuple[str, str]], duration: int = 30) -> str` which: 1. Takes in a list of tuples, where each tuple represents the start and end times of a previously scheduled meeting (in 24-hour time format). 2. Finds the earliest possible starting time for a new meeting that is at least `duration` minutes long. Requirements 1. Implement the function `find_earliest_meeting_slot(schedule: List[Tuple[str, str]], duration: int = 30) -> str`. 2. Return the earliest possible start time as a string in the format \'HH:MM\'. 3. Ensure the returned time slot does not overlap with any of the existing scheduled meetings. 4. The schedule is within a single day (00:00 to 23:59). 5. Assume work hours are from 09:00 to 17:00 and the new meeting must start and end within these hours. Input and Output * **Input**: A list of tuples `schedule` and an integer `duration` representing the length of the meeting in minutes. * **Output**: A string representing the start time of the earliest possible meeting of at least `duration` minutes in the format \'HH:MM\'. Constraints * The input times are given in 24-hour format as strings. * Assume the given `schedule` list is sorted by start times and does not contain overlapping meetings. * The duration of the meeting is between 30 and 120 minutes. * If no suitable slot is found within work hours, return \\"No available slot\\". Example: ```python >>> schedule = [(\\"09:00\\", \\"09:30\\"), (\\"10:00\\", \\"11:00\\"), (\\"12:00\\", \\"13:00\\"), (\\"14:00\\", \\"15:00\\")] >>> find_earliest_meeting_slot(schedule, 30) \\"09:30\\" >>> schedule = [(\\"09:00\\", \\"10:30\\"), (\\"10:45\\", \\"12:15\\"), (\\"12:30\\", \\"14:00\\"), (\\"14:15\\", \\"15:45\\")] >>> find_earliest_meeting_slot(schedule, 30) \\"15:45\\" >>> schedule = [(\\"09:00\\", \\"10:30\\"), (\\"10:30\\", \\"12:00\\"), (\\"12:00\\", \\"14:00\\"), (\\"14:00\\", \\"17:00\\")] >>> find_earliest_meeting_slot(schedule, 30) \\"No available slot\\" ```","solution":"from typing import List, Tuple def time_to_minutes(time: str) -> int: h, m = map(int, time.split(\':\')) return h * 60 + m def minutes_to_time(minutes: int) -> str: h = minutes // 60 m = minutes % 60 return f\\"{h:02d}:{m:02d}\\" def find_earliest_meeting_slot(schedule: List[Tuple[str, str]], duration: int = 30) -> str: work_start = time_to_minutes(\\"09:00\\") work_end = time_to_minutes(\\"17:00\\") # Add a time range before the first meeting and after the last meeting meetings = [(work_start, work_start)] + [ (time_to_minutes(start), time_to_minutes(end)) for start, end in schedule ] + [(work_end, work_end)] for i in range(len(meetings) - 1): end_current_meeting = meetings[i][1] start_next_meeting = meetings[i + 1][0] if start_next_meeting - end_current_meeting >= duration: return minutes_to_time(end_current_meeting) return \\"No available slot\\""},{"question":"# Matrix Rotation Background Rotating a matrix, also known as transposing and reflecting it along its main diagonals, is a common operation in image processing and computer graphics. Conceptually, rotating a matrix 90 degrees clockwise can be achieved by first transposing the matrix (flipping it over its diagonal) and then reversing the rows. Problem Statement You are required to rotate a given N x N matrix by 90 degrees clockwise. Function Signature ```python def rotate_90_clockwise(matrix: list[list[int]]) -> list[list[int]]: Rotate the given N x N matrix by 90 degrees clockwise. :param matrix: A 2D list representing the matrix. :return: A new 2D list representing the rotated matrix. pass ``` Requirements 1. Implement the `rotate_90_clockwise` function that rotates the given matrix by 90 degrees clockwise. Constraints - The matrix will always be a square matrix with dimensions N x N (1 <= N <= 100). - The elements of the matrix will be integers in the range [-10^4, 10^4]. Examples: ```python # Example Rotation 1 matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotated_matrix = rotate_90_clockwise(matrix) # Expected: [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] # Example Rotation 2 matrix = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] rotated_matrix = rotate_90_clockwise(matrix) # Expected: [ # [15, 13, 2, 5], # [14, 3, 4, 1], # [12, 6, 8, 9], # [16, 7, 10, 11] # ] # Example Rotation 3 (Edge case with 1x1 matrix) matrix = [ [1] ] rotated_matrix = rotate_90_clockwise(matrix) # Expected: [ # [1] # ] ``` Additional Notes: - Consider edge cases, such as the smallest matrix size (1x1). - Ensure that your function does not modify the original matrix but returns a new rotated matrix.","solution":"def rotate_90_clockwise(matrix: list[list[int]]) -> list[list[int]]: Rotate the given N x N matrix by 90 degrees clockwise. :param matrix: A 2D list representing the matrix. :return: A new 2D list representing the rotated matrix. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"# Question: File System Analysis You have been tasked with writing a function to analyze the structure of a file system. The function should count the total number of files and directories, identify the largest file, and determine the deepest directory level. **Task** 1. Write a function `analyze_file_system` that takes the root path of a directory and calculates: - The total count of files and directories. - The largest file by size. - The deepest directory level. # Requirements **Function Signature** ```python import os def analyze_file_system(root_path: str) -> dict: pass # Your implementation here ``` **Input** - `root_path` (str): The root directory path to start the analysis from. **Output** - Returns a dictionary with the following structure: ```python { \\"total_files\\": int, \\"total_directories\\": int, \\"largest_file\\": { \\"path\\": str, \\"size\\": int }, \\"deepest_level\\": int } ``` **Constraints** - The function should handle large file systems efficiently. - Properly manage access permissions and handle any potential exceptions appropriately. - The function should be recursive to navigate through nested directories. **Performance** - The function should be efficient with respect to time and space complexities. # Example ```python # Assuming your function implementation is complete root_path = \\"/path/to/root/directory\\" result = analyze_file_system(root_path) print(result) # Output might be: # { # \\"total_files\\": 50, # \\"total_directories\\": 10, # \\"largest_file\\": { # \\"path\\": \\"/path/to/root/directory/subdir/file.txt\\", # \\"size\\": 2048 # }, # \\"deepest_level\\": 5 # } ``` # Note - Use appropriate error handling to manage issues like inaccessible directories or files. - Ensure that the directory traversal is as efficient as possible to handle very large directory structures without significant delays.","solution":"import os def analyze_file_system(root_path: str) -> dict: total_files = 0 total_directories = 0 largest_file = {\\"path\\": \\"\\", \\"size\\": 0} deepest_level = 0 def analyze_directory(path, current_level): nonlocal total_files, total_directories, largest_file, deepest_level try: with os.scandir(path) as iterator: for entry in iterator: if entry.is_file(follow_symlinks=False): total_files += 1 size = entry.stat().st_size if size > largest_file[\\"size\\"]: largest_file = {\\"path\\": entry.path, \\"size\\": size} elif entry.is_dir(follow_symlinks=False): total_directories += 1 analyze_directory(entry.path, current_level + 1) except PermissionError: pass if current_level > deepest_level: deepest_level = current_level analyze_directory(root_path, 0) return { \\"total_files\\": total_files, \\"total_directories\\": total_directories, \\"largest_file\\": largest_file, \\"deepest_level\\": deepest_level }"},{"question":"# Coding Assessment Question Context You are working on a new text editor, and one of the features you need to implement is a simplified version of the \\"undo\\" operation. Users can make a series of text insertions and deletions, and they should be able to undo these operations in the reverse order they were performed. Problem Statement Write a Python class `TextEditor` that supports the following methods: - `insert_text(text: str)` - Inserts the specified text at the end of the current document. - `delete_text(count: int)` - Deletes the last `count` characters from the document. If `count` is greater than the current length of the document, delete all characters. - `undo()` - Reverts the most recent insert or delete operation. Your implementation should ensure that an undo operation can revert both insertions and deletions correctly. Input Format The `TextEditor` class should support the following methods: - `insert_text(text: str)` - `delete_text(count: int)` - `undo()` Each method has the respective input format provided in the Problem Statement. Output Format - The `insert_text` and `delete_text` methods return `None`. - The `undo` method returns the current state of the document as a string after the undo operation. Constraints - All text insertions and deletions are non-negative. - The length of the inserted text can be between 1 and 10^6 characters. - The total number of operations (inserts, deletes, and undos) can be up to 10^6. Examples ```python editor = TextEditor() editor.insert_text(\\"hello\\") editor.insert_text(\\" world\\") assert editor.undo() == \\"hello\\" editor.delete_text(3) assert editor.undo() == \\"hello world\\" ``` Performance Requirements * The expected time complexity for each operation (insert_text, delete_text, undo) should be O(1) on average. * The expected space complexity for storing the text and history of operations should be O(N), where N is the total length of text inserted. Implementation Notes * You should keep track of the history of operations to manage the undo functionality effectively. * Consider using a stack to manage the history of operations. * Handle edge cases where no operations have been performed or where undo operations exceed the number of performed operations.","solution":"class TextEditor: def __init__(self): self.document = \\"\\" self.history = [] def insert_text(self, text: str): self.history.append((\\"insert\\", text)) self.document += text def delete_text(self, count: int): if count > len(self.document): count = len(self.document) deleted_text = self.document[-count:] self.history.append((\\"delete\\", deleted_text)) self.document = self.document[:-count] def undo(self): if not self.history: return self.document last_action, last_text = self.history.pop() if last_action == \\"insert\\": self.document = self.document[:-len(last_text)] elif last_action == \\"delete\\": self.document += last_text return self.document"},{"question":"# Coding Question: Real-Time Kth Largest Element Tracker Imagine you are developing a feature for a real-time data visualization tool that requires keeping track of the k-th largest element in a dynamically changing data stream. Your task is to implement a data structure that supports adding new elements and efficiently retrieving the k-th largest element at any given time. # Requirements: 1. Implement the `KthLargest` class with the following methods: - `__init__(self, k: int, initial_elements: list[int])`: Initializes the object with the integer k and the initial list of integers. - `add(self, val: int) -> int`: Adds the integer val to the stream and returns the k-th largest element in the stream. - `get_kth_largest(self) -> int`: Returns the current k-th largest element without adding a new element. 2. The `add` method should maintain efficient performance even with frequent additions. 3. The `get_kth_largest` method should quickly retrieve the current k-th largest element. # Input: * `k`: An integer representing the k-th position (1-based index). * `initial_elements`: A list of integers representing the initial elements in the data stream. # Output: * For the `add` method, an integer representing the k-th largest element after the addition. * For the `get_kth_largest` method, an integer representing the current k-th largest element. # Constraints: * Your implementation must handle a large number of additions efficiently. * The initial list of elements may be empty or non-empty, and it may contain duplicates. * k is guaranteed to be less than or equal to the number of elements in the current stream after any `add` operation. # Performance Requirements: * Your solution should make efficient use of data structures to handle large data streams and frequent updates while maintaining quick retrieval of the k-th largest element. # Class Definition: ```python class KthLargest: def __init__(self, k: int, initial_elements: list[int]): pass def add(self, val: int) -> int: pass def get_kth_largest(self) -> int: pass ``` # Example: ```python k = 3 initial_elements = [4, 5, 8, 2] kth_largest = KthLargest(k, initial_elements) assert kth_largest.add(3) == 4 # Stream: [4, 5, 8, 2, 3] assert kth_largest.add(5) == 5 # Stream: [4, 5, 8, 2, 3, 5] assert kth_largest.add(10) == 5 # Stream: [4, 5, 8, 2, 3, 5, 10] assert kth_largest.add(9) == 8 # Stream: [4, 5, 8, 2, 3, 5, 10, 9] assert kth_largest.add(4) == 8 # Stream: [4, 5, 8, 2, 3, 5, 10, 9, 4] assert kth_largest.get_kth_largest() == 8 # Confirm the current k-th largest element ``` # Additional Notes: * Consider using a min-heap to efficiently maintain the k largest elements. * Ensure your solution manages both time and space complexity well, especially for large data streams. * Thoroughly test the class with diverse cases, including edge cases and scenarios with varying k values.","solution":"import heapq class KthLargest: def __init__(self, k: int, initial_elements: list[int]): self.k = k self.min_heap = [] for num in initial_elements: self.add(num) def add(self, val: int) -> int: if len(self.min_heap) < self.k: heapq.heappush(self.min_heap, val) elif val > self.min_heap[0]: heapq.heapreplace(self.min_heap, val) return self.min_heap[0] def get_kth_largest(self) -> int: return self.min_heap[0]"},{"question":"# Coding Assessment Question **Scenario**: You are a data analyst at a logistics company. Your team needs to analyze route data to determine the most fuel-efficient path for delivery trucks. The company measures fuel consumption per mile for each segment of the route. You need to calculate the total fuel consumption for a given route and also determine the maximum fuel consumption segment. # Task Implement three functions: `total_fuel_consumption`, `max_fuel_consumption_segment`, and `average_fuel_consumption`. 1. **total_fuel_consumption**: * **Input**: - `segments` (list of tuples): Each tuple represents a segment of the route and contains two elements: - A string representing the segment name (e.g., \\"A-B\\"). - A float representing the fuel consumption over that segment (e.g., 3.2 gallons). * **Output**: - Total fuel consumption (float). 2. **max_fuel_consumption_segment**: * **Input**: - `segments` (list of tuples): Same as above. * **Output**: - The segment name with the maximum fuel consumption (string). 3. **average_fuel_consumption**: * **Input**: - `segments` (list of tuples): Same as above. * **Output**: - The average fuel consumption per segment (float). # Specifications - Ensure appropriate error handling for empty lists or invalid data types. - The overall time complexity for each function should remain O(n), where n is the number of segments. # Example Usage ```python route_segments = [(\\"A-B\\", 3.2), (\\"B-C\\", 4.5), (\\"C-D\\", 2.8), (\\"D-E\\", 5.0)] print(total_fuel_consumption(route_segments)) # Output: 15.5 print(max_fuel_consumption_segment(route_segments)) # Output: \\"D-E\\" print(average_fuel_consumption(route_segments)) # Output: 3.875 ``` # Implementation Write your solution in Python. Ensure it is efficient and robust while adhering to the given constraints.","solution":"def total_fuel_consumption(segments): Calculates the total fuel consumption for a given route. Args: segments (list of tuples): Each tuple contains a string (segment name) and a float (fuel consumption). Returns: float: Total fuel consumption. return sum(fuel for _, fuel in segments) def max_fuel_consumption_segment(segments): Determines the segment with the maximum fuel consumption. Args: segments (list of tuples): Each tuple contains a string (segment name) and a float (fuel consumption). Returns: string: Segment name with the maximum fuel consumption. return max(segments, key=lambda segment: segment[1])[0] def average_fuel_consumption(segments): Calculates the average fuel consumption per segment. Args: segments (list of tuples): Each tuple contains a string (segment name) and a float (fuel consumption). Returns: float: Average fuel consumption per segment. total_segments = len(segments) if total_segments == 0: return 0 total_fuel = total_fuel_consumption(segments) return total_fuel / total_segments"},{"question":"# Single Number in Array You are given an array of integers, `nums`, where every element appears exactly twice, except for one element which appears only once. Your task is to write a function `single_number(nums: List[int]) -> int` that finds and returns the single element that appears only once. Input Format The function receives a list of integers `nums` with the following structure: ```python from typing import List def single_number(nums: List[int]) -> int: # Write your code here pass ``` Output Format An integer representing the single element that appears only once in the array. Constraints * The array `nums` will contain between `1` and `10^5` elements. * Each element of the array is an integer within the range `-3 * 10^4` to `3 * 10^4`. * All elements except one appear exactly twice in the array. Example ``` 1. Example Array: [2, 2, 1] Output: 1 Explanation: The element 1 appears only once. 2. Example Array: [4, 1, 2, 1, 2] Output: 4 Explanation: The element 4 appears only once. 3. Example Array: [1] Output: 1 Explanation: The element 1 appears only once. ``` Performance Requirements * The solution should have O(n) time complexity. * Use O(1) extra space (ignoring the space required for the input array). --- The question above aligns with the existing sample questions by presenting a clear and computationally challenging problem that requires understanding and leveraging fundamental programming concepts, such as array manipulation and efficient algorithm design.","solution":"from typing import List def single_number(nums: List[int]) -> int: This function finds the single number in an array where every element appears exactly twice except for one element which appears only once. Args: nums (List[int]): The input list of integers. Returns: int: The single number that appears only once. single_num = 0 for num in nums: single_num ^= num return single_num"},{"question":"# Scenario As part of an online multiplayer game, you are tasked with developing a messaging system that enforces a maximum message length. The system must truncate any message exceeding the specified limit but ensure that words are not cut off in the middle. # Task Implement a function `truncate_message(message: str, limit: int) -> str` that truncates the input message to the specified limit ensuring no word is cut off. # Input - `message`: A string containing the original message (1 ≤ len(message) ≤ 1000). - `limit`: An integer (1 ≤ limit ≤ 1000), representing the maximum allowed length of the truncated message. # Output - A string containing the truncated message, ensuring no word is cut off if the message is truncated. # Constraints and Notes - If the message\'s length is less than or equal to the limit, return the message as-is. - Words in the message are separated by single spaces. - If truncating the message, the function must ensure that no word is cut off. It should truncate at the last full word fitting within the limit. # Example ```python >>> truncate_message(\\"Welcome to the world of programming\\", 10) \'Welcome to\' >>> truncate_message(\\"Python coding challenges are fun and educational\\", 30) \'Python coding challenges are fun\' >>> truncate_message(\\"Data structures and algorithms\\", 50) \'Data structures and algorithms\' ``` # Additional Notes - Ensure your implementation handles edge cases appropriately, such as a single-word message. - Test your function with a variety of messages and limits to validate its correctness.","solution":"def truncate_message(message: str, limit: int) -> str: Truncates the input message to the specified limit ensuring no word is cut off. Arguments: message -- the original message limit -- the maximum allowed length of the truncated message Returns: A string containing the truncated message. if len(message) <= limit: return message truncated_message = \'\' words = message.split() for word in words: if len(truncated_message) + len(word) + (1 if truncated_message else 0) <= limit: truncated_message += (\' \' if truncated_message else \'\') + word else: break return truncated_message"},{"question":"# Binary Search Tree Operations You are required to implement specific operations of a Binary Search Tree (BST). A Binary Search Tree is a binary tree that follows the property where each node\'s left subtree contains only nodes with values less than the node\'s value, and each node\'s right subtree contains only nodes with values greater than the node\'s value. This implementation must support operations to insert nodes, find a node, find the minimum and maximum values, and delete nodes. **Objective**: Implement the following operations for a binary search tree: 1. **Insertion**: Insert a new value into the BST. 2. **Find Node**: Retrieve a node with a specified value from the BST. 3. **Find Minimum**: Return the minimum value node in the BST. 4. **Find Maximum**: Return the maximum value node in the BST. 5. **Delete Node**: Delete a node with a specified value from the BST. **Detailed Instructions**: 1. **Insert Operation** - Implement the method `insert(self, val)` in the `BinarySearchTree` class. - This method should insert the value `val` into the BST. - Ensure the BST properties are maintained after insertion. 2. **Find Node Operation** - Implement the method `find(self, val)` in the `BinarySearchTree` class. - This method should search for and return the node with the value `val`. - If the value is not found, return `None`. 3. **Find Minimum Operation** - Implement the method `find_min(self)` in the `BinarySearchTree` class. - This method should return the node with the minimum value in the BST. 4. **Find Maximum Operation** - Implement the method `find_max(self)` in the `BinarySearchTree` class. - This method should return the node with the maximum value in the BST. 5. **Delete Node Operation** - Implement the method `delete(self, val)` in the `BinarySearchTree` class. - This method should delete the node with the value `val` from the BST. - Ensure the BST properties are maintained after deletion. Here is the structure of the `BinarySearchTree` class and `TreeNode` class (already provided): ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinarySearchTree: def __init__(self): self.root = None def insert(self, val): # Insert logic pass def find(self, val): # Find logic pass def find_min(self): # Find minimum logic pass def find_max(self): # Find maximum logic pass def delete(self, val): # Delete logic pass ``` **Constraints**: 1. The `insert`, `delete`, `find`, `find_min`, and `find_max` operations should all be efficient and maintain the BST properties. 2. Duplicate values are not allowed in the BST. **Examples**: ```python # Insert and Find Node bst = BinarySearchTree() bst.insert(10) bst.insert(5) bst.insert(15) assert bst.find(5).val == 5 assert bst.find(20) == None # Find Minimum and Maximum bst.insert(2) bst.insert(20) assert bst.find_min().val == 2 assert bst.find_max().val == 20 # Delete Node bst.delete(10) assert bst.find(10) == None assert bst.find_min().val == 2 assert bst.find_max().val == 20 ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinarySearchTree: def __init__(self): self.root = None def insert(self, val): if self.root is None: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node, val): if val < node.val: if node.left is None: node.left = TreeNode(val) else: self._insert(node.left, val) elif val > node.val: if node.right is None: node.right = TreeNode(val) else: self._insert(node.right, val) def find(self, val): return self._find(self.root, val) def _find(self, node, val): if node is None or node.val == val: return node elif val < node.val: return self._find(node.left, val) else: return self._find(node.right, val) def find_min(self): return self._find_min(self.root) def _find_min(self, node): current = node while current and current.left is not None: current = current.left return current def find_max(self): return self._find_max(self.root) def _find_max(self, node): current = node while current and current.right is not None: current = current.right return current def delete(self, val): self.root = self._delete(self.root, val) def _delete(self, node, val): if node is None: return node if val < node.val: node.left = self._delete(node.left, val) elif val > node.val: node.right = self._delete(node.right, val) else: if node.left is None: return node.right elif node.right is None: return node.left temp_node = self._find_min(node.right) node.val = temp_node.val node.right = self._delete(node.right, temp_node.val) return node"},{"question":"# Problem Statement: Context: A sequence of numbers is called an arithmetic series if the difference between consecutive terms is constant. The arithmetic mean of a sequence is the sum of the terms divided by the number of terms. Your task is to enhance the given code to handle edge cases and optimize performance. Task: 1. Enhance the `is_arithmetic_series(series)` function to handle scenarios with floating-point precision issues and improve its validation checks. 2. Optimize the `arithmetic_mean(series)` function to handle large lists efficiently. Function Signature: ```python def is_arithmetic_series(series: list) -> bool def arithmetic_mean(series: list) -> float ``` Input Formats: - `is_arithmetic_series(series)`: A list of integers or floats. - `arithmetic_mean(series)`: A list of integers or floats. Output Formats: - `is_arithmetic_series(series)`: Returns a boolean value indicating if the series is arithmetic. - `arithmetic_mean(series)`: Returns a float, the arithmetic mean of the series. Constraints: - The input series list will have a length of up to 1000 elements. - The elements are strictly positive numbers. - Handle edge cases such as series with one element, and floating-point arithmetic issues. Example: ```python # Example inputs for is_arithmetic_series print(is_arithmetic_series([1, 3, 5, 7])) # True print(is_arithmetic_series([2, 4, 6, 9])) # False print(is_arithmetic_series([5, 5, 5, 5])) # True # Example inputs for arithmetic_mean print(arithmetic_mean([1, 3, 5, 7])) # 4.0 print(arithmetic_mean([0.2, 0.5, 0.8, 1.0])) # 0.625 ``` Performance Requirements: - Ensure efficient computation with minimal complexity. - Properly handle edge cases and possible errors. Implementation Details: - Extend the current functions to improve error handling and performance. - Add appropriate checks and use efficient algorithms for arithmetic mean calculations.","solution":"def is_arithmetic_series(series: list) -> bool: Returns True if the series forms an arithmetic sequence, False otherwise. if len(series) < 2: return True # A series with one element is trivially arithmetic # Calculate the common difference common_diff = series[1] - series[0] # Check if all consecutive differences are equal to the common difference for i in range(2, len(series)): if not abs((series[i] - series[i - 1]) - common_diff) < 1e-9: return False return True def arithmetic_mean(series: list) -> float: Returns the arithmetic mean of the series. if not series: raise ValueError(\\"Series must not be empty\\") # Sum the series and calculate the mean return sum(series) / len(series)"},{"question":"# Problem Statement Dijkstra\'s Algorithm is a graph search algorithm that solves the single-source shortest path problem for non-negative edge weights. Your task is to implement this algorithm to find the shortest path from a given source node to all other nodes in a weighted graph. # Function Signature ```python def dijkstra(n: int, edges: list[tuple[int, int, int]], src: int) -> list[int]: pass ``` # Input - `n` : An integer representing the number of nodes in the graph, numbered from 0 to n-1. - `edges` : A list of tuples `(u, v, w)` representing a directed edge from node `u` to node `v` with weight `w`. - `src` : An integer representing the source node from which to calculate the shortest paths. # Output - Returns a list of integers where the `i`-th element represents the shortest distance from the source node to node `i`. If node `i` is not reachable from the source, its distance should be represented as `float(\'inf\')`. # Constraints 1. `1 <= n <= 10^5` 2. `0 <= len(edges) <= 2 * 10^5` 3. `0 <= u, v < n` 4. `0 <= w <= 10^9` 5. `0 <= src < n` # Examples ```python assert dijkstra(5, [(0, 1, 10), (0, 4, 5), (1, 2, 1), (1, 4, 2), (2, 3, 4), (3, 0, 7), (3, 2, 6), (4, 1, 3), (4, 2, 9), (4, 3, 2)], 0) == [0, 8, 9, 7, 5] assert dijkstra(3, [(0, 1, 5), (1, 2, 2)], 0) == [0, 5, 7] assert dijkstra(3, [(0, 2, 5), (2, 1, 2)], 1) == [float(\'inf\'), 0, float(\'inf\')] ``` # Explanation 1. For the first example: - Node 0 to node 1 has the shortest path of weight 8 (0 -> 4 -> 1). - Node 0 to node 2 has the shortest path of weight 9 (0 -> 4 -> 1 -> 2). - Node 0 to node 3 has the shortest path of weight 7 (0 -> 4 -> 3). - Node 0 to node 4 has the shortest path of weight 5 (direct edge). 2. For the second example: - Node 0 to node 1 has a direct path with weight 5. - Node 0 to node 2 has a path of weight 7 via node 1. 3. For the third example: - Node 1 has no outgoing paths that make a loop back to itself or continue from node 1 since Dijkstra\'s algorithm does not handle negative cycles and thus relies on reachable paths with positive or zero-positive weight. Implement the function to solve for shortest paths using the Dijkstra\'s algorithm details provided. # Scenario You are managing a network of routes and nodes representing cities connected by roads with specific travel times. Given the travel times between connected cities, you need to determine the shortest travel time from a starting city to every other city. This is vital for logistics planning and minimizing travel costs.","solution":"import heapq def dijkstra(n, edges, src): graph = {i: [] for i in range(n)} for u, v, w in edges: graph[u].append((v, w)) distances = [float(\'inf\')] * n distances[src] = 0 priority_queue = [(0, src)] while priority_queue: current_distance, u = heapq.heappop(priority_queue) if current_distance > distances[u]: continue for v, weight in graph[u]: distance = current_distance + weight if distance < distances[v]: distances[v] = distance heapq.heappush(priority_queue, (distance, v)) return distances"},{"question":"# Problem: Shortest Path in a Weighted Graph You are tasked with implementing a function that finds the shortest path in a weighted, directed graph using Dijkstra\'s algorithm. The graph is represented by an adjacency list. Instructions: 1. **Function Name**: `shortest_path` 2. **Inputs**: * **graph** (dict): A dictionary where the keys are node identifiers and the values are lists of tuples. Each tuple represents a neighboring node and the weight of the edge connecting to it. * **start** (str): The starting node for the path. * **end** (str): The ending node for the path. 3. **Output**: * A tuple containing two elements: * **distance** (int): The shortest distance from the start node to the end node. * **path** (list): A list of nodes representing the shortest path from start to end. 4. **Constraints**: * The graph will not contain negative weight edges. * Assume all edge weights are positive. * The graph may be sparse, and the number of nodes can be very large. Example ```python graph = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'C\', 2), (\'D\', 5)], \'C\': [(\'D\', 1)], \'D\': [] } start = \'A\' end = \'D\' shortest_path(graph, start, end) ``` **Expected Output**: ```plaintext (4, [\'A\', \'B\', \'C\', \'D\']) ``` Edge Cases: 1. If the start node is the same as the end node, return a distance of 0 and a path containing only the start node. 2. If the end node is not reachable from the start node, return infinity and an empty path. **Deliverable**: Provide your complete implementation of the `shortest_path` function. Ensure your code handles edge cases effectively and efficiently computes the shortest path using Dijkstra\'s algorithm. ```python import heapq def shortest_path(graph: dict, start: str, end: str) -> tuple: # Initialize the distance dictionary with infinity for all nodes except the start node distances = {node: float(\'infinity\') for node in graph} distances[start] = 0 # Priority queue to hold the nodes to be processed priority_queue = [(0, start, [start])] while priority_queue: current_distance, current_node, path = heapq.heappop(priority_queue) # If we reached the end node, return the result if current_node == end: return current_distance, path # Process each neighbor of the current node for neighbor, weight in graph.get(current_node, []): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor, path + [neighbor])) return float(\'infinity\'), [] # Example usage graph = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'C\', 2), (\'D\', 5)], \'C\': [(\'D\', 1)], \'D\': [] } start = \'A\' end = \'D\' print(shortest_path(graph, start, end)) ```","solution":"import heapq def shortest_path(graph: dict, start: str, end: str) -> tuple: Finds the shortest path in a weighted directed graph using Dijkstra\'s algorithm. Args: graph (dict): The graph represented as an adjacency list. start (str): The start node. end (str): The end node. Returns: tuple: A tuple containing the shortest distance and the shortest path as list of nodes. # Initialize the distance dictionary with infinity for all nodes except the start node distances = {node: float(\'inf\') for node in graph} distances[start] = 0 # Priority queue to hold the nodes to be processed priority_queue = [(0, start, [start])] while priority_queue: current_distance, current_node, path = heapq.heappop(priority_queue) # If we reached the end node, return the result if current_node == end: return current_distance, path # Process each neighbor of the current node for neighbor, weight in graph.get(current_node, []): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor, path + [neighbor])) return float(\'inf\'), [] # Example usage graph = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'C\', 2), (\'D\', 5)], \'C\': [(\'D\', 1)], \'D\': [] } start = \'A\' end = \'D\' print(shortest_path(graph, start, end)) # Output: (4, [\'A\', \'B\', \'C\', \'D\'])"},{"question":"# Coding Assessment Question Binary Tree In-Order Traversal Sum Calculator You are required to implement a function that calculates the sum of all the values of nodes retrieved using an **in-order traversal** of a binary tree. Your task is to use a recursive or iterative approach to perform the in-order traversal and sum the node values. Function Signature ```python def inorder_sum(root: Optional[TreeNode]) -> int: pass ``` Input - A binary tree represented by its root node `root`, where each node contains an integer value. - A node is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Output - An integer representing the sum of all node values encountered during the in-order traversal. Constraints - The number of nodes in the binary tree will be in the range [0, 10000]. - Node values are integers. - Handle edge cases such as an empty tree correctly. Example ```python # Example 1 root = TreeNode(1, None, TreeNode(2, TreeNode(3), None)) assert inorder_sum(root) == 6, \\"Test case 1 failed\\" # Example 2 root = TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(6, TreeNode(5), TreeNode(7))) assert inorder_sum(root) == 28, \\"Test case 2 failed\\" # Example 3 root = None assert inorder_sum(root) == 0, \\"Test case 3 failed\\" ``` Notes - You may not use built-in functions to perform the in-order traversal. - Focus on writing clean and efficient code. - You may include additional helper functions if necessary. Good luck, and ensure your traversal is both accurate and efficient!","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_sum(root: Optional[TreeNode]) -> int: Calculates the sum of all values of nodes using an in-order traversal of a binary tree. def inorder(node): if node is None: return 0 return inorder(node.left) + node.val + inorder(node.right) return inorder(root)"},{"question":"# Real Estate Price Prediction with Linear Regression Context: You have been provided with a dataset containing various features of houses and their corresponding prices. Using this data, you are to build a linear regression model to predict the prices of houses based on their features. Task: 1. Load the dataset and preprocess it, ensuring it is clean and ready for modeling. 2. Split the dataset into training and test sets. 3. Implement a linear regression model to predict house prices. 4. Evaluate the model\'s performance on the test set using R-squared and Mean Absolute Error (MAE) metrics. Requirements: 1. **Input**: The path to the CSV file containing the dataset. 2. **Output**: A tuple `(r_squared, mae)`: * `r_squared`: A float representing the R-squared value of the model\'s predictions. * `mae`: A float representing the Mean Absolute Error of the model\'s predictions. Input and Output Constraints: * The CSV file will contain columns such as \'Area\', \'Bedrooms\', \'Bathrooms\', \'Stories\', \'Garage\', and \'Price\'. * The splits for the training and test sets should be 80% and 20%, respectively. Implementation: Your solution should: 1. Load the dataset from the specified path. 2. Preprocess the data by handling any missing values, encoding categorical variables if necessary, and normalizing the features. 3. Split the data into training and test sets. 4. Train a linear regression model on the training set. 5. Make predictions on the test set and evaluate the model using R-squared and MAE. Function Signature: ```python def real_estate_price_prediction(file_path: str) -> tuple: pass ``` Example: ```python >>> real_estate_price_prediction(\\"real_estate_data.csv\\") (0.87, 14500.67) ```","solution":"import pandas as pd from sklearn.model_selection import train_test_split from sklearn.linear_model import LinearRegression from sklearn.metrics import r2_score, mean_absolute_error def real_estate_price_prediction(file_path: str) -> tuple: # Load the dataset data = pd.read_csv(file_path) # Preprocess the data # Assuming columns are \'Area\', \'Bedrooms\', \'Bathrooms\', \'Stories\', \'Garage\', \'Price\' X = data[[\'Area\', \'Bedrooms\', \'Bathrooms\', \'Stories\', \'Garage\']] y = data[\'Price\'] # Split the data into training and testing sets (80% training, 20% testing) X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Build the linear regression model model = LinearRegression() model.fit(X_train, y_train) # Make predictions on the test set y_pred = model.predict(X_test) # Evaluate the model r_squared = r2_score(y_test, y_pred) mae = mean_absolute_error(y_test, y_pred) return (r_squared, mae)"},{"question":"Implementation of a Simple Genetic Algorithm You are required to implement a simple Genetic Algorithm (GA) to solve a binary string optimization problem. Your task is to implement the following functions: 1. **initialize_population** - To create an initial population of binary strings. 2. **fitness** - To evaluate the fitness of a binary string. 3. **selection** - To select pairs of parent strings for crossover. 4. **crossover** - To perform crossover between pairs of parent strings. 5. **mutation** - To mutate binary strings with a given mutation probability. 6. **evolve** - To evolve the population over a specified number of generations. # Function Definitions Function 1: initialize_population ```python def initialize_population(pop_size: int, string_length: int) -> list[str]: Generate the initial population of binary strings. Args: - pop_size (int): Number of individuals in the population. - string_length (int): Length of each binary string. Returns: - list[str]: List of binary strings representing the initial population. ``` Function 2: fitness ```python def fitness(binary_string: str) -> int: Compute the fitness of a binary string. Higher number of \'1\'s implies higher fitness. Args: - binary_string (str): Binary string to evaluate. Returns: - int: Fitness value of the binary string. ``` Function 3: selection ```python def selection(population: list[str], fitnesses: list[int]) -> list[str]: Select pairs of parents using roulette wheel selection based on fitness. Args: - population (list[str]): List of binary strings representing the population. - fitnesses (list[int]): Corresponding fitness values of the population. Returns: - list[str]: List of selected parent binary strings. ``` Function 4: crossover ```python def crossover(parents: list[str], crossover_rate: float) -> list[str]: Perform single-point crossover between pairs of parents. Args: - parents (list[str]): List of selected parent binary strings. - crossover_rate (float): Probability of crossover occurring. Returns: - list[str]: List of binary strings representing the new generation after crossover. ``` Function 5: mutation ```python def mutation(population: list[str], mutation_rate: float) -> list[str]: Mutate the binary strings with a given mutation rate. Args: - population (list[str]): List of binary strings representing the population. - mutation_rate (float): Probability of flipping each bit. Returns: - list[str]: List of mutated binary strings. ``` Function 6: evolve ```python def evolve(initial_population: list[str], generations: int, crossover_rate: float, mutation_rate: float) -> list[str]: Evolve the population over a specified number of generations. Args: - initial_population (list[str]): Initial population of binary strings. - generations (int): Number of generations to evolve. - crossover_rate (float): Probability of crossover occurring. - mutation_rate (float): Probability of flipping each bit. Returns: - list[str]: Final population after evolution. ``` # Input and Output - **Input**: - pop_size: Integer representing the number of individuals in the population. - string_length: Integer representing the length of each binary string. - generations: Integer representing the number of generations. - crossover_rate: Float representing the crossover rate (0.0 to 1.0). - mutation_rate: Float representing the mutation rate (0.0 to 1.0). - **Output**: - List of binary strings representing the population after evolution. # Constraints - The population size (`pop_size`) is an integer within the range [1, 100]. - The string length (`string_length`) is an integer within the range [1, 50]. - The crossover rate (`crossover_rate`) and mutation rate (`mutation_rate`) are floats within the range [0.0, 1.0]. - All binary strings consist of characters \'0\' and \'1\' only. # Additional Notes - Make sure to handle edge cases, such as an odd population size during crossover. - Optimize your code for readability and efficiency. - Include appropriate comments and docstrings for clarity. # Example Usage ```python pop_size = 10 string_length = 8 generations = 5 crossover_rate = 0.7 mutation_rate = 0.01 # Initialize Population initial_population = initialize_population(pop_size, string_length) # Evolve the population final_population = evolve(initial_population, generations, crossover_rate, mutation_rate) print(f\\"Final population after {generations} generations: {final_population}\\") ```","solution":"import random def initialize_population(pop_size: int, string_length: int) -> list[str]: Generate the initial population of binary strings. Args: - pop_size (int): Number of individuals in the population. - string_length (int): Length of each binary string. Returns: - list[str]: List of binary strings representing the initial population. return [\'\'.join(random.choice(\'01\') for _ in range(string_length)) for _ in range(pop_size)] def fitness(binary_string: str) -> int: Compute the fitness of a binary string. Higher number of \'1\'s implies higher fitness. Args: - binary_string (str): Binary string to evaluate. Returns: - int: Fitness value of the binary string. return binary_string.count(\'1\') def selection(population: list[str], fitnesses: list[int]) -> list[str]: Select pairs of parents using roulette wheel selection based on fitness. Args: - population (list[str]): List of binary strings representing the population. - fitnesses (list[int]): Corresponding fitness values of the population. Returns: - list[str]: List of selected parent binary strings. total_fitness = sum(fitnesses) weights = [f/total_fitness for f in fitnesses] selected_parents = random.choices(population, weights=weights, k=len(population)) return selected_parents def crossover(parents: list[str], crossover_rate: float) -> list[str]: Perform single-point crossover between pairs of parents. Args: - parents (list[str]): List of selected parent binary strings. - crossover_rate (float): Probability of crossover occurring. Returns: - list[str]: List of binary strings representing the new generation after crossover. new_generation = [] for i in range(0, len(parents), 2): parent1 = parents[i] parent2 = parents[i+1 if i+1 < len(parents) else i] if random.random() < crossover_rate and parent1 != parent2: crossover_point = random.randint(1, len(parent1) - 1) offspring1 = parent1[:crossover_point] + parent2[crossover_point:] offspring2 = parent2[:crossover_point] + parent1[crossover_point:] new_generation.extend([offspring1, offspring2]) else: new_generation.extend([parent1, parent2]) return new_generation def mutation(population: list[str], mutation_rate: float) -> list[str]: Mutate the binary strings with a given mutation rate. Args: - population (list[str]): List of binary strings representing the population. - mutation_rate (float): Probability of flipping each bit. Returns: - list[str]: List of mutated binary strings. mutated_population = [] for individual in population: mutated_individual = \'\'.join( bit if random.random() > mutation_rate else \'1\' if bit == \'0\' else \'0\' for bit in individual ) mutated_population.append(mutated_individual) return mutated_population def evolve(initial_population: list[str], generations: int, crossover_rate: float, mutation_rate: float) -> list[str]: Evolve the population over a specified number of generations. Args: - initial_population (list[str]): Initial population of binary strings. - generations (int): Number of generations to evolve. - crossover_rate (float): Probability of crossover occurring. - mutation_rate (float): Probability of flipping each bit. Returns: - list[str]: Final population after evolution. population = initial_population for _ in range(generations): fitnesses = [fitness(individual) for individual in population] selected_parents = selection(population, fitnesses) population = crossover(selected_parents, crossover_rate) population = mutation(population, mutation_rate) return population"},{"question":"# Context You are working on a data processing script that filters and sorts large datasets. One of the tasks is to implement a function that removes any duplicate values from a list of integers and returns the list sorted in ascending order. Your goal is to ensure the solution is efficient even for large lists. # Task Implement a function `remove_duplicates_and_sort(nums: List[int]) -> List[int]` that takes a list of integers, removes any duplicate values, and returns the list sorted in ascending order. # Function Signature ```python def remove_duplicates_and_sort(nums: List[int]) -> List[int]: pass ``` # Input - `nums`: A list of integers, where each integer can be positive, negative, or zero. # Output - A sorted list of integers with all duplicates removed. # Constraints - The function should handle large lists efficiently. # Performance Requirements - The implementation must efficiently handle lists with up to 10^5 elements. # Example Example 1: ```python >>> remove_duplicates_and_sort([4, 6, 2, 2, 6, 4, 7, 5, 1]) [1, 2, 4, 5, 6, 7] ``` Example 2: ```python >>> remove_duplicates_and_sort([10, -1, 2, -1, 10, 5, 3, 2]) [-1, 2, 3, 5, 10] ``` Example 3: ```python >>> remove_duplicates_and_sort([0, 1, 0, 0, 1]) [0, 1] ``` # Notes - You can use built-in collection types and methods to help with the removal of duplicates and sorting. - Ensure the function\'s time and space complexity are well-optimized for large input sizes.","solution":"from typing import List def remove_duplicates_and_sort(nums: List[int]) -> List[int]: Takes a list of integers, removes any duplicate values, and returns the list sorted in ascending order. return sorted(set(nums))"},{"question":"# Binary Search Tree Insertion and Validation Background: A Binary Search Tree (BST) is a tree data structure in which each node has at most two children referred to as the left child and the right child. For each node, all elements in its left subtree are less than the node, and all elements in its right subtree are greater than the node. BSTs are useful for performing efficient searches, insertions, and deletions due to their ordered structure. Task: You need to implement two functionalities, `bst_insert` to insert values into the BST and `is_valid_bst` to validate if a given tree is a Binary Search Tree. Your implementation should correctly enforce the BST properties during insertion and check for BST properties during validation. Function Definitions and Requirements: 1. `bst_insert(root: Optional[\'TreeNode\'], value: int) -> \'TreeNode\'`: * **Input**: A BST represented by its root node and an integer value to be inserted. * **Output**: The root node of the BST after insertion. * **Constraints**: * If the root is `None`, create a new node with the given value and return it as the root. * Insert the value in the correct position to maintain BST properties. 2. `is_valid_bst(root: Optional[\'TreeNode\']) -> bool`: * **Input**: A BST represented by its root node. * **Output**: A boolean indicating whether the provided tree is a valid BST. * **Constraints**: * The function should return `True` if the tree is valid; otherwise, it should return `False`. Example Usage: ```python >>> root = None >>> root = bst_insert(root, 10) # Create the root node >>> root = bst_insert(root, 5) # Insert into the left subtree >>> root = bst_insert(root, 15) # Insert into the right subtree >>> is_valid_bst(root) True >>> root = bst_insert(root, 3) >>> root = bst_insert(root, 7) >>> is_valid_bst(root) True >>> invalid_bst = TreeNode(10) >>> invalid_bst.left = TreeNode(15) # Invalid BST because left child is greater than root >>> is_valid_bst(invalid_bst) False ``` TreeNode Class Definition: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Guidelines: * Focus on maintaining and validating the BST properties during insertion and validation. * Ensure your implementation handles edge cases, such as empty trees and single-node trees. * Aim for optimal time and space complexity using recursion or iteration as appropriate. * Use standard practices for defining and working with tree structures in Python.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bst_insert(root, value): Inserts a value into the BST and returns the root node of the tree. if root is None: return TreeNode(val=value) if value < root.val: root.left = bst_insert(root.left, value) else: root.right = bst_insert(root.right, value) return root def is_valid_bst(root, low=float(\'-inf\'), high=float(\'inf\')): Validates if the given tree is a valid binary search tree. if root is None: return True if not (low < root.val < high): return False return (is_valid_bst(root.left, low, root.val) and is_valid_bst(root.right, root.val, high))"},{"question":"# Problem Statement You are tasked with analyzing a set of text documents to identify certain patterns and statistics for further processing. The goal is to create a function that reads a list of text documents and computes the number of occurrences of a given word along with the total word count of each document. # Requirements 1. **Function Name**: `analyze_documents(docs: List[str], target_word: str) -> DataFrame` 2. **Input**: - `docs`: A list of strings, where each string represents the path to a text document on the local filesystem. - `target_word`: A single string representing the word to be counted in each document. 3. **Output**: - A Pandas DataFrame with the columns: [\\"Document Name\\", \\"Total Words\\", \\"Target Word Count\\"]. 4. **Functionality Expectations**: - Open and read each document specified in the `docs` list. - Calculate the total word count in each document. - Calculate the number of occurrences of `target_word` in each document. - Store the results in a Pandas DataFrame. - Handle file I/O errors gracefully. 5. **Performance Requirements**: - The function should handle cases with up to 100 documents efficiently. - The size of each document can vary, but the function should complete within a reasonabl timeframe (e.g., under 2 seconds per document). # Constraints - Use the **Pandas** and **os** libraries. - The function should be robust to handle edge cases, such as empty documents or non-existent files. # Example ```python from pandas import DataFrame from typing import List import os def analyze_documents(docs: List[str], target_word: str) -> DataFrame: results = [] for doc in docs: try: with open(doc, \'r\') as file: text = file.read() total_words = len(text.split()) target_word_count = text.lower().count(target_word.lower()) results.append([os.path.basename(doc), total_words, target_word_count]) except FileNotFoundError: results.append([os.path.basename(doc), \\"File not found\\", \\"N/A\\"]) except Exception as e: results.append([os.path.basename(doc), f\\"Error: {e}\\", \\"N/A\\"]) df = DataFrame(results, columns=[\\"Document Name\\", \\"Total Words\\", \\"Target Word Count\\"]) return df if __name__ == \\"__main__\\": docs = [\\"document1.txt\\", \\"document2.txt\\", \\"document3.txt\\"] target_word = \\"Python\\" df = analyze_documents(docs, target_word) print(df) ``` # Edge Cases to Consider - If a document is empty or does not exist, handle these scenarios without breaking the function. - Ensure the case-insensitivity while counting the `target_word`. - Handle documents of various sizes efficiently. This problem gives practice in file I/O operations, text processing, error handling, and employing Pandas for data manipulation, closely aligning with the sample question in terms of style, complexity, and scope.","solution":"from pandas import DataFrame from typing import List import os def analyze_documents(docs: List[str], target_word: str) -> DataFrame: results = [] for doc in docs: try: with open(doc, \'r\') as file: text = file.read() total_words = len(text.split()) target_word_count = text.lower().split().count(target_word.lower()) results.append([os.path.basename(doc), total_words, target_word_count]) except FileNotFoundError: results.append([os.path.basename(doc), \\"File not found\\", \\"N/A\\"]) except Exception as e: results.append([os.path.basename(doc), f\\"Error: {e}\\", \\"N/A\\"]) df = DataFrame(results, columns=[\\"Document Name\\", \\"Total Words\\", \\"Target Word Count\\"]) return df"},{"question":"# Coding Assessment Question: Matrix Diagonal Sum You are tasked with implementing two essential functions to handle square matrices: calculating the sum of the primary diagonal and the sum of the secondary diagonal. - **Function 1: `primary_diagonal_sum(matrix: list[list[int]]) -> int`** - **Description**: Calculate the sum of the primary diagonal of the square matrix. - **Input**: A list of lists of integers representing the square matrix. - **Output**: An integer representing the sum of the primary diagonal elements. - **Constraints**: - The input must be a non-empty square matrix (i.e., same number of rows and columns). - **Edge Cases**: - Raise a `ValueError` for invalid inputs, including non-list inputs or non-square matrices. - **Function 2: `secondary_diagonal_sum(matrix: list[list[int]]) -> int`** - **Description**: Calculate the sum of the secondary diagonal of the square matrix. - **Input**: A list of lists of integers representing the square matrix. - **Output**: An integer representing the sum of the secondary diagonal elements. - **Constraints**: - The input must be a non-empty square matrix (i.e., same number of rows and columns). - **Edge Cases**: - Raise a `ValueError` for invalid inputs or non-square matrices. Example: ```python # Example Matrix matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Example Function Calls: print(primary_diagonal_sum(matrix)) # Output: 15 print(secondary_diagonal_sum(matrix)) # Output: 15 # Example Invalid Call: print(primary_diagonal_sum([])) # Output: Raises ValueError # Non-Square matrix example: print(secondary_diagonal_sum([[1, 2], [3, 4, 5]])) # Output: Raises ValueError ``` Performance Requirement: - Both functions should operate in linear time, O(n), where n is the number of rows/columns in the matrix. **Notes**: - You can assume the matrix will have dimensions smaller than 1000x1000. - Use proper exception handling to deal with invalid input scenarios. Implement the functions according to the given specifications.","solution":"def primary_diagonal_sum(matrix: list[list[int]]) -> int: Calculate the sum of the primary diagonal of the square matrix. :param matrix: list of lists of integers representing the square matrix :return: Integer representing the sum of the primary diagonal elements :raises ValueError: If input is invalid (non-list or non-square matrix) if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): raise ValueError(\\"Input must be a list of lists\\") n = len(matrix) if n == 0 or not all(len(row) == n for row in matrix): raise ValueError(\\"Matrix must be non-empty and square\\") return sum(matrix[i][i] for i in range(n)) def secondary_diagonal_sum(matrix: list[list[int]]) -> int: Calculate the sum of the secondary diagonal of the square matrix. :param matrix: list of lists of integers representing the square matrix :return: Integer representing the sum of the secondary diagonal elements :raises ValueError: If input is invalid (non-list or non-square matrix) if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): raise ValueError(\\"Input must be a list of lists\\") n = len(matrix) if n == 0 or not all(len(row) == n for row in matrix): raise ValueError(\\"Matrix must be non-empty and square\\") return sum(matrix[i][n - 1 - i] for i in range(n))"},{"question":"# Problem Statement You are given a collection of containers, each with a certain capacity and containing a certain number of items. You need to transfer items between containers without exceeding any container\'s capacity and determine the maximum number of different items that can be present in any single container after some optimal transfers. Write a function `optimize_capacities` that calculates the maximum variety of items in any single container after the redistribution. # Input * A list of integers `capacities[i]` where `capacities[i]` represents the capacity of the i-th container. * A list of integers `items[i]` where `items[i]` represents the number of items currently in the i-th container. * Both lists have the same length n (1 ≤ n ≤ 1000). # Output * An integer representing the maximum number of different items any single container can hold after redistribution. # Constraints * You should not exceed any container\'s capacity during redistribution. * Items can only be transferred without splitting; every unit stays in its entirety. # Example For example, with containers: - capacities: [5, 8, 3] - items: [3, 7, 2] After redistribution, one way to optimize might be: - First container: 5 items (3 from the first, 2 from the third) - Second container: 7 items (start) - Third container: 0 items So the maximum different items in any single container are: 5 * ```python def optimize_capacities(capacities, items): Returns the maximum variety of items that can be present in any single container after redistributing within capacity constraints. >>> optimize_capacities([5, 8, 3], [3, 7, 2]) Returns 6 # Your code here. pass ``` # Explanation Your implementation should efficiently compute the optimal redistribution of items to maximize the number of different items in any single container without exceeding its capacity. You should consider all possibilities to find the global optimal solution and handle large inputs within the constraints effectively.","solution":"def optimize_capacities(capacities, items): Returns the maximum variety of items that can be present in any single container after redistributing within capacity constraints. sorted_items = sorted(items, reverse=True) max_different_items = 0 for capacity in capacities: different_items = 0 remaining_capacity = capacity for item in sorted_items: if remaining_capacity >= item: remaining_capacity -= item different_items += 1 max_different_items = max(max_different_items, different_items) return max_different_items"},{"question":"# Validating an All-Digit Reversal Number Problem Statement An all-digit reversal number is a number formed by reversing the digits of a number and appending the reversal to the original number. For example, the reversal number of `123` is `123321`. The task is to check if an all-digit reversal number is a prime number. A prime number is a number greater than 1 that has no positive divisors other than 1 and itself. Write a function `check_reversal_prime` that takes an integer `n` as input and returns a boolean indicating whether the reversal number of `n` is prime. Function Signature ```python def check_reversal_prime(n: int) -> bool: pass ``` # Input - An integer `n` (1 <= n <= 10^5) # Output - A boolean value `True` if the reversal number of `n` is prime, else `False`. # Constraints - Consider reversal numbers formed by reversing and appending the digits of `n`. - Ensure that the function runs efficiently to handle the large range of `n`. Example ```python print(check_reversal_prime(123)) # Outputs: False (123321 is not prime) print(check_reversal_prime(13)) # Outputs: True (1331 is prime) ``` # Explanation For `n = 123`, the reversal number is `123321`. Check if `123321` is prime. It is not, so the output is `False`. For `n = 13`, the reversal number is `1331`. Check if `1331` is prime. It is, so the output is `True`. Scenario You are tasked with verifying the primality of numbers formed by a unique process of digit manipulation in a given range. This involves understanding properties of prime numbers and efficiently checking large numbers for primality. Your algorithm should handle the constraints effectively to ensure rapid checking within the given bounds.","solution":"def check_reversal_prime(n: int) -> bool: def is_prime(num: int) -> bool: if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True str_n = str(n) reversed_str_n = str_n[::-1] reversal_number = int(str_n + reversed_str_n) return is_prime(reversal_number)"},{"question":"**Question:** You are given an array of integers and an integer `k`. Your task is to find the `k`-th largest unique element in the array. If there are fewer than `k` unique elements, return -1. # Task Implement the function `kth_largest_unique_element` to solve the problem. # Input - **arr**: A list of integers. - **k**: An integer representing which element to find. # Output - **Return Type**: Integer - **Description**: The `k`-th largest unique integer in the array, or -1 if there are fewer than `k` unique integers. # Constraints and Notes: - The elements in `arr` can be negative, zero, or positive, and the array can be of any size from 0 to 10^5. - The value of `k` is a positive integer and will not exceed the length of the input array. - You should aim to have an efficient solution with a time complexity of O(n log n) or better if possible. # Example: Example 1 ```python Input: arr = [3, 1, 2, 1, 4, 3, 5] k = 2 Output: 4 Explanation: The unique elements in descending order are [5, 4, 3, 2, 1]. The 2nd largest unique element is 4. ``` Example 2 ```python Input: arr = [7, 7, 7] k = 1 Output: 7 Explanation: The only unique element is 7, and the 1st largest unique element is 7. ``` Example 3 ```python Input: arr = [3, 1, 2, 2, 1, 3] k = 4 Output: -1 Explanation: There are only 3 unique elements [3, 1, 2]. Since we need the 4th largest unique element which doesn\'t exist, the output is -1. ``` # Implementation: ```python def kth_largest_unique_element(arr: list, k: int) -> int: unique_elements = list(set(arr)) unique_elements.sort(reverse=True) if len(unique_elements) < k: return -1 return unique_elements[k-1] if __name__ == \\"__main__\\": arr = [3, 1, 2, 1, 4, 3, 5] k = 2 print(kth_largest_unique_element(arr, k)) # Should print 4 ```","solution":"def kth_largest_unique_element(arr, k): Find the k-th largest unique element in the array. If there are fewer than k unique elements, return -1. unique_elements = list(set(arr)) unique_elements.sort(reverse=True) if len(unique_elements) < k: return -1 return unique_elements[k-1]"},{"question":"# Binary Search Tree Level Order Traversal **Scenario**: You are given a Binary Search Tree (BST) and need to perform a level-order traversal (Breadth-First Search). The level-order traversal of a BST visits all nodes at each depth level from left to right, starting from the root node. Implement a function in Python to perform level-order traversal of a BST and return the values in a specific format. # Function Signature ```python def bst_level_order_traversal(root: TreeNode) -> List[List[int]]: pass ``` # Input 1. `root` (TreeNode): The root node of the binary search tree. # Output - `List[List[int]]`: A list of lists, where each sublist contains integer values at each level, from top to bottom. # Constraints - Node values will be unique. - The height of the BST will not exceed 1000. - You may assume that the TreeNode class is already defined as follows: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` # Performance Requirements - The implementation should efficiently handle BSTs of large sizes. # Examples ```python # Example 1: # Construct the following BST: # 4 # / # 2 6 # / / # 1 3 5 7 root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(6) root.left.left = TreeNode(1) root.left.right = TreeNode(3) root.right.left = TreeNode(5) root.right.right = TreeNode(7) print(bst_level_order_traversal(root)) # Expected Output: [[4], [2, 6], [1, 3, 5, 7]] # Example 2: # Construct the following BST: # 3 # / # 1 4 # # 2 5 root = TreeNode(3) root.left = TreeNode(1) root.right = TreeNode(4) root.left.right = TreeNode(2) root.right.right = TreeNode(5) print(bst_level_order_traversal(root)) # Expected Output: [[3], [1, 4], [2, 5]] ``` Write a function `bst_level_order_traversal` following the provided function signature and satisfy the requirements outlined. **Solution**: Here is an implementation of the function in Python: ```python from collections import deque from typing import List class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def bst_level_order_traversal(root: TreeNode) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result ``` This function uses a queue to perform a breadth-first search (level-order traversal) on the binary search tree and returns the values at each level as specified.","solution":"from collections import deque from typing import List class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def bst_level_order_traversal(root: TreeNode) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"# Coding Question Scenario You are a developer tasked with implementing a function that determines if a given list of integers contains a subset that sums up to a specified target value. You want to explore this using a recursive backtracking approach to ensure thorough examination of potential subsets. Requirements Implement a function `has_subset_with_sum` that takes a list of integers and a target sum, and returns a boolean value indicating whether any subset of the list sums up to the target. Function Signature ```python def has_subset_with_sum(nums: list[int], target: int) -> bool: ``` Input * `nums`: A list of integers. * `target`: An integer representing the desired subset-sum. Output * A boolean value that is `True` if there exists a subset of `nums` that adds up to `target`, `False` otherwise. Constraints 1. You may not use any external libraries for subset-sum solutions (such as `itertools`). 2. Assume `nums` length will not exceed 20 for simplicity. Example ```python >>> has_subset_with_sum([3, 34, 4, 12, 5, 2], 9) True >>> has_subset_with_sum([3, 34, 4, 12, 5, 2], 30) False >>> has_subset_with_sum([1, 2, 3, 4], 10) True ``` Edge Cases 1. `nums` is empty. 2. `nums` has one element. 3. `target` is 0. 4. `target` is negative. Hint Use a recursive function to explore each element, deciding whether to include it in the current subset or not, and check if any path leads to the target sum.","solution":"def has_subset_with_sum(nums, target): def backtrack(index, current_sum): if current_sum == target: return True if index == len(nums) or current_sum > target: return False return backtrack(index + 1, current_sum + nums[index]) or backtrack(index + 1, current_sum) return backtrack(0, 0)"},{"question":"# Sorting and Searching Using Merge Sort **Context**: You are handling a large dataset and need to efficiently sort and search the dataset to find specific elements. Using the Merge Sort algorithm ensures that the sort operation is performed efficiently. Once sorted, you will also implement a binary search function to quickly locate elements in the sorted list. Problem Statement Implement the following functions to sort a list using Merge Sort and search for elements using Binary Search. Your task involves implementing the core functionality and ensuring that the implementations are efficient and correct. 1. **Implement the `merge_sort` function to sort a list of integers using the Merge Sort algorithm.** 2. **Implement the `binary_search` function to search for an integer in a sorted list using the Binary Search algorithm.** Function Signatures ```python def merge_sort(arr: list[int]) -> list[int]: Sorts a list of integers using the Merge Sort algorithm. Args: arr (list[int]): A list of integers to be sorted. Returns: list[int]: A new list with the sorted integers. pass def binary_search(arr: list[int], target: int) -> int: Searches for an integer in a sorted list using the Binary Search algorithm and returns its index. Args: arr (list[int]): A sorted list of integers. target (int): The integer to search for. Returns: int: The index of the target in the list if found, otherwise -1. pass ``` Constraints - The `merge_sort` function should divide the list into halves and merge them back in sorted order. - The `binary_search` function should return the index of the target element if found, otherwise, it should return -1. - Both functions should handle edge cases such as empty lists and single-element lists gracefully. - Both functions should have a time complexity of O(log n) for Binary Search and O(n log n) for Merge Sort. Example Execution ```python sorted_list = merge_sort([34, 7, 23, 32, 5, 62]) # Output: [5, 7, 23, 32, 34, 62] index = binary_search([5, 7, 23, 32, 34, 62], 23) # Output: 2 index = binary_search([5, 7, 23, 32, 34, 62], 8) # Output: -1 ``` Additional Notes - Ensure the `merge_sort` and `binary_search` functions are optimized for performance. - Include appropriate checks for the input list to handle special cases. - You may implement helper functions if necessary, as long as the primary function signatures are adhered to.","solution":"def merge_sort(arr: list[int]) -> list[int]: Sorts a list of integers using the Merge Sort algorithm. Args: arr (list[int]): A list of integers to be sorted. Returns: list[int]: A new list with the sorted integers. if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: list[int], right: list[int]) -> list[int]: result = [] i, j = 0, 0 while i < len(left) and j < len(right): if left[i] < right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result def binary_search(arr: list[int], target: int) -> int: Searches for an integer in a sorted list using the Binary Search algorithm and returns its index. Args: arr (list[int]): A sorted list of integers. target (int): The integer to search for. Returns: int: The index of the target in the list if found, otherwise -1. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Binary Search Tree Insertion Objective You are required to implement a function that inserts a value into a binary search tree (BST). To assess your understanding of BST properties, ensure that your insertion maintains the properties of the BST. Requirements 1. **Function Signature**: `insert_into_bst(root: Optional[TreeNode], val: int) -> TreeNode` 2. **Input**: * `root`: The root node of the binary search tree (can be `None` if the tree is empty). * `val`: An integer value to be inserted into the BST. 3. **Output**: * The root node of the BST after the insertion. Constraints * You must implement the insertion method and cannot use predefined data structures (e.g., Python\'s list or set) for the BST. * Handle edge cases such as inserting into an empty BST and inserting duplicate values appropriately (you can choose whether to allow duplicates). TreeNode Structure Assume you have the following `TreeNode` class defined: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Scenario Suppose you are working on a personal project to create a self-sorting data structure for dynamic datasets where insertions happen frequently. You decide to use a binary search tree for this purpose. Example ```python # Example usage: def print_inorder(node): if not node: return print_inorder(node.left) print(node.val, end=\' \') print_inorder(node.right) # Example 1: root = None values = [5, 3, 8, 1, 4] for val in values: root = insert_into_bst(root, val) print_inorder(root) # Expected Output: 1 3 4 5 8 # Example 2: root = TreeNode(10) values = [5, 15, 3, 7, 12, 17] for val in values: root = insert_into_bst(root, val) print_inorder(root) # Expected Output: 3 5 7 10 12 15 17 # Example 3: root = TreeNode(2) values = [1, 3] for val in values: root = insert_into_bst(root, val) print_inorder(root) # Expected Output: 1 2 3 ``` Explanation * **In Example 1**: Starting with an empty tree, values `[5, 3, 8, 1, 4]` are inserted sequentially. The resulting BST, when traversed in-order, gives a sorted sequence `1, 3, 4, 5, 8`. * **In Example 2**: Starting with a root node `10`, values `[5, 15, 3, 7, 12, 17]` are inserted, resulting in a correctly structured BST with in-order traversal yielding `3, 5, 7, 10, 12, 15, 17`. * **In Example 3**: Starting with a root node `2`, values `[1, 3]` are inserted, maintaining BST properties, resulting in an in-order traversal of `1, 2, 3`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def insert_into_bst(root, val): Inserts a value into the binary search tree rooted at root. Args: root (TreeNode): The root of the binary search tree. val (int): The value to insert. Returns: TreeNode: The root of the binary search tree after the insertion. if root is None: return TreeNode(val) if val < root.val: root.left = insert_into_bst(root.left, val) elif val > root.val: root.right = insert_into_bst(root.right, val) else: # If duplicate values are not allowed, you can choose to do nothing. pass return root"},{"question":"Coding Assessment Question # Objective Write a function that analyzes a list of stock prices to find patterns of significant increase and decrease, ultimately identifying the best buying and selling opportunities. # Scenario You are working as a developer for a financial advisory firm that needs to predict stock movements based on historical price data. Your task is to process this data efficiently to find the days with the biggest price changes and recommend the optimal buying and selling points. # Task Implement the function `analyze_stock_prices` with the following requirements: 1. **Input**: * A list of integers representing the daily stock prices of a single stock. 2. **Output**: * A dictionary containing: * The index of the best day to buy. * The index of the best day to sell. * The maximum profit that can be made. 3. **Constraints**: * You must buy before you sell. * If no profit can be achieved, return indices as `-1` and profit as `0`. 4. **Performance Requirements**: * Ensure that the function runs in O(n) time complexity. # Constraints: * The length of the prices list is between 2 and 10,000. * Stock prices are non-negative integers less than 10,000. # Function Signature ```python def analyze_stock_prices(prices: List[int]) -> Dict[str, int]: ``` # Example ```python prices = [7, 1, 5, 3, 6, 4] result = analyze_stock_prices(prices) print(result) # Expected output: {\'buy_day\': 1, \'sell_day\': 4, \'max_profit\': 5} ``` # Additional Task * Write a test script that validates your function with at least three different price lists, including cases with no profit possible, consistent price increase, and consistent price decrease. Test edge cases with the smallest and largest possible lists.","solution":"from typing import List, Dict def analyze_stock_prices(prices: List[int]) -> Dict[str, int]: Analyzes a list of stock prices to determine the best buy and sell days for maximum profit. Args: prices (List[int]): A list of integers representing daily stock prices. Returns: Dict[str, int]: A dictionary containing: - \'buy_day\': index of the best day to buy (int) - \'sell_day\': index of the best day to sell (int) - \'max_profit\': maximum profit possible (int) if not prices or len(prices) < 2: return {\'buy_day\': -1, \'sell_day\': -1, \'max_profit\': 0} min_price_day = 0 max_profit = 0 buy_day = -1 sell_day = -1 for current_day in range(1, len(prices)): if prices[current_day] < prices[min_price_day]: min_price_day = current_day current_profit = prices[current_day] - prices[min_price_day] if current_profit > max_profit: max_profit = current_profit buy_day = min_price_day sell_day = current_day if max_profit == 0: return {\'buy_day\': -1, \'sell_day\': -1, \'max_profit\': 0} return {\'buy_day\': buy_day, \'sell_day\': sell_day, \'max_profit\': max_profit}"},{"question":"# Problem Statement You are tasked to create a function that, given a list of integers, returns a new list containing only the elements that appear exactly once in the input list. The order of elements in the returned list should be the same as their first occurrence in the input list. # Function Signature ```python def unique_elements(nums: list) -> list: pass ``` # Input * A list of integers `nums` (1 <= len(nums) <= 1000): The list of integers which may contain duplicates. # Output * A list of integers: A new list containing unique elements from the input list. # Example ```python >>> unique_elements([4, 3, 2, 4, 1, 3, 2, 5]) [1, 5] >>> unique_elements([1, 2, 2, 3, 4, 4, 5]) [1, 3, 5] ``` # Constraints * The input list `nums` will always contain at least one integer. * The integers in the list can be either positive or negative and may include zero.","solution":"def unique_elements(nums: list) -> list: Returns a list containing only elements that appear exactly once in the input list. The order of elements is preserved as per their first occurrence in the input list. from collections import Counter count = Counter(nums) return [num for num in nums if count[num] == 1]"},{"question":"# Problem: You are tasked with building a function that simulates a simple banking system where users can deposit, withdraw and transfer money between accounts. This function should maintain a record of user balances and ensure that operations are correctly processed. # Function Signature: ```python def banking_system(operations: List[Tuple[str, str, str, Union[float, None]]]) -> Dict[str, float]: Simulates a banking system with deposits, withdrawals, and transfers. :param operations: A list of operations to be processed. Each operation is a tuple consisting of: - a string indicating the type of operation (\\"deposit\\", \\"withdraw\\", \\"transfer\\") - a string indicating the user for \\"deposit\\" and \\"withdraw\\", or the source user for \\"transfer\\" - a string indicating the target user for \\"transfer\\" or None for \\"deposit\\" and \\"withdraw\\" - a float indicating the amount for \\"deposit\\" and \\"withdraw\\", or the transfer amount for \\"transfer\\" :return: A dictionary where the keys are user names and the values are their final balances (float). :raises ValueError: if an invalid operation is provided or if a user tries to withdraw/transfer more money than available. ``` # Input: * `operations`: A list of tuples representing banking operations. Each tuple contains: - A string representing the type of operation (`\\"deposit\\"`, `\\"withdraw\\"`, `\\"transfer\\"`). - A string representing the user for `\\"deposit\\"` and `\\"withdraw\\"`, or the source user for `\\"transfer\\"`. - A string representing the target user for `\\"transfer\\"` or `None` for `\\"deposit\\"` and `\\"withdraw\\"`. - A float representing the amount for `\\"deposit\\"` and `\\"withdraw\\"`, or the transfer amount for `\\"transfer\\"`. # Output: * A dictionary where keys are strings representing user names and values are floats representing their final balances. # Constraints: * The float amounts for deposits, withdrawals, and transfers will always be non-negative and given with up to two decimal places. * A user cannot withdraw or transfer more money than their current balance. * If a user performs an operation and does not exist yet, their initial balance should be considered as `0.0`. * Handle invalid operations by raising a `ValueError` with a descriptive message. # Example Usage: ```python operations = [ (\\"deposit\\", \\"Alice\\", None, 500.00), (\\"deposit\\", \\"Bob\\", None, 300.00), (\\"withdraw\\", \\"Alice\\", None, 200.00), (\\"transfer\\", \\"Alice\\", \\"Bob\\", 100.00) ] >>> banking_system(operations) {\'Alice\': 200.00, \'Bob\': 400.00} operations = [ (\\"deposit\\", \\"Charlie\\", None, 700.00), (\\"withdraw\\", \\"Charlie\\", None, 100.00), (\\"transfer\\", \\"Bob\\", \\"Charlie\\", 200.00), ] >>> banking_system(operations) {\'Charlie\': 800.00, \'Bob\': 100.00} ``` # Notes: * Handle invalid operations like trying to withdraw/transfer more than the user\'s balance by raising a `ValueError`. * Ensure to test for operations of sequence and scenarios like initially zero balances, multiple operations, etc.","solution":"from typing import List, Tuple, Union, Dict def banking_system(operations: List[Tuple[str, str, str, Union[float, None]]]) -> Dict[str, float]: balances = {} for operation in operations: op_type, user, target, amount = operation if user not in balances: balances[user] = 0.0 if op_type == \\"deposit\\": balances[user] += amount elif op_type == \\"withdraw\\": if balances[user] < amount: raise ValueError(f\\"Insufficient funds for {user}.\\") balances[user] -= amount elif op_type == \\"transfer\\": if target not in balances: balances[target] = 0.0 if balances[user] < amount: raise ValueError(f\\"Insufficient funds for {user}.\\") balances[user] -= amount balances[target] += amount else: raise ValueError(\\"Invalid operation type.\\") return balances"},{"question":"# Character Shifting Task Scenario You are tasked to create a utility for shifting characters within a given string based on specified positional values. Think of this utility as a supporting tool for performing various text transformations. Each character in the string is shifted right or left a specified number of positions within the alphabet. Task Implement two functions, `right_shift` and `left_shift`: 1. **right_shift(positions: List[int], text: str) -> str**: This function shifts each character in the text to the right by the positions specified. 2. **left_shift(positions: List[int], text: str) -> str**: This function shifts each character in the text to the left by the positions specified. Input and Output Formats * The `positions` parameter is a list of integers where each value represents the number of positions to shift the corresponding character. * The `text` parameter is a string containing only lowercase English letters. * The returned value should be the transformed string after the shifts. Shift Process 1. For each character in the text, shift it to the right or left by the corresponding number of positions in the `positions` list. 2. The shifting of characters should wrap around the alphabet. For example, shifting \'z\' by 1 to the right results in \'a\'. Constraints * The length of `positions` is equal to the length of `text`, which is between 1 and 10^6. * Each integer in `positions` is between 0 and 25. Example ```python def right_shift(positions: List[int], text: str) -> str: # TODO: Implement this function pass def left_shift(positions: List[int], text: str) -> str: # TODO: Implement this function pass >>> right_shift([1, 2, 3], \\"abc\\") \'bdf\' >>> left_shift([1, 2, 3], \\"bdf\\") \'abc\' ``` Notes * Make sure to handle the wrap around appropriately for both right and left shifts. * Consider the edge cases such as empty string or zero shifts.","solution":"from typing import List def right_shift(positions: List[int], text: str) -> str: Shifts each character in the text to the right by the specified positions. shifted_text = [] for i, char in enumerate(text): new_pos = (ord(char) - ord(\'a\') + positions[i]) % 26 shifted_text.append(chr(ord(\'a\') + new_pos)) return \'\'.join(shifted_text) def left_shift(positions: List[int], text: str) -> str: Shifts each character in the text to the left by the specified positions. shifted_text = [] for i, char in enumerate(text): new_pos = (ord(char) - ord(\'a\') - positions[i]) % 26 shifted_text.append(chr(ord(\'a\') + new_pos)) return \'\'.join(shifted_text)"},{"question":"# Question: Implement k-Nearest Neighbors (k-NN) Classifier You are given a labeled dataset and an unlabeled dataset. Write code to implement a k-Nearest Neighbors (k-NN) classifier to predict the labels of the unlabeled data points based on their proximity to the labeled data points. Requirements: 1. Implement the `knn_classifier()` function that performs the k-Nearest Neighbors algorithm. 2. The function should take the feature matrix and labels of the training data, the feature matrix of the test data, and the value of `k` as input. Function Signature: ```python def knn_classifier(train_features: np.ndarray, train_labels: np.ndarray, test_features: np.ndarray, k: int) -> np.ndarray: ``` Input: - `train_features`: 2D NumPy array of shape `(n_train_samples, n_features)` - `train_labels`: 1D NumPy array of integers of shape `(n_train_samples,)` - `test_features`: 2D NumPy array of shape `(n_test_samples, n_features)` - `k`: Integer, the number of nearest neighbors to consider Output: - 1D NumPy array of integers of shape `(n_test_samples,)` representing the predicted labels for each test data point Constraints: - `k` should be a positive integer less than or equal to the number of training samples. - For ties in voting, the prediction can be any of the tied classes. Example: ```python train_features = np.array([[1, 2], [2, 3], [3, 4], [4, 5], [5, 6]]) train_labels = np.array([0, 1, 0, 1, 0]) test_features = np.array([[1.5, 2.5], [3.5, 4.5]]) # Perform k-NN Classification predictions = knn_classifier(train_features, train_labels, test_features, k=3) print(predictions) ``` Note: Handle all possible edge cases and optimize your code for performance. Use Euclidean distance as the metric for measuring proximity.","solution":"import numpy as np from collections import Counter def knn_classifier(train_features: np.ndarray, train_labels: np.ndarray, test_features: np.ndarray, k: int) -> np.ndarray: Perform k-Nearest Neighbors classification. Parameters: - train_features: 2D NumPy array of shape (n_train_samples, n_features) - train_labels: 1D NumPy array of integers of shape (n_train_samples) - test_features: 2D NumPy array of shape (n_test_samples, n_features) - k: Integer, the number of nearest neighbors to consider Returns: - 1D NumPy array of integers representing the predicted labels for each test data point def euclidean_distance(a, b): return np.sqrt(np.sum((a - b) ** 2)) predictions = [] for test_point in test_features: # Calculate distances between test_point and all training points distances = np.array([euclidean_distance(test_point, train_point) for train_point in train_features]) # Get the indices of the k nearest neighbors k_nearest_indices = distances.argsort()[:k] # Get the labels of the k nearest neighbors k_nearest_labels = train_labels[k_nearest_indices] # Determine the most common label in the k nearest neighbors most_common_label = Counter(k_nearest_labels).most_common(1)[0][0] predictions.append(most_common_label) return np.array(predictions)"},{"question":"# Coding Assessment Question Scenario: You have been asked to develop a data validation system for an online form that collects user information. One of the requirements is to validate the user\'s email address to ensure it adheres to standard email formatting rules. Task: Write a Python function `validate_email(email: str) -> bool` that: * Takes a single string `email` which represents the email address entered by the user. * Validates the email against the specified constraints. * Returns `True` if the email address is valid and `False` otherwise. # Specifications: A valid email address: * Must contain exactly one \\"@\\" symbol. * Must have at least one character before the \\"@\\" symbol. * Must contain at least one \\".\\" symbol after the \\"@\\" symbol. * The \\".\\" symbol must not be immediately before or after the \\"@\\" symbol. * The last \\".\\" symbol must have at least one character following it. # Constraints: * The input string `email` should be considered during validation. * If the input is not a string, your function should raise a `TypeError` with an appropriate error message. Example Inputs and Outputs: 1. `validate_email(\\"user@example.com\\")` should return `True` 2. `validate_email(\\"user..name@example.com\\")` should return `False` 3. `validate_email(\\"user@.example.com\\")` should return `False` 4. `validate_email(\\"user@example..com\\")` should return `False` 5. `validate_email(\\"user@example.com@\\")` should return `False` 6. `validate_email(\\"user@example.com.\\")` should return `False` 7. `validate_email(\\"user@domain.co\\")` should return `True` # Edge Cases: 1. If the input is `12345`, raise a `TypeError` with the message \\"Input value must be a \'str\' type\\". 2. If the input is `None`, raise a `TypeError` with the message \\"Input value must be a \'str\' type\\". 3. If the input is an empty string `\\"\\"`, the function should return `False`. # Example Error Handling: 1. `validate_email(12345)` should raise a `TypeError` with the message \\"Input value must be a \'str\' type\\". 2. `validate_email(None)` should raise a `TypeError` with the message \\"Input value must be a \'str\' type\\". 3. `validate_email(\\"\\")` should return `False`. # Note: Ensure to implement rigorous checks and handle all specified edge cases to ensure the robustness of your email validation function.","solution":"import re def validate_email(email: str) -> bool: Validate the given email address based on the specified rules. :param email: str : The email address to validate. :return: bool : True if valid, False otherwise. if not isinstance(email, str): raise TypeError(\\"Input value must be a \'str\' type\\") # Regex for basic email validation regex = r\'^[^@]+@[^@]+.[^@]+\' # Check if the email doesn\'t match the pattern if not re.match(regex, email): return False # Split the email into local and domain parts local, domain = email.split(\'@\') # Additional checks specified if \'..\' in local or \'..\' in domain: return False if domain.startswith(\'.\') or domain.endswith(\'.\'): return False if email.endswith(\'.\'): return False return True"},{"question":"# Problem Statement: You are designing a function for normalizing data before feeding it into a machine learning algorithm. One common normalization technique is \\"min-max scaling\\", where the goal is to rescale the data to a fixed range, typically [0, 1]. Given a vector of real numbers, implement a function that applies min-max scaling to each element of the vector and returns a new vector with the rescaled results. # Function Signature: ```python def min_max_scale(vector: np.ndarray) -> np.ndarray: # Your code here ``` # Input: - A numpy array `vector` of shape `(n,)` containing real numbers. # Output: - A numpy array of the same shape as the input vector, with each element rescaled to the range [0, 1]. # Constraints: - The input array can have up to 10^6 elements. - Values in the input array can be any real number. # Performance requirements: - Your solution should be efficient in both time and space. # Example: ```python - Input: np.array([1.0, 2.0, 3.0, 4.0, 5.0]) - Output: array([0.0, 0.25, 0.5, 0.75, 1.0]) ``` # Notes: - Handle edge cases where the input vector has constant values. - Ensure the function is vectorized for performance efficiency. # Task: Implement the function as described, and test it with different edge cases to ensure its correctness and efficiency.","solution":"import numpy as np def min_max_scale(vector: np.ndarray) -> np.ndarray: Apply min-max scaling to each element of the vector and return a new vector with the rescaled results in the range [0, 1]. Parameters: vector (np.ndarray): A numpy array of shape (n,) containing real numbers. Returns: np.ndarray: A numpy array with the same shape as the input vector, with each element rescaled to the range [0, 1]. if np.ptp(vector) == 0: # Handle the case where all elements are the same return np.zeros_like(vector) min_val = np.min(vector) max_val = np.max(vector) return (vector - min_val) / (max_val - min_val)"},{"question":"# Task Manager – Task Dependency Resolver Context You are working on a project management software that needs to resolve task dependencies before displaying a list of tasks that can be executed. Tasks can depend on the completion of other tasks, and you need to determine an order in which tasks can be completed. # Problem Statement Your task is to implement a function that takes a list of tasks and their dependencies and returns the order in which the tasks should be completed. # Task Implement a function `resolve_task_order(tasks: List[str], dependencies: List[Tuple[str, str]]) -> List[str]` that takes a list of tasks and a list of dependencies and returns an ordered list of tasks such that each task is completed only after all its dependencies have been completed. Parameters: * `tasks` (List[str]): A list of task names (strings). Each task name is unique. * `dependencies` (List[Tuple[str, str]]): A list of tuples where each tuple represents a dependency `(A, B)` meaning task `B` depends on the completion of task `A`. Expected Output: * A list of task names in an order that satisfies all the dependencies. # Constraints: 1. A valid solution will always exist (no circular dependencies). 2. Each task may depend on zero or more tasks. 3. All tasks specified in the dependencies list will be included in the tasks list. Usage Example ```python tasks = [\\"task1\\", \\"task2\\", \\"task3\\", \\"task4\\", \\"task5\\"] dependencies = [ (\\"task1\\", \\"task2\\"), (\\"task1\\", \\"task3\\"), (\\"task3\\", \\"task4\\"), (\\"task4\\", \\"task5\\") ] resolve_task_order(tasks, dependencies) # Output: [\\"task1\\", \\"task3\\", \\"task4\\", \\"task5\\", \\"task2\\"] tasks = [\\"taskA\\", \\"taskB\\", \\"taskC\\", \\"taskD\\"] dependencies = [ (\\"taskA\\", \\"taskB\\"), (\\"taskB\\", \\"taskC\\"), (\\"taskD\\", \\"taskC\\") ] resolve_task_order(tasks, dependencies) # Output: [\\"taskA\\", \\"taskB\\", \\"taskD\\", \\"taskC\\"] or [\\"taskD\\", \\"taskA\\", \\"taskB\\", \\"taskC\\"] ``` # Implementation Notes: 1. You may use graph traversal algorithms such as topological sorting (e.g., Kahn\'s algorithm or Depth-First Search) to find a valid task order. 2. Ensure to handle cases where a task has no dependencies and can be executed at any time. 3. Validate edge cases and ensure robustness of the solution.","solution":"from typing import List, Tuple from collections import defaultdict, deque def resolve_task_order(tasks: List[str], dependencies: List[Tuple[str, str]]) -> List[str]: Given a list of tasks and their dependencies, return the order in which the tasks can be completed. # Build the adjacency list and in-degree count adj_list = defaultdict(list) in_degree = {task: 0 for task in tasks} for dep1, dep2 in dependencies: adj_list[dep1].append(dep2) in_degree[dep2] += 1 # Queue for tasks with no prerequisites (in-degree 0) queue = deque([task for task in tasks if in_degree[task] == 0]) result = [] while queue: current = queue.popleft() result.append(current) for neighbor in adj_list[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) return result"},{"question":"# Question: Detect Cycle in Directed Graph Using Depth First Search Context: As a software developer, you are responsible for ensuring the reliability of a task management system. In this system, tasks are represented as nodes in a directed graph, and dependencies between tasks (i.e., one task needing to be completed before another) are represented as directed edges. You need to determine if there are any circular dependencies (cycles) in the task graph, which would make it impossible to complete the tasks. Task: Using Depth First Search (DFS), implement the function `detect_cycle(graph: Dict[int, List[int]])` to check if the given directed graph contains any cycles. Function Signature: ```python def detect_cycle(graph: Dict[int, List[int]]) -> bool: pass ``` Input: - `graph`: A dictionary where keys are task indices (integers) and values are lists of integers representing the tasks that depend on the key task. Output: - A boolean value `True` if there is a cycle in the graph, `False` otherwise. Constraints: - The graph can have up to `100` nodes and `500` edges. - Nodes are labeled with unique integers starting from `0` to `N-1` where `N` is the number of nodes. Example: ```python graph = { 0: [1], 1: [2], 2: [0], 3: [4], 4: [] } assert detect_cycle(graph) == True graph = { 0: [1, 2], 1: [2], 2: [3], 3: [] } assert detect_cycle(graph) == False ``` Notes: - Utilize a recursive approach with a helper function to perform DFS. - Use a state array to mark nodes as unvisited (0), visiting (1), and visited (2). - Carefully manage the states to detect back edges, indicating cycles. - Ensure the function handles disconnected components of the graph.","solution":"def detect_cycle(graph): def dfs(node): if state[node] == 1: # Node is being visited, cycle detected return True if state[node] == 2: # Node has been completely visited, no cycle on this path return False state[node] = 1 # Mark the node as visiting # Visit all the neighbors for neighbor in graph.get(node, []): if dfs(neighbor): return True state[node] = 2 # Mark the node as completely visited return False state = [0] * len(graph) # 0 = unvisited, 1 = visiting, 2 = visited for node in graph: if state[node] == 0: if dfs(node): return True return False"},{"question":"# Context: You are required to develop a library management module for a digital library system. The module will manage book information and enable search functionality based on various criteria. You will implement data structures and algorithms to store and retrieve book details efficiently. # Objective: Create a library management module that can add books, remove books, and search for books by title, author, or genre. Additionally, provide functionality to list all books in the library. # Function Definitions: 1. `add_book(book: dict) -> None`: - Adds a book to the library. 2. `remove_book(title: str) -> bool`: - Removes a book with the given title from the library. Returns `True` if the book was successfully removed, `False` otherwise. 3. `search_by_title(title: str) -> list[dict]`: - Returns a list of books matching the given title. 4. `search_by_author(author: str) -> list[dict]`: - Returns a list of books written by the given author. 5. `search_by_genre(genre: str) -> list[dict]`: - Returns a list of books of the specified genre. 6. `list_books() -> list[dict]`: - Returns a list of all books currently in the library. # Input and Output Formats: - **add_book(book: dict)** * `book`: Dictionary with keys `\'title\'`, `\'author\'`, `\'genre\'`, and `\'year\'`. - **remove_book(title: str)** * `title`: String representing the title of the book to be removed. * Returns: Boolean indicating the success of the removal operation. - **search_by_title(title: str)** * `title`: String representing the title to search for. * Returns: List of dictionaries representing matching books. - **search_by_author(author: str)** * `author`: String representing the author to search for. * Returns: List of dictionaries representing matching books. - **search_by_genre(genre: str)** * `genre`: String representing the genre to search for. * Returns: List of dictionaries representing matching books. - **list_books()** * Returns: List of dictionaries representing all books in the library. # Constraints: - The book dictionary must contain the keys `\'title\'`, `\'author\'`, `\'genre\'`, and `\'year\'`. - The title, author, and genre are non-empty strings. - The year is a non-negative integer. # Example Usage: ```python # Initialization library = Library() # Add books library.add_book({\'title\': \'1984\', \'author\': \'George Orwell\', \'genre\': \'Dystopian\', \'year\': 1949}) library.add_book({\'title\': \'To Kill a Mockingbird\', \'author\': \'Harper Lee\', \'genre\': \'Classics\', \'year\': 1960}) # Search books by title print(library.search_by_title(\'1984\')) # Example output: [{\'title\': \'1984\', \'author\': \'George Orwell\', \'genre\': \'Dystopian\', \'year\': 1949}] # Search books by author print(library.search_by_author(\'Harper Lee\')) # Example output: [{\'title\': \'To Kill a Mockingbird\', \'author\': \'Harper Lee\', \'genre\': \'Classics\', \'year\': 1960}] # List all books print(library.list_books()) # Example output: [{\'title\': \'1984\', \'author\': \'George Orwell\', \'genre\': \'Dystopian\', \'year\': 1949}, {\'title\': \'To Kill a Mockingbird\', \'author\': \'Harper Lee\', \'genre\': \'Classics\', \'year\': 1960}] # Remove a book print(library.remove_book(\'1984\')) # Example output: True ``` # Task: Implement the `Library` class and the methods `add_book`, `remove_book`, `search_by_title`, `search_by_author`, `search_by_genre`, and `list_books` following the detailed guidelines and constraints.","solution":"class Library: def __init__(self): self.books = [] def add_book(self, book: dict) -> None: self.books.append(book) def remove_book(self, title: str) -> bool: for book in self.books: if book[\'title\'] == title: self.books.remove(book) return True return False def search_by_title(self, title: str) -> list[dict]: return [book for book in self.books if book[\'title\'].lower() == title.lower()] def search_by_author(self, author: str) -> list[dict]: return [book for book in self.books if book[\'author\'].lower() == author.lower()] def search_by_genre(self, genre: str) -> list[dict]: return [book for book in self.books if book[\'genre\'].lower() == genre.lower()] def list_books(self) -> list[dict]: return self.books"},{"question":"# Fibonacci Sequence Generator **Scenario**: A researcher studying the Fibonacci sequence has approached you to generate sequence values efficiently. You are required to write a Python function that returns the nth Fibonacci number using an optimized approach. **Function Signature**: ```python def fibonacci(n: int) -> int: Returns the nth Fibonacci number. :param n: The position in the Fibonacci sequence (0-indexed) :return: The nth Fibonacci number ``` **Input**: - A single integer `n` (0 <= n <= 10^5) **Output**: - An integer representing the nth Fibonacci number. **Constraints**: - Your solution should be efficient enough to handle values of `n` up to 10^5 within reasonable time limits. **Performance Requirements**: - Aim for an O(log n) time complexity using matrix exponentiation or an iterative approach with memoization, and O(1) space complexity for your solution. **Example**: ```python print(fibonacci(0)) # Output: 0 print(fibonacci(1)) # Output: 1 print(fibonacci(10)) # Output: 55 print(fibonacci(50)) # Output: 12586269025 print(fibonacci(100))# Output: 354224848179261915075 ``` **Special Notes**: - Ensure to handle the edge cases such as `n = 0` and `n = 1`. - Optimize your function to run efficiently for large values of `n`.","solution":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number. :param n: The position in the Fibonacci sequence (0-indexed) :return: The nth Fibonacci number if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Question: String Permutation Checker A permutation of a string is another string that contains the same characters, only the order of characters can be different. For example, \\"abc\\" has the following permutations: \\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", and \\"cba\\". Given two strings, write a function that determines if one is a permutation of the other. Task: Write a function `is_permutation(s1: str, s2: str) -> bool` that checks if one string is a permutation of the other. Input: - `s1` (str): A string consisting of alphanumeric characters. - `s2` (str): Another string consisting of alphanumeric characters. Output: - Returns: A boolean value - `True` if `s1` is a permutation of `s2` and `False` otherwise. Constraints: - `1 ≤ len(s1), len(s2) ≤ 10^4` - Both `s1` and `s2` contain only alphanumeric characters. Example: ```python >>> is_permutation(\\"abc\\", \\"bca\\") True >>> is_permutation(\\"abc\\", \\"abcd\\") False ``` Write a function `is_permutation` that meets the requirements and passes the examples given. Ensure your solution is optimized for performance given the input size constraints.","solution":"def is_permutation(s1: str, s2: str) -> bool: Checks if one string is a permutation of another. if len(s1) != len(s2): return False # Convert both strings to sorted lists and compare return sorted(s1) == sorted(s2)"},{"question":"# String to Integer Conversion with Constraints You are given a function `string_to_integer` that aims to convert a string representation of an integer into its numerical form. The input strings may have leading and trailing spaces, and potentially include a sign (+ or -). The function should handle typical edge cases associated with such conversions. # Problem Statement Implement the function `string_to_integer` to convert a properly formatted string into an integer without using built-in conversion functions like `int()` in Python. # Constraints 1. The input string length shall be between 1 and 1000. 2. The input string can contain leading/trailing spaces. 3. The input string can start with a sign (+ or -). 4. Only the first valid integer should be considered, ignoring any additional characters or invalid sequences after it. 5. If there isn\'t any valid integer representation, return `0`. # Input Format ```plaintext - A string `s` representing the integer. ``` # Output Format ```plaintext - An integer representation of the given string. ``` # Example ```python s = \\" -42\\" result = string_to_integer(s) print(result) # Output should be: -42 s = \\"4193 with words\\" result = string_to_integer(s) print(result) # Output should be: 4193 s = \\"words and 987\\" result = string_to_integer(s) print(result) # Output should be: 0 s = \\"+-12\\" result = string_to_integer(s) print(result) # Output should be: 0 ``` # Implementation Complete the `string_to_integer` function by implementing the logic to convert the string to an integer. Consider removing leading and trailing spaces and handling potential signs correctly. ```python def string_to_integer(s: str) -> int: # Implement this function to convert the string to an integer n = len(s) if n == 0: return 0 index = 0 sign = 1 result = 0 # Discard all spaces from the beginning of the input string. while index < n and s[index] == \' \': index += 1 # Determine the sign. if index < n and s[index] == \'+\': sign = 1 index += 1 elif index < n and s[index] == \'-\': sign = -1 index += 1 # Convert the characters to integer. while index < n and s[index].isdigit(): result = result * 10 + int(s[index]) index += 1 return sign * result ``` # Notes 1. Ensure the function handles invalid input gracefully by returning `0` where appropriate. 2. Avoid using Python\'s built-in conversion functions like `int()` to solve this problem.","solution":"def string_to_integer(s: str) -> int: n = len(s) if n == 0: return 0 index = 0 sign = 1 result = 0 # Skip leading whitespaces while index < n and s[index] == \' \': index += 1 # Check for sign if index < n and (s[index] == \'+\' or s[index] == \'-\'): if s[index] == \'-\': sign = -1 index += 1 # Convert digits to integer while index < n and s[index].isdigit(): result = result * 10 + int(s[index]) index += 1 # Return the final result with sign return sign * result"},{"question":"# Generic Tree - Height Calculation and Node Count Scenario Helen is designing a tree data structure for her filesystem explorer application. She needs the tree to represent folders and files, and perform several operations efficiently: 1. Calculate the height of the tree. 2. Count the total number of nodes. Objective Using a tree structure with nodes that may have multiple children, implement the required functionality. 1. `height(self) -> int`: Returns the height of the tree. (The height of a tree is the length of the longest path from the root to any leaf node.) 2. `count_nodes(self) -> int`: Returns the total number of nodes in the tree. Requirements * **Function Specifications**: * Traverse the tree to correctly calculate its height. * Traverse the tree to get the count of all nodes. * **Constraints**: * Nodes can have arbitrary numbers of children. * **Performance**: * Ensure efficient time complexity by minimizing redundant computations. Implementation Given the following class template: ```python class TreeNode: def __init__(self, value): self.value = value self.children = [] def add_child(self, child_node): self.children.append(child_node) class GenericTree: def __init__(self, root: TreeNode): self.root = root def height(self) -> int: Returns the height of the tree. The height of a tree is the length of the longest path from the root to any leaf node. >>> root = TreeNode(1) >>> child1 = TreeNode(2) >>> child2 = TreeNode(3) >>> root.add_child(child1) >>> root.add_child(child2) >>> tree = GenericTree(root) >>> tree.height() 1 >>> child2.add_child(TreeNode(4)) >>> child2.add_child(TreeNode(5)) >>> tree.height() 2 # Your implementation here def count_nodes(self) -> int: Returns the total number of nodes in the tree. >>> root = TreeNode(1) >>> child1 = TreeNode(2) >>> child2 = TreeNode(3) >>> root.add_child(child1) >>> root.add_child(child2) >>> tree = GenericTree(root) >>> tree.count_nodes() 3 >>> child2.add_child(TreeNode(4)) >>> tree.count_nodes() 4 # Your implementation here ``` Complete the implementation of `height` and `count_nodes` methods. Ensure that the traversal is efficient and that the calculations are correct for any generic tree structure with multiple children nodes.","solution":"class TreeNode: def __init__(self, value): self.value = value self.children = [] def add_child(self, child_node): self.children.append(child_node) class GenericTree: def __init__(self, root: TreeNode): self.root = root def height(self) -> int: def helper(node): if not node.children: return 0 return 1 + max(helper(child) for child in node.children) return helper(self.root) def count_nodes(self) -> int: def helper(node): count = 1 for child in node.children: count += helper(child) return count return helper(self.root)"},{"question":"# Question: Array Zigzag Order Scenario: In many computational problems, arranging elements in a specific order can lead to more efficient processing. A common such arrangement is the zigzag order where each element alternates between being greater than and less than its neighboring elements. Task: Write a function `zigzag_order(arr: List[int]) -> List[int]` that rearranges the elements of a given list of integers into zigzag order, such that `arr[0] < arr[1] > arr[2] < arr[3] > ...`. Function Specifications: 1. `zigzag_order(arr: List[int]) -> List[int]` - **Input**: A list of integers `arr` of length `n` where 1 <= n <= 10^5. - **Output**: A list of integers where the elements are rearranged in zigzag order as described. Examples: ```python >>> zigzag_order([4, 3, 7, 8, 6, 2, 1]) [3, 7, 4, 8, 2, 6, 1] >>> zigzag_order([1, 4, 3, 2]) [1, 4, 2, 3] >>> zigzag_order([1, 2, 3]) [1, 3, 2] >>> zigzag_order([10, 20, 30, 40, 50, 60]) [10, 30, 20, 50, 40, 60] ``` Constraints: - The input list contains no duplicate elements. Performance Requirements: - The solution must run in linear time O(n) and use constant space O(1). Notes: - The function should modify the input list in place if possible. - Ensure that zigzag order is maintained by only making necessary swaps between neighboring elements.","solution":"from typing import List def zigzag_order(arr: List[int]) -> List[int]: Rearranges array in zigzag order such that arr[0] < arr[1] > arr[2] < arr[3] > ... n = len(arr) for i in range(n - 1): if i % 2 == 0: if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] else: if arr[i] < arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] return arr"},{"question":"# Question: Implement a Function to Check Armstrong Numbers An Armstrong number (also known as a narcissistic number, pluperfect number, or pluperfect digit invariant) is a number that is equal to the sum of its own digits each raised to the power of the number of digits. Task Write a function `is_armstrong_number(n: int) -> bool` that determines if a given number `n` is an Armstrong number. Function Signature ```python def is_armstrong_number(n: int) -> bool: pass ``` Input * `n`: an integer that you need to check for being an Armstrong number. - Constraints: (1 leq n leq 10^9) Output * Returns `True` if `n` is an Armstrong number, `False` otherwise. Constraints 1. Your solution should perform well within the range of input values, focusing on efficiency and correctness. 2. Consider edge cases such as single-digit numbers, the largest possible input, and numbers with repeated digits. Example ```python print(is_armstrong_number(153)) # Expected output: True print(is_armstrong_number(9474)) # Expected output: True print(is_armstrong_number(9475)) # Expected output: False print(is_armstrong_number(1)) # Expected output: True print(is_armstrong_number(10)) # Expected output: False ``` Additional Requirements 1. **Performance**: Ensure the function runs efficiently for input values up to (10^9). 2. **Correctness**: Include appropriate checks and balances to ensure the function works for both small and very large numbers, as well as numbers with varying digit counts.","solution":"def is_armstrong_number(n: int) -> bool: Checks if a given number n is an Armstrong number. digits = [int(d) for d in str(n)] num_digits = len(digits) armstrong_sum = sum(d ** num_digits for d in digits) return armstrong_sum == n"},{"question":"# Count Unique Elements in Sorted Rotated Array Given a sorted array of unique integers that has been rotated at some pivot, write a function `count_unique_elements` that counts the number of unique elements in the array. The array does not contain any duplicates and was originally sorted in ascending order before rotation. Function Signature ```python def count_unique_elements(arr: list[int]) -> int: ``` Input - An array `arr` of integers (0 ≤ length of `arr` ≤ 10^6) Output - The function should return an integer which is the count of unique elements in the input array. Example ```python >>> count_unique_elements([4, 5, 6, 7, 0, 1, 2]) 7 >>> count_unique_elements([1]) 1 >>> count_unique_elements([]) 0 ``` Constraints - You must ensure that the solution is efficient and runs within a reasonable time limit for large arrays. Aim for a linear O(n) solution. Task 1. Implement the function `count_unique_elements` to count the number of unique elements in a given sorted rotated array of integers. Notes - Make use of properties of the sorted rotated array to optimize your solution. - Handle edge cases such as an empty array or an array with a single element. - Ensure your code is robust and efficiently handles large input sizes.","solution":"def count_unique_elements(arr: list[int]) -> int: Returns the count of unique elements in the given sorted rotated array. Parameters: arr (list[int]): A sorted rotated array of unique integers. Returns: int: The count of unique elements in the array. return len(arr)"},{"question":"# Problem Statement You are assigned to create an entity for managing book collections in a library. This task checks your knowledge in data structures, object-oriented programming, and algorithm efficiency. Class Specification Implement a class `Library` with the following methods: ```python class Library: def __init__(self): Initializes the library with an empty collection. def add_book(self, book_id: int, title: str, author: str, year: int) -> None: Adds a new book to the library collection. Args: book_id: An integer representing the unique ID of the book. title: A string representing the title of the book. author: A string representing the author of the book. year: An integer representing the publication year of the book. def remove_book(self, book_id: int) -> bool: Removes a book from the library collection. Args: book_id: An integer representing the unique ID of the book. Returns: A boolean indicating if the removal was successful. def get_books_by_author(self, author: str) -> list: Returns a list of book titles by a specific author. Args: author: A string representing the author of the books. Returns: A list of strings where each string is a book title by the specified author. def get_books_by_year(self, year: int) -> list: Returns a list of book titles published in a specific year. Args: year: An integer representing the publication year. Returns: A list of strings where each string is a book title published in the specified year. ``` Methods - **`__init__`**: Initializes the library with an empty collection. - **`add_book(book_id, title, author, year)`**: Adds a new book to the library collection. - `book_id`: An integer `id` where `0 <= id <= 10^6` representing the unique ID of the book. - `title`: A string `t` where `0 < len(t) <= 100` representing the title of the book. - `author`: A string `a` where `0 < len(a) <= 50` representing the author of the book. - `year`: An integer `y` where `1500 <= y <= 2025` representing the publication year of the book. - **`remove_book(book_id)`**: Removes a book from the library collection. - `book_id`: An integer `id` where `0 <= id <= 10^6` representing the unique ID of the book. - Returns a boolean indicating success or failure. - **`get_books_by_author(author)`**: Returns a list of book titles by a specific author. - `author`: A string `a` where `0 < len(a) <= 50` representing the author of the books. - Returns a list of strings representing the book titles. - **`get_books_by_year(year)`**: Returns a list of book titles published in a specific year. - `year`: An integer `y` where `1500 <= y <= 2025` representing the publication year. - Returns a list of strings representing the book titles. Example ```python library = Library() library.add_book(1, \\"1984\\", \\"George Orwell\\", 1949) library.add_book(2, \\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960) library.add_book(3, \\"Animal Farm\\", \\"George Orwell\\", 1945) print(library.get_books_by_author(\\"George Orwell\\")) # [\\"1984\\", \\"Animal Farm\\"] print(library.get_books_by_year(1945)) # [\\"Animal Farm\\"] print(library.remove_book(1)) # True print(library.get_books_by_author(\\"George Orwell\\")) # [\\"Animal Farm\\"] print(library.remove_book(1)) # False ``` Performance Requirements - The implementation should efficiently handle queries and modifications. - Avoid redundant or slow operations to ensure the class performs well with a large number of books.","solution":"class Library: def __init__(self): Initializes the library with an empty collection. self.books = {} self.author_to_books = {} self.year_to_books = {} def add_book(self, book_id: int, title: str, author: str, year: int) -> None: Adds a new book to the library collection. Args: book_id: An integer representing the unique ID of the book. title: A string representing the title of the book. author: A string representing the author of the book. year: An integer representing the publication year of the book. self.books[book_id] = { \'title\': title, \'author\': author, \'year\': year } if author not in self.author_to_books: self.author_to_books[author] = [] self.author_to_books[author].append(title) if year not in self.year_to_books: self.year_to_books[year] = [] self.year_to_books[year].append(title) def remove_book(self, book_id: int) -> bool: Removes a book from the library collection. Args: book_id: An integer representing the unique ID of the book. Returns: A boolean indicating if the removal was successful. if book_id in self.books: book = self.books.pop(book_id) self.author_to_books[book[\'author\']].remove(book[\'title\']) if not self.author_to_books[book[\'author\']]: del self.author_to_books[book[\'author\']] self.year_to_books[book[\'year\']].remove(book[\'title\']) if not self.year_to_books[book[\'year\']]: del self.year_to_books[book[\'year\']] return True return False def get_books_by_author(self, author: str) -> list: Returns a list of book titles by a specific author. Args: author: A string representing the author of the books. Returns: A list of strings where each string is a book title by the specified author. return self.author_to_books.get(author, []) def get_books_by_year(self, year: int) -> list: Returns a list of book titles published in a specific year. Args: year: An integer representing the publication year. Returns: A list of strings where each string is a book title published in the specified year. return self.year_to_books.get(year, [])"},{"question":"# Problem Description You are given a list of integers representing the heights of buildings aligned in a row. Each building has a width of 1. Write a function `max_area(heights: List[int]) -> int` that calculates the maximum area of water that can be trapped between two buildings after a rain. # Input * `heights` (List[int]): A list of non-negative integers representing the heights of the buildings, where 1 <= len(heights) <= 10000. # Output * Returns an integer representing the maximum trapped water area. # Constraints * All elements in `heights` are non-negative integers. * The height of buildings can be zero. # Example ```python heights = [1, 8, 6, 2, 5, 4, 8, 3, 7] print(max_area(heights)) # Output should be 49 ``` # Explanation Your function should find the maximum area of water that can be trapped between two buildings in the list. The area is calculated by multiplying the height of the shorter building with the distance between the two buildings. The goal is to maximize this area. # Note * Use a two-pointer approach to optimize the search for the maximum area. * Ensure the solution handles all edge cases, such as lists with fewer than two buildings.","solution":"from typing import List def max_area(heights: List[int]) -> int: if not heights or len(heights) < 2: return 0 left, right = 0, len(heights) - 1 max_area = 0 while left < right: width = right - left height = min(heights[left], heights[right]) current_area = width * height max_area = max(max_area, current_area) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"# Coding Assessment Question You need to write a function that processes a list of integers and returns a new list of integers where each element is replaced by the product of all the elements in the original list except the one at the current position. Ensure the function handles edge cases and erroneous input values gracefully by raising appropriate exceptions or errors. # Function Specification Function: `product_excluding_index` **Input**: - A list of integers (`nums`). Each value must be non-negative. **Output**: - A list of integers, where each element is the product of all elements in the input list except the one at the current position. **Constraints**: - Raise a `ValueError` with the message \\"Number at index X has a negative value!\\" where X is the index of the negative value if any value is negative. - The function should run in O(n) time and use O(n) additional space. # Examples ```python # Example for product_excluding_index print(product_excluding_index([1, 2, 3, 4])) # Output: [24, 12, 8, 6] try: print(product_excluding_index([1, 2, -3, 4])) except ValueError as e: print(e) # Output: Number at index 2 has a negative value! ``` Note: The function should be implemented in a way that ensures efficient computation, avoiding the need to iterate multiple times over the list.","solution":"def product_excluding_index(nums): Returns a list of products of all elements except the current element for each index. Raises a ValueError if an element is negative. # Check for any negative values and raise an appropriate ValueError for idx, num in enumerate(nums): if num < 0: raise ValueError(f\\"Number at index {idx} has a negative value!\\") # Edge case: if the list is empty or has only one element, result is empty list or [1] if not nums: return [] if len(nums) == 1: return [1] # Initialize the products list n = len(nums) res = [1] * n # Variable to accumulate left and right product left_product = 1 right_product = 1 # Calculate the left products for each index for i in range(n): res[i] *= left_product left_product *= nums[i] # Calculate the right products for each index for i in range(n-1, -1, -1): res[i] *= right_product right_product *= nums[i] return res"},{"question":"# Coding Assessment Question Scenario Your company is developing a web application that includes various data visualization tools. One of the features is a filter that highlights significant spikes in data. Your task is to implement a function that detects all significant spikes in a series of data points. A spike is defined as a point that is greater than a specified factor of the average of the preceding points within a given window size. Task Implement a function `detect_spikes` that identifies spikes in the data series based on the given window size and factor. If a data point is greater than `factor` times the average of the preceding `window_size` points, then it is considered a spike. The function should return a list of boolean values where `True` indicates a spike and `False` indicates a non-spike. Function Signature ```python def detect_spikes(data: Sequence[float], window_size: int, factor: float) -> list[bool]: pass ``` Input * `data`: A sequence of floating-point numbers representing the data points. * `window_size`: An integer representing the number of preceding points to consider for the average. * `factor`: A floating-point number that is used to determine the threshold for a spike. Output * Returns a list of boolean values where each element signifies whether the corresponding data point is a spike (`True`) or not (`False`). Constraints * The window size will be a non-negative integer. * The list of data points can be empty. * The factor will be a positive floating-point number. Performance Requirement * Aim for (O(n)) time complexity by using an efficient calculation technique. Example ```python >>> detect_spikes([10, 15, 20, 25, 30, 50, 55, 10, 15, 20], 3, 1.5) [False, False, False, False, False, True, False, False, False, False] >>> detect_spikes([5, 6, 7, 8, 15, 9, 7, 4], 2, 2.0) [False, False, False, False, True, False, False, False] >>> detect_spikes([1, 2, 1, 2, 1, 2, 1, 20], 3, 5.0) [False, False, False, False, False, False, False, True] ``` Edge Cases * Verify behavior with an empty data list. * Verify handling for zero window size, which should consider every point in isolation. * Window size greater than the data list length which should result in all `False` since there are not enough preceding points to calculate the average. Additional Challenge Implement an optimized version to handle large data sets efficiently.","solution":"from typing import Sequence def detect_spikes(data: Sequence[float], window_size: int, factor: float) -> list[bool]: if not data or window_size <= 0: return [False] * len(data) result = [False] * len(data) for i in range(len(data)): if i < window_size: continue window_data = data[i-window_size:i] avg = sum(window_data) / window_size if data[i] > factor * avg: result[i] = True return result"},{"question":"# Question Description You are required to implement a function that returns the highest power of 2 that is less than or equal to a given positive integer. This exercise will validate your understanding of bitwise manipulations and efficiency in handling binary numbers. # Function Signature ```python def highest_power_of_2(n: int) -> int: # Your code goes here ``` # Input - A single integer `n` (1 <= n <= 10^9) # Output - An integer representing the highest power of 2 less than or equal to `n`. # Constraints - The function should run efficiently for all inputs within the given range. # Example ```python # Example 1: print(highest_power_of_2(5)) # Output: 4 # Example 2: print(highest_power_of_2(8)) # Output: 8 # Example 3: print(highest_power_of_2(10)) # Output: 8 # Example 4: print(highest_power_of_2(17)) # Output: 16 # Example 5: print(highest_power_of_2(1)) # Output: 1 ``` # Notes * Ensure your function passes all provided test cases. * Your function should not use any predefined library functions for computing powers of 2. * Focus on using bitwise operations to uphold the performance expectations.","solution":"def highest_power_of_2(n: int) -> int: Returns the highest power of 2 less than or equal to a given positive integer. if n < 1: raise ValueError(\\"n must be at least 1\\") power = 1 while power <= n: power <<= 1 return power >> 1"},{"question":"# Word Morphing Solver Develop a function to determine if two words of equal length can be transformed into each other by morphing. Morphing is defined as changing one letter at a time, such that each intermediate form is a valid word in a given list. The solution should compute the shortest path of transformations. Input Format - A string, `startWord`, representing the initial word. - A string, `endWord`, representing the final word to morph into. - A list of strings, `wordList`, representing the valid words that can be used for transformations. Output Format - Return an integer representing the minimum number of transformations required to morph `startWord` into `endWord`. If it is not possible, return `-1`. Constraints - The `startWord` and `endWord` will be strings of equal length. - All the words in `wordList` will have the same length as `startWord` and `endWord`. - `startWord` and `endWord` are guaranteed to be non-empty strings. - The length of `wordList` will not exceed 10^4. Example ```python def word_morph(startWord: str, endWord: str, wordList: List[str]) -> int: # Implement the function to compute shortest transformation pass # Example Usage: print(word_morph(\'hit\', \'cog\', [\'hot\', \'dot\', \'dog\', \'lot\', \'log\', \'cog\'])) # Expected output: 5 print(word_morph(\'hit\', \'cog\', [\'hot\', \'dot\', \'dog\', \'lot\', \'log\'])) # Expected output: -1 ``` Implementation Details 1. **Validation**: Ensure that both `startWord` and `endWord` are present in the `wordList`. If `endWord` is not in the list, return `-1`. 2. **Breadth-First Search (BFS)**: - Utilize a queue to explore all possible single-letter transformations of the current word. - Track the number of transformations. - Ensure not to revisit the same word to prevent cycling. 3. **Word Matching**: - Ensure all intermediate word forms are valid words from the `wordList`. - Check each character position to generate possible transformations. Note: If transformation isn\'t possible due to no valid intermediate steps, return `-1`.","solution":"from collections import deque from typing import List def word_morph(startWord: str, endWord: str, wordList: List[str]) -> int: Returns the minimum number of transformations needed to transform the startWord into the endWord. Returns -1 if the transformation is not possible. if endWord not in wordList: return -1 wordList = set(wordList) queue = deque([(startWord, 1)]) while queue: current_word, steps = queue.popleft() if current_word == endWord: return steps for i in range(len(current_word)): for c in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + c + current_word[i+1:] if next_word in wordList: wordList.remove(next_word) queue.append((next_word, steps + 1)) return -1"},{"question":"# Problem: Optimized Pathfinding in a Grid Context You are tasked with developing a pathfinding algorithm for an autonomous robot navigating a warehouse grid. The grid consists of cells, some of which are empty, and others are obstacles. The robot needs to find the shortest path from its starting position to a target position. The warehouse layout is dynamic and can change, so your algorithm needs to be efficient for real-time pathfinding. Task Write a Python function `find_shortest_path` that calculates the shortest path in a 2D grid using the A* search algorithm. The search should account for obstacles and return the path length or indicate if no path is available. Requirements 1. **Input**: * `grid` (List[List[int]]): A 2D list representing the warehouse grid where 0 indicates an empty cell and 1 indicates an obstacle. * `start` (Tuple[int, int]): A tuple (x, y) indicating the starting position of the robot. * `goal` (Tuple[int, int]): A tuple (x, y) indicating the target position. 2. **Output**: * Returns an integer representing the length of the shortest path from the start to the goal. If no path exists, return -1. 3. **Constraints**: * The robot can move up, down, left, or right, but not diagonally. * The input grid is guaranteed to be non-empty. * Ensure the algorithm handles large grids efficiently. **Function Signature**: ```python def find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> int: pass ``` Example ```python grid = [ [0, 0, 1, 0], [1, 0, 0, 0], [0, 1, 1, 0], [0, 0, 0, 0] ] start = (0, 0) goal = (3, 3) path_length = find_shortest_path(grid, start, goal) print(path_length) # Expected output: 6 (or -1 if no path is found) ``` Notes * Implement the A* search algorithm, which uses a heuristic (typically the Manhattan distance) to estimate the shortest path. * Handle edge cases such as start and goal positions being the same. * Optimize for performance to handle larger grids typically encountered in warehouses.","solution":"import heapq def heuristic(a, b): Compute the Manhattan distance heuristic. return abs(a[0] - b[0]) + abs(a[1] - b[1]) def find_shortest_path(grid, start, goal): Uses A* search algorithm to find the shortest path in a 2D grid. if start == goal: return 0 rows, cols = len(grid), len(grid[0]) open_set = [] heapq.heappush(open_set, (0 + heuristic(start, goal), 0, start)) g_score = {start: 0} f_score = {start: heuristic(start, goal)} directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, down, left, right while open_set: _, curr_g, current = heapq.heappop(open_set) if current == goal: return curr_g for direction in directions: neighbor = (current[0] + direction[0], current[1] + direction[1]) if 0 <= neighbor[0] < rows and 0 <= neighbor[1] < cols: if grid[neighbor[0]][neighbor[1]] == 1: continue tentative_g_score = curr_g + 1 if neighbor not in g_score or tentative_g_score < g_score[neighbor]: g_score[neighbor] = tentative_g_score f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal) heapq.heappush(open_set, (f_score[neighbor], tentative_g_score, neighbor)) return -1"},{"question":"# Problem Statement You are given a list of student records where each record contains the student\'s name and their respective scores in multiple subjects. Your task is to implement a function that calculates the average score for each student and returns a dictionary with the student\'s name as the key and their average score as the value. # Function Signature ```python def calculate_student_averages(records: List[Tuple[str, List[float]]]) -> Dict[str, float]: ``` # Input - `records` (List[Tuple[str, List[float]]]): A list of tuples where each tuple consists of the student\'s name (str) and a list of scores (List[float]). # Output - Returns a dictionary with the student\'s name as the key and their average score (float) as the value. # Constraints - The scores list for each student will contain at least one score. - The scores are non-negative floats. # Example ```python >>> calculate_student_averages([(\\"John\\", [90.0, 80.0, 75.0]), (\\"Jane\\", [85.0, 90.0, 92.0])]) {\\"John\\": 81.66666666666667, \\"Jane\\": 89.0} >>> calculate_student_averages([(\\"Alice\\", [100.0, 95.0]), (\\"Bob\\", [70.0, 75.0, 85.0])]) {\\"Alice\\": 97.5, \\"Bob\\": 76.66666666666667} ``` # Instructions 1. Implement the `calculate_student_averages` function in the given signature. 2. Calculate the average score for each student based on their list of scores. 3. Ensure to return a dictionary where each key is a student\'s name and the value is their average score. # Evaluation Criteria Your solution will be assessed based on: 1. Correct computation of average scores. 2. Proper handling of the input list and returning the correct dictionary format. 3. Efficient and clean code adhering to the given constraints.","solution":"from typing import List, Tuple, Dict def calculate_student_averages(records: List[Tuple[str, List[float]]]) -> Dict[str, float]: Calculate the average score for each student. Args: records (List[Tuple[str, List[float]]]): A list of tuples where each tuple contains a student\'s name and their scores. Returns: Dict[str, float]: A dictionary with student names as keys and their average scores as values. averages = {} for name, scores in records: average_score = sum(scores) / len(scores) averages[name] = average_score return averages"},{"question":"# File Size Compressor A common problem in data storage and transmission is managing and reducing the file sizes. Implement a function called `compress_file` that compresses a given text file using a simple run-length encoding (RLE) scheme. The RLE scheme replaces sequences of the same character with that character followed by the count of repetitions. Task Write the `compress_file` function to compress a text file\'s contents by replacing each sequence of the same character with the character followed by the number of repetitions. This compression should be case-sensitive and handle all visible ASCII characters. Function Signature ```python def compress_file(file_path: str) -> str: pass ``` Input - A string `file_path` which is the path to a text file. Output - A string representing the run-length encoded content of the file. Constraints - The input file contains only visible ASCII characters (32-126) and newline characters. - File size up to 1 MB. Example Consider a file \\"sample.txt\\" with the following content: ``` aaaabbbccdaa ``` ```python >>> compress_file(\\"sample.txt\\") \'a4b3c2d1a2\' ``` If the content of \\"empty.txt\\" is an empty string: ```python >>> compress_file(\\"empty.txt\\") \'\' ``` Performance Your implementation should efficiently handle file reads, and max file size constraints ensure memory limitations are respected. Moreover, ensure the output compressed size is considerably less than or equal to the original, as dictated by the typical efficiency of run-length encoding.","solution":"def compress_file(file_path: str) -> str: Compresses the content of the given text file using run-length encoding (RLE). :param file_path: Path to the text file to compress. :return: Run-length encoded content of the file. with open(file_path, \'r\') as file: data = file.read() if not data: return \'\' compressed = [] count = 1 prev_char = data[0] for char in data[1:]: if char == prev_char: count += 1 else: compressed.append(prev_char + str(count)) prev_char = char count = 1 compressed.append(prev_char + str(count)) return \'\'.join(compressed)"},{"question":"# String Permutation Coding Assessment Background You need to generate a function that determines whether one string is a permutation of another string. Two strings are considered permutations if each character has the same frequency in both strings. Task Write a function `is_permutation` that checks if one string is a permutation of another. Implementation Details * **Function Signature**: `def is_permutation(s1: str, s2: str) -> bool` * **Inputs**: Two strings `s1` and `s2` (with lengths 0 ≤ |s1|, |s2| ≤ 10^5). * **Output**: A boolean value - `True` if `s1` is a permutation of `s2`, otherwise `False`. Function Specifics 1. If the lengths of `s1` and `s2` are different, return `False`. 2. Use a data structure (e.g., a dictionary or a collections.Counter) to count the frequency of each character in `s1`. 3. Compare this frequency count with the frequency of characters in `s2`. 4. Return `True` if both frequencies match, otherwise `False`. Edge Cases * Handle empty strings appropriately. * Ensure the function works efficiently even for strings near the maximum length constraint. Example ```python def is_permutation(s1: str, s2: str) -> bool: if len(s1) != len(s2): return False from collections import Counter return Counter(s1) == Counter(s2) # Example Usage print(is_permutation(\'abc\', \'bca\')) # Output: True print(is_permutation(\'hello\', \'olelh\')) # Output: True print(is_permutation(\'test\', \'ttews\')) # Output: False ``` **Constraints**: * Time Complexity: O(n), where n is the length of the input strings. * Space Complexity: O(n), where n is the length of the input strings. Note This function focuses on character frequency comparison rather than sorting the strings, aiming for better performance with large inputs.","solution":"def is_permutation(s1: str, s2: str) -> bool: if len(s1) != len(s2): return False from collections import Counter return Counter(s1) == Counter(s2)"},{"question":"# Problem Statement: Array Rotation with Bounds Checking You are required to implement a function `rotate_array` that rotates an array to the right by a specified number of steps. The function should handle cases where the number of steps is negative or exceeds the length of the array. If the number of steps is not an integer, raise a `TypeError`. ```python def rotate_array(arr: list, steps: int) -> list: pass ``` # Function Signature: ```python def rotate_array(arr: list, steps: int) -> list: Rotates the array to the right by the given number of steps. Parameters: arr (list): The input array to be rotated. steps (int): The number of steps to rotate the array. Returns: list: The rotated array. Raises: TypeError: If steps is not an integer. pass ``` # Input: - A list `arr` containing the elements to be rotated. - An integer `steps` representing the number of steps to rotate the array. # Output: - The rotated array. # Constraints: - The array `arr` can include any data type. - The `steps` parameter must be an integer. If not, a `TypeError` should be raised. # Examples: ```python >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], -1) [2, 3, 4, 5, 1] >>> rotate_array([\\"a\\", \\"b\\", \\"c\\"], 1) [\\"c\\", \\"a\\", \\"b\\"] >>> rotate_array([1, 2, 3, 4], 4) [1, 2, 3, 4] >>> rotate_array([1, 2, 3, 4], \\"3\\") Traceback (most recent call last): ... TypeError: Steps must be an integer ``` # Additional Notes: - If `steps` is greater than the length of the array, it should rotate adequately (e.g., rotating by 5 steps an array of length 3 is equivalent to rotating by 2 steps). - Negative steps imply rotating the array to the left. - Ensure the solution is efficient and includes edge cases.","solution":"def rotate_array(arr, steps): Rotates the array to the right by the given number of steps. Parameters: arr (list): The input array to be rotated. steps (int): The number of steps to rotate the array. Returns: list: The rotated array. Raises: TypeError: If steps is not an integer. if not isinstance(steps, int): raise TypeError(\\"Steps must be an integer\\") n = len(arr) if n == 0: return arr # return empty array if input array is empty # Handle steps that are larger than array length and negative steps steps = steps % n return arr[-steps:] + arr[:-steps]"},{"question":"Problem Statement Implement a function that takes in a string representing a Roman numeral and converts it to its equivalent decimal integer. # Function signature ```python def roman_to_decimal(roman: str) -> int: pass ``` # Input * A string `roman` (1 <= len(roman) <= 15) representing a valid Roman numeral. The string is guaranteed to be a valid Roman numeral containing one or more of these characters: \'I\', \'V\', \'X\', \'L\', \'C\', \'D\', \'M\'. # Output * Returns an integer representing the decimal equivalent of the Roman numeral. # Example ```python assert roman_to_decimal(\\"III\\") == 3 assert roman_to_decimal(\\"IV\\") == 4 assert roman_to_decimal(\\"IX\\") == 9 assert roman_to_decimal(\\"LVIII\\") == 58 assert roman_to_decimal(\\"MCMXCIV\\") == 1994 ``` # Notes * Roman numerals are typically written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five, we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: * I can be placed before V (5) and X (10) to make 4 and 9. * X can be placed before L (50) and C (100) to make 40 and 90. * C can be placed before D (500) and M (1000) to make 400 and 900. * Handle the conversion carefully, ensuring the rules of Roman numeral subtraction are applied appropriately.","solution":"def roman_to_decimal(roman: str) -> int: roman_values = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } total = 0 prev_value = 0 for char in reversed(roman): current_value = roman_values[char] if current_value < prev_value: total -= current_value else: total += current_value prev_value = current_value return total"},{"question":"# Question You are required to implement a function to perform matrix multiplication for given inputs using both iterative and recursive methods as per the description. Your implementation should handle valid inputs gracefully and raise errors for invalid inputs. Function Signature ```python def matrix_multiply_iterative(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]: def matrix_multiply_recursive(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]: ``` Requirements: 1. **Function 1**: `matrix_multiply_iterative(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]` - Use nested loops to perform matrix multiplication. - Should raise `ValueError` if the matrices cannot be multiplied (i.e., the number of columns in the first matrix does not equal the number of rows in the second matrix). 2. **Function 2**: `matrix_multiply_recursive(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]` - Use recursion to perform matrix multiplication. - Should handle base cases properly and raise `ValueError` for incompatible matrices. Input - `matrix1`: A two-dimensional list of integers representing the first matrix. - `matrix2`: A two-dimensional list of integers representing the second matrix. Output - Returns a two-dimensional list of integers representing the result of the matrix multiplication. Constraints - Both matrices should have integer elements. - The number of columns in `matrix1` must equal the number of rows in `matrix2`. - Performance should be considered, especially for larger matrices. Example ```python >>> matrix1 = [[1, 2, 3], [4, 5, 6]] >>> matrix2 = [[7, 8], [9, 10], [11, 12]] >>> matrix_multiply_iterative(matrix1, matrix2) [[58, 64], [139, 154]] ``` ```python >>> matrix1 = [[1, 0], [0, 1]] >>> matrix2 = [[4, 1], [7, 2]] >>> matrix_multiply_recursive(matrix1, matrix2) [[4, 1], [7, 2]] ``` Scenario Consider implementing your solution while keeping in mind computational efficiency for larger matrices, proper handling of edge cases such as incompatible matrices, and potential overflow issues for large integer values in the recursive method.","solution":"from typing import List def matrix_multiply_iterative(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]: if len(matrix1[0]) != len(matrix2): raise ValueError(\\"Incompatible matrices for multiplication\\") result = [[0] * len(matrix2[0]) for _ in range(len(matrix1))] for i in range(len(matrix1)): for j in range(len(matrix2[0])): for k in range(len(matrix2)): result[i][j] += matrix1[i][k] * matrix2[k][j] return result def matrix_multiply_recursive(matrix1: List[List[int]], matrix2: List[List[int]], result=None, i=0, j=0, k=0) -> List[List[int]]: if len(matrix1[0]) != len(matrix2): raise ValueError(\\"Incompatible matrices for multiplication\\") if result is None: result = [[0] * len(matrix2[0]) for _ in range(len(matrix1))] if i >= len(matrix1): return result result[i][j] += matrix1[i][k] * matrix2[k][j] if k + 1 < len(matrix2): return matrix_multiply_recursive(matrix1, matrix2, result, i, j, k + 1) elif j + 1 < len(matrix2[0]): return matrix_multiply_recursive(matrix1, matrix2, result, i, j + 1, 0) else: return matrix_multiply_recursive(matrix1, matrix2, result, i + 1, 0, 0)"},{"question":"# Increasing Triplet Subsequence Context In array manipulation problems, identifying certain patterns or subsequences that fulfill given conditions is a common challenge. One such problem is detecting the presence of a triplet that increases sequentially in any part of the array. This has numerous applications in sorting algorithms, subsequence analysis, and programming contests. Problem Statement Write a function `increasing_triplet(nums: List[int]) -> bool` that determines if there exists a triplet (i, j, k) such that `i < j < k` and `nums[i] < nums[j] < nums[k]` in a given integer array `nums`. Requirements 1. The function should use an efficient algorithm with a linear time complexity. 2. It should handle negative numbers and zeroes. 3. It must operate with constant additional space (O(1) extra space). 4. Avoid nested loops due to potential performance issues with large arrays. Input and Output - **Input**: A list of integers `nums` (-10^9 <= nums[i] <= 10^9, 1 <= len(nums) <= 10^5). - **Output**: A boolean value representing whether such an increasing triplet exists or not. Constraints 1. Consider edge cases, such as arrays with less than 3 elements, which cannot form a triplet. 2. The solution should be optimal to handle the upper limit of array length efficiently. Performance Requirements The algorithm should run in linear time (O(n)) and use constant space (O(1)). # Example ```python def increasing_triplet(nums: List[int]) -> bool: # Your code here # Test cases print(increasing_triplet([1, 2, 3, 4, 5])) # Output: True print(increasing_triplet([5, 4, 3, 2, 1])) # Output: False print(increasing_triplet([2, 1, 5, 0, 4, 6])) # Output: True print(increasing_triplet([1, 1, 1, 1, 1])) # Output: False print(increasing_triplet([1, 2])) # Output: False ``` Explanation - For `nums = [1, 2, 3, 4, 5]`, there is an increasing triplet (1, 2, 3). - For `nums = [5, 4, 3, 2, 1]`, no increasing triplet exists. - For `nums = [2, 1, 5, 0, 4, 6]`, the triplet (1, 4, 6) satisfies the condition. - For `nums = [1, 1, 1, 1, 1]`, no distinct increasing triplet exists. - For `nums = [1, 2]`, there are not enough numbers to form a triplet.","solution":"def increasing_triplet(nums): if len(nums) < 3: return False first = float(\'inf\') second = float(\'inf\') for n in nums: if n <= first: first = n elif n <= second: second = n else: return True return False # Example usage: # print(increasing_triplet([1, 2, 3, 4, 5])) # Should return True # print(increasing_triplet([5, 4, 3, 2, 1])) # Should return False # print(increasing_triplet([2, 1, 5, 0, 4, 6])) # Should return True # print(increasing_triplet([1, 1, 1, 1, 1])) # Should return False # print(increasing_triplet([1, 2])) # Should return False"},{"question":"# Coding Assessment Question 2 Scenario You are developing a software for a financial application that needs to efficiently handle multiple transactions and provide real-time updates on account balances. Given the application must support numerous concurrent transactions, it requires a data structure that can handle both updates and queries optimally. Task Implement a class `TransactionManager` that allows efficient updates to account balances and queries the sum of balances within a specified range. # Class Definition ```python class TransactionManager: def __init__(self, size: int) -> None: # Initialize the class with necessary properties def deposit(self, account: int, amount: int) -> None: # Add the given amount to the specified account def withdraw(self, account: int, amount: int) -> None: # Subtract the given amount from the specified account def balance_query(self, left: int, right: int) -> int: # Return the sum of balances for accounts in the range [left, right) ``` # Method Details * **`__init__(self, size: int) -> None`**: * Initializes the TransactionManager with the specified number of accounts. All accounts start with a balance of 0. * **`deposit(self, account: int, amount: int) -> None`**: * Adds the specified amount to the balance of the given account. * **`withdraw(self, account: int, amount: int) -> None`**: * Subtracts the specified amount from the balance of the given account. * **`balance_query(self, left: int, right: int) -> int`**: * Returns the sum of account balances within the specified range `[left, right)`. # Constraints * `1 <= size <= 10^5` * `0 <= account < size` * `-10^9 <= amount <= 10^9` * `0 <= left < right <= size` # Output Format * Function methods return integer values or update the state without returning any value. # Example ```python tm = TransactionManager(5) tm.deposit(0, 100) tm.deposit(1, 200) tm.deposit(2, 300) tm.withdraw(1, 50) assert tm.balance_query(0, 3) == 550 # Balance of accounts from 0 to 2 are 100, 150, and 300 respectively, so sum is 100 + 150 + 300 = 550 ```","solution":"class TransactionManager: def __init__(self, size: int) -> None: self.size = size self.balances = [0] * size def deposit(self, account: int, amount: int) -> None: self.balances[account] += amount def withdraw(self, account: int, amount: int) -> None: self.balances[account] -= amount def balance_query(self, left: int, right: int) -> int: return sum(self.balances[left:right])"},{"question":"# String Compression Problem Description: You are tasked with implementing a function that compresses a string using Run-Length Encoding (RLE) and another function that decompresses the RLE encoded string. The compressed string should represent repeated characters by the character followed by the number of times it appears consecutively. Function Signatures: ```python def rle_compress(input_string: str) -> str: Compresses the input string using Run-Length Encoding (RLE). Args: - input_string (str): The string to be compressed. Returns: - str: The RLE compressed string. pass def rle_decompress(compressed_string: str) -> str: Decompresses the RLE compressed string back to the original string. Args: - compressed_string (str): The RLE compressed string. Returns: - str: The decompressed, original string. pass ``` Input: - For `rle_compress`: - `input_string`: A string representing the input string to be compressed. - For `rle_decompress`: - `compressed_string`: A string representing the RLE compressed string. Output: - For `rle_compress`: A string representing the compressed version of the input string using Run-Length Encoding. - For `rle_decompress`: A string representing the original string after decompressing the RLE encoded string. Constraints: - The input string for compression can only contain uppercase and lowercase English letters (a-z, A-Z). - The length of the input string for compression will not exceed 10,000 characters. Example: ```python # Example usage of the functions. input_string = \\"aaabbbbcc\\" compressed_string = rle_compress(input_string) print(\\"Compressed:\\", compressed_string) # Output: \\"a3b4c2\\" decompressed_string = rle_decompress(compressed_string) print(\\"Decompressed:\\", decompressed_string) # Output: \\"aaabbbbcc\\" ```","solution":"def rle_compress(input_string: str) -> str: Compresses the input string using Run-Length Encoding (RLE). Args: - input_string (str): The string to be compressed. Returns: - str: The RLE compressed string. if not input_string: return \\"\\" compressed = [] count = 1 for i in range(1, len(input_string)): if input_string[i] == input_string[i - 1]: count += 1 else: compressed.append(input_string[i - 1] + str(count)) count = 1 compressed.append(input_string[-1] + str(count)) return \'\'.join(compressed) def rle_decompress(compressed_string: str) -> str: Decompresses the RLE compressed string back to the original string. Args: - compressed_string (str): The RLE compressed string. Returns: - str: The decompressed, original string. decompressed = [] i = 0 while i < len(compressed_string): char = compressed_string[i] count = \'\' i += 1 while i < len(compressed_string) and compressed_string[i].isdigit(): count += compressed_string[i] i += 1 decompressed.append(char * int(count)) return \'\'.join(decompressed)"},{"question":"# Coding Assessment Question: Image Brightness Adjustment You are tasked to create two functions to adjust the brightness of a given grayscale image represented as a 2D list of integers. **Context**: In this image processing problem, the brightness of a grayscale image needs to be increased or decreased by a given factor. A higher factor increases the brightness, while a lower factor decreases it. **Instructions**: 1. **Function 1**: Implement `increase_brightness`. 2. **Function 2**: Implement `decrease_brightness`. # Function Definitions: 1. `increase_brightness(image: List[List[int]], factor: float) -> List[List[int]]`: * **Input**: * `image`: A 2D list of integers representing the grayscale image where each integer is between 0 to 255. * `factor`: A float representing the factor by which to increase the brightness. * **Output**: * Returns a 2D list of integers representing the brightened image. 2. `decrease_brightness(image: List[List[int]], factor: float) -> List[List[int]]`: * **Input**: * `image`: A 2D list of integers representing the grayscale image where each integer is between 0 to 255. * `factor`: A float representing the factor by which to decrease the brightness. * **Output**: * Returns a 2D list of integers representing the darkened image. # Specifications: * The resultant brightness values should be clamped between the range 0 to 255. * Each pixel value is an integer, so any resultant non-integer pixel value should be rounded to the nearest integer. * Ensure the output image maintains the same dimensions as the input image. # Constraints: * The `image` will always be a non-empty 2D list. * Pixel values in the image are between 0 and 255 inclusive. * The `factor` for increasing brightness will always be `>= 1.0`. * The `factor` for decreasing brightness will always be `<= 1.0`. # Example: ```python image = [ [100, 120, 130], [140, 160, 180], [200, 220, 240] ] increase_factor = 1.2 decrease_factor = 0.8 # Call the increase brightness function brightened_image = increase_brightness(image, increase_factor) print(brightened_image) # Expected Output: # [ # [120, 144, 156], # [168, 192, 216], # [240, 255, 255] # ] # Call the decrease brightness function darkened_image = decrease_brightness(image, decrease_factor) print(darkened_image) # Expected Output: # [ # [80, 96, 104], # [112, 128, 144], # [160, 176, 192] # ] ``` Good luck and demonstrate your ability to handle image processing operations to adjust the brightness of grayscale images!","solution":"def increase_brightness(image, factor): Increases the brightness of a grayscale image by a given factor. :param image: List[List[int]] - 2D list of integers representing the grayscale image :param factor: float - Factor by which to increase the brightness :return: List[List[int]] - The brightened image as a 2D list brightened_image = [] for row in image: brightened_row = [min(255, round(pixel * factor)) for pixel in row] brightened_image.append(brightened_row) return brightened_image def decrease_brightness(image, factor): Decreases the brightness of a grayscale image by a given factor. :param image: List[List[int]] - 2D list of integers representing the grayscale image :param factor: float - Factor by which to decrease the brightness :return: List[List[int]] - The darkened image as a 2D list darkened_image = [] for row in image: darkened_row = [max(0, round(pixel * factor)) for pixel in row] darkened_image.append(darkened_row) return darkened_image"},{"question":"# Background A finite state machine (FSM) is a computational model used to design both computer programs and sequential logic circuits. It is composed of a finite number of states, transitions between those states, and actions. One common type of FSM is the deterministic finite automaton (DFA), which operates on a finite input alphabet to determine if an input string is accepted or rejected by the automaton. # Problem Statement Write a function `is_accepted_by_dfa(transitions: dict, start_state: str, accept_states: List[str], input_string: str) -> bool` that determines whether an input string is accepted by a given deterministic finite automaton (DFA). # Input - `transitions`: A dictionary representing the state transition table of the DFA. The keys are tuples (state, input_symbol), and the values are the resulting state after the transition. - `start_state`: A string representing the initial state of the DFA. - `accept_states`: A list of strings representing the accept states of the DFA. - `input_string`: A string of input symbols to be processed by the DFA. # Output - A boolean value: `True` if the DFA accepts the input string, `False` otherwise. # Constraints - The input symbols in `input_string` should all be in the DFA\'s input alphabet specified in the `transitions` dictionary. - The `transitions` dictionary will cover all possible states and input symbols (complete transition function for the DFA). # Example ```python transitions = { (\'q0\', \'a\'): \'q1\', (\'q0\', \'b\'): \'q0\', (\'q1\', \'a\'): \'q1\', (\'q1\', \'b\'): \'q2\', (\'q2\', \'a\'): \'q2\', (\'q2\', \'b\'): \'q2\' } start_state = \'q0\' accept_states = [\'q2\'] input_string = \'aab\' result = is_accepted_by_dfa(transitions, start_state, accept_states, input_string) print(result) # Output should be True ``` # Notes - Ensure that your implementation correctly handles the transitions according to the DFA definition. - Raised `ValueError` if any symbol in `input_string` is not found in the DFA\'s alphabet. # Hints - Iterate over the input string, starting from the start state and following the transitions defined in the `transitions` dictionary. - After processing the entire input string, check if the current state is one of the accept states.","solution":"from typing import List, Dict, Tuple def is_accepted_by_dfa(transitions: Dict[Tuple[str, str], str], start_state: str, accept_states: List[str], input_string: str) -> bool: Determines whether an input string is accepted by a given DFA. Args: transitions (dict): State transition table of the DFA. start_state (str): Initial state of the DFA. accept_states (list): Accept states of the DFA. input_string (str): Input string to be processed by the DFA. Returns: bool: True if the DFA accepts the input string, False otherwise. current_state = start_state for symbol in input_string: if (current_state, symbol) not in transitions: raise ValueError(f\\"Symbol {symbol} is not in DFA\'s alphabet for state {current_state}\\") current_state = transitions[(current_state, symbol)] return current_state in accept_states"},{"question":"# Objective You are required to implement a function to solve the Traveling Salesman Problem (TSP) using the nearest neighbor heuristic. The goal is to evaluate your understanding of greedy algorithms and your ability to efficiently handle graph traversal. # Problem Statement Write a Python function `tsp_nearest_neighbor(graph: np.ndarray, start: int = 0) -> list` that solves the Traveling Salesman Problem for a given distance matrix using the nearest neighbor heuristic. Input: 1. `graph` (np.ndarray): an `N x N` matrix representing distances between `N` cities. `graph[i][j]` is the distance from city `i` to city `j`. 2. `start` (int, optional): the starting city (default is `0`). Output: Returns a list of integers representing the order in which the cities are visited, starting and ending at the starting city. Constraints: 1. Ensure that all distances in the graph are non-negative. 2. The input matrix `graph` is guaranteed to be symmetric, i.e., `graph[i][j] == graph[j][i]` for all `i` and `j`. 3. The function should handle cases where the number of cities `N` is at least `2`. # Performance Requirements 1. Achieve a solution that efficiently handles input graphs with up to `100` cities. 2. Ensure all numerical operations are performed within acceptable time complexity for the input size. # Example ```python import numpy as np graph = np.array([ [0, 29, 20, 21], [29, 0, 15, 17], [20, 15, 0, 28], [21, 17, 28, 0] ]) start = 0 solution = tsp_nearest_neighbor(graph, start) print(solution) # Expected output: [0, 2, 1, 3, 0] ``` Write the function `tsp_nearest_neighbor` that implements the above problem statement.","solution":"import numpy as np def tsp_nearest_neighbor(graph: np.ndarray, start: int = 0) -> list: Solves the Traveling Salesman Problem using the nearest neighbor heuristic. Parameters: graph (np.ndarray): N x N matrix representing distances between N cities. start (int): The starting city (default is 0). Returns: list: The order in which cities are visited, starting and ending at the starting city. n = graph.shape[0] visited = [False] * n path = [start] visited[start] = True current_city = start for _ in range(n - 1): nearest_city = None nearest_distance = float(\'inf\') for city in range(n): if not visited[city] and graph[current_city, city] < nearest_distance: nearest_city = city nearest_distance = graph[current_city, city] path.append(nearest_city) visited[nearest_city] = True current_city = nearest_city path.append(start) # Return to the starting city return path"},{"question":"# Binary Search: Find Minimum in Rotated Sorted Array Problem Statement You are given a rotated sorted array and tasked to find the minimum element in this array. The array was originally sorted in ascending order but then rotated at some pivot unknown to you beforehand (i.e., `[0,1,2,4,5,6,7]` might become `[4,5,6,7,0,1,2]`). Function Signature ```python def find_min(rotated_array: list) -> int: pass ``` Input - A list of integers, `rotated_array`, representing the rotated sorted array. Output - An integer representing the minimum element in the array. Example ```python # Example 1 find_min([4,5,6,7,0,1,2]) -> 0 # Example 2 find_min([3,4,5,1,2]) -> 1 # Example 3 find_min([11,13,15,17]) -> 11 # Example 4 find_min([5,6,7,8,1,2,3,4]) -> 1 ``` Constraints - You may assume no duplicate exists in the array. - The array will have at least one element and at most `10^4` elements. - The array was originally sorted in ascending order, then rotated. Additional Information - Aim for O(log n) time complexity using binary search. - Test your function with different edge cases, including arrays of length 1 and arrays that were not rotated. Make sure to handle all edge cases efficiently to ensure the correctness of your implementation.","solution":"def find_min(rotated_array): This function finds the minimum element in a rotated sorted array. if not rotated_array: raise ValueError(\\"The input array cannot be empty\\") left, right = 0, len(rotated_array) - 1 while left < right: mid = (left + right) // 2 if rotated_array[mid] > rotated_array[right]: # The minimum value is in the right part left = mid + 1 else: # The minimum value is in the left part including mid right = mid return rotated_array[left]"},{"question":"# Maximum Subarray Sum with Indices In this task, your objective is to find the maximum subarray sum in a given integer array, as well as to return the starting and ending indices of this subarray. Problem Description Given an integer array `nums` of length `n`, find the contiguous subarray (containing at least one number) which has the largest sum and return both the sum as well as the starting and ending indices of this subarray. If there are multiple subarrays with the same maximum sum, return the indices of the first occurrence. Input * `nums`: a list of integers representing the array with length (n). Output * A tuple with three elements: - an integer representing the maximum sum subarray, - an integer representing the starting index of the subarray, - an integer representing the ending index of the subarray. Constraints * (1 leq n leq 10^4) * (-10^5 leq nums[i] leq 10^5) Example ```python nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4] result = max_subarray_with_indices(nums) print(result) ``` Expected Output: ``` (6, 3, 6) ``` Explanation The subarray with the maximum sum is `[4, -1, 2, 1]` which has a sum of `6` and starts at index `3` and ends at index `6`. Function Signature ```python def max_subarray_with_indices(nums: list[int]) -> tuple[int, int, int]: pass ``` Notes * You must implement the approach to find the maximum subarray sum using Kadane\'s algorithm, which operates in linear time. * Ensure that you go through the array once to calculate the maximum sum and to track the starting and ending indices of the subarray.","solution":"def max_subarray_with_indices(nums: list[int]) -> tuple[int, int, int]: Finds the maximum sum subarray and returns the sum and its starting and ending indices. Uses Kadane\'s Algorithm with additional indices tracking. :param nums: List of integers :return: Tuple of (maximum sum, start index, end index) max_sum = float(\'-inf\') current_sum = 0 start = end = 0 temp_start = 0 for i in range(len(nums)): current_sum += nums[i] if current_sum > max_sum: max_sum = current_sum start = temp_start end = i if current_sum < 0: current_sum = 0 temp_start = i + 1 return max_sum, start, end"},{"question":"# Question: Distinct Elements in Subarrays Context: In computer programming, efficient searching and modifications within data structures are crucial. Problems such as finding distinct elements in subarrays frequently arise in algorithmic challenges and can be efficiently solved using advanced data structures like Hash Maps or Sets. Objective: Write a function that for a given array, returns the number of distinct elements for each subarray of a given length. Function Signature: ```python def count_distinct_elements(arr: List[int], k: int) -> List[int]: pass ``` Input: - `arr`: A list of integers `[a1, a2, ..., an]` where `1 <= n <= 10^6` and `1 <= ai <= 10^9`. - `k`: An integer representing the length of subarrays, `1 <= k <= n`. Output: - A list of integers representing the number of distinct elements in each subarray of length `k`. Constraints: - The length of the array will be at least as large as the length of the subarray. - Any subarray will not handle elements outside the given array. Example: ```python >>> count_distinct_elements([1, 2, 1, 3, 4, 2, 3], 4) [3, 4, 4, 3] ``` Explanation: - The subarrays of length 4 are `[1, 2, 1, 3]`, `[2, 1, 3, 4]`, `[1, 3, 4, 2]`, and `[3, 4, 2, 3]`. - Distinct elements counts are `3`, `4`, `4`, and `3` respectively. Tips: - Utilize efficient data structures to manage the sliding window and compute distinct elements quickly. - Consider algorithms that support O(1) insertion and deletion for optimal performance, such as using a hash map to track occurrences. This question tests the ability to handle sliding windows, distinct element counting, and efficient use of data structures, blending well with skills required for algorithmic problem-solving in programming competitions or technical interviews.","solution":"from typing import List from collections import defaultdict def count_distinct_elements(arr: List[int], k: int) -> List[int]: This function returns the number of distinct elements for each subarray of length k. if k > len(arr): return [] result = [] freq_map = defaultdict(int) distinct_count = 0 # Initialize the frequency map for the first k elements for i in range(k): if freq_map[arr[i]] == 0: distinct_count += 1 freq_map[arr[i]] += 1 result.append(distinct_count) # Slide the window across the array for i in range(k, len(arr)): # Remove the first element of the previous window if freq_map[arr[i - k]] == 1: distinct_count -= 1 freq_map[arr[i - k]] -= 1 # Add the new element of the current window if freq_map[arr[i]] == 0: distinct_count += 1 freq_map[arr[i]] += 1 result.append(distinct_count) return result"},{"question":"You are tasked with implementing a function that determines the shortest path from the top-left corner to the bottom-right corner of a given 2D grid. Each cell in the grid has a non-negative integer which represents the cost of stepping onto that cell. You can only move right or down from the current cell. # Objective Write a function `min_path_sum(grid: List[List[int]]) -> int` that: 1. Takes a 2D list `grid` of integers as input. 2. Computes the minimum cost path from the top-left to the bottom-right corner of the grid. 3. Returns the minimum path sum. # Input * A 2D list `grid` of integers, where `1 ≤ len(grid), len(grid[0]) ≤ 100`, and each integer `0 ≤ grid[i][j] ≤ 100`. # Output * An integer representing the minimum cost path from the top-left to the bottom-right corner of the grid. # Constraints 1. The path can only move right or down at any point in time. 2. The grid will always have at least one cell. # Performance Requirement * The solution should run efficiently within the given grid size constraints. # Scenarios 1. For a `3x3` grid `[[1,3,1], [1,5,1], [4,2,1]]`, the function should return `7` because the path `1→3→1→1→1` has the minimum sum. 2. For a `2x2` grid `[[1,2], [1,1]]`, the function should return `3` because the path `1→1→1` has the minimum sum. 3. For a `3x2` grid `[[1,2], [5,6], [1,1]]`, the function should return `8` because the path `1→2→6→1` has the minimum sum. # Example ```python print(min_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]])) # Output: 7 print(min_path_sum([[1, 2], [1, 1]])) # Output: 3 print(min_path_sum([[1]])) # Output: 1 (single cell grid) print(min_path_sum([[0, 0], [0, 0]])) # Output: 0 print(min_path_sum([[1, 2], [5, 6], [1, 1]])) # Output: 8 ``` Implement the function to solve the problem accurately and efficiently for all valid inputs.","solution":"from typing import List def min_path_sum(grid: List[List[int]]) -> int: Computes the minimum path sum from the top-left to bottom-right of the grid. if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) # Initialize dp table with the same dimensions as the grid dp = [[0 for _ in range(cols)] for _ in range(rows)] # Start from the top-left corner dp[0][0] = grid[0][0] # Fill the first row for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) # The bottom-right corner contains the result return dp[-1][-1]"},{"question":"# Recursive Binary Search Implementation **Objective**: Implement a recursive version of the binary search algorithm. The function should find the index of a target value within a sorted list. If the target value is not present in the list, the function should return -1. **Function Signature**: ```python def recursive_binary_search(arr: list[int], target: int, low: int, high: int) -> int: ``` **Input**: - `arr`: A list of sorted integers. - `target`: An integer value to search for within `arr`. - `low`: An integer representing the lower bound index for the search (typically starts at 0). - `high`: An integer representing the upper bound index for the search (typically starts at the length of the list minus one). **Output**: - An integer representing the index of `target` in `arr`. If the `target` is not found, return -1. **Constraints**: - The input will be a sorted list of integers. - The low and high parameters are valid indices within the list. **Error Handling**: - Ensure the function handles cases where the list is empty. - Ensure the function does not perform out-of-bound index operations. **Examples**: ```python assert recursive_binary_search([1, 2, 3, 4, 5], 3, 0, 4) == 2 assert recursive_binary_search([10, 20, 30, 40, 50], 10, 0, 4) == 0 assert recursive_binary_search([3, 4, 5, 20, 90], 90, 0, 4) == 4 assert recursive_binary_search([1, 3, 5, 7, 9], 8, 0, 4) == -1 assert recursive_binary_search([], 10, 0, -1) == -1 ``` **Requirements**: - Implement the binary search algorithm recursively. - The function should operate efficiently with an average and worst-case time complexity of O(log n).","solution":"def recursive_binary_search(arr, target, low, high): Perform a recursive binary search on a sorted array to find the target value. Parameters: arr (list of int): The sorted array where the search is conducted. target (int): The value to search for. low (int): The lower bound index of the search range. high (int): The upper bound index of the search range. Returns: int: The index of the target value in the array, or -1 if the target is not found. if low > high: return -1 mid = (low + high) // 2 if arr[mid] == target: return mid elif arr[mid] > target: return recursive_binary_search(arr, target, low, mid - 1) else: return recursive_binary_search(arr, target, mid + 1, high)"},{"question":"# Problem Statement Design and implement a Music Playlist Manager to handle song operations in a music playlist on a streaming service. Your task is to create a class that maintains a playlist and supports the addition, removal, and retrieval of songs, as well as the ability to sort the playlist based on different criteria. # Requirements 1. **Add Song**: Add a song to the playlist. 2. **Remove Song**: Remove a song from the playlist. 3. **Get Playlist**: Retrieve the list of songs in the playlist. 4. **Sort Playlist**: Sort the playlist based on a given attribute (title, artist, or duration). You need to implement a class `PlaylistManager` with the following methods: * `add_song(self, title: str, artist: str, duration: int) -> None`: Add a song to the playlist with the given title, artist, and duration (in seconds). * `remove_song(self, title: str) -> bool`: Remove a song with the given title from the playlist. Returns `True` if the song is successfully removed, `False` otherwise. * `get_playlist(self) -> List[Dict[str, Any]]`: Retrieve the current list of songs in the playlist. Each song should be represented as a dictionary with keys \'title\', \'artist\', and \'duration\'. * `sort_playlist(self, sort_by: str) -> None`: Sort the current playlist in-place based on the given attribute. The `sort_by` parameter can be \'title\', \'artist\', or \'duration\'. # Constraints * Each song will have a unique title. * Songs should be sorted in ascending order. * You can assume inputs to methods are well-formed and within reasonable size limits. # Example ```python playlist_manager = PlaylistManager() # Test add_song playlist_manager.add_song(\\"Shape of You\\", \\"Ed Sheeran\\", 240) playlist_manager.add_song(\\"Blinding Lights\\", \\"The Weeknd\\", 200) # Test get_playlist assert playlist_manager.get_playlist() == [ {\\"title\\": \\"Shape of You\\", \\"artist\\": \\"Ed Sheeran\\", \\"duration\\": 240}, {\\"title\\": \\"Blinding Lights\\", \\"artist\\": \\"The Weeknd\\", \\"duration\\": 200}, ] # Test remove_song assert playlist_manager.remove_song(\\"Shape of You\\") == True assert playlist_manager.remove_song(\\"Havana\\") == False # Test get_playlist after removal assert playlist_manager.get_playlist() == [ {\\"title\\": \\"Blinding Lights\\", \\"artist\\": \\"The Weeknd\\", \\"duration\\": 200}, ] # Test sort_playlist playlist_manager.add_song(\\"Watermelon Sugar\\", \\"Harry Styles\\", 180) playlist_manager.sort_playlist(\\"title\\") assert playlist_manager.get_playlist() == [ {\\"title\\": \\"Blinding Lights\\", \\"artist\\": \\"The Weeknd\\", \\"duration\\": 200}, {\\"title\\": \\"Watermelon Sugar\\", \\"artist\\": \\"Harry Styles\\", \\"duration\\": 180}, ] playlist_manager.sort_playlist(\\"duration\\") assert playlist_manager.get_playlist() == [ {\\"title\\": \\"Watermelon Sugar\\", \\"artist\\": \\"Harry Styles\\", \\"duration\\": 180}, {\\"title\\": \\"Blinding Lights\\", \\"artist\\": \\"The Weeknd\\", \\"duration\\": 200}, ] ``` Create the PlaylistManager class based on the above requirements and constraints. Ensure that all methods are correctly implemented to handle the specified operations for managing a playlist of songs.","solution":"from typing import List, Dict, Any class PlaylistManager: def __init__(self): self.playlist = [] def add_song(self, title: str, artist: str, duration: int) -> None: Add a song to the playlist with the given title, artist, and duration. song = {\\"title\\": title, \\"artist\\": artist, \\"duration\\": duration} self.playlist.append(song) def remove_song(self, title: str) -> bool: Remove a song with the given title from the playlist. Returns True if the song is successfully removed, False otherwise. for song in self.playlist: if song[\'title\'] == title: self.playlist.remove(song) return True return False def get_playlist(self) -> List[Dict[str, Any]]: Retrieve the current list of songs in the playlist. Each song is represented as a dictionary with keys \'title\', \'artist\', and \'duration\'. return self.playlist def sort_playlist(self, sort_by: str) -> None: Sort the current playlist in-place based on the given attribute. The sort_by parameter can be \'title\', \'artist\', or \'duration\'. if sort_by in [\'title\', \'artist\', \'duration\']: self.playlist.sort(key=lambda song: song[sort_by])"},{"question":"Write a function `longest_common_subsequence(str1: str, str2: str) -> int` that computes the length of the longest common subsequence between two given strings. # Input - **Two strings** `str1` and `str2` where (1 leq text{len}(str1), text{len}(str2) leq 1000). # Output - An **integer** representing the length of the longest common subsequence between the given strings. # Constraints 1. The strings consist of lowercase English letters only. # Example ```python str1 = \\"abcdef\\" str2 = \\"acf\\" print(longest_common_subsequence(str1, str2)) # Output: 3 str1 = \\"12345\\" str2 = \\"54321\\" print(longest_common_subsequence(str1, str2)) # Output: 1 ``` Implement the function `longest_common_subsequence(str1: str, str2: str) -> int` by completing this task. Notes - Consider using dynamic programming to efficiently solve this problem. - Create a 2D DP table where the cell `dp[i][j]` represents the length of the longest common subsequence of the first `i` characters of `str1` and the first `j` characters of `str2`. - Use an iterative approach to fill in the DP table and derive the final answer from it.","solution":"def longest_common_subsequence(str1, str2): Computes the length of the longest common subsequence between two given strings. m, n = len(str1), len(str2) # Create a 2D DP table to store lengths of LCS dp = [[0] * (n+1) for _ in range(m+1)] # Iterate through both strings for i in range(1, m+1): for j in range(1, n+1): if str1[i-1] == str2[j-1]: # Match dp[i][j] = dp[i-1][j-1] + 1 else: # No match dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return dp[m][n]"},{"question":"# Problem Statement You are asked to implement a Sudoku solver. The solver should fill in the empty cells of a given partially completed 9x9 Sudoku grid following the standard Sudoku rules. # Requirements 1. **Sudoku Rules**: Each row, each column, and each 3x3 sub-grid must contain the digits from 1 to 9 without repetition. 2. **Solver Logic**: Use a backtracking algorithm to search for the solution. # Input * A 9x9 matrix (list of lists) containing integers from 1 to 9 and 0s, where 0s represent empty cells. # Output * A 9x9 matrix with the solved Sudoku grid, where no cells should contain 0s. # Constraints 1. The provided grid will always have at least one solution. 2. Use only standard Python libraries. 3. Your implementation should effectively handle the logic for solving typical Sudoku puzzles. # Example **Input**: ```python [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] ``` **Output**: ```python [ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9] ] ``` # Function Signature ```python def solve_sudoku(board: List[List[int]]) -> List[List[int]]: pass ``` # Note 1. Focus on implementing an efficient backtracking algorithm. 2. Ensure your solution passes the typical constraints and can handle various Sudoku puzzles efficiently. 3. Including comments and documentation within your code will help demonstrate your understanding of the logic.","solution":"from typing import List, Tuple def find_empty_position(board: List[List[int]]) -> Tuple[int, int]: for i in range(9): for j in range(9): if board[i][j] == 0: return i, j return -1, -1 def is_valid(board: List[List[int]], row: int, col: int, num: int) -> bool: box_row_start = (row // 3) * 3 box_col_start = (col // 3) * 3 for x in range(9): if board[row][x] == num or board[x][col] == num: return False for i in range(3): for j in range(3): if board[box_row_start + i][box_col_start + j] == num: return False return True def solve_sudoku(board: List[List[int]]) -> List[List[int]]: row, col = find_empty_position(board) if row == -1 and col == -1: return board for num in range(1, 10): if is_valid(board, row, col, num): board[row][col] = num if solve_sudoku(board): return board board[row][col] = 0 return False"},{"question":"# Coding Assessment Question Context In this task, you are required to manipulate and analyze date ranges, specifically to determine the overall duration between the earliest start date and the latest end date provided. This is a common requirement in project scheduling and timeline management. Task Write a Python function `total_project_duration(dates)` that: - Receives a list of dictionaries containing project date ranges. - Each dictionary has `start_date` and `end_date` keys with their values formatted as strings in `YYYY-MM-DD`. The function should calculate and return the total duration in days between the earliest `start_date` and the latest `end_date` from the list. Input - `dates` (list): A list of dictionaries representing project date ranges. Each dictionary has: - `start_date` (str): Project start date, formatted as `YYYY-MM-DD`. - `end_date` (str): Project end date, formatted as `YYYY-MM-DD`. Output - The function should return the total duration in days as an integer. Constraints - Each `start_date` will be earlier than or equal to its corresponding `end_date`. - The input list will have at least one dictionary. - Dates are guaranteed to be valid and properly formatted. Example ```python dates = [ {\\"start_date\\": \\"2023-01-15\\", \\"end_date\\": \\"2023-02-15\\"}, {\\"start_date\\": \\"2023-02-10\\", \\"end_date\\": \\"2023-03-10\\"}, {\\"start_date\\": \\"2023-01-20\\", \\"end_date\\": \\"2023-03-05\\"} ] days = total_project_duration(dates) print(days) # Output should be 54 (from 2023-01-15 to 2023-03-10) ``` Requirements - Parse date strings into date objects using Python\'s `datetime` module. - Calculate the overall duration in days between the earliest `start_date` and the latest `end_date`.","solution":"from datetime import datetime def total_project_duration(dates): Calculate the total duration in days between the earliest start date and the latest end date from the given list of date ranges. Args: dates (list): A list of dictionaries with \'start_date\' and \'end_date\' keys. Returns: int: Total duration in days. # Extract start and end dates start_dates = [datetime.strptime(d[\'start_date\'], \\"%Y-%m-%d\\") for d in dates] end_dates = [datetime.strptime(d[\'end_date\'], \\"%Y-%m-%d\\") for d in dates] # Find earliest start date and latest end date earliest_start = min(start_dates) latest_end = max(end_dates) # Calculate duration in days total_duration = (latest_end - earliest_start).days return total_duration"},{"question":"# Coding Assessment Question Scenario: You have recently joined a software development team that\'s working on a task scheduler application. The scheduler needs to determine the minimal interval required for a repeating task to avoid having overlapping tasks. Implement a function to compute the least common interval (LCI) for a given set of repeating tasks to ensure no task conflict based on their specific periods. Task: Write a function `least_common_interval(tasks: List[int]) -> int` that takes a list of integers representing the periodic intervals of given tasks and returns the minimal interval (LCI) in which the tasks can be scheduled without overlapping. Input: - `tasks`: A list of integers where each integer represents the repeating interval (in time units) of a given task. Output: - An integer representing the minimal interval in which all tasks can be scheduled without overlapping. Constraints: - The list `tasks` will contain at least one element. - The periods will be positive integers. - The intervals of tasks will be between 1 and 10^6. Example: ```python tasks = [2, 3, 4] print(least_common_interval(tasks)) # Output: 12 ``` Explanation: In the given example, the time intervals for the tasks are 2, 3, and 4 units respectively. The minimal interval in which all tasks can be scheduled without overlapping their start times is the LCI of 2, 3, and 4, which is 12. # Performance Requirements: - The algorithm should efficiently handle up to 10,000 task intervals. - The function should compute the least common interval in linear or near-linear time relative to the number of tasks. Hint: - Utilize the mathematical concept of the Least Common Multiple (LCM) to find the minimal interval. - Python\'s math library may provide useful functions to assist with this calculation. Note: - Ensure to handle edge cases where only one task is provided. - Consider the computational efficiency and numerical stability when implementing the LCM calculation for large intervals. Implement the function and test it with various test cases to ensure correctness and performance.","solution":"import math from typing import List def least_common_interval(tasks: List[int]) -> int: Calculate the least common interval (LCI) for the given list of task intervals. def lcm(a, b): return abs(a * b) // math.gcd(a, b) current_lcm = tasks[0] for task in tasks[1:]: current_lcm = lcm(current_lcm, task) return current_lcm"},{"question":"# Context A company is developing a contact management application. They need a feature to manage users\' contacts and allow for efficient searching and grouping of contacts. To facilitate this, as a developer, you need to implement a `ContactManager` class, leveraging a Trie (prefix tree) to store and manage the contacts. The contacts can be searched by prefix, and suggestions can be provided based on the prefix input. # Task Implement the following functions in a class named `ContactManager`, which internally uses a `Trie` to manage contact names: 1. `add_contact(self, name: str) -> None`: Adds a contact name to the Trie. 2. `remove_contact(self, name: str) -> None`: Removes a contact name from the Trie. Raise a `ValueError` if the contact name is not found. 3. `search_contact(self, prefix: str) -> list[str]`: Returns a list of all contact names that start with the given prefix, sorted in lexicographical order. 4. `get_all_contacts(self) -> list[str]`: Returns a list of all contact names sorted in lexicographical order. # Constraints * Contact names are non-empty strings with lengths in the range [1, 100]. * All contact names contain only lowercase English letters. * The Trie can store at most 10^4 contact names. # Performance Requirements Ensure all functions have efficient time complexity, making use of the Trie structure to optimize insertions, deletions, and search operations. # Class signature ```python class ContactManager: def __init__(self) -> None: pass def add_contact(self, name: str) -> None: pass def remove_contact(self, name: str) -> None: pass def search_contact(self, prefix: str) -> list[str]: pass def get_all_contacts(self) -> list[str]: pass ``` # Example Usage ```python cm = ContactManager() cm.add_contact(\\"alice\\") cm.add_contact(\\"bob\\") cm.add_contact(\\"alex\\") cm.add_contact(\\"albert\\") print(cm.search_contact(\\"al\\")) # [\'albert\', \'alex\', \'alice\'] print(cm.get_all_contacts()) # [\'albert\', \'alex\', \'alice\', \'bob\'] cm.remove_contact(\\"alice\\") print(cm.get_all_contacts()) # [\'albert\', \'alex\', \'bob\'] ```","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class ContactManager: def __init__(self) -> None: self.root = TrieNode() self.contacts = set() def add_contact(self, name: str) -> None: node = self.root for char in name: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True self.contacts.add(name) def remove_contact(self, name: str) -> None: if name not in self.contacts: raise ValueError(f\\"Contact \'{name}\' not found.\\") self._remove(self.root, name, 0) self.contacts.remove(name) def _remove(self, node, word, depth): if not node: return False if depth == len(word): if node.is_end_of_word: node.is_end_of_word = False return len(node.children) == 0 char = word[depth] if char in node.children and self._remove(node.children[char], word, depth + 1): del node.children[char] return len(node.children) == 0 and not node.is_end_of_word return False def search_contact(self, prefix: str) -> list[str]: node = self.root for char in prefix: if char in node.children: node = node.children[char] else: return [] return self._collect_all_words(node, prefix) def _collect_all_words(self, node, prefix): results = [] if node.is_end_of_word: results.append(prefix) for char, next_node in node.children.items(): results.extend(self._collect_all_words(next_node, prefix + char)) return sorted(results) def get_all_contacts(self) -> list[str]: return sorted(list(self.contacts))"},{"question":"# Coding Assessment Question You are given an integer `n` which represents the base of a number system, and a string `num` representing a number in that base. Your task is to write the function `convert_to_decimal(n: int, num: str) -> int` that converts the given number in base `n` to its decimal (base 10) equivalent. **Function Signature**: ```python def convert_to_decimal(n: int, num: str) -> int: pass ``` # Input * An integer `n` where `2 <= n <= 36` representing the base of the number system. * A string `num` which is a valid representation of a number in base `n`. # Output * Return an integer which is the decimal (base 10) representation of `num`. # Example ```python assert convert_to_decimal(2, \\"1010\\") == 10 assert convert_to_decimal(16, \\"1A\\") == 26 assert convert_to_decimal(8, \\"17\\") == 15 assert convert_to_decimal(10, \\"123\\") == 123 ``` # Constraints * The function should raise a `ValueError` if `n` is not within the range [2, 36]. * The string `num` contains only valid characters for the given base `n`. # Performance Requirements * Your solution must handle the conversion efficiently, even if `num` is a very large number. # Explanation Provide comments within your code explaining the steps or approaches taken, particularly around: * Validation of base `n` and the string `num` * The approach to converting the base `n` number to a decimal number * Handling of exceptional scenarios such as invalid bases or invalid characters in the input string Good luck!","solution":"def convert_to_decimal(n: int, num: str) -> int: Converts a number in base `n` to its decimal (base 10) equivalent. Arguments: n -- the base of the number system (integer between 2 and 36 inclusive) num -- the string representing the number in base `n` Returns: The decimal equivalent of the number. # Validate base if not (2 <= n <= 36): raise ValueError(\\"Base `n` must be between 2 and 36 inclusive.\\") # Check if all characters in num are valid for base n valid_chars = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\"[:n] if any(c not in valid_chars for c in num.upper()): raise ValueError(\\"The string `num` contains invalid characters for base `n`.\\") # Initialize the decimal result decimal_value = 0 # Convert each character from the string `num` for char in num.upper(): # Convert character to respective integer value digit_value = valid_chars.index(char) # Update the decimal value decimal_value = decimal_value * n + digit_value return decimal_value"},{"question":"# Pattern Matching: Detecting Complex Substring Patterns In this coding problem, you will be implementing a function that detects specific patterns within a given input string. The patterns to be detected are based on sequences of characters that may include wildcards. Problem Description You are given a string `text` and a pattern `pattern`, where the pattern can include regular characters and the wildcard characters: - `?` which matches any single character. - `*` which matches any sequence of characters (including the empty sequence). Your task is to implement a function to determine whether the given pattern matches the entire string. Function to Implement 1. **`is_match`**: ```python def is_match(text: str, pattern: str) -> bool: ``` - **Input Parameters**: - `text`: The input text string. - `pattern`: The pattern string containing regular characters and wildcard characters `?` and `*`. - **Output**: - Returns `True` if the pattern matches the entire text, otherwise returns `False`. Constraints - The `text` string will be non-empty and can have up to `1000` characters. - The `pattern` string will also be non-empty and can have up to `1000` characters. - Wildcards are limited to `?` and `*` where: - `?` matches exactly one character. - `*` matches zero or more consecutive characters. Example Usage 1. Pattern matching with wildcards: ```python result = is_match(\\"abcde\\", \\"a*e\\") print(result) # Should output: True result = is_match(\\"abcde\\", \\"a?c*e\\") print(result) # Should output: True result = is_match(\\"abcde\\", \\"a?d*e\\") print(result) # Should output: False ``` You must follow the given function signature and provide a complete implementation for the problem described above. The solution should efficiently match patterns using dynamic programming techniques where necessary to handle the complexity introduced by wildcard characters. [End of Question]","solution":"def is_match(text: str, pattern: str) -> bool: # Create a DP table where dp[i][j] represents if text[:i] matches pattern[:j] dp = [[False] * (len(pattern) + 1) for _ in range(len(text) + 1)] # Base case: empty text and empty pattern match dp[0][0] = True # Base case: text is empty but pattern might contain stars which can match empty text for j in range(1, len(pattern) + 1): if pattern[j - 1] == \'*\': dp[0][j] = dp[0][j - 1] # Populate the rest of the DP table for i in range(1, len(text) + 1): for j in range(1, len(pattern) + 1): if pattern[j - 1] == \'*\': # Star can match zero characters (dp[i][j-1]) or one more character (dp[i-1][j]) dp[i][j] = dp[i][j - 1] or dp[i - 1][j] elif pattern[j - 1] == \'?\' or pattern[j - 1] == text[i - 1]: dp[i][j] = dp[i - 1][j - 1] return dp[len(text)][len(pattern)]"},{"question":"# Coding Question: Inventory Management System Imagine you are developing a system for a bookstore to manage their inventory. You need to implement a function `inventory_management` that manages the stock levels, adds new books, updates the stock for existing books, and removes books that are out of stock. Function Signature ```python def inventory_management(current_inventory: Dict[str, int], actions: List[Tuple[str, str, int]]) -> Dict[str, int]: ``` Parameters - **current_inventory**: (dict) The current inventory of the bookstore, where keys are book titles (strings) and values are the quantities in stock (integers). - **actions**: (list of tuples) A list of actions to perform on the inventory. Each action is represented as a tuple containing: - Action type: \'add\' or \'update\' (string) - Book title (string) - Quantity (integer) Returns - (dict) The updated inventory after performing all the actions. Any book with a quantity of 0 or less should be removed from the inventory. Constraints - The **quantity** in the actions can be positive or negative, reflecting the addition or removal of books. - Ensure that after all actions, no book with a non-positive quantity remains in the inventory. - All book titles are unique strings without any special characters or numerical values. Example Usage ```python current_inventory = { \'To Kill a Mockingbird\': 4, \'1984\': 6, \'The Great Gatsby\': 3 } actions = [ (\'add\', \'The Catcher in the Rye\', 5), (\'update\', \'1984\', -2), (\'update\', \'To Kill a Mockingbird\', -4), (\'add\', \'The Great Gatsby\', -3) ] print(inventory_management(current_inventory, actions)) # Outputs: {\'1984\': 4, \'The Catcher in the Rye\': 5} ``` Notes - Adding a new book (using \'add\' action type) that already exists should update its stock by increasing the quantity. - Updating a book (using \'update\' action type) with a negative quantity should decrease its stock. - Books with a resulting stock quantity of 0 or less should be removed from the inventory.","solution":"from typing import Dict, List, Tuple def inventory_management(current_inventory: Dict[str, int], actions: List[Tuple[str, str, int]]) -> Dict[str, int]: for action in actions: action_type, book_title, quantity = action if action_type == \'add\': if book_title in current_inventory: current_inventory[book_title] += quantity else: current_inventory[book_title] = quantity elif action_type == \'update\': if book_title in current_inventory: current_inventory[book_title] += quantity # Remove books with 0 or negative quantity if book_title in current_inventory and current_inventory[book_title] <= 0: del current_inventory[book_title] return current_inventory"},{"question":"**Context**: You are required to implement a function that analyzes a log file and determines the most frequent log level (INFO, DEBUG, WARNING, ERROR, or CRITICAL). The log file is a list of strings where each string represents a log entry starting with a log level followed by a timestamp and a message. The function must return the most frequent log level along with its count. If there\'s a tie, return the log level that comes first in the order: CRITICAL, ERROR, WARNING, INFO, DEBUG. **Task**: Create a function `most_frequent_log_level` that accepts a list of log entries and identifies the most frequent log level as described above. **Function Signature**: ```python def most_frequent_log_level(logs: List[str]) -> Tuple[str, int]: ``` **Input**: - `logs`: A list of strings where each string is a log entry that starts with one of the log levels \'INFO\', \'DEBUG\', \'WARNING\', \'ERROR\', or \'CRITICAL\', followed by a timestamp and a message. **Output**: - Return a tuple containing the most frequent log level and its count. **Examples**: ```python logs = [ \\"INFO 2023-10-01 12:00:00 This is an info message\\", \\"ERROR 2023-10-01 12:00:01 An error occurred\\", \\"DEBUG 2023-10-01 12:00:02 Debugging the application\\", \\"WARNING 2023-10-01 12:00:03 This is a warning\\", \\"ERROR 2023-10-01 12:00:04 Another error occurred\\", \\"INFO 2023-10-01 12:00:05 Info message again\\" ] result = most_frequent_log_level(logs) print(result) ``` Expected Output: ``` (\'ERROR\', 2) ``` **Constraints**: - Log levels are guaranteed to be one of the following: \'INFO\', \'DEBUG\', \'WARNING\', \'ERROR\', \'CRITICAL\'. - Each log entry will start with a log level followed by a space, a timestamp, another space, and then the log message. - It is guaranteed that the input list `logs` is not empty. Ensure that your implementation handles all constraints and edge cases effectively.","solution":"from typing import List, Tuple from collections import Counter def most_frequent_log_level(logs: List[str]) -> Tuple[str, int]: Identifies the most frequent log level from a list of log entries and returns the log level with its count. Ties are resolved in the order: CRITICAL, ERROR, WARNING, INFO, DEBUG. log_levels = [\'CRITICAL\', \'ERROR\', \'WARNING\', \'INFO\', \'DEBUG\'] log_count = Counter() for log in logs: log_level = log.split()[0] if log_level in log_levels: log_count[log_level] += 1 most_frequent = max(log_levels, key=lambda level: (log_count[level], -log_levels.index(level))) return most_frequent, log_count[most_frequent]"},{"question":"# Question: Implement a Balanced Binary Search Tree with AVL Trees You are required to implement an AVL tree to maintain a dynamically balanced binary search tree. The AVL tree should support insertion, deletion, and searching efficiently. # Scenario You are building a database indexing feature that needs to maintain data in a balanced binary search tree for efficient querying, insertion, and deletion operations. Implement an AVL tree data structure that ensures the height balance condition is maintained after every insertion and deletion. # Function Signature ```python class AVLTreeNode: def __init__(self, key: int): self.left = None self.right = None self.height = 1 self.key = key class AVLTree: def insert(self, root: AVLTreeNode, key: int) -> AVLTreeNode: pass def delete(self, root: AVLTreeNode, key: int) -> AVLTreeNode: pass def search(self, root: AVLTreeNode, key: int) -> bool: pass ``` # Input - `key` (int): An integer value to insert, search, or delete from the AVL tree. - `root` (AVLTreeNode): The root node of the AVL tree. # Output - For insertion and deletion, return the updated root of the AVL tree. - For searching, return `True` if the key exists in the AVL tree, otherwise return `False`. # Constraints - All `key` values are distinct integers. - Implement the AVL tree such that it maintains balance after each insertion or deletion. # Example ```python avl = AVLTree() root = None root = avl.insert(root, 10) root = avl.insert(root, 20) root = avl.insert(root, 30) assert root.key == 20 # After balancing, 20 should be the new root root = avl.insert(root, 40) root = avl.insert(root, 50) assert avl.search(root, 30) == True assert avl.search(root, 60) == False root = avl.delete(root, 20) assert avl.search(root, 20) == False ``` # Requirements - Implement the full AVL tree class with insert, delete, and search methods. - Ensure the tree remains balanced after each insertion and deletion. - Use appropriate rotations (left, right, and double rotations) to maintain the balance condition. - Your solution should handle a variety of cases, including edge cases where the tree becomes imbalanced. These steps should help you implement an AVL tree that maintains balance, ensuring operations like searching, insertion, and deletion are efficient.","solution":"class AVLTreeNode: def __init__(self, key: int): self.left = None self.right = None self.height = 1 self.key = key class AVLTree: def get_height(self, node: AVLTreeNode) -> int: if not node: return 0 return node.height def get_balance(self, node: AVLTreeNode) -> int: if not node: return 0 return self.get_height(node.left) - self.get_height(node.right) def left_rotate(self, z: AVLTreeNode) -> AVLTreeNode: y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def right_rotate(self, y: AVLTreeNode) -> AVLTreeNode: x = y.left T2 = x.right x.right = y y.left = T2 y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) x.height = 1 + max(self.get_height(x.left), self.get_height(x.right)) return x def insert(self, root: AVLTreeNode, key: int) -> AVLTreeNode: if not root: return AVLTreeNode(key) elif key < root.key: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) balance = self.get_balance(root) # Left Left Case if balance > 1 and key < root.left.key: return self.right_rotate(root) # Right Right Case if balance < -1 and key > root.right.key: return self.left_rotate(root) # Left Right Case if balance > 1 and key > root.left.key: root.left = self.left_rotate(root.left) return self.right_rotate(root) # Right Left Case if balance < -1 and key < root.right.key: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def min_value_node(self, node: AVLTreeNode) -> AVLTreeNode: if node is None or node.left is None: return node return self.min_value_node(node.left) def delete(self, root: AVLTreeNode, key: int) -> AVLTreeNode: if not root: return root if key < root.key: root.left = self.delete(root.left, key) elif key > root.key: root.right = self.delete(root.right, key) else: if root.left is None: temp = root.right root = None return temp elif root.right is None: temp = root.left root = None return temp temp = self.min_value_node(root.right) root.key = temp.key root.right = self.delete(root.right, temp.key) if root is None: return root root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) balance = self.get_balance(root) # Left Left if balance > 1 and self.get_balance(root.left) >= 0: return self.right_rotate(root) # Left Right if balance > 1 and self.get_balance(root.left) < 0: root.left = self.left_rotate(root.left) return self.right_rotate(root) # Right Right if balance < -1 and self.get_balance(root.right) <= 0: return self.left_rotate(root) # Right Left if balance < -1 and self.get_balance(root.right) > 0: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def search(self, root: AVLTreeNode, key: int) -> bool: if not root: return False if root.key == key: return True elif key < root.key: return self.search(root.left, key) else: return self.search(root.right, key)"},{"question":"# Max Consecutive Ones Problem Statement: Given a binary array `A`, your task is to determine the maximum number of consecutive `1`s in the array. Write a function `max_consecutive_ones(A: List[int]) -> int` that receives a list `A` consisting of zeroes and ones, and returns the maximum count of consecutive `1`s in the array. # Input: * A list `A` of length `0 <= len(A) <= 10^5` containing only the integers `0` and `1`. # Output: * Returns an integer representing the maximum number of consecutive `1`s in the array. # Constraints: * The length of the array can be very large (up to 10^5 elements). * The array contains only binary values (`0` or `1`). # Example: 1. `max_consecutive_ones([1, 1, 0, 1, 1, 1])` should return `3` 2. `max_consecutive_ones([1, 0, 1, 1, 0, 1])` should return `2` 3. `max_consecutive_ones([0, 0, 0, 0, 0, 0])` should return `0` 4. `max_consecutive_ones([1, 1, 1, 1, 1, 1])` should return `6` 5. `max_consecutive_ones([])` should return `0` Additional Notes: * Ensure your implementation can handle very large input sizes efficiently. * Consider edge cases such as an empty array or arrays with no `1`s. * Optimal solutions ideally work in O(n) time complexity, where n is the length of the array.","solution":"from typing import List def max_consecutive_ones(A: List[int]) -> int: Returns the maximum number of consecutive 1s in the binary array A. max_count = 0 current_count = 0 for num in A: if num == 1: current_count += 1 max_count = max(max_count, current_count) else: current_count = 0 return max_count"},{"question":"# Problem Statement You are tasked with creating a program that simulates a simple flight reservation system. The system should allow users to book, cancel, and view flight reservations. The handling of reservations must ensure no overbooking occurs and provide functionality to retrieve detailed reservation information. # Objectives 1. **Class `FlightReservationSystem`:** - **Initialization**: - Accepts a dictionary `flights` where keys are flight numbers and values are the available seat count for each flight. - **Methods**: - `reserve_seat(flight_num: str, passenger_name: str) -> str`: - **Input**: - `flight_num`: a string representing the flight number. - `passenger_name`: a string representing the passenger\'s name. - **Output**: - A confirmation message \\"Reservation confirmed for {passenger_name} on flight {flight_num}\\". - **Error Handling**: - If the flight number does not exist in the system, raise a `ValueError` with the message \\"Flight not found\\". - If there are no available seats on the flight, raise a `ValueError` with the message \\"No available seats\\". - `cancel_reservation(flight_num: str, passenger_name: str) -> str`: - **Input**: - `flight_num`: a string representing the flight number. - `passenger_name`: a string representing the passenger\'s name. - **Output**: - A confirmation message \\"Reservation for {passenger_name} on flight {flight_num} has been cancelled\\". - **Error Handling**: - If the flight number does not exist in the system, raise a `ValueError` with the message \\"Flight not found\\". - If the passenger did not have a reservation, raise a `ValueError` with the message \\"Reservation not found\\". - `view_reservations(flight_num: str) -> list`: - **Input**: - `flight_num`: a string representing the flight number. - **Output**: - A list of passenger names with reservations on the specified flight. - **Error Handling**: - If the flight number does not exist in the system, raise a `ValueError` with the message \\"Flight not found\\". # Examples ```python flights = { \\"AA123\\": 2, \\"BB456\\": 3 } # Create an instance of the FlightReservationSystem with predefined flights reservation_system = FlightReservationSystem(flights) # reserve_seat examples: assert reservation_system.reserve_seat(\\"AA123\\", \\"John Doe\\") == \\"Reservation confirmed for John Doe on flight AA123\\" assert reservation_system.reserve_seat(\\"AA123\\", \\"Jane Smith\\") == \\"Reservation confirmed for Jane Smith on flight AA123\\" try: reservation_system.reserve_seat(\\"AA123\\", \\"Alice Johnson\\") except ValueError as e: assert str(e) == \\"No available seats\\" # cancel_reservation examples: assert reservation_system.cancel_reservation(\\"AA123\\", \\"John Doe\\") == \\"Reservation for John Doe on flight AA123 has been cancelled\\" try: reservation_system.cancel_reservation(\\"AA123\\", \\"Bob Brown\\") except ValueError as e: assert str(e) == \\"Reservation not found\\" # view_reservations examples: assert reservation_system.view_reservations(\\"AA123\\") == [\\"Jane Smith\\"] try: reservation_system.view_reservations(\\"CC789\\") except ValueError as e: assert str(e) == \\"Flight not found\\" ``` You are expected to implement the `FlightReservationSystem` class and test your solutions to ensure all edge cases and scenarios are properly handled.","solution":"class FlightReservationSystem: def __init__(self, flights): self.flights = flights # Dictionary with flight numbers as keys and available seat count as values self.reservations = {flight: [] for flight in flights} # Dictionary to store reservations def reserve_seat(self, flight_num, passenger_name): if flight_num not in self.flights: raise ValueError(\\"Flight not found\\") if len(self.reservations[flight_num]) >= self.flights[flight_num]: raise ValueError(\\"No available seats\\") self.reservations[flight_num].append(passenger_name) return f\\"Reservation confirmed for {passenger_name} on flight {flight_num}\\" def cancel_reservation(self, flight_num, passenger_name): if flight_num not in self.flights: raise ValueError(\\"Flight not found\\") if passenger_name not in self.reservations[flight_num]: raise ValueError(\\"Reservation not found\\") self.reservations[flight_num].remove(passenger_name) return f\\"Reservation for {passenger_name} on flight {flight_num} has been cancelled\\" def view_reservations(self, flight_num): if flight_num not in self.flights: raise ValueError(\\"Flight not found\\") return self.reservations[flight_num]"},{"question":"# Problem: Matrix Transpose Implementation You are working on a data analysis tool and your task is to implement a function that calculates the transpose of a given matrix. The transpose of a matrix is generated by swapping the rows and columns. Function Signature ```python def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: ... ``` Input * The function takes a single argument: * `matrix` (list of lists): A two-dimensional list (matrix) of integers where the number of rows and columns can vary, but the number of elements in each row will be the same. Output * The function should return a two-dimensional list (matrix), which is the transpose of the input matrix. Constraints * The matrix dimensions should not exceed 1000x1000 (1 million elements). * Ensure the function executes efficiently with consideration to time complexity. * Avoid using external libraries like numpy for this problem. # Example ```python assert transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[1, 4, 7], [2, 5, 8], [3, 6, 9]] assert transpose_matrix([[1, 2], [3, 4], [5, 6]]) == [[1, 3, 5], [2, 4, 6]] ``` Explanation: - For the matrix `[[1, 2, 3], [4, 5, 6], [7, 8, 9]]`: - Transpose: [ begin{bmatrix} 1 & 4 & 7 2 & 5 & 8 3 & 6 & 9 end{bmatrix} ] - For the matrix `[[1, 2], [3, 4], [5, 6]]`: - Transpose: [ begin{bmatrix} 1 & 3 & 5 2 & 4 & 6 end{bmatrix} ] To compute the transpose, iterate over each element of the rows and columns effectively swapping the position of rows and columns.","solution":"def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: Returns the transpose of the given matrix. if not matrix or not matrix[0]: return [] rows, cols = len(matrix), len(matrix[0]) transposed = [[0] * rows for _ in range(cols)] for i in range(rows): for j in range(cols): transposed[j][i] = matrix[i][j] return transposed"},{"question":"# Problem Statement You are tasked with writing a function `transpose_matrix` that transposes a given matrix. Transposing a matrix means reflecting the matrix over its main diagonal, switching the row and column indices of the matrix elements. # Function Signature ```python def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: pass ``` # Input - `matrix` (list[list[int]]): A 2D list representing an `m x n` matrix of integers. # Output - Returns a new 2D list representing the transposed `n x m` matrix. # Constraints - The input matrix will have dimensions `m x n` where `1 <= m, n <= 500`. - The elements of the matrix are integers in the range `-10^6` to `10^6`. # Examples ```python >>> transpose_matrix([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose_matrix([[1]]) [[1]] >>> transpose_matrix([[0, -1], [1, 0], [2, 3]]) [[0, 1, 2], [-1, 0, 3]] ``` # Notes 1. The function should handle matrices of any size within the given constraints. 2. Ensure that the output matrix has its dimensions as `[original_num_columns] x [original_num_rows]`.","solution":"def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: Transposes the given matrix. Parameters: - matrix (list[list[int]]): A 2D list representing an m x n matrix of integers. Returns: - list[list[int]]: A 2D list representing the transposed n x m matrix. # Get number of rows and columns in the original matrix num_rows = len(matrix) num_columns = len(matrix[0]) # Initialize transposed matrix with the dimensions inverted transposed = [[0] * num_rows for _ in range(num_columns)] # Fill the transposed matrix with the transposed values for i in range(num_rows): for j in range(num_columns): transposed[j][i] = matrix[i][j] return transposed"},{"question":"# Student Grades Management Task You are developing a program to manage and analyze student grade data for a school. Your task is to write a function named `analyze_grades` that performs the following operations: 1. **Read Data from CSV**: Read student grades from a CSV file. Each row in the CSV represents a student\'s record and contains their name, and grades for multiple subjects. 2. **Calculate Average Grades**: Compute the average grade for each student. 3. **Determine Top Students**: Identify the top `n` students based on their average grades. 4. **Generate Report**: Create a summary report that lists each student along with their average grade, and the top `n` students. # Function Signature ```python def analyze_grades(filename: str, n: int) -> str: Analyzes student grades from a CSV file and generates a summary report. Parameters: - filename (str): The path to the CSV file containing student grades. - n (int): The number of top students to identify based on average grades. Returns: - str: A summary report of student names, their average grades, and the top `n` students. ``` # Requirements 1. **Read from CSV**: The function should read student data from a specified CSV file: - CSV Format: `Name, Subject1, Subject2, ..., SubjectN` - Example: `John Doe, 88, 92, 79, 85` 2. **Compute Average Grades**: Calculate the average grade for each student: - Ignore any invalid or non-numeric grades. 3. **Identify Top Students**: Determine the top `n` students with the highest average grades. 4. **Generate Report**: The report should include: - Each student\'s name and their average grade. - A list of the top `n` students. # Constraints - Handle file reading errors gracefully, providing meaningful error messages. - Ignore any invalid or non-numeric grades when calculating averages. # Example ```python report = analyze_grades(\\"grades.csv\\", 3) print(report) # Expected output: # John Doe: 86.0 # Jane Smith: 89.5 # Alice Johnson: 92.3 # # Top 3 Students: # 1. Alice Johnson # 2. Jane Smith # 3. John Doe ``` In this task, you will read data from a CSV file, process it to calculate average grades, and generate a summary report. The example demonstrates what the output should look like, making it easy to verify correctness. This ensures the question aligns well with the existing set in terms of style, complexity, and scope.","solution":"import csv def analyze_grades(filename: str, n: int) -> str: Analyzes student grades from a CSV file and generates a summary report. Parameters: - filename (str): The path to the CSV file containing student grades. - n (int): The number of top students to identify based on average grades. Returns: - str: A summary report of student names, their average grades, and the top `n` students. try: students = [] # Read the CSV file with open(filename, \'r\') as csvfile: reader = csv.reader(csvfile) for row in reader: if len(row) > 1: name, *grades = row numeric_grades = [] for grade in grades: try: numeric_grades.append(float(grade)) except ValueError: # Ignore non-numeric grades continue if numeric_grades: avg_grade = sum(numeric_grades) / len(numeric_grades) students.append((name, avg_grade)) # Sort students based on average grade in descending order students.sort(key=lambda x: x[1], reverse=True) # Generate report report_lines = [f\\"{name}: {avg_grade}\\" for (name, avg_grade) in students] top_students = \\"n\\".join([f\\"{i+1}. {students[i][0]}\\" for i in range(min(n, len(students)))]) report = \\"n\\".join(report_lines) + f\\"nnTop {n} Students:n\\" + top_students return report except FileNotFoundError: return \\"Error: The file was not found.\\" except Exception as e: return f\\"Error: {e}\\""},{"question":"# Context Sorting algorithms are a fundamental concept in computer science, essential for efficiently organizing data. Many types of sorting algorithms exist, each with its advantages and ideal use cases. One valuable class of sorting techniques is merge sort, which uses a divide-and-conquer approach to achieve excellent performance on large lists. # Task You are required to write a function that performs merge sort on a list of integers. Your implementation should use the divide-and-conquer methodology intrinsic to merge sort to divide the list into sublists, sort those sublists, and then merge them back together in sorted order. # Function Signature ```python def merge_sort(arr: List[int]) -> List[int]: pass ``` # Input - `arr` (List[int]): A list of integers to be sorted. # Output - `List[int]`: A new list of integers sorted in ascending order. # Constraints - The length of `arr` will be between 1 and 10^5. - The integers in `arr` will be between -10^9 and 10^9. # Examples ```python >>> merge_sort([3, 5, 2, 9, 1]) [1, 2, 3, 5, 9] >>> merge_sort([10, -1, 2, 5, 3]) [-1, 2, 3, 5, 10] >>> merge_sort([5]) [5] ``` # Additional Requirements - The function should be implemented using a recursive approach where the input list is split into halves until single-element sublists are achieved. - Use a helper function if necessary to manage the merging process of two sorted sublists. - Ensure the function is efficient to handle the upper constraint limits both in terms of time and space complexity.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Perform merge sort on a list of integers. if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: Merge two sorted lists into one sorted list. sorted_list = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 # Append the remaining elements (if any) sorted_list.extend(left[left_index:]) sorted_list.extend(right[right_index:]) return sorted_list"},{"question":"# Problem Statement You are provided with a list of tasks that need to be executed in a specific order such that each task can only be executed after all its dependencies have been completed. Your task is to write a function `task_order` that determines a valid sequence of executing these tasks using topological sorting. # Function Signature ```python def task_order(tasks: List[int], dependencies: List[Tuple[int, int]]) -> List[int]: pass ``` # Parameters - `tasks`: A list of integers representing the tasks (e.g., [1, 2, 3, 4]). - `dependencies`: A list of tuple pairs where each tuple (a, b) indicates that task `b` depends on the completion of task `a`. # Output - Returns a list of integers representing a valid execution order of the tasks. If there are multiple valid orders, any one of them is acceptable. # Constraints - There are no cycles in the dependency graph. - All tasks and dependencies are valid such that there is always at least one valid order. - Tasks are integers between 1 and 10000. - There can be up to 10000 dependencies. # Example ```python # Example 1: tasks = [1, 2, 3, 4] dependencies = [(1, 2), (1, 3), (3, 4), (2, 4)] assert task_order(tasks, dependencies) in [ [1, 2, 3, 4], [1, 3, 2, 4] ] # Both orders are valid # Example 2: tasks = [5, 6, 7] dependencies = [(5, 7), (6, 7)] assert task_order(tasks, dependencies) in [ [5, 6, 7], [6, 5, 7] ] # Both orders are valid ``` # Guidelines 1. You must implement topological sorting using algorithms such as Kahn\'s Algorithm or Depth First Search (DFS). 2. Make sure to handle edge cases where tasks have no dependencies or where dependencies form chains. 3. Complete the task considering the constraints to avoid issues with large input sizes, ensuring efficient time complexity. # Hints - Use a graph representation to model the tasks and dependencies. - Keep track of the in-degrees of each node (task) to determine the order of execution. - Use a queue or stack to manage the working list of tasks that can be executed.","solution":"from collections import deque, defaultdict from typing import List, Tuple def task_order(tasks: List[int], dependencies: List[Tuple[int, int]]) -> List[int]: # Create an adjacency list and a dictionary to keep track of in-degrees adj_list = defaultdict(list) in_degrees = {task: 0 for task in tasks} # Fill adjacency list and in-degrees dictionary for a, b in dependencies: adj_list[a].append(b) in_degrees[b] += 1 # Initialize the queue with tasks having zero in-degree queue = deque([task for task in tasks if in_degrees[task] == 0]) order = [] while queue: task = queue.popleft() order.append(task) # Process neighbors and reduce in-degrees for neighbor in adj_list[task]: in_degrees[neighbor] -= 1 if in_degrees[neighbor] == 0: queue.append(neighbor) return order"},{"question":"# Coding Assessment Question Objective Implement a function to convert Roman numerals to their integer equivalents and vice versa. Function Signature ```python def roman_to_int(roman: str) -> int: pass def int_to_roman(num: int) -> str: pass ``` Input * `roman`: A string representing a Roman numeral. * `num`: An integer representing a number to convert to a Roman numeral. Output * `roman_to_int` should return an integer equivalent of the given Roman numeral string. * `int_to_roman` should return a string representing the Roman numeral equivalent of the given integer. Example ```python # For the function roman_to_int: print(roman_to_int(\\"IX\\")) # Output: 9 print(roman_to_int(\\"XLII\\")) # Output: 42 # For the function int_to_roman: print(int_to_roman(9)) # Output: \\"IX\\" print(int_to_roman(42)) # Output: \\"XLII\\" ``` Roman Numerals Table | Symbol | Value | | ------ | ----- | | I | 1 | | V | 5 | | X | 10 | | L | 50 | | C | 100 | | D | 500 | | M | 1000 | Constraints * `roman`: The input Roman numeral will be a valid numeral from 1 to 3999. * `num`: The input number will be between 1 and 3999, inclusive. Implementation Notes 1. Use a dictionary for symbolic representation. 2. Handle subtraction cases in Roman numerals (e.g., IV, IX, etc.) appropriately. 3. Ensure accurate integer conversion when symbols represent a smaller value before a larger value. 4. Construct Roman numerals by appending symbols in descending order from the largest value to the smallest. Additional Considerations Students should handle the full range of valid Roman numerals and ensure their implementations can translate back and forth between integers and Roman numerals accurately.","solution":"def roman_to_int(roman: str) -> int: Converts a Roman numeral to an integer. roman_values = {\'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000} total = 0 prev_value = 0 for char in reversed(roman): value = roman_values[char] if value < prev_value: total -= value else: total += value prev_value = value return total def int_to_roman(num: int) -> str: Converts an integer to a Roman numeral. value_map = [ (1000, \'M\'), (900, \'CM\'), (500, \'D\'), (400, \'CD\'), (100, \'C\'), (90, \'XC\'), (50, \'L\'), (40, \'XL\'), (10, \'X\'), (9, \'IX\'), (5, \'V\'), (4, \'IV\'), (1, \'I\') ] roman = \\"\\" for value, symbol in value_map: while num >= value: roman += symbol num -= value return roman"},{"question":"You are required to implement a Breadth-First Search (BFS) algorithm to traverse a graph. Your function should adhere to the constraints and handle common edge cases effectively. # Scenario You are developing a navigation system for a city that needs to find the shortest path between various points. The BFS algorithm should efficiently explore connections to determine the shortest route between any two locations. # Function Signature ```python def bfs(graph: Dict[str, List[str]], start: str, end: str) -> List[str]: pass ``` # Input * `graph`: A dictionary representing the graph where keys are node identifiers (strings) and values are lists of neighboring node identifiers. * `start`: The starting node identifier (string). * `end`: The target node identifier (string). # Output * A list of node identifiers representing the shortest path from the starting node to the target node. If no path exists, return an empty list. # Constraints * The function should traverse the graph using O(N) auxiliary space, where N is the number of nodes. * Clearly handle edge cases such as the start and end nodes being the same or the graph being empty. * Ensure optimal performance in terms of time complexity. # Examples ```python bfs({ \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] }, \'A\', \'F\') # Output: [\'A\', \'C\', \'F\'] bfs({ \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] }, \'A\', \'G\') # Output: [] bfs({}, \'A\', \'B\') # Output: [] ``` # Performance Requirements * The algorithm should be guaranteed to find the shortest path in O(V+E) time complexity, where V is the number of vertices (nodes) and E is the number of edges. # Notes * Consider using a queue to facilitate the BFS traversal. * Maintain a visited set to track the explored nodes and avoid cycles. * Think about how you\'ll reconstruct the path after reaching the end node. Happy coding!","solution":"from collections import deque from typing import Dict, List def bfs(graph: Dict[str, List[str]], start: str, end: str) -> List[str]: Perform BFS on the graph to find the shortest path from start to end. Parameters: graph (Dict[str, List[str]]): The graph represented as adjacency list. start (str): The starting node. end (str): The target node. Returns: List[str]: The shortest path from start to end, or an empty list if no path exists. if start not in graph or end not in graph: return [] queue = deque([[start]]) visited = set([start]) while queue: path = queue.popleft() node = path[-1] if node == end: return path for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) new_path = path + [neighbor] queue.append(new_path) return []"},{"question":"# Network Packet Analyzer Process Description: You are assigned to improve a network packet analyzer tool that processes data packets sent over a network. The goal is to analyze packets to determine the frequency of destination IP addresses. Additionally, ensure the functionality is tested thoroughly. Objectives: 1. Implement the function `analyze_packets` that accepts a list of packets. Each packet is represented as a dictionary containing keys `source_ip`, `destination_ip`, `timestamp`, and `size`. 2. The function should return a dictionary where the keys are destination IP addresses and the values are the counts of how many times each destination IP appears in the packet list. 3. Ensure the function handles cases with missing keys or invalid packet formats by ignoring such packets and processing the rest normally. Function Signature: ```python def analyze_packets(packets: list[dict[str, str | int]]) -> dict[str, int]: pass ``` Constraints: - Each packet dictionary should theoretically contain all valid keys: `source_ip`, `destination_ip`, `timestamp`, and `size`. If any key is missing or invalid, that packet should be ignored. - The input list can be empty, in which case the function should return an empty dictionary. - Handle a large number of packets efficiently. Example: ```python packets = [ {\\"source_ip\\": \\"192.168.1.1\\", \\"destination_ip\\": \\"192.168.1.2\\", \\"timestamp\\": 1610000000, \\"size\\": 500}, {\\"source_ip\\": \\"192.168.1.2\\", \\"destination_ip\\": \\"192.168.1.3\\", \\"timestamp\\": 1610000050, \\"size\\": 1500}, {\\"source_ip\\": \\"192.168.1.1\\", \\"destination_ip\\": \\"192.168.1.2\\", \\"timestamp\\": 1610000100, \\"size\\": 500}, {\\"source_ip\\": \\"192.168.1.3\\", \\"destination_ip\\": \\"192.168.1.2\\", \\"timestamp\\": 1610000150, \\"size\\": 2000}, {\\"source_ip\\": \\"192.168.1.4\\", \\"destination_ip\\": \\"192.168.1.2\\", \\"timestamp\\": 1610000200, \\"size\\": 750}, {\\"source_ip\\": \\"192.168.1.1\\", \\"destination_ip\\": \\"invalid.ip.format\\", \\"timestamp\\": 1610000250, \\"size\\": 500}, # invalid destination_ip format {}, # invalid packet with missing keys ] result = analyze_packets(packets) # Expected result: { # \\"192.168.1.2\\": 4, # \\"192.168.1.3\\": 1 # } ``` # Testing: - Implement unit tests to verify the function’s correctness with valid packets. - Ensure that the function properly ignores packets missing required keys or containing invalid formats.","solution":"def analyze_packets(packets: list[dict[str, str | int]]) -> dict[str, int]: Analyzes a list of network packets and counts the frequency of destination IP addresses. :param packets: List of packet dictionaries where each dict contains keys \'source_ip\', \'destination_ip\', \'timestamp\', and \'size\'. :return: Dictionary mapping destination IPs to their corresponding counts. dest_ip_counts = {} for packet in packets: try: dest_ip = packet[\'destination_ip\'] if isinstance(dest_ip, str): dest_ip_counts[dest_ip] = dest_ip_counts.get(dest_ip, 0) + 1 except KeyError: # Ignore packets with missing keys continue return dest_ip_counts"},{"question":"New Question # Maximum Subarray Sum with No Adjacent Elements **Problem Description**: Given a list of integers, find the maximum sum that can be obtained by summing non-adjacent elements of the list. In other words, no two selected elements should be next to each other in the original list. For example, for the list `[3, 2, 5, 10, 7]`, the maximum sum is obtained by selecting the elements `3`, `10`, and `7`, which sum to `20`. **Your Task**: Write a function named `max_non_adjacent_sum(nums: [int]) -> int` that takes a list of integers `nums` and returns the maximum sum of non-adjacent elements. **Function Signature**: ```python def max_non_adjacent_sum(nums: [int]) -> int: pass ``` **Input**: * `nums` (0 ≤ len(nums) ≤ 10^5, -10^4 ≤ nums[i] ≤ 10^4): A list of integers. **Output**: * Returns an integer representing the maximum sum of non-adjacent elements. **Examples**: ```python max_non_adjacent_sum([3, 2, 5, 10, 7]) # Returns 15 (selecting 3, 5, and 7) max_non_adjacent_sum([-1, -2, 9, -4, 10, -1]) # Returns 19 (selecting 9 and 10) max_non_adjacent_sum([]) # Returns 0 (no elements to select) ``` **Constraints**: * The list `nums` may be empty, in which case the result should be `0`. **Hints**: 1. Use dynamic programming to keep track of the maximum sum up to each index with the constraint of non-adjacency. 2. Define two states: one for including the current element and one for excluding it. 3. Update these states as you iterate through the list.","solution":"def max_non_adjacent_sum(nums): Returns the maximum sum of non-adjacent elements in the list. if not nums: return 0 if len(nums) == 1: return max(0, nums[0]) # Initialize two variables to keep track of including and excluding the current element include = 0 exclude = 0 for num in nums: new_exclude = max(include, exclude) # The new exclude will be the max sum of previous include and exclude include = exclude + num # Include current number, therefore we add num to previous exclude exclude = new_exclude return max(include, exclude) # Example usage print(max_non_adjacent_sum([3, 2, 5, 10, 7])) # Returns 15 print(max_non_adjacent_sum([-1, -2, 9, -4, 10, -1])) # Returns 19 print(max_non_adjacent_sum([])) # Returns 0"},{"question":"# Summation of Digits Raised to Consecutive Powers You\'re tasked with implementing a function that calculates the sum of the digits of a number, each raised to consecutive powers starting from 2. Function Specification 1. **Function name**: `sum_of_digits_power` - **Input**: `number` (int) - the number whose digits are to be processed. - **Output**: (int) - the sum of the digits each raised to consecutive powers starting from 2. - **Constraints**: - `number` should be a non-negative integer. Implementation Details **sum_of_digits_power**: For a given non-negative integer `number`, the function should: 1. Extract each digit from the number. 2. Raise the first digit to the power of 2, the second digit to the power of 3, and so on. 3. Sum the results and return the total. Example *Inputs*: ```python print(sum_of_digits_power(1234)) # Expected output: 1^2 + 2^3 + 3^4 + 4^5 = 1 + 8 + 81 + 1024 = 1114 print(sum_of_digits_power(56)) # Expected output: 5^2 + 6^3 = 25 + 216 = 241 ``` *Outputs*: ```python 1114 241 ``` If the `number` is not valid (negative), the function should raise a `ValueError` with the message \\"Number must be non-negative.\\" Requirements - Implement and thoroughly test the function. - Handle edge cases and invalid inputs appropriately.","solution":"def sum_of_digits_power(number): Calculates the sum of the digits of a number, each raised to consecutive powers starting from 2. Args: number (int): A non-negative integer. Returns: int: Sum of the digits each raised to consecutive powers starting from 2. Raises: ValueError: If the `number` is negative. if number < 0: raise ValueError(\\"Number must be non-negative\\") total_sum = 0 for power, digit in enumerate(str(number), start=2): total_sum += int(digit) ** power return total_sum"},{"question":"# Problem Statement You are developing a tool to assist with analyzing book text data for a library. One of the features you need to implement is the ability to count the frequency of words and the frequency of characters in the text. Write Python functions to accomplish these tasks. # Function Specifications Function 1: `word_frequency(text)` - **Input**: A string `text` which contains sentences. - **Output**: A dictionary where keys are words and values are their frequencies in the text. - **Constraints**: - The input string can be empty. - Words are case insensitive, and punctuation should be ignored. - Words are sequences of alphanumeric characters. Function 2: `char_frequency(text)` - **Input**: A string `text` which contains sentences. - **Output**: A dictionary where keys are characters and values are their frequencies in the text. - **Constraints**: - The input string can be empty. - Characters include all alphanumeric characters and punctuation. # Examples Example 1: Word Frequency ```python >>> word_frequency(\\"Hello, world! Hello.\\") {\'hello\': 2, \'world\': 1} >>> word_frequency(\\"\\") {} >>> word_frequency(\\"Python, python, Python!\\") {\'python\': 3} ``` Example 2: Character Frequency ```python >>> char_frequency(\\"Hello, world!\\") {\'H\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \' \': 1, \',\': 1, \'w\': 1, \'r\': 1, \'d\': 1, \'!\': 1} >>> char_frequency(\\"\\") {} >>> char_frequency(\\"Python123!\\") {\'P\': 1, \'y\': 1, \'t\': 1, \'h\': 1, \'o\': 1, \'n\': 1, \'1\': 1, \'2\': 1, \'3\': 1, \'!\': 1} ``` # Detailed Instructions 1. **Implement `word_frequency` function**: - If the input string is empty, return an empty dictionary. - Convert the text to lower case to ensure case insensitivity. - Use regular expressions to remove punctuation and split the text into words. - Count frequencies of each word and store them in a dictionary. 2. **Implement `char_frequency` function**: - If the input string is empty, return an empty dictionary. - Count frequencies of each character in the text and store them in a dictionary. # Additional Notes - You may use Python\'s built-in libraries and functions to simplify string operations. - Ensure your code handles edge cases effectively, such as multiple spaces and punctuation marks. - Optimize your implementation to handle large text inputs efficiently within the constraints. Good luck and ensure to test your functions thoroughly!","solution":"import re from collections import Counter def word_frequency(text): Returns the frequency of each word in the given text. Words are case insensitive and punctuation is ignored. text = text.lower() words = re.findall(r\'bw+b\', text) return dict(Counter(words)) def char_frequency(text): Returns the frequency of each character in the given text. Characters include all alphanumeric characters and punctuation. return dict(Counter(text))"},{"question":"# Question: Implement an Efficient Top K Frequent Elements Finder Problem Statement You need to implement a function that efficiently finds the top `k` most frequent elements in an array. Your approach should handle cases with both small and very large input lists and should be optimized for time complexity. Function Signature ```python def top_k_frequent(nums: List[int], k: int) -> List[int]: ``` Input * **nums**: A list of integers, both positive and negative. The list can be of length 0 to 10^6. * **k**: A positive integer representing the number of top frequent elements to return (1 ≤ k ≤ number of unique elements in `nums`). Output * Returns a list of `k` integers, representing the top `k` most frequent elements in the input list. Constraints * The input list `nums` can contain both positive and negative integers, including zero. * If two elements have the same frequency, their order can be arbitrary in the output list. Examples ```python >>> top_k_frequent([1,1,1,2,2,3], 2) [1, 2] >>> top_k_frequent([4,4,4,4,5,5,5,6,6,7], 3) [4, 5, 6] >>> top_k_frequent([1,1,1,2,2,3], 1) [1] >>> top_k_frequent([], 0) [] >>> top_k_frequent([-1, -1, -2, -2, -3, -3, -3], 2) [-3, -1, -2] ``` Instructions 1. Utilize appropriate data structures to count the frequency of each element in the list. 2. Implement an efficient way to extract the top `k` frequent elements. 3. Consider both time and space complexity in your approach. 4. Do not use built-in sorting functions for the entirety of the task such as `sorted()` on the whole list of elements. 5. Handle the edge cases where the input list might be empty or `k` equals the number of unique elements in the list. Additional Information * You may use any additional helper functions as needed, but the primary functionality should be in `top_k_frequent` function. * Ensure that your solution is optimized for large inputs and performs effectively across diverse test cases.","solution":"from typing import List from collections import Counter import heapq def top_k_frequent(nums: List[int], k: int) -> List[int]: Return the top k most frequent elements in an array. if not nums: return [] # Step 1: Count frequencies of elements in nums count = Counter(nums) # Step 2: Use a heap to get the top k elements with highest frequency return heapq.nlargest(k, count.keys(), key=count.get)"},{"question":"# Coding Assessment Question Objective Implement a Python function to determine the required number of containers to carry a given quantity of various items, ensuring optimal usage of container space. Problem Statement You are organizing an event where you have to distribute multiple items, each with a given volume, into containers with a fixed capacity. Your task is to determine the minimum number of containers needed to carry all the items. Each container can hold up to its maximum capacity in volume, and items cannot be split between containers. The function should return the total number of containers used. Function Specifications 1. **Function Name**: `min_containers` 2. **Input Parameters**: - `items`: list of floats; Volumes of the items to be distributed. - `container_capacity`: float; The maximum volume capacity of a single container. 3. **Output**: - An integer representing the minimum number of containers needed to carry all the items. - If the provided input values are invalid, raise a `ValueError` with a descriptive message. 4. **Constraints**: - All item volumes and container capacities must be positive, non-zero values. - Items must be placed into containers without splitting. - Efficiency and optimal filling of containers should be considered. ```python def min_containers(items: list[float], container_capacity: float) -> int | ValueError: Input Parameters: ----------------- items: List of item volumes (floats). container_capacity: The maximum volume capacity of a single container (float). Returns: -------- An integer representing the minimum number of containers needed to carry all the items. If the inputs are invalid, raises a ValueError with an appropriate error message. Examples: --------- >>> min_containers([1.5, 2.5, 3.0, 4.0], 5.0) 3 >>> min_containers([1.0, 1.0, 1.0, 1.0], 2.0) 2 >>> min_containers([1.0, 2.0, 3.0], -1.0) ValueError(\'Input Error: All item volumes and container capacities must be positive values.\') pass # Your code here ``` Notes: 1. Ensure the function returns the minimum number of containers required to carry all the items. 2. Proper error handling should be in place to provide informative messages for invalid inputs. 3. The efficiency and readability of your code will be evaluated.","solution":"def min_containers(items, container_capacity): Input Parameters: ----------------- items: List of item volumes (floats). container_capacity: The maximum volume capacity of a single container (float). Returns: -------- An integer representing the minimum number of containers needed to carry all the items. If the inputs are invalid, raises a ValueError with an appropriate error message. if not items or container_capacity <= 0: raise ValueError(\'Input Error: All item volumes and container capacities must be positive values.\') if any(item <= 0 for item in items): raise ValueError(\'Input Error: All item volumes and container capacities must be positive values.\') items = sorted(items, reverse=True) containers = 0 while items: remaining_capacity = container_capacity used_items = [] for i in range(len(items)): if items[i] <= remaining_capacity: remaining_capacity -= items[i] used_items.append(i) if remaining_capacity == 0: break for i in sorted(used_items, reverse=True): items.pop(i) containers += 1 return containers"},{"question":"**Context**: You are provided with a binary search tree (BST) class that supports basic operations such as insertion, deletion, and searching of nodes. However, there is no feature to find the lowest common ancestor (LCA) of two nodes in the tree efficiently. **Objective:** Implement the `find_lca` method in the given `BST` class that finds and returns the lowest common ancestor of two given nodes. The method must handle all standard cases effectively, including when the nodes are not present in the tree or when the tree is empty. **Function Signature:** ```python def find_lca(self, node1: int, node2: int) -> int: Find the lowest common ancestor (LCA) of two given nodes in the BST. Args: node1 (int): The first node\'s value. node2 (int): The second node\'s value. Returns: int: The value of the lowest common ancestor of the two nodes. If either of the nodes is not found, return -1. Examples: >>> bst = BST() >>> bst.insert(20) >>> bst.insert(10) >>> bst.insert(30) >>> bst.insert(5) >>> bst.insert(15) >>> bst.find_lca(5, 15) 10 >>> bst.find_lca(5, 35) -1 ``` **Constraints:** - The method should handle cases where either or both of the nodes do not exist in the tree. - The solution should have O(h) time complexity, where h is the height of the tree. **Examples:** 1. Finding the LCA of two nodes present in the tree: ```python bst = BST() bst.insert(20) bst.insert(10) bst.insert(30) bst.insert(5) bst.insert(15) assert bst.find_lca(5, 15) == 10 ``` 2. Finding the LCA when one node is not present in the tree: ```python bst = BST() bst.insert(20) bst.insert(10) bst.insert(30) bst.insert(5) bst.insert(15) assert bst.find_lca(5, 35) == -1 ``` 3. Finding the LCA in an empty tree: ```python bst = BST() assert bst.find_lca(10, 20) == -1 ``` 4. Finding the LCA when both nodes are the same: ```python bst = BST() bst.insert(20) bst.insert(10) bst.insert(30) bst.insert(5) bst.insert(15) assert bst.find_lca(10, 10) == 10 ``` By maintaining the format, complexity, and scope defined by the original questions, this new question provides a complementary challenge in the domain of binary search trees while introducing a unique scenario requiring the implementation of an LCA-finding method.","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.key: if root.left is None: root.left = Node(key) else: self._insert(root.left, key) else: if root.right is None: root.right = Node(key) else: self._insert(root.right, key) def find_lca(self, node1, node2): return self._find_lca(self.root, node1, node2) def _find_lca(self, root, node1, node2): if root is None: return -1 if root.key > node1 and root.key > node2: return self._find_lca(root.left, node1, node2) if root.key < node1 and root.key < node2: return self._find_lca(root.right, node1, node2) if self._find(root, node1) and self._find(root, node2): return root.key return -1 def _find(self, root, key): if root is None: return False if root.key == key: return True elif key < root.key: return self._find(root.left, key) else: return self._find(root.right, key)"},{"question":"# Problem Statement You are given a list of strings which may contain duplicate strings. Your task is to implement a function `find_most_frequent_string` that finds the string which appears the most frequently in the list. If there are ties, return the lexicographically smallest string among those that appear the most frequently. Additionally, your function should handle edge cases efficiently, such as an empty list or a list where all strings are unique. ```python def find_most_frequent_string(strings: List[str]) -> str: pass ``` **Input:** * `strings`: A list of strings (0 <= len(strings) <= 10^5). **Output:** * A string that appears the most frequently in the list. If there are ties, return the lexicographically smallest string among those tied. **Constraints:** - The strings in the list consist of lowercase alphabets and spaces. **Performance Requirements:** - Your implementation should run in O(n log n) time where `n` is the number of strings in the list. - Use O(n) additional space. **Example:** ```python assert find_most_frequent_string([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"]) == \\"apple\\" assert find_most_frequent_string([\\"apple\\", \\"banana\\", \\"orange\\"]) == \\"apple\\" assert find_most_frequent_string([]) == \\"\\" assert find_most_frequent_string([\\"banana\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"orange\\"]) == \\"banana\\" assert find_most_frequent_string([\\"apple\\", \\"apple\\", \\"banana\\", \\"banana\\", \\"cherry\\"]) == \\"apple\\" ``` **Explanation**: The function counts the frequency of each string in the list. In case of a tie, it returns the lexicographically smallest string. Edge cases such as an empty list or a list where all strings appear only once are handled appropriately by returning an empty string or the smallest string lexicographically, respectively.","solution":"from typing import List from collections import Counter def find_most_frequent_string(strings: List[str]) -> str: if not strings: return \\"\\" frequency = Counter(strings) max_frequency = max(frequency.values()) most_frequent_strings = [s for s in frequency if frequency[s] == max_frequency] return min(most_frequent_strings)"},{"question":"# Problem Statement: You are required to build a function that reads a CSV file containing students\' scores, processes the data to calculate the average score for each subject, and writes the results to a new CSV file. The function should handle various edge cases, including non-existent files and empty or malformed data. # Function Signature: ```python def calculate_average_scores(input_filename: str, output_filename: str) -> None: Reads student scores from a CSV file, calculates the average score for each subject, and writes the results to a new CSV file. Parameters: input_filename (str): The name of the input CSV file containing student scores. output_filename (str): The name of the output CSV file where average scores will be saved. Raises: FileNotFoundError: If the input file does not exist. ValueError: If the input file is empty or contains malformed data. IOError: If there is an error while reading from or writing to the files. ``` # Input: - `input_filename`: A string representing the name of the input CSV file. - `output_filename`: A string representing the name of the output CSV file where average scores will be saved. # Output: - None (The result should be written to the `output_filename` CSV file). # Example Invocation: ```python # Calculate average scores from \'student_scores.csv\' and write to \'average_scores.csv\' calculate_average_scores(\'student_scores.csv\', \'average_scores.csv\') ``` # CSV File Format: Input CSV: ``` Name,Math,Science,English Alice,80,90,70 Bob,85,85,80 Charlie,90,95,85 ``` Output CSV: ``` Subject,Average Math,85.0 Science,90.0 English,78.3 ``` # Constraints: 1. **File Handling**: The function should raise a `FileNotFoundError` if the input file does not exist and a `ValueError` if the file is empty or contains malformed data. 2. **Data Processing**: Handle cases where the scores are missing or not integers, and normalize the results accordingly. 3. **Performance**: Optimize the code to handle large datasets efficiently. 4. **Output Formatting**: Ensure the output CSV is well-formatted with two columns: `Subject` and `Average`. # Notes: * The function should be robust enough to handle files with different delimiters and missing scores. * Include error handling to manage various potential issues with reading and writing files. * Document each step and include comments to explain your logic and error handling strategies.","solution":"import csv import os def calculate_average_scores(input_filename: str, output_filename: str) -> None: Reads student scores from a CSV file, calculates the average score for each subject, and writes the results to a new CSV file. Parameters: input_filename (str): The name of the input CSV file containing student scores. output_filename (str): The name of the output CSV file where average scores will be saved. Raises: FileNotFoundError: If the input file does not exist. ValueError: If the input file is empty or contains malformed data. IOError: If there is an error while reading from or writing to the files. if not os.path.isfile(input_filename): raise FileNotFoundError(f\\"The file {input_filename} does not exist.\\") with open(input_filename, newline=\'\', mode=\'r\') as infile: reader = csv.DictReader(infile) if not reader.fieldnames: raise ValueError(\\"The input file is empty or malformed.\\") if not all(field in reader.fieldnames for field in [\\"Name\\"] + reader.fieldnames[1:]): raise ValueError(\\"Malformed CSV: Missing expected columns.\\") subject_totals = {} subject_counts = {} for row in reader: for subject, score in row.items(): if subject == \\"Name\\": continue if score.strip() == \'\': continue try: score = float(score) except ValueError: raise ValueError(f\\"Malformed data: Cannot convert {score} to float.\\") if subject in subject_totals: subject_totals[subject] += score subject_counts[subject] += 1 else: subject_totals[subject] = score subject_counts[subject] = 1 if not subject_totals: raise ValueError(\\"The input file contains no valid scores.\\") with open(output_filename, newline=\'\', mode=\'w\') as outfile: writer = csv.writer(outfile) writer.writerow([\\"Subject\\", \\"Average\\"]) for subject in subject_totals: average_score = subject_totals[subject] / subject_counts[subject] writer.writerow([subject, round(average_score, 1)])"},{"question":"# Coding Problem: Unique Anagram Checker # Objective Write a function that checks if two given input strings are anagrams of each other. An anagram is a word formed by rearranging the letters of another word, using all the original letters exactly once. Your solution should ignore spaces and be case-insensitive. # Function Signature ```python def are_anagrams(str1: str, str2: str) -> bool: ... ``` # Input * Two strings, `str1` and `str2`, which contain ASCII characters. # Output * A single boolean value: * `True` if `str1` and `str2` are anagrams of each other. * `False` otherwise. # Constraints * The length of each input string ( 0 leq len(str1), len(str2) leq 10^5 ) # Example 1. Input: `\\"Listen\\"`, `\\"Silent\\"` Output: `True` 2. Input: `\\"Dormitory\\"`, `\\"Dirty room\\"` Output: `True` 3. Input: `\\"Hello\\"`, `\\"Olelh\\"` Output: `True` 4. Input: `\\"Programming\\"`, `\\"Gram Ring Mop\\"` Output: `True` 5. Input: `\\"Hello world\\"`, `\\"World Hello\\"` Output: `True` 6. Input: `\\"Hello\\"`, `\\"World\\"` Output: `False` # Performance Requirements * Ensure that your solution runs in linear time and makes optimal use of space. # Notes * Your solution must handle mixed case inputs and ignore any spaces in the strings.","solution":"def are_anagrams(str1: str, str2: str) -> bool: Checks if str1 and str2 are anagrams of each other, ignoring spaces and case sensitivity. # Remove spaces and convert to lowercase str1_processed = \'\'.join(str1.split()).lower() str2_processed = \'\'.join(str2.split()).lower() # If the lengths differ, they cannot be anagrams if len(str1_processed) != len(str2_processed): return False # Compare sorted versions of the strings return sorted(str1_processed) == sorted(str2_processed)"},{"question":"# Coding Assessment Question Context and Scenario: As part of a social media platform\'s backend system, you are responsible for managing user comments on posts. Each comment has a unique identifier and a timestamp. The comments are stored in an array sorted by their timestamps in ascending order. Your task is to develop efficient functions to insert comments and retrieve comments within a specific time range. Task: 1. **Function 1: Insert Comment** Write a function `insert_comment(comments, comment)` that inserts a new `comment` into the sorted `comments` list while maintaining the order based on the timestamp. Each comment is represented as a dictionary with `id`, `content`, and `timestamp`. ```python def insert_comment(comments: list[dict], comment: dict) -> None: Insert a new comment into the sorted list of comments while maintaining order by timestamp. :param comments: A list of comment dictionaries sorted by timestamp. :param comment: A dictionary with keys \'id\', \'content\', and \'timestamp\'. pass ``` **Example:** ```python comments = [ {\'id\': 1, \'content\': \'Great post!\', \'timestamp\': 1618300800}, {\'id\': 2, \'content\': \'I agree!\', \'timestamp\': 1618300900} ] new_comment = {\'id\': 3, \'content\': \'Nice article.\', \'timestamp\': 1618300850} insert_comment(comments, new_comment) print(comments) # Output: [{\'id\': 1, \'content\': \'Great post!\', \'timestamp\': 1618300800}, # {\'id\': 3, \'content\': \'Nice article.\', \'timestamp\': 1618300850}, # {\'id\': 2, \'content\': \'I agree!\', \'timestamp\': 1618300900}] ``` 2. **Function 2: Retrieve Comments by Time Range** Write a function `retrieve_comments_in_range(comments, start_time, end_time)` that retrieves all comments within a given time range `[start_time, end_time]`. The comments should be returned as a list sorted by their timestamps. ```python def retrieve_comments_in_range(comments: list[dict], start_time: int, end_time: int) -> list[dict]: Retrieve all comments within the specified time range, inclusive of the boundaries. :param comments: A list of comment dictionaries sorted by timestamp. :param start_time: The starting timestamp of the range. :param end_time: The ending timestamp of the range. :return: A list of comments within the specified time range. pass ``` **Example:** ```python comments = [ {\'id\': 1, \'content\': \'Great post!\', \'timestamp\': 1618300800}, {\'id\': 2, \'content\': \'I agree!\', \'timestamp\': 1618300900}, {\'id\': 3, \'content\': \'Nice article.\', \'timestamp\': 1618300850} ] filtered_comments = retrieve_comments_in_range(comments, 1618300800, 1618300850) print(filtered_comments) # Output: [{\'id\': 1, \'content\': \'Great post!\', \'timestamp\': 1618300800}, # {\'id\': 3, \'content\': \'Nice article.\', \'timestamp\': 1618300850}] ``` Constraints: - Each comment dictionary will contain the keys \'id\' (int), \'content\' (str), and \'timestamp\' (int). - Your functions should ensure the `comments` list remains sorted by timestamp after insertion. - Handle edge cases such as an empty comments list, single-comment list, and time ranges with no matching comments. - You are not allowed to use built-in sorting functions for the insertion; you should maintain the sorted order during insertion manually. Performance Requirements: - Your solution should handle up to ( 10^5 ) comments efficiently. - Ensure that the insertion and retrieval operations have time complexities appropriate for handling large data sets.","solution":"def insert_comment(comments, comment): Insert a new comment into the sorted list of comments while maintaining order by timestamp. :param comments: A list of comment dictionaries sorted by timestamp. :param comment: A dictionary with keys \'id\', \'content\', and \'timestamp\'. left, right = 0, len(comments) while left < right: mid = (left + right) // 2 if comments[mid][\'timestamp\'] < comment[\'timestamp\']: left = mid + 1 else: right = mid comments.insert(left, comment) def retrieve_comments_in_range(comments, start_time, end_time): Retrieve all comments within the specified time range, inclusive of the boundaries. :param comments: A list of comment dictionaries sorted by timestamp. :param start_time: The starting timestamp of the range. :param end_time: The ending timestamp of the range. :return: A list of comments within the specified time range. filtered_comments = [] for comment in comments: if start_time <= comment[\'timestamp\'] <= end_time: filtered_comments.append(comment) return filtered_comments"},{"question":"# Question: Find the First Unique Character in a String You are tasked with finding the first non-repeating character in a given string. If there isn\'t any non-repeating character, return an underscore (\'_\'). **Function Signature**: `def first_unique_char(s: str) -> str:` **Input**: - A string `s` consisting of lowercase English letters (1 <= len(s) <= 10^5). **Output**: - Return a single character which is the first non-repeating character in the string, or underscore (\'_\') if there is no non-repeating character. **Constraints**: - Optimize for time complexity to handle large input sizes efficiently. - Handle cases where all characters repeat or where the string is entirely unique. **Example**: ```python assert first_unique_char(\\"leetcode\\") == \'l\' assert first_unique_char(\\"loveleetcode\\") == \'v\' assert first_unique_char(\\"aabbcc\\") == \'_\' assert first_unique_char(\\"z\\") == \'z\' ``` **Notes**: 1. Consider using a data structure that allows for efficient counting and indexing. 2. Your solution should be designed to handle the full range of valid input sizes within the given constraints. 3. Ensure the function works correctly for strings with repeated and non-repeated characters. Implement your solution in the following function definition: ```python def first_unique_char(s: str) -> str: # Your code here ```","solution":"def first_unique_char(s: str) -> str: from collections import Counter # Count the occurrences of each character char_count = Counter(s) # Iterate over the string to find the first unique character for char in s: if char_count[char] == 1: return char # If no unique character is found, return an underscore return \'_\'"},{"question":"# Coding Assessment Question Write a function `rotate_matrix_90_clockwise(matrix: List[List[int]]) -> List[List[int]]` that takes a square matrix (2D list) as input and rotates it 90 degrees clockwise. # Input - `matrix` (List[List[int]]): A square matrix (nxn) consisting of integers. (1 ≤ n ≤ 500) # Output - Return the rotated matrix as a list of lists. # Constraints: - Ensure the solution is efficient in both time and space complexity. - Do not use any in-built functions that directly perform the rotation. # Example: ```python def rotate_matrix_90_clockwise(matrix: List[List[int]]) -> List[List[int]]: pass # Implement the function here # Example 1 matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(rotate_matrix_90_clockwise(matrix1)) # Output: [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] # Example 2 matrix2 = [ [1, 2], [3, 4] ] print(rotate_matrix_90_clockwise(matrix2)) # Output: [ # [3, 1], # [4, 2] # ] ``` Rotate the matrix by moving the elements layer by layer from the outermost layer to the innermost layer. Ensure thorough testing with various matrix sizes and edge cases.","solution":"from typing import List def rotate_matrix_90_clockwise(matrix: List[List[int]]) -> List[List[int]]: n = len(matrix) # Create a new matrix of the same size rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n - i - 1] = matrix[i][j] return rotated_matrix"},{"question":"# Question: Validate MAC Address You are tasked with writing a Python function `is_valid_mac_address(address: str) -> bool` that checks if the provided string is a valid MAC (Media Access Control) address. The function should return `True` if the input is a valid MAC address and `False` otherwise. Requirements: 1. **Input Type Validation**: - The function should raise a `ValueError` if the input is not a string. 2. **General Format Check**: - A valid MAC address contains 12 hexadecimal digits, which are divided into 6 groups of 2 digits, separated by either colons (`:`) or hyphens (`-`). - Example formats: `00:1A:2B:3C:4D:5E`, `00-1A-2B-3C-4D-5E`. 3. **Hexadecimal Digits Check**: - Each group should contain exactly 2 valid hexadecimal digits. Function Signature: ```python def is_valid_mac_address(address: str) -> bool: ``` Input: - `address (str)`: The string potentially representing a MAC address. Output: - Returns `True` if the `address` is a valid MAC address, else `False`. Examples: ```python >>> is_valid_mac_address(\\"00:1A:2B:3C:4D:5E\\") True >>> is_valid_mac_address(\\"00-1A-2B-3C-4D-5E\\") True >>> is_valid_mac_address(\\"001A:2B:3C:4D:5E\\") False >>> is_valid_mac_address(\\"00:1A:2B:3C:4D:5G\\") False >>> is_valid_mac_address(\\"00:1A:2B:3C:4D\\") False ``` Notes: - Ensure your solution accurately handles different valid formats of MAC addresses and properly identifies invalid formats due to incorrect separators, length, or invalid hexadecimal digits.","solution":"import re def is_valid_mac_address(address: str) -> bool: Check if the provided string is a valid MAC address. if not isinstance(address, str): raise ValueError(\\"Input must be a string\\") pattern = re.compile(r\'^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})\') return bool(pattern.match(address))"},{"question":"Problem Statement A matrix is a rectangular array of numbers arranged in rows and columns. One common operation on matrices is transposition, which involves swapping the matrix\'s rows and columns. # Task Write a Python function `transpose_matrix(matrix: List[List[int]]) -> List[List[int]]` that: - Takes a 2D list of integers, `matrix`, representing an `m x n` matrix. - Returns the transpose of the matrix, which is an `n x m` matrix. # Function Signature ```python from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: ``` # Input - `matrix`: A 2D list of integers where each sub-list represents a row in an `m x n` matrix. # Output - A 2D list of integers representing the transpose of the input matrix. # Constraints - The matrix can be empty (i.e., `matrix = []`). - The matrix can contain varying numbers of columns and rows, but all rows must have the same length. - The values in the matrix are within the range of valid 32-bit integers. # Examples ```python >>> transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> transpose_matrix([[1,2], [3,4], [5,6]]) [[1, 3, 5], [2, 4, 6]] >>> transpose_matrix([[]]) [[]] >>> transpose_matrix([]) [] ``` # Performance Requirements - The solution should be efficient in terms of both time and space. - Aim for an approach that directly converts the input `m x n` matrix to an `n x m` matrix with a time complexity of O(m * n) and a space complexity of O(m * n). # Hint - You may find it useful to iterate over the range of columns, forming new rows for the transposed matrix.","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: if not matrix or not matrix[0]: return matrix rows = len(matrix) cols = len(matrix[0]) transposed = [] for c in range(cols): new_row = [] for r in range(rows): new_row.append(matrix[r][c]) transposed.append(new_row) return transposed"},{"question":"# Coding Assessment Question Scenario You are tasked with developing a feature for an e-commerce platform that involves processing users\' browsing histories to generate personalized recommendations. An important step in this process is to analyze clickstream data to determine the longest sequence of consecutive days a user has been active on the platform. Task Write a function named `longest_consecutive_days` that takes two arguments: 1. A list `dates` representing the days a user has logged into the platform. Each date is in the format `\\"YYYY-MM-DD\\"`. 2. A string `user_id` which serves as an identifier in the input log data. The function should return an integer representing the length of the longest consecutive sequence of days during which the user was active. Input * `dates`: A list of strings where each string is a date in the \\"YYYY-MM-DD\\" format. * `user_id`: A string serving as a user\'s unique identifier. Output * An integer representing the length of the longest consecutive sequence of days the user was active. Constraints * The `dates` list contains no duplicate dates. * You may assume all dates are valid and in the correct format. Function Signature ```python def longest_consecutive_days(dates: List[str], user_id: str) -> int: ``` # Example ```python assert longest_consecutive_days([\\"2023-01-01\\", \\"2023-01-02\\", \\"2023-01-04\\", \\"2023-01-05\\", \\"2023-01-06\\"], \\"user_123\\") == 3 assert longest_consecutive_days([\\"2023-03-01\\", \\"2023-03-02\\", \\"2023-03-04\\", \\"2023-03-05\\", \\"2023-03-06\\", \\"2023-03-08\\"], \\"user_456\\") == 3 assert longest_consecutive_days([], \\"user_789\\") == 0 ``` Explanation - In the first example, the dates \\"2023-01-01\\" and \\"2023-01-02\\" are consecutive, and the sequence \\"2023-01-04\\", \\"2023-01-05\\", \\"2023-01-06\\" is also consecutive, making the longest sequence 3 days. - In the second example, the dates \\"2023-03-01\\" and \\"2023-03-02\\" are consecutive, and the sequence \\"2023-03-04\\", \\"2023-03-05\\", \\"2023-03-06\\" is also consecutive, also making the longest sequence 3 days. - In the third example, since there are no dates, the longest sequence is obviously 0. Notes - You should ensure that the function handles large input efficiently. - Consider edge cases such as empty inputs and non-consecutive dates.","solution":"from typing import List from datetime import datetime, timedelta def longest_consecutive_days(dates: List[str], user_id: str) -> int: if not dates: return 0 # Convert string dates to datetime objects date_objects = sorted(datetime.strptime(date, \\"%Y-%m-%d\\") for date in dates) max_streak = 0 current_streak = 1 for i in range(1, len(date_objects)): if date_objects[i] - date_objects[i-1] == timedelta(days=1): current_streak += 1 else: max_streak = max(max_streak, current_streak) current_streak = 1 max_streak = max(max_streak, current_streak) return max_streak"},{"question":"# Implementing a Custom Sorting Algorithm for Complex Data Structures Context In a company’s internal system, various records need to be sorted in a specific order based on multiple criteria. You have been asked to implement a custom sorting algorithm that can handle complex data structures efficiently. The sorting needs to consider both numerical and alphabetical fields in the records. Problem Statement Implement a function `custom_sort` which takes a list of dictionaries. Each dictionary represents a record and contains three keys: \'id\', \'name\', and \'value\'. The function should return the list sorted primarily by \'value\' in descending order. If two records have the same \'value\', sort them by \'name\' in ascending alphabetical order. If the \'name\' is also the same, use \'id\' to sort in ascending numerical order. Requirements 1. **Input and Output Formats**: - Input for `custom_sort`: A list of dictionaries, each containing \'id\' (integer), \'name\' (string), and \'value\' (float). - Output for `custom_sort`: The input list sorted according to the specified criteria. 2. **Constraints**: - The list will contain between 1 and 10^5 records. - \'id\' is a unique integer. - \'name\' is a non-empty string consisting of printable ASCII characters. - \'value\' is a floating point number which can be positive or negative. 3. **Performance**: - Ensure the implementation handles large input sizes efficiently within the given constraints. Example ```python def custom_sort(records: list) -> list: # Implement this function pass # Example usage: records = [ {\\"id\\": 3, \\"name\\": \\"Alice\\", \\"value\\": 10.5}, {\\"id\\": 1, \\"name\\": \\"Bob\\", \\"value\\": 7.8}, {\\"id\\": 2, \\"name\\": \\"Alice\\", \\"value\\": 10.5}, {\\"id\\": 4, \\"name\\": \\"David\\", \\"value\\": 7.8} ] sorted_records = custom_sort(records) # Expected output: # [ # {\\"id\\": 2, \\"name\\": \\"Alice\\", \\"value\\": 10.5}, # {\\"id\\": 3, \\"name\\": \\"Alice\\", \\"value\\": 10.5}, # {\\"id\\": 1, \\"name\\": \\"Bob\\", \\"value\\": 7.8}, # {\\"id\\": 4, \\"name\\": \\"David\\", \\"value\\": 7.8} # ] ``` Notes - Pay attention to edge cases such as lists with only one record, all records having the same \'value\', \'name\' or \'id\'. - Optimize for both time and space complexity, ensuring the solution works efficiently for the upper constraint limits. - Use Python’s built-in sorting functionalities to achieve the desired order if necessary.","solution":"def custom_sort(records): Sorts a list of records based on \'value\' (descending), \'name\' (ascending), and \'id\' (ascending). return sorted(records, key=lambda x: (-x[\'value\'], x[\'name\'], x[\'id\']))"},{"question":"# Question: You are tasked with implementing a function that reads a CSV (Comma-Separated Values) file containing user data and returns a list of dictionaries, where each dictionary represents a user. Your function should follow these steps: 1. Open the specified CSV file. 2. Read the file line by line, where the first line contains the column headers. 3. For each subsequent line, create a dictionary where the keys are the column headers, and the values are the corresponding data from the line. 4. Append each dictionary to a list. Your function should handle possible errors such as file not found, incorrect file format, and I/O errors gracefully. Specifications: * **Function Name**: `read_user_data` * **Inputs**: - `file_path`: A string representing the path to the CSV file. * **Outputs**: - A list of dictionaries, each representing a user. * **Constraints**: - Assume all necessary libraries are available for file and CSV handling. - The CSV file should follow a format where the first line contains the header. - If the CSV file is empty or does not exist, the function should return an empty list. - The function should have proper error handling for file-related operations. Example: ```python file_path = \\"user_data.csv\\" print(read_user_data(file_path)) # Possible output: [{\\"name\\": \\"John Doe\\", \\"email\\": \\"john.doe@example.com\\"}, {\\"name\\": \\"Jane Smith\\", \\"email\\": \\"jane.smith@example.com\\"}] # or an empty list if the CSV file is empty or does not exist. ``` **Note**: Do not use any global variables. Ensure your function is self-contained and does not depend on side effects.","solution":"import csv def read_user_data(file_path): Reads a CSV file and returns a list of dictionaries representing user data. Parameters: file_path (str): The path to the CSV file. Returns: list: A list of dictionaries containing the user data. user_data = [] try: with open(file_path, mode=\'r\', encoding=\'utf-8\') as csvfile: reader = csv.DictReader(csvfile) for row in reader: user_data.append(row) except FileNotFoundError: print(f\\"File not found: {file_path}\\") except IOError: print(f\\"Error reading file: {file_path}\\") except Exception as e: print(f\\"An error occurred: {str(e)}\\") return user_data"},{"question":"# Context You are required to help with data analysis for a sports event. One component of this involves working with timestamps and calculating specific metrics based on event logs. Each event is recorded with a timestamp (in seconds) and a type. One crucial metric needed is the maximum duration of continuous events of a given type. # Task Write a function `max_continuous_event_duration` that accepts a list of event logs and a specific event type, and returns the maximum duration of continuous occurrences of that event type. # Input - A list of tuples where each tuple contains an integer timestamp (in seconds) and a string representing the event type (e.g., `[(10, \'start\'), (12, \'goal\'), (15, \'goal\'), (18, \'end\')]`). - A string representing the event type to analyze (`e.g., \'goal\'`). # Output - An integer representing the maximum duration (in seconds) of continuous occurrences of the specified event type. # Example ```python event_logs = [ (5, \'start\'), (10, \'goal\'), (12, \'goal\'), (14, \'end\'), (20, \'start\'), (25, \'goal\'), (28, \'goal\'), (30, \'goal\') ] max_continuous_event_duration(event_logs, \'goal\') ``` Expected Output: ``` 5 ``` # Constraints - Event logs are sorted in ascending order of timestamps. - Each event type string is non-empty and has a maximum length of 10 characters. - Timestamps are positive integers and unique within the list. - The number of events does not exceed 10000. # Performance Requirements - The solution should efficiently handle up to 10000 event logs. - Optimize the time complexity to avoid excessive calculations.","solution":"def max_continuous_event_duration(event_logs, event_type): max_duration = 0 current_start = None for i in range(len(event_logs)): if event_logs[i][1] == event_type: if current_start is None: current_start = event_logs[i][0] else: if current_start is not None: duration = event_logs[i-1][0] - current_start if duration > max_duration: max_duration = duration current_start = None # Check if the last events in the list were of the given type if current_start is not None: duration = event_logs[-1][0] - current_start if duration > max_duration: max_duration = duration return max_duration"},{"question":"# Coding Assessment Question **Context**: You have been given a data analysis task involving a list of transactions. Each transaction consists of an ID, a product name, and a cost. You need to aggregate the data to determine the total cost for each product sold. Your task is to write a function that takes this list and returns a summary of the total cost for each product. **Task**: Write a function `calculate_total_sales(transactions: List[Tuple[str, str, float]]) -> Dict[str, float]` that: 1. Receives a list of transactions where each transaction is represented as a tuple `(id, product_name, cost)`. 2. Returns a dictionary with product names as keys and the total cost for each product as values. **Input**: - A list of tuples where each tuple contains: - `id`: A string representing the transaction ID. - `product_name`: A string representing the name of the product. - `cost`: A float representing the cost of the product in that transaction. **Output**: - A dictionary with product names as keys and their total costs as values. **Constraints**: - The input list can contain up to 100,000 transactions. - Each transaction ID is unique. - Costs will be positive floats with up to two decimal places. **Example**: ```python transactions = [ (\\"T1\\", \\"ProductA\\", 9.99), (\\"T2\\", \\"ProductB\\", 5.49), (\\"T3\\", \\"ProductA\\", 12.99), (\\"T4\\", \\"ProductC\\", 7.99), (\\"T5\\", \\"ProductB\\", 3.49) ] print(calculate_total_sales(transactions)) # Output: {\'ProductA\': 22.98, \'ProductB\': 8.98, \'ProductC\': 7.99} ``` **Function Signature**: ```python from typing import List, Tuple, Dict def calculate_total_sales(transactions: List[Tuple[str, str, float]]) -> Dict[str, float]: pass ``` Ensure that your solution efficiently aggregates the data, given the constraints.","solution":"from typing import List, Tuple, Dict def calculate_total_sales(transactions: List[Tuple[str, str, float]]) -> Dict[str, float]: product_sales = {} for transaction_id, product_name, cost in transactions: if product_name in product_sales: product_sales[product_name] += cost else: product_sales[product_name] = cost return product_sales"},{"question":"# Inventory Management System Scenario: You are tasked with developing part of an inventory management system for a retail company. One feature required is to track and update inventory levels as items are added or removed during sales and restocking operations. # Task Write a Python class that simulates an inventory management system. This class should be able to add items to the inventory, remove items, and check the current stock level of any item. It should handle edge cases and validate input parameters effectively. Class Signature ```python class InventoryManagementSystem: def __init__(self): pass def add_item(self, item_name: str, quantity: int) -> None: pass def remove_item(self, item_name: str, quantity: int) -> None: pass def check_stock(self, item_name: str) -> int: pass ``` Methods 1. **`__init__`** - Initializes an empty inventory. 2. **`add_item(item_name: str, quantity: int) -> None`** - Adds the specified quantity of the item to the inventory. - If the item already exists, increment its quantity. - Raises appropriate exceptions for invalid input. 3. **`remove_item(item_name: str, quantity: int) -> None`** - Removes the specified quantity of the item from the inventory. - If the item does not exist, raise an exception. - If the removal quantity is greater than available stock, raise an exception. - Raises appropriate exceptions for invalid input. 4. **`check_stock(item_name: str) -> int`** - Returns the current stock level of the given item. - If the item does not exist, return 0. Constraints * `item_name` must be a non-empty string. * `quantity` must be a positive integer. Examples ```python >>> ims = InventoryManagementSystem() >>> ims.add_item(\\"Apples\\", 10) >>> ims.check_stock(\\"Apples\\") 10 >>> ims.add_item(\\"Apples\\", 5) >>> ims.check_stock(\\"Apples\\") 15 >>> ims.remove_item(\\"Apples\\", 3) >>> ims.check_stock(\\"Apples\\") 12 >>> ims.remove_item(\\"Bananas\\", 5) Exception: Item not found in inventory >>> ims.remove_item(\\"Apples\\", 20) Exception: Cannot remove more than available stock >>> ims.check_stock(\\"Bananas\\") 0 >>> ims.add_item(\\"Bananas\\", 0) Exception: Quantity must be a positive integer >>> ims.remove_item(\\"Apples\\", -3) Exception: Quantity must be a positive integer ``` Validation and Error Handling Your class methods should raise appropriate exceptions for the following conditions: * If `item_name` is an empty string, raise `Exception: Item name must be a non-empty string` * If `quantity` is less than or equal to 0 (for both adding and removing), raise `Exception: Quantity must be a positive integer` * If attempting to remove more than the available stock, raise `Exception: Cannot remove more than available stock` * If attempting to remove an item not present in the inventory, raise `Exception: Item not found in inventory`","solution":"class InventoryManagementSystem: def __init__(self): # Initializes an empty inventory as a dictionary self.inventory = {} def add_item(self, item_name: str, quantity: int) -> None: # Validation for item_name and quantity if not item_name: raise ValueError(\\"Item name must be a non-empty string\\") if quantity <= 0: raise ValueError(\\"Quantity must be a positive integer\\") # Add the item to the inventory if item_name in self.inventory: self.inventory[item_name] += quantity else: self.inventory[item_name] = quantity def remove_item(self, item_name: str, quantity: int) -> None: # Validation for item_name and quantity if not item_name: raise ValueError(\\"Item name must be a non-empty string\\") if quantity <= 0: raise ValueError(\\"Quantity must be a positive integer\\") # Check if item exists in the inventory if item_name not in self.inventory: raise ValueError(\\"Item not found in inventory\\") # Check if there are enough items to remove if self.inventory[item_name] < quantity: raise ValueError(\\"Cannot remove more than available stock\\") # Remove the item(s) from the inventory self.inventory[item_name] -= quantity # Remove the item from the inventory if the quantity becomes zero if self.inventory[item_name] == 0: del self.inventory[item_name] def check_stock(self, item_name: str) -> int: # Validation for item_name if not item_name: raise ValueError(\\"Item name must be a non-empty string\\") # Return the stock level of the item, or 0 if item not present return self.inventory.get(item_name, 0)"},{"question":"# Rotating a Square Matrix by 90 Degrees You have been given a function to rotate a square matrix (N x N) by 90 degrees clockwise. However, the current implementation is not very efficient. Your task is to optimize and refactor the given function to achieve better performance and readability. **Task Description**: * Write a Python function named `rotate_matrix_optimized` that takes a square matrix and rotates it by 90 degrees clockwise. **Function Signature**: ```python def rotate_matrix_optimized(matrix: list[list[int]]) -> list[list[int]]: pass ``` **Input**: * `matrix` (list[list[int]]): A square matrix of integers (N x N) where N is the number of rows and columns. **Output**: * Returns a 2D list of integers representing the rotated matrix. **Exceptions**: * If the input is not a list of lists of integers, raise a `TypeError` with the message \\"The input should be a list of lists of integers\\". * If the matrix is not square, i.e., if rows and columns are not equal, raise a `ValueError` with the message \\"The input matrix must be square (NxN)\\". **Performance Requirements**: * The function should handle large inputs efficiently by minimizing redundant calculations and leveraging in-place swaps where possible. **Example**: ```python # Rotates a 3x3 matrix by 90 degrees clockwise matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(rotate_matrix_optimized(matrix)) # Output should be: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] # Error cases print(rotate_matrix_optimized([[1,2,3], [4,5,6]])) # Output: ValueError: The input matrix must be square (NxN) print(rotate_matrix_optimized(\\"not a matrix\\")) # Output: TypeError: The input should be a list of lists of integers ``` Remember to include test cases to verify the correctness and efficiency of your implementation.","solution":"def rotate_matrix_optimized(matrix: list[list[int]]) -> list[list[int]]: Rotates a square matrix by 90 degrees clockwise. # Check if the input is a list of lists of integers if not all(isinstance(row, list) and all(isinstance(x, int) for x in row) for row in matrix): raise TypeError(\\"The input should be a list of lists of integers\\") # Check if the matrix is square (NxN) n = len(matrix) if any(len(row) != n for row in matrix): raise ValueError(\\"The input matrix must be square (NxN)\\") # Rotate the matrix by 90 degrees clockwise rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n - 1 - i] = matrix[i][j] return rotated_matrix"},{"question":"# Problem Statement You are tasked with implementing a function for managing intervals and optimizing various operations. The challenge involves implementing a system to manage intervals, which may overlap, and perform efficient operations on them. # Requirements 1. Implement a class `IntervalManager` that initializes with no intervals. 2. Implement a method `add_interval(start, end)` that adds a new interval [start, end] to the system. Assume that intervals are inclusive of their end points. 3. Implement a method `merge_intervals()` that merges all overlapping intervals in the current interval list and returns the list of merged intervals sorted by the starting point. 4. Implement a method `query_point(point)` that returns `True` if the point falls within any of the current intervals and `False` otherwise. 5. Enhance the `add_interval` method to automatically merge overlapping intervals upon addition. # Provided Code You need to implement the `IntervalManager` class as specified and include the methods. # Function Signatures ```python class IntervalManager: def __init__(self): pass def add_interval(self, start: int, end: int) -> None: pass def merge_intervals(self) -> List[Tuple[int, int]]: pass def query_point(self, point: int) -> bool: pass ``` # Input and Output Formats * **add_interval**: - **Input**: Two integers, `start` and `end`, representing the interval. - **Output**: No output but modifies the internal list of intervals. * **merge_intervals**: - **Input**: No additional input. - **Output**: A list of tuples representing the merged intervals sorted by the starting point. * **query_point**: - **Input**: An integer `point`. - **Output**: Boolean indicating whether the point is within any of the intervals. # Constraints 1. The intervals will always be valid where `start` is less than or equal to `end`. 2. The system should efficiently handle a large number of intervals. 3. Pay attention to edge cases like adding overlapping intervals, and querying points outside the bounds of the intervals. # Scenario Alice is a software engineer tasked with managing multiple time intervals. She needs to add new intervals, merge overlapping ones, and efficiently query specific points to determine whether they fall within any of the intervals. Implement the class and functions to assist Alice with her tasks. # Usage Example ```python interval_manager = IntervalManager() interval_manager.add_interval(1, 5) interval_manager.add_interval(10, 15) interval_manager.add_interval(4, 11) # After adding all intervals, automatic merging should occur print(interval_manager.merge_intervals()) # Output: [(1, 15)] print(interval_manager.query_point(3)) # Output: True print(interval_manager.query_point(16)) # Output: False interval_manager.add_interval(16, 18) print(interval_manager.merge_intervals()) # Output: [(1, 15), (16, 18)] print(interval_manager.query_point(17)) # Output: True ``` Implement the methods `add_interval`, `merge_intervals`, and `query_point` in the `IntervalManager` class and test the class with the provided scenarios.","solution":"from typing import List, Tuple class IntervalManager: def __init__(self): self.intervals = [] def add_interval(self, start: int, end: int) -> None: self.intervals.append((start, end)) self.intervals = self.merge_intervals() def merge_intervals(self) -> List[Tuple[int, int]]: if not self.intervals: return [] self.intervals.sort() merged = [self.intervals[0]] for current in self.intervals[1:]: last_merged_start, last_merged_end = merged[-1] current_start, current_end = current if current_start <= last_merged_end: merged[-1] = (last_merged_start, max(last_merged_end, current_end)) else: merged.append(current) return merged def query_point(self, point: int) -> bool: for start, end in self.intervals: if start <= point <= end: return True return False"},{"question":"# Coding Question: Longest Increasing Subsequence Scenario You are tasked with analyzing a sequence of numbers to find trends and patterns. A common problem in this domain is detecting the longest increasing subsequence within a sequence of integers. Problem Write a function to find the length of the longest increasing subsequence in a given list of integers. Function Signature ```python def longest_increasing_subsequence(arr: List[int]) -> int: ``` Input * A list of integers `arr` (0 ≤ length of arr ≤ 10^3, -10^6 ≤ arr[i] ≤ 10^6). Output * An integer representing the length of the longest increasing subsequence in the list. Constraints * The sequence may include negative numbers. * The solution should have a time complexity of O(n log n) or better. Example ```python >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([-1, 3, 4, 5, 2, 2, 2, 1]) 4 >>> longest_increasing_subsequence([1]) 1 >>> longest_increasing_subsequence([]) 0 ``` Note: * The function `longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18])` returns 4 because the longest increasing subsequence is [2, 3, 7, 101]. Edge Cases * An empty array should return 0. * Arrays with one element should return 1. Implement the function `longest_increasing_subsequence`.","solution":"from typing import List import bisect def longest_increasing_subsequence(arr: List[int]) -> int: Returns the length of the longest increasing subsequence in the given list of integers. Uses a method with a time complexity of O(n log n). if not arr: return 0 # This will be our dynamic array to track the longest increasing subsequence lis = [] for num in arr: # Find the index where this number will go in the lis array index = bisect.bisect_left(lis, num) # If index is equal to length of lis, it means we can append this number if index == len(lis): lis.append(num) else: # Otherwise replace the existing value with this number lis[index] = num # The length of the lis array will be our answer return len(lis)"},{"question":"# Problem Statement Write a function `find_substring_indices` that finds all starting indices of a target substring in a given text string. The function should be case-sensitive and return a list of indices where the substring starts in the text. Function Signature ```python def find_substring_indices(text: str, target: str) -> list[int]: ``` # Input * `text`: A string in which to search for the target substring. Length is in the range [1, 10^5]. * `target`: The target substring to find within the text. Length is in the range [1, 1000]. # Output * Returns a list of integers representing the starting indices of the target substring in the text. # Constraints * The input strings will only contain printable ASCII characters. * If the target substring is not found in the text, return an empty list. # Performance Requirements * Aim for a solution that processes the text in O(n) time complexity where n is the length of the text. # Examples ```python assert find_substring_indices(\\"abracadabra\\", \\"abra\\") == [0, 7] assert find_substring_indices(\\"aaaaa\\", \\"aa\\") == [0, 1, 2, 3] assert find_substring_indices(\\"hello\\", \\"world\\") == [] ``` # Description The provided examples illustrate typical uses where the function should identify all occurrences of the target substring in the text. Your function should correctly handle overlapping substrings (as seen in the second example). # Edge Cases * Target substring longer than the text. * Target substring not present in the text. * Multiple overlapping occurrences of the target substring. Design your function `find_substring_indices` to efficiently find all starting indices while maintaining the overall complexity requirements.","solution":"def find_substring_indices(text: str, target: str) -> list[int]: Finds all starting indices of a target substring in a given text string. :param text: The string in which to search for the target substring :param target: The target substring to find within the text :return: A list of integers representing the starting indices indices = [] target_len = len(target) for i in range(len(text) - target_len + 1): if text[i:i + target_len] == target: indices.append(i) return indices"},{"question":"# Coding Assessment Question: Pixel Value Flipping Scenario: In digital image processing, flipping the pixel values can be an interesting operation. Given an MxN grid representing a grayscale image, each pixel value ranges from 0 to 255. By flipping the pixel values, we transform the image to its negative, which means each pixel value should be updated to `255 - pixel_value`. Problem Statement: Write a Python function `flip_pixel_values(image)` that takes an MxN grid of integers (a 2D list) and returns a new grid where each pixel value is flipped as described above. Input: - `image`: A list of lists containing integers representing the pixel values of the image. The list represents an MxN matrix where 1 <= M, N <= 100. - Each pixel value in the image is an integer between 0 and 255. Output: - A list of lists of integers representing the new image with flipped pixel values. Constraints: - The function should not modify the input image directly; instead, it should return a new grid with updated pixel values. - The time complexity should favor O(MxN). Example: ```python def flip_pixel_values(image): # Your code here # Example image = [ [0, 125, 255], [2, 128, 200] ] print(flip_pixel_values(image)) ``` Output: ``` [ [255, 130, 0], [253, 127, 55] ] ``` Tips: 1. Iterate through each pixel in the grid and calculate the new value using the formula `255 - pixel_value`. 2. Construct a new grid to store the flipped values. 3. Pay attention to the constraints and ensure the function runs efficiently. **Good Luck!**","solution":"def flip_pixel_values(image): Takes an MxN grid of integers representing pixel values of a grayscale image, and returns a new grid where each pixel value is flipped to its negative. :param image: List of lists of integers representing the image pixel values. :return: List of lists of integers representing the image with flipped pixel values. flipped_image = [] for row in image: flipped_row = [(255 - pixel) for pixel in row] flipped_image.append(flipped_row) return flipped_image"},{"question":"# Coding Assessment Question Context You\'ve been assigned to design a utility to interact with a new text-based API that provides quotes. Your task is to create a tool that fetches and saves quotes based on user-specified criteria. Task Create a function `fetch_and_save_quotes(keyword: str, max_quotes: int = 10) -> int` which: 1. Uses the provided `keyword` to search for quotes through the Quotes API. 2. Parses the JSON response to extract the quotes and their authors. 3. Saves the quotes in a local file named `<keyword>_quotes.txt`. Requirements 1. Implement the function `fetch_and_save_quotes(keyword: str, max_quotes: int = 10) -> int`. 2. The function should return the number of quotes successfully saved. 3. Fetch a maximum of 50 quotes. 4. Implement error handling for network issues or unsuccessful responses. 5. Ensure the function gracefully handles cases where no quotes are found. Input and Output * **Input**: A string `keyword` representing the search term, and an integer `max_quotes` specifying the maximum number of quotes to fetch. * **Output**: An integer count of successfully saved quotes. Constraints * The function should fetch a maximum of 50 quotes. * Assume the environment has internet access and necessary permissions. * Your solution should handle common network errors gracefully. * The script must use the `requests` library for HTTP requests and handle JSON responses. Example: ```python >>> count = fetch_and_save_quotes(\\"inspiration\\", 5) >>> print(count) 5 ``` *JSON response example from the Quotes API:* ```json [ {\\"quote\\": \\"The best way to predict the future is to invent it.\\", \\"author\\": \\"Alan Kay\\"}, {\\"quote\\": \\"Life is 10% what happens to us and 90% how we react to it.\\", \\"author\\": \\"Charles R. Swindoll\\"}, {\\"quote\\": \\"The only way to do great work is to love what you do.\\", \\"author\\": \\"Steve Jobs\\"} ] ``` Your function should handle this JSON structure and save the quotes in a text file as follows: `inspiration_quotes.txt`: ``` \\"The best way to predict the future is to invent it.\\" - Alan Kay \\"Life is 10% what happens to us and 90% how we react to it.\\" - Charles R. Swindoll \\"The only way to do great work is to love what you do.\\" - Steve Jobs ```","solution":"import requests def fetch_and_save_quotes(keyword: str, max_quotes: int = 10) -> int: url = f\\"https://api.example.com/quotes?keyword={keyword}&limit=50\\" try: response = requests.get(url) response.raise_for_status() quotes_data = response.json() except requests.RequestException as e: # Handle network issues and unsuccessful responses print(f\\"Error fetching quotes: {e}\\") return 0 # Limit the number of quotes to save quotes_to_save = quotes_data[:max_quotes] filename = f\\"{keyword}_quotes.txt\\" try: with open(filename, \'w\') as file: for quote in quotes_to_save: quote_text = f\'\\"{quote[\\"quote\\"]}\\" - {quote[\\"author\\"]}\' file.write(quote_text + \\"n\\") except IOError as e: # Handle file I/O issues print(f\\"Error saving quotes to file: {e}\\") return 0 return len(quotes_to_save)"},{"question":"# Question: Validate and Generate ISBN-13 You are tasked with implementing two functions to handle ISBN-13 validation and conversion from ISBN-10. Function 1: `is_valid_isbn13(isbn: str) -> bool` Implement a function that checks if a given ISBN-13 number is valid. **Inputs:** * `isbn (str)`: A string representing the ISBN-13 number, e.g., \\"9780306406157\\". **Outputs:** * `bool`: `True` if the ISBN-13 is valid, `False` otherwise. **Constraints:** * The input string must be exactly 13 digits long. * ISBN-13 numbers use a specific checksum algorithm to determine their validity. **Validation Algorithm:** 1. Sum all the digits in the odd positions. 2. Sum all the digits in the even positions and multiply this sum by 3. 3. Add the results of steps 1 and 2. 4. The result must be divisible by 10 for the ISBN-13 to be valid. Input Examples: - `\\"9780306406157\\"` - `\\"9781861972712\\"` Output Examples: - `True` - `True` Function 2: `convert_isbn10_to_isbn13(isbn10: str) -> str` Implement a function that converts an ISBN-10 number to its equivalent ISBN-13 format. **Inputs:** * `isbn10 (str)`: A string representing the ISBN-10 number, e.g., \\"0306406152\\". **Outputs:** * `str`: The ISBN-13 representation of the input ISBN-10 number. **Constraints:** * The input string must be exactly 10 digits long. * The ISBN-10 number must pass its checksum validation before conversion. * Use the \\"978\\" prefix for conversion. **Conversion Algorithm:** 1. Append the \\"978\\" prefix to the first 9 digits of the ISBN-10 number. 2. Calculate the checksum for the resulting 12-digit number using the ISBN-13 algorithm. 3. Append the checksum digit to the end. **Validation Algorithm for ISBN-10:** 1. Sum of the first 9 digits each multiplied by (10 - their position index). 2. Add the 10th digit. 3. The result must be divisible by 11. Input Examples: - `\\"0306406152\\"` - `\\"1861972717\\"` Output Examples: - `\\"9780306406157\\"` - `\\"9781861972712\\"` # Requirements 1. Your functions must handle edge cases, such as invalid ISBN formats or lengths. 2. Implement the ISBN validation algorithms accurately. 3. Ensure the conversion function properly transforms a valid ISBN-10 to a valid ISBN-13. Examples Example 1: ```python >>> is_valid_isbn13(\\"9780306406157\\") True >>> is_valid_isbn13(\\"9781861972712\\") True >>> is_valid_isbn13(\\"9780306406158\\") False ``` Example 2: ```python >>> convert_isbn10_to_isbn13(\\"0306406152\\") \'9780306406157\' >>> convert_isbn10_to_isbn13(\\"1861972717\\") \'9781861972712\' ``` Implement the above functions ensuring they fulfill the requirements and handle all edge cases appropriately.","solution":"def is_valid_isbn13(isbn: str) -> bool: Check if a given ISBN-13 number is valid. Args: isbn (str): A string representing the ISBN-13 number, e.g., \\"9780306406157\\". Returns: bool: True if the ISBN-13 is valid, False otherwise. if len(isbn) != 13 or not isbn.isdigit(): return False total = 0 for index, char in enumerate(isbn): digit = int(char) if index % 2 == 0: total += digit else: total += digit * 3 return total % 10 == 0 def convert_isbn10_to_isbn13(isbn10: str) -> str: Convert an ISBN-10 number to its equivalent ISBN-13 format. Args: isbn10 (str): A string representing the ISBN-10 number, e.g., \\"0306406152\\". Returns: str: The ISBN-13 representation of the input ISBN-10 number. if len(isbn10) != 10 or not (isbn10[:-1].isdigit() and (isbn10[-1].isdigit() or isbn10[-1] == \'X\')): raise ValueError(\\"Invalid ISBN-10 format\\") check_sum = sum((10 - i) * (10 if c == \'X\' else int(c)) for i, c in enumerate(isbn10[:-1])) + (10 if isbn10[-1] == \'X\' else int(isbn10[-1])) if check_sum % 11 != 0: raise ValueError(\\"Invalid ISBN-10 checksum\\") isbn13_prefix = \\"978\\" + isbn10[:-1] total = 0 for index, char in enumerate(isbn13_prefix): digit = int(char) if index % 2 == 0: total += digit else: total += digit * 3 check_digit = (10 - (total % 10)) % 10 return isbn13_prefix + str(check_digit)"},{"question":"Introduction: The Traveling Salesman Problem (TSP) is a classic optimization problem where a salesman is required to visit a set of cities, each exactly once, and return to the starting city while minimizing the total travel distance. Problem: You need to create a class `TSPSolver` that finds the minimum travel distance using dynamic programming with memoization. # Task: 1. Implement the `TSPSolver` class with methods to calculate the minimum travel distance for the given set of cities. 2. Use dynamic programming with memoization to store already computed minimum distances for subproblems to increase the efficiency of the solution. # Input/Output Format: * **Input**: - `distances`: A 2D list of integers representing the pairwise distances between cities. `distances[i][j]` represents the distance from city `i` to city `j`. * **Output**: - An integer representing the minimum travel distance to visit all cities starting and ending at the first city. # Constraints: 1. The distance matrix will be a square matrix where the number of cities equals the number of rows and columns (`N`). 2. `1 <= N <= 20` 3. Distance values will be non-negative integers. # Example: ```python distances = [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ] solver = TSPSolver(distances) print(solver.find_minimum_distance()) # Output should be 80 ``` # Evaluation Criteria: 1. Correctness: The implemented algorithm must correctly compute the minimum travel distance. 2. Efficiency: The method should handle the constraints efficiently using dynamic programming. 3. Code Quality: Solutions should maintain readability, modularity, and proper documentation of logic.","solution":"class TSPSolver: def __init__(self, distances): self.distances = distances self.n = len(distances) self.memo = {} def tsp(self, mask, pos): if mask == (1 << self.n) - 1: return self.distances[pos][0] if (mask, pos) in self.memo: return self.memo[(mask, pos)] min_cost = float(\'inf\') for city in range(self.n): if mask & (1 << city) == 0: new_cost = self.distances[pos][city] + self.tsp(mask | (1 << city), city) min_cost = min(min_cost, new_cost) self.memo[(mask, pos)] = min_cost return min_cost def find_minimum_distance(self): return self.tsp(1, 0)"},{"question":"# Binary Search Tree (BST) Operations Context You are required to extend and utilize a `BinarySearchTree` class to perform several common tree operations. This question aims to test your understanding and ability to manipulate a BST effectively. Problem Statement 1. **Node Depth Calculation**: Implement a method `get_depth(self, node: Node) -> int` that calculates and returns the depth of a given node in the binary search tree. * **Input**: `node` is a reference to a node in the BST. * **Output**: Return the depth of the node as an integer. Return `-1` if the node is not found in the tree. 2. **Inorder Predecessor**: Implement a method `get_inorder_predecessor(self, node: Node) -> Node` to find the inorder predecessor of a given node. * **Input**: `node` is a reference to a node in the BST. * **Output**: Return the inorder predecessor node. If the node has no inorder predecessor (i.e., it\'s the smallest node), return `None`. # Implementation Details * Implement the following two methods inside the `BinarySearchTree` class provided: ```python class BinarySearchTree: # Existing methods of the class... def get_depth(self, node: Node) -> int: # Your implementation here def get_inorder_predecessor(self, node: Node) -> Node: # Your implementation here ``` # Example Usage ```python bst = BinarySearchTree() values = [20, 10, 30, 5, 15, 25, 35] for val in values: bst.insert(val) # Assume a method `insert` is defined to insert values into the BST # Assume the method `find` is defined to return a reference to a node with the given value. node_15 = bst.find(15) node_5 = bst.find(5) depth_of_15 = bst.get_depth(node_15) print(depth_of_15) # Should print: 2 (If root node depth is considered as 0) inorder_predecessor_15 = bst.get_inorder_predecessor(node_15) print(inorder_predecessor_15.data) # Should print: 10 (Inorder predecessor of 15) ``` * **Constraints**: - Assume all node values are unique. - Node depth should be calculated with the root node depth considered as `0`. * **Submission Requirements**: - The `get_depth` method should return an integer representing the depth of the node. - The `get_inorder_predecessor` method should return a Node object or `None` if no predecessor exists. Explain your approach after implementing the above methods briefly.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = Node(key) else: self._insert(root.left, key) else: if root.right is None: root.right = Node(key) else: self._insert(root.right, key) def find(self, key): return self._find(self.root, key) def _find(self, root, key): if root is None or root.val == key: return root if key < root.val: return self._find(root.left, key) return self._find(root.right, key) def get_depth(self, node): return self._get_depth(self.root, node, 0) def _get_depth(self, root, node, depth): if root is None: return -1 if root == node: return depth downlevel = self._get_depth(root.left, node, depth + 1) if downlevel != -1: return downlevel downlevel = self._get_depth(root.right, node, depth + 1) return downlevel def get_inorder_predecessor(self, node): # Step 1: If left child exists, find the max value in left subtree if node.left: return self._get_max(node.left) # Step 2: Otherwise, go to the root and find the deepest ancestor # where the node would be in the right subtree. predecessor = None root = self.root while root: if node.val > root.val: predecessor = root root = root.right elif node.val < root.val: root = root.left else: break return predecessor def _get_max(self, node): current = node while current.right: current = current.right return current"},{"question":"# Problem Statement You are tasked with implementing a function that determines whether any two elements in an input sequence of integers have a greatest common divisor (GCD) greater than 1. Use the Euclidean algorithm to compute the GCD efficiently. Given an array of integers, your goal is to find whether there exists any pair of integers in the array with a GCD greater than 1. Implement the function `has_pair_with_gcd_greater_than_one(arr: List[int]) -> bool` in Python, which takes a list of integers and returns `True` if there exists at least one such pair, otherwise `False`. # Function Signature ```python def has_pair_with_gcd_greater_than_one(arr: List[int]) -> bool: pass ``` # Input - `arr`: List of integers that may contain negative numbers, zero, and positive numbers, with length (0 ≤ len ≤ 10^5). # Output - Return `True` if there exists at least one pair of integers in the list with a GCD greater than 1, otherwise return `False`. # Constraints - Use the Euclidean algorithm to compute the GCD efficiently. - The input list can contain various integers, but your function should handle these cases appropriately. # Examples ```python >>> has_pair_with_gcd_greater_than_one([3, 5, 7, 9]) False >>> has_pair_with_gcd_greater_than_one([10, 15, 25, 35]) True >>> has_pair_with_gcd_greater_than_one([]) False >>> has_pair_with_gcd_greater_than_one([4, 6, 8, 10]) True >>> has_pair_with_gcd_greater_than_one([17, 23, 29]) False >>> has_pair_with_gcd_greater_than_one([12, -18, 27]) True ``` # Notes 1. The function should return `True` if there is at least one pair of integers with a GCD greater than 1, otherwise `False`. 2. Ensure your implementation can handle up to 100,000 elements efficiently. 3. The Euclidean algorithm is an efficient method for computing the GCD of two numbers.","solution":"from typing import List from math import gcd def has_pair_with_gcd_greater_than_one(arr: List[int]) -> bool: n = len(arr) if n < 2: return False # Function to compute GCD of an array def compute_gcd_of_array(array): current_gcd = array[0] for num in array[1:]: current_gcd = gcd(current_gcd, num) if current_gcd == 1: return 1 return current_gcd return compute_gcd_of_array(arr) > 1"},{"question":"Matrix Transposition in Place Matrix transposition involves swapping the rows and columns of a matrix, turning rows into columns and vice versa. In this problem, you are required to implement an in-place transposition of a square matrix. # Objective: Write a function to perform an in-place transposition of a given `n x n` matrix. # Context: Imagine you\'re working on a graphics rendering engine that needs to transpose large matrices efficiently to optimize computational resources. Given a square matrix, your task is to transpose the matrix in-place, meaning you cannot use any additional matrix or array in the process. # Function Signature: ```python def transpose_in_place(matrix: List[List[int]]) -> None: pass ``` # Input: - `matrix`: A 2D list (size n x n) representing the square matrix where `matrix[i][j]` is an integer. # Output: - Modifies the input matrix in-place to its transpose. The function does not return any value. # Constraints: - The matrix is always a square matrix (n x n), where 1 <= n <= 200. - The values of the matrix elements are integers between -10^9 and 10^9. # Performance Requirements: - The transposition operation must be done in O(n^2) time complexity. - No additional memory should be used beyond a few auxiliary variables (i.e., must be done in-place). # Scenario: ```python # Example 1 matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] transpose_in_place(matrix1) print(matrix1) # Expected output: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] # Example 2 matrix2 = [ [1, 0], [0, 1] ] transpose_in_place(matrix2) print(matrix2) # Expected output: # [ # [1, 0], # [0, 1] # ] ``` # Hints: 1. Remember the property that `matrix[i][j]` should become `matrix[j][i]` after transposition. 2. You only need to traverse the matrix above or below the main diagonal to perform the swap, as this will cover all necessary element pairs.","solution":"from typing import List def transpose_in_place(matrix: List[List[int]]) -> None: Perform an in-place transposition of the given n x n matrix. :param matrix: 2D list of integers representing the matrix. n = len(matrix) for i in range(n): for j in range(i + 1, n): # Swap elements matrix[i][j] and matrix[j][i] matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]"},{"question":"# Array Element Counter You are tasked with implementing a method within the `ArrayCounter` class. Specifically, implement the \\"count_elements\\" method to count the occurrences of each distinct element in a given array. **Task**: Add the following method to the `ArrayCounter` class: ```python def count_elements(self): Count occurrences of each element in the array. :return: A dictionary with elements as keys and their counts as values. element_count = {} for elem in self.array: if elem in element_count: element_count[elem] += 1 else: element_count[elem] = 1 return element_count ``` **Objective**: Define this method such that it operates on the class\'s internal attribute (`array`). Ensure your implementation correctly counts each unique element and returns the counts in a dictionary. **Input/Output**: * **Input**: The method will use the existing attribute (`self.array`), a Python list containing the elements. * **Output**: A dictionary with elements as keys and their counts as values. **Constraints**: * `array` is a list of integers. * There is no restriction on the element values, but the list should not exceed 10,000 elements. **Performance**: Ensure your implementation handles large arrays efficiently. **Scenario**: You are working with a dataset containing repeated measurements. Your task is to count how often each measurement occurs in the dataset to identify common values and their frequencies. Example: ```python # Given input array array = [1, 2, 2, 3, 1, 4, 2, 1, 3] # Expected Output # element_count {1: 3, 2: 3, 3: 2, 4: 1} ``` Add your method definition to the `ArrayCounter` class and verify its correctness based on the provided example.","solution":"class ArrayCounter: def __init__(self, array): self.array = array def count_elements(self): Count occurrences of each element in the array. :return: A dictionary with elements as keys and their counts as values. element_count = {} for elem in self.array: if elem in element_count: element_count[elem] += 1 else: element_count[elem] = 1 return element_count"},{"question":"Problem Statement You are developing a feature that requires you to remove all HTML tags from a given string and return the cleaned text. HTML tags are enclosed in angle brackets `< >`, and you need to ensure that only the inner text remains. # Function Signature ```python def strip_html_tags(html_string: str) -> str: ``` # Input * `html_string` (str): The input string that contains HTML tags (0 ≤ len(html_string) ≤ 1000). # Output * Returns a string (str) with all HTML tags removed, retaining only the text outside the tags. # Constraints * The input string may contain nested or non-nested HTML tags. * The input string contains only printable ASCII characters. # Example ```python strip_html_tags(\\"<div><p>Hello, World!</p></div>\\") # Returns: \\"Hello, World!\\" strip_html_tags(\\"<html><body>Test</body></html>\\") # Returns: \\"Test\\" strip_html_tags(\\"<a href=\'link\'>click here</a>\\") # Returns: \\"click here\\" strip_html_tags(\\"No tags here!\\") # Returns: \\"No tags here!\\" ``` # Detailed Description Write the function `strip_html_tags` which strips away all HTML tags from the input string and returns the cleaned text. The function should properly handle both nested and non-nested tags and ensure that only the plain text remains. # Hints * Use a state machine or regular expressions to identify and remove HTML tags. * Ensure that the solution handles various HTML tag structures and nested tag scenarios. # Edge Cases * The input string may not contain any HTML tags. * The HTML tags may be nested within each other. * There may be multiple consecutive tags with no text in between. # Notes * You should not use any external libraries for HTML parsing. The solution should be implemented with basic string manipulation techniques available in Python.","solution":"import re def strip_html_tags(html_string: str) -> str: Removes all HTML tags from the given string and returns cleaned text. Parameters: html_string (str): The input string containing HTML tags. Returns: str: The cleaned text with HTML tags removed. # Regular expression to find HTML tags html_tag_re = re.compile(r\'<.*?>\') # Substituting the HTML tags with an empty string cleaned_text = re.sub(html_tag_re, \'\', html_string) return cleaned_text"},{"question":"# Binary Search Tree (BST) Operations **Scenario**: You are required to implement basic operations on a Binary Search Tree (BST). Your task is to write two functions to insert a new value into the BST and to check if a given value exists in the BST. Function 1: `insert_into_bst` - **Input**: - `root`: A TreeNode representing the root of the BST (it can be None if the tree is empty). - `value`: An integer representing the value to be inserted into the BST. - **Output**: - A TreeNode representing the root of the BST after the insertion. - **Function Signature**: ```python def insert_into_bst(root: TreeNode, value: int) -> TreeNode: ``` Function 2: `search_bst` - **Input**: - `root`: A TreeNode representing the root of the BST. - `value`: An integer representing the value to search in the BST. - **Output**: - A boolean indicating whether the value exists in the BST or not (True if the value exists, False otherwise). - **Function Signature**: ```python def search_bst(root: TreeNode, value: int) -> bool: ``` Constraints - The tree nodes carry integer values. - The values of the tree nodes are unique. - `1 <= value <= 10^9` - The input BST may not necessarily be balanced. Example ```python # Definition for a binary tree node class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None # Input root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(7) root.left.left = TreeNode(1) root.left.right = TreeNode(3) # Function Execution root = insert_into_bst(root, 5) exists = search_bst(root, 5) # Expected Output print(root.right.left.val) # 5 print(exists) # True # Further Execution exists = search_bst(root, 6) # Expected Output print(exists) # False ``` Your implementation of the functions will be tested with various inputs to ensure they correctly insert new nodes and search for values in the BST. Make sure to handle edge cases and ensure the resulting tree maintains the properties of a BST.","solution":"# Definition for a binary tree node class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def insert_into_bst(root: TreeNode, value: int) -> TreeNode: Inserts a new value into the BST. If the root is None, creates a new TreeNode with the value. if root is None: return TreeNode(value) else: if value < root.val: root.left = insert_into_bst(root.left, value) else: root.right = insert_into_bst(root.right, value) return root def search_bst(root: TreeNode, value: int) -> bool: Searches for a value in the BST. Returns True if the value exists, False otherwise. if root is None: return False if root.val == value: return True elif value < root.val: return search_bst(root.left, value) else: return search_bst(root.right, value)"},{"question":"# Problem Statement You are tasked with implementing a function that generates a sequence of prime numbers up to a certain limit using the Sieve of Eratosthenes algorithm. # Function Signature ```python def sieve_of_eratosthenes(limit: int) -> List[int]: Generate all prime numbers up to a given limit using the Sieve of Eratosthenes. Parameters: limit (int): The upper limit (inclusive) for generating prime numbers. Returns: List[int]: A list of prime numbers up to the specified limit. Examples: >>> sieve_of_eratosthenes(10) [2, 3, 5, 7] >>> sieve_of_eratosthenes(20) [2, 3, 5, 7, 11, 13, 17, 19] ``` # Requirements 1. **Input**: * An integer, `limit`, representing the upper limit for prime numbers (inclusive). 2. **Output**: * A list of integers containing all prime numbers up to the specified `limit`. 3. **Constraints**: * The function should handle limits up to 10^6 efficiently. * The limit will always be a positive integer. # Example Scenarios Example 1: * **Input**: `10` * **Output**: `[2, 3, 5, 7]` * **Explanation**: The prime numbers less than or equal to 10 are 2, 3, 5, and 7. Example 2: * **Input**: `20` * **Output**: `[2, 3, 5, 7, 11, 13, 17, 19]` * **Explanation**: The prime numbers less than or equal to 20 are 2, 3, 5, 7, 11, 13, 17, and 19. # Notes 1. Validate the input to ensure it is a positive integer. 2. The function should be optimized for time and space to handle large values of `limit` efficiently.","solution":"from typing import List def sieve_of_eratosthenes(limit: int) -> List[int]: Generate all prime numbers up to a given limit using the Sieve of Eratosthenes. Parameters: limit (int): The upper limit (inclusive) for generating prime numbers. Returns: List[int]: A list of prime numbers up to the specified limit. if limit < 2: return [] sieve = [True] * (limit + 1) sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers for start in range(2, int(limit**0.5) + 1): if sieve[start]: for multiple in range(start*start, limit + 1, start): sieve[multiple] = False return [num for num in range(2, limit + 1) if sieve[num]]"},{"question":"# Identify Unique Elements in a List **Context**: You\'re tasked with developing a part of a data analysis library that identifies unique elements in a dataset. This functionality is crucial for analyzing datasets where duplicate entries might be present, and the presence of unique values is needed for various statistical operations. **Task**: Implement a function `unique_elements(data: List[int]) -> List[int]` that receives a list of integers and returns a list of unique integers in the order they first appear in the input list. Your solution should be efficient, even for large datasets, making use of appropriate data structures to maintain the uniqueness property and insertion order. **Input**: * A list of integers representing the dataset. **Output**: * A list of unique integers in the order they first appear in the input list. **Constraints**: * The input list can have up to 1,000,000 elements. * Input values can be negative or positive integers. * The output list should preserve the order of first appearance of unique elements. **Example**: ```python assert unique_elements([1, 2, 2, 3, 1, 4, 5, 3]) == [1, 2, 3, 4, 5] assert unique_elements([10, 20, 10, 30, 20]) == [10, 20, 30] assert unique_elements([7, 4, 7, 4, 4, 7]) == [7, 4] ``` **Performance Requirement**: * Ensure the solution is optimal regarding time complexity and can handle the upper constraint limits efficiently. **Hints**: * Consider using a set to track seen elements and a list to maintain the order of unique elements.","solution":"def unique_elements(data): Returns a list of unique integers in the order they first appear in the input list. :param data: List[int] - a list of integers :return: List[int] - a list of unique integers seen = set() unique_list = [] for item in data: if item not in seen: seen.add(item) unique_list.append(item) return unique_list"},{"question":"# Problem Statement: You are developing a geometry tool and need to determine whether a given point lies within a triangle. This is a crucial feature for understanding geometric relationships in various applications. # Requirements: Implement a function `is_point_in_triangle(px: float, py: float, ax: float, ay: float, bx: float, by: float, cx: float, cy: float) -> bool` that checks if a point (px, py) lies within the triangle formed by three vertices (ax, ay), (bx, by), and (cx, cy). The function should: 1. Return `True` if the point lies inside or on the edges of the triangle. 2. Return `False` if the point lies outside the triangle. # Input: * Coordinates of the point: px, py (floats) * Coordinates of the triangle vertices: ax, ay, bx, by, cx, cy (all floats) # Output: * A boolean value indicating whether the point lies within the triangle. # Constraints: * All input coordinates are between (-10^6) and (10^6) # Example: ```python def is_point_in_triangle(px: float, py: float, ax: float, ay: float, bx: float, by: float, cx: float, cy: float) -> bool: pass # Example Usage: print(is_point_in_triangle(0, 0, 0, 0, 5, 0, 5, 5)) # Should output True (point is on vertex) print(is_point_in_triangle(2, 2, 0, 0, 5, 0, 5, 5)) # Should output True (point is inside) print(is_point_in_triangle(6, 6, 0, 0, 5, 0, 5, 5)) # Should output False (point is outside) print(is_point_in_triangle(5, 5, 0, 0, 5, 0, 5, 5)) # Should output True (point is on edge) ``` # Note: * You can use the Barycentric coordinate method, or any other geometric approach, to determine if the point is inside the triangle. * Ensure considerations for edge cases such as the point being exactly on one of the triangle\'s vertices or edges.","solution":"def is_point_in_triangle(px: float, py: float, ax: float, ay: float, bx: float, by: float, cx: float, cy: float) -> bool: Determine if the point (px, py) lies inside the triangle formed by (ax, ay), (bx, by), and (cx, cy). Uses the Barycentric coordinate method. def sign(x1, y1, x2, y2, x3, y3): return (x1 - x3) * (y2 - y3) - (x2 - x3) * (y1 - y3) d1 = sign(px, py, ax, ay, bx, by) d2 = sign(px, py, bx, by, cx, cy) d3 = sign(px, py, cx, cy, ax, ay) has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0) has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0) return not (has_neg and has_pos)"},{"question":"# Problem Statement You are given an array of integers and a target sum. Your task is to find all unique pairs of integers in the array that add up to the target sum. Each pair should be sorted in ascending order, and the result should not contain duplicate pairs. # Context Finding pairs of numbers that add up to a target sum is a common problem in algorithm design, often used in exercises on hash tables and sorting. This problem will test your ability to manipulate arrays, use hash-based data structures, and ensure the uniqueness of your results. # Function Signature ```python def find_pairs_with_sum(arr: list[int], target: int) -> list[tuple[int, int]]: ``` # Input - `arr`: A list of integers where the array elements can be positive, negative or zero. - `target`: An integer representing the target sum that the pairs of integers should add up to. # Output - A list of tuples, where each tuple contains two integers that sum up to the target. Each tuple should be sorted in ascending order and the overall list should contain unique tuples. # Constraints - The length of the array (1 leq text{len}(arr) leq 10^4). - The integer values in `arr` are in the range (-10^4 leq arr[i] leq 10^4). - The target sum is in the range (-10^8 leq text{target} leq 10^8). # Example ```python result = find_pairs_with_sum([1, 2, -2, 3, 4, -1, -1, 2], 3) print(result) # Expected [[-1, 4], [1, 2]] ``` # Specifications 1. The function should efficiently handle the input size. 2. Ensure that each pair appearing in the result list is unique. 3. Return the list of tuples sorted in ascending order by the first element in each pair; if two pairs have the same first element, then they should be sorted by the second element. 4. Handle edge cases such as: - No pairs found. - Duplicated values in the array. - Negative numbers in the array.","solution":"def find_pairs_with_sum(arr: list[int], target: int) -> list[tuple[int, int]]: seen = set() output = set() for num in arr: complement = target - num if complement in seen: output.add(tuple(sorted((num, complement)))) seen.add(num) return sorted(list(output))"},{"question":"# Advanced Coding Assessment Question Context In the development of a real-time data analytics platform, you need to efficiently manage and retrieve information from a large dataset. This dataset is dynamic and may frequently change, including adding, removing, and updating records. Problem Statement Implement a class `DynamicSortedArray` that maintains a sorted array. This class should support efficient insertion, deletion, and access operations. 1. Implement the `DynamicSortedArray` class with the following methods: - `add(value: int) -> None`: Adds an integer `value` to the sorted array while maintaining the sorted order. - `remove(value: int) -> None`: Removes an integer `value` from the sorted array if it exists. If the value does not exist, it should raise a `ValueError`. - `find_value(index: int) -> int`: Returns the integer at the given index in the sorted array. If the index is out-of-bounds, it should raise an `IndexError`. - `find_index(value: int) -> int`: Finds and returns the smallest index of `value` in the sorted array. If the value does not exist, it should raise a `ValueError`. 2. Ensure proper handling of edge cases: - Provide meaningful error messages for out-of-bound indices and non-existing values. - Ensure that the insertion, deletion, and find operations maintain performance efficiency. Constraints * The array should handle up to 10^5 elements efficiently. Function Signatures ```python class DynamicSortedArray: def __init__(self): Initializes an empty sorted array. pass def add(self, value: int) -> None: Adds value to the sorted array. pass def remove(self, value: int) -> None: Removes value from the sorted array. pass def find_value(self, index: int) -> int: Retrieves the element at the specified index. pass def find_index(self, value: int) -> int: Retrieves the index of the specified value. pass ``` Example Usage ```python # Initialize the dynamic sorted array dsa = DynamicSortedArray() # Add values to the array dsa.add(5) dsa.add(3) dsa.add(10) dsa.add(5) # The array should now be [3, 5, 5, 10] # Find values by index print(dsa.find_value(0)) # Outputs: 3 print(dsa.find_value(2)) # Outputs: 5 # Find index of values print(dsa.find_index(5)) # Outputs: 1 (The first occurrence of 5 is at index 1) # Remove values from the array dsa.remove(5) # The array should now be [3, 5, 10] # Ensure edge case handling # Finding a value at out-of-bounds index try: print(dsa.find_value(10)) except IndexError as e: print(e) # Outputs: index out of range # Removing a non-existing value try: dsa.remove(100) except ValueError as e: print(e) # Outputs: value not found ```","solution":"import bisect class DynamicSortedArray: def __init__(self): Initializes an empty sorted array. self.array = [] def add(self, value: int) -> None: Adds value to the sorted array. bisect.insort(self.array, value) def remove(self, value: int) -> None: Removes value from the sorted array. index = bisect.bisect_left(self.array, value) if index != len(self.array) and self.array[index] == value: self.array.pop(index) else: raise ValueError(f\\"value {value} not found\\") def find_value(self, index: int) -> int: Retrieves the element at the specified index. if index < 0 or index >= len(self.array): raise IndexError(f\\"index {index} out of range\\") return self.array[index] def find_index(self, value: int) -> int: Retrieves the index of the specified value. index = bisect.bisect_left(self.array, value) if index != len(self.array) and self.array[index] == value: return index else: raise ValueError(f\\"value {value} not found\\")"},{"question":"# Matrix Rotation Problem You are developing an image processing feature that requires rotating an image represented by an `n x n` 2D matrix by 90 degrees clockwise. Each element of the matrix represents a pixel value of the image. **Task**: Write a function `rotate_matrix(matrix: List[List[int]]) -> List[List[int]]` that takes an `n x n` matrix and rotates it 90 degrees clockwise. **Constraints**: - The matrix will be `n x n`, where (1 leq n leq 20). - The elements of the matrix will be integers between -1000 and 1000. # Function Description and Example 1. **rotate_matrix** - **Input**: - `matrix` (List[List[int]]): 2D list of integers representing the matrix. - **Output**: - Returns a new 2D list of integers representing the rotated matrix. - **Examples**: ```python assert rotate_matrix([[1, 2], [3, 4]]) == [[3, 1], [4, 2]] assert rotate_matrix([[5, 1, 9], [2, 4, 8], [7, 3, 6]]) == [[7, 2, 5], [3, 4, 1], [6, 8, 9]] assert rotate_matrix([[1]]) == [[1]] ``` **Explanation**: - To rotate the matrix 90 degrees clockwise, you need to perform a transpose of the matrix followed by a reversal of each row. Make sure the function handles various edge cases such as: - Very small matrices (e.g., (1 times 1)). - The function should not modify the input matrix but return a new rotated matrix instead. ```python def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: n = len(matrix) # Transpose the matrix transposed_matrix = [[matrix[j][i] for j in range(n)] for i in range(n)] # Reverse each row rotated_matrix = [row[::-1] for row in transposed_matrix] return rotated_matrix ```","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates the given n x n matrix 90 degrees clockwise. Args: matrix (List[List[int]]): A 2D list of integers representing the matrix. Returns: List[List[int]]: A new 2D list of integers representing the rotated matrix. n = len(matrix) # Transpose the matrix transposed_matrix = [[matrix[j][i] for j in range(n)] for i in range(n)] # Reverse each row rotated_matrix = [row[::-1] for row in transposed_matrix] return rotated_matrix"},{"question":"# Scenario You have been asked to develop a recommendation system for an online bookstore. The system should suggest books to users based on their past reading history. The past reading history is stored in the form of user-book interactions, where each interaction consists of a user ID, a book ID, and a rating given by the user to the book. # Question Implement a function to train a collaborative filtering model using matrix factorization to predict book ratings. The training data will be provided as a list of interactions, and your model should learn latent vectors for users and books. Use these latent vectors to predict ratings for user-book pairs. # Specifications 1. **Data Pre-processing:** - Convert the list of interactions to a user-item matrix. - Normalize the ratings (if necessary). 2. **Model Architecture:** - Use matrix factorization to obtain low-dimensional user and book latent factors. - Apply a linear combination of these factors to predict ratings. 3. **Training:** - Initialize latent factors randomly. - Optimize the user and book matrices using gradient descent to minimize the mean squared error between actual and predicted ratings. - Train for 50 iterations. # Function Signature ```python def train_recommendation_model(interactions, num_users, num_books, latent_features=10, learning_rate=0.01, iterations=50): pass ``` # Input - `interactions`: A list of tuples, where each tuple is of the form `(user_id, book_id, rating)`. - `num_users`: Total number of users in the dataset. - `num_books`: Total number of books in the dataset. - `latent_features`: Number of latent factors (default 10). - `learning_rate`: Learning rate for gradient descent (default 0.01). - `iterations`: Number of iterations for training (default 50). # Output - Return the learned user and book matrices as a tuple `(user_matrix, book_matrix)`. # Constraints - Assume `numpy` library is imported and available. - All user IDs and book IDs are in the range of 0 to `num_users-1` and 0 to `num_books-1` respectively. # Performance Requirements - Efficient training with a standard workstation (training should not exceed 1 hour). # Examples ```python # Example usage interactions = [(0, 0, 5), (0, 1, 3), (1, 0, 4), (1, 2, 5)] num_users = 2 num_books = 3 user_matrix, book_matrix = train_recommendation_model(interactions, num_users, num_books) ``` # Notes - Use accurate data source paths and adjust learning rates, batch sizes if necessary. - Ensure the training process is robust to potential outliers in the dataset. This function\'s main operations include converting interactions to a matrix, initializing and optimizing latent factors, and returning the trained matrices.","solution":"import numpy as np def train_recommendation_model(interactions, num_users, num_books, latent_features=10, learning_rate=0.01, iterations=50): Train a recommendation model using matrix factorization. Args: interactions (list of tuples): Each tuple contains (user_id, book_id, rating). num_users (int): Total number of users. num_books (int): Total number of books. latent_features (int): Number of latent factors. Default is 10. learning_rate (float): Learning rate for gradient descent. Default is 0.01. iterations (int): Number of iterations for training. Default is 50. Returns: tuple: A tuple containing the user latent matrix and the book latent matrix. # Initialize user and book matrices with random values user_matrix = np.random.rand(num_users, latent_features) book_matrix = np.random.rand(num_books, latent_features) # Convert interactions to a user-item rating matrix ratings_matrix = np.zeros((num_users, num_books)) for (user_id, book_id, rating) in interactions: ratings_matrix[user_id, book_id] = rating # Matrix factorization using stochastic gradient descent for _ in range(iterations): for (user_id, book_id, rating) in interactions: error = rating - np.dot(user_matrix[user_id, :], book_matrix[book_id, :]) user_matrix[user_id, :] += learning_rate * (error * book_matrix[book_id, :] - 0.02 * user_matrix[user_id, :]) book_matrix[book_id, :] += learning_rate * (error * user_matrix[user_id, :] - 0.02 * book_matrix[book_id, :]) return user_matrix, book_matrix"},{"question":"# Temperature Conversion and Description Enhancement You are tasked with enhancing a temperature conversion tool used in various scientific and general applications. This converter should support additional temperature units and provide helpful descriptions about each unit. Requirements: 1. **Extend Unit Support**: Add support for the additional temperature units: \\"Rankine\\" (1 Rankine = 1.8 Kelvin) and \\"Réaumur\\" (0.8 Réaumur = 1 Kelvin). 2. **Unit Description Function**: Implement a function `temperature_unit_description(unit: str) -> str` that returns a detailed string description of the given unit. It should include the full name, historical background, and commonly used context. For unsupported units, raise a ValueError with a descriptive error message. # Input Specifications: 1. `temperature_conversion(value: float, from_unit: str, to_unit: str) -> float`: This function converts temperature from one unit to another. 2. `temperature_unit_description(unit: str) -> str`: This function provides descriptions about the given temperature unit. # Output Specifications: 1. `temperature_conversion` should return the converted temperature value. 2. `temperature_unit_description` should return a detailed description string for the unit. # Constraints: 1. The units provided must be valid; otherwise, raise a `ValueError`. 2. Ensure the descriptions are thorough and informative. # Scenarios and Examples: 1. **Converting Temperatures**: - `temperature_conversion(0, \\"Celsius\\", \\"Kelvin\\")` should return `273.15`. - `temperature_conversion(32, \\"Fahrenheit\\", \\"Celsius\\")` should return `0`. - `temperature_conversion(100, \\"Rankine\\", \\"Kelvin\\")` should return approximately `55.5556`. - `temperature_conversion(80, \\"Réaumur\\", \\"Fahrenheit\\")` should return `212`. 2. **Unit Descriptions**: - `temperature_unit_description(\\"Rankine\\")` should return a string like \\"Rankine: An absolute temperature scale named after William John Macquorn Rankine, primarily used in engineering systems where heat computations are done using Fahrenheit degrees.\\" - `temperature_unit_description(\\"Réaumur\\")` should return a string like \\"Réaumur: A temperature scale named after René Antoine Ferchault de Réaumur, used in some parts of Europe for specialized purposes.\\" # Boilerplate Code ```python def celsius_to_kelvin(c: float) -> float: return c + 273.15 def kelvin_to_celsius(k: float) -> float: return k - 273.15 def celsius_to_fahrenheit(c: float) -> float: return c * 9/5 + 32 def fahrenheit_to_celsius(f: float) -> float: return (f - 32) * 5/9 def rankine_to_kelvin(r: float) -> float: return r * 5/9 def kelvin_to_rankine(k: float) -> float: return k * 9/5 def reaumur_to_celsius(re: float) -> float: return re * 5/4 def celsius_to_reaumur(c: float) -> float: return c * 4/5 TEMPERATURE_CONVERSIONS = { \'Celsius\': {\'Kelvin\': celsius_to_kelvin, \'Fahrenheit\': celsius_to_fahrenheit, \'Réaumur\': celsius_to_reaumur}, \'Kelvin\': {\'Celsius\': kelvin_to_celsius, \'Rankine\': kelvin_to_rankine}, \'Fahrenheit\': {\'Celsius\': fahrenheit_to_celsius}, \'Rankine\': {\'Kelvin\': rankine_to_kelvin}, \'Réaumur\': {\'Celsius\': reaumur_to_celsius} } def temperature_conversion(value: float, from_unit: str, to_unit: str) -> float: if from_unit == to_unit: return value if from_unit in TEMPERATURE_CONVERSIONS and to_unit in TEMPERATURE_CONVERSIONS[from_unit]: return TEMPERATURE_CONVERSIONS[from_unit][to_unit](value) else: intermediate_value = TEMPERATURE_CONVERSIONS[from_unit][list(TEMPERATURE_CONVERSIONS[to_unit].keys())[0]](value) return TEMPERATURE_CONVERSIONS[list(TEMPERATURE_CONVERSIONS[to_unit].keys())[0]][to_unit](intermediate_value) def temperature_unit_description(unit: str) -> str: descriptions = { \'Celsius\': \\"Celsius: A temperature scale used worldwide for weather forecasts and clinical thermometers.\\", \'Kelvin\': \\"Kelvin: An absolute temperature scale used primarily in scientific contexts.\\", \'Fahrenheit\': \\"Fahrenheit: A temperature scale mainly used in the United States for weather forecasts and cooking.\\", \'Rankine\': \\"Rankine: An absolute temperature scale named after William John Macquorn Rankine, primarily used in engineering systems where heat computations are done using Fahrenheit degrees.\\", \'Réaumur\': \\"Réaumur: A temperature scale named after René Antoine Ferchault de Réaumur, used in some parts of Europe for specialized purposes.\\" } if unit not in descriptions: raise ValueError(f\\"Unsupported unit: {unit}. Supported units are: {\', \'.join(descriptions.keys())}\\") return descriptions[unit] # Example usage print(temperature_conversion(100, \'Celsius\', \'Kelvin\')) # 373.15 print(temperature_unit_description(\'Réaumur\')) # Should return the description of Réaumur ``` This question requires adding support for two new temperature units and their descriptions, similar to the original set which involves enhancing a conversion tool with additional units and descriptions.","solution":"def temperature_conversion(value: float, from_unit: str, to_unit: str) -> float: Converts temperature from one unit to another. Supported units: Celsius, Kelvin, Fahrenheit, Rankine, Réaumur. from_to_kelvin = { \\"Celsius\\": lambda v: v + 273.15, \\"Fahrenheit\\": lambda v: (v + 459.67) * 5/9, \\"Kelvin\\": lambda v: v, \\"Rankine\\": lambda v: v * 5/9, \\"Réaumur\\": lambda v: v * 5/4 + 273.15 } kelvin_to = { \\"Celsius\\": lambda v: v - 273.15, \\"Fahrenheit\\": lambda v: v * 9/5 - 459.67, \\"Kelvin\\": lambda v: v, \\"Rankine\\": lambda v: v * 9/5, \\"Réaumur\\": lambda v: (v - 273.15) * 4/5 } if from_unit not in from_to_kelvin or to_unit not in kelvin_to: raise ValueError(f\\"Unsupported units: {from_unit}, {to_unit}\\") kelvin_value = from_to_kelvin[from_unit](value) return kelvin_to[to_unit](kelvin_value) def temperature_unit_description(unit: str) -> str: Provides a detailed description of the specified temperature unit. descriptions = { \\"Celsius\\": \\"Celsius: A temperature scale used worldwide for weather forecasts and clinical thermometers.\\", \\"Kelvin\\": \\"Kelvin: An absolute temperature scale used primarily in scientific contexts. It starts from absolute zero.\\", \\"Fahrenheit\\": \\"Fahrenheit: A temperature scale mainly used in the United States for weather forecasts and cooking.\\", \\"Rankine\\": \\"Rankine: An absolute temperature scale named after William John Macquorn Rankine, primarily used in engineering systems where heat computations are done using Fahrenheit degrees.\\", \\"Réaumur\\": \\"Réaumur: A temperature scale named after René Antoine Ferchault de Réaumur, used in some parts of Europe for specialized purposes.\\" } if unit not in descriptions: raise ValueError(f\\"Unsupported unit: {unit}. Supported units: {\', \'.join(descriptions.keys())}\\") return descriptions[unit]"},{"question":"# Problem Description You are tasked with implementing a function to calculate the sum of the first `n` prime numbers. The function should handle edge cases where `n` is less than or equal to zero by returning an appropriate message. # Function to Implement Write a Python function `sum_first_n_primes(n: int) -> str:` that: 1. Ensures the input value is valid: * `n` should be a positive integer. 2. If the input value is invalid: * Return a specific string message describing the error. 3. If the input is valid: * Compute the sum of the first `n` prime numbers. * Return the sum as a formatted string. # Example ```python def sum_first_n_primes(n: int) -> str: # Your implementation here # Example Usage print(sum_first_n_primes(5)) # Expected: \\"The sum of the first 5 primes is 28\\" print(sum_first_n_primes(0)) # Expected: \\"Error: n should be a positive integer\\" print(sum_first_n_primes(-3)) # Expected: \\"Error: n should be a positive integer\\" ``` # Input * `n` (int): The count of prime numbers to sum, should be a positive integer. # Output * If the input is invalid, the function should return a string in the following format: * \\"Error: n should be a positive integer\\" * If the input is valid, the function should return: * \\"The sum of the first n primes is X\\", where `X` is the computed sum. # Constraints * Edge cases need to be considered. * The function should use an efficient algorithm to determine primes. * Ideally, the implementation should efficiently handle the computation up to at least the 1000th prime number. # Notes * You may use helper functions to check for prime numbers and compute the sum. * Ensure your function handles reasonable ranges for `n` efficiently.","solution":"def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def sum_first_n_primes(n: int) -> str: if n <= 0: return \\"Error: n should be a positive integer\\" count = 0 num = 2 prime_sum = 0 while count < n: if is_prime(num): prime_sum += num count += 1 num += 1 return f\\"The sum of the first {n} primes is {prime_sum}\\""},{"question":"# 2D Array - Find Local Maxima Problem Statement You are given a 2D array of integers where each element represents the elevation at that point. Your task is to identify and return the positions of local maxima. A local maximum is an element that is greater than or equal to all of its 8 neighbors. Requirements 1. **Function name**: `find_local_maxima` - `find_local_maxima(matrix: List[List[int]]) -> List[Tuple[int, int]]` 2. **Input**: - `matrix`: A list of lists of integers representing a 2D elevation map. 3. **Output**: - A list of tuples, each representing the row and column index of a local maximum. Constraints - The dimensions of the matrix will be at most (1000 times 1000). - The integers in the matrix will be within the range [-1000, 1000]. Performance Requirements - The solution should have a time complexity of O(n * m). Example ```python # Given 2D array matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # The local maxima are: # - Element at (2, 2), value = 9 # - Element at (1, 1), value = 5 (central element in this specific case does not qualify; corrected below based on neighbors) # Correct Example assert find_local_maxima(matrix) == [(2, 2)] # Given 2D array with more local maxima matrix = [ [1, 2, 1], [2, 4, 2], [1, 2, 1] ] # The local maxima are: # - Element at (1, 1), value = 4 (central element in 3x3 grid) assert find_local_maxima(matrix) == [(1, 1)] ``` Signature ```python from typing import List, Tuple def find_local_maxima(matrix: List[List[int]]) -> List[Tuple[int, int]]: # Your code here ```","solution":"from typing import List, Tuple def find_local_maxima(matrix: List[List[int]]) -> List[Tuple[int, int]]: if not matrix or not matrix[0]: return [] rows = len(matrix) cols = len(matrix[0]) local_maxima = [] for i in range(rows): for j in range(cols): if is_local_maxima(matrix, i, j, rows, cols): local_maxima.append((i, j)) return local_maxima def is_local_maxima(matrix: List[List[int]], i: int, j: int, rows: int, cols: int) -> bool: directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < rows and 0 <= nj < cols: if matrix[i][j] < matrix[ni][nj]: return False return True"},{"question":"# Longest Consecutive Sequence Objective Given an unsorted array of integers, implement a function to find the length of the longest consecutive sequence of integers in the array. Your algorithm should aim for O(n) complexity. Function Signature ```python def longest_consecutive_sequence(nums: List[int]) -> int: pass ``` Input 1. `nums` (List[int]): A list of integers. Output An integer representing the length of the longest consecutive sequence of integers in the given list. Constraints - The length of the list `nums` does not exceed 10^6. - The integers in `nums` may range from a large negative to a large positive value. - The input list can contain both positive and negative integers, including zero. - There may be duplicates in the list, but they should be ignored while calculating the longest sequence. Performance Requirements - The implementation should aim for linear time complexity, O(n). Scenario Consider a research team analyzing a dataset of temperatures recorded over several days. The researchers are interested in finding the longest streak of consecutive days where the temperature reading appeared in their dataset. Your algorithm will help them determine the length of this longest streak. Example ```python nums = [100, 4, 200, 1, 3, 2] result = longest_consecutive_sequence(nums) # Expected output: # 4 # Explanation: The longest consecutive sequence is [1, 2, 3, 4], which has length 4. ``` ```python nums = [0, -1, 1, 2, 3, -2, 8, 9, 7] result = longest_consecutive_sequence(nums) # Expected output: # 6 # Explanation: The longest consecutive sequence is [-2, -1, 0, 1, 2, 3], which has length 6. ```","solution":"def longest_consecutive_sequence(nums): Finds the length of the longest consecutive sequence of integers in the given list. Time complexity should be O(n). if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: if num - 1 not in num_set: # Check for the start of a sequence current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# Arrange Array into Zigzag Fashion You are tasked with transforming an array of integers into a \\"zigzag\\" pattern. An array is considered to be in zigzag fashion if the following conditions hold true for all elements: - If `i` is even, then `arr[i] <= arr[i+1]` - If `i` is odd, then `arr[i] >= arr[i+1]` Write a function `zigzag(arr: List[int]) -> List[int]` to transform the given array into zigzag fashion, modifying the input array in-place. # Requirements: 1. **Transform** the array such that it fits the zigzag pattern with O(n) time complexity. 2. **Ensure** no element is lost or duplicated in the transformation. 3. **Allow** both positive and negative integers, and handle arrays of various lengths (including empty arrays). # Input and Output Format - The input function takes a single argument: - `arr` - a list of integers. - The function should return the list modified in zigzag fashion. # Example ```python def zigzag(arr: List[int]) -> List[int]: n = len(arr) flag = True for i in range(n-1): if flag: if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] else: if arr[i] < arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] flag = not flag return arr # Test Cases assert zigzag([4, 3, 7, 8, 6, 2, 1]) == [3, 4, 7, 6, 2, 8, 1] assert zigzag([1, 4, 3, 2]) == [1, 4, 2, 3] assert zigzag([-1, -4, -3, -2]) == [-4, -1, -3, -2] assert zigzag([]) == [] assert zigzag([10]) == [10] ``` Provide the complete implementation of the `zigzag` function.","solution":"from typing import List def zigzag(arr: List[int]) -> List[int]: n = len(arr) if n < 2: return arr flag = True for i in range(n-1): if flag: if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] else: if arr[i] < arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] flag = not flag return arr"},{"question":"You are given a binary tree and an integer `target`. Your task is to implement a function that finds the path from the root of the tree to a node whose value matches the `target`. If such a node exists, return the path as a list of node values; otherwise, return an empty list. # Function Signature ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_path(root: TreeNode, target: int) -> list[int]: pass ``` # Input - `root`: The root node of the binary tree. Each node has an integer value, a left child, and a right child. - `target`: An integer value representing the target node\'s value. # Output - Return the path from the root to the target node as a list of integers. If the target value does not exist in the tree, return an empty list. # Constraints 1. You may assume the existence of the TreeNode class as provided. 2. The binary tree can have up to 100,000 nodes. 3. The values of the nodes in the binary tree are unique. 4. The target integer may not exist in the tree. # Examples ```python # Example 1 # Tree representation: # 5 # / # 3 7 # / / # 2 6 8 root = TreeNode(5) root.left = TreeNode(3) root.right = TreeNode(7) root.left.left = TreeNode(2) root.right.left = TreeNode(6) root.right.right = TreeNode(8) assert find_path(root, 6) == [5, 7, 6] assert find_path(root, 4) == [] # Example 2 # Tree representation: # 1 # / # 2 3 # / # 4 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) assert find_path(root, 5) == [1, 2, 5] assert find_path(root, 3) == [1, 3] assert find_path(root, 10) == [] ``` # Additional Notes 1. In the first example, the path to the node with value 6 is [5, 7, 6] and the node with value 4 does not exist in the tree, hence the output is an empty list. 2. In the second example, the path to the node with value 5 is [1, 2, 5] and the path to the node with value 3 is [1, 3]. The node with value 10 does not exist in the tree, so it returns an empty list. 3. Make sure your solution can handle large trees efficiently to meet the constraints.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_path(root: TreeNode, target: int) -> list[int]: def helper(node, path): if not node: return False path.append(node.val) if node.val == target: return True if (helper(node.left, path) or helper(node.right, path)): return True path.pop() return False result = [] if root: helper(root, result) return result"},{"question":"# Coding Assessment Question Scenario A text messaging application needs an enhancement feature to automatically highlight and extract hashtags from a given text message. Hashtags are words or phrases preceded by a \\"#\\" symbol and cannot contain spaces or special characters other than underscores (\\"_\\"). For instance, in the sentence \\"Loving the new features in #Coding_App, can\'t wait to try #Python!\\", the hashtags would be \\"#Coding_App\\" and \\"#Python\\". Task Implement the `extract_hashtags` function that extracts all valid hashtags from a given input string and returns them in a list. The hashtags should maintain their original casing. Requirements - The function should take one input, a string `text`. - The function should return a list of strings, each representing a valid hashtag found in the input string. - If no valid hashtags are found, return an empty list. Input Format: - A single string `text` which may include letters, numbers, spaces, and special characters. Output Format: - A list of strings where each string is a valid hashtag from the input. Constraints: - The length of the input string will be at most ( 10^4 ) characters. - Hashtags can only include alphanumeric characters and underscores following the \\"#\\" symbol. Example: ``` Input: \\"Join our new platform #Tech_Geeks and explore #AI_2023!\\" Output: [\\"#Tech_Geeks\\", \\"#AI_2023\\"] ``` ``` Input: \\"No hashtags here!\\" Output: [] ``` Function Signature: ```python def extract_hashtags(text: str) -> list: pass ``` **Hint**: Consider using regular expressions to detect valid hashtags in the string. Good luck!","solution":"import re def extract_hashtags(text: str) -> list: Extracts all valid hashtags from the given text. Parameters: text (str): The input string containing potential hashtags. Returns: list: A list of valid hashtags found in the input string. # Regular expression to find hashtags hashtag_pattern = r\'#w+\' hashtags = re.findall(hashtag_pattern, text) return hashtags"},{"question":"# Context In computer science, tree traversal refers to the process of visiting each node in a tree data structure, exactly once, in a systematic way. There are various methods for tree traversal including Pre-order, In-order, and Post-order traversal. These methods can be recursively defined or implemented using an iterative approach. A specialized application of tree traversal involves finding the Kth smallest element in a Binary Search Tree (BST). A BST is a node-based binary tree where each node has at most two children, with the left child\'s value being less than the parent\'s value and the right child\'s value being greater than or equal to the parent\'s value. # Task Implement a function `kth_smallest_element` that finds the Kth smallest element in a given BST. 1. **Function Signature**: ```python def kth_smallest_element(root: Optional[TreeNode], k: int) -> int: pass ``` 2. **Parameters**: - `root`: The root node of the binary search tree (BST). - `k`: The number representing the Kth position in the tree when sorted by its elements\' values. 3. **Returns**: - An integer representing the Kth smallest element in the BST. 4. **TreeNode Class Definition**: - A class `TreeNode` where: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Constraints - The BST is guaranteed to have at least `k` nodes. - Node values will be unique integers. # Example Given the BST: ``` 5 / 3 7 / 2 4 8 / 1 ``` For `k = 3`, the function should return `3`, since the sorted order of the tree values is `[1, 2, 3, 4, 5, 7, 8]`, and the 3rd smallest element is `3`. # Hints 1. Perform an in-order traversal of the tree which yields the elements in sorted order. 2. Keep a counter to track the number of elements visited during the traversal. 3. Once the counter equals `k`, return the corresponding node\'s value. # Implementation Details 1. You can use either a recursive or an iterative method to implement the in-order traversal. 2. The function should effectively handle edge cases such as when the tree is very unbalanced.","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest_element(root: Optional[TreeNode], k: int) -> int: Finds the Kth smallest element in a given Binary Search Tree (BST). def inorder_traversal(node): if not node: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) # Perform in-order traversal to get elements in sorted order sorted_elements = inorder_traversal(root) # The kth smallest element is at index k-1 (since k is 1-based) return sorted_elements[k - 1]"},{"question":"# Question: Balanced Bracket Sequences with Minimum Moves Write a function `min_moves_to_balance` that computes the minimum number of moves required to balance a given sequence of brackets. A move is defined as deleting any bracket from the string. Task Your function should ensure that after the minimum number of moves, the sequence of brackets is balanced. A string is said to be balanced if: - Every opening bracket has a corresponding closing bracket. - The brackets are in the correct order. Expected Input and Output Your function should have the following signature: ```python def min_moves_to_balance(bracket_sequence: str) -> int: pass ``` **Input**: - A single string `bracket_sequence`, consisting of characters `(` and `)` only. **Output**: - An integer representing the minimum number of moves required to make the bracket sequence balanced. Constraints * `1 <= len(bracket_sequence) <= 10^5` Performance Requirements Your solution should efficiently compute the minimum number of moves even for large input sizes. # Example ```python bracket_sequence = \\"(()))(\\" # Expected Output: 2 # Explanation: Remove the bracket at indices 4 and 5 to get \\"(()())\\" bracket_sequence = \\"()()()\\" # Expected Output: 0 # Explanation: The sequence is already balanced. bracket_sequence = \\")(\\" # Expected Output: 2 # Explanation: Remove both brackets. ``` Context Balancing bracket sequences is a common problem in parsing and compiling, and optimizing the process has critical applications in syntax checking and error recovery in compilers, interpreters, and even text editors. This exercise will help you understand how to detect and correct imbalances in sequential data efficiently.","solution":"def min_moves_to_balance(bracket_sequence: str) -> int: Returns the minimum number of moves required to balance the given sequence of brackets. Parameters: bracket_sequence (str): A string containing only \'(\' and \')\'. Returns: int: The minimum number of moves (deletions) required to make the bracket sequence balanced. open_count = 0 close_count = 0 # Iterate through each character in the sequence for char in bracket_sequence: if char == \'(\': open_count += 1 else: if open_count > 0: open_count -= 1 else: close_count += 1 # The number of unmatched open brackets + the number of unmatched close brackets return open_count + close_count"},{"question":"Task Write a Python function that calculates the average rating of a product based on its customer reviews. The reviews are stored in a JSON file. Input * The file path to the JSON file containing reviews. * The JSON file structure is a list of dictionaries, where each dictionary represents a review with the keys \\"reviewer\\", \\"review_text\\", and \\"rating\\". Output * A float representing the average rating rounded to two decimal places. Constraints * The \\"rating\\" key in the JSON file is guaranteed to be an integer between 1 and 5. * The function should handle file-related errors such as file not found, and JSON parsing errors gracefully. * If there are no reviews, return a default value of 0.0. Performance * Ensure efficient reading and parsing of the JSON file to handle large datasets. Function Signature ```python def average_rating(file_path: str) -> float: ``` Example ```python # Content of the reviews.json file: # [ # {\\"reviewer\\": \\"Alice\\", \\"review_text\\": \\"Great product!\\", \\"rating\\": 5}, # {\\"reviewer\\": \\"Bob\\", \\"review_text\\": \\"Not bad\\", \\"rating\\": 3}, # {\\"reviewer\\": \\"Charlie\\", \\"review_text\\": \\"Wouldn\'t buy again\\", \\"rating\\": 1} # ] result = average_rating(\\"reviews.json\\") print(result) # Expected output: 3.00 ``` Hint Use Python\'s built-in `json` module to read and parse the JSON file. Also, consider exception handling mechanisms like `try-except` to manage potential file and parsing errors.","solution":"import json def average_rating(file_path: str) -> float: Calculate the average rating from a JSON file containing reviews. Parameters: - file_path (str): The path to the JSON file containing reviews. Returns: - float: The average rating rounded to two decimal places. Returns 0.0 if there are no reviews or if an error occurs. try: with open(file_path, \'r\') as file: reviews = json.load(file) if not reviews: return 0.0 total_rating = sum(review[\'rating\'] for review in reviews) average = total_rating / len(reviews) return round(average, 2) except (FileNotFoundError, json.JSONDecodeError): return 0.0"},{"question":"# Problem Statement You are implementing a text editor feature that involves finding and replacing certain words in a given string. Given a list of words to be replaced and their corresponding replacements, your task is to perform all replacements in the most efficient way possible while preserving the original text\'s structure. # Goal Write a function `replace_words` that takes a string and a dictionary where keys are the words to be replaced, and values are their replacements. The function should return the modified string with all replacements applied. # Function Signature ```python def replace_words(text: str, replacements: dict[str, str]) -> str: ``` # Input - `text`: A string representing the original text in which replacements need to be made. - `replacements`: A dictionary where each key is a word to be replaced and its corresponding value is the new word to be used as replacement. # Output - A string with all the specified words replaced. # Constraints - The input text will only contain alphabetic characters and spaces. - Words in the text are separated by single spaces. - The words to be replaced are case-sensitive. - The length of the text will not exceed 10^4 characters. - The number of keys in the replacements dictionary will not exceed 100. # Examples 1. `replace_words(\\"the quick brown fox jumps over the lazy dog\\", {\\"jumps\\": \\"leaps\\", \\"lazy\\": \\"sleepy\\"})` should return `\\"the quick brown fox leaps over the sleepy dog\\"`. 2. `replace_words(\\"hello world\\", {\\"hello\\": \\"hi\\", \\"world\\": \\"earth\\"})` should return `\\"hi earth\\"`. 3. `replace_words(\\"a quick brown dog jumps over the quick fox\\", {\\"quick\\": \\"fast\\", \\"fox\\": \\"wolf\\"})` should return `\\"a fast brown dog jumps over the fast wolf\\"`. # Notes - The order of replacements in the dictionary can be assumed to not affect the result; you should replace each word independently. - Each word in the text will only match whole words in the replacements dictionary, i.e., substrings will not be matched. # Hints 1. Use the `split` method to break the text into words. 2. Replace words by iterating through the list and using the dictionary for substitutions. 3. Reconstruct the string after performing all necessary replacements.","solution":"def replace_words(text: str, replacements: dict[str, str]) -> str: Replaces words in the input text based on the replacements dictionary. Args: text (str): The input text where words need to be replaced. replacements (dict): A dictionary where keys are the words to be replaced, and values are their replacements. Returns: str: Modified text with all replacements applied. words = text.split() modified_words = [replacements.get(word, word) for word in words] return \' \'.join(modified_words)"},{"question":"# Context A logistics company requires an optimized solution to manage their delivery routes effectively. They need a function that can determine the shortest delivery route passing through all the delivery locations (similar to the Traveling Salesman Problem) but with a constraint that the delivery must start and end at the company\'s depot. # Task Write a function `shortest_delivery_route(depot: tuple, locations: list) -> list` that determines the optimal delivery route starting and ending at the depot while visiting all other delivery locations exactly once. # Input - `depot` (tuple): a tuple of (x, y) coordinates representing the depot\'s location. - `locations` (list): a list of tuples, where each tuple contains (x, y) coordinates of a delivery location. # Output - (list): a list of tuples representing the optimal order of delivery locations starting and ending at the depot. # Constraints - `len(locations) > 0`: there is at least one delivery location. - Locations are represented as 2D coordinates with integer values ranging from -1000 to 1000. # Example ```python >>> depot = (0, 0) >>> locations = [(2, 1), (3, 5), (5, 2)] >>> shortest_delivery_route(depot, locations) [(0, 0), (2, 1), (5, 2), (3, 5), (0, 0)] >>> depot = (5, 5) >>> locations = [(2, 3), (1, 1)] >>> shortest_delivery_route(depot, locations) [(5, 5), (2, 3), (1, 1), (5, 5)] >>> depot = (1, 1) >>> locations = [(2, 2)] >>> shortest_delivery_route(depot, locations) [(1, 1), (2, 2), (1, 1)] ``` # Function Signature ```python def shortest_delivery_route(depot: tuple, locations: list) -> list: pass ``` # Additional Notes - This problem can be approached using algorithms suitable for the Traveling Salesman Problem (TSP) such as dynamic programming, genetic algorithms, or greedy heuristics. - Consider using existing libraries or algorithms for solving TSP to implement the solution efficiently. - The solution must return a reasonable approximation within the bounds given the constraints. - Ensure to account for edge cases such as minimum and maximum number of locations.","solution":"from itertools import permutations def calculate_distance(p1, p2): Calculate the Euclidean distance between two points p1 and p2. return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2) ** 0.5 def shortest_delivery_route(depot, locations): Determines the shortest delivery route starting and ending at the depot while visiting all other delivery locations exactly once. Args: depot (tuple): a tuple of (x, y) coordinates representing the depot\'s location. locations (list): a list of tuples, where each tuple contains (x, y) coordinates of a delivery location. Returns: list: a list of tuples representing the optimal order of delivery locations starting and ending at the depot. all_places = [depot] + locations min_route = None min_distance = float(\'inf\') # Generate all permutations of locations for perm in permutations(locations): # Create the route route = [depot] + list(perm) + [depot] # Calculate the total distance of this route total_distance = 0 for i in range(len(route) - 1): total_distance += calculate_distance(route[i], route[i + 1]) # Check if this route is the shortest one found so far if total_distance < min_distance: min_distance = total_distance min_route = route return min_route"},{"question":"# Problem Statement Your task is to implement a function that determines and returns the first missing positive integer in an unsorted integer array. The function should be optimally efficient. # Input - An unordered list of integers `nums` where `1 <= len(nums) <= 500000` and `-2^31 <= nums[i] <= 2^31 - 1`. # Output - A single integer representing the first missing positive integer from the list. # Constraints - Your solution should have a time complexity of O(n) and use constant extra space. - Avoid using sorting algorithms with higher space complexity. # Example ```python def first_missing_positive(nums: list) -> int: pass # Test cases print(first_missing_positive([3, 4, -1, 1])) # Expected: 2 print(first_missing_positive([1, 2, 0])) # Expected: 3 print(first_missing_positive([7, 8, 9, 11, 12])) # Expected: 1 print(first_missing_positive([1, 2, 3])) # Expected: 4 ``` # Additional Notes - Consider using the array itself to convey presence information of integers within the range. - Ensure your function handles arrays that contain duplicates and negative numbers properly. - Implement and test your function thoroughly to account for edge cases, such as arrays with all negative numbers or arrays already containing consecutive positive numbers starting from 1.","solution":"def first_missing_positive(nums: list) -> int: Returns the first missing positive integer in an unsorted integer array. n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"# Scenario: You have been tasked with developing a utility for processing and summarizing order data for a retail company. Your goal is to create a function that identifies the most popular product category based on the provided purchase records. # Function Specification: You are to implement a function called `most_popular_category` that adheres to the following: Input: - `orders` (list of dictionaries): Each dictionary represents an order and has the following keys: - `order_id` (int): A unique identifier for the order. - `product` (str): The name of the product ordered. - `category` (str): The category to which the product belongs. Output: - Returns a string that represents the most popular category based on the number of orders. If there is a tie, return the lexicographically smallest category. # Constraint: - The `orders` list will always contain at least one order. # Examples: ```python >>> orders = [ ... {\\"order_id\\": 1, \\"product\\": \\"Shampoo\\", \\"category\\": \\"Health\\"}, ... {\\"order_id\\": 2, \\"product\\": \\"Laptop\\", \\"category\\": \\"Electronics\\"}, ... {\\"order_id\\": 3, \\"product\\": \\"Conditioner\\", \\"category\\": \\"Health\\"}, ... {\\"order_id\\": 4, \\"product\\": \\"TV\\", \\"category\\": \\"Electronics\\"}, ... {\\"order_id\\": 5, \\"product\\": \\"Keyboard\\", \\"category\\": \\"Electronics\\"}, ... ] >>> most_popular_category(orders) \'Electronics\' >>> orders = [ ... {\\"order_id\\": 1, \\"product\\": \\"Shampoo\\", \\"category\\": \\"Health\\"}, ... {\\"order_id\\": 2, \\"product\\": \\"Laptop\\", \\"category\\": \\"Electronics\\"}, ... {\\"order_id\\": 3, \\"product\\": \\"Conditioner\\", \\"category\\": \\"Health\\"}, ... ] >>> most_popular_category(orders) \'Health\' >>> orders = [ ... {\\"order_id\\": 1, \\"product\\": \\"Shampoo\\", \\"category\\": \\"Health\\"}, ... {\\"order_id\\": 2, \\"product\\": \\"Laptop\\", \\"category\\": \\"Electronics\\"}, ... ] >>> most_popular_category(orders) \'Electronics\' ``` # Implementation Details: To implement this function, use appropriate data structures to count the number of orders per category. Handle the lexicographical sorting using Python\'s built-in functionalities to determine the correct tie-breaking category.","solution":"def most_popular_category(orders): Identifies the most popular product category based on order data. :param orders: List of dictionaries, where each dictionary contains \'order_id\', \'product\', and \'category\' :type orders: list :return: Most popular category :rtype: str category_count = {} for order in orders: category = order[\'category\'] if category in category_count: category_count[category] += 1 else: category_count[category] = 1 # Find the category with the maximum orders max_count = max(category_count.values()) popular_categories = [category for category, count in category_count.items() if count == max_count] # Return the lexicographically smallest category in case of a tie return min(popular_categories)"},{"question":"# Coding Assessment Question Scenario You\'re developing a matchmaking algorithm for an online game. To optimize the matchmaking process, you need to ensure that players with closer skill levels are matched against each other to ensure balanced gameplay. Task 1. **Function Implementation**: Write a function `find_closest_match` that, given a list of player skill levels and a target player\'s skill level, finds the player with the closest skill level to the target player\'s skill level. 2. **Detailed Steps**: - Define the function `find_closest_match(player_skills: List[int], target_skill: int) -> int`. 3. **Requirements**: * The list `player_skills` contains integer values representing the skill levels of other players. * The function should return the skill level of the player that is closest to the `target_skill`. If there are two players equidistant in skill level, return the lower skill level. 4. **Example**: ```python >>> player_skills = [1500, 1700, 1600, 1800, 2000] >>> target_skill = 1650 >>> closest_match = find_closest_match(player_skills, target_skill) >>> print(closest_match) 1600 ``` Constraints * **Input**: - The list `player_skills` will have at least one skill level. - Skill levels are positive integers. * **Expected Output**: - An integer representing the skill level of the player closest to the target skill level. Performance Requirements * The function should have a time complexity of O(n), where n is the number of player skill levels provided. * The space complexity should be O(1), as only a few variables are used to track the closest match. Additional Notes * Consider edge cases where the list might contain only one skill level or where multiple skill levels are equally close to the target.","solution":"def find_closest_match(player_skills, target_skill): Finds the player with the closest skill level to the target player\'s skill level. Args: player_skills (List[int]): List of skill levels of other players. target_skill (int): Skill level of the target player. Returns: int: Skill level of the player closest to the target skill level. closest_skill = player_skills[0] min_diff = abs(player_skills[0] - target_skill) for skill in player_skills[1:]: diff = abs(skill - target_skill) if diff < min_diff or (diff == min_diff and skill < closest_skill): closest_skill = skill min_diff = diff return closest_skill"},{"question":"# Scenario You are working on a data analysis project and need to write a program that handles statistical calculations. One of the tasks involves calculating the median of a list of numbers that might be very large and can change dynamically. # Task Implement a class `DynamicMedianFinder` that supports dynamic insertion and finding the median of the current list of numbers. # Class Structure ```python class DynamicMedianFinder: def __init__(self): Initializes the data structure. # your code here def add_num(self, num: int) -> None: Adds a number to the data structure. :param num: The number to be added. :return: None # your code here def find_median(self) -> float: Finds the median of the current list of numbers. :return: The median as a float. # your code here ``` # Function Descriptions - `__init__(self)`: Initializes the data structure with no elements. - `add_num(self, num: int) -> None`: Adds a new number to the data structure. - `find_median(self) -> float`: Returns the median of the current list of numbers. If the list has an even number of elements, return the average of the two middle elements. # Input - `num`: An integer to be added to the data structure, where -10^9 ≤ num ≤ 10^9. - The `find_median` method can be called at any point after the initialization and after any number of calls to the `add_num` method. # Output - `find_median` should return a float representing the median. # Constraints - The number of calls to `add_num` and `find_median` will be at most 10^5. # Performance Requirements - Implement an efficient approach, ideally O(log n) time complexity for each insertion and O(1) time complexity for finding the median. # Example ```python mf = DynamicMedianFinder() mf.add_num(1) mf.add_num(2) print(mf.find_median()) # Output: 1.5 mf.add_num(3) print(mf.find_median()) # Output: 2.0 ``` # Notes - Consider using two heaps (a max-heap for the lower half and a min-heap for the upper half) to maintain the median dynamically. - Make sure to handle edge cases such as adding a very large or small number and frequently finding the median.","solution":"import heapq class DynamicMedianFinder: def __init__(self): self.lower_half = [] # Max-heap for the lower half self.upper_half = [] # Min-heap for the upper half def add_num(self, num: int) -> None: if not self.lower_half or num <= -self.lower_half[0]: heapq.heappush(self.lower_half, -num) else: heapq.heappush(self.upper_half, num) # Balance the heaps if len(self.lower_half) > len(self.upper_half) + 1: heapq.heappush(self.upper_half, -heapq.heappop(self.lower_half)) elif len(self.upper_half) > len(self.lower_half): heapq.heappush(self.lower_half, -heapq.heappop(self.upper_half)) def find_median(self) -> float: if len(self.lower_half) > len(self.upper_half): return float(-self.lower_half[0]) else: return (-self.lower_half[0] + self.upper_half[0]) / 2.0"},{"question":"# Coding Question Problem Statement You are provided with a function `reverse_and_sort` that takes a list of integers and performs two operations: reverses the order of the elements and then sorts the reversed list. However, the implementation has performance issues and can be optimized. Write a function `optimized_reverse_and_sort` that accomplishes the same task more efficiently. Input - A list of integers `arr` (0 <= len(arr) <= 10^6), where each integer `x` satisfies (-10^9 <= x <= 10^9). Output - A list of integers, which is the sorted version of the reversed input list. Constraints - Your solution should handle the edge cases efficiently, including very large lists and negative numbers. Performance Requirement - The runtime complexity of your solution should be O(n log n), where `n` is the length of the input list. Examples 1. `optimized_reverse_and_sort([3, 1, 4, 1, 5, 9, 2, 6])` should return `[1, 1, 2, 3, 4, 5, 6, 9]`. 2. `optimized_reverse_and_sort([5, -1, -10, 8, 0])` should return `[-10, -1, 0, 5, 8]`. 3. `optimized_reverse_and_sort([])` should return `[]`. Function Signature ```python def optimized_reverse_and_sort(arr: list) -> list: Returns the sorted version of the reversed input list. pass ``` Additional Notes - There\'s no need to explicitly reverse the list before sorting; you can directly sort the list which will handle the reversed order\'s sorting inherently.","solution":"def optimized_reverse_and_sort(arr: list) -> list: Returns the sorted version of the reversed input list. # Sorting the array, which inherently handles the order return sorted(arr)"},{"question":"# K-Means Clustering Implementation and Cluster Visualization Context You are working as a data scientist for a retail company. Your task is to segment customers based on their purchasing behaviors to identify distinct customer clusters. To achieve this, you decide to use the K-Means clustering algorithm. Objective Implement a K-Means clustering algorithm from scratch and visualize the resulting clusters. Customize the model to include random initialization of centroids and a maximum number of iterations for optimization. Input Format 1. A matrix `points` of shape (n, d) representing n data points with d dimensions each. 2. Number of clusters `k` (integer). 3. Maximum iterations `max_iters` (integer) for the K-Means algorithm. 4. Seed for random initialization `random_seed` (integer). Output Format 1. A vector `cluster_labels` of shape (n,) assigning each data point to one of the k clusters (0 to k-1). 2. A plot visualizing the resulting clusters along with their centroids. Constraints 1. Number of dimensions `d` should be ≥ 2 and ≤ 10. 2. Number of data points `n` should be ≥ 50 and ≤ 5000. 3. The range for `k`, `max_iters`, and `random_seed` will be provided to ensure proper initialization and iteration. # Function Signature ```python def k_means_clustering(points: np.ndarray, k: int, max_iters: int, random_seed: int) -> np.ndarray: pass ``` # Example ```python import numpy as np import matplotlib.pyplot as plt points = np.array([[1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], [1.0, 0.6], [9.0, 11.0], [8.0, 2.0], [10.0, 2.0]]) k = 3 max_iters = 100 random_seed = 42 cluster_labels = k_means_clustering(points, k, max_iters, random_seed) print(\\"Cluster labels:\\", cluster_labels) # Visualize the clustering def plot_clusters(points, centroids, cluster_labels, k): plt.figure(figsize=(8, 6)) for i in range(k): cluster_points = points[cluster_labels == i] plt.scatter(cluster_points[:, 0], cluster_points[:, 1], s=50, label=f\'Cluster {i}\') plt.scatter(centroids[:, 0], centroids[:, 1], s=200, c=\'red\', label=\'Centroids\', marker=\'X\') plt.legend() plt.show() # Assume `centroids` were returned along with cluster_labels (for visualization) centroids = np.array([[1.0, 1.5], [8.5, 9.0], [9.0, 2.0]]) plot_clusters(points, centroids, cluster_labels, k) ``` In this example, the function `k_means_clustering` should output the cluster labels for each data point based on their assigned cluster. # Requirements Implement the core operational steps for K-Means clustering: 1. Initialize centroids randomly from the data points. 2. Assign each data point to the nearest centroid. 3. Recompute centroids as the mean of all points assigned to each cluster. 4. Repeat the process for a specified number of iterations or until convergence. 5. Visualize the clustered points and centroids using a plot. Good luck!","solution":"import numpy as np import matplotlib.pyplot as plt def initialize_centroids(points, k, random_seed): np.random.seed(random_seed) random_indices = np.random.choice(points.shape[0], k, replace=False) centroids = points[random_indices] return centroids def closest_centroid(points, centroids): distances = np.sqrt(((points - centroids[:, np.newaxis])**2).sum(axis=2)) return np.argmin(distances, axis=0) def move_centroids(points, closest, k): return np.array([points[closest==k].mean(axis=0) for k in range(k)]) def k_means_clustering(points: np.ndarray, k: int, max_iters: int, random_seed: int): centroids = initialize_centroids(points, k, random_seed) for _ in range(max_iters): closest = closest_centroid(points, centroids) new_centroids = move_centroids(points, closest, k) if np.all(centroids == new_centroids): break centroids = new_centroids return closest, centroids def plot_clusters(points, centroids, cluster_labels, k): plt.figure(figsize=(8, 6)) for i in range(k): cluster_points = points[cluster_labels == i] plt.scatter(cluster_points[:, 0], cluster_points[:, 1], s=50, label=f\'Cluster {i}\') plt.scatter(centroids[:, 0], centroids[:, 1], s=200, c=\'red\', label=\'Centroids\', marker=\'X\') plt.legend() plt.show()"},{"question":"# Context You are working on a project that involves managing an inventory system for an online store. Each product in the store has a unique ID, a price, and a quantity in stock. You need to implement a function that helps in replenishing the stock of products when their quantities fall below a specified threshold. # Task Implement a function `replenish_inventory(products: dict, threshold: int, replenish_amount: int) -> dict` that checks each product\'s quantity in the stock and replenishes those that fall below the threshold with a specified amount. The function should return the updated inventory. # Input and Output * **Input**: * `products` (dict): A dictionary where keys are product IDs (strings) and values are tuples containing the price (float) of the product and the quantity (int) in stock. * `threshold` (int): An integer indicating the minimum quantity threshold. * `replenish_amount` (int): An integer indicating the amount of stock to add to each product that falls below the threshold. * **Output**: * A dictionary with updated quantities for products that were below the threshold. # Constraints * All product IDs will be unique. * Prices will be positive floating-point numbers. * Quantities and thresholds will be non-negative integers. # Example ```python inventory = { \\"P001\\": (25.99, 5), \\"P002\\": (13.50, 2), \\"P003\\": (7.75, 0), \\"P004\\": (15.00, 10) } print(replenish_inventory(inventory, 3, 5)) # Expected Output: # { # \'P001\': (25.99, 10), # Replenished # \'P002\': (13.50, 7), # Replenished # \'P003\': (7.75, 5), # Replenished # \'P004\': (15.00, 10) # Not replenished # } print(replenish_inventory(inventory, 5, 10)) # Expected Output: # { # \'P001\': (25.99, 15), # Replenished # \'P002\': (13.50, 12), # Replenished # \'P003\': (7.75, 10), # Replenished # \'P004\': (15.00, 10) # Not replenished # } ``` # Performance Requirements The function should be designed to handle up to 1,000,000 products efficiently. # Note You do not need to handle input validation. Assume all input provided will be valid according to the constraints.","solution":"def replenish_inventory(products: dict, threshold: int, replenish_amount: int) -> dict: Replenishes the stock of products that fall below a specified threshold. Args: products (dict): Dicitionary where keys are product IDs and values are tuples of (price, quantity). threshold (int): The minimum quantity threshold. replenish_amount (int): The amount of stock to add to each product that falls below the threshold. Returns: dict: Updated inventory with replenished quantities for products that were below the threshold. updated_inventory = {} for product_id, (price, quantity) in products.items(): if quantity < threshold: updated_quantity = quantity + replenish_amount else: updated_quantity = quantity updated_inventory[product_id] = (price, updated_quantity) return updated_inventory"},{"question":"# Coding Assessment Question Scenario You are developing a software module for a content management system that handles hierarchical data structures, like file directories and their contents. The system must be able to manage and retrieve files quickly based on their paths. Task Implement a function `add_file` that, given an initial directory structure and a file path, adds the specified file to the directory structure. Additionally, implement a function `find_file` that, given a file path, retrieves the file if it exists in the directory structure. Function Signatures ```python def add_file(directory: dict, file_path: str) -> None: def find_file(directory: dict, file_path: str) -> bool: ``` Input for `add_file` * `directory (dict)`: A dictionary representing the current state of the directory. * `file_path (str)`: The full path of the file to be added, where directories are separated by \'/\'. Output for `add_file` * Adds the file to the directory structure. If the file already exists, it does nothing. Input for `find_file` * `directory (dict)`: A dictionary representing the current state of the directory. * `file_path (str)`: The full path of the file to be retrieved, where directories are separated by \'/\'. Output for `find_file` * Returns `True` if the file exists in the directory structure, otherwise `False`. Constraints * The `directory` is guaranteed to be a valid dictionary representing the directory structure. * Paths are provided as strings with directories separated by \'/\' and always starting from the root. Example ```python Initial directory structure: root = {} add_file(root, \\"home/user/documents/report.txt\\") add_file(root, \\"home/user/photos/vacation/photo1.jpg\\") The function call find_file(root, \\"home/user/documents/report.txt\\") should return True. The function call find_file(root, \\"home/user/music/album/song.mp3\\") should return False. root = {} add_file(root, \\"home/user/documents/report.txt\\") add_file(root, \\"home/user/photos/vacation/photo1.jpg\\") exists = find_file(root, \\"home/user/documents/report.txt\\") print(exists) # Output should be True not_exists = find_file(root, \\"home/user/music/album/song.mp3\\") print(not_exists) # Output should be False ``` Notes * Focus on designing efficient and clean functions to manage the directory structure. * Ensure to handle potential edge cases such as empty paths or trying to add files to non-existent directories.","solution":"def add_file(directory, file_path): Adds a file to the directory structure given its file path. parts = file_path.split(\'/\') current = directory for part in parts[:-1]: if part not in current: current[part] = {} current = current[part] # Add the file as a key with None value in the specific directory if parts[-1] not in current: current[parts[-1]] = None def find_file(directory, file_path): Finds if a file exists in the directory structure given its file path. parts = file_path.split(\'/\') current = directory for part in parts: if part in current: current = current[part] else: return False return True"},{"question":"# Tic-Tac-Toe Winner Determination Context: Tic-Tac-Toe is a classic two-player game where players alternately mark \'X\' or \'O\' in a 3x3 grid. The winner is the first player to align three of their marks horizontally, vertically, or diagonally. Task: Implement a function `determine_winner(board: List[List[str]]) -> str` that determines the winner of a Tic-Tac-Toe game or identifies if the game is a tie. Requirements: 1. **Function Definition** - Define the function `determine_winner(board: List[List[str]]) -> str`. - The function accepts a 3x3 list of lists representing the Tic-Tac-Toe board. Each cell contains either \'X\', \'O\', or an empty string \'\'. 2. **Winning Condition** - Check all possible ways to win the game: rows, columns, and diagonals. - If \'X\' wins, return \\"X\\". - If \'O\' wins, return \\"O\\". - If neither player wins and there are no empty cells, return \\"Tie\\". - If the game is still ongoing (i.e., there are empty cells but no winner yet), return \\"Pending\\". 3. **Edge Cases Handling** - Handle edge cases like all cells being empty, one move made, and scenarios with no winner. Input/Output: - **Input**: ``` [ [\\"X\\", \\"O\\", \\"X\\"], [\\"O\\", \\"X\\", \\"O\\"], [\\"O\\", \\"X\\", \\"X\\"] ] ``` - **Output**: ``` \\"X\\" ``` Constraints: - The board is always a 3x3 grid. - The input is guaranteed to contain only valid characters: \'X\', \'O\', or \'\'. Example Usage: ```python >>> board = [ ... [\\"X\\", \\"O\\", \\"X\\"], ... [\\"O\\", \\"X\\", \\"O\\"], ... [\\"O\\", \\"X\\", \\"X\\"] ...] >>> determine_winner(board) \'X\' >>> board = [ ... [\\"O\\", \\"X\\", \\"X\\"], ... [\\"X\\", \\"O\\", \\"O\\"], ... [\\"X\\", \\"O\\", \\"X\\"] ...] >>> determine_winner(board) \'Tie\' >>> board = [ ... [\\"X\\", \\"O\\", \\"\\"], ... [\\"O\\", \\"X\\", \\"\\"], ... [\\"O\\", \\"\\", \\"\\"] ...] >>> determine_winner(board) \'Pending\' ```","solution":"def determine_winner(board): Determines the winner of a Tic-Tac-Toe game or identifies if the game is a tie or still pending. Args: board (List[List[str]]): A 3x3 list of lists representing the Tic-Tac-Toe board. Returns: str: \\"X\\" if X wins, \\"O\\" if O wins, \\"Tie\\" if the game is a tie, \\"Pending\\" if the game is still ongoing. # Check rows and columns for a winner for i in range(3): if board[i][0] == board[i][1] == board[i][2] and board[i][0] != \'\': return board[i][0] if board[0][i] == board[1][i] == board[2][i] and board[0][i] != \'\': return board[0][i] # Check diagonals for a winner if board[0][0] == board[1][1] == board[2][2] and board[0][0] != \'\': return board[0][0] if board[0][2] == board[1][1] == board[2][0] and board[0][2] != \'\': return board[0][2] # Check for any empty cell to determine if the game is still pending for row in board: if \'\' in row: return \\"Pending\\" # If no winner and no empty cell, it\'s a tie return \\"Tie\\""},{"question":"# Find the K-th Smallest Element in a BST Scenario You are developing software for efficient data retrieval from a binary search tree (BST). One common task is to find the k-th smallest element in the BST. Task Write a function `kth_smallest_element(root: Node, k: int) -> float` that takes the root of a binary tree and an integer `k`, returning the k-th smallest element in the binary search tree (BST). Input The function will receive the following parameters: - `root`: a `Node` instance where `Node` is defined as follows: ```python @dataclass class Node: data: float left: Node | None = None right: Node | None = None ``` - `k`: an integer representing the position of the smallest element to find (1 <= k <= total number of nodes in the BST). Output The function should return the k-th smallest element in the BST as a float. Constraints - Nodes contain numerical values (int or float). - The BST can contain negative numbers. - Assume no two nodes have the same value. - The value of `k` is always valid with respect to the number of nodes in the tree. Example ```python # Example BST root = Node(data=3) root.left = Node(data=1) root.right = Node(data=4) root.left.right = Node(data=2) kth_smallest_element(root, 1) # Output: 1.0 kth_smallest_element(root, 3) # Output: 3.0 ``` # Additional Notes - Consider utilizing the BST properties to optimize the retrieval process. - Avoid unnecessary space complexity and ensure efficient traversal of the tree. - Handle edge cases like an empty tree or cases where k matches the number of nodes.","solution":"from dataclasses import dataclass @dataclass class Node: data: float left: \'Node\' = None right: \'Node\' = None def kth_smallest_element(root: Node, k: int) -> float: # In-order traversal of the tree yields elements in sorted order for a BST def inorder_traversal(node: Node): if not node: return [] # Traverse the left subtree, the node itself, and then the right subtree return inorder_traversal(node.left) + [node.data] + inorder_traversal(node.right) sorted_elements = inorder_traversal(root) return sorted_elements[k - 1]"},{"question":"# Problem Statement You are asked to write a function that identifies and returns the nth ugly number. Ugly numbers are positive integers whose prime factors are limited to 2, 3, and 5. The sequence of ugly numbers starts with 1. Specifically, the first 10 ugly numbers are 1, 2, 3, 4, 5, 6, 8, 9, 10, and 12. # Function Signature ```python def nth_ugly_number(n: int) -> int: # Your code here ``` # Input * `n` (int): The position (1-indexed) of the ugly number you need to find. (1 ≤ n ≤ 10^4) # Output * `int`: The nth ugly number. # Constraints * The function should handle values of `n` efficiently considering the constraints. # Example ```python >>> nth_ugly_number(1) 1 >>> nth_ugly_number(10) 12 >>> nth_ugly_number(15) 24 >>> nth_ugly_number(150) 5832 ``` # Additional Notes * Generate the sequence of ugly numbers up to the nth position using a dynamic programming or min-heap based approach. * Consider edge cases, like when `n` is at its minimum or maximum constraint. * Ensure that the solution is optimized for both time and space complexity.","solution":"def nth_ugly_number(n: int) -> int: # Array to store ugly numbers ugly_numbers = [0] * n ugly_numbers[0] = 1 # Initial positions for multiples of 2, 3, and 5 i2, i3, i5 = 0, 0, 0 # Initial multiples of 2, 3, and 5 next_2, next_3, next_5 = 2, 3, 5 for i in range(1, n): next_ugly = min(next_2, next_3, next_5) ugly_numbers[i] = next_ugly if next_ugly == next_2: i2 += 1 next_2 = ugly_numbers[i2] * 2 if next_ugly == next_3: i3 += 1 next_3 = ugly_numbers[i3] * 3 if next_ugly == next_5: i5 += 1 next_5 = ugly_numbers[i5] * 5 return ugly_numbers[n - 1]"},{"question":"# Implementing a Basic Finite Automaton for Pattern Matching Scenario You\'re working on a text processing tool, and you need a solution to quickly find occurrences of a pattern in a given text. To achieve this, you plan to implement a finite automaton-based approach for pattern matching. Objective * **Implement**: Implement a Finite Automaton class to search for occurrences of a pattern in a text. * **Test**: Write test cases to ensure your implementation is correct. # Requirements `FiniteAutomaton` Class 1. **Init method**: Initialize the class with a string pattern. ```python def __init__(self, pattern: str): pass ``` 2. **Build method**: Implement a method to build the finite automaton transitions for the input pattern. ```python def build_finite_automaton(self): pass ``` 3. **Search method**: Implement a method to search for occurrences of the pattern within a text using the finite automaton. ```python def search(self, text: str) -> list: pass ``` # Example Usage ```python # Initialize with a pattern pattern = \\"abc\\" finite_automaton = FiniteAutomaton(pattern) finite_automaton.build_finite_automaton() # Search for pattern occurrences in a text assert finite_automaton.search(\\"abcabcabc\\") == [0, 3, 6] assert finite_automaton.search(\\"aabcabc\\") == [1, 4] assert finite_automaton.search(\\"bacbacabac\\") == [] assert finite_automaton.search(\\"abc\\") == [0] assert finite_automaton.search(\\"\\") == [] assert finite_automaton.search(\\"acbdabcacab\\") == [5] # Ensure pattern occurs correctly in boundary cases assert finite_automaton.search(\\"ababcabc\\") == [2, 5] ``` # Constraints * 1 ≤ len(pattern) ≤ 1000 * 0 ≤ len(text) ≤ 10^6 * Both text and pattern contain only lowercase English letters # Performance Requirements Your solution must: * Build the finite automaton in linear time relative to the length of the pattern, O(m). * Search for pattern occurrences in linear time relative to the length of the text, O(n). # Instructions 1. Implement the class and its methods as described. 2. Create a suite of test cases to verify the correctness of your implementation. 3. Ensure your implementation is efficient and can handle edge cases.","solution":"class FiniteAutomaton: def __init__(self, pattern: str): self.pattern = pattern self.transition_table = [] self.build_finite_automaton() def build_finite_automaton(self): m = len(self.pattern) alphabet = set(self.pattern) self.transition_table = [{} for _ in range(m + 1)] for state in range(m + 1): for char in alphabet: next_state = self._next_state(state, char) self.transition_table[state][char] = next_state def _next_state(self, state, char): if state < len(self.pattern) and char == self.pattern[state]: return state + 1 for ns in range(state, 0, -1): if self.pattern[ns - 1] == char: if self.pattern[:ns - 1] == self.pattern[state - ns + 1:state]: return ns return 0 def search(self, text: str) -> list: n, m = len(text), len(self.pattern) state = 0 occurrences = [] for i in range(n): state = self.transition_table[state].get(text[i], 0) if state == m: occurrences.append(i - m + 1) return occurrences"},{"question":"# Analyze Network Packet Origins You have been tasked with writing a function that simulates the analysis of network packet origins to identify the first packet that arrives from a different country than the previous packet. Assume you have a stream of network packets, each with an associated timestamp and originating country. The packets arrive sequentially, and you are to determine the first packet in the stream that arrives from a different country compared to the previous packet. Write a function `first_different_origin` that takes a list of tuples where each tuple contains a timestamp (integer) and a country code (string). Function Signature: ```python def first_different_origin(packets: list[tuple[int, str]]) -> tuple[int, str]: pass ``` # Requirements: - **Input**: A list of tuples with each tuple containing: - An integer timestamp in non-decreasing order. - A string representing the 2-letter country code according to ISO 3166-1 alpha-2. - **Output**: The tuple containing the timestamp and country code of the first packet that arrives from a different country than the previous packet. # Constraints: - The input list will contain at least two packets. - Country codes are guaranteed to follow the ISO 3166-1 alpha-2 standard. - The timestamp for each packet is guaranteed to be unique and in non-decreasing order. - The list will contain no more than 100,000 packets. # Example Usage: ```python packets = [ (1, \\"US\\"), (2, \\"US\\"), (3, \\"CA\\"), (4, \\"CA\\"), (5, \\"MX\\") ] print(first_different_origin(packets)) # Expected: (3, \\"CA\\") packets = [ (10, \\"DE\\"), (20, \\"DE\\"), (30, \\"JP\\") ] print(first_different_origin(packets)) # Expected: (30, \\"JP\\") packets = [ (5, \\"FR\\"), (10, \\"FR\\"), (15, \\"FR\\"), (20, \\"CN\\") ] print(first_different_origin(packets)) # Expected: (20, \\"CN\\") ``` # Detailed Explanation of Concepts: - **Sequential Processing**: Iterate through the list of tuples and compare the country code of the current packet with the previous packet. - **Tuple Access**: Efficiently access elements of the tuple for comparison. - **Early Termination**: Stop as soon as the first packet from a different country is found for optimized performance. - **Edge Case Handling**: Ensure correct output even if the first packet itself is from a different country compared to a hypothetical initial state. Focus on writing robust, efficient, and well-documented code that handles sequential packet analysis while ensuring performance considerations for large datasets.","solution":"def first_different_origin(packets: list[tuple[int, str]]) -> tuple[int, str]: Given a list of network packets with timestamp and country code, identifies the first packet that arrives from a different country than the previous packet. Parameters: packets (list[tuple[int, str]]): A list of tuples, where each tuple contains an integer timestamp and a string country code. Returns: tuple[int, str]: The tuple containing the timestamp and country code of the first packet with a different origin. prev_country = packets[0][1] for packet in packets[1:]: if packet[1] != prev_country: return packet prev_country = packet[1] return None # This line should ideally never be reached given the problem constraints."},{"question":"# Question Context: In the world of competitive programming, efficiently managing and modifying collections of data is a common task. This exercise will test your ability to implement and utilize a frequently used data structure in solving such problems. Problem Statement: Define a class `CustomList` that supports efficient insertion, deletion, and sum calculation of its elements. The class should provide the following methods: 1. `insert(element: int) -> None`: Insert an element to the list. 2. `remove(element: int) -> bool`: Remove an element from the list. Returns `True` if the element was found and removed, `False` otherwise. 3. `sum_elements() -> int`: Calculate and return the sum of the elements in the list. Class Signature: ```python class CustomList: def __init__(self): self.elements = [] def insert(self, element: int) -> None: pass def remove(self, element: int) -> bool: pass def sum_elements(self) -> int: pass ``` Constraints: 1. The elements are integers within the range of -10^6 to 10^6. 2. The list can have up to 10^5 elements at any point in time. 3. The sum of elements or individual elements will not exceed the range of 64-bit signed integer (i.e., -2^63 to 2^63-1). Example Usage: ```python custom_list = CustomList() custom_list.insert(1) custom_list.insert(2) custom_list.insert(3) assert custom_list.sum_elements() == 6 assert custom_list.remove(2) == True assert custom_list.sum_elements() == 4 assert custom_list.remove(2) == False assert custom_list.sum_elements() == 4 ``` Additional Context: Consider the efficiency of your implementation regarding the data structure chosen for the list and the operations performed on it. Since insertion and deletion can occur frequently, think about how to maintain optimal time complexity for these methods.","solution":"class CustomList: def __init__(self): self.elements = [] self.total_sum = 0 def insert(self, element: int) -> None: self.elements.append(element) self.total_sum += element def remove(self, element: int) -> bool: if element in self.elements: self.elements.remove(element) self.total_sum -= element return True return False def sum_elements(self) -> int: return self.total_sum"},{"question":"# Problem Statement You are on a journey to collect fruits from several farms located along a straight path. You start your journey with two empty baskets and a goal to collect the maximum number of fruits. There are `n` farms, and each farm `i` grows a different type of fruit `fruits[i]`. You can move in either direction along the path and you can only carry up to two different types of fruits at any time. Write a function `max_fruit_collected(fruits: List[int]) -> int` that returns the maximum number of fruits you can collect. **Constraints**: 1. `1 <= n <= 100000` 2. `1 <= fruits.length <= 100000` **Input**: - `fruits`: List of integers representing the types of fruits at each farm. **Output**: - An integer representing the maximum number of fruits you can collect with up to two different types of fruits at any point. **Example**: ```python # Example 1 fruits = [1, 2, 1] assert max_fruit_collected(fruits) == 3 # Example 2 fruits = [0, 1, 2, 2] assert max_fruit_collected(fruits) == 3 # Example 3 fruits = [1, 2, 3, 2, 2] assert max_fruit_collected(fruits) == 4 # Example 4 fruits = [3, 3, 3, 1, 2, 1, 1, 2, 3, 3, 4] assert max_fruit_collected(fruits) == 5 ``` **Explanation**: - In the first example, you can collect all fruits because there are only two types of fruits (1 and 2). - In the second example, you can collect up to the second type of fruit (2), from index 1 to 3. - In the third example, starting from index 1 to 4 allows you to collect the maximum fruits, up to four. - In the fourth example, you can collect fruits between index 3 to 7 (1, 2, 1, 1, 2) for a maximum of five fruits. # Solution Approach This problem can be efficiently solved using the sliding window technique. This allows you to adjust the range of farms considered while keeping track of the types of fruits collected within the current window.","solution":"from collections import defaultdict def max_fruit_collected(fruits): Returns the maximum number of fruits collected with up to two different types of fruits at any point. basket = defaultdict(int) left = 0 max_fruits = 0 for right in range(len(fruits)): basket[fruits[right]] += 1 while len(basket) > 2: basket[fruits[left]] -= 1 if basket[fruits[left]] == 0: del basket[fruits[left]] left += 1 max_fruits = max(max_fruits, right - left + 1) return max_fruits"},{"question":"**Scenario**: You are given a list of words and a single string `s`. Your task is to determine if `s` can be formed by concatenating words from the given list any number of times. Each word can be used any number of times in the concatenation. **Instructions**: - Implement the `WordBreakChecker` class as described. - The `add_word` method should add a word to the list. - The `can_form` method should return `True` if `s` can be formed using the words from the list, otherwise return `False`. **Function Signature**: The function signatures should be as follows: ```python class WordBreakChecker: def __init__(self): # Initialization code goes here def add_word(self, word: str): # Code to add word to the list goes here def can_form(self, s: str) -> bool: # Code to determine if s can be formed ``` # Expected Input and Output **Input**: - `words` (List[str]): List of words. - `s` (str): String to be checked. **Output**: - `can_form` method should return `True` if string `s` can be formed using words in the list, otherwise `False`. # Sample Input: ```python words = [\\"apple\\", \\"pen\\", \\"applepen\\"] s = \\"applepenapple\\" checker = WordBreakChecker() for word in words: checker.add_word(word) print(checker.can_form(s)) # Output should be True words = [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"] s = \\"catsandog\\" checker = WordBreakChecker() for word in words: checker.add_word(word) print(checker.can_form(s)) # Output should be False ``` **Constraints**: - Each word within the range of `1 to 1000` characters. - The length of string `s` within the range `1 to 1000`. - The number of words is `1 <= words.length <= 1000`. **Performance Requirements**: The solution should efficiently handle the problem within the constraints using a dynamic programming approach.","solution":"class WordBreakChecker: def __init__(self): self.word_set = set() def add_word(self, word: str): self.word_set.add(word) def can_form(self, s: str) -> bool: dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in self.word_set: dp[i] = True break return dp[len(s)]"},{"question":"# Question: Detecting Cycles in a Directed Graph Given a directed graph represented as an adjacency list, write a Python function to detect if there are any cycles in the graph. The function should return a boolean value indicating the presence of a cycle. Function Signature: ```python def has_cycle(graph: dict) -> bool: ``` # Input - `graph`: A dictionary where keys are vertices and values are lists of adjacent vertices. The graph is directed, so if vertex `u` has a directed edge to vertex `v`, then `v` should be in the adjacency list of `u`. # Output - Return `True` if there is at least one cycle in the graph, otherwise return `False`. # Constraints - The number of vertices will not exceed `1000`. - The vertices are labeled with integers starting from `0`. # Example ```python graph1 = {0: [1], 1: [2], 2: [0]} assert has_cycle(graph1) == True graph2 = {0: [1, 2], 1: [2], 2: [3], 3: []} assert has_cycle(graph2) == False graph3 = {0: [1], 1: [2], 2: [3], 3: [1]} assert has_cycle(graph3) == True ``` # Notes - Ensure that your solution can handle graphs with isolated nodes. - Test with directed graphs of varying structure and complexity to validate correctness. - You may use Depth-First Search (DFS) or other graph traversal algorithms to detect cycles in the graph. - Consider edge cases such as graphs that contain self-loops or vertices with no outgoing edges.","solution":"def has_cycle(graph: dict) -> bool: Detect if a directed graph has a cycle. Args: - graph (dict): A dictionary representing a directed graph with keys as vertices and values as lists of adjacent vertices. Returns: - bool: True if there is a cycle in the graph, False otherwise. def dfs(vertex): # Recursively perform depth first search if vertex in visiting: return True if vertex in visited: return False visiting.add(vertex) for neighbor in graph.get(vertex, []): if dfs(neighbor): return True visiting.remove(vertex) visited.add(vertex) return False visited = set() visiting = set() for v in graph: if dfs(v): return True return False"},{"question":"# Problem Statement You are given a grid of size M x N representing a farm. Each cell in the grid either contains a tree (\'T\') or is empty (\'.\'). The trees are planted such that they form rectangular forest patches. Your task is to count the number of distinct forest patches on the farm. # Input * An integer M (1 <= M <= 100) representing the number of rows. * An integer N (1 <= N <= 100) representing the number of columns. * A list of M strings of length N where each character is either \'T\' (tree) or \'.\' (empty cell). # Output * An integer representing the number of distinct forest patches. # Example ```python Input M = 4 N = 5 grid = [ \'TT..T\', \'TT..T\', \'.....\', \'..TTT\' ] Output 3 ``` # Explanation There are three distinct forest patches in the grid: 1. The first two rows and the first two columns form one rectangular patch. 2. The first and last columns on the first two rows form the second patch. 3. The last row and the last three columns form the third rectgular patch. # Function Signature ```python def count_forest_patches(M: int, N: int, grid: [str]) -> int: # Implement your solution here ``` # Notes 1. Ensure the implementation can handle grids of varying sizes and configurations effectively. 2. Consider edge cases such as multiple isolated trees or no trees at all. This new question integrates seamlessly with the given sample question, maintaining consistency in style, complexity, and format.","solution":"def count_forest_patches(M: int, N: int, grid: [str]) -> int: Returns the number of distinct forest patches in the farm grid. def dfs(x, y): # Use DFS to visited all contiguous \'T\' cells if x < 0 or x >= M or y < 0 or y >= N or grid[x][y] != \'T\' or visited[x][y]: return visited[x][y] = True dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) visited = [[False] * N for _ in range(M)] forest_patches_count = 0 for i in range(M): for j in range(N): if grid[i][j] == \'T\' and not visited[i][j]: # a new forest patch found, begin DFS forest_patches_count += 1 dfs(i, j) return forest_patches_count"},{"question":"# Problem Description Write a function that takes as input an array of integers and returns an array where each element is replaced by the product of all the other elements in the original array, without using division. # Function Signature ```python def product_except_self(nums: List[int]) -> List[int]: ``` # Input - `nums`: A list of integers where each integer is not zero and the list contains at least two elements. # Output - A list of integers where each element corresponds to the product of all other elements in the input list except for the element at the same index. # Constraints - The function must not use division. - The list will contain no more than (10^4) elements. - The elements of the list are integers. # Example ```python # Example usage print(product_except_self([1, 2, 3, 4])) # [24, 12, 8, 6] print(product_except_self([2, 3, 4, 5])) # [60, 40, 30, 24] ``` # Note To solve this problem without using the division operator, you can use two separate arrays to keep track of the cumulative product from the left and from the right. Then combine these results to get the desired output.","solution":"from typing import List def product_except_self(nums: List[int]) -> List[int]: length = len(nums) # Initialize arrays to hold the product of all elements to the left and right left_products = [1] * length right_products = [1] * length # Fill left_products array for i in range(1, length): left_products[i] = left_products[i - 1] * nums[i - 1] # Fill right_products array for i in range(length - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Construct the result by multiplying left_products and right_products result = [] for i in range(length): result.append(left_products[i] * right_products[i]) return result"},{"question":"# Sort Words by Length Problem Statement You are given a function `sort_by_length` that sorts a list of words by their length in ascending order. Your task is to implement this function. Function Signature ```python def sort_by_length(words: List[str]) -> List[str]: pass ``` Detailed Description * `words` (List[str]): A list of words (strings) that needs to be sorted by their length. Input Constraints - The list `words` should contain at least one word and no more than 1000 words. - Each word in the list will be a non-empty string containing only alphabetical characters (both uppercase and lowercase) and will not exceed 100 characters in length. Output - Return a list of words sorted by their length in ascending order. If two words have the same length, preserve their original order. Example Usage Implement the function with the following behavior: ```python >>> sort_by_length([\\"apple\\", \\"banana\\", \\"kiwi\\", \\"grape\\"]) [\'kiwi\', \'apple\', \'grape\', \'banana\'] >>> sort_by_length([\\"a\\", \\"abc\\", \\"ab\\", \\"abcd\\"]) [\'a\', \'ab\', \'abc\', \'abcd\'] >>> sort_by_length([\\"word\\", \\"alphabet\\", \\"letter\\", \\"character\\"]) [\'word\', \'letter\', \'alphabet\', \'character\'] ``` Hints - You can use the `sorted` function with a key parameter to sort based on the length of the words. - Remember to maintain stability in sorting to preserve the order of words with equal length. Ensure that your implementation passes these test cases and handles additional edge cases, especially those involving words with the same length.","solution":"from typing import List def sort_by_length(words: List[str]) -> List[str]: Sorts a list of words by their length in ascending order. Parameters: words (List[str]): A list of words to be sorted. Returns: List[str]: A list of words sorted by their length in ascending order. return sorted(words, key=len)"},{"question":"# Coding Assessment Question Context Graphs are fundamental data structures and often require traversal to analyze and manipulate the data they represent. One common traversal is Depth-First Search (DFS), which can be used in a variety of applications including detecting cycles in a graph. Task Write a Python function that determines whether an undirected graph contains any cycle. A cycle means there is a path that starts and ends at the same node. Function Signature ```python def detect_cycle_in_graph(n: int, edges: List[List[int]]) -> bool: pass ``` Input * An integer `n` (1 ≤ n ≤ 10^5) representing the number of nodes in the graph. * A list of edges, `edges`, where each edge is represented as a pair of integers `[u, v]` indicating an undirected edge between nodes `u` and `v`. Output * A boolean value: `True` if the graph contains any cycle, `False` otherwise. Example ```python print(detect_cycle_in_graph(3, [[0, 1], [1, 2], [2, 0]])) # Output: True print(detect_cycle_in_graph(4, [[0, 1], [1, 2], [2, 3]])) # Output: False print(detect_cycle_in_graph(5, [[0, 1], [1, 2], [1, 3], [3, 4], [4, 1]])) # Output: True ``` Constraints * Handle graphs with up to `10^5` nodes efficiently. * Assume the graph is represented as an adjacency list. * Executing the function should not exceed acceptable time and space limits for large inputs. Notes * Implement the cycle detection using DFS with parent tracking to avoid false cycle detection due to bidirectional edges. * Consider using a recursive approach with visited nodes set to track the traversal state.","solution":"from typing import List def detect_cycle_in_graph(n: int, edges: List[List[int]]) -> bool: from collections import defaultdict def dfs(node, parent): visited[node] = True for neighbour in graph[node]: if not visited[neighbour]: if dfs(neighbour, node): return True elif neighbour != parent: return True return False graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * n for i in range(n): if not visited[i]: if dfs(i, -1): return True return False"},{"question":"# String Compression Using RLE As part of a data compression project, you need to implement the Run-Length Encoding (RLE) algorithm. RLE is a simple compression algorithm that replaces consecutive occurrences of the same character in a string with that character followed by the number of its occurrences. Objective Write a function `compress_string` that compresses a given string using the RLE algorithm. If the compressed string is not shorter than the original string, the function should return the original string instead. Function Signature ```python def compress_string(s: str) -> str: ``` # Input - A string `s` comprising `n` characters. # Output - A compressed string using the RLE algorithm or the original string if the compressed string is not shorter. # Constraints - `1 <= n <= 10^6` - The string `s` consists of only lowercase English letters (`\'a\'` to `\'z\'`). # Examples ```python assert compress_string(\\"aaabbcc\\") == \\"a3b2c2\\" assert compress_string(\\"a\\") == \\"a\\" assert compress_string(\\"abca\\") == \\"abca\\" assert compress_string(\\"aaabbaaa\\") == \\"a3b2a3\\" ``` **Explanation**: 1. For the first example, compressing \\"aaabbcc\\" produces \\"a3b2c2\\" which is shorter than the original, hence returned. 2. For the second example, compressing \\"a\\" has no effect since it is a single character, so it is returned as \\"a\\". 3. For the third example, \\"abca\\" can\'t be compressed to a shorter string, thus returned as is. 4. For the fourth example, compressing \\"aaabbaaa\\" gives \\"a3b2a3\\". # Requirements - Ensure your implementation handles large inputs efficiently. - Consider edge cases such as the function receiving an empty string, though this case is not within the given constraints.","solution":"def compress_string(s: str) -> str: Compresses a string using Run-Length Encoding (RLE). If the compressed string is not shorter than the original, returns the original string. if not s: return s compressed = [] current_char = s[0] current_count = 1 for char in s[1:]: if char == current_char: current_count += 1 else: compressed.append(f\\"{current_char}{current_count}\\") current_char = char current_count = 1 # Append the last character and its count compressed.append(f\\"{current_char}{current_count}\\") compressed_string = \'\'.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"# Context Working with strings is a fundamental skill in programming, and efficiently solving string manipulation problems is a common requirement in coding assessments. # Problem Statement Write a function `decodeString` that takes an encoded string and returns its decoded version. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is repeated exactly k times. # Requirements 1. The function **decodeString(s: str) -> str** should decode the string following the above rules. # Input and Output Formats * **Input**: a single string `s` which represents the encoded string. * **Output**: a single string which is the decoded version of `s`. # Constraints * The input string `s` will be well-formed with matching square brackets. * The integer `k` inside the encoded string will be a positive integer. * The length of `s` will not exceed 100. # Example ```python assert decodeString(\\"3[a]2[bc]\\") == \\"aaabcbc\\" assert decodeString(\\"3[a2[c]]\\") == \\"accaccacc\\" assert decodeString(\\"2[abc]3[cd]ef\\") == \\"abcabccdcdcdef\\" assert decodeString(\\"10[a]\\") == \\"aaaaaaaaaa\\" assert decodeString(\\"2[3[xy]]\\") == \\"xyxyxyxyxyxy\\" ``` # Edge Cases to Consider * Nested encoded strings like \\"3[a2[c]]\\". * Strings with multiple encodings like \\"2[abc]3[cd]ef\\". * Large repetitions like \\"10[a]\\". * Strings without encodings, such as \\"hello\\". Implement the function: ```python def decodeString(s: str) -> str: stack = [] current_string = \'\' current_num = 0 for ch in s: if ch.isdigit(): current_num = current_num * 10 + int(ch) elif ch == \'[\': stack.append((current_string, current_num)) current_string = \'\' current_num = 0 elif ch == \']\': prev_string, num = stack.pop() current_string = prev_string + num * current_string else: current_string += ch return current_string ```","solution":"def decodeString(s: str) -> str: stack = [] current_string = \'\' current_num = 0 for ch in s: if ch.isdigit(): current_num = current_num * 10 + int(ch) elif ch == \'[\': stack.append((current_string, current_num)) current_string = \'\' current_num = 0 elif ch == \']\': prev_string, num = stack.pop() current_string = prev_string + num * current_string else: current_string += ch return current_string"},{"question":"# Question: Implement a Breadth-First Search Algorithm with Path Tracking You are tasked with implementing the Breadth-First Search (BFS) Algorithm to find the shortest path in an unweighted graph. Your implementation should also provide a feature to track the path taken from the start node to the goal node. Function Signature ```python def bfs_shortest_path(graph: Dict[int, List[int]], start: int, goal: int) -> Tuple[List[int], int]: ``` Parameters * **graph**: A dictionary representing the adjacency list of the graph. The keys are node identifiers, and the values are lists of adjacent node identifiers. * **start**: The starting node identifier. * **goal**: The goal node identifier. Return Return a tuple containing: - A list of node identifiers representing the shortest path from the start node to the goal node. - An integer representing the number of nodes in the shortest path, including the start and goal nodes. If no path exists, return an empty list and 0. Example ```python graph = { 1: [2, 3], 2: [4], 3: [4], 4: [5], 5: [] } # find the shortest path from node 1 to node 5 path, length = bfs_shortest_path(graph, 1, 5) print(\\"The shortest path found via BFS:\\", path) print(\\"Number of nodes in the shortest path:\\", length) # Output: # The shortest path found via BFS: [1, 2, 4, 5] # Number of nodes in the shortest path: 4 ``` # Requirements 1. Implement the `bfs_shortest_path` function based on the BFS algorithm. 2. Extend its functionality to track the path taken from the start node to the goal node. 3. Ensure your implementation handles cases where no path exists by returning an appropriate response.","solution":"from collections import deque from typing import Dict, List, Tuple def bfs_shortest_path(graph: Dict[int, List[int]], start: int, goal: int) -> Tuple[List[int], int]: if start == goal: return ([start], 1) queue = deque([(start, [start])]) visited = set() while queue: current_node, path = queue.popleft() if current_node == goal: return (path, len(path)) if current_node not in visited: visited.add(current_node) for neighbor in graph.get(current_node, []): if neighbor not in visited: queue.append((neighbor, path + [neighbor])) return ([], 0)"},{"question":"# Number String Decompression You are given a compressed version of a string where each letter is followed by a number representing how many times that letter should appear. Your task is to write a function `decompress(compressed_string: str) -> str` that decompresses the string. The compressed version is comprised of sequences of letters and integers. Each letter can be followed by a single or multi-digit number indicating its repetition. Input and Output Formats * **Input**: * A single string `compressed_string` containing the compressed version. * **Output**: * A single string representing the decompressed version of the input. Constraints * The input string `compressed_string` will only contain alphabetical letters and positive integers. * Alphabetical letters will always be uppercase. * Ensure your implementation handles sequences of varying lengths appropriately. Performance Requirements * Decompressing the string must occur in linear time relative to the input size. # Example ```python compressed_string = \\"A2B3C4\\" print(decompress(compressed_string)) # Output: AABBBCCCC compressed_string = \\"X1Y2Z10\\" print(decompress(compressed_string)) # Output: XYYZZZZZZZZZZ ``` # Implementation Implement the function `decompress` which takes the `compressed_string` as input and returns the decompressed string as output. ```python def decompress(compressed_string: str) -> str: result = [] i = 0 while i < len(compressed_string): if compressed_string[i].isalpha(): letter = compressed_string[i] i += 1 count = 0 while i < len(compressed_string) and compressed_string[i].isdigit(): count = count * 10 + int(compressed_string[i]) i += 1 result.append(letter * count) return \'\'.join(result) ```","solution":"def decompress(compressed_string: str) -> str: Decompresses a given compressed string where each letter is followed by a number representing how many times that letter should appear. result = [] i = 0 while i < len(compressed_string): # Check for alphabetical characters if compressed_string[i].isalpha(): letter = compressed_string[i] i += 1 count = 0 # Accumulate digits to form the complete number while i < len(compressed_string) and compressed_string[i].isdigit(): count = count * 10 + int(compressed_string[i]) i += 1 result.append(letter * count) return \'\'.join(result)"},{"question":"# E-commerce Product Review Sentiment Analysis **Context**: You are tasked with improving the customer feedback analysis for an online e-commerce platform. To achieve this, you need to implement a basic sentiment analysis tool to classify product reviews into positive, negative, or neutral categories based on the textual content. **Task**: Write a Python function named `analyze_review_sentiment(review: str) -> str:` that performs the following tasks: 1. Preprocess the input review text (convert to lowercase, remove punctuation and special characters). 2. Use a predefined set of positive and negative keywords to evaluate the sentiment. 3. Return one of the following strings based on the analysis: \\"Positive\\", \\"Negative\\", \\"Neutral\\". **Constraints**: - A review is classified as \\"Positive\\" if it contains more positive keywords than negative. - A review is classified as \\"Negative\\" if it contains more negative keywords than positive. - A review is classified as \\"Neutral\\" if the counts are equal, or no keywords are found. - The analysis does not require advanced natural language processing techniques. **Input**: - `review` (str): A string containing the text of a product review. **Output**: - `str`: A string indicating the sentiment of the review (\\"Positive\\", \\"Negative\\", or \\"Neutral\\"). **Example**: Given the following predefined keywords: ```python positive_keywords = [\\"excellent\\", \\"good\\", \\"great\\", \\"fantastic\\", \\"amazing\\", \\"love\\", \\"like\\"] negative_keywords = [\\"bad\\", \\"terrible\\", \\"horrible\\", \\"poor\\", \\"hate\\", \\"dislike\\"] ``` **Example Usage**: ```python example_review = \\"This product is absolutely fantastic, I love it!\\" output = analyze_review_sentiment(example_review) # Output: \\"Positive\\" ``` # Instructions: 1. Preprocess the review text to remove noise (punctuation, special characters) and convert to lowercase. 2. Count occurrences of positive and negative keywords in the review. 3. Compare the counts to determine the overall sentiment. 4. Return the appropriate sentiment classification. Here is a sample implementation outline: ```python import string def analyze_review_sentiment(review: str) -> str: positive_keywords = [\\"excellent\\", \\"good\\", \\"great\\", \\"fantastic\\", \\"amazing\\", \\"love\\", \\"like\\"] negative_keywords = [\\"bad\\", \\"terrible\\", \\"horrible\\", \\"poor\\", \\"hate\\", \\"dislike\\"] # Preprocess review text review = review.lower() review = review.translate(str.maketrans(\'\', \'\', string.punctuation)) # Count keyword occurrences positive_count = sum(review.count(word) for word in positive_keywords) negative_count = sum(review.count(word) for word in negative_keywords) # Determine sentiment if positive_count > negative_count: return \\"Positive\\" elif negative_count > positive_count: return \\"Negative\\" else: return \\"Neutral\\" ``` This new question aligns with the existing set by focusing on text processing and basic natural language processing tasks commonly required in web and data analytics applications. The question seamlessly integrates with the original set in terms of style, complexity, and scope.","solution":"import string def analyze_review_sentiment(review: str) -> str: positive_keywords = [\\"excellent\\", \\"good\\", \\"great\\", \\"fantastic\\", \\"amazing\\", \\"love\\", \\"like\\"] negative_keywords = [\\"bad\\", \\"terrible\\", \\"horrible\\", \\"poor\\", \\"hate\\", \\"dislike\\"] # Preprocess review text review = review.lower() review = review.translate(str.maketrans(\'\', \'\', string.punctuation)) # Count keyword occurrences positive_count = sum(review.count(word) for word in positive_keywords) negative_count = sum(review.count(word) for word in negative_keywords) # Determine sentiment if positive_count > negative_count: return \\"Positive\\" elif negative_count > positive_count: return \\"Negative\\" else: return \\"Neutral\\""},{"question":"# Coding Assessment Question Sum of Digit Factorials: You are tasked with solving a problem that involves identifying specific numbers based on the factorials of their digits. A number `n` is said to be equal to the sum of the factorials of its digits if: - n = sum(factorial(digit)) for each digit in `n`. Your objective is to find all such numbers within a given range and return their sum. Function Definition: Implement a function `sum_of_special_numbers(limit)` that takes a parameter `limit` and returns the sum of all numbers `n` within the range `10` to `limit` where the sum of the factorials of the digits of `n` equals `n`. Input: - An integer `limit` (2 <= limit <= 100,000). Output: - An integer, the sum of all numbers `n` that meet the criteria. Example: ```python >>> result = sum_of_special_numbers(100000) >>> print(result) 40730 ``` Constraints: 1. Your function should efficiently handle the range up to the upper limit. 2. Ensure the solution works correctly for the lower boundary as well as large values of `limit`. 3. Consider using pre-computed factorials for digits 0-9 to optimize performance. Good luck!","solution":"import math def sum_of_special_numbers(limit): def digit_factorial_sum(n): return sum(math.factorial(int(digit)) for digit in str(n)) special_sum = 0 for number in range(10, limit): if number == digit_factorial_sum(number): special_sum += number return special_sum"},{"question":"Introduction: Dijkstra\'s algorithm is a classic algorithm used for finding the shortest paths between nodes in a graph, particularly from a single source node to all other nodes. Problem: You need to extend the functionality of the `WeightedGraph` and `ShortestPathFinder` classes to handle dynamic edge updates and queries efficiently. # Task: 1. Implement a method in the `WeightedGraph` class to add or update an edge with a given weight dynamically. 2. Implement a method in the `ShortestPathFinder` class to recalculate shortest paths using Dijkstra\'s algorithm whenever an edge is added or updated. Ensure that the recalculation is efficient, leveraging partial updates when possible. # Input/Output Format: * **Input**: - `edges`: A 2D list of tuples representing the initial list of edges, where each tuple is `(u, v, w)` representing an edge from vertex `u` to vertex `v` with weight `w`. - `updates`: A list of tuples representing dynamic updates to the edges, where each tuple is `(u, v, w)` indicating that the edge from vertex `u` to vertex `v` should be added or its weight updated to `w`. - `source`: An integer representing the index of the source vertex. * **Output**: - A list of integers where each integer represents the shortest path distance from the `source` vertex to each other vertex after all updates have been applied. Return `-1` for vertices that are unreachable from the source. The output list should be sorted by vertex indices in ascending order. # Constraints: 1. The number of vertices `V` is `1 <= V <= 500`. 2. Edge weights are non-negative integers. 3. There will be at most `1000` updates. 4. The `WeightedGraph` class can be assumed to handle graphs with `V x V` adjacency matrices. 5. Self-loops and multiple edges between the same pair of vertices are allowed, but only the minimum weight edge should be considered for shortest path calculations. # Example: ```python edges = [ (0, 1, 4), (0, 2, 1), (2, 1, 2), (1, 3, 1), (2, 3, 5), (3, 4, 3) ] updates = [ (0, 3, 2), # Adds/updates the edge 0 -> 3 with weight 2 (2, 3, 1) # Adds/updates the edge 2 -> 3 with weight 1 ] source = 0 graph = WeightedGraph(edges) for u, v, w in updates: graph.add_or_update_edge(u, v, w) shortest_path_finder = ShortestPathFinder(graph) print(shortest_path_finder.find_shortest_paths(source)) # Output should be [0, 3, 1, 2, 5] ``` # Evaluation Criteria: 1. Correctness: The implemented methods must update the graph correctly and recalculate the shortest paths accurately. 2. Efficiency: The solution should minimize unnecessary recalculations and leverage efficient data structures. 3. Code Quality: Ensure the code is clean, well-documented, and adheres to best practices in terms of modularity and readability.","solution":"import heapq import sys from typing import List, Tuple class WeightedGraph: def __init__(self, edges: List[Tuple[int, int, int]], V: int): self.V = V self.graph = [[sys.maxsize] * V for _ in range(V)] for u, v, w in edges: self.add_or_update_edge(u, v, w) def add_or_update_edge(self, u: int, v: int, w: int): self.graph[u][v] = min(self.graph[u][v], w) class ShortestPathFinder: def __init__(self, graph: WeightedGraph): self.graph = graph.graph self.V = graph.V def find_shortest_paths(self, source: int) -> List[int]: dist = [sys.maxsize] * self.V dist[source] = 0 priority_queue = [(0, source)] while priority_queue: current_dist, u = heapq.heappop(priority_queue) if current_dist > dist[u]: continue for v in range(self.V): if self.graph[u][v] != sys.maxsize: distance = current_dist + self.graph[u][v] if distance < dist[v]: dist[v] = distance heapq.heappush(priority_queue, (distance, v)) return [d if d != sys.maxsize else -1 for d in dist] # Helper function to create the graph, perform updates and find shortest paths def get_shortest_paths(edges: List[Tuple[int, int, int]], updates: List[Tuple[int, int, int]], source: int, V: int) -> List[int]: graph = WeightedGraph(edges, V) for u, v, w in updates: graph.add_or_update_edge(u, v, w) shortest_path_finder = ShortestPathFinder(graph) return shortest_path_finder.find_shortest_paths(source)"},{"question":"# Problem Description You are given a string containing only lowercase letters; you need to group identical consecutive characters together. For each group of characters, append the character followed by the length of the group. Write a function that compresses the string in this manner. # Function Signature ```python def compress_string(s: str) -> str: ``` # Input * `s` (str): A string consisting only of lowercase letters (1 ≤ len(s) ≤ 10^5). # Output * (str): The compressed string where each group of consecutive identical characters is replaced by the character followed by the count of its occurrences. # Constraints * The length of the string `s` will be in the range [1, 10^5]. * The string will contain only lowercase English letters (\'a\' to \'z\'). # Performance Requirements * The solution must handle strings up to length 100,000 efficiently. # Example Cases Example 1: ```python s = \\"aabccc\\" output = \\"a2b1c3\\" ``` Example 2: ```python s = \\"abc\\" output = \\"a1b1c1\\" ``` Example 3: ```python s = \\"aaabbbaaa\\" output = \\"a3b3a3\\" ``` # Additional Information 1. Your code should handle edge cases such as strings with a single character and strings with all the same characters. 2. Ensure your implementation is efficient and runs within acceptable time limits for large inputs.","solution":"def compress_string(s: str) -> str: if not s: return \\"\\" compressed = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: compressed.append(current_char + str(count)) current_char = char count = 1 compressed.append(current_char + str(count)) # Don\'t forget to add the last group return \'\'.join(compressed)"},{"question":"# Problem Statement You are required to implement a simple event scheduling system. The system should be able to add events, remove events, and retrieve a list of events within a specific time range. Each event consists of a start time, an end time, and a description. # Instructions 1. Write a class `EventScheduler` that supports the following methods: * `add_event(start: str, end: str, description: str) -> None`: Adds an event to the scheduler. Start and end times are formatted as \\"HH:MM\\". * `remove_event(description: str) -> bool`: Removes an event with the given description. Returns `True` if the event was found and removed, `False` otherwise. * `get_events(start_range: str, end_range: str) -> list[str]`: Retrieves a list of event descriptions whose time overlaps with the specified time range. Start and end times of the range are formatted as \\"HH:MM\\". # Function Signature The methods should have the following signatures: ```python class EventScheduler: def __init__(self): pass def add_event(self, start: str, end: str, description: str) -> None: pass def remove_event(self, description: str) -> bool: pass def get_events(self, start_range: str, end_range: str) -> list[str]: pass ``` # Example ```python # Initializing the EventScheduler object scheduler = EventScheduler() # Adding events scheduler.add_event(\\"09:00\\", \\"11:00\\", \\"Team Meeting\\") scheduler.add_event(\\"13:00\\", \\"14:00\\", \\"Client Call\\") scheduler.add_event(\\"10:30\\", \\"12:00\\", \\"Project Update\\") # Removing an event scheduler.remove_event(\\"Team Meeting\\") # Returns: True # Getting events within a specific time range events = scheduler.get_events(\\"10:00\\", \\"13:00\\") # Expected Output: [\'Project Update\', \'Client Call\'] print(events) ``` # Constraints * The start and end times all follow a 24-hour HH:MM format. * Assume all times are in the same day. * If `start` time is equal to `end` time, it should be treated as a 0-duration event which is valid. * Validate that `start` is before `end` when adding an event. * Events should not overlap when being added. * Overlapping events should be correctly retrieved when querying with `get_events`. # Notes - Use appropriate data structures to ensure efficient operations where possible. - Raise a `ValueError` if an invalid time format is provided, or if the specified time range in `add_event` is invalid.","solution":"class EventScheduler: def __init__(self): self.events = [] def _convert_to_minutes(self, time_str): hour, minute = map(int, time_str.split(\\":\\")) return hour * 60 + minute def add_event(self, start: str, end: str, description: str) -> None: start_minutes = self._convert_to_minutes(start) end_minutes = self._convert_to_minutes(end) if start_minutes >= end_minutes: raise ValueError(\\"Start time must be before end time.\\") for event in self.events: if not (end_minutes <= event[0] or start_minutes >= event[1]): raise ValueError(\\"Event times overlap with existing event.\\") self.events.append((start_minutes, end_minutes, description)) def remove_event(self, description: str) -> bool: for i, event in enumerate(self.events): if event[2] == description: del self.events[i] return True return False def get_events(self, start_range: str, end_range: str) -> list: start_range_minutes = self._convert_to_minutes(start_range) end_range_minutes = self._convert_to_minutes(end_range) result = [] for event in self.events: if not (end_range_minutes <= event[0] or start_range_minutes >= event[1]): result.append(event[2]) return result"},{"question":"# Coding Assessment Question Context In this exercise, you\'ll explore properties of numbers concerning their divisors. This type of problem often occurs in mathematical programming and requires a good understanding of number theory. Problem Statement Write a function `find_sum_of_divisors(n: int) -> int` that returns the sum of all divisors of a given integer `n`. The divisors of a number `n` are the numbers that divide `n` without leaving a remainder, including 1 and `n` itself. Constraints * The function parameter `n` is a positive integer. * You should consider efficiency, especially for larger values of `n` (e.g., n <= 10^6). Input * An integer `n`. Output * The integer value of the sum of all divisors of `n`. Examples * `find_sum_of_divisors(6)` should return `12` (Divisors: 1, 2, 3, 6). * `find_sum_of_divisors(28)` should return `56` (Divisors: 1, 2, 4, 7, 14, 28). * `find_sum_of_divisors(10)` should return `18` (Divisors: 1, 2, 5, 10). Function Signature ```python def find_sum_of_divisors(n: int) -> int: pass ``` Requirements * Ensure that the code handles edge cases like the smallest and largest possible values within the provided constraints. * Focus on optimizing the function to reduce runtime complexity. * Include appropriate test cases to verify the correctness of your implementation.","solution":"def find_sum_of_divisors(n: int) -> int: Returns the sum of all divisors of a given integer n if n <= 0: raise ValueError(\\"n must be a positive integer\\") divisors_sum = 0 # Iterate through possible divisors up to the square root of n for i in range(1, int(n**0.5) + 1): if n % i == 0: divisors_sum += i if i != n // i: # Add the complementary divisor if it is different divisors_sum += n // i return divisors_sum"},{"question":"# Secure User Authentication Using Hashing You are tasked with creating a secure user authentication system. Your goal is to implement functions that handle the registration and login processes for users, ensuring that passwords are securely stored using hashing and salt. # Requirements: 1. **Function Definitions**: - `register_user(username: str, password: str) -> dict`: - **Parameters**: - `username`: The user\'s username. - `password`: The user\'s password. - **Returns**: - A dictionary with `username` as the key and the hashed password (with salt) as the value. - `login_user(username: str, password: str, user_db: dict) -> bool`: - **Parameters**: - `username`: The user\'s username. - `password`: The user\'s password. - `user_db`: Dictionary containing registered users and their hashed passwords. - **Returns**: - `True` if the login is successful (i.e., the username exists and the password matches); `False` otherwise. 2. **Input**: - `username` is a non-empty string. - `password` must be hashed and salted before storage. 3. **Output**: - `register_user` should store the username and the salted hash of the password in a dictionary. - `login_user` should validate the provided password against the stored username and hashed password. 4. **Constraints**: - Passwords must be hashed using a secure hashing algorithm (e.g., SHA-256) and must include a unique salt for each user. - Ensure performance efficiency and security, considering common attacks such as brute force and rainbow table attacks. - Handle edge cases such as empty usernames, short or simple passwords, and existing usernames during registration. ```python import hashlib import os def register_user(username: str, password: str) -> dict: Register a new user, hashing their password with a unique salt. Parameters: - username <type: str>: the username to register. - password <type: str>: the user\'s password. Return: - user_db <type: dict>: dictionary with \'username\' as key and hashed password with salt as value. salt = os.urandom(16) # Generate a unique salt hashed_password = hashlib.sha256(salt + password.encode()).hexdigest() return {username: (salt, hashed_password)} def login_user(username: str, password: str, user_db: dict) -> bool: Authenticate a user by validating their password. Parameters: - username <type: str>: the username to login. - password <type: str>: the password provided by the user. - user_db <type: dict>: dictionary with registered users and their hashed passwords. Return: - <type: bool>: True if login is successful, False otherwise. if username not in user_db: return False salt, stored_hash = user_db[username] hashed_password = hashlib.sha256(salt + password.encode()).hexdigest() return hashed_password == stored_hash ``` # Scenario: You are part of a software engineering team developing a secure web application. One of your responsibilities is managing user authentication in a way that ensures passwords are stored securely, mitigating risks of password theft and other attacks. By implementing and integrating the `register_user` and `login_user` functions, you can handle user registrations and logins securely. This is a critical module that will be a part of the entire authentication system of your application, intended to maintain user data privacy and integrity. Use the provided function templates to implement the solution. Your solution will be an integral part of the authentication service, handling potentially millions of user credentials securely.","solution":"import hashlib import os def register_user(username: str, password: str) -> dict: Register a new user, hashing their password with a unique salt. Parameters: - username <type: str>: the username to register. - password <type: str>: the user\'s password. Return: - user_db <type: dict>: dictionary with \'username\' as key and hashed password with salt as value. if not username or not password: raise ValueError(\\"Username and password must be non-empty\\") salt = os.urandom(16) # Generate a unique salt hashed_password = hashlib.sha256(salt + password.encode()).hexdigest() return {username: (salt, hashed_password)} def login_user(username: str, password: str, user_db: dict) -> bool: Authenticate a user by validating their password. Parameters: - username <type: str>: the username to login. - password <type: str>: the password provided by the user. - user_db <type: dict>: dictionary with registered users and their hashed passwords. Return: - <type: bool>: True if login is successful, False otherwise. if username not in user_db: return False salt, stored_hash = user_db[username] hashed_password = hashlib.sha256(salt + password.encode()).hexdigest() return hashed_password == stored_hash"},{"question":"**Find Duplicates in a List** You are provided with a list of integers where each integer may appear one or more times. Write a function `find_duplicates` that identifies all integers that appear more than once in the list and returns a sorted list of these duplicate integers. # Function Signature ```python def find_duplicates(nums: list[int]) -> list[int]: ``` # Input - `nums`: A list of integers (e.g., `[4, 3, 2, 7, 8, 2, 3, 1]`). # Output - Returns a sorted list of integers that are duplicates in the input list. # Constraints - The input list can have up to 10^5 elements. - Each integer in the list will be between `1` and `10^5`. - The list may contain duplicated integers. # Example ```python >>> find_duplicates([4, 3, 2, 7, 8, 2, 3, 1]) [2, 3] >>> find_duplicates([1, 1, 1, 2, 3, 3, 4, 5, 6]) [1, 3] >>> find_duplicates([10, 20, 30, 40, 50]) [] ``` # Notes - The output list should not contain any duplicate values and must be sorted in ascending order. - Handle edge cases where the input list might be empty or contain no duplicates. The above task requires you to identify the integers with multiple occurrences in the list and output them in a sorted manner, demonstrating skills in list manipulation, usage of sets/dictionaries, and sorting algorithms.","solution":"def find_duplicates(nums): Identifies duplicates in a list and returns them sorted. Arguments: nums -- list of integers Returns: list of integers that are duplicates in the input list, sorted from collections import Counter # Count occurrences of each number counts = Counter(nums) # Identify numbers which have more than one occurrence duplicates = [num for num, count in counts.items() if count > 1] # Return the sorted list of duplicates return sorted(duplicates)"},{"question":"# Binary Search Tree (BST): Find the Lowest Common Ancestor (LCA) You are asked to implement a function to find the Lowest Common Ancestor (LCA) of two given nodes in a Binary Search Tree (BST). Given a BST and two distinct nodes in the tree, determine their LCA. Function Specifications: 1. Implement the function `find_lca(root: Optional[TreeNode], n1: int, n2: int) -> Optional[TreeNode]`. * **Input**: * `root`: The root node of the BST (or `None` if the tree is empty). * `n1`: An integer representing the value of the first node. * `n2`: An integer representing the value of the second node. * **Output**: * Returns the TreeNode representing the LCA of nodes `n1` and `n2`. Definition for a binary tree node: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` Example: ```python # Example BST # 20 # / # 8 22 # / # 4 12 # / # 10 14 root = TreeNode(20) root.left = TreeNode(8) root.right = TreeNode(22) root.left.left = TreeNode(4) root.left.right = TreeNode(12) root.left.right.left = TreeNode(10) root.left.right.right = TreeNode(14) lca = find_lca(root, 10, 14) print(lca.val) # Output: 12 lca = find_lca(root, 14, 8) print(lca.val) # Output: 8 lca = find_lca(root, 10, 22) print(lca.val) # Output: 20 ``` Constraints: * The tree is a Binary Search Tree. * All TreeNode values are distinct. * Both `n1` and `n2` exist in the BST. Notes: * Ensure to handle cases where one or both input nodes are the root node. * Optimize the algorithm to minimize the number of traversals within the tree. * Validate your implementation with diverse test cases, including edge cases where the nodes are adjacent to each other in the tree or one node is an ancestor of the other.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_lca(root: TreeNode, n1: int, n2: int) -> TreeNode: Find the Lowest Common Ancestor (LCA) of two given nodes in a BST. :param root: The root node of the BST :param n1: The value of the first node :param n2: The value of the second node :return: The TreeNode representing the LCA of nodes n1 and n2 # Start from the root and traverse the tree while root: # If both n1 and n2 are smaller than root, then LCA is in the left subtree if root.val > n1 and root.val > n2: root = root.left # If both n1 and n2 are greater than root, then LCA is in the right subtree elif root.val < n1 and root.val < n2: root = root.right else: # One of n1 or n2 is equal to root, or they are on opposite sides return root"},{"question":"# Background: Sorting algorithms are fundamental in computer science, used in a variety of applications from database management to data analysis. One such algorithm is QuickSort, known for its efficiency in sorting large datasets. Your task is to implement this algorithm. # Task: Implement the QuickSort algorithm to sort a list of integers in ascending order. Your implementation should handle lists of varying lengths efficiently, including edge cases such as empty lists and lists with repeated elements. # Function Signature: ```python def quicksort(arr: List[int]) -> List[int]: pass ``` # Input: - `arr`: A list of integers that needs to be sorted. # Output: - Returns a sorted version of the input list in ascending order. # Constraints: - Input list elements will be in the range of `[-10^6, 10^6]`. - The length of `arr` will be between `0` and `10^4`. # Examples: ```python print(quicksort([3, 6, 8, 10, 1, 2, 1])) # Expected: [1, 1, 2, 3, 6, 8, 10] print(quicksort([1, 4, 3, 9, 5])) # Expected: [1, 3, 4, 5, 9] print(quicksort([])) # Expected: [] print(quicksort([10, -3, -5, 5, 2])) # Expected: [-5, -3, 2, 5, 10] print(quicksort([10, 10, 10])) # Expected: [10, 10, 10] ``` # Scenario: You are building a feature in a data analysis tool that requires sorting data efficiently to present it in a user-friendly format. QuickSort is chosen for its average-case time complexity of ( O(n log n) ), making it suitable for large datasets. Implement the sorting function to ensure the performance and correctness of the tool.","solution":"from typing import List def quicksort(arr: List[int]) -> List[int]: Sorts a list of integers in ascending order using the QuickSort algorithm. if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quicksort(left) + middle + quicksort(right)"},{"question":"# Coding Question: Palindrome Permutation Checker Objective Create a function that determines if any permutation of the provided string can form a palindrome. Ignore spaces and treat uppercase and lowercase letters as the same. Problem Statement A permutation of a string is a rearrangement of its characters. A string is considered to be a permutation of a palindrome if the characters of the string can be rearranged to form a palindrome. Write a function `can_form_palindrome(s: str) -> bool` which determines if any permutation of the input string can be a palindrome. **Input:** * A string (1 <= length <= 10^6). The string may contain spaces and alphabetic characters. **Output:** * Returns `True` if any permutation of the input string can form a palindrome, otherwise returns `False`. **Constraints:** * Ignore spaces and consider letters to be case-insensitive during the check. * Raise a `ValueError` if the string contains any non-alphabetic characters other than spaces. **Example:** ```python >>> can_form_palindrome(\\"Taco cat\\") True >>> can_form_palindrome(\\"Able was I, I saw Elba\\") Traceback (most recent call last): ... ValueError: String must only contain alphabetic characters and spaces. >>> can_form_palindrome(\\"Toy cat\\") False ``` Key Points: * Ensure the solution runs efficiently with a time complexity of O(n). * Ignore spaces and handle letters case-insensitively (treat \'A\' as \'a\', etc.). * Given the high potential input length, ensure the solution is efficient in both time and space complexities. You can assume the input will fit into memory.","solution":"def can_form_palindrome(s: str) -> bool: Determines if any permutation of the input string can form a palindrome. # Remove spaces and convert to lowercase cleaned_str = \'\'.join([char.lower() for char in s if char.isalpha()]) # Raise ValueError if there are any non-alphabetic characters other than spaces if not all(char.isalpha() or char.isspace() for char in s): raise ValueError(\\"String must only contain alphabetic characters and spaces.\\") char_count = {} # Count frequency of each character for char in cleaned_str: char_count[char] = char_count.get(char, 0) + 1 # Check the number of characters with odd counts odd_counts = sum(1 for count in char_count.values() if count % 2 != 0) # At most one character with an odd count is allowed for a string to be a permutation of a palindrome return odd_counts <= 1"},{"question":"# Dynamic Programming and Matrix Manipulation Challenge Objective You are required to implement a dynamic programming solution to solve the following problem using Python. Specifically, you should: 1. Implement a function that finds the minimum cost path to traverse from the top-left to the bottom-right of a given 2D cost matrix. Input/Output Format * **Input**: * A 2D list \'cost_matrix\' with dimensions `m x n`, where `m` is the number of rows and `n` is the number of columns. Each cell represents the cost of entering that cell. * Both `m` (number of rows) and `n` (number of columns) will be >= 1. * **Output**: * An integer representing the minimum cost to reach the bottom-right cell from the top-left cell of the matrix. Constraints * You can only move right or down from a given cell. * Assume all input data values are non-negative. Code Requirements 1. Use dynamic programming to construct a solution that ensures an efficient traversal through the matrix. 2. Consider edge cases where the matrix might be a single row or column. Template ```python def min_cost_path(cost_matrix): Find the minimum cost path in a 2D cost matrix from top-left to bottom-right. \'cost_matrix\' should be a 2D list with dimensions m x n. # Your implementation here return min_cost # Example usage cost_matrix = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(\\"Minimum cost:\\", min_cost_path(cost_matrix)) # Should output 7 ``` Explanation For the given example, the function should traverse the matrix and find the minimum cost path, which would be `1 -> 3 -> 1 -> 1 -> 1 -> 1`. The total minimum cost is 7. Develop a dynamic programming table (or 2D list) where each cell contains the minimum cost to reach that cell starting from the top-left. Carefully update the table by considering the cost values of moving right or down, ensuring an efficient path calculation.","solution":"def min_cost_path(cost_matrix): Find the minimum cost path in a 2D cost matrix from top-left to bottom-right. \'cost_matrix\' should be a 2D list with dimensions m x n. if not cost_matrix: return 0 m, n = len(cost_matrix), len(cost_matrix[0]) dp = [[0 for _ in range(n)] for _ in range(m)] dp[0][0] = cost_matrix[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + cost_matrix[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + cost_matrix[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + cost_matrix[i][j] return dp[m-1][n-1] # Example usage cost_matrix = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(\\"Minimum cost:\\", min_cost_path(cost_matrix)) # Should output 7"},{"question":"# Coding Assessment Question You are developing an e-commerce platform and need to implement a feature to calculate the total cart value for customers. The system needs to handle various types of products with different pricing models and apply discounts accordingly. Problem Statement Write a function `calculate_cart_value` that computes the total value of items in a shopping cart. Your function should be able to: 1. Calculate the total price for a list of items. 2. Apply any applicable discounts provided in the cart. 3. Ensure proper handling of different pricing models (e.g., fixed price, price per weight). Each item in the cart is represented as a dictionary with the following keys: - `type`: A string indicating the type of the item. It can be `\\"fixed\\"`, `\\"weight\\"`, or `\\"discount\\"`. - `\\"fixed\\"`: The item has a fixed price. - `\\"weight\\"`: The item is priced per weight unit. - `\\"discount\\"`: This is a discount applied to the cart. The discount has its own sub-keys. - For `\\"fixed\\"` items: - `price`: A float representing the fixed price of the item. - `quantity`: An integer indicating the number of units of the item. - For `\\"weight\\"` items: - `price_per_unit`: A float representing the price per weight unit of the item. - `weight`: A float indicating the total weight of the item. - For `\\"discount\\"` items: - `on_type`: A string indicating the type of items the discount applies to (`\\"fixed\\"` or `\\"weight\\"`). - `amount`: A float representing the discount amount. Implement the function `calculate_cart_value` that calculates the total value of the cart considering the above-mentioned properties. Function Signature ```python def calculate_cart_value(cart: list) -> float: ``` Input - `cart`: A list of dictionaries, each representing an item or a discount in the cart. Output - Return the total value of the cart as a float. Example ```python cart = [ {\\"type\\": \\"fixed\\", \\"price\\": 10.0, \\"quantity\\": 2}, {\\"type\\": \\"weight\\", \\"price_per_unit\\": 5.0, \\"weight\\": 3.0}, {\\"type\\": \\"discount\\", \\"on_type\\": \\"fixed\\", \\"amount\\": 5.0}, {\\"type\\": \\"discount\\", \\"on_type\\": \\"weight\\", \\"amount\\": 3.0} ] print(calculate_cart_value(cart)) # Should return 36.0 ``` Constraints 1. All prices and amounts are non-negative floats. 2. Quantities and weights are non-negative numbers. 3. Discounts should only be applied to their respective item types. 4. The function should handle applicable discounts in the provided order. Notes - The cart may contain a mix of fixed price items, weight-based items, and discounts. - Discounts must be subtracted from their respective item types before calculating the total cart value.","solution":"def calculate_cart_value(cart): total_fixed = 0 total_weight = 0 for item in cart: if item[\\"type\\"] == \\"fixed\\": total_fixed += item[\\"price\\"] * item[\\"quantity\\"] elif item[\\"type\\"] == \\"weight\\": total_weight += item[\\"price_per_unit\\"] * item[\\"weight\\"] for item in cart: if item[\\"type\\"] == \\"discount\\": if item[\\"on_type\\"] == \\"fixed\\": total_fixed -= item[\\"amount\\"] elif item[\\"on_type\\"] == \\"weight\\": total_weight -= item[\\"amount\\"] # Ensure discounts do not make the values negative total_fixed = max(total_fixed, 0) total_weight = max(total_weight, 0) return total_fixed + total_weight"},{"question":"# Coding Question **Context**: Alex is developing an organizing tool for managing time slots for various tasks. He wants to ensure that the time slots do not overlap and each task is scheduled appropriately. **Task**: Write a Python class `Scheduler` that: 1. Helps in scheduling tasks with specified start and end times. 2. Ensures no overlapping time slots. **Class Signature**: ```python class Scheduler: def __init__(self): Initializes an empty schedule. pass def add_task(self, start_time: str, end_time: str) -> bool: Adds a task with given start and end times to the schedule. Returns True if the task is added successfully without overlap. Returns False if there is a conflict with another scheduled task. :param start_time: str - the starting time of the task in \\"HH:MM\\" 24-hour format :param end_time: str - the ending time of the task in \\"HH:MM\\" 24-hour format :return: bool - True if task added successfully, False otherwise pass def get_schedule(self) -> list: Returns the list of all scheduled tasks. Each task is represented as a tuple (start_time, end_time). :return: list - list of tuples representing the scheduled tasks pass ``` **Constraints**: * The `start_time` and `end_time` are given in \\"HH:MM\\" 24-hour format, and `start_time` is always less than `end_time`. * The times are strings and should be compared lexicographically to determine overlaps. * The schedule should be sorted by `start_time`. **Example**: ```python scheduler = Scheduler() print(scheduler.add_task(\\"09:00\\", \\"10:00\\")) # Output: True print(scheduler.add_task(\\"09:30\\", \\"11:00\\")) # Output: False (overlaps with \\"09:00\\" to \\"10:00\\") print(scheduler.add_task(\\"10:00\\", \\"11:00\\")) # Output: True print(scheduler.get_schedule()) # Output: [(\'09:00\', \'10:00\'), (\'10:00\', \'11:00\')] ```","solution":"class Scheduler: def __init__(self): Initializes an empty schedule. self.schedule = [] def add_task(self, start_time: str, end_time: str) -> bool: Adds a task with given start and end times to the schedule. Returns True if the task is added successfully without overlap. Returns False if there is a conflict with another scheduled task. :param start_time: str - the starting time of the task in \\"HH:MM\\" 24-hour format :param end_time: str - the ending time of the task in \\"HH:MM\\" 24-hour format :return: bool - True if task added successfully, False otherwise for task in self.schedule: if start_time < task[1] and end_time > task[0]: return False self.schedule.append((start_time, end_time)) self.schedule.sort() return True def get_schedule(self) -> list: Returns the list of all scheduled tasks. Each task is represented as a tuple (start_time, end_time). :return: list - list of tuples representing the scheduled tasks return self.schedule"},{"question":"# Problem Statement: Batch File Data Parsing and Aggregation You are developing a data processing tool that reads and processes batches of data from text files. Each file contains several records, each on a new line, with values separated by commas. Your task is to parse these files and compute aggregated statistics for specific columns of the records based on given criteria. # Requirements 1. **Function Implementation**: Implement the function `batch_file_aggregator(file_paths: list[str], column_indices: list[int], operation: str) -> dict[int, float]` 2. **Input**: * `file_paths` - A list of strings representing the file paths of the text files to be processed. * `column_indices` - A list of integers representing the indices of the columns to be aggregated. * `operation` - A string that specifies the aggregation operation: either \\"sum\\", \\"average\\", \\"min\\", or \\"max\\". 3. **Output**: * Returns a dictionary where keys are the column indices from `column_indices` and values are the result of the specified aggregation operation for each column. # Constraints 1. Each file will contain at least one record. 2. Each record is a comma-separated list of non-negative floats. 3. `column_indices` contains valid indices for the records. 4. The `operation` string is guaranteed to be one of \\"sum\\", \\"average\\", \\"min\\", or \\"max\\". # Example ```python file1 = \\"data1.txt\\" file2 = \\"data2.txt\\" # Content of data1.txt: # 12.5, 45.0, 78.0 # 10.0, 55.5, 60.7 # Content of data2.txt: # 15.3, 40.2, 70.1 # 13.2, 50.1, 64.6 file_paths = [file1, file2] column_indices = [0, 2] operation = \\"average\\" result = batch_file_aggregator(file_paths, column_indices, operation) print(result) # Expected Output: # {0: 12.75, 2: 68.35} ``` # Requirements 1. Efficiently read and parse data from multiple files. 2. Perform the aggregation operation as specified (e.g., summing values, computing average, finding minimum or maximum). 3. Handle potential errors gracefully, such as empty files or missing values, ensuring robust processing of input data.","solution":"import os def batch_file_aggregator(file_paths: list[str], column_indices: list[int], operation: str) -> dict[int, float]: Aggregates data from specified columns in the given files using the specified operation. Parameters: - file_paths: List of file paths to be read. - column_indices: List of column indices to be aggregated. - operation: Aggregation operation: \\"sum\\", \\"average\\", \\"min\\", or \\"max\\". Returns: - Dictionary with column indices as keys and aggregated result as values. # Initialize data structure to collect column values column_data = {index: [] for index in column_indices} for file_path in file_paths: if os.path.exists(file_path): with open(file_path, \'r\') as file: for line in file: values = line.strip().split(\',\') for index in column_indices: if index < len(values): column_data[index].append(float(values[index])) result = {} for index in column_indices: values = column_data[index] if not values: continue if operation == \\"sum\\": result[index] = sum(values) elif operation == \\"average\\": result[index] = sum(values) / len(values) elif operation == \\"min\\": result[index] = min(values) elif operation == \\"max\\": result[index] = max(values) return result"},{"question":"Realistic Simulated System Design You are tasked with designing a simplified flight reservation system for an airline. The system should allow for the booking and cancellation of seats on flights and also provide a way to search for available flights based on departure and arrival locations. # Problem Statement Design and implement the classes and methods required to support the following functionalities: 1. **Add Flight**: Add a flight to the system with specific details such as flight number, departure location, arrival location, and the number of seats. 2. **Book Seat**: Book a seat on a specified flight if available. 3. **Cancel Seat**: Cancel a booking on a specified flight if the booking exists. 4. **Search Flights**: Search for available flights between a given departure and arrival location. # Class Definitions and Function Signatures You will need to define at least two classes: `Flight` and `FlightSystem`. Class: `Flight` ```python class Flight: def __init__(self, flight_number: str, departure: str, arrival: str, seats: int): pass def book_seat(self) -> bool: pass def cancel_seat(self) -> bool: pass ``` Class: `FlightSystem` ```python class FlightSystem: def __init__(self): pass def add_flight(self, flight_number: str, departure: str, arrival: str, seats: int): pass def book_seat(self, flight_number: str) -> bool: pass def cancel_seat(self, flight_number: str) -> bool: pass def search_flights(self, departure: str, arrival: str) -> List[str]: pass ``` # Input - For the `add_flight` method: - **flight_number**: `str` - Unique identifier for the flight. - **departure**: `str` - Departure location of the flight. - **arrival**: `str` - Arrival location of the flight. - **seats**: `int` - Total number of seats on the flight. - For the `book_seat` and `cancel_seat` methods: - **flight_number**: `str` - Unique identifier for the flight. - For the `search_flights` method: - **departure**: `str` - **arrival**: `str` # Output - The `book_seat` and `cancel_seat` methods return `True` if the action succeeds, otherwise `False`. - The `search_flights` method returns a list of flight numbers that match the given departure and arrival locations. # Constraints - The number of flights in the system will not exceed 1000. - Seat booking and cancellation requests will not exceed 10,000 in total. - Flight numbers are unique strings consisting of alphanumeric characters. # Example ```python fs = FlightSystem() fs.add_flight(\\"AB123\\", \\"NYC\\", \\"LAX\\", 100) fs.add_flight(\\"CD456\\", \\"NYC\\", \\"LAX\\", 50) fs.add_flight(\\"EF789\\", \\"LAX\\", \\"SFO\\", 200) print(fs.book_seat(\\"AB123\\")) print(fs.book_seat(\\"AB123\\")) print(fs.cancel_seat(\\"AB123\\")) print(fs.search_flights(\\"NYC\\", \\"LAX\\")) ``` Expected Output: ``` True True True [\\"AB123\\", \\"CD456\\"] ``` # Instructions 1. Implement both `Flight` and `FlightSystem` classes. 2. Implement the methods to manage flights (`add_flight`, `book_seat`, `cancel_seat`). 3. Implement the method to search available flights (`search_flights`). 4. Make sure to handle edge cases such as booking a seat on a non-existent flight, canceling a non-existent booking, or searching for flights with no matches.","solution":"from typing import List, Dict class Flight: def __init__(self, flight_number: str, departure: str, arrival: str, seats: int): self.flight_number = flight_number self.departure = departure self.arrival = arrival self.total_seats = seats self.booked_seats = 0 def book_seat(self) -> bool: if self.booked_seats < self.total_seats: self.booked_seats += 1 return True return False def cancel_seat(self) -> bool: if self.booked_seats > 0: self.booked_seats -= 1 return True return False class FlightSystem: def __init__(self): self.flights: Dict[str, Flight] = {} def add_flight(self, flight_number: str, departure: str, arrival: str, seats: int): if flight_number not in self.flights: self.flights[flight_number] = Flight(flight_number, departure, arrival, seats) def book_seat(self, flight_number: str) -> bool: if flight_number in self.flights: return self.flights[flight_number].book_seat() return False def cancel_seat(self, flight_number: str) -> bool: if flight_number in self.flights: return self.flights[flight_number].cancel_seat() return False def search_flights(self, departure: str, arrival: str) -> List[str]: result = [] for flight in self.flights.values(): if flight.departure == departure and flight.arrival == arrival: result.append(flight.flight_number) return result"},{"question":"# Programming Question: Implement a Priority Queue You are tasked with implementing a priority queue using a binary heap. The priority queue should be able to handle different types (integers, floats, strings, etc.) and allow for dynamic insertion and extraction of elements based on their priority. **Function Signature:** ```python class PriorityQueue: def __init__(self): Initializes an empty Priority Queue. pass def push(self, value): Pushes a value onto the priority queue. :param value: The value to be added. pass def pop(self): Removes and returns the highest priority element from the queue. :return: The highest priority element. pass def peek(self): Returns the highest priority element without removing it from the queue. :return: The highest priority element. pass def is_empty(self): Checks if the priority queue is empty. :return: True if the queue is empty, False otherwise. pass ``` # Constraints * PriorityQueue must support any number of elements up to a total of `10^6`. * Elements are comparable and have a valid `__lt__` method, enabling comparisons. * The `pop` method must operate in O(log n) time complexity. * The `push` method must operate in O(log n) time complexity. * The `peek` method must operate in O(1) time complexity. * The `is_empty` method must operate in O(1) time complexity. # Input & Output Examples 1. **Example 1:** ```python pq = PriorityQueue() pq.push(4) pq.push(2) pq.push(6) pq.pop() # Output: 6 pq.peek() # Output: 4 pq.is_empty() # Output: False ``` 2. **Example 2:** ```python pq = PriorityQueue() pq.push(\'apple\') pq.push(\'banana\') pq.push(\'cherry\') pq.pop() # Output: \'cherry\' pq.peek() # Output: \'banana\' pq.is_empty() # Output: False ``` 3. **Example 3:** ```python pq = PriorityQueue() pq.push(3.1) pq.push(1.4) pq.push(2.5) pq.pop() # Output: 3.1 pq.peek() # Output: 2.5 pq.is_empty() # Output: False ``` 4. **Example 4:** ```python pq = PriorityQueue() pq.is_empty() # Output: True pq.push(10) pq.pop() # Output: 10 pq.is_empty() # Output: True ``` # Additional Notes * Your implementation must ensure that operations abide by the heap property. * The priority queue should dynamically resize as needed without performance degradation. * Consider edge cases like handling ties in priority and empty queue operations.","solution":"import heapq class PriorityQueue: def __init__(self): Initializes an empty Priority Queue. self.heap = [] def push(self, value): Pushes a value onto the priority queue. :param value: The value to be added. heapq.heappush(self.heap, value) def pop(self): Removes and returns the highest priority element from the queue. :return: The highest priority element. if self.is_empty(): raise IndexError(\\"pop from an empty priority queue\\") return heapq.heappop(self.heap) def peek(self): Returns the highest priority element without removing it from the queue. :return: The highest priority element. if self.is_empty(): raise IndexError(\\"peek from an empty priority queue\\") return self.heap[0] def is_empty(self): Checks if the priority queue is empty. :return: True if the queue is empty, False otherwise. return len(self.heap) == 0"},{"question":"# Coding Assessment Question You are tasked with implementing a function that finds the highest bit set in the binary representation of a given integer. Objective: Write a function `highest_bit_set(n: int) -> int` that takes an integer `n` and returns the position of the highest bit set (starting from 1 for the least significant bit). Input: - `n` (1 <= n <= 10^9): an integer that represents the value to analyze. Output: - Returns an integer indicating the position of the highest bit set in the binary representation of the given number. Example: ```python assert highest_bit_set(1) == 1 assert highest_bit_set(16) == 5 assert highest_bit_set(9) == 4 ``` Constraints: - Ensure that your solution runs efficiently even for the upper limit of the input range. - Your solution should work correctly for all edge cases, including when `n` is the smallest or largest possible value. Performance Requirements: - Aim for a time complexity of O(1) for determining the highest bit position. - Utilize precise and efficient bit manipulation techniques to determine the position.","solution":"def highest_bit_set(n: int) -> int: Finds the highest bit set in the binary representation of n. if n <= 0: raise ValueError(\\"Input must be a positive integer.\\") position = 0 while n > 0: position += 1 n >>= 1 return position"},{"question":"# Problem Statement Design and implement a simplified blockchain for a cryptocurrency system, simulating the basic functionalities such as creating transactions, mining blocks, and validating the chain. Requirements: 1. **Function Name**: `Blockchain` 2. **Methods**: - `__init__`: Initializes the blockchain with the genesis block. - `create_transaction`: Accepts sender, recipient, and amount, and stores the transaction. - `mine_block`: Mines a new block using the stored transactions, and resets the transaction pool. - `is_chain_valid`: Validates the entire blockchain by checking hashes and breaks in the chain. 3. **Classes**: - **Transaction**: Represents individual transactions. - **Block**: Represents individual blocks on the blockchain. - **Blockchain**: Manages the chain, transactions, and blocks. 4. **Input**: - For `create_transaction` method: - `sender`: A string representing the sender\'s address. - `recipient`: A string representing the recipient\'s address. - `amount`: A numeric value representing the amount of cryptocurrency transferred. - For `mine_block` method: - No input. - For `is_chain_valid` method: - No input. 5. **Output**: - For `create_transaction` method: - No return. - For `mine_block` method: - Returns the newly created Block object. - For `is_chain_valid` method: - Returns a boolean indicating if the chain is valid or not. 6. **Constraints**: - Ensure that each block has a unique hash. - The hash of each block must be a SHA-256 hash of its contents (previous hash, timestamp, transactions). - Transactions should be stored in a list within each block. - The transactions list should be reset after a block is mined. - Genesis block should be created upon initialization of the Blockchain. Scenario You have been approached by a startup to develop a lightweight simulation of a blockchain for their new cryptocurrency. The system should allow for creating transactions, mining new blocks with these transactions, and verifying the integrity of the entire blockchain. Implement the following class structure to model this system: ```python from typing import List import hashlib import time class Transaction: def __init__(self, sender: str, recipient: str, amount: float): self.sender = sender self.recipient = recipient self.amount = amount class Block: def __init__(self, previous_hash: str, transactions: List[Transaction], timestamp=None): self.previous_hash = previous_hash self.timestamp = timestamp or time.time() self.transactions = transactions self.hash = self.calculate_hash() def calculate_hash(self) -> str: transactions_str = \'\'.join([f\'{t.sender}{t.recipient}{t.amount}\' for t in self.transactions]) block_string = f\'{self.previous_hash}{self.timestamp}{transactions_str}\' return hashlib.sha256(block_string.encode()).hexdigest() class Blockchain: def __init__(self): self.chain = [self.create_genesis_block()] self.transactions = [] def create_genesis_block(self) -> Block: return Block(\'0\', []) def create_transaction(self, sender: str, recipient: str, amount: float): transaction = Transaction(sender, recipient, amount) self.transactions.append(transaction) def mine_block(self): new_block = Block(self.chain[-1].hash, self.transactions) self.transactions = [] self.chain.append(new_block) return new_block def is_chain_valid(self) -> bool: for i in range(1, len(self.chain)): current_block = self.chain[i] previous_block = self.chain[i - 1] if current_block.hash != current_block.calculate_hash(): return False if current_block.previous_hash != previous_block.hash: return False return True ```","solution":"from typing import List, Optional import hashlib import time class Transaction: def __init__(self, sender: str, recipient: str, amount: float): self.sender = sender self.recipient = recipient self.amount = amount class Block: def __init__(self, previous_hash: str, transactions: List[Transaction], timestamp: Optional[float] = None): self.previous_hash = previous_hash self.timestamp = timestamp or time.time() self.transactions = transactions self.hash = self.calculate_hash() def calculate_hash(self) -> str: transactions_str = \'\'.join([f\'{t.sender}{t.recipient}{t.amount}\' for t in self.transactions]) block_string = f\'{self.previous_hash}{self.timestamp}{transactions_str}\' return hashlib.sha256(block_string.encode()).hexdigest() class Blockchain: def __init__(self): self.chain = [self.create_genesis_block()] self.transactions = [] def create_genesis_block(self) -> Block: return Block(\'0\', []) def create_transaction(self, sender: str, recipient: str, amount: float): transaction = Transaction(sender, recipient, amount) self.transactions.append(transaction) def mine_block(self): new_block = Block(self.chain[-1].hash, self.transactions) self.transactions = [] self.chain.append(new_block) return new_block def is_chain_valid(self) -> bool: for i in range(1, len(self.chain)): current_block = self.chain[i] previous_block = self.chain[i - 1] if current_block.hash != current_block.calculate_hash(): return False if current_block.previous_hash != previous_block.hash: return False return True"},{"question":"# **Coding Assessment Question: Implement a Red-Black Tree** As a software engineer, your task is to design an efficient balanced binary search tree that can maintain a dynamically changing dataset. One of the widely used self-balancing trees is the Red-Black Tree which ensures the tree is balanced after every insert and delete operation, thus maintaining an optimal time complexity for search, insert, and delete operations. **Task**: Design and implement a Red-Black Tree class with insert and search functionalities. Ensure that the tree properties are maintained after each insertion. **Red-Black Tree Properties**: 1. Every node is either red or black. 2. The root is always black. 3. Every leaf (null node) is black. 4. If a red node has children then, the children are always black (no two red nodes can be adjacent). 5. Every path from a node to its descendant leaves has the same number of black nodes (black-height). **Input and Notes**: 1. Create a class `RedBlackTree`. ```python class RedBlackTree: def __init__(self): # Initializes an empty Red-Black Tree def insert(self, key: int) -> None: # Inserts a node with the given key into the tree def search(self, key: int) -> bool: # Returns True if a node with the given key exists in the tree, False otherwise ``` 2. The keys in the tree are unique integers. 3. Implement necessary helper methods to maintain Red-Black Tree properties. 4. Nodes may also have additional attributes like parent, color, and left and right children pointers. **Output**: 1. `insert`: Updates the tree by adding a new integer key while maintaining Red-Black Tree properties. 2. `search`: Returns whether a node with the specified key exists in the tree. **Constraints**: * **Performance**: Ensure that the time complexity for insert and search is O(log n). **Example**: ```python rbt = RedBlackTree() rbt.insert(10) rbt.insert(20) rbt.insert(30) rbt.insert(15) rbt.insert(25) assert rbt.search(10) == True assert rbt.search(15) == True assert rbt.search(25) == True assert rbt.search(5) == False # Properties: # The tree is balanced as per Red-Black Tree rules after each insert. # The search operations return the correct results based on the current tree structure. ``` Implement the `RedBlackTree` class, ensuring efficient insertions and searches while maintaining the Red-Black Tree properties.","solution":"class Node: def __init__(self, key, color=\\"red\\"): self.key = key self.color = color self.left = None self.right = None self.parent = None class RedBlackTree: def __init__(self): self.NIL = Node(key=None, color=\\"black\\") self.root = self.NIL def insert(self, key: int) -> None: new_node = Node(key) new_node.left = self.NIL new_node.right = self.NIL parent = None current = self.root while current != self.NIL: parent = current if new_node.key < current.key: current = current.left else: current = current.right new_node.parent = parent if parent is None: self.root = new_node elif new_node.key < parent.key: parent.left = new_node else: parent.right = new_node if new_node.parent is None: new_node.color = \\"black\\" return if new_node.parent.parent is None: return self.fix_insert(new_node) def fix_insert(self, k): while k.parent.color == \\"red\\": if k.parent == k.parent.parent.right: u = k.parent.parent.left # uncle if u.color == \\"red\\": u.color = \\"black\\" k.parent.color = \\"black\\" k.parent.parent.color = \\"red\\" k = k.parent.parent else: if k == k.parent.left: k = k.parent self.right_rotate(k) k.parent.color = \\"black\\" k.parent.parent.color = \\"red\\" self.left_rotate(k.parent.parent) else: u = k.parent.parent.right # uncle if u.color == \\"red\\": u.color = \\"black\\" k.parent.color = \\"black\\" k.parent.parent.color = \\"red\\" k = k.parent.parent else: if k == k.parent.right: k = k.parent self.left_rotate(k) k.parent.color = \\"black\\" k.parent.parent.color = \\"red\\" self.right_rotate(k.parent.parent) if k == self.root: break self.root.color = \\"black\\" def left_rotate(self, x): y = x.right x.right = y.left if y.left != self.NIL: y.left.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def right_rotate(self, x): y = x.left x.left = y.right if y.right != self.NIL: y.right.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y def search(self, key: int) -> bool: current = self.root while current != self.NIL: if key == current.key: return True elif key < current.key: current = current.left else: current = current.right return False"},{"question":"# Question: Implement a Custom Sorting Algorithm for a Specific Scenario You are employed by a logistics company that needs to sort delivery addresses optimally based on a specific set of rules to minimize delivery time. You are required to implement a custom sorting function that orders addresses according to the following criteria: 1. Addresses starting with a digit should come first. 2. Among addresses starting with a digit, sort them lexicographically. 3. Followed by addresses starting with an uppercase letter, sorted lexicographically. 4. Finally, addresses starting with a lowercase letter, sorted lexicographically. Task Implement the function `custom_sort(addresses: List[str]) -> List[str]` that sorts a list of delivery addresses based on the given criteria. Function Signature ```python from typing import List def custom_sort(addresses: List[str]) -> List[str]: pass ``` Input * `addresses`: a list of delivery address strings. - Constraints: (1 leq text{len(addresses)} leq 10^5) - Each address is a non-empty string containing alphanumeric characters and spaces, with a maximum length of (100). Output * Returns a list of addresses sorted based on the specified rules. Example ```python addresses = [ \\"123 Main St\\", \\"45 Apple Rd\\", \\"apple orchard\\", \\"Zebra Lane\\", \\"678 Pine St\\", \\"zebra cave\\", \\"Almond Ave\\", \\"49 zebra plaza\\" ] print(custom_sort(addresses)) # Expected output: [ # \\"123 Main St\\", # \\"45 Apple Rd\\", # \\"49 zebra plaza\\", # \\"678 Pine St\\", # \\"Almond Ave\\", # \\"Zebra Lane\\", # \\"apple orchard\\", # \\"zebra cave\\" # ] ``` Constraints 1. **Efficiency**: Your solution should sort up to (10^5) addresses efficiently. 2. **Correctness**: Ensure the sorting is done accurately based on the provided criteria. Use this example as a reference and aim to test your function with different sets of addresses to ensure its correctness and efficiency.","solution":"from typing import List def custom_sort(addresses: List[str]) -> List[str]: def sorting_key(address: str): if address[0].isdigit(): return (0, address) elif address[0].isupper(): return (1, address) else: return (2, address) return sorted(addresses, key=sorting_key)"},{"question":"# Problem Statement: You are required to implement a function that determines the nth Fibonacci number using an optimized approach such as Dynamic Programming. Your function should handle large values of `n` efficiently, avoiding the limitations of a naïve recursive approach. # Function Signature: ``` def fibonacci(n: int) -> int: ``` # Input: - `n`: an integer denoting the position in the Fibonacci sequence (0-indexed). # Output: - An integer representing the nth Fibonacci number. # Constraints: * `n` will be an integer in the range [0, 10000]. # Example: Example 1: ``` Input: n = 6 Output: 8 ``` Example 2: ``` Input: n = 10 Output: 55 ``` Example 3: ``` Input: n = 0 Output: 0 ``` # Requirements: - Optimize for both time and space complexity. - Do not use the built-in Fibonacci or mathematical libraries. - Ensure the solution handles edge cases, such as `n` being zero or one. # Hint: Consider using an iterative approach with a bottom-up dynamic programming technique to store intermediate results and avoid recomputation.","solution":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Problem Statement You are tasked with implementing a feature for a food delivery application that automatically adjusts delivery times based on detected traffic patterns. Given a history of recorded delivery times and corresponding traffic conditions, you will create a function that predicts the delivery time for new orders based on current traffic conditions. Use linear regression to model the relationship between traffic conditions and delivery times. # Function Signature ```python def predict_delivery_time(history: list[tuple[float, float]], new_traffic_condition: float) -> float: pass ``` # Input - `history`: A list of tuples where each tuple contains two floats representing past traffic conditions and the corresponding delivery times. - `new_traffic_condition`: A float representing the current traffic condition for which you need to predict the delivery time. # Output - A float representing the predicted delivery time for the new traffic condition. # Constraints - The length of `history` will be between 2 and 1000. - Traffic conditions and delivery times are positive floats. # Example ```python # Example usage history = [ (0.5, 30.0), (0.8, 35.0), (1.0, 40.0), (1.2, 45.0), (1.5, 50.0) ] new_traffic_condition = 1.1 # Example expected output # For new_traffic_condition = 1.1, the expected output could be around 42.5 predict_delivery_time(history, new_traffic_condition) ``` # Task Description 1. **Data Preparation**: Extract the features (traffic conditions) and targets (delivery times) from the history. 2. **Linear Regression Model**: Use simple linear regression to estimate the relationship between traffic conditions and delivery times. 3. **Prediction**: Apply the fitted model to predict the delivery time for the new traffic condition. 4. **Edge Cases & Performance**: Handle edge cases such as minimal history data and large datasets efficiently.","solution":"from sklearn.linear_model import LinearRegression from typing import List, Tuple def predict_delivery_time(history: List[Tuple[float, float]], new_traffic_condition: float) -> float: Predicts the delivery time for a new traffic condition based on the provided history using linear regression. :param history: A list of tuples where each tuple contains two floats representing past traffic conditions and the corresponding delivery times. :param new_traffic_condition: A float representing the current traffic condition for which to predict the delivery time. :return: A float representing the predicted delivery time for the new traffic condition. # Extract features (traffic conditions) and targets (delivery times) from the history X = [[traffic] for traffic, time in history] y = [time for traffic, time in history] # Create and fit the linear regression model model = LinearRegression() model.fit(X, y) # Predict the delivery time for the new traffic condition predicted_time = model.predict([[new_traffic_condition]]) return predicted_time[0]"},{"question":"# Coding Assessment Question: You are given a list of integers which can contain positive, negative, and zero values. Your task is to implement a function `sum_unique` that returns the sum of all unique integers in the list. # Function Signature: ```python def sum_unique(nums: list[int]) -> int: pass ``` # Input: * A list `nums` containing integers (both positive and negative and zeros). * Constraints: The length of the list `nums` is 0 <= len(nums) <= 10^6. # Output: * Returns an integer which is the sum of all unique integers in the list. # Examples: ```python >>> sum_unique([1, 2, 3, 2, 4, 4, 5]) 15 >>> sum_unique([-1, -1, 2, 3, 3]) 4 >>> sum_unique([0, 0, 0]) 0 >>> sum_unique([1, 1, 1, 1]) 1 >>> sum_unique([]) 0 ``` # Performance Requirements: * The solution must have a time complexity of O(n) and a space complexity of O(n), where n is the length of the input list.","solution":"def sum_unique(nums: list[int]) -> int: Returns the sum of all unique integers in the list. return sum(set(nums))"},{"question":"# Scenario You are responsible for creating the specifications for processing textual data in a document analysis tool. The tool performs a series of operations, one of which involves counting the frequency of all words in a given document and listing the most common words. # Task You need to write two functions, `count_words` and `most_common_words`, that will handle the word frequency analysis of a given text. # Details 1. **count_words(text: str) -> dict**: * Takes a string `text`, processes it to count the occurrences of each word, and returns a dictionary where the keys are words and the values are their respective counts. 2. **most_common_words(word_count: dict, n: int) -> list**: * Takes the word count dictionary generated by `count_words` and an integer `n`, and returns a list of the `n` most common words sorted by their frequency in descending order. # Input and Output * **Input Format**: * For `count_words`, the input is a single string `text` which can contain spaces, letters, and punctuation. * For `most_common_words`, the input consists of a dictionary `word_count` and an integer `n`. * **Output Format**: * `count_words` should return a dictionary with word frequencies. * `most_common_words` should return a list of strings representing the most common words. # Constraints * Words are case-insensitive and should be converted to lowercase. * Punctuation should be ignored (treated as word separators). * The value of `n` will be within the range [1, length of word_count). # Examples * Example 1: ```python text = \\"Hello, world! Hello world.\\" word_count = count_words(text) # {\'hello\': 2, \'world\': 2} most_common_words(word_count, 1) # [\'hello\'] ``` * Example 2: ```python text = \\"Python is great, and Python is fun. Fun is good!\\" word_count = count_words(text) # {\'python\': 2, \'is\': 3, \'great\': 1, \'and\': 1, \'fun\': 2, \'good\': 1} most_common_words(word_count, 2) # [\'is\', \'python\'] ``` # Additional Considerations 1. Ensure your functions handle edge cases correctly, such as empty texts, texts with only punctuation, and mixed-case words. 2. Consider the performance implications of processing large texts and ensure your functions are efficient. --- This new question covers similar programming concepts and challenges as the sample question, such as dealing with strings and efficient processing of text. It introduces a new context - document analysis - while maintaining the style, complexity, and scope of the original set.","solution":"import re from collections import Counter def count_words(text: str) -> dict: Takes a string text, processes it to count the occurrences of each word, and returns a dictionary where the keys are words and the values are their respective counts. words = re.findall(r\'bw+b\', text.lower()) word_count = Counter(words) return dict(word_count) def most_common_words(word_count: dict, n: int) -> list: Takes the word count dictionary generated by count_words and an integer n, and returns a list of the n most common words sorted by their frequency in descending order. return [word for word, _ in Counter(word_count).most_common(n)]"},{"question":"# Coding Challenge: Single-Linked List with Kth Element Retrieval **Context**: A singly linked list is a linear data structure that consists of nodes where each node contains a data part and a reference to the next node in the sequence. # Task Implement a class `LinkedList` that supports the following operations: 1. **Append Element**: Append an element to the end of the list. 2. **Prepend Element**: Prepend an element to the beginning of the list. 3. **Delete Element**: Delete an element from the list. 4. **Retrieve Kth Element**: Retrieve the k-th element from the start (0-based index). # Input and Output - **Append Operation**: - Method: `append(data: int) -> None` - Input: Integer data. - Output: None. - **Prepend Operation**: - Method: `prepend(data: int) -> None` - Input: Integer data. - Output: None. - **Delete Operation**: - Method: `delete(data: int) -> bool` - Input: Integer data. - Output: True if the element was found and deleted, False otherwise. - **Retrieve Kth Element**: - Method: `get_kth_element(k: int) -> int | None` - Input: Integer k (0-based index). - Output: Integer data or None if the element does not exist. # Constraints 1. The list should appropriately handle appending, prepending, and deleting nodes. 2. Ensure efficient traversal to retrieve the k-th element. 3. Edge cases such as attempting to retrieve a k-th element that does not exist, and deleting elements that are not in the list should be considered. # Scenario Create a `LinkedList` instance and perform the following operations: ```python class Node: def __init__(self, data: int) -> None: self.data = data self.next = None class LinkedList: def __init__(self) -> None: self.head = None def append(self, data: int) -> None: pass # Implement the append operation def prepend(self, data: int) -> None: pass # Implement the prepend operation def delete(self, data: int) -> bool: pass # Implement the delete operation def get_kth_element(self, k: int) -> int | None: pass # Implement the retrieval of the k-th element if __name__ == \\"__main__\\": ll = LinkedList() ll.append(10) ll.append(20) ll.append(30) print(ll.get_kth_element(1)) # Expected Output: 20 ll.prepend(5) print(ll.get_kth_element(0)) # Expected Output: 5 ll.delete(20) print(ll.get_kth_element(1)) # Expected Output: 10 print(ll.delete(50)) # Expected Output: False (since 50 is not in the list) print(ll.get_kth_element(4)) # Expected Output: None (since there\'s no 4th element) ``` Make sure the class handles all possible edge cases such as trying to delete non-existing elements, and retrieving elements that are out-of-bound of the current list size.","solution":"class Node: def __init__(self, data: int) -> None: self.data = data self.next = None class LinkedList: def __init__(self) -> None: self.head = None def append(self, data: int) -> None: new_node = Node(data) if not self.head: self.head = new_node return curr = self.head while curr.next: curr = curr.next curr.next = new_node def prepend(self, data: int) -> None: new_node = Node(data) new_node.next = self.head self.head = new_node def delete(self, data: int) -> bool: curr = self.head if not curr: return False if curr.data == data: self.head = curr.next return True prev = None while curr and curr.data != data: prev = curr curr = curr.next if not curr: return False prev.next = curr.next return True def get_kth_element(self, k: int) -> int | None: curr = self.head count = 0 while curr: if count == k: return curr.data count += 1 curr = curr.next return None"},{"question":"# Scenario You are building a tool to identify prime factors of a number and determine the frequency of each prime factor. This tool will help in various mathematical analyses where understanding prime factorization plays a critical role. # Task Write a function `prime_factors_count` that receives an integer and returns a dictionary where keys are the prime factors and values are their respective counts in the prime factorization of the given number. # Input/Output - **Input**: An integer `n` (2 <= n <= 10^6) - **Output**: A dictionary with prime factors as keys and their counts as values. # Constraints - Efficiently handle the factorization to ensure performance is acceptable even for large numbers. - Use appropriate algorithms and data structures to handle this problem within constraints. # Function Signature ```python def prime_factors_count(n: int) -> dict: ``` # Example ```python # Example inputs and expected outputs: print(prime_factors_count(360)) # Output should be {2: 3, 3: 2, 5: 1} print(prime_factors_count(1001)) # Output should be {7: 1, 11: 1, 13: 1} ``` # Notes Ensure your function correctly identifies all prime factors and their frequencies. Consider edge cases such as powers of primes and composite numbers with multiple distinct prime factors.","solution":"def prime_factors_count(n): Returns a dictionary with prime factors of n as keys and their counts as values. factors = {} # Start with the smallest prime number divisor = 2 while n > 1: if n % divisor == 0: if divisor in factors: factors[divisor] += 1 else: factors[divisor] = 1 n //= divisor else: divisor += 1 return factors"},{"question":"# Scenario You are tasked with developing a function that processes customer orders for an e-commerce platform. The function should calculate the total cost, including shipping charges, and return a detailed invoice in the form of a string. The platform has a specific pricing model and shipping rules. # Task Write a Python function `calculate_invoice(orders: List[Dict[str, Union[str, int]]], shipping_country: str) -> str` that accepts a list of orders where each order is represented as a dictionary with an item name, quantity, and price. Additionally, you are given the shipping country as a string. Your function should compute the total cost including item prices and determine the shipping charges based on the country provided. # Requirements - Use the following shipping rates: - \\"USA\\" : 10 - \\"Canada\\" : 15 - \\"Other\\" : 25 - Calculate the total cost by summing up the price of each item multiplied by its quantity, then adding the shipping cost. - Format the invoice string as shown in the example below, including a breakdown of each item and the total cost at the end. - Ensure proper error handling for invalid inputs such as missing keys in the order dictionaries or invalid shipping country. # Input and Output - **Input**: - `orders` (List[Dict[str, Union[str, int]]]): A list of dictionaries, each representing an order with keys \\"item\\", \\"quantity\\", and \\"price\\". - `shipping_country` (str): The country where the order will be shipped (e.g., \\"USA\\", \\"Canada\\", \\"Other\\"). - **Output**: The function should return a string formatted as an invoice showing the breakdown of the items and the total cost including shipping. # Code Template ```python from typing import List, Dict, Union def calculate_invoice(orders: List[Dict[str, Union[str, int]]], shipping_country: str) -> str: shipping_rates = { \\"USA\\": 10, \\"Canada\\": 15, \\"Other\\": 25 } if shipping_country not in shipping_rates: return \\"Invalid shipping country.\\" try: total_cost = 0 invoice_lines = [] for order in orders: item = order[\\"item\\"] quantity = order[\\"quantity\\"] price = order[\\"price\\"] cost = quantity * price total_cost += cost invoice_lines.append(f\\"{item}: {quantity} x {price} = {cost}\\") shipping_cost = shipping_rates[shipping_country] total_cost += shipping_cost invoice_lines.append(f\\"Shipping ({shipping_country}): {shipping_cost}\\") invoice_lines.append(f\\"Total: {total_cost}\\") invoice = \\"n\\".join(invoice_lines) except KeyError as e: return f\\"Missing key in order: {e}\\" except TypeError: return \\"Invalid order data.\\" return invoice # Example usage (do not include in submission): # orders = [ # {\\"item\\": \\"T-Shirt\\", \\"quantity\\": 2, \\"price\\": 20}, # {\\"item\\": \\"Jeans\\", \\"quantity\\": 1, \\"price\\": 50} # ] # print(calculate_invoice(orders, \\"USA\\")) ``` # Example Input and Output **Input**: ```python orders = [ {\\"item\\": \\"T-Shirt\\", \\"quantity\\": 2, \\"price\\": 20}, {\\"item\\": \\"Jeans\\", \\"quantity\\": 1, \\"price\\": 50} ] shipping_country = \\"USA\\" ``` **Output**: ``` T-Shirt: 2 x 20 = 40 Jeans: 1 x 50 = 50 Shipping (USA): 10 Total: 100 ``` **Constraints**: - Ensure inputs are validated and errors are handled gracefully. - Aim to handle up to 10 orders efficiently. - Mock inputs for testing purposes to avoid real transactions.","solution":"from typing import List, Dict, Union def calculate_invoice(orders: List[Dict[str, Union[str, int]]], shipping_country: str) -> str: shipping_rates = { \\"USA\\": 10, \\"Canada\\": 15, \\"Other\\": 25 } if shipping_country not in shipping_rates: return \\"Invalid shipping country.\\" try: total_cost = 0 invoice_lines = [] for order in orders: item = order[\\"item\\"] quantity = order[\\"quantity\\"] price = order[\\"price\\"] cost = quantity * price total_cost += cost invoice_lines.append(f\\"{item}: {quantity} x {price} = {cost}\\") shipping_cost = shipping_rates[shipping_country] total_cost += shipping_cost invoice_lines.append(f\\"Shipping ({shipping_country}): {shipping_cost}\\") invoice_lines.append(f\\"Total: {total_cost}\\") invoice = \\"n\\".join(invoice_lines) except KeyError as e: return f\\"Missing key in order: {e}\\" except TypeError: return \\"Invalid order data.\\" return invoice"},{"question":"# Context You are working on a system that involves processing a sequence of operations on a 2D plane. Each operation is either to draw a rectangle or query the total area covered by the rectangles. Simply drawing the rectangles directly and computing the total area would be inefficient due to potential overlaps. Therefore, you need to efficiently manage these operations and keep track of the covered area using a data structure. # Task Implement a `RectangleManager` class that efficiently supports adding rectangles and querying the total covered area on a 2D plane. # Specifications `__init__(self) -> None` Initializes the rectangle manager with no rectangles. `add_rectangle(self, x1: int, y1: int, x2: int, y2: int) -> None` Adds a rectangle to the plane. The rectangle is defined by its bottom-left corner (`x1`, `y1`) and top-right corner (`x2`, `y2`). `total_area(self) -> int` Queries the total area covered by all rectangles added so far, accounting for any overlaps. Input/Output - The `add_rectangle` method takes four integers `x1`, `y1`, `x2`, `y2` as input, representing the coordinates of the bottom-left and top-right corners of the rectangle. - The `total_area` method returns an integer representing the total area covered by all rectangles. # Example ```python # Example usage: rm = RectangleManager() rm.add_rectangle(1, 1, 3, 3) rm.add_rectangle(2, 2, 4, 4) rm.add_rectangle(5, 5, 6, 6) assert rm.total_area() == 7 # Area of three rectangles, with overlap considered ``` Implement the `RectangleManager` class such that it correctly manages the rectangles and efficiently computes the total covered area. Ensure that it handles any overlaps appropriately and optimally.","solution":"class RectangleManager: def __init__(self): self.rectangles = [] def add_rectangle(self, x1, y1, x2, y2): self.rectangles.append((x1, y1, x2, y2)) def total_area(self): # Utility function to calculate intersection area def rect_intersection_area(r1, r2): x_left = max(r1[0], r2[0]) y_bottom = max(r1[1], r2[1]) x_right = min(r1[2], r2[2]) y_top = min(r1[3], r2[3]) if x_right > x_left and y_top > y_bottom: return (x_right - x_left) * (y_top - y_bottom) return 0 # Each added rectangle\'s area total_raw_area = sum((r[2] - r[0]) * (r[3] - r[1]) for r in self.rectangles) # Subtract overlapping areas to get actual covered area overlap_area = 0 n = len(self.rectangles) for i in range(n): for j in range(i + 1, n): overlap_area += rect_intersection_area(self.rectangles[i], self.rectangles[j]) return total_raw_area - overlap_area"},{"question":"# Question: Implement a Stock Price Analyzer In this exercise, you are to implement a Python function that retrieves historical stock prices and calculates the moving average for a given period. Function Signature ```python def stock_moving_average(stock_symbol: str, days: int) -> float: ``` Input * A string `stock_symbol` representing the ticker symbol of the stock (e.g., \'AAPL\', \'GOOGL\', \'MSFT\'). * An integer `days` representing the period over which the moving average should be calculated. Output * A float representing the moving average of the stock price over the given period of days. Constraints * You must use the provided URL template to fetch the stock prices in JSON format: ``` url = \\"https://financialmodelingprep.com/api/v3/historical-price-full/{stock_symbol}?apikey=demo\\" ``` * The JSON structure contains the historical prices in an array under `historical`, with each price record containing fields `date` and `close`. * You must handle network errors and invalid inputs gracefully. * The value of `days` must be a positive integer and less than or equal to the number of available historical prices for the stock. Requirements * The function must use the `requests` library to make an HTTP GET request. * It should parse the JSON content to extract the closing prices for the calculation. * You must handle cases where the JSON structure differs or the data is not available. * Validate the inputs and provide meaningful error messages for invalid inputs. # Example Usage ```python print(stock_moving_average(\\"AAPL\\", 5)) ```","solution":"import requests def stock_moving_average(stock_symbol: str, days: int) -> float: Fetches historical stock prices and calculates the moving average for a given period. :param stock_symbol: Ticker symbol of the stock. :param days: The period over which the moving average should be calculated. :return: The moving average of the stock price over the given period. if not isinstance(stock_symbol, str): raise ValueError(\\"Stock symbol must be a string.\\") if not isinstance(days, int) or days <= 0: raise ValueError(\\"Days must be a positive integer.\\") url = f\\"https://financialmodelingprep.com/api/v3/historical-price-full/{stock_symbol}?apikey=demo\\" response = requests.get(url) if response.status_code != 200: raise RuntimeError(f\\"Failed to fetch stock data: HTTP {response.status_code}\\") data = response.json() if \\"historical\\" not in data: raise ValueError(\\"Invalid data format from API.\\") historical_prices = data[\\"historical\\"] if len(historical_prices) < days: raise ValueError(\\"Not enough historical data available to compute the moving average.\\") closing_prices = [entry[\'close\'] for entry in historical_prices[:days]] return sum(closing_prices) / days"},{"question":"# Coding Assessment Question You are developing software that simulates movements of agents in a 2D grid. Each agent starts at the origin (0, 0) and can move in four possible directions: up, down, left, and right. You need to calculate the final coordinates of the agent after a series of moves. **Function Specification:** Implement the function `final_coordinates` that takes a list of strings and returns a tuple representing the final coordinates of the agent after processing all the moves. Each move is represented by a single character string: `\'U\'` for up, `\'D\'` for down, `\'L\'` for left, and `\'R\'` for right. ```python def final_coordinates(moves: list[str]) -> tuple[int, int]: pass ``` # Input - `moves` (a list of strings): List containing moves, each being one of `\'U\'`, `\'D\'`, `\'L\'`, or `\'R\'`. The list may be empty. # Output - Returns a tuple (int, int) representing the final coordinates of the agent after processing the moves. # Constraints - The length of the list is arbitrarily large, and performance should be efficient for large inputs. - Each move in the list will be one of the valid characters (\'U\', \'D\', \'L\', \'R\'). # Requirements - Handle the case of an empty list by returning the starting coordinates `(0, 0)`. - The solution should be implemented with a time complexity of (O(n)) and space complexity of (O(1)). # Functionality Tests Ensure your function passes the following test cases: ```python >>> final_coordinates([\'U\', \'L\', \'D\', \'R\']) (0, 0) >>> final_coordinates([\'U\', \'U\', \'R\', \'R\']) (2, 2) >>> final_coordinates([\'D\', \'D\', \'L\', \'L\', \'U\']) (-2, -1) >>> final_coordinates([\'R\', \'R\', \'R\', \'U\', \'U\']) (3, 2) >>> final_coordinates([]) (0, 0) ``` # Scenario You are working on a gaming server where multiple agents need to be autonomously navigating a grid based on instructions. To determine their positions after a series of command instructions, you can utilize the `final_coordinates` function to know where an agent will end up, which is crucial for managing the game state and implementing mechanics such as collision detection or goal achievement.","solution":"def final_coordinates(moves): Calculate the final coordinates after a series of moves. Params: moves: list of strings representing moves (\'U\', \'D\', \'L\', \'R\') Returns: tuple of integers representing the final coordinates x, y = 0, 0 for move in moves: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 return (x, y)"},{"question":"# Problem Statement You have been provided with a function definition to implement the `running_median` algorithm. The `running_median` function should take an infinite generator `stream` which yields integers and update the median each time a new integer is generated. Your task is to implement this function to maintain and return the running median efficiently. # Requirements and Constraints 1. **Input**: - `stream`: An infinite generator that yields integers. Note that you will need to handle the streamed data on-the-fly as it comes in. 2. **Output**: - A generator that yields the median after each new integer from the input stream. 3. **Constraints**: - The generator stream will yield integer values continuously. - Each integer value will be in the range `[-10^6, 10^6]`. # Example **Input**: ```python def stream(): for value in [2, 1, 5, 7, 2, 0, 5]: yield value running_medians = running_median(stream()) print([next(running_medians) for _ in range(7)]) ``` **Output**: ``` [2, 1.5, 2, 3.5, 2, 2, 2] ``` # Instructions 1. Implement the function `running_median(stream: Generator[int, None, None]) -> Generator[float, None, None]`. 2. Ensure the function yields the correct running median value as the new integers are received. 3. Test your function thoroughly with different input streams to ensure correctness and efficiency. ```python import heapq from typing import Generator def running_median(stream: Generator[int, None, None]) -> Generator[float, None, None]: min_heap = [] # Will act as the right half max_heap = [] # Will act as the left half for num in stream: if len(max_heap) == 0 or num <= -max_heap[0]: heapq.heappush(max_heap, -num) else: heapq.heappush(min_heap, num) if len(max_heap) > len(min_heap) + 1: heapq.heappush(min_heap, -heapq.heappop(max_heap)) elif len(min_heap) > len(max_heap): heapq.heappush(max_heap, -heapq.heappop(min_heap)) if len(max_heap) == len(min_heap): yield (-max_heap[0] + min_heap[0]) / 2.0 else: yield -max_heap[0] # Example usage: # def stream(): # for value in [2, 1, 5, 7, 2, 0, 5]: # yield value # running_medians = running_median(stream()) # print([next(running_medians) for _ in range(7)]) ``` Use the above template and function implementations to test if the `running_median` behaves correctly as expected.","solution":"import heapq from typing import Generator def running_median(stream: Generator[int, None, None]) -> Generator[float, None, None]: min_heap = [] # Will act as the right half max_heap = [] # Will act as the left half for num in stream: if len(max_heap) == 0 or num <= -max_heap[0]: heapq.heappush(max_heap, -num) else: heapq.heappush(min_heap, num) if len(max_heap) > len(min_heap) + 1: heapq.heappush(min_heap, -heapq.heappop(max_heap)) elif len(min_heap) > len(max_heap): heapq.heappush(max_heap, -heapq.heappop(min_heap)) if len(max_heap) == len(min_heap): yield (-max_heap[0] + min_heap[0]) / 2.0 else: yield float(-max_heap[0])"},{"question":"# Question You are tasked with enhancing a system designed to parse and evaluate arithmetic expressions coded as strings into an Abstract Syntax Tree (AST). You are provided a class `ExpressionParser`, which currently supports basic operations such as addition and multiplication without operator precedence or parenthesis parsing. # Requirements Write a method `parse_and_evaluate` in the given `ExpressionParser` class. This method should: 1. **Convert the expression** from its string format into an abstract syntax tree. 2. **Evaluate the expression** based on the constructed AST. 3. **Support operator precedence** and handle parentheses correctly. # Function Signature ```python def parse_and_evaluate(self, expression: str) -> float: Parse the arithmetic expression and evaluate its result. Args: expression: The arithmetic expression as a string. Returns: The evaluated result of the expression as a float. Example: >>> ep = ExpressionParser() >>> ep.parse_and_evaluate(\\"3 + 5 * (2 - 4 / 2)\\") # doctest: +ELLIPSIS 1.0 pass ``` # Constraints 1. The expression can contain the operators `+` (addition), `-` (subtraction), `*` (multiplication), and `/` (division). 2. The methods should respect the standard operator precedence: `*` and `/` over `+` and `-`. 3. Parentheses should be handled to modify the precedence correctly. 4. The input expression will be a valid arithmetic expression. # Input * `expression`: A string representing a valid arithmetic expression. # Output * A float representing the evaluated result of the expression. # Assumptions 1. The expression will not contain any invalid characters and will be well-formed. 2. The number and operator spacing will be consistent (e.g., no consecutive operators without numbers). 3. The division by zero will be handled gracefully by returning `float(\'inf\')`. # Scenarios The implementation will be challenged to: 1. Correctly parse nested expressions with multiple levels of parentheses. 2. Apply operator precedence rules accurately. 3. Evaluate both simple and complex arithmetic expressions efficiently. # Example ```python # Example usage of ExpressionParser def f(): ep = ExpressionParser() # Example 1 result = ep.parse_and_evaluate(\\"3 + 2 * 2\\") assert result == 7.0, f\\"Expected 7.0, but got {result}\\" # Example 2 result = ep.parse_and_evaluate(\\"2 * (3 + 4) / 2\\") assert result == 7.0, f\\"Expected 7.0, but got {result}\\" # Example 3 result = ep.parse_and_evaluate(\\"(1 + 2 * 3) - (4 / 2)\\") assert result == 5.0, f\\"Expected 5.0, but got {result}\\" print(\\"All tests passed.\\") f() ```","solution":"import re class ExpressionParser: def parse_and_evaluate(self, expression: str) -> float: def parse_expression(tokens): def parse_factor(tokens): token = tokens.pop(0) if token == \'(\': result = parse_expression(tokens) tokens.pop(0) # remove \')\' return result return float(token) def parse_term(tokens): result = parse_factor(tokens) while tokens and tokens[0] in (\'*\', \'/\'): op = tokens.pop(0) if op == \'*\': result *= parse_factor(tokens) elif op == \'/\': divisor = parse_factor(tokens) if divisor == 0: return float(\'inf\') result /= divisor return result result = parse_term(tokens) while tokens and tokens[0] in (\'+\', \'-\'): op = tokens.pop(0) if op == \'+\': result += parse_term(tokens) elif op == \'-\': result -= parse_term(tokens) return result tokens = re.findall(r\'d+|+|-|*|/|(|)\', expression) return parse_expression(tokens)"},{"question":"# Context: You are developing a software that requires frequent calculations of prefix sums for a given list of integers. A prefix sum is the sum of all elements of the list up to a certain index. To optimize your software, you need a function that precomputes the prefix sums to efficiently return the sum for any given index. # Problem Statement: Write a function `compute_prefix_sums(arr: List[int]) -> List[int]` that takes a list of integers as input and returns a new list where the value at each index `i` is equal to the sum of the elements from index `0` to index `i` of the input list. Input and Output Formats: * **Input**: A single argument `arr` which is a list of integers. * **Output**: A list of integers representing the prefix sums. Constraints and Limitations: * The input list can be empty, in which case, the output should also be an empty list. * The input list can contain a mix of positive, negative, and zero values. * You should assume the list can be very large, so performance is important. Example: ```python >>> compute_prefix_sums([1, 2, 3]) [1, 3, 6] >>> compute_prefix_sums([-1, 2, -3, 4]) [-1, 1, -2, 2] >>> compute_prefix_sums([0, 0, 0]) [0, 0, 0] >>> compute_prefix_sums([]) [] >>> compute_prefix_sums([5]) [5] ``` # Performance Requirements: * The solution should ideally run in O(n) time complexity, where n is the length of the input list.","solution":"from typing import List def compute_prefix_sums(arr: List[int]) -> List[int]: Returns a list of prefix sums for the given list of integers. if not arr: return [] prefix_sums = [0] * len(arr) prefix_sums[0] = arr[0] for i in range(1, len(arr)): prefix_sums[i] = prefix_sums[i - 1] + arr[i] return prefix_sums"},{"question":"# Question: Maximum Width of Binary Tree Given the root of a binary tree, your task is to find its maximum width. The width of a binary tree is defined as the maximum width among all levels. The width of a level is defined as the number of nodes between the leftmost and rightmost non-null nodes inclusive (ignoring null nodes in between). # Function Signature ```python def max_width_of_binary_tree(root: Node) -> int: ``` # Input * `root`: The root node of the binary tree (Node object). # Output * Return an integer representing the maximum width of the binary tree. # Constraints * The number of nodes in the tree is in the range [1, 2000]. * -100 <= Node.value <= 100 # Example ```python class Node: def __init__(self, value: int): self.value = value self.left = None self.right = None tree = Node(1) tree.left = Node(3) tree.right = Node(2) tree.left.left = Node(5) tree.left.right = Node(3) tree.right.right = Node(9) # Example print(max_width_of_binary_tree(tree)) # Output: 4 ``` # Note * The maximum width occurs at the last level with node values [5, 3, None, 9] which gives a width of 4 (including the null in between). Implement the function to traverse the tree level by level and calculate the width by considering the distance between the first and last non-null nodes at each level.","solution":"import collections class Node: def __init__(self, value: int): self.value = value self.left = None self.right = None def max_width_of_binary_tree(root: Node) -> int: Returns the maximum width of the binary tree. if not root: return 0 max_width = 0 queue = collections.deque([(root, 0)]) # (node, index) while queue: level_length = len(queue) _, first_index = queue[0] for i in range(level_length): node, index = queue.popleft() if node.left: queue.append((node.left, 2 * index)) if node.right: queue.append((node.right, 2 * index + 1)) # Calculate the width of the current level _, last_index = queue[-1] if queue else (None, first_index) max_width = max(max_width, last_index - first_index + 1) return max_width"},{"question":"# Coding Problem: Find the Strongly Connected Components in a Directed Graph You are given a directed graph. Your task is to identify all the strongly connected components (SCCs) of the graph. A strongly connected component is a maximal subgraph where every vertex is reachable from every other vertex in the subgraph. # Function Signature ```python def find_sccs(graph: Dict[int, List[int]]) -> List[List[int]]: ``` # Input - `graph`: A dictionary representing a directed graph where the keys are node identifiers (integers) and the values are lists of adjacent nodes (also integers). # Output - A list of lists, where each inner list contains the nodes belonging to one strongly connected component. The order of components and nodes within each component does not matter. # Constraints - The graph may be disconnected. - The number of nodes, `n`, ranges from 1 to 10^5. - The number of edges, `m`, ranges from 0 to 10^6. # Example Input ```python graph = { 0: [1], 1: [2], 2: [0, 3], 3: [4], 4: [5, 7], 5: [6], 6: [4], 7: [8], 8: [3], } ``` Output ```python [[0, 1, 2], [3, 4, 5, 6, 7, 8]] ``` Explanation In the example graph: - There are two strongly connected components: - The first component includes nodes `[0, 1, 2]`, where each node is reachable from any other node in this subset. - The second component includes nodes `[3, 4, 5, 6, 7, 8]`, where each node is reachable from any other node in this subset. # Notes - You should implement an efficient algorithm to handle large inputs within reasonable time limits. - Consider edge cases such as single-node SCCs and graphs with no edges. - Algorithms such as Kosaraju\'s or Tarjan\'s can be used to find strongly connected components with a time complexity of O(V + E).","solution":"def find_sccs(graph): Finds and returns all strongly connected components in the given directed graph. Args: graph (dict): A dictionary representation of the directed graph where the keys are node identifiers (integers) and the values are lists of adjacent nodes (also integers). Returns: List[List[int]]: A list of lists, where each inner list contains the nodes belonging to one strongly connected component. # Initialize the variables index = 0 stack = [] indices = {} lowlink = {} on_stack = {} sccs = [] def strongconnect(v): nonlocal index # Set the depth index for v to the smallest unused index indices[v] = index lowlink[v] = index index += 1 stack.append(v) on_stack[v] = True # Consider successors of v for w in graph[v]: if w not in indices: # Successor w has not yet been visited; recurse on it strongconnect(w) lowlink[v] = min(lowlink[v], lowlink[w]) elif on_stack[w]: # Successor w is in stack and hence in the current SCC lowlink[v] = min(lowlink[v], indices[w]) # If v is a root node, pop the stack and generate an SCC if lowlink[v] == indices[v]: scc = [] while True: w = stack.pop() on_stack[w] = False scc.append(w) if w == v: break sccs.append(scc) # Initialize the graph traversal for v in graph: if v not in indices: strongconnect(v) return sccs"},{"question":"# Question: Unique Character Checker **Context** A string is said to have all unique characters if no character repeats within the string. This property is significant in various applications such as cryptography, data compression, and information theory. For example: - \\"abcdef\\" has all unique characters. - \\"hello\\" does not have all unique characters because \'l\' is repeated. **Task** Write a function `has_unique_characters(s: str) -> bool` that determines if all characters in the given string `s` are unique. **Input** - `s` is a single string containing only lowercase alphabetic characters (1 <= len(s) <= 1,000,000). **Output** - Return `True` if all characters in `s` are unique; otherwise, return `False`. **Constraints** - You can assume the string contains only lowercase alphabetic characters (`a-z`). **Examples** ```python >>> has_unique_characters(\\"abcdef\\") True >>> has_unique_characters(\\"hello\\") False >>> has_unique_characters(\\"world\\") True >>> has_unique_characters(\\"character\\") False ``` **Notes** - Use the above examples to test correctness. - Consider the performance implications with very long strings. - Think through all possible edge cases within the input constraints. - Aim to implement a solution with optimal time complexity. Write your function below: ```python def has_unique_characters(s: str) -> bool: # Your implementation here ```","solution":"def has_unique_characters(s: str) -> bool: Determines if all characters in the given string `s` are unique. Parameters: s (str): The input string containing only lowercase alphabetic characters. Returns: bool: True if all characters in `s` are unique, otherwise False. char_set = set() for char in s: if char in char_set: return False char_set.add(char) return True"},{"question":"# Factorial Calculation with Memoization You are working on developing software that requires extensive use of factorial calculations. To improve efficiency, you decide to implement memoization to store previously calculated factorials. You are required to implement two functions: 1. **compute_factorial(n: int, memo: dict={}) -> int** This function calculates the factorial of `n` using memoization to cache and reuse previously computed results. 2. **factorial_sequence(n: int) -> list[int]** This function generates a list of factorials for all integers from 0 to `n` (inclusive) using the `compute_factorial` function with memoization. # Input 1. `compute_factorial`: - `n`: The integer for which to compute the factorial. Assumed to be non-negative. - `memo`: A dictionary to store previously computed factorial values. Defaults to an empty dictionary. 2. `factorial_sequence`: - `n`: The integer up to which (inclusive) the list of factorials is to be generated. Assumed to be non-negative. # Output 1. `compute_factorial`: The factorial of `n`. 2. `factorial_sequence`: A list of factorials for all integers from 0 to `n` (inclusive). # Example Usage ```python # Example usage of compute_factorial print(compute_factorial(5)) # Output: 120 print(compute_factorial(10)) # Output: 3628800 # Example usage of factorial_sequence print(factorial_sequence(5)) # Output: [1, 1, 2, 6, 24, 120] print(factorial_sequence(10)) # Output: [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800] ``` # Debugging Constraints 1. Ensure the correct handling of the base cases such as `n = 0`. 2. Validate that memoization is correctly utilized to avoid redundant calculations. 3. Check for potential edge cases such as very large values of `n` and ensure that the function does not exceed recursion limits when possible.","solution":"def compute_factorial(n, memo={}): Computes the factorial of n using memoization to cache results. Parameters: - n (int): The integer for which to compute the factorial. - memo (dict): A dictionary to store previously computed factorial values. Returns: - int: The factorial of n. if n in memo: return memo[n] if n == 0: return 1 result = n * compute_factorial(n - 1, memo) memo[n] = result return result def factorial_sequence(n): Generates a list of factorials for all integers from 0 to n (inclusive). Parameters: - n (int): The integer up to which (inclusive) the list of factorials is to be generated. Returns: - list[int]: A list of factorials for all integers from 0 to n (inclusive). memo = {} return [compute_factorial(i, memo) for i in range(n + 1)]"},{"question":"# Context: In numerical computations, it is important to handle matrix operations efficiently, especially for large datasets. Knowing how to perform matrix addition and multiplication is fundamental in fields such as machine learning, computer graphics, and scientific simulations. Given two matrices, you will implement functions to handle their addition and multiplication. # Objective: Implement two functions to perform matrix addition and matrix multiplication. Your functions should handle edge cases by raising appropriate exceptions. # Problem Statement: Write two functions, `add_matrices` and `multiply_matrices`, that perform addition and multiplication of two given matrices. Function Signature: ```python def add_matrices(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]: pass def multiply_matrices(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]: pass ``` Input: - `matrix1` and `matrix2`: 2D lists representing the matrices. Each inner list contains integers representing the rows of the matrix. Output: - `add_matrices` returns a 2D list representing the sum of the matrices. - `multiply_matrices` returns a 2D list representing the product of the matrices. Constraints: - For matrix addition: - Both matrices must have the same dimensions. If not, raise an `Exception` with message `\\"Matrices must have the same dimensions\\"`. - For matrix multiplication: - The number of columns in the first matrix must be equal to the number of rows in the second matrix. If not, raise an `Exception` with message `\\"Number of columns in the first matrix must equal number of rows in the second matrix\\"`. # Examples: ```python >>> add_matrices([[1, 2], [3, 4]], [[5, 6], [7, 8]]) [[6, 8], [10, 12]] >>> add_matrices([[1, 2, 3]], [[4, 5, 6]]) [[5, 7, 9]] >>> add_matrices([[1, 2]], [[1], [2]]) Exception: Matrices must have the same dimensions >>> multiply_matrices([[1, 2], [3, 4]], [[5, 6], [7, 8]]) [[19, 22], [43, 50]] >>> multiply_matrices([[1, 2, 3]], [[4], [5], [6]]) [[32]] >>> multiply_matrices([[1, 2]], [[1, 2], [3, 4], [5, 6]]) Exception: Number of columns in the first matrix must equal number of rows in the second matrix ```","solution":"from typing import List def add_matrices(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]: # Check if matrices have the same dimensions if len(matrix1) != len(matrix2) or any(len(row1) != len(row2) for row1, row2 in zip(matrix1, matrix2)): raise Exception(\\"Matrices must have the same dimensions\\") # Add corresponding elements return [[matrix1[i][j] + matrix2[i][j] for j in range(len(matrix1[0]))] for i in range(len(matrix1))] def multiply_matrices(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]: if len(matrix1[0]) != len(matrix2): raise Exception(\\"Number of columns in the first matrix must equal number of rows in the second matrix\\") # Initialize result matrix with zeros result = [[0 for _ in range(len(matrix2[0]))] for _ in range(len(matrix1))] # Perform multiplication for i in range(len(matrix1)): for j in range(len(matrix2[0])): for k in range(len(matrix2)): result[i][j] += matrix1[i][k] * matrix2[k][j] return result"},{"question":"**Problem Statement**: Given a string consisting of lowercase English letters, you are tasked with finding the length of the longest substring that contains at most two distinct characters. Write a function to implement this logic efficiently. **Function Signature**: ```python def longest_substring_k_distinct(s: str) -> int: ``` **Inputs**: - `s`: A string consisting of lowercase English letters with a length between 0 and 10^5. **Outputs**: - Return an integer representing the length of the longest substring containing at most two distinct characters. **Constraints**: - The input string can be empty. - You must handle cases with different lengths of input and varying distributions of characters. - Aim for an O(n) time complexity and use efficient space handling. **Scenario**: Imagine you are working on a text analysis tool, and one of the requirements is to find and highlight the longest balanced sections of text, where balance is defined as having no more than two distinct characters in a segment. **Examples**: ```python >>> longest_substring_k_distinct(\\"eceba\\") 3 # Explanation: The substring \\"ece\\" contains 2 distinct characters and is the longest. >>> longest_substring_k_distinct(\\"ccaabbb\\") 5 # Explanation: The substring \\"aabbb\\" contains 2 distinct characters and is the longest. >>> longest_substring_k_distinct(\\"\\") 0 # Explanation: The input string is empty, so the output is 0. ``` **Requirements**: - Return 0 if the input string is empty. - Aim for an efficient approach to handle the character analysis and counting.","solution":"def longest_substring_k_distinct(s: str) -> int: Finds the length of the longest substring containing at most 2 distinct characters. if not s: return 0 char_map = {} left = 0 max_length = 0 for right in range(len(s)): char_map[s[right]] = char_map.get(s[right], 0) + 1 while len(char_map) > 2: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"# Flood Fill Algorithm Implementation **Scenario**: You are working on an image processing module where one of the necessary tasks is to implement a flood fill algorithm. The flood fill algorithm is used to change the color of a specific area of an image, starting from a given pixel and extending outwards to all connected pixels of the same color. **Problem**: Write a function to perform a flood fill on a 2D grid representing an image. Each cell in the grid is an integer representing the color of that pixel. Given a starting pixel and a new color, change the color of the starting pixel and all pixels connected to it with the same initial color to the new color. **Function Signature**: ```python def flood_fill(image: List[List[int]], sr: int, sc: int, new_color: int) -> List[List[int]]: Function to perform a flood fill on the given image starting from the given pixel. Args: image (List[List[int]]): A 2D list of integers representing the image. sr (int): The starting row index of the pixel. sc (int): The starting column index of the pixel. new_color (int): The new color to apply to the connected pixels. Returns: List[List[int]]: The modified image after performing the flood fill. ``` **Input**: - `image`: A 2D list of integers where `image[r][c]` represents the color of the pixel at row `r` and column `c`. - `sr`: An integer representing the starting pixel\'s row index. - `sc`: An integer representing the starting pixel\'s column index. - `new_color`: An integer representing the new color to apply. **Output**: - A 2D list of integers representing the image after performing the flood fill. **Constraints**: - The dimensions of the image will not exceed 50x50. - The values within the image are between 0 and 65535. - 0 <= sr < len(image) - 0 <= sc < len(image[0]) **Examples**: ```python >>> flood_fill([[1, 1, 1], [1, 1, 0], [1, 0, 1]], 1, 1, 2) [[2, 2, 2], [2, 2, 0], [2, 0, 1]] >>> flood_fill([[0, 0, 0], [0, 1, 1]], 1, 1, 1) [[0, 0, 0], [0, 1, 1]] >>> flood_fill([[0, 1, 1], [0, 1, 1], [1, 1, 0]], 0, 0, 1) [[1, 1, 1], [1, 1, 1], [1, 1, 0]] ``` **Note**: Use either Depth-First Search (DFS) or Breadth-First Search (BFS) for this problem to ensure all connected pixels are appropriately changed. Avoid infinite loops by managing visited pixels carefully.","solution":"from typing import List def flood_fill(image: List[List[int]], sr: int, sc: int, new_color: int) -> List[List[int]]: old_color = image[sr][sc] if old_color == new_color: return image def dfs(r: int, c: int): if (r < 0 or r >= len(image) or c < 0 or c >= len(image[0]) or image[r][c] != old_color): return image[r][c] = new_color dfs(r + 1, c) # down dfs(r - 1, c) # up dfs(r, c + 1) # right dfs(r, c - 1) # left dfs(sr, sc) return image"},{"question":"# Context You are tasked with developing a library management system that handles various book-related operations including borrowing and returning books, as well as tracking the status of each book within the library. # Problem Statement Write a Python class `Library` that supports the following functionalities: 1. **Initialization**: Should initialize the library with a list of books, each of which is represented by a dictionary. 2. **Borrow Book**: Implement a method to borrow a book given its title. 3. **Return Book**: Implement a method to return a borrowed book given its title. 4. **List Available Books**: Implement a method to list all available books in the library. 5. **Check Book Status**: Implement a method to check if a specific book is available. Additionally, implement a proper unit test suite to validate these functionalities. Ensure to cover edge cases, error handling, and status consistency where applicable. # Implementation Details 1. **Initialization**: ```python class Library: def __init__(self, books: List[Dict[str, str]]) -> None: ... ``` 2. **Borrow Book**: ```python def borrow_book(self, title: str) -> bool: ... ``` 3. **Return Book**: ```python def return_book(self, title: str) -> bool: ... ``` 4. **List Available Books**: ```python def list_available_books(self) -> List[str]: ... ``` 5. **Check Book Status**: ```python def is_book_available(self, title: str) -> bool: ... ``` # Constraints - A book can only be borrowed if it is available. - Attempting to borrow a non-existent or already borrowed book should return an appropriate error or message. - No two books in the initial list should have the same title. # Unit Tests Create a test class `TestLibrary` using `unittest` that validates all aspects of your implementation. Cover typical edge cases and error scenarios such as trying to borrow a book that is not available or returning a book that was not borrowed. # Example ```python books = [ {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\"}, {\\"title\\": \\"Brave New World\\", \\"author\\": \\"Aldous Huxley\\"}, {\\"title\\": \\"Fahrenheit 451\\", \\"author\\": \\"Ray Bradbury\\"} ] library = Library(books) # Test Borrowing a Book print(library.borrow_book(\\"1984\\")) # Should return True print(library.borrow_book(\\"1984\\")) # Should return False as book is already borrowed # Test Returning a Book print(library.return_book(\\"1984\\")) # Should return True print(library.return_book(\\"1984\\")) # Should return False as book was not borrowed # Test List Available Books print(library.list_available_books()) # Should list all books except those borrowed # Test Check Book Status print(library.is_book_available(\\"1984\\")) # Should return True or False depending on borrowing status ```","solution":"class Library: def __init__(self, books): Initialize the library with a list of books. Each book is a dictionary with keys \'title\' and \'author\'. self.books = {book[\\"title\\"]: book for book in books} self.borrowed_books = set() def borrow_book(self, title: str) -> bool: Borrow a book given its title. Returns True if the book was successfully borrowed, False otherwise. if title in self.books and title not in self.borrowed_books: self.borrowed_books.add(title) return True return False def return_book(self, title: str) -> bool: Return a borrowed book given its title. Returns True if the book was successfully returned, False otherwise. if title in self.borrowed_books: self.borrowed_books.remove(title) return True return False def list_available_books(self): List all available books in the library. Returns a list of titles of available books. return [title for title in self.books if title not in self.borrowed_books] def is_book_available(self, title: str) -> bool: Check if a specific book is available. Returns True if the book is available, False otherwise. return title in self.books and title not in self.borrowed_books"},{"question":"# Problem Statement Context You are developing a software system that processes strings of text for various natural language processing tasks. One module of the system requires the ability to count the frequency of unique words in a given text. This function will be called repeatedly, so it must be optimized for both time and space efficiency. Task Implement a function that counts the frequency of each unique word in a given string and returns a dictionary with words as keys and their respective frequencies as values. Words are case-insensitive, and the output should be in lowercase. Function Signature ```python def word_frequency(text: str) -> dict: pass ``` Input Format - A single string `text` where: * `0 <= len(text) <= 10^6` * The string may contain alphabetic characters and common punctuation marks (.,!?;:\'\\"). Output Format - A dictionary with words (in lowercase) as keys and their frequencies as values. Constraints - Words are defined as sequences of alphabetic characters separated by spaces or punctuation. - The punctuation marks should not be included as part of the words. - Your implementation should efficiently handle input size up to the maximum constraint. Example ```python assert word_frequency(\\"Hello, hello! How are you? Are you okay?\\") == {\'hello\': 2, \'how\': 1, \'are\': 2, \'you\': 2, \'okay\': 1} assert word_frequency(\\"Test. A test, a TEST.\\") == {\'test\': 3, \'a\': 2} ``` Requirements - Ensure the solution handles edge cases such as empty strings and strings containing only punctuation. - Return an empty dictionary for an empty input string. Notes - Assume the text will only contain English characters. - The dictionary keys should be in lowercase, representing words in a case-insensitive manner. --- When creating this new question, I followed the structure, complexity, and format from the sample question provided, ensuring it is aligned in context and functionality. The question tackles a different but related domain (string processing in comparison to sorting algorithms) while still maintaining a focus on efficient implementation.","solution":"import re from collections import defaultdict def word_frequency(text: str) -> dict: Counts the frequency of each unique word in a given string and returns a dictionary with words as keys and their frequencies as values. Words are case-insensitive, and the output is in lowercase. if not text: return {} # Convert text to lowercase and use regex to find words words = re.findall(r\'bw+b\', text.lower()) # Using defaultdict to simplify counting frequency = defaultdict(int) for word in words: frequency[word] += 1 return dict(frequency)"},{"question":"# Route Optimization for Delivery Trucks Context You are a software engineer for a logistics company. The company wants to optimize the delivery routes for their trucks to minimize the total distance traveled. Each truck starts from the warehouse, makes deliveries to assigned locations, and returns to the warehouse. Objective Implement a function to find the shortest possible round-trip route for a single truck given a list of delivery locations and the distances between them. Use the Traveling Salesman Problem (TSP) approach to solve this optimization problem. Input Format 1. A square matrix `distances` of shape (n, n) where `distances[i][j]` represents the distance between location `i` and location `j`. The warehouse is represented by the 0th index. 2. An integer `num_trucks` representing the number of trucks available. 3. A list `truck_routes` of length `num_trucks` where each element is a list of integers representing the locations assigned to that truck (excluding the warehouse). Output Format 1. A list of lists where each sublist represents the optimal route for a truck, starting and ending at the warehouse (location 0). Constraints 1. Number of locations `n` (including the warehouse) should be ≥ 4 and ≤ 20. 2. Distances between locations are non-negative integers. 3. Each location from 1 to `n-1` must be assigned to exactly one truck\'s route. # Function Signature ```python def optimize_routes(distances: List[List[int]], num_trucks: int, truck_routes: List[List[int]]) -> List[List[int]]: pass ``` # Example ```python distances = [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ] num_trucks = 2 truck_routes = [[1, 3], [2]] routes = optimize_routes(distances, num_trucks, truck_routes) print(\\"Optimized routes:\\", routes) ``` In this example, the function `optimize_routes` should output the best possible routes for the trucks to minimize the total travel distance. The output could be: ```python Optimized routes: [[0, 1, 3, 0], [0, 2, 0]] ``` # Requirements 1. Use a brute-force or heuristic approach to solve the TSP for each truck route to ensure the minimal traveling distance. 2. Ensure that each route starts and ends at the warehouse (location 0). 3. The solution should handle up to 20 locations optimally or near-optimally. 4. Print the optimized route along with the total distance traveled for each truck. Good luck!","solution":"from itertools import permutations from typing import List def calculate_route_distance(route: List[int], distances: List[List[int]]) -> int: total_distance = 0 for i in range(len(route) - 1): total_distance += distances[route[i]][route[i + 1]] return total_distance def optimize_routes(distances: List[List[int]], num_trucks: int, truck_routes: List[List[int]]) -> List[List[int]]: optimized_routes = [] for truck_route in truck_routes: # Add warehouse to start and end locations = [0] + truck_route + [0] min_distance = float(\'inf\') best_route = [] for perm in permutations(truck_route): candidate_route = [0] + list(perm) + [0] dist = calculate_route_distance(candidate_route, distances) if dist < min_distance: min_distance = dist best_route = candidate_route optimized_routes.append(best_route) return optimized_routes"},{"question":"# Coding Assessment Question Scenario You have been given the task of parsing and evaluating mathematical expressions provided as strings. The expressions can contain integers, addition, subtraction, multiplication, and division operations. Parentheses can be used to indicate the precedence of operations. Your task is to implement a function that evaluates these arithmetic expressions accurately. Task Implement the function `evaluate_expression` which takes a single string input representing a mathematical expression and returns its evaluated result as an integer. Your implementation should correctly handle operator precedence and parentheses. Requirements - Define the function `evaluate_expression(expression: str) -> int`. - The function should return the correct integer result of the expression. - Ensure the function manages different operator precedences: parentheses > multiplication/division > addition/subtraction. - Provide sufficient test cases to thoroughly assess your implementation. Constraints - The expression will only contain non-negative integers, \'+\', \'-\', \'*\', \'/\', and parentheses. - Input expression length: 1 to 10^4 characters. - The expression is guaranteed to be valid and does not need error handling for malformed inputs. Performance Requirements - Time Complexity: O(n), where n is the length of the input string. - Space Complexity: O(n), due to the usage of stacks or recursion to handle nested expressions. Example ```python >>> evaluate_expression(\\"3 + 4 * 2 / ( 1 - 5 )\\") 1 >>> evaluate_expression(\\"(2 + 3) * 4\\") 20 >>> evaluate_expression(\\"3 + (2 - 1) * 5\\") 8 >>> evaluate_expression(\\"10 / 2 + 3 * 4\\") 17 ```","solution":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing integers, +, -, *, /, and parentheses. def apply_operation(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == \'+\': values.append(left + right) elif operator == \'-\': values.append(left - right) elif operator == \'*\': values.append(left * right) elif operator == \'/\': values.append(int(left / right)) # Ensure integer division def precedence(op): if op == \'+\' or op == \'-\': return 1 if op == \'*\' or op == \'/\': return 2 return 0 operators = [] values = [] i = 0 while i < len(expression): if expression[i] == \' \': i += 1 elif expression[i] == \'(\': operators.append(expression[i]) i += 1 elif expression[i].isdigit(): val = 0 while i < len(expression) and expression[i].isdigit(): val = val * 10 + int(expression[i]) i += 1 values.append(val) elif expression[i] == \')\': while operators[-1] != \'(\': apply_operation(operators, values) operators.pop() # Pop \'(\' i += 1 else: while (operators and precedence(operators[-1]) >= precedence(expression[i])): apply_operation(operators, values) operators.append(expression[i]) i += 1 while operators: apply_operation(operators, values) return values[0]"},{"question":"# Context Dynamic programming is a method for solving complex problems by breaking them down into simpler subproblems and storing the results of these subproblems to avoid redundant calculations. A typical use case is optimizing a problem that involves making a series of decisions to achieve the best outcome. # Question Consider the problem of finding the longest palindromic subsequence in a given string. Write a function `longest_palindromic_subsequence` that takes a string as input and returns the length of its longest palindromic subsequence. # Function Signature ```python def longest_palindromic_subsequence(s: str) -> int: Finds the length of the longest palindromic subsequence in the given string. :param s: The input string. :return: The length of the longest palindromic subsequence. ``` # Input * `s`: A string, e.g., `\\"babad\\"` # Output * The length of the longest palindromic subsequence, e.g., `3` for the input string `\\"babad\\"` (one possible subsequence is \\"bab\\" or \\"aba\\"). # Constraints * The length of the input string `s` is at most `1000`. * The input string `s` consists of lowercase English letters. # Examples ```python assert longest_palindromic_subsequence(\\"babad\\") == 3 assert longest_palindromic_subsequence(\\"cbbd\\") == 2 assert longest_palindromic_subsequence(\\"a\\") == 1 assert longest_palindromic_subsequence(\\"abcba\\") == 5 ```","solution":"def longest_palindromic_subsequence(s: str) -> int: Finds the length of the longest palindromic subsequence in the given string. :param s: The input string. :return: The length of the longest palindromic subsequence. n = len(s) if n == 0: return 0 # Create a 2D array to store the length of the longest palindromic subsequence dp = [[0] * n for _ in range(n)] # Every single character is a palindrome of length 1 for i in range(n): dp[i][i] = 1 # Fill the table for cl in range(2, n+1): for i in range(n-cl+1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i][j-1], dp[i+1][j]) return dp[0][n-1]"},{"question":"# Question **Problem Statement**: You are given the task of simulating a simplified version of a vending machine that dispenses products based on coin input and product selection. The vending machine can handle four types of coins (1, 5, 10, 25) and has a small set of products, each with a specific cost. **Objective**: 1. Write a class `VendingMachine` that supports the following methods: - `insert_coin(coin: int) -> None`: This function accepts a coin of value 1, 5, 10, or 25 and adds it to the total amount inserted. - `select_product(product_code: str) -> str`: This function accepts a product code and dispenses the product if enough money has been inserted. It also returns change if the inserted amount exceeds the product\'s cost. If sufficient funds are not provided, it returns an appropriate message. 2. The class should also have the following property: - `products` (a dictionary with product codes as keys and their respective cost and names as values). **Constraints**: - A product code is a single uppercase letter (A, B, C, D). - The product costs and names are predefined as: ```python { \'A\': {\'name\': \'Soda\', \'cost\': 10}, \'B\': {\'name\': \'Chips\', \'cost\': 5}, \'C\': {\'name\': \'Candy\', \'cost\': 2}, \'D\': {\'name\': \'Juice\', \'cost\': 15} } ``` **Input**: - An integer for the `insert_coin` method. - A string for the `select_product` method. **Output**: - `None` for the `insert_coin` method. - A string message for the `select_product` method. **Examples**: ```python vm = VendingMachine() vm.insert_coin(10) vm.insert_coin(5) assert vm.select_product(\'B\') == \\"Dispensing Chips with 10 cents as Change.\\" ``` ```python vm = VendingMachine() vm.insert_coin(5) assert vm.select_product(\'D\') == \\"Not enough money inserted for Juice.\\" ``` This question tests your ability to design a class with fundamental operations and state management, along with simple arithmetic logic. Be sure to handle edge cases where invalid coins or product codes are given.","solution":"class VendingMachine: A simple vending machine class to dispense products based on coin inputs and product selection. def __init__(self): self.total_amount = 0 self.products = { \'A\': {\'name\': \'Soda\', \'cost\': 10}, \'B\': {\'name\': \'Chips\', \'cost\': 5}, \'C\': {\'name\': \'Candy\', \'cost\': 2}, \'D\': {\'name\': \'Juice\', \'cost\': 15} } self.valid_coins = [1, 5, 10, 25] def insert_coin(self, coin: int) -> None: if coin in self.valid_coins: self.total_amount += coin else: raise ValueError(\\"Invalid coin inserted.\\") def select_product(self, product_code: str) -> str: if product_code in self.products: product = self.products[product_code] if self.total_amount >= product[\'cost\']: change = self.total_amount - product[\'cost\'] self.total_amount = 0 return f\\"Dispensing {product[\'name\']} with {change} cents as Change.\\" else: return f\\"Not enough money inserted for {product[\'name\']}.\\" else: return \\"Invalid product code.\\""},{"question":"# Question: Enhanced String Manipulation - Pattern Matching and Replacement Context: Consider a set of operations designed to manipulate strings in various ways. You are required to implement a class `StringManipulator` that supports the following methods to enhance text processing functionality: 1. `find_all(pattern)`: Use regex to find all occurrences of a pattern in the string and return their starting indices. 2. `replace_all(old, new)`: Replace all occurrences of a substring `old` with a substring `new` in the string. 3. `is_palindrome()`: Check if the string is a palindrome, ignoring non-alphanumeric characters and case. Implementation Details: - **find_all(pattern)**: - Input: `pattern` (a regex pattern string). - Output: List of integers representing starting indices of all matches. - **replace_all(old, new)**: - Input: `old` (substring to be replaced), `new` (substring to replace with). - Output: The modified string with all replacements done. - **is_palindrome()**: - Input: None. - Output: Boolean indicating whether the string is a palindrome or not. Constraints: - The input string will have at most 10000 characters. - The pattern and substrings can be of varying lengths. Example: ```python text = \\"A man, a plan, a canal, Panama\\" manipulator = StringManipulator(text) print(manipulator.find_all(r\'baw*b\')) # Output: [3, 8, 11, 13, 20, 22] print(manipulator.replace_all(\\"a\\", \\"o\\")) # Output: \\"A mon, o plon, o conol, Ponomo\\" print(manipulator.is_palindrome()) # Output: True ``` Class Skeleton: ```python import re class StringManipulator: def __init__(self, text): self.text = text def find_all(self, pattern): # Implement using re.findall pass def replace_all(self, old, new): # Implement string replacement pass def is_palindrome(self): # Implement palindrome check pass ```","solution":"import re class StringManipulator: def __init__(self, text): self.text = text def find_all(self, pattern): matches = re.finditer(pattern, self.text) return [match.start() for match in matches] def replace_all(self, old, new): return self.text.replace(old, new) def is_palindrome(self): cleaned_text = re.sub(r\'[^A-Za-z0-9]\', \'\', self.text).lower() return cleaned_text == cleaned_text[::-1]"},{"question":"# Coding Challenge: Social Media Feed Image Downloader Your task is to develop a Python function that downloads images from a user\'s social media feed. The function should integrate data from two different social media platforms: Instagram and Twitter. You should implement additional error handling and optimize the downloading process to handle various edge cases effectively. Function Signature ```python def download_images(user_id: str) -> dict: Downloads images from the social media feeds of Instagram and Twitter for a given user ID. Args: user_id (str): The user ID whose images are to be fetched. Returns: dict: A dictionary with the status and list of downloaded image URLs or an error message in case of an issue. ``` # Instructions 1. **API Responses Integration**: - Fetch image URLs from the provided API endpoints using the defined API keys (assume the keys are constants in the script). - Collect the image URLs into a single dictionary that includes the source of each image. 2. **Error Handling**: - Implement robust error handling to manage scenarios where one or both APIs fail to return data. - Include meaningful error messages for different failure cases: - If no API keys are provided. - Invalid user ID format. - Network issues / API timeouts. - Partial data retrieval (one API succeeds, another fails). 3. **Optimization**: - Minimize the impact of network latency by handling API requests in parallel. - Add retry logic for transient network issues or API rate-limit errors. 4. **Edge Cases**: - Ensure correct handling when the user ID is invalid or the APIs return no data. 5. **Testing**: - Write tests covering various scenarios, including valid and invalid user IDs, network failures, and scenarios where only one API returns valid data. # Constraints - Assume that you have valid API keys for both Instagram and Twitter. - Use Python\'s `requests` library for making HTTP GET requests. ```python import requests import concurrent.futures # Put your API key(s) here INSTAGRAM_API_KEY = \\"your_instagram_api_key\\" TWITTER_API_KEY = \\"your_twitter_api_key\\" INSTAGRAM_URL_BASE = \\"https://graph.instagram.com/v12.0/\\" TWITTER_URL_BASE = \\"https://api.twitter.com/2/\\" def download_images(user_id: str) -> dict: # Your implementation here pass if __name__ == \\"__main__\\": from pprint import pprint user_id = input(\\"Enter a user ID: \\").strip() if user_id: try: image_data = download_images(user_id) pprint(image_data) except Exception as e: print(f\\"Error: {e}\\") ``` # Example ```python >>> download_images(\\"user123\\") { \\"Instagram\\": [ \\"https://instagram.com/some_image_url.jpg\\", \\"https://instagram.com/another_image_url.jpg\\" ], \\"Twitter\\": [ \\"https://twitter.com/some_image_url.jpg\\", \\"https://twitter.com/another_image_url.jpg\\" ] } ``` Ensure your function handles the specified requirements and runs efficiently.","solution":"import requests import concurrent.futures # Put your API key(s) here INSTAGRAM_API_KEY = \\"your_instagram_api_key\\" TWITTER_API_KEY = \\"your_twitter_api_key\\" INSTAGRAM_URL_BASE = \\"https://graph.instagram.com/v12.0/\\" TWITTER_URL_BASE = \\"https://api.twitter.com/2/\\" def fetch_instagram_images(user_id): try: url = f\\"{INSTAGRAM_URL_BASE}{user_id}/media?access_token={INSTAGRAM_API_KEY}\\" response = requests.get(url) response.raise_for_status() data = response.json() return {\\"Instagram\\": [item[\'media_url\'] for item in data[\'data\'] if \'media_url\' in item]} except Exception as e: return {\\"Instagram_error\\": str(e)} def fetch_twitter_images(user_id): try: url = f\\"{TWITTER_URL_BASE}users/{user_id}/tweets?media.fields=url&access_token={TWITTER_API_KEY}\\" response = requests.get(url) response.raise_for_status() data = response.json() return {\\"Twitter\\": [item[\'url\'] for item in data[\'data\'] if \'url\' in item]} except Exception as e: return {\\"Twitter_error\\": str(e)} def download_images(user_id: str) -> dict: if not user_id: return {\\"error\\": \\"User ID is required\\"} with concurrent.futures.ThreadPoolExecutor() as executor: future_to_platform = { executor.submit(fetch_instagram_images, user_id): \'Instagram\', executor.submit(fetch_twitter_images, user_id): \'Twitter\' } results = {} for future in concurrent.futures.as_completed(future_to_platform): platform = future_to_platform[future] try: data = future.result() results.update(data) except Exception as e: results[f\\"{platform}_error\\"] = str(e) return results"},{"question":"# Count Unique Anagrams You are given a list of strings where each string contains only lowercase alphabets. Two strings are anagrams if they can be rearranged to form each other. Your task is to count the number of unique anagrams in the list. Requirements: 1. **Counting Anagrams**: Implement a method to determine the number of unique anagrams in the list. # Function Signature: ```python def count_unique_anagrams(words: list[str]) -> int: pass ``` # Input: - A list `words` of strings. Each string is composed of lowercase alphabets only. The list may be empty. # Output: - An integer representing the number of unique anagrams in the list. # Constraints: - You must handle empty lists by returning `0`. - Be mindful of edge cases, such as lists with repeated elements and lists with single-character strings. # Sample Usage: ```python # Test cases assert count_unique_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"gogole\\"]) == 2 assert count_unique_anagrams([\\"cat\\", \\"tac\\", \\"act\\", \\"dog\\", \\"god\\"]) == 2 assert count_unique_anagrams([\\"a\\", \\"b\\", \\"c\\", \\"a\\", \\"a\\"]) == 3 assert count_unique_anagrams([\\"aaa\\", \\"aaa\\", \\"aaa\\"]) == 1 # Edge case: empty list assert count_unique_anagrams([]) == 0 ``` Implement this function ensuring efficiency and correctness, and handle edge cases appropriately.","solution":"def count_unique_anagrams(words: list[str]) -> int: Returns the number of unique anagrams in the list. # Use a set to store unique signatures of the words unique_anagrams = set() for word in words: # Sort the word to get its signature and add to the set signature = \'\'.join(sorted(word)) unique_anagrams.add(signature) # The size of the set will be the count of unique anagrams return len(unique_anagrams)"},{"question":"# Stock Price Averaging Over a Period As a financial analyst, you are tasked with enhancing a function to calculate the average stock price over a certain period. The current function `calculate_average_price` takes a list of daily stock prices and returns the average price. However, it has the following limitations: 1. **Input Validation**: - It only checks that input is a list but does not validate the contents of the list. 2. **Empty List**: - It does not handle cases where the list of prices is empty. 3. **Comprehensive Error Messages**: - It does not provide detailed error messages for invalid inputs. Enhance the `calculate_average_price` function to: - Include detailed error messages for invalid input cases, such as non-numeric values in the list, and handle empty lists gracefully. - Accept prices as either integers or floating-point numbers. # Function Signature ```python def calculate_average_price(prices: List[Union[int, float]]) -> float: pass ``` Input Constraints - `prices`: A list of daily stock prices, where each price is either an integer or a float. - The list `prices` should not be empty. # Expected Output - A floating-point number representing the average stock price. # Example Usage ```python >>> calculate_average_price([100, 200, 300]) 200.0 >>> calculate_average_price([150.5, 200.0, 250.75]) 200.41666666666666 >>> calculate_average_price([]) Traceback (most recent call last): ... ValueError: The list of prices should not be empty. >>> calculate_average_price([150, \'200\', 250]) Traceback (most recent call last): ... TypeError: Each price should be an integer or a float. ``` Steps 1. Validate that the input is a list. 2. Ensure the list is not empty. 3. Validate that each element in the list is either an integer or a float. 4. Calculate the average price and return it as a floating-point number. Implement the `calculate_average_price` function that meets the above requirements.","solution":"from typing import List, Union def calculate_average_price(prices: List[Union[int, float]]) -> float: Returns the average price from a list of daily stock prices. The list must contain only integers or floats and should not be empty. :param prices: List of daily stock prices :return: The average stock price as a float if not isinstance(prices, list): raise TypeError(\\"Input should be a list of prices.\\") if not prices: raise ValueError(\\"The list of prices should not be empty.\\") if not all(isinstance(price, (int, float)) for price in prices): raise TypeError(\\"Each price should be an integer or a float.\\") return sum(prices) / len(prices)"},{"question":"# Question: Implement a Priority Queue using a Min-Heap You are required to implement a priority queue using a min-heap. The priority queue must support the basic operations of insertion, finding the minimum element, and extracting the minimum element. Function Specifications: 1. `class MinHeap`: A class that implements a min-heap. - `def __init__(self) -> None`: Initializes an empty min-heap. - `def insert(self, element: int) -> None`: Adds an element to the min-heap. - **Input**: An integer (`element`). - **Output**: None - `def get_min(self) -> int`: Returns the minimum element from the min-heap without removing it. - **Input**: None - **Output**: The minimum element (integer) in the min-heap. - `def extract_min(self) -> int`: Removes and returns the minimum element from the min-heap. - **Input**: None - **Output**: The minimum element (integer) that was removed from the min-heap. Requirements: - Ensure the `insert`, `get_min`, and `extract_min` operations perform in O(log n) time complexity. - The `get_min` and `extract_min` operations should correctly manage an empty min-heap by returning a specific value, such as None or an appropriate error message, if the heap is empty. Example Usage: ```python heap = MinHeap() heap.insert(5) heap.insert(3) heap.insert(8) assert heap.get_min() == 3 assert heap.extract_min() == 3 assert heap.get_min() == 5 ``` Constraints: - Inserted elements will be non-negative integers. - The priority queue should handle typical edge cases like inserting a single element, finding/extracting from an empty heap, and inserting multiple elements in random order. Implement the MinHeap class and its methods to meet the above specifications and functionality.","solution":"class MinHeap: def __init__(self) -> None: self.heap = [] def _heapify_up(self, index: int) -> None: parent_idx = (index - 1) // 2 if parent_idx >= 0 and self.heap[index] < self.heap[parent_idx]: self.heap[index], self.heap[parent_idx] = self.heap[parent_idx], self.heap[index] self._heapify_up(parent_idx) def _heapify_down(self, index: int) -> None: left_child_idx = 2 * index + 1 right_child_idx = 2 * index + 2 smallest = index if left_child_idx < len(self.heap) and self.heap[left_child_idx] < self.heap[smallest]: smallest = left_child_idx if right_child_idx < len(self.heap) and self.heap[right_child_idx] < self.heap[smallest]: smallest = right_child_idx if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._heapify_down(smallest) def insert(self, element: int) -> None: self.heap.append(element) self._heapify_up(len(self.heap) - 1) def get_min(self) -> int: if not self.heap: return None return self.heap[0] def extract_min(self) -> int: if not self.heap: return None if len(self.heap) == 1: return self.heap.pop() min_element = self.heap[0] self.heap[0] = self.heap.pop() self._heapify_down(0) return min_element"},{"question":"# Question You are tasked with implementing a function that verifies whether there exists a valid path from the top-left corner to the bottom-right corner of a grid filled with walls and open spaces. The path can only traverse through open spaces and can move in four possible directions: up, down, left, or right. **Core Concepts**: - Treating the grid as a graph where cells are nodes and edges exist between adjacent open cells. - Using graph traversal techniques like Breadth-First Search (BFS) to explore possible paths. # Input - An integer `n` representing the number of rows in the grid. - An integer `m` representing the number of columns in the grid. - A list of lists `grid` of size `n x m` representing the grid, where each element is either `0` (an open space) or `1` (a wall). # Output - A boolean indicating whether a valid path exists from the top-left corner (0, 0) to the bottom-right corner (n-1, m-1). # Constraints - 1 ≤ n, m ≤ 1000 - The grid contains only `0`s and `1`s. # Example ```python n = 3 m = 3 grid = [ [0, 1, 0], [0, 0, 0], [1, 1, 0] ] print(is_valid_path(n, m, grid)) ``` Output: ```python True ``` # Implementation Function signature: ```python def is_valid_path(n: int, m: int, grid: list[list[int]]) -> bool: pass ``` # Steps to Solve: 1. Check if the starting point `(0, 0)` or the ending point `(n-1, m-1)` is a wall (`1`); if so, return `False`. 2. Utilize a BFS algorithm to explore all reachable cells from the starting point. 3. Maintain a queue for BFS and a visited set to avoid revisiting cells. 4. Return `True` if the bottom-right corner is reached during BFS traversal; otherwise, return `False`. **Additional Information**: Your solution should efficiently handle large grids within the specified constraints. Consider potential edge cases such as grids filled entirely with walls except for the start and end points.","solution":"from collections import deque def is_valid_path(n: int, m: int, grid: list[list[int]]) -> bool: if grid[0][0] == 1 or grid[n-1][m-1] == 1: return False directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] # Down, Right, Up, Left queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (n-1, m-1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return False"},{"question":"# Evaluate Postfix Expression Scenario You have been hired by a company to develop a calculator that evaluates arithmetic expressions written in postfix notation (also known as Reverse Polish notation). Postfix notation is a mathematical notation in which every operator follows all of its operands. Task Write a function `evaluate_postfix(expression: List[str]) -> float` that takes a list of strings representing a postfix expression and returns the evaluated result. Input The function will receive a list of strings: - `expression`: a list of strings, where each string represents either an operand (a numerical value) or an operator (`+`, `-`, `*`, `/`). Output The function should return a floating-point number: - The evaluated result of the postfix expression. Constraints - The input postfix expression is valid. - Operands are numerical values (int or float). - The operators are limited to `+`, `-`, `*`, and `/`. - Division is integer division. - Expect the numbers involved to be within the range of standard 32-bit integers. - Input list can contain negative numbers. Example ```python # Example of evaluating a postfix expression expression = [\\"2\\", \\"1\\", \\"+\\", \\"3\\", \\"*\\"] evaluate_postfix(expression) # Output: 9.0 expression = [\\"4\\", \\"13\\", \\"5\\", \\"/\\", \\"+\\"] evaluate_postfix(expression) # Output: 6.6 ``` # Additional Notes - Make sure your function handles edge cases like an empty expression list or a list with only one operand correctly. - Consider the optimal usage of stack data structure to evaluate the postfix expression efficiently. - Ensure your solution does not cause stack overflow issues for large expressions.","solution":"def evaluate_postfix(expression): Evaluates a postfix (Reverse Polish notation) expression. Args: expression (List[str]): Postfix expression where each string is either an operand or operator. Returns: float: Evaluated result of the postfix expression. stack = [] for token in expression: if token in \\"+-*/\\": # Pop the top two elements from the stack for the operation b = stack.pop() a = stack.pop() # Perform the operation and push the result back to the stack if token == \\"+\\": stack.append(a + b) elif token == \\"-\\": stack.append(a - b) elif token == \\"*\\": stack.append(a * b) elif token == \\"/\\": stack.append(a / b) # Ensure floating division else: # It\'s an operand; convert it to float and push it to the stack stack.append(float(token)) # The final result should be the only element left in the stack return stack[0] if stack else 0.0"},{"question":"# Problem Statement You\'re tasked with managing a data stream of integers and need to perform specific operations efficiently. The data stream can grow dynamically, and you must be able to answer range queries and perform updates in logarithmic time complexity. Tasks 1. **Implement \'update\' function** Add a method `update(index: int, value: int) -> None` to the DataStream class. This function should update the element at the specified index with the given value. 2. **Implement \'range_sum\' function** Add a method `range_sum(left: int, right: int) -> int` to the DataStream class. This function should return the sum of elements in the range [left, right] (both inclusive). # Constraints - Assume you have at most (10^5) elements in the data stream. - The `update` and `range_sum` methods should have a time complexity of O(log n), where \'n\' is the current size of the data stream. - Use appropriate data structures like Segment Trees or Binary Indexed Trees (Fenwick Trees) to achieve the required time complexity. # Function Signatures ```python def update(self, index: int, value: int) -> None: pass def range_sum(self, left: int, right: int) -> int: pass ``` # Example ```python # Initialize the data stream with initial values ds = DataStream([1, 2, 3, 4, 5]) # Update the 3rd element (0-indexed) to 10 ds.update(2, 10) # Query for the sum from index 1 to 3 (inclusive) print(ds.range_sum(1, 3)) # Output should be 16 (2 + 10 + 4) ``` **Note**: The provided DataStream class shall be used and modified according to the task requirements. Ensuring that `update` and `range_sum` operations are efficient is crucial for maintaining performance in a large data stream.","solution":"class DataStream: def __init__(self, data): self.n = len(data) self.data = data[:] self.tree = [0] * (self.n * 4) self.build(0, 0, self.n - 1) def build(self, node, start, end): if start == end: self.tree[node] = self.data[start] else: mid = (start + end) // 2 self.build(2 * node + 1, start, mid) self.build(2 * node + 2, mid + 1, end) self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2] def update(self, index, value): def _update(node, start, end): if start == end: self.data[index] = value self.tree[node] = value else: mid = (start + end) // 2 if start <= index <= mid: _update(2 * node + 1, start, mid) else: _update(2 * node + 2, mid + 1, end) self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2] _update(0, 0, self.n - 1) def range_sum(self, left, right): def _sum(node, start, end, L, R): if R < start or L > end: return 0 if L <= start and end <= R: return self.tree[node] mid = (start + end) // 2 left_sum = _sum(2 * node + 1, start, mid, L, R) right_sum = _sum(2 * node + 2, mid + 1, end, L, R) return left_sum + right_sum return _sum(0, 0, self.n - 1, left, right)"},{"question":"# Problem Statement You are tasked with implementing the LU decomposition with partial pivoting of a given square matrix. Your function should take a 2D NumPy array `A` and return three matrices `P`, `L`, and `U`, where `P` is a permutation matrix, `L` is a lower triangular matrix with unit diagonal elements, and `U` is an upper triangular matrix. This LU decomposition is useful for solving linear equations, inverting matrices, and computing determinants. # Function Signature ```python def lu_decomposition_with_pivoting(A: np.ndarray) -> Tuple[np.ndarray, np.ndarray, np.ndarray]: pass ``` # Input - `A` (NumPy 2D array): A square matrix of shape (n, n). # Output - `P` (NumPy 2D array): A permutation matrix of shape (n, n). - `L` (NumPy 2D array): A lower triangular matrix of shape (n, n) with unit diagonal elements. - `U` (NumPy 2D array): An upper triangular matrix of shape (n, n). # Constraints 1. `1 <= n <= 100` 2. `-1000.0 <= A[i][j] <= 1000.0` for all valid i, j # Example ```python import numpy as np A = np.array([[2, 0, 2, 0.6], [3, 3, 4, -2], [5, 5, 4, 2], [-1, -2, 3.4, 1]], dtype=float) P, L, U = lu_decomposition_with_pivoting(A) # Verification assert np.allclose(P @ A, L @ U), \\"Decomposition is incorrect\\" assert np.allclose(np.tril(L, -1) + np.eye(L.shape[0]), L), \\"L is not lower triangular with unit diagonal elements\\" assert np.allclose(np.triu(U), U), \\"U is not upper triangular\\" assert np.allclose(P.T @ P, np.eye(A.shape[0])), \\"P is not a valid permutation matrix\\" ``` # Notes - You are only allowed to use the `numpy` library for numerical operations. Usage of `scipy.linalg` or any inbuilt direct LU decomposition functions is prohibited. - To verify your solution: - Ensure `P @ A = L @ U`. - Check if `L` is a lower triangular matrix with unit diagonal elements. - Ensure `U` is an upper triangular matrix. - Verify if `P` is a valid permutation matrix.","solution":"import numpy as np from typing import Tuple def lu_decomposition_with_pivoting(A: np.ndarray) -> Tuple[np.ndarray, np.ndarray, np.ndarray]: Perform LU decomposition with partial pivoting on the given square matrix A. Parameters: A (np.ndarray): A square matrix of shape (n, n) Returns: Tuple[np.ndarray, np.ndarray, np.ndarray]: P, L, U matrices n = A.shape[0] U = A.copy() L = np.eye(n) P = np.eye(n) for i in range(n): # Perform partial pivoting pivot = np.argmax(np.abs(U[i:n, i])) + i if i != pivot: U[[i, pivot], :] = U[[pivot, i], :] P[[i, pivot], :] = P[[pivot, i], :] if i > 0: L[[i, pivot], :i] = L[[pivot, i], :i] # LU decomposition for j in range(i+1, n): L[j, i] = U[j, i] / U[i, i] U[j, i:n] -= L[j, i] * U[i, i:n] return P, L, U"},{"question":"# Problem Statement: A file system allocates memory in chunks of a fixed size. There are different types of files to be stored, and each type has a different fixed size. You are tasked with implementing a space allocation function that determines the minimum number of chunks required to store a given list of files. # Requirements: 1. You will be given a list of file sizes and the chunk size. 2. Return the total number of chunks required to store all files. 3. Ensure the function handles edge cases, such as empty file lists or when no extra chunks are needed beyond the minimum required. # Function Signature: ```python def min_chunks_required(files: List[int], chunk_size: int) -> int: pass ``` # Input Format: * `files`: A list of integers, where each integer represents the size of a file in bytes. * `chunk_size`: An integer representing the fixed size of each chunk in bytes. # Output Format: * An integer representing the total number of chunks required to store all files. # Example: ```python # Example 1 files = [2000, 3000, 1500] chunk_size = 1000 # File sizes: [2000, 3000, 1500] # Chunks needed: [2, 3, 2] = 7 print(min_chunks_required(files, chunk_size)) # Example 2 files = [1000, 1000, 1000] chunk_size = 1000 # File sizes: [1000, 1000, 1000] # Chunks needed: [1, 1, 1] = 3 print(min_chunks_required(files, chunk_size)) # Example 3 files = [500, 600, 700] chunk_size = 1000 # File sizes: [500, 600, 700] # Chunks needed: [1, 1, 1] = 3 print(min_chunks_required(files, chunk_size)) # Example 4 files = [] chunk_size = 1000 # No files # Chunks needed: 0 print(min_chunks_required(files, chunk_size)) ``` # Constraints: * Each file size and chunk size is a positive integer no larger than 1,000,000 bytes. * The list of files can contain up to 10,000 file sizes.","solution":"from typing import List def min_chunks_required(files: List[int], chunk_size: int) -> int: Determines the minimum number of chunks required to store a list of files given a chunk size. Parameters: files (List[int]): A list of integers representing the size of each file in bytes. chunk_size (int): The size of each chunk in bytes. Returns: int: The total number of chunks required to store all files. total_chunks = 0 for file_size in files: total_chunks += (file_size + chunk_size - 1) // chunk_size return total_chunks"},{"question":"# Coding Assessment Question Scenario You are responsible for a file system that holds files and directories with specific access permissions. Each file or directory has an access pattern string representing permissions for user, group, and others. Your task is to determine whether a given action is allowed based on the access pattern. Problem Statement Write a function `is_action_allowed(permission: str, action: str, user_type: str) -> bool` to check if the given action is permissible for a specified user type based on the access pattern. Input - `permission`: A string of length 9, representing access permissions in the format \'rwxrwxrwx\'. These represent read (r), write (w), and execute (x) permissions for user, group, and others. - `action`: A string, one of \'read\', \'write\', or \'execute\'. - `user_type`: A string, one of \'user\', \'group\', or \'others\'. Output - The function should return a boolean, `True` if the action is allowed based on the permissions, otherwise `False`. Constraints - The `permission` string will always be 9 characters long consisting of only \'r\', \'w\', \'x\', or \'-\'. - The `action` will always be one of the valid actions \'read\', \'write\', \'execute\'. - The `user_type` will always be one of \'user\', \'group\', \'others\'. Example ```python def is_action_allowed(permission: str, action: str, user_type: str) -> bool: Checks if the given action is allowed based on the access pattern for the specified user type. >>> is_action_allowed(\'rwxr-xr--\', \'read\', \'user\') True >>> is_action_allowed(\'rwxr-xr--\', \'write\', \'group\') False >>> is_action_allowed(\'rwxr-xr--\', \'execute\', \'others\') False >>> is_action_allowed(\'rwxr-xr--\', \'execute\', \'group\') True # Mapping from action to character index offsets in the permission string action_to_index = {\'read\': 0, \'write\': 1, \'execute\': 2} user_type_to_offset = {\'user\': 0, \'group\': 3, \'others\': 6} index = user_type_to_offset[user_type] + action_to_index[action] return permission[index] != \'-\' if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` You are required to ensure your solution handles edge cases appropriately and returns the correct result based on the given inputs.","solution":"def is_action_allowed(permission: str, action: str, user_type: str) -> bool: Checks if the given action is allowed based on the access pattern for the specified user type. action_to_index = {\'read\': 0, \'write\': 1, \'execute\': 2} user_type_to_offset = {\'user\': 0, \'group\': 3, \'others\': 6} index = user_type_to_offset[user_type] + action_to_index[action] return permission[index] != \'-\'"},{"question":"# Matrix Rotation You are provided with a class definition for a matrix, which includes several methods such as `__init__`, `display`, and `transpose`. Your task is to implement a new method `rotate_90_degrees` for the `Matrix` class, which will rotate the matrix by 90 degrees clockwise. Requirements: 1. **Input**: The `rotate_90_degrees` method should take no input parameters (other than `self` for the class method). 2. **Output**: The method should modify the matrix in place to achieve the 90 degrees rotation. 3. **Performance Constraints**: The method should run in O(n^2) time complexity, where n is the number of rows/columns of the matrix. 4. **Corner Cases**: Handle edge cases where the matrix is empty or is not a square matrix. Function Signature: ```python def rotate_90_degrees(self) -> None ``` Example: ```python # Example 1 matrix = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) matrix.rotate_90_degrees() assert matrix.display() == [[7, 4, 1], [8, 5, 2], [9, 6, 3]] # 90 degrees rotated matrix # Example 2 matrix = Matrix([[1, 2], [3, 4], [5, 6]]) matrix.rotate_90_degrees() assert matrix.display() == [[5, 3, 1], [6, 4, 2]] # 90 degrees rotated matrix for non-square matrix ``` **Note**: Make sure you thoroughly test your implementation with various edge cases to ensure its robustness.","solution":"class Matrix: def __init__(self, matrix): self.matrix = matrix def display(self): return self.matrix def transpose(self): self.matrix = [list(row) for row in zip(*self.matrix)] def reverse_rows(self): for row in self.matrix: row.reverse() def rotate_90_degrees(self): Rotates the matrix by 90 degrees clockwise. if not self.matrix or not self.matrix[0]: return self.transpose() self.reverse_rows()"},{"question":"# Task: Given a 2D matrix of characters and a list of words, implement a function to find the presence of each word in the matrix. Words can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once per word. # Problem Statement: Write a Python function `find_words_in_matrix(matrix: List[List[str]], words: List[str]) -> Dict[str, bool]` that takes a grid (2D list) of characters and a list of words, and returns a dictionary where the keys are the words and the values are Boolean indicating whether the word exists in the matrix or not. # Function Signature: ```python def find_words_in_matrix(matrix: List[List[str]], words: List[str]) -> Dict[str, bool]: ``` # Input: * `matrix`: A 2D list of characters where each character is an ASCII letter. * `words`: A list of strings where each string is a word to be found in the matrix. # Output: * A dictionary with each word as the key and a Boolean as the value indicating if the word is present in the matrix. # Constraints: * The number of rows and columns in the matrix will be between 1 and 100. * The length of each word in the words list will be between 1 and 10. * The maximum number of words to be checked will be 100. # Example: Given the matrix: ``` [[\'A\', \'B\', \'C\'], [\'D\', \'E\', \'F\'], [\'G\', \'H\', \'I\']] ``` And words: ``` [\'ABE\', \'EFI\', \'BDH\'] ``` # Implementation Details: * You can assume that each letter in the matrix is unique in the row and column. * Implement a helper function to search the word starting from a given cell using Depth-First Search (DFS). * Handle searching for multiple words efficiently. # Example Call: ```python matrix = [[\'A\', \'B\', \'C\'], [\'D\', \'E\', \'F\'], [\'G\', \'H\', \'I\']] words = [\'ABE\', \'EFI\', \'BDH\'] result = find_words_in_matrix(matrix, words) print(result) ``` # Expected Output: ```python {\'ABE\': True, \'EFI\': True, \'BDH\': False} ```","solution":"from typing import List, Dict def find_words_in_matrix(matrix: List[List[str]], words: List[str]) -> Dict[str, bool]: rows, cols = len(matrix), len(matrix[0]) result = {} def dfs(r, c, word, index): if index == len(word): return True if (r < 0 or c < 0 or r >= rows or c >= cols or matrix[r][c] != word[index]): return False temp, matrix[r][c] = matrix[r][c], \'#\' # Mark as visited found = (dfs(r+1, c, word, index+1) or dfs(r-1, c, word, index+1) or dfs(r, c+1, word, index+1) or dfs(r, c-1, word, index+1)) matrix[r][c] = temp # Unmark visited return found for word in words: result[word] = any(dfs(r, c, word, 0) for r in range(rows) for c in range(cols)) return result"},{"question":"# Task To test your understanding of string manipulation and counts of alphanumeric characters, implement a function that identifies whether a given string is an isogram. # Function Signature ```python def is_isogram(s: str) -> bool: Check if the given string is an isogram. :param s: The string to check. :return: True if the string is an isogram, otherwise False. ``` # Description - **Input**: A single string `s`. - **Output**: Return a boolean value, `True` if `s` is an isogram, and `False` otherwise. # Constraints - The string will only contain alphabetic characters and will be non-empty. - The string length will not exceed `10^6`. # Example ```python assert is_isogram(\\"machine\\") == True # \\"machine\\" has all unique letters assert is_isogram(\\"isogram\\") == True # \\"isogram\\" has all unique letters assert is_isogram(\\"hello\\") == False # \\"hello\\" has repeated \'l\' assert is_isogram(\\"Python\\") == True # \\"Python\\" has all unique letters assert is_isogram(\\"aabbcc\\") == False # \\"aabbcc\\" has repeated \'a\', \'b\', and \'c\' assert is_isogram(\\"Dermatoglyphics\\") == True # \\"Dermatoglyphics\\" has all unique letters assert is_isogram(\\"aba\\") == False # \\"aba\\" has repeated \'a\' ``` # Guideline 1. **Definition**: An isogram is a word or phrase without a repeating letter. 2. **Case Insensitivity**: Consider the letters case-insensitively, i.e., \'A\' and \'a\' should be considered the same. 3. **Utilize Sets**: - Use a set to keep track of characters encountered and ensure no character is encountered more than once. 4. **Efficient Check**: Loop through the string a single time, adding to the set and checking for repetitions. # Note Consider edge cases such as variations in capitalization and very long strings. Make sure your implementation is efficient with respect to both time and space complexity.","solution":"def is_isogram(s: str) -> bool: Check if the given string is an isogram. :param s: The string to check. :return: True if the string is an isogram, otherwise False. s = s.lower() seen = set() for char in s: if char in seen: return False seen.add(char) return True"},{"question":"# Classifier for Even and Odd Indexed Elements You are working on a list manipulation program that processes elements based on their position in the list (even or odd indexed). The task requires you to create a function that classifies the elements into two separate lists: one containing elements at even indices and another containing elements at odd indices. # Task Write a function `classify_indices(elements: List[int]) -> Tuple[List[int], List[int]]` that: 1. Takes in a list of integers `elements`. 2. Separates the list into two lists: - One with elements at even indices. - Another with elements at odd indices. 3. Returns a tuple containing the two lists. **Function Signature:** ```python def classify_indices(elements: List[int]) -> Tuple[List[int], List[int]] ``` Input - A list of integers `elements`. Output - A tuple containing two lists: `(even_indices_list, odd_indices_list)`. Constraints - The input list can be of any length, including zero. - The elements within the list are integers. # Scenario For example: - `classify_indices([10, 20, 30, 40, 50])` should return `([10, 30, 50], [20, 40])`, as 10, 30, and 50 are at even indices (0, 2, 4), and 20, 40 are at odd indices (1, 3). - `classify_indices([15, 25])` should return `([15], [25])`, as 15 is at index 0 and 25 is at index 1. Edge Cases - Empty list: `classify_indices([])` should return `([], [])`. - Single element list: `classify_indices([5])` should return `([5], [])`. Performance Ensure that your implementation efficiently handles lists of various lengths. # Example ```python print(classify_indices([1, 2, 3, 4, 5])) # ([1, 3, 5], [2, 4]) print(classify_indices([7, 8, 9, 10])) # ([7, 9], [8, 10]) ``` Your task is to implement the `classify_indices` function as defined above.","solution":"from typing import List, Tuple def classify_indices(elements: List[int]) -> Tuple[List[int], List[int]]: Classifies elements into two lists based on their indices: - even_indices_list: elements at even indices - odd_indices_list: elements at odd indices Args: elements (List[int]): The input list of integers. Returns: Tuple[List[int], List[int]]: A tuple containing two lists. even_indices_list = [] odd_indices_list = [] for i, element in enumerate(elements): if i % 2 == 0: even_indices_list.append(element) else: odd_indices_list.append(element) return (even_indices_list, odd_indices_list)"},{"question":"# Regular Expression Pattern Matching The objective of this coding task is to extend your understanding of regular expressions (regex) provided by the `re` module in Python. You are required to implement a function that utilizes regex to find all substrings within a given string that match a specified pattern. # Task Implement a function `find_pattern_substrings` that takes two arguments: a string and a pattern, and performs the following steps: 1. Use regular expressions to find all substrings within the given string that match the specified pattern. 2. Return the found substrings as a list of strings. # Specifications: - **Function Signature**: ```python def find_pattern_substrings(s: str, pattern: str) -> List[str] ``` - **Input Parameters**: - `s`: A string in which to search for pattern matches. - `pattern`: A string representing the regex pattern to be matched. - **Output**: - The function should return a list of strings representing the substrings from `s` that match the provided regex pattern. - **Constraints**: - You must use the `re` module from Python standard library. - Ensure that the solution handles patterns with different levels of complexity including but not limited to, simple literal matches, character sets, quantifiers, and special character sequences. # Example ```python s = \\"The rain in Spain falls mainly on the plain.\\" pattern = r\\"bw*ainb\\" print(find_pattern_substrings(s, pattern)) # Expected Output: [\'rain\', \'Spain\', \'main\', \'plain\'] ``` Note Ensure that your function handles potential issues such as special characters in the regex pattern or overlapping matches gracefully.","solution":"import re from typing import List def find_pattern_substrings(s: str, pattern: str) -> List[str]: Finds all substrings within the given string that match the specified regex pattern. Parameters: s (str): The string in which to search for pattern matches. pattern (str): The regex pattern to be matched. Returns: List[str]: A list of substrings from the input string that match the provided regex pattern. return re.findall(pattern, s)"},{"question":"Question: Implement a Custom Binary Search with Error Handling Given your understanding of the binary search algorithm, your task is to implement a refined version that includes error handling for unsorted input arrays and log the steps taken during the search process. Specifically: 1. **Implement a function `is_sorted`** that verifies if the given list is sorted in ascending order. 2. **Modify the `binary_search` function** to: - Utilize `is_sorted` to check if the array is sorted before performing the search. - Raise a `ValueError` if the array is not sorted. - Include step logging which details each midpoint and the corresponding comparison result. **Function Signature**: ```python def is_sorted(arr: list[int]) -> bool: pass def custom_binary_search(arr: list[int], target: int, log_steps: bool = False) -> tuple[int, list[tuple[int, str]]]: pass ``` **Input**: - `arr`: A list of integers. - `target`: The integer value to search for in `arr`. - `log_steps`: A boolean to determine if you should log intermediate steps and comparisons. **Output**: - A tuple containing the index of the `target` in the array (or -1 if not found) and a list of tuples where each tuple logs the midpoint and the comparison result (`\'equal\'`, `\'less\'`, `\'greater\'`). **Constraints**: - Ensure that the array is checked for being sorted in ascending order. - Handle edge cases responsibly, including empty arrays and target values outside the range of elements in `arr`. Example: ```python def example_test(): arr = [1, 2, 3, 4, 5, 6, 7, 8, 9] target = 5 index, log = custom_binary_search(arr, target, log_steps=True) print(index) # Result should be 4 (0-based index) print(log) # Intermediate steps and their comparison results example_test() ``` Ensure you test your implementation with various arrays and target values to validate its correctness and efficiency. Handle cases like unsorted arrays and verify the detailed logs for accurate step tracing.","solution":"def is_sorted(arr: list[int]) -> bool: Checks if the given list is sorted in ascending order. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def custom_binary_search(arr: list[int], target: int, log_steps: bool = False) -> tuple[int, list[tuple[int, str]]]: Performs binary search on a sorted array with logging and error handling for unsorted arrays. Args: arr: list[int] - Array of integers to search within. target: int - The target integer to search for. log_steps: bool - Flag to log the steps taken during search. Returns: tuple[int, list[tuple[int, str]]] - A tuple containing the index of the target if found, and a log of steps as (midpoint, comparison result) tuples. if not is_sorted(arr): raise ValueError(\\"The array is not sorted in ascending order.\\") left, right = 0, len(arr) - 1 log = [] while left <= right: mid = (left + right) // 2 if log_steps: if arr[mid] == target: log.append((mid, \'equal\')) elif arr[mid] < target: log.append((mid, \'less\')) else: log.append((mid, \'greater\')) if arr[mid] == target: return (mid, log) elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return (-1, log)"},{"question":"# Question: Task Scheduling with Dependency Resolution You are designing a task scheduling system that needs to execute tasks with dependencies. Each task may depend on the completion of other tasks, forming a Directed Acyclic Graph (DAG). Your task is to implement a scheduler that returns a valid execution order for a given set of tasks and their dependencies. **Task** 1. Parse the list of tasks and their dependencies. 2. Detect if there are any cycles in the task dependencies (which would make scheduling impossible). 3. If no cycles are detected, return a valid order for executing the tasks. 4. Ensure the implementation is efficient and handles edge cases properly. # Requirements **Function Signature** ```python from typing import List, Tuple def schedule_tasks(tasks: List[int], dependencies: List[Tuple[int, int]]) -> List[int]: pass # Your implementation here ``` **Input** - `tasks` (List[int]): A list of task IDs. - `dependencies` (List[Tuple[int, int]]): A list of dependencies, where each tuple represents a directed edge `(a, b)` indicating that task `a` must be completed before task `b`. **Output** - Returns a list of task IDs in the order they should be executed. If it\'s not possible to schedule the tasks due to a cycle, return an empty list to indicate failure. **Constraints** - Both input lists will have lengths up to 1000. - Task IDs are unique integers. **Performance** - Ensure the function operates efficiently under the given constraints. # Example ```python tasks = [1, 2, 3, 4, 5] dependencies = [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5)] # Expected output: A possible valid order could be [1, 2, 3, 4, 5] print(schedule_tasks(tasks, dependencies)) ``` # Note - If there are multiple valid orders, any one of them is acceptable. - Utilize graph algorithms such as topological sorting to achieve the desired functionality.","solution":"from typing import List, Tuple from collections import defaultdict, deque def schedule_tasks(tasks: List[int], dependencies: List[Tuple[int, int]]) -> List[int]: # Build the graph and calculate in-degrees graph = defaultdict(list) in_degree = {task: 0 for task in tasks} for a, b in dependencies: graph[a].append(b) in_degree[b] += 1 # Use a queue to manage tasks with no incoming edges (in-degree 0) queue = deque([task for task in tasks if in_degree[task] == 0]) sorted_order = [] while queue: current_task = queue.popleft() sorted_order.append(current_task) # Decrease the in-degree of each neighbor by 1 for neighbor in graph[current_task]: in_degree[neighbor] -= 1 # If in-degree becomes 0, add it to the queue if in_degree[neighbor] == 0: queue.append(neighbor) # If sorted order does not contain all tasks, return empty list (cycle detected) if len(sorted_order) != len(tasks): return [] return sorted_order"},{"question":"# Dynamic Programming - Minimum Coin Change You are tasked with finding the minimum number of coins required to make a given sum using the denominations provided. Implement the following functions: 1. **min_coins** - To determine the minimum number of coins needed to reach a given sum. 2. **get_coin_combination** - To retrieve the combination of coins that makes up the given sum using the minimum number of coins. # Function Definitions Function 1: min_coins ```python def min_coins(coins: list[int], sum_amount: int) -> int: Calculate the minimum number of coins required to make the given sum. Args: - coins (list[int]): Available denominations of coins. - sum_amount (int): Target sum to be made using the coins. Returns: - int: Minimum number of coins needed to reach the given sum. ``` Function 2: get_coin_combination ```python def get_coin_combination(coins: list[int], sum_amount: int) -> list[int]: Retrieve the combination of coins that make up the given sum using the minimum number of coins. Args: - coins (list[int]): Available denominations of coins. - sum_amount (int): Target sum to be made using the coins. Returns: - list[int]: A list of coins that sums up to the given sum using the minimum number of coins. ``` # Input and Output - **Input**: - coins: List of available coin denominations (each coin is an integer). - sum_amount: Integer representing the target sum. - **Output**: - For `min_coins`: Integer representing the minimum number of coins needed. - For `get_coin_combination`: List of integers representing the combination of coins that sums up to the given target sum. # Constraints - The coins array contains only positive integers. - The sum_amount is a non-negative integer. - The length of the coins array is within the range [1, 100]. - sum_amount is within the range [0, 10000]. # Additional Notes - If no combination of coins can make up the given sum, return an indication (for example, -1 for `min_coins`, and an empty list for `get_coin_combination`). - Make sure to handle edge cases such as zero or negative sums appropriately. - Comments and docstrings are encouraged for code clarity. # Example Usage ```python coins = [1, 2, 5] sum_amount = 11 # Find minimum number of coins min_count = min_coins(coins, sum_amount) print(f\\"Minimum number of coins: {min_count}\\") # Get the combination of coins coin_combination = get_coin_combination(coins, sum_amount) print(f\\"Coin combination: {coin_combination}\\") ``` # Expected Output ``` Minimum number of coins: 3 Coin combination: [5, 5, 1] ```","solution":"def min_coins(coins, sum_amount): Calculate the minimum number of coins required to make the given sum. Args: - coins (list[int]): Available denominations of coins. - sum_amount (int): Target sum to be made using the coins. Returns: - int: Minimum number of coins needed to reach the given sum, or -1 if it is not possible. dp = [float(\'inf\')] * (sum_amount + 1) dp[0] = 0 # Zero coins needed to make sum 0 for coin in coins: for x in range(coin, sum_amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[sum_amount] if dp[sum_amount] != float(\'inf\') else -1 def get_coin_combination(coins, sum_amount): Retrieve the combination of coins that make up the given sum using the minimum number of coins. Args: - coins (list[int]): Available denominations of coins. - sum_amount (int): Target sum to be made using the coins. Returns: - list[int]: A list of coins that sums up to the given sum using the minimum number of coins, or an empty list if it is not possible. dp = [float(\'inf\')] * (sum_amount + 1) dp[0] = 0 # Zero coins needed to make sum 0 backtrack = [-1] * (sum_amount + 1) for coin in coins: for x in range(coin, sum_amount + 1): if dp[x - coin] + 1 < dp[x]: dp[x] = dp[x - coin] + 1 backtrack[x] = coin if dp[sum_amount] == float(\'inf\'): return [] result = [] while sum_amount > 0: coin = backtrack[sum_amount] result.append(coin) sum_amount -= coin return result"},{"question":"# Problem Statement You are given a list of home prices in a neighborhood, represented as an array of integers where each integer represents the price of a house. You are tasked with writing a function `find_peak_prices(prices: List[int]) -> List[int]` that returns a list of prices where each price is a \\"peak\\". A \\"peak\\" is defined as a price which is greater than the prices immediately before and after it, except for the first and last houses, which only need to be greater than the single neighboring house. # Function Signature ```python def find_peak_prices(prices: List[int]) -> List[int]: ``` # Input * `prices`: A list of integers representing the prices of houses, where `1 ≤ len(prices) ≤ 10^4` and `1 ≤ price ≤ 10^6`. # Output * A list of integers representing the peak prices in the same order they appear in the input list. # Example Example 1 ```python prices = [300, 450, 600, 480, 700, 650, 800] print(find_peak_prices(prices)) # Output: [600, 700, 800] ``` Example 2 ```python prices = [100, 200, 300] print(find_peak_prices(prices)) # Output: [300] ``` Example 3 ```python prices = [900, 800, 1000, 700] print(find_peak_prices(prices)) # Output: [900, 1000] ``` # Constraints 1. You must solve this problem with `O(n)` complexity where `n` is the length of the input list. 2. Avoid any unnecessary space complexity. # Requirements * Ensure that the solution adheres to the peak definition properly and can handle edge cases like a list with only one price or two prices where the first or last price is obviously the peak.","solution":"from typing import List def find_peak_prices(prices: List[int]) -> List[int]: if len(prices) == 1: return prices peaks = [] for i in range(len(prices)): # For the first element, check only the next element if i == 0 and prices[i] > prices[i + 1]: peaks.append(prices[i]) # For the last element, check only the previous element elif i == len(prices) - 1 and prices[i] > prices[i - 1]: peaks.append(prices[i]) # For all other elements, check both previous and next elements elif 0 < i < len(prices) - 1 and prices[i] > prices[i - 1] and prices[i] > prices[i + 1]: peaks.append(prices[i]) return peaks"},{"question":"# Coding Assessment Question Context You are implementing a console-based text editor that allows users to store and manipulate their text notes. As part of this feature, you need to add a command to search for a specific word in the notes and count its occurrences. Task Create a function `count_word_occurrences(notes: str, search_word: str) -> int` which: 1. Takes a large string of notes and a search word as input. 2. Counts the occurrences of the search word in the notes, disregarding case. 3. The search should only consider full words (i.e., the search word should be bounded by whitespace or punctuation). Requirements 1. Implement the function `count_word_occurrences(notes: str, search_word: str) -> int`. 2. The function should return the count of how many times the search word appears in the notes. 3. Perform case-insensitive searching. 4. Ensure the function efficiently handles large input strings. Input and Output * **Input**: A string `notes` containing the text notes, and a string `search_word` representing the word to search for. * **Output**: An integer count of all occurrences of `search_word` within `notes`. Constraints * `notes` can be up to 100,000 characters long. * `search_word` is a non-empty string of up to 100 characters. * Consider standard English punctuation and whitespace as word boundaries. Example: ```python >>> notes = \\"Hello, world! The world is beautiful. World: a place we live in.\\" >>> search_word = \\"world\\" >>> count = count_word_occurrences(notes, search_word) >>> print(count) 3 ```","solution":"import re def count_word_occurrences(notes: str, search_word: str) -> int: Count the occurrences of the search word in the notes, disregarding case. Args: notes (str): The string containing the text notes. search_word (str): The word to search for within the notes. Returns: int: The count of occurrences of the search word in the notes. # Using regular expression to count full word matches, case insensitive pattern = re.compile(r\'b\' + re.escape(search_word) + r\'b\', re.IGNORECASE) matches = pattern.findall(notes) return len(matches)"},{"question":"# Question on Sorting a List of Dictionaries by Key Context Manipulating lists of dictionaries is common in data processing where each dictionary represents a record with multiple attributes. One typical operation is sorting the collection based on one or more keys. Task Given a list of dictionaries, create a function to sort the list by the specified key(s) in either ascending or descending order. Function Requirements 1. **Function Signature**: ```python def sort_list_of_dicts(data: list, keys: list, reverse: bool = False) -> list: ``` 2. **Parameters**: * `data` (list): A list of dictionaries to be sorted. * `keys` (list): A list of keys used for sorting. The list should allow for multi-level sorting, where the first key has the highest priority. * `reverse` (bool): A flag indicating whether the sorting should be in descending order. Defaults to `False` (ascending order). 3. **Return Value**: * `sorted_data` (list): The sorted list of dictionaries. Constraints * The list of dictionaries will be non-empty. * Each dictionary in the list will have all the keys specified in the `keys` parameter. * The values for the keys in the dictionaries will be comparable (e.g., all integers, all strings). * The `keys` list will contain at least one key. * Keys in the dictionaries are assumed to be strings. Performance Requirements Your solution should handle typical data sizes efficiently, with up to thousands of items in the list. Example Consider the following dataset and key for sorting: ```python data = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"score\\": 85}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"score\\": 90}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"score\\": 78} ] ``` Sorting by the key `age` in ascending order would result in: ```python sorted_data = sort_list_of_dicts(data, [\\"age\\"]) # sorted_data: # [ # {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"score\\": 90}, # {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"score\\": 85}, # {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"score\\": 78} # ] ``` Sorting by `score` in descending order: ```python sorted_data = sort_list_of_dicts(data, [\\"score\\"], True) # sorted_data: # [ # {\\"name\\": \\"Bob\\", \\"score\\": 90, \\"age\\": 25}, # {\\"name\\": \\"Alice\\", \\"score\\": 85, \\"age\\": 30}, # {\\"name\\": \\"Charlie\\", \\"score\\": 78, \\"age\\": 35} # ] ``` Submit your implementation of the `sort_list_of_dicts` function below:","solution":"def sort_list_of_dicts(data: list, keys: list, reverse: bool = False) -> list: Sorts a list of dictionaries by specified keys. Parameters: data (list): A list of dictionaries to be sorted. keys (list): A list of keys used for sorting. reverse (bool): Should the list be sorted in descending order? Defaults to False. Returns: list: The sorted list of dictionaries. def get_sort_key(item): return tuple(item[key] for key in keys) sorted_data = sorted(data, key=get_sort_key, reverse=reverse) return sorted_data"},{"question":"# Coding Assessment Question Problem Statement: You are provided with a function `product_of_primes` which is supposed to calculate the product of all prime numbers up to and including a given number `n`. Your task is to implement this function efficiently. Input: - An integer `n` (2 <= n <= 10,000). Output: - An integer representing the product of all prime numbers less than or equal to `n`. Constraints: - The integer `n` will be a valid number within the specified range. - The solution must be efficient and handle the maximum constraint gracefully. Function Signature: ```python def product_of_primes(n: int) -> int: pass ``` Example: ```python print(product_of_primes(10)) # Output: 210 (because 2 * 3 * 5 * 7 = 210) print(product_of_primes(20)) # Output: 9699690 (because 2 * 3 * 5 * 7 * 11 * 13 * 17 * 19 = 9699690) ``` Context: You have been tasked by a scientific research team to compute the product of all prime numbers up to a certain threshold. This task needs an efficient algorithm to accommodate their large data analysis involving prime products. # Requirements: - Implement an optimized algorithm that efficiently identifies prime numbers and computes their product. - Avoid naive solutions that could lead to performance issues with larger inputs. Hint: Consider utilizing the Sieve of Eratosthenes to generate a list of all prime numbers up to `n`, then compute their product.","solution":"def product_of_primes(n: int) -> int: Calculate the product of all prime numbers up to and including n. if n < 2: return 1 sieve = [True] * (n + 1) sieve[0] = sieve[1] = False # 0 and 1 are not primes for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start * start, n + 1, start): sieve[multiple] = False product = 1 for num in range(2, n + 1): if sieve[num]: product *= num return product"},{"question":"# Stock Prices Prediction with LSTM Given the partially implemented Long Short-Term Memory (LSTM) class named `LSTM` above, your task is to complete the functionality to implement a stock prices prediction system. You will need to: 1. **Implement the `train` method** in the `LSTM` class to handle sequential input data for a given number of epochs and batch size. 2. **Implement the `predict` method** to generate predictions based on the recent sequence of stock prices. # Implementation Details: 1. **`train` method** should: - Accept training data (historical stock prices) and validation data, along with the number of epochs and batch size. - Perform training using the training data and incorporate backpropagation through time (BPTT). - Validate the model at the end of each epoch using validation data. - Print or log the training and validation loss after each epoch. 2. **`predict` method** should: - Accept a sequence of recent stock prices. - Return the predicted next stock price based on the input sequence. # Input/Output: - **Input**: - For `train` method: ```python def train(self, X_train, y_train, X_val, y_val, epochs, batch_size): # X_train, y_train: Training data (sequences of stock prices and their next prices) # X_val, y_val: Validation data (sequences of stock prices and their next prices) # epochs: Number of epochs for training # batch_size: Size of each batch during training ``` - For `predict` method: ```python def predict(self, X_seq): # X_seq: Sequence of recent stock prices ``` - **Output**: - For `train` method: No explicit return, but should print/log training and validation loss for each epoch. - For `predict` method: Return the predicted stock price for the given input sequence. # Constraints: 1. Assume data is provided in appropriate format (e.g., numpy arrays). 2. `train` method should utilize the existing LSTM operations to handle sequential data and backpropagation through time. 3. Implementation should be efficient and utilize numpy operations where possible for computational efficiency. # Notes: - Focus on enhancing model training with sequential input processing and epoch loops. - Consider common practices in time series forecasting such as feature scaling, train-validation split, and shuffling within batches. # Example Scenario: ```python # Assuming model is initialized and data is preprocessed lstm = LSTM(input_dim=1, hidden_dim=50, output_dim=1, num_layers=2) lstm.train(X_train, y_train, X_val, y_val, epochs=20, batch_size=16) predicted_price = lstm.predict(recent_prices) print(f\\"Predicted next stock price: {predicted_price}\\") ```","solution":"import numpy as np class LSTM: def __init__(self, input_dim, hidden_dim, output_dim, num_layers): self.input_dim = input_dim self.hidden_dim = hidden_dim self.output_dim = output_dim self.num_layers = num_layers self.weights = self.initialize_weights() def initialize_weights(self): # Initialize the LSTM weights weights = { \'Wf\': np.random.randn(self.hidden_dim, self.hidden_dim + self.input_dim), \'Wi\': np.random.randn(self.hidden_dim, self.hidden_dim + self.input_dim), \'Wo\': np.random.randn(self.hidden_dim, self.hidden_dim + self.input_dim), \'Wc\': np.random.randn(self.hidden_dim, self.hidden_dim + self.input_dim), \'Wy\': np.random.randn(self.output_dim, self.hidden_dim) } biases = { \'bf\': np.zeros((self.hidden_dim, 1)), \'bi\': np.zeros((self.hidden_dim, 1)), \'bo\': np.zeros((self.hidden_dim, 1)), \'bc\': np.zeros((self.hidden_dim, 1)), \'by\': np.zeros((self.output_dim, 1)) } weights.update(biases) return weights def sigmoid(self, x): return 1 / (1 + np.exp(-x)) def tanh(self, x): return np.tanh(x) def train(self, X_train, y_train, X_val, y_val, epochs, batch_size): for epoch in range(epochs): training_loss = 0 val_loss = 0 for i in range(0, len(X_train), batch_size): X_batch = X_train[i:i+batch_size] y_batch = y_train[i:i+batch_size] batch_loss = 0 for X, y in zip(X_batch, y_batch): pred = self.forward_step(X) loss = self.compute_loss(pred, y) self.backward_step(X, y) batch_loss += loss training_loss += batch_loss / len(X_batch) for i in range(0, len(X_val), batch_size): X_val_batch = X_val[i:i+batch_size] y_val_batch = y_val[i:i+batch_size] batch_loss = 0 for X, y in zip(X_val_batch, y_val_batch): pred = self.forward_step(X) loss = self.compute_loss(pred, y) batch_loss += loss val_loss += batch_loss / len(X_val_batch) print(f\\"Epoch {epoch+1}/{epochs} - Training Loss: {training_loss:.4f}, Validation Loss: {val_loss:.4f}\\") def forward_step(self, X): h_prev = np.zeros((self.hidden_dim, 1)) c_prev = np.zeros((self.hidden_dim, 1)) for t in range(X.shape[0]): xt = X[t].reshape(-1, 1) z = np.row_stack((h_prev, xt)) ft = self.sigmoid(np.dot(self.weights[\'Wf\'], z) + self.weights[\'bf\']) it = self.sigmoid(np.dot(self.weights[\'Wi\'], z) + self.weights[\'bi\']) ot = self.sigmoid(np.dot(self.weights[\'Wo\'], z) + self.weights[\'bo\']) cct = self.tanh(np.dot(self.weights[\'Wc\'], z) + self.weights[\'bc\']) c_prev = ft * c_prev + it * cct h_prev = ot * self.tanh(c_prev) y_pred = np.dot(self.weights[\'Wy\'], h_prev) + self.weights[\'by\'] return y_pred def compute_loss(self, y_pred, y_true): return ((y_pred - y_true) ** 2).mean() def backward_step(self, X, y): # Backpropagation step (placeholder for actual implementation) pass def predict(self, X_seq): return self.forward_step(X_seq).flatten()"},{"question":"# Coding Question: Fibonacci Subsequence Extractor Write a Python function that extracts a specific range of Fibonacci numbers from the Fibonacci sequence. The sequence starts from 0 and 1, and each subsequent number is the sum of the previous two. Your Task Implement the function `extract_fibonacci_subsequence(start: int, end: int) -> list[int]` that follows these rules: 1. The function accepts two parameters: * `start` (int): The starting index (inclusive) of the Fibonacci subsequence. * `end` (int): The ending index (exclusive) of the Fibonacci subsequence. 2. Returns a list containing the Fibonacci subsequence from the specified start index to the end index. 3. If `start` is greater than or equal to `end`, return an empty list. 4. If any index is less than 0, return an empty list. 5. The function should handle large indices efficiently within standard computational limits. Example Usage ```python assert extract_fibonacci_subsequence(0, 5) == [0, 1, 1, 2, 3] assert extract_fibonacci_subsequence(2, 6) == [1, 2, 3, 5] assert extract_fibonacci_subsequence(5, 10) == [5, 8, 13, 21, 34] assert extract_fibonacci_subsequence(7, 7) == [] assert extract_fibonacci_subsequence(-3, 2) == [] ``` Constraints * `0 <= start, end <= 10^4` * Ensure the solution is optimized for memory and performance. Performance Requirements * Aim for an efficient solution ideally with O(n) time complexity where n is the number of Fibonacci numbers to be computed. * Ensure computations handle large numbers accurately without overflow.","solution":"def extract_fibonacci_subsequence(start, end): Extracts a specific range of Fibonacci numbers from the sequence. Parameters: start (int): The starting index (inclusive). end (int): The ending index (exclusive). Returns: list[int]: The Fibonacci subsequence from start to end. if start >= end or start < 0 or end < 0: return [] # Initialize the first two Fibonacci numbers fibonacci = [0, 1] # Generate Fibonacci numbers up to the end index for i in range(2, end): fibonacci.append(fibonacci[-1] + fibonacci[-2]) # Extract the subsequence return fibonacci[start:end]"},{"question":"# Question: Data Consistency Checker for Enrollment Records You are given a function that processes enrollment records for a university system. The function needs to ensure data consistency by validating specific constraints and providing clear error messages when constraints are violated. Your Task Improve the given function to enforce data integrity and provide clear feedback for any inconsistencies. Specifically, you should: 1. Validate that the `student_id` and `course_id` are both positive integers. 2. Ensure that `enrollment_date` is not in the future. 3. Verify that `grade` is between 0 and 100, inclusive. 4. Provide clear error messages for any constraint violations. Function Signature ```python def check_enrollment_record( student_id: int, course_id: int, enrollment_date: str, grade: float ) -> dict[str, bool]: ``` Input - `student_id`: The student\'s unique identifier (a positive integer). - `course_id`: The course\'s unique identifier (a positive integer). - `enrollment_date`: The date the student enrolled in the course (a string in \\"YYYY-MM-DD\\" format). - `grade`: The student\'s grade (a float between 0 and 100 inclusive). Output - A dictionary with keys indicating the validated attributes and boolean values indicating whether each attribute is valid. Constraints - **Positive Integers**: `student_id` and `course_id` must be positive integers. - **Date Validation**: `enrollment_date` must not be in the future based on the current date. - **Grade Range**: `grade` must be in the range [0, 100]. Examples ```python assert check_enrollment_record(123, 456, \\"2023-09-15\\", 85.5) == { \\"student_id\\": True, \\"course_id\\": True, \\"enrollment_date\\": True, \\"grade\\": True } assert check_enrollment_record(-123, 456, \\"2023-09-15\\", 85.5) == { \\"student_id\\": False, \\"course_id\\": True, \\"enrollment_date\\": True, \\"grade\\": True } assert check_enrollment_record(123, 456, \\"2025-09-15\\", 85.5) == { \\"student_id\\": True, \\"course_id\\": True, \\"enrollment_date\\": False, \\"grade\\": True } assert check_enrollment_record(123, 456, \\"2023-09-15\\", 105.5) == { \\"student_id\\": True, \\"course_id\\": True, \\"enrollment_date\\": True, \\"grade\\": False } ``` Implement the function to enforce data integrity and provide clear feedback for any inconsistencies.","solution":"from datetime import datetime def check_enrollment_record(student_id: int, course_id: int, enrollment_date: str, grade: float) -> dict: Validates the enrollment record ensuring data integrity by checking: - student_id and course_id are positive integers, - enrollment_date is not in the future, - grade is between 0 and 100 inclusive. Arguments: student_id -- student\'s unique identifier (positive integer) course_id -- course\'s unique identifier (positive integer) enrollment_date -- date the student enrolled in the course (format \\"YYYY-MM-DD\\") grade -- student\'s grade (float between 0 and 100 inclusive) Returns: A dictionary indicating the validity of each attribute. result = { \\"student_id\\": True, \\"course_id\\": True, \\"enrollment_date\\": True, \\"grade\\": True, } # Validate student_id if not isinstance(student_id, int) or student_id <= 0: result[\\"student_id\\"] = False # Validate course_id if not isinstance(course_id, int) or course_id <= 0: result[\\"course_id\\"] = False # Validate enrollment_date try: enrollment_date_obj = datetime.strptime(enrollment_date, \\"%Y-%m-%d\\") if enrollment_date_obj > datetime.now(): result[\\"enrollment_date\\"] = False except ValueError: result[\\"enrollment_date\\"] = False # Validate grade if not (0 <= grade <= 100): result[\\"grade\\"] = False return result"},{"question":"# Scenario You have been contracted by an online marketplace platform to develop a feature that helps users identify the best time to buy products based on historical price trends. The feature should analyze a list of daily prices for a product and recommend the maximum possible profit a user could achieve if they bought the product on one day and sold it on a later date. # Task Implement a function that takes a list of daily prices for a product and determines the maximum potential profit. The function should return the maximum profit that can be achieved or 0 if no profit is possible. # Input - A list of integers representing the daily prices of the product. - Constraints: Each price is a positive integer, and the list can have up to 10,000 elements. # Output - An integer representing the maximum profit, or 0 if no profit can be achieved. # Function Signature ```python from typing import List def max_profit(prices: List[int]) -> int: pass ``` # Example ```python print(max_profit([7, 1, 5, 3, 6, 4])) # Output: 5 (Buy on day 2 at price 1, and sell on day 5 at price 6) print(max_profit([7, 6, 4, 3, 1])) # Output: 0 (No profit can be achieved) print(max_profit([1, 2, 3, 4, 5])) # Output: 4 (Buy on day 1 at price 1, and sell on day 5 at price 5) print(max_profit([3, 3, 3, 3, 3])) # Output: 0 (Prices do not change) import random prices = random.sample(range(1, 100), 10000) print(max_profit(prices)) # Output: (example depends on random prices) ``` # Constraints - The function must handle edge cases efficiently, such as very small or very large input lists. - Consider both time and space complexities, aiming for O(n) time complexity. - Do not use built-in functions that directly solve the problem. Evaluate the implementation on large datasets to ensure optimal performance.","solution":"from typing import List def max_profit(prices: List[int]) -> int: if not prices: return 0 min_price = float(\'inf\') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"# Encrypt and Decrypt a Message You are tasked with implementing a simple encryption and decryption algorithm for messages. The algorithm uses a Caesar cipher technique where each letter in the message is shifted by a specified number of places. The cipher should only modify alphabetic characters, leaving other characters unchanged. **Problem Statement:** Write two functions: `encrypt_message` and `decrypt_message`. The `encrypt_message` function takes in a string message and an integer shift value and outputs the encrypted message. The `decrypt_message` function takes in an encrypted message and the same shift value used for encryption and outputs the original message. - The first function `encrypt_message`: - `message` is a string containing the original message. - `shift` is an integer representing the number of places to shift each letter. - The second function `decrypt_message`: - `encrypted_message` is a string containing the encrypted message. - `shift` is the same integer used during the encryption process. **Function Signatures:** ```python def encrypt_message(message: str, shift: int) -> str: def decrypt_message(encrypted_message: str, shift: int) -> str: ``` **Input Format:** - `message`: a string of length n (1 ≤ n ≤ 10^4) containing alphabetic and non-alphabetic characters. - `shift`: an integer (0 ≤ shift ≤ 25). **Output Format:** - For `encrypt_message`, return a string representing the encrypted message. - For `decrypt_message`, return a string representing the decrypted original message. **Examples:** ```python >>> encrypt_message(\\"Hello, World!\\", 3) \'Khoor, Zruog!\' >>> decrypt_message(\\"Khoor, Zruog!\\", 3) \'Hello, World!\' >>> encrypt_message(\\"Python 3.8\\", 5) \'Udymts 3.8\' >>> decrypt_message(\\"Udymts 3.8\\", 5) \'Python 3.8\' ``` **Constraints:** - The string length n will be in the range [1, 10^4]. - The shift value will be within the range [0, 25]. - All characters in the input strings are guaranteed to be either alphabetic characters (a-z, A-Z) or other printable characters. **Scoring:** - Correctness: Solutions will be verified based on correct implementation of the encryption and decryption processes. - Efficiency: Solutions must handle the upper range of input efficiently.","solution":"def encrypt_message(message: str, shift: int) -> str: encrypted = [] for char in message: if \'a\' <= char <= \'z\': encrypted.append(chr((ord(char) - ord(\'a\') + shift) % 26 + ord(\'a\'))) elif \'A\' <= char <= \'Z\': encrypted.append(chr((ord(char) - ord(\'A\') + shift) % 26 + ord(\'A\'))) else: encrypted.append(char) return \'\'.join(encrypted) def decrypt_message(encrypted_message: str, shift: int) -> str: decrypted = [] for char in encrypted_message: if \'a\' <= char <= \'z\': decrypted.append(chr((ord(char) - ord(\'a\') - shift) % 26 + ord(\'a\'))) elif \'A\' <= char <= \'Z\': decrypted.append(chr((ord(char) - ord(\'A\') - shift) % 26 + ord(\'A\'))) else: decrypted.append(char) return \'\'.join(decrypted)"},{"question":"# Problem Scenario A company hires employees in different departments and at different pay grades. The company wants to create an automated system to keep track of each employee\'s salary details. They follow a unique way of storing salaries which is a combination of department code and pay grade. Each department has a unique one-letter code (for example, \'A\', \'B\', \'C\') and each pay grade is represented by an integer (for example, 1, 2, 3). The salary for any employee can be found in a dictionary structured as `{\'department_code + pay_grade\': salary}`. Your task is to help the company by writing a function that calculates the total salary expenses for a given department. # Task Write a function `calculate_department_expenses(salaries: dict, department_code: str) -> int`. Your function should: 1. Take as input: - A dictionary where keys are strings representing \\"department code + pay grade\\" and values are integers representing salaries. - A string representing the department code to calculate the total salary expenses for. 2. Return the total salary expenses for all employees in that department. # Expected Input and Output Input: * A dictionary, `salaries`, structured as described above. - Example: `{\'A1\': 5000, \'A2\': 6000, \'B1\': 4500, \'B2\': 5500}` * A string, `department_code`, representing the department to calculate the expenses for. - Example: `\'A\'` Output: * An integer representing the total salary expenses for the given department. - Example: `11000` # Constraints: * The dictionary `salaries` will have at most 1000 entries. * Each key in the dictionary will always be correctly formatted as a single letter followed by an integer. * All salary values in the dictionary will be positive integers. # Performance Requirements: * Your solution should be efficient, iterating through the dictionary once and performing constant-time operations. # Example ```python def calculate_department_expenses(salaries: dict, department_code: str) -> int: # Implement the logic to sum the salaries for the given department pass # Example usage: print(calculate_department_expenses({\'A1\': 5000, \'A2\': 6000, \'B1\': 4500, \'B2\': 5500}, \'A\')) # Output: 11000 ``` Provide your implementation of the `calculate_department_expenses()` function to correctly sum the salaries for the given department.","solution":"def calculate_department_expenses(salaries: dict, department_code: str) -> int: Calculate the total salary expenses for a given department. Parameters: salaries (dict): A dictionary where keys are strings representing \\"department code + pay grade\\" and values are integers representing salaries. department_code (str): A string representing the department code to calculate the total salary expenses for. Returns: int: The total salary expenses for all employees in that department. total_expenses = 0 for key, salary in salaries.items(): if key.startswith(department_code): total_expenses += salary return total_expenses"},{"question":"# Distance to Closest Zero Given a matrix of integers, where each cell contains either a 0 or a positive integer, the task is to find the distance of each cell from the nearest 0. The distance between any two adjacent cells is 1. Implement a solution that efficiently computes the distances using an appropriate algorithm. Function Signature ```python def update_matrix(matrix: List[List[int]]) -> List[List[int]]: pass ``` Input * `matrix` (List[List[int]]): A 2D matrix where each element is either 0 or a positive integer. The dimensions of the matrix will be at most 200 x 200. Output * Return a List[List[int]] which is the same size as the input matrix, where each cell contains the distance to the nearest 0. Constraints * The matrix will contain at least one element and at most 40,000 elements. * Should handle cases where there are no 0s in the matrix. * Use BFS (Breadth-First Search) for efficiency to solve the problem. Example ```python matrix = [ [0, 1, 2], [1, 2, 0], [1, 0, 1], ] print(update_matrix(matrix)) # Output: # [ # [0, 1, 1], # [1, 1, 0], # [1, 0, 1] # ] ``` # Prompt Write a Python function `update_matrix(matrix: List[List[int]]) -> List[List[int]]` that takes a 2D matrix as input and returns a 2D matrix where each element contains the distance to the nearest 0 using an efficient algorithm such as BFS. Ensure to handle large inputs efficiently, consider edge cases, and avoid performance bottlenecks wherever possible.","solution":"from collections import deque from typing import List def update_matrix(matrix: List[List[int]]) -> List[List[int]]: rows, cols = len(matrix), len(matrix[0]) dist = [[float(\'inf\')] * cols for _ in range(rows)] queue = deque() # Initialize the queue with all the 0 cells for r in range(rows): for c in range(cols): if matrix[r][c] == 0: dist[r][c] = 0 queue.append((r, c)) # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS while queue: r, c = queue.popleft() for dr, dc in directions: rr, cc = r + dr, c + dc if 0 <= rr < rows and 0 <= cc < cols: if dist[rr][cc] > dist[r][c] + 1: dist[rr][cc] = dist[r][c] + 1 queue.append((rr, cc)) return dist"},{"question":"# Question: String Permutation Checker You are tasked with implementing a function that checks if one string is a permutation of another string. Two strings are permutations of each other if they contain the same characters in the same counts, but possibly in a different order. Your function should handle various input cases, including invalid inputs, and return a boolean value indicating whether the second string is a permutation of the first one. Constraints 1. The input strings can contain any printable ASCII characters. 2. Both input strings are non-empty. 3. You should raise a `ValueError` with a specific message for invalid inputs as described below. Input and Output Format * **Input**: Two strings. - Example: `\\"nick\\"`, `\\"kcin\\"`, `\\"brad\\"`, `\\"dbra\\"` * **Output**: A boolean value indicating whether the second string is a permutation of the first one. - Example: `True`, `False` Function Signature ```python def is_permutation(str1: str, str2: str) -> bool: ``` Implementation Details 1. If either input string is empty, raise a `ValueError` with the message `\\"Empty string(s) were passed to the function\\"`. 2. The function should check the characters and their counts in both strings to determine if one is a permutation of the other. 3. Case sensitivity should be maintained (i.e., uppercase and lowercase characters are considered different). Examples ```python >>> is_permutation(\\"nick\\", \\"kcin\\") True >>> is_permutation(\\"brad\\", \\"dbra\\") True >>> is_permutation(\\"apple\\", \\"applf\\") False >>> is_permutation(\\"foo\\", \\"bar\\") False >>> is_permutation(\\"\\", \\"abc\\") Traceback (most recent call last): ... ValueError: Empty string(s) were passed to the function >>> is_permutation(\\"hello\\", \\"\\") Traceback (most recent call last): ... ValueError: Empty string(s) were passed to the function ``` Notes * Consider how the function should handle case sensitivity and different printable ASCII characters. * Ensure your function correctly identifies and handles edge cases by raising appropriate errors.","solution":"def is_permutation(str1: str, str2: str) -> bool: Returns True if str2 is a permutation of str1, else returns False. Raises ValueError if either input string is empty. if not str1 or not str2: raise ValueError(\\"Empty string(s) were passed to the function\\") # Count the characters in both strings from collections import Counter return Counter(str1) == Counter(str2)"},{"question":"# Temperature Data Analysis In this assessment, you are required to implement a Python function that processes a collection of temperature data recorded over several days. This function should demonstrate your understanding of data manipulation and statistical analysis in Python. Function Signature ```python def analyze_temperatures(data: List[Dict[str, Any]]) -> Dict[str, float]: Analyzes a list of temperature data and returns a dictionary with statistical information. :param data: A list of dictionaries, each containing \'date\' and \'temperature\' keys. :return: A dictionary with keys \'mean\', \'median\', \'min\', \'max\' representing respective statistical values of the temperatures. ``` Instructions 1. **Data Format**: Each dictionary in the input list contains a \'date\' string in YYYY-MM-DD format and a \'temperature\' float indicating the temperature for that date. 2. **Statistical Analysis**: Calculate and return the mean, median, minimum, and maximum temperatures from the dataset. 3. **Libraries**: You may utilize standard libraries such as `statistics` and `datetime` for the operations. Constraints - The input list will contain at least one dictionary. - Dates will be unique and valid. - Temperatures will be real numbers. Example Input: ```python data = [ {\\"date\\": \\"2023-03-01\\", \\"temperature\\": 15.0}, {\\"date\\": \\"2023-03-02\\", \\"temperature\\": 18.5}, {\\"date\\": \\"2023-03-03\\", \\"temperature\\": 12.3}, {\\"date\\": \\"2023-03-04\\", \\"temperature\\": 20.1}, ] result = analyze_temperatures(data) ``` Expected Output: ```python { \\"mean\\": 16.475, \\"median\\": 16.75, \\"min\\": 12.3, \\"max\\": 20.1 } ``` Important Points - Ensure your function correctly handles edge cases such as a single entry in the dataset. - Ensure that calculations are accurate to a reasonable number of decimal places. - You may assume that the input dates are already in chronological order.","solution":"from typing import List, Dict, Any import statistics def analyze_temperatures(data: List[Dict[str, Any]]) -> Dict[str, float]: temperatures = [entry[\'temperature\'] for entry in data] mean_temp = statistics.mean(temperatures) median_temp = statistics.median(temperatures) min_temp = min(temperatures) max_temp = max(temperatures) return { \\"mean\\": mean_temp, \\"median\\": median_temp, \\"min\\": min_temp, \\"max\\": max_temp }"},{"question":"# Order Frequency Checker **Background**: In e-commerce systems, it is important to track the frequencies of orders for different products. Your task is to develop a function that calculates how often each product was ordered. **Function Specification**: Implement the function `order_frequency(order_list)` that accomplishes the task. **Input**: - `order_list`: A list of strings where each string represents a product ID indicating that the product was ordered. **Output**: - A dictionary where the keys are product IDs and the values are the counts of how many times each product was ordered. - If the input list is empty, return an empty dictionary. **Constraints**: - The product IDs shall be treated as case-insensitive (i.e., \'product1\' and \'PRODUCT1\' should be considered the same). **Performance Requirements**: - The solution should handle large input sizes efficiently. **Example**: ```python def order_frequency(order_list): # Your code here # Examples print(order_frequency([\\"apple\\", \\"banana\\", \\"Apple\\", \\"orange\\", \\"banana\\"])) # {\\"apple\\": 2, \\"banana\\": 2, \\"orange\\": 1} print(order_frequency([\\"productA\\", \\"productB\\", \\"ProductA\\", \\"PRODUCTB\\", \\"producta\\"])) # {\\"producta\\": 3, \\"productb\\": 2} print(order_frequency([])) # {} ``` Implement the `order_frequency` function to demonstrate your understanding of handling case-insensitive counting and efficiently producing a frequency table for product orders.","solution":"def order_frequency(order_list): Returns the frequency of each product in the order list. The frequency count is case-insensitive. frequency_dict = {} for product in order_list: product_lower = product.lower() if product_lower in frequency_dict: frequency_dict[product_lower] += 1 else: frequency_dict[product_lower] = 1 return frequency_dict"},{"question":"**Context**: You are assigned to develop a tool that processes log entries from a system\'s operation logs. Each log entry contains a timestamp and an event description. The tool should filter the logs based on the time range specified by the user. It should then print out the filtered logs in chronological order and count the number of logs within the specified time range. **Task**: Create a function `filter_logs_by_time` that accepts a list of log entries and two timestamps specifying the start and end of the time range. The function should filter the logs based on the given time range and print them sequentially. **Function Signature**: ```python def filter_logs_by_time(logs: List[str], start_time: str, end_time: str) -> None: ``` **Input**: - `logs`: A list of strings, where each string is formatted as \\"yyyy-mm-dd HH:MM:SS - EVENT_DESCRIPTION\\" - `start_time`: A string representing the start time of the range in \\"yyyy-mm-dd HH:MM:SS\\" format. - `end_time`: A string representing the end time of the range in \\"yyyy-mm-dd HH:MM:SS\\" format. **Output**: - Print the filtered logs in chronological order. - Print the total count of filtered logs. **Examples**: ```python logs = [ \\"2023-01-01 10:00:00 - System rebooted\\", \\"2023-01-01 12:30:00 - User login\\", \\"2023-01-01 15:00:00 - File uploaded\\", \\"2023-01-02 09:00:00 - Error detected\\", \\"2023-01-02 11:45:00 - System shutdown\\" ] start_time = \\"2023-01-01 12:00:00\\" end_time = \\"2023-01-02 10:00:00\\" filter_logs_by_time(logs, start_time, end_time) ``` Expected Output: ``` 2023-01-01 12:30:00 - User login 2023-01-01 15:00:00 - File uploaded 3 ``` **Constraints**: - Log entries are guaranteed to be in chronological order. - Timestamps are formatted correctly. - It is ensured that `start_time` is less than or equal to `end_time`. - The input list `logs` is not empty. Ensure that your implementation adheres to the provided constraints and handles potential edge cases effectively.","solution":"from typing import List def filter_logs_by_time(logs: List[str], start_time: str, end_time: str) -> None: filtered_logs = [log for log in logs if start_time <= log[:19] <= end_time] for log in filtered_logs: print(log) print(len(filtered_logs))"},{"question":"# Question You need to implement a set of functions to perform operations on a balanced binary search tree (BST). The functions should support the following operations efficiently: 1. `insert`: Insert a new value into the BST. 2. `delete`: Delete a value from the BST. 3. `search`: Check whether a value exists in the BST. 4. `inorder_traversal`: Return the values of the tree in sorted order. Objectives - Implement a balanced BST class, ensuring optimal time complexities for the above operations. - Utilize an appropriate balancing mechanism, such as AVL tree, Red-Black tree, or any other self-balancing technique. Input - `insert`, `delete`, and `search` functions will take a single integer value as input. - `inorder_traversal` function will take no input. Output - `insert` and `delete` functions will not return any value. - `search` function will return `True` if the value exists in the BST, `False` otherwise. - `inorder_traversal` function will return a list of integers representing the tree\'s values in sorted order. Constraints - Values for insertion, deletion, and search will be integers in the range [-10^6, 10^6]. - The tree should handle up to 10^5 operations efficiently. Example ```python # Sample usage tree = BalancedBST() tree.insert(10) tree.insert(20) tree.insert(5) print(tree.inorder_traversal()) # Expected: [5, 10, 20] print(tree.search(10)) # Expected: True print(tree.search(15)) # Expected: False tree.delete(10) print(tree.inorder_traversal()) # Expected: [5, 20] print(tree.search(10)) # Expected: False ``` Requirements 1. Implement the `BalancedBST` class with appropriate methods inside it. 2. Ensure that the tree remains balanced after each insertion or deletion. 3. Aim for optimal time complexities for each operation: O(log n) for insert, delete, and search, and O(n) for inorder traversal. By maintaining these requirements, your implementation should be efficient and capable of handling large inputs and operations smoothly.","solution":"class AVLTreeNode: def __init__(self, key, left=None, right=None, height=1): self.key = key self.left = left self.right = right self.height = height class BalancedBST: def __init__(self): self.root = None def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return AVLTreeNode(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._height(node.left), self._height(node.right)) return self._balance(node) def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, node, key): if not node: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp = self._get_min_value_node(node.right) node.key = temp.key node.right = self._delete(node.right, temp.key) node.height = 1 + max(self._height(node.left), self._height(node.right)) return self._balance(node) def search(self, key): return self._search(self.root, key) def _search(self, node, key): if not node: return False if node.key == key: return True elif key < node.key: return self._search(node.left, key) else: return self._search(node.right, key) def inorder_traversal(self): result = [] self._inorder_traversal(self.root, result) return result def _inorder_traversal(self, node, result): if node: self._inorder_traversal(node.left, result) result.append(node.key) self._inorder_traversal(node.right, result) def _height(self, node): if not node: return 0 return node.height def _balance(self, node): balance = self._get_balance(node) if balance > 1: if self._get_balance(node.left) < 0: node.left = self._rotate_left(node.left) return self._rotate_right(node) if balance < -1: if self._get_balance(node.right) > 0: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def _get_balance(self, node): if not node: return 0 return self._height(node.left) - self._height(node.right) def _rotate_left(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._height(z.left), self._height(z.right)) y.height = 1 + max(self._height(y.left), self._height(y.right)) return y def _rotate_right(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._height(z.left), self._height(z.right)) y.height = 1 + max(self._height(y.left), self._height(y.right)) return y def _get_min_value_node(self, node): if node is None or node.left is None: return node return self._get_min_value_node(node.left)"},{"question":"# Question: Implementing a Stack Using Queues Scenario You are tasked with implementing a stack using only queue operations. Recall that a stack follows Last-In-First-Out (LIFO) order, while a queue follows First-In-First-Out (FIFO) order. You can use standard queue operations like enqueue (adding an element to the end of the queue) and dequeue (removing an element from the front of the queue). Task Write a class `MyStack` that simulates the behavior of a stack using queues. Implement the following methods: Requirements * **Class Definition**: ```python class MyStack: def __init__(self): def push(self, x: int) -> None: def pop(self) -> int: def top(self) -> int: def empty(self) -> bool: ``` * **Methods**: - `__init__(self)`: Initializes an empty stack. - `push(self, x: int) -> None`: Push element `x` onto stack. - `pop(self) -> int`: Removes the element on top of the stack and returns that element. - `top(self) -> int`: Returns the element on the top of the stack without removing it. - `empty(self) -> bool`: Returns `True` if the stack is empty, `False` otherwise. Constraints * You must use only queue operations. * Queue operations available: `enqueue` (or `put`), `dequeue` (or `get`), checking if the queue is empty, and getting the queue\'s size. # Example ```python # Example usage: stack = MyStack() stack.push(1) stack.push(2) assert stack.top() == 2 # returns 2 assert stack.pop() == 2 # returns 2 assert not stack.empty() # returns False stack.push(3) assert stack.pop() == 3 # returns 3 assert stack.pop() == 1 # returns 1 assert stack.empty() # returns True ``` Your implementation should simulate the stack\'s LIFO behavior accurately using only the queue operations.","solution":"from collections import deque class MyStack: def __init__(self): self.queue = deque() def push(self, x: int) -> None: self.queue.append(x) # Rotate the queue to make the last pushed element the first element. for _ in range(len(self.queue) - 1): self.queue.append(self.queue.popleft()) def pop(self) -> int: return self.queue.popleft() def top(self) -> int: return self.queue[0] def empty(self) -> bool: return not bool(self.queue) # Example usage: # stack = MyStack() # stack.push(1) # stack.push(2) # assert stack.top() == 2 # returns 2 # assert stack.pop() == 2 # returns 2 # assert not stack.empty() # returns False # stack.push(3) # assert stack.pop() == 3 # returns 3 # assert stack.pop() == 1 # returns 1 # assert stack.empty() # returns True"},{"question":"# Problem Statement You are tasked with simulating the functionalities of an elevator system in a building. The building consists of `n` floors, and the elevator can either move up or down one floor at a time. Given a series of requests from different floors, simulate the movement of the elevator and return the total number of floors traversed. # Function Signature ```python def simulate_elevator(n: int, requests: List[int]) -> int: pass ``` # Parameters - **`n`** (int): The number of floors in the building (1 <= n <= 100). - **`requests`** (List[int]): A list of integers indicating the floors from which requests are made in the order they are received (1 <= requests[i] <= n). # Output - **(int):** Return the total number of floors traversed by the elevator to fulfill all the requests. # Constraints - The elevator initially starts at the ground floor (floor 1). - Assume that each request is always serviced immediately in the order it is received. # Example ```python simulate_elevator(10, [3, 5, 7, 2]) ``` This example should return `9`: 1. Elevator starts at 1, moves to 3 (traverse 2 floors). 2. Moves from 3 to 5 (2 floors). 3. Moves from 5 to 7 (2 floors). 4. Moves from 7 to 2 (5 floors). Total = 2 + 2 + 2 + 5 = 9 floors. # Performance Requirements - The function should efficiently handle up to 100 requests. # Implementation Notes - Keep track of the current position of the elevator. - Efficiently calculate the total floors traversed according to the sequence of requests. - Ensure that the elevator correctly moves one floor at a time and accumulates the floors traversed in the process of fulfilling each request.","solution":"from typing import List def simulate_elevator(n: int, requests: List[int]) -> int: current_floor = 1 total_floors_traversed = 0 for request in requests: total_floors_traversed += abs(request - current_floor) current_floor = request return total_floors_traversed"},{"question":"# Coding Assessment Question Context: In a given list of integers, a \\"special\\" number is defined as a number that appears exactly three times in the list. Problem: Write a function that identifies all \\"special\\" numbers from the input list. The function should return a sorted list of these special numbers in ascending order. Function Signature: ```python def find_special_numbers(numbers: list[int]) -> list[int]: ``` Input: - `numbers`: a list of integers that may contain duplicates. Output: - Returns a list of integers that appear exactly three times in the input list, sorted in ascending order. Requirements: 1. The function must handle edge cases such as an empty list or a list with no numbers appearing exactly three times. 2. The function should handle lists with large sizes and ensure optimal performance. Constraints: - The input list can be empty, which should return an empty list. - All elements in the input list are integers. Example: ```python >>> find_special_numbers([1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5]) [3, 5] >>> find_special_numbers([4, 4, 4, 4, 4, 4, 4]) [] >>> find_special_numbers([6, 6, 6, 7, 7, 7, 8, 8, 8]) [6, 7, 8] >>> find_special_numbers([]) [] ``` Note: Ensure that the function correctly handles edge cases and invalid inputs gracefully. Ashestion is important for understanding and verifying the behavior of the function for different scenarios.","solution":"def find_special_numbers(numbers: list[int]) -> list[int]: Identifies numbers that appear exactly three times in the list, and returns them sorted in ascending order. from collections import Counter # Count the occurrences of each number count = Counter(numbers) # Filter the numbers that appear exactly three times special_numbers = [num for num, cnt in count.items() if cnt == 3] # Return the sorted list of special numbers return sorted(special_numbers)"},{"question":"# Context Given a text file containing multiple lines of strings, your task is to analyze the document to determine the longest word contained within it. This can be useful in scenarios where document analysis and text processing are required, such as plagiarism detection, indexing for search engines, or text summarization. # Problem Implement a program that reads a text file and finds the longest word in the file. If there are multiple words with the maximum length, return the first one encountered. Words are defined as sequences of alphabetic characters only. # Task 1. Implement the function `find_longest_word(filename: str) -> str` that reads a text file and returns the longest word in the file. # Requirements 1. **Function 1**: `find_longest_word` - **Input**: A string `filename` representing the name of the text file. - **Output**: Returns the longest word in the file as a string. - **Constraints**: - You may assume the file exists and contains at least one word. - Words are case-sensitive, i.e., \'Word\' and \'word\' are considered different. - Non-alphabetic characters (e.g., punctuation) are not part of words. # Examples Consider the following content of a file named \\"example.txt\\": ``` Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. ``` - In this file, the longest word is `consectetur`. ```python # Example assert find_longest_word(\\"example.txt\\") == \\"consectetur\\" ``` # Notes - Ensure that you handle the extraction of words correctly by ignoring punctuation and other non-alphabetic characters. - Account for lines with varying lengths and the presence of newline characters.","solution":"import re def find_longest_word(filename: str) -> str: Reads a text file and returns the longest word found in the file. If there are multiple words with the maximum length, returns the first one encountered. Words are sequences of alphabetic characters only. longest_word = \\"\\" with open(filename, \'r\') as file: for line in file: words = re.findall(r\'b[a-zA-Z]+b\', line) for word in words: if len(word) > len(longest_word): longest_word = word return longest_word"},{"question":"# Question: Efficient Breadth-First Search Level Detection Given a graph represented as an adjacency list, implement an algorithm to determine the level (distance from the source node) of each node in a Breadth-First Search (BFS) traversal starting from a given source node. The level of a node is defined as the minimum number of edges that must be traversed to reach that node from the source. You must write a function that performs a BFS and returns a dictionary mapping each node to its BFS level. Function Signature ```python def bfs_levels(graph: dict, source: int) -> dict: @input: - graph (Graph stored as an adjacency list where each vertex is represented as an integer) - source (The starting node for the BFS traversal) @return: A dictionary mapping each vertex to its BFS level # Input * `graph`: A dictionary where each key is a vertex, and each value is a list of adjacent vertices. Each vertex is represented as an integer. * `source`: An integer representing the starting vertex for the BFS traversal. # Output * A dictionary where each key is a vertex and each value is the level of that vertex in the BFS traversal from the source. # Example ```python >>> graph = {0: [1, 2], 1: [0, 3, 4], 2: [0], 3: [1], 4: [1, 5], 5: [4]} >>> source = 0 >>> bfs_levels(graph, source) {0: 0, 1: 1, 2: 1, 3: 2, 4: 2, 5: 3} ``` # Constraints * You can assume the graph will have up to 1000 vertices. * The adjacency list representation guarantees there are no duplicate edges. * Self-loops are not present in the graph. # Notes * Your implementation should handle edge cases such as graphs with no edges, isolated vertices, and non-connected components appropriately. * Ensure your solution is tested on various graph structures (sparse, dense, with isolated vertices). * Focus on the accuracy and efficiency of the BFS algorithm. # Hints * Consider using a queue to implement the BFS traversal. * Initialize the source node with level 0 and visit its adjacent nodes accordingly. * Use an additional dictionary to keep track of visited nodes and their respective levels.","solution":"from collections import deque def bfs_levels(graph: dict, source: int) -> dict: Perform BFS and return the level (distance from the source) of each vertex. Args: - graph: A dictionary where each key is a vertex, and each value is a list of adjacent vertices. - source: The starting vertex for the BFS traversal. Returns: - A dictionary mapping each vertex to its BFS level # Initialize the levels dictionary with the source node at level 0 levels = {source: 0} # Initialize a queue and add the source node queue = deque([source]) # Perform BFS while queue: node = queue.popleft() current_level = levels[node] # Visit each adjacent node for neighbor in graph.get(node, []): if neighbor not in levels: levels[neighbor] = current_level + 1 queue.append(neighbor) return levels"},{"question":"# Problem Statement You are tasked with implementing a scheduling system that detects conflicts between appointments. An appointment is represented by a tuple containing the start time and end time in 24-hour format (e.g., 14:30 for 2:30 PM). Implement a function `detect_conflict(appointments)` that checks whether any two appointments conflict. A conflict occurs if one appointment overlaps with another. # Function Signature ```python def detect_conflict(appointments: List[Tuple[str, str]]) -> bool: pass ``` # Input * `appointments` (List[Tuple[str, str]]): A list of tuples where each tuple contains two strings representing the start and end time of an appointment. # Output * Returns `True` if there is any conflict between appointments, otherwise returns `False`. # Constraints * The start time of each appointment will be strictly less than the end time. * Time is represented in a 24-hour format as \\"HH:MM\\". * The number of appointments will not exceed 100. # Example ```python appointments = [(\\"09:00\\", \\"10:00\\"), (\\"10:30\\", \\"11:30\\"), (\\"10:00\\", \\"11:00\\")] detect_conflict(appointments) == False appointments = [(\\"09:00\\", \\"10:00\\"), (\\"09:30\\", \\"10:30\\"), (\\"10:00\\", \\"11:00\\")] detect_conflict(appointments) == True ``` # Additional Notes Convert the time strings to a comparable format (e.g., the number of minutes from midnight) for easier comparison. # Performance Requirements The solution should be efficient enough to handle the upper constraint of appointment numbers within a reasonable time. # Algorithm 1. Parse the time strings into a comparable numeric format, such as the total number of minutes from midnight. 2. Sort the appointments based on their start times. 3. Check for any overlapping appointments by comparing the start time of the current appointment with the end time of the previous one. 4. Return `True` if a conflict is found, otherwise `False`. # Edge Cases * Handle cases where appointments start or end at the boundary of one another. * Ensure that the algorithm correctly identifies non-overlapping consecutive appointments.","solution":"from typing import List, Tuple def time_to_minutes(time: str) -> int: Convert a time string in HH:MM format to the number of minutes past midnight. hours, minutes = map(int, time.split(\\":\\")) return hours * 60 + minutes def detect_conflict(appointments: List[Tuple[str, str]]) -> bool: Check if any two appointments conflict with each other. :param appointments: A list of tuples with start and end times in \\"HH:MM\\" format. :return: True if there is a conflict, False otherwise. # Convert appointment times to minutes and sort by start time appointments_in_minutes = [(time_to_minutes(start), time_to_minutes(end)) for start, end in appointments] appointments_in_minutes.sort() # Check for conflicts for i in range(1, len(appointments_in_minutes)): previous_end = appointments_in_minutes[i-1][1] current_start = appointments_in_minutes[i][0] if current_start < previous_end: return True return False"},{"question":"Given as input a square grid of dimension ( n times n ) filled with distinct positive integers, write a function `find_peak_element(grid: List[List[int]]) -> Tuple[int, int]` that returns the position (row index, column index) of any peak element in the grid. A peak element is an element that is greater than or equal to its neighbors. # Input: * A 2D list `grid` with dimensions ( n times n ). * ( n ) will be an integer satisfying ( 1 leq n leq 500 ). * All elements in `grid` are distinct positive integers. # Output: * A tuple representing the (row index, column index) of any peak element. # Function Signature: ```python def find_peak_element(grid: List[List[int]]) -> Tuple[int, int]: pass ``` # Example: ```python >>> grid = [ ... [10, 20, 15], ... [21, 30, 14], ... [7, 16, 32] ... ] >>> find_peak_element(grid) (1, 1) >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> find_peak_element(grid) (2, 2) ``` # Note: - A peak element is greater than or equal to its four possible neighbors: left, right, above, and below. - For example, in the first grid: ``` 10 20 15 21 30 14 7 16 32 ``` Element `30` at position (1,1) is greater than all its adjacent neighbors (20, 21, 14, and 16), making it a peak element. - In the second grid: ``` 1 2 3 4 5 6 7 8 9 ``` Element `9` at position (2,2) is greater than its adjacent neighbors (6 and 8), making it a peak element. - Ensure that your solution works efficiently within the provided constraints.","solution":"from typing import List, Tuple def find_peak_element(grid: List[List[int]]) -> Tuple[int, int]: n = len(grid) def get_neighbors_val(row, col): neighbors = [] if row > 0: neighbors.append(grid[row - 1][col]) if row < n - 1: neighbors.append(grid[row + 1][col]) if col > 0: neighbors.append(grid[row][col - 1]) if col < n - 1: neighbors.append(grid[row][col + 1]) return neighbors def is_peak(row, col): current_value = grid[row][col] neighbors_val = get_neighbors_val(row, col) return all(current_value >= v for v in neighbors_val) for i in range(n): for j in range(n): if is_peak(i, j): return (i, j) # Default return statement (should never reach here with distinct positive integers) return (0, 0)"},{"question":"# Problem Statement Write a function `find_duplicate` that, given a list of integers, returns the first duplicate value it encounters. If there are no duplicates, the function should return -1. # Function Signature ```python def find_duplicate(nums: list[int]) -> int: pass ``` # Input * `nums`: A list of integers where 1 <= len(nums) <= 10^5. # Output * The function should return the first duplicate integer it encounters in the list. * If there are no duplicates, return -1. # Constraints * The function should operate with a time complexity of O(n) and space complexity of O(n). # Example ```python assert find_duplicate([1, 3, 4, 2, 5, 3, 7]) == 3 assert find_duplicate([5, 6, 4, 7, 9, 2, 1]) == -1 assert find_duplicate([1, 2, 1, 3, 4, 5]) == 1 assert find_duplicate([7, 9, 4, 7, 2, 4, 8]) == 7 assert find_duplicate([8, 1, 8, 2, 3, 8]) == 8 ``` # Notes * The function should halt and return the first duplicate it encounters, ensuring minimal iterations. * Be cautious of edge cases where the list might be very small or very large, and still handle the detection efficiently.","solution":"def find_duplicate(nums: list[int]) -> int: Returns the first duplicate value in the list. If no duplicates, returns -1. seen = set() for num in nums: if num in seen: return num seen.add(num) return -1"},{"question":"# Coding Assessment Question: Optimized String Matching With Wildcards Objective Implement a function capable of performing string matching with support for single character and multiple character wildcards. Problem Statement You are tasked with writing a function `match_pattern(pattern: str, text: str) -> bool` to determine if the given `pattern` matches the `text`. The `pattern` may contain two special characters: 1. `?` - matches exactly one character. 2. `*` - matches zero or more characters. The function should return `True` if the `pattern` matches the `text`, and `False` otherwise. Requirements * Implement the function `match_pattern(pattern: str, text: str) -> bool` to determine pattern matching. Example ```python def match_pattern(pattern: str, text: str) -> bool: # Your implementation here # Example usage: pattern1 = \\"a*b\\" text1 = \\"aaab\\" # Output: True pattern2 = \\"a?b\\" text2 = \\"acb\\" # Output: True pattern3 = \\"a*b?d\\" text3 = \\"aabcd\\" # Output: True pattern4 = \\"ab?c\\" text4 = \\"abc\\" # Output: False print(match_pattern(pattern1, text1)) # Output: True print(match_pattern(pattern2, text2)) # Output: True print(match_pattern(pattern3, text3)) # Output: True print(match_pattern(pattern4, text4)) # Output: False ``` Constraints * The length of both `pattern` and `text` will be at least 1 and at most (10^4). * Both `pattern` and `text` will consist only of lowercase English letters and the special characters `?` and `*`. Ensure your solution is efficient and takes into consideration edge cases such as multiple consecutive wildcards and very large input strings.","solution":"def match_pattern(pattern: str, text: str) -> bool: Determines if the given pattern matches the text. The pattern can include \'?\' to match any single character and \'*\' to match zero or more characters. # Initialize the DP table m, n = len(pattern), len(text) dp = [[False] * (n + 1) for _ in range(m + 1)] # Base condition: empty pattern matches empty text dp[0][0] = True # Fill the table for cases where pattern starts with \'*\' for i in range(1, m + 1): if pattern[i - 1] == \'*\': dp[i][0] = dp[i - 1][0] # Fill the rest of the table for i in range(1, m + 1): for j in range(1, n + 1): if pattern[i - 1] == \'*\': dp[i][j] = dp[i - 1][j] or dp[i][j - 1] elif pattern[i - 1] == \'?\' or pattern[i - 1] == text[j - 1]: dp[i][j] = dp[i - 1][j - 1] return dp[m][n]"},{"question":"# Scenario You are tasked with developing a utility to automatically clean up old log files in a designated directory. The tool needs to delete files that are older than a specified number of days to free up storage space. Additionally, it should generate a report summarizing the files that were deleted and ones that were skipped. # Task Implement the function `cleanup_logs` that scans the specified directory, deletes files older than a given threshold, and logs the actions taken to a report file. # Function Signature ```python def cleanup_logs(directory_path: str, days_threshold: int, report_file: str) -> None: pass ``` # Input * `directory_path` (str): The path to the directory containing the log files. * `days_threshold` (int): The number of days to use as the threshold for deleting files. Files older than this threshold will be deleted. * `report_file` (str): The path to the file where the report should be written. # Output * None # Constraints * `directory_path` will be a valid directory path. * `report_file` will be a valid file path. * The files in `directory_path` will only contain log files with `.log` extension. * The report should contain the filenames and whether they were deleted or skipped. # Example ```python cleanup_logs(\\"/var/logs\\", 30, \\"/var/reports/cleanup_report.txt\\") ``` # Notes * Use Python\'s standard libraries for file handling and date/time operations. * Ensure the report file contains entries in the format \\"Filename: [deleted/skipped]\\". * Handle possible exceptions (e.g., directory not found, permission issues) gracefully by logging appropriate error messages to the report file. # Report Example ``` system_log_2022-01-01.log: deleted application_log_2022-07-15.log: skipped database_log_2022-05-10.log: deleted ```","solution":"import os import datetime def cleanup_logs(directory_path: str, days_threshold: int, report_file: str) -> None: Scans the specified directory, deletes files older than a given threshold, and logs the actions taken to a report file. :param directory_path: The path to the directory containing the log files. :param days_threshold: The number of days to use as the threshold for deleting files. :param report_file: The path to the file where the report should be written. try: current_time = datetime.datetime.now() threshold_time = current_time - datetime.timedelta(days=days_threshold) with open(report_file, \'w\') as report: for filename in os.listdir(directory_path): file_path = os.path.join(directory_path, filename) if filename.endswith(\'.log\') and os.path.isfile(file_path): # Get the last modified time of the file file_mod_time = datetime.datetime.fromtimestamp(os.path.getmtime(file_path)) if file_mod_time < threshold_time: os.remove(file_path) report.write(f\\"{filename}: deletedn\\") else: report.write(f\\"{filename}: skippedn\\") except Exception as e: with open(report_file, \'a\') as report: report.write(f\\"Error: {str(e)}n\\")"},{"question":"# Coding Assessment Question: Inventory Management System with Command Processor You are working on a simple inventory management system where items can be added to, removed from, and queried within the inventory. The system will receive a series of commands, and you need to implement a function to process these commands and manage the inventory accordingly. Your task is to implement a function that processes the following commands: 1. \\"ADD <item_name> <quantity>\\": Adds the given quantity of the specified item to the inventory. If the item already exists, increment its quantity. 2. \\"REMOVE <item_name> <quantity>\\": Removes the given quantity of the specified item from the inventory. If the item does not exist or if the removal quantity is greater than the existing quantity, do nothing. 3. \\"CHECK <item_name>\\": Returns the current quantity of the specified item. If the item does not exist, return 0. **Function Specification** ```python def process_commands(commands: List[str]) -> List[int]: Process a list of commands to manage inventory and return results for \'CHECK\' commands. Parameters: commands (List[str]): List of commands to be processed. Returns: List[int]: A list of results for each \'CHECK\' command in the order they appear. ``` # Input - A list of strings `commands`, where each string is a command in the format mentioned above. # Output - A list of integers, where each integer is the result of a \\"CHECK\\" command in the order they appear. # Example ```python commands = [ \\"ADD apple 10\\", \\"ADD orange 5\\", \\"REMOVE apple 3\\", \\"CHECK apple\\", \\"CHECK orange\\", \\"REMOVE apple 20\\", \\"CHECK apple\\" ] print(process_commands(commands)) # Output: [7, 5, 7] ``` # Notes - The item names and quantities will follow the constraints of only containing alphanumeric characters and whitespace will not be considered within item names. - Ensure the function can handle a sequence of commands, including edge cases where quantities might be zero or negative. # Constraints - Each command string will be valid and correctly formatted. - Handle all possible command sequences efficiently.","solution":"from typing import List def process_commands(commands: List[str]) -> List[int]: inventory = {} results = [] for command in commands: parts = command.split() action = parts[0] item = parts[1] if action == \\"ADD\\": quantity = int(parts[2]) if item in inventory: inventory[item] += quantity else: inventory[item] = quantity elif action == \\"REMOVE\\": quantity = int(parts[2]) if item in inventory and inventory[item] >= quantity: inventory[item] -= quantity if inventory[item] == 0: del inventory[item] elif action == \\"CHECK\\": results.append(inventory.get(item, 0)) return results"},{"question":"# **Design a Simple Calculator with Basic Operators** You are required to implement a simple calculator that supports basic arithmetic operations. The calculator should be able to handle addition, subtraction, multiplication, and division. The input will be provided in the form of a string expression representing a basic arithmetic calculation. Function Specifications: - **Function Name**: `simple_calculator` - **Input**: A string `expression` containing a basic arithmetic expression (e.g., `\\"3 + 5\\"`, `\\"10 / 2\\"`, `\\"8 * 3\\"`, `\\"9 - 4\\"`). - **Output**: The result of the arithmetic operation as a float. Constraints: * The input string will be a valid arithmetic expression containing two operands and one operator. * The operands will be floating-point numbers or integers. * The operator will be one of `+`, `-`, `*`, or `/`. * Division by zero should return a warning message, \\"Division by zero is undefined.\\" Performance Requirements: * The function should handle basic operations efficiently. Example: ```python assert simple_calculator(\\"3 + 5\\") == 8.0 assert simple_calculator(\\"10 / 2\\") == 5.0 assert simple_calculator(\\"8 * 3\\") == 24.0 assert simple_calculator(\\"9 - 4\\") == 5.0 assert simple_calculator(\\"7 / 0\\") == \\"Division by zero is undefined\\" ``` # Additional Challenge: Ensure the function can handle various whitespace insertion formats such as `\\" 3+5 \\"`, `\\" 10 / 2 \\"`, and `\\" 8* 3 \\"` without affecting the correct evaluation of the expression. # Hint: Consider utilizing Python\'s string manipulation capabilities to parse the expression, and ensure arithmetic operations are correctly evaluated based on the operator provided.","solution":"def simple_calculator(expression): Evaluates a basic arithmetic expression given as a string. Supported operators are: +, -, *, and /. Parameters: expression (str): A string containing the arithmetic expression. Returns: float: The result of the arithmetic operation. str: A warning message if the operation is invalid (e.g., division by zero). # Remove all whitespace from the expression expression = expression.replace(\\" \\", \\"\\") # Determine the operator and split the expression into operands if \'+\' in expression: operands = expression.split(\'+\') operator = \'+\' elif \'-\' in expression: operands = expression.split(\'-\') operator = \'-\' elif \'*\' in expression: operands = expression.split(\'*\') operator = \'*\' elif \'/\' in expression: operands = expression.split(\'/\') operator = \'/\' else: return \\"Invalid expression\\" operand1, operand2 = map(float, operands) # Perform the arithmetic operation if operator == \'+\': return operand1 + operand2 elif operator == \'-\': return operand1 - operand2 elif operator == \'*\': return operand1 * operand2 elif operator == \'/\': if operand2 == 0: return \\"Division by zero is undefined\\" return operand1 / operand2"},{"question":"# Coding Assessment Question Prerequisites: Understanding of linked lists, list manipulation, and algorithm design. Problem Statement: Implement a function `merge_alternating_lists(list1: List[int], list2: List[int]) -> List[int]` that merges two lists by alternating elements from each list. Function Signature: ```python def merge_alternating_lists(list1: List[int], list2: List[int]) -> List[int]: pass ``` Input: - `list1` and `list2`: two lists of integers. (0 ≤ len(list1), len(list2) ≤ 10^6) Output: - A new list representing the merged list by alternating elements from `list1` and `list2`. If one list runs out of elements, append the remaining elements from the other list. Requirements: 1. **Efficiency**: Your implementation should have linear time complexity O(n). 2. **Space Optimization**: Aim for a clear and logical structure without unnecessary memory usage. Constraints: - Handle invalid inputs by raising appropriate Python exceptions: - If either `list1` or `list2` is not a list of integers, raise a `TypeError`. Examples: ```python assert merge_alternating_lists([1, 2, 3], [4, 5, 6]) == [1, 4, 2, 5, 3, 6] assert merge_alternating_lists([1], [4, 5, 6]) == [1, 4, 5, 6] assert merge_alternating_lists([1, 2, 3], []) == [1, 2, 3] assert merge_alternating_lists([], [4, 5, 6]) == [4, 5, 6] assert merge_alternating_lists([], []) == [] ``` Note: - Ensure to include edge-case testing. - Optimize both for readability and performance. - Unit tests are highly recommended.","solution":"from typing import List def merge_alternating_lists(list1: List[int], list2: List[int]) -> List[int]: Merges two lists by alternating elements from each list. if not isinstance(list1, list) or not isinstance(list2, list): raise TypeError(\\"Both arguments must be lists\\") if not all(isinstance(i, int) for i in list1) or not all(isinstance(i, int) for i in list2): raise TypeError(\\"All elements in the lists must be integers\\") merged_list = [] i = 0 while i < len(list1) or i < len(list2): if i < len(list1): merged_list.append(list1[i]) if i < len(list2): merged_list.append(list2[i]) i += 1 return merged_list"},{"question":"# R-Tree Implementation and Intersection Search You are to implement an R-Tree, which is a tree data structure used for spatial access methods, i.e., for indexing multi-dimensional information. Task 1: R-Tree Construction Write a function, `build_rtree(rectangles: list[list[float]], M: int) -> RTreeNode | None`, that constructs an R-Tree from a list of MBRs (minimum bounding rectangles). Each rectangle is represented by a list of four floating-point numbers `[x_min, y_min, x_max, y_max]`. Task 2: Intersection Search Additionally, implement a function, `search_intersections(root: RTreeNode, search_rect: list[float]) -> list[list[float]]`, that finds and returns all rectangles from the R-Tree that intersect with a given search rectangle. Input: 1. A list of `n` MBRs, `rectangles: list[list[float]]`, each represents a rectangle in 2D space. 2. A search rectangle, `search_rect: list[float]`, which also is in the format `[x_min, y_min, x_max, y_max]`. Output: 1. Return a list of MBRs that intersect with the `search_rect`. Example: ```python # Given rectangles rectangles = [ [1, 1, 3, 3], [2, 2, 5, 5], [8, 8, 9, 9], [6, 6, 7, 8] ] # Search rectangle search_rect = [2, 2, 4, 4] # Maximum number of entries per node M = 4 # Construct the R-Tree root = build_rtree(rectangles, M) # Find intersecting rectangles intersections = search_intersections(root, search_rect) # Output: List of intersecting rectangles, e.g., [[1, 1, 3, 3], [2, 2, 5, 5]] ``` Constraints: - The number of rectangles `n` and maximum entries `M` will be such that `1 ≤ n ≤ 1000` and `2 ≤ M ≤ 10`. Performance Requirements: - Aim for time complexity of `O(n log n)` for tree construction. - Aim for efficient intersection querying with expected performance of `O(log n + k)` where `k` is the number of intersecting rectangles.","solution":"class RTreeNode: def __init__(self, mbrs=None, children=None, is_leaf=True): self.mbrs = mbrs if mbrs else [] self.children = children if children else [] self.is_leaf = is_leaf def build_rtree(rectangles, M): if not rectangles: return None return _build_rtree_recursive(rectangles, M) def _build_rtree_recursive(rectangles, M): if len(rectangles) <= M: return RTreeNode(mbrs=rectangles, is_leaf=True) rectangles.sort(key=lambda r: r[0]) # Sort by x_min num_splits = (len(rectangles) + M - 1) // M child_nodes = [] for i in range(num_splits): sub_rects = rectangles[i * M:(i + 1) * M] child_nodes.append(_build_rtree_recursive(sub_rects, M)) non_leaf_mbrs = [get_mbr(child.mbrs) for child in child_nodes] return RTreeNode(mbrs=non_leaf_mbrs, children=child_nodes, is_leaf=False) def get_mbr(rectangles): x_min = min(r[0] for r in rectangles) y_min = min(r[1] for r in rectangles) x_max = max(r[2] for r in rectangles) y_max = max(r[3] for r in rectangles) return [x_min, y_min, x_max, y_max] def search_intersections(root, search_rect): if not root: return [] return _search_intersections_recursive(root, search_rect) def _search_intersections_recursive(node, search_rect): intersecting_rects = [] if node.is_leaf: for rect in node.mbrs: if _intersects(rect, search_rect): intersecting_rects.append(rect) else: for idx, rect in enumerate(node.mbrs): if _intersects(rect, search_rect): intersecting_rects.extend(_search_intersections_recursive(node.children[idx], search_rect)) return intersecting_rects def _intersects(rect1, rect2): return not (rect1[2] < rect2[0] or rect1[0] > rect2[2] or rect1[3] < rect2[1] or rect1[1] > rect2[3])"},{"question":"# Scenario In an analytics application, you are required to compute the weighted average of a list of numbers. The weighted average takes into account both the value of each number and its associated weight. Your goal is to create a function that calculates the weighted average for a given list of numbers and their corresponding weights. # Function to Implement Write a function `weighted_average`: Input - `values` (list[float]): A list of numbers. - `weights` (list[float]): A list of weights corresponding to the numbers in `values`. Output - (float): The weighted average of the numbers. Constraints 1. Both `values` and `weights` must have the same length. 2. All weights must be non-negative numbers. 3. Raise a `ValueError` if the length of `values` and `weights` do not match. 4. Raise a `ValueError` if any weight is negative. 5. Raise a `ValueError` if both the `values` and `weights` lists are empty. # Example ```python >>> weighted_average([1.0, 2.0, 3.0], [0.1, 0.3, 0.6]) 2.5 >>> weighted_average([10, 20], [0.4, 0.6]) 16.0 >>> weighted_average([], []) Traceback (most recent call last): ... ValueError: The lists \'values\' and \'weights\' must not be empty. >>> weighted_average([1, 2], [1]) Traceback (most recent call last): ... ValueError: The lists \'values\' and \'weights\' must be of the same length. >>> weighted_average([1, 2, 3], [1, -1, 1]) Traceback (most recent call last): ... ValueError: All weights must be non-negative. ``` You need to ensure that your code is efficient and clear. Carefully handle all constraints and validate input data properly to provide a robust implementation.","solution":"def weighted_average(values, weights): Returns the weighted average of a list of numbers given their weights. :param values: list of float, the numbers. :param weights: list of float, the weights corresponding to each number. :return: float, the weighted average. if len(values) != len(weights): raise ValueError(\\"The lists \'values\' and \'weights\' must be of the same length.\\") if not values: raise ValueError(\\"The lists \'values\' and \'weights\' must not be empty.\\") if any(w < 0 for w in weights): raise ValueError(\\"All weights must be non-negative.\\") weighted_sum = sum(v * w for v, w in zip(values, weights)) total_weight = sum(weights) if total_weight == 0: return 0 # To handle the case where all weights are zero, the weighted average is defined as zero. return weighted_sum / total_weight"},{"question":"# Question **Context**: As a software engineer at a financial technology company, you are tasked with developing a system for detecting anomalies in user behavior. One common anomaly detection method involves finding unusual sequences of events. In this problem, you need to identify the longest sequence of increasing operations based on their timestamps. **Task**: Implement a function to find the longest increasing subsequence of operation timestamps given a list of timestamps for various user operations. **Function Signature**: ```python def longest_increasing_subsequence(timestamps: list[int]) -> int: Args: - timestamps: A list of integer timestamps representing the times at which operations occurred. Returns: - An integer representing the length of the longest increasing subsequence of timestamps. ``` **Requirements**: 1. Implement the function `longest_increasing_subsequence` that takes in: * `timestamps`: A list of integers representing operation timestamps. 2. The function should return an integer representing the length of the longest increasing subsequence of timestamps. **Examples**: ```python >>> timestamps = [1, 2, 3, 2, 5, 4, 6] >>> longest_increasing_subsequence(timestamps) 5 >>> timestamps = [5, 1, 2, 3, 1, 6, 7, 2, 8] >>> longest_increasing_subsequence(timestamps) 6 ``` **Constraints**: * The length of the timestamps list can be up to (10^5). * Each timestamp is represented as an integer and is unique within the context of this problem. Good luck, and happy coding!","solution":"def longest_increasing_subsequence(timestamps: list[int]) -> int: Returns the length of the longest increasing subsequence from the given list of timestamps. Args: - timestamps: A list of integer timestamps representing the times at which operations occurred. Returns: - An integer representing the length of the longest increasing subsequence of timestamps. if not timestamps: return 0 n = len(timestamps) dp = [1] * n # dp[i] will store the length of LIS ending at index i for i in range(1, n): for j in range(i): if timestamps[i] > timestamps[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"# Question: Implement a File Content Sorting Utility Context: You have been assigned to create a utility tool that reads multiple text files, extracts their contents, and sorts the content lines alphabetically. The current implementation can handle only one file at a time, but now you need to extend the functionality for batch processing multiple files concurrently. Requirements: 1. **Batch Processing**: Extend the utility to accept a list of file paths and process all files concurrently. 2. **Concurrency**: Use threading or asynchronous programming capabilities to read and sort multiple files efficiently. 3. **Improved Error Handling**: Enhance error handling to manage partial failures (e.g., file not found) gracefully and provide a summary of failed and successful operations. Main Function Specification: ```python def sort_files_contents(file_paths: List[str]) -> Dict[str, Union[str, List[str]]]: Given a list of file paths, read and sort each file\'s content lines alphabetically. Parameters: file_paths (List[str]): List of file paths to read and sort. Returns: Dict[str, Union[str, List[str]]]: A dictionary where each key is the file path and the value is the sorted content lines or an error message if the file could not be processed. pass ``` * **Input**: A list of file paths. * **Output**: A dictionary mapping each file path to its sorted content lines or an appropriate error message. Constraints: - The function should handle up to 50 file paths in one call efficiently. - Gracefully handle any I/O errors (e.g., file not found) and return corresponding error messages for failed file operations. - The content lines within each file should be sorted alphabetically and the operation should be performed concurrently for all files to minimize total execution time. * **Example**: ```python input_files = [\\"file1.txt\\", \\"file2.txt\\"] # Suppose file1.txt contains [\'banana\', \'apple\', \'cherry\'] # and file2.txt contains [\'dog\', \'elephant\', \'cat\'] expected_output = { \\"file1.txt\\": [\'apple\', \'banana\', \'cherry\'], \\"file2.txt\\": [\'cat\', \'dog\', \'elephant\'], \\"non_existent_file.txt\\": \\"Error: File not found\\" } assert sort_files_contents(input_files + [\\"non_existent_file.txt\\"]) == expected_output ``` Performance Requirements: - Ensure the function can process the maximum number of files within a reasonable time limit (e.g., < 10 seconds). Note: Provide a well-documented and tested solution demonstrating your understanding of concurrency, error handling, file I/O, and sorting in Python.","solution":"from typing import List, Dict, Union import concurrent.futures import os def read_and_sort_file(file_path: str) -> Union[str, List[str]]: Reads and sorts the contents of a file. Parameters: file_path (str): Path to the file. Returns: Union[str, List[str]]: Sorted content lines of the file or an error message if the file could not be processed. if not os.path.exists(file_path): return f\\"Error: File not found ({file_path})\\" try: with open(file_path, \'r\') as file: content = file.readlines() content = [line.strip() for line in content] content.sort() return content except Exception as e: return f\\"Error: {str(e)} ({file_path})\\" def sort_files_contents(file_paths: List[str]) -> Dict[str, Union[str, List[str]]]: Given a list of file paths, read and sort each file\'s content lines alphabetically. Parameters: file_paths (List[str]): List of file paths to read and sort. Returns: Dict[str, Union[str, List[str]]]: A dictionary where each key is the file path and the value is the sorted content lines or an error message if the file could not be processed. results = {} with concurrent.futures.ThreadPoolExecutor() as executor: future_to_file_path = {executor.submit(read_and_sort_file, path): path for path in file_paths} for future in concurrent.futures.as_completed(future_to_file_path): file_path = future_to_file_path[future] try: result = future.result() results[file_path] = result except Exception as e: results[file_path] = f\\"Error: {str(e)} ({file_path})\\" return results"},{"question":"# Problem Statement You are developing a utility for a spreadsheet application, and one of the core functionalities required is to compute the transpose of a given matrix. The transpose of a matrix is achieved by flipping the matrix over its diagonal, i.e., switching the row and column indices of its elements. Your task is to implement a function that computes the transpose of an input matrix. # Requirements Implement a function `transpose_matrix` that takes a list of lists (representing a matrix) and returns a new list of lists representing its transpose. Function Signature: ```python def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: pass ``` Input: * `matrix` (List[List[int]]): A 2-dimensional list where each sub-list is a row in the matrix. All sub-lists (rows) are of the same length. Output: * `transposed_matrix` (List[List[int]]): A 2-dimensional list where each sub-list is a column in the original matrix. # Constraints: * The input matrix can be of any rectangular size with dimensions m (rows) by n (columns), where 1 <= m, n <= 1000. * Each element in the matrix is an integer in the range -10^9 to 10^9. # Examples: ```python >>> transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> transpose_matrix([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] >>> transpose_matrix([[7]]) [[7]] ``` # Hints: 1. Use nested list comprehensions to construct the transposed matrix efficiently. 2. Consider leveraging Python\'s built-in functions and libraries to optimize the operation.","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Returns the transpose of the given matrix. :param matrix: List of lists representing the original matrix. :return: List of lists representing the transposed matrix. return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]"},{"question":"# Maximum Subarray Sum with Fixed Size Given an integer array `nums` and an integer `k`, implement the function `max_subarray_sum_fixed_size(nums: List[int], k: int) -> int` which computes the maximum sum of a subarray with a fixed size `k`. Input: * An integer array `nums` of length `n` (1 ≤ n ≤ 10^5), where -10^4 ≤ nums[i] ≤ 10^4. * An integer `k` (1 ≤ k ≤ n). Output: * An integer representing the maximum sum of any subarray of size `k`. Constraints: * The solution must run in O(n) time complexity, where `n` is the length of the input array. Example: ```python assert max_subarray_sum_fixed_size([1, -2, 3, 4, -1, 2, 1, -5, 4], 3) == 6 assert max_subarray_sum_fixed_size([1, 2, 3, 4, -10], 4) == 10 assert max_subarray_sum_fixed_size([5, -3, 5, 1], 2) == 6 ``` # Implementation: 1. Begin by calculating the sum of the first `k` elements. This is your initial window sum. 2. Iterate through the array by shifting the window one element to the right at a time. 3. For each new window, update the sum by subtracting the element that falls out of the window and adding the new element that enters the window. 4. Track the maximum window sum encountered during the iterations. 5. Return the maximum window sum as the result.","solution":"from typing import List def max_subarray_sum_fixed_size(nums: List[int], k: int) -> int: Computes the maximum sum of any subarray with a fixed size k. if not nums or k <= 0 or k > len(nums): raise ValueError(\\"Invalid input\\") # Calculate the sum of the first k elements window_sum = sum(nums[:k]) max_sum = window_sum # Slide the window over the array for i in range(k, len(nums)): window_sum += nums[i] - nums[i - k] max_sum = max(max_sum, window_sum) return max_sum"},{"question":"# Merging Two Sorted Linked Lists **Objective**: Write a Python function to merge two sorted linked lists into one sorted linked list. **Function Signature**: ```python def merge_sorted_lists(l1: ListNode | None, l2: ListNode | None) -> ListNode | None: ``` Input: 1. **`l1`** (ListNode | None): The head of the first sorted linked list. 2. **`l2`** (ListNode | None): The head of the second sorted linked list. Output: The head of a new linked list that contains all the elements from `l1` and `l2` in sorted order. Constraints: 1. Both linked lists are sorted in non-decreasing order. 2. The linked lists may include negative and positive numbers. 3. The linked lists can be empty (i.e., `l1` or `l2` can be `None`). Example Scenarios: Here are some example scenarios to illustrate the expected outputs: 1. **Example 1:** * Input: `l1 = [1, 3, 5]`, `l2 = [2, 4, 6]` * Output: `[1, 2, 3, 4, 5, 6]` 2. **Example 2:** * Input: `l1 = []`, `l2 = [1, 2, 3]` * Output: `[1, 2, 3]` 3. **Example 3:** * Input: `l1 = [1, 2, 3]`, `l2 = []` * Output: `[1, 2, 3]` 4. **Example 4:** * Input: `l1 = [-10, -3, 0, 1]`, `l2 = [-5, 3, 7]` * Output: `[-10, -5, -3, 0, 1, 3, 7]` Additional Requirements: 1. Your implementation should maintain the non-decreasing order of elements. 2. Please include sufficient tests to validate your implementation, covering both typical and edge cases. Use the given structure for the ListNode class: ```python @dataclass class ListNode: val: int next: ListNode | None = None ```","solution":"from typing import Optional, Union from dataclasses import dataclass @dataclass class ListNode: val: int next: Optional[\'ListNode\'] = None def merge_sorted_lists(l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]: if not l1: return l2 if not l2: return l1 dummy = ListNode(0) current = dummy while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next current.next = l1 if l1 else l2 return dummy.next"},{"question":"# Problem Statement You are working on generating data insights and need to preprocess some data for effective analytics. One of the tasks involves summarizing the sequence of events in a log by grouping sequential entries with the same event type and keeping a count of occurrences in that block. You are provided with a function `summarize_events` which should perform this task. Your task is to write this function that processes a list of event types and converts it into a summary format showing the event type and the count of its consecutive occurrences. # Function Signature ```python def summarize_events(event_list: List[str]) -> List[Tuple[str, int]]: This function summarizes consecutive similar events in a log list. Args: event_list: List of strings, where each string represents an event type. Returns: List of tuples, where each tuple contains: - A string representing the event type. - An integer representing the count of consecutive occurrences of that event type. ``` # Expected Input and Output - **Input**: - A list of strings where each string represents an event type. - **Output**: - A list of tuples, where each tuple contains a string representing the event type and an integer representing the count of consecutive occurrences of that event type. # Example ```python event_list = [\\"login\\", \\"login\\", \\"click\\", \\"click\\", \\"click\\", \\"logout\\", \\"login\\", \\"click\\"] result = summarize_events(event_list) print(result) # [(\'login\', 2), (\'click\', 3), (\'logout\', 1), (\'login\', 1), (\'click\', 1)] ``` # Constraints * The list will have at least one event. * The events are case-sensitive, meaning \\"login\\" and \\"Login\\" are considered different events. * Consecutive occurrences are counted only for adjacent events in the list. # Evaluation * **Correctness**: Ensure that your function correctly summaries the event list with accurate counts of consecutive similar events. * **Efficiency**: Your implementation should be efficient in terms of both time and space complexity.","solution":"from typing import List, Tuple def summarize_events(event_list: List[str]) -> List[Tuple[str, int]]: if not event_list: # Check if the event list is empty return [] summary = [] current_event = event_list[0] count = 1 for event in event_list[1:]: if event == current_event: count += 1 else: summary.append((current_event, count)) current_event = event count = 1 summary.append((current_event, count)) return summary"},{"question":"# Problem Statement Write a function that determines if a given number is a prime number and also finds the next prime number greater than the given number. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. Create a function `next_prime_info(n: int) -> (bool, int)` where `n` is the given number. # Function Signature ```python def next_prime_info(n: int) -> (bool, int): pass ``` # Input - An integer `n` where `1 <= n <= 10^6` # Output - A tuple containing two elements: 1. A boolean value indicating whether the given number `n` is a prime number. 2. The next prime number greater than `n`. # Constraints - You need to optimize the function to handle large values of `n` efficiently. - Utilize efficient algorithms for prime-checking and finding the next prime number. # Performance Requirements - The solution should be optimized to handle inputs close to the upper limit within a reasonable time frame. # Example ```python >>> next_prime_info(10) (False, 11) >>> next_prime_info(29) (True, 31) >>> next_prime_info(1000000) (False, 1000003) ``` # Notes - Remember to consider edge cases such as `n` being a very large non-prime number close to `10^6`. - Focus on both time complexity (O(sqrt(n)) for prime-checking) and space efficiency.","solution":"from math import isqrt def is_prime(num): Returns True if num is a prime number, otherwise False. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def next_prime(num): Returns the next prime number greater than num. prime_candidate = num + 1 while not is_prime(prime_candidate): prime_candidate += 1 return prime_candidate def next_prime_info(n: int) -> (bool, int): Determines if n is a prime number and finds the next prime number greater than n. :param n: An integer :return: A tuple (is_n_prime, next_prime_greater_than_n) is_n_prime = is_prime(n) next_prime_number = next_prime(n) return is_n_prime, next_prime_number"},{"question":"# Graph Depth Calculation **Objective:** You are tasked with determining the depth of a graph\'s longest path using Depth-First Search (DFS). The depth of a graph is defined as the maximum length of a path between any two nodes, where the length is the number of edges in the path. **Function Signature:** ```python def graph_depth(graph: dict[str, list[str]]) -> int: # Your implementation here ``` **Input:** - `graph`: A dictionary where each key is a string representing a node, and the corresponding value is a list of strings representing the adjacent nodes (neighbors). **Output:** - Returns an integer representing the depth of the graph. **Constraints:** 1. The graph is connected, meaning there is a path between any two nodes. 2. The graph can have cycles. 3. The number of nodes (keys in the dictionary) will not exceed 100. **Performance Requirements:** - Your solution should efficiently explore all paths and compute the maximum depth. **Instructions:** 1. Implement the DFS algorithm to traverse the graph. 2. Keep track of the visited nodes to avoid infinite loops in case of cycles. 3. Ensure your implementation is able to handle edge cases such as small graphs or graphs with nodes having no outgoing edges (leaf nodes). # Example Given the following configuration: Graph: ```python { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"D\\", \\"E\\"], \\"C\\": [\\"F\\"], \\"D\\": [], \\"E\\": [\\"F\\"], \\"F\\": [\\"G\\"], \\"G\\": [] } ``` **Returns:** 4 Explanation: The longest path is from \\"A\\" -> \\"C\\" -> \\"F\\" -> \\"G\\". Implement the above function in Python and thoroughly test your solution. *Note: You can use additional helper functions if needed to structure your DFS implementation effectively.*","solution":"def graph_depth(graph): def dfs(node, visited): visited.add(node) max_depth = 0 for neighbor in graph[node]: if neighbor not in visited: depth = dfs(neighbor, visited) + 1 max_depth = max(max_depth, depth) visited.remove(node) return max_depth max_depth_overall = 0 for node in graph: max_depth_overall = max(max_depth_overall, dfs(node, set())) return max_depth_overall"},{"question":"# Problem Scenario As a data engineer, you are tasked to design an algorithm to efficiently find and return the most frequently occurring element in a large list of integers. If there are multiple elements with the same highest frequency, return any one of them. # Task Implement the `find_most_frequent` function in Python that identifies and returns the most frequently occurring element in a list of integers. # Function Signature ```python def find_most_frequent(numbers: List[int]) -> int: ... ``` # Constraints * `numbers` (List[int]): A non-empty list of integers where all elements are within the range ([-10^6, 10^6]). * The length of the list (|numbers|) is at most (10^6). # Input * `numbers`: A list of integers, which may or may not contain repeated values. # Output * An integer representing the most frequently occurring element in the list. # Example ```python print(find_most_frequent([1, 3, 1, 3, 2, 1])) # Output: 1 print(find_most_frequent([3, 3, 1, 3, 2, 2, 1])) # Output: 3 ``` # Note * If multiple elements have the same highest frequency, return any one of them. * Ensure input validation is performed to catch and handle invalid input scenarios. * Optimize the performance to handle large input sizes efficiently. # Additional Information Consider edge cases: - All elements in the list are unique. - The list contains only one element. - The list contains both negative and positive integers.","solution":"from typing import List from collections import Counter def find_most_frequent(numbers: List[int]) -> int: Returns the most frequently occurring element in the list. # Using Counter to count frequencies of elements in the list frequency_counter = Counter(numbers) # Finding the item with the maximum frequency most_frequent = frequency_counter.most_common(1)[0][0] return most_frequent"},{"question":"**Problem Statement: Word Ladder Path** You are given two words, `beginWord` and `endWord`, and a dictionary of words called `wordList`. Your task is to find the shortest transformation sequence from `beginWord` to `endWord`, such that: 1. Only one letter can be changed at a time. 2. Each intermediate word must exist in the `wordList`. Return the length of the shortest transformation sequence. If no such sequence exists, return 0. # Example: **Input:** - `beginWord = \\"hit\\"` - `endWord = \\"cog\\"` - `wordList = [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"]` **Output:** 5 (The shortest transformation sequence is `\\"hit\\" -> \\"hot\\" -> \\"dot\\" -> \\"dog\\" -> \\"cog\\"`, which is 5 words long.) # Detailed Steps: 1. **Initialization**: * Use a queue to perform breadth-first search (BFS) starting from the `beginWord`. * Use a set to keep track of visited words to prevent cycles. 2. **Transformation**: * For the current word, change each letter to every possible letter from \'a\' to \'z\'. * Check if the transformed word is in the `wordList` and hasn’t been visited. 3. **Process**: * Add the transformed valid word to the queue and mark it as visited. * Repeat the process until the `endWord` is found or the queue is empty. 4. **Result**: * Return the number of transformations (the length of the shortest path) if `endWord` is reached; otherwise, return 0. # Constraints: - All input strings are of lowercase letters and have the same length. - There are no duplicate words in the `wordList`. - The `beginWord` is not in the `wordList`. # Function Signature: ```python def word_ladder_length(beginWord: str, endWord: str, wordList: list) -> int: Find the length of the shortest transformation sequence from beginWord to endWord. :param beginWord: A string representing the starting word. :param endWord: A string representing the target word. :param wordList: A list of strings representing the dictionary of words. :return: An integer representing the length of the shortest transformation sequence. ``` # Input: - `beginWord`: A string representing the starting word. - `endWord`: A string representing the target word. - `wordList`: A list of strings representing the dictionary of words. # Output: - An integer representing the length of the shortest transformation sequence. # Example: **Input:** ```python beginWord = \\"hit\\" endWord = \\"cog\\" wordList = [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"] ``` **Output:** ```python 5 ``` # Implementation: Implement the `word_ladder_length` function using the provided guidelines. ```python from collections import deque def word_ladder_length(beginWord: str, endWord: str, wordList: list) -> int: if endWord not in wordList: return 0 wordSet = set(wordList) queue = deque([(beginWord, 1)]) # (current word, current length) visited = set() while queue: current_word, length = queue.popleft() if current_word == endWord: return length for i in range(len(current_word)): for c in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + c + current_word[i+1:] if next_word in wordSet and next_word not in visited: visited.add(next_word) queue.append((next_word, length + 1)) return 0 ```","solution":"from collections import deque def word_ladder_length(beginWord: str, endWord: str, wordList: list) -> int: if endWord not in wordList: return 0 wordSet = set(wordList) queue = deque([(beginWord, 1)]) # (current word, current length) visited = set([beginWord]) while queue: current_word, length = queue.popleft() if current_word == endWord: return length for i in range(len(current_word)): for c in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + c + current_word[i+1:] if next_word in wordSet and next_word not in visited: visited.add(next_word) queue.append((next_word, length + 1)) return 0"},{"question":"# Context You are developing a search algorithm to find the shortest path in a grid using Breadth-First Search (BFS). BFS is an algorithm for traversing or searching tree or graph data structures and is known for its simplicity and efficiency in unweighted grids. # Problem Statement Implement a function `shortest_path_in_grid` that determines the shortest path length from a given start position to a given end position in a grid where `0` represents a walkable cell and `1` represents a blocked cell that cannot be traversed. # Requirements 1. **Function Signature**: ```python def shortest_path_in_grid( grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int], ) -> int: ``` 2. **Input**: - `grid` (List of Lists of ints): A 2D grid where `0` represents a walkable cell and `1` represents a blocked cell. - `start` (Tuple of ints): The starting cell coordinates (row, column), assumed to always be a walkable cell. - `end` (Tuple of ints): The target cell coordinates (row, column), assumed to always be a walkable cell. 3. **Output**: - Returns an integer representing the length of the shortest path from the start cell to the end cell. - If no path exists, return `-1`. 4. **Constraints**: - Each cell in the grid can be either `0` or `1`. - The grid will have at least one cell and at most 1000 x 1000 cells. - The start and end cells will be different. - Movements are allowed up, down, left, or right, but not diagonally. 5. **Error Handling**: - Raise `ValueError` with an appropriate message if any input constraints are not met, such as invalid grid dimensions or coordinates outside the grid. # Examples ```python >>> grid = [ ... [0, 1, 0, 0, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 1, 0], ... [0, 1, 1, 1, 0], ... [0, 0, 0, 0, 0], ... ] >>> start = (0, 0) >>> end = (4, 4) >>> shortest_path_in_grid(grid, start, end) 8 >>> grid = [ ... [0, 1, 0], ... [1, 1, 0], ... [0, 0, 0], ... ] >>> start = (0, 0) >>> end = (2, 2) >>> shortest_path_in_grid(grid, start, end) 4 >>> grid = [ ... [0, 1], ... [1, 1], ... ] >>> start = (0, 0) >>> end = (1, 1) >>> shortest_path_in_grid(grid, start, end) -1 >>> grid = [ ... [0, 0, 0, 0], ... [1, 1, 1, 0], ... [0, 0, 0, 0], ... ] >>> start = (-1, 0) >>> end = (2, 3) >>> shortest_path_in_grid(grid, start, end) Traceback (most recent call last): ... ValueError: Start and end positions must be within the grid boundaries >>> grid = [ ... [0, 0, 0, 0], ... [1, 1, 1, 0], ... [0, 0, 0, 0], ... ] >>> start = (0, 0) >>> end = (2, 3) >>> shortest_path_in_grid(grid, start, end) Traceback (most recent call last): ... ValueError: Start and end positions must be different ``` # Notes - Ensure the implementation efficiently handles the BFS traversal and correctly determines the path length. - Utilize appropriate data structures, such as queues, to manage the BFS algorithm. - Validates the input constraints appropriately before processing the algorithm.","solution":"from typing import List, Tuple from collections import deque def shortest_path_in_grid( grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int], ) -> int: Determines the shortest path length from a given start position to a given end position in a grid where 0 represents a walkable cell and 1 represents a blocked cell. # Validate input constraints rows = len(grid) if rows == 0: raise ValueError(\\"The grid must have at least one row.\\") cols = len(grid[0]) if cols == 0: raise ValueError(\\"The grid must have at least one column.\\") if not (0 <= start[0] < rows and 0 <= start[1] < cols): raise ValueError(\\"Start position must be within the grid boundaries.\\") if not (0 <= end[0] < rows and 0 <= end[1] < cols): raise ValueError(\\"End position must be within the grid boundaries.\\") if start == end: raise ValueError(\\"Start and end positions must be different.\\") if grid[start[0]][start[1]] == 1 or grid[end[0]][end[1]] == 1: return -1 def get_neighbors(pos): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] neighbors = [] for direction in directions: neighbor = (pos[0] + direction[0], pos[1] + direction[1]) if 0 <= neighbor[0] < rows and 0 <= neighbor[1] < cols: neighbors.append(neighbor) return neighbors queue = deque([(start, 0)]) # (position, distance) visited = set([start]) while queue: current, distance = queue.popleft() if current == end: return distance for neighbor in get_neighbors(current): if neighbor not in visited and grid[neighbor[0]][neighbor[1]] == 0: visited.add(neighbor) queue.append((neighbor, distance + 1)) return -1 # If no path is found"},{"question":"Sorting Algorithm - Merge Sort You are given a partial implementation of the merge sort algorithm. Complete the implementation so that it correctly sorts a list of integers in ascending order. You need to implement both the merge function which merges two sorted lists, and the merge_sort function which recursively sorts the list. **Task** Implement the `merge` and `merge_sort` functions using the following steps: 1. Define the `merge` function that merges two sorted sublists into one sorted list. 2. Define the `merge_sort` function that recursively splits the list into sublists and sorts them. **Function Signature** ```python def merge_sort(arr: list[int], debug: bool = True) -> list[int]: def merge(left: list[int], right: list[int]) -> list[int]: ``` # Input * `arr` (list[int]): The list of integers to be sorted. * `debug` (bool): If set to `True`, the algorithm should print the array at each merge step. # Output * A list containing the sorted integers. # Constraints * Ensure the input list contains integers only. * Handle edge cases like empty lists and single-element lists explicitly. # Implementation Steps 1. Split the list into two halves. 2. Recursively apply merge_sort on the two halves until base cases of single-element or empty lists are reached. 3. Merge the sorted halves using the merge function. # Example ```python array = [38, 27, 43, 3, 9, 82, 10] sorted_array = merge_sort(array, debug=False) print(sorted_array) # Output should be [3, 9, 10, 27, 38, 43, 82] ``` **Notes** * Use standard merge sort methodology to implement the solution. * Consider edge cases like: * The input list being empty. * The input list containing a single element. # Optimizations * Consider tail-recursion optimizations if applicable to improve performance on large datasets.","solution":"def merge_sort(arr: list[int], debug: bool = True) -> list[int]: def merge(left: list[int], right: list[int]) -> list[int]: merged = [] left_idx, right_idx = 0, 0 while left_idx < len(left) and right_idx < len(right): if left[left_idx] < right[right_idx]: merged.append(left[left_idx]) left_idx += 1 else: merged.append(right[right_idx]) right_idx += 1 # Append any remaining elements from both lists merged.extend(left[left_idx:]) merged.extend(right[right_idx:]) if debug: print(f\\"Merged: {merged}\\") return merged if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid], debug) right_half = merge_sort(arr[mid:], debug) return merge(left_half, right_half)"},{"question":"# IPv4 Address Validator **Scenario:** You need to implement a function that validates IPv4 addresses. An IPv4 address consists of four octets, each ranging from 0 to 255, separated by periods. This validation is essential for network management software to ensure that only valid IP addresses are processed or stored. **Function Specification:** ```python def is_valid_ipv4_address(address: str) -> bool: Validates an IPv4 address. Parameters: address (str): The IPv4 address to be validated. Returns: bool: True if the address is a valid IPv4 address, False otherwise. Raises: TypeError: If the input is not a string. ValueError: If the input does not follow the correct IPv4 address format. Example: >>> is_valid_ipv4_address(\\"192.168.0.1\\") True >>> is_valid_ipv4_address(\\"256.168.0.1\\") False >>> is_valid_ipv4_address(\\"192.168.0\\") False >>> is_valid_ipv4_address(\\"192.168.0.one\\") Traceback (most recent call last): ... ValueError: Invalid format for IPv4 address ``` **Requirements:** 1. The function should accept one parameter `address` which is expected to be a string containing an IPv4 address. 2. Validate the input: - Ensure the input is a string. - Split the input by periods. - Ensure there are exactly four parts. - Ensure each part is a digit and in the range from 0 to 255. 3. Return `True` if all parts are valid; otherwise, `False`. 4. Raise a `TypeError` if the input is not a string. 5. Raise a `ValueError` if the input does not follow the correct IPv4 address format. **Constraints:** - The input should consist of exactly four octets separated by periods. - Each octet must be a number between 0 and 255 inclusive. - Leading zeros in octets are invalid (e.g., \\"192.168.001.1\\" should be invalid). # Examples: ```python assert is_valid_ipv4_address(\\"192.168.0.1\\") == True assert is_valid_ipv4_address(\\"256.168.0.1\\") == False assert is_valid_ipv4_address(\\"192.168.0\\") == False # Less than four parts assert is_valid_ipv4_address(\\"192.168.0.001\\") == False # Leading zeros are not allowed assert is_valid_ipv4_address(\\"192.168.0.one\\") == False # Not numeric assert is_valid_ipv4_address(\\"192.168.0.1.1\\") == False # More than four parts assert is_valid_ipv4_address(19216801) == False # Raises TypeError ```","solution":"def is_valid_ipv4_address(address: str) -> bool: Validates an IPv4 address. Parameters: address (str): The IPv4 address to be validated. Returns: bool: True if the address is a valid IPv4 address, False otherwise. Raises: TypeError: If the input is not a string. ValueError: If the input does not follow the correct IPv4 address format. if not isinstance(address, str): raise TypeError(\\"Input must be a string\\") octets = address.split(\'.\') if len(octets) != 4: return False for octet in octets: if not octet.isdigit(): return False if not 0 <= int(octet) <= 255: return False if octet != str(int(octet)): return False return True"},{"question":"Problem Statement You need to implement a version of a Hash Table that supports multiple keys mapping to the same value. Specifically, this Hash Table should allow for a key to be associated with a list of strings. # Requirements: 1. **Class Definition**: ```python class MultiKeyHashTable: def __init__(self): # Initialize your data structure here def put(self, key: int, value: str) -> None: # Add the value to the list associated with the given key def get(self, key: int) -> list: # Return the list of values associated with the given key # If the key does not exist, return an empty list def delete(self, key: int) -> None: # Delete the list of values associated with the given key ``` 2. **Input**: * An integer (key) and a string (value) in the `put` method. * An integer (key) in the `get` and `delete` methods. 3. **Output**: * `put`: No return value. * `get`: A list of strings associated with the given (key). If the key does not exist, return an empty list. * `delete`: No return value. 4. **Constraints**: * The keys are integers and the values are strings. * You should handle basic cases where operations are performed on the Hash Table, ensuring efficient key management. * The methods should handle lists of varying lengths efficiently. # Example Usage: ```python # Example 1: hash_table = MultiKeyHashTable() hash_table.put(1, \\"apple\\") hash_table.put(1, \\"banana\\") print(hash_table.get(1)) # Output: [\\"apple\\", \\"banana\\"] hash_table.delete(1) print(hash_table.get(1)) # Output: [] # Example 2: hash_table.put(2, \\"carrot\\") print(hash_table.get(2)) # Output: [\\"carrot\\"] # Example 3: hash_table.put(3, \\"dog\\") hash_table.put(3, \\"cat\\") print(hash_table.get(3)) # Output: [\\"dog\\", \\"cat\\"] hash_table.delete(3) print(hash_table.get(3)) # Output: [] ``` # Edge Cases to Consider: 1. Adding and retrieving values for a non-existing key. 2. Deleting a key that doesn\'t exist. 3. Handling multiple values for a single key. 4. Large number of operations to assess performance and efficiency of the implmentation.","solution":"class MultiKeyHashTable: def __init__(self): self.table = {} def put(self, key: int, value: str) -> None: if key not in self.table: self.table[key] = [] self.table[key].append(value) def get(self, key: int) -> list: return self.table.get(key, []) def delete(self, key: int) -> None: if key in self.table: del self.table[key]"},{"question":"# Problem Description In this task, you need to implement a function that determines whether a given input is a palindrome or not. A palindrome is a number or string that reads the same forwards and backwards. Your implementation should handle both integer and string inputs and raise appropriate errors for non-integer and non-string inputs. # Function Signature ```python def is_palindrome(value) -> bool: pass ``` # Input * A single input `value` which can either be a string or an integer. # Output * Return `True` if the input value is a palindrome, otherwise return `False`. # Constraints * The input must be either an integer or a string. If the input is neither, the function should raise a `TypeError` with the message \\"value must be an integer or string\\". * For integer inputs, the palindrome check should disregard any negative sign (i.e., `-121` is considered a palindrome because `121` reads the same forwards and backwards). * The input must not be empty. # Performance Requirements * The implementation should efficiently handle edge cases and large inputs within the given constraints. # Examples ```python >>> is_palindrome(121) True >>> is_palindrome(-121) True >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"\\") Traceback (most recent call last): TypeError: value must be an integer or string >>> is_palindrome([1, 2, 1]) Traceback (most recent call last): TypeError: value must be an integer or string ``` # Detailed Example Walkthrough 1. For input `is_palindrome(121)`: The number 121 reads the same forwards and backwards, so the output is `True`. 2. For input `is_palindrome(-121)`: The number `-121` (disregarding the negative sign) reads the same forwards and backwards, so the output is `True`. 3. For input `is_palindrome(\\"racecar\\")`: The string \\"racecar\\" reads the same forwards and backwards, so the output is `True`. 4. For input `is_palindrome(\\"hello\\")`: The string \\"hello\\" does not read the same forwards and backwards, so the output is `False`. 5. For non-integer and non-string inputs like lists, the function raises a `TypeError`. # Notes * The solution should critically evaluate different inputs and handle appropriate type checking. * Consider edge cases such as negative numbers and empty strings while implementing the solution.","solution":"def is_palindrome(value) -> bool: Returns True if the input value is a palindrome, otherwise False. The input value should be either an integer or a string. if isinstance(value, int): raw_str = str(abs(value)) elif isinstance(value, str): raw_str = value else: raise TypeError(\\"value must be an integer or string\\") return raw_str == raw_str[::-1]"},{"question":"# Coding Challenge Question: Matrix Zone Sum **Context**: In matrix operations, it is often useful to calculate the sum of elements within a particular sub-matrix or a specific zone. This task involves writing a function to compute the sum of elements falling in a designated \'zone\' of a given 2D matrix, where the zone is defined by a set of coordinates (top-left and bottom-right corners). Problem Statement Implement a function `zone_sum(matrix: list[list[int]], zone: tuple[int, int, int, int]) -> int` that takes a 2D list representing an `m x n` matrix and a tuple representing the \'zone\' (top-left row index, top-left column index, bottom-right row index, bottom-right column index). The function should return the sum of all elements within that zone, inclusive of the boundaries described by the given coordinates. Input * A 2D list of integers representing the matrix. * A tuple with four integers representing the zone coordinates: `(top_left_row, top_left_col, bottom_right_row, bottom_right_col)`. Output * An integer: the sum of elements within the specified zone. Constraints * The matrix dimensions (m, n) can be 1 <= m, n <= 1000. * The zone coordinates will always define a valid submatrix within the given matrix. * Each element in the matrix will be an integer between -1000 and 1000. Expectations 1. Efficient calculation of the zone sum. 2. Proper handling of matrix boundary conditions. 3. Safely assume the input zone coordinates are always valid. Example ```python >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> zone = (0, 1, 2, 2) >>> zone_sum(matrix, zone) 33 >>> zone = (1, 1, 2, 2) >>> zone_sum(matrix, zone) 28 >>> zone = (0, 0, 0, 2) >>> zone_sum(matrix, zone) 6 >>> zone = (2, 0, 2, 2) >>> zone_sum(matrix, zone) 24 ``` Implementation Challenge * Efficient summation within specified matrix bounds. * Consider edge cases such as very small or very large matrices. * The function should scale efficiently with matrix size.","solution":"def zone_sum(matrix, zone): Returns the sum of elements within the specified zone of the matrix. :param matrix: List of lists representing the 2D matrix :param zone: Tuple of four integers (top_left_row, top_left_col, bottom_right_row, bottom_right_col) :return: Sum of elements within the specified zone top_left_row, top_left_col, bottom_right_row, bottom_right_col = zone total_sum = 0 for i in range(top_left_row, bottom_right_row + 1): for j in range(top_left_col, bottom_right_col + 1): total_sum += matrix[i][j] return total_sum"},{"question":"# Coding Assessment Question Objective Implement a function to find the first non-repeating character in a given string. Your implementation should efficiently handle scenarios with frequent repetitions and large input strings. Task Write a function `find_first_non_repeating_char(s: str) -> str:` that finds the first non-repeating character in the input string `s`. If all characters are repeating, return an empty string. Input and Output Format **Input**: - `s`: A string consisting of alphanumeric characters and special symbols. **Output**: - The function should return the first non-repeating character as a string. If no non-repeating character is found, return an empty string. Constraints - The input string `s` can have a length up to 10^5 characters. - Consider both uppercase and lowercase characters; \'A\' and \'a\' are different characters. - The function should handle edge cases such as empty strings and strings where all characters repeat efficiently. Performance Requirements - The function should have a time complexity of O(n), where n is the length of the input string. Example ```python def find_first_non_repeating_char(s: str) -> str: Function to find the first non-repeating character in a string. from collections import OrderedDict # Create ordered dictionary to store character counts char_count = OrderedDict() # Populate the dictionary with character counts for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first character with a count of 1 for char, count in char_count.items(): if count == 1: return char # If no non-repeating character is found return \\"\\" # Example usage: # \'s\' is a sample input string s = \\"aabbccddeffghh\\" # Find the first non-repeating character result = find_first_non_repeating_char(s) print(result) # Output should be \'g\' ``` Scenario Imagine you are developing a text analysis tool which needs to identify unique characters for highlighting purposes. Your task is to implement this core functionality to find the first unique character in any given text input. Use the provided `find_first_non_repeating_char` function template to complete this task.","solution":"def find_first_non_repeating_char(s: str) -> str: Function to find the first non-repeating character in a string. from collections import OrderedDict # Create ordered dictionary to store character counts char_count = OrderedDict() # Populate the dictionary with character counts for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first character with a count of 1 for char, count in char_count.items(): if count == 1: return char # If no non-repeating character is found return \\"\\""},{"question":"# Stock Price Trend Analysis **Scenario**: You are a software developer working for a financial analytics company. Your current task is to analyze stock price data to identify long-term trends. Specifically, you need to implement a feature that determines the length of the longest increasing subsequence of daily stock prices. **Objective**: Write a function `longest_increasing_subsequence(prices: List[int]) -> int` that calculates the length of the longest increasing subsequence in a given list of daily stock prices. **Input**: - `prices` (List[int]): A list of integers representing daily stock prices. **Output**: - An integer representing the length of the longest increasing subsequence. **Constraints**: - 1 <= len(prices) <= 1000 - 1 <= prices[i] <= 10000 **Performance Requirements**: - Your function should efficiently handle the upper limit constraints. **Example**: ```python prices1 = [3, 10, 2, 1, 20] prices2 = [3, 2] prices3 = [50, 3, 10, 7, 40, 80] result1 = longest_increasing_subsequence(prices1) # Expected output: 3 (subsequence: [3, 10, 20]) result2 = longest_increasing_subsequence(prices2) # Expected output: 1 (subsequence: [3] or [2]) result3 = longest_increasing_subsequence(prices3) # Expected output: 4 (subsequence: [3, 7, 40, 80]) ``` Implement the function `longest_increasing_subsequence` following the specifications and ensure to handle performance and various edge cases effectively.","solution":"def longest_increasing_subsequence(prices): Function to determine the length of the longest increasing subsequence of a list of daily stock prices. :param prices: List[int] - A list of integers representing daily stock prices. :return: int - The length of the longest increasing subsequence. if not prices: return 0 n = len(prices) # Initialize DP array, each position starts with 1 (the subsequence itself) dp = [1] * n # Populate the dp array for i in range(1, n): for j in range(i): if prices[i] > prices[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"# Problem Statement You are given a string `s` representing a list of positive integers separated by commas. Your task is to return the second largest integer in the list. If there is no second largest integer (e.g., the list contains fewer than two unique integers), return `None`. # Function Signature Write a function: ```python def second_largest_integer(s: str) -> int: # Your implementation here ``` # Input and Output Input: * `s`: A string containing positive integers separated by commas. Each integer is guaranteed to be a positive whole number. Output: * An integer representing the second largest unique integer in the list, or `None` if there is no second largest integer. # Examples ```python assert second_largest_integer(\\"4,2,9,7,5,6\\") == 7 assert second_largest_integer(\\"1,3,3,5,5,5,8\\") == 5 assert second_largest_integer(\\"3\\") == None assert second_largest_integer(\\"8,8,8,8\\") == None assert second_largest_integer(\\"10,20,10,30,40,40,50\\") == 40 ``` # Notes - Ensure your function handles edge cases properly, such as strings with fewer than two unique integers.","solution":"def second_largest_integer(s: str) -> int: Returns the second largest unique integer from a comma-separated string of positive integers. :param s: A string containing positive integers separated by commas. :return: The second largest unique integer in the list or None if there is no second largest integer. # Split the string into a list of integers numbers = list(map(int, s.split(\',\'))) # Remove duplicates by converting to a set and then back to a sorted list unique_numbers = sorted(set(numbers), reverse=True) # Check if there are at least two unique numbers if len(unique_numbers) < 2: return None # Return the second largest unique number return unique_numbers[1]"},{"question":"# Coding Question: Fibonacci Sum Calculation Write a function that calculates the sum of the first `n` Fibonacci numbers. The Fibonacci sequence is defined as follows: * `F(0) = 0` * `F(1) = 1` * `F(n) = F(n - 1) + F(n - 2)` for `n >= 2` Function Signature ```python def fibonacci_sum(n: int) -> int: pass ``` Input Parameters * `n` (int): The number of terms in the Fibonacci sequence to sum. Output * An integer representing the sum of the first `n` Fibonacci numbers. Constraints * `0 <= n <= 10^4` Doctests ```python >>> fibonacci_sum(0) 0 >>> fibonacci_sum(1) 0 >>> fibonacci_sum(2) 1 >>> fibonacci_sum(5) 7 >>> fibonacci_sum(10) 88 ``` The function should raise a `ValueError` for the following cases: ```python >>> fibonacci_sum(-1) Traceback (most recent call last): ... ValueError: n must be a non-negative integer >>> fibonacci_sum(10**5) Traceback (most recent call last): ... ValueError: n must be less than or equal to 10^4 ``` Ensure your implementation follows the constraints and handles edge cases appropriately.","solution":"def fibonacci_sum(n: int) -> int: if n < 0: raise ValueError(\\"n must be a non-negative integer\\") if n > 10**4: raise ValueError(\\"n must be less than or equal to 10^4\\") if n == 0: return 0 a, b = 0, 1 fib_sum = 0 for _ in range(n): fib_sum += a a, b = b, a + b return fib_sum"},{"question":"# Decision Tree Classifier Enhancement Challenge Objective You are required to enhance the existing Decision Tree classifier implemented using scikit-learn. Specifically, you should: 1. Implement a pruning strategy to prevent overfitting (e.g., cost complexity pruning). 2. Introduce a feature importance metric to identify the most significant features. Input/Output Format * **Input**: * A 2D NumPy array \'X\' with shape (n, m), where n is the number of samples and m is the number of features. * A 1D NumPy array \'y\' with shape (n,), where each element is the class label of the corresponding sample. * An optional float \'ccp_alpha\' for cost complexity pruning with a default value of 0.01. * **Output**: * A trained DecisionTreeClassifier object. * A NumPy array of the feature importances. Constraints * The input data should have at least two samples. * Assume all input data points are valid and not empty. Code Requirements 1. Implement the Decision Tree classifier with cost complexity pruning using scikit-learn\'s `DecisionTreeClassifier`. 2. Calculate the feature importances and return them along with the trained classifier. Template ```python from sklearn.tree import DecisionTreeClassifier from sklearn.datasets import load_iris from numpy import array def enhanced_decision_tree_classifier(X, y, ccp_alpha=0.01): Enhanced Decision Tree Classifier with pruning and feature importance metrics. \'X\' should be a n*m 2-D NumPy array, where n is the number of samples and m is the number of features. \'y\' should be a n*1 1-D NumPy array, where n is the number of class labels. \'ccp_alpha\' is the complexity parameter used for Minimal Cost-Complexity Pruning. # Implement the classifier clf = DecisionTreeClassifier(ccp_alpha=ccp_alpha) clf.fit(X, y) # Retrieve feature importances feature_importances = clf.feature_importances_ return clf, feature_importances # Example usage iris = load_iris() X, y = iris.data, iris.target clf, feature_importances = enhanced_decision_tree_classifier(X, y) print(\\"Trained DecisionTreeClassifier object:\\", clf) print(\\"Feature importances:\\", feature_importances) ``` This question closely matches the style, complexity, and topic alignment of the initial set by focusing on enhancing a machine learning algorithm with additional functionalities, similar to the K-Means clustering enhancement challenge.","solution":"from sklearn.tree import DecisionTreeClassifier from numpy import array def enhanced_decision_tree_classifier(X, y, ccp_alpha=0.01): Enhanced Decision Tree Classifier with pruning and feature importance metrics. \'X\' should be a n*m 2-D NumPy array, where n is the number of samples and m is the number of features. \'y\' should be a n*1 1-D NumPy array, where n is the number of class labels. \'ccp_alpha\' is the complexity parameter used for Minimal Cost-Complexity Pruning. # Initialize the Decision Tree Classifier clf = DecisionTreeClassifier(ccp_alpha=ccp_alpha) # Fit the classifier with the input data clf.fit(X, y) # Calculate feature importances feature_importances = clf.feature_importances_ return clf, feature_importances"},{"question":"# Movie Database Filter You are tasked with creating a filter for a movie database that allows users to find movies based on multiple criteria such as genre, release year, and minimum rating. Implement the `filter_movies(movies: List[Dict[str, Union[str, int, float]]], genre: str, min_year: int, min_rating: float) -> List[Dict[str, Union[str, int, float]]]` function, which returns a list of movies that match all the given criteria. Function Signature: ```python def filter_movies(movies: List[Dict[str, Union[str, int, float]]], genre: str, min_year: int, min_rating: float) -> List[Dict[str, Union[str, int, float]]]: pass ``` Input: - `movies`: A list of dictionaries, where each dictionary represents a movie with the following keys: - `\'title\'`: a string representing the title of the movie. - `\'genre\'`: a string representing the genre of the movie. - `\'year\'`: an integer representing the release year of the movie. - `\'rating\'`: a float representing the rating of the movie. - `genre`: a string representing the genre to filter by. - `min_year`: an integer representing the minimum release year of the movies. - `min_rating`: a float representing the minimum rating of the movies. Output: - Returns a list of dictionaries where each dictionary represents a movie that matches the provided genre, was released in `min_year` or later, and has a rating of `min_rating` or higher. The dictionaries should maintain the same structure as the input. Constraints: - (1950 leq text{year} leq 2023) - (0.0 leq text{rating} leq 10.0) - The function should handle empty lists and return an empty list in such cases. - The function should raise a `ValueError` if `min_year` or `min_rating` are out of valid range. Example: ```python >>> movies = [ {\\"title\\": \\"Inception\\", \\"genre\\": \\"Sci-Fi\\", \\"year\\": 2010, \\"rating\\": 8.8}, {\\"title\\": \\"The Godfather\\", \\"genre\\": \\"Crime\\", \\"year\\": 1972, \\"rating\\": 9.2}, {\\"title\\": \\"Interstellar\\", \\"genre\\": \\"Sci-Fi\\", \\"year\\": 2014, \\"rating\\": 8.6}, {\\"title\\": \\"The Dark Knight\\", \\"genre\\": \\"Action\\", \\"year\\": 2008, \\"rating\\": 9.0}, {\\"title\\": \\"Pulp Fiction\\", \\"genre\\": \\"Crime\\", \\"year\\": 1994, \\"rating\\": 8.9} ] >>> filter_movies(movies, \\"Sci-Fi\\", 2000, 8.5) [{\\"title\\": \\"Inception\\", \\"genre\\": \\"Sci-Fi\\", \\"year\\": 2010, \\"rating\\": 8.8}, {\\"title\\": \\"Interstellar\\", \\"genre\\": \\"Sci-Fi\\", \\"year\\": 2014, \\"rating\\": 8.6}] ``` # Explanation: 1. Inception (2010, 8.8) and Interstellar (2014, 8.6) match the given genre \\"Sci-Fi\\", are released in year 2000 or later, and have ratings of 8.5 or higher. 2. The other movies either don\'t match the genre, are released before 2000, or have a rating lower than 8.5. Consider implementing the `filter_movies` function, ensuring it validates inputs and handles edge cases appropriately.","solution":"from typing import List, Dict, Union def filter_movies(movies: List[Dict[str, Union[str, int, float]]], genre: str, min_year: int, min_rating: float) -> List[Dict[str, Union[str, int, float]]]: Filters the list of movies according to the provided genre, minimum year, and minimum rating. Parameters: movies (List[Dict[str, Union[str, int, float]]]): List of movies represented as dictionaries. genre (str): The genre to filter by. min_year (int): The minimum release year of the movies. min_rating (float): The minimum rating of the movies. Returns: List[Dict[str, Union[str, int, float]]]: Filtered list of movies matching all criteria. if not (1950 <= min_year <= 2023): raise ValueError(\\"min_year must be between 1950 and 2023.\\") if not (0.0 <= min_rating <= 10.0): raise ValueError(\\"min_rating must be between 0.0 and 10.0.\\") filtered_movies = [ movie for movie in movies if movie[\'genre\'] == genre and movie[\'year\'] >= min_year and movie[\'rating\'] >= min_rating ] return filtered_movies"},{"question":"# Question: Subset Sum Finder You are required to write a function that identifies if there exists a subset within a given list of integers that adds up to a target sum. This problem is fundamental in the context of dynamic programming and is widely applicable in resource allocation, decision making, and optimization problems. **Objective**: Implement a function that checks for the existence of a subset of the input integers that sums up to a given target value using dynamic programming. # Function Signature ```python def subset_sum_exists(nums: list[int], target: int) -> bool: pass ``` # Input * `nums`: A list of integers. * `target`: An integer representing the target sum. # Output * Returns `True` if there exists a subset of `nums` that adds up to `target`; otherwise, returns `False`. # Constraints 1. The input list will contain at most 20 elements. 2. The value of each integer in the list will range between -10^5 and 10^5. 3. The target value will be between -10^5 and 10^5. # Performance Requirements * The algorithm should efficiently handle the worst-case scenarios while keeping space and time complexity minimal. * Aim to meet the time complexity in terms of O(n * sum(nums)), where n is the number of elements in `nums`. # Examples ```python # Example 1 nums = [1, 2, 3, 4, 5] target = 9 # Expected result: True (because the subset [4, 5] sums to 9) # Example 2 nums = [3, 34, 4, 12, 5, 2] target = 30 # Expected result: False (because no subset sums to 30) # Example 3 nums = [1, -1, 2, -2, 3] target = 0 # Expected result: True (because the subset [1, -1] or [2, -2] sums to 0) # Example 4 nums = [] target = 0 # Expected result: True (because the empty subset sums to 0) # Example 5 nums = [10, 20, 30, 40] target = 70 # Expected result: True (because the subset [30, 40] sums to 70) ``` # Hints 1. Use dynamic programming to build a table representing whether a certain sum can be achieved with subsets of the elements seen so far. 2. Consider edge cases like an empty list and handle the condition where the target is zero gracefully. 3. Ensure to handle both positive and negative numbers correctly within the subset finding logic.","solution":"def subset_sum_exists(nums: list[int], target: int) -> bool: Checks if there exists a subset of the input list `nums` that sums up to `target`. Args: nums (list[int]): List of integers. target (int): Target sum. Returns: bool: True if a subset of `nums` sums to `target`, False otherwise. n = len(nums) # Initialize a list to store the possible sums with given elements possible_sums = {0} for num in nums: new_sums = set() for current_sum in possible_sums: new_sums.add(current_sum + num) possible_sums.update(new_sums) if target in possible_sums: return True return target in possible_sums"},{"question":"# Problem Description You are given a singly linked list implemented as a Python class. Your task is to implement a method named `delete_node(self, node: Node) -> None` in the `LinkedList` class. This method should delete a given node (except the tail) from the linked list. Note that the node to be deleted is not given as the head or tail of the linked list. # Requirements - The function should not return any value but must modify the linked list in place to remove the provided node. - Delete the node without using an auxiliary data structure to store nodes. # Input - `node (Node)`: The node to be deleted from the linked list. You can assume it is neither the head nor the tail node but is guaranteed to be in the list. # Output - The linked list should be modified in place, deleting the given node. # Constraints - The linked list contains at least two nodes. - The input node is not the head nor the tail node. - The number of nodes in the linked list is between 2 and 10^5. # Examples Example 1: ```python linked_list = LinkedList() for i in range(1, 6): linked_list.push(i) node_to_delete = linked_list.head.next.next # Node with value 3 print(list(linked_list)) # Output before delete_node: [5, 4, 3, 2, 1] linked_list.delete_node(node_to_delete) print(list(linked_list)) # Output after delete_node: [5, 4, 2, 1] ``` Example 2: ```python linked_list = LinkedList() for i in range(1, 6): linked_list.push(i) node_to_delete = linked_list.head.next # Node with value 4 print(list(linked_list)) # Output before delete_node: [5, 4, 3, 2, 1] linked_list.delete_node(node_to_delete) print(list(linked_list)) # Output after delete_node: [5, 3, 2, 1] ``` # Notes - You need to manipulate the next pointers to achieve the node deletion. - Consider creating utility methods for operations that modify the linked list. - Ensure your implementation handles all edge cases gracefully.","solution":"class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def push(self, new_data): new_node = Node(new_data) new_node.next = self.head self.head = new_node def __iter__(self): current = self.head while current: yield current.data current = current.next def delete_node(self, node: Node) -> None: Deletes a node (except the tail) from the linked list. if node is None or node.next is None: raise ValueError(\\"Cannot delete the given node.\\") # Copy the data from the next node to the current node next_node = node.next node.data = next_node.data node.next = next_node.next next_node = None # Optionally help garbage collection"},{"question":"# User Input Simulation You are designing a function to simulate user inputs for an interactive program. The goal is to ensure that a piece of software correctly handles different types of user inputs under various scenarios. **Objective:** Write a Python function that can generate a list of simulated user inputs based on provided types and constraints. # Function Signature Requirements: ```python def simulate_user_inputs( input_types: List[str], type_constraints: List[Dict[str, Any]], num_simulations: int ) -> List[Dict[str, Any]]: ``` # Parameters: 1. **input_types**: (List[str]) A list of strings representing the types of inputs needed for the simulation (e.g., \\"int\\", \\"float\\", \\"string\\"). 2. **type_constraints**: (List[Dict[str, Any]]) A list of dictionaries, each containing constraints for the corresponding input type in `input_types`. Example constraints might include range for numbers or length for strings. 3. **num_simulations**: (int) The number of simulations to generate. # Returns: - A list of dictionaries, each representing a set of simulated inputs. Each dictionary should have keys corresponding to the input types and values consistent with the given constraints. # Constraints: - The length of `input_types` and `type_constraints` should be the same. - Ensure that constraints are adhered to strictly. - Raise a `ValueError` if any input constraint is invalid. # Examples: ```python >>> simulate_user_inputs( [\\"int\\", \\"string\\", \\"float\\"], [ {\\"min\\": 0, \\"max\\": 10}, {\\"length\\": 5, \\"chars\\": \\"abc\\"}, {\\"min\\": 1.0, \\"max\\": 3.5} ], 3 ) [ {\'int\': 7, \'string\': \'abbbb\', \'float\': 2.76}, {\'int\': 1, \'string\': \'caaaa\', \'float\': 1.97}, {\'int\': 5, \'string\': \'bcabc\', \'float\': 3.0} ] >>> simulate_user_inputs( [\\"int\\"], [{\\"min\\": -5, \\"max\\": -1}], 2 ) [ {\'int\': -3}, {\'int\': -5} ] >>> simulate_user_inputs( [\\"float\\"], [{\\"min\\": -2.5, \\"max\\": -2.0}], 1 ) [ {\'float\': -2.27} ] >>> simulate_user_inputs( [\\"int\\"], [{\\"min\\": 5, \\"max\\": 3}], # Invalid constraint 1 ) Traceback (most recent call last): ... ValueError: Invalid constraints. \'min\' should be less than \'max\'. ``` **Hint:** Utilize random generation techniques to create inputs that meet the specified constraints. Use `random.uniform` for floats and `random.randint` for integers. For strings, use Python\'s `random.choices` to pick characters. # Solution: Implement and test your function to ensure correctness. The solution should handle different types of inputs and adhere to constraints provided effectively, while also accounting for possible edge cases and errors.","solution":"import random import string from typing import List, Dict, Any def simulate_user_inputs( input_types: List[str], type_constraints: List[Dict[str, Any]], num_simulations: int ) -> List[Dict[str, Any]]: def generate_int_constraint(constraint): if constraint[\'min\'] > constraint[\'max\']: raise ValueError(\\"Invalid constraints. \'min\' should be less than \'max\'.\\") return random.randint(constraint[\'min\'], constraint[\'max\']) def generate_float_constraint(constraint): if constraint[\'min\'] > constraint[\'max\']: raise ValueError(\\"Invalid constraints. \'min\' should be less than \'max\'.\\") return random.uniform(constraint[\'min\'], constraint[\'max\']) def generate_string_constraint(constraint): if \'length\' not in constraint or \'chars\' not in constraint: raise ValueError(\\"Invalid string constraints. \'length\' and \'chars\' must be specified.\\") if constraint[\'length\'] < 0: raise ValueError(\\"Invalid constraints. \'length\' should be a non-negative integer.\\") return \'\'.join(random.choices(constraint[\'chars\'], k=constraint[\'length\'])) simulated_inputs = [] for _ in range(num_simulations): simulation = {} for input_type, constraint in zip(input_types, type_constraints): if input_type == \\"int\\": simulation[input_type] = generate_int_constraint(constraint) elif input_type == \\"float\\": simulation[input_type] = generate_float_constraint(constraint) elif input_type == \\"string\\": simulation[input_type] = generate_string_constraint(constraint) else: raise ValueError(f\\"Unsupported input type: {input_type}\\") simulated_inputs.append(simulation) return simulated_inputs"},{"question":"# Coding Assessment Question Problem Statement You are given a non-empty string `s` which contains only lowercase alphabetic characters. Your task is to determine the frequency of each character and find the characters that have the highest frequency. The function should return these characters sorted in alphabetical order. Function Signature ```python def highest_frequency_chars(s: str) -> list[str]: ``` Input - `s`: A non-empty string consisting only of lowercase lowercase letters. Constraints: - 1 <= len(s) <= 1000 Output - The function should return a list of characters that have the highest frequency in the string, sorted in alphabetical order. Examples ```python >>> highest_frequency_chars(\\"abracadabra\\") [\'a\'] >>> highest_frequency_chars(\\"mississippi\\") [\'i\', \'s\'] >>> highest_frequency_chars(\\"balloon\\") [\'l\'] >>> highest_frequency_chars(\\"aabbcc\\") [\'a\', \'b\', \'c\'] ``` Constraints & Considerations - Handle the edge cases such as all characters having the same frequency. - The function should ensure to return characters in alphabetical order if multiple characters share the highest frequency. - Aim for a solution with O(n) time complexity, where n is the length of the input string. Detailed Explanation 1. **Count Character Frequencies**: - Use a dictionary to count the frequency of each character in the input string. 2. **Determine Highest Frequency**: - Find the maximum value in the frequency dictionary. 3. **Collect Characters with Highest Frequency**: - Collect all characters from the dictionary that have the highest frequency. 4. **Sort and Return**: - Return the list of characters sorted in alphabetical order. ```python def highest_frequency_chars(s: str) -> list[str]: if not s: return [] frequency = {} # Count the frequencies for char in s: if char not in frequency: frequency[char] = 1 else: frequency[char] += 1 # Determine the highest frequency max_freq = max(frequency.values()) # Collect characters with the highest frequency result = [char for char, freq in frequency.items() if freq == max_freq] # Return sorted list of characters return sorted(result) ``` This question integrates seamlessly with the existing set in terms of style, complexity, and scope. It covers a different but related aspect of string manipulation, tests understanding of dictionary operations, and introduces sorting as an additional layer of complexity.","solution":"def highest_frequency_chars(s: str) -> list[str]: if not s: return [] frequency = {} # Count the frequencies for char in s: if char not in frequency: frequency[char] = 1 else: frequency[char] += 1 # Determine the highest frequency max_freq = max(frequency.values()) # Collect characters with the highest frequency result = [char for char, freq in frequency.items() if freq == max_freq] # Return sorted list of characters return sorted(result)"},{"question":"# Problem Statement You are given a 2D list representing a grid of non-negative integers, where each cell contains some number of gold coins. You need to determine the maximum number of gold coins you can collect if you start from the top-left cell and can only move right or down at any point in time until you reach the bottom-right cell. Implement a function named `max_gold_coins` to accomplish this. Function Signature ```python def max_gold_coins(grid: List[List[int]]) -> int: ``` Input - `grid (List[List[int]])`: A 2D list of non-negative integers representing the grid. Output - Returns an integer representing the maximum number of gold coins that can be collected. Constraints - The grid dimensions will be between 1x1 and 100x100. - All integers in the grid will be between 0 and 1000 inclusive. - If the grid is empty, the function should raise a `ValueError` with the message \\"Empty grid was passed to the function\\". Examples ```python >>> max_gold_coins([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 12 >>> max_gold_coins([[1, 2, 5], [3, 2, 1]]) 9 >>> max_gold_coins([[0]]) 0 >>> max_gold_coins([]) Traceback (most recent call last): ... ValueError: Empty grid was passed to the function ``` Additional Notes - You may use dynamic programming to find an optimal solution. - Consider edge cases such as single cell grids and grids filled primarily with zeros.","solution":"from typing import List def max_gold_coins(grid: List[List[int]]) -> int: if not grid or not grid[0]: raise ValueError(\\"Empty grid was passed to the function\\") # Get the dimensions of the grid rows = len(grid) cols = len(grid[0]) # Create a DP table to store the maximum gold collected up to each cell dp = [[0] * cols for _ in range(rows)] # Initialize the first cell with its own value dp[0][0] = grid[0][0] # Fill the first row for col in range(1, cols): dp[0][col] = dp[0][col-1] + grid[0][col] # Fill the first column for row in range(1, rows): dp[row][0] = dp[row-1][0] + grid[row][0] # Fill the rest of the dp table for row in range(1, rows): for col in range(1, cols): dp[row][col] = max(dp[row-1][col], dp[row][col-1]) + grid[row][col] # The bottom-right cell will contain the max gold that can be collected return dp[rows-1][cols-1]"},{"question":"# Binary Search Tree Validation Objective You are required to implement a function that checks whether a given binary tree is a valid Binary Search Tree (BST). A Binary Search Tree follows these properties: 1. The left subtree of a node contains only nodes with keys less than the node\'s key. 2. The right subtree of a node contains only nodes with keys greater than the node\'s key. 3. Both the left and right subtrees must also be binary search trees. Requirements 1. **Function Signature**: `is_valid_bst(root: TreeNode) -> bool` 2. **Input**: * `root`: The root node of a binary tree. * The tree can have between 0 and 10^4 nodes. * Each node\'s value will be between -2^31 and 2^31 - 1. 3. **Output**: * Return `True` if the tree is a valid BST, otherwise return `False`. Constraints * Implement the check without using built-in library functions that directly solve the problem. * Your solution should be efficient in terms of both time and space complexities. * Handle edge cases such as an empty tree (which is considered a valid BST) and trees with duplicate values. Performance Requirements * The solution should ideally run in O(n) time complexity and use O(h) space complexity, where n is the number of nodes in the tree and h is the height of the tree. Scenario Imagine you are tasked with validating that the database storing hierarchical user permissions follows strict ordered rules of inheritance. Each node in the tree represents a user, and validations must ensure that user permissions adhere to the Binary Search Tree properties. Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example usage: root = TreeNode(2, TreeNode(1), TreeNode(3)) print(is_valid_bst(root)) # Expected Output: True root = TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6))) print(is_valid_bst(root)) # Expected Output: False root = TreeNode(1, TreeNode(1)) print(is_valid_bst(root)) # Expected Output: False root = None print(is_valid_bst(root)) # Expected Output: True ``` Notes * You may assume the definition of `TreeNode` class as provided in the example. * Pay careful attention to edge cases, such as nodes with duplicate values and subtrees with a single node, to ensure your solution is robust.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_valid_bst(root: TreeNode) -> bool: def validate(node, low=-float(\'inf\'), high=float(\'inf\')): if not node: return True if not (low < node.val < high): return False return validate(node.left, low, node.val) and validate(node.right, node.val, high) return validate(root)"},{"question":"# Question: Mirror a Binary Tree You are tasked with mirroring a binary tree, which means converting it such that the left and right children of all nodes are swapped. The mirrored tree should be created by modifying the original tree in place. Implement the function `mirror_tree` that will perform this transformation. Function Signature ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def mirror_tree(root: TreeNode) -> None: pass ``` Input * A `TreeNode` object `root` representing the root of the binary tree. Output * The function does not return any value. It modifies the tree in place. Constraints * You may assume the binary tree\'s node values are unique. * The height of the tree will not exceed 1000. * The input tree might be empty. Example ```python # Example 1 # Input: # 1 # / # 2 3 # / # 4 5 # # Output (Tree structure, in-place modified): # 1 # / # 3 2 # / # 5 4 # Test Code: root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3)) mirror_tree(root) assert root.left.value == 3 assert root.right.value == 2 assert root.right.left.value == 5 assert root.right.right.value == 4 # Example 2 # Input: (An empty tree) # Output: (Still an empty tree) # Test Code: root = None mirror_tree(root) assert root == None # Example 3 # Input: # 10 # / # 5 # # Output (Tree structure, in-place modified): # 10 # # 5 # Test Code: root = TreeNode(10, TreeNode(5), None) mirror_tree(root) assert root.left == None assert root.right.value == 5 ``` Performance Challenge Ensure that your implementation handles trees with the maximum height of 1000 efficiently.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def mirror_tree(root: TreeNode) -> None: if root: # Swap the left and right children root.left, root.right = root.right, root.left # Recursively mirror the left and right subtrees mirror_tree(root.left) mirror_tree(root.right)"},{"question":"# Inventory Tracking System **Objective**: Create a function that tracks the inventory levels of products based on incoming and outgoing transactions. **Function Signature**: `def update_inventory(transactions: list[tuple[str, int]]) -> dict:` # Input: - `transactions` (list of tuples): A list of tuples where each tuple contains two elements: - A string representing either an \'incoming\' or \'outgoing\' transaction. - An integer representing the amount of product for that transaction. Positive integers represent product amounts for both transaction types. # Output: - Returns a dictionary with two keys: - \'incoming\': Total amount of incoming products. - \'outgoing\': Total amount of outgoing products. # Constraints: - The transactions list must not be empty. - Each transaction string must be either \'incoming\' or \'outgoing\'. - Transaction amounts must be positive integers. - The function should raise a `ValueError` if the transactions list is empty or if invalid transaction types or amounts are provided. # Examples: 1. `update_inventory([(\'incoming\', 100), (\'outgoing\', 50), (\'incoming\', 200)])` should return `{\'incoming\': 300, \'outgoing\': 50}`. 2. `update_inventory([(\'incoming\', 150), (\'incoming\', 150), (\'outgoing\', 50)])` should return `{\'incoming\': 300, \'outgoing\': 50}`. 3. `update_inventory([(\'outgoing\', 30), (\'outgoing\', 70), (\'incoming\', 100)])` should return `{\'incoming\': 100, \'outgoing\': 100}`. 4. `update_inventory([(\'incoming\', -50), (\'outgoing\', 50)])` should raise `ValueError: Transaction amounts must be positive integers`. 5. `update_inventory([])` should raise `ValueError: Transactions list cannot be empty`. # Notes: - Ensure your implementation validates each transaction for correct types and positive amounts. - Handle edge cases such as empty transactions list and invalid transaction types before calculating totals. - Efficiently update and track the totals using a dictionary. # Hints: - Initialize totals for \'incoming\' and \'outgoing\' to zero. - Iterate through the transactions list and update the totals accordingly based on transaction type. - Use exception handling to raise appropriate errors for invalid inputs.","solution":"def update_inventory(transactions): Tracks the inventory levels of products based on incoming and outgoing transactions. Parameters: transactions (list of tuples): A list of tuples where each tuple contains two elements: - A string representing either \'incoming\' or \'outgoing\' transaction. - An integer representing the amount of product for that transaction (positive integers). Returns: dict: A dictionary with two keys \'incoming\' and \'outgoing\' representing total amounts. Raises: ValueError: If the transactions list is empty or if any transaction amount is not a positive integer, or if the transaction type is not \'incoming\' or \'outgoing\'. if not transactions: raise ValueError(\\"Transactions list cannot be empty.\\") inventory = {\\"incoming\\": 0, \\"outgoing\\": 0} for transaction in transactions: if len(transaction) != 2 or transaction[0] not in (\\"incoming\\", \\"outgoing\\") or not isinstance(transaction[1], int) or transaction[1] <= 0: raise ValueError(\\"Invalid transaction. Must be (\'incoming\' or \'outgoing\', positive integer).\\") inventory[transaction[0]] += transaction[1] return inventory"},{"question":"# Calculating the Sum of Digits in an Integer You are tasked with implementing a function that calculates the sum of the digits of a given non-negative integer until the sum becomes a single digit. Rules: 1. Add up all the digits of the given integer. 2. If the sum is a single digit (i.e., less than 10), return that sum. 3. If the sum has more than one digit, repeat the process on the sum until it becomes a single digit. Write a function `sum_of_digits_until_single(num: int) -> int` that performs these calculations. # Input: - `num`: A non-negative integer. # Output: - An integer representing the final single-digit sum of the digits. Constraints: * The input integer will be non-negative and will have at most 10^18 digits. # Example: ```python num = 9875 print(sum_of_digits_until_single(num)) ``` Output: ```python 2 ``` Explanation: 1. Sum of digits of `9875` is `9 + 8 + 7 + 5 = 29`. 2. Since `29` is not a single digit, sum the digits of `29` to get `2 + 9 = 11`. 3. Since `11` is not a single digit, sum the digits of `11` to get `1 + 1 = 2`. 4. `2` is a single digit, so the final result is `2`. # Note: - The function should handle edge cases where the input has only one digit (e.g., `num = 5` should return `5`). - Consider using a loop or a recursive function to compute the repeated sum of digits. Implement your solution in a function called `sum_of_digits_until_single`.","solution":"def sum_of_digits_until_single(num: int) -> int: Returns the sum of the digits of a given integer until the sum becomes a single digit. while num >= 10: num = sum(int(digit) for digit in str(num)) return num # Example usage # num = 9875 # print(sum_of_digits_until_single(num)) # Output: 2"},{"question":"Fibonacci Sequence with Memoization **Objective**: Implement a function to generate the Fibonacci sequence up to a given number of terms using memoization to optimize performance. # Function: `generate_fibonacci_terms(n: int) -> list[int]` **Input**: - `n`: An integer representing the number of terms in the Fibonacci sequence to generate. **Output**: - A list of integers representing the first `n` terms of the Fibonacci sequence. # Constraints: - 0 <= `n` <= 1000 - Use memoization to ensure efficient computation for large values of `n`. # Requirements: 1. Implement the `generate_fibonacci_terms` function to compute the Fibonacci sequence up to `n` terms. 2. Use a dictionary or similar data structure to store previously computed terms and avoid redundant calculations. 3. Handle the base cases (e.g., when `n` is 0 or 1) appropriately. 4. Ensure the function runs efficiently for the maximum constraint (`n` = 1000). # Example: ```python >>> generate_fibonacci_terms(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> generate_fibonacci_terms(0) [] >>> generate_fibonacci_terms(1) [0] ``` **Hint**: The Fibonacci sequence is defined as follows: - F(0) = 0 - F(1) = 1 - F(n) = F(n-1) + F(n-2) for n >= 2 Use these definitions along with memoization to complete the function. **Note**: 1. Do not use external libraries for the memoization. Implement it manually using a suitable data structure. 2. Ensure your function can be tested using standard unit tests.","solution":"def generate_fibonacci_terms(n): Generates the first n terms of the Fibonacci sequence using memoization. :param n: The number of terms to generate. :return: A list of the first n terms of the Fibonacci sequence. if n == 0: return [] if n == 1: return [0] memo = {0: 0, 1: 1} def fib(k): if k not in memo: memo[k] = fib(k-1) + fib(k-2) return memo[k] fib_sequence = [fib(i) for i in range(n)] return fib_sequence"},{"question":"**Scenario**: Imagine you are building a web application for an online bookstore. You need to manage inventory updates and sales analytics in real-time. Your task is to implement a class that handles these functionalities. The book data includes information like the title, author, genre, price, and stock. **Task**: Implement a class `Bookstore` with the following methods: 1. `add_book(book: dict) -> None`: Add a new book to the inventory. The book dictionary should contain the keys: \'title\', \'author\', \'genre\', \'price\', and \'stock\'. 2. `update_stock(title: str, number: int) -> None`: Update the stock quantity of a given book by the specified number. The number can be positive (addition) or negative (subtraction). 3. `get_sales_summary() -> dict`: Fetch a summary of sales, grouped by genre. The summary should be a dictionary where each key is a genre, and the value is the total number of copies sold in that genre. * Expected input and output formats: * `add_book({\'title\': \'Title\', \'author\': \'Author\', \'genre\': \'Genre\', \'price\': 19.99, \'stock\': 100})` -> None * `update_stock(\\"Title\\", -2)` -> None * `get_sales_summary()` -> `{ \\"Genre1\\": int, \\"Genre2\\": int, ... }` * Constraints: * Ensure that the book titles are unique within the inventory. * Stock values should not fall below zero. * The total copies sold in each genre should consider only completed sales (stock updates with negative numbers). Below is the starting code for the class: ```python class Bookstore: def __init__(self): self.inventory = {} self.sales = {} def add_book(self, book: dict) -> None: # Implement the logic to add a new book to the inventory. pass def update_stock(self, title: str, number: int) -> None: # Implement the logic to update the stock of a given book. pass def get_sales_summary(self) -> dict: # Implement the logic to get the sales summary, grouped by genre. pass ```","solution":"class Bookstore: def __init__(self): self.inventory = {} self.sales = {} def add_book(self, book: dict) -> None: # Ensure book title is unique if book[\'title\'] in self.inventory: raise ValueError(\\"Book title must be unique\\") # Add the book to the inventory self.inventory[book[\'title\']] = book self.sales[book[\'genre\']] = 0 def update_stock(self, title: str, number: int) -> None: if title not in self.inventory: raise KeyError(\\"Book not found in inventory\\") # Update the stock new_stock = self.inventory[title][\'stock\'] + number if new_stock < 0: raise ValueError(\\"Stock cannot be negative\\") self.inventory[title][\'stock\'] = new_stock # Update sales if books are sold if number < 0: genre = self.inventory[title][\'genre\'] self.sales[genre] += abs(number) def get_sales_summary(self) -> dict: return self.sales"},{"question":"# Problem Statement: Common Words in Book Titles You are given a collection of book titles, and your task is to find the most common words that appear across these titles. Develop a function that, given a list of book titles, returns the `n` most frequently occurring words. Words are considered the same irrespective of their case (i.e., case-insensitive), and common stop words like \\"and\\", \\"the\\", etc., should be excluded from the count. # Objective Write a function that: 1. Splits the titles into words, normalizing for case. 2. Excludes common stop words from the count. 3. Determines the most frequent words and returns them in descending order of frequency. # Function Signature ```python def most_common_words(titles: list[str], n: int) -> list[str]: Find the n most common words in the given list of book titles, excluding common stop words. Args: titles (list[str]): A list of book titles. n (int): The number of most common words to return. Returns: list: A list of the n most frequent words sorted by frequency in descending order. ``` # Input * `titles` - A list of strings where each string represents a book title. * `n` - An integer representing the number of most common words to return. # Output * A list of strings representing the `n` most common words sorted by frequency in descending order. # Constraints * The list `titles` will contain at most 1000 titles. * Each title will have a maximum length of 100 characters. * The common stop words to exclude are [\\"the\\", \\"and\\", \\"of\\", \\"in\\", \\"a\\", \\"to\\", \\"is\\", \\"with\\", \\"that\\", \\"for\\", \\"on\\", \\"as\\", \\"it\\", \\"by\\", \\"at\\", \\"from\\"]. # Example ```python >>> titles = [ ... \\"The Great Gatsby\\", ... \\"To Kill a Mockingbird\\", ... \\"The Catcher in the Rye\\", ... \\"Great Expectations\\", ... \\"The Great Adventure\\" ... ] >>> most_common_words(titles, 2) [\'great\', \'gatsby\'] ``` # Notes * Consider using a Counter or a similar data structure to count the frequency of words. * Normalize all words to lowercase. * Efficiently handle the filtering of stop words to ensure accurate word counts.","solution":"from collections import Counter import re def most_common_words(titles: list[str], n: int) -> list[str]: Find the n most common words in the given list of book titles, excluding common stop words. Args: titles (list[str]): A list of book titles. n (int): The number of most common words to return. Returns: list: A list of the n most frequent words sorted by frequency in descending order. stop_words = set([\\"the\\", \\"and\\", \\"of\\", \\"in\\", \\"a\\", \\"to\\", \\"is\\", \\"with\\", \\"that\\", \\"for\\", \\"on\\", \\"as\\", \\"it\\", \\"by\\", \\"at\\", \\"from\\"]) word_counter = Counter() for title in titles: words = re.findall(r\'bw+b\', title.lower()) filtered_words = [word for word in words if word not in stop_words] word_counter.update(filtered_words) most_common_words_list = [word for word, _ in word_counter.most_common(n)] return most_common_words_list"},{"question":"# Task Manager with Priority and Deadlines Design and implement a Task Manager that can add, remove, and retrieve tasks based on their priority and deadlines. The Task Manager should efficiently manage and sort tasks to always provide the next task with the highest priority and the nearest deadline. Class Specification: Implement the class `TaskManager`. This class should: 1. Allow adding a new task with a name, priority, and deadline. 2. Allow removing a task by its name. 3. Retrieve and return the task with the highest priority and nearest deadline. 4. Ensure that tasks with the same priority are ordered by their deadline. 5. Handle cases where multiple tasks have the same priority and deadline. 6. Support retrieval of the complete list of tasks sorted by priority and deadline. Methods: - `add_task(name: str, priority: int, deadline: int) -> None`: Adds a new task. - `remove_task(name: str) -> None`: Removes a task by its name. - `get_next_task() -> Tuple[str, int, int]`: Returns the next task as a tuple of (name, priority, deadline). - `get_all_tasks() -> List[Tuple[str, int, int]]`: Returns a list of all tasks sorted by priority and deadline. Input: - The `name` of all tasks will be unique strings. - The `priority` is an integer where a higher value means a higher priority. - The `deadline` is an integer representing a timestamp (seconds since the epoch). Constraints: - The number of tasks will not exceed 10^4. - The `priority` levels range from 1 to 10. - The `timestamp` ranges from 0 to 10^9. Example Usage: ```python task_manager = TaskManager() task_manager.add_task(\\"Task1\\", 5, 1633072800) task_manager.add_task(\\"Task2\\", 7, 1632979200) task_manager.add_task(\\"Task3\\", 5, 1633152000) print(task_manager.get_next_task()) # Should return (\\"Task2\\", 7, 1632979200) task_manager.remove_task(\\"Task2\\") print(task_manager.get_next_task()) # Should return (\\"Task1\\", 5, 1633072800) print(task_manager.get_all_tasks()) # Should return [(\\"Task1\\", 5, 1633072800), (\\"Task3\\", 5, 1633152000)] ``` Notes: - Use appropriate data structures to maintain the tasks efficiently. - Consider edge cases such as retrieving a task from an empty manager, handling duplicate tasks, etc. - Ensure all methods perform efficiently within the given constraints.","solution":"import heapq from typing import List, Tuple class TaskManager: def __init__(self): self.tasks = [] self.task_map = {} def add_task(self, name: str, priority: int, deadline: int) -> None: # using (-priority, deadline) ensures a max-heap based on priority and min heap on deadline heapq.heappush(self.tasks, (-priority, deadline, name)) self.task_map[name] = (-priority, deadline, name) def remove_task(self, name: str) -> None: if name in self.task_map: task = self.task_map.pop(name) self.tasks.remove(task) heapq.heapify(self.tasks) def get_next_task(self) -> Tuple[str, int, int]: if not self.tasks: return None priority, deadline, name = heapq.heappop(self.tasks) self.task_map.pop(name) return (name, -priority, deadline) def get_all_tasks(self) -> List[Tuple[str, int, int]]: # Sorting all tasks based on heap properties sorted_tasks = sorted(self.tasks, reverse=True) return [(name, -priority, deadline) for priority, deadline, name in sorted_tasks]"},{"question":"# Implementing a Custom Priority Queue You are given the task to implement a `PriorityQueue` class using a binary heap. The `PriorityQueue` should support basic operations such as inserting elements with priority values, removing the highest priority element, and adjusting priorities of existing elements. Requirements: 1. The `insert` function should add elements with their corresponding priority values into the queue. 2. The `pop` function should remove and return the element with the highest priority (maximum priority value). 3. The `adjust_priority` function should update the priority of an existing element in the queue. # Input and Output Formats: 1. **Input**: - The `insert` function takes two arguments: an element and its priority value. - The `pop` function takes no arguments and returns the element with the highest priority. - The `adjust_priority` function takes two arguments: an element and its new priority value. 2. **Output**: - The `pop` function returns the element with the highest priority. # Constraints: - The priority values are integers. - Operations should handle duplicate priorities but unique elements. - Each element is guaranteed to be unique within the queue. # Testing and Performance: - Create different test cases to verify the working of: - `insert` function by checking if elements are correctly added. - `pop` function by ensuring the element with the highest priority is returned. - `adjust_priority` function by confirming the priority adjustment and the subsequent order in the queue. ```python class PriorityQueue: def __init__(self): Initialize the PriorityQueue with an empty heap. Parameters: - heap: The list-based heap storing (priority, element) tuples. - position_map: A dictionary to map elements to their positions in the heap. self.heap = [] self.position_map = {} def insert(self, element, priority): Insert an element with a given priority into the queue. Parameters: - element: The element to be inserted. - priority: The priority value of the element. Returns: None self.heap.append((priority, element)) self.position_map[element] = len(self.heap) - 1 self._heapify_up(len(self.heap) - 1) def pop(self): Remove and return the element with the highest priority. Returns: - The element with the highest priority. if len(self.heap) == 0: raise IndexError(\\"The priority queue is empty.\\") if len(self.heap) == 1: priority, element = self.heap.pop() del self.position_map[element] return element top_priority, top_element = self.heap[0] self.heap[0] = self.heap.pop() del self.position_map[top_element] self.position_map[self.heap[0][1]] = 0 self._heapify_down(0) return top_element def adjust_priority(self, element, new_priority): Adjust the priority of an existing element. Parameters: - element: The element whose priority is to be changed. - new_priority: The new priority value for the element. Returns: None if element not in self.position_map: raise ValueError(\\"Element not found in the queue.\\") index = self.position_map[element] old_priority, _ = self.heap[index] self.heap[index] = (new_priority, element) if new_priority > old_priority: self._heapify_up(index) else: self._heapify_down(index) def _heapify_up(self, index): Maintain the heap property by moving the element at index up. Parameters: - index: The index of the element to be moved up. Returns: None while index > 0: parent_index = (index - 1) // 2 if self.heap[index][0] <= self.heap[parent_index][0]: break self._swap(index, parent_index) index = parent_index def _heapify_down(self, index): Maintain the heap property by moving the element at index down. Parameters: - index: The index of the element to be moved down. Returns: None size = len(self.heap) while 2 * index + 1 < size: left = 2 * index + 1 right = 2 * index + 2 largest = index if left < size and self.heap[left][0] > self.heap[largest][0]: largest = left if right < size and self.heap[right][0] > self.heap[largest][0]: largest = right if largest == index: break self._swap(index, largest) index = largest def _swap(self, i, j): Swap elements at indices i and j in the heap and update the position map. Parameters: - i: Index of the first element. - j: Index of the second element. Returns: None self.heap[i], self.heap[j] = self.heap[j], self.heap[i] self.position_map[self.heap[i][1]] = i self.position_map[self.heap[j][1]] = j # Test Cases if __name__ == \\"__main__\\": pq = PriorityQueue() pq.insert(\\"task1\\", 3) pq.insert(\\"task2\\", 5) pq.insert(\\"task3\\", 2) assert pq.pop() == \\"task2\\" pq.adjust_priority(\\"task1\\", 6) assert pq.pop() == \\"task1\\" assert pq.pop() == \\"task3\\" print(\\"All test cases passed.\\") ``` By ensuring your `PriorityQueue` implementation matches the style and complexity of other coding assessment questions, the new problem integrates seamlessly with the original set.","solution":"class PriorityQueue: def __init__(self): self.heap = [] self.position_map = {} def insert(self, element, priority): self.heap.append((priority, element)) self.position_map[element] = len(self.heap) - 1 self._heapify_up(len(self.heap) - 1) def pop(self): if len(self.heap) == 0: raise IndexError(\\"The priority queue is empty.\\") if len(self.heap) == 1: priority, element = self.heap.pop() del self.position_map[element] return element top_priority, top_element = self.heap[0] self.heap[0] = self.heap.pop() del self.position_map[top_element] if self.heap: self.position_map[self.heap[0][1]] = 0 self._heapify_down(0) return top_element def adjust_priority(self, element, new_priority): if element not in self.position_map: raise ValueError(\\"Element not found in the queue.\\") index = self.position_map[element] old_priority, _ = self.heap[index] self.heap[index] = (new_priority, element) if new_priority > old_priority: self._heapify_up(index) else: self._heapify_down(index) def _heapify_up(self, index): while index > 0: parent_index = (index - 1) // 2 if self.heap[index][0] <= self.heap[parent_index][0]: break self._swap(index, parent_index) index = parent_index def _heapify_down(self, index): size = len(self.heap) while 2 * index + 1 < size: left = 2 * index + 1 right = 2 * index + 2 largest = index if left < size and self.heap[left][0] > self.heap[largest][0]: largest = left if right < size and self.heap[right][0] > self.heap[largest][0]: largest = right if largest == index: break self._swap(index, largest) index = largest def _swap(self, i, j): self.heap[i], self.heap[j] = self.heap[j], self.heap[i] self.position_map[self.heap[i][1]] = i self.position_map[self.heap[j][1]] = j"},{"question":"# Coding Question: Temperature Conversions with Validation You are tasked with designing a function for a weather analysis system that involves temperature conversions. The function will convert temperatures between Fahrenheit and Celsius based on the specified direction of conversion. Additionally, the function should validate the inputs to ensure that they fall within physically possible ranges. **Problem Statement**: Implement a function to convert temperatures between Fahrenheit and Celsius. The function should start with validating the given temperature and then perform the conversion. Function Signature ```python def temperature_converter(value: float, direction: str) -> float: Converts temperature between Fahrenheit and Celsius. Args: value (float): The temperature value to be converted. direction (str): The direction of conversion. Must be either \'FtoC\' for Fahrenheit to Celsius or \'CtoF\' for Celsius to Fahrenheit. Returns: float: The converted temperature value. Raises: ValueError: if the input value is outside the valid range or if the direction is invalid. ``` Inputs: | Name | Description | Type | |-----------|-------------|--------| | value | Temperature value to be converted. | float | | direction | Conversion direction `FtoC` or `CtoF`. | str | Output: | Name | Description | Type | |-------------|-----------------------------|--------| | converted_value | The converted temperature value. | float | Constraints: 1. Conversion should be valid based on the following formulas: - `Celsius to Fahrenheit (CtoF)`: ( f = c times frac{9}{5} + 32 ) - `Fahrenheit to Celsius (FtoC)`: ( c = (f - 32) times frac{5}{9} ) 2. The function should raise a `ValueError` if an invalid temperature or conversion direction is provided: - Celsius cannot be lower than -273.15 (absolute zero). - Fahrenheit cannot be lower than -459.67 (absolute zero in Fahrenheit). - Valid directions are only \'FtoC\' and \'CtoF\'. Example: ```python >>> temperature_converter(32, \'FtoC\') 0.0 >>> temperature_converter(100, \'CtoF\') 212.0 >>> temperature_converter(-500, \'FtoC\') ValueError: \'Input temperature is below absolute zero.\' >>> temperature_converter(25, \'XtoY\') ValueError: \'Invalid conversion direction.\' ``` **Note**: Ensure all edge cases are handled properly, such as input temperatures exactly at the absolute zero point and invalid conversion directions by raising `ValueError`. **Performance Requirements**: * The time complexity should remain O(1), as the operations are basic arithmetic conversions.","solution":"def temperature_converter(value: float, direction: str) -> float: Converts temperature between Fahrenheit and Celsius. Args: value (float): The temperature value to be converted. direction (str): The direction of conversion. Must be either \'FtoC\' for Fahrenheit to Celsius or \'CtoF\' for Celsius to Fahrenheit. Returns: float: The converted temperature value. Raises: ValueError: if the input value is outside the valid range or if the direction is invalid. if direction == \'FtoC\': if value < -459.67: raise ValueError(\\"Input temperature is below absolute zero in Fahrenheit.\\") return (value - 32) * 5.0 / 9.0 elif direction == \'CtoF\': if value < -273.15: raise ValueError(\\"Input temperature is below absolute zero in Celsius.\\") return value * 9.0 / 5.0 + 32 else: raise ValueError(\\"Invalid conversion direction.\\")"}]'),F={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},N={class:"search-container"},L={class:"card-container"},R={key:0,class:"empty-state"},O=["disabled"],z={key:0},P={key:1};function D(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",N,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",L,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",R,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",P,"Loading...")):(n(),i("span",z,"See more"))],8,O)):u("",!0)])}const j=c(F,[["render",D],["__scopeId","data-v-956d6825"]]),V=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"quotes/54.md","filePath":"quotes/54.md"}'),Y={name:"quotes/54.md"},M=Object.assign(Y,{setup(r){return(e,l)=>(n(),i("div",null,[x(j)]))}});export{V as __pageData,M as default};
