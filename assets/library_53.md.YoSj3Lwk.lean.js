import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},I={class:"review-title"},S={class:"review-content"};function E(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",I,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",S,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const N=c(k,[["render",E],["__scopeId","data-v-15004083"]]),A=JSON.parse('[{"question":"# Given Problem: You are provided with n x m matrices and you need to perform various transformations on these matrices. Write implementations of the following functions with the given requirements: # Required Function Descriptions: 1. **rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]**: Rotate the given matrix 90 degrees clockwise. 2. **rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]**: Rotate the given matrix 90 degrees counterclockwise. 3. **bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]**: Invert the given matrix from bottom-left to top-right. # Inputs: - matrix: List of lists representing the matrix consisting of integers. (1 <= len(matrix) <= 100; 1 <= len(matrix[0]) <= 100) # Outputs: - Each function should return a new matrix that represents the transformed version of the input matrix. # Constraints: - Matrices are rectangular, i.e., non-square. - Matrix values are integers and could be negative. # Definition of the functions: ```python def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: pass def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: pass def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: pass ``` # Example: Given the following matrix: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] ``` - **rotate_clockwise(matrix)** would output: ```python [ [7, 4, 1], [8, 5, 2], [9, 6, 3], ] ``` - **rotate_counterclockwise(matrix)** would output: ```python [ [3, 6, 9], [2, 5, 8], [1, 4, 7], ] ``` - **bottom_left_invert(matrix)** would output: ```python [ [9, 8, 7], [6, 5, 4], [3, 2, 1], ] ``` Ensure your implementations pass these cases and handle all edge cases effectively.","solution":"from typing import List def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotate the given matrix by 90 degrees clockwise. return [list(row) for row in zip(*matrix[::-1])] def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: Rotate the given matrix by 90 degrees counterclockwise. return [list(row) for row in zip(*matrix)][::-1] def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: Invert the matrix from bottom-left to top-right. return [row[::-1] for row in matrix[::-1]]"},{"question":"**Assessing Anagram Equality of Strings** # Problem Statement: You are given two strings that contain only lowercase alphabetic characters. Write a function to determine if they are anagrams of each other. Strive to implement the solution with optimal performance in mind. # Function Signature: ```python def are_anagrams(s1: str, s2: str) -> bool: ``` # Input: - `s1`: A string of lowercase alphabetic characters (1 ≤ |s1| ≤ 10^5) - `s2`: A string of lowercase alphabetic characters (1 ≤ |s2| ≤ 10^5) # Output: - Return `True` if `s1` and `s2` are anagrams. - Return `False` otherwise. # Constraints: - String lengths are no greater than (10^5). - Only lowercase English alphabet characters are included. # Examples: Example 1: ```python s1 = \\"listen\\" s2 = \\"silent\\" # Output: True (Both strings contain the same characters with the same frequency) ``` Example 2: ```python s1 = \\"triangle\\" s2 = \\"integral\\" # Output: True (Both strings contain the same characters with the same frequency) ``` Example 3: ```python s1 = \\"apple\\" s2 = \\"pale\\" # Output: False (Different frequency of characters) ``` # Performance Requirements: - Ensure the solution operates efficiently within the given constraints.","solution":"def are_anagrams(s1: str, s2: str) -> bool: Determine if two strings are anagrams of each other. # Anagrams must be of the same length if len(s1) != len(s2): return False # Count characters in both strings from collections import Counter return Counter(s1) == Counter(s2)"},{"question":"# Question: Reconstruct Queue with Constraints **Scenario**: You are tasked with organizing a queue of people based on their heights and a specific position constraint. Each person is described by a pair of integers ((h, k)), where: - ( h ) is the height of the person. - ( k ) is the number of people in front of this person who have a height greater than or equal to ( h ). Your goal is to reconstruct the queue such that the given constraints are satisfied for each person. **Input**: - A list of pairs of integers. Each pair represents a person in the form ([h, k]). **Output**: - Reconstructed queue as a list of pairs of integers. **Constraints**: 1. The number of people is less than 1,100. 2. Heights and counts are non-negative integers. **Example**: ```python Input: [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]] Output: [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] ``` **Explanation**: 1. Person [7,0] has height 7 and no one taller in front. 2. Person [4,4] has height 4 and four taller people in front. 3. Person [7,1] has height 7 and one person taller or same height in front. 4. Person [5,0] has height 5 and no one taller in front. 5. Person [6,1] has height 6 and one person taller or same height in front. 6. Person [5,2] has height 5 and two people taller in front. **Task**: Implement the function `reconstruct_queue(people)` to generate the correct reconstructed queue. ```python def reconstruct_queue(people): :type people: List[List[int]] :rtype: List[List[int]] queue = [] people.sort(key=lambda x: (-x[0], x[1])) for h, k in people: queue.insert(k, [h, k]) return queue ``` **Evaluation Criteria**: - Correct implementation of the sorting and insertion steps. - Handling of edge cases accurately. - Time and space complexity analysis.","solution":"def reconstruct_queue(people): Reconstructs a queue based on heights and the number of people in front with greater or equal height. :param people: List of [height, count] pairs where height is the height of the person and count is the number of people in front of this person who have a greater or equal height. :return: Reconstructed queue as a list of [height, count] pairs. # Sort people by decreasing height and within same height by increasing k value people.sort(key=lambda x: (-x[0], x[1])) queue = [] for h, k in people: # Insert person at index k queue.insert(k, [h, k]) return queue"},{"question":"# Question: You are given two strings `s` and `t`. Write a function `is_anagram(s: str, t: str) -> bool` to determine if `t` is an anagram of `s`. An anagram is defined as a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Example 1: ```plaintext Input: s = \\"anagram\\", t = \\"nagaram\\" Output: True ``` Example 2: ```plaintext Input: s = \\"rat\\", t = \\"car\\" Output: False ``` # Constraints: * The strings `s` and `t` will only contain lowercase alphabets. * The solution should be optimized for time and space complexity as described in the provided algorithm analysis. # Input Format: Two strings `s` and `t`. # Output Format: A boolean value `True` if `t` is an anagram of `s`, and `False` otherwise. # Requirements: 1. Implement and use hash maps (dictionaries) to count character occurrences. 2. Ensure the comparison of these counts to determine the anagram status. 3. Add edge case checks for empty strings. # Performance: * Time Complexity should be O(n) where n is the length of the given strings. * Space Complexity should remain constant, considering the fixed size of the alphabet. ```python def is_anagram(s: str, t: str) -> bool: # Your code here # Ensure to implement hash map, count comparison, and edge-case handling pass ```","solution":"def is_anagram(s: str, t: str) -> bool: if len(s) != len(t): return False # Create counting dictionaries for both strings count_s, count_t = {}, {} for char in s: count_s[char] = count_s.get(char, 0) + 1 for char in t: count_t[char] = count_t.get(char, 0) + 1 # Compare the two dictionaries return count_s == count_t"},{"question":"**Problem Description**: Suppose you are in charge of designing a library that deals with data processing. One of the key functionalities is to sort a list of integers. To achieve this, you will implement a standard sorting algorithm. Your task is to implement the `merge_sort` function below. The `merge_sort` function takes a list of integers and returns the list sorted in non-decreasing order using the merge sort algorithm. You should also ensure this function handles edge cases correctly and is optimally performant. # Function Signature ```python def merge_sort(arr: List[int]) -> List[int]: pass ``` # Input - A single list of integers `arr` where `1 <= len(arr) <= 10^5`. # Output - A list of integers sorted in non-decreasing order. # Constraints - You must implement the sorting algorithm using the merge sort technique. - The time complexity should be O(n log(n)), and space complexity should be O(n). # Performance Requirements - Make sure the sorting function works efficiently for both very small and very large lists. # Example ```python print(merge_sort([38, 27, 43, 3, 9, 82, 10])) # Expected Output: [3, 9, 10, 27, 38, 43, 82] ``` # Detailed Instructions 1. Recursively divide the list into halves until single-element or empty sublists are obtained. 2. Merge the sublists by comparing elements and combining them in sorted order. 3. Ensure that edge cases, such as empty lists or lists with duplicate elements, are correctly handled. 4. Optimize your implementation to manage space complexity effectively. **Note**: You may assume all elements in the list are integers and the list fits in memory.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Function to perform merge sort on a list of integers. if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: Helper function to merge two sorted lists. sorted_list = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 sorted_list.extend(left[left_index:]) sorted_list.extend(right[right_index:]) return sorted_list"},{"question":"Context A software system deals with large datasets where numbers require frequent simplification and manipulation. Your task is to create a function capable of calculating both the greatest common divisor (GCD) and the trailing zero count in the binary representation of numbers within this system. Problem Statement Design and implement a function `compute(a: int, b: int) -> Tuple[int, int]` that meets the following requirements: 1. Calculates the greatest common divisor (GCD) of `a` and `b` using bitwise operators. 2. Counts the number of trailing zeros in the binary representation of the calculated GCD. Input * Two non-negative integers `a` and `b` where `a, b >= 0` and `a > 0 or b > 0`. Output * A tuple `(gcd_value, trailing_zero_count)` where: * `gcd_value`: The greatest common divisor of `a` and `b`. * `trailing_zero_count`: The number of trailing zeros in the binary representation of `gcd_value`. Examples Example 1: ```python compute(8, 12) ``` Output: ```python (4, 2) ``` Example 2: ```python compute(15, 25) ``` Output: ```python (5, 0) ``` Example 3: ```python compute(0, 20) ``` Output: ```python (20, 2) ``` Constraints 1. Optimize your solution to operate in logarithmic time complexity relative to the minimum of `a` and `b`. 2. Ensure the function correctly handles the edge case where one of the integers is zero. 3. Validate input to prevent invalid data types. 4. Avoid unnecessary memory usage and keep the space complexity to O(1). Evaluation Your solution will be assessed on: * Correctness: Correctly computing GCD and trailing zero count. * Performance: Ensuring efficient computation. * Readability: Clear and maintainable code structure. * Robustness: Proper error handling and edge cases management.","solution":"from typing import Tuple def gcd(a: int, b: int) -> int: while b: a, b = b, a % b return a def count_trailing_zeros(n: int) -> int: if n == 0: return 0 count = 0 while n % 2 == 0: n //= 2 count += 1 return count def compute(a: int, b: int) -> Tuple[int, int]: if a == 0: gcd_value = b elif b == 0: gcd_value = a else: gcd_value = gcd(a, b) trailing_zero_count = count_trailing_zeros(gcd_value) return gcd_value, trailing_zero_count"},{"question":"# Scenario You\'re part of a team developing a network security framework, and one of your tasks is to ensure that the network is robust by identifying isolated clusters. These clusters can be viewed as connected components in a corresponding undirected graph. Given an undirected graph representing connectivity in your network, you need to determine how many isolated clusters (connected components) exist. # Task Write a function `count_connected_components(n: int, edges: List[Tuple[int, int]]) -> int` that computes the number of connected components in an undirected graph. # Input * `n` (integer): The number of nodes in the graph, labeled from `1` to `n`. * `edges` (List of tuples): Each tuple `(u, v)` represents an undirected edge between nodes `u` and `v`. # Output * An integer representing the number of connected components in the graph. # Example ```python n = 7 edges = [(1, 2), (2, 4), (4, 5), (5, 6), (3, 7)] print(count_connected_components(n, edges)) # Output: 2 ``` # Constraints * (1 leq n leq 10^5) * (0 leq text{edges} leq 2 times 10^5) * Node labels are positive integers and indexed from 1 to n. # Notes * Handle graphs with no edges. * Consider optimizing for large graphs to avoid deep recursion issues. # Hints * You may use an iterative approach to implement DFS or use another robust method like Union-Find for handling large inputs.","solution":"from typing import List, Tuple def count_connected_components(n: int, edges: List[Tuple[int, int]]) -> int: Returns the number of connected components in an undirected graph. Args: n : int : number of nodes edges : List[Tuple[int, int]] : list of edges Returns: int : number of connected components # Initialize adjacency list adj_list = {i: [] for i in range(1, n+1)} for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # Initialize variables visited = set() components = 0 def dfs(node): stack = [node] while stack: curr = stack.pop() for neighbor in adj_list[curr]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) # Iterate through each node, perform DFS for unvisited nodes for node in range(1, n+1): if node not in visited: visited.add(node) components += 1 dfs(node) return components"},{"question":"Implement Depth-First Search (DFS) Traversal Methods in Binary Search Tree (BST) Context: You are provided with a Binary Search Tree (BST) implementation that includes basic operations like insertion, search, and size calculation. Currently, it includes traversal methods that print nodes in Preorder, Inorder, and Postorder traversals. Objective: You need to extend this BST class by implementing methods that perform Depth-First Search (DFS) traversals and return the output as a list of node values instead of printing them. Task: 1. Implement three new methods in the BST class: * `preorder_list(self)`: It should return a list of node values in pre-order traversal. * `inorder_list(self)`: It should return a list of node values in in-order traversal. * `postorder_list(self)`: It should return a list of node values in post-order traversal. Requirements: - Implement the methods such that they traverse the tree using DFS principles. - Ensure that each method returns the correct list of nodes. Constraints: - Assume that the BST can only contain integers. - You are not allowed to use any auxiliary data structures like stacks or queues for the traversal methods. - Performance should be optimized to the best possible complexity for each traversal method, i.e., O(N). # Example: If the BST is structured as shown: ``` 10 / 6 15 / / 4 9 12 24 / / 7 20 30 / 18 ``` - Preorder traversal: [10, 6, 4, 9, 7, 15, 12, 24, 20, 18, 30] - Inorder traversal: [4, 6, 7, 9, 10, 12, 15, 18, 20, 24, 30] - Postorder traversal: [4, 7, 9, 6, 12, 18, 20, 30, 24, 15, 10] # Function Signature: ```python def preorder_list(self) -> List[int]: # Your code here def inorder_list(self) -> List[int]: # Your code here def postorder_list(self) -> List[int]: # Your code here ``` Ensure you write these methods correctly and create the necessary test cases to validate your implementations.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = TreeNode(key) else: self._insert(root.left, key) else: if root.right is None: root.right = TreeNode(key) else: self._insert(root.right, key) def preorder_list(self): def _preorder(node): if not node: return [] return [node.val] + _preorder(node.left) + _preorder(node.right) return _preorder(self.root) def inorder_list(self): def _inorder(node): if not node: return [] return _inorder(node.left) + [node.val] + _inorder(node.right) return _inorder(self.root) def postorder_list(self): def _postorder(node): if not node: return [] return _postorder(node.left) + _postorder(node.right) + [node.val] return _postorder(self.root)"},{"question":"# AVL Tree Implementation Enhancement You are provided with an AVL Tree implementation. Augment this implementation by adding a delete function. The deletion function should correctly rebalance the tree after any deletions to maintain the AVL property. Task: 1. **Insert Function**: Function to insert a node into the AVL tree. Refactor if necessary to fit into the enhanced class. 2. **Delete Function**: Implement a delete function to remove a given node from the AVL tree while maintaining the balance. Function Signatures: ```python def delete(self, key: int) -> None: Delete a node with the given key from the AVL Tree. ``` Example Usage: ```python # Create an AVL tree and insert elements avl = AvlTree() avl.insert(10) avl.insert(20) avl.insert(30) avl.insert(40) avl.insert(50) avl.insert(25) # Delete an element and traverse in order avl.delete(40) print(avl.in_order_traverse()) # Should print the elements in sorted order after the deletion ``` Performance Requirements: - Ensure the tree maintains its balance after each insertion and deletion. - The delete function should operate in O(log n) time complexity. Constraints: - Do not use external libraries. - Follow Pythonic conventions for class and method definitions.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AvlTree: def __init__(self): self.root = None def _height(self, node): if not node: return 0 return node.height def _update_height(self, node): if node: node.height = 1 + max(self._height(node.left), self._height(node.right)) def _balance_factor(self, node): if not node: return 0 return self._height(node.left) - self._height(node.right) def _rotate_right(self, y): x = y.left T2 = x.right x.right = y y.left = T2 self._update_height(y) self._update_height(x) return x def _rotate_left(self, x): y = x.right T2 = y.left y.left = x x.right = T2 self._update_height(x) self._update_height(y) return y def _rebalance(self, node): balance = self._balance_factor(node) if balance > 1: if self._balance_factor(node.left) < 0: node.left = self._rotate_left(node.left) return self._rotate_right(node) if balance < -1: if self._balance_factor(node.right) > 0: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def _insert(self, node, key): if not node: return TreeNode(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) self._update_height(node) return self._rebalance(node) def insert(self, key): self.root = self._insert(self.root, key) def _min_value_node(self, node): current = node while current.left: current = current.left return current def _delete(self, node, key): if not node: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if not node.left: return node.right if not node.right: return node.left temp = self._min_value_node(node.right) node.key = temp.key node.right = self._delete(node.right, temp.key) self._update_height(node) return self._rebalance(node) def delete(self, key): self.root = self._delete(self.root, key) def in_order_traverse(self): def _in_order(node): return _in_order(node.left) + [node.key] + _in_order(node.right) if node else [] return _in_order(self.root)"},{"question":"# Function Implementation: Reverse String Using Custom Stack Implementations Context You are working on a text processing application where you need to reverse the characters in a given string. To achieve this task, you will use the custom stack implementations based on the Stack Abstract Data Type (ADT) provided above. Task Write a function that accepts a string and reverses it using one of the provided stack implementations (`ArrayStack` or `LinkedListStack`). Your task is to showcase your understanding by creating an efficient solution. Implementation Requirements 1. **Function Name**: `reverse_string` 2. **Input**: A string `s` (1 ≤ |s| ≤ 1000) 3. **Output**: The reversed string Constraints - You must use either the `ArrayStack` or `LinkedListStack` for managing stack operations. - Ensure your function handles edge cases properly, such as an empty string. - Performance requirement: The solution should run within O(n) time complexity where n is the length of the input string. Function Signature ```python def reverse_string(s: str, stack_type: str) -> str: Reverse the input string using a specified stack type. Args: s (str): The string to be reversed. stack_type (str): The type of stack to use (\'array\' or \'linked_list\'). Returns: str: The reversed string. ``` Example ```python assert reverse_string(\\"hello\\", \\"array\\") == \\"olleh\\" assert reverse_string(\\"world\\", \\"linked_list\\") == \\"dlrow\\" assert reverse_string(\\"\\", \\"array\\") == \\"\\" assert reverse_string(\\"a\\", \\"linked_list\\") == \\"a\\" ``` Notes 1. Choose the most appropriate stack implementation between `ArrayStack` or `LinkedListStack` based on the input parameter `stack_type`. 2. Validate the stack type and handle any invalid stack type gracefully by raising a `ValueError`.","solution":"class ArrayStack: def __init__(self): self.stack = [] def push(self, item): self.stack.append(item) def pop(self): if not self.is_empty(): return self.stack.pop() raise IndexError(\'Pop from empty stack\') def is_empty(self): return len(self.stack) == 0 class Node: def __init__(self, value=None): self.value = value self.next = None class LinkedListStack: def __init__(self): self.head = None def push(self, item): new_node = Node(item) new_node.next = self.head self.head = new_node def pop(self): if not self.is_empty(): value = self.head.value self.head = self.head.next return value raise IndexError(\'Pop from empty stack\') def is_empty(self): return self.head is None def reverse_string(s: str, stack_type: str) -> str: if stack_type == \'array\': stack = ArrayStack() elif stack_type == \'linked_list\': stack = LinkedListStack() else: raise ValueError(\\"Invalid stack type. Use \'array\' or \'linked_list\'.\\") for char in s: stack.push(char) reversed_str = [] while not stack.is_empty(): reversed_str.append(stack.pop()) return \'\'.join(reversed_str)"},{"question":"# Coding Challenge **Context:** You\'ve been hired by a text processing company that frequently deals with merging multiple logs into a single chronological log. To ensure accuracy, they have a verification process where they need to confirm if a merged log can be derived by interleaving entries from two sub-logs while maintaining their internal order. **Problem Statement:** You are given a string `s` and two other strings, `part1` and `part2`. You need to write a function `is_merge_optimized` that checks if `s` can be formed by interleaving `part1` and `part2` while maintaining the character order for both `part1` and `part2`. **Function Signature:** ```python def is_merge_optimized(s: str, part1: str, part2: str) -> bool: # Your implementation here ``` **Input:** - `s` (1 ≤ |s| ≤ 100): The string you want to check. - `part1` (0 ≤ |part1| ≤ 100): The first part of the string. - `part2` (0 ≤ |part2| ≤ 100): The second part of the string. **Output:** - Return `True` if `s` can be formed by merging `part1` and `part2`, otherwise return `False`. **Constraints:** - The characters in `part1` and `part2` must appear in the same order as they appear in `s`. **Example:** ```python is_merge_optimized(\\"codewars\\", \\"cdw\\", \\"oears\\") # Returns True is_merge_optimized(\\"abc\\", \\"ab\\", \\"cd\\") # Returns False is_merge_optimized(\\"abcdef\\", \\"abc\\", \\"def\\") # Returns True is_merge_optimized(\\"aabbcc\\", \\"abc\\", \\"abc\\") # Returns True is_merge_optimized(\\"abc\\", \\"abc\\", \\"\\") # Returns True ``` **Additional Notes:** 1. Consider edge cases including empty strings and overlapping character scenarios. 2. Optimize your solution to handle up to 100 characters efficiently.","solution":"def is_merge_optimized(s: str, part1: str, part2: str) -> bool: n, m, o = len(s), len(part1), len(part2) if n != m + o: return False # Create a DP table to store the truth value dp = [[False] * (o + 1) for _ in range(m + 1)] # Initialization dp[0][0] = True # Fill the DP table for i in range(m + 1): for j in range(o + 1): if i > 0 and s[i + j - 1] == part1[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j] if j > 0 and s[i + j - 1] == part2[j - 1]: dp[i][j] = dp[i][j] or dp[i][j - 1] return dp[m][o]"},{"question":"# String Reversal Challenge Scenario You are working on a text-processing module where you need to reverse strings efficiently. Given the need for different performance and readability characteristics, implement a function that efficiently reverses a given string. You will need to handle and assess different approaches with given constraints. Task Implement the function `reverse_string(s)` that takes a single string `s` and returns its reversal. * Expected input: * A non-null string `s` with length up to `10^5`. * Expected output: * A single string which is the reverse of the input string. * Constraints: * Optimize for time complexity O(n) and space complexity O(n) or better. * Handle edge cases, such as empty strings and special characters. * Performance requirements: * The function should perform efficiently even for the maximum input size. * Example: ```python assert reverse_string(\\"hello\\") == \\"olleh\\" assert reverse_string(\\"abcdefg\\") == \\"gfedcba\\" ``` Solution Requirements Provide both a simple, Pythonic way of reversing the string (using slicing) and an iterative method (using the two-pointer approach). Clearly comment each method and justify the efficiency in terms of time and space complexities.","solution":"def reverse_string(s): Returns the reverse of the string s using slicing. return s[::-1] def reverse_string_iterative(s): Returns the reverse of the string s using an iterative approach with two pointers. s_list = list(s) # Convert string to list to allow modification left, right = 0, len(s) - 1 while left < right: # Swap characters s_list[left], s_list[right] = s_list[right], s_list[left] left, right = left + 1, right - 1 # Convert list back to string return \'\'.join(s_list)"},{"question":"# Question: Regular Expression Matching Given the provided description of the regular expression matching and the available function prototype `bool is_match(const char *s, const char *p)`, write an optimized version of the function to match the string `s` against the pattern `p`. The pattern `p` contains the special characters `.` which matches any single character, and `*` which matches zero or more of the preceding element. # Function Signature ```python def is_match(s: str, p: str) -> bool: pass ``` # Input * `s`: A non-empty string with a length up to 1000 characters. * `p`: A string that contains only lowercase letters a-z, the characters `.` and `*`, with length up to 1000 characters. # Output * The function should return `True` if the entire string `s` matches the pattern `p` according to the rules specified. Otherwise, it should return `False`. # Constraints * The problem guarantees that `p` is a well-formed regular expression pattern. # Examples 1. `is_match(\\"aa\\",\\"a\\")` should return `False` 2. `is_match(\\"aa\\",\\"aa\\")` should return `True` 3. `is_match(\\"aaa\\",\\"aa\\")` should return `False` 4. `is_match(\\"aa\\", \\"a*\\")` should return `True` 5. `is_match(\\"aa\\", \\".*\\")` should return `True` 6. `is_match(\\"ab\\", \\".*\\")` should return `True` 7. `is_match(\\"aab\\", \\"c*a*b\\")` should return `True` # Explanation 1. First example - pattern does not fully cover the string. 2. Second example - pattern exactly matches the string. 3. Third example - pattern is shorter than the string. 4. Fourth example - `*` allows preceding element (`a`) to repeat zero or more times. 5. Fifth example - `.` matches any single character, followed by `*` matching any sequence of characters. 6. Sixth example - `.*` can cover all characters in the string. 7. Seventh example - `c*` can match zero occurrences of `c`, then `a*` matches length `2` of `a`, and `b` matches exactly. # Requirements 1. Your implementation should be optimized to handle the worst-case input size efficiently. 2. Ensure to handle edge cases including empty strings/patterns, patterns with standalone `*`, and character sequences that utilize `.` and `*` effectively.","solution":"def is_match(s: str, p: str) -> bool: Returns True if the string s matches the pattern p. Patterns includes \'.\' for any single character and \'*\' for zero or more preceding element. # Implementing the is_match function using dynamic programming dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] dp[0][0] = True # Both empty pattern and empty string match # Handle patterns like a* or a*b* or a*b*c* for j in range(2, len(p) + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j - 1] == s[i - 1] or p[j - 1] == \'.\': dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] if p[j - 2] == s[i - 1] or p[j - 2] == \'.\': dp[i][j] = dp[i][j] or dp[i - 1][j] return dp[len(s)][len(p)]"},{"question":"**Binary Search with Edge Cases and Error Handling** **Objective**: Write a function to find the index of a target value in a sorted array using binary search. Ensure to handle various edge cases, error scenarios, and provide correct output. **Function Signature**: ```python def advanced_binary_search(array: List[int], query: int) -> Optional[int]: pass ``` **Input**: - `array`: List of integers sorted in ascending order. The array can be empty. - `query`: Integer value to search for in the array. **Output**: - Return the index of the target value (`query`) if found. - Return `None` if the target value is not found. - Return `-1` if the input array is invalid or null. **Constraints**: - You must use the binary search algorithm. - Your solution should have a time complexity of O(log(n)). - You should handle edge cases and error scenarios efficiently. **Example Case**: ```python # Example 1: assert advanced_binary_search([1, 2, 3, 4, 5], 3) == 2 # Example 2: assert advanced_binary_search([1, 2, 3, 4, 5], 6) == None # Example 3: assert advanced_binary_search([], 1) == -1 # Example 4: assert advanced_binary_search(None, 1) == -1 ``` **Instruction**: Implement `advanced_binary_search` function. Make sure to handle an empty array and null input correctly.","solution":"from typing import List, Optional def advanced_binary_search(array: List[int], query: int) -> Optional[int]: if array is None: # If the input array is NULL return -1 if not array: # If the input array is empty return -1 left, right = 0, len(array) - 1 while left <= right: mid = left + (right - left) // 2 if array[mid] == query: return mid elif array[mid] < query: left = mid + 1 else: right = mid - 1 return None"},{"question":"# Question Objective: Given a sorted array of integers in increasing order, write a function to find the index of the last occurrence of a specified element using the binary search algorithm. Function Signature: ```python def last_occurrence(array: List[int], query: int) -> int: ``` # Input: * `array` (List[int]): A list of integers sorted in increasing order. * `query` (int): The target integer whose last occurrence index needs to be found in the array. # Output: * Returns an integer representing the index of the last occurrence of the specified element. If the element does not exist, return -1. # Constraints: * The array can be empty. * There may be multiple occurrences of the target integer in the array. * The elements in the array are sorted in increasing order. * The integer values in the array and query can be both positive and negative. # Performance Requirements: * The solution should have a time complexity of O(log n). * The solution should optimize space usage to O(1). # Scenario: You are given a list of widgets\' production times recorded sequentially and sorted in increasing order. You need to find the last production time occurrence of a specific type of widget efficiently to better understand production trends for future planning. # Example: ```python # Example 1 array = [1, 2, 2, 2, 3, 4, 5] query = 2 # Output should be 3 # Example 2 array = [1, 1, 2, 3, 5, 6, 6] query = 6 # Output should be 6 # Example 3 array = [1, 2, 3, 4, 5] query = 6 # Output should be -1 # Example 4 array = [] query = 4 # Output should be -1 print(last_occurrence(array, query)) ``` # Note: Write your `last_occurrence` function considering all edge cases and aiming for optimal efficiency.","solution":"from typing import List def last_occurrence(array: List[int], query: int) -> int: Finds the last occurrence of `query` in a sorted `array` using binary search. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] == query: result = mid left = mid + 1 # Move to the right half elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Question Write a function `bitwise_sum` that takes two unsigned integers and returns the sum of their Hamming weights. The Hamming weight of an integer is the number of \'1\' bits in its binary representation. Write both a recursive and an iterative function to compute the Hamming weight of an integer using Brian Kernighan\'s algorithm, and use these functions within the `bitwise_sum` function to find the combined Hamming weights of two numbers. Function Signature ```python def bitwise_sum(a: int, b: int) -> int: pass def hamming_weight_recur(n: int) -> int: pass def hamming_weight_iter(n: int) -> int: pass ``` Input - `a`: Non-negative integer (0 ≤ a ≤ 2^31 - 1) - `b`: Non-negative integer (0 ≤ b ≤ 2^31 - 1) Output - Returns the sum of the Hamming weights of `a` and `b`. Constraints - Performance (time complexity): The solution should be designed to be efficient and handle the provided input range effectively. - Do not use built-in functions except for bitwise operations. - `hamming_weight_recur` and `hamming_weight_iter` must independently use the iterative and recursive approach of Brian Kernighan\'s algorithm. Example ```python # Example usage: # For a = 11 (binary: 1011) and b = 15 (binary: 1111) # Hamming weight of 11 is 3 # Hamming weight of 15 is 4 # Thus, bitwise_sum(11, 15) should return 7. print(bitwise_sum(11, 15)) # Output: 7 ```","solution":"def hamming_weight_recur(n: int) -> int: Computes the Hamming weight of a number using recursion. if n == 0: return 0 else: # Turn off the rightmost 1-bit and count the number of operations return 1 + hamming_weight_recur(n & (n - 1)) def hamming_weight_iter(n: int) -> int: Computes the Hamming weight of a number using iteration. count = 0 while n: # Turn off the rightmost 1-bit and count the number of operations n = n & (n - 1) count += 1 return count def bitwise_sum(a: int, b: int) -> int: Computes the sum of the Hamming weights of two numbers. return hamming_weight_recur(a) + hamming_weight_recur(b)"},{"question":"# Question: Implement a Moving Average Calculator for a Data Stream You are required to implement a class `EfficientMovingAverage` that calculates the moving average of a sliding window for a stream of integers. This enhanced version should be optimized to avoid recalculating the sum from scratch. # Detailed Specifications: Class: `EfficientMovingAverage` - **Initialization** - `__init__(self, size: int)`: Initializes the data structure with a specific window size. - **Methods** - `next(self, val: int) -> float`: Adds a new integer to the stream and returns the current moving average of the last `size` elements. Constraints: - The size will always be a positive integer. - The values in the stream will be integers and fit within the typical signed 32-bit integer range. - You must optimize the operation to maintain O(1) time complexity for each `next` call. Expected Input and Output: - Example: ```python m = EfficientMovingAverage(3) print(m.next(1)) # Output: 1.0 print(m.next(10)) # Output: 5.5 print(m.next(3)) # Output: 4.666666666666667 print(m.next(5)) # Output: 6.0 ``` You need to handle edge cases where the number of elements is less than the window size initially and when sliding the window.","solution":"from collections import deque class EfficientMovingAverage: def __init__(self, size: int): Initializes the data structure with a specific window size. self.size = size self.window = deque() self.total = 0 def next(self, val: int) -> float: Adds a new integer to the stream and returns the current moving average of the last \'size\' elements. # Add the new value to the window self.window.append(val) self.total += val # Remove the oldest value if the window is larger than the size if len(self.window) > self.size: self.total -= self.window.popleft() # Calculate and return the moving average return self.total / len(self.window)"},{"question":"Diffie-Hellman Key Exchange is a cryptographic protocol that allows two parties to establish a shared secret over an insecure channel. To implement this securely, it is essential to use large prime numbers and their respective primitive roots. Your task is to implement a secure key exchange simulation using the Diffie-Hellman protocol. # Problem Statement: Write a Python function `diffie_hellman_simulation(p: int) -> str` that performs the Diffie-Hellman key exchange protocol. 1. Determine if the given `p` is a prime number using the provided `prime_check` function. 2. Find the primitive root of `p` using the provided `find_primitive_root` function. 3. For a valid prime `p` and a valid primitive root `a` (the smallest primitive root found): - Generate private keys for Alice and Bob using `alice_private_key` and `bob_private_key`. - Compute public keys using Alice’s and Bob\'s public key functions. - Calculate the shared secret keys for Alice and Bob. Your function should return: - The prime `p` and the selected primitive root `a`. - Both private keys and public keys. - The shared secret key, confirming if both keys match. # Input: - An integer `p` representing a candidate prime number. # Output: - A string summarizing the entire key exchange process, indicating if the protocol was successful and displaying: - Prime `p` and primitive root `a`. - Alice’s private key, public key, and shared key. - Bob’s private key, public key, and shared key. - Confirmation if both shared keys match. # Constraints: - ( p ) is a positive integer. - For a valid prime `p`, there should exist at least one primitive root. # Example: ```python from random import seed seed(0) # For reproducibility in tests; remove in real implementation. def diffie_hellman_simulation(p: int) -> str: # include the necessary functions here... # ... pass # Your implementation print(diffie_hellman_simulation(23)) ``` # Expected Output: ``` Prime: 23 Primitive Root: 5 Alice\'s Private Key: 18 Alice\'s Public Key: 6 Bob\'s Private Key: 13 Bob\'s Public Key: 21 Shared Key Calculated by Alice: 2 Shared Key Calculated by Bob: 2 Both keys match: True ``` # Note: - Ensure to encapsulate data validations, especially checks for valid prime and primitive root. - Implement the edge cases handling effectively. - The random key generation should be reproducible for testing but needs to be secure in production.","solution":"import random from sympy.ntheory import isprime, primitive_root def prime_check(p): return isprime(p) def find_primitive_root(p): return primitive_root(p) def diffie_hellman_simulation(p: int) -> str: if not prime_check(p): return f\\"{p} is not a prime number.\\" a = find_primitive_root(p) if a is None: return f\\"No primitive root found for prime {p}.\\" alice_private_key = random.randint(1, p-1) bob_private_key = random.randint(1, p-1) alice_public_key = pow(a, alice_private_key, p) bob_public_key = pow(a, bob_private_key, p) alice_shared_key = pow(bob_public_key, alice_private_key, p) bob_shared_key = pow(alice_public_key, bob_private_key, p) keys_match = (alice_shared_key == bob_shared_key) result = ( f\\"Prime: {p}n\\" f\\"Primitive Root: {a}n\\" f\\"Alice\'s Private Key: {alice_private_key}n\\" f\\"Alice\'s Public Key: {alice_public_key}n\\" f\\"Bob\'s Private Key: {bob_private_key}n\\" f\\"Bob\'s Public Key: {bob_public_key}n\\" f\\"Shared Key Calculated by Alice: {alice_shared_key}n\\" f\\"Shared Key Calculated by Bob: {bob_shared_key}n\\" f\\"Both keys match: {keys_match}n\\" ) return result"},{"question":"Question # Context You are developing a feature for a combinatorics tool aimed at generating all possible subsets from a given set of distinct integers. This tool will be used for various mathematical computations and problem-solving scenarios requiring the identification of all possible selections from a set. # Task Write a function `generate_subsets(nums)` that returns all possible subsets of a given list of distinct integers `nums`. # Function Signature ```python def generate_subsets(nums: List[int]) -> List[List[int]]: ``` # Input - `nums`: A list of distinct integers. - Length of `nums` (denoted as n) is in the range [0, 10]. - Integers are in the range [-10, 10]. # Output - A list of lists, where each inner list represents a subset of `nums`. # Examples Example 1 ```python generate_subsets([1, 2, 3]) ``` **Output**: ```python [ [], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3] ] ``` Example 2 ```python generate_subsets([0]) ``` **Output**: ```python [ [], [0] ] ``` # Constraints - Do not use any built-in library functions that directly solve the problem. - Achieve an efficient and clean implementation following best coding practices. # Notes - Ensure that the elements in each subset appear in the same order as they appear in `nums`, although the subsets themselves can be in any order. - Include sufficient comments in your code to describe your approach and reasoning.","solution":"from typing import List def generate_subsets(nums: List[int]) -> List[List[int]]: Given a list of distinct integers, return all possible subsets. result = [] def backtrack(start, path): # Append the current path as a new subset result.append(path[:]) # Explore further elements to generate more subsets for i in range(start, len(nums)): path.append(nums[i]) backtrack(i + 1, path) path.pop() backtrack(0, []) return result"},{"question":"Question: Implement an Optimized GCD and LCM Function Given two positive integers `a` and `b`, write a Python function to calculate both the greatest common divisor (GCD) and the least common multiple (LCM) using both standard and bitwise methods. Your task is to implement the following functions: 1. Standard GCD calculation using the Euclidean algorithm. 2. LCM calculation based on the GCD. 3. GCD calculation using bitwise operations. 4. Trailing zero counting function to be reused in bitwise GCD. # Function Signatures ```python def gcd_standard(a: int, b: int) -> int: pass def lcm(a: int, b: int) -> int: pass def gcd_bitwise(a: int, b: int) -> int: pass ``` # Input - Two positive integers `a` and `b`. # Output - For `gcd_standard(a, b)`, return an integer representing the greatest common divisor of `a` and `b`. - For `lcm(a, b)`, return an integer representing the least common multiple of `a` and `b`. - For `gcd_bitwise(a, b)`, return an integer representing the greatest common divisor of `a` and `b` using bitwise operations. # Constraints - `1 <= a, b <= 10^9` # Performance Requirements - Ensure your implementations handle large values efficiently and avoid overflow wherever possible. # Example ```python print(gcd_standard(48, 18)) # Output: 6 print(lcm(48, 18)) # Output: 144 print(gcd_bitwise(48, 18)) # Output: 6 ``` # Edge Cases to Consider - Inputs where `a` or `b` is 1. - Large values close to the upper constraint. - Both numbers are equal.","solution":"def gcd_standard(a: int, b: int) -> int: while b: a, b = b, a % b return a def lcm(a: int, b: int) -> int: return a * b // gcd_standard(a, b) def gcd_bitwise(a: int, b: int) -> int: if a == 0: return b if b == 0: return a shift = 0 while ((a | b) & 1) == 0: a >>= 1 b >>= 1 shift += 1 while (a & 1) == 0: a >>= 1 while b != 0: while (b & 1) == 0: b >>= 1 if a > b: a, b = b, a b -= a return a << shift"},{"question":"# Problem: Counting Unique Binary Search Trees You are given an integer `n`. Your task is to determine the number of structurally unique Binary Search Trees (BSTs) that store values 1 through `n`. A Binary Search Tree (BST) is a binary tree in which each node has at most two children, and for a node with value `v`: - All values of the left subtree are less than `v`. - All values of the right subtree are greater than `v`. # Input - An integer `n` where `0 <= n <= 100`. # Output - An integer representing the number of structurally unique BSTs that can be formed with values 1 to `n`. # Constraints - The input will always be a valid integer. - Numbers might be large, but Python supports arbitrarily large integers. # Examples Example 1 **Input**: ``` 3 ``` **Output**: ``` 5 ``` **Explanation**: There are 5 unique BSTs that can be formed with values 1, 2, 3: ``` 1 3 3 2 1 / / / 3 2 1 1 3 2 / / 2 1 2 3 ``` Example 2 **Input**: ``` 1 ``` **Output**: ``` 1 ``` **Explanation**: There is only 1 unique BST that can be formed with the value 1, which is itself. # Function Signature You need to implement the following function: ```python def num_trees(n: int) -> int: # Your code here ``` # Requirements - Your implementation should run within the acceptable time limits. - Ensure to handle edge cases properly (e.g., n = 0 or n = 1).","solution":"def num_trees(n: int) -> int: Returns the number of structurally unique BSTs that can be formed with values 1 to n. if n == 0: return 1 # The array to store the number of unique BSTs for each count up to n dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 # Filling the dp array using the formula for i in range(2, n + 1): for j in range(1, i + 1): dp[i] += dp[j - 1] * dp[i - j] return dp[n]"},{"question":"# Graph Traversal: Depth-First Search (DFS) You are required to implement a Depth-First Search (DFS) algorithm for the provided `DirectedGraph` class. The DFS algorithm should traverse the graph starting from a given node and return the order of nodes visited during the traversal. Function Signature ```python def depth_first_search(graph: DirectedGraph, start_node: Node) -> List[Node]: ``` Input - `graph`: An instance of `DirectedGraph`. - `start_node`: The starting node for the DFS traversal. Output - A list of `Node` objects representing the order of nodes visited during the DFS traversal. Constraints - The graph may contain cycles. - Nodes in the graph may have multiple outgoing edges. - If a node has no outgoing edges, terminate the traversal from that node. - All node names are unique. Example ```python # Example graph dictionary graph_dict = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"D\\", \\"E\\"], \\"C\\": [\\"F\\"], \\"D\\": [], \\"E\\": [\\"F\\"], \\"F\\": [] } graph = DirectedGraph(graph_dict) start_node = graph.add_node(\\"A\\") visited_order = depth_first_search(graph, start_node) print(visited_order) # Output should be in the DFS visiting order ``` # Additional Notes - Make sure to handle cycles appropriately to avoid infinite loops. - Ensure your implementation is efficient and correctly manages traversal without revisiting already visited nodes.","solution":"class Node: def __init__(self, name): self.name = name def __repr__(self): return self.name class DirectedGraph: def __init__(self, graph_dict=None): Initializes a graph object with a dictionary representation of the graph. if graph_dict is None: graph_dict = {} self.graph_dict = graph_dict self.nodes = {name: Node(name) for name in graph_dict} for key in graph_dict: self.nodes[key] = Node(key) def add_node(self, name): if name not in self.nodes: self.nodes[name] = Node(name) return self.nodes[name] def add_edge(self, from_node, to_node): if from_node not in self.graph_dict: self.graph_dict[from_node] = [] self.graph_dict[from_node].append(to_node) def depth_first_search(graph, start_node): visited = set() order = [] def dfs(node): if node in visited: return visited.add(node) order.append(node) for neighbor_name in graph.graph_dict.get(node.name, []): neighbor = graph.nodes[neighbor_name] dfs(neighbor) dfs(start_node) return order"},{"question":"Pattern to Substring Mapping You are given a pattern string and a target string. Your task is to determine if the target string follows the pattern. Function Signature: ```python def pattern_match(pattern: str, string: str) -> bool: ``` Description 1. **Input**: - **pattern**: A string containing only lowercase letters, representing the pattern. - **string**: A string containing only lowercase letters, representing the target string. 2. **Output**: - Return `True` if the target string follows the pattern according to the rules stated below. Otherwise, return `False`. 3. **Rules**: - Establish a bijection between each unique character in the pattern and a non-empty substring of the target string. - Each character in the pattern must map to a unique and consistent substring from the target string throughout the pattern. - If no such bijection is possible, return `False`. Examples: ```python pattern_match(\\"abab\\", \\"redblueredblue\\") # Returns: True pattern_match(\\"aaaa\\", \\"asdasdasdasd\\") # Returns: True pattern_match(\\"aabb\\", \\"xyzabcxzyabc\\") # Returns: False pattern_match(\\"abc\\", \\"xyyyz\\") # Returns: True pattern_match(\\"a\\", \\"xyz\\") # Returns: True pattern_match(\\"aa\\", \\"abcd\\") # Returns: False ``` Constraints: - Patterns and strings may contain only lowercase letters. - The length of the pattern will not exceed 20. - The length of the string will not exceed 200. Implement the function `pattern_match` to complete the task.","solution":"def pattern_match(pattern: str, string: str) -> bool: def backtrack(p_index, s_index, pattern_to_str, str_to_pattern): # If we\'ve reached the end of both pattern and the string, it\'s a match if p_index == len(pattern) and s_index == len(string): return True # If we\'ve reached the end of one but not the other, it\'s not a match if p_index == len(pattern) or s_index == len(string): return False pattern_char = pattern[p_index] # Try all possible substring matches for this pattern character for end_index in range(s_index + 1, len(string) + 1): substring = string[s_index:end_index] if pattern_char in pattern_to_str: # If the pattern character is already mapped, check for consistency if pattern_to_str[pattern_char] == substring: if backtrack(p_index + 1, end_index, pattern_to_str, str_to_pattern): return True elif substring in str_to_pattern: # If the substring is already mapped to another pattern character, skip continue else: # Make the mapping pattern_to_str[pattern_char] = substring str_to_pattern[substring] = pattern_char if backtrack(p_index + 1, end_index, pattern_to_str, str_to_pattern): return True # Unmake the mapping (backtracking) del pattern_to_str[pattern_char] del str_to_pattern[substring] return False return backtrack(0, 0, {}, {}) # Example usage # print(pattern_match(\\"abab\\", \\"redblueredblue\\")) # Should return True"},{"question":"You are given an array of integers and you need to sort this array using Bogo Sort, despite its inefficiency. The Bogo Sort algorithm randomly shuffles the array until it is sorted. You need to implement the Bogo Sort algorithm and ensure that the result meets the required sorted order. # Function Signature ```python def bogo_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` # Input * `arr` (List[int]): A list of integers that need to be sorted. (1 ≤ len(arr) ≤ 10) * `simulation` (bool): A boolean flag to determine if the intermediate steps should be printed (default is False). # Output * Returns a list of integers sorted in non-decreasing order. # Constraints * The input list will have a size between 1 and 10 inclusive. * You should not use any built-in sort functions other than what is provided. # Examples ```python # Example 1 input = [3, 2, 1] output = bogo_sort(input) print(output) # Output could be [1, 2, 3] # Example 2 input = [5, 4, 3, 2, 1] output = bogo_sort(input) print(output) # Output should be [1, 2, 3, 4, 5] ``` # Note * You may use the built-in `random.shuffle` for suffling operations. * If the `simulation` flag is set to `True`, print the array at each iteration of shuffling. * Handling of edge cases like an already sorted array or an array with all identical elements should be considered.","solution":"import random from typing import List def is_sorted(arr: List[int]) -> bool: Helper function to check if the array is sorted. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def bogo_sort(arr: List[int], simulation: bool = False) -> List[int]: Sorts the array using Bogo Sort algorithm which randomly shuffles the array until it is sorted. attempts = 0 while not is_sorted(arr): if simulation: print(arr) random.shuffle(arr) attempts += 1 if simulation: print(f\\"Sorted array after {attempts} attempts: {arr}\\") return arr"},{"question":"You are given an array which may contain duplicate elements. Write a Python function to remove the duplicates and return a new array with unique elements. The order of the elements should be preserved as in the original array. # Function Signature ```python def remove_duplicates(array: List[Any]) -> List[Any]: ``` # Input - `array`: A list of elements which can be of any data type (integers, strings, booleans, etc.). # Output - A list of elements where all duplicates have been removed, maintaining original order. # Constraints - The list can contain up to 10^5 elements. # Example ```python assert remove_duplicates([1, 1, 1, 2, 2, 3, 4, 4, \\"hey\\", \\"hey\\", \\"hello\\", True, True]) == [1, 2, 3, 4, \'hey\', \'hello\'] assert remove_duplicates([5, 3, 5, 7, 3, 9, 11, 11, \'a\', \'b\', \'a\']) == [5, 3, 7, 9, 11, \'a\', \'b\'] assert remove_duplicates([1, 2, 3, 4]) == [1, 2, 3, 4] assert remove_duplicates([]) == [] ``` # Performance Requirements - The function should run efficiently for arrays up to 10^5 elements. # Scenario Consider you are working on a data cleaning task where you have a list of items that could contain duplicates due to some processing error. You need to ensure all elements in the list are unique while maintaining the original insertion order. Implement this functionality as described above.","solution":"from typing import List, Any def remove_duplicates(array: List[Any]) -> List[Any]: Removes duplicates from the array while maintaining the order of elements. Parameters: array (List[Any]): The input list containing elements which may have duplicates. Returns: List[Any]: A list with all duplicates removed and the original order preserved. seen = set() unique_array = [] for element in array: if element not in seen: seen.add(element) unique_array.append(element) return unique_array"},{"question":"You are tasked with optimizing the recursive binomial coefficient algorithm. To handle larger inputs efficiently and avoid deep recursion, implement an iterative version of the binomial coefficient calculator, using memoization to store intermediate results. Implement a function `iterative_binomial_coefficient(n, k)` that computes the binomial coefficient C(n, k) using an iterative approach. Your solution should: 1. Leverage the same core principles as the provided recursive version. 2. Avoid deep recursion for large values of n and k. 3. Utilize memoization for efficient computation of intermediate results. # Input - `n`: a non-negative integer `n` (0 <= n <= 1000). - `k`: a non-negative integer `k` (0 <= k <= n). # Output - A single integer representing the binomial coefficient C(n, k). # Constraints - 0 <= n <= 1000 - 0 <= k <= n # Example - `iterative_binomial_coefficient(5, 0)` should return `1` - `iterative_binomial_coefficient(8, 2)` should return `28` - `iterative_binomial_coefficient(500, 300)` should return a large integer value without overflow. # Performance Requirements - Your solution should efficiently handle large values of n and k within the given constraints. - Time Complexity: O(n * k) - Space Complexity: O(k)","solution":"def iterative_binomial_coefficient(n, k): Computes the binomial coefficient C(n, k) using an iterative approach with memoization. if k > n: return 0 if k == 0 or k == n: return 1 k = min(k, n - k) C = [0] * (k + 1) C[0] = 1 for i in range(1, n + 1): for j in range(min(i, k), 0, -1): C[j] += C[j - 1] return C[k]"},{"question":"# Binary Search Tree Enhancement You are provided with a basic implementation of a Binary Search Tree (BST) with common operations such as insertion, searching, calculating tree size, and tree traversal (preorder, inorder, postorder). Your task is to enhance the BST implementation by adding a `delete` operation. # Objective Implement an additional method `delete()` in the `BST` class that allows for deleting a node with a given value while maintaining the BST properties. # Function Specification **delete(self, data: int) -> bool**: - **Input**: An integer `data` that represents the value to be deleted from the BST. - **Output**: Return `True` if the node with the given value was successfully deleted. Otherwise, return `False` if no such node exists. - **Constraints**: * If the node to be deleted has no children, remove it directly. * If the node to be deleted has one child, replace it with its child. * If the node to be deleted has two children, replace it with its in-order successor (smallest node in its right subtree). # Example: Assume initial BST is: ``` 10 / 6 15 / / 4 9 12 24 / / 7 20 30 / 18 ``` 1. `delete(15)` will remove 15 and replace it with 18: 2. `delete(9)` will remove 9 and 7 becomes the new child of 6: 3. `delete(4)` will just remove 4: # Testing: Extend the provided `TestSuite` class with appropriate test cases for the `delete()` method to ensure the correctness of your implementation.","solution":"class TreeNode: def __init__(self, data): self.data = data self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, data): if not self.root: self.root = TreeNode(data) else: self._insert(self.root, data) def _insert(self, node, data): if data < node.data: if not node.left: node.left = TreeNode(data) else: self._insert(node.left, data) elif data > node.data: if not node.right: node.right = TreeNode(data) else: self._insert(node.right, data) def search(self, data): return self._search(self.root, data) def _search(self, node, data): if not node: return False if data == node.data: return True elif data < node.data: return self._search(node.left, data) else: return self._search(node.right, data) def inorder(self): return self._inorder(self.root, []) def _inorder(self, node, acc): if node: self._inorder(node.left, acc) acc.append(node.data) self._inorder(node.right, acc) return acc def delete(self, data): self.root, deleted = self._delete(self.root, data) return deleted def _delete(self, node, data): if not node: return node, False if data < node.data: node.left, deleted = self._delete(node.left, data) elif data > node.data: node.right, deleted = self._delete(node.right, data) else: if not node.left: return node.right, True elif not node.right: return node.left, True min_larger_node = self._get_min(node.right) node.data = min_larger_node.data node.right, _ = self._delete(node.right, min_larger_node.data) return node, True return node, deleted def _get_min(self, node): current = node while current.left is not None: current = current.left return current"},{"question":"# Context A priority queue is an abstract data type similar to a regular queue or stack data structure in which each element additionally has a \\"priority\\" associated with it. In a priority queue, an element with high priority is served before an element with low priority. A common way to implement a priority queue is using a binary min-heap, where the least element is given the highest priority. # Problem Statement You are given an implementation of a binary min-heap. Your task is to complete the `BinaryHeap` class by implementing two additional functionalities – `heap_sort` and `build_heap` that will utilize the existing methods of the `BinaryHeap` class. # Function Definitions 1. **heap_sort(self)**: - Sorts the elements in the binary heap in ascending order and returns the sorted list. This should use the `remove_min` method to remove the smallest elements until the heap is empty. - **Input**: No input arguments. - **Output**: Returns a list of elements sorted in ascending order. 2. **build_heap(self, item_list)**: - Constructs a binary heap from a given list of elements by inserting the elements into the heap in a way that the heap is efficiently constructed (not simply by calling insert repeatedly but by efficiently building the heap, which improves performance). - **Input**: A list of integers `item_list`. - **Output**: Modifies the `BinaryHeap` class\'s internal structure to represent a min-heap of the given elements. # Example ```python bh = BinaryHeap() bh.build_heap([9, 5, 6, 2, 3]) sorted_list = bh.heap_sort() print(sorted_list) # Output should be [2, 3, 5, 6, 9] ``` # Constraints - The input list for `build_heap` can contain up to 10^4 elements. - All elements in the input list will be integers within the range [-10^6, 10^6]. # Code Template Below is the code template. Complete the `heap_sort` and `build_heap` methods in the `BinaryHeap` class: ```python class BinaryHeap: def __init__(self): self.current_size = 0 self.heap = [(0)] def perc_up(self, i): while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i // 2] = self.heap[i // 2], self.heap[i] i = i // 2 def insert(self, val): self.heap.append(val) self.current_size += 1 self.perc_up(self.current_size) def min_child(self, i): if 2 * i + 1 > self.current_size: return 2 * i if self.heap[2 * i] > self.heap[2 * i + 1]: return 2 * i + 1 return 2 * i def perc_down(self, i): while 2 * i <= self.current_size: min_child = self.min_child(i) if self.heap[min_child] < self.heap[i]: self.heap[min_child], self.heap[i] = self.heap[i], self.heap[min_child] i = min_child def remove_min(self): ret_val = self.heap[1] self.heap[1] = self.heap[self.current_size] self.current_size -= 1 self.heap.pop() self.perc_down(1) return ret_val def heap_sort(self): # Implement this method pass def build_heap(self, item_list): # Implement this method pass ```","solution":"class BinaryHeap: def __init__(self): self.current_size = 0 self.heap = [0] def perc_up(self, i): while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i // 2] = self.heap[i // 2], self.heap[i] i = i // 2 def insert(self, val): self.heap.append(val) self.current_size += 1 self.perc_up(self.current_size) def min_child(self, i): if 2 * i + 1 > self.current_size: return 2 * i if self.heap[2 * i] > self.heap[2 * i + 1]: return 2 * i + 1 return 2 * i def perc_down(self, i): while 2 * i <= self.current_size: min_child = self.min_child(i) if self.heap[min_child] < self.heap[i]: self.heap[min_child], self.heap[i] = self.heap[i], self.heap[min_child] i = min_child def remove_min(self): if self.current_size == 0: return None ret_val = self.heap[1] self.heap[1] = self.heap[self.current_size] self.current_size -= 1 self.heap.pop() if self.current_size > 0: self.perc_down(1) return ret_val def heap_sort(self): sorted_list = [] while self.current_size > 0: sorted_list.append(self.remove_min()) return sorted_list def build_heap(self, item_list): self.current_size = len(item_list) self.heap = [0] + item_list[:] i = self.current_size // 2 while i > 0: self.perc_down(i) i -= 1"},{"question":"Given the following problem statement and function signature, implement the function `intersection` that identifies the intersection node of two singly linked lists, if any. # Problem Statement You are given two singly linked lists that merge at some point into a single list. Your task is to identify and return the node at which the two linked lists intersect. If there is no intersection, return `None`. # Function Signature ```python class Node(object): def __init__(self, val=None): self.val = val self.next = None def intersection(h1: Node, h2: Node) -> Node: # Your code here pass ``` # Input - `h1` and `h2` are the heads of two singly linked lists. # Output - Return the node where the two linked lists intersect. If there is no intersection, return `None`. # Constraints - The list may contain up to 10^5 nodes. - Do not modify the list nodes. - The lists are non-cyclic and do not overlap other than at the intersection. # Example ```python a1 = Node(1) b1 = Node(3) c1 = Node(5) d = Node(7) a2 = Node(2) b2 = Node(4) c2 = Node(6) e = Node(9) f = Node(11) a1.next = b1 b1.next = c1 c1.next = d a2.next = b2 b2.next = c2 c2.next = d d.next = e e.next = f result = intersection(a1, a2) assert result.val == 7 # Point of intersection ``` # Explanation - The node with value `7` is where the linked lists intersect. - Ensure to handle edge cases like no intersection or an empty list. # Notes - Be mindful of the time complexity and ensure the solution operates in linear time. - The space complexity should be minimal, ideally O(1). Good luck and happy coding!","solution":"class Node(object): def __init__(self, val=None): self.val = val self.next = None def get_length(head: Node) -> int: Helper function to calculate the length of a linked list starting from head. length = 0 current = head while current: length += 1 current = current.next return length def intersection(h1: Node, h2: Node) -> Node: Function to find the intersection point of two singly linked lists. if not h1 or not h2: return None # Calculate the lengths of both linked lists len1 = get_length(h1) len2 = get_length(h2) # Align both pointers to the same starting point if len1 > len2: for _ in range(len1 - len2): h1 = h1.next else: for _ in range(len2 - len1): h2 = h2.next # Traverse both lists together to find the intersection point while h1 and h2: if h1 == h2: return h1 h1 = h1.next h2 = h2.next return None"},{"question":"Scenario You are tasked with optimizing a crucial function for analyzing text to find unique identifiers efficiently. Your current solution has performance issues with large datasets, and you need to improve it to handle bigger inputs effectively. Problem Statement Write a function `first_unique_char` that identifies the index of the first non-repeating character in a given string. If no unique character exists, return -1. Optimize your solution to handle large strings efficiently. Function Signature ```python def first_unique_char(s: str) -> int: pass ``` Input and Output * **Input**: - `s`: A non-null string (0 ≤ length of s ≤ 10^5). * **Output**: - Return an integer representing the index of the first non-repeating character or -1 if none exists. Constraints * Characters in the string are lowercase English letters. * The function should run in O(n) time complexity. Examples 1. Input: `s = \\"leetcode\\"` Output: `0` 2. Input: `s = \\"loveleetcode\\"` Output: `2` 3. Input: `s = \\"aabbcc\\"` Output: `-1` 4. Input: `s = \\"\\"` Output: `-1` Explanation - In the first example, the character \'l\' appears only once and is the first such character, so its index (0) is returned. - In the second example, \'v\' is the first non-repeating character at index 2. - In the third example, all characters repeat, so -1 is returned. - For the empty string, there are no characters to check; hence -1 is returned. Good luck! Optimize your implementation to ensure efficiency.","solution":"def first_unique_char(s: str) -> int: This function returns the index of the first non-repeating character in the given string `s`. If no unique character exists, return -1. from collections import Counter # Step 1: Create a counter for all characters in the string char_count = Counter(s) # Step 2: Iterate through the string and find the index of the first non-repeating character for index, char in enumerate(s): if char_count[char] == 1: return index # Step 3: If no unique character is found, return -1 return -1"},{"question":"# Question: Binary Tree Preorder Traversal Objective Implement both iterative and recursive functions that perform a preorder traversal on a binary tree and return the sequence of node values in a list. Scenario Imagine you are creating a system that records the hierarchy and sequence of tasks for a project management tool. Tasks are structured in a hierarchical manner. Given the root of this hierarchy represented as a binary tree, you need to retrieve the tasks in the order they should be worked on, which follows a preorder traversal sequence: process the current task, then process all subtasks in the left subtree, followed by all subtasks in the right subtree. Requirements 1. **Function**: `preorder(root: Node) -> List[int]` - **Input**: A binary tree represented by its root node `root`. - **Output**: A list of integer values representing the preorder traversal sequence of the tree. 2. **Function**: `preorder_rec(root: Node) -> List[int]` - **Input**: Same as above. - **Output**: Same as above. Constraints * The number of nodes in the tree is at most 10000. * Node values are unique integers. * Assume class `Node` is already defined as per the provided code snippet. * For iterative approach, do not exceed O(n) additional space. Example Given the binary tree: ``` 1 / 2 3 / 4 5 ``` * The result for both `preorder` and `preorder_rec` should be `[1, 2, 4, 5, 3]`. Code Snippet ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right # Implement the following functions def preorder(root: Node) -> List[int]: pass def preorder_rec(root: Node, res=None) -> List[int]: pass ```","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def preorder(root: Node) -> list: Iterative preorder traversal of a binary tree. if root is None: return [] stack = [root] result = [] while stack: node = stack.pop() result.append(node.val) if node.right: stack.append(node.right) if node.left: stack.append(node.left) return result def preorder_rec(root: Node, res=None) -> list: Recursive preorder traversal of a binary tree. if res is None: res = [] if root: res.append(root.val) preorder_rec(root.left, res) preorder_rec(root.right, res) return res"},{"question":"# Dynamic Programming: Coin Change Problem Problem Statement You are given a set of coin denominations and an integer value. Write a function `count(coins, value)` that returns the number of ways to make up that value using the given coin denominations. Each denomination can be used an unlimited number of times. Input - `coins`: A list of integers representing coin denominations (e.g., `[1, 2, 3]`). - `value`: An integer representing the target value to be made up using the coin denominations. Output - An integer representing the number of ways to make up the given value using the provided coin denominations. Constraints - All elements in `coins` are positive integers. - The `value` is a non-negative integer. - There is an infinite supply of each coin denomination. Example 1. **Input**: - `coins = [1, 2, 3]` - `value = 4` **Output**: `4` **Explanation**: There are four ways to make change for 4 using the coins `[1, 2, 3]`: `[1, 1, 1, 1]`, `[1, 1, 2]`, `[2, 2]`, and `[1, 3]`. 2. **Input**: - `coins = [2, 5, 3, 6]` - `value = 10` **Output**: `5` **Explanation**: There are five ways to make change for 10 using the coins `[2, 5, 3, 6]`: `[2, 2, 2, 2, 2]`, `[2, 2, 3, 3]`, `[2, 2, 6]`, `[2, 3, 5]`, and `[5, 5]`. Implementation Challenge Implement the function `count(coins, value)` in Python. Make sure to consider edge cases such as when the value is zero or when no coins are given. ```python def count(coins, value): Find number of combination of `coins` that adds up to `value` Keyword arguments: coins -- List[int] value -- int Return: int # Complete the implementation here ``` Additional Requirements: - Your solution should have a time complexity of O(n * m), and space complexity of O(n), where `n` is the target value and `m` is the number of different coin denominations.","solution":"def count(coins, value): Returns the number of ways to make the given value using the provided coin denominations. Parameters: coins (list): List of positive integers representing coin denominations. value (int): Target value to be made up using the coin denominations. Returns: int: Number of ways to make up the given value using the provided coin denominations. # Create a list to store the number of ways to make each value dp = [0] * (value + 1) # There is one way to make the value 0 (using no coins) dp[0] = 1 # Iterate over each coin denomination for coin in coins: # Update the dp list for all values greater than or equal to the coin\'s value for i in range(coin, value + 1): dp[i] += dp[i - coin] return dp[value]"},{"question":"You are tasked with implementing a function `binary_search` that performs a binary search on a sorted list of integers. The function should take two inputs: a sorted list of integers and an integer target value to search for. If the target value is found in the list, the function should return its index. If it\'s not found, the function should return -1. In addition to implementing the function, analyze and explain the time complexity of your solution. Function Signature ```python def binary_search(nums: List[int], target: int) -> int: ``` Input - `nums` (List[int]): A list of integers sorted in ascending order. - `target` (int): The integer value to search for. Output - (int): The index of the target value if found; otherwise, -1. Constraints - The length of `nums` will be between 1 and 10^4. - The integers in `nums` will be in the range of -10^4 to 10^4. - `target` will be an integer in the range of -10^4 to 10^4. Performance Requirements - Your implementation should aim for **O(log n)** time complexity due to the nature of binary search. Example ```python assert binary_search([1, 2, 3, 4, 5], 3) == 2 assert binary_search([1, 2, 3, 4, 5], 6) == -1 assert binary_search([-10, -5, 0, 5, 10, 15], -5) == 1 ``` # Scenario You\'ve been hired to implement a component of a larger search engine that frequently needs to check the availability of a target value within a large dataset of sorted integers. Efficient and accurate searching is critical for the performance of the search engine. Assessing your ability to implement the binary search algorithm will help ensure that the search engine performs optimally.","solution":"from typing import List def binary_search(nums: List[int], target: int) -> int: Performs a binary search on a sorted list of integers. Args: nums (List[int]): A sorted list of integers. target (int): The integer value to search for. Returns: int: The index of the target value if found; otherwise, -1. left, right, = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return -1 # Time Complexity: O(log n) # The binary search algorithm divides the range of the list in half every iteration, # leading to a logarithmic time complexity."},{"question":"**Graph Path Detection Using Depth-First Search (DFS)** Context: You are working on a navigation system that needs to determine if there is a path between two points in a network of roads. The road network is represented as a directed graph where intersections are nodes, and roads are directed edges. Given a starting point (source) and a destination (target), your task is to determine if there exists a path between these two points using the DFS algorithm. Task: Implement the `Graph`, `add_edge`, and `is_reachable` methods which utilize Depth-First Search to determine if there is a path between two given nodes in a directed graph. # Requirements: 1. **Graph Class**: * The `Graph` class should be initialized with the number of vertices (`vertex_count`), and should use an adjacency list to represent edges. 2. **add_edge Method**: * Should accept two parameters: `source` and `target`, indicating a directed edge from `source` to `target`. 3. **is_reachable Method**: * Should accept two parameters: `source` and `target`, and return `True` if there\'s a path from `source` to `target`, otherwise `False`. ```python from collections import defaultdict class Graph: def __init__(self, vertex_count): self.vertex_count = vertex_count self.graph = defaultdict(list) def add_edge(self, source, target): self.graph[source].append(target) def is_reachable(self, source, target): # To be implemented ``` # Constraints: * 1 <= `vertex_count` <= 10^4 * 0 <= source, target < `vertex_count` # Example: ```python g = Graph(4) g.add_edge(0, 1) g.add_edge(0, 2) g.add_edge(1, 2) g.add_edge(2, 0) g.add_edge(2, 3) g.add_edge(3, 3) print(g.is_reachable(1, 3)) # Expected Output: True print(g.is_reachable(3, 1)) # Expected Output: False ``` # Evaluation Criteria: Your implementation will be evaluated based on: * Correctness: Whether the `is_reachable` function correctly determines the existence of a path. * Efficiency: The time and space complexity relative to the input size. * Code Quality: Cleanliness, readability, and proper use of data structures. **Note**: Do not use any built-in library functions that perform graph traversal. Implement the logic from scratch.","solution":"from collections import defaultdict class Graph: def __init__(self, vertex_count): self.vertex_count = vertex_count self.graph = defaultdict(list) def add_edge(self, source, target): self.graph[source].append(target) def is_reachable(self, source, target): visited = [False] * self.vertex_count return self._dfs(source, target, visited) def _dfs(self, current, target, visited): if current == target: return True visited[current] = True for neighbor in self.graph[current]: if not visited[neighbor]: if self._dfs(neighbor, target, visited): return True return False"},{"question":"# Question You are given two functions, `combination(n, r)` and `combination_memo(n, r)`, which calculate the number of ways to choose `r` items from `n` items (`nCr` or \\"n choose r\\") recursively. `combination_memo` uses memoization to enhance performance by storing intermediate results. Using the insights from these functions, write a new function called `combination_iterative(n, r)` that calculates `nCr` iteratively. This function should avoid recursion and memoization, aiming for better space efficiency. Input - Two integers `n` and `r` where `0 <= r <= n`. Output - An integer representing the number of ways to choose `r` items from `n` items. Constraints - The maximum value of `n` or `r` will not exceed 1000. Performance Requirements - The solution should have a time complexity of `O(n * r)` and a space complexity of `O(r)`. # Example ```python >>> combination_iterative(5, 2) 10 >>> combination_iterative(10, 3) 120 >>> combination_iterative(6, 0) 1 >>> combination_iterative(6, 6) 1 ``` Task Implement the function `combination_iterative(n, r)` to compute `nCr` iteratively: ```python def combination_iterative(n, r): # Your code here ```","solution":"def combination_iterative(n, r): Calculate nCr iteratively. Args: n (int): the total number of items. r (int): the number of items to choose. Returns: int: the number of ways to choose `r` items from `n` items. if r > n: return 0 if r == 0 or r == n: return 1 # Using the property nCr = nC(n-r), we take the smaller value r = min(r, n - r) # Create a list to store the current state\'s values for combinations C = [0] * (r + 1) C[0] = 1 for i in range(1, n + 1): for j in range(min(i, r), 0, -1): C[j] += C[j - 1] return C[r]"},{"question":"# Question: Implement Serialize and Deserialize Binary Tree Given the fundamental concepts and implementation provided above, your task is to create a similar implementation for a different tree traversal method. Specifically, implement serialization and deserialization using **level-order traversal** instead of pre-order traversal. # Requirements: Serialization: - The function `serialize(root)` should take the root of a binary tree and return a string representation in level-order traversal. - For null nodes, use the marker `\\"#\\"`. Deserialization: - The function `deserialize(data)` should take a level-order serialized string and reconstruct the binary tree, returning the root node. # Input and Output Formats: **Serialize:** - Input: A `TreeNode` root - Output: A string that represents the serialized binary tree **Deserialize:** - Input: A string representing a binary tree in level-order serialization - Output: A `TreeNode` which is the root of the restored binary tree # Constraints: - The number of nodes in the tree could be up to 10^4. - The node values will be in the range [-10^5, 10^5]. # Example: **Input:** ``` 1 / 2 3 / 4 5 ``` **Serialize Output:** ``` \\"1 2 3 # # 4 5 # # # #\\" ``` **Deserialize Input:** ``` \\"1 2 3 # # 4 5 # # # #\\" ``` **Output:** ``` Returns the root of the original tree. ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root): if not root: return \\"\\" from collections import deque queue = deque([root]) result = [] while queue: node = queue.popleft() if node: result.append(str(node.val)) queue.append(node.left) queue.append(node.right) else: result.append(\\"#\\") return \\" \\".join(result) def deserialize(data): if not data: return None nodes = data.split() root = TreeNode(int(nodes[0])) from collections import deque queue = deque([root]) i = 1 while queue: node = queue.popleft() if nodes[i] != \\"#\\": node.left = TreeNode(int(nodes[i])) queue.append(node.left) i += 1 if nodes[i] != \\"#\\": node.right = TreeNode(int(nodes[i])) queue.append(node.right) i += 1 return root"},{"question":"# Binary Exponentiation Function Implementation You are asked to implement a function that computes the result of a number raised to a power efficiently using binary exponentiation. The function should have the option to compute the result modulo a given number. Function Signature ```python def efficient_power(base: int, exponent: int, modulus: int = None) -> int: Calculate base ^ exponent efficiently using binary exponentiation. :param base: The base number, an integer. :param exponent: The exponent, a non-negative integer. :param modulus: An optional modulus to compute the power with, an integer. :return: The result of (base ^ exponent) if modulus is None, otherwise (base ^ exponent) % modulus. :raises: ValueError if the exponent is negative. pass ``` Input - `base`: an integer specifying the base number. - `exponent`: a non-negative integer specifying the exponent. - `modulus`: an optional integer specifying the modulus. Output - An integer resulting from the operation base raised to the exponent, optionally modulo the given modulus. Example ```python assert efficient_power(2, 10) == 1024 assert efficient_power(2, 10, 1000) == 24 assert efficient_power(3, -1) # Raise ValueError ``` Constraints * The exponent will be a non-negative integer. * The modulus, if provided, will be a positive integer. Performance Requirements The function should run in O(log(n)) time complexity and O(1) space complexity for moderately large exponent values (up to 10^18), adhering to efficient use of both time and space.","solution":"def efficient_power(base: int, exponent: int, modulus: int = None) -> int: Calculate base ^ exponent efficiently using binary exponentiation. :param base: The base number, an integer. :param exponent: A non-negative integer. :param modulus: An optional modulus to compute the power with, an integer. :return: The result of (base ^ exponent) if modulus is None, otherwise (base ^ exponent) % modulus. :raises: ValueError if the exponent is negative. if exponent < 0: raise ValueError(\\"Exponent should be a non-negative integer\\") result = 1 base = base % modulus if modulus else base while exponent > 0: if exponent % 2: # If exponent is odd, multiply result by base result = (result * base) % modulus if modulus else result * base base = (base * base) % modulus if modulus else base * base exponent //= 2 # Divide exponent by 2 return result"},{"question":"Scenario You are working on a messaging system where you need to send lists of strings over a network. However, the network transmission protocol requires you to encode the list of strings into a single string and decode it back to the original list upon receipt. Task Implement the `encode` and `decode` methods for the following interface: ```python def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str pass def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] pass ``` Input and Output Formats * `encode` * **Input**: A list of strings, `strs` (e.g., `[\\"hello\\", \\"world\\"]`). * **Output**: A single string representing the encoded list (e.g., `\\"5:hello5:world\\"`). * `decode` * **Input**: An encoded string, `s` (e.g., `\\"5:hello5:world\\"`). * **Output**: A list of strings decoded from this single string (e.g., `[\\"hello\\", \\"world\\"]`). Constraints * The list of strings and the strings themselves may contain special characters and be of varying lengths. * You may assume that the input strings will not contain the delimiter `\\":\\"` for this basic implementation. Requirements * Ensure your implementation correctly handles edge cases such as empty input (`[]`), single string lists, and varying string lengths. * Aim for O(N) time complexity for both encoding and decoding methods where N is the total length of all characters in the list. Example ```python encode([\\"hello\\", \\"world\\"]) -> \\"5:hello5:world\\" decode(\\"5:hello5:world\\") -> [\\"hello\\", \\"world\\"] ```","solution":"def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str encoded_string = \'\' for s in strs: encoded_string += f\'{len(s)}:{s}\' return encoded_string def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] decoded_strings = [] i = 0 while i < len(s): # Find the separator \':\' j = i while s[j] != \':\': j += 1 length = int(s[i:j]) decoded_strings.append(s[j+1:j+1+length]) i = j + 1 + length return decoded_strings"},{"question":"Context: You are given a conceptual infinite sequence formed by concatenating all positive integers in ascending order: \\"1234567891011121314151617181920...\\". Your task is to find the nth digit in this sequence. Task: Implement a function `find_nth_digit(n)` that will return the nth digit in this infinite sequence. Function Signature: ```python def find_nth_digit(n: int) -> int: ``` Parameters: - `n` (int): The position of the digit to find in the infinite sequence (1-based index, `1 <= n <= 2^31 - 1`). Returns: - `int`: The digit at the nth position of the sequence. Example: ```python find_nth_digit(3) # Output: 3 (The sequence is \\"123...\\", so the third digit is \'3\'). find_nth_digit(11) # Output: 0 (The sequence is \\"12345678910112...\\", so the 11th digit is \'0\'). ``` Constraints: - The function should handle large input values efficiently, considering the constraints of time and space complexity. - Ensure that the function is optimized to handle the upper limit of n without excessive time delay or memory usage. Explanation: The sequence is constructed by concatenating all positive integers. For example, the sequence starts as \\"1234567891011121314...\\". Using this understanding, identify the range and exact number for the nth digit, and return the appropriate digit. Notes: - Think about how to skip over large chunks of the sequence by digits instead of generating the entire sequence. - Ensure handling of edge cases and large inputs effectively.","solution":"def find_nth_digit(n: int) -> int: digit_length = 1 count = 9 start = 1 # Find the range that \'n\' falls into. while n > digit_length * count: n -= digit_length * count digit_length += 1 count *= 10 start *= 10 # Find the exact number where the nth digit is located. num = start + (n - 1) // digit_length # Find the exact digit in the number. digit_index = (n - 1) % digit_length result_digit = str(num)[digit_index] return int(result_digit)"},{"question":"# Scenario: You have been tasked with managing the queue system of a hospital emergency room, where patients are treated based on the severity of their condition. Implement a class `ERPriorityQueue` using a min binary heap to ensure that the patient with the most severe condition is treated first. Each patient is added with a severity level, and you must always efficiently fetch and remove the patient with the highest severity (indicated by the lowest severity number). # Requirements: 1. Implement `insert(patient_name: str, severity: int)` method to add a new patient. 2. Implement `treat_next_patient() -> str` method to remove and fetch the patient with the highest severity. 3. Ensure your implementation manages edge cases and maintains the efficiency properties of the heap. Input Format: - The `insert` method receives: - `patient_name` (string): Name of the patient. - `severity` (integer): The severity level of the patient\'s condition. - The `treat_next_patient` method returns: - `patient_name` (string): Name of the treated patient. Constraints: - `1 <= severity <= 10^6` - Patient names are alphanumeric strings. Example Usage: ```python er_queue = ERPriorityQueue() er_queue.insert(\\"Alice\\", 5) er_queue.insert(\\"Bob\\", 2) er_queue.insert(\\"Charlie\\", 3) print(er_queue.treat_next_patient()) # Output: \\"Bob\\" print(er_queue.treat_next_patient()) # Output: \\"Charlie\\" print(er_queue.treat_next_patient()) # Output: \\"Alice\\" ``` # Performance Requirements: 1. Insertion of a patient and treatment of the next patient should be handled in O(log N) time complexity. 2. Ensure the space efficiency of your class implementation. Implement the `ERPriorityQueue` class and its methods as described.","solution":"import heapq class ERPriorityQueue: def __init__(self): self.heap = [] def insert(self, patient_name: str, severity: int): # Using a heap tuple (severity, patient_name) to maintain the min heap property heapq.heappush(self.heap, (severity, patient_name)) def treat_next_patient(self) -> str: if not self.heap: raise IndexError(\\"No patients to treat.\\") severity, patient_name = heapq.heappop(self.heap) return patient_name"},{"question":"# ZigZag Iterator for Multiple Lists You are required to implement a ZigZag Iterator that can handle an arbitrary number of input lists. The iterator should alternate between elements of these lists such that elements are retrieved in a round-robin fashion until all lists are exhausted. # Function Implementations Implement the following methods in the ZigZag Iterator class: 1. `__init__(self, lists: List[List[int]])`: - Constructor takes a list of lists `lists`. 2. `next(self) -> int`: - Returns the next element in the ZigZag order. - Raises an exception if there are no more elements. 3. `has_next(self) -> bool`: - Returns `True` if there are more elements to iterate, `False` otherwise. # Input and Output Formats Input The input consists of a single list of lists: - Each sublist contains integers representing the elements of that list. Output - Directly print the integers returned by the `next` method. - The iteration continues until `has_next` returns `False`. # Example Scenario ```python lists = [[1, 2, 3], [4, 5, 6, 7], [8, 9]] it = ZigZagIterator(lists) while it.has_next(): print(it.next()) ``` This should output: ``` 1 4 8 2 5 9 3 6 7 ``` # Constraints - Each inner list contains integers within the range [1, 10^9]. - The number of lists, k, is such that 1 <= k <= 1000. - The total number of elements across all lists does not exceed 10^5. # Performance Requirements - Ensure that each call to `next` and `has_next` is efficient and maintains O(1) complexity where possible.","solution":"from collections import deque class ZigZagIterator: def __init__(self, lists): Initialize your data structure here. :type lists: List[List[int]] self.queue = deque() for lst in lists: if lst: self.queue.append(deque(lst)) def next(self): :rtype: int if not self.has_next(): raise Exception(\\"No more elements.\\") curr_list = self.queue.popleft() value = curr_list.popleft() if curr_list: self.queue.append(curr_list) return value def has_next(self): :rtype: bool return bool(self.queue)"},{"question":"Linear Search Enhancements **Context**: You are working on a project where you need to locate specific records in a large dataset. Given the basic nature of linear search, you want to build an enhanced version of linear search with additional requirements to make it more robust and informative. **Objective**: Implement an enhanced linear search function that not only returns the index of the target element but also provides information on specific edge cases and performance metrics after running the search. # Requirements 1. **Function Name**: `enhanced_linear_search` 2. **Inputs**: * `array`: A list of elements (e.g., integers). * `query`: The element to search for in the array. 3. **Outputs**: * A dictionary with the following fields: * **index**: The index of the first occurrence of the query in the array, or -1 if not found. * **found**: A boolean indicating whether the query was found in the array. * **checkedElements**: The number of elements checked until a match was found or until the end of the array. * **isEmpty**: A boolean indicating if the input array was empty. 4. **Constraints**: * The input `array` can contain any number of elements including zero. * The input `array` can contain any type of elements that are comparable to the `query`. 5. **Performance**: * Aim to maintain O(n) time complexity. * Ensure O(1) space complexity, apart from the input and output data. # Example Usage ```python def enhanced_linear_search(array, query): # Your implementation here # Example test cases print(enhanced_linear_search([5, 1, 2, 9, 5], 9)) # Output: {\'index\': 3, \'found\': True, \'checkedElements\': 4, \'isEmpty\': False} print(enhanced_linear_search([], 9)) # Output: {\'index\': -1, \'found\': False, \'checkedElements\': 0, \'isEmpty\': True} print(enhanced_linear_search([5, 1, 2, 9, 5], 7)) # Output: {\'index\': -1, \'found\': False, \'checkedElements\': 5, \'isEmpty\': False} ``` # Constraints * You should not use any additional libraries or built-in functions other than those needed for basic list operations. **Your task**: Implement the `enhanced_linear_search` function in Python that meets the above requirements.","solution":"def enhanced_linear_search(array, query): Perform a linear search on the given array for the query and return a dictionary of results. Args: array (list): The list of elements to search. query (any): The element to search for in the array. Returns: dict: A dictionary with results of the search. result = { \'index\': -1, \'found\': False, \'checkedElements\': 0, \'isEmpty\': len(array) == 0 } for index, element in enumerate(array): result[\'checkedElements\'] += 1 if element == query: result[\'index\'] = index result[\'found\'] = True break return result"},{"question":"**Problem Statement**: You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each node contains a single digit. Write a function to add the two numbers and return the sum as a linked list. # Function Specification **Function Name**: `add_two_numbers` **Input**: - `left` (Node): The head of the first linked list. - `right` (Node): The head of the second linked list. **Output**: - `Node`: The head of the linked list representing the sum of the two numbers. # Example Input/Output 1. **Example 1**: - Input: `(2 -> 4 -> 3) + (5 -> 6 -> 4)` - Output: `7 -> 0 -> 8` - Explanation: 342 + 465 = 807 (digits in reverse order). 2. **Example 2**: - Input: `(1 -> 8) + (0)` - Output: `1 -> 8` - Explanation: 81 + 0 = 81 (digits in reverse order). # Constraints - The input linked lists will not be null and will not contain any leading zeros except the number 0 itself. - You are not allowed to use any built-in big integer libraries. - Try to optimize the space complexity as best as you can. # Scenario Imagine you are developing a large-scale numerical computation library intended to handle operations on huge integers. Some of your users need the ability to work with such numbers as linked lists due to memory limitations in their environment. This function is a foundational operation in your library. # Additional Notes * Ensure your function is efficient and robust against edge cases like different lengths of input linked lists, carry overflows, and null lists. * Focus on clarity of implementation and thorough handling of all potential edge cases.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def add_two_numbers(left: ListNode, right: ListNode) -> ListNode: dummy_head = ListNode(0) current, carry = dummy_head, 0 while left or right or carry: left_val = left.val if left else 0 right_val = right.val if right else 0 total = left_val + right_val + carry carry = total // 10 current.next = ListNode(total % 10) current = current.next if left: left = left.next if right: right = right.next return dummy_head.next"},{"question":"Implement Basic Operations for a Binary Search Tree Scenario You have been tasked with implementing a Binary Search Tree (BST) for a company’s real-time data processing needs. The BST should support insert, search, and delete operations efficiently. Task Implement a `BST` class with the following methods: 1. `insert(val: int) -> None`: Insert a value into the BST. 2. `search(val: int) -> bool`: Search for a value in the BST. Return `True` if the value exists, otherwise `False`. 3. `delete(val: int) -> None`: Delete a value from the BST. Input/Output Format 1. **Insert** * **Input**: An integer `val` to insert. * **Output**: None. Modifies the tree structure. 2. **Search** * **Input**: An integer `val` to search. * **Output**: `True` if the value exists in the BST, otherwise `False`. 3. **Delete** * **Input**: An integer `val` to delete. * **Output**: None. Modifies the tree structure by removing the specified node. Constraints - All operations must have an average time complexity of O(log n). Example ```python bst = BST() bst.insert(5) bst.insert(3) bst.insert(7) assert bst.search(3) == True assert bst.search(4) == False bst.delete(3) assert bst.search(3) == False ``` Provide the implementation for the BST class.","solution":"class TreeNode: def __init__(self, val): self.val = val self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, val: int) -> None: if self.root is None: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node, val): if val < node.val: if node.left is None: node.left = TreeNode(val) else: self._insert(node.left, val) else: if node.right is None: node.right = TreeNode(val) else: self._insert(node.right, val) def search(self, val: int) -> bool: return self._search(self.root, val) def _search(self, node, val): if not node: return False if node.val == val: return True elif val < node.val: return self._search(node.left, val) else: return self._search(node.right, val) def delete(self, val: int) -> None: self.root = self._delete(self.root, val) def _delete(self, node, val): if not node: return node if val < node.val: node.left = self._delete(node.left, val) elif val > node.val: node.right = self._delete(node.right, val) else: if not node.left: return node.right elif not node.right: return node.left min_larger_node = self._get_min(node.right) node.val = min_larger_node.val node.right = self._delete(node.right, min_larger_node.val) return node def _get_min(self, node): while node.left: node = node.left return node"},{"question":"Enhanced Selection Sort Problem Statement: You are tasked with enhancing the Selection Sort algorithm to handle various data types and improve its efficiency slightly by incorporating an early termination check. Implement the function `enhanced_selection_sort(arr)` that sorts a given list, `arr`. In addition, the function should check a `verbose` flag. When `verbose` is `True`, it should print each intermediate step of the array after each iteration of the outer loop. Function Signature: ```python def enhanced_selection_sort(arr: List[int], verbose: bool = False) -> List[int]: pass ``` Input: - `arr`: List of integers or floats. The list of elements to be sorted. Example: `[4, 3, 2, 1]` - `verbose`: A boolean flag indicating whether to print the array after every iteration. Defaults to `False`. Output: - The sorted list in ascending order. Constraints: 1. The list can be empty or contain up to `10^4` elements. 2. Elements can be either integers or floating-point numbers. Requirements: 1. Your implementation should perform an in-place sort. 2. Implement an early termination check to optimize performance. 3. Consider edge cases like empty arrays and arrays of one element. 4. If `verbose` is `True`, print the array after every iteration of the outer loop. Example: ```python arr = [64, 25, 12, 22, 11] enhanced_selection_sort(arr, verbose=True) # Expected Output # After iteration 0: [11, 25, 12, 22, 64] # After iteration 1: [11, 12, 25, 22, 64] # After iteration 2: [11, 12, 22, 25, 64] # After iteration 3: [11, 12, 22, 25, 64] # After iteration 4: [11, 12, 22, 25, 64] ```","solution":"def enhanced_selection_sort(arr, verbose=False): Sorts the list `arr` using an enhanced selection sort algorithm. Parameters: - arr: List of integers or floats to be sorted. - verbose: Boolean flag to print intermediate steps of the array after each iteration. Returns: - The sorted list in ascending order. n = len(arr) for i in range(n - 1): min_index = i for j in range(i + 1, n): if arr[j] < arr[min_index]: min_index = j # Swap the found minimum element with the first element of the unsorted part arr[i], arr[min_index] = arr[min_index], arr[i] if verbose: print(f\\"After iteration {i}: {arr}\\") # Early termination check if all(arr[k] <= arr[k + 1] for k in range(n - 1)): break return arr"},{"question":"Generating Permutations Objective Design an efficient solution to generate all possible permutations of a given list of distinct integers. Problem Statement You are given a collection of distinct integers represented as a list. Your task is to write a function `generate_permutations` that returns all possible permutations of the given list. You are expected to handle lists containing up to 9 integers efficiently. Function Signature ```python def generate_permutations(nums: List[int]) -> List[List[int]]: pass ``` Input and Output * **Input**: A list of distinct integers `nums` where `1 <= len(nums) <= 9`. * **Output**: A list of lists, where each list is a unique permutation of `nums`. Constraints * The solution must handle up to 9 integers efficiently due to factorial growth. * The input list contains unique elements only. Example 1. Example 1: * Input: `[1, 2, 3]` * Output: ```python [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] ``` 2. Example 2: * Input: `[0, 1]` * Output: ```python [ [0, 1], [1, 0] ] ``` 3. Example 3: * Input: `[1]` * Output: ```python [ [1] ] ``` Performance Requirements * The implementation should avoid excessive memory usage and must not exceed a reasonable runtime for the input constraint. Scenario Consider a board game with a set of unique tokens. Each player wants to analyze all possible arrangements of their tokens to strategize better. You are tasked with developing an algorithm to generate all possible arrangements for a set of up to 9 tokens. Good luck!","solution":"from typing import List def generate_permutations(nums: List[int]) -> List[List[int]]: Generate all permutations of the input list of distinct integers. :param nums: List[int] - Input list of distinct integers :return: List[List[int]] - List containing all possible permutations of the input list def backtrack(start, end): if start == end: result.append(nums[:]) for i in range(start, end): nums[start], nums[i] = nums[i], nums[start] backtrack(start + 1, end) nums[start], nums[i] = nums[i], nums[start] # backtrack result = [] backtrack(0, len(nums)) return result"},{"question":"You are given a string `s` consisting of lowercase alphabetical characters. Your task is to implement a function that removes any recurring characters while preserving the order of their first appearance, and then returns the new string. # Function Signature ```python def unique_characters(s: str) -> str: pass ``` # Input - `s`: A string (1 ≤ |s| ≤ 10^6), containing lowercase alphabetical characters. # Output - A string containing only the first occurrences of each character from the input string `s`. # Constraints - Time complexity should be O(n), where n is the length of the input string. - Space complexity should also be O(n). # Example ```python assert unique_characters(\\"google\\") == \\"gole\\" assert unique_characters(\\"abcdef\\") == \\"abcdef\\" assert unique_characters(\\"aabbcc\\") == \\"abc\\" assert unique_characters(\\"\\") == \\"\\" ``` # Explanation 1. For the input string \\"google\\", the characters \'o\' and \'l\' each appear more than once, so only their first occurrences are kept, resulting in \\"gole\\". 2. For the input string \\"abcdef\\", all characters are unique, so the result remains \\"abcdef\\". 3. For the input string \\"aabbcc\\", every character is duplicated, so only the first \'a\', first \'b\', and first \'c\' are kept, resulting in \\"abc\\". 4. For an empty string, the result is also an empty string. # Constraints Handling - The function should be able to handle strings as large as 1,000,000 characters efficiently.","solution":"def unique_characters(s: str) -> str: This function removes any recurring characters from the given string `s` while preserving the order of their first appearance. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Coding Challenge: Permutation Generation and Analysis Problem Statement Given a collection of distinct numbers, write a function to return all possible permutations. You need to implement this in three different ways and analyze their performance. Function Signature ```python def generate_permutations(elements: List[int]) -> List[List[int]]: # Your code here def generate_permutations_iter(elements: List[int]) -> Generator[List[int], None, None]: # Your code here def generate_permutations_recursive_dfs(elements: List[int]) -> List[List[int]]: # Your code here ``` Input * `elements` (List[int]): A list of distinct integers. Output * `generate_permutations`: Returns a list of lists, where each inner list is a permutation of the input list. * `generate_permutations_iter`: Returns a generator that yields permutations of the input list one by one. * `generate_permutations_recursive_dfs`: Returns a list of lists, where each inner list is a permutation of the input list using a depth-first search approach. Constraints * The input list `elements` will contain at most 8 integers to ensure manageable computation times. Performance Requirements * Your implementations should handle edge cases, such as empty lists and single-element lists correctly. * Aim to minimize additional memory usage and optimize recursive calls to avoid stack overflow. # Detailed Instructions and Context 1. **Recursive Permutation Generation**: - Implement the function `generate_permutations` using a recursive approach. - Fix one element at a time and recursively generate permutations of the remaining elements. 2. **Iterative Permutation Generation**: - Implement the function `generate_permutations_iter` to use an iterative approach, making use of generators to yield permutations one by one. 3. **Recursive DFS Permutation Generation**: - Implement the function `generate_permutations_recursive_dfs` using a depth-first search approach. - Avoid storing all intermediate results in memory to save space. # Example ```python elements = [1, 2, 3] generate_permutations(elements) # Output: [ # [1, 2, 3], # [1, 3, 2], # [2, 1, 3], # [2, 3, 1], # [3, 1, 2], # [3, 2, 1] # ] for perm in generate_permutations_iter(elements): print(perm) # Output: # [1, 2, 3] # [1, 3, 2] # [2, 1, 3] # [2, 3, 1] # [3, 1, 2] # [3, 2, 1] generate_permutations_recursive_dfs(elements) # Output: [ # [1, 2, 3], # [1, 3, 2], # [2, 1, 3], # [2, 3, 1], # [3, 1, 2], # [3, 2, 1] # ] ```","solution":"from typing import List, Generator def generate_permutations(elements: List[int]) -> List[List[int]]: Returns all possible permutations of a list of distinct integers. if len(elements) <= 1: return [elements] result = [] for i in range(len(elements)): rest = elements[:i] + elements[i+1:] for perm in generate_permutations(rest): result.append([elements[i]] + perm) return result def generate_permutations_iter(elements: List[int]) -> Generator[List[int], None, None]: Iteratively generates all possible permutations of a list of distinct integers. if len(elements) == 0: yield [] else: stack = [(elements, [])] while stack: elems, current_perm = stack.pop() if not elems: yield current_perm for i in range(len(elems)): stack.append((elems[:i] + elems[i+1:], current_perm + [elems[i]])) def generate_permutations_recursive_dfs(elements: List[int]) -> List[List[int]]: Uses a recursive depth-first search (DFS) approach to generate permutations. def dfs(path, remaining, results): if not remaining: results.append(path) for i in range(len(remaining)): dfs(path + [remaining[i]], remaining[:i] + remaining[i+1:], results) results = [] dfs([], elements, results) return results"},{"question":"Euler\'s Totient Function Implementation Write a function `euler_totient_extended` which calculates and returns the values of Euler\'s Totient Function ϕ(n) for all integers from 1 up to ( n ) inclusive. Function Signature ```python def euler_totient_extended(n: int) -> list: pass ``` Input * An integer ( n ) (1 ≤ ( n ) ≤ 10^5). Output * A list of integers where the ith element is ϕ(i). Constraints * Ensure the solution runs efficiently for the maximum constraint (( n = 10^5 )). * Handle also the edge cases such as the minimum possible input. Example ```python print(euler_totient_extended(6)) [0, 1, 1, 2, 2, 4, 2] # Explanation: The list returns ϕ(0) to ϕ(6). ``` Your task is to implement the function, making sure to optimize it for large inputs where necessary.","solution":"def euler_totient_extended(n: int) -> list: This function calculates Euler\'s Totient Function values for all integers from 1 to n inclusive. # Initialize the result array phi = list(range(n + 1)) # Implement the Sieve of Eratosthenes for i in range(2, n + 1): if phi[i] == i: # i is a prime for j in range(i, n + 1, i): phi[j] *= (i - 1) phi[j] //= i return phi"},{"question":"**Scenario**: Imagine you are developing a sequence generator that creates an infinite series of all positive integers concatenated together: \\"123456789101112131415...\\". You are tasked to write a function that can find the nth digit in this sequence efficiently. **Problem Statement**: Write a function `find_nth_digit(n: int) -> int` that returns the nth digit in the infinite sequence of concatenated positive integers. **Function Signature**: ```python def find_nth_digit(n: int) -> int: ``` # Input - An integer `n` such that `1 <= n <= 2 * 10^9`, representing the position of the digit in the sequence. # Output - Returns the nth digit as an integer. # Examples 1. `find_nth_digit(3)` should return `3`. 2. `find_nth_digit(11)` should return `0`. # Constraints - The function should run in logarithmic time relative to `n`. - Consider potential issues related to floating-point arithmetic. - Handle edge cases such as transitions from single-digit to multi-digit numbers. # Notes - Be mindful of the range of values `n` can take. - Ensure that your function accurately navigates through different lengths of numbers and correctly identifies the nth digit.","solution":"def find_nth_digit(n: int) -> int: # Start by determining the length of the number range we are looking at digit_length = 1 count = 9 start = 1 while n > digit_length * count: n -= digit_length * count digit_length += 1 count *= 10 start *= 10 # Find the actual number that contains the nth digit start += (n - 1) // digit_length s = str(start) return int(s[(n - 1) % digit_length])"},{"question":"You are given a singly linked list where each node contains a single character and a method to determine the k-th to last element of the list. Implement a function `find_kth_to_last(head: Node, k: int) -> Node` that returns the k-th to last node in the linked list. Requirements: 1. **Input**: * `head` - The head node of a singly linked list. * `k` - An integer representing the k-th position from the end (0-based index). 2. **Output**: * The Node that is k-th from the last. 3. **Constraints**: * The value of `k` will be non-negative. * If `k` is greater than or equal to the length of the list, the function should raise an `IndexError`. * The linked list will have at least one node. * Nodes of the linked list will have a `val` attribute which is a character and a `next` attribute pointing to the next node in the list. 4. **Performance**: * The solution should be optimized for both time and space, ideally using O(n) time and O(1) space complexity. Example: Given the following linked list representation: A -> B -> C -> D -> E - `find_kth_to_last(head, 0)` should return the Node with value `E`. - `find_kth_to_last(head, 2)` should return the Node with value `C`. - `find_kth_to_last(head, 4)` should return the Node with value `A`. # Function Signature ```python class Node: def __init__(self, val=None): self.val = val self.next = None def find_kth_to_last(head: Node, k: int) -> Node: pass ``` Implement the function `find_kth_to_last` in the provided space. # Solution Template ```python class Node: def __init__(self, val=None): self.val = val self.next = None def find_kth_to_last(head: Node, k: int) -> Node: # Implement the two-pointer technique to find k-th to last element if not head or k < 0: raise IndexError(\\"Invalid index\\") p1 = head p2 = head # Move p1 k steps ahead for _ in range(k): if not p1: raise IndexError(\\"Index out of range\\") p1 = p1.next while p1.next: p1 = p1.next p2 = p2.next return p2 ```","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def find_kth_to_last(head: Node, k: int) -> Node: # Implement the two-pointer technique to find k-th to last element if not head or k < 0: raise IndexError(\\"Invalid index\\") p1 = head p2 = head # Move p1 k steps ahead for _ in range(k): if not p1.next: # if k is >= number of nodes raise IndexError(\\"Index out of range\\") p1 = p1.next # Move both pointers until p1 reaches the last node while p1.next: p1 = p1.next p2 = p2.next return p2"},{"question":"# Bipartite Graph Checker Scenario: You are tasked with determining whether a given undirected graph is bipartite. A bipartite graph is one that can be colored using two colors such that no two adjacent vertices have the same color. Problem: Implement a function `is_bipartite(graph)` that checks whether the given graph is bipartite. Function Signature: ```python def is_bipartite(graph: List[List[int]]) -> bool: ``` Input: * `graph` (List[List[int]]): An adjacency matrix representing the given graph. `graph[i][j]` is 1 if there is an edge between vertices `i` and `j`, and 0 otherwise. `graph[i][i]` is 0. Output: * `bool`: Return `True` if the graph is bipartite, otherwise `False`. Constraints: * `1 <= len(graph) <= 1000` * `0 <= graph[i][j] <= 1` Example: ```python print(is_bipartite([[0,1,0], [1,0,1], [0,1,0]])) # Output: True print(is_bipartite([[0,1,1], [1,0,1], [1,1,0]])) # Output: False ``` Explanation: 1. The first example graph can be colored with two colors where vertex 0 and 2 are of one color, and vertex 1 is of another. 2. The second example graph has an odd-length cycle, making it impossible to color with two colors without adjacent vertices sharing the same color. Notes: 1. Assume the graph is connected. 2. Handle self-loops and ensure no unmanaged adjacent vertices violate bipartiteness.","solution":"def is_bipartite(graph): Check if the given graph is bipartite using BFS. Args: graph (List[List[int]]): Adjacency matrix representing the graph. Returns: bool: True if the graph is bipartite, False otherwise. n = len(graph) colors = [-1] * n # -1 means uncolored, 0 and 1 are the two colors def bfs(start): queue = [start] colors[start] = 0 # Start coloring the first node with color 0 while queue: node = queue.pop(0) current_color = colors[node] for neighbor in range(n): if graph[node][neighbor] == 1: if colors[neighbor] == -1: colors[neighbor] = 1 - current_color queue.append(neighbor) elif colors[neighbor] == current_color: return False return True for i in range(n): if colors[i] == -1: # For an unvisited node if not bfs(i): return False return True"},{"question":"# String Rotation Function **Objective:** Write a function that rotates a given string `s` to the left by `k` positions. **Function Signature:** ```python def rotate_string(s: str, k: int) -> str: pass ``` **Input:** - `s` (1 <= len(s) <= 1000): A non-empty string consisting of lowercase English letters. - `k` (1 <= k <= 10^9): A positive integer representing the number of positions to rotate the string. **Output:** - Return the rotated string after `k` left rotations. **Example:** ```python Rotate_String(\\"hello\\", 2) # Output: \\"llohe\\" Rotate_String(\\"hello\\", 5) # Output: \\"hello\\" (Full rotation) Rotate_String(\\"hello\\", 6) # Output: \\"elloh\\" Rotate_String(\\"hello\\", 7) # Output: \\"llohe\\" Rotate_String(\\"hello\\", 102) # Output: \\"lohel\\" ``` Constraints: - You may assume that the input will always be valid according to the given constraints. - Performance: The function should handle large values of `k` efficiently, without constructing excessively large intermediate strings. # Scenario: Consider a situation where you need to process text with repeated patterns or cyclic sequences. For example, manipulating text within limited buffer spaces or implementing circular arrays. **Task:** Implement the function `rotate_string` such that it efficiently produces the desired rotation for any valid input, observing the performance constraints when handling large values of `k`.","solution":"def rotate_string(s: str, k: int) -> str: Rotates the string `s` to the left by `k` positions. n = len(s) k = k % n # Reduce k to the minimum equivalent rotations needed return s[k:] + s[:k]"},{"question":"You are tasked with creating a function that filters an array of integers, retaining only those elements that lie within a specified minimum and maximum range. If the minimum or maximum limit is not provided, those boundaries should be assumed to be the smallest and largest values in the array, respectively. Write a function `filter_within_range(arr, min_lim=None, max_lim=None)` that: 1. Takes in the following arguments: - `arr`: List of integers. - `min_lim`: An integer indicating the minimum limit (inclusive). If None, assume the smallest element in `arr`. - `max_lim`: An integer indicating the maximum limit (inclusive). If None, assume the largest element in `arr`. 2. Returns a list of integers that fall between `min_lim` and `max_lim`, inclusive of these boundary values. # Constraints: - The input array can have up to (10^6) elements. - Each element in the array can range from (-10^9) to (10^9). - The function should run in linear time (O(n)). # Example: ```python filter_within_range([1, 2, 3, 4, 5], 2, 4) -> [2, 3, 4] filter_within_range([10, 20, 30, 40], None, 25) -> [10, 20] filter_within_range([5, -10, 15, 20], -5, None) -> [5, 15, 20] filter_within_range([], 1, 10) -> [] ``` # Additional Requirements: - The function should handle empty arrays gracefully by returning an empty list. - If all elements fall outside the specified range, return an empty list. - Your solution must handle edge cases efficiently without unnecessary computations. # Performance Note: Ensure your solution can handle the upper limits of input sizes within reasonable time bounds.","solution":"def filter_within_range(arr, min_lim=None, max_lim=None): Returns a list of integers from arr that fall between min_lim and max_lim, inclusive. If min_lim is None, it\'s assumed to be the smallest value in arr. If max_lim is None, it\'s assumed to be the largest value in arr. if not arr: return [] if min_lim is None: min_lim = min(arr) if max_lim is None: max_lim = max(arr) return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"You are tasked with implementing a variant of the AVL Tree that supports an additional feature: finding the k-th smallest element in the tree efficiently. # Problem Description Write a Python class `AVLWithKthElement` that extends the provided `AvlTree` class. Modify or extend the provided functions as needed to support the `find_kth_smallest` method. # Method Details Implement the following method: 1. **find_kth_smallest(k: int) -> int**: Returns the k-th smallest element in the AVL tree. If k is out of bounds (i.e., there are fewer than k elements in the tree), raise a `ValueError`. # Constraints * Every key in the AVL tree will be a unique integer. * You can assume `k` will always be a positive integer. # Input & Output Examples ```python # Initializing the AVL tree avl_tree = AVLWithKthElement() # Inserting elements avl_tree.insert(20) avl_tree.insert(4) avl_tree.insert(26) avl_tree.insert(3) avl_tree.insert(9) avl_tree.insert(15) # Finding the k-th smallest element print(avl_tree.find_kth_smallest(3)) # Output: 9 print(avl_tree.find_kth_smallest(1)) # Output: 3 print(avl_tree.find_kth_smallest(6)) # Output: 26 try: print(avl_tree.find_kth_smallest(7)) except ValueError as e: print(e) # Output: ValueError: k is out of bounds ``` # Additional Information * Feel free to add additional helper methods to maintain and retrieve the size of sub-trees. * Make sure to maintain the AVL properties after every insertion.","solution":"class AVLNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 self.size = 1 # The new property to keep track of the sizes of subtrees class AVLWithKthElement: def __init__(self): self.root = None def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return AVLNode(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) node.size = 1 + self._get_size(node.left) + self._get_size(node.right) balance = self._get_balance(node) # Left Left if balance > 1 and key < node.left.key: return self._right_rotate(node) # Right Right if balance < -1 and key > node.right.key: return self._left_rotate(node) # Left Right if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) # Right Left if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def find_kth_smallest(self, k): if k <= 0 or k > self._get_size(self.root): raise ValueError(\\"k is out of bounds\\") return self._find_kth_smallest(self.root, k).key def _find_kth_smallest(self, node, k): left_size = self._get_size(node.left) if k == left_size + 1: return node if k <= left_size: return self._find_kth_smallest(node.left, k) return self._find_kth_smallest(node.right, k - left_size - 1) def _right_rotate(self, y): x = y.left T2 = x.right x.right = y y.left = T2 y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) y.size = 1 + self._get_size(y.left) + self._get_size(y.right) x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) x.size = 1 + self._get_size(x.left) + self._get_size(x.right) return x def _left_rotate(self, x): y = x.right T2 = y.left y.left = x x.right = T2 x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) x.size = 1 + self._get_size(x.left) + self._get_size(x.right) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) y.size = 1 + self._get_size(y.left) + self._get_size(y.right) return y def _get_height(self, node): if not node: return 0 return node.height def _get_size(self, node): if not node: return 0 return node.size def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right)"},{"question":"# Question: Two Sum Problem Context You are working on a financial application that needs to verify transaction pairs that sum up to a specific amount quickly. For this, you\'ll need to implement an efficient algorithm that identifies indices of two numbers in a list that add up to a given target. Problem Statement Given an array of integers, write a function `two_sum(array, target)` that returns indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Input and Output **Input**: - `array`: A list of integers `[a1, a2, ..., an]` (2 ≤ n ≤ 10^5) - `target`: An integer, representing the target sum. **Output**: - A tuple `(i, j)` where `i` and `j` are the indices of the two numbers in the array that add up to the target. The order of the indices does not matter. Constraints - Each input will have exactly one solution. - An element cannot be used twice in the same solution. Example ```python # Example # Input: nums = [2, 7, 11, 15], target = 9 # Output: (0, 1) # Explanation: # Because nums[0] + nums[1] = 2 + 7 = 9, # return (0, 1) ``` Requirements - Time Complexity: O(n) - Space Complexity: O(n) ```python def two_sum(array, target): dic = {} for i, num in enumerate(array): if num in dic: return dic[num], i else: dic[target - num] = i return None ``` Write your function implementation below and test it with various scenarios including edge cases such as arrays with negative numbers or multiple possible pairs summing to the target.","solution":"def two_sum(array, target): Finds the indices of the two numbers in `array` that add up to `target`. Parameters: array (list): A list of integers. target (int): The target sum. Returns: tuple: A tuple of the indices of the two numbers. seen = {} for i, num in enumerate(array): complement = target - num if complement in seen: return seen[complement], i seen[num] = i return None"},{"question":"# Question: Finding Primitive Roots **Context**: In modular arithmetic and number theory, a primitive root of a number (n) is an integer (a) such that any number coprime with (n) can be expressed as (a) raised to some power mod (n). This concept finds applications in cryptographic algorithms and cyclic group theory. **Task**: Write a function `find_primitive_roots(n: int) -> List[int]` that finds all primitive roots of a given positive integer (n). The function should return a list of all primitive roots if they exist. If no primitive roots exist, return an empty list. **Input Format**: - `n (int)`: A positive integer (n). **Output Format**: - Return a list of integers representing the primitive roots of (n). **Constraints**: - (1 leq n leq 10^4) **Example**: ```python find_primitive_roots(9) ``` **Expected Output**: ```python [2, 5] ``` **Explanation**: - For (n=9), the primitive roots 2 and 5 can generate all elements coprime to 9. **Implementation Specifications**: - Ensure your solution handles edge cases like the trivial case (n=1). - Optimize the solution to avoid excessive computational overhead.","solution":"from typing import List def gcd(a, b): while b: a, b = b, a % b return a def is_primitive_root(root, n): required_set = set(num for num in range(1, n) if gcd(num, n) == 1) results_set = set() current = root for power in range(1, n): results_set.add(current) current = (current * root) % n return required_set == results_set def find_primitive_roots(n: int) -> List[int]: if n <= 1: return [] primitive_roots = [] for possible_root in range(1, n): if is_primitive_root(possible_root, n): primitive_roots.append(possible_root) return primitive_roots"},{"question":"# Ordered Stack with Advanced Operations Scenario You have been provided with a special stack data structure called `OrderedStack` that maintains its elements in decreasing order from bottom to top. This means the largest element is at the top and the smallest element at the bottom. This stack allows for efficient retrieval and removal of the largest element but potentially slower insertions due to reordering. Objective Your task is to enhance the `OrderedStack` by adding a new method `merge` that takes another `OrderedStack` as input and merges it into the current stack while maintaining the order. The resulting stack should still be in decreasing order from bottom to top. Specifications * **Method Signature**: ```python def merge(self, other_stack: \\"OrderedStack\\") -> None: ``` * **Input**: * `other_stack`: An instance of `OrderedStack` to be merged into the current stack. * **Output**: * The method should modify the current stack in place (merge other_stack into it). * **Constraints**: * You may use additional data structures if necessary. * Aim to minimize the number of stack operations and ensure that the resultant stack maintains order. ```python class OrderedStack: def __init__(self): self.items = [] def is_empty(self): return self.items == [] def push_t(self, item): self.items.append(item) # push method to maintain order when pushing new elements def push(self, item): temp_stack = OrderedStack() if self.is_empty() or item > self.peek(): self.push_t(item) else: while item < self.peek() and not self.is_empty(): temp_stack.push_t(self.pop()) self.push_t(item) while not temp_stack.is_empty(): self.push_t(temp_stack.pop()) def pop(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.items.pop() def peek(self): return self.items[len(self.items) - 1] def size(self): return len(self.items) def merge(self, other_stack: \\"OrderedStack\\") -> None: # Your code here to merge other_stack into this stack while maintaining order pass ``` Example: ```python # Example usage: stack1 = OrderedStack() stack1.push(5) stack1.push(3) stack1.push(1) stack2 = OrderedStack() stack2.push(6) stack2.push(4) stack2.push(2) stack1.merge(stack2) # The elements of stack1 should be in descending order: # stack1.items -> [6, 5, 4, 3, 2, 1] ``` Note: Make sure that both stacks maintain their ordering properties after the merge operation.","solution":"class OrderedStack: def __init__(self): self.items = [] def is_empty(self): return self.items == [] def push_t(self, item): self.items.append(item) def push(self, item): temp_stack = OrderedStack() while not self.is_empty() and self.peek() > item: temp_stack.push_t(self.pop()) self.push_t(item) while not temp_stack.is_empty(): self.push_t(temp_stack.pop()) def pop(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.items.pop() def peek(self): return self.items[-1] def size(self): return len(self.items) def merge(self, other_stack: \\"OrderedStack\\") -> None: temp_items = [] while not self.is_empty(): temp_items.append(self.pop()) while not other_stack.is_empty(): temp_items.append(other_stack.pop()) temp_items.sort(reverse=True) for item in temp_items: self.push_t(item)"},{"question":"**Counting Sort Implementation with Enhanced Functionality** # Problem Statement: You are required to implement an enhanced version of the Counting Sort algorithm that sorts an array of integers. Your implementation should handle arrays containing both positive and negative integers and output the sorted array. # Function Signature: ```python def counting_sort(arr: list[int]) -> list[int]: ``` # Input: - `arr` (list of integers): The list of integers to be sorted. The length of the array (n) will not exceed `10^6`, and the absolute value of any integer within the array (k) will not exceed `10^6`. # Output: - The function should return a new sorted list of integers in ascending order. # Constraints: - The array can contain a mix of positive and negative integers, and it may have duplicate values. - Your solution should have a time complexity of O(n + k). # Example: ```python >>> counting_sort([-5, -10, 0, -3, 8, 5, -1, 10]) [-10, -5, -3, -1, 0, 5, 8, 10] >>> counting_sort([1, 4, 1, 2, 7, 5, 2]) [1, 1, 2, 2, 4, 5, 7] ``` # Instructions: 1. Adjust the given algorithm to handle negative integers by shifting the integer range. 2. Ensure that the algorithm remains stable. 3. Avoid modifying the input array directly; instead, create and return a new sorted array. 4. Optimize your solution to handle the constraints efficiently. Consider edge cases such as: - An empty array. - All elements being the same. - Arrays with all negative or all positive numbers only. # Performance Requirements: - Handle up to `10^6` integer elements efficiently. - Maintain an optimal time complexity of O(n + k).","solution":"def counting_sort(arr: list[int]) -> list[int]: if not arr: return [] min_val = min(arr) max_val = max(arr) range_of_elements = max_val - min_val + 1 # Initialize count array count_arr = [0] * range_of_elements # Store the count of each element for num in arr: count_arr[num - min_val] += 1 # Calculate the starting index for each key for i in range(1, len(count_arr)): count_arr[i] += count_arr[i - 1] # Place the elements in the sorted array sorted_arr = [0] * len(arr) for num in reversed(arr): sorted_arr[count_arr[num - min_val] - 1] = num count_arr[num - min_val] -= 1 return sorted_arr"},{"question":"Scenario: You have been given a task to analyze datasets of continuous measurements that span over a period, represented as sorted lists of unique integers. Your goal is to identify and summarize these continuous sequences efficiently. # Task: Implement a function `summarize_ranges` that takes a sorted list of unique integers and returns a list of strings summarizing the contiguous ranges. Function Signature: ```python def summarize_ranges(array: List[int]) -> List[str]: ``` Input: * `array` (List[int]): A sorted list of unique integers. Output: * `List[str]`: A list of strings where each string summarizes a contiguous range. For example, \\"0-2\\" represents the range from 0 to 2, and \\"7\\" represents the single number 7. Constraints: * The input list can have a length between 0 and 10^4. * Each integer in the list can range from -10^4 to 10^4. Examples: * Example 1: * Input: `[0, 1, 2, 4, 5, 7]` * Output: `[\\"0-2\\", \\"4-5\\", \\"7\\"]` * Example 2: * Input: `[3]` * Output: `[\\"3\\"]` * Example 3: * Input: `[-5, -4, -3, -1, 0, 2, 3]` * Output: `[\\"-5--3\\", \\"-1-0\\", \\"2-3\\"]` # Notes: * Ensure to handle edge cases such as single-element arrays and empty arrays. * The array is guaranteed to be sorted and contain unique integers.","solution":"from typing import List def summarize_ranges(array: List[int]) -> List[str]: if not array: return [] ranges = [] start = array[0] end = array[0] for i in range(1, len(array)): if array[i] == end + 1: end = array[i] else: if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") start = array[i] end = array[i] if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") return ranges"},{"question":"You are given a number, and you need to find the next higher number that has exactly the same set of digits as the original number. If no such number exists, return -1. Write a function `next_bigger(num: int) -> int` in Python that implements this functionality. # Input Format: * A single integer `num` (1 ≤ num ≤ 10^9). # Output Format: * A single integer representing the next larger permutation of `num` using its digits, or `-1` if no such permutation exists. # Constraints: * The input number is positive and consists of digits from 0-9. * No leading zeroes (except the number itself is zero). # Example: ```python next_bigger(38276) -> 38627 next_bigger(12345) -> 12354 next_bigger(54321) -> -1 next_bigger(99999) -> -1 next_bigger(1528452) -> 1528524 ``` # Explanation: For `next_bigger(38276)`, following the steps of the algorithm: - From the right, find the first number (8) which is smaller than the number after it (2). The index `i` is 2. - Find the largest number after position `i` which is larger than the pivot (2). We find the swap index to be 4 (the digit 6). - Swap these two digits giving us 38672. - Reverse the digits to the right of index `i` giving us 38627. # Note: Ensure your function handles edge cases effectively, such as when no larger permutation exists or the number has repeating digits.","solution":"def next_bigger(num: int) -> int: For a given number, find the next higher number which contains the exact same set of digits. If no such number exists, return -1. digits = list(str(num)) length = len(digits) # Step 1: Find the pivot, the first element that is smaller than the element to its right. pivot = -1 for i in range(length - 2, -1, -1): if digits[i] < digits[i + 1]: pivot = i break # If no pivot is found, that means the digits are sorted in descending order if pivot == -1: return -1 # Step 2: Find the smallest element larger than the pivot to the right of the pivot for j in range(length - 1, pivot, -1): if digits[j] > digits[pivot]: # Swap the pivot with this element digits[pivot], digits[j] = digits[j], digits[pivot] break # Step 3: Reverse the sequence to the right of the pivot digits = digits[:pivot + 1] + list(reversed(digits[pivot + 1:])) return int(\'\'.join(digits))"},{"question":"Context You are given a 2D matrix of integers where each row and each column are sorted in non-decreasing order. Your task is to implement a function that searches for a given integer key in the matrix and returns the coordinates (row, column) of the key if found, else returns (-1, -1). Function Signature ```python def search_in_sorted_matrix(matrix: list[list[int]], key: int) -> tuple[int, int]: # your code here ``` Input - `matrix`: A list of lists where each sub-list is of equal length and sorted in non-decreasing order, representing a 2D matrix. - `key`: An integer value to search for in the matrix. Output - Returns a tuple (i, j) where `i` is the row index and `j` is the column index of the key if found. Returns (-1, -1) if the key is not found. Constraints - `1 <= len(matrix) <= 1000` - `1 <= len(matrix[0]) <= 1000` - Each element in the matrix is an integer. - The given matrix is sorted in non-decreasing order both row-wise and column-wise. Performance Requirements - Your solution should have a time complexity of O(m + n) and a space complexity of O(1). Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] key = 5 # Expected output: (1, 1) print(search_in_sorted_matrix(matrix, key)) ``` Write an efficient implementation of the function that handles edge cases and performs within the given constraints.","solution":"def search_in_sorted_matrix(matrix: list[list[int]], key: int) -> tuple[int, int]: Searches for the key in the given sorted 2D matrix and returns the coordinates if found. Otherwise, returns (-1, -1). Args: matrix (list[list[int]]): The 2D matrix of integers. key (int): The integer to search for. Returns: tuple[int, int]: The coordinates (row, col) of the found key or (-1, -1) if not found. if not matrix or not matrix[0]: return (-1, -1) rows = len(matrix) cols = len(matrix[0]) # Start from the top right corner row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == key: return (row, col) elif matrix[row][col] < key: row += 1 else: col -= 1 return (-1, -1)"},{"question":"# Binary Exponentiation Implementation You are required to implement a function `power` that calculates the power of a number `a` raised to an exponent `n` efficiently using binary exponentiation. Additionally, you should support an optional modulus operation. Function Signature ```python def power(a: int, n: int, mod: int = None) -> int: pass ``` # Input * `a` (int): Base integer (can be positive or negative). * `n` (int): Non-negative integer exponent. * `mod` (int, optional): A positive integer for modulus operation. # Output * (int): Result of `a` raised to the power `n`, optionally modulo `mod`. # Constraints * `0 <= a <= 10^9` * `0 <= n <= 10^9` * `1 <= mod <= 10^9` (if provided) # Examples 1. `power(2, 10)` should return `1024` 2. `power(2, 10, 1000)` should return `24` 3. `power(3, 7)` should return `2187` 4. `power(3, 7, 20)` should return `7` # Notes * You must implement the function using the iterative approach as shown in the requirement. * Make sure to handle edge cases properly. * Ensure the function is efficient and adheres to the provided constraints.","solution":"def power(a: int, n: int, mod: int = None) -> int: Calculate the power of a number a raised to an exponent n using binary exponentiation. Optionally computes the result modulo `mod`. result = 1 base = a while n > 0: if n % 2 == 1: result = result * base if mod is None else (result * base) % mod base = base * base if mod is None else (base * base) % mod n //= 2 return result"},{"question":"# Problem: Minimum Additions for Strong Password Given a password string, determine the minimum number of additional characters required to make it strong according to the following rules: 1. The password length must be at least 6 characters. 2. The password must contain at least one digit (0-9). 3. The password must contain at least one lowercase letter (a-z). 4. The password must contain at least one uppercase letter (A-Z). 5. The password must contain at least one special character from the set: !@#%^&*()-+ # Function Signature ```python def strong_password(n: int, password: str) -> int: pass ``` # Input - `n`: An integer representing the length of the password string. - `password`: A string representing the password. # Output - An integer representing the minimum number of additional characters required to make the password strong. # Constraints - `1 <= n <= 100` - The password consists of ASCII characters. # Examples Example 1 ```python n = 3 password = \\"Ab1\\" strong_password(n, password) ``` **Output**: 3 Example 2 ```python n = 11 password = \\"#Algorithms\\" strong_password(n, password) ``` **Output**: 1 # Explanation - For the first example, the password `Ab1` is only 3 characters long and already contains a digit, a lowercase letter, and an uppercase letter but lacks a special character and adequate length. Thus, the minimum number of additional characters required is 3 to make it of length 6 and include the required special character. - For the second example, the password `#Algorithms` lacks a digit, so just one additional character (a digit) is needed. # Notes Students should focus on checking each required character type and the total length of the password. Based on the analysis, they should calculate the necessary additions and handle both character and length requirements efficiently.","solution":"def strong_password(n: int, password: str) -> int: requirements = [False, False, False, False] # [digit, lowercase, uppercase, special] special_characters = set(\\"!@#%^&*()-+\\") for char in password: if char.isdigit(): requirements[0] = True elif char.islower(): requirements[1] = True elif char.isupper(): requirements[2] = True elif char in special_characters: requirements[3] = True required_types = requirements.count(False) length_needed = max(0, 6 - n) return max(required_types, length_needed)"},{"question":"# Scenario You\'re working on a binary data communication system where you need to ensure that transmitted data patterns adhere to certain criteria to avoid interference. One such criterion is that all data must have alternating bits. Your task is to implement a function that verifies whether a given integer (representing binary data) satisfies this requirement. # Task Implement a function that determines if a provided positive integer has alternating bits. # Input and Output * Input: A positive integer `n` (1 ≤ n ≤ 2^63 - 1). * Output: A boolean value `True` if `n` has alternating bits, otherwise `False`. # Constraints 1. You must optimize for both time and space efficiency. 2. Consider edge cases, such as minimum and maximum input values. 3. Provide a solution that handles the largest 64-bit integer efficiently. # Function Signature ```python def has_alternating_bits(n: int) -> bool: pass ``` # Example ```python assert has_alternating_bits(5) == True # binary: 101 assert has_alternating_bits(7) == False # binary: 111 assert has_alternating_bits(11) == False # binary: 1011 assert has_alternating_bits(10) == True # binary: 1010 ``` # Notes - Consider the binary representations carefully. - Optimize your function to make it suitable for large integers potentially up to 64 bits.","solution":"def has_alternating_bits(n: int) -> bool: # Shift n to the right by 1 bit and XOR it with n. If n has alternating bits, # the result of this operation will be a sequence of all 1\'s. x = n ^ (n >> 1) # Check if the result is all 1\'s by adding 1 and performing a bitwise AND # with the result. If it is all 1\'s, x + 1 will be a power of 2. return (x & (x + 1)) == 0"},{"question":"# Question: Path Splitting Challenge You are working on a file management system that should be capable of splitting a given path into its directory and file/leaf part. The paths to be used in your system might be URLs, Unix file paths, or even include non-standard separators. **Function Definition** ```python def split_path(path: str, separator: str = \'/\') -> list: Splits a given path into two parts: the directory part and the file/leaf part. Parameters: path (str): The path to be split. separator (str): The separator used in the path, default is \'/\'. Returns: list: A list containing the directory part and the file/leaf part. Examples: >>> split_path(\'https://algorithms/unix/test.py\') [\'https://algorithms/unix\', \'test.py\'] >>> split_path(\'algorithms/unix/test.py\') [\'algorithms/unix\', \'test.py\'] >>> split_path(\'file\', separator=\'/\') [\'\', \'file\'] >>> split_path(\'dir/\', separator=\'/\') [\'dir\', \'\'] >>> split_path(\'/\', separator=\'/\') [\'\', \'\'] >>> split_path(\'C:Userstestfile.txt\', separator=\'\') [\'C:Userstest\', \'file.txt\'] pass ``` Constraints: 1. Path will be a non-empty string. 2. The separator will be a single character string. 3. The function should return the correct directory and file/leaf part even if the path does not contain the separator. 4. The function should handle paths ending or beginning with the separator correctly. Evaluation Criteria: 1. **Correctness**: Your function should handle all specified test cases correctly. 2. **Efficiency**: Your function should be efficient and perform well on larger input strings. 3. **Robustness**: Consider edge cases and handling of different types of separators. **Write your implementation for the `split_path` function below:** ```python def split_path(path: str, separator: str = \'/\') -> list: Implementation here ```","solution":"def split_path(path: str, separator: str = \'/\') -> list: Splits a given path into two parts: the directory part and the file/leaf part. Parameters: path (str): The path to be split. separator (str): The separator used in the path, default is \'/\'. Returns: list: A list containing the directory part and the file/leaf part. if separator not in path: return [\'\', path] last_sep_index = path.rindex(separator) directory_part = path[:last_sep_index] file_leaf_part = path[last_sep_index + 1:] return [directory_part, file_leaf_part]"},{"question":"# Problem Description You are given a singly linked list and a number k. Your task is to write a function that returns the k-th to last node of the linked list. If k is 0, return the last node; if k is 1, return the second-to-last node, and so on. Note that the list may contain repeated elements, and k is guaranteed to be non-negative but may not always be valid for the given list length. # Function Signature ```python def find_kth_to_last(head: Node, k: int) -> Node: pass ``` # Input * `head` - The head node of the singly linked list. * `k` - A non-negative integer representing the position from the end of the list. # Output * Return the k-th to last node of the list. # Constraints 1. The number of nodes in the linked list will be at most (10^4). 2. The value of `k` is a non-negative integer. # Example Example 1 ```python # Define the linked list A -> B -> C -> D -> E a = Node(\\"A\\") b = Node(\\"B\\") c = Node(\\"C\\") d = Node(\\"D\\") e = Node(\\"E\\") a.next = b b.next = c c.next = d d.next = e # k = 2 find_kth_to_last(a, 2) # Output: Node(\\"C\\") ``` Example 2 ```python # Define the linked list X -> Y -> Z x = Node(\\"X\\") y = Node(\\"Y\\") z = Node(\\"Z\\") x.next = y y.next = z # k = 0 find_kth_to_last(x, 0) # Output: Node(\\"Z\\") ``` Example 3 ```python # Define the linked list U u = Node(\\"U\\") # k = 1 find_kth_to_last(u, 1) # Output: IndexError (k is larger than list length) ``` # Notes - You should handle invalid `k` values by raising an appropriate exception (e.g., IndexError). - Focus on optimizing both time and space complexities.","solution":"class Node: def __init__(self, value): self.value = value self.next = None def find_kth_to_last(head: Node, k: int) -> Node: if head is None: raise IndexError(\\"The list is empty.\\") # Two-pointer approach fast = slow = head count = 0 # Move fast k+1 steps ahead while count < k + 1: if fast is None: raise IndexError(\\"k is larger than the list length.\\") fast = fast.next count += 1 # Move both pointers until fast reaches the end while fast: fast = fast.next slow = slow.next return slow"},{"question":"**Question**: As a Roman historian, you often need to convert Roman numerals to Arabic numerals to record and analyze ancient texts accurately. Write a function `roman_to_int` that takes a string representing a Roman numeral and converts it to an integer. The input is guaranteed to be within the range from 1 to 3999. # Function Signature: ```python def roman_to_int(s: str) -> int: ``` # Input: * `s` (str): A string representing a valid Roman numeral, with the length between 1 and 15 characters. # Output: * `int`: The corresponding integer value of the Roman numeral. # Constraints: * The input Roman numeral string is valid and within the range from 1 to 3999. # Example: ```python assert roman_to_int(\\"DCXXI\\") == 621 assert roman_to_int(\\"IX\\") == 9 assert roman_to_int(\\"MCMXCIV\\") == 1994 assert roman_to_int(\\"MMXXI\\") == 2021 assert roman_to_int(\\"III\\") == 3 ``` # Notes: 1. Ensure that your implementation also handles the subtractive combinations like IV, IX, XL, etc. 2. The function should have linear time complexity O(n), where n is the length of the string, and constant space complexity O(1).","solution":"def roman_to_int(s: str) -> int: Converts a Roman numeral to an integer. roman_values = {\'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000} integer_value = 0 prev_value = 0 # Traverse the string from end to start for char in reversed(s): current_value = roman_values[char] # If current value is less than previous value, subtract current value if current_value < prev_value: integer_value -= current_value else: # Otherwise, add current value integer_value += current_value # Update previous value for next iteration prev_value = current_value return integer_value"},{"question":"# Coin Change Combination Count Context: You are given a value `value` and an array of coin denominations `coins`. Your task is to determine how many ways you can combine these coins to sum up to `value`. The order of the coins does not matter, and you have an infinite supply of each coin denomination. Task: Implement a function `count(coins: List[int], value: int) -> int` which returns the number of ways to combine the coins to sum up to the given value. Input Format: - `coins`: A list of integers representing the denominations of the coins. - `value`: An integer representing the total value you need to form using the given coins. Output Format: - Return an integer representing the number of possible combinations to make the `value`. Constraints: - The `value` will be a non-negative integer. - Each coin in the `coins` list will be a positive integer. Examples: 1. **Input**: `value = 4`, `coins = [1, 2, 3]` - **Output**: 4 - **Explanation**: The possible combinations are [1, 1, 1, 1], [1, 1, 2], [2, 2], [1, 3]. 2. **Input**: `value = 10`, `coins = [2, 5, 3, 6]` - **Output**: 5 - **Explanation**: The possible combinations are [2, 2, 2, 2, 2], [2, 2, 3, 3], [2, 2, 6], [2, 3, 5], [5, 5]. Notes: - Consider edge cases such as when `value` is 0 or when the `coins` list is empty. - Ensure your algorithm handles large values efficiently.","solution":"from typing import List def count(coins: List[int], value: int) -> int: Returns the number of ways to combine the coins to sum up to the given value. # Initialize a list to store the number of combinations for each value combinations = [0] * (value + 1) # There is one way to make the value 0, that is using no coins combinations[0] = 1 # Iterate through each coin and update the combinations array for coin in coins: for i in range(coin, value + 1): combinations[i] += combinations[i - coin] return combinations[value]"},{"question":"# Problem Description: You are tasked with implementing an optimized Bubble Sort algorithm that can handle edge cases more effectively and provide detailed debugging information when requested. # Function Signature: ```python def optimized_bubble_sort(arr: List[int], debug: bool = False) -> List[int]: pass ``` # Input: - `arr` (List[int]): A list of integers that need to be sorted. - `debug` (bool): A boolean flag indicating whether to print detailed step-by-step information about the sorting process. Default is False. # Output: - The function should return the sorted list of integers. # Requirements: 1. Implement the Bubble Sort algorithm as provided, with the following optimizations: - The algorithm should be able to terminate earlier if the list is already sorted. - Include a debug mode that prints the list state at each swap and iteration. 2. Handle edge cases such as: - Empty list - Single-element list - List with all identical elements 3. Ensure your function is efficient in terms of performance and readability. # Constraints: - You must not use built-in sorting functions. - The list can contain between 0 to 10^5 elements. - Each element of the list can be between -10^5 to 10^5. # Example: ```python # Example 1 arr = [5, 1, 4, 2, 8] debug = False print(optimized_bubble_sort(arr, debug)) # Output: [1, 2, 4, 5, 8] # Example 2 arr = [3, 0, 2, 5, -1, 4, 1] debug = True # Output during debugging: \'\'\' iteration 0: 3 0 2 5 -1 4 1 swap 3 0 iteration 1: 0 3 2 5 -1 4 1 swap 3 2 ... sorted list: [-1, 0, 1, 2, 3, 4, 5] \'\'\' print(optimized_bubble_sort(arr, debug)) # Output: [-1, 0, 1, 2, 3, 4, 5] ```","solution":"from typing import List def optimized_bubble_sort(arr: List[int], debug: bool = False) -> List[int]: n = len(arr) for i in range(n): swapped = False if debug: print(f\\"iteration {i}: {\' \'.join(map(str, arr))}\\") for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True if debug: print(f\\"swap {arr[j]} {arr[j+1]}\\") if not swapped: break if debug: print(f\\"sorted list: {\' \'.join(map(str, arr))}\\") return arr"},{"question":"You are required to implement a ZigZag Iterator for multiple lists (more than two). Given a number of integer lists, implement a ZigZag Iterator class that iterates through these lists in a round-robin fashion but stops and removes a list when it has been completely iterated over. # Requirements 1. **Initialization**: - The constructor should take multiple lists as input. - Initialize your data structure such that it can handle any number of provided lists. 2. **Methods**: - `next()`: This method returns the next element in the zigzag iteration and advances the iterator. - `has_next()`: This method returns `True` if there are remaining elements in any of the lists, otherwise `False`. # Input and Output Format 1. The constructor will receive a list of lists of integers. 2. `next()` method will return a single integer. 3. `has_next()` method will return a boolean indicating whether there are more elements to iterate. # Example ```python lists = [[1, 2], [3, 4, 5, 6], [7, 8, 9]] it = ZigZagIterator(*lists) # Initialize with multiple lists output = [] while it.has_next(): output.append(it.next()) print(output) # Expected Output: [1, 3, 7, 2, 4, 8, 5, 9, 6] ``` # Constraints - The number of input lists can be zero or more. - The elements within the lists are integers. - All input lists are finite in length. # Your Task Implement the `ZigZagIterator` class with the following methods: - `__init__(self, *args)`: Initialize the iterator. - `next(self)`: Returns the next element. - `has_next(self)`: Returns a boolean indicating if there are more elements. Make sure your solution handles the edge cases mentioned in the analysis, such as differing list lengths and empty lists.","solution":"from collections import deque class ZigZagIterator: def __init__(self, *args): self.queue = deque(args) # queue of lists self.indices = deque([0] * len(args)) # corresponding indices for each list def next(self): if not self.has_next(): raise StopIteration(\\"No more elements in the iterator.\\") # Get the next list and its current index from the queue lst = self.queue.popleft() idx = self.indices.popleft() # Get the value at the current index value = lst[idx] # Move to the next index next_idx = idx + 1 if next_idx < len(lst): # If there are more elements in the current list, put it back in the queue self.queue.append(lst) self.indices.append(next_idx) return value def has_next(self): # Check if there are any remaining elements in any list in the queue while self.queue and self.indices[0] >= len(self.queue[0]): self.queue.popleft() self.indices.popleft() return len(self.queue) > 0"},{"question":"# Rotated Sorted Array Search with Unknown Rotation Point **Scenario:** You are a software engineer at a company that processes large datasets stored in arrays. To optimize query operations, some of these arrays are pre-sorted in ascending order for binary searching but later get rotated at unknown pivot points due to periodic maintenance processes. You are tasked with implementing a function that quickly finds the index of a target value in such a rotated sorted array. Function Signature: ```python def search_rotated_sorted_array(arr: List[int], target: int) -> int: pass ``` Input: - `arr`: A list of integers that is sorted in ascending order and then potentially rotated. Each element in the list is unique. - `target`: An integer representing the value to search for in the array. Output: - Returns the index of the target value if it is found in the array. - Returns -1 if the target value is not found. Constraints: - The array can have between 1 and (10^5) elements. - The values in the array range between (-10^5) and (10^5). - The algorithm\'s runtime complexity must be (O(log n)). # Example: ```python # Example 1 arr = [4, 5, 6, 7, 0, 1, 2] target = 0 search_rotated_sorted_array(arr, target) # -> 4 # Example 2 arr = [4, 5, 6, 7, 0, 1, 2] target = 3 search_rotated_sorted_array(arr, target) # -> -1 # Example 3 arr = [1] target = 0 search_rotated_sorted_array(arr, target) # -> -1 # Example 4 arr = [1] target = 1 search_rotated_sorted_array(arr, target) # -> 0 ``` Requirements: - Your function should handle arrays of any size within the constraints efficiently. - Consider edge cases (e.g., no rotation, single-element arrays). - Do not use any built-in library functions that directly solve the problem. **Challenge**: Implement both the iterative and recursive approaches for the solution and discuss the pros and cons of each.","solution":"from typing import List def search_rotated_sorted_array(arr: List[int], target: int) -> int: Searches for a target value in a rotated sorted array and returns its index or -1 if not found. Args: arr : List[int] : A rotated sorted array of unique integers. target : int : The target integer value to find. Returns: int : Index of the target if found, else -1. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid # Determine which part is sorted if arr[left] <= arr[mid]: # Left part is sorted if arr[left] <= target < arr[mid]: # Target is in the left part right = mid - 1 else: # Target is in the right part left = mid + 1 else: # Right part is sorted if arr[mid] < target <= arr[right]: # Target is in the right part left = mid + 1 else: # Target is in the left part right = mid - 1 return -1"},{"question":"You are given two two-dimensional matrices. Implement a function, `matrix_multiply`, that computes the product of these matrices. Make sure to handle edge cases where the matrices are not compatible for multiplication and optimize the performance for large matrices where possible. Function Signature ```python def matrix_multiply(multiplicand: list, multiplier: list) -> list: :param multiplicand: List[List[int]] - First matrix to multiply :param multiplier: List[List[int]] - Second matrix to multiply :return: List[List[int]] - Product of the two matrices ``` Input * `multiplicand` (List[List[int]]): A list of lists where each inner list represents a row in the matrix to be multiplied as the first operand. * `multiplier` (List[List[int]]): A list of lists where each inner list represents a row in the matrix to be multiplied as the second operand. Output * (List[List[int]]): A list of lists representing the resulting matrix product. Constraints 1. Elements in the matrices are integers. 2. The number of columns in `multiplicand` is equal to the number of rows in `multiplier`. Example ```python # Example 1 multiplicand = [ [1, 2], [3, 4] ] multiplier = [ [2, 0], [1, 2] ] output = [ [4, 4], [10, 8] ] assert matrix_multiply(multiplicand, multiplier) == output # Example 2 multiplicand = [ [1, 0], [0, 1] ] multiplier = [ [4, 5], [6, 7] ] output = [ [4, 5], [6, 7] ] assert matrix_multiply(multiplicand, multiplier) == output ``` Notes - Raise an exception with a clear message if the matrices are not compatible for multiplication. - Ensure to test your solution against different edge cases, including but not limited to: * Matrix with zero elements. * Large matrices to evaluate performance. * Identity matrices multiplication.","solution":"def matrix_multiply(multiplicand, multiplier): Multiply two matrices and return the resulting matrix. :param multiplicand: List[List[int]] - First matrix to multiply :param multiplier: List[List[int]] - Second matrix to multiply :return: List[List[int]] - Product of the two matrices # Check the matrix dimensions for compatibility if len(multiplicand[0]) != len(multiplier): raise ValueError(\\"Incompatible matrices: The number of columns in the first matrix must be equal to the number of rows in the second matrix.\\") result = [[0] * len(multiplier[0]) for _ in range(len(multiplicand))] for i in range(len(multiplicand)): for j in range(len(multiplier[0])): for k in range(len(multiplier)): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"# Objective You are tasked with creating a utility function that converts a given file path into its corresponding absolute path, resolving any user home directory shortcuts. Additionally, you must implement a mechanism to handle specific edge cases and return appropriate messages. # Problem Write a Python function `resolve_path(file: str) -> str` that accepts a file path as input and returns its absolute path. The function should properly handle edge cases, including: 1. **Empty or blank input**: Return `\'Invalid path: empty string\'`. 2. **Non-string input**: Return `\'Invalid path: not a string\'`. 3. **Valid path**: Return the absolute path resolved. # Constraints - The function must handle paths for typical operating systems (e.g., Windows, Unix). - Assume valid file paths do not include complex symbols or illegal characters outside their normal usage. # Input - `file` (string): A relative or absolute file path which may include `~` for the home directory. # Output - Return a string representing the absolute path. - If the input is invalid or empty, return specific error messages as described. # Example ```python assert resolve_path(\\"~/Documents\\") == \\"/home/user/Documents\\" assert resolve_path(\\"\\") == \\"Invalid path: empty string\\" assert resolve_path(12345) == \\"Invalid path: not a string\\" ``` # Implementation ```python import os def resolve_path(file): if not isinstance(file, str): return \\"Invalid path: not a string\\" if file.strip() == \\"\\": return \\"Invalid path: empty string\\" return os.path.abspath(os.path.expanduser(file)) ``` # Explanation This function first checks if the input is a string and non-empty. If any of these initial checks fail, it returns the appropriate error message. Otherwise, it uses Python\'s built-in `os.path` methods to resolve and return the absolute path.","solution":"import os def resolve_path(file): Returns the absolute path of the given file path, resolving any user home directory shortcuts. Handles edge cases like non-string input and blank input. if not isinstance(file, str): return \\"Invalid path: not a string\\" if file.strip() == \\"\\": return \\"Invalid path: empty string\\" return os.path.abspath(os.path.expanduser(file))"},{"question":"# Scenario: You are tasked with enhancing a review system for an e-commerce platform. Given customer reviews, you need to ensure the most helpful reviews are displayed first. To do this, we\'ll use an extended version of heap sort to provide the capability of dynamically updating the sorted list of reviews. # Task: Design and implement a function that sorts an array using the principles of heap sort. Extend the heap sort functionality to maintain a dynamic min or max heap structure that allows insertion of new elements into the sorted list and fetches the top k elements efficiently. # Requirements: 1. Implement a heap sort function using the structure provided in the code snippets above. 2. Extend the heap structure to support the following functionalities: - **Insert**: Insert a new element into the heap and re-sort. - **Fetch top k elements**: Efficiently retrieve the top k elements from the heap. 3. The heap should be able to dynamically maintain the sorted property after each insertion. 4. Implement max-heap and min-heap variants. # Function Signature: ```python class DynamicHeapSort: def __init__(self, arr: List[int], heap_type=\'max\', k=5): Initialize the object with array and heap type :param arr: List[int] - initial array :param heap_type: str - \'max\' or \'min\' :param k: int - number of top elements to fetch pass def insert(self, value: int) -> None: Insert value into the dynamic heap and maintain heap property. :param value: int pass def fetch_top_k(self) -> List[int]: Fetch the top k elements from the heap. :return: List[int] pass def heap_sort(self) -> List[int]: Perform heap sort on the array. :return: List[int] - sorted array. pass ``` # Constraints: - `1 <= len(arr) <= 10^4` - `1 <= k <= len(arr)` - `-10^6 <= arr[i] <= 10^6` - `value` for insert will always be within the same range as `arr`. # Example: ```python dh = DynamicHeapSort([4, 10, 3, 5, 1], heap_type=\'max\', k=3) dh.heap_sort() # Output should be [1, 3, 4, 5, 10] dh.insert(6) dh.fetch_top_k() # Output should be [10, 6, 5] ```","solution":"import heapq from typing import List class DynamicHeapSort: def __init__(self, arr: List[int], heap_type=\'max\', k=5): Initialize the object with array and heap type :param arr: List[int] - initial array :param heap_type: str - \'max\' or \'min\' :param k: int - number of top elements to fetch self.arr = arr self.heap_type = heap_type self.k = k if heap_type == \\"max\\": self.arr = [-x for x in arr] heapq.heapify(self.arr) def insert(self, value: int) -> None: Insert value into the dynamic heap and maintain heap property. :param value: int if self.heap_type == \\"max\\": heapq.heappush(self.arr, -value) else: heapq.heappush(self.arr, value) def fetch_top_k(self) -> List[int]: Fetch the top k elements from the heap. :return: List[int] if self.heap_type == \\"max\\": return sorted([-heapq.heappop(self.arr) for _ in range(min(len(self.arr), self.k))], reverse=True) return sorted([heapq.heappop(self.arr) for _ in range(min(len(self.arr), self.k))]) def heap_sort(self) -> List[int]: Perform heap sort on the array. :return: List[int] - sorted array. sorted_array = [] while self.arr: if self.heap_type == \\"max\\": sorted_array.append(-heapq.heappop(self.arr)) else: sorted_array.append(heapq.heappop(self.arr)) if self.heap_type == \\"max\\": return list(reversed(sorted_array)) return sorted_array"},{"question":"# Ternary Search Challenge # Context: You have been tasked with finding the index of a specific element in a sorted array faster than binary search. Utilizing the divide-and-conquer method, you need to implement a ternary search algorithm. # Problem Statement: Write a function `ternary_search(left: int, right: int, key: int, arr: List[int]) -> int` that searches for a target value (`key`) in a sorted array (`arr`). If the value is found, return its index. Otherwise, return `-1`. # Input: 1. `left` (int): The starting index of the search range. 2. `right` (int): The ending index of the search range. 3. `key` (int): The target value to search for. 4. `arr` (List[int]): The sorted list of integers. # Output: * The index (int) of `key` in `arr` if found. Otherwise, `-1`. # Constraints: * The array `arr` is sorted. * ( 0 leq text{left} leq text{right} < text{len(arr)} ) * ( -10^9 leq text{key} leq 10^9 ) * ( 0 leq text{len(arr)} leq 10^6 ) # Example: ```python assert ternary_search(0, 4, 3, [1, 2, 3, 4, 5]) == 2 assert ternary_search(0, 4, 6, [1, 2, 3, 4, 5]) == -1 assert ternary_search(0, 0, 1, [1]) == 0 assert ternary_search(0, 0, 2, [1]) == -1 ``` # Notes: * Carefully select mid-points using integer division. * Ensure handling of edge-cases, such as empty array or single-element array effectively. * Strive for optimal performance while ensuring clear and correct code.","solution":"from typing import List def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: Uses ternary search algorithm to find the index of key in arr. If the key is found, return its index, otherwise return -1. while right >= left: # breaks arr into three parts mid1 = left + (right - left) // 3 mid2 = right - (right - left) // 3 if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"**Context**: The greatest common divisor (GCD) of two integers is the largest positive integer that divides both numbers without leaving a remainder. The Euclidean algorithm is a classic method to compute the GCD via iterative division, while bitwise manipulation can offer an alternate pathway under certain hardware conditions. This problem will test your ability to create an efficient GCD function using bitwise operators and your ability to handle edge cases effectively. **Task**: Write a Python function `optimized_gcd(a, b)` which calculates the GCD of two non-negative integers `a` and `b` using bitwise operations. The inputs are guaranteed to be non-negative, and at least one of the two integers is non-zero. **Function Signature**: ```python def optimized_gcd(a: int, b: int) -> int: pass ``` **Input Format**: * Two non-negative integers `a` and `b`. **Output Format**: * Return a single integer which is the GCD of `a` and `b`. **Constraints**: * `0 <= a, b <= 10^9` * `a == 0 or b == 0` is guaranteed to be false. **Example**: ```python assert optimized_gcd(48, 18) == 6 assert optimized_gcd(100, 25) == 25 assert optimized_gcd(7, 1) == 1 assert optimized_gcd(0, 99) == 99 # This case will not occur due to constraints, just for understanding assert optimized_gcd(34, 0) == 34 # This case will not occur due to constraints, just for understanding ``` **Instructions**: 1. Implement the function `optimized_gcd` as described. 2. Consider edge cases such as when one of the input values is very large. 3. Make sure to optimize for performance and clarity.","solution":"def optimized_gcd(a: int, b: int) -> int: Compute the greatest common divisor (GCD) using the Euclidean algorithm optimized with bitwise operations. if a == 0: return b if b == 0: return a # Use the fact that GCD(a, b) == GCD(b, a % b) while b != 0: a, b = b, a % b return a"},{"question":"# Coding Exercise: Implement a Custom Cocktail Shaker Sort Context You are working on improving the efficiency of a sorting routine for a retail inventory system. Your system often encounters datasets that are nearly sorted, and you need to implement a sorting algorithm that can efficiently handle such cases. Task Write a Python function `custom_cocktail_shaker_sort(arr)` that sorts a given list of integers `arr` using the Cocktail Shaker Sort algorithm. Your implementation must account for the following features and constraints: Input * A list of integers `arr` with `1 <= len(arr) <= 10^4` where each integer is in the range `-10^5` to `10^5`. Output * The function must return a new list of integers sorted in non-decreasing order. Constraints 1. The algorithm should minimize unnecessary passes. If during a pass (either forward or backward) no swaps are made, the algorithm should terminate early. 2. No auxiliary data structures are allowed (in-place sorting). 3. You should consider edge cases like an already sorted array or an array with duplicate values. Example ```python # Example 1 input_arr = [4, 2, 5, 3, 1] output_arr = custom_cocktail_shaker_sort(input_arr) print(output_arr) # Output: [1, 2, 3, 4, 5] # Example 2 input_arr = [1, 1, 1, 1, 1] output_arr = custom_cocktail_shaker_sort(input_arr) print(output_arr) # Output: [1, 1, 1, 1, 1] ``` Performance Requirements * The implementation should be optimized for scenarios where the array is nearly sorted or contains many duplicate values. * The solution should aim for a best-case time complexity of (O(N)). Note * Implement the function `custom_cocktail_shaker_sort` without using the built-in `sorted` function or any other sorting library calls.","solution":"def custom_cocktail_shaker_sort(arr): Sorts the given list of integers in non-decreasing order using the Cocktail Shaker Sort algorithm. n = len(arr) if n <= 1: return arr # No need to sort if the list has zero or one element start, end = 0, n - 1 while True: swapped = False # Forward pass for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break # Mark the end boundary of the unsorted portion end -= 1 swapped = False # Backward pass for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True if not swapped: break # Mark the start boundary of the unsorted portion start += 1 return arr"},{"question":"# Question: Cycle Detection in a Directed Graph In a software system, various processes depend on each other to complete tasks. Represent this system as a directed graph, where each process is a vertex, and a directed edge from vertex A to vertex B implies process A is waiting for process B to complete. You are required to write a function that detects if there is a cycle in the process dependency graph. A cycle indicates a deadlock, which must be resolved to ensure smooth operation of the system. **Function Signature:** ```python def contains_cycle(graph: dict) -> bool: pass ``` # Input: * `graph`: A dictionary where the keys are strings representing processes (vertices) and the values are lists of strings representing the processes that each key process is waiting for (directed edges). # Output: * `True` if there is a cycle in the graph, otherwise `False`. # Constraints: * The graph can have up to 1000 vertices and 2000 edges. * Vertices are represented by unique string identifiers. * No parallel edges or loops. # Performance Requirements: * Time Complexity: O(V + E), where V is the number of vertices and E is the number of edges. * Space Complexity: O(V). # Example: Input: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } ``` Output: `True` The example above depicts a cycle: B -> D -> E -> B. # Edge Cases to Consider: * A graph with no edges. * A graph with no cycles. * A graph with multiple disconnected components. Implement the `contains_cycle` function using the principles of Depth-First Search (DFS) and its variant for cycle detection as described in the analysis report.","solution":"def contains_cycle(graph): Returns True if there is a cycle in the directed graph, else False. Using Depth-First Search (DFS) with coloring method, where: - `WHITE`: the node has not been visited. - `GRAY`: the node is in the current path. - `BLACK`: the node has been fully explored. WHITE, GRAY, BLACK = 0, 1, 2 color = {node: WHITE for node in graph} def dfs(node): if color[node] == GRAY: return True if color[node] == BLACK: return False color[node] = GRAY for neighbor in graph[node]: if dfs(neighbor): return True color[node] = BLACK return False for node in graph: if color[node] == WHITE: if dfs(node): return True return False"},{"question":"# Question Imagine you are a software engineer for a history tracking system in a web browser. You are tasked with implementing a simplified version of the browser\'s forward and backward history functionality using a doubly linked list. Task 1. **Implement the `DoublyLinkedListNode` class**: - Initialize with value, next pointer, and previous pointer. 2. **Write a class `BrowserHistory`** to manage the browser\'s navigation history with the following methods: - `visit(page: str) -> None`: Add a new page to the history and clear any forward history if it exists. - `back(steps: int) -> str`: Move backward by the specified number of steps in history and return the current page. If `steps` exceed the available history, return the earliest page. - `forward(steps: int) -> str`: Move forward by the specified number of steps in history and return the current page. If `steps` exceed the available forward history, return the latest page. Example Usage ```python browser_history = BrowserHistory(\\"leetcode.com\\") browser_history.visit(\\"google.com\\") # History: leetcode.com -> google.com browser_history.visit(\\"facebook.com\\") # History: leetcode.com -> google.com -> facebook.com browser_history.visit(\\"youtube.com\\") # History: leetcode.com -> google.com -> facebook.com -> youtube.com assert browser_history.back(1) == \\"facebook.com\\" # Current Page: facebook.com assert browser_history.back(1) == \\"google.com\\" # Current Page: google.com assert browser_history.forward(1) == \\"facebook.com\\" # Current Page: facebook.com browser_history.visit(\\"linkedin.com\\") # History: google.com -> facebook.com -> linkedin.com assert browser_history.forward(2) == \\"linkedin.com\\" # Cannot move forward any further, remain at linkedin.com assert browser_history.back(2) == \\"google.com\\" # Current Page: google.com assert browser_history.back(2) == \\"leetcode.com\\" # Current Page: leetcode.com ``` Constraints - The number of calls to `visit`, `back`, and `forward` is up to 10000. - The length of each page URL will be within the range [1, 20]. Ensure your implementation efficiently handles the operations and adheres to O(1) complexity for adding, and removing nodes, and O(n) in the worst case for moving steps across the list.","solution":"class DoublyLinkedListNode: def __init__(self, value: str): self.value = value self.next = None self.prev = None class BrowserHistory: def __init__(self, homepage: str): self.head = self.current = DoublyLinkedListNode(homepage) def visit(self, page: str) -> None: new_node = DoublyLinkedListNode(page) self.current.next = new_node new_node.prev = self.current self.current = new_node def back(self, steps: int) -> str: while self.current.prev and steps > 0: self.current = self.current.prev steps -= 1 return self.current.value def forward(self, steps: int) -> str: while self.current.next and steps > 0: self.current = self.current.next steps -= 1 return self.current.value"},{"question":"**Selection Sort with Custom Comparator** Given an array of integers, write a function to sort the array using Selection Sort. However, instead of the regular ascending order, the array should be sorted based on a custom comparator function that you will also implement. # Input: - **arr**: A list of integers (e.g., [3, 1, 4, 1, 5, 9, 2, 6]) - **comp**: A comparator function that takes two integers as input and returns a negative number if the first is \'less\' than the second, zero if they are equivalent, and a positive number otherwise. # Output: - Return the sorted array, where the order is determined by the comparator function. # Constraints: - The input array length will be between 0 and 1000. - All integers in the array will be between -10^6 and 10^6. - You must use Selection Sort as your algorithm. # Performance Requirements: - The function should run in O(n^2) time complexity. - The function should use O(1) additional space (in-place sorting). # Example: ```python # Comparator function: sort in descending order def comp(a, b): return b - a # Example usage arr = [3, 1, 4, 1, 5, 9, 2, 6] sorted_arr = selection_sort_custom(arr, comp) print(sorted_arr) # Output: [9, 6, 5, 4, 3, 2, 1, 1] ``` # Specifications: - **Function Name**: `selection_sort_custom` - **Parameters**: - `arr`: List[int] - `comp`: Callable[[int, int], int] - **Returns**: List[int] # Additional Context: Imagine you are tasked with sorting records not simply by numerical values, but by custom criteria—for instance, arranging scores based on a custom grading system. The comparator function allows flexibility to handle various sorting requirements easily.","solution":"def selection_sort_custom(arr, comp): Sorts an array using selection sort with a custom comparator function. Parameters: arr (List[int]): The list to be sorted. comp (Callable[[int, int], int]): A comparator function that returns a negative number if the first argument is \'less\' than the second, zero if they are equivalent, and a positive number otherwise. Returns: List[int]: The sorted list. n = len(arr) for i in range(n): min_idx = i for j in range(i + 1, n): if comp(arr[j], arr[min_idx]) < 0: min_idx = j arr[i], arr[min_idx] = arr[min_idx], arr[i] return arr # Example comparator that sorts in descending order def comp(a, b): return b - a"},{"question":"You are given a set of labeled training vectors and an input vector. Your task is to implement a function that determines the label of the input vector using the nearest neighbor algorithm. Function Signature ```python def nearest_neighbor_classification(x: tuple, tSet: dict) -> any: Determine the label of the input vector \'x\' using the nearest neighbor algorithm. Arguments: - x: A tuple, the input vector. Length of the tuple is assumed to be equal to the length of the vectors in \'tSet\'. - tSet: A dictionary where the keys are tuples representing vectors, and values are labels. Returns: - The label of the vector in `tSet` that is closest to `x`. pass ``` Input - `x`: A tuple of numeric values representing the input vector. - `tSet`: A dictionary where keys are tuples (vectors) and values are the labels associated with those vectors. Output - Returns the label (value) of the nearest neighbor from the training set. Constraints - All vectors (tuples) in the input will be numeric. - The length of the input vector `x` will match the length of the vectors in `tSet`. Example ```python # Training set tSet = { (1.5, 2.3): \'A\', (3.1, 4.2): \'B\', (1.1, 1.8): \'A\', (3.5, 3.8): \'B\' } # Input vector x = (2.0, 3.0) # Expected Output # \'B\' because the nearest neighbor to (2.0, 3.0) is (3.1, 4.2) or (3.5, 3.8) and both have label \'B\'. print(nearest_neighbor_classification(x, tSet)) # Output: \'B\' ``` Consider performance implications when dealing with large and high-dimensional datasets. Implement appropriate edge case handling and demonstrate efficient computation principles.","solution":"def nearest_neighbor_classification(x: tuple, tSet: dict) -> any: Determine the label of the input vector \'x\' using the nearest neighbor algorithm. Arguments: - x: A tuple, the input vector. Length of the tuple is assumed to be equal to the length of the vectors in \'tSet\'. - tSet: A dictionary where the keys are tuples representing vectors, and values are labels. Returns: - The label of the vector in `tSet` that is closest to `x`. def euclidean_distance(p1, p2): return sum((p1[i] - p2[i]) ** 2 for i in range(len(p1))) ** 0.5 nearest_vector = None min_distance = float(\'inf\') for vector in tSet: distance = euclidean_distance(x, vector) if distance < min_distance: min_distance = distance nearest_vector = vector return tSet[nearest_vector]"},{"question":"You are given an array of integers, and you need to sort this array using the Pigeonhole Sort algorithm. The function should closely follow the principles of the Pigeonhole Sort, ensuring efficient sorting for appropriate arrays. # Function Signature ```python def pigeonhole_sort(arr: List[int]) -> List[int]: ``` # Input - `arr` (List[int]): A list of integers where the elements and the range of values are closely matched. # Output - (List[int]): A sorted list of integers. # Constraints - 1 <= len(arr) <= 10^5 - -10^5 <= arr[i] <= 10^5 for all i in arr # Requirements - The function should be able to handle empty arrays and return an empty list. - The function should handle arrays where all elements are the same. - The function should work efficiently for arrays where the range of values (`Max - Min`) is small. # Example ```python print(pigeonhole_sort([8, 3, 2, 7, 4])) # Output: [2, 3, 4, 7, 8] print(pigeonhole_sort([8, 8, 8, 8])) # Output: [8, 8, 8, 8] print(pigeonhole_sort([])) # Output: [] print(pigeonhole_sort([-3, -1, -2])) # Output: [-3, -2, -1] ``` # Scenario Imagine you are tasked with sorting log entries of timestamps. Each timestamp is recorded as an integer representing seconds since the epoch (1/1/1970). If the log file typically records entries on a time scale of seconds within a limited window (e.g., 0 to 1000 seconds in a minute of high activity), implement a sorting function using Pigeonhole Sort to efficiently organize these timestamps.","solution":"from typing import List def pigeonhole_sort(arr: List[int]) -> List[int]: if len(arr) == 0: return arr min_value = min(arr) max_value = max(arr) size = max_value - min_value + 1 holes = [0] * size for number in arr: holes[number - min_value] += 1 sorted_arr = [] for i in range(size): while holes[i] > 0: sorted_arr.append(i + min_value) holes[i] -= 1 return sorted_arr"},{"question":"# Minimum Deletion Steps to Make Two Strings Identical Problem Description Given two strings `word1` and `word2`, you need to find the minimum number of steps required to make `word1` and `word2` identical. In each step, you can delete a single character from either string. Input - Two non-empty strings `word1` and `word2`. Output - An integer representing the minimum number of deletion steps required. Constraints - The length of each string is at most 1000. - The strings consist of lowercase English characters only. Example ```python Input: \\"sea\\", \\"eat\\" Output: 2 Explanation: You need to delete two characters to make the strings identical. Delete \'s\' from \\"sea\\" to get \\"ea\\", then delete \'t\' from \\"eat\\" to get \\"ea\\". ``` Function Signature ```python def min_deletion_steps(word1: str, word2: str) -> int: # Implementation goes here pass ``` Requirements: - Implement the function `min_deletion_steps` that accepts two string arguments and returns an integer representing the minimum number of deletions required. - Optimize the function for both time and space complexity where possible. Additional Notes - Consider edge cases where one or both strings are empty, or where there is no common subsequence. - Focus on efficiency for larger input sizes (near the upper constraint limits).","solution":"def min_deletion_steps(word1: str, word2: str) -> int: Returns the minimum number of deletion steps required to make word1 and word2 identical. # Find the length of the longest common subsequence (LCS) m, n = len(word1), len(word2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) lcs_length = dp[m][n] return (m + n) - 2 * lcs_length"},{"question":"# Binary Indexed Tree Challenge **Objective**: You are provided with an implementation of the Fenwick Tree (also known as the Binary Indexed Tree) to perform efficient prefix sum queries and single element updates on an array. Your task is to implement additional functionalities to enhance its capabilities. # Task: 1. Implement the function `range_sum(bit_tree, left, right)` that returns the sum of elements from index `left` to `right` (both inclusive) in the given `bit_tree`. This should be accomplished using efficient prefix sum queries. 2. Implement the method `scale_down(bit_tree, c)` that scales every element in the array down by a given integer \'c\' using efficient update operations. Specifications: * **Function Signatures**: * `def range_sum(bit_tree, left, right):` * `def scale_down(bit_tree, c):` * **Input**: * `bit_tree`: The binary indexed tree constructed. * `left` and `right`: Indices defining the range for summation. * `c`: Integer value by which every element in the array should be scaled down. * **Output**: * For `range_sum`: Integer sum of the values in the specified range. * For `scale_down`: In-place updated `bit_tree`. Constraints: * Assume typical integer inputs. * Indices will be valid and within the bounds of the BIT. Example: Given the array `arr = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2]` and its constructed BIT, perform the following: ```python bit_tree = Fenwick_Tree(arr).construct() # Range sum query rsum = range_sum(bit_tree, 2, 5) print(rsum) # Outputs the result of sum of elements from index 2 to 5. # Scale down operation scale_down(bit_tree, 2) print(bit_tree) # Outputs the updated BIT structure. ```","solution":"class Fenwick_Tree: def __init__(self, input_array): self.arr = input_array[:] self.n = len(input_array) self.bit = [0] * (self.n + 1) def update(self, idx, val): idx += 1 # BIT index starts from 1 while idx <= self.n: self.bit[idx] += val idx += (idx & -idx) def query(self, idx): idx += 1 # BIT index starts from 1 sum_val = 0 while idx > 0: sum_val += self.bit[idx] idx -= (idx & -idx) return sum_val def construct(self): for idx, value in enumerate(self.arr): self.update(idx, value) return self.bit def range_sum(bit_tree, left, right): bit = bit_tree.bit fenwick_tree = Fenwick_Tree([]) fenwick_tree.bit = bit fenwick_tree.n = len(bit) - 1 return fenwick_tree.query(right) - fenwick_tree.query(left - 1) def scale_down(bit_tree, c): fenwick_tree = Fenwick_Tree([]) fenwick_tree.bit = bit_tree.bit fenwick_tree.n = len(bit_tree.bit) - 1 for i in range(fenwick_tree.n): current_val = (fenwick_tree.query(i) - fenwick_tree.query(i - 1)) // c fenwick_tree.update(i, current_val - (fenwick_tree.query(i) - fenwick_tree.query(i - 1)))"},{"question":"Stutter a Stack Given an input stack, design and implement a function `stutter_stack` that takes a stack as a list of integers as a parameter and replaces every value in the stack with two occurrences of that value. You may not use any other stack as auxiliary storage but may use other data structures. **Function Signature:** ```python def stutter_stack(stack: List[int]) -> List[int]: pass ``` **Input:** * `stack` (List[int]): A list of integers representing the stack in sequential order from bottom to top. **Output:** * `stack` (List[int]): A list of integers where each integer from the input stack appears twice, preserving the original order in a Last-In-First-Out manner. **Constraints:** * The input list (i.e., stack) can be of any length from 0 to 10^4. * The integers in the stack can be any valid integer in Python. **Performance Requirements:** * Aim for an algorithm with a time complexity of O(n) and a space complexity not exceeding O(n). **Examples:** 1. If the stack initially is `[3, 7, 1, 14, 9]` - After stuttering the stack becomes `[3, 3, 7, 7, 1, 1, 14, 14, 9, 9]`. 2. If the stack is `[]` - The result should be `[]`. 3. If the stack is `[6]` - The result should be `[6, 6]`. Implement the `stutter_stack` function to achieve the desired results based on the provided examples.","solution":"from typing import List def stutter_stack(stack: List[int]) -> List[int]: Replace every value in the stack with two occurrences of that value. :param stack: List of integers representing the stack from bottom to top. :return: List of integers with each integer appearing twice. if not stack: return stack stuttered_stack = [] for item in stack: stuttered_stack.extend([item, item]) return stuttered_stack"},{"question":"# Coding Challenge: Implementing a Heapsort Variant **Problem Statement**: Given an array of integers, implement a Heapsort algorithm to sort the array in ascending order. You are required to write the `ascending_heap_sort` function using a max heap to achieve the sort. Additionally, you must add functionality to handle cases to output debug information of each intermediate step if a debug mode is enabled. **Function Signature**: ```python def ascending_heap_sort(arr: List[int], debug: bool = False) -> List[int]: pass ``` **Input**: - `arr`: A list of integers `[a1, a2, ..., an]` where `1 <= len(arr) <= 10^6` - `debug`: A boolean flag indicating if debugging information should be printed. **Output**: - The sorted list of integers in ascending order. **Constraints**: 1. You must use a max heap approach to sort. 2. If `debug` is True, your function should print the array at each modification step. The format is: `iteration i : <array_elements>` **Example**: ```python # Example 1 arr = [3, 1, 4, 1, 5, 9, 2, 6] print(ascending_heap_sort(arr)) # Output: [1, 1, 2, 3, 4, 5, 6, 9] # Example 2 arr = [3, 1, 4, 1, 5, 9, 2, 6] ascending_heap_sort(arr, debug=True) # Expected debug output: # iteration 1: [6, 3, 4, 2, 5, 9, 1, 1] # iteration 2: [1, 3, 2, 1, 5, 4, 9, 6] # ... # Final output: [1, 1, 2, 3, 4, 5, 6, 9] ``` **Note**: - You can use helper functions where necessary. - Consider edge cases like empty arrays, a list with single element, and arrays with all identical elements.","solution":"def ascending_heap_sort(arr, debug=False): def heapify(arr, n, i, debug_info): largest = i left = 2 * i + 1 right = 2 * i + 2 # If left child is larger than root if left < n and arr[i] < arr[left]: largest = left # If right child is larger than largest so far if right < n and arr[largest] < arr[right]: largest = right # If largest is not root if largest != i: arr[i], arr[largest] = arr[largest], arr[i] # If debugging, add the state of the array if debug: debug_info.append(list(arr)) # Recursively heapify the affected sub-tree heapify(arr, n, largest, debug_info) n = len(arr) debug_info = [] # Build a maxheap. for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i, debug_info) if debug: print(f\\"After building max heap: {arr}\\") # One by one extract elements for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] heapify(arr, i, 0, debug_info) if debug: print(f\\"iteration {n-i}: {arr}\\") return arr"},{"question":"You are given a binary tree. Implement a function to perform a postorder traversal of the tree and return the list of visited nodes. The function should be implemented in two ways: 1. **Iteratively**: Using an explicit stack. 2. **Recursively**: Using function calls. Consider the following class definition for the tree node: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ``` # Constraints * The tree can have up to `10^4` nodes. * Node values are unique integers. # Function Signature * `def postorder_iterative(root: Node) -> List[int]:` * `def postorder_recursive(root: Node) -> List[int]:` # Examples Example 1 Input: A tree with the following structure: ``` 1 / 2 3 / 4 5 ``` Output: For both functions `postorder_iterative` and `postorder_recursive`, the output should be: [4, 5, 2, 3, 1] Example 2 Input: A tree with a single node: ``` 1 ``` Output: For both functions `postorder_iterative` and `postorder_recursive`, the output should be: [1] Example 3 Input: An empty tree (root is `None`). Output: For both functions `postorder_iterative` and `postorder_recursive`, the output should be: [] # Note Ensure that your solution handles edge cases such as an empty tree or a tree with only one node.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def postorder_iterative(root: Node) -> list[int]: if not root: return [] result = [] stack = [root] while stack: node = stack.pop() result.append(node.val) if node.left: stack.append(node.left) if node.right: stack.append(node.right) return result[::-1] def postorder_recursive(root: Node) -> list[int]: def helper(node, result): if not node: return helper(node.left, result) helper(node.right, result) result.append(node.val) result = [] helper(root, result) return result"},{"question":"# Scenario You are developing a validation tool for a software system where you need to verify if certain configurations follow a repeated pattern format. Implement a function that determines if a given string can be constructed by repeating a substring of itself. # Task Write a function `repeat_substring(s)` that takes a single non-empty string `s` and returns `True` if it can be constructed by repeating a substring, and `False` otherwise. # Input - `s` (1 ≤ len(s) ≤ 10^4): The input string consisting of lowercase English letters. # Output - A boolean value: `True` or `False`. # Examples 1. `repeat_substring(\\"abab\\")` - **Output**: `True` - **Explanation**: It\'s constructed by repeating the substring \\"ab\\". 2. `repeat_substring(\\"aba\\")` - **Output**: `False` - **Explanation**: No substring can form it by repeating. 3. `repeat_substring(\\"abcabcabcabc\\")` - **Output**: `True` - **Explanation**: It\'s constructed by repeating the substring \\"abc\\". # Constraints - The function should be efficient with a time complexity of O(n) and space complexity of O(n). - Do not use built-in string matching functions like Python\'s `re` module for pattern matching. # Function Signature ```python def repeat_substring(s: str) -> bool: ```","solution":"def repeat_substring(s: str) -> bool: Determines if the input string can be constructed by repeating a substring of itself. n = len(s) for i in range(1, n // 2 + 1): if n % i == 0: # Only consider lengths that can divide the string evenly if s[:i] * (n // i) == s: return True return False"},{"question":"# Trie Implementation and Usage Objective You are tasked with implementing a trie (prefix tree) from scratch and using it to solve a specific problem. Your implementation should support insertion of words, searching for exact words, and prefix search functionality as described. Problem Statement Given a list of strings, implement a system that can: - Insert each string into the trie. - Return the count of strings matching a given prefix. # Function Signature ```python class TrieNode: def __init__(self): self.children = collections.defaultdict(TrieNode) self.is_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: pass def search(self, word: str) -> bool: pass def starts_with(self, prefix: str) -> bool: pass def count_words_with_prefix(self, prefix: str) -> int: pass ``` # Input: - A list of strings `words` where each string consists of lowercase letters (\'a\' to \'z\'). (1 <= len(words) <= 10^4, 1 <= len(word) <= 100) - A list of prefix queries `prefixes` where each string consists of lowercase letters (\'a\' to \'z\'). (1 <= len(prefixes) <= 10^3, 1 <= len(prefix) <= 100) # Output: - For each prefix query, return the number of words in the trie that start with the given prefix. # Constraints: - The input strings are composed of lowercase English letters only. - The operations should be optimized to handle up to 10^4 insertions and 10^3 prefix queries efficiently. # Example: ```python trie = Trie() trie.insert(\\"apple\\") trie.insert(\\"app\\") trie.insert(\\"apex\\") print(trie.count_words_with_prefix(\\"ap\\")) # Output: 3 (includes \\"apple\\", \\"app\\", \\"apex\\") print(trie.count_words_with_prefix(\\"app\\")) # Output: 2 (includes \\"apple\\", \\"app\\") print(trie.count_words_with_prefix(\\"apple\\")) # Output: 1 (includes \\"apple\\") print(trie.count_words_with_prefix(\\"banana\\")) # Output: 0 ``` # Guidelines - Implement the `TrieNode` and `Trie` classes with methods `insert`, `search`, and `starts_with`. - Implement an additional method `count_words_with_prefix` that returns the number of words in the trie starting with a specified prefix. - Ensure that your solutions handle edge cases and constraints effectively.","solution":"from collections import defaultdict class TrieNode: def __init__(self): self.children = defaultdict(TrieNode) self.is_word = False self.word_count = 0 # To keep count of words passing through this node class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: node = node.children[char] node.word_count += 1 # Increment word count for each node in the path node.is_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_word def starts_with(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True def count_words_with_prefix(self, prefix: str) -> int: node = self.root for char in prefix: if char not in node.children: return 0 node = node.children[char] return node.word_count"},{"question":"**Subset Generation Task** **Context**: You are asked to design a utility for a data analysis application. One crucial requirement is that given a set of distinct integers, you need to generate all possible subsets (i.e., the power set) of those integers. **Task**: Implement a function `generate_subsets(nums)` that accepts a list of distinct integers and returns a set of tuples, where each tuple represents a unique subset of the input list. **Function Signature**: ```python def generate_subsets(nums: List[int]) -> Set[Tuple[int]]: ``` **Input**: - `nums` (List[int]): A list of distinct integers (0 ≤ len(nums) ≤ 20). **Output**: - A set of tuples, where each tuple is a unique subset of `nums`. **Examples**: ```python generate_subsets([1, 2, 3]) # Expected output: {(), (1, 2, 3), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3)} generate_subsets([5]) # Expected output: {(), (5,)} generate_subsets([]) # Expected output: {()} ``` **Constraints**: - The solution set must not contain duplicate subsets. - The input list will only contain distinct integers. **Requirements**: - Your solution should have a time complexity of O(n * 2^n) and a space complexity of O(2^n). **Hints**: - Pay attention to the bit manipulation technique for efficiently generating subsets. - Ensure your solution handles edge cases, such as empty input and single-element input, correctly.","solution":"from typing import List, Set, Tuple def generate_subsets(nums: List[int]) -> Set[Tuple[int]]: Given a list of distinct integers, generate all possible subsets of those integers. Args: nums (List[int]): A list of distinct integers. Returns: Set[Tuple[int]]: A set of tuples, where each tuple is a unique subset of `nums`. def backtrack(start: int, path: List[int]): subsets.add(tuple(path)) for i in range(start, len(nums)): path.append(nums[i]) backtrack(i + 1, path) path.pop() subsets = set() backtrack(0, []) return subsets"},{"question":"**Context**: You are working as a software engineer for a large-scale application. One critical component of your system involves task scheduling, where each task is dependent on the completion of other tasks. To ensure the feasibility of scheduling and avoid potential deadlocks, you need to check whether the task dependencies form a cycle. **Problem Statement**: Given a directed graph representing the task dependencies, write a function `detect_cycle(graph)` that determines if the graph contains a cycle. - The graph is represented as a dictionary where keys are task identifiers (strings) and values are lists of task identifiers that the key task depends on. **Function Signature**: ```python def detect_cycle(graph: Dict[str, List[str]]) -> bool: pass ``` **Input**: - `graph`: A dictionary `Dict[str, List[str]]` where each key is a task identifier (string), and the corresponding value is a list of task identifiers that the key task depends on. **Output**: - Returns `True` if there is a cycle in the graph; otherwise, returns `False`. **Examples**: ```python graph1 = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } print(detect_cycle(graph1)) # Output: True graph2 = { \'1\': [\'2\'], \'2\': [\'3\'], \'3\': [] } print(detect_cycle(graph2)) # Output: False graph3 = { \'x\': [\'y\'], \'y\': [\'z\'], \'z\': [\'x\'] } print(detect_cycle(graph3)) # Output: True ``` **Constraints**: 1. The number of tasks (vertices) `N` is in the range of [1, 1000]. 2. Each task identifier is a string with a length in the range [1, 100]. 3. The graph does not need to be connected. **Notes**: - Consider edge cases, such as isolated tasks and self-loops. - Aim for a time complexity of O(V + E) and a space complexity of O(V).","solution":"from typing import List, Dict def detect_cycle(graph: Dict[str, List[str]]) -> bool: Detects if there is a cycle in the given directed graph. :param graph: A dictionary representing the graph where keys are task identifiers and values are lists of dependent task identifiers. :return: True if there is a cycle, otherwise False. def visit(node): if node in temp_mark: return True if node in perm_mark: return False temp_mark.add(node) for neighbor in graph.get(node, []): if visit(neighbor): return True temp_mark.remove(node) perm_mark.add(node) return False temp_mark = set() perm_mark = set() for node in graph: if visit(node): return True return False"},{"question":"# Task You are provided with an incomplete implementation of a Binary Search Tree (BST) class in Python. Your goal is to complete and extend this implementation to handle some additional operations. Operations to Implement: 1. **Delete**: Remove a node with a given value from the tree. 2. **Find Minimum**: Find and return the minimum value in the tree. 3. **Find Maximum**: Find and return the maximum value in the tree. # Requirements: 1. **delete(data)**: This method should remove a node with the given `data` from the BST. If the node is not found, the tree should remain unchanged. 2. **find_min()**: This method should return the minimum value in the BST. 3. **find_max()**: This method should return the maximum value in the BST. # Constraints: - The BST will contain only integers. - The values in the BST are unique. - You should handle edge cases such as trying to delete a node that does not exist in the tree. # Input Format: - The methods are part of the `BST` class. - The methods will be called on instances of the `BST` class which might have multiple elements. # Output Format: - The `delete` method should modify the BST. - The `find_min` and `find_max` methods should return integers. # Example: ```python # Example tree for reference: # 10 # / # 6 15 # / / # 4 9 12 24 # / / # 7 20 30 # / # 18 ``` Given the above tree: - `find_min()` should return `4` - `find_max()` should return `30` - After `delete(4)`, `find_min()` should return `6` - After `delete(15)`, the tree should be updated appropriately maintaining BST properties. # Additional Instructions: 1. **Avoid using libraries**: Implement the logic without utilizing any tree-specific data structure libraries. 2. **Unit Testing**: Define test cases using the `unittest` framework to validate your methods.","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, data): if not self.root: self.root = Node(data) else: self._insert(data, self.root) def _insert(self, data, node): if data < node.data: if node.left: self._insert(data, node.left) else: node.left = Node(data) else: if node.right: self._insert(data, node.right) else: node.right = Node(data) def delete(self, data): self.root = self._delete(self.root, data) def _delete(self, node, data): if not node: return node if data < node.data: node.left = self._delete(node.left, data) elif data > node.data: node.right = self._delete(node.right, data) else: if not node.left: return node.right elif not node.right: return node.left temp = self._find_min(node.right) node.data = temp.data node.right = self._delete(node.right, temp.data) return node def find_min(self): if self.root: min_node = self._find_min(self.root) return min_node.data if min_node else None return None def _find_min(self, node): current = node while current and current.left: current = current.left return current def find_max(self): if self.root: max_node = self._find_max(self.root) return max_node.data if max_node else None return None def _find_max(self, node): current = node while current and current.right: current = current.right return current"},{"question":"Binomial Coefficient with Memoization Many combinatorial problems, such as those involving subsets, can be solved efficiently by calculating the binomial coefficient, C(n, k). Understanding and optimizing these calculations is crucial. **Objective**: Your task is to implement an optimized version of the binomial coefficient calculation using dynamic programming (memoization) to improve performance. **Problem Statement**: Write a Python function `binomial_coefficient` that calculates the binomial coefficient C(n, k). The function should use memoization to avoid redundant calculations and improve efficiency over the naive recursive approach. **Function Signature**: ```python def binomial_coefficient(n: int, k: int) -> int: pass ``` **Input**: * `n` (0 <= n <= 1000) - Number of elements in the set. * `k` (0 <= k <= n) - Number of elements to choose from the set. **Output**: * Return the binomial coefficient C(n, k). **Constraints**: * Assume valid integer inputs are given according to the problem statement constraints. * Time complexity should preferably be O(n*k). **Examples**: ```python assert binomial_coefficient(5, 0) == 1 assert binomial_coefficient(8, 2) == 28 assert binomial_coefficient(20, 10) == 184756 ``` **Requirements**: * The solution should handle large inputs efficiently by leveraging memoization. * The solution should be well-documented with comments explaining the approach. **Scenario**: Imagine you are developing a combinatorial library that will be used extensively for statistical analysis involving large datasets. Efficiently calculating the binomial coefficient is a crucial part of this library.","solution":"def binomial_coefficient(n: int, k: int) -> int: Calculate the binomial coefficient C(n, k) using memoization. Args: n (int): Number of elements in the set. k (int): Number of elements to choose from the set. Returns: int: The binomial coefficient C(n, k). # Create a memoization table memo = [[-1 for _ in range(k + 1)] for _ in range(n + 1)] def compute(n, k): # Base cases if k == 0 or k == n: return 1 # If value already computed, return it if memo[n][k] != -1: return memo[n][k] # Compute value and store in memo table memo[n][k] = compute(n - 1, k - 1) + compute(n - 1, k) return memo[n][k] return compute(n, k)"},{"question":"Scenario You are working on a project that involves a lot of number theory based calculations. One of your tasks is to efficiently compute the Euler\'s Totient function, which counts the number of integers up to a given integer n that are coprime with n. Your implementation is used in a performance-critical part of the system and needs to be both efficient and robust. Task Implement the function `optimized_totient(n)` that takes a single integer `n` and returns the count of integers from 1 to n that are coprime with n, leveraging the insights from the classical Euler\'s Totient function. # Input * An integer `n` (1 ≤ n ≤ 10^6). # Output * An integer representing the count of integers from 1 to n that are coprime with n. # Constraints 1. The function should run efficiently within the given input constraint. 2. You cannot use pre-built library functions for this task. You should implement the logic from scratch. 3. Consider all edge cases such as n being a prime number or 1. # Performance Requirements * Your algorithm should have a time complexity of O(√n). # Example ```python print(optimized_totient(9)) # Output: 6 print(optimized_totient(10)) # Output: 4 print(optimized_totient(1)) # Output: 1 ``` # Note For `n = 9`, the integers 1, 2, 4, 5, 7, and 8 are coprime with 9. For `n = 10`, the integers 1, 3, 7, and 9 are coprime with 10. # Additional Context (if necessary) Euler\'s Totient function is crucial in cryptographic algorithms such as RSA, where understanding and calculating coprimes is necessary for key generation and encryption processes.","solution":"def optimized_totient(n): Computes the Euler\'s Totient function of n efficiently. if n == 1: return 1 result = n p = 2 # Check for every number to see if it is a prime factor of n while p * p <= n: if n % p == 0: # If p is a prime factor, subtract its multiples less than or equal to n while n % p == 0: n //= p result -= result // p p += 1 # If there is a prime factor greater than sqrt(n) if n > 1: result -= result // n return result"},{"question":"# B-Tree Operations - Advanced Coding Challenge Objective Design and implement a class `BTree` that supports efficient insertion, search, and deletion operations while maintaining the properties of a B-Tree of minimum degree `t`. Context You are given the task of designing a B-Tree for a database indexing system. This system needs to efficiently handle frequent insertions, deletions, and fast search operations over potentially large datasets. The B-Tree should be height-balanced, ensuring an efficient log-based complexity for these operations. Task 1. **Insertion**: Implement a function `insert_key(self, key: int)` to insert a new key into the B-Tree. - Input: A key (integer) to be inserted. - Output: None (modifies the tree in-place). 2. **Search**: Implement a function `find(self, key: int) -> bool` to search for a given key in the B-Tree. - Input: A key (integer) to search. - Output: `True` if the key is found, `False` otherwise. 3. **Deletion**: Implement a function `remove_key(self, key: int)` to remove a specific key from the B-Tree. - Input: A key (integer) to be removed. - Output: None (modifies the tree in-place). 4. **Traversal**: Implement a function `traverse_tree(self)` to traverse and print the keys of the tree in an in-order manner. - Input: None. - Output: Prints the keys in sorted order. Constraints * The B-Tree degree `t` is at least 2. * All the keys are integers. Performance Requirement * Ensure that all operations (`insert_key`, `find`, `remove_key`) have a time complexity of `O(log n)`, where `n` is the number of keys in the tree. * The tree should always remain height-balanced with a maximum height of `O(log_t(n))`. Additional Notes 1. **Edge Cases**: - Insert into an empty tree. - Delete keys that require node balancing. - Handle duplicates gracefully (if not allowed, ignore subsequent same key insert requests). 2. **Error Handling**: - Ensure the tree does not enter an inconsistent state after operations. - Gracefully handle underflows during deletions by merging or borrowing from siblings. Example: ```python btree = BTree(3) btree.insert_key(10) btree.insert_key(20) btree.insert_key(5) btree.insert_key(6) btree.insert_key(12) btree.insert_key(30) btree.insert_key(7) btree.insert_key(17) assert btree.find(6) == True assert btree.find(15) == False btree.traverse_tree() # Expected Output: 5 6 7 10 12 17 20 30 btree.remove_key(6) btree.traverse_tree() # Expected Output: 5 7 10 12 17 20 30 btree.remove_key(15) # Key not found btree.traverse_tree() # Expected Output: 5 7 10 12 17 20 30 ``` Implement the `BTree` class with the above functionality to meet the requirements of the database indexing system.","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t # Minimum degree (defines the range for number of keys) self.leaf = leaf # True if leaf node, else False self.keys = [] # List of keys in the node self.children = [] # List of child nodes def insert_non_full(self, key): Inserts a key into this node. Assumes this node is non-full when called. i = len(self.keys) - 1 if self.leaf: # Insert the new key into the correct location by shifting keys greater than key self.keys.append(None) while i >= 0 and key < self.keys[i]: self.keys[i + 1] = self.keys[i] i -= 1 self.keys[i + 1] = key else: # Locate the child which is going to have the new key while i >= 0 and key < self.keys[i]: i -= 1 i += 1 # Split the child if it is full if len(self.children[i].keys) == (2 * self.t) - 1: self.split_child(i) if key > self.keys[i]: i += 1 self.children[i].insert_non_full(key) def split_child(self, i): Splits the full child of this node at index i into two nodes. t = self.t y = self.children[i] z = BTreeNode(t, y.leaf) self.children.insert(i + 1, z) self.keys.insert(i, y.keys[t - 1]) z.keys = y.keys[t:(2 * t) - 1] y.keys = y.keys[0:t - 1] if not y.leaf: z.children = y.children[t:(2 * t)] y.children = y.children[0:t] class BTree: def __init__(self, t): self.t = t # Minimum degree self.root = BTreeNode(t, True) def insert_key(self, key): root = self.root if len(root.keys) == (2 * self.t) - 1: temp = BTreeNode(self.t, False) temp.children.append(self.root) temp.split_child(0) self.root = temp temp.insert_non_full(key) else: root.insert_non_full(key) def find(self, key): def _find(node, key): i = 0 while i < len(node.keys) and key > node.keys[i]: i += 1 if i < len(node.keys) and key == node.keys[i]: return True if node.leaf: return False return _find(node.children[i], key) return _find(self.root, key) def traverse_tree(self): def _traverse(node): for i, key in enumerate(node.keys): if not node.leaf: _traverse(node.children[i]) print(key, end=\' \') if not node.leaf: _traverse(node.children[-1]) _traverse(self.root) print() def remove_key(self, key): def _remove(node, key): t = node.t def _merge(idx): child = node.children[idx] sibling = node.children[idx + 1] child.keys.append(node.keys[idx]) child.keys.extend(sibling.keys) if not child.leaf: child.children.extend(sibling.children) node.keys.pop(idx) node.children.pop(idx + 1) def _borrow_from_prev(idx): child = node.children[idx] sibling = node.children[idx - 1] child.keys.insert(0, node.keys[idx - 1]) if not child.leaf: child.children.insert(0, sibling.children.pop()) node.keys[idx - 1] = sibling.keys.pop() def _borrow_from_next(idx): child = node.children[idx] sibling = node.children[idx + 1] child.keys.append(node.keys[idx]) if not child.leaf: child.children.append(sibling.children.pop(0)) node.keys[idx] = sibling.keys.pop(0) def _get_pred(idx): cur = node.children[idx] while not cur.leaf: cur = cur.children[-1] return cur.keys[-1] def _get_succ(idx): cur = node.children[idx + 1] while not cur.leaf: cur = cur.children[0] return cur.keys[0] idx = 0 while idx < len(node.keys) and node.keys[idx] < key: idx += 1 if idx < len(node.keys) and node.keys[idx] == key: if node.leaf: node.keys.pop(idx) else: if len(node.children[idx].keys) >= t: pred = _get_pred(idx) node.keys[idx] = pred _remove(node.children[idx], pred) elif len(node.children[idx + 1].keys) >= t: succ = _get_succ(idx) node.keys[idx] = succ _remove(node.children[idx + 1], succ) else: _merge(idx) _remove(node.children[idx], key) else: if node.leaf: return flag = (idx == len(node.keys)) if len(node.children[idx].keys) < t: if idx > 0 and len(node.children[idx - 1].keys) >= t: _borrow_from_prev(idx) elif idx < len(node.children) - 1 and len(node.children[idx + 1].keys) >= t: _borrow_from_next(idx) else: if idx != len(node.keys): _merge(idx) else: _merge(idx - 1) idx -= 1 if flag and idx > len(node.keys): _remove(node.children[idx - 1], key) else: _remove(node.children[idx], key) _remove(self.root, key) if len(self.root.keys) == 0: if not self.root.leaf: self.root = self.root.children[0] else: self.root = BTreeNode(self.t, True)"},{"question":"You are tasked to write a function to perform substring search within a text. Your implementation should efficiently find the first occurrence of a given pattern in the text. # Function Signature ```python def search_substring(text: str, pattern: str) -> int: ``` # Input - `text` (str): A string representing the text where the search is performed. (1 ≤ len(text) ≤ 10^4) - `pattern` (str): A string representing the pattern to search for within the `text`. (0 ≤ len(pattern) ≤ 10^4) # Output - The function should return an integer. - The zero-based starting index of the first occurrence of `pattern` in `text`. - Return -1 if `pattern` is not found in `text`. # Constraints - The search should be case-sensitive. - A pattern of length 0 is considered to always match at index 0 of `text`. - Ensure the implementation runs efficiently even for the longest possbile inputs. # Examples Example 1: ```python text = \\"hello\\" pattern = \\"ll\\" output = 2 assert search_substring(text, pattern) == 2 ``` Example 2: ```python text = \\"aaaaa\\" pattern = \\"bba\\" output = -1 assert search_substring(text, pattern) == -1 ``` Example 3: ```python text = \\"abcdef\\" pattern = \\"\\" output = 0 assert search_substring(text, pattern) == 0 ``` # Hints - Carefully handle edge cases, particularly when the pattern is empty. - Consider iterating through the text and comparing substrings to identify the pattern.","solution":"def search_substring(text: str, pattern: str) -> int: This function returns the zero-based starting index of the first occurrence of pattern in text. If the pattern is not found in the text, it returns -1. if len(pattern) == 0: return 0 pattern_len = len(pattern) text_len = len(text) for i in range(text_len - pattern_len + 1): if text[i:i + pattern_len] == pattern: return i return -1"},{"question":"<|Analysis Begin|> # Algorithm Analysis Core Identification * **Algorithm/Data Structure**: Binary Search Tree (BST) traversal. * **Type**: Tree data structure traversal algorithm. * **Main Purpose**: To find the value in a Binary Search Tree (BST) that is closest to a given target value. Complexity * **Time Complexity**: (O(h)), where (h) is the height of the tree. In a balanced BST, this is (O(log n)); in the worst case (unbalanced tree), it is (O(n)). * **Space Complexity**: (O(h)) due to the recursive call stack. Principles * **Core Operational Steps**: 1. Start from the root node. 2. Compare the current node\'s value with the target. 3. Decide the next node to visit: left child if the target is less than the current node\'s value, right child otherwise. 4. Recursively call the function on the chosen child. 5. Return the value that is closest to the target between the current node and the closest value found in the subtree. # Characteristics & Applications Properties * Binary Search Trees maintain ordered properties: left child values are less than the parent, and right child values are greater. * The traversal leverages the BST properties to efficiently hone in on the closest value. Common Use Cases * Efficient search operations where comparison is based on a target value. * Scenarios requiring ordered data retrieval, such as database indexing or range queries. Strengths/Limitations * **Strengths**: * Efficient searching due to the BST properties. * Works well with dynamically changing datasets where frequent insertions and deletions are expected. * **Limitations**: * Performance degrades with tree unbalance. * May require rebalancing to maintain efficiency. # Implementation Challenges * **Edge Cases**: * Single-node tree. * Target value equidistant between two nodes. * Target value greater than the maximum or smaller than the minimum node values. * **Performance Bottlenecks**: * Unbalanced trees leading to (O(n)) time complexity. * **Error Scenarios**: * Null root node (though the prompt specifies a non-empty BST). * **Optimization Points**: * Iterative rather than recursive implementation to avoid stack overflow in extremely deep trees. * Rebalancing the tree if frequent operations lead to imbalance. <|Analysis End|> <|Question Begin|> # Coding Assessment Question **Context**: You are a software engineer working on a medical application that uses patient data stored in a Binary Search Tree (BST). One of the tasks involves finding the patient\'s age that is closest to a reference age (target). You need to implement a function to efficiently find this age. **Task**: Write a function `find_closest_age` that takes a BST representing patient ages and a target age, and returns the age in the BST that is closest to the target. **Input**: - `root`: The root node of the BST representing patient ages. Each node will have an integer value and two children (left and right). - `target`: A floating-point number representing the reference age. **Output**: - An integer representing the age in the BST closest to the target. ```python # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None def find_closest_age(root, target): :type root: TreeNode :type target: float :rtype: int # Write your code here ``` **Constraints**: - The BST is guaranteed to be non-empty. - There is only one unique value in the BST that is the closest to the target. **Example**: Given a BST: ``` 10 / 5 15 / 2 7 18 ``` - `find_closest_age(root, 9)` should return `10`. - `find_closest_age(root, 6.5)` should return `7`. **Performance Requirements**: - Your solution should have a time complexity of (O(h)), where (h) is the height of the tree. - The space complexity should be minimal, ideally (O(h)) due to the recursion stack.","solution":"class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None def find_closest_age(root, target): def helper(node, target, closest): if node is None: return closest if abs(target - node.val) < abs(target - closest): closest = node.val if target < node.val: return helper(node.left, target, closest) else: return helper(node.right, target, closest) return helper(root, target, root.val)"},{"question":"# Task Description You need to create a class implementing a Trie data structure with methods to insert words, search for words, and check if any word starts with a given prefix. You should handle only lowercase letters (\'a\' to \'z\'). Class Definition ```python class TrieNode: # Initializes a Trie node with children and a boolean is_word indicator. def __init__(self): pass class Trie: # Initializes the Trie with a root TrieNode. def __init__(self): pass # Method to insert a word into the Trie. def insert(self, word: str) -> None: pass # Method to search for a word in the Trie. def search(self, word: str) -> bool: pass # Method to check if any word in the Trie starts with a given prefix. def starts_with(self, prefix: str) -> bool: pass ``` Function Signature ```python class TrieNode: def __init__(self): self.children = collections.defaultdict(TrieNode) self.is_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: current = self.root for letter in word: current = current.children[letter] current.is_word = True def search(self, word: str) -> bool: current = self.root for letter in word: current = current.children.get(letter) if current is None: return False return current.is_word def starts_with(self, prefix: str) -> bool: current = self.root for letter in prefix: current = current.children.get(letter) if current is None: return False return True ``` Input/Output * `insert(word: str) -> None`: Inserts the given word into the Trie. No output is expected. * `search(word: str) -> bool`: Returns `True` if the given word is in the Trie, and `False` otherwise. * `starts_with(prefix: str) -> bool`: Returns `True` if there is any word in the Trie that starts with the given prefix, and `False` otherwise. Example Scenarios 1. Inserting a word: ```python trie = Trie() trie.insert(\'apple\') ``` 2. Searching for a word: ```python trie.search(\'apple\') # Returns True trie.search(\'app\') # Returns False ``` 3. Checking for a prefix: ```python trie.starts_with(\'app\') # Returns True trie.starts_with(\'apl\') # Returns False ``` Constraints * The inputs consist of lowercase English letters only. * The Trie should handle methods in O(m) time complexity, where m is the length of the word or prefix being processed.","solution":"from collections import defaultdict class TrieNode: def __init__(self): self.children = defaultdict(TrieNode) self.is_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: current = self.root for letter in word: current = current.children[letter] current.is_word = True def search(self, word: str) -> bool: current = self.root for letter in word: current = current.children.get(letter) if current is None: return False return current.is_word def starts_with(self, prefix: str) -> bool: current = self.root for letter in prefix: current = current.children.get(letter) if current is None: return False return True"},{"question":"**Scenario**: You are tasked with implementing a simple encoding and decoding mechanism for transmitting a list of strings over a network. The encoding function should convert a list of strings to a single string that can be easily sent over the network. The decoding function should convert that single encoded string back to the original list of strings. The encoded format should add a numeric prefix to each string, denoting the string\'s length, followed by a colon \\":\\" and then the string itself. For example, the string \\"hello\\" would be encoded as \\"5:hello\\". **Function Implementation**: You need to implement two functions, `encode` and `decode`, per the following specifications: 1. **Function `encode`**: * **Input**: List of strings. * **Output**: Encoded single string. * **Constraints**: Strings will not contain the delimiter `:`. 2. **Function `decode`**: * **Input**: A single encoded string. * **Output**: List of strings. * **Constraints**: The encoded string is always correctly formatted as per the encoding schema. **Performance Requirements**: - The functions should handle up to 10^5 strings, where each string\'s length can go up to 10^5 characters. **Example**: ```python # Example input input_strings = [\\"hello\\", \\"world\\"] encoded_string = encode(input_strings) # encoded_string should be \\"5:hello5:world\\" decoded_strings = decode(encoded_string) # decoded_strings should be [\\"hello\\", \\"world\\"] ``` **Note**: Be mindful of edge case handling, such as empty strings and very long lists or strings, and ensure your solution is efficient and robust.","solution":"def encode(strings): Encodes a list of strings into a single string. :param strings: List of strings. :return: Encoded single string. return \'\'.join(f\'{len(s)}:{s}\' for s in strings) def decode(encoded_string): Decodes a single encoded string back into a list of strings. :param encoded_string: Encoded single string. :return: List of strings. decoded_strings = [] i = 0 while i < len(encoded_string): j = encoded_string.find(\':\', i) length = int(encoded_string[i:j]) decoded_strings.append(encoded_string[j+1:j+1+length]) i = j + 1 + length return decoded_strings"},{"question":"# Context Count the number of 1 bits (Hamming weight) in the binary representation of a given unsigned integer using efficient bit manipulation techniques. # Function Signature ```python def count_ones(n: int) -> int: pass ``` # Input - `n`: an unsigned integer (0 ≤ n ≤ 2^32 - 1) # Output - Returns the number of \'1\' bits in the binary representation of `n`. # Constraints - The input integer is guaranteed to be in the range `[0, 2^32 - 1]`. - Your solution should optimize for time complexity, and should not use more than constant extra space. # Requirements - **Performance**: The function should run in O(k) time, where k is the number of \'1\' bits in the binary representation of `n`. # Example ```python # Example 1 n = 11 # Binary representation: 00000000000000000000000000001011 # Number of 1 bits (Hamming weight): 3 # Output: 3 # Example 2 n = 128 # Binary representation: 00000000000000000000000010000000 # Number of 1 bits: 1 # Output: 1 # Example 3 n = 4294967295 # Binary representation: 11111111111111111111111111111111 # Number of 1 bits: 32 # Output: 32 ``` # Testing - Ensure your implementation works for edge cases like `n = 0` (output 0) and `n = 2^32 - 1` (output 32). # Hint Consider iterative or recursive methods using Brian Kernighan’s algorithm, which repeatedly flips the least significant \'1\' bit to \'0\'.","solution":"def count_ones(n: int) -> int: Count the number of 1 bits in the binary representation of the given unsigned integer n. :param n: an unsigned integer (0 ≤ n ≤ 2^32 - 1) :return: the number of 1 bits in the binary representation of n count = 0 while n: n &= n - 1 # Flip the least significant \'1\' bit to \'0\' count += 1 return count"},{"question":"Context You are working on a low-level embedded system project. The project involves manipulating specific bits within integers to set flags or achieve efficient state management. To perform these operations effectively, you need to write functions that handle bit manipulation reliably and efficiently. Task Write a function `bit_manipulation(num: int, i: int, action: str, bit: int = None) -> int` that performs one of four different bit manipulation operations on a given integer `num`. The function should accept the following parameters: * `num`: The integer on which the bit operation will be performed. * `i`: The index of the bit to be manipulated. * `action`: The type of bit manipulation to be performed. This can be \'get\', \'set\', \'clear\', or \'update\'. * `bit`: The value to set the ith bit to, applicable only for the \'update\' action. Specifications * For the \'get\' action, return 1 if the ith bit is 1, and 0 if the ith bit is 0. * For the \'set\' action, set the ith bit to 1. * For the \'clear\' action, set the ith bit to 0. * For the \'update\' action, update the ith bit to the given `bit` value (0 or 1). Input * `num`: An integer within the standard 32-bit signed integer range. * `i`: A non-negative integer indicating the bit index. * `action`: A string, one of \'get\', \'set\', \'clear\', or \'update\'. * `bit`: An integer, either 0 or 1, only when `action` is \'update\'. Output * Return an integer result of the bitwise operation or the bit value in case of \'get\' action. Constraints * `0 <= num < 2**31` * `0 <= i < 31` * `bit` is applicable only when `action` is \'update\'. Example ```python assert bit_manipulation(5, 0, \'get\') == 1 # 5 in binary is 101 and 0th bit is 1 assert bit_manipulation(5, 1, \'clear\') == 5 # 5 in binary is 101, clearing 1st bit results in 101 assert bit_manipulation(5, 1, \'set\') == 7 # 5 in binary is 101, setting 1st bit results in 111 (7 in decimal) assert bit_manipulation(5, 1, \'update\', 0) == 5 # 101, updating 1st bit to 0 results in 101 assert bit_manipulation(5, 1, \'update\', 1) == 7 # 101, updating 1st bit to 1 results in 111 ``` Implementation Implement the function based on the provided bit manipulation functions for each operation.","solution":"def bit_manipulation(num: int, i: int, action: str, bit: int = None) -> int: Perform bit manipulation on the given integer `num`. Parameters: - num: The integer to be manipulated. - i: The index of the bit to be manipulated. - action: The type of manipulation. One of \'get\', \'set\', \'clear\', or \'update\'. - bit: The value to set the bit to, applicable only for \'update\'. Returns: - Result of the bit manipulation or the bit value for \'get\' action. # Perform the specified action if action == \'get\': return (num >> i) & 1 elif action == \'set\': return num | (1 << i) elif action == \'clear\': return num & ~(1 << i) elif action == \'update\': if bit not in [0, 1]: raise ValueError(\\"bit must be either 0 or 1 for \'update\' action\\") return (num & ~(1 << i)) | (bit << i) else: raise ValueError(\\"Invalid action. Choose from \'get\', \'set\', \'clear\', \'update\'.\\")"},{"question":"You are tasked with implementing a Binary Heap with specific methods to support priority queue operations. You will be implementing the following methods in the `BinaryHeap` class: `insert(val)`, `remove_min()`, and `perc_up(i)`. The heap will maintain the properties of a min-heap, where the smallest element will always be at the root. # Requirements 1. **Insert Method (`insert(val)`):** - Inserts the value `val` into the heap. - Maintains the complete binary tree structure and min-heap properties. - Time Complexity: O(logN) 2. **Remove Minimum Method (`remove_min()`):** - Removes and returns the smallest element (root) from the heap. - Maintains the complete binary tree structure and min-heap properties after removal. - Should handle the case when the heap is empty. - Time Complexity: O(logN) 3. **Percolate Up Method (`perc_up(i)`):** - Moves the element at index `i` up to its correct position if it\'s smaller than its parent. - Ensures the min-heap property is maintained. - Time Complexity: O(logN) # Input & Output Format - `insert(val)`: No input/output format (method to be used within the class) - `remove_min() -> int`: Returns the minimum value from the heap if it exists, otherwise should handle an empty scenario gracefully. # Constraints - The heap size will not exceed 10^5 elements. - All inserted values will be integers within the range of -10^6 to 10^6. # Example ```python # Create an instance of BinaryHeap heap = BinaryHeap() # Insert elements heap.insert(4) heap.insert(50) heap.insert(7) heap.insert(55) heap.insert(90) heap.insert(87) # Remove the minimum element assert heap.remove_min() == 4 # Insert a new element heap.insert(2) # Remove the minimum element again assert heap.remove_min() == 2 ``` Your implementation should correctly maintain the min-heap properties and ensure efficient insertion and deletion operations.","solution":"class BinaryHeap: def __init__(self): self.heap = [0] self.current_size = 0 def insert(self, val): self.heap.append(val) self.current_size += 1 self.perc_up(self.current_size) def perc_up(self, i): while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i // 2] = self.heap[i // 2], self.heap[i] i = i // 2 def remove_min(self): if self.current_size == 0: return None # Handle the case where the heap is empty root = self.heap[1] self.heap[1] = self.heap[self.current_size] self.current_size -= 1 self.heap.pop() self.perc_down(1) return root def perc_down(self, i): while (i * 2) <= self.current_size: min_child = self.min_child(i) if self.heap[i] > self.heap[min_child]: self.heap[i], self.heap[min_child] = self.heap[min_child], self.heap[i] i = min_child def min_child(self, i): if (i * 2 + 1) > self.current_size: return i * 2 else: if self.heap[i * 2] < self.heap[i * 2 + 1]: return i * 2 else: return i * 2 + 1"},{"question":"# Post-order Traversal of a Binary Tree Scenario You are given a binary tree and need to implement functions to perform post-order traversal, both iteratively and recursively. Task Write two Python functions: 1. `postorder_iter(root: Node) -> List[int]` 2. `postorder_recur(root: Node) -> List[int]` Where `Node` is a class representing a node of a binary tree. Each node contains an integer value (`val`), and references to its left and right children (`left`, `right`). Function Signatures - **Iterative Function**: ```python def postorder_iter(root: Node) -> List[int]: ``` - **Recursive Function**: ```python def postorder_recur(root: Node) -> List[int]: ``` Example Consider the binary tree: ``` 1 / 2 3 / 4 5 ``` For the tree with root `Node(1, Node(2, Node(4), Node(5)), Node(3))`: - The post-order traversal output should be `[4, 5, 2, 3, 1]`. Constraints 1. The tree has at most 10^4 nodes. 2. Each value of the node is a 32-bit integer. Notes - Your implementations should handle edge cases such as empty trees and trees with a single node. - Ensure the time complexity is O(n) and handle large inputs efficiently.","solution":"from typing import List, Optional class Node: def __init__(self, val=0, left: \'Node\' = None, right: \'Node\' = None): self.val = val self.left = left self.right = right def postorder_iter(root: Optional[Node]) -> List[int]: Performs iterative post-order traversal on a binary tree. if not root: return [] stack, output = [root], [] while stack: node = stack.pop() output.append(node.val) if node.left: stack.append(node.left) if node.right: stack.append(node.right) return output[::-1] def postorder_recur(root: Optional[Node]) -> List[int]: Performs recursive post-order traversal on a binary tree. def helper(node: Optional[Node], result: List[int]): if not node: return helper(node.left, result) helper(node.right, result) result.append(node.val) result = [] helper(root, result) return result"},{"question":"# Simplify Absolute Path Problem Statement: You are tasked with simplifying an absolute Unix-style file path by resolving the directory changes represented by `.` (current directory) and `..` (parent directory), as well as removing any redundant slashes. Requirements: - Implement a function `def simplify_path(path: str) -> str` that takes an absolute path as input and returns the simplified canonical path. - The input path is a string consisting of `/`, letters, numbers, `.` and `..`. - The output should be the simplified path string. Constraints: 1. The returned output must always start with a single `/`. 2. The input path will not have trailing space and will always represent an absolute path. Examples: 1. Given `path = \\"/home/\\"`, the output should be `\\"/home\\"`. 2. Given `path = \\"/a/./b/../../c/\\"`, the output should be `\\"/c\\"`. 3. Given `path = \\"/../\\"`, the output should be `\\"/\\"`. 4. Given `path = \\"/home//foo/\\"`, the output should be `\\"/home/foo\\"`. Edge-Cases Considerations: - Input path = `\\"/../\\"` - Input path = `\\"/./././\\"` - Input path containing multiple slashes together, e.g. `\\"/home///user\\"` - An empty or single slash input `\\"/\\"` Write the function with the above requirements to correctly handle the simplification process.","solution":"def simplify_path(path: str) -> str: Simplifies an absolute Unix-style file path. Args: path (str): The absolute path as input. Returns: str: The simplified canonical path. # Split the input by \'/\' to get the path components components = path.split(\'/\') # Stack to hold valid path components stack = [] # Iterate through each component in the path for component in components: if component == \'..\': if stack: stack.pop() # Go back to the parent directory elif component and component != \'.\': stack.append(component) # Add valid components only # Join the components with \'/\' to form the simplified path simplified_path = \'/\' + \'/\'.join(stack) return simplified_path"},{"question":"You are tasked with creating an algorithm that maintains a sorted list and performs regular insertions in an optimal manner. For each insertion, your implementation must ensure that the list remains sorted. # Function Signature: ```python def optimized_insertion(sorted_list: List[int], new_val: int) -> List[int]: pass ``` # Input: - `sorted_list`: A list of integers sorted in non-decreasing order. - `new_val`: An integer to be inserted into the `sorted_list`. # Output: - Returns a new list with `new_val` inserted into `sorted_list` in a manner that keeps the list sorted. # Constraints: - The `sorted_list` can have up to 10^5 elements. - The function should run in O(log n) time for the search part due to the requirement of inserting into a sorted structure and O(n) for the shift. # Example: ```python optimized_insertion([1, 3, 5, 6], 5) -> [1, 3, 5, 5, 6] optimized_insertion([1, 3, 5, 6], 2) -> [1, 2, 3, 5, 6] optimized_insertion([1, 3, 5, 6], 7) -> [1, 3, 5, 6, 7] optimized_insertion([], 0) -> [0] ``` # Explanation: - In the first example, `5` already exists in the list, so it is inserted at the position maintaining the order. - In the second example, `2` is inserted into its correct sorted position. - In the third example, `7` is added to the end as it is larger than all current elements. - In the fourth example, we handle the edge case of an empty array, returning a single-element list. You are required to implement the `optimized_insertion` function using the `search_insert` helper method provided above. The helper method determines the appropriate index to insert `new_val` into the sorted list.","solution":"from typing import List def optimized_insertion(sorted_list: List[int], new_val: int) -> List[int]: def search_insert(nums: List[int], target: int) -> int: Find the index to insert target into nums to keep nums sorted. low, high = 0, len(nums) - 1 while low <= high: mid = (low + high) // 2 if nums[mid] < target: low = mid + 1 else: high = mid - 1 return low insert_pos = search_insert(sorted_list, new_val) sorted_list.insert(insert_pos, new_val) return sorted_list"},{"question":"Maximum Path Sum in a Binary Tree Problem Statement: You are provided with a binary tree where each node contains an integer value. Your task is to write a Python function `max_path_sum(root)` that calculates the maximum path sum in the binary tree. A path in a binary tree is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Function Signature: ```python def max_path_sum(root) -> int: ``` Input: * `root`: A `TreeNode` object representing the root of the binary tree. Output: * An integer representing the maximum path sum in the binary tree. Constraints: * Node values range from `-1000` to `1000`. * The number of nodes in the binary tree ranges from `0` to `10^4`. Performance Requirements: * The solution should run in linear time, O(N), where N is the number of nodes in the binary tree. * Ensure the space complexity is optimal and handle deep trees gracefully. Example: Consider the following binary tree: ``` 1 / 2 3 ``` * **Input**: ```python root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) ``` * **Output**: `6` (The path with maximum sum is: 2 → 1 → 3) Notes: * The provided helper function in the initial code snippet has a bug concerning the integer immutability for the `maximum` variable during recursive calls. Consider using a different approach to handle this. Implement the `max_path_sum` function that adheres to the above requirements.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root): def helper(node): nonlocal max_sum if not node: return 0 left_sum = max(helper(node.left), 0) right_sum = max(helper(node.right), 0) current_sum = node.val + left_sum + right_sum max_sum = max(max_sum, current_sum) return node.val + max(left_sum, right_sum) max_sum = float(\'-inf\') helper(root) return max_sum"},{"question":"# **Problem Statement:** You are tasked to implement an advanced variation of the classic insertion sort algorithm with enhanced efficiency for nearly sorted arrays. This variant should stop early if the array becomes sorted before the end of the list. Additionally, you have to simulate the sorting process for demonstration purposes, similar to the provided `insertion_sort` function. # **Function Signature:** ```python def efficient_insertion_sort(arr: List[int], simulation: bool = False) -> List[int]: Sorts an array using an optimized insertion sort algorithm that stops early if the array becomes sorted. Parameters: arr (List[int]): The list of integers to be sorted. simulation (bool): If True, prints the array at each significant step of the algorithm. Returns: List[int]: The sorted list of integers. ``` # **Requirements and Constraints:** * **Input**: - The function accepts a list of integers `arr` which is to be sorted. - The `simulation` parameter is a boolean. If `True`, the function should print the state of the array at each iteration. * **Output**: - The function returns the sorted list. * **Constraints**: - The input list `arr` has at most (10^4) elements. - Elements in `arr` have values from (-10^6) to (10^6). * **Performance**: - Optimize the insertion sort to detect early if a portion of the array is sorted and break out of unnecessary iterations. # **Edge Cases to Consider**: - Handle empty lists. - Handle arrays with a single element. - Handle arrays that are already sorted. - Handle arrays that may be sorted in reverse order. # **Example**: ```python print(efficient_insertion_sort([3, 2, 1, 5, 4], simulation=True)) # Outputs: # iteration 0 : 3 2 1 5 4 # iteration 1 : 2 3 1 5 4 # iteration 2 : 2 1 3 5 4 # iteration 3 : 2 1 3 5 4 # iteration 4 : 2 1 3 4 5 # => [1, 2, 3, 4, 5] ``` Implement the `efficient_insertion_sort` function correctly to pass the example and handle specified constraints and edge cases.","solution":"from typing import List def efficient_insertion_sort(arr: List[int], simulation: bool = False) -> List[int]: Sorts an array using an optimized insertion sort algorithm that stops early if the array becomes sorted. Parameters: arr (List[int]): The list of integers to be sorted. simulation (bool): If True, prints the array at each significant step of the algorithm. Returns: List[int]: The sorted list of integers. n = len(arr) for i in range(1, n): current_value = arr[i] position = i while position > 0 and arr[position - 1] > current_value: arr[position] = arr[position - 1] position -= 1 arr[position] = current_value # Check if array is already sorted after this iteration if simulation: print(f\'iteration {i - 1} : {\\" \\".join(map(str, arr))}\') if all(arr[j] <= arr[j + 1] for j in range(n - 1)): break return arr"},{"question":"Scenario: You work for a text cleaning service. One of your tasks is to sanitize user-provided text data by removing any recurring characters while preserving the first occurrence of each character in the text. To efficiently handle this task, you\'ve decided to write a Python function. The function must handle both upper-case and lower-case letters uniquely. Task: Write a function `sanitize_text` that takes a string as input and returns a new string with all recurring characters removed, preserving only the first appearance of each character. The function should be optimized to run in linear time. Input and Output Specifications: - **Input**: A single string ( s ) - Constraints: ( 0 leq text{len}(s) leq 10^5 ) - **Output**: A new string with duplicate characters removed, retaining only the first occurrence of each character. Examples: 1. **Input**: `\'hello\'` - **Output**: `\'helo\'` 2. **Input**: `\'abracadabra\'` - **Output**: `\'abrcd\'` 3. **Input**: `\'AaBbCc\'` - **Output**: `\'AaBbCc\'` 4. **Input**: `\'\'` - **Output**: `\'\'` Constraints: - The function should run in O(n) time complexity. - The function should handle both uppercase and lowercase letters as distinct characters. Function Signature: ```python def sanitize_text(s: str) -> str: # Your implementation here pass ```","solution":"def sanitize_text(s: str) -> str: Removes duplicate characters from the input string while preserving the first occurrence of each character. seen = set() sanitized_string = [] for char in s: if char not in seen: seen.add(char) sanitized_string.append(char) return \'\'.join(sanitized_string)"},{"question":"# Scenario Imagine you\'re building an application that simulates a web browser\'s \\"back\\" and \\"forward\\" button functionality. You need to implement a browsing history mechanism using stacks. # Task You need to implement a class called `BrowserHistory` which utilizes two stacks (`ArrayStack` or `LinkedListStack`) to manage browsing history. The class should provide the following functionalities: 1. **visit(url)**: This method adds a new URL to the browsing history and clears the forward history stack. 2. **back()**: This method returns the previous URL in the history if it exists, otherwise it returns a message \\"No previous URL\\". 3. **forward()**: This method returns the next URL in the forward stack if it exists, otherwise it returns a message \\"No forward URL\\". # Input and Output - The `visit(url)` method will take a single string representing the URL. - The `back()` and `forward()` methods will return strings: - Either the valid URL string from history. - Or the respective message \\"No previous URL\\" / \\"No forward URL\\". # Constraints - Assume the browser history can grow indefinitely (no memory constraints). - The URLs are valid, non-empty strings. - Operations are frequent but should meet efficient time complexity expectations. # Example ```python history = BrowserHistory() history.visit(\\"google.com\\") history.visit(\\"wikipedia.org\\") history.visit(\\"answers.com\\") print(history.back()) # Output: \\"wikipedia.org\\" print(history.back()) # Output: \\"google.com\\" print(history.forward()) # Output: \\"wikipedia.org\\" print(history.visit(\\"newsite.com\\")) print(history.forward()) # Output: \\"No forward URL\\" ``` # Implementation Outline You need to implement the `BrowserHistory` class and decide on using either `ArrayStack` or `LinkedListStack` for managing the stack operations. ```python class BrowserHistory: def __init__(self): Initializes the BrowserHistory with two stacks. One for the back history and one for the forward history. pass def visit(self, url): Push the url to the back stack and clear the forward stack. pass def back(self): Returns the previous URL in the history if it exists, else \\"No previous URL\\". pass def forward(self): Returns the next URL in the forward stack if it exists, else \\"No forward URL\\". pass # Example usage: history = BrowserHistory() history.visit(\\"google.com\\") history.visit(\\"wikipedia.org\\") history.visit(\\"answers.com\\") print(history.back()) # Output: \\"wikipedia.org\\" print(history.back()) # Output: \\"google.com\\" print(history.forward()) # Output: \\"wikipedia.org\\" history.visit(\\"newsite.com\\") print(history.forward()) # Output: \\"No forward URL\\" ``` Use the `ArrayStack` or `LinkedListStack` to store and manage the URLs.","solution":"class BrowserHistory: def __init__(self): Initializes the BrowserHistory with two stacks. One for the back history and one for the forward history. self.back_stack = [] self.forward_stack = [] def visit(self, url): Push the url to the back stack and clear the forward stack. if url: self.back_stack.append(url) self.forward_stack.clear() def back(self): Returns the previous URL in the history if it exists, else \\"No previous URL\\". Moves the current URL to the forward stack. if len(self.back_stack) > 1: self.forward_stack.append(self.back_stack.pop()) return self.back_stack[-1] else: return \\"No previous URL\\" def forward(self): Returns the next URL in the forward stack if it exists, else \\"No forward URL\\". Moves the current URL to the back stack. if self.forward_stack: next_url = self.forward_stack.pop() self.back_stack.append(next_url) return next_url else: return \\"No forward URL\\""},{"question":"# Scenario You are tasked with enhancing a hash table implementation by introducing a method that can retrieve the count of unique keys currently stored in the hash table, given a specific collection of keys. This is particularly useful in applications where understanding the frequency of unique items within a dataset is required, such as counting distinct elements in a streaming data input. # Task Implement the function `count_unique_keys(keys)` in the `ResizableHashTable` class. - This function takes a list of keys and returns an integer representing the count of unique keys from the list that are currently stored in the hash table. # Input - A list of integers `keys`, where each integer represents a key. # Output - An integer representing the count of unique keys from the given list that are present in the hash table. # Example ```python # creating a ResizableHashTable instance rht = ResizableHashTable() rht.put(1, \'one\') rht.put(2, \'two\') rht.put(3, \'three\') # counting unique keys print(rht.count_unique_keys([1, 2, 4, 5])) # Output should be 2 (keys 1 and 2 are present in the table) ``` # Constraints - The list of keys will contain no more than 10^6 elements. - Keys will be non-negative integers. # Requirements 1. Provide a complete implementation in Python. 2. Ensure the solution is efficient to handle large input sizes.","solution":"class ResizableHashTable: def __init__(self): self.table = {} def put(self, key, value): self.table[key] = value def get(self, key): return self.table.get(key, None) def count_unique_keys(self, keys): Returns the count of unique keys from the given list that are present in the hash table. :param keys: List of integers. :return: Integer count of unique keys in the hash table. unique_keys = set(keys) count = 0 for key in unique_keys: if key in self.table: count += 1 return count"},{"question":"# Question **Objective**: Implement a function that checks if a given directed graph is strongly connected. **Scenario**: You are analyzing a social networking site where users follow each other unidirectionally. You want to determine if all users in the network can potentially reach each other through a series of follows. In technical terms, this means checking if the directed graph of this network is strongly connected. **Function Signature**: ```python def is_strongly_connected(vertex_count: int, edges: List[Tuple[int, int]]) -> bool: pass ``` # Input - `vertex_count` (1 ≤ vertex_count ≤ 10^5): An integer representing the number of vertices in the graph. - `edges` (0 ≤ len(edges) ≤ 10^6): A list of tuples where each tuple (u, v) represents a directed edge from vertex `u` to vertex `v`. # Output - Return `True` if the graph is strongly connected, otherwise return `False`. # Constraints - Assume vertices are labeled from 0 to `vertex_count - 1`. - There are no self-loops or multiple edges between the same pair of vertices in the same direction. # Performance Requirement - The function should run within reasonable time limits for the given constraints. # Steps 1. Construct the graph using the given edges. 2. Perform a DFS from an arbitrary starting node to check reachability of all nodes. 3. Reverse the graph. 4. Perform a DFS again from the same starting node in the reversed graph. 5. If all nodes are reachable in both DFS traversals, the graph is strongly connected. # Example Usage ```python print(is_strongly_connected(5, [(0, 1), (1, 2), (2, 3), (3, 0), (2, 4), (4, 2)])) # Output: True print(is_strongly_connected(4, [(0, 1), (1, 2), (2, 3)])) # Output: False ```","solution":"from typing import List, Tuple, Dict from collections import defaultdict, deque def is_strongly_connected(vertex_count: int, edges: List[Tuple[int, int]]) -> bool: if vertex_count == 1: return True graph = defaultdict(list) reverse_graph = defaultdict(list) for u, v in edges: graph[u].append(v) reverse_graph[v].append(u) def bfs(start: int, g: Dict[int, List[int]]) -> List[bool]: visited = [False] * vertex_count queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in g[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return visited start_node = 0 reachable_from_start = bfs(start_node, graph) if not all(reachable_from_start): return False reachable_from_start_in_reversed = bfs(start_node, reverse_graph) if not all(reachable_from_start_in_reversed): return False return True"},{"question":"# Diffie-Hellman Key Exchange Simulation # Scenario: You are tasked with implementing a simulation of the Diffie-Hellman key exchange process. Two parties, Alice and Bob, want to securely agree on a shared secret key using an insecure channel. Alice and Bob will generate their own private keys, compute their public keys, exchange these public keys, and then each compute the shared secret key. # Function Implementations: Implement the following functions: 1. **`is_prime(n: int) -> bool`**: Check if a number `n` is a prime number. 2. **`primitive_root(n: int) -> int`**: Find a primitive root of a prime number `n`. 3. **`private_key(p: int) -> int`**: Generate a private key for a given prime `p`. 4. **`public_key(private_key: int, primitive_root: int, prime: int) -> int`**: Compute the public key given a private key, a primitive root, and a prime number. 5. **`shared_secret(their_public_key: int, your_private_key: int, prime: int) -> int`**: Compute the shared secret key given the other party\'s public key, your private key, and a prime number. 6. **`diffie_hellman(p: int, g: int) -> int`**: Simulate the entire Diffie-Hellman key exchange process and return the shared secret key. # Constraints: - The prime number `p` should be a prime less than 1000. - You need to find a primitive root for the prime `p`. - The private keys should be between 1 and `p-1`. # Input Format: - A prime number `p` and its primitive root `g` are provided as input. # Output Format: - Print Alice\'s and Bob\'s private and public keys. - Print the shared secret key computed by Alice and Bob. # Example: ```python is_prime(23) # True primitive_root(23) # 5 private_key(23) # Randomly generates 6, for example public_key(6, 5, 23) # 5^6 % 23 = 8 shared_secret(8, 15, 23) # 8^15 % 23 = 19 shared_secret(19, 6, 23) # 19 diffie_hellman(23, 5) # Output: # Alice\'s private key: 6 # Alice\'s public key: 8 # Bob\'s private key: 15 # Bob\'s public key: 19 # Shared key calculated by Alice: 19 # Shared key calculated by Bob: 19 ```","solution":"import random import math def is_prime(n: int) -> bool: Check if a number n is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def primitive_root(p: int) -> int: Find a primitive root of a prime number p. if p == 2: return 1 required_set = set(num for num in range(1, p) if math.gcd(num, p) == 1) for g in range(1, p): actual_set = set(pow(g, powers, p) for powers in range(1, p)) if required_set == actual_set: return g return -1 def private_key(p: int) -> int: Generate a private key for a given prime p. return random.randint(1, p - 1) def public_key(private_key: int, primitive_root: int, prime: int) -> int: Compute the public key given a private key, a primitive root, and a prime number. return pow(primitive_root, private_key, prime) def shared_secret(their_public_key: int, your_private_key: int, prime: int) -> int: Compute the shared secret key given the other party\'s public key, your private key, and a prime number. return pow(their_public_key, your_private_key, prime) def diffie_hellman(p: int, g: int) -> int: Simulate the entire Diffie-Hellman key exchange process and return the shared secret key. alice_private = private_key(p) bob_private = private_key(p) alice_public = public_key(alice_private, g, p) bob_public = public_key(bob_private, g, p) alice_shared_secret = shared_secret(bob_public, alice_private, p) bob_shared_secret = shared_secret(alice_public, bob_private, p) print(f\\"Alice\'s private key: {alice_private}\\") print(f\\"Alice\'s public key: {alice_public}\\") print(f\\"Bob\'s private key: {bob_private}\\") print(f\\"Bob\'s public key: {bob_public}\\") print(f\\"Shared key calculated by Alice: {alice_shared_secret}\\") print(f\\"Shared key calculated by Bob: {bob_shared_secret}\\") return alice_shared_secret # Both should be the same # Running the Diffie-Hellman Simulation if __name__ == \\"__main__\\": p = 23 g = primitive_root(p) shared_key = diffie_hellman(p, g) print(f\\"Shared key: {shared_key}\\")"},{"question":"# Question: Suppose you are tasked with implementing a `HashTable` class that supports the most common dictionary operations but also keeps track of the order of inserted keys. This extended class should be able to provide an ordered list of keys based on their insertion sequence. Implement a class `OrderedHashTable` by extending the given `HashTable` class. The `OrderedHashTable` should support the following operations: 1. `put(key, value)`: Adds a new key-value pair to the map. If the key already exists, update the existing value. 2. `get(key)`: Returns the value associated with the key, or None if the key does not exist. 3. `del_(key)`: Removes the key-value pair from the map. 4. `keys_ordered()`: Returns a list of keys in the order they were inserted. Constraints: * Implement the `OrderedHashTable` by extending the given `HashTable` class. * `keys_ordered` should return an accurate sequence of keys based on their initial insertion, irrespective of updates to values. Input: The class methods will be called with various keys and values. There is no direct input function. Output: The output will be from the `get` and `keys_ordered` methods. Example: ```python ht = OrderedHashTable() ht.put(1, \'A\') ht.put(2, \'B\') ht.put(3, \'C\') print(ht.keys_ordered()) # Output: [1, 2, 3] ht.put(2, \'BB\') print(ht.get(2)) # Output: \'BB\' ht.del_(1) print(ht.keys_ordered()) # Output: [2, 3] ```","solution":"class HashTable: def __init__(self): self.table = {} def put(self, key, value): self.table[key] = value def get(self, key): return self.table.get(key, None) def del_(self, key): if key in self.table: del self.table[key] class OrderedHashTable(HashTable): def __init__(self): super().__init__() self.order = [] def put(self, key, value): if key not in self.table: self.order.append(key) super().put(key, value) def del_(self, key): if key in self.table: self.order.remove(key) super().del_(key) def keys_ordered(self): return self.order"},{"question":"# Question: Detect Cycles in a Directed Graph Background: You are developing a system for managing course requirements at a university. Each course has a set of prerequisites, forming a directed graph. The goal is to ensure that there are no circular dependencies among the courses, which would mean a cycle exists in the graph. If a cycle is detected, it indicates that some courses would not be possible to complete. Problem Statement: Write a function `contains_cycle(graph)` that determines if there is a cycle in the given directed graph. The graph will be provided as a dictionary where the keys are course names (vertices) and the values are lists of courses (nodes) that are prerequisites for the key course. Input: - `graph`: A dictionary representing the directed graph, where the key is a course (vertex) and the value is a list of prerequisite courses (edges). Output: - `True` if there is a cycle in the graph, `False` otherwise. Constraints: - The graph can have between 1 and 10<sup>4</sup> vertices. - Prerequisite lists can contain up to 10<sup>4</sup> courses. - Course names will be strings of uppercase alphabets and numbers. Example: ```python graph = { \'CS101\': [\'CS102\', \'CS103\'], \'CS102\': [\'CS104\'], \'CS103\': [\'CS105\'], \'CS104\': [\'CS101\'], \'CS105\': [] } print(contains_cycle(graph)) # Output: True (because CS101 -> CS102 -> CS104 -> CS101 forms a cycle) graph = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [] } print(contains_cycle(graph)) # Output: False ``` Implement the function to detect cycles in the graph. Notes: - Consider edge cases such as disjoint graphs or self-loops. - Ensure that your implementation is efficient and adheres to the mentioned constraints.","solution":"def contains_cycle(graph): Detects if there is a cycle in the directed graph. :param graph: A dictionary representing the directed graph. :returns: True if there is a cycle, False otherwise. # Helper function to perform a depth-first search def dfs(node): # If the current node is being visited in the same recursion then there is a cycle. if node in visiting: return True # Once fully visited, return False since we\'ve checked this path if node in visited: return False # Mark the node as visiting visiting.add(node) # Recur for all the vertices adjacent to this vertex for neighbor in graph.get(node, []): if dfs(neighbor): return True # Remove from visiting set and add to the visited set visiting.remove(node) visited.add(node) return False visited = set() visiting = set() for course in graph: if dfs(course): return True return False"},{"question":"# Sorting Challenge with Modified Comb Sort You are given an array of integers that needs to be sorted. Implement a modified version of the comb sort algorithm, ensuring that it uses an optimized shrink factor to potentially reduce the number of passes needed for sorting. Your modified comb sort must also include an additional feature to count and return the number of swaps made during the sort. Function Signature ```python def modified_comb_sort(arr: List[int]) -> (List[int], int): # Implement your solution here ``` Input * `arr` (List[int]): An array of integers to be sorted. Output * `(List[int], int)`: A tuple where the first element is the sorted array and the second element is the total number of swaps made. Constraints 1. (1 leq text{len}(arr) leq 10^5) 2. ( -10^9 leq text{arr}[i] leq 10^9 ) for each (i) Notes * Employ a shrink factor of your choice to potentially optimize sorting performance. Here is an example to illustrate: Example **Input** ```python arr = [20, -4, 3, 15, 7, -1] ``` **Output** ```python ([-4, -1, 3, 7, 15, 20], 5) ``` Explanation: The array is sorted into ascending order with 5 swaps.","solution":"from typing import List, Tuple def modified_comb_sort(arr: List[int]) -> Tuple[List[int], int]: def get_next_gap(gap: int) -> int: # Shrink factor of 1.3 gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True total_swaps = 0 while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(0, n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True total_swaps += 1 return arr, total_swaps"},{"question":"# Flatten Nested Arrays Given a nested list of arbitrary depth, your task is to flatten it such that all the elements appear in a single-level list. For instance, given an input list `[[1, 2, [3]], 4]`, the output should be `[1, 2, 3, 4]`. Write two functions: 1. `flatten_nested_list(nested_list)`: This function should use a recursive approach to flatten the input list. 2. `flatten_nested_list_generator(nested_list)`: This function should use a generator to flatten the input list iteratively. Inputs: * `nested_list`: A list that may contain integers or other lists that in turn contain integers or lists, and so on. Outputs: * Both functions should produce an output list containing the flattened elements from the input list. Constraints: * You can assume that the list is arbitrarily nested. * Strings should be treated as atomic values (i.e., not iterated over like lists). Performance Requirements: * The `flatten_nested_list` function should handle input lists with a depth of up to `1000` without a stack overflow. * The `flatten_nested_list_generator` should be able to handle very large lists efficiently in terms of memory usage. # Example: ```python assert flatten_nested_list([1, [2, [3, 4], 5]]) == [1, 2, 3, 4, 5] assert list(flatten_nested_list_generator([1, [2, [3, 4], 5]])) == [1, 2, 3, 4, 5] ``` # Implementation Details: * Ensure to test on various edge cases including empty lists, single element lists, lists with mixed data types, and very deep nested lists.","solution":"def flatten_nested_list(nested_list): Flattens a nested list using a recursive approach. def flatten_helper(nested): for item in nested: if isinstance(item, list): yield from flatten_helper(item) else: yield item return list(flatten_helper(nested_list)) def flatten_nested_list_generator(nested_list): Flattens a nested list using a generator. stack = [iter(nested_list)] while stack: for elem in stack[-1]: if isinstance(elem, list): stack.append(iter(elem)) break else: yield elem else: stack.pop()"},{"question":"You are given a connected, weighted undirected graph represented by an adjacency list. Implement a function that utilizes Prim\'s Algorithm to find and return the minimum cost of a spanning tree. # Function Signature ```python def minimum_spanning_tree_cost(graph: Dict[str, List[Tuple[int, str]]]) -> int: ``` # Input - `graph`: A dictionary representing a weighted undirected graph. Each key is a node, and its corresponding value is a list of tuples. Each tuple contains two elements: an integer representing the weight of the edge and a string representing the adjacent node. # Output - Return an integer which is the total weight of the minimum spanning tree of the graph. # Constraints - The graph is connected. - There are no negative edge weights. - The graph contains at most 1000 nodes and 10000 edges. # Example ```python graph = { \'a\': [(3, \'b\'), (8, \'c\')], \'b\': [(3, \'a\'), (5, \'d\')], \'c\': [(8, \'a\'), (2, \'d\'), (4, \'e\')], \'d\': [(5, \'b\'), (2, \'c\'), (6, \'e\')], \'e\': [(4, \'c\'), (6, \'d\')] } print(minimum_spanning_tree_cost(graph)) # Output: 14 ``` # Explanation Prim\'s Algorithm would start from any arbitrary node (let\'s say \'a\'), and iteratively add the smallest weight edge to grow the MST until all nodes are included. The minimum spanning tree\'s total weight for the sample graph is 14.","solution":"from heapq import heappop, heappush from typing import Dict, List, Tuple def minimum_spanning_tree_cost(graph: Dict[str, List[Tuple[int, str]]]) -> int: Returns the minimum cost of a spanning tree for a connected, weighted undirected graph. The graph is represented by an adjacency list. if not graph: return 0 # Use a priority queue to keep track of the edges with the smallest weight priority_queue = [] total_cost = 0 visited = set() # Choose an arbitrary starting point start_node = next(iter(graph)) visited.add(start_node) # Add all edges from the starting node to the priority queue for weight, neighbour in graph[start_node]: heappush(priority_queue, (weight, start_node, neighbour)) while priority_queue: weight, from_node, to_node = heappop(priority_queue) if to_node not in visited: visited.add(to_node) total_cost += weight for edge in graph[to_node]: heappush(priority_queue, (edge[0], to_node, edge[1])) return total_cost"},{"question":"**Binary Heap Operations** You are tasked with implementing and extending the `BinaryHeap` class provided below. Your job is to include additional functionalities that will help in better management and understanding of a min-heap. You will implement the following additional methods: 1. **find_min**: Implement a method to find and return the minimum element in the heap without removing it. 2. **build_heap**: Implement a method to build a heap from an unsorted list of elements. This method should be efficient with a time complexity of (O(N)). 3. **heap_sort**: Implement a method to sort an array in ascending order using the heap. This method should first build a heap from the array elements and then repeatedly remove the minimum element to generate a sorted order. The complexity of this method should be (O(N log N)). # Function Signature ```python class BinaryHeap(AbstractHeap): # Previous methods def perc_up(self, i): # Implementation def insert(self, val): # Implementation def min_child(self, i): # Implementation def perc_down(self, i): # Implementation def remove_min(self): # Implementation def find_min(self): # Your implementation here def build_heap(self, elements): # Your implementation here def heap_sort(self, elements): # Your implementation here ``` # Constraints 1. For `build_heap` method, the input will be a list of integers. 2. For `heap_sort` method, the input will be a list of integers. 3. You should handle edge cases such as empty lists appropriately. # Example ```python heap = BinaryHeap() heap.build_heap([10, 20, 15, 30, 40]) print(heap.find_min()) # Output: 10 sorted_list = heap.heap_sort([3, 5, 1, 10, 2]) print(sorted_list) # Output: [1, 2, 3, 5, 10] ```","solution":"class BinaryHeap: def __init__(self): self.heap = [0] # First element is 0 to simplify parent/child calculations self.curr_size = 0 def perc_up(self, i): # Bubble-up to maintain heap property while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i // 2] = self.heap[i // 2], self.heap[i] i = i // 2 def insert(self, val): self.heap.append(val) self.curr_size += 1 self.perc_up(self.curr_size) def min_child(self, i): # Return the index of the smallest child if i * 2 + 1 > self.curr_size: return i * 2 # Left child only else: if self.heap[i * 2] < self.heap[i * 2 + 1]: return i * 2 else: return i * 2 + 1 def perc_down(self, i): # Bubble-down to maintain heap property while (i * 2) <= self.curr_size: mc = self.min_child(i) if self.heap[i] > self.heap[mc]: self.heap[i], self.heap[mc] = self.heap[mc], self.heap[i] i = mc def remove_min(self): # Remove and return the minimum element if self.curr_size == 0: raise IndexError(\\"remove_min() called on empty heap\\") min_val = self.heap[1] self.heap[1] = self.heap[self.curr_size] self.curr_size -= 1 self.heap.pop() self.perc_down(1) return min_val def find_min(self): # Return the minimum element without removing it if self.curr_size == 0: raise IndexError(\\"find_min() called on empty heap\\") return self.heap[1] def build_heap(self, elements): # Build a new heap from a list of elements self.heap = [0] + elements[:] self.curr_size = len(elements) i = self.curr_size // 2 while i > 0: self.perc_down(i) i -= 1 def heap_sort(self, elements): # Perform heap sort and return the sorted array self.build_heap(elements) sorted_array = [] while self.curr_size > 0: sorted_array.append(self.remove_min()) return sorted_array"},{"question":"Scenario You are given an array of integers that represents the ages of participants in a competition. For presentation purposes, you are required to sort these ages in ascending order. However, due to resource constraints, you have to implement a sorting algorithm with O(1) additional space complexity. Write a function named `sort_ages` that sorts the ages using the selection sort algorithm. Ensure that your function is efficient and handles all edge cases appropriately. Requirements * Implement the `selection sort` algorithm in the function. * Ensure your code handles edge cases such as empty arrays, single-element arrays, and arrays with duplicate elements. Function Signature ```python def sort_ages(ages: List[int]) -> List[int]: pass ``` Input * `ages` (List[int]): A list of integers representing the ages of participants. Output * Return a list of integers where the ages are sorted in ascending order. Constraints * The length of the array will be between 0 and 1000 elements. Examples ```python assert sort_ages([29, 15, 20, 10, 32]) == [10, 15, 20, 29, 32] assert sort_ages([5, 3, 1, 2, 4]) == [1, 2, 3, 4, 5] assert sort_ages([3, 3, 3]) == [3, 3, 3] assert sort_ages([]) == [] ``` Notes * Your solution should be efficient and concise. * Ensure you test your function with a wide range of inputs, including edge cases. * Do not use any built-in sorting functions provided by the language.","solution":"from typing import List def sort_ages(ages: List[int]) -> List[int]: Sorts the list of ages using the selection sort algorithm. Args: ages (List[int]): A list of integers representing the ages of participants. Returns: List[int]: The list of ages sorted in ascending order. n = len(ages) for i in range(n): # Find the minimum element in the remaining unsorted array min_index = i for j in range(i + 1, n): if ages[j] < ages[min_index]: min_index = j # Swap the found minimum element with the first element ages[i], ages[min_index] = ages[min_index], ages[i] return ages"},{"question":"# Context Imagine you have a sequence of all natural numbers written consecutively in order: \\"123456789101112131415...\\". You need to identify and return the nth digit in this sequence. This task requires accounting for the variable length of individual numbers as the sequence progresses. # Problem Statement Implement a function `find_nth_digit(n)` that returns the nth digit in the concatenated sequence of natural numbers. # Input and Output * **Input**: An integer `n` representing the position in the infinite sequence. * **Output**: An integer indicating the nth digit in the sequence. # Constraints * 1 ≤ n ≤ 2 * 10^9 # Example ```python # Example invocation print(find_nth_digit(15)) # Should output 2 because the first digits are: \\"123456789101112\\" so the 15th digit is \'2\' print(find_nth_digit(1)) # Should output 1 print(find_nth_digit(11)) # Should output 0 (The 11th digit in \\"12345678910\\" is 0) ``` # Performance Requirements Your implementation should aim to accomplish this in a time complexity of O(log n) and use constant extra space.","solution":"def find_nth_digit(n): Returns the nth digit in the concatenated sequence of natural numbers. length = 1 # starting with numbers of length 1 count = 9 start = 1 while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 start += (n - 1) // length s = str(start) return int(s[(n - 1) % length])"},{"question":"**Scenario** You\'re working on enhancing a digital image manipulation tool. One of the functionalities needed is to rotate images, represented as matrices, by 90 degrees clockwise. **Task** Write a function `rotate_image(matrix: List[List[int]]) -> List[List[int]]` that takes an n x n 2D matrix representing an image and rotates the image by 90 degrees clockwise in-place. **Input Format** 1. matrix: a list of lists, where each sublist represents a row of the image matrix (0 <= matrix.length == matrix[i].length <= 10^3). **Output Format** The function should return the same matrix rotated by 90 degrees clockwise (modifying the original matrix). **Constraints** 1. You must perform the rotation in-place, modifying the original list without using additional space for another matrix. **Example** ``` Input: matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] Output: [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` **Performance Requirements** 1. Your solution must have a time complexity of O(n^2). 2. Your solution must have a space complexity of O(1). **Edge Cases to Consider** 1. Empty matrix. 2. Matrix with only one element. 3. Matrix with very large n (up to 1000). **Hints** - First reverse the matrix rows from top to bottom. - Then, transpose the matrix by swapping elements across the main diagonal. ```python from typing import List def rotate_image(matrix: List[List[int]]) -> List[List[int]]: if not matrix: return matrix # Step 1: Reverse the matrix top to bottom matrix.reverse() # Step 2: Transpose the matrix for i in range(len(matrix)): for j in range(i): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] return matrix ```","solution":"from typing import List def rotate_image(matrix: List[List[int]]) -> List[List[int]]: if not matrix: return matrix # Step 1: Reverse the matrix top to bottom matrix.reverse() # Step 2: Transpose the matrix for i in range(len(matrix)): for j in range(i): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] return matrix"},{"question":"# Bogo Sort Replacement: Matrix Shuffle Sort **Scenario**: To demonstrate the impracticality of Bogo Sort, you are required to implement a new sorting algorithm named `Matrix Shuffle Sort` that operates on a different principle but uses a similar shuffling concept. Given a 2D matrix of integers, your task is to sort each row of the matrix until all rows are sorted in ascending order. The twist is that you can only shuffle rows randomly in addition to sorting the rows independently. # Function Signature ```python def matrix_shuffle_sort(matrix: List[List[int]]) -> List[List[int]]: ``` # Input - `matrix`: A 2D list of integers with dimensions `m x n` where `m` is the number of rows and `n` is the number of columns. # Output - Returns a 2D list of integers where each row is independently sorted in ascending order. # Constraints 1. (1 leq m, n leq 10) 2. Each integer in the matrix is between (-10^3) and (10^3). # Performance Constraints - Although this will be inefficient, aim for a solution that avoids infinite execution by integrating a maximum number of shuffles constraint (e.g., 1,000 shuffles). # Example ```python matrix = [ [3, 1, 2], [9, 7, 5], [4, 6, 8] ] # Possible outputs (after shuffles and sorting until all rows sorted): # [ # [1, 2, 3], # [5, 7, 9], # [4, 6, 8] # ] print(matrix_shuffle_sort(matrix)) ``` # Note - Consider edge cases with an empty matrix or single row. - Be mindful of the 1,000 maximum shuffles limit to prevent infinite loops. - The function must ensure each row is independently sorted and if after 1,000 shuffles, any row is still not sorted, the last state of the matrix should be returned.","solution":"import random from typing import List def matrix_shuffle_sort(matrix: List[List[int]]) -> List[List[int]]: Sorts each row of the matrix independently until all rows are sorted, using a maximum of 1,000 random shuffles for the rows. def is_sorted(row): return all(row[i] <= row[i + 1] for i in range(len(row) - 1)) num_shuffles = 0 max_shuffles = 1000 while num_shuffles < max_shuffles: # Sort each row independently for i in range(len(matrix)): matrix[i].sort() # Check if all rows are sorted if all(is_sorted(row) for row in matrix): break # Shuffle the rows of the matrix random.shuffle(matrix) num_shuffles += 1 # After the maximum number of shuffles, return the possibly partially sorted matrix return matrix"},{"question":"**Bitonic Sort Implementation** # Problem Statement You are given an array `arr` of integers. The task is to implement the **Bitonic Sort** algorithm to sort the array in increasing order. The bitonic sort only works for arrays where the size is a power of two. If the size of the array is not a power of two, the function should raise a `ValueError` with the message \\"the size of input should be power of two\\". # Input * An integer array `arr` where `1 <= len(arr) <= 10^6`. # Output * A sorted array in increasing order. # Constraints * The size of `arr` must be a power of two. * If the input size is not a power of two, raise a `ValueError` with the message \\"the size of input should be power of two\\". # Function Signature Define the function as follows: ```python def bitonic_sort(arr: List[int]) -> List[int]: ``` # Example ```python print(bitonic_sort([3, 7, 2, 8, 1, 5, 4, 6])) # Output: [1, 2, 3, 4, 5, 6, 7, 8] print(bitonic_sort([10, 30, 20, 40, 25, 35, 15, 45])) # Output: [10, 15, 20, 25, 30, 35, 40, 45] # This should raise an error print(bitonic_sort([10, 30, 20, 40, 25, 35, 15])) # Output: ValueError: the size of input should be power of two ``` # Notes * Make sure to handle edge cases such as empty arrays or single-element arrays properly. * Ensure performance constraints are met and the sort operation completes efficiently even for large arrays.","solution":"from typing import List def bitonic_sort(arr: List[int]) -> List[int]: def compare_and_swap(arr, i, j, direction): if direction == (arr[i] > arr[j]): arr[i], arr[j] = arr[j], arr[i] def bitonic_merge(arr, low, count, direction): if count > 1: k = count // 2 for i in range(low, low + k): compare_and_swap(arr, i, i + k, direction) bitonic_merge(arr, low, k, direction) bitonic_merge(arr, low + k, k, direction) def bitonic_sort_recursive(arr, low, count, direction): if count > 1: k = count // 2 bitonic_sort_recursive(arr, low, k, 1) # Sort in ascending order bitonic_sort_recursive(arr, low + k, k, 0) # Sort in descending order bitonic_merge(arr, low, count, direction) def is_power_of_two(n): return n and (n & (n - 1)) == 0 n = len(arr) if n <= 1: return arr if not is_power_of_two(n): raise ValueError(\\"the size of input should be power of two\\") bitonic_sort_recursive(arr, 0, n, 1) return arr"},{"question":"# Insertion Sort with Binary Search Helper Function You are tasked with implementing the Insertion Sort algorithm. To optimize your implementation, use the provided `search_insert` function which utilizes binary search to find the correct insert position. # Function to Implement ```python def binary_insertion_sort(array): Sorts an array using the insertion sort algorithm optimized with a binary search method to find the correct insert position. Parameters: array (List[int]): A list of integers to be sorted. Returns: List[int]: The sorted list of integers. pass ``` # Example ```python array = [12, 10, 4, 8, 6] sorted_array = binary_insertion_sort(array) print(sorted_array) # Output: [4, 6, 8, 10, 12] ``` # Constraints - The input array can have up to 10^5 elements. - The elements will be integers in the range -10^9 to 10^9. - The `search_insert` helper function is provided and should be used as-is. # Requirements - Make sure your function runs efficiently. - Handle edge cases such as an empty array or an already sorted array. **Hint**: Utilize the `search_insert` function to determine where each element should be placed as you iterate through the array.","solution":"def search_insert(array, value): Uses binary search to find the index at which value should be inserted to maintain sorted order. Parameters: array (List[int]): A sorted list of integers. value (int): The value to find the insert position for. Returns: int: The index where the value should be inserted. left, right = 0, len(array) while left < right: mid = (left + right) // 2 if array[mid] < value: left = mid + 1 else: right = mid return left def binary_insertion_sort(array): Sorts an array using the insertion sort algorithm optimized with a binary search method to find the correct insert position. Parameters: array (List[int]): A list of integers to be sorted. Returns: List[int]: The sorted list of integers. for i in range(1, len(array)): key = array[i] insertion_index = search_insert(array[:i], key) array = array[:insertion_index] + [key] + array[insertion_index:i] + array[i+1:] return array"},{"question":"# Context You are tasked with implementing a `WordDictionary` that allows adding words and searching for words in a very efficient manner. This data structure should efficiently handle exact word matches as well as \\".\\" wildcard matches. # Requirements 1. **Class Definition**: - Define a class `WordDictionary`. - Implement the following methods: - `void add_word(word: str)`: Adds a word into the data structure. - `bool search(word: str)`: Searches a word in the data structure. A word could contain the dot character `.` that can represent any one letter. 2. **Functionality**: - `add_word` should insert the word into the data structure efficiently. - `search` should handle exact matches and \\".\\" wildcard patterns. 3. **Expected Input and Output**: - Example: ```python wd = WordDictionary() wd.add_word(\\"bad\\") wd.add_word(\\"dad\\") wd.add_word(\\"mad\\") assert wd.search(\\"pad\\") == False # \\"pad\\" is not in the dictionary assert wd.search(\\"bad\\") == True # \\"bad\\" is in the dictionary assert wd.search(\\".ad\\") == True # \\".ad\\" can match \\"bad\\", \\"dad\\", or \\"mad\\" assert wd.search(\\"b..\\") == True # \\"b..\\" can match \\"bad\\" ``` 4. **Constraints**: - Word length `<= 500`. - Number of words added `<= 10^4`. 5. **Performance Requirements**: - `add_word` and `search` must run efficiently within acceptable time limits even for the upper input constraints. # Implementation ```python class TrieNode: def __init__(self, letter, is_terminal=False): self.children = {} self.letter = letter self.is_terminal = is_terminal class WordDictionary: def __init__(self): self.root = TrieNode(\\"\\") def add_word(self, word): cur = self.root for letter in word: if letter not in cur.children: cur.children[letter] = TrieNode(letter) cur = cur.children[letter] cur.is_terminal = True def search(self, word, node=None): cur = node if node else self.root for i, letter in enumerate(word): if letter == \\".\\": return any(self.search(word[i+1:], child) for child in cur.children.values()) if letter not in cur.children: return False cur = cur.children[letter] return cur.is_terminal ``` # Task Implement the `WordDictionary` class following the given specifications and constraints. Ensure your implementation can handle the provided example and additional test cases.","solution":"class TrieNode: def __init__(self, letter=\'\', is_terminal=False): self.children = {} self.letter = letter self.is_terminal = is_terminal class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word): cur = self.root for letter in word: if letter not in cur.children: cur.children[letter] = TrieNode(letter) cur = cur.children[letter] cur.is_terminal = True def search(self, word, node=None): cur = node if node else self.root for i, letter in enumerate(word): if letter == \\".\\": return any(self.search(word[i + 1:], child) for child in cur.children.values()) if letter not in cur.children: return False cur = cur.children[letter] return cur.is_terminal"},{"question":"# Scenario: You have been asked to help automate the process of sorting product prices before they are displayed on an e-commerce website. # Problem Statement: Implement the `selection_sort` function which sorts an array of numbers in non-decreasing order. The function should also have a capability to simulate each iteration of the sorting process. # Function Signature: ```python def selection_sort(arr: List[int], simulation: bool = False) -> List[int]: Function to perform selection sort on the provided list. Parameters: - arr: List of integers to be sorted - simulation: Boolean indicating whether or not to print iteration steps Returns: - A list of integers sorted in non-decreasing order ``` # Input: - An array of integers `arr` which needs to be sorted. - A boolean flag `simulation` which indicates whether to print the array at each iteration of the sorting process. `False` by default. # Output: - A new sorted array in non-decreasing order. # Constraints: - The length of `arr` will be between 0 and 1000 inclusive. - All elements in `arr` will fit within the range of a 32-bit signed integer. # Examples: 1. Given the input `arr = [4, 2, 3, 1]`, the output should be `[1, 2, 3, 4]`. 2. Given the input `arr = [10, 7, 2, 3, 5]` with `simulation=True`, the function should print: ``` iteration 0 : 10 7 2 3 5 iteration 1 : 2 7 10 3 5 iteration 2 : 2 3 10 7 5 iteration 3 : 2 3 5 7 10 ``` **Note**: If `simulation` is set to `True`, print the array at each step whenever an element is swapped. # Additional Details: Students should ensure to handle: - Edge cases involving empty or single-element arrays. - Proper simulation outputs for debugging and learning purposes.","solution":"from typing import List def selection_sort(arr: List[int], simulation: bool = False) -> List[int]: Function to perform selection sort on the provided list. Parameters: - arr: List of integers to be sorted - simulation: Boolean indicating whether or not to print iteration steps Returns: - A list of integers sorted in non-decreasing order n = len(arr) for i in range(n): min_index = i for j in range(i + 1, n): if arr[j] < arr[min_index]: min_index = j arr[i], arr[min_index] = arr[min_index], arr[i] if simulation: print(f\\"iteration {i} : {\' \'.join(map(str, arr))}\\") return arr"},{"question":"Problem Statement # Context: You are tasked with designing a system that can encode and decode a list of strings for efficient transmission over a network. The system should ensure that the original list of strings can be perfectly reconstructed after decoding. # Function Requirements: Implement two functions, `encode` and `decode`, which will handle the conversion between list of strings and a single string, and vice versa. 1. **encode(strs) -> str** * **Input**: List of strings. * **Output**: A single encoded string. * **Constraints**: * Strings may contain any ASCII characters. * The encoded string should be efficient and compact. 2. **decode(encoded_str) -> List[str]** * **Input**: A single encoded string. * **Output**: Original list of strings. * **Constraints**: * The encoded string format will be as produced by the `encode` function. * The output should match the original list exactly. # Example ```python encoded = encode([\\"Hello\\", \\"world\\"]) print(encoded) # Output: \\"5:Hello5:world\\" decoded = decode(encoded) print(decoded) # Output: [\\"Hello\\", \\"world\\"] ``` # Instructions 1. Write the `encode` function that converts a list of strings to a single encoded string. 2. Write the `decode` function that converts the encoded string back to the original list of strings. 3. Ensure your code handles edge cases such as empty lists, and strings containing various characters. 4. Your solution should be efficient with a linear time complexity relative to the size of the input.","solution":"def encode(strs): Encodes a list of strings to a single string. encoded_str = \\"\\" for s in strs: length = len(s) encoded_str += f\\"{length}:{s}\\" return encoded_str def decode(encoded_str): Decodes a single string back into a list of strings. strs = [] i = 0 while i < len(encoded_str): j = encoded_str.find(\':\', i) length = int(encoded_str[i:j]) i = j + 1 strs.append(encoded_str[i:i+length]) i += length return strs"},{"question":"# Merge Sort Implementation and Count Inversions **Scenario**: You are implementing a sorting utility similar to what one might find in a standard library. However, in addition to sorting the array, you are tasked with calculating the number of inversions in the array. An inversion is a pair of indices `i, j` such that `i < j` and `arr[i] > arr[j]`. **Task**: Implement the merge sort algorithm that sorts an input array of integers in ascending order and also counts the number of inversions. **Function Signature**: ```python def merge_sort_and_count(arr): Sorts the array in ascending order and counts inversions. :param arr: List[int] - a list of integers to be sorted. :return: Tuple(List[int], int) - A tuple containing the sorted list and the number of inversions. pass ``` **Input**: - An array `arr` containing `n` integers, where `1 <= n <= 10^5`. **Output**: - A tuple containing: * The sorted list of integers. * The number of inversions in the original array. **Performance Requirements**: - The sorting part of the function should have a time complexity of O(n log(n)). - An auxiliary space complexity of O(n) is acceptable. **Constraints**: - The elements of the array can be negative as well as positive. - Do not use Python’s in-built sort function directly for this task. **Example**: ```python arr = [2, 4, 1, 3, 5] output = merge_sort_and_count(arr) print(output) # Expected output: ([1, 2, 3, 4, 5], 3) # In this example, the inversions are (2, 1), (4, 1), and (4, 3). ```","solution":"def merge_sort_and_count(arr): Sorts the array in ascending order and counts inversions. :param arr: List[int] - a list of integers to be sorted. :return: Tuple(List[int], int) - A tuple containing the sorted list and the number of inversions. if len(arr) <= 1: return arr, 0 mid = len(arr) // 2 left, left_inversions = merge_sort_and_count(arr[:mid]) right, right_inversions = merge_sort_and_count(arr[mid:]) sorted_arr, split_inversions = merge_and_count(left, right) total_inversions = left_inversions + right_inversions + split_inversions return sorted_arr, total_inversions def merge_and_count(left, right): Merges two sorted arrays and counts split inversions. :param left: List[int] - Left half of the array. :param right: List[int] - Right half of the array. :return: Tuple(List[int], int) - A tuple containing the merged and sorted list and the number of split inversions. i = j = 0 merged = [] split_inversions = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 split_inversions += len(left) - i merged.extend(left[i:]) merged.extend(right[j:]) return merged, split_inversions"},{"question":"Problem Statement # Scenario You are working as a software engineer tasked with optimizing the performance of a database system. One of the bottlenecks identified is the efficiency of internal sorting mechanisms used for moderate-sized datasets (~5,000 to 50,000 elements). The current insertion sort algorithm is too slow, and you are required to implement an improved version leveraging Shell Sort. # Task You need to implement the Shell Sort algorithm to sort an array of integers in non-decreasing order. As part of your implementation, ensure that you optimize the choice of the gap sequence to improve performance, choosing from common sequences (e.g., Shell’s original sequence, Hibbard’s increments, or Sedgewick’s increments). # Implementation Details 1. **Function Signature**: ```python def optimized_shell_sort(arr: List[int]) -> List[int]: ``` 2. **Input**: * `arr`: A list of integers `List[int]` where 0 <= len(arr) <= 10^6. 3. **Output**: * Returns a sorted list of integers in non-decreasing order. 4. **Constraints**: * You can choose any common, well-researched incremental sequence to improve the performance of the sort. # Example ```python assert optimized_shell_sort([12, 34, 54, 2, 3]) == [2, 3, 12, 34, 54] assert optimized_shell_sort([5, 5, 5, 5, 5]) == [5, 5, 5, 5, 5] assert optimized_shell_sort([]) == [] assert optimized_shell_sort([1]) == [1] assert optimized_shell_sort([20, -5, 0, -1]) == [-5, -1, 0, 20] ``` # Performance Requirements Your implementation should be efficient enough to handle large inputs (up to 10^6 elements) with a suitable choice of gap sequence to avoid the worst-case time complexity.","solution":"from typing import List def optimized_shell_sort(arr: List[int]) -> List[int]: Implements the Shell Sort algorithm to sort an array of integers in non-decreasing order. We use the Shell\'s original sequence: n/2, n/4, ..., 1. n = len(arr) gap = n // 2 while gap > 0: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 2 return arr"},{"question":"# Question: Implement and Optimize Bitonic Sort You are given an implementation of the Bitonic Sort algorithm in Python. Bitonic Sort is a parallel algorithm capable of efficiently sorting arrays, but the provided version is a sequential (non-parallel) one. Your task is to perform the following: 1. **Implement an Optimized Version**: - Implement an iterative version of the Bitonic Sort algorithm to reduce recursive overhead. - Ensure the implementation is efficient, maintaining the key principles and correctness of the bitonic sort. 2. **Generalize for Non-Power of Two**: - Modify the bitonic sort to handle arrays of arbitrary size by padding them to the next power of two with an appropriate value, such as infinity (for ascending order). **Function Signature**: ```python def optimized_bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: ``` Input: * `arr`: A list of integers (can be of arbitrary size, not necessarily a power of two). * `reverse`: A boolean flag indicating whether to sort the array in ascending (`False`) or descending (`True`) order. Default is ascending order. Output: * A list of integers sorted in the specified order. Constraints: * Ensure the function works efficiently for large input sizes (up to 10^5 elements). Example: ```python # Example 1 print(optimized_bitonic_sort([3, 7, 2, 5, 1, 6, 4], reverse=False)) # Output: [1, 2, 3, 4, 5, 6, 7] # Example 2 print(optimized_bitonic_sort([3, 7, 2, 5, 1, 6, 4], reverse=True)) # Output: [7, 6, 5, 4, 3, 2, 1] # Example 3 print(optimized_bitonic_sort([9, 4, 3], reverse=False)) # Output: [3, 4, 9] ``` Ensure to handle edge cases such as: * Empty list (`[]`). * Single element list (`[x]`). * Lists with duplicate values (`[3, 3, 2, 1, 1, 0]`). Ensure code readability, and efficiency and include comments or docstrings explaining your approach.","solution":"import math def bitonic_compare_and_swap(arr, i, j, direction): if (direction and arr[i] > arr[j]) or (not direction and arr[i] < arr[j]): arr[i], arr[j] = arr[j], arr[i] def bitonic_merge(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 for i in range(low, low + k): bitonic_compare_and_swap(arr, i, i + k, direction) bitonic_merge(arr, low, k, direction) bitonic_merge(arr, low + k, k, direction) def bitonic_sort(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 bitonic_sort(arr, low, k, True) bitonic_sort(arr, low + k, k, False) bitonic_merge(arr, low, cnt, direction) def get_next_power_of_two(x): return 1 if x == 0 else 2 ** (x - 1).bit_length() def optimized_bitonic_sort(arr, reverse=False): n = len(arr) if n == 0: return arr next_power_of_two = get_next_power_of_two(n) extended_arr = arr + [float(\'inf\')] * (next_power_of_two - n) bitonic_sort(extended_arr, 0, next_power_of_two, not reverse) return [x for x in extended_arr if x != float(\'inf\')]"},{"question":"# Pigeonhole Sort Implementation and Optimization You have been given a set of arrays to sort using the Pigeonhole Sort algorithm. **Objective**: Implement the Pigeonhole Sort algorithm and make enhancements to handle large input ranges more efficiently by switching to an alternative sorting algorithm when appropriate. Function Signature: ```python def optimized_pigeonhole_sort(arr: List[int]) -> List[int]: pass ``` # Input: - A list of integers `arr` where the integers can be negative and may have a large range. # Output: - A new list of integers, sorted in non-decreasing order. # Constraints: - The array can contain up to 100,000 elements. - The integer values can range anywhere between -10^6 and 10^6. # Performance Requirements: - If the range of the array is too large relative to the number of elements (more than 1,000 times the number of elements), switch to an alternative sorting algorithm like Timsort. # Steps: 1. Compute the `Range` and the number of elements (`n`) in the input list. 2. If the range is manageable (Range <= 1000 * n), proceed with the Pigeonhole Sort implementation. 3. If the range is large (Range > 1000 * n), use an alternative efficient sorting algorithm such as Python\'s built-in sorted() function (which uses Timsort). Example: ```python Input: arr = [8, 3, 2, 7, 4, 6, 8] Output: [2, 3, 4, 6, 7, 8, 8] Input: arr = [-10**6, 3, 2, 7, 4, 6, 10**6] Output: [-10**6, 2, 3, 4, 6, 7, 10**6] ``` Write the `optimized_pigeonhole_sort` function to meet these requirements.","solution":"from typing import List def optimized_pigeonhole_sort(arr: List[int]) -> List[int]: if not arr: return arr min_val = min(arr) max_val = max(arr) # Range is max - min + 1 range_val = max_val - min_val + 1 n = len(arr) # If range is too large compared to the number of elements, use Timsort if range_val > 1000 * n: return sorted(arr) # Initialize pigeonholes holes = [0] * range_val # Populate the pigeonholes for number in arr: holes[number - min_val] += 1 # Collect the sorted output sorted_arr = [] for i in range(range_val): while holes[i] > 0: sorted_arr.append(i + min_val) holes[i] -= 1 return sorted_arr"},{"question":"# Binary Search Question You are provided with a sorted array of integers. Your task is to write a function that performs a binary search to find the index of a given target value. Function Signature ```python def binary_search(array, target): Search for the target in the sorted array and return its index. Parameters: array (list of int): A list of sorted integers in ascending order. target (int): The integer value to be searched. Returns: int: The index of the target in the array, if found. Otherwise, return -1. ``` Input * `array`: A list of integers sorted in ascending order. The length of the array is guaranteed to be between 1 and 10^5. * `target`: An integer value to search for in the array. Output * Return the index of `target` if it is found in the array. * Return `-1` if the `target` is not found in the array. Constraints * The array will contain unique values. * There will be no duplicate elements in the array. Performance Requirement * Your solution should have a worst-case time complexity of O(log(n)). Example ```python # Example 1 array = [1, 2, 3, 4, 5, 6, 7, 8, 9] target = 5 print(binary_search(array, target)) # Output: 4 # Example 2 array = [1, 2, 3, 4, 5, 6, 7, 8, 9] target = 10 print(binary_search(array, target)) # Output: -1 ``` Note You are expected to handle edge cases such as: * The target being the first or last element. * The target not being present in an empty array. * The target is not present in the array at all.","solution":"def binary_search(array, target): Search for the target in the sorted array and return its index. Parameters: array (list of int): A list of sorted integers in ascending order. target (int): The integer value to be searched. Returns: int: The index of the target in the array, if found. Otherwise, return -1. left, right = 0, len(array) - 1 while left <= right: mid = left + (right - left) // 2 # Check if target is present at mid if array[mid] == target: return mid # If target greater, ignore left half elif array[mid] < target: left = mid + 1 # If target is smaller, ignore right half else: right = mid - 1 # If we reach here, the element was not present return -1"},{"question":"# Single Number in Array Using Bit Manipulation **Objective**: Given an array of integers where each integer appears exactly three times except for one unique integer, identify that unique integer. Your solution should have a time complexity of O(n) and use O(1) additional memory. **Function Signature**: ```python def find_unique_number(nums: List[int]) -> int: pass ``` **Input**: * An array `nums` of integers where `1 <= len(nums) <= 3 * 10^4`. **Output**: * An integer representing the unique number in the array. **Constraints**: * All elements in the array appear three times except for one element which appears exactly once. * The array may contain both positive and negative integers. **Performance Requirements**: * Time Complexity: O(n) * Space Complexity: O(1) **Example**: ```python assert find_unique_number([2, 2, 3, 2]) == 3 assert find_unique_number([0, 1, 0, 1, 0, 1, 99]) == 99 assert find_unique_number([-2, -2, 1, -2]) == 1 assert find_unique_number([30000, 500, 100, 30000, 100, 30000, 100]) == 500 ``` **Explanation**: In the first example, the number 3 appears only once while 2 appears three times. In the second example, the number 99 appears only once while 0 and 1 each appear three times. The expected outcome is the unique integer in the array.","solution":"from typing import List def find_unique_number(nums: List[int]) -> int: This function finds the unique number in the array where every other number appears three times. We use bit manipulation to achieve this. # Initialize variables to hold the count of bits ones, twos = 0, 0 for num in nums: # First add the new number to \\"twos\\" if it is already in \\"ones\\" twos |= ones & num # Then add the new number to \\"ones\\" ones ^= num # The common bits in \\"ones\\" and \\"twos\\" are the bits which appear three times. common_bit_mask = ~(ones & twos) # Remove these common bits from \\"ones\\" and \\"twos\\" ones &= common_bit_mask twos &= common_bit_mask return ones"},{"question":"# Question You are tasked with optimizing a company\'s product sorting system. The current system uses a Bubble Sort implementation and struggles with large datasets due to its inefficient nature. Your company has decided to implement the Comb Sort algorithm to accelerate the sorting process. Implement the `comb_sort` function to sort an array of integers in ascending order using the Comb Sort approach. # Function Signature ```python def comb_sort(arr: List[int]) -> List[int]: pass ``` # Input Format * A list `arr` of integers where `1 <= len(arr) <= 10^5`. * Each integer element in `arr` can range from `-10^6` to `10^6`. # Output Format * A list of integers sorted in ascending order. # Example ```python assert comb_sort([5, 3, 8, 4, 2]) == [2, 3, 4, 5, 8] ``` # Constraints * **Performance Requirement**: The solution should ideally have an average-case time complexity of O(N log N). # Notes Make sure to handle edge cases such as: * An empty array or an array with a single element. * Arrays with all identical elements.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: Sorts a list of integers in ascending order using the Comb Sort algorithm. def next_gap(gap): # Shrink gap by the shrink factor of 1.3 gap = int(gap / 1.3) if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = next_gap(gap) swapped = False for i in range(0, n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Problem: Bijective Word Pattern Validator Given a pattern and a string `s`, write a function `validate_pattern(pattern: str, s: str) -> bool` to determine if `s` follows the same pattern as specified by `pattern`. Input: - `pattern`: A string of lowercase letters. - `s`: A string of lowercase words separated by a single space. Output: - Returns `True` if `s` follows the pattern described by `pattern`. - Returns `False` otherwise. Constraints: - 1 <= len(pattern) <= 100 - 1 <= len(s) <= 1000 Example: 1. `validate_pattern(\\"abba\\", \\"dog cat cat dog\\")` should return `True`. 2. `validate_pattern(\\"abba\\", \\"dog cat cat fish\\")` should return `False`. 3. `validate_pattern(\\"aaaa\\", \\"dog cat cat dog\\")` should return `False`. 4. `validate_pattern(\\"abba\\", \\"dog dog dog dog\\")` should return `False`. Performance Requirements: - The implementation should run efficiently within the provided constraints, ideally in O(n) time complexity with respect to the number of words in the string. Evaluation Criteria: - Correctness: Does the function return the correct bijection result? - Efficiency: Does it handle larger inputs within time limits? - Robustness: Does the function handle edge cases properly? Function Definition: ```python def validate_pattern(pattern: str, s: str) -> bool: pass ``` Implement the function `validate_pattern` to solve the problem.","solution":"def validate_pattern(pattern: str, s: str) -> bool: words = s.split() # Pattern length should match the number of words if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False if word in word_to_char: if word_to_char[word] != char: return False char_to_word[char] = word word_to_char[word] = char return True"},{"question":"# Question You are given the implementation of a graph data structure which computes the transitive closure using Depth-First Search (DFS). Your task is to implement the following functionalities: 1. **Reachable Nodes**: Write a function `reachable_nodes(self, source)` that returns a list of nodes reachable from the given source node using the transitive closure matrix. 2. **New Graph from Closure**: Write a function `create_graph_from_closure(self)` that creates a new Graph object where only the edges present in the transitive closure matrix are added. Function Signature ```python class Graph: ... def reachable_nodes(self, source: int) -> List[int]: pass def create_graph_from_closure(self) -> \'Graph\': pass ``` Input - `reachable_nodes(self, source: int)`: Takes an integer `source` representing the source node. - `create_graph_from_closure(self)`: No additional input. Output - `reachable_nodes(self, source: int)`: Returns a list of integers representing the nodes reachable from the given source node. - `create_graph_from_closure(self)`: Returns a new Graph object created from the transitive closure matrix. Constraints - Assume the graph has at least one vertex. - Vertices are numbered from `0` to `vertex_count-1`. - The graph can be disconnected. - Edges are directed. Example ```python # Example usage: g = Graph(4) g.add_edge(0, 1) g.add_edge(0, 2) g.add_edge(1, 2) g.add_edge(2, 0) g.add_edge(2, 3) # Compute transitive closure closure = g.transitive_closure() # Reachable nodes from 0 print(g.reachable_nodes(0)) # Output: [0, 1, 2, 3] # Create new graph from closure new_graph = g.create_graph_from_closure() # Expected structure would have edges representing reachability directly ```","solution":"from typing import List, Optional class Graph: def __init__(self, vertices: int): self.vertices = vertices self.adj_list = [[] for _ in range(vertices)] self.closure = [[0] * vertices for _ in range(vertices)] def add_edge(self, u: int, v: int): self.adj_list[u].append(v) def dfs_util(self, s: int, v: int, visited: List[bool]): visited[v] = True self.closure[s][v] = 1 for neigh in self.adj_list[v]: if not visited[neigh]: self.dfs_util(s, neigh, visited) def transitive_closure(self): for i in range(self.vertices): visited = [False] * self.vertices self.dfs_util(i, i, visited) return self.closure def reachable_nodes(self, source: int) -> List[int]: if not self.closure[source][source]: self.transitive_closure() return [i for i in range(self.vertices) if self.closure[source][i] == 1] def create_graph_from_closure(self) -> \'Graph\': if not self.closure[0][0]: self.transitive_closure() new_graph = Graph(self.vertices) for i in range(self.vertices): for j in range(self.vertices): if self.closure[i][j] == 1: new_graph.add_edge(i, j) return new_graph"},{"question":"Implementing Prim\'s Algorithm for MST You are tasked with implementing a function that computes the Minimum Spanning Tree (MST) of a given connected, undirected graph using Prim\'s algorithm. The function should take the graph in the form of an adjacency list and return the total weight of the MST. Function Signature: ```python def calculate_mst_weight(graph: Dict[int, List[Tuple[int, int]]]) -> int: pass ``` Input: - `graph`: A dictionary where each key is an integer representing a node, and each value is a list of tuples. Each tuple consists of two integers: the weight of the edge and the adjacent node. Example: ```python { 1: [(3, 2), (8, 3)], 2: [(3, 1), (5, 4)], 3: [(8, 1), (2, 4), (4, 5)], 4: [(5, 2), (2, 3), (6, 5)], 5: [(4, 3), (6, 4)] } ``` Output: - An integer representing the total weight of the Minimum Spanning Tree (MST). Constraints: - The graph is connected and undirected. - The number of nodes `n` is in the range [1, 1000]. - The number of edges `m` is in the range [0, 10^6]. - Edge weights are positive integers. Example: ```python graph = { 1: [(3, 2), (8, 3)], 2: [(3, 1), (5, 4)], 3: [(8, 1), (2, 4), (4, 5)], 4: [(5, 2), (2, 3), (6, 5)], 5: [(4, 3), (6, 4)] } result = calculate_mst_weight(graph) print(result) # Output: 14 ``` # Requirements: 1. Implement the function `calculate_mst_weight` which uses Prim\'s algorithm to calculate the MST weight. 2. Handle edge cases for graphs with only one node (weight should be 0). 3. Ensure efficiency and handle up to 10^6 edges. # Additional Information: - You may use Python\'s `heapq` library to implement the priority queue. - Start the MST with the node labeled `1`. Good Luck!","solution":"import heapq from typing import Dict, List, Tuple def calculate_mst_weight(graph: Dict[int, List[Tuple[int, int]]]) -> int: if not graph: return 0 total_weight = 0 visited = set() min_heap = [(0, 1)] # Starting with node 1, weight 0 while min_heap and len(visited) < len(graph): weight, node = heapq.heappop(min_heap) if node in visited: continue visited.add(node) total_weight += weight for edge_weight, adjacent in graph[node]: if adjacent not in visited: heapq.heappush(min_heap, (edge_weight, adjacent)) return total_weight"},{"question":"# Sparse Matrix Multiplication Description You are given two sparse matrices A and B. Your task is to write a function that computes the matrix product AB. You may assume that the number of columns in matrix A is equal to the number of rows in matrix B. Input * `A`: A list of lists of integers representing matrix A. * `B`: A list of lists of integers representing matrix B. Output * Return a list of lists of integers representing the matrix product AB. Constraints * The number of columns in A must match the number of rows in B. * The matrices can contain both positive and negative integers, as well as zeros. * Matrices A and B can have up to 1000 rows or columns. Example # Example 1: ``` Input: A = [ [ 1, 0, 0], [-1, 0, 3] ] B = [ [ 7, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 1 ] ] Output: [ [ 7, 0, 0 ], [-7, 0, 3 ] ] ``` Explanation In the example above, the multiplication is carried out only for non-zero elements, making it efficient. Notes 1. The space complexity of your solution should be optimized by leveraging the sparsity of the matrices. 2. Make sure to handle the edge case where matrices have dimensions that don\'t match the multiplication requirements.","solution":"def sparse_matrix_multiply(A, B): This function returns the product of two sparse matrices A and B. # Number of rows in A and columns in B rows_A = len(A) cols_B = len(B[0]) cols_A = len(A[0]) # Initialize the result matrix with zeros result = [[0] * cols_B for _ in range(rows_A)] # Use dictionary to store the non-zero elements of A to avoid computing with zeroes non_zero_A = {} for i in range(rows_A): for j in range(cols_A): if A[i][j] != 0: if i not in non_zero_A: non_zero_A[i] = {} non_zero_A[i][j] = A[i][j] # Compute the matrix product for i in non_zero_A: for k in non_zero_A[i]: for j in range(cols_B): result[i][j] += non_zero_A[i][k] * B[k][j] return result"},{"question":"# Problem Description You are given a binary tree and you need to implement an in-order traversal algorithm. The task is to create a function that takes the root node of a binary tree and returns a list of node values in in-order sequence. # Function Signature ```python def inorder_traversal(root: Node) -> List[int]: ``` # Input - `root` (`Node`): The root node of the binary tree. A `Node` object has three attributes: `val` (int), `left` (Node or None), and `right` (Node or None). # Output - Returns a list of integers representing the in-order traversal of the tree. # Constraints - The binary tree can have up to 10^6 nodes. - Node values are integers within the range `[-10^9, 10^9]`. # Example Consider the following binary tree: ``` 100 / 50 150 / / 25 75 125 175 ``` `Node` objects are created and connected as follows: ```python n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 ``` Input ```python inorder_traversal(n1) ``` Output ```python [25, 50, 75, 100, 125, 150, 175] ``` # Requirements 1. **Accuracy**: Ensure that your implementation returns the correct in-order sequence. 2. **Performance**: Handle up to 10^6 nodes efficiently. 3. **Memory**: Optimize for space, especially in the iterative solution. # Additional Challenge Implement both iterative and recursive versions of the in-order traversal in the same function, allowing the user to choose the method via an optional parameter.","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root: Node, method: str = \'recursive\') -> list: Returns the in-order traversal of the binary tree rooted at \'root\'. Parameters: - root: Node, the root of the binary tree - method: str, the method of traversal (\'recursive\' or \'iterative\') Returns: - list of integers representing the in-order traversal of the tree. if method == \'iterative\': return inorder_traversal_iterative(root) else: return inorder_traversal_recursive(root) def inorder_traversal_recursive(root: Node) -> list: result = [] def traverse(node: Node): if not node: return traverse(node.left) result.append(node.val) traverse(node.right) traverse(root) return result def inorder_traversal_iterative(root: Node) -> list: result, stack = [], [] current = root while stack or current: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result"},{"question":"# Summary of Ranges Algorithm Given a sorted list of unique integers, write a Python function `summarize_ranges(array: List[int]) -> List[str]` that returns the summary of its ranges. For each range `[a, b]` (inclusive) in the array, the output should contain \\"a-b\\". If the range contains only one element, it should be represented as \\"a\\". Input: - `array`: A sorted list of unique integers. Output: - A list of strings representing the summary of ranges. Constraints: - The input list is sorted in ascending order. - The input list contains no duplicate integers. - The input list can be empty, or contain just one element. Requirements: - The function should handle all edge cases gracefully. - The function should have a time complexity of O(n). - The function should use O(1) additional space beyond the space required for the output. Examples: 1. **Input**: `[0, 1, 2, 4, 5, 7]` **Output**: `[\'0-2\', \'4-5\', \'7\']` 2. **Input**: `[0, 2, 3, 4, 6, 8, 9]` **Output**: `[\'0\', \'2-4\', \'6\', \'8-9\']` 3. **Input**: `[]` **Output**: `[]` 4. **Input**: `[1, 3]` **Output**: `[\'1\', \'3\']` Implement the function `summarize_ranges(array: List[int]) -> List[str]` below: ```python def summarize_ranges(array: List[int]) -> List[str]: res = [] if not array: return res if len(array) == 1: return [str(array[0])] it = iter(array) start = end = next(it) for num in it: if num - end == 1: end = num else: res.append(f\\"{start}-{end}\\" if start != end else str(start)) start = end = num res.append(f\\"{start}-{end}\\" if start != end else str(start)) return res ```","solution":"def summarize_ranges(array: list[int]) -> list[str]: res = [] if not array: return res if len(array) == 1: return [str(array[0])] start = end = array[0] for num in array[1:]: if num == end + 1: end = num else: res.append(f\\"{start}-{end}\\" if start != end else str(start)) start = end = num res.append(f\\"{start}-{end}\\" if start != end else str(start)) return res"},{"question":"# Context Run-Length Encoding (RLE) is a straightforward and effective data compression algorithm that transforms a sequence of data into a sequence of counts of consecutive values. For example, the string `\\"AAAABBBCCDAA\\"` would be compressed to `\\"4A3B2C1D2A\\"` using RLE. Conversely, Run-Length Decoding (RLD) performs the reverse operation, converting the encoded sequence back to its original form. # Objective You are to implement two functions: 1. `encode_rle(input)` - This function takes a string as input and returns the run-length encoded string. 2. `decode_rle(input)` - This function takes a run-length encoded string as input and returns the decoded string. # Function Signatures ```python def encode_rle(input: str) -> str: pass def decode_rle(input: str) -> str: pass ``` # Input * `encode_rle(input: str)`: A string `input` where `1 <= len(input) <= 10^4`. It contains only uppercase English letters. * `decode_rle(input: str)`: A run-length encoded string `input` where `1 <= len(input) <= 10^4`. The encoding format guarantees that it is well-formed. # Output * The `encode_rle` function returns the run-length encoded version of the input string. * The `decode_rle` function returns the original string from its run-length encoded version. # Examples ```python # Example 1 (Encoding): input = \\"AAAABBBCCDAA\\" output = encode_rle(input) # \\"4A3B2C1D2A\\" # Example 2 (Decoding): input = \\"4A3B2C1D2A\\" output = decode_rle(input) # \\"AAAABBBCCDAA\\" # Example 3 (Encoding): input = \\"A\\" output = encode_rle(input) # \\"1A\\" # Example 4 (Decoding): input = \\"1A\\" output = decode_rle(input) # \\"A\\" ``` # Constraints & Notes * Ensure your code runs efficiently within the time and space limits. * Handle edge cases such as empty inputs or inputs without consecutive characters appropriately. * The input for `decode_rle` will always be a valid run-length encoded string.","solution":"def encode_rle(input: str) -> str: if not input: return \\"\\" encoded = [] count = 1 current_char = input[0] for char in input[1:]: if char == current_char: count += 1 else: encoded.append(f\\"{count}{current_char}\\") current_char = char count = 1 # Append the last run encoded.append(f\\"{count}{current_char}\\") return \'\'.join(encoded) def decode_rle(input: str) -> str: decoded = [] count = 0 for char in input: if char.isdigit(): count = count * 10 + int(char) else: decoded.append(char * count) count = 0 return \'\'.join(decoded)"},{"question":"You are given an array of integers and a commutative function (e.g., sum, maximum). Your task is to implement a segment tree to efficiently perform range queries and updates. # Function Signature ```python class SegmentTree: def __init__(self, arr: List[int], function: Callable[[Any, Any], Any]) -> None: pass def update(self, index: int, value: int) -> None: pass def query(self, left: int, right: int) -> Any: pass ``` # Requirements 1. **Init**: Initialize the segment tree using the input array and commutative function. 2. **Update**: Implement the update method to modify an element in the array. 3. **Query**: Implement the query method to return the result of the commutative function over a range [left, right] inclusive. # Input * The array consists of integers, e.g., `[1, 3, 5, 7, 9, 11]`. * Commutative function is provided, e.g., `lambda a, b: a + b` for sum. # Output * The query method should return the result of the commutative function over the specified range. * The update method should update the element at the specified index and adjust the segment tree accordingly. # Constraints * (1 leq text{len(array)} leq 10^5) * (0 leq text{array[i]} leq 10^9) * Updates and queries will be called multiple times. # Example ```python arr = [1, 3, 5, 7, 9, 11] segment_tree = SegmentTree(arr, lambda a, b: a + b) print(segment_tree.query(1, 3)) # Output: 15 segment_tree.update(1, 10) print(segment_tree.query(1, 3)) # Output: 22 ``` # Notes * Ensure your implementation is efficient and meets the required time complexities. * Handle edge cases such as updates and queries at the boundaries of the array.","solution":"from typing import List, Callable, Any class SegmentTree: def __init__(self, arr: List[int], function: Callable[[Any, Any], Any]) -> None: self.n = len(arr) self.function = function self.tree = [0] * (2 * self.n) # Build the tree for i in range(self.n): self.tree[self.n + i] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, index: int, value: int) -> None: # Update the leaf node index += self.n self.tree[index] = value # Update the internal nodes while index > 1: index //= 2 self.tree[index] = self.function(self.tree[2 * index], self.tree[2 * index + 1]) def query(self, left: int, right: int) -> Any: # Initialize result for merge function result = None # Adjust indices to leaf nodes left += self.n right += self.n while left <= right: if left % 2 == 1: result = self.tree[left] if result is None else self.function(result, self.tree[left]) left += 1 if right % 2 == 0: result = self.tree[right] if result is None else self.function(result, self.tree[right]) right -= 1 left //= 2 right //= 2 return result"},{"question":"# Hash Table with Custom Hash Function In this task, you will implement a hash table similar to the one provided but with a custom hash function. Your implementation will support basic operations including `put`, `get`, and `delete` and will adapt to dynamic resizing. You will need to: 1. Rewrite the hash function to use your custom logic instead of the provided modulo operation. 2. Ensure that your implementation maintains efficient average-case time complexity. 3. Handle collisions using linear probing and manage dynamic resizing when the table becomes too full. # Specific Requirements 1. **Custom Hash Function**: Implement a custom hash function in place of the existing `hash` method. 2. **Maintaining Efficiency**: Keep average-case time complexities for `put`, `get`, and `del` operations as O(1) while ensuring the hash table can resize dynamically as it grows. 3. **Handling Collisions**: Use linear probing to resolve collisions. 4. **Dynamic Resizing**: Implement dynamic resizing such that the table size doubles when the load factor exceeds 2/3. # Implementation Details 1. **Custom Hash Function**: Design and implement a custom function named `custom_hash_func` that takes a key and returns a hash value. 2. **Class Structure**: You can extend the given `HashTable` and `ResizableHashTable` classes, but you need to override the `hash` method to use your custom hash function. 3. **Resizing Logic**: Ensure that when extending the table size, all existing key-value pairs are rehashed and placed correctly in the new table. 4. **Edge Cases**: Handle cases where table becomes full, as well as scenarios involving deleted keys. # Function Signatures ```python class CustomHashTable(ResizableHashTable): def custom_hash_func(self, key): # Implement your custom hash function here. pass def hash(self, key): return self.custom_hash_func(key) # Example usage ht = CustomHashTable() ht.put(10, \'apple\') ht.put(20, \'orange\') print(ht.get(10)) # Output should be \'apple\' ht.del_(10) print(ht.get(10)) # Output should be None ``` # Constraints - Assume keys will be integers. - Values can be any data type. # Notes 1. The custom hash function you implement should aim to minimize collisions. 2. Ensure your hash table passes the provided unit tests for correctness. Good luck, and happy coding!","solution":"class CustomHashTable: def __init__(self, initial_capacity=8): self.capacity = initial_capacity self.size = 0 self.table = [None] * self.capacity self.threshold = 2 / 3 # Load factor threshold for resizing def custom_hash_func(self, key): hash_value = key * 2654435761 % 2**32 # A commonly used prime number and 32-bit overflow return hash_value def hash(self, key): return self.custom_hash_func(key) % self.capacity def put(self, key, value): if self.size / self.capacity > self.threshold: self._resize() idx = self.hash(key) while self.table[idx] is not None: if self.table[idx][0] == key: self.table[idx] = (key, value) return idx = (idx + 1) % self.capacity self.table[idx] = (key, value) self.size += 1 def get(self, key): idx = self.hash(key) while self.table[idx] is not None: if self.table[idx][0] == key: return self.table[idx][1] idx = (idx + 1) % self.capacity return None def delete(self, key): idx = self.hash(key) while self.table[idx] is not None: if self.table[idx][0] == key: value = self.table[idx][1] self.table[idx] = None self.size -= 1 return value idx = (idx + 1) % self.capacity return None def _resize(self): old_table = self.table self.capacity *= 2 self.size = 0 self.table = [None] * self.capacity for item in old_table: if item is not None: self.put(item[0], item[1]) # Example usage: ht = CustomHashTable() ht.put(10, \'apple\') print(ht.get(10)) # Output should be \'apple\' ht.put(20, \'orange\') print(ht.get(20)) # Output should be \'orange\' ht.delete(10) print(ht.get(10)) # Output should be None"},{"question":"# Kosaraju\'s Algorithm for Strongly Connected Components # Objective: Implement Kosaraju\'s Algorithm to find all the Strongly Connected Components (SCCs) in a given directed graph. # Description: Kosaraju’s algorithm uses linear time Depth-First Search (DFS) to find SCCs. The graph is first traversed to get the finish times of each vertex. It is then transposed, and another DFS is performed in the order of decreasing finishing times. # Problem Statement: Given a directed graph, implement the `Kosaraju` class with a method `kosaraju` that takes the number of vertices `V` and the adjacency list `adj` as input and returns the count of SCCs. # Input Format: - The first line contains two integers (V) and (E) (1 <= V, E <= 1000), the number of vertices and edges in the graph. - The next (E) lines each contain two integers (u) and (v) (0 <= u, v < V), representing a directed edge from vertex `u` to vertex `v`. # Output Format: - Print the number of Strongly Connected Components in the graph. # Constraints: - Integer (1 leq V, E leq 1000). - Directed graph, no multiple edges between the same vertices. # Example: Input: ``` 6 7 0 2 1 0 2 3 3 1 3 4 4 5 5 4 ``` Output: ``` 2 ``` Explanation: The input graph has 6 vertices and 7 edges. Kosaraju\'s algorithm will identify 2 strongly connected components. # Requirements: 1. Implement the `Kosaraju` class and the `kosaraju` method. 2. Your solution should efficiently handle the edge cases and constraints given. # Function Signature: ```python class Kosaraju: def kosaraju(self, V: int, adj: List[List[int]]) -> int: ``` Write your solution below:","solution":"from typing import List class Kosaraju: def kosaraju(self, V: int, adj: List[List[int]]) -> int: def dfs(v, visited, stack): visited[v] = True for neighbour in adj[v]: if not visited[neighbour]: dfs(neighbour, visited, stack) stack.append(v) def dfs_transposed(v, visited, transposed_adj): visited[v] = True for neighbour in transposed_adj[v]: if not visited[neighbour]: dfs_transposed(neighbour, visited, transposed_adj) # Step 1: Perform standard DFS and push nodes onto stack by finish time stack = [] visited = [False] * V for v in range(V): if not visited[v]: dfs(v, visited, stack) # Step 2: Transpose the graph transposed_adj = [[] for _ in range(V)] for u in range(V): for v in adj[u]: transposed_adj[v].append(u) # Step 3: Perform DFS on transposed graph in order of decreasing finishing times visited = [False] * V scc_count = 0 while stack: v = stack.pop() if not visited[v]: dfs_transposed(v, visited, transposed_adj) scc_count += 1 return scc_count"},{"question":"# Scenario Imagine you are part of a software development team that handles complex data preprocessing tasks. One common task is to transform deeply nested lists into a single, flat list. Your task is to help implement a solution that can efficiently handle these cases. # Problem Statement You will write a function to flatten nested arrays (lists). Although Python lists are defined here, your solution should universally apply to any iterable types and respect non-iterable elements like strings or numbers. Implement the following function: Function Signature ```python def flatten_recursive(input_data: Iterable) -> List: Recursive function to flatten a nested list. Args: input_data (Iterable): The nested iterable containing a mix of data. Returns: List: A flat list with all elements from the input iterable. pass def flatten_iteratively(input_data: Iterable) -> Iterator: Iterative function to flatten a nested list using a generator. Args: input_data (Iterable): The nested iterable containing a mix of data. Returns: Iterator: A flat iterator with all elements from the input iterable. pass ``` # Constraints: * **Input** can be any iterable containing nested iterables. * **Output** must be a single-level list or iterator containing all elements from the input in a depth-first order. * You **cannot** use in-built or third-party libraries that directly flatten the structure (e.g., `itertools.chain`). # Example Usage ```python # Example for recursive function flatten_recursive([1, [2, [3, 4], 5], 6, [[7]], 8]) # Expected Output: [1, 2, 3, 4, 5, 6, 7, 8] # Example for iterative function list(flatten_iteratively([1, [2, [3, 4], 5], 6, [[7]], 8])) # Expected Output: [1, 2, 3, 4, 5, 6, 7, 8] ``` **Notes**: * Pay close attention to non-iterable types within the input to avoid incorrect processing. * Ensure your recursive and iterative implementations are both optimized for performance and memory usage.","solution":"from collections.abc import Iterable from typing import List, Iterator def flatten_recursive(input_data: Iterable) -> List: Recursive function to flatten a nested list. Args: input_data (Iterable): The nested iterable containing a mix of data. Returns: List: A flat list with all elements from the input iterable. flat_list = [] for element in input_data: if isinstance(element, Iterable) and not isinstance(element, (str, bytes)): flat_list.extend(flatten_recursive(element)) else: flat_list.append(element) return flat_list def flatten_iteratively(input_data: Iterable) -> Iterator: Iterative function to flatten a nested list using a generator. Args: input_data (Iterable): The nested iterable containing a mix of data. Returns: Iterator: A flat iterator with all elements from the input iterable. stack = [iter(input_data)] while stack: try: element = next(stack[-1]) if isinstance(element, Iterable) and not isinstance(element, (str, bytes)): stack.append(iter(element)) else: yield element except StopIteration: stack.pop()"},{"question":"# Question: You are given an integer `n`. Your task is to determine the number of structurally unique BSTs (binary search trees) that store values 1 to `n`. For example: ``` Input: n = 3 Output: 5 ``` This means there are 5 unique BST\'s that can be formed with values {1, 2, 3}, as visually represented below: ``` 1 3 3 2 1 / / / 3 2 1 1 3 2 / / 2 1 2 3 ``` # Function Signature: Implement the function `num_trees(n: int) -> int` such that: - The function receives an integer `n` and returns an integer representing the number of structurally unique BSTs that store values 1 to `n`. # Constraints: - `0 <= n <= 19` - The function should be optimized for both time and space complexity. - Ensure your function handles edge cases such as `n = 0` and `n = 1`. # Performance Requirements: - Time Complexity: O(n^2) - Space Complexity: O(n) # Examples: 1. **Example 1** - Input: `n = 3` - Output: `5` 2. **Example 2** - Input: `n = 0` - Output: `1` 3. **Example 3** - Input: `n = 1` - Output: `1` # Test Cases: 1. `num_trees(4)` should return `14`. 2. `num_trees(5)` should return `42`.","solution":"def num_trees(n: int) -> int: Returns the number of structurally unique BSTs that store values 1 to n. if n == 0 or n == 1: return 1 dp = [0] * (n + 1) dp[0], dp[1] = 1, 1 for i in range(2, n + 1): for j in range(1, i + 1): dp[i] += dp[j - 1] * dp[i - j] return dp[n]"},{"question":"# Graph Traversal Challenge Your task is to implement two functions, `graph_traversal_dfs` and `graph_traversal_bfs`, to traverse a given graph using Depth First Search (DFS) and Breadth First Search (BFS) techniques respectively. Graph is represented as a dictionary where keys are nodes, and corresponding values are lists of adjacent nodes. # Function Specifications Function 1: graph_traversal_dfs ```python def graph_traversal_dfs(graph: Dict[int, List[int]], start: int) -> List[int]: pass ``` Function 2: graph_traversal_bfs ```python def graph_traversal_bfs(graph: Dict[int, List[int]], start: int) -> List[int]: pass ``` # Input * `graph`: Dictionary representing the graph structure. `{int: List[int]}`. * `start`: Integer representing the starting node for the traversal. # Output * Return a list of integers representing the nodes in the order they are visited during the traversal. # Constraints * All nodes in the graph are non-negative integers. * The graph is connected, meaning there\'s a path between any two nodes. * The graph can have up to (10^4) nodes and (10^5) edges. * Self-loops or multiple edges between two nodes are allowed. # Example ```python graph = { 0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2, 4], 4: [3] } start = 0 print(graph_traversal_dfs(graph, start)) # Possible output: [0, 3, 4, 2, 1] print(graph_traversal_bfs(graph, start)) # Possible output: [0, 1, 3, 2, 4] ``` # Notes - The order of nodes for the DFS traversal may differ due to differing path choices but should remain consistent with the DFS strategy. - Similar flexibility applies to BFS output as long as it adheres to the BFS level order strategy.","solution":"def graph_traversal_dfs(graph, start): Perform a depth-first search on the graph starting from the given node. visited = set() traversal_order = [] def dfs(node): if node in visited: return visited.add(node) traversal_order.append(node) for neighbor in graph[node]: dfs(neighbor) dfs(start) return traversal_order def graph_traversal_bfs(graph, start): Perform a breadth-first search on the graph starting from the given node. visited = set() queue = [start] traversal_order = [] while queue: node = queue.pop(0) if node not in visited: visited.add(node) traversal_order.append(node) queue.extend(neighbor for neighbor in graph[node] if neighbor not in visited) return traversal_order"},{"question":"# FizzBuzz Plus: The Extended Multiples Challenge You are tasked with extending the classic FizzBuzz implementation to handle additional specified multiples and substitutions. # Problem Statement: Write a function called `custom_fizzbuzz` that takes an integer `n`, a dictionary `multiples_dict` where the keys are integers and the values are strings. The function should iterate from 1 to `n` and do the following: - For each number, check if it is divisible by any keys in `multiples_dict`. - If a number is divisible by exactly one key `k`, replace it with the corresponding value from `multiples_dict[k]`. - If a number is divisible by multiple keys, concatenate the corresponding values in the order of the keys. - If a number is not divisible by any key, retain the number itself. # Input: - An integer `n` where `n >= 1`. - A dictionary `multiples_dict` with integer keys and string values. # Output: - A list of length `n` with elements transformed based on the above rules. Examples: ```python custom_fizzbuzz(15, {3: \\"Fizz\\", 5: \\"Buzz\\"}) # Output: [1, 2, \\"Fizz\\", 4, \\"Buzz\\", \\"Fizz\\", 7, 8, \\"Fizz\\", \\"Buzz\\", 11, \\"Fizz\\", 13, 14, \\"FizzBuzz\\"] custom_fizzbuzz(10, {2: \\"Even\\", 3: \\"Odd\\"}) # Output: [1, \\"Even\\", \\"Odd\\", \\"Even\\", 5, \\"EvenOdd\\", 7, \\"Even\\", \\"Odd\\", \\"Even\\"] custom_fizzbuzz(5, {7: \\"Seven\\"}) # Output: [1, 2, 3, 4, 5] ``` # Constraints: - The value of `n` will be a positive integer. - The dictionary will contain positive integer keys. - The total number of keys in the dictionary will be less than 10. Implement the function as described.","solution":"def custom_fizzbuzz(n, multiples_dict): result = [] for i in range(1, n + 1): output = \\"\\" for key in sorted(multiples_dict.keys()): if i % key == 0: output += multiples_dict[key] result.append(output if output else i) return result"},{"question":"You are tasked to determine if a given non-empty string can be constructed by taking a substring of it and appending multiple copies of the substring together. The string consists of lowercase alphabetical characters only. # Function Signature: ```python def is_repeated_substring(s: str) -> bool: pass ``` # Inputs: - A string `s` with length `1 <= len(s) <= 10^4`. # Output: - A boolean value `True` if the string can be constructed by repeating a substring, otherwise `False`. # Example: ```python assert is_repeated_substring(\\"abab\\") == True assert is_repeated_substring(\\"aba\\") == False assert is_repeated_substring(\\"abcabcabcabc\\") == True ``` # Constraints: - The input string `s` will always be non-empty and contain only lowercase alphabetical characters. # Notes: - Consider the edge cases where the string has a single character and strings where no repetition is possible. # Requirements: - You must implement the function efficiently both in terms of time and space complexity (O(n) time complexity and O(n) space complexity). # Clarification: The approach should not brute force checking all possible substrings but instead make use of an optimized method as analyzed above, leveraging string manipulation techniques efficiently.","solution":"def is_repeated_substring(s: str) -> bool: Determine if the string can be constructed by repeating a substring. n = len(s) for i in range(1, n // 2 + 1): if n % i == 0: if s[:i] * (n // i) == s: return True return False"},{"question":"# FizzBuzz Enhanced Coding Challenge You are required to implement an enhanced version of the classic FizzBuzz algorithm. This version must: - Replace numbers divisible by 3 with \\"Fizz\\". - Replace numbers divisible by 5 with \\"Buzz\\". - Replace numbers divisible by both 3 and 5 with \\"FizzBuzz\\". - Replace numbers divisible by 7 with \\"Bazz\\". **Function Signature:** ```python def enhanced_fizzbuzz(n: int) -> List[Union[int, str]]: ``` **Input:** - `n` (integer): A positive integer (1 ≤ n ≤ 10^6). **Output:** - A list of integers and/or strings as per the rules specified above, from 1 to n. **Constraints:** - The function should handle up to 10^6 numbers efficiently in terms of both time and space. # Example: ```python assert enhanced_fizzbuzz(15) == [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', \'Bazz\', 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, \'Bazz\', \'FizzBuzz\'] ``` # Implementation notes: - Efficiently handle the provided constraints (1 ≤ n ≤ 10^6), considering performance and memory usage. - Consider edge cases such as smallest valid (N = 1) and largest valid inputs (N up to 10^6). - Aim to reduce any redundant checks and optimize performance where possible.","solution":"from typing import List, Union def enhanced_fizzbuzz(n: int) -> List[Union[int, str]]: Generate a list from 1 to n with the following rules: - Replace numbers divisible by 3 with \\"Fizz\\". - Replace numbers divisible by 5 with \\"Buzz\\". - Replace numbers divisible by both 3 and 5 with \\"FizzBuzz\\". - Replace numbers divisible by 7 with \\"Bazz\\". Args: n (int): A positive integer (1 ≤ n ≤ 10^6). Returns: List[Union[int, str]]: List with replacements as per the rules. result = [] for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") elif i % 7 == 0: result.append(\\"Bazz\\") else: result.append(i) return result"},{"question":"# Modular Exponential Function You are tasked with implementing a function that efficiently computes modulo powers using the principle of exponentiation by squaring. Your function should correctly handle both typical and edge cases and should be optimized for performance. Function Signature ```python def modular_exponential(base: int, exponent: int, mod: int) -> int: ``` Input - `base` (int): The base of the exponential expression (0 <= base <= 10^9). - `exponent` (int): The exponent of the expression (0 <= exponent <= 10^9). - `mod` (int): The modulus (1 <= mod <= 10^9). Output - `int`: The result of ( (base^text{exponent}) , % , text{mod} ). Constraints 1. Exponent must be non-negative. 2. Modulus must be positive. 3. Handle large numbers efficiently without causing overflow. Example ```python assert modular_exponential(2, 10, 1000) == 24 # (2^10) % 1000 = 1024 % 1000 = 24 assert modular_exponential(3, 7, 13) == 3 # (3^7) % 13 = 2187 % 13 = 3 assert modular_exponential(10, 0, 7) == 1 # (10^0) % 7 = 1 % 7 = 1 ``` Explanation This function needs to efficiently compute the given exponential expression under a modulus, even for very large numbers. The solution should utilize the exponentiation by squaring technique to reduce the time complexity to O(log n) and ensure that intermediate results are managed correctly to avoid overflow and large number performance issues.","solution":"def modular_exponential(base: int, exponent: int, mod: int) -> int: Computes (base^exponent) % mod using the method of exponentiation by squaring. :param base: The base of the exponential expression (0 <= base <= 10^9). :param exponent: The exponent of the expression (0 <= exponent <= 10^9). :param mod: The modulus (1 <= mod <= 10^9). :return: The result of (base^exponent) % mod. result = 1 base = base % mod # Ensure base is within mod initially while exponent > 0: if (exponent % 2) == 1: # Odd exponent case result = (result * base) % mod exponent = exponent >> 1 # Divide exponent by 2 base = (base * base) % mod # Square the base return result"},{"question":"# Red-Black Tree Implementation and Balancing Verification **Context**: You are working for a software company that handles the backend infrastructure for a large-scale database. One of the core components of their architecture requires efficient and balanced data search and modification operations. A Red-Black Tree data structure is being used for this purpose. Your task is to implement a Red-Black Tree from scratch and validate its self-balancing properties. # Task 1. **Implement the Red-Black Tree**: - Implement the basic structure and functions of a Red-Black tree based on the provided code snippets. - Ensure correct implementation of insertion, deletion, and their corresponding fix-up functions. 2. **Verify Balancing Properties**: - Write a function `is_valid_rb_tree()` to verify if the tree maintains all Red-Black Tree properties. # Function Signatures ```python # Node class for Red-Black Tree node class RBNode: def __init__(self, val, is_red, parent=None, left=None, right=None): self.val = val # Value of the node self.parent = parent # Parent node self.left = left # Left child node self.right = right # Right child node self.color = is_red # Node color (True for red, False for black) # Red-Black Tree class with required methods class RBTree: def __init__(self): self.root = None # Root node of the Red-Black Tree def insert(self, node: RBNode) -> None: # Insert a node into the Red-Black Tree def delete(self, node: RBNode) -> None: # Delete a node from the Red-Black Tree def left_rotate(self, node: RBNode) -> None: # Perform a left rotation def right_rotate(self, node: RBNode) -> None: # Perform a right rotation def fix_insert(self, node: RBNode) -> None: # Fix Red-Black Tree properties after insertion def fix_delete(self, node: RBNode) -> None: # Fix Red-Black Tree properties after deletion def inorder(self) -> List[Dict[str, Union[int, bool]]]: # Perform an inorder traversal of the tree def is_valid_rb_tree(self) -> bool: Verify if the tree maintains all Red-Black Tree properties. # Input and Output Formats - The `insert` and `delete` functions should properly update the tree maintaining Red-Black Tree properties. - The `is_valid_rb_tree` function should return `True` if all Red-Black Tree properties are maintained, otherwise `False`. # Constraints and Considerations - Each node\'s value will be an integer. - Node values will be unique in the tree. - You must ensure that all tree properties hold after any number of insertions and deletions. # Example ```python if __name__ == \\"__main__\\": # Create a Red-Black Tree instance rb = RBTree() # Insert nodes nodes = [RBNode(val, True) for val in [11, 2, 14, 1, 7, 15, 5, 8, 4]] for node in nodes: rb.insert(node) # Verify the Red-Black Tree properties is_valid = rb.is_valid_rb_tree() print(\\"Is valid RB Tree:\\", is_valid) # Expected output: True # Perform further operations and verification rb.delete(nodes[0]) # Delete the node with value 11 is_valid = rb.is_valid_rb_tree() print(\\"Is valid RB Tree after deletion:\\", is_valid) # Expected output: True ``` # Performance Requirements - Your solution should maintain O(log n) time complexity for insertion and deletion operations. - Operations should be optimized to handle a large number of insertions and deletions efficiently.","solution":"class RBNode: def __init__(self, val, is_red=True, parent=None, left=None, right=None): self.val = val self.parent = parent self.left = left self.right = right self.is_red = is_red class RBTree: def __init__(self): self.NULL = RBNode(val=None, is_red=False) # Sentinel node self.root = self.NULL def insert(self, key): new_node = RBNode(val=key, left=self.NULL, right=self.NULL, is_red=True) parent = None current = self.root while current != self.NULL: parent = current if new_node.val < current.val: current = current.left else: current = current.right new_node.parent = parent if parent is None: self.root = new_node elif new_node.val < parent.val: parent.left = new_node else: parent.right = new_node if new_node.parent is None: new_node.is_red = False return if new_node.parent.parent is None: return self.fix_insert(new_node) def left_rotate(self, node): temp = node.right node.right = temp.left if temp.left != self.NULL: temp.left.parent = node temp.parent = node.parent if node.parent is None: self.root = temp elif node == node.parent.left: node.parent.left = temp else: node.parent.right = temp temp.left = node node.parent = temp def right_rotate(self, node): temp = node.left node.left = temp.right if temp.right != self.NULL: temp.right.parent = node temp.parent = node.parent if node.parent is None: self.root = temp elif node == node.parent.right: node.parent.right = temp else: node.parent.left = temp temp.right = node node.parent = temp def fix_insert(self, node): while node.parent.is_red: if node.parent == node.parent.parent.right: uncle = node.parent.parent.left if uncle.is_red: uncle.is_red = False node.parent.is_red = False node.parent.parent.is_red = True node = node.parent.parent else: if node == node.parent.left: node = node.parent self.right_rotate(node) node.parent.is_red = False node.parent.parent.is_red = True self.left_rotate(node.parent.parent) else: uncle = node.parent.parent.right if uncle.is_red: uncle.is_red = False node.parent.is_red = False node.parent.parent.is_red = True node = node.parent.parent else: if node == node.parent.right: node = node.parent self.left_rotate(node) node.parent.is_red = False node.parent.parent.is_red = True self.right_rotate(node.parent.parent) if node == self.root: break self.root.is_red = False def delete_node_helper(self, node, key): z = self.NULL while node != self.NULL: if node.val == key: z = node if node.val <= key: node = node.right else: node = node.left if z == self.NULL: print(\\"Cannot find key in the tree\\") return y = z y_original_color = y.is_red if z.left == self.NULL: x = z.right self.rb_transplant(z, z.right) elif (z.right == self.NULL): x = z.left self.rb_transplant(z, z.left) else: y = self.minimum(z.right) y_original_color = y.is_red x = y.right if y.parent == z: x.parent = y else: self.rb_transplant(y, y.right) y.right = z.right y.right.parent = y self.rb_transplant(z, y) y.left = z.left y.left.parent = y y.is_red = z.is_red if y_original_color == False: self.fix_delete(x) def fix_delete(self, x): while x != self.root and x.is_red == False: if x == x.parent.left: s = x.parent.right if s.is_red: s.is_red = False x.parent.is_red = True self.left_rotate(x.parent) s = x.parent.right if s.left.is_red == False and s.right.is_red == False: s.is_red = True x = x.parent else: if s.right.is_red == False: s.left.is_red = False s.is_red = True self.right_rotate(s) s = x.parent.right s.is_red = x.parent.is_red x.parent.is_red = False s.right.is_red = False self.left_rotate(x.parent) x = self.root else: s = x.parent.left if s.is_red: s.is_red = False x.parent.is_red = True self.right_rotate(x.parent) s = x.parent.left if s.left.is_red == False and s.right.is_red == False: s.is_red = True x = x.parent else: if s.left.is_red == False: s.right.is_red = False s.is_red = True self.left_rotate(s) s = x.parent.left s.is_red = x.parent.is_red x.parent.is_red = False s.left.is_red = False self.right_rotate(x.parent) x = self.root x.is_red = False def rb_transplant(self, u, v): if u.parent == None: self.root = v elif u == u.parent.left: u.parent.left = v else: u.parent.right = v v.parent = u.parent def minimum(self, node): while node.left != self.NULL: node = node.left return node def delete(self, key): self.delete_node_helper(self.root, key) def is_valid_rb_tree(self): def count_black_nodes(node): if node == self.NULL: return 1 left_count = count_black_nodes(node.left) right_count = count_black_nodes(node.right) if left_count != 0 and left_count == right_count: return left_count + (0 if node.is_red else 1) return 0 def check_red_black_properties(node): if node == self.NULL: return True # NULL nodes are black and don\'t violate properties if node.is_red: # Red violation: no two red nodes can be adjacent if (node.left.is_red or node.right.is_red): return False if count_black_nodes(self.root) == 0: return False # Black height is not consistent return (check_red_black_properties(node.left) and check_red_black_properties(node.right)) # Main verification if self.root.is_red: return False # Root must be black return check_red_black_properties(self.root)"},{"question":"# Problem Description You have been tasked with optimizing an array duplicate removal algorithm. The current approach has a quadratic time complexity, which makes it inefficient for large datasets. Your goal is to write a function that efficiently removes duplicates from an array while maintaining the order of the first occurrences of elements. # Function Signature ```python def optimized_remove_duplicates(array: list) -> list: pass ``` # Input * `array` (list): A list containing elements, where elements can be of any hashable type (e.g., integers, strings, booleans). The list is not necessarily sorted and may contain duplicates. # Output * Returns a list with duplicates removed, preserving the order of the first occurrences of the elements. # Constraints * The length of the `array` will be at most 10^5. * The array may contain mixed hashable types. # Performance Requirement * The solution should aim for an average-case time complexity of O(n). # Example ```python assert optimized_remove_duplicates([1, 1 ,1 ,2 ,2 ,3 ,4 ,4 ,\\"hey\\", \\"hey\\", \\"hello\\", True, True]) == [1, 2, 3, 4, \'hey\', \'hello\'] assert optimized_remove_duplicates([]) == [] assert optimized_remove_duplicates([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] ``` # Scenario Consider a case where you work with data sets containing thousands of user IDs, and some IDs may appear more than once due to repeated submissions. Efficient duplicate removal is crucial to ensure data integrity without compromising performance. Design your function to handle such scenarios effectively.","solution":"def optimized_remove_duplicates(array: list) -> list: Removes duplicates from the input list while preserving the order of the first occurrences. Args: array (list): The input list which may contain duplicates. Returns: list: A list with duplicates removed and order of first occurrences preserved. seen = set() result = [] for item in array: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"You have been assigned to develop a function that efficiently computes the power of a number under a modular constraint. This function is essential for cryptographic algorithms, ensuring results are managed within feasible numerical ranges. Function Specification Write a function `modular_exponential(base: int, exponent: int, mod: int) -> int` that computes ( ( text{base}^{text{exponent}} ) mod text{mod} ). Input - `base` (int): the base number, where ( 1 leq text{base} leq 10^9 ). - `exponent` (int): the exponent number, where ( 0 leq text{exponent} leq 10^9 ). - `mod` (int): the modulus, where ( 1 leq text{mod} leq 10^9 ). Output - (int): the result of ( ( text{base}^{text{exponent}} ) mod text{mod} ). Constraints - All inputs are guaranteed to be positive integers. - The function must compute the result within an acceptable time frame for the given constraints. Example ```python print(modular_exponential(2, 10, 1000)) # Expected output: 24 print(modular_exponential(7, 13, 11)) # Expected output: 2 print(modular_exponential(5, 0, 7)) # Expected output: 1 ``` Description 1. Use the method of exponentiation by squaring to achieve the efficient computations. 2. Ensure you handle edge cases such as when the exponent is zero. 3. Consider raising appropriate errors for invalid inputs, though inputs according to the constraints are guaranteed to be valid. Implement the function based on the described algorithm and constraints.","solution":"def modular_exponential(base: int, exponent: int, mod: int) -> int: Computes (base ** exponent) % mod using the method of exponentiation by squaring for efficiency. if mod == 1: return 0 result = 1 base = base % mod # In case base is larger than mod while exponent > 0: if exponent % 2 == 1: result = (result * base) % mod exponent = exponent >> 1 # Divide exponent by 2 base = (base * base) % mod return result"},{"question":"# Scenario You are developing a system that requires binary trees to be stored persistently and later reconstructed exactly as they were before. To achieve this, you need an efficient way to serialize and deserialize binary trees. # Problem Statement Implement two functions: `serialize` and `deserialize` to convert a binary tree into a string and to parse the string back into the original binary tree structure. Function 1: serialize * **Input**: A `TreeNode` object representing the root of a binary tree. * **Output**: A `str` representing the serialized binary tree. Function 2: deserialize * **Input**: A `str` representing a serialized binary tree. * **Output**: A `TreeNode` object representing the root of the binary tree. # Constraints * The number of nodes in the tree is in the range `[0, 10^4]`. * The tree might be very deep (i.e., over 1000 levels). # Example ```python # Example usage: # Constructing a binary tree: # 1 # / # 2 3 # / # 4 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(4) root.right.right = TreeNode(5) serialized = serialize(root) print(serialized) # Should print a string representation of the tree deserialized = deserialize(serialized) assert serialize(deserialized) == serialized # The tree should be accurately reconstructed ``` # Additional Considerations * Ensure your solution handles edge cases like empty trees or very deep/unbalanced trees. * Optimize for both time and space efficiency. * You may assume that the input for deserialization is always valid.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root): Encodes a tree to a single string. def helper(node): if node: vals.append(str(node.val)) helper(node.left) helper(node.right) else: vals.append(\'#\') vals = [] helper(root) return \' \'.join(vals) def deserialize(data): Decodes your encoded data to tree. def helper(): val = next(vals) if val == \'#\': return None node = TreeNode(int(val)) node.left = helper() node.right = helper() return node vals = iter(data.split()) return helper()"},{"question":"# Question: You are given a connected, undirected graph as an adjacency list where each key represents a node, and the associated value is a list of nodes connected to it. Implement the following functions: 1. `find_any_path(graph, start, end)`: This function should return any single path from the start node to the end node using recursive traversal and backtracking. 2. `find_all_paths(graph, start, end)`: This function should return all possible paths from the start node to the end node using recursive traversal and backtracking. 3. `find_shortest_path(graph, start, end)`: This function should return the shortest path (least number of edges) from the start node to the end node using recursive traversal and backtracking techniques. # Function Signatures: ```python def find_any_path(graph, start, end): pass def find_all_paths(graph, start, end): pass def find_shortest_path(graph, start, end): pass ``` # Input: * `graph`: A dictionary representing the adjacency list of the graph. The keys are the nodes, and the values are lists of nodes connected by an edge. * `start`: The starting node for the path (a key in the graph). * `end`: The ending node for the path (a key in the graph). # Output: * `find_any_path`: Returns a list representing any path from `start` to `end`. If no path exists, return `None`. * `find_all_paths`: Returns a list of lists, where each inner list represents a path from `start` to `end`. If no paths exist, return an empty list. * `find_shortest_path`: Returns a list representing the shortest path from `start` to `end`. If no path exists, return `None`. # Constraints: * You may assume that the graph is connected and undirected. * The nodes are labeled with integers or strings. * The graph will contain at least one node but not more than 1000 nodes. # Example: ```python graph = { \'A\': [\'B\', \'D\'], \'B\': [\'A\', \'C\', \'D\'], \'C\': [\'B\', \'D\'], \'D\': [\'A\', \'B\', \'C\'] } # Example function calls print(find_any_path(graph, \'A\', \'C\')) # Output: [\'A\', \'B\', \'C\'] or any valid path print(find_all_paths(graph, \'A\', \'C\')) # Output: [[\'A\', \'B\', \'C\'], [\'A\', \'D\', \'C\'], ...] print(find_shortest_path(graph, \'A\', \'C\')) # Output: [\'A\', \'B\', \'C\'] (or shortest path) ```","solution":"def find_any_path(graph, start, end, path=[]): path = path + [start] if start == end: return path for node in graph[start]: if node not in path: new_path = find_any_path(graph, node, end, path) if new_path: return new_path return None def find_all_paths(graph, start, end, path=[]): path = path + [start] if start == end: return [path] paths = [] for node in graph[start]: if node not in path: new_paths = find_all_paths(graph, node, end, path) for new_path in new_paths: paths.append(new_path) return paths def find_shortest_path(graph, start, end): paths = find_all_paths(graph, start, end) if not paths: return None shortest_path = min(paths, key=len) return shortest_path"},{"question":"You have been hired by a tech company to optimize and improve the efficiency of an algorithm used in their text processing system. The current implementation is slow and doesn\'t scale well for large inputs. Your task is to write a more efficient solution. Objective: Given a string `s`, find the index of the first non-repeating character in it and return its index. If it doesn\'t exist, return -1. Function Signature ```python def first_unique_char(s: str) -> int: pass ``` Input: * A string `s` with a length between 0 and 10^5. Output: * An integer representing the index of the first non-repeating character or -1 if no such character exists. Examples: * `first_unique_char(\\"leetcode\\")` should return `0`. * `first_unique_char(\\"loveleetcode\\")` should return `2`. * `first_unique_char(\\"aabb\\")` should return `-1`. Constraints: * You should aim for an optimal solution with a time complexity of O(n). * Focus on efficient space use, ideally keeping it within O(n). Edge Cases: * `first_unique_char(\\"\\")` should return `-1` for an empty string. * `first_unique_char(\\"a\\")` should return `0` for a single-character string. * `first_unique_char(\\"aabbcc\\")` should return `-1` for strings with all repeating characters.","solution":"def first_unique_char(s: str) -> int: Given a string s, find the first non-repeating character and return its index. If it doesn\'t exist, return -1. # Dictionary to store count of each character char_count = {} # First pass: Count the frequency of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Second pass: Find the first character with a count of 1 for index, char in enumerate(s): if char_count[char] == 1: return index return -1"},{"question":"Context: In robust statistical analysis, it\'s often necessary to calculate the mean of a dataset while mitigating the effects of outliers. One common method is to \\"trim\\" a certain percentage of the highest and lowest values in the dataset before calculating the mean. This method helps in providing a more stable and representative measure of central tendency. Task: Implement the function `trimmean(arr, per)`, which calculates the trimmed mean of the dataset `arr` by excluding the top and bottom `per` percent values. Function Signature: ```python def trimmean(arr: List[int], per: float) -> float: ``` Input: * `arr` - A list of integers representing the dataset (1 <= length of arr <= 10^6). * `per` - A float representing the percentage of values to trim from both ends of the sorted dataset (0 <= per < 100). Output: * Returns a float which is the trimmed mean of the dataset. Constraints: - The input list `arr` will have at least one element but no more than one million. - The percentage `per` will be a non-negative float less than 100. - The calculated mean should be precise up to two decimal places. Example: ```python arr = [6, 2, 3, 9, 12, 7, 8, 14, 1, 15, 11, 4, 10, 5, 13] per = 20 print(trimmean(arr, per)) ``` *Output: 8.0* Explanation: 1. **Sorting**: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] 2. **Removing 10% from each end (20% of `15` is `3` from each end)**: [4, 5, 6, 7, 8, 9, 10, 11, 12] 3. **Mean**: (4+5+6+7+8+9+10+11+12) / 9 = 8.0 Use this information to implement the function and handle various edge cases effectively.","solution":"from typing import List def trimmean(arr: List[int], per: float) -> float: Calculate the trimmed mean of the dataset arr by excluding the top and bottom per percent values. # Sort the array arr_sorted = sorted(arr) n = len(arr) # Calculate number of elements to trim from each end trim_count = int(n * (per / 100) / 2) # Slice off the trim_count elements from both ends of the sorted array trimmed_array = arr_sorted[trim_count : n - trim_count] # Calculate the mean of the trimmed array trimmed_mean = sum(trimmed_array) / len(trimmed_array) # Return the mean rounded to two decimal places return round(trimmed_mean, 2)"},{"question":"# Question: Optimized Insertion Sort You are given a list of numbers. Your task is to implement an optimized version of the Insertion Sort algorithm. This optimized version should include early termination if the array is detected to be sorted at any point to improve performance over the standard Insertion Sort. Implement the function `optimized_insertion_sort` that takes in a list of integers `arr` and returns the sorted list. Function Signature ```python def optimized_insertion_sort(arr: List[int]) -> List[int]: ``` # Input - `arr`: A list of integers (e.g., `[-1, 2, 3, 1, 4]`). # Output - A list of integers sorted in non-decreasing order. # Constraints - The list can contain negative numbers. - The list length will be between 0 and 1000. # Example ```python assert optimized_insertion_sort([4, 3, 2, 1]) == [1, 2, 3, 4] assert optimized_insertion_sort([1, 2, 3, 4]) == [1, 2, 3, 4] assert optimized_insertion_sort([10, -2, 33, 21, 0]) == [-2, 0, 10, 21, 33] assert optimized_insertion_sort([]) == [] ``` # Performance - Your algorithm should attempt to terminate early if it detects that the array is already sorted during any iteration, aiming to improve from O(n^2) to O(n) in the best-case scenario.","solution":"from typing import List def optimized_insertion_sort(arr: List[int]) -> List[int]: Performs an optimized insertion sort on the input list. The optimization includes an early termination if the array is detected to be sorted. n = len(arr) for i in range(1, n): current_value = arr[i] position = i while position > 0 and arr[position - 1] > current_value: arr[position] = arr[position - 1] position -= 1 arr[position] = current_value # Early termination check if all(arr[j] <= arr[j + 1] for j in range(n - 1)): break return arr"},{"question":"You are tasked with writing a function to sort an array of integers using Exchange Sort. In addition to sorting, your function should handle edge cases gracefully and should include additional features to address some common array problems. # Specifications 1. **Function Name**: enhanced_exchange_sort 2. **Input**: A list of integers `arr` 3. **Output**: A sorted list of integers # Constraints 1. The function should also return a count of the number of swaps that occurred during the sorting process. 2. Implement a check to detect if the array is already sorted before starting the sorting process. 3. Handle edge cases such as empty arrays or arrays with a single element. # Example ```python def enhanced_exchange_sort(arr): # your code here # Example Usage sorted_arr, swap_count = enhanced_exchange_sort([3, 1, 4, 1, 5]) print(sorted_arr) # Output: [1, 1, 3, 4, 5] print(swap_count) # Output: 3 ``` # Notes - Implement an optimal check for detecting if the array is already sorted before initiating the sorting process to potentially save time. - Ensure that your implementation is in-place and does not use any extra space except for variables to hold counts and indices.","solution":"def enhanced_exchange_sort(arr): Sorts an array of integers using Exchange Sort and counts the number of swaps. Parameters: - arr: List of integers Returns: - sorted_arr: List of sorted integers - swap_count: Integer representing the number of swaps performed n = len(arr) sorted_arr = arr[:] # Make a copy to avoid modifying the original array swap_count = 0 if n <= 1: return sorted_arr, swap_count # Check if the array is already sorted already_sorted = True for i in range(n - 1): if sorted_arr[i] > sorted_arr[i + 1]: already_sorted = False break if already_sorted: return sorted_arr, swap_count # Perform Exchange Sort for i in range(n): for j in range(i + 1, n): if sorted_arr[i] > sorted_arr[j]: sorted_arr[i], sorted_arr[j] = sorted_arr[j], sorted_arr[i] swap_count += 1 return sorted_arr, swap_count # Example usage print(enhanced_exchange_sort([3, 1, 4, 1, 5]))"},{"question":"# Next Bigger Number with Same Digits Problem Statement You are provided with an integer. Your task is to find the next higher permutation of its digits. If the digits are already the highest permutation, return `-1`. For example, given `38276` you should return `38627`, and given `99999` return `-1` as there is no higher permutation. Implement the following function: ```python def next_bigger(num: int) -> int: pass ``` # Input * `num` - an integer, where `1 <= num <= 10**18`. # Output * Return the next higher permutation of `num`. If no such permutation exists, return `-1`. # Constraints * Your solution should run in linear time complexity `O(n)`, where `n` is the number of digits in the input number. * You should consider edge cases such as single-digit numbers, numbers where all digits are the same, and numbers already in descending order. # Example ```python assert next_bigger(38276) == 38627 assert next_bigger(12345) == 12354 assert next_bigger(99999) == -1 assert next_bigger(54321) == -1 assert next_bigger(1528452) == 1528524 ``` # Note: You may assume the input number is a non-negative integer and contains only digits from 0 to 9. Make sure your solution handles large numbers efficiently.","solution":"def next_bigger(num: int) -> int: num_list = list(str(num)) length = len(num_list) # Step 1: Find the first pair (num_list[i], num_list[i+1]) from end where num_list[i] < num_list[i+1] i = length - 2 while i >= 0 and num_list[i] >= num_list[i + 1]: i -= 1 if i == -1: # If no such pair exists, the digits are sorted in descending order return -1 # Step 2: Find the smallest digit on the right side of the (i\'th digit) which is greater than num_list[i] j = length - 1 while num_list[j] <= num_list[i]: j -= 1 # Step 3: Swap the digits found at index i and j num_list[i], num_list[j] = num_list[j], num_list[i] # Step 4: Reverse the sequence after the position i num_list = num_list[:i + 1] + num_list[i + 1:][::-1] next_bigger_num = int(\\"\\".join(num_list)) return next_bigger_num"},{"question":"**Scenario**: You\'re given a dataset represented as a singly linked list, where each node contains an integer. To proceed with further analysis, you need to ensure that the data is sorted in increasing order. Write a function to verify if the linked list is sorted. Function Signature ```python def is_sorted(head): pass ``` Input - The input is a reference `head` to the first node of a singly linked list. Each list node contains an integer `val` and a reference to the next node `next`. The list might be empty (i.e., `head` is `None`). Output - The function should return a boolean value: `True` if the list is sorted in increasing order, and `False` otherwise. Constraints - You may assume that the values in the list nodes are integers. - There are no additional constraints on the integer values (they can be negative or positive). - The list can have a maximum of (10^5) nodes. Example ```python # Example 1: # Input: # Empty list (head is None) # Output: # True # Example 2: # Input: # 1 -> 2 -> 3 -> 4 -> None # Output: # True # Example 3: # Input: # 1 -> 2 -> -1 -> 3 -> None # Output: # False ``` Explanation - In example 1, an empty list is considered sorted. - In example 2, the nodes are in increasing order (1, 2, 3, 4), so the function returns True. - In example 3, the list is not sorted because 2 is followed by -1, which is not in increasing order.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def is_sorted(head): Determine if a singly linked list is sorted in increasing order. :param head: ListNode, the head of the singly linked list :return: bool, True if the list is sorted in increasing order, False otherwise if head is None: return True current = head while current.next is not None: if current.val > current.next.val: return False current = current.next return True"},{"question":"# Question: Implement Additional Operations for Binary Search Tree Scenario You\'ve been provided a basic implementation of a Binary Search Tree (BST) in Python. The existing BST supports insertion, searching, size calculation, and tree traversals (preorder, inorder, and postorder). However, this implementation lacks support for a few essential operations. Your task is to extend the BST by implementing the following additional functionalities: 1. `delete(data)`: Delete a given node with the specified value from the BST. 2. `height()`: Calculate the height of the BST. 3. `is_balanced()`: Check if the BST is balanced. A balanced tree is defined as one where the height of two subtrees of any node never differ by more than one. Requirements - Maintain the BST properties after deletion. - Promptly calculate the height of the tree. - Efficiently check if the tree is balanced. - Ensure that your operations handle edge cases (like deletion in an empty tree or checking for height/balance of an empty tree). Constraints - Your solution must be efficient with a focus on clear and concise code. - You can assume all elements in the tree are unique integers. Input and Output Formats **delete(data)** - **Input**: An integer `data` representing the value to be removed from the tree. - **Output**: Should adjust the BST structure by removing the node with value `data`. **height()** - **Input**: No input. - **Output**: An integer representing the height of the BST. The height of an empty tree is defined as -1. **is_balanced()** - **Input**: No input. - **Output**: A boolean `True` if the tree is balanced, otherwise `False`. ```python class BST(object): # Your existing BST methods here... # Implement the following methods def delete(self, data): # Your code here... def height(self): # Your code here... def is_balanced(self): # Your code here... # The test cases class TestSuite(unittest.TestCase): def setUp(self): self.tree = BST() self.tree.insert(10) self.tree.insert(15) self.tree.insert(6) self.tree.insert(4) self.tree.insert(9) self.tree.insert(12) self.tree.insert(24) self.tree.insert(7) self.tree.insert(20) self.tree.insert(30) self.tree.insert(18) def test_delete(self): self.tree.delete(24) self.assertFalse(self.tree.search(24)) self.assertEqual(self.tree.size(), 10) def test_height(self): self.assertEqual(self.tree.height(), 4) def test_is_balanced(self): self.assertFalse(self.tree.is_balanced()) if __name__ == \\"__main__\\": unittest.main() ```","solution":"class TreeNode: def __init__(self, data): self.left = None self.right = None self.data = data class BST: def __init__(self): self.root = None def insert(self, data): if self.root is None: self.root = TreeNode(data) else: self._insert(data, self.root) def _insert(self, data, node): if data < node.data: if node.left is None: node.left = TreeNode(data) else: self._insert(data, node.left) else: if node.right is None: node.right = TreeNode(data) else: self._insert(data, node.right) def search(self, data): return self._search(data, self.root) def _search(self, data, node): if node is None: return False if data == node.data: return True elif data < node.data: return self._search(data, node.left) else: return self._search(data, node.right) def size(self): return self._size(self.root) def _size(self, node): if node is None: return 0 return 1 + self._size(node.left) + self._size(node.right) def delete(self, data): self.root = self._delete(self.root, data) def _delete(self, node, data): if node is None: return node if data < node.data: node.left = self._delete(node.left, data) elif data > node.data: node.right = self._delete(node.right, data) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self._min_value_node(node.right) node.data = temp.data node.right = self._delete(node.right, temp.data) return node def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def height(self): return self._height(self.root) def _height(self, node): if node is None: return -1 left_height = self._height(node.left) right_height = self._height(node.right) return max(left_height, right_height) + 1 def is_balanced(self): return self._is_balanced(self.root) def _is_balanced(self, node): if node is None: return True left_height = self._height(node.left) right_height = self._height(node.right) if abs(left_height - right_height) > 1: return False return self._is_balanced(node.left) and self._is_balanced(node.right)"},{"question":"# Question: Enhanced Insertion Sort with Negative Number Handling You have been given an array of integers that includes both positive and negative numbers. Your task is to modify the `insertion_sort` algorithm to handle negative numbers correctly and ensure that the array is sorted in descending order. Function Signature ```python def modified_insertion_sort(arr: List[int]) -> List[int]: pass ``` # Input * `arr`: A list of integers which may include both positive and negative numbers. * Constraints: ( -10^6 leq text{arr[i]} leq 10^6 ) * Length of the array: ( 0 leq text{len(arr)} leq 10^4 ) # Output * Returns a list of integers sorted in descending order. # Examples ```python assert modified_insertion_sort([4, -1, 7, 3, -5, 2]) == [7, 4, 3, 2, -1, -5] assert modified_insertion_sort([0, -10, 5, -3, 8]) == [8, 5, 0, -3, -10] assert modified_insertion_sort([]) == [] ``` # Constraints * You should ensure the algorithm performs efficiently within the given constraints. * Avoid using any built-in sorting functions. # Notes * Consider efficient handling of both positive and negative integers during insertion. * Make sure the sorting order is correct (descending) in the final output.","solution":"from typing import List def modified_insertion_sort(arr: List[int]) -> List[int]: Sorts the list `arr` in descending order using the insertion sort algorithm. for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key > arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr"},{"question":"# Challenging Combination Calculation Problem Statement: You are required to create a function that calculates the number of ways to choose `r` items from `n` items (denoted as `nCr`). Your implementation should efficiently handle large values of `n` and `r` by employing dynamic programming with memoization to store intermediate results. Implement the function `efficient_combination(n, r)` which calculates `nCr` using memoization. It should return the computed value. Ensure your solution is optimal and can handle the given constraints efficiently. Input: - `n` (integer): the total number of items, with 1 <= n <= 500 - `r` (integer): the number of items to choose, with 0 <= r <= n Output: - `integer`: the number of ways to choose `r` items from `n` items. Constraints: - Use memoization to optimize performance. - Ensure that your function runs efficiently within the given problem constraints. Example: ```python assert efficient_combination(5, 2) == 10 # 5C2 = 10 assert efficient_combination(6, 3) == 20 # 6C3 = 20 ``` Scenario/Context: In a field of study focusing on combinatorial mathematics, accurate and efficient calculation of combinations is crucial. The function you design here will be used in an application where performance and precision in large inputs are critical. ```python # Function to be implemented by the student def efficient_combination(n, r): # Your code here pass # Example usage and assertions for testing assert efficient_combination(5, 2) == 10 assert efficient_combination(6, 3) == 20 assert efficient_combination(10, 0) == 1 assert efficient_combination(10, 10) == 1 assert efficient_combination(10, 1) == 10 assert efficient_combination(10, 5) == 252 ```","solution":"def efficient_combination(n, r): Returns the number of ways to choose r items from n items using memoization. memo = {} def combination(n, r): if r == 0 or r == n: return 1 if (n, r) in memo: return memo[(n, r)] memo[(n, r)] = combination(n-1, r-1) + combination(n-1, r) return memo[(n, r)] return combination(n, r)"},{"question":"**Problem Statement: Implement a Modified KMP Algorithm for Multi-Pattern Matching** You are tasked with modifying the Knuth-Morris-Pratt (KMP) algorithm to handle multiple patterns within a given text. This requires preprocessing a list of patterns and then searching for any of these patterns in the text. # Instructions Write a function `multi_pattern_kmp` that takes two arguments: * `text` (a string): The text in which to search. * `patterns` (a list of strings): The list of patterns to search for within the text. The function should return a dictionary where each key is a pattern and the value is a list of start indices where the pattern is found in the text. # Function Signature ```python def multi_pattern_kmp(text: str, patterns: List[str]) -> Dict[str, List[int]]: ``` # Expected Behavior - If `patterns` is an empty list, return an empty dictionary. - If `text` is an empty string, the output should be an empty dictionary. - Each pattern should independently match across the entire text. # Example ```python # Given text and patterns text = \'testtexttext\' patterns = [\'test\', \'text\'] # The expected output: # \'test\' is found at index 0 # \'text\' is found at index 4 and index 8 # # Output: {\'test\': [0], \'text\': [4, 8]} print(multi_pattern_kmp(text, patterns)) # {\'test\': [0], \'text\': [4, 8]} ``` # Constraints - Length of `text` (N): 1 ≤ N ≤ 10^5 - Length of `patterns` list: 1 ≤ number of patterns ≤ 100 - Length of any individual pattern (M): 1 ≤ M ≤ 1000 # Notes 1. Optimize the function to handle the upper limits effectively. 2. Consider edge cases like empty patterns or text. 3. Take care of overlapping patterns and ensure they are counted multiple times if they appear at different indices.","solution":"from typing import List, Dict def compute_lps(pattern: str) -> List[int]: Compute the Longest Prefix Suffix (LPS) array for the KMP algorithm. lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps def kmp_search(text: str, pattern: str) -> List[int]: Perform KMP search for a single pattern in the text. lps = compute_lps(pattern) indices = [] i = 0 j = 0 while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): indices.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return indices def multi_pattern_kmp(text: str, patterns: List[str]) -> Dict[str, List[int]]: Search for multiple patterns in the text using the KMP algorithm. result = {} if not text or not patterns: return result for pattern in patterns: result[pattern] = kmp_search(text, pattern) return result"},{"question":"You are tasked with implementing a robust quick sort algorithm. This implementation must handle potential pitfalls of a basic quick-sort, such as poor pivot selection. Additionally, you are required to enhance the basic quick sort to better manage worst-case scenarios. # Function Specification: Implement the function `optimized_quick_sort(arr: List[int]) -> List[int]` that takes an unsorted array and returns the sorted array. Your solution should: 1. Implement a quick sort that dynamically chooses a good pivot to avoid worst-case scenarios. 2. Implement a hybrid approach combining quick sort and insertion sort to enhance performance on smaller subarrays. # Input: - A list `arr` of integers where 1 <= len(arr) <= 10^5. - Elements of `arr` are within the range of -10^9 to 10^9. # Output: - A list of integers sorted in ascending order. # Constraints: - You should aim to maintain average-case time complexity of O(n log(n)) and strive to prevent worst-case scenarios. - Space complexity should remain at O(log(n)). # Example: ```python arr = [3, 6, 8, 10, 1, 2, 1] print(optimized_quick_sort(arr)) # Output: [1, 1, 2, 3, 6, 8, 10] arr = [9, -2, 1, 0, -1, 5] print(optimized_quick_sort(arr)) # Output: [-2, -1, 0, 1, 5, 9] ```","solution":"from typing import List def insertion_sort(arr: List[int], low: int, high: int) -> None: for i in range(low + 1, high + 1): key = arr[i] j = i - 1 while j >= low and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def partition(arr: List[int], low: int, high: int) -> int: # Choosing the median of three as the pivot to avoid worst-case scenarios mid = (low + high) // 2 pivot_candidates = [arr[low], arr[mid], arr[high]] pivot_candidates.sort() pivot = pivot_candidates[1] # Swap pivot with the high element to use it in Lomuto\'s partition scheme pivot_index = arr.index(pivot) arr[pivot_index], arr[high] = arr[high], arr[pivot_index] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quick_sort(arr: List[int], low: int, high: int) -> None: if low < high: if (high - low) < 10: # Use insertion sort for small segments insertion_sort(arr, low, high) else: pi = partition(arr, low, high) quick_sort(arr, low, pi - 1) quick_sort(arr, pi + 1, high) def optimized_quick_sort(arr: List[int]) -> List[int]: This function sorts an array using the optimized quick sort algorithm with a hybrid approach. if len(arr) <= 1: return arr quick_sort(arr, 0, len(arr) - 1) return arr"},{"question":"# Coding Challenge: Reverse a String Using an Iterative Approach Context You have been asked to implement a function that reverses a given string. As part of a text processing module, string reversal is a fundamental operation that helps in various scenarios, such as checking for palindromes or implementing certain cipher algorithms. Problem Write a function that reverses a string using an iterative approach. Your function should not use any built-in functions that directly reverse the string (e.g., `reversed()`, slicing with `[::-1]`, etc.). Function Signature ```python def reverse_string(s: str) -> str: ``` Input * `s` (str): The input string to be reversed. Output * The function should return a new string which is the reverse of the input string. Example ```python input: \\"hello\\" output: \\"olleh\\" input: \\"Python\\" output: \\"nohtyP\\" ``` Constraints 1. Length of the string `0 <= len(s) <= 10^5`. 2. The input string `s` may contain any printable ASCII characters. Performance Requirements * The algorithm should have O(n) time complexity, where `n` is the length of the string. * The additional space used should be O(n). Edge Cases 1. Empty string should return an empty string. 2. Single character string should return the same character.","solution":"def reverse_string(s: str) -> str: Reverses the input string using an iterative approach. reversed_chars = [] for char in s: reversed_chars.insert(0, char) return \'\'.join(reversed_chars)"},{"question":"# Question: Implement and Validate RandomizedSet Scenario You are tasked with implementing a data structure named `RandomizedSet` that supports the following operations: - `insert(val)`: Inserts a value `val` to the set if it is not already present. - `remove(val)`: Removes a value `val` from the set if it is present. - `random_element()`: Returns a random element from the current set of elements. Each element must have the same probability of being returned. Your implementation should ensure that these operations are executed in O(1) average time complexity. Function Signature ```python class RandomizedSet: def __init__(self): pass def insert(self, val: int) -> None: pass def remove(self, val: int) -> None: pass def random_element(self) -> int: pass ``` Constraints - The operations will be called at most 10^5 times in total. - Values inserted will be between -10^9 and 10^9. - It is guaranteed that at least one call to `random_element` will be valid (i.e., the set is not empty at the time of calling `random_element`). Example Interactions ```python rset = RandomizedSet() print(rset.insert(1)) # Should output something like: None print(rset.remove(2)) # Should output something like: None print(rset.insert(2)) # Should output something like: None print(rset.random_element()) # Should output either 1 or 2 with equal probability print(rset.remove(1)) # Should output something like: None print(rset.insert(2)) # Should output something like: None print(rset.random_element()) # Should output 2 ``` Validation To validate your implementation, ensure: - Multiple inserts work correctly without inserting duplicates. - Random element retrieval is uniform. - Removal of elements works and does not affect the remaining elements adversely.","solution":"import random class RandomizedSet: def __init__(self): self.data_dict = {} self.data_list = [] def insert(self, val: int) -> bool: if val in self.data_dict: return False self.data_dict[val] = len(self.data_list) self.data_list.append(val) return True def remove(self, val: int) -> bool: if val not in self.data_dict: return False # Move the last element to the place of the element to delete last_element = self.data_list[-1] index = self.data_dict[val] self.data_list[index] = last_element self.data_dict[last_element] = index # Remove the last element self.data_list.pop() del self.data_dict[val] return True def random_element(self) -> int: return random.choice(self.data_list)"},{"question":"# Question Scenario: Imagine you\'re working on a software for managing a network of computers. The network supports a feature where multiple independent connections can form clusters, and you can know if two computers are directly or indirectly connected within the same cluster. You also perform dynamic operations where you frequently add new connections and need to count the number of distinct clusters formed after each new connection. # Task Implement a class and a function based on the `Union` data structure that manages clusters efficiently. # Requirements: - Implement a class `ClusterNetwork` using the `Union-Find` data structure. - Add methods to support the following operations: 1. `add_computer(computer_id: int)`: Adds a new computer to the network if it doesn\'t already exist. 2. `connect(computer_1: int, computer_2: int)`: Connects two computers, ensuring they are part of the same cluster. 3. `find_cluster_count() -> int`: Returns the current number of distinct clusters in the network. 4. `connected(computer_1: int, computer_2: int) -> bool`: Returns `True` if two computers are in the same cluster, otherwise `False`. # Input and Output - Assume all inputs are valid integers. # Constraints: - Performance: Aim for operations to be efficient with near-constant time complexity. # Example: ```python network = ClusterNetwork() network.add_computer(1) network.add_computer(2) network.add_computer(3) network.connect(1, 2) print(network.find_cluster_count()) # Output: 2 print(network.connected(1, 3)) # Output: False network.connect(2, 3) print(network.find_cluster_count()) # Output: 1 print(network.connected(1, 3)) # Output: True ``` # Implement the Solution: ```python class ClusterNetwork: def __init__(self): self.parents = {} self.size = {} self.count = 0 def add_computer(self, computer_id): if computer_id in self.parents: return self.parents[computer_id] = computer_id self.size[computer_id] = 1 self.count += 1 def root(self, computer_id): while computer_id != self.parents[computer_id]: self.parents[computer_id] = self.parents[self.parents[computer_id]] computer_id = self.parents[computer_id] return computer_id def connect(self, computer_1, computer_2): root1, root2 = self.root(computer_1), self.root(computer_2) if root1 == root2: return if self.size[root1] > self.size[root2]: root1, root2 = root2, root1 self.parents[root1] = root2 self.size[root2] += self.size[root1] self.count -= 1 def find_cluster_count(self): return self.count def connected(self, computer_1, computer_2): return self.root(computer_1) == self.root(computer_2) # Sample Usage network = ClusterNetwork() network.add_computer(1) network.add_computer(2) network.add_computer(3) network.connect(1, 2) print(network.find_cluster_count()) # Output: 2 print(network.connected(1, 3)) # Output: False network.connect(2, 3) print(network.find_cluster_count()) # Output: 1 print(network.connected(1, 3)) # Output: True ```","solution":"class ClusterNetwork: def __init__(self): self.parents = {} self.size = {} self.count = 0 def add_computer(self, computer_id): if computer_id in self.parents: return self.parents[computer_id] = computer_id self.size[computer_id] = 1 self.count += 1 def root(self, computer_id): while computer_id != self.parents[computer_id]: self.parents[computer_id] = self.parents[self.parents[computer_id]] computer_id = self.parents[computer_id] return computer_id def connect(self, computer_1, computer_2): root1, root2 = self.root(computer_1), self.root(computer_2) if root1 == root2: return if self.size[root1] > self.size[root2]: root1, root2 = root2, root1 self.parents[root1] = root2 self.size[root2] += self.size[root1] self.count -= 1 def find_cluster_count(self): return self.count def connected(self, computer_1, computer_2): return self.root(computer_1) == self.root(computer_2)"},{"question":"# Question: Find the nth Digit in an Infinite Integer Sequence Scenario: Write a function `find_nth_digit(n: int) -> int` that takes an integer `n` and returns the nth digit of an infinite concatenated sequence of positive integers: \\"123456789101112...\\". The sequence starts at 1 and infinitely concatenates the subsequent positive integers. Implementation Details: - **Inputs**: * `n`: (1 ≤ n ≤ 10^9). The position of the digit in the infinite sequence. - **Output**: * The nth digit in the sequence as an integer. Constraints: - The function must run in a time complexity of O(log n). - Memory usage should be constant, O(1). Example: ```python find_nth_digit(3) -> 3 find_nth_digit(11) -> 0 find_nth_digit(15) -> 2 find_nth_digit(1000000000) -> 1 ``` Performance Requirements: Ensure that your function can handle the upper constraint efficiently. Consider necessary optimizations and proper handling of edge cases described in the analysis.","solution":"def find_nth_digit(n: int) -> int: # Initialize length, count, and start to find the range length = 1 count = 9 start = 1 # Determine the range in which the nth digit lies while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Find the actual number where the nth digit is located start += (n - 1) // length s = str(start) # Determine the exact digit within the number digit = s[(n - 1) % length] return int(digit)"},{"question":"# Zigzag Iterator for Multiple Lists Context In many real-world applications, we might need to alternate output from multiple sources. Designing a zigzag iterator efficiently becomes crucial especially when the number of lists exceeds two. Prompt Write a Python class `ZigZagIteratorK` that takes in multiple lists (more than two) and iterates over them in a zigzag fashion, consuming elements alternately from each list until all elements are exhausted. Functional Requirements 1. **Constructor**: `__init__(self, vectors: List[List[int]])` * Initialize the iterator with a list of input lists. 2. **next(self) -> int** * Returns the next element in zigzag order. 3. **has_next(self) -> bool** * Returns `True` if there are any remaining elements in any of the lists, `False` otherwise. Example ```python l1 = [1, 2] l2 = [3, 4, 5, 6] l3 = [7, 8, 9] zigzag = ZigZagIteratorK([l1, l2, l3]) result = [] while zigzag.has_next(): result.append(zigzag.next()) print(result) # Output should be [1, 3, 7, 2, 4, 8, 5, 9, 6] ``` Constraints * Input lists can have different lengths. * Assume the input lists and elements within are non-empty integers. * The solution should maintain O(1) time complexity for `next()` and `has_next()` functions. * The overall space complexity of the solution should be O(n + m + p + ...), where n, m, p,... are the lengths of the input lists.","solution":"from collections import deque from typing import List class ZigZagIteratorK: def __init__(self, vectors: List[List[int]]): self.queue = deque() for vector in vectors: if vector: self.queue.append(deque(vector)) def next(self) -> int: if self.has_next(): current_list = self.queue.popleft() value = current_list.popleft() if current_list: self.queue.append(current_list) return value else: raise Exception(\\"No more elements\\") def has_next(self) -> bool: return len(self.queue) > 0"},{"question":"# Question: Advanced Polynomial Arithmetic As a new recruit in a symbolic computation software company, your first task is to complete the implementation of a polynomial class that can handle various polynomial operations. The provided code already supports a set of operations for single-term polynomials (monomials) and multi-term polynomials. However, one of the key operations, polynomial division, is not fully implemented. Objective: Implement the polynomial division operation for the `Polynomial` class. The division should support dividing one polynomial by another as long as the divisor is a monomial. The result should also be a polynomial or raise a suitable exception if the division cannot be performed. Instructions: 1. **Definition**: - Function Signature: `def divide(self, divisor: Union[int, float, Fraction, Monomial, Polynomial]) -> Polynomial:` 2. **Expected Input & Output**: - **Input**: - `self`: The polynomial instance. - `divisor`: The monomial or polynomial divisor. - **Output**: - A new `Polynomial` instance representing the quotient of the division. - Raises `ValueError` if division by zero is attempted or if division by a polynomial is not possible. 3. **Constraints**: - Only handle division where the divisor is a monomial. - If the divisor is an integer, float, or fraction, handle accordingly by treating it as a monomial with no variables. - You can assume inputs will not be malformed but should validate the proper operations for enhancing robustness. # Example: ```python p1 = Polynomial([Monomial({1: 2}, 4), Monomial({1: 1}, 2)]) # Represents 4a_1^2 + 2a_1 p2 = Monomial({1: 1}, 2) # Represents 2a_1 result = p1.divide(p2) print(result) # Should output a Polynomial equivalent to (2a_1 + 1) ``` Note: - Make sure to handle edge cases like division by zero. - Ensure the implementation conforms with the polynomial wrapper formats provided. Complete the `divide` function in the below given `Polynomial` class. ```python class Polynomial: # other methods ... def divide(self, divisor: Union[int, float, Fraction, Monomial, Polynomial]) -> Polynomial: # Your implementation here ```","solution":"from typing import Union from fractions import Fraction class Monomial: def __init__(self, exponents: dict, coefficient: Union[int, float, Fraction]): self.exponents = exponents # Dictionary of variable: exponent pairs self.coefficient = coefficient def __truediv__(self, other: Union[int, float, Fraction, \'Monomial\']): if isinstance(other, Monomial): new_exponents = self.exponents.copy() for var, exp in other.exponents.items(): if var in new_exponents: new_exponents[var] -= exp if new_exponents[var] == 0: del new_exponents[var] else: raise ValueError(\\"Cannot divide by monomial with a variable not in the numerator monomial\\") return Monomial(new_exponents, self.coefficient / other.coefficient) elif isinstance(other, (int, float, Fraction)): return Monomial(self.exponents, self.coefficient / other) else: raise ValueError(\\"Division by non-monomial polynomial is not supported\\") class Polynomial: def __init__(self, monomials: list): self.monomials = monomials # List of Monomial instances def __repr__(self): return \\" + \\".join([f\\"{monom.coefficient}*{\'*\'.join([f\'a_{var}^{exp}\' for var, exp in monom.exponents.items()])}\\" for monom in self.monomials]) def divide(self, divisor: Union[int, float, Fraction, Monomial, \'Polynomial\']) -> \'Polynomial\': if isinstance(divisor, Polynomial): if len(divisor.monomials) != 1: raise ValueError(\\"Can only divide by a monomial, not a polynomial with multiple terms\\") divisor = divisor.monomials[0] if isinstance(divisor, (int, float, Fraction)): divisor = Monomial({}, divisor) new_monomials = [] for monomial in self.monomials: new_monomials.append(monomial / divisor) return Polynomial(new_monomials)"},{"question":"Given two words `word1` and `word2`, write a function `min_distance_optimized(word1, word2)` to find the minimum number of steps required to make the two words the same by only deleting characters. **Function Signature**: ```python def min_distance_optimized(word1: str, word2: str) -> int: pass ``` **Input**: * `word1`: A string of length n. * `word2`: A string of length m. **Output**: * Returns an integer representing the minimum number of steps required to make the two words the same by deleting characters. **Constraints**: * The length of both words is between 1 and 1000. * `word1` and `word2` consist of lowercase English letters. **Scenario**: You are given the task to implement an efficient text comparison algorithm that will be integrated into a text editing application. The application requires a function to determine how many delete operations are needed to make two strings of text identical. Your solution should optimize for both time and space complexity. **Example**: ```python print(min_distance_optimized(\\"sea\\", \\"eat\\")) # Output: 2 ``` **Explanation**: In the above example: - One step is to delete \'s\' from \\"sea\\" to make it \\"ea\\". - Another step is to delete \'e\' from \\"eat\\" to make it \\"at\\" and another step to delete \'a\' to make it \\"t\\". Please ensure that your implementation is optimized specifically for high input sizes and meets the outlined performance requirements.","solution":"def min_distance_optimized(word1: str, word2: str) -> int: def lcs_length(word1, word2): n, m = len(word1), len(word2) dp = [[0] * (m + 1) for _ in range(n + 1)] # Fill the dp array for i in range(1, n + 1): for j in range(1, m + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m] lcs_len = lcs_length(word1, word2) return len(word1) + len(word2) - 2 * lcs_len"},{"question":"Objective: You are tasked with implementing an improved function to print a tree-like nested dictionary structure. The goal is to ensure that any tree structure can be displayed in a cleanly formatted manner, supporting a more generalized case where each sub-element might not strictly follow a string or integer type check. Function Signature: ```python def improved_tree_print(tree: dict) -> None: Prints the tree-like nested dictionary structure in a clean format. Parameters: - tree (dict): a dictionary where keys are strings and values are lists containing sub-elements that may contain strings, integers, or nested dictionaries. Returns: - None: this function prints the tree structure to the standard output. ``` Constraints: - The dictionary keys are always strings. - Values are lists containing mixed types including strings, integers, and dictionaries. - There are no cycles in the nested structure. Expected Input and Output: # Input: ```python tree = { \'a\': [\'Adam\', {\'Book\': 4}], \'b\': [\'Bill\', {\'Computer\': 5}, {\'TV\': 6}, \'Jill\', {\'Sports\': 1}], \'c\': [\'Bill\', {\'Sports\': 3}], \'d\': [\'Adam\', {\'Computer\': 3}, \'Quin\', {\'Computer\': 3}], \'e\': [\'Quin\', {\'Book\': 5}, {\'TV\': 2}], \'f\': [\'Adam\', {\'Computer\': 7}], } ``` # Output: ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 -> Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` Additional Notes: * Carefully handle nested dictionaries within the lists. * Ensure that the output formatting remains consistent, especially handling indentations for nested output. * Consider avoiding redundant dictionary key lookups within the inner loops.","solution":"def improved_tree_print(tree: dict) -> None: def print_list(elements, indent=\\"\\"): for elem in elements: if isinstance(elem, dict): for key, value in elem.items(): print(indent + \\" -> \\" + key, end=\\"\\") if isinstance(value, list): print() print_list(value, indent + \\" \\") else: print(\\" -> \\" + str(value)) else: print(indent + \\" -> \\" + str(elem)) for key, values in tree.items(): print(f\\"{key}\\", end=\\"\\") if isinstance(values, list): print() print_list(values, \\"\\") else: print(\\" -> \\" + str(values))"},{"question":"# Scenario A company holds a records list of student scores that needs to be verified for orderliness before being processed further. Your task is to implement a function to ensure the scores list is sorted in increasing order. # Function Implementation Implement the function `is_sorted(head)` that checks if a given singly linked list is sorted in increasing order. If the list is empty or contains only one element, it should return `True`. # Function Signature ```python def is_sorted(head): # your code here ``` # Input * `head` (Node): The head node of a singly linked list where each node contains an integer `val` and a reference to the next node. # Output * `bool`: `True` if the list is sorted in increasing order, `False` otherwise. # Constraints * The linked list can have up to 10^6 nodes. * Each node\'s value lies within the range of integer values in Python (typically -2^31 to 2^31-1). # Example ```python class Node: def __init__(self, val=0, next=None): self.val = val self.next = next # Example 1: # Input: 1 -> 2 -> 3 -> 4 # Output: True head1 = Node(1, Node(2, Node(3, Node(4)))) print(is_sorted(head1)) # True # Example 2: # Input: 1 -> 2 -> -1 -> 3 # Output: False head2 = Node(1, Node(2, Node(-1, Node(3)))) print(is_sorted(head2)) # False # Example 3: # Input: (empty list) # Output: True print(is_sorted(None)) # True ``` # Notes * Ensure that your function handles an edge case where the list might be empty. * You are provided with a class `Node` for constructing the linked list.","solution":"class Node: def __init__(self, val=0, next=None): Initialize a Node with a value and a reference to the next node. self.val = val self.next = next def is_sorted(head): Checks if the given singly linked list is sorted in increasing order. :param head: Node, the head node of a singly linked list :return: bool, True if the list is sorted, False otherwise # If the list is empty or has only one element, it is sorted if head is None or head.next is None: return True current = head while current.next is not None: if current.val > current.next.val: return False current = current.next return True"},{"question":"**Problem Statement:** You are given two strings `x` and `y` consisting only of lowercase letters. String `y` is generated by randomly shuffling string `x` and then adding one more letter at a random position. Your task is to find the letter that was added to `y`. **Function Signature:** ```python def find_added_letter(x: str, y: str) -> str: # implementation here ``` **Input:** - `x` (String): A string of lowercase letters. (1 <= len(x) <= 10^5) - `y` (String): A string of lowercase letters, which is the same as `x` but with one additional letter. Thus, len(y) = len(x) + 1. **Output:** - Return the single additional letter (a single character string). **Constraints:** - Each character in the string is a lowercase English letter. - String `y` is `x` with one extra randomly added letter. **Example:** ```python assert find_added_letter(\\"abcd\\", \\"abecd\\") == \'e\' assert find_added_letter(\\"xyz\\", \\"yxzz\\") == \'z\' ``` **Explanation:** The problem leverages the properties of the XOR operation to identify the added character in linear time and constant space. Your solution should handle strings efficiently, ensuring correct identification of the added letter under all valid scenarios.","solution":"def find_added_letter(x: str, y: str) -> str: Finds the single additional letter in y which was not present in x. result = 0 for char in x + y: result ^= ord(char) return chr(result)"},{"question":"You have been given the task of improving the RSA key generation function to enhance its efficiency by incorporating probabilistic primality tests and optimizing the modular inverse calculation. Additionally, you should extend the RSA encryption scheme by implementing a signature verification mechanism. Requirements: 1. **Generate Efficient Key Pair**: Enhance the given RSA `generate_key` functionality using the Miller-Rabin primality test to improve prime number generation efficiency. 2. **Signature Implementation**: - Implement a `sign` function that uses the private key to generate a signature for a given data. - Implement a `verify` function that uses the public key to verify the signature against the original data. Function Definitions: - `generate_key(k, seed=None):` - Input: Integer `k` (bit length of modulus `n`), `seed` for random number generation (default None). - Output: Tuple `(n, e, d)` where n is the modulus, e is the public exponent, and d is the private exponent. - `sign(data, d, n):` - Input: Integer `data` to be signed, private exponent `d`, and modulus `n`. - Output: Integer representing the signature. - `verify(data, signature, e, n):` - Input: Integer `data`, signature integer `signature`, public exponent `e`, and modulus `n`. - Output: Boolean indicating whether the signature is valid. Input and Output Formats: - Assume all inputs are integers. - `data`, `d`, `e`, `n`, `signature` within acceptable RSA bit lengths defined by `k`. Constraints: - `k` should be at least 8 bits but usually much larger (e.g., 256 bits). - The `data` to be signed/encrypted must be smaller than the modulus `n`. # Example Usage ```python # Key generation with 16 bits key size n, e, d = generate_key(16) # Data to encrypt data = 12345 # Generate signature signature = sign(data, d, n) # Verify signature assert verify(data, signature, e, n) == True ``` Ensure to validate your implementation with other custom test cases as well.","solution":"import random from sympy import isprime, mod_inverse def miller_rabin(n, k=40): Test if n is a prime number using the Miller-Rabin primality test if n == 2 or n == 3: return True if n <= 1 or n % 2 == 0: return False r, s = 0, n - 1 while s % 2 == 0: r += 1 s //= 2 for _ in range(k): a = random.randrange(2, n - 1) x = pow(a, s, n) if x != 1 and x != n - 1: for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: break else: return False return True def generate_large_prime(bit_length): Generate a prime number of specified bit length while True: candidate = random.getrandbits(bit_length) # Ensure the candidate is odd and not too small candidate |= (1 << (bit_length - 1)) | 1 if miller_rabin(candidate): return candidate def generate_key(k, seed=None): Generate RSA key pair (n, e, d) with modulus bit length k if seed is not None: random.seed(seed) e = 65537 # Common choice for public exponent p = generate_large_prime(k // 2) q = generate_large_prime(k // 2) n = p * q phi = (p - 1) * (q - 1) d = mod_inverse(e, phi) return (n, e, d) def sign(data, d, n): Generate a signature for the given data using private key (d, n) return pow(data, d, n) def verify(data, signature, e, n): Verify the signature of the given data using public key (e, n) return pow(signature, e, n) == data"},{"question":"Word Search Data Structure **Objective**: Design a data structure that supports adding words and searching for words, including support for \'.\' wildcards where \'.\' can represent any letter. **Function Signature**: ```python class WordDictionary: def __init__(self): # Initialize your data structure here. def add_word(self, word: str) -> None: # Adds a word into the data structure. def search(self, word: str) -> bool: # Returns true if the word is in the trie, considering \\".\\" as any letter. ``` **Input and Output Formats**: * `add_word(word: str)` will add the word to the data structure. The word is a non-empty string containing only lowercase English letters. * `search(word: str)` will return a boolean indicating whether the word is present in the data structure. The word can contain \'.\' characters, where \'.\' can be treated as any letter. **Constraints**: * Words added to the data structure will be non-empty and have a length of at most 100. * Only lowercase English letters will be used. * Total number of words added will be at most 10^4. **Performance Requirements**: * Your implementation should efficiently add and search words, even when considering the wildcards. **Example Scenarios**: ```python # Example Usage: wordDictionary = WordDictionary() wordDictionary.add_word(\\"bad\\") wordDictionary.add_word(\\"dad\\") wordDictionary.add_word(\\"mad\\") assert wordDictionary.search(\\"pad\\") == False assert wordDictionary.search(\\"bad\\") == True assert wordDictionary.search(\\".ad\\") == True assert wordDictionary.search(\\"b..\\") == True ``` Your task is to implement the `WordDictionary` class fully.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: def dfs(j, node): for i in range(j, len(word)): char = word[i] if char == \'.\': for child in node.children.values(): if dfs(i + 1, child): return True return False else: if char not in node.children: return False node = node.children[char] return node.is_end_of_word return dfs(0, self.root)"},{"question":"# Right-Angled Triangle Side Calculation You are tasked with implementing a function that calculates the length of one side of a right-angled triangle when the lengths of the other two sides are given. Your function should handle cases with both integer and floating-point lengths and must be robust to invalid inputs. Function Signature ```python def calculate_side(opposite, adjacent, hypotenuse): Given the lengths of two sides of a right-angled triangle, returns the length of the third side. If one of the sides\' lengths is unknown, it is represented by None. :param opposite: (float) length of the side opposite the right angle, or None if unknown. :param adjacent: (float) length of the side adjacent to the right angle, or None if unknown. :param hypotenuse: (float) length of the hypotenuse side, or None if unknown. :return: the length of the unknown side (float). raises ValueError if: - more than one side is None - the supplied lengths do not form a valid right-angled triangle pass ``` # Constraints - Only one of the parameters will be `None` at a time, indicating the side that needs to be calculated. - Assert that: * The lengths of the known sides must be non-negative numbers. * The triangle inequality must hold for valid triangles. - The calculated side length should be a floating-point number rounded to two decimal places (if required). # Examples - `calculate_side(3, 4, None)` should return `5.0` (length of the hypotenuse). - `calculate_side(None, 3, 5)` should return `4.0` (length of the opposite side). - `calculate_side(1.5, None, 2.5)` should return approximately `2.12` (length of the adjacent side). # Implementation Consider edge cases, including invalid inputs, and ensure to handle errors gracefully by raising appropriate exceptions.","solution":"import math def calculate_side(opposite, adjacent, hypotenuse): Given the lengths of two sides of a right-angled triangle, returns the length of the third side. If one of the sides\' lengths is unknown, it is represented by None. :param opposite: (float or int) length of the side opposite the right angle, or None if unknown. :param adjacent: (float or int) length of the side adjacent to the right angle, or None if unknown. :param hypotenuse: (float or int) length of the hypotenuse side, or None if unknown. :return: the length of the unknown side (float). Raises ValueError if: - more than one side is None - the supplied lengths do not form a valid right-angled triangle sides = [opposite, adjacent, hypotenuse] if sides.count(None) != 1: raise ValueError(\\"Exactly one side must be None.\\") if opposite is None: if hypotenuse <= adjacent: raise ValueError(\\"Hypotenuse must be greater than adjacent side.\\") result = math.sqrt(hypotenuse**2 - adjacent**2) elif adjacent is None: if hypotenuse <= opposite: raise ValueError(\\"Hypotenuse must be greater than opposite side.\\") result = math.sqrt(hypotenuse**2 - opposite**2) elif hypotenuse is None: result = math.sqrt(opposite**2 + adjacent**2) else: raise ValueError(\\"Invalid input: All sides are provided, one should be None\\") return round(result, 2)"},{"question":"Problem Description Implement a function `iterative_binomial_coefficient(n, k)` that computes the binomial coefficient ( C(n, k) ) using an iterative approach. This function should avoid recursion and optimize computation using dynamic programming principles. # Function Signature ```python def iterative_binomial_coefficient(n: int, k: int) -> int: ``` # Input - `n` (0 <= n <= 1000): A non-negative integer. - `k` (0 <= k <= n): A non-negative integer satisfying ( k leq n ). # Output - Returns an integer representing the binomial coefficient ( C(n, k) ). # Constraints - Use an iterative approach to avoid recursion depth issues. - Ensure efficient computation using dynamic programming. # Example ```python assert iterative_binomial_coefficient(5, 0) == 1 assert iterative_binomial_coefficient(8, 2) == 28 assert iterative_binomial_coefficient(500, 300) == 5054949849935535817667719165973249533761635252733275327088189563256013971725761702359997954491403585396607971745777019273390505201262259748208640 ``` # Notes - The relation ( C(n, k) = C(n-1, k-1) + C(n-1, k) ) can be used iteratively to build up the solution. - Use a table to store intermediate results to optimize the computation.","solution":"def iterative_binomial_coefficient(n: int, k: int) -> int: Computes binomial coefficient C(n, k) using an iterative approach. :param n: Integer, where 0 <= n <= 1000. :param k: Integer, where 0 <= k <= n. :return: Binomial coefficient calculated as C(n, k). # Base case: C(n, 0) == 1 and C(n, n) == 1 for all n if k == 0 or k == n: return 1 # To optimize space, we only need a 1D array of size k+1 C = [0] * (k + 1) C[0] = 1 # C(n, 0) is always 1 # Calculate value of binomial coefficient in bottom-up manner for i in range(1, n + 1): # Compute values in reverse to use previous row values for j in range(min(i, k), 0, -1): C[j] = C[j] + C[j - 1] return C[k]"},{"question":"# Scenario You are helping a thief in planning their next heist! The thief is targeting a mansion and wants to maximize the value of items they can carry without exceeding their carrying capacity. # Task Write a function `maximizeHeistValue` that determines the maximum value the thief can carry given the items and their values and weights. # Function Signature ```python def maximizeHeistValue(items: List[Tuple[int, int]], capacity: int) -> int: ``` # Input * `items`: A list of tuples where each tuple represents an item with (value, weight). * `capacity`: An integer representing the maximum weight the thief can carry. # Output * Returns an integer representing the maximum value the thief can carry. # Constraints * 1 ≤ len(items) ≤ 1000 * 1 ≤ capacity ≤ 10^4 * 0 ≤ value, weight ≤ 1000 for any item # Examples ```python assert maximizeHeistValue([(60, 5), (50, 3), (70, 4), (30, 2)], 5) == 80 assert maximizeHeistValue([(10, 1), (20, 2), (30, 3)], 6) == 60 assert maximizeHeistValue([(100, 5), (90, 4), (50, 2), (60, 3)], 8) == 160 assert maximizeHeistValue([(50, 10), (55, 10), (60, 10)], 10) == 60 assert maximizeHeistValue([(50, 10), (55, 10), (60, 7)], 10) == 60 ``` # Performance Requirements * Your solution should run efficiently within the given constraints, specifically with time complexity of O(n * m) where n is the number of items and m is the capacity. # Edge Cases * If the capacity is zero, the function should return 0. * If all items have zero value, the function should return 0 regardless of their weights. * If all items are heavier than the capacity, the function should return 0.","solution":"from typing import List, Tuple def maximizeHeistValue(items: List[Tuple[int, int]], capacity: int) -> int: Determines the maximum value the thief can carry given the items and their values and weights. Uses dynamic programming approach to solve the Knapsack problem. n = len(items) dp = [0] * (capacity + 1) for value, weight in items: for w in range(capacity, weight - 1, -1): dp[w] = max(dp[w], dp[w - weight] + value) return dp[capacity]"},{"question":"# String Bracketing with Symbols Problem Statement You are given an array of words and an array of symbols. You need to substitute the first matching symbol found in each word with itself surrounded by square brackets []. If a word string matches multiple symbols, you must use the symbol with the longest length. If no symbols match the word, the word should remain unchanged. Write a function `highlight_symbols` that takes in: - `words`: A list of strings representing the words. - `symbols`: A list of strings representing the symbols. Your function should return a list of words where each word has its appropriate symbol replaced by the same symbol bracketed by []. Input - `words`: List[str] - List of words (`1 <= len(words) <= 1000` and `1 <= len(words[i]) <= 100`). - `symbols`: List[str] - List of symbols (`1 <= len(symbols) <= 1000` and `1 <= len(symbols[i]) <= 100`). Output - `List[str]`: A list of strings with each word containing its appropriate symbols bracketed. Example ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] print(highlight_symbols(words, symbols)) # Output: [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` Constraints - Ensure to substitute the longest possible matching symbol. - The solution must be efficient and should handle the provided constraints gracefully. Implementation Notes You can consider using a Trie data structure to organize the symbols for efficient matching. Ensure that your function handles edge cases effectively, such as when no symbols match a word.","solution":"def highlight_symbols(words, symbols): def find_best_symbol(word, symbols): best_symbol = None for symbol in symbols: if symbol in word: if best_symbol is None or len(symbol) > len(best_symbol): best_symbol = symbol return best_symbol result = [] for word in words: best_symbol = find_best_symbol(word, symbols) if best_symbol: word = word.replace(best_symbol, f\'[{best_symbol}]\', 1) result.append(word) return result"},{"question":"# Question: You are given a singly linked list where each node contains a single character. Your task is to implement an algorithm to remove all duplicate characters from the linked list in an efficient manner. You are required to implement a function `remove_duplicates` which achieves this using O(N) time complexity and O(N) space complexity. # Input: A head node `head` of the linked list. # Output: A linked list with all duplicate characters removed. # Assumptions: 1. The linked list is singly linked. 2. The input linked list can have up to 10^5 nodes. 3. The characters are case-sensitive. # Constraints: - The given implementation must run in O(N) time and use O(N) space. # Example: Example 1: ```plaintext Input: A -> A -> B -> C -> D -> C -> F -> G Output: A -> B -> C -> D -> F -> G ``` Example 2: ```plaintext Input: H -> I -> J -> I -> K -> L -> J -> M Output: H -> I -> J -> K -> L -> M ``` # Definition of Node: ```python class Node(): def __init__(self, val=None): self.val = val self.next = None ``` # Function Signature: ```python def remove_duplicates(head: Node) -> Node: # Your code here ``` # Notes: - Implement the method `remove_duplicates` in the provided function signature. - Use provided `Node` class for linked list nodes.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_duplicates(head: Node) -> Node: if not head: return None current = head seen = set() seen.add(current.val) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next return head"},{"question":"You are a software engineer working on a signal processing application. Your task is to implement the Cooley-Tukey Fast Fourier Transform (FFT) algorithm in an iterative manner, which avoids the overhead associated with recursive calls. Given an array of complex numbers where the length of the array is an integer power of 2, your goal is to translate the provided recursive FFT implementation into an efficient iterative version. # Function Signature ```python def fft_iterative(x): Perform an iterative Cooley-Tukey FFT. Args: x: List[complex], an array of N complex numbers where N is a power of 2 Returns: List[complex], the DFT of the input array pass ``` # Input Format - The function will take one argument, `x`, which is a list of complex numbers having length N, where N is a power of 2 (1 ≤ N ≤ 2^12). # Output Format - The function should return a list of complex numbers which represents the discrete Fourier transform of the input list. # Constraints - The input list `x` will always have a length that is an integer power of 2. - The elements of `x` will be complex numbers with real and imaginary parts in the range [-1000, 1000]. # Example ```python x = [2.0+2j, 1.0+3j, 3.0+1j, 2.0+2j] print(fft_iterative(x)) # Output: [(8+8j), 2j, (2-2j), (-2+0j)] ``` # Performance Requirements - The solution should run in O(N log N) time complexity. - The solution should use O(N) additional space. # Notes - Make sure to handle the twiddle factors accurately. - Ensure that the result matches the output produced by the provided recursive FFT function.","solution":"import cmath def fft_iterative(x): Perform an iterative Cooley-Tukey FFT. Args: x: List[complex], an array of N complex numbers where N is a power of 2 Returns: List[complex], the DFT of the input array N = len(x) if N <= 1: return x # Bit-reversal permutation indices = list(range(N)) j = 0 for i in range(1, N): bit = N >> 1 while j >= bit: j -= bit bit >>= 1 j += bit if i < j: indices[i], indices[j] = indices[j], indices[i] x = [x[i] for i in indices] # Iterative FFT m = 1 while m < N: step = m * 2 theta = -2j * cmath.pi / step w_m = cmath.exp(theta) for k in range(0, N, step): w = 1.0 for j in range(m): t = w * x[k + j + m] u = x[k + j] x[k + j] = u + t x[k + j + m] = u - t w *= w_m m = step return x"},{"question":"# Question 1: Two Sum Problem You\'re given an array of integers and a target integer. Your task is to write a function `find_pair_with_sum` that finds two distinct indices in the array such that the values at those indices sum up to the target value. # Requirements: - The function must return a tuple of two indices. The first index should be less than the second to maintain order. - Each input will have exactly one solution. - You may not use the same element twice. - If no such indices exist, the function should return `None`. # Function Signature: ```python def find_pair_with_sum(nums: List[int], target: int) -> Optional[Tuple[int, int]]: pass ``` # Input: - `nums`: List of integers (0 ≤ len(nums) ≤ 10^5) - `target`: Integer # Output: - A tuple `(i, j)` where `i < j` and `nums[i] + nums[j] == target` - `None` if no such indices are found. # Constraints: - Only one valid pair exists. - Index `i` must be less than index `j`. # Examples: ```python >>> find_pair_with_sum([2, 7, 11, 15], 9) (0, 1) >>> find_pair_with_sum([3, 2, 4], 6) (1, 2) >>> find_pair_with_sum([1, 2, 3], 6) None ``` # Notes: - Be mindful of edge cases where the array has fewer than two elements. - Consider cases with negative numbers and zeros. # Hints: - Think about utilizing a hash map to store potential complement values as you iterate through the array.","solution":"from typing import List, Tuple, Optional def find_pair_with_sum(nums: List[int], target: int) -> Optional[Tuple[int, int]]: Finds two distinct indices in the array such that the values at those indices sum up to the target value. Args: nums (List[int]): A list of integers. target (int): The target sum. Returns: Optional[Tuple[int, int]]: A tuple of indices (i, j) where nums[i] + nums[j] == target and i < j, None if no such indices are found. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], index) num_to_index[num] = index return None"},{"question":"# Context You are tasked with simulating random states in a weather prediction model, where the weather transitions between \'Sunny\', \'Cloudy\', and \'Rainy\' following a Markov Chain model. # Task Implement a Markov Chain simulation that predicts the weather state for a given number of days based on an initial state and a transition matrix. # Function Signature ```python def simulate_weather(chain: dict, initial_state: str, days: int) -> list: \'\'\' Simulate weather using a Markov Chain model. Parameters: chain (dict): A dictionary representing the Markov Chain transitions. initial_state (str): The initial weather state. days (int): Number of days to simulate. Returns: list: A list of weather states over the given number of days. \'\'\' pass ``` # Input * `chain`: A dictionary where each key is a weather state, and the value is another dictionary representing possible transitions and their probabilities. * `initial_state`: A string representing the initial weather state (\'Sunny\', \'Cloudy\', or \'Rainy\'). * `days`: An integer representing the number of days to simulate. # Output * Return a list of strings, where each string is a weather state predicted for each day. # Constraints * The sum of probabilities for a given state must equal 1. * There must be at least one valid state transition for each state. * The number of days (`days`) is a positive integer. # Example ```python transition_chain = { \'Sunny\': {\'Sunny\': 0.6, \'Cloudy\': 0.3, \'Rainy\': 0.1}, \'Cloudy\': {\'Sunny\': 0.2, \'Cloudy\': 0.5, \'Rainy\': 0.3}, \'Rainy\': {\'Sunny\': 0.1, \'Cloudy\': 0.4, \'Rainy\': 0.5} } initial_state = \'Sunny\' days = 5 simulate_weather(transition_chain, initial_state, days) ``` Expected output will be a list of weather states for 5 days, such as: ``` [\'Sunny\', \'Cloudy\', \'Cloudy\', \'Rainy\', \'Sunny\'] ``` # Requirements * Ensure the solution handles edge cases such as invalid probabilities and missing states. * The function should be efficient and handle up to 10^5 days.","solution":"import random def simulate_weather(chain, initial_state, days): Simulate weather using a Markov Chain model. Parameters: chain (dict): A dictionary representing the Markov Chain transitions. initial_state (str): The initial weather state. days (int): Number of days to simulate. Returns: list: A list of weather states over the given number of days. result = [initial_state] current_state = initial_state for _ in range(days - 1): next_state = random.choices( population=list(chain[current_state].keys()), weights=list(chain[current_state].values()) )[0] result.append(next_state) current_state = next_state return result"},{"question":"Scenario You are working as a software developer, and one of your clients is using a binary search tree (BST) to store and manage data entries. To enable data retrieval in a sorted order, you need to implement an in-order traversal algorithm. Task Write two functions to perform in-order traversal of a binary tree: 1. `inorder_iter(root: Node) -> List[int]`: An iterative approach. 2. `inorder_rec(root: Node) -> List[int]`: A recursive approach. Input * `root`: Root node of a binary tree. The tree node is defined as follows: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ``` Output * Both functions should return a list of integers representing the node values in in-order traversal order. Constraints * The number of nodes in the tree is in the range `[0, 10^4]`. * Each node\'s value is an integer within the range of `[-10^9, 10^9]`. # Example ```python # Build the following tree # 100 # / # 50 150 # / / # 25 75 125 175 n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 print(inorder_iter(n1)) # Output: [25, 50, 75, 100, 125, 150, 175] print(inorder_rec(n1)) # Output: [25, 50, 75, 100, 125, 150, 175] ``` # Notes * Ensure your functions can handle edge cases such as an empty tree or a single-node tree. * Optimize for time and space efficiency given the constraints.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def inorder_iter(root: Node) -> list: Perform in-order traversal iteratively. stack, result = [], [] current = root while stack or current: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result def inorder_rec(root: Node) -> list: Perform in-order traversal recursively. def helper(node: Node, result: list): if not node: return helper(node.left, result) result.append(node.val) helper(node.right, result) result = [] helper(root, result) return result"},{"question":"**Scenario**: You are working for a company that processes and validates sequences of customer actions. These sequences must conform to specific patterns defined by a deterministic model. Given a deterministic finite automaton (DFA) represented by its transition table, a start state, and a set of final states, you need to check if a sequence of actions (represented as a string) is accepted by the DFA. **Objective**: Create a function `is_accepted_by_dfa(transitions, start, final, string)` that determines whether the given action sequence (string) is accepted by the DFA. **Function Signature**: ```python def is_accepted_by_dfa(transitions: dict, start: str, final: list, string: str) -> bool: ``` **Inputs**: 1. `transitions`: A dictionary where keys are states (represented as strings) and values are dictionaries. The inner dictionaries map input symbols (characters) to resulting states. 2. `start`: A string representing the initial state of the DFA. 3. `final`: A list of strings representing the final (accepting) states of the DFA. 4. `string`: A string representing the sequence of actions to be validated. **Output**: - Return a boolean value: `True` if the sequence is accepted by the DFA, `False` otherwise. **Constraints**: 1. The state names and input symbols are ASCII strings. 2. Transitions dictionary and final states list are properly defined. 3. The DFA may have states missing some transitions (in which case the sequence should be rejected immediately). **Example**: ```python transitions = { \\"q0\\": {\\"a\\": \\"q1\\", \\"b\\": \\"q0\\"}, \\"q1\\": {\\"a\\": \\"q1\\", \\"b\\": \\"q2\\"}, \\"q2\\": {\\"a\\": \\"q1\\", \\"b\\": \\"q0\\"} } start = \\"q0\\" final = [\\"q2\\"] string = \\"ab\\" # Calling is_accepted_by_dfa with the above inputs should return True print(is_accepted_by_dfa(transitions, start, final, string)) # Output: True ``` **Explanation**: The DFA starts in state \\"q0\\", reads \'a\', transitions to \\"q1\\", reads \'b\', and transitions to \\"q2\\", which is a final state. Thus, the string \\"ab\\" is accepted by the DFA.","solution":"def is_accepted_by_dfa(transitions: dict, start: str, final: list, string: str) -> bool: Determines if the given action sequence is accepted by the DFA. Args: transitions (dict): The transition table of the DFA. start (str): The start state of the DFA. final (list): The list of final states of the DFA. string (str): The sequence of actions to be validated. Returns: bool: True if the sequence is accepted by the DFA, False otherwise. current_state = start for char in string: if char in transitions.get(current_state, {}): current_state = transitions[current_state][char] else: return False return current_state in final"},{"question":"Scenario You have been provided with a binary tree structure for storing a list of values in a hierarchical manner. Your task is to write a function that transforms this binary tree into a doubly linked list following its in-order traversal. The resulting doubly linked list should maintain references to its previous and next nodes. Task Write a function `binary_tree_to_linked_list(root: TreeNode) -> TreeNode`. This function should take the root of a binary tree as input and return the head of the doubly linked list. The function should satisfy the following conditions: 1. The doubly linked list should be in in-order traversal order. 2. You must perform the transformation in place, without creating new nodes. 3. Consider edge cases such as an empty binary tree or a tree with only one node. Your solution should also include a function `print_doubly_linked_list(head: TreeNode)` that prints out the values of the doubly linked list. Function Signature ```python def binary_tree_to_linked_list(root: TreeNode) -> TreeNode: pass def print_doubly_linked_list(head: TreeNode) -> None: pass ``` Input - The input `root` is a `TreeNode` instance representing the root of the binary tree. Output - The output is the head of the doubly linked list. Example Given the binary tree: ``` 10 / 6 14 / / 5 8 11 18 ``` The output doubly linked list should be: ``` 5 <-> 6 <-> 8 <-> 10 <-> 11 <-> 14 <-> 18 ``` Constraints * `root` is a `TreeNode` instance or `None`. * The binary tree does not always have to be balanced. Performance Ensure that your solution works efficiently within the constraints mentioned and optimally handles large trees.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right self.prev = None # For doubly linked list conversion self.next = None # For doubly linked list conversion def binary_tree_to_linked_list(root: TreeNode) -> TreeNode: if not root: return None def inorder_traversal(node): nonlocal last, head if node: inorder_traversal(node.left) if last: last.next = node node.prev = last else: head = node last = node inorder_traversal(node.right) last, head = None, None inorder_traversal(root) return head def print_doubly_linked_list(head: TreeNode) -> None: node = head while node: print(node.val, end=\\" <-> \\" if node.next else \\"\\") node = node.next print()"},{"question":"You are given a pattern and a string. Your task is to determine if the string follows the given pattern. Following a pattern means there is a bijection between characters in the pattern and non-empty substrings in the string. Write a function `pattern_match(pattern, string)` that returns `True` if the string follows the pattern, otherwise `False`. You may assume both the pattern and the string contain only lowercase letters. Input * `pattern` (str): The pattern to follow. Constraints: 1 <= len(pattern) <= 20. * `string` (str): The string to be checked against the pattern. Constraints: 1 <= len(string) <= 1000. Output * `bool`: Return True if the string follows the pattern, otherwise False. Example 1. `pattern_match(\\"abab\\", \\"redblueredblue\\")` should return `True` 2. `pattern_match(\\"aaaa\\", \\"asdasdasdasd\\")` should return `True` 3. `pattern_match(\\"aabb\\", \\"xyzabcxzyabc\\")` should return `False` Constraints * Each character in the pattern must map to a non-empty substring in the string. * Different characters in the pattern must map to different substrings. * Two characters in the pattern cannot map to the same substring. Considerations and Edge Cases * The pattern or string being empty should be considered invalid, and you may assume neither is empty. * If pattern length is greater than the string length, return False. * Handle cases where multiple recursive calls occur due to multiple potential substring mappings. Provide a Python function `pattern_match` that implements the described functionality using backtracking to explore all possible bijective mappings and ensures performance and correctness.","solution":"def pattern_match(pattern, string): def backtrack(p_idx, s_idx, p_map, s_map): if p_idx == len(pattern) and s_idx == len(string): return True if p_idx == len(pattern) or s_idx == len(string): return False pattern_char = pattern[p_idx] if pattern_char in p_map: substring = p_map[pattern_char] if string.startswith(substring, s_idx): return backtrack(p_idx + 1, s_idx + len(substring), p_map, s_map) else: return False else: for end in range(s_idx + 1, len(string) + 1): substring = string[s_idx:end] if substring in s_map: continue p_map[pattern_char] = substring s_map[substring] = pattern_char if backtrack(p_idx + 1, s_idx + len(substring), p_map, s_map): return True p_map.pop(pattern_char) s_map.pop(substring) return False return backtrack(0, 0, {}, {}) # Examples #print(pattern_match(\\"abab\\", \\"redblueredblue\\")) # Should return True #print(pattern_match(\\"aaaa\\", \\"asdasdasdasd\\")) # Should return True #print(pattern_match(\\"aabb\\", \\"xyzabcxzyabc\\")) # Should return False"},{"question":"# Trie Implementation and Query Integration Context You have been hired by a tech company to implement a Trie (prefix tree) to power their auto-complete feature. As part of the feature, users can insert words into the Trie, search for exact words, and check whether any words start with a given prefix. Your task is to implement and integrate this Trie data structure, taking into careful consideration its efficiency and correctness. Challenge Write a class `TrieWithDeletion` that extends the given Trie implementation by adding the ability to delete words. The class should include the following methods: 1. **insert(word)**: Inserts a word into the Trie. 2. **search(word)**: Returns true if the word is in the Trie. 3. **starts_with(prefix)**: Returns true if there is any word in the Trie that starts with the given prefix. 4. **delete(word)**: Removes a word from the Trie, but only if it exists. # Function Implementations Class Definition ``` class TrieWithDeletion: def __init__(self): pass def insert(self, word): pass def search(self, word): pass def starts_with(self, prefix): pass def delete(self, word): pass ``` # Method Descriptions 1. **insert(word: str)**: Insert a string into the Trie. - *Input*: A string `word` composed of lowercase letters. - *Output*: None 2. **search(word: str) -> bool**: Search for a string in the Trie. - *Input*: A string `word` composed of lowercase letters. - *Output*: Returns `True` if the string exists in the Trie, otherwise returns `False`. 3. **starts_with(prefix: str) -> bool**: Check if there exists any word that starts with the given prefix. - *Input*: A string `prefix` composed of lowercase letters. - *Output*: Returns `True` if there\'s any word in the Trie that starts with the given prefix. 4. **delete(word: str)**: Remove the word from the Trie if it exists. - *Input*: A string `word` composed of lowercase letters. - *Output*: None. The function will delete the word if it exists in the Trie. # Constraints * The Trie operations will only involve lowercase letters (\'a\' to \'z\'). * Words may not always exist for the delete operation, handle such cases gracefully. * Feel free to implement any helper functions as needed. # Example ```python trie = TrieWithDeletion() trie.insert(\\"apple\\") print(trie.search(\\"apple\\")) # returns True print(trie.search(\\"app\\")) # returns False print(trie.starts_with(\\"app\\")) # returns True trie.insert(\\"app\\") print(trie.search(\\"app\\")) # returns True trie.delete(\\"apple\\") print(trie.search(\\"apple\\")) # returns False ``` Implement the `TrieWithDeletion` class to complete the task.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class TrieWithDeletion: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word): node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix): node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True def delete(self, word): self._delete(self.root, word, 0) def _delete(self, node, word, depth): if not node: return False if depth == len(word): if node.is_end_of_word: node.is_end_of_word = False return len(node.children) == 0 char = word[depth] if char in node.children: should_delete_child = self._delete(node.children[char], word, depth + 1) if should_delete_child: del node.children[char] return len(node.children) == 0 return False"},{"question":"# Comb Sort Implementation and Optimization **Objective**: Implement the Comb Sort algorithm and optimize it to improve its performance. **Description**: Comb Sort is a variant of Bubble Sort that tackles the problem of small increments between elements by introducing a gap. The gap starts large and is reduced by a shrink factor until it reaches 1. Your task is to implement the Comb Sort algorithm and then further optimize it to handle edge cases more efficiently. # Task: 1. Implement the Comb Sort algorithm based on the provided algorithm. 2. Optimize the algorithm to improve its average performance time. 3. Test your implementation with various inputs to ensure it handles edge cases properly. # Function Signature: ```python def optimized_comb_sort(arr: List[int]) -> List[int]: pass ``` # Input: * A single list of integers, `arr` (1 <= len(arr) <= 10^5), where -10^6 <= arr[i] <= 10^6. # Output: * Return a sorted list of integers. # Constraints: * Consider the constraints on input size while optimizing the performance. * Ensure your algorithm handles edge cases, such as an array of length 1, an already sorted array, and an array where all elements are identical. # Example: Input: [5, 1, 4, 2, 8] Output: [1, 2, 4, 5, 8] # Notes: * The optimized version should take into account the typical range of input and attempt to handle edge cases more gracefully.","solution":"from typing import List def optimized_comb_sort(arr: List[int]) -> List[int]: def next_gap(gap: int) -> int: # Shrink gap by the shrink factor 1.3 gap = int(gap // 1.3) if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"**Implement BST Operations** You are required to implement a Binary Search Tree (BST) with the following functionalities: 1. **Insert a node** 2. **Search for a node** 3. **Delete a node** Your implementation should consist of the following functions: 1. `insert(root, val)`: Insert a value into the BST. - **Input**: - `root`: The root of the BST (or `None` if tree is empty). - `val`: The value to be inserted. - **Output**: Return the new root of the BST after insertion. 2. `search(root, val)`: Search for a value in the BST. - **Input**: - `root`: The root of the BST. - `val`: The value to be searched. - **Output**: Return `True` if the value is found, `False` otherwise. 3. `deleteNode(root, val)`: Delete a value from the BST. - **Input**: - `root`: The root of the BST. - `val`: The value to be deleted. - **Output**: Return the new root of the BST after deletion. # Constraints - The value to be inserted, searched, or deleted will be a non-negative integer. - You may assume that all values in the BST are unique. - Your BST implementation should handle edge cases gracefully, such as inserting into an empty tree or deleting from a single-node tree. # Example Scenario & Expected Output ```python # Example usage root = None root = insert(root, 50) root = insert(root, 30) root = insert(root, 70) root = insert(root, 20) root = insert(root, 40) root = insert(root, 60) root = insert(root, 80) print(search(root, 40)) # Output: True print(search(root, 90)) # Output: False root = deleteNode(root, 20) print(search(root, 20)) # Output: False root = deleteNode(root, 50) root = deleteNode(root, 70) ``` Write the full implementation for the `insert`, `search`, and `deleteNode` functions following the provided guidelines.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def insert(root, val): if root is None: return TreeNode(val) if val < root.val: root.left = insert(root.left, val) else: root.right = insert(root.right, val) return root def search(root, val): if root is None or root.val == val: return root is not None if val < root.val: return search(root.left, val) else: return search(root.right, val) def minValueNode(node): current = node while current.left is not None: current = current.left return current def deleteNode(root, val): if root is None: return root if val < root.val: root.left = deleteNode(root.left, val) elif val > root.val: root.right = deleteNode(root.right, val) else: if root.left is None: return root.right elif root.right is None: return root.left temp = minValueNode(root.right) root.val = temp.val root.right = deleteNode(root.right, temp.val) return root"},{"question":"# Coding Assessment: Balanced Interval Tree Context A Red-Black Tree is utilized to maintain dynamically changing data in sorted order while ensuring balanced tree height. In practice, this allows efficient insertion, deletion, and look-up operations. Objective Implement a function `insert_interval` that takes a list of tuples (intervals) where each interval represents a start and end time `(start, end)`. The function should insert each interval into a Red-Black Tree such that the tree does not violate the red-black properties. After all intervals are inserted, the function should print the inorder traversal of the tree showing interval boundaries. Guidelines * Create a new Red-Black Tree class based on the provided implementation. * Define methods necessary for inserting intervals while maintaining balancing rules of Red-Black trees. * Ensure that intervals are sorted by their starting times when performing operations. * Implement and use the `insert_interval` method. # Function Specification ```python def insert_interval(intervals: List[Tuple[int, int]]) -> None: pass ``` Input Format * `intervals`: A list of tuples where each tuple contains two integers representing the start and end points of an interval. Output Format * Prints the inorder traversal of the tree containing interval boundaries where each node is represented as a dictionary `{ \'start\': int, \'end\': int, \'color\': int }`. # Constraints * Each interval in the list is defined by two endpoints: `(start, end)` such that `0 <= start < end <= 10^6`. * The number of intervals `n` is given by `1 <= n <= 10^4`. Sample Input ```python intervals = [(15, 20), (10, 30), (5, 20), (12, 15), (17, 19)] ``` Sample Output ``` [ {\\"start\\": 5, \\"end\\": 20, \\"color\\": 0}, {\\"start\\": 10, \\"end\\": 30, \\"color\\": 1}, {\\"start\\": 12, \\"end\\": 15, \\"color\\": 0}, {\\"start\\": 15, \\"end\\": 20, \\"color\\": 1}, {\\"start\\": 17, \\"end\\": 19, \\"color\\": 0} ] ``` Explanation - After inserting all the intervals, the intervals are stored in the Red-Black Tree maintaining the balanced properties. - The inorder traversal displays nodes in increasing order by their start points. # Notes * You are required to handle all balancing aspects of the Red-Black Tree while inserting intervals. * Ensure your solution is efficient and handles edge cases properly.","solution":"class Node: def __init__(self, interval, color): self.interval = interval self.color = color # 0 for black, 1 for red self.left = None self.right = None self.parent = None class RedBlackTree: def __init__(self): self.TNULL = Node((0, 0), 0) self.root = self.TNULL def inorder_helper(self, node, result): if node != self.TNULL: self.inorder_helper(node.left, result) result.append({\\"start\\": node.interval[0], \\"end\\": node.interval[1], \\"color\\": node.color}) self.inorder_helper(node.right, result) def fix_insert(self, k): while k.parent.color == 1: if k.parent == k.parent.parent.right: u = k.parent.parent.left if u.color == 1: u.color = 0 k.parent.color = 0 k.parent.parent.color = 1 k = k.parent.parent else: if k == k.parent.left: k = k.parent self.right_rotate(k) k.parent.color = 0 k.parent.parent.color = 1 self.left_rotate(k.parent.parent) else: u = k.parent.parent.right if u.color == 1: u.color = 0 k.parent.color = 0 k.parent.parent.color = 1 k = k.parent.parent else: if k == k.parent.right: k = k.parent self.left_rotate(k) k.parent.color = 0 k.parent.parent.color = 1 self.right_rotate(k.parent.parent) if k == self.root: break self.root.color = 0 def __balance_delete(self, x): while x != self.root and x.color == 0: if x == x.parent.left: s = x.parent.right if s.color == 1: s.color = 0 x.parent.color = 1 self.left_rotate(x.parent) s = x.parent.right if s.left.color == 0 and s.right.color == 0: s.color = 1 x = x.parent else: if s.right.color == 0: s.left.color = 0 s.color = 1 self.right_rotate(s) s = x.parent.right s.color = x.parent.color x.parent.color = 0 s.right.color = 0 self.left_rotate(x.parent) x = self.root else: s = x.parent.left if s.color == 1: s.color = 0 x.parent.color = 1 self.right_rotate(x.parent) s = x.parent.left if s.left.color == 0 and s.left.color == 0: s.color = 1 x = x.parent else: if s.left.color == 0: s.right.color = 0 s.color = 1 self.left_rotate(s) s = x.parent.left s.color = x.parent.color x.parent.color = 0 s.left.color = 0 self.right_rotate(x.parent) x = self.root x.color = 0 def __delete_node_helper(self, node, key): z = self.TNULL while node != self.TNULL: if node.interval[0] == key: z = node if node.interval[0] <= key: node = node.right else: node = node.left if z == self.TNULL: print(\\"Couldn\'t find key in the tree\\") return y = z y_original_color = y.color if z.left == self.TNULL: x = z.right self.__rb_transplant(z, z.right) elif z.right == self.TNULL: x = z.left self.__rb_transplant(z, z.left) else: y = self.minimum(z.right) y_original_color = y.color x = y.right if y.parent == z: x.parent = y else: self.__rb_transplant(y, y.right) y.right = z.right y.right.parent = y self.__rb_transplant(z, y) y.left = z.left y.left.parent = y y.color = z.color if y_original_color == 0: self.__balance_delete(x) def __rb_transplant(self, u, v): if u.parent == None: self.root = v elif u == u.parent.left: u.parent.left = v else: u.parent.right = v v.parent = u.parent def left_rotate(self, x): y = x.right x.right = y.left if y.left != self.TNULL: y.left.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def right_rotate(self, x): y = x.left x.left = y.right if y.right != self.TNULL: y.right.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y def insert(self, interval): node = Node(interval, 1) node.left = self.TNULL node.right = self.TNULL node.parent = None y = None x = self.root while x != self.TNULL: y = x if node.interval[0] < x.interval[0]: x = x.left else: x = x.right node.parent = y if y == None: self.root = node elif node.interval[0] < y.interval[0]: y.left = node else: y.right = node if node.parent == None: node.color = 0 return if node.parent.parent == None: return self.fix_insert(node) def get_inorder(self): result = [] self.inorder_helper(self.root, result) return result def insert_interval(intervals): rbt = RedBlackTree() for interval in intervals: rbt.insert(interval) return rbt.get_inorder()"},{"question":"You have been tasked with implementing an advanced variant of a hash table: an extendable hash table that not only resizes dynamically but also occasionally shifts its hash function to improve performance. Functionality Requirements: 1. **Initialization**: Initialize the hash table with a minimum and maximum size, as well as the initial size. 2. **Dynamic Resizing**: Resize the hash table when the load factor (number of elements/size) exceeds a predefined threshold or drops below a certain threshold. 3. **Dynamic Rehashing**: Change the hash function when the load factor exceeds a threshold, aiming for better distribution and fewer collisions. Methods to Implement: 1. `def put(self, key: int, value: int) -> None`: Insert or update the given key with the value. 2. `def get(self, key: int) -> int`: Retrieve the value for the given key. 3. `def delete(self, key: int) -> None`: Remove the key and its associated value. 4. `def size(self) -> int`: Return the current number of key-value pairs in the hash table. 5. `def current_capacity(self) -> int`: Return the current capacity of the hash table. 6. `def load_factor(self) -> float`: Return the current load factor of the hash table. Constraints: - Initial size should be greater than 0. - Min size should be ≤ initial size and max size should be ≥ initial size. - Handle collisions using linear probing with rehashing. - Rehash every time the load factor exceeds a threshold of 0.75. Edge Cases: - Attempting operations on non-existent keys (e.g., `get` or `delete`). - Key-value operations when the table is at maximum or minimum capacity. - Ensuring rehashing maintains all existing key-value pairs correctly. Example Scenarios: 1. **Scenario 1**: Add multiple key-value pairs and check if the resizing logic is applied correctly. 2. **Scenario 2**: Delete keys and verify table contraction when the load factor is too low. 3. **Scenario 3**: Stress-test the table with a sequence of inserts, updates, and deletions to ensure stability. # Expected Signature: ```python class ExtendableHashTable: def __init__(self, min_size: int, max_size: int, initial_size: int): ... def put(self, key: int, value: int) -> None: ... def get(self, key: int) -> int: ... def delete(self, key: int) -> None: ... def size(self) -> int: ... def current_capacity(self) -> int: ... def load_factor(self) -> float: ... ``` Implement the `ExtendableHashTable` class methods following above specifications.","solution":"class ExtendableHashTable: def __init__(self, min_size: int, max_size: int, initial_size: int): assert min_size <= initial_size <= max_size, \\"Initial size within min and max bounds required\\" self.min_size = min_size self.max_size = max_size self.table_size = initial_size self.table = [None] * self.table_size self.count = 0 self.load_factor_threshold = 0.75 def _hash_function(self, key: int) -> int: return key % self.table_size def put(self, key: int, value: int) -> None: self._resize_if_necessary(up=True) idx = self._find_slot(key, insert=True) if self.table[idx] is None: self.count += 1 self.table[idx] = (key, value) def get(self, key: int) -> int: idx = self._find_slot(key, insert=False) if self.table[idx] is None: raise KeyError(\\"Key not found\\") return self.table[idx][1] def delete(self, key: int) -> None: idx = self._find_slot(key, insert=False) if self.table[idx] is None: raise KeyError(\\"Key not found\\") self.table[idx] = None self.count -= 1 self._resize_if_necessary(up=False) def size(self) -> int: return self.count def current_capacity(self) -> int: return self.table_size def load_factor(self) -> float: return self.count / self.table_size def _find_slot(self, key: int, insert: bool) -> int: original_idx = self._hash_function(key) idx = original_idx while self.table[idx] is not None and self.table[idx][0] != key: idx = (idx + 1) % self.table_size if idx == original_idx: raise RuntimeError(\\"Hash table is full\\") if insert and self.table[idx] is None and idx != original_idx: idx = original_idx # Prefer the original index for inserts if possible return idx def _resize_if_necessary(self, up: bool) -> None: if up and self.load_factor() > self.load_factor_threshold: new_size = min(self.max_size, self.table_size * 2) if new_size > self.table_size: self._resize_table(new_size) if not up and self.load_factor() < 0.25: new_size = max(self.min_size, self.table_size // 2) if new_size < self.table_size: self._resize_table(new_size) def _resize_table(self, new_size: int) -> None: old_table = self.table self.table_size = new_size self.table = [None] * self.table_size self.count = 0 # Will be repopulated in put() for entry in old_table: if entry is not None: self.put(entry[0], entry[1])"},{"question":"# Question **Topic**: Sorting Algorithms - Analysis and Alternative Approach. Problem Description You are given the task of analyzing Bogo Sort and improving its performance by modifying it to a more reasonable sorting algorithm. Specifically, you are to implement the **Bogobogosort**, an even more inefficient but educational variant for sorting arrays. Instead of just randomly shuffling the entire array, the idea is: * Begin by sorting the first 2 elements. * Then sort the first 3 elements, ensure the first 2 are still sorted, and so on up to sorting the entire array. Task 1. Understand and explain the inefficiencies of Bogo Sort. 2. Implement the function `bogobogo_sort(arr: List[int], simulation: bool=False) -> List[int]` that: * Sorts the array using the Bogobogo sort technique. * Optionally prints each shuffle iteration if `simulation` is set to `True`. Input * A list of integers `arr` with (1 leq |arr| leq 100). Output * A list of integers sorted in ascending order. Constraints * You may use `random.shuffle()` from the `random` module to perform shuffling. * Ensure that no in-built sort functions (like `sorted()` or `.sort()`) are used for implementation. Performance Requirements * Given the nature of Bogobogo Sort, expect the solution to be highly inefficient. Provide a brief analysis on its complexity as a comment in your code. Example ```python Input: [3, 1, 2, 4] Output: [1, 2, 3, 4] ``` *Note: The example is just for illustration; expect to see a performance hit with larger arrays.* Code Snippet for Bogo Sort Use the Bogo Sort provided below as a reference: ```python import random def bogo_sort(arr, simulation=False): Bogo Sort Best Case Complexity: O(n) Worst Case Complexity: O(∞) Average Case Complexity: O(n(n-1)!) iteration = 0 if simulation: print(\\"iteration\\",iteration,\\":\\",*arr) def is_sorted(arr): #check the array is inorder i = 0 arr_len = len(arr) while i+1 < arr_len: if arr[i] > arr[i+1]: return False i += 1 return True while not is_sorted(arr): random.shuffle(arr) if simulation: iteration = iteration + 1 print(\\"iteration\\",iteration,\\":\\",*arr) return arr ```","solution":"import random def bogobogo_sort(arr, simulation=False): Bogobogo Sort implementation. Best Case Complexity: O(n!) - factorial grows very quickly Worst Case Complexity: O(∞) Average Case Complexity: O(n^n!) def is_sorted(lst): for i in range(len(lst) - 1): if lst[i] > lst[i + 1]: return False return True def bogo_sort_sublist(sublist): Helper function to bogo sort a sublist while not is_sorted(sublist): random.shuffle(sublist) return sublist n = len(arr) for i in range(1, n + 1): sublist = arr[:i] bogo_sort_sublist(sublist) arr[:i] = sublist if simulation: iteration = i print(f\\"iteration {iteration}: {arr}\\") return arr"},{"question":"# Question: Hamming Weight Calculation Using Bit Manipulation Your task is to write a function that calculates the Hamming weight of a given unsigned integer. The Hamming weight is the number of \'1\' bits in the binary representation of the number. Implement both recursive and iterative approaches for this problem using bit manipulation. Function Signatures ```python def hamming_weight_recursive(n: int) -> int: pass def hamming_weight_iterative(n: int) -> int: pass ``` # Input * An unsigned integer `n` where `0 <= n <= 2^31 - 1`. # Output * An integer representing the number of \'1\' bits in the binary representation of `n`. # Constraints * The function must handle large unsigned integers up to `2^31 - 1`. * The recursive function should be implemented without depth errors for reasonable input sizes, but prefer iterative approach for usual usage. # Performance Requirements * Your solution must run in O(k) time complexity, where k is the number of \'1\' bits in the binary representation of the integer. # Example ```python # Example usage and test cases print(hamming_weight_recursive(11)) # Should return 3 because 11 is 1011 in binary print(hamming_weight_iterative(11)) # Should return 3 because 11 is 1011 in binary print(hamming_weight_recursive(128)) # Should return 1 because 128 is 10000000 in binary print(hamming_weight_iterative(128)) # Should return 1 because 128 is 10000000 in binary print(hamming_weight_recursive(255)) # Should return 8 because 255 is 11111111 in binary print(hamming_weight_iterative(255)) # Should return 8 because 255 is 11111111 in binary print(hamming_weight_recursive(0)) # Should return 0 because 0 is 0 in binary print(hamming_weight_iterative(0)) # Should return 0 because 0 is 0 in binary ```","solution":"def hamming_weight_recursive(n: int) -> int: Calculate the Hamming weight (number of \'1\' bits) of an integer using recursion. if n == 0: return 0 else: return (n & 1) + hamming_weight_recursive(n >> 1) def hamming_weight_iterative(n: int) -> int: Calculate the Hamming weight (number of \'1\' bits) of an integer using iteration. count = 0 while n > 0: count += n & 1 n >>= 1 return count"},{"question":"You are given a list of unique integers in the range [0, n] where exactly one number is missing or the list is complete. Your task is to find the missing number or, if the list is complete, return the next integer in the sequence. # Function Description Implement the function `find_missing_number(nums)` that takes in a list of integers `nums` and returns the missing number in the sequence. **Input:** * A list of unique integers `nums` in the range [0, n]. **Output:** * An integer representing the missing number or if the sequence is complete, the next integer in the sequence. # Constraints * The input list will always consist of unique integers. * The input list length is at most (10^6). # Examples Example 1: ``` Input: [4, 1, 3, 0, 6, 5, 2] Output: 7 ``` Example 2: ``` Input: [0, 1, 2, 3] Output: 4 ``` # Notes * Ensure that your solution has a time complexity of (O(n)) and a space complexity of (O(1)). * Handle edge cases like an empty list correctly.","solution":"def find_missing_number(nums): Returns the missing number in the list or the next integer if the list is complete. :param nums: List of unique integers in the range [0, n] :return: The missing number or next integer in sequence n = len(nums) expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) missing_number = expected_sum - actual_sum return missing_number"},{"question":"# Word Abbreviation Generation **Objective** Write a function `generate_abbreviations(word)` that outputs all possible abbreviations of the input word using a recursive backtracking approach. **Function Signature** ```python def generate_abbreviations(word: str) -> list: ``` **Input** * `word` (str): A non-null, lower-case English alphabetic string (1 <= len(word) <= 100). **Output** * list: A list of all possible abbreviations for the given word. The order of elements in the list doesn\'t matter. **Examples** ```python generate_abbreviations(\\"word\\") # Expected Output: [\'word\', \'wor1\', \'wo1d\', \'wo2\', \'w1rd\', \'w1r1\', \'w2d\', \'w3\', \'1ord\', \'1or1\', \'1o1d\', \'1o2\', \'2rd\', \'2r1\', \'3d\', \'4\'] generate_abbreviations(\\"ab\\") # Expected Output: [\'ab\', \'a1\', \'1b\', \'2\'] ``` **Constraints** 1. The function should handle edge cases like an empty string. 2. Ensure performance considerations for large input sizes up to 100 characters. **Scenario** Imagine you\'re developing a text editing tool and need to provide autocomplete suggestions based on word abbreviations. Implementing this function helps in creating and managing a dictionary of possible abbreviations for faster lookup and suggestions. This needs to be efficient to handle real-time suggestions even with words approaching the length limit.","solution":"def generate_abbreviations(word): Generates all possible abbreviations for the given word using a recursive backtracking approach. def backtrack(pos, cur, count): if pos == len(word): if count > 0: cur += str(count) result.append(cur) else: # Option 1: Abbreviate the current character. backtrack(pos + 1, cur, count + 1) # Option 2: Do not abbreviate the current character. backtrack(pos + 1, cur + (str(count) if count > 0 else \'\') + word[pos], 0) result = [] backtrack(0, \'\', 0) return result"},{"question":"# Context You are given a logic puzzle where you need to determine if there is a way to assign boolean values (True/False) to variables, such that a given set of logical clauses in a 2-CNF (conjunctive normal form with exactly two literals per clause) is satisfied. Each clause can be represented as a pair of literals. Your task is to write a program that solves this 2-SAT problem using graph theory. # Problem Implement a function `solve_2sat(clauses)` that accepts a list of clauses and returns a dictionary with the boolean assignment of each variable if the clauses can be satisfied, or `None` if there is no possible assignment. # Input * **clauses**: A list of tuples, with each tuple containing two literals. * Each literal is a tuple itself in the format `(variable_name, is_negated)`, where `variable_name` is a string and `is_negated` is a boolean indicating if the literal is negated. # Output * A dictionary with the variable assignments if the clauses are satisfiable, otherwise `None`. # Constraints * Each variable name will consist of alphanumeric characters and will be case-sensitive. * The number of clauses will not exceed (10^4). # Example ```python def main(): clauses = [ ((\'x\', False), (\'y\', False)), ((\'y\', True), (\'y\', True)), ((\'a\', False), (\'b\', False)), ((\'a\', True), (\'c\', True)), ((\'c\', False), (\'b\', True)) ] result = solve_2sat(clauses) if result: for variable, value in result.items(): print(f\\"{variable}: {value}\\") else: print(\\"No solution exists\\") # Expected output: Dictionary with the truth values of the variables or \\"No solution exists\\" if __name__ == \\"__main__\\": main() ``` # Note Develop your solution considering the algorithm analysis and guidelines given. You are expected to implement: * Construction of the implication graph. * SCC detection using Tarjan\'s or Kosaraju\'s algorithm. * Checking for satisfiability by ensuring no variable and its negation are in the same SCC. * Assigning boolean values to the variables.","solution":"def solve_2sat(clauses): from collections import defaultdict, deque def var_id(var): return 2 * var[0] if not var[1] else 2 * var[0] + 1 def add_edge(graph, u, v): graph[u].append(v) def build_implication_graph(clauses, n_vars): graph = defaultdict(list) for (u, v) in clauses: u, v = (var_id(u), var_id(v)) add_edge(graph, u ^ 1, v) add_edge(graph, v ^ 1, u) return graph def tarjan_scc(graph, n_vars): index = 0 indices = [-1] * (2 * n_vars) low_link = [0] * (2 * n_vars) on_stack = [False] * (2 * n_vars) stack = [] sccs = [] def strongconnect(v): nonlocal index indices[v] = index low_link[v] = index index += 1 stack.append(v) on_stack[v] = True for w in graph[v]: if indices[w] == -1: strongconnect(w) low_link[v] = min(low_link[v], low_link[w]) elif on_stack[w]: low_link[v] = min(low_link[v], indices[w]) if low_link[v] == indices[v]: scc = [] while True: w = stack.pop() on_stack[w] = False scc.append(w) if w == v: break sccs.append(scc) for v in range(2 * n_vars): if indices[v] == -1: strongconnect(v) return sccs def get_variable_map(sccs, n_vars): component_idx = [-1] * (2 * n_vars) for i, scc in enumerate(sccs): for v in scc: component_idx[v] = i assignment = [False] * n_vars for i in range(0, 2 * n_vars, 2): if component_idx[i] == component_idx[i + 1]: return None assignment[i // 2] = component_idx[i] < component_idx[i + 1] return assignment all_vars = set() for clause in clauses: all_vars.update({clause[0][0], clause[1][0]}) var_index = {var: i for i, var in enumerate(all_vars)} indexed_clauses = [((var_index[var1[0]], var1[1]), (var_index[var2[0]], var2[1])) for var1, var2 in clauses] implication_graph = build_implication_graph(indexed_clauses, len(var_index)) sccs = tarjan_scc(implication_graph, len(var_index)) variable_map = get_variable_map(sccs, len(var_index)) if variable_map is None: return None assignment = {var: variable_map[i] for var, i in var_index.items()} return assignment"},{"question":"# Palindrome Linked List Checker We use linked lists to store sequences of integers, and one common question is to check whether the sequence forms a palindrome. A palindrome is a sequence that reads the same forward and backward. For example, the sequences `[1, 2, 3, 2, 1]` and `[1, 2, 2, 1]` are palindromes, whereas `[1, 2, 3, 4, 5]` is not. Your task is to implement a function that checks if a given singly linked list is a palindrome. You are restricted from using extra space, other than a few pointers (O(1) space). The function signature is as follows: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_palindrome(head: ListNode) -> bool: pass ``` # Constraints: 1. The number of nodes in the list is in the range `[1, 10^5]`. 2. `0 <= Node.val <= 9` # Example: **Input**: ``` 1 -> 2 -> 3 -> 2 -> 1 ``` **Output**: ``` True ``` **Input**: ``` 1 -> 2 -> 3 -> 4 -> 5 ``` **Output**: ``` False ``` # Requirements: 1. Utilize the given linked list structure without converting its format. 2. Achieve the solution with O(1) additional space. Consider all edge cases, such as an empty linked list, a single element list, and lists with an even or odd number of elements.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_palindrome(head: ListNode) -> bool: if not head or not head.next: return True # Find the end of the first half and reverse the second half def end_of_first_half(node) -> ListNode: fast = slow = node while fast.next and fast.next.next: fast = fast.next.next slow = slow.next return slow def reverse_list(node) -> ListNode: prev = None curr = node while curr: next_temp = curr.next curr.next = prev prev = curr curr = next_temp return prev first_half_end = end_of_first_half(head) second_half_start = reverse_list(first_half_end.next) # Check whether there is a palindrome result = True first_position = head second_position = second_half_start while result and second_position: if first_position.val != second_position.val: result = False first_position = first_position.next second_position = second_position.next # Restore the list and return the result first_half_end.next = reverse_list(second_half_start) return result"},{"question":"Scenario You are a software engineer tasked with improving system performance for handling priority tasks. An integral part of this involves optimizing how a list of tasks (with associated priorities) is sorted before execution. Problem Statement Implement the `priority_selection_sort` function which sorts a list of tasks based on their priorities using a variation of the selection sort algorithm. Each task is represented as a tuple `(task_id, priority)`, where `task_id` is a string identifying the task, and `priority` is an integer indicating its priority (lower value means higher priority). Function Signature ```python def priority_selection_sort(tasks): Sorts a list of tasks based on their specified priorities using selection sort. Args: - tasks (list of tuple): A list where each tuple is (task_id, priority). Returns: - list of tuple: The sorted list of tasks based on priority. ``` Input: * `tasks`: A list of tuples where each tuple contains a task identifier (`task_id`, a string) and a priority (`priority`, an integer). Output: * A list of tuples sorted in increasing order of priority. Constraints: * The number of tasks in the list is between 0 and 10^3. * Each `task_id` is a non-empty string containing only alphanumeric characters. * `priority` is an integer between 1 and 1000. Examples: 1. **Example 1:** ```python tasks = [(\\"task1\\", 3), (\\"task2\\", 1), (\\"task3\\", 2)] print(priority_selection_sort(tasks)) # Output: [(\'task2\', 1), (\'task3\', 2), (\'task1\', 3)] ``` 2. **Example 2:** ```python tasks = [(\\"a\\", 5), (\\"b\\", 1), (\\"c\\", 3), (\\"d\\", 2)] print(priority_selection_sort(tasks)) # Output: [(\'b\', 1), (\'d\', 2), (\'c\', 3), (\'a\', 5)] ``` Notes: * Your `priority_selection_sort` function should utilize the selection sort technique. * Consider edge cases such as empty task lists and lists where all priorities are the same.","solution":"def priority_selection_sort(tasks): Sorts a list of tasks based on their specified priorities using selection sort. Args: - tasks (list of tuple): A list where each tuple is (task_id, priority). Returns: - list of tuple: The sorted list of tasks based on priority. n = len(tasks) for i in range(n): min_index = i for j in range(i + 1, n): if tasks[j][1] < tasks[min_index][1]: min_index = j # Swap the found minimum element with the first element tasks[i], tasks[min_index] = tasks[min_index], tasks[i] return tasks"},{"question":"Scenario As part of a software development team working on a high-performance database, you are tasked with implementing and verifying a Red-Black Tree, a self-balancing binary search tree which guarantees logarithmic time complexity for search, insertion, and deletion operations. You are provided with a partially implemented Red-Black Tree, and you need to implement a specific function to modify the tree structure after the insertion operation to ensure that the Red-Black Tree properties are preserved. Challenge In this exercise, you must implement the `fix_insert` function in the `RBTree` class to ensure it satisfies the Red-Black Tree properties after inserting a new node. Function Details **Function**: `fix_insert(self, node)` **Purpose**: Adjust the RP-Tree starting from the given node to preserve the Red-Black Tree properties. **Parameters**: - `node` (RBNode): The newly inserted node which possibly violates Red-Black Tree properties. **Core Operations to Perform**: 1. Ensure the new node\'s color is appropriately adjusted. 2. Maintain tree property balance by performing necessary rotations and recoloring. 3. Ensure all Red-Black Tree balancing rules are followed to restore the tree\'s properties. Expected Output There is no explicit output for the function itself; it modifies the tree structure in place to ensure the Red-Black Tree properties are restored after node insertion. Constraints - Assume that the input node and tree are valid and follow initial Red-Black Tree properties before insertion. - No additional libraries or global variables should be used. - Your solution must be efficient in terms of time and space complexity. Example Usage ```python rb = RBTree() node1 = RBNode(10, 1) # inserting a red node rb.insert(node1) rb.fix_insert(node1) node2 = RBNode(20, 1) # inserting another red node rb.insert(node2) rb.fix_insert(node2) # The tree should remain balanced and follow Red-Black Tree properties: # An in-order traversal of the tree would showcase the balanced nature. print(rb.inorder()) # Example of checking the tree ``` Your implementation should ensure that after each insertion and `fix_insert` call, the tree remains balanced and adheres to the Red-Black Tree properties.","solution":"class RBNode: def __init__(self, data, color, left=None, right=None, parent=None): self.data = data self.color = color # 1 for red, 0 for black self.left = left self.right = right self.parent = parent class RBTree: def __init__(self): self.TNULL = RBNode(0, 0) self.root = self.TNULL def insert(self, key): node = RBNode(key, 1) node.parent = None node.data = key node.left = self.TNULL node.right = self.TNULL node.color = 1 # New node must be red y = None x = self.root while x != self.TNULL: y = x if node.data < x.data: x = x.left else: x = x.right node.parent = y if y == None: self.root = node elif node.data < y.data: y.left = node else: y.right = node if node.parent == None: node.color = 0 return if node.parent.parent == None: return self.fix_insert(node) def left_rotate(self, x): y = x.right x.right = y.left if y.left != self.TNULL: y.left.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def right_rotate(self, x): y = x.left x.left = y.right if y.right != self.TNULL: y.right.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y def fix_insert(self, k): while k.parent.color == 1: if k.parent == k.parent.parent.right: u = k.parent.parent.left if u.color == 1: u.color = 0 k.parent.color = 0 k.parent.parent.color = 1 k = k.parent.parent else: if k == k.parent.left: k = k.parent self.right_rotate(k) k.parent.color = 0 k.parent.parent.color = 1 self.left_rotate(k.parent.parent) else: u = k.parent.parent.right if u.color == 1: u.color = 0 k.parent.color = 0 k.parent.parent.color = 1 k = k.parent.parent else: if k == k.parent.right: k = k.parent self.left_rotate(k) k.parent.color = 0 k.parent.parent.color = 1 self.right_rotate(k.parent.parent) if k == self.root: break self.root.color = 0 def inorder(self): def _inorder_helper(node): return _inorder_helper(node.left) + [node.data] + _inorder_helper(node.right) if node != self.TNULL else [] return _inorder_helper(self.root)"},{"question":"# Binary Search Tree Extra Function Implementations **Context**: You have been provided with a basic implementation of a Binary Search Tree (BST) that supports insertion, searching, and three types of traversals (preorder, inorder, postorder). Now, we want to extend its functionality by adding some advanced operations that involve deeper understanding of BST properties. **Task**: Implement the following additional functionalities in the given `BST` class: 1. **Find Minimum and Maximum**: - `find_min()`: Returns the minimum value stored in the BST. - `find_max()`: Returns the maximum value stored in the BST. 2. **Check BST Validity**: - `is_valid_bst()`: Returns `True` if the tree is a valid BST and `False` otherwise. 3. **Delete a Node**: - `delete(data)`: Deletes a node with the given value from the BST. Input and Output Specifications: - `find_min() -> int`: Returns the minimum integer value in the BST. - `find_max() -> int`: Returns the maximum integer value in the BST. - `is_valid_bst() -> bool`: Returns `True` if the BST is valid, else `False`. - `delete(data: int) -> bool`: Deletes the node with the specified data, returns `True` if the node was found and deleted, else `False`. Constraints: - Assume no duplicate entries are ever inserted into the BST. - The `delete` function should handle: * Nodes with no children (leaf nodes). * Nodes with one child. * Nodes with two children. **Example Scenario:** Assume we have a BST created with the following insertions in order: ```python bst = BST() for val in [15, 10, 20, 8, 12, 17, 25, 6, 11, 16]: bst.insert(val) ``` **Example Functionality Use:** ```python # Example method calls after performing the above insertions. print(bst.find_min()) # Output: 6 print(bst.find_max()) # Output: 25 print(bst.is_valid_bst()) # Output: True bst.delete(10) # Deletes node with value 10 print(bst.is_valid_bst()) # Output: True (should remain a valid BST after deletion) ``` Implement these methods in the given BST class to complete the functionality.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = Node(key) else: self._insert(root.left, key) else: if root.right is None: root.right = Node(key) else: self._insert(root.right, key) def find_min(self): if self.root is None: return None current = self.root while current.left is not None: current = current.left return current.val def find_max(self): if self.root is None: return None current = self.root while current.right is not None: current = current.right return current.val def is_valid_bst(self): def _is_valid_bst(node, left, right): if node is None: return True if not (left < node.val < right): return False return _is_valid_bst(node.left, left, node.val) and _is_valid_bst(node.right, node.val, right) return _is_valid_bst(self.root, float(\'-inf\'), float(\'inf\')) def delete(self, key): self.root, deleted = self._delete(self.root, key) return deleted def _delete(self, root, key): if root is None: return root, False if key < root.val: root.left, deleted = self._delete(root.left, key) elif key > root.val: root.right, deleted = self._delete(root.right, key) else: deleted = True if root.left is None: return root.right, deleted elif root.right is None: return root.left, deleted min_larger_node = self._find_min(root.right) root.val = min_larger_node.val root.right, _ = self._delete(root.right, min_larger_node.val) return root, deleted def _find_min(self, root): current = root while current.left is not None: current = current.left return current"},{"question":"# Context In cryptography and number theory, determining whether a number is prime plays a crucial role. We need to verify the primality of a number efficiently to ensure the security and efficiency of cryptographic algorithms. # Task Write a function `is_prime(n: int) -> bool` to determine if a given integer `n` is a prime number. Follow the provided algorithmic principles and ensure it handles all possible edge cases efficiently. # Input * `n` (0 ≤ n ≤ 10^12): An integer to check for primality. # Output * Returns `True` if `n` is a prime number, otherwise `False`. # Constraints * The function should run in O(sqrt(n)) time. * Handle edge cases such as negative numbers, zero, and one appropriately. # Sample Input/Output Sample Input 1: ```python print(is_prime(5)) ``` Sample Output 1: ```python True ``` Sample Input 2: ```python print(is_prime(10)) ``` Sample Output 2: ```python False ``` Sample Input 3: ```python print(is_prime(17)) ``` Sample Output 3: ```python True ``` Sample Input 4: ```python print(is_prime(1)) ``` Sample Output 4: ```python False ``` # Notes * Be mindful of optimizing your solution to handle very large numbers. # Advanced Consideration (Optional) For an optional challenge, modify your solution to handle and improve performance further for very large numbers (e.g., using probabilistic tests like Miller-Rabin).","solution":"import math def is_prime(n: int) -> bool: Returns True if n is a prime number, otherwise False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"# Question: Removing Duplicates from a Linked List You are given a singly linked list where each node contains a character value. Your task is to implement a function that removes duplicates from the list. The linked list should maintain its original order without duplicates. Function Signature ```python def remove_duplicates(head: Node) -> Node: # Your implementation ``` Input - `head`: The head node of a singly linked list where each node has a character value. Output - The head node of the modified linked list with duplicates removed. Constraints - You must write an efficient solution with a time complexity of O(N). - You should use O(N) additional space for tracking duplicates. - The linked list has at most 10^4 nodes. Example 1. Given the linked list: `A -> A -> B -> C -> D -> C -> F -> G` - After removing duplicates: `A -> B -> C -> D -> F -> G` 2. Given the linked list: `B -> A -> B -> C -> B -> D` - After removing duplicates: `B -> A -> C -> D` # Note The Node class is already defined as follows: ```python class Node(): def __init__(self, val: str = None): self.val = val self.next = None ``` Implement the function `remove_duplicates` to solve the described problem.","solution":"class Node: def __init__(self, val: str = None): self.val = val self.next = None def remove_duplicates(head: Node) -> Node: Removes duplicates from the linked list and returns the new head of the linked list. if not head: return head current = head seen = set() seen.add(current.val) while current and current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next return head"},{"question":"# Lowest Common Ancestor in a Binary Tree Problem Statement Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. The lowest common ancestor is defined as the lowest node in the tree that has both given nodes as descendants (where a node can be a descendant of itself). Function Signature ```python def lca(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode: ``` Input 1. `root`: The root of the binary tree (of type `TreeNode`). 2. `p` and `q`: The two nodes for which the LCA needs to be found (of type `TreeNode`). Output - Return the lowest common ancestor node (of type `TreeNode`). Constraints - All the nodes and the tree structure are of type `TreeNode`. - All node values are unique. - The binary tree is a generic binary tree (no specific balancing). Example Given the binary tree: ```plaintext _______3______ / ___5__ ___1__ / / 6 _2 0 8 / 7 4 ``` - For nodes 5 and 1, the LCA is 3. - For nodes 5 and 4, the LCA is 5. Implementation Implement the `lca` function: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def lca(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode: if root is None or root is p or root is q: return root left = lca(root.left, p, q) right = lca(root.right, p, q) if left is not None and right is not None: return root return left if left else right ``` Edge Cases - Tree nodes `p` and `q` could be the same node. - Either of `p` or `q` or both may not be present in the tree. - The tree may be empty.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def lca(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode: if root is None or root is p or root is q: return root left = lca(root.left, p, q) right = lca(root.right, p, q) if left is not None and right is not None: return root return left if left else right"},{"question":"# Coding Problem: Endian Conversion Validator Problem Description You are required to write a function that verifies the correctness of integer-to-byte and byte-to-integer conversion processes. This function should validate that the original integer value remains the same after converting to bytes and back to an integer for both big-endian and little-endian formats. Function Signature ```python def validate_endian_conversion(num: int) -> bool: pass ``` Input - `num`: An integer, where 0 <= num <= 2^64 - 1. Output - Returns `True` if conversions retain the original integer value for both endian formats, `False` otherwise. Constraints - Use the provided conversion algorithms: * `int_to_bytes_big_endian()` * `int_to_bytes_little_endian()` * `bytes_big_endian_to_int()` * `bytes_little_endian_to_int()` - Perform the conversion and validation within O(n) time complexity. - Ensure that the function handles edge cases such as the maximum and minimum possible values. Example ```python assert validate_endian_conversion(305419896) == True assert validate_endian_conversion(0) == True assert validate_endian_conversion(2**64 - 1) == True assert validate_endian_conversion(18446744073709551615) == True ``` # Usage This problem is central in situations where endian format conversions are frequent, such as when transferring data across different network protocols or interacting with hardware components with varying endian types.","solution":"def int_to_bytes_big_endian(num): return num.to_bytes((num.bit_length() + 7) // 8, \'big\') def int_to_bytes_little_endian(num): return num.to_bytes((num.bit_length() + 7) // 8, \'little\') def bytes_big_endian_to_int(byte_data): return int.from_bytes(byte_data, \'big\') def bytes_little_endian_to_int(byte_data): return int.from_bytes(byte_data, \'little\') def validate_endian_conversion(num: int) -> bool: big_endian_bytes = int_to_bytes_big_endian(num) little_endian_bytes = int_to_bytes_little_endian(num) big_endian_to_int = bytes_big_endian_to_int(big_endian_bytes) little_endian_to_int = bytes_little_endian_to_int(little_endian_bytes) return num == big_endian_to_int == little_endian_to_int"},{"question":"# Stack ADT Implementation and Bracket Balancing Checker You are provided with two stack implementations: `ArrayStack` and `LinkedListStack`. Your task is to utilize one of these stack implementations to write a function that checks if the brackets in a given string are balanced. # Problem Write a function `is_balanced(expression: str, stack_type: str) -> bool` which takes in a string `expression` containing brackets `()[]{}`, and a string `stack_type` indicating which stack implementation to use (`\\"array\\"` or `\\"linked\\"`). The function should return `True` if the brackets in the expression are balanced, and `False` otherwise. # Examples 1. `is_balanced(\\"(a+b)\\", \\"array\\")` returns `True` 2. `is_balanced(\\"(a+b[)\\", \\"linked\\")` returns `False` 3. `is_balanced(\\"[a+b)*(c+d)]\\", \\"array\\")` returns `False` 4. `is_balanced(\\"{a+b/(c-d)}\\", \\"linked\\")` returns `True` # Constraints * The length of the expression will not exceed 1000 characters. * Only `()[]{}` brackets are to be validated for balance. # Implementation Details 1. Choose the appropriate stack implementation based on the `stack_type` parameter. 2. Use the chosen stack to verify if the brackets in the given expression are balanced. 3. Balanced brackets mean every opening bracket has a corresponding closing bracket in the correct order. # Solution Requirements * Implement the function `is_balanced(expression: str, stack_type: str) -> bool`. * Ensure proper handling of edge cases such as empty strings and unexpected characters in the expression. * The function should have an optimal time complexity of O(n) where n is the length of the expression. # Important Notes * Use the provided stack implementations in the code snippet. * Do not import additional libraries except for testing purposes.","solution":"class ArrayStack: def __init__(self): self.stack = [] def push(self, item): self.stack.append(item) def pop(self): if not self.is_empty(): return self.stack.pop() return None def is_empty(self): return len(self.stack) == 0 class LinkedListStack: class Node: def __init__(self, value, next_node=None): self.value = value self.next_node = next_node def __init__(self): self.head = None def push(self, item): new_node = self.Node(item, self.head) self.head = new_node def pop(self): if not self.is_empty(): value = self.head.value self.head = self.head.next_node return value return None def is_empty(self): return self.head is None def is_balanced(expression: str, stack_type: str) -> bool: if stack_type == \\"array\\": stack = ArrayStack() elif stack_type == \\"linked\\": stack = LinkedListStack() else: raise ValueError(\\"Unsupported stack type\\") matching_bracket = {\\")\\": \\"(\\", \\"]\\": \\"[\\", \\"}\\": \\"{\\"} opening_brackets = set(matching_bracket.values()) for char in expression: if char in opening_brackets: stack.push(char) elif char in matching_bracket: if stack.is_empty() or stack.pop() != matching_bracket[char]: return False return stack.is_empty()"},{"question":"# Nearest Neighbor Implementation You are given the following scenario where you need to write code that demonstrates your understanding of the nearest neighbor search algorithm: Scenario Imagine that you are developing a simple machine learning model to classify data points in a multi-dimensional space. Your task is to implement the nearest neighbor algorithm which will identify the closest data point in the training set to a given input vector using Euclidean distance as the measure of proximity. # Function Requirements You need to implement the following function: ```python def nearest_neighbor(x, tSet): Implements the nearest neighbor search to find the closest vector in the training set. Arguments: x (tuple): A tuple or list representing the input vector. tSet (dict): A dictionary with each key as a vector (tuple) in the training set and corresponding value as the label/class of that vector. Returns: The label of the vector in the training set that is closest to the input vector `x`. pass ``` # Input and Output * **Input**: - `x`: A tuple or list of integers or floats, representing the input vector of dimension m. - `tSet`: A dictionary with keys being tuples of integers or floats (each tuple represents a vector of dimension m) and values being the label of the corresponding vector. * **Output**: - Return the label of the nearest vector in `tSet` to the input vector `x`. # Constraints * All vectors in `x` and training set will have the same length (i.e., the same number of dimensions), no empty vectors will be present. * The input vectors and training set vectors will contain only numeric values (integers and floats). * The training set will contain at least one vector. # Example ```python x = (1.0, 2.0) tSet = { (0.0, 1.0): \'A\', (2.0, 3.0): \'B\', (1.5, 2.5): \'A\' } result = nearest_neighbor(x, tSet) print(result) # Output should be \'A\' ``` # Performance Expectation The function should run efficiently for reasonably sized datasets, say up to 10,000 vectors each of up to 100 dimensions.","solution":"import math def nearest_neighbor(x, tSet): Implements the nearest neighbor search to find the closest vector in the training set. Arguments: x (tuple): A tuple or list representing the input vector. tSet (dict): A dictionary with each key as a vector (tuple) in the training set and corresponding value as the label/class of that vector. Returns: The label of the vector in the training set that is closest to the input vector `x`. nearest_label = None smallest_distance = float(\'inf\') for vector, label in tSet.items(): distance = math.dist(x, vector) if distance < smallest_distance: smallest_distance = distance nearest_label = label return nearest_label"},{"question":"# Red-Black Tree Enhancement and Testing **Scenario**: Given the Red-Black Tree class implementation, you need to implement a method to find the kth smallest element within the Red-Black Tree. The aim is to enhance understanding of binary search tree properties and Red-Black tree specific balancing properties while practicing coding a functional extension to an existing data structure. # Task: * Implement a function `kth_smallest(self, k)` within the `RBTree` class. * The method should return the kth smallest element in the tree. * If `k` is larger than the number of nodes in the tree or `k` is less than or equal to zero, the function should return `None`. # Function Specification: ```python class RBTree: # existing implementation def kth_smallest(self, k: int) -> Optional[int]: # your implementation here ``` # Input: * A Red-Black Tree `rb` containing up to `n` nodes. * Integer `k` (1 ≤ k ≤ n). # Output: * The `k`th smallest element in the Red-Black Tree. * If `k` is out of valid range, return `None`. # Constraints: * Ensure that your solution maintains the integrity and properties of the Red-Black Tree. * Optimize for minimal tree traversal to find the kth smallest element. # Example: ```python rb = RBTree() nodes = [11, 2, 14, 1, 7, 15, 5, 8, 4] for n in nodes: node = RBNode(n, 1) rb.insert(node) print(rb.kth_smallest(3)) # Output should be 4 print(rb.kth_smallest(5)) # Output should be 7 print(rb.kth_smallest(9)) # Output should be 15 print(rb.kth_smallest(10)) # Output should be None print(rb.kth_smallest(-1)) # Output should be None ``` # Implementation Hints: * Utilize inorder traversal properties to solve this problem efficiently. * Possibly augment nodes to track the size of their subtrees for faster access.","solution":"class RBNode: def __init__(self, value, color): self.value = value self.color = color # 0 for Red, 1 for Black self.left = None self.right = None self.parent = None self.size = 1 # Number of nodes in the subtree rooted at this node including the node itself class RBTree: def __init__(self): self.NIL_LEAF = RBNode(value=None, color=1) self.root = self.NIL_LEAF def insert(self, z): y = None x = self.root while x != self.NIL_LEAF: y = x x.size += 1 # increment size of each ancestor node if z.value < x.value: x = x.left else: x = x.right z.parent = y if y is None: self.root = z elif z.value < y.value: y.left = z else: y.right = z z.left = self.NIL_LEAF z.right = self.NIL_LEAF z.color = 0 self.insert_fixup(z) def insert_fixup(self, z): # Red-Black Tree fixup logic goes here pass def kth_smallest(self, k): def in_order_traversal(node): if node and node != self.NIL_LEAF: in_order_traversal(node.left) elements.append(node.value) in_order_traversal(node.right) if k <= 0: return None elements = [] in_order_traversal(self.root) if k > len(elements): return None return elements[k - 1]"},{"question":"You need to implement a function that finds the smallest positive integer ( x ) that satisfies a system of simultanous congruences using the Chinese Remainder Theorem. The congruences will be in the form: [ x % nums[i] = rems[i] ] where ( nums ) and ( rems ) are given lists of integers with equal length. Your function should raise an error if the integers in `nums` are not pairwise coprime. # Function Signature ```python def solve_chinese_remainder(nums: List[int], rems: List[int]) -> int: ``` # Input * `nums`: A list of integers where each integer is greater than 1. These integers are the moduli and are pairwise coprime. * `rems`: A list of integers representing remainders corresponding to the congruences. **Constraints**: * Length of nums and rems (( n )) is between 1 and 100. * All elements in `nums` are greater than 1 and are pairwise coprime. # Output * An integer `x` which is the smallest positive integer that satisfies all the given congruences. # Examples ```python # Example 1 nums = [3, 4, 5] rems = [2, 3, 1] print(solve_chinese_remainder(nums, rems)) # Output: 11 # Example 2 nums = [5, 7] rems = [1, 3] print(solve_chinese_remainder(nums, rems)) # Output: 31 ``` # Notes * Your solution should raise an Exception with the message \\"Lists nums and rems should have equal length\\" if the lengths of `nums` and `rems` do not match. * Your solution should raise an Exception with the message \\"Lists nums and rems need to contain at least one element\\" if either list is empty. * Your solution should raise an Exception with the message \\"All pairs of numbers in nums are not coprime\\" if the provided numbers in `nums` are not pairwise coprime. * Your solution should raise an Exception with the message \\"All numbers in nums need to be > 1\\" if any element in `nums` is less or equal to 1.","solution":"from typing import List import math def solve_chinese_remainder(nums: List[int], rems: List[int]) -> int: def gcd(a, b): while b: a, b = b, a % b return a def are_pairwise_coprime(nums): n = len(nums) for i in range(n): for j in range(i + 1, n): if gcd(nums[i], nums[j]) != 1: return False return True if len(nums) != len(rems): raise Exception(\\"Lists nums and rems should have equal length\\") if len(nums) == 0 or len(rems) == 0: raise Exception(\\"Lists nums and rems need to contain at least one element\\") if not are_pairwise_coprime(nums): raise Exception(\\"All pairs of numbers in nums are not coprime\\") if any(n <= 1 for n in nums): raise Exception(\\"All numbers in nums need to be > 1\\") # Chinese Remainder Theorem implementation x = 0 prod = math.prod(nums) for num, rem in zip(nums, rems): partial_prod = prod // num inverse = pow(partial_prod, -1, num) x += rem * partial_prod * inverse return x % prod"},{"question":"Find the Mode(s) of an Array Given an array of integers, write a function `find_modes(arr)` that returns a list of the mode(s) of the array. The mode of a dataset is the value that appears most frequently. If there are multiple such values, all of them should be returned in the output list. Input: * An array of integers `arr`. - Array length: `0 <= len(arr) <= 10^5` - Array elements: `-10^6 <= arr[i] <= 10^6` Output: * A list of integers representing the mode(s) of the array. The list can be in any order. Examples: 1. `find_modes([1, 1, 2, 2, 3, 4])` should return `[1, 2]` 2. `find_modes([4, 5, 4, 6, 4, 7])` should return `[4]` 3. `find_modes([])` should return `[]` 4. `find_modes([1, 2, 3, 4, 5, 6, 7])` should return `[1, 2, 3, 4, 5, 6, 7]` Constraints: * Your implementation should ensure a time complexity of `O(n)` and a space complexity of `O(n)`. Notes: * Handle the edge case where the input array is empty - return an empty list. * You may assume that the input list will contain at most `10^5` integers.","solution":"from collections import defaultdict def find_modes(arr): if not arr: return [] count_dict = defaultdict(int) max_count = 0 for num in arr: count_dict[num] += 1 if count_dict[num] > max_count: max_count = count_dict[num] modes = [num for num, count in count_dict.items() if count == max_count] return modes"},{"question":"# Question Context You are developing an auto-complete feature for a text editor. The users of this editor often abbreviate common words by replacing continuous sequences of characters with the number of skipped characters. For instance, \\"word\\" could be abbreviated to \\"w1rd\\" or \\"2rd\\". The feature needs an algorithm to generate all such possible abbreviations for a given word. Problem Statement Write a function `generate_abbreviations(word: str) -> List[str]` that generates all possible abbreviations for a given word using a backtracking approach. Input * **word** (string): A word consisting of lowercase English letters (1 <= len(word) <= 15). Output * **List of strings**: All possible abbreviations of the word. Constraints * The function should handle words up to 15 characters in length efficiently. * All abbreviations should be unique and included in the output. Example ```python def generate_abbreviations(word: str) -> List[str]: # Function implementation pass # Example Usage word = \\"word\\" print(generate_abbreviations(word)) # Output: # [\'word\', \'wor1\', \'wo1d\', \'wo2\', \'w1rd\', \'w1r1\', \'w2d\', \'w3\', \'1ord\', \'1or1\', \'1o1d\', \'1o2\', \'2rd\', \'2r1\', \'3d\', \'4\'] ``` Explanation For the input word \\"word\\": * You can keep the entire word as it is. * You can replace each character with its count in an abbreviated form. * The list includes all combinations like [\'w1rd\', \'wo1d\', \'w3\', etc.]. Use a backtracking approach where you can either include a character or abbreviate it by counting the characters skipped. Explore all possible ways of writing the word as an abbreviation.","solution":"from typing import List def generate_abbreviations(word: str) -> List[str]: def backtrack(pos: int, current: str, count: int): # If we have reached the end of the word if pos == len(word): # Append the abbreviation so far, if any pending count add it result.append(current + (str(count) if count > 0 else \\"\\")) else: # Option 1: Abbreviate this character backtrack(pos + 1, current, count + 1) # Option 2: Keep this character backtrack(pos + 1, current + (str(count) if count > 0 else \\"\\") + word[pos], 0) result = [] backtrack(0, \\"\\", 0) return result"},{"question":"# Context: You are tasked with implementing a function to construct a Binary Search Tree (BST) from a given list of integers. The BST should satisfy the properties of a Binary Search Tree where, for each node, all elements in its left subtree are less than the node\'s value and all elements in the right subtree are greater than the node\'s value. # Task: Write a function `construct_bst` that takes a list of integers `nums` and returns the root of the constructed BST. You also need to implement an in-order traversal of the BST which prints out the values in non-decreasing order. # Specification: **Function Signature**: ```python def construct_bst(nums: list[int]) -> TreeNode: pass ``` **In-order Traversal Function**: ```python def in_order_traversal(root: TreeNode) -> None: pass ``` # Input: - `nums` (list of integers) — a list of integers which may contain duplicates. # Output: - Returns the root node of the BST constructed from the input list. - The `in_order_traversal` function should print the values of nodes in non-decreasing order. # Example: ```python # Example Test Case nums = [5, 3, 1, 4, 7, 6, 8] root = construct_bst(nums) in_order_traversal(root) # Expected output: 1 3 4 5 6 7 8 ``` # Constraints: - All integers in the list are in the range -10^4 to 10^4. - The length of the list is between 1 and 10^4 inclusive. # Notes: - Ensure that your implementation works efficiently for larger input sizes. Consider balanced tree insertion to avoid worst-case O(n) height trees. - Your code should not have any print statements other than those required for the in-order traversal.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def insert_into_bst(root, val): if root is None: return TreeNode(val) if val < root.val: root.left = insert_into_bst(root.left, val) else: root.right = insert_into_bst(root.right, val) return root def construct_bst(nums): if not nums: return None root = None for num in nums: root = insert_into_bst(root, num) return root def in_order_traversal(root): if root is not None: in_order_traversal(root.left) print(root.val, end=\' \') in_order_traversal(root.right)"},{"question":"<|Analysis Begin|> # Algorithm Analysis Core Identification * **Algorithm/Data Structure**: Depth-First Search (DFS) on a matrix * **Complexity**: * **Time Complexity**: O(m * n) where m is the number of rows and n is the number of columns. * **Space Complexity**: O(m * n) to store the boolean matrices `pacific` and `atlantic`. * **Principles**: The core operational mechanism involves using DFS to explore possible water flow paths from each cell to identify which cells can flow to both the Pacific and Atlantic Oceans. Characteristics & Applications * **Properties**: * Works with directional constraints (only moves to cells with equal or lower height). * Uses boolean matrices to track cells accessible to each ocean. * **Common Use Cases**: * Determines flow connectivity in grid-based pathfinding problems. * Useful in geographical and topographical analysis. * **Strengths/Limitations**: * **Strengths**: Efficiently handles the constraints of flowing in specific directions and provides precise results. * **Limitations**: Can be less efficient for larger matrices with complex flow paths, and may require careful management of recursion depth. Implementation Challenges * **Edge Cases**: * Empty matrix (needs to return an empty list). * Single-row or single-column matrices (ensuring correct initial constraints for DFS). * **Performance Bottlenecks**: * Recursion depth could be a limitation in deeply nested structures or unusually large matrices. * **Error Scenarios**: * Not handling boundary conditions properly. * Incorrectly updating boolean matrices. * **Optimization Points**: * Using iterative DFS with an explicit stack to handle larger matrices. * Avoiding redundant DFS by checking previously visited cells. <|Analysis End|> <|Question Begin|> Question: You are given an `m x n` matrix of non-negative integers representing the height of each unit cell in a continent. The matrix touches two oceans: * The \\"Pacific Ocean\\" touches the left and top edges of the matrix. * The \\"Atlantic Ocean\\" touches the right and bottom edges of the matrix. Water can only flow in four directions (up, down, left, or right) from a cell to another cell with an equal or lower height. **Objective:** Write a function `pacific_atlantic` which takes this matrix as an input and returns a list of coordinates `[i, j]` representing all cells where water can flow to both the Pacific and Atlantic Oceans. **Example:** ```python def pacific_atlantic(matrix): # Example Matrix: # Pacific ~ ~ ~ ~ ~ # ~ 1 2 2 3 (5) * # ~ 3 2 3 (4) (4) * # ~ 2 4 (5) 3 1 * # ~ (6) (7) 1 4 5 * # ~ (5) 1 1 2 4 * # * * * * * * Atlantic # Expected Output: [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] ``` **Constraints:** * Both `m` and `n` are less than 150. **Function Signature:** ```python def pacific_atlantic(matrix): # Your code here ``` **Input Format:** 1. `matrix` - List[List[int]]: A 2D list where each element is an integer representing the height of a unit cell. **Output Format:** 1. List[List[int]]: A list of coordinates where water can flow to both oceans.","solution":"def pacific_atlantic(matrix): if not matrix: return [] m, n = len(matrix), len(matrix[0]) pacific = [[False for _ in range(n)] for _ in range(m)] atlantic = [[False for _ in range(n)] for _ in range(m)] def dfs(i, j, ocean): ocean[i][j] = True directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < m and 0 <= nj < n and not ocean[ni][nj] and matrix[ni][nj] >= matrix[i][j]: dfs(ni, nj, ocean) for i in range(m): dfs(i, 0, pacific) dfs(i, n - 1, atlantic) for j in range(n): dfs(0, j, pacific) dfs(m - 1, j, atlantic) result = [] for i in range(m): for j in range(n): if pacific[i][j] and atlantic[i][j]: result.append([i, j]) return result"},{"question":"Implement a Sliding Window Median Calculator Scenario: You are tasked with building a real-time financial tool that tracks the median price of a stock in the last ( k ) minutes. This tool should effectively process a continuous stream of stock prices and quickly provide the median of the last ( k ) prices. Requirements: Write a Python class `SlidingWindowMedian` that processes a stream of integers representing stock prices and maintains a sliding window of the last ( k ) prices. Implement a method `next`, which takes an integer input (next stock price) and returns the median of the current sliding window. Ensure that the solution efficiently processes large datasets with frequent updates. # Function Signature: ```python class SlidingWindowMedian: def __init__(self, size: int): # Initialize your data structure here. def next(self, val: int) -> float: # Process the next value and return the current median. ``` # Example: ```python swm = SlidingWindowMedian(3) print(swm.next(1)) # -> 1 print(swm.next(5)) # -> 3 (median of [1,5]) print(swm.next(1)) # -> 1 (median of [1,5,1]) print(swm.next(3)) # -> 3 (median of [5, 1, 3]) print(swm.next(2)) # -> 2 (median of [3,1,2]) ``` # Constraints: * The size of the sliding window is a positive integer less than or equal to ( 10^5 ). * The input values can be any valid integer and can include negative numbers. * Maintain an amortized time complexity of ( O(log k) ) for each insertion to efficiently handle large streams.","solution":"import heapq class SlidingWindowMedian: def __init__(self, size: int): self.size = size self.min_heap = [] self.max_heap = [] self.window = [] def next(self, val: int) -> float: self.window.append(val) if len(self.window) > self.size: element_to_remove = self.window.pop(0) self._remove(element_to_remove) self._add(val) return self._get_median() def _add(self, val: int): if len(self.max_heap) == 0 or val <= -self.max_heap[0]: heapq.heappush(self.max_heap, -val) else: heapq.heappush(self.min_heap, val) self._balance_heaps() def _remove(self, val: int): if val <= -self.max_heap[0]: self.max_heap.remove(-val) heapq.heapify(self.max_heap) else: self.min_heap.remove(val) heapq.heapify(self.min_heap) self._balance_heaps() def _balance_heaps(self): if len(self.max_heap) > len(self.min_heap) + 1: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) if len(self.min_heap) > len(self.max_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) def _get_median(self): if len(self.max_heap) == len(self.min_heap): return (-self.max_heap[0] + self.min_heap[0]) / 2.0 else: return float(-self.max_heap[0])"},{"question":"# Polynomial Evaluation and Simplification Objective: Implement a function that evaluates a polynomial at given variable values. Given a polynomial and a dictionary of variable values, return the evaluated result. Your function should handle edge cases where variables do not exist or have zero coefficients. Function Signature: ```python def evaluate_polynomial(polynomial: Polynomial, substitutions: Dict[int, Union[int, float, Fraction]]) -> Union[int, float, Fraction]: pass ``` Input: - `polynomial`: A `Polynomial` object representing a multivariable polynomial. - `substitutions`: A dictionary where keys are variable indices and values are their respective replacements (int, float, or Fraction). Output: - The evaluated result of the polynomial after replacing the variables with the given values. Constraints: - Coefficient values are non-zero rational numbers. - Variable indices are positive integers. - The substitutions dictionary contains values for all variables present in the polynomial, but can contain more. - Divisions by zero should raise a `ValueError`. Example: ```python # Example Monomial and Polynomial Implementation from the provided code. # Assuming Monomial and Polynomial classes are correctly implemented and imported. poly = Polynomial([ Monomial({1:1}, 2), Monomial({2:3, 1:-1}, -1), Fraction(-1, 2) ]) result = evaluate_polynomial(poly, {1: 2, 2: 3}) print(result) # anticipated output depends on the correct evaluation ``` Requirements: 1. Correctly perform the required substitutions for each monomial. 2. Return the simplified result after entire evaluation. 3. Ensure time complexity is kept within acceptable limits, considering the constraints. 4. Handle potential edge cases like division by zero or missing variables.","solution":"from fractions import Fraction from typing import Dict, Union class Monomial: def __init__(self, variables: Dict[int, int], coefficient: Union[int, float, Fraction]): self.variables = variables self.coefficient = coefficient def evaluate(self, substitutions: Dict[int, Union[int, float, Fraction]]) -> Union[int, float, Fraction]: result = self.coefficient for var, exp in self.variables.items(): if var in substitutions: result *= substitutions[var] ** exp else: raise ValueError(f\\"Missing value for variable {var}\\") return result class Polynomial: def __init__(self, monomials: [Monomial]): self.monomials = monomials def evaluate(self, substitutions: Dict[int, Union[int, float, Fraction]]) -> Union[int, float, Fraction]: result = sum(monomial.evaluate(substitutions) for monomial in self.monomials) return result def evaluate_polynomial(polynomial: Polynomial, substitutions: Dict[int, Union[int, float, Fraction]]) -> Union[int, float, Fraction]: return polynomial.evaluate(substitutions)"},{"question":"# Priority Queue with Custom Priorities You have been provided with an implementation of a priority queue using a linear array. This priority queue allows for insertion of items with an associated priority and retrieval of the item with the lowest priority. It features the operations `push` (to insert elements) and `pop` (to extract the lowest priority element). Your task is to extend this priority queue to support a change in priorities for existing items. You need to implement a method `update_priority(item, new_priority)` that updates the priority of an existing item in the priority queue. Function Signature ```python def update_priority(self, item, new_priority): # Your code here ``` Expected Behavior * The method should update the priority of the specified item to `new_priority`. * If the item is not found in the priority queue, the method should return `None`. * After updating the priority, the internal order of the priority queue should be correct according to the priorities. Input * `item`: The item whose priority needs to be updated. (assume all items are unique) * `new_priority`: The new priority for the item. Output * Return the updated node if successful, otherwise `None`. Constraints * The priority queue contains at most `10^5` elements. * New priorities are integers and can be positive or negative. * Assume that the items are unique. Example ```python pq = PriorityQueue(items=[5, 3, 8], priorities=[1, 3, 2]) print(pq) # PriorityQueue([3: 3, 8: 2, 5: 1]) pq.update_priority(8, 4) print(pq) # PriorityQueue([8: 4, 3: 3, 5: 1]) pq.update_priority(10, 5) # Returns None as 10 is not in the priority queue ``` Notes * Students should handle any edge cases, such as attempting to update the priority of an item not in the queue. * The performance should be kept in mind, though a linear array-based implementation will inherently have some limitations.","solution":"import heapq class PriorityQueue: def __init__(self, items=[], priorities=[]): self.heap = [] self.item_map = {} # To maintain a mapping of item to their heap index for item, priority in zip(items, priorities): node = [priority, item] self.heap.append(node) self.item_map[item] = node heapq.heapify(self.heap) def push(self, item, priority): if item in self.item_map: return None # item already in queue node = [priority, item] heapq.heappush(self.heap, node) self.item_map[item] = node def pop(self): if not self.heap: return None priority, item = heapq.heappop(self.heap) del self.item_map[item] return item def update_priority(self, item, new_priority): if item not in self.item_map: return None node = self.item_map[item] node[0] = new_priority heapq.heapify(self.heap) return node def __repr__(self): return \\"PriorityQueue([\\" + \\", \\".join(f\\"{x[1]}: {x[0]}\\" for x in self.heap) + \\"])\\""},{"question":"# Binary Tree Traversals In this task, you are required to implement three different types of tree traversal methods for a given binary tree: **In-order**, **Pre-order**, and **Post-order**. # Function Signatures You need to implement the following functions: ```python def inorder_traversal(root: TreeNode) -> List[int]: pass def preorder_traversal(root: TreeNode) -> List[int]: pass def postorder_traversal(root: TreeNode) -> List[int]: pass ``` # Input - The input is the root node of a binary tree. You can assume the `TreeNode` class has been defined as follows: ```python class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None ``` # Output - Each function should return a list of integers representing the node values in the order they were visited during the traversal. # Constraints - The number of nodes in the tree is in the range `[0, 10^4]`. - `-10^4 <= Node.val <= 10^4` # Example Given the binary tree: ``` 1 / 2 3 / 4 5 ``` - In-order traversal: `[4, 2, 5, 1, 3]` - Pre-order traversal: `[1, 2, 4, 5, 3]` - Post-order traversal: `[4, 5, 2, 3, 1]` # Notes - Use recursion for the traversal implementations. - Make sure to handle all edge cases such as empty trees and single-node trees. Implement the functions to achieve successful traversal of a binary tree in the required order.","solution":"from typing import List class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None def inorder_traversal(root: TreeNode) -> List[int]: result = [] def traverse(node): if node: traverse(node.left) result.append(node.val) traverse(node.right) traverse(root) return result def preorder_traversal(root: TreeNode) -> List[int]: result = [] def traverse(node): if node: result.append(node.val) traverse(node.left) traverse(node.right) traverse(root) return result def postorder_traversal(root: TreeNode) -> List[int]: result = [] def traverse(node): if node: traverse(node.left) traverse(node.right) result.append(node.val) traverse(root) return result"},{"question":"# Coding Challenge: Filter List by Element Occurrence Scenario A retail inventory system often requires capping the number of specific items in a list to avoid oversupply situations. You are tasked with implementing a function that ensures no item appears more than a specified number of times in a given list, while preserving the original order. Task Implement a function `delete_nth(array: List[int], n: int) -> List[int]` that filters a given list `array` so that each element appears at most `n` times. The order of elements should be maintained as in the input list. Input * `array`: a list of integers `(1 <= len(array) <= 10^5)`. * `n`: a non-negative integer. Output * Return a list of integers where each element appears no more than `n` times as per the inputs. Constraints * The list `array` may contain duplicates. * `n` will be a non-negative integer within reasonable limits for practical scenarios. Examples ```python assert delete_nth([1,2,3,1,2,1,2,3], 2) == [1,2,3,1,2,3] assert delete_nth([20,37,20,21], 1) == [20,37,21] assert delete_nth([1,1,1,1,1], 0) == [] ``` Performance Requirements Your implementation should have a time complexity of `O(n)` and use additional space proportional to `O(k)` where `k` is the number of unique elements in the list.","solution":"from typing import List def delete_nth(array: List[int], n: int) -> List[int]: Filters the list so that each element appears at most n times, maintaining the order of appearance. count_dict = {} result = [] for item in array: if count_dict.get(item, 0) < n: result.append(item) count_dict[item] = count_dict.get(item, 0) + 1 return result"},{"question":"# Atbash Cipher: Implementation Challenge You are required to implement a function that performs the Atbash cipher encryption on a given string. The Atbash cipher maps each letter of the alphabet to its reverse while leaving non-alphabetical characters unchanged. Function Signature: ```python def atbash_cipher(input_string: str) -> str: ``` Input: * `input_string`: A string `s` of length `n` (0 <= n <= 10000), containing lowercase, uppercase letters, digits, and special characters. Output: * Return a new string that represents the Atbash cipher of the `input_string`. Constraints: - Handle both uppercase and lowercase letters. - Non-alphabetical characters remain unchanged. - The function should run efficiently with a time complexity of O(n). Example: ```python assert atbash_cipher(\\"Attack at dawn\\") == \\"Zggzxp zg wzdm\\" assert atbash_cipher(\\"abc XYZ 123\\") == \\"zyx CBA 123\\" assert atbash_cipher(\\"Hello, World!\\") == \\"Svool, Dliow!\\" assert atbash_cipher(\\"\\") == \\"\\" ``` Instructions: 1. Implement the function `atbash_cipher` following the provided function signature. 2. Ensure the function handles both upper and lower case letters and keeps non-alphabet characters unchanged. 3. Consider edge cases such as empty strings and strings with a mix of characters. 4. Test your function with various inputs to ensure correctness.","solution":"def atbash_cipher(input_string: str) -> str: def map_char(c): if \'a\' <= c <= \'z\': return chr(219 - ord(c)) elif \'A\' <= c <= \'Z\': return chr(155 - ord(c)) else: return c return \'\'.join(map(map_char, input_string))"},{"question":"You are given a number, and your task is to generate the next higher number consisting of the exact same set of digits as the original number. If no such number exists, return -1. **Function Signature** ```python def next_bigger(num: int) -> int: ``` **Input:** 1. An integer `num`, where (1 leq num leq 10^9). **Output:** 1. Return the next higher integer that can be formed with the same set of digits, or -1 if no such number exists. # Examples 1. `next_bigger(38276)` should return `38627`. 2. `next_bigger(12345)` should return `12354`. 3. `next_bigger(1528452)` should return `1528524`. 4. `next_bigger(138654)` should return `143568`. 5. `next_bigger(54321)` should return `-1`. 6. `next_bigger(999)` should return `-1`. 7. `next_bigger(5)` should return `-1`. # Constraints - You must execute and return your answer within a time complexity of (O(n)), where (n) is the number of digits in the number. - The input number will always be a positive integer and the output must be an integer as well. # Additional Requirements: - Handle edge cases such as single-digit numbers, numbers where all digits are identical, and the highest possible permutation. - Optimize for readability and performance.","solution":"def next_bigger(num: int) -> int: digits = list(str(num)) n = len(digits) # Step 1: Find the rightmost digit which is smaller than its next digit for i in range(n - 2, -1, -1): if digits[i] < digits[i + 1]: break else: return -1 # If no such digit is found, return -1 # Step 2: Find the smallest digit on the right side of the above found digit which is greater than the found digit for j in range(n - 1, i, -1): if digits[j] > digits[i]: # Step 3: Swap these two digits digits[i], digits[j] = digits[j], digits[i] break # Step 4: Reverse the digits after the swapped position digits = digits[:i + 1] + sorted(digits[i + 1:]) return int(\\"\\".join(digits))"},{"question":"# Jump Search Exercise **Objective**: Implement the `jump_search` function to find an element in a sorted array using the Jump Search algorithm. Function Signature: ```python def jump_search(arr: List[int], target: int) -> int: pass ``` Input: - `arr`: A sorted list of integers (0 ≤ len(arr) ≤ 10^6) - `target`: An integer representing the element to search for Output: - Returns the index of the `target` in `arr` if found. - Returns `-1` if `target` is not in the array. Constraints: - The array `arr` will always be sorted in non-decreasing order. - You should aim to achieve O(√n) time complexity. Example: ```python arr = [1, 3, 4, 7, 9, 10, 15] target = 10 # Output: 5 arr = [1, 3, 4, 7, 9, 10, 15] target = 2 # Output: -1 ``` Scenario: You are building a search engine to quickly find indexes of search queries in a large, pre-sorted dataset of indexed entries. You decide to implement Jump Search due to its efficiency on large sorted data. Your task is to develop the `jump_search` function to perform this search efficiently.","solution":"from math import sqrt from typing import List def jump_search(arr: List[int], target: int) -> int: Implements the Jump Search algorithm to find the position of a target element in a sorted array. Parameters: arr (List[int]): A sorted list of integers target (int): The element to search for in the list Returns: int: The index of the target if found, otherwise -1. n = len(arr) if n == 0: return -1 step = int(sqrt(n)) prev = 0 # Finding the block where element is present (if it is present) while prev < n and arr[min(n, prev + step) - 1] < target: prev += step # Linear search for target in the block beginning with prev for i in range(prev, min(prev + step, n)): if arr[i] == target: return i return -1"},{"question":"Find Two Unique Elements in an Array **Context**: You are working as a software engineer and you have been assigned to process telemetry data from sensors. The data contains periodic readings, but due to noise or malfunctions, exactly two readings might be unique and not follow the usual duplicity pattern. Your task is to isolate these two unique readings. Problem Statement Given an array of integers `nums`, where exactly two elements appear only once and all the other elements appear exactly twice. Implement a function `find_unique_elements` to find the two elements that appear only once. **Function Signature**: ```python def find_unique_elements(nums: List[int]) -> List[int]: ``` **Input**: - `nums`: A list of integers where exactly two elements appear only once and all others appear exactly twice. (Guaranteed to be at least 2 elements in the list). **Output**: - A list of two integers you found that appear only once. The order of the result does not matter. **Constraints**: - Your solution must have a time complexity of (O(N)) and a space complexity of (O(1)). **Example**: ```python find_unique_elements([1, 2, 1, 3, 2, 5]) # returns [3, 5] or [5, 3] ``` **Additional Notes**: Ensure your solution handles edge cases where: - The input list contains only the required minimum length. - All integers, apart from two, are duplicated. Performance Requirement: - The function must execute in linear time relative to the input size. - The solution should not use any auxiliary space except for a few variables.","solution":"def find_unique_elements(nums): Finds the two unique elements in a list where all other elements appear exactly twice. Args: nums (List[int]): List of integers where exactly two elements appear only once. Returns: List[int]: List of the two unique integers. # Initial xor will be performed for all elements xor_result = 0 for num in nums: xor_result ^= num # Find rightmost set bit in xor_result # This bit position separates the two unique numbers rightmost_set_bit = xor_result & -xor_result unique1 = 0 unique2 = 0 # Divide all numbers in two groups based on rightmost set bit for num in nums: if num & rightmost_set_bit: unique1 ^= num else: unique2 ^= num return [unique1, unique2]"},{"question":"# Task: Implement a function `delete_n_times(nums: List[int], N: int) -> List[int]` that, given a list of integers `nums` and a non-negative integer `N`, returns a new list where each distinct integer appears at most `N` times, while maintaining the original order of appearance. # Input Specifications: - `nums`: A list of integers (0 ≤ |nums| ≤ 10^6) - `N`: A non-negative integer (0 ≤ N ≤ 10^6) # Output Specifications: - Returns a list of integers with each element\'s occurrence limited to `N`. # Constraints: - If `N` is zero, return an empty list. - Elements of `nums` are within the range of -10^6 to 10^6. - Aim for a time complexity of O(n). # Example: ```python >>> delete_n_times([1,2,3,1,2,1,2,3], 2) [1, 2, 3, 1, 2, 3] >>> delete_n_times([1,1,1,1], 2) [1, 1] >>> delete_n_times([], 2) [] >>> delete_n_times([1,2,3,1,2,1,2,3], 0) [] ``` # Note: - Ensure the function handles large input efficiently. - Consider edge cases such as an empty list or `N` being zero. **Hints**: - Use dictionaries to track occurrences of elements. - Iterate through the list once to build the result. - Validate the input `N` to handle invalid cases gracefully.","solution":"from typing import List def delete_n_times(nums: List[int], N: int) -> List[int]: Returns a list where each distinct integer appears at most N times. :param nums: List[int] - The input list of integers. :param N: int - The maximum number of times each distinct integer should appear in the output list. :return: List[int] - The new list with constrained occurrences of each integer. if N == 0: return [] count = {} result = [] for num in nums: if num in count: if count[num] < N: count[num] += 1 result.append(num) else: count[num] = 1 result.append(num) return result"},{"question":"Generalized Exchange Sort Background In practice, sorting algorithms are fundamental for organizing data. While basic sorting algorithms like Bubble Sort and Exchange Sort are intuitive, they aren\'t efficient for larger datasets. Here, we assess your understanding by extending the basic Exchange Sort for generalized data structures. Problem Statement You are required to implement a function `generalized_exchange_sort` that sorts a list of tuples based on a specified tuple index. The sorting must use the principles of Exchange Sort. Function Signature ```python def generalized_exchange_sort(arr: list[tuple], sort_index: int) -> list[tuple]: pass ``` Input - `arr`: A list of tuples, where each element is a tuple of comparable values (e.g., numbers, strings). - `sort_index`: An integer representing the index of the tuple elements based on which the list should be sorted. Output - A sorted list of tuples based on the `sort_index` element. Constraints - `0 <= sort_index < len(arr[0])` - `1 <= len(arr) <= 100` - Each tuple in `arr` contains no more than 5 elements. - The values in the tuple are of types comparable with each other. Example ```python # Example 1: input_arr = [(5, \'apple\'), (2, \'banana\'), (4, \'cherry\')] sort_index = 0 output = generalized_exchange_sort(input_arr, sort_index) # Expected output: [(2, \'banana\'), (4, \'cherry\'), (5, \'apple\')] # Example 2: input_arr = [(5, \'apple\'), (2, \'banana\'), (4, \'cherry\')] sort_index = 1 output = generalized_exchange_sort(input_arr, sort_index) # Expected output: [(5, \'apple\'), (2, \'banana\'), (4, \'cherry\')] ``` Guidelines - Implement the sorting algorithm using the exchange sort principle. - Handle any potential edge cases.","solution":"def generalized_exchange_sort(arr: list[tuple], sort_index: int) -> list[tuple]: Sorts a list of tuples based on the specified tuple index using the principle of Exchange Sort. n = len(arr) for i in range(n): for j in range(i + 1, n): if arr[i][sort_index] > arr[j][sort_index]: # Swap the tuples arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"Palindromic Substring Checker Write a function to determine if a substring of a given string is a palindrome. Considering that the substring is defined by its start and end indices, your function should efficiently check if this substring is a palindrome by ignoring non-alphanumeric characters and considering case insensitivity. Function Signature ```python def is_palindromic_substring(s: str, start: int, end: int) -> bool: Determines if the substring of \'s\' from \'start\' to \'end\' is a palindrome. ``` Input * A string `s` with a length of up to 10^5 characters. * Two integers `start` and `end` that denote the beginning and ending indices (inclusive) of the substring within `s`. Output * Boolean value `True` or `False` indicating whether the specified substring is a palindrome. Constraints * 0 <= start <= end < len(s) * Your solution should efficiently handle strings up to the maximum length. Example ```python assert is_palindromic_substring(\\"A man, a plan, a canal: Panama\\", 0, 29) == True assert is_palindromic_substring(\\"race a car\\", 0, 8) == False assert is_palindromic_substring(\\"abccba\\", 1, 4) == True assert is_palindromic_substring(\\" \\", 0, 0) == True ``` Additional Notes * Handle edge cases such as empty substrings, substrings made entirely of non-alphanumeric characters, and the case where `start` equals `end`. * Ensure the function can handle large input within performance limits.","solution":"def is_palindromic_substring(s: str, start: int, end: int) -> bool: Determines if the substring of \'s\' from \'start\' to \'end\' is a palindrome. if not s or start > end or start < 0 or end >= len(s): return False substring = s[start:end+1] filtered_chars = [ char.lower() for char in substring if char.isalnum() ] left, right = 0, len(filtered_chars) - 1 while left < right: if filtered_chars[left] != filtered_chars[right]: return False left += 1 right -= 1 return True"},{"question":"You are given an array of integers representing a stack of pancakes, each with a different diameter. Your task is to sort the pancakes in order of their size, with the smallest pancake at the top (index 0) and the largest at the bottom (index N-1). You can only flip pancakes from the top of the stack. A flip operation is defined as reversing the order of the first k pancakes for any integer k where 1 ≤ k ≤ N. Write a function `pancake_sort(arr)` that takes an array `arr` of integers and sorts the array using the pancake sorting method described. # Input * `arr` (List[int]): A list of integers representing the diameter of pancakes. # Output * List[int]: A sorted list of integers in ascending order. # Constraints * The input list will have at least one and at most 1000 elements (1 ≤ len(arr) ≤ 1000). * The elements in the list will be unique and between -10^6 and 10^6 inclusive. # Example ```python # Example 1 arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3] sorted_arr = pancake_sort(arr) print(sorted_arr) # Output should be [1, 1, 2, 3, 3, 4, 5, 5, 6, 9] # Example 2 arr = [10, -1, 6, 3, 7] sorted_arr = pancake_sort(arr) print(sorted_arr) # Output should be [-1, 3, 6, 7, 10] ``` # Explanation 1. Find the maximum element in the current unsorted portion of the array. 2. Move it to the beginning of the array (if not already there) by reversing the sub-array from the start to its position. 3. Then, move it to its correct position by reversing the entire sub-array up to its current position. 4. Repeat the above steps for the remaining unsorted portion of the array until the entire array is sorted. Your implementation should demonstrate proficiency with working with array indices, list slicing, and reversing sub-arrays.","solution":"def flip(arr, k): return arr[:k][::-1] + arr[k:] def find_max_index(arr, n): max_index = 0 for i in range(1, n): if arr[i] > arr[max_index]: max_index = i return max_index def pancake_sort(arr): n = len(arr) for size in range(n, 1, -1): max_index = find_max_index(arr, size) if max_index != size - 1: if max_index != 0: arr = flip(arr, max_index + 1) arr = flip(arr, size) return arr"},{"question":"# Rotating an Image Matrix You are given an `n x n 2D` matrix representing an image. Your task is to write a function `rotate_in_place(matrix)` to rotate the image by 90 degrees clockwise, in-place. Function Signature ```python def rotate_in_place(matrix: List[List[int]]) -> None: ``` Parameters - `matrix` (List[List[int]]): An n x n list of lists representing the image to be rotated. Returns - None: The function modifies the input matrix in-place. Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_in_place(matrix) print(matrix) ``` **Output**: ``` [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` Constraints - The input matrix will always be non-null. - The dimensions of the matrix will be such that the length of each row is equal (square matrix). Performance Requirements - The algorithm should run in O(n^2) time complexity. - The algorithm must not use any extra space other than the input matrix (O(1) space complexity). Additional Notes - Ensure proper handling of edge cases such as empty matrices or single-element matrices. - Think about the manual steps required for in-place rotation and how to avoid index mismanagement errors.","solution":"from typing import List def rotate_in_place(matrix: List[List[int]]) -> None: Rotates the input image matrix by 90 degrees clockwise, in-place. Parameters: matrix (List[List[int]]): An n x n list of lists representing the image to be rotated. Returns: None: This function modifies the input matrix in-place. n = len(matrix) # First, transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Then, reverse each row for row in matrix: row.reverse()"},{"question":"# Question: Implement Stack Stutter Function Objective You have been assigned to implement a function `stutter` using an auxiliary stack. The function should take a stack as input and duplicate every item in the stack such that each item appears twice in the same order. # Specifications: * Function name: `stutter` * Input: A stack represented as a list of integers. * Output: The modified stack with each element duplicated in original order. * Constraints: * The function should use an auxiliary stack only. * The original stack may contain no more than 10,000 integers. * The values in the stack are in the range -10^6 to 10^6. # Example ```python Input: [3, 7, 1, 14, 9] Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` # Instructions 1. Implement the `stutter` function that meets the above specifications. 2. Consider edge cases such as an empty stack or a stack with one element. 3. Ensure that your implementation uses an auxiliary stack for temporary storage. ```python def stutter(stack): storage_stack = [] while len(stack) > 0: storage_stack.append(stack.pop()) while len(storage_stack) > 0: val = storage_stack.pop() stack.append(val) stack.append(val) return stack # Example usage original_stack = [3, 7, 1, 14, 9] print(stutter(original_stack)) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ```","solution":"def stutter(stack): Duplicates each element in the stack such that each element appears twice in original order. Uses an auxiliary stack for temporary storage. storage_stack = [] # Move all elements from the original stack to the auxiliary stack while len(stack) > 0: storage_stack.append(stack.pop()) # Move elements back to the original stack, while duplicating each element while len(storage_stack) > 0: val = storage_stack.pop() stack.append(val) stack.append(val) return stack # Example usage original_stack = [3, 7, 1, 14, 9] print(stutter(original_stack)) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9]"},{"question":"Problem Description: Write a function `optimized_exchange_sort` that improves the given exchange sort algorithm by adding a mechanism to detect if the array is already sorted. If no swaps are made during an entire pass through the array, the sorting should complete early, thus potentially reducing the number of comparisons. Function Signature: ```python def optimized_exchange_sort(arr: list[int]) -> list[int]: ``` Input/Output Specification: * **Input**: - `arr`: A list of integers that needs to be sorted. (1 ≤ len(arr) ≤ 10^5) * **Output**: - Sorted list of integers in ascending order. Constraints: * You should enhance the given exchange sort to incorporate this optimization while adhering to its in-place sorting characteristic (O(1) space complexity). * Ensure your solution improves the efficiency on nearly sorted input arrays. Example: ```python assert optimized_exchange_sort([5, 1, 4, 2, 8]) == [1, 2, 4, 5, 8] assert optimized_exchange_sort([3, 2, 1, 5, 6]) == [1, 2, 3, 5, 6] assert optimized_exchange_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert optimized_exchange_sort([]) == [] assert optimized_exchange_sort([5]) == [5] ``` Instructions: - You may utilize Python’s basic syntax and functions. - Do not use any built-in sorting functions. - Focus on enhancing performance where possible, particularly for input that is already or nearly sorted.","solution":"def optimized_exchange_sort(arr: list[int]) -> list[int]: Sorts the list in ascending order using an optimized version of exchange sort. n = len(arr) if n < 2: # No need to sort if the array has less than 2 elements return arr for i in range(n - 1): swapped = False for j in range(i + 1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] swapped = True if not swapped: break return arr"},{"question":"# Challenging Coding Assessment Question using Stooge Sort # Scenario You are a software engineer tasked with integrating a legacy Stooge Sort algorithm into a data processing pipeline for educational purposes. Your goal is to implement the Stooge Sort algorithm and apply it to an array of integers. # Task Write a function `stooge_sort(arr: List[int]) -> List[int]` that sorts an array of integers using the Stooge Sort algorithm. # Input Format - A list of integers `arr` representing the array to be sorted. # Output Format - Return a new list of integers representing the sorted array. # Constraints - (1 leq len(arr) leq 100) - (-10^3 leq arr[i] leq 10^3) for all valid (i) # Example Example 1 **Input:** `[2, 4, 1, 3, 5]` **Output:** `[1, 2, 3, 4, 5]` Example 2 **Input:** `[5, 3, 2, 4, 1]` **Output:** `[1, 2, 3, 4, 5]` # Performance Requirements - The solution should have a worst-case time complexity of (O(n^{2.709})). # Instructions - Follow the principles of the Stooge Sort algorithm as analyzed above. ```python def stooge_sort(arr): def stoogesort(arr, l, h): if l >= h: return if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h-l + 1 > 2: t = (int)((h-l + 1)/3) stoogesort(arr, l, h-t) stoogesort(arr, l+t, h) stoogesort(arr, l, h-t) stoogesort(arr, 0, len(arr)-1) return arr # Example Tests print(stooge_sort([2, 4, 1, 3, 5])) # [1, 2, 3, 4, 5] print(stooge_sort([5, 3, 2, 4, 1])) # [1, 2, 3, 4, 5] ```","solution":"from typing import List def stooge_sort(arr: List[int]) -> List[int]: def stoogesort(arr, l, h): if l >= h: return if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 stoogesort(arr, l, h - t) stoogesort(arr, l + t, h) stoogesort(arr, l, h - t) stoogesort(arr, 0, len(arr) - 1) return arr"},{"question":"# Pancake Sort Implementation Challenge Problem Statement You are provided with an unsorted list of integers. Your task is to implement the Pancake Sort algorithm to sort this list in ascending order. Pancake sorting involves repeatedly flipping sublists to move the largest unsorted element to its correct position. Function Signature ```python def pancake_sort(arr: List[int]) -> List[int]: pass ``` Input - A list of integers `arr` where `1 <= len(arr) <= 1000`. Output - A list of integers sorted in ascending order. Constraints 1. Your solution should have a time complexity of O(N^2) and an in-place sorting mechanism. 2. Ensure that the function handles edge cases such as: - A single element list. - An already sorted list. - A list with duplicate values. 3. Assume that the array only contains integers, both positive and negative. Examples 1. Input: `[3, 6, 1, 10, 8]` Output: `[1, 3, 6, 8, 10]` 2. Input: `[1, 2, 3, 4, 5]` Output: `[1, 2, 3, 4, 5]` 3. Input: `[5, 4, 3, 2, 1]` Output: `[1, 2, 3, 4, 5]` Additional Information You may refer to the definition and theory of Pancake Sort for better understanding, but ensure that your final implementation and logic are your own work. The algorithm should be implemented using the core in-place techniques typical in Pancake Sorting without borrowing directly from any existing solution.","solution":"from typing import List def pancake_sort(arr: List[int]) -> List[int]: def flip(sublist: List[int], k: int) -> None: sublist[:k] = sublist[:k][::-1] n = len(arr) for size in range(n, 1, -1): # Find the index of the largest element in arr[0:size] max_index = 0 for i in range(1, size): if arr[i] > arr[max_index]: max_index = i if max_index != size - 1: # Flip the largest element to the front if it\'s not already there if max_index != 0: flip(arr, max_index + 1) # Flip the largest element to its correct position flip(arr, size) return arr"},{"question":"# Problem Context In data analysis and statistics, it is often useful to understand the frequency with which different values occur in a dataset. A histogram provides a way to visualize this information by mapping each unique value in the dataset to the number of times it occurs. # Task You are required to write a function `calculate_histogram(input_list: list) -> dict` that builds a histogram from a list of numbers. # Requirements * **Input**: A list of integers `[int1, int2, int3, ...]`. * **Output**: A dictionary where each key is a unique number from the list and each value is the count of occurrences of that number. # Constraints * The input list may contain zero or more integers. * The values in the input list can be positive, negative, or zero. # Example ```python # Example 1 input_list = [3, 3, 2, 1] output = calculate_histogram(input_list) # Expected output: {1: 1, 2: 1, 3: 2} # Example 2 input_list = [2, 3, 5, 5, 5, 6, 4, 3, 7] output = calculate_histogram(input_list) # Expected output: {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} # Example 3 input_list = [] output = calculate_histogram(input_list) # Expected output: {} # Example 4 input_list = [1, 1, 1, 1, 1, 1] output = calculate_histogram(input_list) # Expected output: {1: 6} ``` # Performance Requirements Your solution should process up to 10^6 elements in the list in an efficient manner. It should provide a result within reasonable time limits for large inputs. # Additional Notes Consider edge cases such as empty lists or lists with all identical elements. The function should perform checks to ensure correctness of the input data type.","solution":"def calculate_histogram(input_list): Generates a histogram from the input list of integers. Parameters: input_list (list): List of integers. Returns: dict: A dictionary where keys are unique integers from the input list and values are their counts. histogram = {} for num in input_list: if num in histogram: histogram[num] += 1 else: histogram[num] = 1 return histogram"},{"question":"# Question: Find the nth Digit in Suffix of Integers Problem Statement You are given an infinite sequence of integers starting from 1 and concatenating them: \\"123456789101112...\\". Write a function `find_nth_digit(n: int) -> int` that returns the nth digit of this sequence. Function Signature ```python def find_nth_digit(n: int) -> int: pass ``` Input and Output Format * **Input**: * `n` (1 <= n <= 10^9): The position of the digit you need to find in the sequence. * **Output**: * Return the digit at the nth position as an integer. Constraints * You must implement an efficient solution with time complexity better than O(n). Examples 1. **Example 1**: * Input: `n = 3` * Output: `3` * Explanation: The third digit in the sequence \\"123...\\" is 3. 2. **Example 2**: * Input: `n = 11` * Output: `0` * Explanation: The 11th digit in the sequence \\"123456789101112...\\" is 0 (from the number 10). 3. **Example 3**: * Input: `n = 15` * Output: `2` * Explanation: The 15th digit in the sequence \\"12345678910111213...\\" is 2 (from the number 12). Notes * Consider edge cases like when `n` is a very large number. * Ensure that the solution handles integer division accurately to avoid errors especially when dealing with limits.","solution":"def find_nth_digit(n: int) -> int: Returns the nth digit in the infinite sequence of concatenated integers starting from 1. # Define length of current block of numbers (1-9, 10-99, etc.) length = 1 count = 9 start = 1 # Determine the block in which the nth digit falls while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Determine the actual number that contains the nth digit number = start + (n - 1) // length # Determine the position of the required digit in the number digit_index = (n - 1) % length # Convert number to string and return the digit at the calculated index return int(str(number)[digit_index])"},{"question":"# Matrix Key Search You are provided with a matrix where each row and each column are sorted in a non-decreasing order. Write a function that searches for a given key in this matrix. If the key is found, return a tuple with the row and column indices where the key is located (both indices should be 1-based). If the key is not found, return a tuple (-1, -1). Function Signature: ```python def search_in_matrix(matrix: List[List[int]], key: int) -> Tuple[int, int]: pass ``` Input * `matrix`: A list of lists of integers `matrix` where each row and column is sorted in non-decreasing order. * `key`: An integer `key` to search in the matrix. Output * A tuple with the row and column indices (1-based) where the key is found, or `(-1, -1)` if the key is not present in the matrix. Constraints * The number of rows (m) will be between `1` and `10^3`. * The number of columns (n) will be between `1` and `10^3`. * Each element of the matrix will be within the range `-10^6` to `10^6`. Performance Requirements * Your solution must run in `O(m + n)` time and use `O(1)` additional space. Example ```python matrix = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] key = 13 # Output should be (2, 3) since 13 is located at the second row and third column in 1-based indexing. print(search_in_matrix(matrix, key)) ```","solution":"from typing import List, Tuple def search_in_matrix(matrix: List[List[int]], key: int) -> Tuple[int, int]: if not matrix or not matrix[0]: return -1, -1 rows = len(matrix) cols = len(matrix[0]) row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == key: return row + 1, col + 1 elif matrix[row][col] > key: col -= 1 else: row += 1 return -1, -1"},{"question":"You are given an array of integers where every element appears exactly three times except for one integer, which appears exactly once. Write a function `find_unique_element` that finds and returns the single one that appears only once. Your solution should have a linear runtime complexity and should not use extra memory. # Function Signature ```python def find_unique_element(nums: List[int]) -> int: ``` # Input - `nums` (List[int]): A list of integers where each integer appears exactly three times except for one, which appears exactly once. # Output - Returns an integer that is the unique element appearing exactly once in the array. # Constraints - The length of `nums` is at least 1 and at most (10^5). - Each element in `nums` is a valid integer that can be represented within the Python integer range. # Examples ```python assert find_unique_element([2, 2, 3, 2]) == 3 assert find_unique_element([0, 1, 0, 1, 0, 1, 99]) == 99 assert find_unique_element([30000, 500, 100, 30000, 100, 30000, 100]) == 500 ``` # Constraints - **Performance**: Your algorithm should run in O(n) time and use O(1) extra space. - **Programming Concepts**: You are encouraged to use bit manipulation to solve this problem. # Scenario Consider a large data set of IDs where each ID is repeated three times, except one that is faulty and appears only once. This unique ID needs to be identified quickly without additional memory overhead due to constraints of the system in which this program is running.","solution":"def find_unique_element(nums): Find the unique element in an array where every element appears exactly three times except for one. ones, twos = 0, 0 for num in nums: # `twos` gets those bits which are appearing second time twos |= ones & num # `ones` gets those bits which are appearing first time ones ^= num # `common_bit_mask` stores common bits of `ones` and `twos` common_bit_mask = ~(ones & twos) # Remove common bits (appearing third time) from `ones` and `twos` ones &= common_bit_mask twos &= common_bit_mask return ones"},{"question":"# Rabin-Karp Algorithm Enhancement **Context**: You are tasked with improving a plagiarism detection system that relies on the Rabin-Karp algorithm for string matching. The current implementation is encountering an unexpected number of hash collisions, leading to inefficient performance. Your goal is to re-implement the algorithm to reduce hash collisions and optimize performance. Problem Statement Write a modified version of the Rabin-Karp algorithm that: 1. Utilizes a large prime number as the modulus operator in the hash calculations. 2. Ensures efficient handling of edge cases such as empty strings or non-matching words. 3. Minimizes hash collisions by adjusting the base of the hash function. Input and Output - **Input**: Two strings, `word` (the string to search for) and `text` (the string to search within). - **Output**: The starting index of the first occurrence of `word` in `text`, or `None` if the `word` is not found. Constraints - Assume all strings consist of lowercase English letters. - Length of both `word` and `text` ( leq 10^5 ). Example ```python def enhanced_rabin_karp(word: str, text: str) -> int: # Your code here # Example input print(enhanced_rabin_karp(\\"abc\\", \\"abxabcabcaby\\")) # Output should be 3 print(enhanced_rabin_karp(\\"abc\\", \\"defghijklmnopqrst\\")) # Output should be None ``` Requirements 1. Implement the Rabin-Karp algorithm using a large prime number (e.g., 101). 2. Ensure you handle all edge cases correctly. 3. The solution must be efficient and minimize hash collisions.","solution":"def enhanced_rabin_karp(word: str, text: str) -> int: Implements the Rabin-Karp algorithm to find the first occurrence of `word` in `text`. Uses a large prime number to minimize hash collisions. if word == \\"\\": return 0 if len(word) > len(text): return None # Define the base and a large prime number for the modulus base = 256 prime = 101 word_len = len(word) text_len = len(text) # Calculate the hash value of the word and the initial hash value of the text substring word_hash = 0 text_hash = 0 high_order = 1 # The value of high_order is \\"base^(word_len-1) % prime\\" for i in range(word_len - 1): high_order = (high_order * base) % prime for i in range(word_len): word_hash = (base * word_hash + ord(word[i])) % prime text_hash = (base * text_hash + ord(text[i])) % prime # Iterate over the text to find the match for i in range(text_len - word_len + 1): if word_hash == text_hash: # Verify the characters match when hash values are equal if text[i:i + word_len] == word: return i if i < text_len - word_len: # Remove the leading char and add the next char in the text window text_hash = (text_hash - ord(text[i]) * high_order) % prime text_hash = (text_hash * base + ord(text[i + word_len])) % prime text_hash = (text_hash + prime) % prime # Ensure positive hash value return None"},{"question":"Alice is working on a project that involves manipulating images represented as matrices. She needs your help to write functions that can perform specific transformations on these matrices. The transformations include rotating the matrix clockwise and counterclockwise, and inverting the matrix from the top-left and bottom-left corners. Your task is to write these functions efficiently. # Input and Output - **Input**: A 2D list (matrix) `matrix`, where `matrix[i][j]` is an integer. - **Output**: A 2D list representing the transformed matrix. # Problem Requirements 1. **rotate_clockwise(matrix)**: Rotates the given matrix 90 degrees clockwise. 2. **rotate_counterclockwise(matrix)**: Rotates the given matrix 90 degrees counterclockwise. 3. **top_left_invert(matrix)**: Inverts the given matrix from the top-left corner. 4. **bottom_left_invert(matrix)**: Inverts the given matrix from the bottom-left corner. # Constraints 1. `0 <= len(matrix) <= 100` - The number of rows in the matrix. 2. `0 <= len(matrix[i]) <= 100` - The number of columns in each row. 3. The matrix is well-formed, i.e., all rows are of equal length. 4. `0 <= matrix[i][j] <= 1000` - The integers in the matrix are non-negative. # Function Signatures ```python def rotate_clockwise(matrix): pass def rotate_counterclockwise(matrix): pass def top_left_invert(matrix): pass def bottom_left_invert(matrix): pass ``` # Examples ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(rotate_clockwise(matrix)) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] print(rotate_counterclockwise(matrix)) # Output: # [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7] # ] print(top_left_invert(matrix)) # Output: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] print(bottom_left_invert(matrix)) # Output: # [ # [9, 6, 3], # [8, 5, 2], # [7, 4, 1] # ] ``` # Notes * Ensure your functions handle edge cases such as empty matrices and single-element matrices gracefully. * Optimize for readability and performance where possible.","solution":"def rotate_clockwise(matrix): Rotates the given matrix 90 degrees clockwise. if not matrix: return [] return [[matrix[j][i] for j in range(len(matrix) - 1, -1, -1)] for i in range(len(matrix[0]))] def rotate_counterclockwise(matrix): Rotates the given matrix 90 degrees counterclockwise. if not matrix: return [] return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]) - 1, -1, -1)] def top_left_invert(matrix): Inverts the given matrix from the top-left corner. if not matrix: return [] return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))] def bottom_left_invert(matrix): Inverts the given matrix from the bottom-left corner. if not matrix: return [] return [[matrix[j][i] for j in range(len(matrix) - 1, -1, -1)] for i in range(len(matrix[0]) - 1, -1, -1)]"},{"question":"# Bit Manipulation Task **Context**: In low-level data manipulation, it is often necessary to insert specific bits into an integer\'s binary representation at a given position. Such tasks are common in systems programming, data compression, and cryptography. **Objective**: Implement two functions that insert bits into an integer at specific positions. These functions should be efficient and handle edge cases appropriately. **Function Descriptions**: 1. **insert_one_bit(num: int, bit: int, i: int) -> int**: * **Description**: Inserts a single bit (`bit`, 0 or 1) at position `i` in the integer `num`. * **Parameters**: - `num`: The given integer (32-bit or 64-bit depending on your system). - `bit`: The bit to insert (only 0 or 1). - `i`: The position at which to insert the bit (0-based). * **Returns**: The resulting integer after insertion. * **Example**: ```python insert_one_bit(21, 1, 2) # Output: 45 insert_one_bit(21, 0, 2) # Output: 41 insert_one_bit(21, 1, 5) # Output: 53 insert_one_bit(21, 1, 0) # Output: 43 ``` 2. **insert_mult_bits(num: int, bits: int, length: int, i: int) -> int**: * **Description**: Inserts a sequence of `length` bits (`bits`) at position `i` in the integer `num`. * **Parameters**: - `num`: The given integer (32-bit or 64-bit depending on your system). - `bits`: The bits to insert (should fit within `length` bits). - `length`: The number of bits in `bits` to be inserted. - `i`: The position at which to insert the bits (0-based). * **Returns**: The resulting integer after insertion. * **Example**: ```python insert_mult_bits(5, 7, 3, 1) # Output: 47 insert_mult_bits(5, 7, 3, 0) # Output: 47 insert_mult_bits(5, 7, 3, 3) # Output: 61 ``` **Constraints**: - You may assume the inputs are valid, with `num` a non-negative integer, `bit` either 0 or 1, `bits` non-negative integer fitting within `length` bits, `length` a positive integer, and `i` a non-negative integer not exceeding the binary length of `num`. **Performance Requirement**: The solution should be efficient, ideally operating at O(log n) time complexity.","solution":"def insert_one_bit(num, bit, i): Inserts a single bit (0 or 1) at position i in the integer num. if bit not in (0, 1): raise ValueError(\\"bit must be 0 or 1\\") mask = (1 << i) - 1 # Mask for lower bits upper_bits = (num >> i) << (i + 1) # Bits above position i lower_bits = num & mask # Bits below position i result = (upper_bits | (bit << i) | lower_bits) return result def insert_mult_bits(num, bits, length, i): Inserts a sequence of \'length\' bits (given by \'bits\') at position \'i\' in the integer \'num\'. if bits >= (1 << length): raise ValueError(\\"bits does not fit within the specified length\\") mask = (1 << i) - 1 # Mask for lower bits upper_bits = (num >> i) << (i + length) # Bits above position i lower_bits = num & mask # Bits below position i bits_shifted = bits << i result = (upper_bits | bits_shifted | lower_bits) return result"},{"question":"You are given a binary tree where each node has a value and pointers to the left and right child nodes. Your task is to write a function that inverts the binary tree. This process will swap the left and right child pointers of all nodes in the tree. # Function Signature: ```python def invert_tree(root: TreeNode) -> TreeNode: pass ``` # Input: - `root` (TreeNode): The root of the binary tree. Each node in the tree has attributes: - `val`: an integer value. - `left`: a pointer to the left child node (TreeNode or None). - `right`: a pointer to the right child node (TreeNode or None). # Output: - `TreeNode`: The root of the inverted binary tree. # Constraints: - The number of nodes in the binary tree is in the range [0, 10000]. - The values of the nodes are integers and can be negative or positive. # Performance Requirements: - The time complexity should be O(n) where n is the number of nodes in the tree. - The space complexity should be O(h) where h is the height of the tree. # Example: Consider the following binary tree `[4,2,7,1,3,6,9]`: ``` 4 / 2 7 / / 1 3 6 9 ``` After inversion, it should become: ``` 4 / 7 2 / / 9 6 3 1 ``` If the input `root` references the above tree structure, then: ```python invert_tree(root) # Output would be a reference to the root of the inverted tree ``` # Implementation Notes: - Carefully handle edge cases, such as an empty tree or a tree with a single node. - Ensure the solution is optimized to handle large trees efficiently.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invert_tree(root: TreeNode) -> TreeNode: if not root: return None # Recursively invert the left and right subtrees left_inverted = invert_tree(root.left) right_inverted = invert_tree(root.right) # Swap the left and right children root.left = right_inverted root.right = left_inverted return root"},{"question":"Longest Common Substring Given two strings `s1` and `s2`, where `s2` contains all distinct characters, write a function that returns the longest common substring between the two. If there are multiple substrings of the same length, return the first one found. # Function Signature ```python def longest_common_substring(s1: str, s2: str) -> str: ``` # Parameters - **s1** (str): The first input string. - **s2** (str): The second input string, guaranteed to have all unique characters. # Return - **str**: The longest common substring found in both strings. # Constraints - The length of `s1` and `s2` ranges from 0 to 10^5. - No characters in `s2` repeat. - Preference should be given to efficient handling matching the expected time complexity O(n log n). # Example ```python assert longest_common_substring(\\"abcde\\", \\"fbcdfgh\\") == \\"bcd\\" assert longest_common_substring(\\"abcdef\\", \\"ghijkl\\") == \\"\\" assert longest_common_substring(\\"12345\\", \\"34567\\") == \\"345\\" assert longest_common_substring(\\"\\", \\"anything\\") == \\"\\" assert longest_common_substring(\\"apple\\", \\"apple\\") == \\"apple\\" ``` # Detailed Explanation Input `s1: \\"abcde\\", s2: \\"fbcdfgh\\"` - The longest common substring between `s1` and `s2` is \\"bcd\\" which is found starting position in `s1` and `s2`. Remember to consider edge cases where one or both strings might be empty or no common substring exists.","solution":"def longest_common_substring(s1: str, s2: str) -> str: Returns the longest common substring between s1 and s2. m, n = len(s1), len(s2) max_len = 0 end_pos = 0 # Create a table to store lengths of longest common suffixes of substrings lc_suffix = [[0] * (n + 1) for _ in range(m + 1)] # Build the lc_suffix table for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: lc_suffix[i][j] = lc_suffix[i - 1][j - 1] + 1 if lc_suffix[i][j] > max_len: max_len = lc_suffix[i][j] end_pos = i # Using the end_pos and max_len to get the longest common substring return s1[end_pos - max_len:end_pos]"},{"question":"Problem Statement: You are a software engineer tasked with developing a function that standardizes file paths for a file management tool. Your function should ensure that: 1. The input file path is transformed into an absolute path. 2. Any user shortcuts like `~` (home directory) are adequately resolved. Function Signature: ```python def standardized_path(file: str) -> str: ``` Input: - `file` (str): A string representing a file path which may include relative paths or user-specific shortcuts. Output: - Returns a string representing the absolute path of the input file. Constraints: - The input path can be relative or absolute. - The input path might include user-specific shortcuts like `~`. - Do not assume the input file or directory actually exists. Example: ``` Input: \\"~/Documents/project/file.txt\\" Output: \\"/home/user/Documents/project/file.txt\\" (assuming \'/home/user\' is the user home directory) Input: \\"../folder/file.txt\\" Output: \\"/current/directory/folder/file.txt\\" ``` Performance Requirements: - Your function should handle conversion efficiently, considering typical file path manipulations. Scenario: \\"You are working on a cross-platform file management system that standardizes file paths for various operations. For instance, you may need to store file paths in a database or perform filesystem operations where absolute paths are required.\\" Implementation: Write the `standardized_path` function by leveraging built-in OS utilities in Python.","solution":"import os def standardized_path(file: str) -> str: Returns the absolute path of the file path given by resolving any user-specific shortcuts and relative paths. Parameters: file (str): The file path which may include relative or user-specific shortcuts. Returns: str: The absolute path of the input file. return os.path.abspath(os.path.expanduser(file))"},{"question":"Context You are tasked with creating a robust system to manage prerequisites among different tasks in a task management system. The tasks are represented as nodes in a Directed Acyclic Graph (DAG). The goal is to determine the order in which you can perform the tasks, respecting the dependencies. Problem Statement Implement a function `topological_sort` that computes a valid topological ordering of tasks given a directed acyclic graph without cycles. If the graph contains a cycle, your function should detect it and raise a `ValueError` exception. Input - `graph`: A dictionary where keys are task identifiers (nodes), and values are lists of tasks (nodes) that depend on the key task. - Example: ```python graph = { \'A\': [\'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'E\'], \'D\': [\'F\'], \'E\': [], \'F\': [] } ``` Output - A list representing the topological order of the tasks. Constraints - The graph is a valid DAG without self-loops. - The graph may consist of up to `10^3` nodes and `10^4` edges. Example ```python graph = { \'A\': [\'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'E\'], \'D\': [\'F\'], \'E\': [], \'F\': [] } print(topological_sort(graph)) # Possible output: [\'B\', \'D\', \'A\', \'F\', \'C\', \'E\'] ``` Requirements - Your implementation should handle edge cases and validate the input graph. - It should have a time complexity of O(V + E) and space complexity of O(V). - The function should raise a `ValueError` if a cycle is detected during the sort. Notes - You can implement the solution using either a recursive or iterative DFS approach. - Ensure your solution is robust and handles various edge scenarios gracefully. Function Signature ```python def topological_sort(graph: dict) -> list: # Your implementation here ```","solution":"def topological_sort(graph): Perform a topological sort on a directed acyclic graph (DAG). :param graph: A dictionary where keys are task identifiers and values are lists of tasks that depend on the key task. :return: A list representing the topological order of tasks. :raises ValueError: If a cycle is detected in the graph. def dfs(node): if node in visited: if visited[node] == -1: # Currently visiting in the recursion stack raise ValueError(\\"Cycle detected in the graph\\") return # Already processed visited[node] = -1 # Mark node as being visited for neighbor in graph.get(node, []): dfs(neighbor) visited[node] = 1 # Mark node as processed result.append(node) visited = {} result = [] for node in graph: if node not in visited: dfs(node) result.reverse() # Reverse to get the correct order return result"},{"question":"# Binary Search Assessment Background: You are developing a module for a large-scale library system that needs to efficiently look up books in an indexed database. You have a sorted list of book IDs and need to implement a search function using binary search, both iteratively and recursively. Task: Implement two functions to perform binary search on a sorted array of book IDs: 1. **Iterative Approach**: - Function Name: `iterative_binary_search` - Inputs: `book_ids` (List[int]), `target_id` (int) - Output: Index of `target_id` in `book_ids`, or `-1` if `target_id` is not found. 2. **Recursive Approach**: - Function Name: `recursive_binary_search` - Inputs: `book_ids` (List[int]), `low` (int), `high` (int), `target_id` (int) - Output: Index of `target_id` in `book_ids`, or `-1` if `target_id` is not found. Function Signatures: ```python def iterative_binary_search(book_ids, target_id): pass def recursive_binary_search(book_ids, low, high, target_id): pass ``` Constraints: - The `book_ids` array is guaranteed to be sorted in ascending order. - The length of the `book_ids` array is `n` where `1 <= n <= 10^6`. - You must not use built-in Python functions like `index()` or other high-level searching functions. Example: ```python book_ids = [2, 3, 4, 10, 40] iterative_binary_search(book_ids, 10) # Output: 3 iterative_binary_search(book_ids, 5) # Output: -1 book_ids = [2, 3, 4, 10, 40] recursive_binary_search(book_ids, 0, len(book_ids) - 1, 10) # Output: 3 recursive_binary_search(book_ids, 0, len(book_ids) - 1, 5) # Output: -1 ``` Requirements: - Implement **robust** error handling for edge cases (e.g., empty arrays, values outside the array) - Ensure **optimal performance** in terms of time and space complexity.","solution":"def iterative_binary_search(book_ids, target_id): Searches for a target_id in book_ids using an iterative binary search. Returns the index of target_id if found, otherwise returns -1. low, high = 0, len(book_ids) - 1 while low <= high: mid = (low + high) // 2 if book_ids[mid] == target_id: return mid elif book_ids[mid] < target_id: low = mid + 1 else: high = mid - 1 return -1 def recursive_binary_search(book_ids, low, high, target_id): Searches for a target_id in book_ids using a recursive binary search. Returns the index of target_id if found, otherwise returns -1. if low <= high: mid = (low + high) // 2 if book_ids[mid] == target_id: return mid elif book_ids[mid] < target_id: return recursive_binary_search(book_ids, mid + 1, high, target_id) else: return recursive_binary_search(book_ids, low, mid - 1, target_id) return -1"},{"question":"# Matrix Inversion Coding Challenge Given a square matrix `A`, implement a function to compute its inverse. The function should return the inverted matrix, employing the steps delineated below. Matrices provided will always be invertible and square (n x n) with n >= 2. # Input * A two-dimensional list `A` representing an n x n matrix, where 2 <= n <= 10. # Output * A two-dimensional list representing the inverse of the input matrix `A`. # Constraints * The determinant of the matrix will never be zero. * All input matrices are guaranteed to be valid square matrices with dimensions between 2 and 10. # Steps to Compute the Inverse 1. **Matrix of Minors**: Compute the matrix of minors. 2. **Matrix of Cofactors**: Apply alternate signs in a checkerboard pattern to the matrix of minors. 3. **Adjugate**: Transpose the matrix of cofactors. 4. **Multiply by the Reciprocal of the Determinant**: Scale the adjugate matrix by the reciprocal of the determinant of the original matrix. # Edge Cases * Matrix dimensions exactly 2x2, testing both trivial and general cases of matrix inversion. # Function Signature ```python def inverse_matrix(A: List[List[int]]) -> List[List[float]]: # Your code here ``` # Example Input ```python A = [ [4, 7], [2, 6] ] ``` Output ```python [ [0.6, -0.7], [-0.2, 0.4] ] ``` Explanation: The inverse matrix is computed following the principles of matrix inversion described above. Ensure your function handles matrices up to 10x10 efficiently. The solution should be optimized for performance to handle the upper constraint without significant delay.","solution":"from typing import List def inverse_matrix(A: List[List[int]]) -> List[List[float]]: Computes the inverse of a given square matrix A. import numpy as np A_np = np.array(A) A_inv_np = np.linalg.inv(A_np) # Convert numpy matrix back to list of lists A_inv = A_inv_np.tolist() return A_inv"},{"question":"You are given a positive integer. Your task is to write a function `next_bigger(num: int) -> int` that takes this number and returns the smallest number that is strictly greater than the given number and can be formed using the digits of the given number. If no such number is possible, return `-1`. # Input: - An integer `num` (1 ≤ num ≤ 10^9). # Output: - An integer which is the next permutation of the digits. If no such permutation exists, return `-1`. # Example: ```python print(next_bigger(38276)) # Output: 38627 print(next_bigger(99999)) # Output: -1 ``` # Constraints: 1. You may not use any built-in library to generate permutations. 2. The solution should handle all edge cases efficiently and correctly. # Edge Cases: 1. Input number consists of identical digits (e.g., 999 or 11111). 2. Zero or single-digit numbers should return `-1` as there is no higher permutation available. 3. Large numbers close to the upper constraint should be handled within reasonable time and space limits. Performance Requirements: - The solution must execute within the time and space complexity of O(n), where n is the number of digits in the input number. - Avoid unnecessary data structures or excessive recursive calls that do not offer performance improvements. # Scenario: Imagine a digital lock where the current combination is stored as an integer. You need to write an algorithm that finds the next combination which is numerically greater than the current one using the same digits, ensuring that the next higher combination can be quickly computed for security reasons.","solution":"def next_bigger(num: int) -> int: Returns the smallest number strictly greater than `num` that can be formed using its digits. If no such number exists, return -1. num_list = list(str(num)) n = len(num_list) # Step 1: Find the rightmost digit which is smaller than its next digit i = n - 2 while i >= 0 and num_list[i] >= num_list[i + 1]: i -= 1 # If no such digit is found, return -1 (digits are in descending order) if i == -1: return -1 # Step 2: Find the smallest digit on the right side of (i)\'th digit which is greater than num_list[i] j = n - 1 while num_list[j] <= num_list[i]: j -= 1 # Step 3: Swap the found digits num_list[i], num_list[j] = num_list[j], num_list[i] # Step 4: Reverse the digits after (i+1) to get the smallest lexicographical order num_list = num_list[:i+1] + num_list[i+1:][::-1] # Convert the list back to integer return int(\\"\\".join(num_list))"},{"question":"Scenario You are working on a project to merge traffic data from two different sources that occasionally intersect but are mostly independent. Your task is to identify the intersection point where the data overlaps if it exists. Problem Statement Given the heads of two singly linked lists, write a function `find_intersection(h1, h2)` that finds the node at which the two lists intersect. If the two linked lists have no intersection, return `None`. Note that the intersection is based on reference, not value. Function Signature ```python def find_intersection(h1: Node, h2: Node) -> Optional[Node]: # Your code here ``` Constraints - The linked lists must be acyclic. - Nodes are uniquely identifiable and contain non-unique integer values. - The lists can be empty. Expected Input and Output - Input: `h1` and `h2` are the heads of two singly linked lists. - Output: The node where the two lists intersect or `None` if there is no intersection. Example ```python class Node: def __init__(self, value): self.value = value self.next = None # Create lists: # 1 -> 3 -> 5 # # 7 -> 9 -> 11 # / # 2 -> 4 -> 6 a1 = Node(1) b1 = Node(3) c1 = Node(5) d = Node(7) a2 = Node(2) b2 = Node(4) c2 = Node(6) e = Node(9) f = Node(11) a1.next = b1 b1.next = c1 c1.next = d a2.next = b2 b2.next = c2 c2.next = d d.next = e e.next = f intersection_node = find_intersection(a1, a2) assert intersection_node is not None and intersection_node.value == 7 ``` Performance Requirements Your implementation should run efficiently with a complexity of O(N + M), where N and M are the lengths of the two lists. Ensure that your solution uses O(1) extra space.","solution":"class Node: def __init__(self, value): self.value = value self.next = None def find_intersection(h1, h2): if not h1 or not h2: return None # Calculate lengths of both lists def get_length(head): length = 0 current = head while current: length += 1 current = current.next return length len1 = get_length(h1) len2 = get_length(h2) # Adjust starting points current1, current2 = h1, h2 if len1 > len2: for _ in range(len1 - len2): current1 = current1.next else: for _ in range(len2 - len1): current2 = current2.next # Traverse both lists together to find intersection while current1 and current2: if current1 == current2: return current1 current1 = current1.next current2 = current2.next return None"},{"question":"You are given a sequence of integers and you must perform specific operations: finding the GCD and LCM of two numbers, and counting the trailing zeros in the binary representation of an integer. Furthermore, implement an optimized version of GCD using bitwise operations. # Tasks: 1. Write a function `compute_gcd(a, b)` that returns the GCD of integers `a` and `b` using Euclid’s Algorithm. 2. Write a function `compute_lcm(a, b)` that returns the LCM of integers `a` and `b`. 3. Write a function `count_trailing_zeros(x)` that returns the number of trailing zero bits in the binary representation of integer `x`. 4. Write a function `compute_gcd_bitwise(a, b)` that returns the GCD of integers `a` and `b` using bitwise operations. # Input Format: * For `compute_gcd` and `compute_lcm`: Two integers `a` and `b`, where `1 ≤ a, b ≤ 10^9`. * For `count_trailing_zeros`: One integer `x`, where `1 ≤ x ≤ 10^9`. * For `compute_gcd_bitwise`: Two integers `a` and `b`, where `1 ≤ a, b ≤ 10^9`. # Output Format: * For all functions: A single integer representing the result. # Constraints: * You must handle all edge cases such as zeros and negative numbers appropriately in `compute_gcd` and `compute_lcm`. * Performance should be optimized to handle the upper constraint limits efficiently. * Try to maintain constant space complexity. # Example: ```python # Example 1: a, b = 48, 18 print(compute_gcd(a, b)) # Output: 6 print(compute_lcm(a, b)) # Output: 144 # Example 2: x = 40 print(count_trailing_zeros(x)) # Output: 3 # Example 3: a, b = 48, 18 print(compute_gcd_bitwise(a, b)) # Output: 6 ``` # Notes: * Ensure to handle invalid inputs appropriately by raising relevant exceptions. * Pay attention to integer overflow scenarios in LCM.","solution":"def compute_gcd(a, b): Compute the GCD (Greatest Common Divisor) of two integers using Euclid\'s Algorithm. :param a: First integer :param b: Second integer :return: GCD of a and b while b: a, b = b, a % b return a def compute_lcm(a, b): Compute the LCM (Least Common Multiple) of two integers. :param a: First integer :param b: Second integer :return: LCM of a and b return abs(a * b) // compute_gcd(a, b) def count_trailing_zeros(x): Count the number of trailing zero bits in the binary representation of an integer. :param x: The integer :return: Number of trailing zero bits count = 0 while (x & 1) == 0 and x != 0: x >>= 1 count += 1 return count def compute_gcd_bitwise(a, b): Compute the GCD (Greatest Common Divisor) of two integers using bitwise operations. :param a: First integer :param b: Second integer :return: GCD of a and b if a == 0: return b if b == 0: return a # Find common factors of 2 common_factors_of_2 = count_trailing_zeros(a | b) a >>= count_trailing_zeros(a) while b != 0: b >>= count_trailing_zeros(b) if a > b: a, b = b, a b -= a return a << common_factors_of_2"},{"question":"Context You are working as a software engineer at a company that needs to generate Fibonacci numbers to model various financial scenarios. However, the program you currently have is too slow for large inputs and lacks the necessary efficiency. Your task is to implement an efficient version of the Fibonacci sequence generator. Task Implement the function `fib_efficient(n: int) -> int` to compute the nth Fibonacci number efficiently. Input - A non-negative integer `n` (0 <= n <= 10^6). Output - Return the nth Fibonacci number. **Constraints:** - Ensure your function can handle very large inputs up to 10^6 efficiently. Performance Requirement: - Time Complexity: O(log n) would be optimal. - Space Complexity: O(1) if possible. Example ```python # Example 1 fib_efficient(10) # Output: 55 # Example 2 fib_efficient(50) # Output: 12586269025 # Example 3 fib_efficient(1000000) # Output: a very large number that your implementation should handle efficiently ``` Implementation Notes: Consider using matrix exponentiation or another advanced technique beyond simple iteration or recursion to achieve the desired performance.","solution":"def fib_efficient(n: int) -> int: Compute the nth Fibonacci number efficiently using matrix exponentiation. if n == 0: return 0 if n == 1: return 1 def matrix_mult(A, B): return [ [A[0][0]*B[0][0] + A[0][1]*B[1][0], A[0][0]*B[0][1] + A[0][1]*B[1][1]], [A[1][0]*B[0][0] + A[1][1]*B[1][0], A[1][0]*B[0][1] + A[1][1]*B[1][1]] ] def matrix_exponentiation(A, power): result = [[1, 0], [0, 1]] # Identity matrix base = A while power > 0: if power % 2 == 1: result = matrix_mult(result, base) base = matrix_mult(base, base) power //= 2 return result F = [[1, 1], [1, 0]] result_matrix = matrix_exponentiation(F, n-1) return result_matrix[0][0]"},{"question":"# Scenario You are assisting in improving the performance of a startup\'s inventory management system. The current system works well with just a few hundred items but shows considerable lag as more items are added. You are asked to implement a function that sorts the list of items using the Insertion Sort algorithm, ensuring that the inventory system performs better under typical use cases where items are nearly sorted. # Task Write a function `optimized_insertion_sort` in Python that takes a list of integers and sorts it using the insertion sort algorithm with the following enhancements: 1. **Early Exit**: If during an iteration it is found that no elements were moved, terminate the algorithm early as the list is already sorted. 2. **Binary Search**: Implement a binary search to find the correct position of the element being inserted in the sorted part of the list. This should reduce the number of comparisons. # Function Signature ```python def optimized_insertion_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` # Input - A list of integers `arr` where ( 1 leq text{len}(arr) leq 10^4 ). - A boolean `simulation` (default is False). If True, the function should print the state of the list after each iteration. # Output - A sorted list of integers. # Constraints - The function should sort the list in place with a time complexity of ( O(n^2) ) and space complexity of O(1). - You are not allowed to use Python\'s built-in sort function. # Example ```python >>> optimized_insertion_sort([4, 3, 2, 1]) iteration 0: 4 3 2 1 iteration 1: 3 4 2 1 iteration 2: 2 3 4 1 iteration 3: 1 2 3 4 [1, 2, 3, 4] ``` # Additional Information - Focus on the provided constraints and aim to optimize the insertion process. - Test your solution against both typical and edge cases like already sorted arrays, reverse-sorted arrays, and arrays with repetitive elements.","solution":"from typing import List def binary_search_insert(arr: List[int], val: int, start: int, end: int) -> int: Binary search helper to find the correct insert position for val within arr[start:end] while start < end: mid = (start + end) // 2 if arr[mid] < val: start = mid + 1 else: end = mid return start def optimized_insertion_sort(arr: List[int], simulation: bool = False) -> List[int]: Sorts the list using enhanced insertion sort with early exit and binary search for position. n = len(arr) for i in range(1, n): current_value = arr[i] insertion_pos = binary_search_insert(arr, current_value, 0, i) # Early exit check if insertion_pos == i: continue # Shift elements to the right to make space for the current_value for j in range(i, insertion_pos, -1): arr[j] = arr[j - 1] arr[insertion_pos] = current_value if simulation: print(f\'iteration {i}:\', \' \'.join(map(str, arr))) return arr"},{"question":"Coin Change Dynamic Programming You are given an infinite supply of coins of different denominations, and your task is to determine the number of ways to make change for a given value. The order of the coins does not matter. Implement a function `count_combinations(coins, value)` that computes and returns the number of ways to make change for `value` cents using the given `coins`. Input 1. `coins` (List[int]): A list of integers representing the denominations of available coins. (e.g., [1, 2, 3]) 2. `value` (int): An integer representing the desired amount of money in cents. Output - An integer representing the number of ways to make the change for the given value. Constraints - All elements in `coins` are positive integers. - `value` is a non-negative integer. - You have an infinite supply of each coin in `coins`. Examples - Example 1: - Input: `coins = [1, 2, 3]`, `value = 4` - Output: `4` - Explanation: There are four ways to make change for 4: [1, 1, 1, 1], [1, 1, 2], [2, 2], [1, 3]. - Example 2: - Input: `coins = [2, 5, 3, 6]`, `value = 10` - Output: `5` - Explanation: There are five ways to make change for 10: [2, 2, 2, 2, 2], [2, 2, 3, 3], [2, 2, 6], [2, 3, 5], [5, 5]. Implementation Please write the implementation of the function `count_combinations(coins, value)` based on the provided input and output formats. ```python def count_combinations(coins, value): # Initialize dp array with a base case dp_array = [1] + [0] * value for coin in coins: for i in range(coin, value + 1): dp_array[i] += dp_array[i - coin] return dp_array[value] ``` Make sure to test your implementation with various edge cases and validate the performance within the given constraints.","solution":"def count_combinations(coins, value): Function that returns the number of ways to make change for \'value\' cents using the given \'coins\'. :param coins: List of integers representing the denominations of available coins. :param value: Integer representing the desired amount of money in cents. :return: Integer representing the number of ways to make change for \'value\' cents. # Initialize the dp array where dp[i] will store the number of ways to make change for \'i\' cents dp = [0] * (value + 1) # There is one way to make zero value i.e., to use no coins dp[0] = 1 # Update the dp array for each coin for coin in coins: for i in range(coin, value + 1): dp[i] += dp[i - coin] return dp[value]"},{"question":"# Context You are tasked with implementing an alternative addition function for an embedded system, where the \'+\' operator is either costly or unavailable due to constraints. The system primarily deals with unsigned 32-bit integers. # Problem Statement Write a function `add_without_plus(a: int, b: int) -> int` that takes two non-negative integers `a` and `b` and returns their sum without using the \'+\' operator. You must use bitwise operations. # Input and Output * **Input**: * `a (0 <= a < 2^31)` * `b (0 <= b < 2^31)` * **Output**: * The sum of `a` and `b`. # Constraints * Your function should handle cases where `a` or `b` is zero. * You may assume that the sum of the inputs will not exceed the maximum value for a signed 32-bit integer (2^31 - 1). * Aim to keep your solution efficient in both time and space. # Example ```python print(add_without_plus(2, 3)) # Output: 5 print(add_without_plus(15, 25)) # Output: 40 ``` # Notes 1. Remember to handle the carry correctly using bitwise operations. 2. Ensure the solution does not simply replicate the function of the \'+\' operator.","solution":"def add_without_plus(a: int, b: int) -> int: Returns the sum of a and b without using the \'+\' operator. Uses bitwise operations for the calculation. while b != 0: carry = a & b a = a ^ b b = carry << 1 return a"},{"question":"You are tasked with modifying a given Union-Find (Disjoint Set) data structure to handle a variant of the \\"Number of Islands\\" problem on a dynamic grid. Instead of a fixed-size grid, this problem involves a dynamically sized grid where land can be added in real-time. # Problem Statement: Given a series of addLand operations that add a piece of land to a grid dynamically, implement a function `num_islands_dynamically(positions)` that returns an updated count of islands after each land addition. An island is defined as a group of 1s (land) connected 4-directionally (horizontally or vertically). A position is provided as a list of tuples, where each tuple represents the coordinates (row, col) where land is added to the grid. Initially, the entire grid is water, and the grid expands dynamically as new lands are added. # Function Signature: ```python def num_islands_dynamically(positions): # Your implementation here ``` # Input: - `positions`: A list of tuples, `positions = [(0, 0), (0, 1), (1, 2), (2, 1)]`, where each tuple represents a land addition operation. # Output: - A list of integers, representing the number of islands in the grid after each land addition. # Example: ```python positions = [(0, 0), (0, 1), (1, 2), (2, 1)] print(num_islands_dynamically(positions)) # Output: [1, 1, 2, 3] ``` # Constraints: - The number of elements in `positions` will not exceed 10^4. - Each position will be a tuple of non-negative integers. # Performance Requirements: - Your solution should be efficient and handle the mentioned constraints gracefully. - Aim to keep the overall time complexity close to O(n), where n is the number of operations (due to the efficiency of the Union-Find structure). # Additional Requirements: - Ensure thorough testing of edge cases, such as adding land to already existing land positions. - Justify the complexity and correctness of your solution with comments and reasoning within the code.","solution":"class UnionFind: def __init__(self): self.parent = {} self.rank = {} self.count = 0 def add(self, x): if x not in self.parent: self.parent[x] = x self.rank[x] = 0 self.count += 1 def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) # Path compression return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: # Union by rank if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 self.count -= 1 def getCount(self): return self.count def num_islands_dynamically(positions): uf = UnionFind() directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] results = [] for pos in positions: if pos in uf.parent: results.append(uf.getCount()) continue uf.add(pos) for direction in directions: neighbor = (pos[0] + direction[0], pos[1] + direction[1]) if neighbor in uf.parent: uf.union(pos, neighbor) results.append(uf.getCount()) return results"},{"question":"# Flatten Nested Arrays You are given a nested array (or iterable) that may contain other arrays (or iterables). Your task is to flatten this array into a single, one-dimensional array. The function should recursively unroll the nested arrays till there are no more nested arrays left. You must implement two versions of the flattening process: 1. One using pure recursion. 2. One using a generator to yield the elements iteratively. # Function Signature ```python def flatten(input_arr: List[Any], output_arr: List[Any] = None) -> List[Any]: pass def flatten_iter(iterable: Iterable) -> Iterator[Any]: pass ``` # Input - `input_arr` (List[Any]): An array that contains nested arrays or iterables. - `iterable` (Iterable): A nested iterable structure. # Output - `flatten`: Returns a flat list containing all the elements of `input_arr`. - `flatten_iter`: Yields each element of `iterable` one at a time, producing the elements of the flattened structure. # Constraints - Elements in the input array can be integers, floats, strings, and any other iterables. - Strings are not considered iterables for the purpose of flattening. - You may assume the input data will not include cyclic references. # Examples ```python # Example 1 input_arr = [1, [2, [3, 4], 5], 6, [[7, 8], 9]] flatten(input_arr) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9] # Example 2 input_arr = [] flatten(input_arr) # Output: [] # Example 3 (Using generator) input_arr = [1, [2, \\"text\\", [3.5, (4, 5)], 6], 7, [[8, 9], 10]] list(flatten_iter(input_arr)) # Output: [1, 2, \'text\', 3.5, 4, 5, 6, 7, 8, 9, 10] ``` **Note**: Ensure that your function handles various nested levels and heterogeneously typed arrays efficiently.","solution":"from typing import List, Any, Iterable, Iterator def flatten(input_arr: List[Any], output_arr: List[Any] = None) -> List[Any]: if output_arr is None: output_arr = [] for element in input_arr: if isinstance(element, list): flatten(element, output_arr) else: output_arr.append(element) return output_arr def flatten_iter(iterable: Iterable) -> Iterator[Any]: for element in iterable: if isinstance(element, list): yield from flatten_iter(element) else: yield element"},{"question":"# Question: Next Higher Number with Same Digits You are given a non-negative integer `num`. Write a function `next_higher_number(num)` that returns the next higher number that contains the exact same set of digits. If no such number exists, return `-1`. Function Signature ```python def next_higher_number(num: int) -> int: ``` # Input - An integer `num` where ( 0 leq num leq 10^9 ). # Output - The next higher number with the same digits as `num`, or `-1` if no such number exists. # Constraints - You are not allowed to use any libraries for permutations. - Your solution should have a time complexity of O(n), where n is the number of digits in `num` and should optimize space usage. # Examples 1. `next_higher_number(38276)` → `38627` 2. `next_higher_number(54321)` → `-1` 3. `next_higher_number(12345)` → `12354` 4. `next_higher_number(1528452)` → `1528524` 5. `next_higher_number(999)` → `-1` # Scenario Suppose you\'re working on a feature in a software project that requires generating the next possible unique identifier from a given numerical identifier. This should be useful when identifiers need to maintain a certain order but should reuse the same set of digits. Implement the `next_higher_number` function by adhering to the guidelines provided above. Be sure to consider edge cases and optimize for performance.","solution":"def next_higher_number(num: int) -> int: digits = list(map(int, str(num))) n = len(digits) # Step 1: Find the first digit `i` that can be increased. i = n - 2 while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 if i == -1: return -1 # Step 2: Find the smallest digit `j` greater than `digits[i]` to the right of it. j = n - 1 while digits[j] <= digits[i]: j -= 1 # Step 3: Swap `digits[i]` and `digits[j]` digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the digits to the right of `i` digits = digits[:i + 1] + digits[i + 1:][::-1] return int(\\"\\".join(map(str, digits)))"},{"question":"# Question Given a list of integers `nums` which is sorted in ascending order and a target value `target`, write a function `find_range` to find the starting and ending positions of the given target value in the list. If the target value is not found, return `[-1, -1]`. Input - `nums`: List[int] (sorted in ascending order, 1 <= len(nums) <= 10^5) - `target`: int Output - List[int]: A list containing two integers representing the starting and ending positions of the target value. Constraints - Your solution must run in O(log n) time complexity for the range-finding algorithm. - The list `nums` may contain negative and positive integers. Example ``` Input: nums = [5,7,7,8,8,8,10], target = 8 Output: [3, 5] Input: nums = [5,7,7,8,8,8,10], target = 11 Output: [-1, -1] ``` Performance Requirements - Your function must handle up to 10^5 elements in the input list efficiently. Function Signature ```python def find_range(nums: List[int], target: int) -> List[int]: # Your code here and below comment line pass ```","solution":"from typing import List def find_range(nums: List[int], target: int) -> List[int]: def find_left(nums, target): Binary search helper function to find leftmost (first) index of target. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] < target: left = mid + 1 else: right = mid - 1 return left def find_right(nums, target): Binary search helper function to find rightmost (last) index of target. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] <= target: left = mid + 1 else: right = mid - 1 return right left_index = find_left(nums, target) right_index = find_right(nums, target) if left_index <= right_index and left_index < len(nums) and nums[left_index] == target: return [left_index, right_index] else: return [-1, -1]"},{"question":"Counting Connected Components in an Undirected Graph You are given an undirected graph represented as an adjacency list. Each node in the graph is labeled with an integer from 1 to N. Your task is to write a function that counts the number of connected components in this graph. **Function Signature:** ```python def count_connected_components(n: int, edges: List[Tuple[int, int]]) -> int: ``` **Input:** - `n`: The number of nodes in the graph (1 <= n <= 1000). - `edges`: A list of tuples representing the edges of the graph, where each tuple (u, v) indicates an undirected edge between nodes u and v. **Output:** - Return an integer representing the number of connected components in the graph. **Example:** ```python n = 7 edges = [(1, 2), (2, 4), (4, 5), (5, 6), (3, 7)] print(count_connected_components(n, edges)) # Output: 2 ``` **Explanation:** In the example, nodes 1, 2, 4, 5, and 6 form one connected component. Nodes 3 and 7 form another connected component. Thus, there are 2 connected components. **Constraints:** - 1 <= n <= 1000 - 0 <= len(edges) <= n * (n - 1) / 2 - 1 <= u, v <= n - The graph might be disconnected.","solution":"from typing import List, Tuple def count_connected_components(n: int, edges: List[Tuple[int, int]]) -> int: def dfs(node: int): stack = [node] while stack: current = stack.pop() if not visited[current]: visited[current] = True stack.extend(graph[current]) # Create adjacency list graph = [[] for _ in range(n + 1)] for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) count = 0 for i in range(1, n + 1): if not visited[i]: count += 1 dfs(i) return count"},{"question":"# Question: You are given a 1-dimensional array of integers representing financial transactions in a specific period. Your task is to find the maximum sum of a contiguous subsequence within this array, ensuring that the subsequence contains at least one positive integer to make a meaningful profit. # Constraints: - The array can have a length of up to (10^5). - Each element in the array is an integer and can range from (-10^4) to (10^4). # Function Signature: ```python def max_contiguous_subsequence_sum(arr: List[int]) -> int: ``` # Input: - `arr`: A list of integers representing financial transactions. # Output: - An integer representing the maximum sum of a contiguous subsequence with at least one positive component. # Examples: 1. **Input**: `[-2, 3, 8, -12, 8, 4]` - **Output**: `12` - **Explanation**: The maximum sum gains from the subsequence `[8, 4]`. 2. **Input**: `[-1, 1, 0]` - **Output**: `1` - **Explanation**: The maximum sum is just the single positive element `1`. 3. **Input**: `[-1, -3, -4]` - **Output**: `0` - **Explanation**: There\'s no positive element; hence no meaningful profit can be made, returning 0. 4. **Input**: `[1, 2, 3, 4]` - **Output**: `10` - **Explanation**: The entire array is the optimal subsequence. # Note: The subsequence must contain at least one positive integer to qualify as a valid, profitable subsequence. Otherwise, return `0` if no such subsequence exists.","solution":"from typing import List def max_contiguous_subsequence_sum(arr: List[int]) -> int: Finds the maximum sum of a contiguous subsequence that contains at least one positive integer. # Check for the presence of any positive integers if all(x <= 0 for x in arr): return 0 # Initialize variables to keep track of the maximum subsequence sum max_sum = float(\'-inf\') current_sum = 0 for num in arr: current_sum += num if num > 0: # Update max_sum only if the current number is positive or if current_sum > max_sum max_sum = max(max_sum, current_sum) if current_sum < 0: # Reset current_sum if it goes negative as it won\'t contribute positively in future sums current_sum = 0 return max_sum"},{"question":"**Context/Scenario**: You are working on an inventory management system where items have to be processed in a Last-In-First-Out (LIFO) manner. However, items have expiration dates and processing them in sorted order based on expiration dates can benefit the system. **Task**: Implement a class `OrderedStack` which ensures that items in the stack are always ordered such that the item with the latest expiration date is always on top. **Specifications**: 1. The `OrderedStack` class should include the following methods: * `__init__(self)`: Initializes an empty stack. * `is_empty(self)`: Returns `True` if the stack is empty, otherwise `False`. * `push(self, item)`: Inserts an `item` in such a way that the stack remains ordered. * `pop(self)`: Removes and returns the top item from the stack. * `peek(self)`: Returns the top item from the stack without removing it. * `size(self)`: Returns the number of elements in the stack. **Input/Output Requirements**: - `push(item)`: `item` is expected to be comparable (e.g., an integer or float representing date). - `pop()`: Returns the top item if the stack is not empty, otherwise raises an `IndexError` with message \\"Stack is empty\\". - `peek()`: Returns the top item without removing it, raises an `IndexError` with message \\"Stack is empty\\" if the stack is empty. - `is_empty()`: Returns a boolean indicating if the stack is empty. - `size()`: Returns an integer representing the number of elements in the stack. **Constraints**: - Assume all items are unique. - The stack can hold a reasonably large number of elements but should maintain efficiency for operations. Write the `OrderedStack` class based on the provided specifications.","solution":"class OrderedStack: def __init__(self): self.stack = [] def is_empty(self): return len(self.stack) == 0 def push(self, item): if self.is_empty(): self.stack.append(item) else: temp_stack = [] while not self.is_empty() and self.stack[-1] > item: temp_stack.append(self.pop()) self.stack.append(item) while temp_stack: self.stack.append(temp_stack.pop()) def pop(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.stack.pop() def peek(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.stack[-1] def size(self): return len(self.stack)"},{"question":"# Question: Implement an Enhanced Radix Sort **Background**: You are tasked with implementing an enhanced version of Radix Sort. This sort algorithm is particularly beneficial for sorting large datasets of fixed-length integers due to its linear time complexity under these circumstances. However, to leverage Radix Sort effectively, your implementation should handle several improvements and edge cases effectively. **Objective**: Write a function `enhanced_radix_sort(arr: List[int], simulation: bool = False) -> List[int]` that sorts an array of non-negative integers using Radix Sort. Your implementation must account for the edge cases and performance optimizations. Requirements: 1. **Input**: - `arr`: A list of non-negative integers to sort. - `simulation` (Optional): A boolean flag. If set to True, the function should print debug information on each iteration of the sorting. 2. **Output**: - A list of integers sorted in ascending order. 3. **Constraints**: - All integers in the array are non-negative. - Array size is determined by the problem constraints of up to (10^6) elements. 4. **Performance**: - The function should run efficiently with time complexity of O(nk + n) and handle large datasets up to the given constraint. 5. **Special Considerations**: - Handle empty arrays gracefully. - Optimize memory usage where possible. - Provide debug output for each iteration if `simulation` is set to True, showing the current state of the array. **Example**: ```python assert enhanced_radix_sort([170, 45, 75, 90, 802, 24, 2, 66]) == [2, 24, 45, 66, 75, 90, 170, 802] assert enhanced_radix_sort([5, 3, 8, 6, 2, 7, 4, 1]) == [1, 2, 3, 4, 5, 6, 7, 8] assert enhanced_radix_sort([]) == [] ``` *Note: Make sure your implementation handles edge cases like null or empty arrays, and large numbers efficiently. Also, include comments to explain the key steps in your implementation.*","solution":"from typing import List def enhanced_radix_sort(arr: List[int], simulation: bool = False) -> List[int]: Sorts a list of non-negative integers using Radix Sort with optional simulation/debugging. Args: arr (List[int]): The list of non-negative integers to sort. simulation (bool): If True, print debug information for each iteration. Returns: List[int]: The sorted list of integers in ascending order. if not arr: return [] max_num = max(arr) exp = 1 # We start with the least significant digit # Perform counting sort for every digit. while max_num // exp > 0: arr = counting_sort(arr, exp, simulation) exp *= 10 return arr def counting_sort(arr: List[int], exp: int, simulation: bool) -> List[int]: n = len(arr) output = [0] * n # output array that will hold the sorted array count = [0] * 10 # there are 10 possible values (0 to 9) for a digit # Store count of occurrences of each digit in the count array for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 # Change count[i] so that count[i] now contains the actual position of this digit in the output array for i in range(1, 10): count[i] += count[i - 1] # Build the output array using the count array for i in range(n - 1, -1, -1): index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 # Copy the output array to arr, so that arr contains sorted numbers according to current digit for i in range(n): arr[i] = output[i] if simulation: print(f\\"After sorting with exp={exp}, array is: {arr}\\") return arr"},{"question":"Problem Statement You are tasked with implementing an algorithm to check if a given non-empty string `s` can be constructed by repeating a substring of it. Your goal is to write a function `is_repeated_substring` that returns `True` if the string `s` can be constructed by repeating a substring of it, and `False` otherwise. Function Signature ```python def is_repeated_substring(s: str) -> bool: pass ``` Parameters - `s` (str): A non-empty string of lowercase alphabets. Returns - (bool): Return `True` if the string can be constructed by repeating a substring, otherwise return `False`. Constraints - The length of `s` will always be in the range [1, 10^5]. Example ```python assert is_repeated_substring(\\"abab\\") == True assert is_repeated_substring(\\"aba\\") == False assert is_repeated_substring(\\"abcabcabcabc\\") == True ``` Explanation of Examples 1. In the string \\"abab\\", the substring \\"ab\\" is repeated twice. 2. The string \\"aba\\" cannot be constructed by repeating any of its substrings. 3. The string \\"abcabcabcabc\\" is constructed by repeating the substring \\"abc\\" four times. Performance Requirement Your solution should aim for linear O(n) time complexity and O(n) space complexity given the constraints.","solution":"def is_repeated_substring(s: str) -> bool: Returns True if the string `s` can be constructed by repeating a substring of it, else False. # Edge case for single character string if len(s) == 1: return False # Create a new string which is s + s excluding the first and last characters new_s = (s + s)[1:-1] # If s is found in the newly created string then it can be constructed by repeating a substring return s in new_s"},{"question":"Enhanced Quick Sort Implementation **Scenario**: You have been hired by a tech company to optimize their data processing software. One critical module is responsible for sorting large datasets efficiently. The current implementation uses Quick Sort, and while performant, it encounters significant slowdowns in certain conditions, notably when dealing with nearly-sorted or uniform datasets. **Objective**: Improve the robustness and performance of the Quick Sort algorithm by implementing an optimized pivot selection strategy and efficient handling of edge cases. **Task**: Write a Python function `enhanced_quick_sort(arr)` that implements Quick Sort with the following enhancements: 1. **Pivot Selection**: Use the \'median-of-three\' strategy to choose the pivot. This involves picking the first, middle, and last elements of the array, sorting them, and using the median value as the pivot. 2. **Optimization for Small Arrays**: For small arrays (size <= 10), use Insertion Sort for improved performance. 3. **Edge Case Handling**: Ensure the function correctly handles arrays that are empty, contain one element, or are already sorted. **Function Signature**: ```python def enhanced_quick_sort(arr): pass ``` **Input Type**: * `arr`: List of integers to be sorted. **Output Type**: * Returns a new list with elements sorted in ascending order. **Constraints**: * Do not use any built-in sorting functions (like `sorted()` or `sort()`). * The algorithm should have a best and average-case time complexity of O(n log n) and handle the worst-case complexity as efficiently as possible. **Examples**: ```python assert enhanced_quick_sort([3, 6, 1, 5, 2, 4]) == [1, 2, 3, 4, 5, 6] assert enhanced_quick_sort([]) == [] assert enhanced_quick_sort([7]) == [7] assert enhanced_quick_sort([2, 2, 2, 2, 2]) == [2, 2, 2, 2, 2] ``` **Hints**: * Implement a helper function for the \'median-of-three\' pivot selection. * Use a hybrid sorting approach combining Quick Sort and Insertion Sort for optimization.","solution":"def insertion_sort(arr, left, right): for i in range(left + 1, right + 1): key = arr[i] j = i - 1 while j >= left and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def median_of_three(arr, left, right): mid = (left + right) // 2 a = arr[left] b = arr[mid] c = arr[right] if a > b: if a < c: return left elif b > c: return mid else: return right else: if a > c: return left elif b < c: return mid else: return right def quick_sort(arr, left, right): if right - left <= 10: insertion_sort(arr, left, right) return pivot_index = median_of_three(arr, left, right) arr[pivot_index], arr[right] = arr[right], arr[pivot_index] pivot = arr[right] i = left - 1 for j in range(left, right): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[right] = arr[right], arr[i + 1] pivot_index = i + 1 quick_sort(arr, left, pivot_index - 1) quick_sort(arr, pivot_index + 1, right) def enhanced_quick_sort(arr): if len(arr) <= 1: return arr arr_copy = arr[:] quick_sort(arr_copy, 0, len(arr_copy) - 1) return arr_copy"},{"question":"Context You are given two strings: `pattern` and `string`. Your goal is to determine if `string` follows the same pattern as dictated by `pattern`. Each character in `pattern` should map to a non-empty substring in `string`, such that no two characters in `pattern` map to the same substring in `string`. Instructions Write a function `does_follow_pattern(pattern: str, string: str) -> bool` that returns `True` if `string` follows `pattern`, and `False` otherwise. - You can assume both `pattern` and `string` contain only lowercase letters. Constraints - The length of `pattern` and `string` will be at most 16 each. - Characters in `pattern` map to substrings in `string` in a one-to-one mapping. Input - `pattern`: A string containing the pattern characters (1 ≤ len(pattern) ≤ 16). - `string`: A string against which the pattern should be matched (1 ≤ len(string) ≤ 16). Output - Return a boolean value `True` if `string` follows `pattern`, otherwise `False`. Example Cases 1. Example 1: - Input: `pattern = \\"abab\\"`, `string = \\"redblueredblue\\"` - Output: `True` - Explanation: \'a\' maps to \\"red\\", \'b\' maps to \\"blue\\". 2. Example 2: - Input: `pattern = \\"aaaa\\"`, `string = \\"asdasdasdasd\\"` - Output: `True` - Explanation: \'a\' consistently maps to \\"asd\\". 3. Example 3: - Input: `pattern = \\"aabb\\"`, `string = \\"xyzabcxyzabc\\"` - Output: `False` - Explanation: There is no consistent mapping such that each character in the pattern matches with the specified substrings. Function Signature ```python def does_follow_pattern(pattern: str, string: str) -> bool: # Your implementation here ```","solution":"def does_follow_pattern(pattern: str, string: str) -> bool: # Helper function for backtracking def backtrack(pattern_idx, string_idx, mapping, used_substrings): if pattern_idx == len(pattern) and string_idx == len(string): return True if pattern_idx == len(pattern) or string_idx == len(string): return False pattern_char = pattern[pattern_idx] for end in range(string_idx + 1, len(string) + 1): substring = string[string_idx:end] if pattern_char in mapping: if mapping[pattern_char] == substring: if backtrack(pattern_idx + 1, end, mapping, used_substrings): return True else: if substring in used_substrings: continue mapping[pattern_char] = substring used_substrings.add(substring) if backtrack(pattern_idx + 1, end, mapping, used_substrings): return True del mapping[pattern_char] used_substrings.remove(substring) return False return backtrack(0, 0, {}, set())"},{"question":"You have been hired to enhance a text processing system. One of your tasks is to implement a function that removes duplicate characters from a given string, retaining only the first occurrences and the order of characters. Function Signature ```python def remove_duplicates(input_string: str) -> str: ``` Input * A single string `input_string` (1 ≤ `input_string` length ≤ 10^6) composed of ASCII characters. Output * A new string with all duplicate characters removed, keeping only their first occurrences and maintaining the order. Constraints * The function should be efficient with a linear time complexity, O(n). * You should consider edge cases including: - Empty input string. - String with all identical characters. - String with no duplicates. Example ```python assert remove_duplicates(\\"programming\\") == \\"progamin\\" assert remove_duplicates(\\"\\") == \\"\\" assert remove_duplicates(\\"aabbcc\\") == \\"abc\\" assert remove_duplicates(\\"abcdef\\") == \\"abcdef\\" ``` # Requirements The function must: * Use efficient time and space complexity. * Handle large input sizes up to the given limit. * Maintain the order of first occurrences of characters.","solution":"def remove_duplicates(input_string: str) -> str: Removes duplicate characters from a given string, retaining only the first occurrences and maintaining the order. Args: input_string (str): The input string from which to remove duplicate characters. Returns: str: A new string with all duplicate characters removed. seen = set() result = [] for char in input_string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"In this task, you are to design a function based on the given `Stutter` algorithm. Specifically, you will implement a function `stutter_stack` that takes a stack as an input and replaces every value in the stack with two occurrences of that value. Your solution will require you to demonstrate an understanding of both stack and queue data structures. # Function Signature ```python def stutter_stack(stack: list) -> list: ``` # Input * `stack`: A list of integers representing a stack. The last element of the list is considered the top of the stack, and the first element is the bottom of the stack. The input stack can be empty. # Output * The return should be a list representing the modified stack where every element is duplicated. The structure and order of the stack must be preserved as described. # Constraints * The input stack can have at most (10^5) integers. * Each integer in the stack can be in the range ([-10^9, 10^9]). # Example ```python # Example 1: stack = [3, 7, 1, 14, 9] print(stutter_stack(stack)) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] # Example 2: stack = [] print(stutter_stack(stack)) # Output: [] # Example 3: stack = [5] print(stutter_stack(stack)) # Output: [5, 5] ``` # Explanation * In Example 1, the `stutter_stack` function duplicates each element resulting in the transformation from [3, 7, 1, 14, 9] to [3, 3, 7, 7, 1, 1, 14, 14, 9, 9]. * Example 2 demonstrates that an empty stack remains unchanged. * Example 3 shows duplication of a single element stack. Your task is to implement the `stutter_stack` function in Python.","solution":"def stutter_stack(stack: list) -> list: Duplicates each element in the given stack. Parameters: stack (list): A list of integers representing the stack. Returns: list: A list where each element in the original stack is duplicated. result = [] for elem in stack: result.append(elem) result.append(elem) return result"},{"question":"You are tasked with implementing a function to ensure you can reliably determine the absolute path of any given file. The function should handle various user inputs such as relative paths, paths with user directory references (`~`), and already absolute paths. Additionally, the function should verify that the resolved path actually exists. Objective: Write a function `resolve_absolute_path` that takes a single string input `file_path` and resolves it to an absolute path. If the file at the given path does not exist, raise a `FileNotFoundError`. Function Signature: ```python def resolve_absolute_path(file_path: str) -> str: pass ``` Input: - `file_path`: A string representing the file path. It can be an absolute path, a relative path, or contain user directory references (`~`). Output: - Returns a string representing the absolute path of the file. Constraints: - The path should be resolved and verified to exist on the local filesystem. - The function should raise a `FileNotFoundError` if the file does not exist. Examples: ```python # Example 1 resolve_absolute_path(\\"~/documents/report.txt\\") # Returns: \'/home/user/documents/report.txt\' (assuming /home/user is the user\'s home directory and the file exists) # Example 2 resolve_absolute_path(\\"../../../somefile\\") # Returns: \'/absolute/path/to/somefile\' (if the file exists) # Example 3 resolve_absolute_path(\\"/absolute/path/to/somefile\\") # Returns: \'/absolute/path/to/somefile\' (if the file exists) # Example 4 resolve_absolute_path(\\"/nonexistent/file\\") # Raises FileNotFoundError ``` Note: - Consider using Python\'s `os.path` functionalities to handle path expansions and absolute conversions. - Ensure that you check the existence of the file before returning the path.","solution":"import os def resolve_absolute_path(file_path: str) -> str: Resolves and returns the absolute path of the given file_path. If the file does not exist, raises a FileNotFoundError. # Expand user home (~) and convert to absolute path abs_path = os.path.abspath(os.path.expanduser(file_path)) # Check if the path exists if not os.path.exists(abs_path): raise FileNotFoundError(f\\"The file {abs_path} does not exist.\\") return abs_path"},{"question":"# Question: You are helping to develop a digital scoreboard for a sporting event. The scoreboard needs to display the number of digits of the score accurately and quickly. Implement a Python function `scoreboard_digits(n)` to determine the number of digits in a given integer score. The function must consider the following requirements: * The input is a single integer `n` which can be a positive or negative integer, including zero. * The function should return an integer representing the number of digits in the input number. Your task is to: 1. Handle both positive and negative integers, including zero. 2. Ensure the function runs in constant time complexity. 3. Avoid importing any unnecessary modules or using inefficient operations. # Input: * An integer `n` (-10^9 <= n <= 10^9) # Output: * An integer corresponding to the number of digits in the given number. # Example: ```python assert scoreboard_digits(12345) == 5 assert scoreboard_digits(0) == 1 assert scoreboard_digits(-54321) == 5 ``` # Constraints: 1. The input integer `n` will be between -10^9 and 10^9. 2. Your function should complete in O(1) time complexity. You should implement the following function: ```python def scoreboard_digits(n): # Your implementation here ```","solution":"def scoreboard_digits(n): Returns the number of digits in the given integer n. Handles both positive and negative integers, including zero. # Convert the number to string and take absolute value to ignore the minus sign return len(str(abs(n)))"},{"question":"In the context of graph theory, a bipartite graph is a graph whose vertices can be divided into two disjoint and independent sets U and V such that every edge connects a vertex in U to one in V. Given an adjacency matrix representation of a graph, write a function `is_bipartite(adj_matrix)` to determine if the graph is bipartite. # Input * `adj_matrix` (list of list of int): The adjacency matrix of the graph where `adj_matrix[i][j] = 1` means there is an edge between vertex i and vertex j, and `adj_matrix[i][j] = 0` means there is no edge. # Output * `bool`: Return `True` if the graph is bipartite, `False` otherwise. # Constraints * The number of vertices `V` is between 1 and 1000. * The adjacency matrix is a square matrix where each element is either 0 or 1. * The graph might be disconnected, in which case, each connected component must be bipartite. # Example ```python def is_bipartite(adj_matrix): # Your implementation here # Example Usage adj_matrix = [ [0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0] ] print(is_bipartite(adj_matrix)) # Output: True ``` # Explanation In the given example, the graph can be divided into two sets {[0,2], [1,3]} with edges only between the sets and not within them, making it a bipartite graph. # Guidelines * Consider edge cases such as graphs with self-loops, disconnected components, and odd-length cycles. * Ensure algorithm efficiency, given the constraints on the size of the graph.","solution":"def is_bipartite(adj_matrix): Determines if a given graph represented by an adjacency matrix is bipartite. Parameters: adj_matrix (list of list of int): The adjacency matrix of the graph. Returns: bool: True if the graph is bipartite, False otherwise. V = len(adj_matrix) color = [-1] * V # Use -1 for uncolored, 0 and 1 for two different colors def bfs(start): queue = [start] color[start] = 0 while queue: u = queue.pop(0) for v in range(V): if adj_matrix[u][v] == 1: if color[v] == -1: color[v] = 1 - color[u] queue.append(v) elif color[v] == color[u]: return False return True for i in range(V): if color[i] == -1: if not bfs(i): return False return True"},{"question":"# Permutation Generation Problem You are required to implement a function that generates all possible permutations of a given list of distinct integers. Given the high complexity, you are also required to implement an optimized solution utilizing in-place swaps and iterative backtracking. # Function Signature ```python def generate_permutations(nums: List[int]) -> List[List[int]]: pass ``` # Input - `nums`: A list of distinct integers, with `1 <= len(nums) <= 8`. # Output - Returns a list of lists, where each inner list is a permutation of the input list `nums`. # Constraints - You must avoid using additional memory proportional to the number of permutations. - Focus on in-place swaps and iterative backtracking to optimize for space. # Example ```python generate_permutations([1, 2, 3]) # Expected Output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] ``` # Notes * The input list size will not exceed 8 to ensure manageable computation. * Your solution should handle edge cases like an empty list or a single element list properly. * Ensure the function adheres to time and space constraints.","solution":"from typing import List def generate_permutations(nums: List[int]) -> List[List[int]]: def backtrack(start): if start == len(nums): result.append(nums[:]) for i in range(start, len(nums)): nums[start], nums[i] = nums[i], nums[start] backtrack(start + 1) nums[start], nums[i] = nums[i], nums[start] result = [] backtrack(0) return result"},{"question":"# Eudoxus Numbers Identification **Overview**: According to mathematical properties, certain numbers called Eudoxus numbers (similar to the special numbers in the provided scenario) have a unique characteristic: they are equal to the sum of their digits raised to consecutive powers starting from 1. For example, 89 is a Eudoxus number because 8^1 + 9^2 = 89. **Objective**: Write a function `find_eudoxus_numbers(low: int, high: int) -> List[int]` that returns a list of all Eudoxus numbers within a given inclusive range `[low, high]`. **Function Signature**: ```python def find_eudoxus_numbers(low: int, high: int) -> List[int]: ``` **Input**: * `low`: an integer representing the lower bound of the range (inclusive). * `high`: an integer representing the upper bound of the range (inclusive). **Output**: * A list of integers representing all Eudoxus numbers within the specified range `[low, high]`. **Constraints**: * `1 <= low <= high <= 10^6` * The function should be efficient enough to handle large ranges up to 10^6. * Focus on readability and performance optimization where possible. # Example ```python assert find_eudoxus_numbers(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert find_eudoxus_numbers(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert find_eudoxus_numbers(50, 150) == [89, 135] ``` # Scenarios to Consider: 1. Ensure your function handles the case where the range includes a single number. 2. Consider edge cases where numbers are at the very edge of the range (upper bound). 3. Optimize for ranges that cover multiple digits (e.g., testing from 100 to 10^6). **Notes**: * You may not use any third-party libraries; only standard Python libraries are allowed. * Efficient code that considers both space and time complexity will be graded higher.","solution":"from typing import List def find_eudoxus_numbers(low: int, high: int) -> List[int]: def is_eudoxus_number(n: int) -> bool: digits = [int(d) for d in str(n)] sum_of_powers = sum(digits[i]**(i+1) for i in range(len(digits))) return n == sum_of_powers return [num for num in range(low, high + 1) if is_eudoxus_number(num)]"},{"question":"Objective: Design a function to identify a unique element in an array of integers where every element appears exactly three times except for one. Problem Statement: You are given an array of integers where every element appears exactly three times except one element, which appears exactly once. Your task is to write a function `find_unique_number` that finds and returns this unique element. The solution must have a linear runtime complexity and should not use extra memory. Function Signature: ```python def find_unique_number(nums: [int]) -> int: pass ``` Input: * A list, `nums`, of integers where `1 <= len(nums) <= 10^5` and `-2^31 <= nums[i] <= 2^31 - 1`. Output: * An integer representing the unique number that appears exactly once. Constraints: * The array contains integers where every element appears exactly three times except for one. Example: ```python assert find_unique_number([2, 2, 3, 2]) == 3 assert find_unique_number([0, 1, 0, 1, 0, 1, 99]) == 99 assert find_unique_number([-2, -2, -2, -5]) == -5 ``` Performance Expectation: * Time Complexity: O(n) * Space Complexity: O(1) Notes: * Make sure to consider edge cases such as arrays with minimum length. * Do not use extra memory beyond primitive variables. Solution Approach: Use bit manipulation to count occurrences of bits in all numbers and employ modulo operations to isolate the bits of the unique number.","solution":"def find_unique_number(nums): Identify the unique element in an array where every element appears exactly three times except for one. Args: nums (list): List of integers where every element appears exactly three times except one. Returns: int: The unique element. ones, twos = 0, 0 for num in nums: # see links (1) and (2) for explanation # twos should also exclude \'ones\' twos = twos | (ones & num) ones = ones ^ num not_threes = ~(ones & twos) ones &= not_threes twos &= not_threes return ones"},{"question":"# Cosine Similarity Calculation with Additional Features Context Given the function `cosine_similarity`, which calculates the cosine similarity between two vectors, you are to extend this function with additional features to handle more edge cases and optimize for performance. Task Modify the `cosine_similarity` function to handle the following: 1. **Normalization**: Before calculating the cosine similarity, normalize the vectors to ensure they are non-zero. 2. **Performance**: Optimize the function to handle large vectors (length might be in the order of 10^6). 3. **Edge Case Handling**: If any of the vectors has all elements as zero, return a similarity of 0. Requirements * Implement the function `cosine_similarity_extended` with the following signature: ```python def cosine_similarity_extended(vec1, vec2): # Your implementation here ``` * **Input**: * `vec1` and `vec2`: Two lists of integers or floats with the same length `n`. * **Output**: * A float indicating the cosine similarity between `vec1` and `vec2`. * **Constraints**: * 1 <= len(vec1) = len(vec2) <= 10^6 * Elements of vec1 and vec2 are in the range [-10^3, 10^3] * **Performance**: * Aim to optimize time complexity to O(n) while keeping space complexity to O(1). Example ```python cosine_similarity_extended([1, 1, 1], [1, 2, -1]) # Output: 0.47140452079103173 cosine_similarity_extended([0, 0, 0], [1, 2, 3]) # Output: 0.0 cosine_similarity_extended([0, 0, 0], [0, 0, 0]) # Output: 0.0 ```","solution":"import math def cosine_similarity_extended(vec1, vec2): Calculates the cosine similarity between two vectors with additional features: 1. Normalization 2. Performance optimization for large vectors 3. Handling edge cases for zero vectors. if len(vec1) != len(vec2): raise ValueError(\\"Vectors must be of the same length\\") # Calculate dot product and magnitudes dot_product = 0 magnitude_vec1 = 0 magnitude_vec2 = 0 for i in range(len(vec1)): dot_product += vec1[i] * vec2[i] magnitude_vec1 += vec1[i] ** 2 magnitude_vec2 += vec2[i] ** 2 # Compute the magnitudes magnitude_vec1 = math.sqrt(magnitude_vec1) magnitude_vec2 = math.sqrt(magnitude_vec2) # Check for zero magnitude and handle edge cases if magnitude_vec1 == 0 or magnitude_vec2 == 0: return 0.0 # Calculate cosine similarity return dot_product / (magnitude_vec1 * magnitude_vec2)"},{"question":"**Binary Search Tree implementation and traversal** **Scenario**: You are hired by a company that deals with large datasets. They require an efficient way to store and retrieve integer data while maintaining them in a sorted manner. You decide to use a binary search tree for this purpose. Your BST should support the following functionalities efficiently: insertion, search, size calculation, and traversal. **Task**: Implement a Binary Search Tree (BST) with the following methods: 1. **Insert**: Inserts an integer into the BST. 2. **Search**: Returns True if the integer is in the BST, otherwise returns False. 3. **Size**: Returns the number of elements in the BST. 4. **Traversal**: Returns a list of elements in: - Inorder - Preorder - Postorder **Input Format**: - For insertions: single integer values. - For searches: single integer values. - For traversal functions: No input required. **Output Format**: - For insertions: boolean indicating success/failure (True if inserted, False if duplicate). - For searches: boolean indicating presence of the integer in the tree (True if found, False if not). - For size: integer representing the count of elements in the BST. - For traversals: list of integers representing the BST elements in specified order. **Example**: Suppose you create an instance of your BST and perform the following operations: ```python tree = BST() tree.insert(10) tree.insert(15) tree.insert(6) tree.insert(4) tree.insert(9) tree.insert(12) tree.insert(24) tree.insert(7) tree.insert(20) tree.insert(30) tree.insert(18) print(tree.search(24)) # Output: True print(tree.search(50)) # Output: False print(tree.size()) # Output: 11 print(tree.inorder()) # Output: [4, 6, 7, 9, 10, 12, 15, 18, 20, 24, 30] print(tree.preorder()) # Output: [10, 6, 4, 9, 7, 15, 12, 24, 20, 18, 30] print(tree.postorder()) # Output: [4, 7, 9, 6, 12, 18, 20, 30, 24, 15, 10] ``` **Constraints**: - Assume integers can be negative and positive. - Assume no duplicate insertions are allowed; return `False` for any attempt to insert a duplicate. - Implement these methods as part of a class BST with the setup similar to the provided snippet\'s structure. **Performance Requirements**: - Aim for average time complexity of O(log N) for search and insert operations. - Optimize traversal methods for O(N) time complexity.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None self._size = 0 def insert(self, key): if self.root is None: self.root = Node(key) self._size += 1 return True else: return self._insert(self.root, key) def _insert(self, node, key): if key < node.val: if node.left is None: node.left = Node(key) self._size += 1 return True else: return self._insert(node.left, key) elif key > node.val: if node.right is None: node.right = Node(key) self._size += 1 return True else: return self._insert(node.right, key) else: return False # Duplicate key def search(self, key): return self._search(self.root, key) def _search(self, node, key): if node is None: return False if node.val == key: return True elif key < node.val: return self._search(node.left, key) else: return self._search(node.right, key) def size(self): return self._size def inorder(self): result = [] self._inorder(self.root, result) return result def _inorder(self, node, result): if node: self._inorder(node.left, result) result.append(node.val) self._inorder(node.right, result) def preorder(self): result = [] self._preorder(self.root, result) return result def _preorder(self, node, result): if node: result.append(node.val) self._preorder(node.left, result) self._preorder(node.right, result) def postorder(self): result = [] self._postorder(self.root, result) return result def _postorder(self, node, result): if node: self._postorder(node.left, result) self._postorder(node.right, result) result.append(node.val)"},{"question":"# Querying and Updating a Frequency Table using Fenwick Tree You are provided with a list of integers representing frequencies of certain events. Your task is to implement a class `FenwickTree` to efficiently perform the following operations using a Fenwick Tree (Binary Indexed Tree): 1. **Update the frequency** of a specified element in the list. 2. **Compute the cumulative sum** (prefix sum) of the first `i` elements. # Function Signatures - `__init__(self, freq: List[int]) -> None`: constructor to initialize the Fenwick Tree with the given frequency list. - `update(self, i: int, value: int) -> None`: method to update the element at index `i` to a new `value`. - `prefix_sum(self, i: int) -> int`: method to return the cumulative sum of the first `i` elements. # Input and Output Formats 1. The constructor `__init__` takes a list `freq` of integers. 2. The `update` method takes an index `i` (0-based) and a new `value`, and updates the element at index `i` to this new `value`. 3. The `prefix_sum` method takes an index `i` (0-based) and returns the sum of the first `i+1` elements (equivalent to `freq[0] + freq[1] + ... + freq[i]`). # Constraints - 1 <= len(freq) <= 10^5 - 0 <= i < len(freq) - -10^9 <= value <= 10^9 # Example ```python # Creating the Fenwick Tree with initial frequencies freq = [1, 7, 3, 0, 5, 8, 3, 6, 2, 6] ft = FenwickTree(freq) # Querying prefix sums print(ft.prefix_sum(5)) # Output should be 24 (1+7+3+0+5+8) print(ft.prefix_sum(8)) # Output should be 35 (1+7+3+0+5+8+3+6+2) # Updating element at index 3 to new value 6 ft.update(3, 6) # Querying prefix sums after update print(ft.prefix_sum(5)) # Output should be 30 (1+7+3+6+5+8) print(ft.prefix_sum(8)) # Output should be 41 (1+7+3+6+5+8+3+6+2) ``` # Explanation In the example provided: - We initialize the Fenwick Tree with the given frequency list. - We perform prefix sum queries to calculate cumulative sums of the first few elements. - We update a specific element and perform further queries to verify the update. Implement the `FenwickTree` class as per the specifications above.","solution":"class FenwickTree: def __init__(self, freq): Initializes the Fenwick Tree with the given frequency list. self.n = len(freq) self.tree = [0] * (self.n + 1) for i, value in enumerate(freq): self._add(i + 1, value) self.original = freq[:] # store original freq for update purpose def update(self, i, new_value): Updates the element at index `i` to `new_value`. delta = new_value - self.original[i] self.original[i] = new_value self._add(i + 1, delta) def prefix_sum(self, i): Returns the cumulative sum of the first `i` elements. return self._sum(i + 1) def _add(self, i, delta): Increases value of `i`-th element by `delta`. while i <= self.n: self.tree[i] += delta i += i & -i def _sum(self, i): Returns the sum of the first `i` elements. total = 0 while i > 0: total += self.tree[i] i -= i & -i return total"},{"question":"# Question: Implement and Extend Ordered Stack Context You are tasked with maintaining an ordered stack that keeps elements sorted. This stack supports the classic stack operations (`push`, `pop`, `peek`, `is_empty`), along with maintaining a sorted order invariant. Task 1. **Correct any issues** in the provided `OrderedStack` implementation. Make sure it works correctly for all input scenarios and edge cases. 2. **Extend the functionality** to include a `merge` method that merges another `OrderedStack` into the current one while maintaining the order. Function Requirements 1. **push**: Adds an item to the stack, maintaining the sorted order. 2. **pop**: Removes and returns the item from the top of the stack. 3. **peek**: Returns the item at the top of the stack without removing it. 4. **is_empty**: Returns whether the stack is empty. 5. **merge**: Takes another `OrderedStack` and merges its elements into the current stack, keeping the overall order. Expected Input and Output Formats * `push(item)`: Takes a single element `item` (integer) and adds it to the stack. Does not return anything. * `pop() -> int`: Returns the integer element at the top of the stack. * `peek() -> int`: Returns the integer element at the top of the stack without removing it. * `is_empty() -> bool`: Returns `True` if the stack is empty, otherwise `False`. * `merge(other_stack: OrderedStack) -> None`: Merges another `OrderedStack` into the current stack. Constraints * Assume all elements are integers. * Elements in the stack are unique. * `merge` operation should be efficient and maintain the sorted order without converting stacks to other data structures for sorting. Example ```python os = OrderedStack() os.push(10) os.push(5) os.push(30) # Stack now is [5, 10, 30] print(os.pop()) # Output: 30 print(os.peek()) # Output: 10 os2 = OrderedStack() os2.push(15) os2.push(25) os.merge(os2) # The combined stack should now be [5, 10, 15, 25] print(os.pop()) # Output: 25 print(os.pop()) # Output: 15 ```","solution":"class OrderedStack: def __init__(self): self.stack = [] def push(self, item): Adds an item to the stack, maintaining the sorted order. if self.is_empty() or item >= self.stack[-1]: self.stack.append(item) else: temp_stack = [] while not self.is_empty() and self.stack[-1] > item: temp_stack.append(self.pop()) self.stack.append(item) while temp_stack: self.push(temp_stack.pop()) def pop(self): Removes and returns the item from the top of the stack. if self.is_empty(): return None return self.stack.pop() def peek(self): Returns the item at the top of the stack without removing it. if self.is_empty(): return None return self.stack[-1] def is_empty(self): Returns whether the stack is empty. return len(self.stack) == 0 def merge(self, other_stack): Merges another OrderedStack into the current stack, keeping the overall order. temp = [] while not other_stack.is_empty(): temp.append(other_stack.pop()) while temp: self.push(temp.pop())"},{"question":"# Question You are given an unsorted singly linked list where each node contains a character value. Your task is to write a function that removes all duplicate nodes from the list. You will implement two functions with different constraints, described as follows: 1. **Using extra space**: Write a function `remove_duplicates_with_set(head)` that removes duplicates using an additional data structure (e.g., set or dictionary) to track occurrences of each element. 2. **Without using extra space**: Write a function `remove_duplicates_without_set(head)` that removes duplicates without using any additional data structures, aside from standard variable storage. # Input and Output Formats - **Input**: The input will be the head node of a singly linked list. - **Output**: The same linked list without duplicates, modified in place. # Constraints - The characters in the list can be any valid characters. - Do not use any built-in functions that directly solve the problem. - You need to consider edge cases such as: * An empty linked list. * A linked list with only one element. * A linked list with all identical elements. * A linked list with no duplicates. # Function Signatures: ```python class Node(): def __init__(self, val=None): self.val = val self.next = None def remove_duplicates_with_set(head: Node) -> None: pass def remove_duplicates_without_set(head: Node) -> None: pass ``` # Example ```python # Create linked list: A -> A -> B -> C -> D -> C -> F -> G a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g # Remove duplicates using set remove_duplicates_with_set(a1) # Output should print: A -> B -> C -> D -> F -> G # Create the linked list again: A -> A -> B -> C -> D -> C -> F -> G a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g # Remove duplicates without using set remove_duplicates_without_set(a1) # Output should print: A -> B -> C -> D -> F -> G ``` # Note Your solution should maintain the original order of elements and modify the linked list in place. Make sure to test your functions on various edge cases to ensure robustness.","solution":"class Node(): def __init__(self, val=None): self.val = val self.next = None def remove_duplicates_with_set(head: Node) -> None: if not head: return current = head seen_values = set() seen_values.add(current.val) while current.next: if current.next.val in seen_values: current.next = current.next.next else: seen_values.add(current.next.val) current = current.next def remove_duplicates_without_set(head: Node) -> None: if not head: return current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"# Directed Graph - Cycle Detection Objective You are given a directed graph implemented with nodes, edges, and an adjacency list. Your task is to implement a function to detect if there\'s a cycle in the graph or not. A cycle in a directed graph occurs if there is a path from a node back to itself traversing the directed edges. Detailed Explanation * **Function Specification**: Implement a function `has_cycle(self)`, where `self` refers to an instance of the `DirectedGraph` class. * **Input**: No new additional input aside from the class methods. The graph will already be formed using the `DirectedGraph` class implementation shared. * **Output**: * Return `True` if there is at least one cycle in the graph. * Return `False` if the graph has no cycles. * **Constraints**: * Nodes are named with unique identifiers. * The graph is represented using the provided `DirectedGraph` class. * **Performance Requirements**: The solution should be optimized for scenarios where there could be a large number of nodes and edges. Hint To detect a cycle, you can use the Depth-First Search (DFS) approach where you maintain a recursion stack to track nodes visited in the current path. If a node is revisited that\'s already in the stack, a cycle exists. Example Consider the graph with the following adjacency list: ``` { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'A\'], \'D\': [] } ``` In this case, the graph has a cycle: A -> B -> C -> A. The `has_cycle` function should return `True`. ```python class DirectedGraph: # Existing implementation... # including Node and DirectedEdge classes def has_cycle(self): Detect if the graph has any cycle. :return: bool # Implement the function here pass # Example test case graph_dict = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'A\'], \'D\': [] } graph = DirectedGraph(graph_dict) print(graph.has_cycle()) # Output should be True ``` Notes * Ensure to handle graphs with disconnected nodes. * Validate with multiple cases such as linear connections without cycles, graphs with a single node self-loop, and complex interconnected nodes with and without cycles.","solution":"class DirectedGraph: def __init__(self, adjacency_list): self.graph = adjacency_list def has_cycle_util(self, node, visited, rec_stack): visited[node] = True rec_stack[node] = True for neighbor in self.graph.get(node, []): if not visited[neighbor]: if self.has_cycle_util(neighbor, visited, rec_stack): return True elif rec_stack[neighbor]: return True rec_stack[node] = False return False def has_cycle(self): visited = {node: False for node in self.graph} rec_stack = {node: False for node in self.graph} for node in self.graph: if not visited[node]: if self.has_cycle_util(node, visited, rec_stack): return True return False"},{"question":"Context A queue is a fundamental data structure in computer science that follows the First-In-First-Out (FIFO) principle. Two common ways to implement a queue are through arrays and linked lists. While the array-based implementation can be simple, managing its size can be challenging. On the other hand, the linked list implementation handles dynamic sizes gracefully but incurs additional memory overhead for pointers. Problem Statement You are required to implement a specialized `Queue` class, combining the advantages of both array and linked list implementations. The queue should start with an array of fixed size and, upon reaching its capacity, switch to a linked list implementation. Requirements 1. Implement a `HybridQueue` class that starts as an array-based queue. 2. When the array-based queue exceeds a specified capacity, switch to a linked list-based queue. 3. Implement the following methods in `HybridQueue`: - `enqueue(self, value)`: Adds a new item to the queue. - `dequeue(self)`: Removes the front item from the queue. - `peek(self)`: Returns the front element without removing it. - `isEmpty(self)`: Checks if the queue is empty. - `size(self)`: Returns the number of items in the queue. Constraints - Starting capacity for the array: `capacity = 10`. - You must handle overflows by transitioning to a linked list. - The methods should exhibit expected time complexities on average. Input and Output Formats - Input: Operations on `HybridQueue` as method calls. - Output: Return values from methods such as `dequeue`, `peek`, `size`, etc. Example ```python hq = HybridQueue() hq.enqueue(1) hq.enqueue(2) print(hq.dequeue()) # Output: 1 print(hq.peek()) # Output: 2 print(hq.size()) # Output: 1 for i in range(3, 14): hq.enqueue(i) hq.enqueue(14) print(hq.dequeue()) # Output: 2 (should handle transition to linked list) ``` Implementation Provide a well-documented and thoroughly tested implementation of the `HybridQueue` class.","solution":"class Node: def __init__(self, value=None, next=None): self.value = value self.next = next class LinkedListQueue: def __init__(self): self.front = None self.rear = None self._size = 0 def enqueue(self, value): new_node = Node(value) if not self.rear: self.front = self.rear = new_node else: self.rear.next = new_node self.rear = new_node self._size += 1 def dequeue(self): if not self.front: raise IndexError(\'dequeue from empty queue\') value = self.front.value self.front = self.front.next if not self.front: self.rear = None self._size -= 1 return value def peek(self): if not self.front: raise IndexError(\'peek from empty queue\') return self.front.value def isEmpty(self): return self._size == 0 def size(self): return self._size class HybridQueue: def __init__(self, capacity=10): self.array_queue = [] self.capacity = capacity self.linked_list_queue = None def enqueue(self, value): if self.linked_list_queue is not None: self.linked_list_queue.enqueue(value) else: if len(self.array_queue) < self.capacity: self.array_queue.append(value) else: self.linked_list_queue = LinkedListQueue() while self.array_queue: self.linked_list_queue.enqueue(self.array_queue.pop(0)) self.linked_list_queue.enqueue(value) def dequeue(self): if self.linked_list_queue is not None: return self.linked_list_queue.dequeue() else: if not self.array_queue: raise IndexError(\'dequeue from empty queue\') return self.array_queue.pop(0) def peek(self): if self.linked_list_queue is not None: return self.linked_list_queue.peek() else: if not self.array_queue: raise IndexError(\'peek from empty queue\') return self.array_queue[0] def isEmpty(self): if self.linked_list_queue is not None: return self.linked_list_queue.isEmpty() else: return len(self.array_queue) == 0 def size(self): if self.linked_list_queue is not None: return self.linked_list_queue.size() else: return len(self.array_queue)"},{"question":"You are tasked to implement a function that checks if a given non-empty string can be formed by taking a substring of it and repeating the substring multiple times. This problem evaluates your understanding of string manipulation and pattern recognition. Function Signature ```python def can_form_repeated_substring(s: str) -> bool: ``` Input * `s` (str): a non-empty string where the substring repetition should be checked. (1 <= len(s) <= 10^4) Output * Returns `True` if the string can be formed by repeating a substring, `False` otherwise. Constraints * The input string `s` will contain only lowercase English letters. Performance Requirements * The solution must run with a time complexity of O(n), where n is the length of the string. * The space complexity should be optimized to O(n) if possible. Example ```python assert can_form_repeated_substring(\\"abab\\") == True assert can_form_repeated_substring(\\"aba\\") == False assert can_form_repeated_substring(\\"abcabcabcabc\\") == True assert can_form_repeated_substring(\\"a\\") == False assert can_form_repeated_substring(\\"aaaa\\") == True ``` # Scenario/Context Imagine you are working on a text processing tool that needs to detect repeated patterns within texts quickly. This detection can be useful in various fields such as DNA sequence analysis, rhythm detection in music, and data compression algorithms.","solution":"def can_form_repeated_substring(s: str) -> bool: Check if the given string can be constructed by taking a substring of it and repeating the substring multiple times. n = len(s) # Create a new string by concatenating the input string with itself and then removing the first and last character. doubled_s = (s + s)[1:-1] # Check if the original string can be found within this transformed string. return s in doubled_s"},{"question":"Context You are provided with a basic sorting algorithm, the exchange sort, which is simple but inefficient for large datasets due to its O(n^2) complexity. Your task is to implement an optimized sorting algorithm that performs better on larger datasets. Task Write a function `optimized_sort` that sorts a list of integers in non-decreasing order using an algorithm with better performance than O(n^2). You can select any efficient sorting algorithm, such as QuickSort or MergeSort. Function Signature ```python def optimized_sort(arr: List[int]) -> List[int]: pass ``` Input * `arr`: A list of integers with length n (0 <= n <= 10^6). Output * A list of integers sorted in non-decreasing order. Constraints * The algorithm should not exceed O(n log n) time complexity. Scenario Your program is supposed to handle large datasets efficiently and sort them quickly. Ensure your implementation is robust and can handle edge cases such as empty lists and lists with duplicate elements. Example ```python # Input: arr = [4, 2, 5, 1, 3] # Output: [1, 2, 3, 4, 5] ``` Notes * You may use the standard library for sorting utilities if you wish. * Your implementation should be optimal for a wide range of input sizes.","solution":"from typing import List def optimized_sort(arr: List[int]) -> List[int]: Sorts a list of integers in non-decreasing order using a more efficient sorting algorithm, MergeSort. if len(arr) <= 1: return arr def merge_sort(array): if len(array) <= 1: return array mid = len(array) // 2 left_half = merge_sort(array[:mid]) right_half = merge_sort(array[mid:]) return merge(left_half, right_half) def merge(left, right): sorted_array = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: sorted_array.append(left[i]) i += 1 else: sorted_array.append(right[j]) j += 1 sorted_array.extend(left[i:]) sorted_array.extend(right[j:]) return sorted_array return merge_sort(arr)"},{"question":"In a very large sequence of concatenated positive integers (1, 2, 3, 4,...), each digit is treated as part of a continuous string. Your task is to write a function `find_nth_digit` that determines which digit is at the nth position in this infinite sequence. Function Signature ```python def find_nth_digit(n: int) -> int: ``` Input * `n` (int): The position (1-based index) of the digit in the concatenated sequence of all positive integers. Output * Returns the digit (0-9) present at the nth position in the infinite concatenated sequence of integers. Constraints * 1 ≤ `n` ≤ 2^31 - 1 (Given the nature of the problem, consider efficient handling of large values of `n`) **Note**: When finding the nth digit, the sequence \\"1234567891011121314...\\" continues indefinitely. Example ```python # Example 1: n = 3 # Output: 3 # Explanation: The sequence starts with \\"123...\\" and the 3rd digit is 3. # Example 2: n = 11 # Output: 0 # Explanation: The sequence starts with \\"123456789101112...\\" and the 11th digit is 0. ``` Instructions Implement the `find_nth_digit` function to pass all provided test cases. Consider edge cases, and ensure your solution is efficient in terms of time and space complexity. Provide comments wherever necessary to improve readability and maintainability of the code.","solution":"def find_nth_digit(n: int) -> int: Returns the digit at the nth position in the infinite sequence of concatenated positive integers. # Determine the number of digits in the current range length = 1 # Number of digits in the current numbers considered count = 9 # Total numbers in the current range total_digits = 0 # Find the range in which the nth digit falls while n > length * count: n -= length * count length += 1 count *= 10 # Determine the exact number within the range that contains the nth digit start = 10 ** (length - 1) num = start + (n - 1) // length # Determine the exact digit within the number digit_index = (n - 1) % length return int(str(num)[digit_index])"},{"question":"# Question: Integer Decomposition Count You are given a positive integer `n`. Write a function `int_decompose_count(n)` that returns the number of ways `n` can be decomposed into sums of positive integers. For instance, for `n = 4`, the decompositions are: 1. 4 2. 3 + 1 3. 2 + 2 4. 2 + 1 + 1 5. 1 + 1 + 1 + 1 Thus, there are 5 ways to decompose the number 4. Input - An integer `n` (1 ≤ n ≤ 100) Output - An integer representing the number of ways to decompose `n`. Example 1. Input: `4` Output: `5` Explanation: The ways to decompose 4 into sums of positive integers are {4}, {3 + 1}, {2 + 2}, {2 + 1 + 1}, and {1 + 1 + 1 + 1}. 2. Input: `7` Output: `15` Explanation: The ways to decompose 7 into sums of positive integers are: - 7 - 6 + 1 - 5 + 2 - 5 + 1 + 1 - 4 + 3 - 4 + 2 + 1 - 4 + 1 + 1 + 1 - 3 + 3 + 1 - 3 + 2 + 2 - 3 + 2 + 1 + 1 - 3 + 1 + 1 + 1 + 1 - 2 + 2 + 2 + 1 - 2 + 2 + 1 + 1 + 1 - 2 + 1 + 1 + 1 + 1 + 1 - 1 + 1 + 1 + 1 + 1 + 1 + 1 # Constraints 1. Do not use any built-in functions related to partitions. 2. The solution must be efficient with a complexity of O(n^2). # Function Signature ```python def int_decompose_count(n: int) -> int: # Your code goes here ```","solution":"def int_decompose_count(n): Returns the number of ways n can be decomposed into sums of positive integers. # Initialize a list to store the number of decompositions for each number from 0 to n dp = [0] * (n + 1) dp[0] = 1 # Base case: one way to decompose 0 # Loop through each number from 1 to n for i in range(1, n + 1): # Loop through each possible decomposition of i for j in range(i, n + 1): dp[j] += dp[j - i] return dp[n]"},{"question":"**Scenario**: You are a software engineer working on a library management system. One of the tasks is to ensure that lists of books sorted by year of publication remain in order after various operations. To do this, you need a function that checks if lists are sorted correctly. **Task**: Write a function `is_sorted(head)` that determines if a given singly-linked list of integers is sorted in non-decreasing order. An empty list should be considered sorted. **Function Signature**: `def is_sorted(head: Optional[ListNode]) -> bool:` **Input**: - `head`: The head node of a singly linked list where each node contains an integer. **Output**: - Returns `True` if the list is sorted in non-decreasing order, otherwise `False`. **Constraints**: - The linked list can contain any integer values, both positive and negative. - The length of the linked list is in the range ([0, 10^5]). # Example ```python # Definition for singly-linked list. class ListNode: def __init__(self, x): self.val = x self.next = None # Example 1: # Input: 1 -> 2 -> 3 -> 4 # Output: True # Example 2: # Input: 1 -> 2 -> -1 -> 3 # Output: False # Example 3: # Input: None # Output: True def is_sorted(head: Optional[ListNode]) -> bool: if not head: return True current = head while current.next: if current.val > current.next.val: return False current = current.next return True # Testing Function ``` # Explanation 1. Example 1: The linked list `1 -> 2 -> 3 -> 4` is in non-decreasing order, hence `True` is returned. 2. Example 2: The linked list `1 -> 2 -> -1 -> 3` contains an element `-1` which is smaller than its predecessor `2`, hence `False` is returned. 3. Example 3: An empty linked list is passed, so the function returns `True` as specified. Write your solution to ensure the lists of books are sorted correctly by their year.","solution":"# Definition for singly-linked list. class ListNode: def __init__(self, x): self.val = x self.next = None from typing import Optional def is_sorted(head: Optional[ListNode]) -> bool: if not head: return True current = head while current.next: if current.val > current.next.val: return False current = current.next return True"},{"question":"# Question You are tasked with designing a playlist application where songs can be dynamically added, moved, and removed. Implement a doubly linked list to manage the playlist. Your implementation should include the following functionalities: 1. **Add Song**: Add a new song to the end of the playlist. 2. **Remove Song**: Remove a song from the playlist given the song title. 3. **Move Song**: Move a song to a new position in the playlist given the song title and the new position. 4. **Print Playlist**: Print the current list of songs from head to tail. Function Signatures ```python class DoublyLinkedList: def __init__(self): # Initialize head and tail pass def add_song(self, song: str) -> None: # Implement code to add song pass def remove_song(self, song: str) -> None: # Implement code to remove song pass def move_song(self, song: str, position: int) -> None: # Implement code to move song to new position pass def print_playlist(self) -> None: # Implement code to print playlist pass ``` # Constraints and Notes - Ensure that your `add_song`, `remove_song`, and `move_song` methods handle edge cases, such as attempting to remove or move a song not in the list. - Optimize for readability and maintainability in your code. - Bonus points for minimizing the number of operations in `move_song`. **Example Usage** ```python playlist = DoublyLinkedList() playlist.add_song(\\"Song A\\") playlist.add_song(\\"Song B\\") playlist.add_song(\\"Song C\\") playlist.print_playlist() # Output: # Song A -> Song B -> Song C playlist.remove_song(\\"Song B\\") playlist.print_playlist() # Output: # Song A -> Song C playlist.move_song(\\"Song C\\", 1) playlist.print_playlist() # Output: # Song C -> Song A ```","solution":"class Node: def __init__(self, song: str): self.song = song self.prev = None self.next = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def add_song(self, song: str) -> None: new_node = Node(song) if not self.head: self.head = self.tail = new_node else: self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def remove_song(self, song: str) -> None: current = self.head while current: if current.song == song: if current.prev: current.prev.next = current.next else: # removing head self.head = current.next if current.next: current.next.prev = current.prev else: # removing tail self.tail = current.prev return current = current.next def move_song(self, song: str, position: int) -> None: if position < 0: return # Invalid position current = self.head count = 0 song_node = None while current: if current.song == song: song_node = current break current = current.next count += 1 if not song_node or position == count: return # Remove song_node if song_node.prev: song_node.prev.next = song_node.next else: self.head = song_node.next if song_node.next: song_node.next.prev = song_node.prev else: self.tail = song_node.prev # Reset current to head to traverse to the new position current = self.head new_position_count = 0 prev_node = None while current and new_position_count < position: prev_node = current current = current.next new_position_count += 1 # Insert before the current node if prev_node: prev_node.next = song_node else: self.head = song_node song_node.prev = prev_node if current: current.prev = song_node song_node.next = current if not song_node.next: self.tail = song_node def print_playlist(self) -> None: current = self.head playlist = [] while current: playlist.append(current.song) current = current.next print(\\" -> \\".join(playlist))"},{"question":"# Question You are designing a smart home exercise program for people to reach their daily step-count goals more engagingly. You want to include a feature that helps users calculate the number of distinct ways they can complete their step goal by combining 1-step and 2-step movements. Problem Statement: Implement a function `distinct_way_to_step_goal(steps: int) -> int` that calculates the number of distinct ways to complete `steps` number of steps, where each step can either be 1 or 2 steps. Input: * An integer `steps` (1 ≤ `steps` ≤ 1000) representing the number of steps to be taken. Output: * An integer representing the number of distinct ways the step goal can be achieved. Constraints: * You can take either 1-step or 2-steps at a time. * Your solution must run in O(n) time complexity. * Optimize the space complexity to O(1). Example: ```python distinct_way_to_step_goal(steps=2) # Output: 2 distinct_way_to_step_goal(steps=3) # Output: 3 distinct_way_to_step_goal(steps=5) # Output: 8 ``` Requirements: * Ensure the function works efficiently for large inputs up to 1000 steps. * Handle edge cases such as the smallest number of steps (1 step).","solution":"def distinct_way_to_step_goal(steps: int) -> int: Calculate the number of distinct ways to reach a step goal using 1-step or 2-step movements. Args: steps (int): The total number of steps to be taken. Returns: int: The number of distinct ways to achieve the step goal. if steps == 1: return 1 elif steps == 2: return 2 prev2 = 1 # dp[0] prev1 = 2 # dp[1] for _ in range(2, steps): current = prev1 + prev2 prev2 = prev1 prev1 = current return prev1"},{"question":"**[Coding Assessment Question]** # Context You are given a 2D grid of characters and a list of words. Your task is to find all the words from the list that can be formed by sequentially adjacent characters on the 2D grid. The same character on the grid may not be used more than once per word. A word should be constructed using adjacent cells (horizontally or vertically neighboring). # Requirement Implement a function `find_words` that takes the following inputs: - `board`: List[List[str]] - a 2D grid of characters. - `words`: List[str] - a list of words to search for in the grid. And returns: - `List[str]` - a list of words found in the grid. # Constraints - The dimensions of the board are at most 12 x 12. - The length of words will be at most 10. - The list of words will contain at most 100 words. - Words, grid characters, and desired matches will be lowercase English letters. # Example ```python board = [ [\'o\',\'a\',\'a\',\'n\'], [\'e\',\'t\',\'a\',\'e\'], [\'i\',\'h\',\'k\',\'r\'], [\'i\',\'f\',\'l\',\'v\'] ] words = [\\"oath\\",\\"pea\\",\\"eat\\",\\"rain\\"] # Output should be [\'oath\', \'eat\'] print(find_words(board, words)) # Expected output: [\'oath\', \'eat\'] ``` # Guidelines - Build a Trie for the list of words. - Use backtracking to check sequentially adjacent characters. - Ensure efficiency in both time and space complexity to meet the constraints. - Avoid reusing a cell for a single word by marking it appropriately during the search.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): current = self.root for letter in word: if letter not in current.children: current.children[letter] = TrieNode() current = current.children[letter] current.is_word = True def find_words(board, words): def backtrack(row, col, parent, prefix): letter = board[row][col] curr_node = parent.children[letter] prefix += letter if curr_node.is_word: result.add(prefix) curr_node.is_word = False board[row][col] = \'#\' for row_offset, col_offset in [(0, 1), (1, 0), (0, -1), (-1, 0)]: new_row, new_col = row + row_offset, col + col_offset if 0 <= new_row < len(board) and 0 <= new_col < len(board[0]) and board[new_row][new_col] in curr_node.children: backtrack(new_row, new_col, curr_node, prefix) board[row][col] = letter trie = Trie() for word in words: trie.insert(word) result = set() for row in range(len(board)): for col in range(len(board[0])): if board[row][col] in trie.root.children: backtrack(row, col, trie.root, \\"\\") return list(result)"},{"question":"# Pattern Matching with Backtracking **Context:** You are tasked with implementing a function that checks if a given string can be segmented into substrings that match a given pattern. The pattern consists of lowercase letters, and each character in the pattern must map to a unique, non-empty substring in the input string. **Problem Statement:** Write a function `pattern_match(pattern: str, string: str) -> bool` that returns `True` if the string can be segmented to match the pattern, and `False` otherwise. **Parameters:** - `pattern` (str): A string consisting of lowercase letters that represent the pattern. - `string` (str): A string consisting of lowercase letters. **Returns:** - `bool`: Returns `True` if there exists a valid bijection from characters in the pattern to substrings in the string, otherwise returns `False`. **Constraints:** - Both `pattern` and `string` will contain only lowercase letters. - Length of `pattern` ≤ 20 - Length of `string` ≤ 100 **Examples:** 1. `pattern_match(\\"abab\\", \\"redblueredblue\\")` should return `True`. 2. `pattern_match(\\"aaaa\\", \\"asdasdasdasd\\")` should return `True`. 3. `pattern_match(\\"aabb\\", \\"xyzabcxzyabc\\")` should return `False`. **Implementation Guidelines:** Your solution should effectively utilize a backtracking approach where: 1. You recursively attempt to map each character in the pattern to a non-empty substring in the string. 2. Maintain a dictionary to store these mappings and ensure characters map uniquely. 3. Backtrack when you encounter dead ends to explore other potential mappings. 4. Handle edge cases and avoid performance bottlenecks by pruning unnecessary branches early. **Additional Notes:** 1. Consider edge cases such as an empty pattern or string, repeated characters in the pattern, and highly uneven lengths between the pattern and string. 2. Optimize where possible to handle the constraints effectively.","solution":"def pattern_match(pattern: str, string: str) -> bool: def is_match(p_idx, s_idx, mapping, used): # If both indices reach the end, it is a match if p_idx == len(pattern) and s_idx == len(string): return True # If only one reaches the end, it is not a match if p_idx == len(pattern) or s_idx == len(string): return False pattern_char = pattern[p_idx] # If the pattern character has been encountered before if pattern_char in mapping: word = mapping[pattern_char] if not string.startswith(word, s_idx): return False return is_match(p_idx + 1, s_idx + len(word), mapping, used) else: for end in range(s_idx + 1, len(string) + 1): word = string[s_idx:end] if word in used: continue mapping[pattern_char] = word used.add(word) if is_match(p_idx + 1, s_idx + len(word), mapping, used): return True del mapping[pattern_char] used.remove(word) return False return is_match(0, 0, {}, set())"},{"question":"# Skyline Problem Given a city\'s skyline represented by buildings specified as ([Li, Ri, Hi]) tuples, your task is to implement a function `get_skyline` that computes the sky line when viewed from a distance. Each building is represented by its: - **(Li)**: left x-coordinate. - **(Ri)**: right x-coordinate. - **(Hi)**: height. The output should be a list of \\"key points\\" ([[x_1, y_1], [x_2, y_2], ...]) that uniquely define the skyline. A key point is the left end of a horizontal line segment. The last key point at the rightmost building ends should have a height of 0. **Function Signature**: ```python def get_skyline(buildings: List[List[int]]) -> List[List[int]]: ``` **Input**: - `buildings`: A list of ([Li, Ri, Hi]) tuples where (0 le Li, Ri le text{INT_MAX}), (0 < Hi le text{INT_MAX}), and (Ri - Li > 0). **Output**: - Return the list of \\"key points\\" defining the skyline. **Constraints**: - The number of buildings in the input list is guaranteed to be in the range ([0, 10,000]). - The input list is already sorted by the left x position (Li). **Notes**: - The output list must be sorted by the x position. - There must be no consecutive horizontal lines of equal height in the output skyline. **Example**: ```python buildings = [[2, 9, 10], [3, 7, 15], [5, 12, 12], [15, 20, 10], [19, 24, 8]] print(get_skyline(buildings)) # Output should be [[2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0]] ``` **Explanation**: The output key points accurately represent the skyline from the buildings provided, ensuring no consecutive redundant heights and including the termination points for clarity.","solution":"from typing import List from heapq import heappush, heappop def get_skyline(buildings: List[List[int]]) -> List[List[int]]: Computes the skyline of given buildings specified by (Li, Ri, Hi) tuples. A key point is the left end of a horizontal line segment. events = [] # Collecting all the building points for L, R, H in buildings: events.append((L, -H, R)) # Starting point has negative height value events.append((R, 0, 0)) # Ending point has zero height value events.sort() # Sort events based on position, height, and end result = [[0, 0]] # Initialize result with a dummy point live_heap = [(0, float(\\"inf\\"))] # Heap to keep track of active buildings for x, negH, R in events: while live_heap[0][1] <= x: # Remove the past building from the heap heappop(live_heap) if negH: # If this is the start of a building heappush(live_heap, (negH, R)) current_height = -live_heap[0][0] last_height = result[-1][1] if current_height != last_height: # Only add to result on height change result.append([x, current_height]) return result[1:] # Exclude the initial dummy point"},{"question":"Implement a function that reverses the order of words in a given sentence while maintaining the words themselves unchanged. The function should handle multiple spaces between words and leading/trailing spaces. # Function Signature ```python def reverse_words(sentence: str) -> str: pass ``` # Input * `sentence` (string): A string consisting of words separated by spaces. It may contain leading, trailing or multiple spaces in between. # Output * Returns a string where the words are in reverse order compared to their original appearance, with appropriate handling of spaces. # Constraints * The sentence length will not exceed 10^4 characters. # Example ```python # Example 1: # Input: \\"Hello World\\" # Output: \\"World Hello\\" # Example 2: # Input: \\" This is a test \\" # Output: \\"test a is This\\" # Example 3: # Input: \\"SingleWord\\" # Output: \\"SingleWord\\" ``` # Notes * You should strip leading and trailing spaces before splitting the words. * Ensure that the number of spaces between words in the reversed sentence matches those in the original sentence. # Tips * Consider using Python\'s `split` method with no arguments to handle multiple spaces appropriately.","solution":"def reverse_words(sentence: str) -> str: Reverses the order of words in a given sentence while maintaining the words themselves unchanged. Handles multiple spaces between words and leading/trailing spaces. # Split the sentence into words, handling multiple spaces words = sentence.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list of words to form the new sentence reversed_sentence = \\" \\".join(reversed_words) return reversed_sentence"},{"question":"# Stooge Sort Implementation You have been provided with the incomplete Stooge Sort algorithm. Your task is to implement this sorting algorithm and demonstrate your understanding of recursion and sorting efficiency. Description The Stooge Sort algorithm sorts an array of integers recursively as follows: 1. If the first element is smaller than the last, they are swapped. 2. Recursively sort the initial two-thirds of the array. 3. Recursively sort the final two-thirds of the array. 4. Recursively sort the initial two-thirds of the array again. Your task is to complete the implementation of the recursive Stooge Sort algorithm in Python. Requirements 1. Implement the `stoogesort` function. 2. The function should take in a list of integers and return the sorted list. 3. You must handle edge cases including when the array length is 0, 1, or 2. 4. Your implementation must work even for large arrays, but understand that it will be less efficient due to the algorithm’s high time complexity. Function Signature ```python def stoogesort(arr: List[int], l: int, h: int) -> List[int]: pass ``` Input - `arr` is a list of integers (`List[int]`). - `l` is an integer representing the starting index (`int`). - `h` is an integer representing the ending index (`int`). Output - The function should return the sorted list of integers (`List[int]`). Constraints - The input list can contain up to 1000 integers. - Each integer in the list can range from -10^6 to 10^6. Example ```python arr = [1, 3, 64, 5, 7, 8] stoogesort(arr, 0, len(arr) - 1) print(arr) # Output should be: [1, 3, 5, 7, 8, 64] ``` Complete the Stooge Sort function to be sure it correctly sorts arrays as described above, and be mindful of handling potential edge cases and ensuring that your implementation does not cause stack overflow for larger input sizes (although inherently this sorting method is not optimal for such scenarios).","solution":"from typing import List def stoogesort(arr: List[int], l: int, h: int) -> List[int]: if l >= h: return arr # Step 1: If the first element is greater than the last, they are swapped. if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than two elements in the array if h - l + 1 > 2: t = (h - l + 1) // 3 # Step 2: Recursively sort the initial two-thirds of the array stoogesort(arr, l, h - t) # Step 3: Recursively sort the final two-thirds of the array stoogesort(arr, l + t, h) # Step 4: Recursively sort the initial two-thirds of the array again stoogesort(arr, l, h - t) return arr"},{"question":"# Array Rotation Challenge Problem Statement: You are given a list of integers and an integer `k`. Your task is to write a function that rotates the elements of the list to the right by `k` steps. You should explore and implement at least two different methods to accomplish this, ensuring that one method is efficient both in time and space complexity. Requirements: 1. Implement at least two methods for array rotation. 2. Ensure one of the methods has a time complexity of O(n) and space complexity of O(1). Function Signature: ```python def rotate_method1(array: List[int], k: int) -> List[int]: # Method 1 Implementation def rotate_method2(array: List[int], k: int) -> List[int]: # Method 2 Implementation ``` Input: - `array` (List[int]): The list of integers to be rotated. It\'s guaranteed to have at least 1 element. - `k` (int): The number of steps to rotate the array. It is non-negative. Output: - Returns the rotated list of integers. Constraints: - 1 <= len(array) <= 10^5 - 0 <= k <= 10^9 Performance Expectations: - Handle large values of `k` efficiently by reducing unnecessary rotations. - Make sure at least one solution works efficiently for large lists and adheres to the time and space complexity requirements. Examples: ```python assert rotate_method1([1, 2, 3, 4, 5, 6, 7], 3) == [5, 6, 7, 1, 2, 3, 4] assert rotate_method2([1, 2, 3, 4, 5, 6, 7], 3) == [5, 6, 7, 1, 2, 3, 4] assert rotate_method1([1, 2], 5) == [2, 1] assert rotate_method2([1, 2], 5) == [2, 1] assert rotate_method1([], 0) == [] assert rotate_method2([], 0) == [] ``` Notes: - Consider edge cases like rotations larger than the array length. - Ensure that your implementations do not modify the input array in-place unless specified.","solution":"from typing import List def rotate_method1(array: List[int], k: int) -> List[int]: Rotate array to the right by k steps using slicing. if not array: return array n = len(array) k %= n # Handle cases where k is larger than the array length return array[-k:] + array[:-k] def rotate_method2(array: List[int], k: int) -> List[int]: Rotate array to the right by k steps using the reversal algorithm. if not array: return array n = len(array) k %= n # Handle cases where k is larger than the array length # Helper function to reverse a segment of the array def reverse(start, end): while start < end: array[start], array[end] = array[end], array[start] start += 1 end -= 1 # Reverse the entire array reverse(0, n-1) # Reverse the first k elements reverse(0, k-1) # Reverse the rest reverse(k, n-1) return array"},{"question":"# Scenario You are part of a team developing a cross-platform data communication system. Your task is to handle data serialization and deserialization for the system which involves converting integer values to byte arrays and vice versa, considering both big-endian and little-endian formats. # Problem Statement Write four functions to handle the conversion between integers and their byte representations in both big-endian and little-endian formats. Ensure your implementations are efficient, correct, and handle potential edge cases. # Function Signatures 1. `def int_to_bytes_big_endian(num: int) -> bytes:` 2. `def int_to_bytes_little_endian(num: int) -> bytes:` 3. `def bytes_big_endian_to_int(bytestr: bytes) -> int:` 4. `def bytes_little_endian_to_int(bytestr: bytes) -> int:` # Input/Output Formats 1. `int_to_bytes_big_endian(num: int) -> bytes` - **Input**: A non-negative integer `num` - **Output**: A bytes object representing `num` in big-endian byte order. 2. `int_to_bytes_little_endian(num: int) -> bytes` - **Input**: A non-negative integer `num` - **Output**: A bytes object representing `num` in little-endian byte order. 3. `bytes_big_endian_to_int(bytestr: bytes) -> int` - **Input**: A bytes object `bytestr` - **Output**: An integer decoded from big-endian byte order. 4. `bytes_little_endian_to_int(bytestr: bytes) -> int` - **Input**: A bytes object `bytestr` - **Output**: An integer decoded from little-endian byte order. # Constraints * You can assume the input integers will fit within 64-bit numbers. * Consider edge cases like the integer 0 or very large integers. # Example ```python int_to_bytes_big_endian(305419896) # returns b\'x12x34x56x78\' int_to_bytes_little_endian(305419896) # returns b\'xV4x12\' bytes_big_endian_to_int(b\'x12x34x56x78\') # returns 305419896 bytes_little_endian_to_int(b\'xV4x12\') # returns 305419896 ``` # Requirements * Aim for an efficient algorithm with minimal computational overhead. * Handle all mentioned edge cases.","solution":"def int_to_bytes_big_endian(num: int) -> bytes: Converts an integer to a byte array in big-endian format. if num == 0: return b\'x00\' byte_length = (num.bit_length() + 7) // 8 return num.to_bytes(byte_length, \'big\') def int_to_bytes_little_endian(num: int) -> bytes: Converts an integer to a byte array in little-endian format. if num == 0: return b\'x00\' byte_length = (num.bit_length() + 7) // 8 return num.to_bytes(byte_length, \'little\') def bytes_big_endian_to_int(bytestr: bytes) -> int: Converts a byte array in big-endian format to an integer. return int.from_bytes(bytestr, \'big\') def bytes_little_endian_to_int(bytestr: bytes) -> int: Converts a byte array in little-endian format to an integer. return int.from_bytes(bytestr, \'little\')"},{"question":"You are given a `pattern` and a string `str`. Write a function `word_pattern(pattern, str)` that returns `True` if `str` follows the same pattern as the given `pattern`, and `False` otherwise. # Requirements - **Input Format**: - `pattern` (string): Contains only lowercase letters. - `str` (string): A series of lowercase words separated by single spaces. - **Output Format**: - Return a boolean value: `True` if the given pattern matches the string, `False` otherwise. - **Constraints**: - The pattern and the words in str are non-empty. - The number of characters in pattern corresponds to the number of words in str. # Example Input ```python pattern = \\"abba\\" str = \\"dog cat cat dog\\" ``` Output ```python True ``` Input ```python pattern = \\"abba\\" str = \\"dog cat cat fish\\" ``` Output ```python False ``` # Constraints 1. Pattern will only contain lowercase letters. 2. `str` will contain lowercase words separated by a single space. Performance Requirements - Ensure the function runs efficiently with a linear time complexity relative to the length of the `pattern` and `str`. # Implementation Details and Edge Cases: - The function must handle cases where `pattern` and `str` have different lengths. - Ensure unique and consistent mappings from `pattern` characters to words. - Consider duplicate words or pattern characters and manage the bijection accurately. Implement the function in a way that correctly handles all edge cases and efficiently verifies the pattern matching against the string.","solution":"def word_pattern(pattern, str): Checks if the given str follows the same pattern as the given pattern. Args: pattern (string): Contains only lowercase letters. str (string): A series of lowercase words separated by single spaces. Returns: bool: True if str matches the pattern, False otherwise. words = str.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for p, w in zip(pattern, words): if p in char_to_word: if char_to_word[p] != w: return False else: char_to_word[p] = w if w in word_to_char: if word_to_char[w] != p: return False else: word_to_char[w] = p return True"},{"question":"# Flatten a Nested Array - Advanced Level Background You are working on a project that involves parsing complex nested configuration files. Your task is to flatten out any nested structures to simplify data handling and processing. This task will test your understanding of recursion, iteration over complex structures, and careful handling of different data types. Problem Statement Write a function `flatten_array` which takes a potentially deeply nested array of elements and flattens it into a single list of elements, maintaining the order. Your function should handle mixed data types and should not treat strings as iterable for the purposes of flattening. Function Signature ```python def flatten_array(input_array: list) -> list: Flattens a multi-dimensional array into a one-dimensional list. :param input_array: List which may contain nested lists :return: Flattened one-dimensional list containing all elements pass ``` Input - `input_array`: a list of elements which may include other lists, strings, and various data types. Output - A single flattened list of elements. Constraints - The array may contain elements of any type (integers, strings, lists, etc.). - Do not treat strings as iterable for the purposes of flattening. - Ensure the function runs efficiently in terms of both time and space complexity. Example ```python assert flatten_array([1, [2, [3, 4], 5], 6]) == [1, 2, 3, 4, 5, 6] assert flatten_array([\'a\', [\'b\', [\'c\', \'d\']], \'e\']) == [\'a\', \'b\', \'c\', \'d\', \'e\'] assert flatten_array([1, [], [2, [3]], [[]], 4]) == [1, 2, 3, 4] ``` Notes - Consider edge cases such as deeply nested empty arrays or arrays with no elements. - Think about the iterative and recursive strategies to solve this problem and choose the one that works best to control recursion depth issues.","solution":"def flatten_array(input_array: list) -> list: Flattens a multi-dimensional array into a one-dimensional list. :param input_array: List which may contain nested lists :return: Flattened one-dimensional list containing all elements result = [] def flatten(item): if isinstance(item, list): for subitem in item: flatten(subitem) else: result.append(item) flatten(input_array) return result"},{"question":"# Scenario You are tasked with optimizing a feature in a large-scale analytics platform. The feature performs thousands of range queries and point updates on a dynamic dataset. To achieve this, you decide to use a Segment Tree data structure. # Problem Statement You need to implement a Segment Tree class in Python that supports efficient range queries and point updates on a given array with an associative function. # Requirements 1. Implement the `SegmentTree` class as described below. 2. The `SegmentTree` should support the following methods: * **`__init__(self, arr, function)`**: Initialize the segment tree with the given array `arr` and an associative function `function`. * **`update(self, p, v)`**: Update the element at index `p` to new value `v`. * **`query(self, l, r)`**: Return the result of applying the associative function over the range `[l, r]` (inclusive). # Input and Output Formats * **Initialization**: `SegmentTree(arr: List[Any], function: Callable[[Any, Any], Any])` * **Update**: `update(p: int, v: Any) -> None` * **Query**: `query(l: int, r: int) -> Any` # Constraints * The array can have up to (10^5) elements. * The associative function is commutative and associative. * Update and query operations will be called multiple times. # Example ```python # Example with sum function arr = [4, 5, 2, 3, 4, 43, 3] mytree = SegmentTree(arr, lambda a, b: a + b) print(mytree.query(0, 6)) # Output: 64 mytree.update(2, -10) print(mytree.query(0, 6)) # Output: 52 # Example with max function arr = [2, 4, 5, 3, 4] mytree = SegmentTree(arr, max) print(mytree.query(2, 4)) # Output: 5 mytree.update(3, 6) print(mytree.query(0, 3)) # Output: 6 ``` # Performance Requirements * Your implementation should handle range queries and updates within (O(log N)) time complexity.","solution":"class SegmentTree: Segment Tree data structure supporting efficient range queries and point updates with an associative function. def __init__(self, arr, function): self.n = len(arr) self.function = function self.tree = [0] * (2 * self.n) # Build the tree for i in range(self.n): self.tree[self.n + i] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, p, v): # Update value at index p pos = p + self.n self.tree[pos] = v while pos > 1: pos //= 2 self.tree[pos] = self.function(self.tree[pos * 2], self.tree[pos * 2 + 1]) def query(self, l, r): # Query range [l, r] l += self.n r += self.n + 1 res = None while l < r: if l % 2: res = self.tree[l] if res is None else self.function(res, self.tree[l]) l += 1 if r % 2: r -= 1 res = self.tree[r] if res is None else self.function(res, self.tree[r]) l //= 2 r //= 2 return res"},{"question":"# Matrix Multiplication Programming Challenge Context: Matrix multiplication is an essential operation in various fields, including computer graphics, machine learning, and scientific computing. It involves multiplying the rows of the first matrix with the columns of the second matrix and summing up the products to form the cells of a new resultant matrix. This task requires careful consideration of matrix dimensions to ensure compatibility for multiplication. Problem Statement: Write a function `matrix_multiply(multiplicand: List[List[int]], multiplier: List[List[int]]) -> List[List[int]]` in Python that multiplies two compatible matrices and returns their product. Input: - `multiplicand`: A list of lists where each sublist represents a row of the multiplicand matrix, containing integers. - `multiplier`: A list of lists where each sublist represents a row of the multiplier matrix, containing integers. Output: - A list of lists where each sublist represents a row of the resultant matrix. Constraints: - Each matrix will have dimensions ranging from 1x1 to 100x100. - The number of columns in the multiplicand matrix will always equal the number of rows in the multiplier matrix. - Values within matrices are integers in the range of ([-1000, 1000]). Performance Requirement: - The function should handle the largest possible matrix size efficiently, specifically within the time complexity limit of (O(n^3)). Example: ```python # Input multiplicand = [ [1, 2], [3, 4] ] multiplier = [ [5, 6], [7, 8] ] # Output result = [ [19, 22], [43, 50] ] ``` Additional Information: - Raise an `Exception` with the message \\"Multiplicand matrix not compatible with Multiplier matrix.\\" if the matrices cannot be multiplied due to incompatible dimensions. - Ensure that the resultant matrix is initialized to zeros before carrying out the multiplication.","solution":"from typing import List def matrix_multiply(multiplicand: List[List[int]], multiplier: List[List[int]]) -> List[List[int]]: Multiplies two matrices and returns the resultant matrix. Parameters: multiplicand (List[List[int]]): The first matrix (m x n) multiplier (List[List[int]]): The second matrix (n x p) Returns: List[List[int]]: The resultant matrix (m x p) Raises: Exception: If the matrices cannot be multiplied due to incompatible dimensions. if len(multiplicand[0]) != len(multiplier): raise Exception(\\"Multiplicand matrix not compatible with Multiplier matrix.\\") # Dimensions of the resultant matrix m = len(multiplicand) # Number of rows in multiplicand n = len(multiplier[0]) # Number of columns in multiplier p = len(multiplicand[0]) # Number of columns in multiplicand and rows in multiplier # Initialize the resultant matrix with zeros result = [[0 for _ in range(n)] for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(n): for k in range(p): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"**Context:** You are hired by a social networking company that wants to determine the reachability of users through their connections. They’ve provided you with a directed graph where each node represents a user and each edge represents a follow relationship between users. You need to compute the reachability matrix to determine if one user can eventually reach another user, either directly or through a series of connections. **Task:** Implement a function `compute_transitive_closure(n, edges)` that calculates the transitive closure of a directed graph with `n` vertices and a list of edges. **Input:** - `n`: An integer representing the number of vertices in the graph (0 <= n <= 100). - `edges`: A list of tuples where each tuple `(source, target)` represents a directed edge from `source` to `target`. (0 <= source, target < n) **Output:** - A 2D list `closure` of size `n x n` where `closure[i][j]` is 1 if there is a path from vertex `i` to vertex `j`, and 0 otherwise. **Function Signature:** ```python def compute_transitive_closure(n: int, edges: list) -> list: pass ``` **Constraints:** - The number of vertices `n` will be between 0 and 100. - The number of edges will be between 0 and n*(n-1). **Example:** ```python assert compute_transitive_closure(4, [(0, 1), (1, 2), (2, 3)]) == [ [1, 1, 1, 1], [0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1] ] ``` **Explanation:** From the example, starting from vertex 0, we can reach all other vertices directly or through intermediate vertices, thus the row corresponding to vertex 0 is all 1s. Similarly for other vertices, their reachability matrix reflects their connections.","solution":"def compute_transitive_closure(n, edges): Computes the transitive closure of a directed graph. Args: n (int): The number of vertices in the graph. edges (list of tuples): The list of directed edges in the graph. Returns: list of list: The transitive closure matrix where closure[i][j] is 1 if there is a path from vertex i to vertex j, otherwise 0. closure = [[0] * n for _ in range(n)] for i in range(n): closure[i][i] = 1 for (src, tgt) in edges: closure[src][tgt] = 1 for k in range(n): for i in range(n): for j in range(n): closure[i][j] = closure[i][j] or (closure[i][k] and closure[k][j]) return closure"},{"question":"Scenario: You are helping a mathematician friend analyze partition functions in number theory. One important problem they are studying involves counting the number of ways an integer can be decomposed into sums of other integers. Your friend provides you with an algorithm that uses dynamic programming to compute these decompositions, but they need it to be implemented efficiently. Task: Write a function `int_partition_count(n)` that takes a single integer `n` and returns the number of ways it can be decomposed into sums of other integers. You should use dynamic programming to ensure efficiency. Input: * An integer `n` where (1 leq n leq 500). Output: * An integer representing the number of different decompositions of `n`. Constraints: * You may assume the input `n` is always a positive integer. * Your solution should be efficient in terms of both time and space complexity given the constraints. Examples: ```python assert int_partition_count(4) == 5 assert int_partition_count(7) == 15 ``` Use the following template for your implementation: ```python def int_partition_count(n): Compute the number of ways to decompose an integer `n` into sums of other integers. Parameters: n (int) -- the integer to be decomposed Returns: int -- the number of distinct decompositions # Initialize the 2D array for dynamic programming dp = [[0 for _ in range(n + 1)] for _ in range(n + 1)] # Base case: there is exactly one way to decompose 0 or any i with itself for i in range(n + 1): dp[i][0] = 1 # Fill in the dynamic programming table for i in range(1, n + 1): for j in range(1, n + 1): if i >= j: dp[i][j] = dp[i][j-1] + dp[i-j][j] else: dp[i][j] = dp[i][i] return dp[n][n] # Example tests print(int_partition_count(4)) # Output should be 5 print(int_partition_count(7)) # Output should be 15 ``` Implement this function and make sure to test it with the example cases provided to validate its correctness.","solution":"def int_partition_count(n): Compute the number of ways to decompose an integer `n` into sums of other integers. Parameters: n (int) -- the integer to be decomposed Returns: int -- the number of distinct decompositions # Initialize the array for dynamic programming dp = [0] * (n + 1) dp[0] = 1 # Fill in the dynamic programming table using bottom-up approach for i in range(1, n + 1): for j in range(i, n + 1): dp[j] += dp[j - i] return dp[n]"},{"question":"**Problem Statement**: You are given an integer array `nums`. Implement the `bogo_sort` function that sorts the array using the Bogo Sort algorithm—a highly inefficient sorting algorithm that randomly shuffles the array until it is sorted. This is mainly educational to understand algorithm inefficiency. The function should also support a `simulation` flag which, when `True`, prints each iteration of the array during the sorting process. Function Signature: ```python def bogo_sort(nums: List[int], simulation: bool = False) -> List[int]: ``` Input * `nums`: A list of integers that needs to be sorted. * `simulation`: A boolean flag to indicate if each iteration should be printed for visualization purposes (default is `False`). Output * A list of integers sorted in non-decreasing order. Constraints: * The number of elements in the list should not exceed 10 (to avoid infinite run time). * The function must use random shuffling to attempt sorting the array. * The elements of `nums` are within the range ([-10^3, 10^3]). **Example:** ```python print(bogo_sort([3, 2, 5, 1, 4])) # Output: [1, 2, 3, 4, 5] # With simulation bogo_sort([3, 2, 5, 1, 4], simulation=True) ``` **Note:** - For educational purposes, this question focuses on demonstrating the inefficiency of certain algorithms. A real-world implementation would use more efficient sorting algorithms.","solution":"import random from typing import List def is_sorted(nums: List[int]) -> bool: Helper function to check if the list is sorted. for i in range(len(nums) - 1): if nums[i] > nums[i + 1]: return False return True def bogo_sort(nums: List[int], simulation: bool = False) -> List[int]: Function to sort the array using the Bogo Sort algorithm. It shuffles the array until it gets sorted. while not is_sorted(nums): if simulation: print(nums) random.shuffle(nums) return nums"},{"question":"You are given an api which returns an array of words and an array of symbols. Your task is to display the word with their matched symbol surrounded by square brackets. If the word string matches more than one symbol, then choose the one with longest length. (e.g., \'Microsoft\' matches \'i\' and \'cro\'): Write a function `match_symbol` that achieves this efficiently using a Trie data structure. Function Signature ```python def match_symbol(words: List[str], symbols: List[str]) -> List[str]: ... ``` Input * `words`: A list of strings representing the words. * `symbols`: A list of strings representing the symbols. Output * A list of strings where each word has its matching symbols replaced with the symbol surrounded by square brackets. If no symbol matches the word, the word remains unaltered. Constraints * Length of the word strings `1 <= len(word) <= 100` * Length of the symbol strings `1 <= len(symbol) <= 50` * Number of words `1 <= len(words) <= 1000` * Number of symbols `1 <= len(symbols) <= 500` # Example ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] print(match_symbol(words, symbols)) ``` Expected Output: ```python [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` # Explanation - For \'Amazon\', \'Am\' is the longest matching symbol, so it becomes \'[Am]azon\'. - For \'Microsoft\', \'cro\' is the longest matching symbol, so it becomes \'Mi[cro]soft\'. - For \'Google\', \'le\' is the longest matching symbol, so it becomes \'Goog[le]\'. This will test the ability to implement efficient searching and string replacement using a Trie and will evaluate your understanding of data structures and their applications.","solution":"from typing import List class TrieNode: def __init__(self): self.children = {} self.is_end_of_symbol = False self.symbol = None class Trie: def __init__(self): self.root = TrieNode() def insert(self, symbol: str): node = self.root for char in symbol: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_symbol = True node.symbol = symbol def search_longest_matching_symbol(self, word: str) -> str: node = self.root longest_symbol = \\"\\" current_symbol = \\"\\" for char in word: if char in node.children: node = node.children[char] current_symbol += char if node.is_end_of_symbol: longest_symbol = current_symbol else: break return node.symbol if node.is_end_of_symbol else \\"\\" def match_symbol(words: List[str], symbols: List[str]) -> List[str]: trie = Trie() for symbol in symbols: trie.insert(symbol) result = [] for word in words: longest_matching_symbol = \\"\\" for i in range(len(word)): current_match = trie.search_longest_matching_symbol(word[i:]) if len(current_match) > len(longest_matching_symbol): longest_matching_symbol = current_match if longest_matching_symbol: modified_word = word.replace(longest_matching_symbol, f\\"[{longest_matching_symbol}]\\") else: modified_word = word result.append(modified_word) return result"},{"question":"# Problem: Strongly Connected Components in Directed Graph You are provided with a `Graph` class that represents a directed graph with vertex_count vertices. Each directed edge in the graph is a one-way connection from one vertex to another. # Your Task Implement the following function within the provided class: ```python def is_strongly_connected(self) -> bool: Determine if the graph is strongly connected. Returns: - True if the graph is strongly connected. - False otherwise. # Constraints * 1 <= vertex_count <= 1000 * The graph can have at most 5000 edges. # Input/Output * The function doesn\'t take any input directly, but relies on the graph structure built using the provided methods (`add_edge`). * Output is a boolean value that indicates if the graph is strongly connected. # Example Consider a graph with 4 vertices and the following edges: 1. add_edge(0, 1) 2. add_edge(1, 2) 3. add_edge(2, 3) 4. add_edge(3, 0) In this example, `is_strongly_connected()` should return `True` since there is a path between every pair of vertices. You need to effectively use the DFS-based approach to determine the strong connectivity of the graph as described in the analysis. # Additional Notes * Ensure that you handle large graphs efficiently both in terms of space and time. * Consider edge cases such as graphs with no edges, single node graphs, and graphs with disconnected components.","solution":"class Graph: def __init__(self, vertex_count): self.vertex_count = vertex_count self.adj_list = [[] for _ in range(vertex_count)] self.rev_adj_list = [[] for _ in range(vertex_count)] def add_edge(self, u, v): self.adj_list[u].append(v) self.rev_adj_list[v].append(u) def is_strongly_connected(self): def dfs(v, visited, adj_list): stack = [v] while stack: node = stack.pop() for neighbor in adj_list[node]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) visited = [False] * self.vertex_count visited[0] = True dfs(0, visited, self.adj_list) if not all(visited): return False visited = [False] * self.vertex_count visited[0] = True dfs(0, visited, self.rev_adj_list) if not all(visited): return False return True"},{"question":"Moving Average with Sliding Window You are tasked to design a more efficient version of the `MovingAverage` class provided, that computes the moving average of values in a sliding window. The current implementation recalculates the sum of the window elements every time a new value is added, which can be optimized. Please implement the `EfficientMovingAverage` class with the following specifications: 1. `__init__(self, size: int)`: Initializes an instance with a window size. 2. `next(self, val: int) -> float`: Adds the new integer value to the window and returns the moving average of the last `size` elements. Requirements: - Optimize the sum calculation to avoid redundant arithmetic operations. - Maintain a fixed-size window of the most recent values using efficient data structures. - Handle edge cases such as window size zero or negative. Input: - `size`: An integer for the window size (n). - `val`: An integer representing the next value in the stream. Output: - Returns the current moving average as a float. Constraints: - Assume that size (window size) is a non-negative integer (0 ≤ size ≤ 10^4). - Val (new value) can be any integer within the range (-10^4 ≤ val ≤ 10^4). Your implementation should efficiently compute the moving average for each call to `next`. Example: ```python if __name__ == \\"__main__\\": ema = EfficientMovingAverage(3) assert ema.next(1) == 1.0 assert ema.next(10) == 5.5 # (1 + 10) / 2 assert ema.next(3) == 4.666666666666667 # (1 + 10 + 3) / 3 assert ema.next(5) == 6.0 # (10 + 3 + 5) / 3 ``` You are expected to develop the class `EfficientMovingAverage` addressing the mentioned optimizations and constraints.","solution":"from collections import deque class EfficientMovingAverage: def __init__(self, size: int): self.size = size self.window = deque() self.window_sum = 0 def next(self, val: int) -> float: if self.size == 0: return 0.0 # Add new value to the window self.window.append(val) self.window_sum += val # If window exceeds the size, remove the oldest value if len(self.window) > self.size: self.window_sum -= self.window.popleft() return self.window_sum / len(self.window)"},{"question":"# Maximum Depth of Binary Tree Context You are tasked with finding the maximum depth of a binary tree. The depth is defined as the number of nodes along the longest path from the root node to the farthest leaf node. Problem Statement Write a function `max_height` that calculates the maximum depth of a binary tree and returns it. The binary tree is represented by a `TreeNode` class that contains an integer value and pointers to its left and right child nodes. Function Signature ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_height(root: TreeNode) -> int: pass ``` Input * `root` (TreeNode): The root node of the binary tree. If the tree is empty, the root will be `None`. Output * An integer representing the maximum depth of the tree. Constraints * The number of nodes in the tree is in the range `[0, 10^4]`. * The values of each node are unique integers. Performance Requirements * The function should have a time complexity of O(N) where N is the number of nodes in the tree. * The space complexity should be O(N), considering the maximum size of the queue during the operation. Examples 1. Given the binary tree: ``` 1 / 2 3 / 4 5 ``` The function should return `3`, as the longest path is 1->2->4. 2. For a single-node binary tree: ``` 1 ``` The function should return `1`. 3. For an empty binary tree: ``` None ``` The function should return `0`. Edge Cases * An empty tree should return `0`. * A tree with only one node should return `1`. * Trees with nodes only on one side should also be handled gracefully. Notes * Consider optimizing your queue operations using a `deque` from the `collections` module if necessary. * You may add other helper functions if needed but focus on the main function `max_height` for submission.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_height(root: TreeNode) -> int: if root is None: return 0 else: left_depth = max_height(root.left) right_depth = max_height(root.right) return max(left_depth, right_depth) + 1"},{"question":"Enhanced Linear Search Objective Your task is to design an enhanced version of the linear search algorithm that not only finds the index of the target element but also returns the count of comparisons made during the search. This will test students\' understanding of algorithm modification and performance evaluation. Problem Description Improve the linear search function in such a way that it also counts the number of comparisons made while searching for the target element. Return both the index of the target element and the count of comparisons as a tuple. If the target element is not found, return -1 for the index and the total number of comparisons made. Function Signature ```python def enhanced_linear_search(array: list, query: int) -> tuple: Searches for the target element in the array and returns a tuple of the index and the number of comparisons made. Parameters: array (list): The array to search within. query (int): The target element to search for. Returns: tuple: A tuple containing the index of the target element and the count of comparisons made. If the element is not found, return (-1, comparison_count). ``` Input and Output Formats * **Input**: - `array`: A list of integers, where the number of elements (n) satisfies 0 <= n <= 10^6. - `query`: An integer representing the target element. * **Output**: - A tuple (index of the target element, count of comparisons made). If the element is not found, the index should be -1. Constraints * The elements in the array are integers and can have any order. * The array can be empty. Example ```python array = [4, 2, 7, 1, 3] query = 7 assert enhanced_linear_search(array, query) == (2, 3) # 7 is found at index 2 with 3 comparisons array = [4, 2, 7, 1, 3] query = 5 assert enhanced_linear_search(array, query) == (-1, 5) # 5 is not found with 5 comparisons in total ``` Explanation For the first example, the function should: 1. Compare `4` with `7` (1st comparison). 2. Compare `2` with `7` (2nd comparison). 3. Compare `7` with `7` (3rd comparison, match found). Thus, it returns `(2, 3)` because the target is at index 2 and it took 3 comparisons. For the second example, the function should: 1. Compare `4` with `5` (1st comparison). 2. Compare `2` with `5` (2nd comparison). 3. Compare `7` with `5` (3rd comparison). 4. Compare `1` with `5` (4th comparison). 5. Compare `3` with `5` (5th comparison). No match is found, so it returns `(-1, 5)`.","solution":"def enhanced_linear_search(array, query): comparisons = 0 for index, element in enumerate(array): comparisons += 1 if element == query: return index, comparisons return -1, comparisons"},{"question":"# Wiggle Sort Challenge Scenario: You are working on a data visualization tool and need to present data in a unique wave-like pattern. Given an array of integers, you need to reorder it such that elements at even indices are smaller than their neighbors and elements at odd indices are greater than their neighbors. Task: Write a function `wiggle_sort(nums)` that takes a list of integers `nums` and reorders it in-place to follow the pattern `nums[0] < nums[1] > nums[2] < nums[3]...`. Requirements: * **Input**: A list of integers `nums` of length n (1 <= n <= 1000). * **Output**: No return value. The list should be modified in place to meet the wiggle sorting criteria. * **Performance**: The solution should have a time complexity of O(n) and a space complexity of O(1). Function Signature: ```python def wiggle_sort(nums: List[int]) -> None: # Implement your solution here ``` Constraints and Assumptions: * All integers in the list are within the range of -1000 to 1000. * The list may contain negative numbers and duplicates. * You are not allowed to use any additional space for another array. Example: *Example 1*: ``` Input: nums = [3, 5, 2, 1, 6, 4] Output: [3, 5, 1, 6, 2, 4] Explanation: One possible wiggle sorted array is [3, 5, 1, 6, 2, 4] ``` *Example 2*: ``` Input: nums = [6, 4, 2, 1, 5, 3] Output: [4, 6, 1, 5, 2, 3] Explanation: One possible wiggle sorted array is [4, 6, 1, 5, 2, 3] ``` *Example 3*: ``` Input: nums = [1, 3, 2] Output: [1, 3, 2] Explanation: The array is already wiggle sorted. ``` Note: 1. Ensure your solution specifically modifies the input list as the desired output.","solution":"def wiggle_sort(nums): for i in range(len(nums) - 1): if i % 2 == 0: if nums[i] > nums[i + 1]: nums[i], nums[i + 1] = nums[i + 1], nums[i] else: if nums[i] < nums[i + 1]: nums[i], nums[i + 1] = nums[i + 1], nums[i]"},{"question":"One Edit Distance Context In text editing and correction software, it\'s crucial to determine how many edits (insertions, deletions, or substitutions) are needed to transform one string into another. This functionality is commonly used in spell checkers, autocorrect features, and diff tools. Task Your task is to write a function `is_one_edit_dist` that determines if two given strings `a` and `b` are exactly one edit distance apart. Function Signature ```python def is_one_edit_dist(a: str, b: str) -> bool: Determine if two strings are one edit distance apart. :param a: First input string. :param b: Second input string. :return: True if a and b are one edit distance apart, otherwise False. ``` Input - `a` (str): The first string (0 <= len(a) <= 10^4) - `b` (str): The second string (0 <= len(b) <= 10^4) Output - `bool`: Returns `True` if the strings are one edit distance apart, `False` otherwise. Examples ```python assert is_one_edit_dist(\\"abc\\", \\"ab\\") == True # One deletion assert is_one_edit_dist(\\"abc\\", \\"abcdef\\") == False # More than one edit assert is_one_edit_dist(\\"abc\\", \\"abx\\") == True # One substitution assert is_one_edit_dist(\\"abc\\", \\"abcd\\") == True # One insertion ``` Constraints - Do not use libraries that directly solve this problem. - Aim for O(n) time complexity where n is the length of the shorter string. Notes - Consider all possible one-edit operations including insertions, deletions, and substitutions. - Ensure your solution efficiently handles edge cases and large inputs.","solution":"def is_one_edit_dist(a: str, b: str) -> bool: Determine if two strings are one edit distance apart. :param a: First input string. :param b: Second input string. :return: True if a and b are one edit distance apart, otherwise False. len_a, len_b = len(a), len(b) # If the length difference is more than 1, they can\'t be one edit distance apart if abs(len_a - len_b) > 1: return False # Make sure a is the shorter string or they are of equal length if len_a > len_b: a, b = b, a len_a, len_b = len_b, len_a i, j = 0, 0 found_difference = False while i < len_a and j < len_b: if a[i] != b[j]: if found_difference: return False found_difference = True if len_a == len_b: # If lengths are equal, move both pointers i += 1 else: i += 1 j += 1 # Account for the last character being an additional character return found_difference or len_a != len_b"},{"question":"# Context: You are tasked with optimizing the logistics of a global shipping company. The company operates through a network of distribution centers spread across the world. The goal is to determine the shortest possible routes for packages traveling between any two distribution centers considering possible intermediary centers. # Problem Statement: Implement a function `all_pairs_shortest_path(adjacency_matrix)` that calculates the shortest path between all pairs of distribution centers. The input will be a square matrix `adjacency_matrix` where: - `adjacency_matrix[i][j]` represents the direct travel cost from center `i` to center `j`. - A value of 0 indicates the cost of travel from a center to itself. - No negative weights are provided, and no center can have a direct negative cost loop. **Function Signature**: ```python def all_pairs_shortest_path(adjacency_matrix: List[List[float]]) -> List[List[float]]: ``` **Input**: - `adjacency_matrix`: A 2D list of floats representing the travel costs between centers. **Output**: - A 2D list of floats where `result[i][j]` represents the shortest travel cost from center `i` to center `j`. **Constraints**: - The matrix dimensions will be `n x n` where `n` is the number of distribution centers and `1 <= n <= 100`. - Each travel cost will be a non-negative float. - Direct travel costs will not exceed `10^6`. # Example: **Input**: ```python adjacency_matrix = [ [0, 1.2, 4.5], [1.2, 0, 2.5], [4.5, 2.5, 0] ] ``` **Output**: ```python [ [0, 1.2, 3.7], [1.2, 0, 2.5], [3.7, 2.5, 0] ] ``` # Requirements: - Your implementation should handle n <= 100 efficiently. - The solution must avoid using any deprecated or non-standard Python libraries. - Include error handling for incorrect input formats. **Performance Tip**: - Consider reducing unnecessary computations based on initialization and comparison of the distance array to optimize performance.","solution":"from typing import List def all_pairs_shortest_path(adjacency_matrix: List[List[float]]) -> List[List[float]]: Calculates the shortest path between all pairs of distribution centers. n = len(adjacency_matrix) # Initialize the distance matrix with a copy of the adjacency matrix distance = [row[:] for row in adjacency_matrix] # Apply Floyd-Warshall algorithm for k in range(n): for i in range(n): for j in range(n): if distance[i][j] > distance[i][k] + distance[k][j]: distance[i][j] = distance[i][k] + distance[k][j] return distance"},{"question":"# Scenario You are given a city\'s road network represented as a directed graph, where intersections are nodes and roads are edges with certain capacities. Your task is to compute the maximum amount of traffic that can flow from the central intersection (source) to the main exit (sink) using the Ford-Fulkerson method with BFS. # Question Implement the `maximum_flow_bfs` function that computes the maximum flow in a given directed graph represented by an adjacency matrix. # Function Signature ```python def maximum_flow_bfs(adjacency_matrix: List[List[int]]) -> int: Finds the maximum flow in the given graph from the source node (0) to the sink node (last node). Parameters: adjacency_matrix (List[List[int]]): A 2D list representing the capacity graph. Returns: int: The value of the maximum possible flow. ``` # Input Format * A 2D list of integers `adjacency_matrix` representing the capacities of the edges between nodes in the graph. - `adjacency_matrix[i][j]` is the capacity of the edge from node `i` to node `j`. - Node `0` is the source, and `n-1` (last node) is the sink. # Output Format * An integer representing the maximum possible flow from the source to the sink. # Constraints * The number of nodes (n) can be between 2 and 100. * All capacities are non-negative integers and can go up to 10^5. * Assume there is at least one valid path from the source to the sink. # Example ```python graph = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] print(maximum_flow_bfs(graph)) # Expected output: 23 ``` # Notes * You need to handle updates to the residual graph correctly. * Be mindful of the memory and computational efficiency of your solution. * Think about potential edge cases and ensure your solution is robust.","solution":"from collections import deque from typing import List def bfs(residual_graph: List[List[int]], source: int, sink: int, parent: List[int]) -> bool: Perform BFS to find a path from source to sink in the residual graph. Updates the parent array to store the path. Returns True if a path is found, False otherwise. visited = [False] * len(residual_graph) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for ind, val in enumerate(residual_graph[u]): if not visited[ind] and val > 0: # Check for positive capacity queue.append(ind) visited[ind] = True parent[ind] = u if ind == sink: return True return False def maximum_flow_bfs(adjacency_matrix: List[List[int]]) -> int: Finds the maximum flow in the given graph from the source node (0) to the sink node (last node). Parameters: adjacency_matrix (List[List[int]]): A 2D list representing the capacity graph. Returns: int: The value of the maximum possible flow. source = 0 sink = len(adjacency_matrix) - 1 residual_graph = [list(row) for row in adjacency_matrix] parent = [-1] * len(adjacency_matrix) max_flow = 0 # Augment the flow while there is a path from source to sink while bfs(residual_graph, source, sink, parent): # Find the maximum flow through the path found by BFS path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, residual_graph[parent[s]][s]) s = parent[s] # update residual capacities of the edges and reverse edges along the path v = sink while v != source: u = parent[v] residual_graph[u][v] -= path_flow residual_graph[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"# Stooge Sort Enhancement & Implementation _ You are given a sorting task using a specified sorting algorithm, Stooge Sort. You need to perform two main tasks: 1. Enhance the Stooge Sort algorithm to minimize the recursive overhead while still maintaining the expected order of general Stooge Sort. 2. Implement a non-recursive version of Stooge Sort to better understand iterative problem-solving approaches. # Task Description: - **Function 1**: `enhanced_stooge_sort(arr: List[int], l: int, h: int) -> None` - **Input**: An input array `arr` and two integers `l`, `h` representing the start and end indices of the array section that needs to be sorted. - **Output**: The function modifies the input array such that the section from index `l` to index `h` is sorted in non-decreasing order. *Hint*: Minimize recursive calls for sections over a certain threshold length by checking other conditions. - **Function 2**: `iterative_stooge_sort(arr: List[int]) -> List[int]` - **Input**: An input array `arr` that needs to be sorted. - **Output**: A new array sorted in non-decreasing order, same as using Stooge Sort algorithm. # Constraints: - `1 <= len(arr) <= 10^3` - The values in the array are integers within a reasonable bound for sorting purposes. - Try to manage the highest time complexity impact through optimization or hybrid methods. # Example: ```python # Given an array arr = [5, 1, 6, 3, 8, 7] # Expected outcome after sorting (examples): enhanced_stooge_sort(arr, 0, len(arr) - 1) # arr should be [1, 3, 5, 6, 7, 8] # Testing iterative approach sorted_arr = iterative_stooge_sort([5, 1, 6, 3, 8, 7]) # sorted_arr should be [1, 3, 5, 6, 7, 8] ``` # Note: - Ensure your solution handles edge cases and maintains valid bounds for all operations. - Provide a brief explanation of your enhancement and any optimizations applied in comments within your code.","solution":"def enhanced_stooge_sort(arr, l, h): Enhanced Stooge Sort with reduced recursive calls for optimized performance. if l >= h: return # If first element is greater than last, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than 2 elements in the segment if h - l + 1 > 2: t = (h - l + 1) // 3 # Sort first 2/3rd enhanced_stooge_sort(arr, l, h - t) # Sort last 2/3rd enhanced_stooge_sort(arr, l + t, h) # Sort first 2/3rd again to ensure order enhanced_stooge_sort(arr, l, h - t) def iterative_stooge_sort(arr): Iterative version of Stooge Sort based on non-recursive sorting. n = len(arr) for i in range(n): for j in range(n - i - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] return arr"},{"question":"# Graph Traversal: Discovery and Path Storage **Problem Statement:** You are provided two fundamental graph traversal algorithms: Depth First Search (DFS) and Breadth First Search (BFS). Your task is to augment these algorithms to not only return the set of visited nodes but also to keep track of the path followed to reach each node. You need to implement both DFS and BFS to store the traversal path as a list for a given graph input. Each path should start from the source node and follow the order of traversal until the current node. # Function Signature ```python def dfs_with_path(graph: dict, start: int) -> dict: pass def bfs_with_path(graph: dict, start: int) -> dict: pass ``` # Input - `graph`: A dictionary where keys represent nodes of the graph and values are lists of adjacent nodes. - `start`: An integer representing the starting node for traversal. # Output - Returns a dictionary where keys are the nodes that have been visited and values are lists representing the path taken from the start node to that node. # Constraints 1. The graph is represented as an adjacency list. 2. The graph may have cycles. 3. The graph can be either directed or undirected. 4. The graph nodes are labeled by non-negative integers. 5. The start node exists in the graph. 6. You may assume there are no duplicate edges or nodes. # Example ```python graph = { 0: [1, 2], 1: [2], 2: [3], 3: [1, 2] } start = 0 assert dfs_with_path(graph, start) == { 0: [0], 1: [0, 1], 2: [0, 2], 3: [0, 2, 3] } assert bfs_with_path(graph, start) == { 0: [0], 1: [0, 1], 2: [0, 2], 3: [0, 1, 2, 3] } ``` # Note: 1. The path stored in the output should be in the order the nodes were visited. 2. Your solution should handle all edge cases, including graphs with cycles and disjoint graphs. Ensure that your traversal does not fall into infinite loops.","solution":"def dfs_with_path(graph, start): def dfs(v, path): visited[v] = path[:] for neighbor in graph.get(v, []): if neighbor not in visited: dfs(neighbor, path + [neighbor]) visited = {} dfs(start, [start]) return visited def bfs_with_path(graph, start): from collections import deque visited = {} queue = deque([(start, [start])]) while queue: node, path = queue.popleft() if node not in visited: visited[node] = path for neighbor in graph.get(node, []): if neighbor not in visited: queue.append((neighbor, path + [neighbor])) return visited"},{"question":"# Question: Implement a Unique Element Counter Your task is to write a function that takes a list of integers and returns the count of unique elements that appear exactly once in the list. Function Signature ```python def count_unique_elements(input_list: list) -> int: Count the number of unique elements that appear exactly once. :param input_list: list of integers :return: count of unique elements ``` Input * A list of integers `input_list` where: * The length of the list is between (0) and (10^6). * The integers are in the range (-10^9) to (10^9). Output * An integer representing the number of unique elements that occur exactly once in the input list. Examples ```python # Example 1 input_list = [3, 3, 2, 1] # 2 and 1 appear exactly once # Output: 2 # Example 2 input_list = [2, 3, 5, 5, 5, 6, 4, 3, 7] # 2, 4, 6, and 7 appear exactly once # Output: 4 # Example 3 input_list = [] # No elements, thus no unique elements # Output: 0 ``` Constraints * You should aim to achieve O(n) time complexity for your solution. * Consider edge cases, such as an empty input list. Notes You can use the provided `get_histogram` function as a building block for your solution or build your own frequency counting mechanism.","solution":"def count_unique_elements(input_list: list) -> int: Count the number of unique elements that appear exactly once. :param input_list: list of integers :return: count of unique elements frequency = {} # Build frequency dictionary for num in input_list: if num in frequency: frequency[num] += 1 else: frequency[num] = 1 # Count elements that appear exactly once unique_count = 0 for count in frequency.values(): if count == 1: unique_count += 1 return unique_count"},{"question":"# Atbash Cipher Implementation Challenge You have been hired as a software engineer tasked with developing a feature for an encryption tool. Specifically, you need to implement the Atbash cipher, which is a simple substitution cipher that maps each letter of the alphabet to its reverse. **Function Signature:** ```python def atbash_cipher(input_string: str) -> str: ``` **Input:** - `input_string` (str): A string that contains the text to be encrypted. The string can include upper and lower case alphabet letters, digits, punctuation, and spaces. **Output:** - Returns a string that represents the encrypted text. **Constraints:** - The input string will have a length of at least 1 and at most 10^4 characters. - Non-alphabet characters should remain unchanged in the output string. - The algorithm should handle both upper and lowercase letters correctly. **Performance Requirements:** - The implementation should run in linear time relative to the input string length. **Example:** ```python assert atbash_cipher(\\"Attack at dawn\\") == \\"Zggzxp zg wzdm\\" assert atbash_cipher(\\"Hello, World!\\") == \\"Svool, Dliow!\\" assert atbash_cipher(\\"abcdXYZ!\\") == \\"zyxwCBA!\\" ``` **Scenario:** You are working on an encryption tool for maintaining confidentiality of ancient texts being digitized. Your task is to implement the Atbash cipher in the tool to provide encoded versions of these texts as a reversible step. Write a function `atbash_cipher` that converts the given text to its Atbash cipher equivalent, ensuring all non-letter characters remain unchanged.","solution":"def atbash_cipher(input_string: str) -> str: Apply the Atbash cipher to an input string, replacing each letter with its reverse in the alphabet, and leaving all non-letter characters unchanged. :param input_string: str : the original text to be encrypted :returns: str : the encrypted text encrypted_string = [] for char in input_string: if char.isalpha(): if char.isupper(): # Calculate reversed character for uppercase letters encrypted_char = chr(65 + (90 - ord(char))) else: # Calculate reversed character for lowercase letters encrypted_char = chr(97 + (122 - ord(char))) encrypted_string.append(encrypted_char) else: # Non-alphabetic characters remain unchanged encrypted_string.append(char) return \\"\\".join(encrypted_string)"},{"question":"# Task You need to implement a function that sorts an array of integers in ascending order. However, unlike typical Heap Sort which uses either a Max Heap or a Min Heap, your implementation should start by building both a Max Heap and a Min Heap simultaneously. The array should be sorted based on the priority assigned to either of these heaps: * **Max Priority**: Use the Max Heap logic for most elements but spice up some nodes by comparing with Min Heap nodes to ensure novelty. * **Min Priority**: Use the Min Heap logic predominantly, but a few nodes prioritize Max Heap rules. # Function Signature ```python def hybrid_heap_sort(arr: list[int], max_priority=True, simulation=False) -> list[int]: pass ``` # Parameters * `arr`: List of integers to be sorted. * `max_priority`: Boolean flag indicating the dominant heap logic (default is `True` for Max Priority). * `simulation`: Boolean flag for printing the steps during sorting (default is `False`). # Returns * The function should return the sorted array in ascending order. # Examples ```python print(hybrid_heap_sort([3, 6, 5, 0, 8, 2, 1, 9])) # Output: [0, 1, 2, 3, 5, 6, 8, 9] print(hybrid_heap_sort([3, 6, 5, 0, 8, 2, 1, 9], max_priority=False)) # Output may vary slightly but must be sorted ``` # Constraints * The array can have up to `10^4` elements. * The elements in the array can range from `-10^3` to `10^3`. # Requirements 1. Your function should ensure that the array is sorted correctly. 2. Demonstrate usage of both Max Heap and Min Heap. 3. Provide a feature to print out iterations if `simulation` is `True`.","solution":"def hybrid_heap_sort(arr, max_priority=True, simulation=False): def max_heapify(arr, n, i): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[i] < arr[left]: largest = left if right < n and arr[largest] < arr[right]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] max_heapify(arr, n, largest) def min_heapify(arr, n, i): smallest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[i] > arr[left]: smallest = left if right < n and arr[smallest] > arr[right]: smallest = right if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] min_heapify(arr, n, smallest) def build_max_heap(arr, n): for i in range(n // 2 - 1, -1, -1): max_heapify(arr, n, i) def build_min_heap(arr, n): for i in range(n // 2 - 1, -1, -1): min_heapify(arr, n, i) def heap_sort(arr, max_priority): n = len(arr) if max_priority: build_max_heap(arr, n) for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] max_heapify(arr, i, 0) if simulation: print(arr) else: build_min_heap(arr, n) sorted_arr = [] for i in range(n): sorted_arr.append(arr[0]) arr[0], arr[-1] = arr[-1], arr[0] arr.pop() min_heapify(arr, len(arr), 0) if simulation: print(sorted_arr + arr) arr.extend(sorted_arr) heap_sort(arr, max_priority) return arr"},{"question":"# Reverse Words in a Sentence Given a string sentence, write a function `reverse_words_in_sentence(sentence)` that reverses the words of the sentence in place. The function should return the resulting string with the words in reverse order. Input - A single string, `sentence`, which may contain multiple words separated by spaces. The string may also have leading or trailing spaces, and may contain multiple spaces between words. Output - A single string with the words in reverse order, with only one space between words and no leading or trailing spaces. Constraints - You may assume that the input string will not be empty and will only contain alphabetic characters and spaces. - The function should perform efficiently, within linear time complexity. Example ```python def reverse_words_in_sentence(sentence: str) -> str: # Implement the function here pass # Test the function sentence1 = \\"Hello world\\" print(reverse_words_in_sentence(sentence1)) # Output: \\"world Hello\\" sentence2 = \\" This is a test \\" print(reverse_words_in_sentence(sentence2)) # Output: \\"test a is This\\" ``` **Explanation**: The function splits the input string into words, removes any leading or trailing spaces or excessive spaces, reverses the words list, and joins them back into a single string, ensuring that the words are separated by a single space.","solution":"def reverse_words_in_sentence(sentence: str) -> str: Reverses the words in a sentence. Parameters: sentence (str): The input sentence which may contain multiple words separated by spaces. Returns: str: The resulting string with words in reverse order. # Split the sentence into words by spaces, and remove extra spaces words = sentence.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed words into a single string separated by a single space return \' \'.join(reversed_words)"},{"question":"# RLE Challenge **Context**: You\'ve just been hired by a software company that manages a large database of simple graphic images. To optimize storage, the company uses Run-Length Encoding (RLE) to compress the image data. Your task is to implement both the encoding and decoding process using RLE. **Problem**: Write two functions: 1. `encode_rle(input: str) -> str` 2. `decode_rle(input: str) -> str` **Function 1: encode_rle** * Input: A string representing the image data to be compressed. * Output: The RLE encoded string. **Function 2: decode_rle** * Input: A RLE encoded string. * Output: The original string after decoding. # Input Format: * The input to `encode_rle` and `decode_rle` functions will be a single string. # Output Format: * The output of `encode_rle` will be a single string representing the compressed data. * The output of `decode_rle` will be a single string representing the decompressed data. # Constraints: * The input string for encoding and decoding will only contain uppercase and lowercase letters (A-Z, a-z). * The length of the input string will be at most 10^7 characters. * Ensure your solution handles edge cases, such as emptiness and lack of consecutive repeated characters. # Performance Requirements: * Optimize for time complexity O(n) for both encoding and decoding, where n is the length of the input string. * Keep space complexity to O(1) additional space beyond input and output. # Example: ```python # encode_rle examples encode_rle(\\"AAAABBBCCDAA\\") => \\"4A3B2C1D2A\\" encode_rle(\\"AABBCC\\") => \\"2A2B2C\\" encode_rle(\\"\\") => \\"\\" # decode_rle examples decode_rle(\\"4A3B2C1D2A\\") => \\"AAAABBBCCDAA\\" decode_rle(\\"2A2B2C\\") => \\"AABBCC\\" decode_rle(\\"\\") => \\"\\" ``` Note: The provided function definitions should be used to ensure correct implementation.","solution":"def encode_rle(input: str) -> str: if not input: return \\"\\" encoded_str = [] count = 1 previous_char = input[0] for char in input[1:]: if char == previous_char: count += 1 else: encoded_str.append(f\\"{count}{previous_char}\\") previous_char = char count = 1 # Append the last run encoded_str.append(f\\"{count}{previous_char}\\") return \'\'.join(encoded_str) def decode_rle(input: str) -> str: if not input: return \\"\\" decoded_str = [] count = \\"\\" for char in input: if char.isdigit(): count += char else: decoded_str.append(char * int(count)) count = \\"\\" return \'\'.join(decoded_str)"},{"question":"# Kruskal\'s Algorithm: Find the Minimum Spanning Tree Problem Statement: Given a connected, undirected graph with `n` vertices and `m` edges, find the Minimum Spanning Tree (MST) of the graph using Kruskal’s algorithm and compute the sum of the weights of the edges in this MST. Input: * The first line contains two integers `n` and `m` — the number of vertices and edges in the graph respectively. * Each of the following `m` lines contains three integers `u`, `v`, and `w`, describing an edge between vertex `u` and vertex `v` with weight `w`. Output: * Output the sum of the weights of the MST. Constraints: * (1 leq n leq 10^5) * (0 leq m leq 2 times 10^5) * (1 leq u, v leq n) * The graph is guaranteed to be connected. Example: ```plaintext Input: 5 6 1 2 3 1 3 8 2 4 5 3 4 2 3 5 4 4 5 6 Output: 14 ``` Explanation: In the given example, the graph has 5 vertices and 6 edges. The edges of the MST include (3-4), (1-2), (3-5), (2-4) with weights 2, 3, 4, 5 respectively, hence the sum is 14.","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal(n, edges): result = [] i = 0 e = 0 edges.sort(key=lambda item: item[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) while e < n - 1: u, v, w = edges[i] i = i + 1 x = find(parent, u - 1) y = find(parent, v - 1) if x != y: e = e + 1 result.append(w) union(parent, rank, x, y) return sum(result)"},{"question":"# Question: Implement and Enhance Nested Dictionary Traversal Given a nested dictionary, implement a function `enhanced_tree_print(tree)` that traverses the dictionary and prints its contents in a structured and hierarchical manner. Your implementation should improve upon the provided `tree_print` function by addressing performance bottlenecks and extending it to handle additional edge cases and data types. Requirements: 1. **Input**: A nested dictionary where keys are strings and values are lists containing strings or further nested dictionaries. ```python Example: { \'a\': [\'Adam\', {\'Book\': 4}], \'b\': [\'Bill\', {\'Computer\': 5, \'TV\': 6}, \'Jill\', {\'Sports\': 1}], \'c\': [\'Bill\', {\'Sports\': 3}], \'d\': [\'Adam\', {\'Computer\': 3}, \'Quin\', {\'Computer\': 3}], \'e\': [\'Quin\', {\'Book\': 5, \'TV\': 2}], \'f\': [\'Adam\', {\'Computer\': 7}] } ``` 2. **Output**: Print the elements in the specified hierarchical format. ``` a -> Adam Book -> 4 b -> Bill Computer -> 5 TV -> 6 Jill Sports -> 1 c -> Bill Sports -> 3 d -> Adam Computer -> 3 Quin Computer -> 3 e -> Quin Book -> 5 TV -> 2 f -> Adam Computer -> 7 ``` Constraints: * You should minimize the number of dictionary lookups. * Ensure the function is robust to handle different data types and nested structures. Implementation Guidelines: 1. Use caching for minimizing dictionary lookups. 2. Handle nested dictionaries recursively. 3. Include error handling for unexpected data types. 4. Add appropriate indentations and line breaks for readability. Example: ```python def enhanced_tree_print(tree): # Your implementation here pass # Example tree tree = { \'a\': [\'Adam\', {\'Book\': 4}], \'b\': [\'Bill\', {\'Computer\': 5, \'TV\': 6}, \'Jill\', {\'Sports\': 1}], \'c\': [\'Bill\', {\'Sports\': 3}], \'d\': [\'Adam\', {\'Computer\': 3}, \'Quin\', {\'Computer\': 3}], \'e\': [\'Quin\', {\'Book\': 5, \'TV\': 2}], \'f\': [\'Adam\', {\'Computer\': 7}] } enhanced_tree_print(tree) ``` **Hint**: Consider using a helper function for the recursive calls to simplify the main function logic.","solution":"def enhanced_tree_print(tree): Print the contents of a nested dictionary in a structured, hierarchical manner. def print_recursive(data, indent=0): for item in data: if isinstance(item, dict): for k, v in item.items(): print(\\" \\" * indent + f\\"{k} -> {v}\\") else: print(\\" \\" * indent + f\\"{item}\\") if isinstance(item, list): print_recursive(item, indent + 4) for k, v in tree.items(): print(f\\"{k} -> {v[0]}\\") if len(v) > 1: print_recursive(v[1:], indent=4) # Example tree tree = { \'a\': [\'Adam\', {\'Book\': 4}], \'b\': [\'Bill\', {\'Computer\': 5, \'TV\': 6}, \'Jill\', {\'Sports\': 1}], \'c\': [\'Bill\', {\'Sports\': 3}], \'d\': [\'Adam\', {\'Computer\': 3}, \'Quin\', {\'Computer\': 3}], \'e\': [\'Quin\', {\'Book\': 5, \'TV\': 2}], \'f\': [\'Adam\', {\'Computer\': 7}] } enhanced_tree_print(tree)"},{"question":"# Description: You are given two integers, A and B. Your task is to determine the minimal number of bits you need to flip to convert integer A to integer B. # Input: - Two integers A and B, where (0 <= A, B <= 2^31 - 1). # Output: - A single integer representing the number of bits that need to be flipped. # Constraints: - The integers A and B are non-negative. - You must minimize both time and space complexity. - Try to optimize the use of bitwise operations. # Example: ```plaintext Input: 29 15 Output: 2 ``` Explanation: Binary representation of 29 is 11101 and 15 is 01111. To convert 11101 to 01111, flip two bits (the first and the fifth least significant bits). # Function Signature: ```python def count_flips_to_convert(a: int, b: int) -> int: # Your code here ``` # Note: - You cannot use any built-in functions except basic operators and control structures. - Consider edge cases such as when integers A and B are the same.","solution":"def count_flips_to_convert(a: int, b: int) -> int: Returns the number of bits that need to be flipped to convert integer a to integer b. xor_result = a ^ b flip_count = 0 while xor_result: flip_count += xor_result & 1 xor_result >>= 1 return flip_count"},{"question":"# Question: Implement Counting Digits in Alternative Bases Traditionally, the number of digits in a number is counted in base 10 using logarithmic properties. However, different applications may require digit counting in various bases. You are tasked with implementing a function that calculates the number of digits of a given integer in any specified base. **Function Signature** ```python def num_digits_in_base(n: int, base: int) -> int: ``` **Input** - `n` (integer): The integer number to count digits for. Can be positive, negative, or zero. - `base` (integer): The base in which to count digits. Guaranteed to be greater than 1. **Output** - Returns an integer representing the count of digits of `n` when expressed in the specified base. **Constraints** - The base is greater than 1. - Avoid using string conversion methods to count digits. **Examples** - `num_digits_in_base(345, 10)` should return `3`. - `num_digits_in_base(16, 2)` should return `5`. - `num_digits_in_base(-100, 10)` should return `3`. **Notes** - Consider edge cases such as zero and negative numbers. - Avoid string conversion to ensure the solution scales well for large numbers. # Example ```python def num_digits_in_base(n: int, base: int) -> int: if n == 0: return 1 n = abs(n) return int(math.log(n, base)) + 1 ``` Implement the function `num_digits_in_base` ensuring it behaves correctly based on the given examples and constraints.","solution":"import math def num_digits_in_base(n: int, base: int) -> int: if n == 0: return 1 n = abs(n) return int(math.log(n, base)) + 1"},{"question":"# Question You are given an implementation of two functions that `stutter` the elements of a stack. The `stutter` function replaces every value in a stack with two occurrences of that value: ```python bottom [3, 7, 1, 14, 9] top ``` will become: ```python bottom [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] top ``` Implement a function `third_stutter(stack)` which uses no auxiliary data structures (neither a queue nor a stack, but simple lists). The goal is to achieve the same outcome with O(1) additional space. Constraints 1. You may use only list operations and avoid using any in-built data structures like collections.dequeue. 2. The original stack should be modified in place (no need to return a new stack). Function Signature ```python def third_stutter(stack: list) -> None: pass ``` Input - The input stack will be provided as a list of integers, where the end of the list represents the top of the stack. Output - The function should modify the stack directly without returning anything. Example ```python stack = [3, 7, 1, 14, 9] third_stutter(stack) print(stack) # Output should be: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` Requirements 1. Time complexity should remain O(n). 2. Space complexity should be O(1), meaning no additional space proportional to the size of the input stack.","solution":"def third_stutter(stack): This function modifies the passed stack in-place such that every element in the stack is duplicated. i = 0 while i < len(stack): # Insert a duplicate of stack[i] at position i+1 stack.insert(i + 1, stack[i]) i += 2 # Move to the next original element"},{"question":"**Context**: You are given an array of digits representing a non-negative integer, where the most significant digit is at the head of the list. Your task is to implement a function that increments this number by one and returns the resulting array of digits. **Function Signature**: ```python def increment_number(digits: List[int]) -> List[int]: pass ``` **Input Format**: - A list of integer digits `digits` where each element is in the range 0 - 9. - The list represents a non-negative integer. **Output Format**: - Return a list of integers representing the incremented number. **Constraints**: - You may not use built-in arbitrary-precision arithmetic functions. - You should modify the input list in place if possible to optimize space. **Performance Requirements**: - Time Complexity: O(n) - Space Complexity: O(1) (Modifications in place are preferred) **Example**: ```python # Example 1 input: digits = [1, 2, 3] output: [1, 2, 4] # Example 2 input: digits = [9, 9, 9] output: [1, 0, 0, 0] # Example 3 input: digits = [0] output: [1] ``` Implement your solution in the function `increment_number`.","solution":"from typing import List def increment_number(digits: List[int]) -> List[int]: Increments the given array of digits by one. Args: digits (List[int]): List of digits representing a number. Returns: List[int]: List of digits representing the incremented number. n = len(digits) # Traverse the digits from the end to start for i in range(n-1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits # set digit to 0 as we support carry over digits[i] = 0 # If all digits are 9, we are here as an edge case return [1] + [0] * n"},{"question":"# B-Tree Coding Assessment Question Problem Statement: You are tasked with implementing two critical functionalities for a B-Tree: merging and rotation optimization. A B-Tree is a balanced tree data structure used in databases and file systems for rapid data retrieval and maintaining sorted data. You have to implement the `merge_nodes` and `rotate_left` functionalities which are crucial for maintaining the B-Tree properties during deletion operations. - The `merge_nodes` function combines two sibling nodes into one when a node is below the minimum threshold of keys. - The `rotate_left` function moves a key from a sibling node to ensure that each node maintains the minimum required keys and balances the tree. Your task is to complete these two functions while ensuring the tree remains balanced and efficient. Implementation Requirements: 1. **`merge_nodes(parent: Node, child1_index: int, child2_index: int) -> None`**: * **Input**: * `parent` - The parent node of the two children to be merged. * `child1_index` - The index of the first child. * `child2_index` - The index of the second child. * **Output**: None. The function should modify the B-Tree in place by merging the two children. 2. **`rotate_left(parent: Node, child_index: int) -> None`**: * **Input**: * `parent` - The parent node of the children involved in the rotation. * `child_index` - The index of the child which requires a key from its right sibling. * **Output**: None. The function should modify the B-Tree in place by rotating a key from the right sibling to the left sibling. Input Format: * For simplicity, assume that the B-Tree and Node classes are already implemented, and you\'ll be working directly with Node objects. Output Format: * No direct output is expected. The B-Tree structure should be modified accordingly. Constraints: * Degree `t` is a positive integer greater than 1. Examples: Assuming a B-Tree of degree `t=3`: ```python root = Node() root.keys = [10, 20] child1 = Node() child1.keys = [5, 7] child2 = Node() child2.keys = [15, 18] child3 = Node() child3.keys = [25, 30] root.children = [child1, child2, child3] # Perform left rotate operation rotate_left(root, 1) # After rotation child2 should have [18], root should have [10, 20], and child3 should have [30] print(root) print(child1) print(child2) print(child3) ``` You should write complete implementations for `merge_nodes` and `rotate_left` based on the above specifications and examples.","solution":"class Node: def __init__(self, t): self.t = t # Minimum degree (defines the range for number of keys) self.keys = [] # List of keys self.children = [] # List of children Nodes def merge_nodes(parent, child1_index, child2_index): Merge two children nodes at indices child1_index and child2_index from the parent node. child1 = parent.children[child1_index] child2 = parent.children[child2_index] # Move the separator key from the parent into child1 sep_key = parent.keys.pop(child1_index) child1.keys.append(sep_key) # Merge keys and children from child2 into child1 child1.keys.extend(child2.keys) child1.children.extend(child2.children) # Remove child2 from the parent\'s children list parent.children.pop(child2_index) def rotate_left(parent, child_index): Rotate keys to the left by taking a key from the right sibling. child = parent.children[child_index] right_sibling = parent.children[child_index + 1] # Move the separating key from the parent to the child separator_key = parent.keys[child_index] child.keys.append(separator_key) # Move the first key from the right sibling to the parent new_separator_key = right_sibling.keys.pop(0) parent.keys[child_index] = new_separator_key # If right sibling has children, transfer the first one to the child if right_sibling.children: child.children.append(right_sibling.children.pop(0))"},{"question":"# Meeting Room Scheduling Problem Problem Statement You are given an array of meeting time intervals consisting of start times and end times `[[s1, e1], [s2, e2], ...]` where `si < ei` for each interval. Your task is to determine if a person could attend all the meetings without any overlaps. Write a function `can_attend_meetings(intervals)` that takes a list of intervals as an input and returns a boolean value indicating whether it is possible to attend all the meetings without any overlap. Input and Output - **Input**: A list of intervals `intervals`, where each interval is a list `[start, end]` with `start` and `end` as integers representing the start and end time of a meeting. - **Output**: A boolean value `True` if the person can attend all meetings without conflict, `False` otherwise. Constraints 1. (0 leq text{number of intervals} leq 10^4) 2. (0 leq text{start time, end time} leq 10^6) 3. (0 leq text{start time} < text{end time}) for each interval Example 1. **Example 1**: - Input: `[[0, 30], [5, 10], [15, 20]]` - Output: `False` - Explanation: The interval `[5, 10]` overlaps with `[0, 30]`, so it is not possible to attend all meetings. 2. **Example 2**: - Input: `[[7, 10], [2, 4]]` - Output: `True` - Explanation: There are no overlapping intervals, so it is possible to attend all meetings. Function Signature ```python def can_attend_meetings(intervals: List[List[int]]) -> bool: # Your code here ``` Write your implementation for the `can_attend_meetings` function. Ensure your code efficiently handles the constraints mentioned.","solution":"def can_attend_meetings(intervals): Determine if a person could attend all the meetings without any overlaps. Args: intervals (List[List[int]]): A list of meeting time intervals where each interval is a list of two integers [start, end]. Returns: bool: True if a person can attend all the meetings without any overlaps, False otherwise. # Sort intervals by start time intervals.sort(key=lambda x: x[0]) # Check each interval against the next one for overlap for i in range(1, len(intervals)): # If the current meeting starts before the previous meeting ends if intervals[i][0] < intervals[i-1][1]: return False return True"},{"question":"# Matrix Multiplication Implementation You are required to implement a matrix multiplication function that will take two compatible 2-D matrices and return their product. The matrices will be represented as lists of lists, containing integer elements. Requirements - **Function Signature**: `def multiply(multiplicand: list, multiplier: list) -> list:` - **Input**: - `multiplicand` and `multiplier`: lists of lists of integers representing the two matrices. - Both matrices will contain integers, and you can assume that each inner list (row) has consistent length within the matrix. - **Output**: - A new matrix (list of lists) which is the product of the `multiplicand` and `multiplier` matrices. Constraints - The number of columns in the `multiplicand` matrix must equal the number of rows in the `multiplier` matrix. Otherwise, the function should raise a relevant exception. - All entries in the matrices are integers. - Keep efficiency in mind; although for this exercise, you do not need to implement advanced techniques beyond basic nested loops. Examples 1. **Example 1**: - **Input**: ```python multiplicand = [ [1, 2], [3, 4] ] multiplier = [ [2, 0], [1, 2] ] ``` - **Output**: ```python result = [ [4, 4], [10, 8] ] ``` 2. **Example 2**: - **Input**: ```python multiplicand = [ [2, 4], [1, 3], [1, 2] ] multiplier = [ [1, 2, 3], [4, 5, 6] ] ``` - **Output**: ```python result = [ [18, 24, 30], [13, 17, 21], [9, 12, 15] ] ``` 3. **Edge Case**: - **Input**: ```python multiplicand = [[1, 2]] multiplier = [[3], [4]] ``` - **Output**: ```python result = [[11]] ``` **Note**: Make sure to handle edge cases like empty matrices or non-uniform inner list lengths gracefully by raising appropriate exceptions.","solution":"def multiply(multiplicand, multiplier): Multiplies two matrices where multiplicand is an n x m matrix (n rows, m columns) and multiplier is an m x p matrix (m rows, p columns). Returns the resulting n x p matrix. Parameters: multiplicand (list of lists of ints): The first matrix to be multiplied. multiplier (list of lists of ints): The second matrix to be multiplied. Returns: list of lists of ints: The product of the two matrices. Raises: ValueError: If the number of columns in multiplicand does not equal the number of rows in multiplier. if not multiplicand or not multiplier: raise ValueError(\\"Input matrices must not be empty.\\") num_rows_multiplicand = len(multiplicand) num_cols_multiplicand = len(multiplicand[0]) num_rows_multiplier = len(multiplier) num_cols_multiplier = len(multiplier[0]) if num_cols_multiplicand != num_rows_multiplier: raise ValueError(\\"Number of columns in multiplicand must equal number of rows in multiplier\\") # Initialize the result matrix with zeros result = [[0] * num_cols_multiplier for _ in range(num_rows_multiplicand)] # Perform matrix multiplication for i in range(num_rows_multiplicand): for j in range(num_cols_multiplier): result[i][j] = sum(multiplicand[i][k] * multiplier[k][j] for k in range(num_cols_multiplicand)) return result"},{"question":"# Minimum Spanning Tree with Kruskal’s Algorithm Context You are given a graph that is connected and undirected. Your task is to find the sum of the weights of the edges in the Minimum Spanning Tree (MST) using Kruskal’s algorithm. This problem tests your understanding of graph algorithms, specifically MST, and the use of the Disjoint-Set data structure. Problem Statement Write a function `kruskal_mst(vertex_count, edge_list)` in Python that takes: * `vertex_count` (int): the number of vertices in the graph. * `edge_list` (list of tuples): a list of tuples where each tuple contains three integers `(source, target, weight)` representing an edge between `source` and `target` vertices with the given weight. The function should return: * `int`: the sum of the weights of the edges in the MST. Input * `vertex_count`: Integer (2 leq vertex_count leq 1000). * `edge_list`: List of tuples where each tuple contains three integers representing an edge. Each edge weight is a positive integer, and there are between (1) and (5000) edges. Output * An integer representing the sum of the weights of the MST. Constraints * The graph is guaranteed to be connected. Edge Cases * The minimum number of vertices is 2. * Graphs where multiple MSTs are possible with the same weight. Example ```python vertex_count = 5 edge_list = [ (1, 2, 3), (1, 3, 8), (2, 4, 5), (3, 4, 2), (3, 5, 4), (4, 5, 6) ] # Expected output: 14 print(kruskal_mst(vertex_count, edge_list)) vertex_count = 3 edge_list = [ (2, 1, 20), (3, 1, 20), (2, 3, 100) ] # Expected output: 40 print(kruskal_mst(vertex_count, edge_list)) ```","solution":"def kruskal_mst(vertex_count, edge_list): Returns the sum of the weights of the edges in the Minimum Spanning Tree (MST) using Kruskal\'s algorithm. # Sort edges based on their weights sorted_edges = sorted(edge_list, key=lambda edge: edge[2]) # Initialize the Disjoint-Set data structure parent = list(range(vertex_count + 1)) rank = [0] * (vertex_count + 1) def find(v): if parent[v] != v: parent[v] = find(parent[v]) return parent[v] def union(v1, v2): root1 = find(v1) root2 = find(v2) if root1 != root2: if rank[root1] > rank[root2]: parent[root2] = root1 elif rank[root1] < rank[root2]: parent[root1] = root2 else: parent[root2] = root1 rank[root1] += 1 mst_weight_sum = 0 edge_count = 0 for edge in sorted_edges: u, v, weight = edge # Include the edge if it does not form a cycle if find(u) != find(v): union(u, v) mst_weight_sum += weight edge_count += 1 # Stop if we already have n-1 edges in the MST if edge_count == vertex_count - 1: break return mst_weight_sum"},{"question":"# Question: Optimizing Quick Sort for Improved Performance The QuickSort algorithm is efficient for sorting large datasets but suffers from poor performance in certain cases, such as when the input array is already sorted or contains many duplicate elements. A common optimization involves using the \\"median-of-three\\" pivot choice and switching to insertion sort for small sub-arrays. Your task is to implement an enhanced version of the QuickSort algorithm that incorporates these optimizations. Specifically, you need to: 1. Implement median-of-three pivot selection. 2. Switch to insertion sort for sub-arrays smaller than a given threshold `k`. # Function Signature: ```python def optimized_quick_sort(arr, k): Sorts an array using an optimized version of QuickSort. Parameters: arr (List[int]): The array to be sorted. k (int): The size of sub-arrays below which insertion sort should be used. Returns: List[int]: The sorted array. ``` # Input: * `arr`: A list of integers to sort. * `k`: An integer threshold for switching to insertion sort. # Output: * A sorted list of integers. # Constraints: * The elements of `arr` are integers. * 1 <= len(arr) <= 10^4 * -10^9 <= arr[i] <= 10^9 for 0 <= i < len(arr) # Example: ```python arr = [3, 2, 1, 5, 4, 6] k = 3 print(optimized_quick_sort(arr, k)) # Output: [1, 2, 3, 4, 5, 6] ``` # Additional Guidelines: 1. Use the median-of-three method for pivot selection: Choose the median of the first, middle, and last elements of the sub-array. 2. When the size of a sub-array is less than `k`, switch to insertion sort to sort that sub-array. 3. Ensure the implementation handles edge cases, such as small arrays, and arrays with all equal elements.","solution":"def insertion_sort(arr, low, high): for i in range(low + 1, high + 1): key = arr[i] j = i - 1 while j >= low and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def median_of_three(arr, low, mid, high): if arr[low] > arr[mid]: arr[low], arr[mid] = arr[mid], arr[low] if arr[mid] > arr[high]: arr[mid], arr[high] = arr[high], arr[mid] if arr[low] > arr[mid]: arr[low], arr[mid] = arr[mid], arr[low] return arr[mid] def partition(arr, low, high): mid = (low + high) // 2 pivot = median_of_three(arr, low, mid, high) arr[mid], arr[high] = arr[high], arr[mid] pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quick_sort(arr, low, high, k): if high - low + 1 <= k: insertion_sort(arr, low, high) else: if low < high: pi = partition(arr, low, high) quick_sort(arr, low, pi - 1, k) quick_sort(arr, pi + 1, high, k) def optimized_quick_sort(arr, k): if not arr: return [] quick_sort(arr, 0, len(arr) - 1, k) return arr"},{"question":"You are given a string `s` and you need to determine if it is a palindrome. A palindrome is defined as a string that reads the same forward and backward, ignoring non-alphanumeric characters and case differences. # Requirements: 1. Implement a function `is_palindrome(s: str) -> bool` that: - Takes a single string `s` as input. - Returns `True` if the string is a palindrome, `False` otherwise. 2. You must implement the function using the two-pointer technique. The function should be efficient with a linear time complexity O(n) and constant space complexity O(1). # Input: * `s` - A string which can contain alphabetic characters, digits, spaces, and punctuation. The length of `s` will be in the range `[0, 10^5]`. # Output: * Returns a boolean value: - `True` if `s` is a palindrome. - `False` otherwise. # Constraints: * Only alphanumeric characters should be considered, and case should be ignored. * You cannot use additional storage like stack, deque, etc., beyond a constant amount of space. # Example: ```python assert is_palindrome(\\"A man, a plan, a canal: Panama\\") == True assert is_palindrome(\\"race a car\\") == False assert is_palindrome(\\"\\") == True assert is_palindrome(\\",,,.\\") == True ``` # Function Signature: ```python def is_palindrome(s: str) -> bool: pass ``` # Implementation You should ensure the algorithm by: - Converting characters to lowercase. - Filtering out non-alphanumeric characters. - Using two pointers to compare characters from both ends of the string.","solution":"def is_palindrome(s: str) -> bool: Determines if the input string is a palindrome. :param s: The input string. :return: True if the string is a palindrome, False otherwise. left, right = 0, len(s) - 1 while left < right: # Move left pointer to the next alphanumeric character while left < right and not s[left].isalnum(): left += 1 # Move right pointer to the previous alphanumeric character while left < right and not s[right].isalnum(): right -= 1 # Compare characters ignoring the case if s[left].lower() != s[right].lower(): return False # Move towards the middle left += 1 right -= 1 return True"},{"question":"Manipulating Specific Bits of an Integer In this assessment, you are required to write a function leveraging bit manipulation to solve a common problem. Scenario You are given an integer representing a binary number. You need to implement a function that returns the result of toggling (flipping) specific bits identified by their positions. Toggling a bit means changing 0 to 1 or 1 to 0. Task Implement the function `toggle_bits(num: int, positions: List[int]) -> int` that toggles the bits of `num` at the indices given in the list `positions`. Input * `num` (integer): The integer whose bits are to be toggled. * `positions` (list of integers): The list of positions where the bits need to be toggled. Output * Returns the new integer resulted from toggling the bits. Constraints * Each index in `positions` will be a valid bit position within the range of bit-length of the integer. * 0 ≤ len(positions) ≤ 32 (assuming a 32-bit system). Example ```python # Example 1 # Binary representation of 29 is 11101 # Toggling bit at position 0 (least significant): 11100 -> 28 # Toggling bit at position 3 (fourth bit from the right): 10100 -> 20 (new integer) assert toggle_bits(29, [0, 3]) == 20 # Example 2 # Binary representation of 50 is 110010 # Toggling bit at position 1 (second bit from the right): 110000 -> 48 assert toggle_bits(50, [1]) == 48 ``` Performance Requirements Your solution should run in O(n) time complexity, where n is the number of positions to toggle. Hints * Utilize the XOR operation to toggle a specific bit. **Function Signature:** ```python def toggle_bits(num: int, positions: List[int]) -> int: pass ```","solution":"from typing import List def toggle_bits(num: int, positions: List[int]) -> int: Toggles the bits at specified positions in the given integer. :param num: Integer whose bits are to be toggled :param positions: List of positions to be toggled :return: The new integer after toggling the bits for pos in positions: num ^= (1 << pos) return num"},{"question":"# Priority Queue Using Linked List Problem Description: In this task, you are required to modify the implementation of the Priority Queue to use a linked list rather than a linear list (array). The linked list should hold nodes with data and priority attributes, and the queue will manage these nodes such that the highest priority element is always accessible. Objectives: You will implement the following: 1. **Node Class**: Each node will have `data` and `priority` attributes along with `next` pointer. 2. **LinkedListPriorityQueue Class**: * **`size` method**: Returns the current size of the queue. * **`push` method**: Insert a new element into the priority queue maintaining the priority order. * **`pop` method**: Remove and return the highest priority element from the queue. Input and Output: * **Input**: * `size` method: No input. * `push` method: Two inputs - `data`: value to be inserted, and `priority`: priority of the value. * `pop` method: No input. * **Output**: * `size` method: Returns an integer representing the size of the queue. * `push` method: None (modifies the queue). * `pop` method: Returns the `data` of the highest priority node. Constraints: 1. The data types for `data` can be any, and `priority` is an integer. 2. The priority queue can contain elements with duplicate priorities, but `pop` should always remove the element with the highest priority. Example: ```python # Create a priority queue pq = LinkedListPriorityQueue() # Insert elements pq.push(\\"task1\\", 1) pq.push(\\"task2\\", 2) pq.push(\\"task3\\", 1) # Get size of the queue assert pq.size() == 3 # Pop highest priority element assert pq.pop() == \\"task2\\" # Get size of the queue after pop assert pq.size() == 2 ``` Implementation: ```python class Node: def __init__(self, data, priority): self.data = data self.priority = priority self.next = None class LinkedListPriorityQueue: def __init__(self): self.head = None self._size = 0 def size(self): return self._size def push(self, data, priority): new_node = Node(data, priority) self._size += 1 if self.head is None or self.head.priority < priority: new_node.next = self.head self.head = new_node return current = self.head while current.next and current.next.priority >= priority: current = current.next new_node.next = current.next current.next = new_node def pop(self): if self.head is None: raise IndexError(\\"pop from empty priority queue\\") highest_priority_node = self.head self.head = self.head.next self._size -= 1 return highest_priority_node.data ```","solution":"class Node: def __init__(self, data, priority): self.data = data self.priority = priority self.next = None class LinkedListPriorityQueue: def __init__(self): self.head = None self._size = 0 def size(self): Returns the current size of the queue return self._size def push(self, data, priority): Insert a new element into the priority queue maintaining the priority order new_node = Node(data, priority) self._size += 1 if self.head is None or self.head.priority < priority: new_node.next = self.head self.head = new_node return current = self.head while current.next and current.next.priority >= priority: current = current.next new_node.next = current.next current.next = new_node def pop(self): Remove and return the highest priority element from the queue if self.head is None: raise IndexError(\\"pop from empty priority queue\\") highest_priority_node = self.head self.head = self.head.next self._size -= 1 return highest_priority_node.data"},{"question":"# Question Context You are developing a utility for a digital forensics tool that analyzes the lengths of various numeric codes extracted from data files. As part of this, you need a function that quickly computes the number of digits in given integers. Your function will be integrated into data pipelines where performance is crucial. # Problem Statement **Function Implementation**: Write a function `digit_count(n: int) -> int` that returns the number of digits in an integer, ensuring high performance. # Input and Output Formats * **Input**: * An integer `n`, where ( -10^{18} leq n leq 10^{18} ). * **Output**: * Return the number of digits in the input integer `n`. # Constraints * Handle zero correctly - it should return 1 digit. * Handle negative numbers by considering their absolute value. * Ensure that the function runs in constant time. # Example ```python # Example 1 digit_count(0) -> 1 # Example 2 digit_count(12345) -> 5 # Example 3 digit_count(-67890) -> 5 # Example 4 digit_count(1000000000000000000) -> 19 ``` # Notes * Do not use string conversion methods; focus on a mathematical approach for constant time complexity. * Consider edge case scenarios such as the negative range and number zero explicitly. Implement the function to ensure those requirements are met.","solution":"def digit_count(n: int) -> int: Returns the number of digits in an integer n. if n == 0: return 1 count = 0 n = abs(n) while n > 0: n //= 10 count += 1 return count"},{"question":"# Transitive Closure Using Iterative DFS Given the implementation of a directed graph using adjacency lists, you are required to calculate the transitive closure of the graph. The transitive closure of a graph is a matrix that indicates whether a vertex can reach another vertex through a series of directed edges. **Problem Statement:** Implement the `iterative_dfs_transitive_closure` function which finds the transitive closure using an iterative version of the Depth-First Search (DFS). The function should return a matrix where `closure[i][j]` is `1` if vertex `i` can reach vertex `j`, otherwise `0`. **Function Signature:** ```python def iterative_dfs_transitive_closure(graph: Graph) -> List[List[int]]: # your code here ``` **Input:** - `graph`: An instance of the `Graph` class with vertices and directed edges already added. **Output:** - A 2D list `closure` where `closure[i][j]` is `1` if vertex `i` can reach vertex `j`, otherwise `0`. **Constraints:** - The graph has no more than 100 vertices. - The number of edges is less than or equal to 1000. - Vertices are labeled from 0 to `V-1`. **Examples:** ```python g = Graph(4) g.add_edge(0, 1) g.add_edge(1, 2) g.add_edge(2, 0) g.add_edge(3, 2) closure = iterative_dfs_transitive_closure(g) print(closure) # Output: # [ # [1, 1, 1, 0], # [1, 1, 1, 0], # [1, 1, 1, 0], # [0, 0, 1, 1] # ] ``` # Notes: - Consider using a stack to implement the iterative DFS. - The closure matrix should be initially filled with 0s. - Pay special attention to correctly marking reachability in the matrix and avoiding infinite loops.","solution":"from typing import List class Graph: def __init__(self, vertices: int): self.V = vertices self.adj_list = [[] for _ in range(vertices)] def add_edge(self, src: int, dest: int): self.adj_list[src].append(dest) def iterative_dfs_transitive_closure(graph: Graph) -> List[List[int]]: V = graph.V closure = [[0] * V for _ in range(V)] def dfs(start: int): stack = [start] visited = [False] * V while stack: node = stack.pop() for neighbor in graph.adj_list[node]: if not visited[neighbor]: visited[neighbor] = True closure[start][neighbor] = 1 stack.append(neighbor) for i in range(V): closure[i][i] = 1 # A vertex is always reachable from itself dfs(i) return closure"},{"question":"# Frequency Capping in Array **Scenario**: You are working on a data sanitization feature for a large-scale data processing pipeline. One task requires you to clean up datasets by limiting the frequency of each element while preserving the original order. This means no element should appear more than a specified number of times in the resulting dataset. **Task**: Write a function `frequency_capping(arr: List[int], n: int) -> List[int]` which takes: - `arr`: a list of integers. - `n`: an integer cap that limits the occurrence of each integer in the list. **Input**: - A list of integers `arr` where (0 leq |arr| leq 10^6). - An integer `n` representing the maximum number of times any value can appear in the result, where (0 leq n leq 10^6). **Output**: - A new list containing the integers from `arr` but no integer appears more than `n` times. **Constraints**: - If `n` is 0, the resulting list must be empty. - The elements in the resulting list must be in the same order as they appear in the input list `arr`. **Examples**: - Input: `arr = [1, 2, 3, 1, 2, 1, 2, 3]`, `n = 2` Output: `[1, 2, 3, 1, 2, 3]` - Input: `arr = [20, 37, 20, 21]`, `n = 1` Output: `[20, 37, 21]` - Input: `arr = [1, 1, 1, 1, 1, 1]`, `n = 3` Output: `[1, 1, 1]` - Input: `arr = [1, 2, 3, 4, 5]`, `n = 0` Output: `[]` **Function Signature**: ```python from typing import List def frequency_capping(arr: List[int], n: int) -> List[int]: # Function implementation goes here ``` **Notes**: - It\'s crucial to preserve the order of elements while implementing the capping mechanism. - Think about the edge cases like empty lists and zero cap values.","solution":"from typing import List from collections import defaultdict def frequency_capping(arr: List[int], n: int) -> List[int]: if n == 0: return [] count = defaultdict(int) result = [] for element in arr: if count[element] < n: result.append(element) count[element] += 1 return result"},{"question":"Context You are given a list that contains elements of various types. Your task is to reorder the list in such a way that all zeros (integer 0) are moved to the end of the list, while the relative order of the non-zero elements is preserved. Note that boolean `False` should not be considered as 0. Function Signature ```python def move_zeros(array: list) -> list: ``` Input - `array`: A list containing arbitrary elements (e.g., integers, strings, booleans). Output - Returns a list with all the zeros moved to the end. Constraints - The order of non-zero elements must be preserved. - The function must handle mixed data types, including booleans where `False` should not be considered as zero. Performance Requirements - The solution should have a time complexity of O(n). Example ```python assert move_zeros([False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"]) == [False, 1, 1, 2, 1, 3, \\"a\\", 0, 0] assert move_zeros([1, 2, 0, 3, 0, 4, 5]) == [1, 2, 3, 4, 5, 0, 0] assert move_zeros([0, 0, 0, 0]) == [0, 0, 0, 0] assert move_zeros([]) == [] ``` Task Implement the function `move_zeros` that meets the above specifications and passes all the given test cases.","solution":"def move_zeros(array: list) -> list: Reorders the list such that all zeros are moved to the end while preserving the order of non-zero elements. non_zeros = [x for x in array if x is not 0] zeros = [x for x in array if x is 0] return non_zeros + zeros"},{"question":"# Problem Description You are provided with an array of integers, and two limit values: `min_lim` and `max_lim`. Your task is to implement a function that takes this array and returns a new array containing only the elements that are greater than or equal to `min_lim` and less than or equal to `max_lim`. If `min_lim` is `None`, it should be treated as the minimum possible value for the limits. Similarly, if `max_lim` is `None`, it should be treated as the maximum possible value for the limits. If both limits are `None`, return the original array. Function Signature ```python def limit(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: pass ``` # Input - `arr`: A list of integers, `arr` (0 <= len(arr) <= 10^6). - `min_lim`: An integer representing the minimum limit or None. - `max_lim`: An integer representing the maximum limit or None. # Output - A list of integers that are within the given range [min_lim, max_lim]. # Constraints - The input array can be empty. - The elements of the array, as well as `min_lim` and `max_lim`, can be any integer value. - You should focus on O(n) time complexity. # Example Example 1: ```python limit([1, 2, 3, 4, 5], None, 3) ``` **Output**: `[1, 2, 3]` Example 2: ```python limit([10, 15, 20, 25, 30], 15, None) ``` **Output**: `[15, 20, 25, 30]` Example 3: ```python limit([1, 4, 10, 12, 14, 20], 5, 15) ``` **Output**: `[10, 12, 14]` # Notes - Take into account edge cases such as empty arrays or limits that include all or none of the elements. - Ensure your function is optimized and can handle the upper limits of the input size efficiently.","solution":"from typing import List, Optional def limit(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: Returns a new list containing only the elements that are greater than or equal to min_lim and less than or equal to max_lim. If a limit is None, it\'s considered as unbounded. if min_lim is None: min_lim = float(\'-inf\') if max_lim is None: max_lim = float(\'inf\') return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"Context The “Hailstone sequence” or “Collatz sequence” is a sequence of numbers produced according to the Collatz conjecture, which is only partially understood, given a starting positive integer `n`. Your task is to implement a function that computes this sequence. Task Write a Python function `hailstone_subsequence(n, k)` that generates the first `k` numbers of the hailstone sequence starting from `n`. If the sequence terminates before reaching k elements (ends at 1), the function should return the sequence up to that point. Function Signature ```python def hailstone_subsequence(n: int, k: int) -> List[int]: ``` Input - `n (1 <= n <= 10^6)`: The integer to start the hailstone sequence from. - `k (1 <= k <= 10^6)`: The number of elements of the sequence to return. Output - A list of integers representing the first `k` elements of the hailstone sequence starting from `n`. If the sequence terminates before `k` elements are generated, return the sequence up to that point. Constraints - Your implementation should handle large values efficiently. - Ensure that the function handles the edge cases correctly. Examples ```python assert hailstone_subsequence(7, 5) == [7, 22, 11, 34, 17] assert hailstone_subsequence(1, 3) == [1] assert hailstone_subsequence(10, 10) == [10, 5, 16, 8, 4, 2, 1] ``` Notes 1. For `hailstone_subsequence(1, k)` always return `[1]` since the sequence terminates immediately. 2. For `hailstone_subsequence(10, 10)`, the sequence terminates before reaching 10 elements.","solution":"def hailstone_subsequence(n: int, k: int) -> list: Generates the first k numbers of the hailstone sequence starting from n. If the sequence terminates before reaching k elements (ends at 1), returns the sequence up to that point. sequence = [n] while len(sequence) < k and sequence[-1] != 1: if sequence[-1] % 2 == 0: sequence.append(sequence[-1] // 2) else: sequence.append(3 * sequence[-1] + 1) return sequence"},{"question":"You are developing a mini bitwise manipulation library to help manage bit-level operations on integers. Implement the following four functions that perform specific bit manipulations. 1. `get_bit(num, i)`: This function extracts and returns the bit at position `i` from the integer `num`. 2. `set_bit(num, i)`: This function sets the bit at position `i` of `num` to 1 and returns the new integer. 3. `clear_bit(num, i)`: This function clears (sets to 0) the bit at position `i` of `num` and returns the new integer. 4. `update_bit(num, i, bit)`: This function updates the bit at position `i` of `num` to the specified bit value and returns the new integer. # Input * `num`: A positive integer. * `i`: A non-negative integer representing the bit position (0-indexed). * `bit`: A boolean value where `1` represents setting the bit to 1 and `0` represents setting it to 0 (only for `update_bit` function). # Output * The modified integer after performing the specified operation. # Function Signatures ```python def get_bit(num: int, i: int) -> bool: # Implement this function def set_bit(num: int, i: int) -> int: # Implement this function def clear_bit(num: int, i: int) -> int: # Implement this function def update_bit(num: int, i: int, bit: bool) -> int: # Implement this function ``` # Constraints * `0 <= num <= 10^9` * `0 <= i < 32` (The bit position must be within a 32-bit integer range) * `bit` is either `0` or `1` # Example ```python # Example 1: num = 5 # Binary: 0000 0101 i = 2 print(get_bit(num, i)) # Output: True (Bit at position 2 is 1) # Example 2: num = 5 # Binary: 0000 0101 i = 1 print(set_bit(num, i)) # Output: 7 (Binary: 0000 0111) # Example 3: num = 5 # Binary: 0000 0101 i = 2 print(clear_bit(num, i)) # Output: 1 (Binary: 0000 0001) # Example 4: num = 5 # Binary: 0000 0101 i = 2 bit = 0 print(update_bit(num, i, bit)) # Output: 1 (Binary: 0000 0001) ``` Use these functions to demonstrate your understanding of bit manipulation in Python.","solution":"def get_bit(num: int, i: int) -> bool: Extracts and returns the bit at position i from the integer num. return (num & (1 << i)) != 0 def set_bit(num: int, i: int) -> int: Sets the bit at position i of num to 1 and returns the new integer. return num | (1 << i) def clear_bit(num: int, i: int) -> int: Clears (sets to 0) the bit at position i of num and returns the new integer. return num & ~(1 << i) def update_bit(num: int, i: int, bit: bool) -> int: Updates the bit at position i of num to the specified bit value and returns the new integer. value = 1 << i num = num & ~value # Clear the bit at position i if bit: num = num | value # Set the bit at position i if bit == 1 return num"},{"question":"You are given an array of words and an array of symbols. Your task is to surround the matched symbols in each word with square brackets. However, if a word contains multiple matching symbols, you must choose the one with the longest length. Write a function `highlight_symbols(words, symbols)` that takes two parameters: - `words`: a list of strings, where each string is a word. - `symbols`: a list of strings, where each string is a symbol to be matched within the words. The function should return a list of strings where each word has the matching symbol surrounded by square brackets. If no symbol matches a word, the original word should be returned in the output list. **Input Format**: - `words`: List of strings `[word1, word2, ..., wordN]` where (1 leq N leq 10^3) and each word has a length ranging from (1) to (50). - `symbols`: List of strings `[symbol1, symbol2, ..., symbolM]` where (0 leq M leq 100) and each symbol has a length ranging from (1) to (10). **Output Format**: - A list of strings with symbols in each word surrounded by square brackets. **Examples**: ```python words = [\\"Amazon\\", \\"Microsoft\\", \\"Google\\"] symbols = [\\"i\\", \\"Am\\", \\"cro\\", \\"Na\\", \\"le\\", \\"abc\\"] highlight_symbols(words, symbols) # Output: [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` **Constraints**: 1. If a word contains more than one symbol, choose the one with the longest length. 2. If no symbols match any part of a word, return the word as it is in the list. 3. The comparison should be case-sensitive.","solution":"def highlight_symbols(words, symbols): Surround the matched symbols in each word with square brackets, choosing the symbol with the longest length if there are multiple matches. def find_longest_symbol(word, symbols): longest_symbol = \\"\\" for symbol in symbols: if symbol in word: if len(symbol) > len(longest_symbol): longest_symbol = symbol return longest_symbol highlighted_words = [] for word in words: longest_symbol = find_longest_symbol(word, symbols) if longest_symbol: highlighted_word = word.replace(longest_symbol, f\'[{longest_symbol}]\') highlighted_words.append(highlighted_word) else: highlighted_words.append(word) return highlighted_words"},{"question":"Implement a Priority Queue using a Min-Heap. A priority queue is a data structure where each element has a priority associated with it, and elements are served based on their priority (lower priority numbers are served first). # Function Signature ```python class PriorityQueue: def __init__(self): # Initializes an empty priority queue pass def enqueue(self, value: int, priority: int): # Inserts an element into the priority queue with the given priority pass def dequeue(self) -> int: # Removes and returns the element with the highest priority (i.e., the lowest priority number) pass def peek(self) -> int: # Returns the element with the highest priority without removing it pass def is_empty(self) -> bool: # Returns True if the priority queue is empty, False otherwise pass def size(self) -> int: # Returns the number of elements in the priority queue pass ``` # Input and Output * `enqueue(value: int, priority: int)`: Adds an element with a specified priority to the queue. * `dequeue() -> int`: Removes and returns the element with the highest priority from the queue. Raises an `IndexError` if the queue is empty. * `peek() -> int`: Returns the element with the highest priority without removing it. Raises an `IndexError` if the queue is empty. * `is_empty() -> bool`: Checks whether the queue is empty. * `size() -> int`: Returns the current number of elements in the queue. # Constraints * You must use a Min-Heap for the underlying data structure. * Elements have integer values and priorities are also integers. * All operations should be optimized for performance. * Handle edge cases such as attempting to dequeue from or peek into an empty queue by raising appropriate exceptions. # Example ```python pq = PriorityQueue() pq.enqueue(10, 2) pq.enqueue(5, 1) pq.enqueue(7, 3) print(pq.dequeue()) # Output: 5 print(pq.peek()) # Output: 10 print(pq.is_empty()) # Output: False print(pq.size()) # Output: 2 pq.dequeue() pq.dequeue() print(pq.is_empty()) # Output: True ``` # Notes * Ensure the priority queue operations (enqueue, dequeue, peek) are efficient. * Take care of potential performance bottlenecks, such as ensuring that the heap is maintained correctly during enqueue and dequeue operations.","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] def enqueue(self, value: int, priority: int): # Insert the item into the heap, with the priority as the first value of the tuple heapq.heappush(self.heap, (priority, value)) def dequeue(self) -> int: if self.is_empty(): raise IndexError(\\"Dequeue from an empty PriorityQueue\\") # Pop the item with the smallest priority (min-heap property) return heapq.heappop(self.heap)[1] def peek(self) -> int: if self.is_empty(): raise IndexError(\\"Peek into an empty PriorityQueue\\") # Return the value that has the smallest priority return self.heap[0][1] def is_empty(self) -> bool: return len(self.heap) == 0 def size(self) -> int: return len(self.heap)"},{"question":"# Task Description Design a function `compare_serializations` that takes the root of two binary trees and returns `True` if their serialized forms are identical, otherwise return `False`. This function will help ensure consistency in tree structure and node values between two trees. # Requirements * **Function Signature**: ```python def compare_serializations(root1: TreeNode, root2: TreeNode) -> bool: ``` * **Input**: * `root1` and `root2`: The roots of two binary trees (instances of `TreeNode`). * **Output**: * Return `True` if both trees serialize to the same string, otherwise `False`. # Constraints 1. The number of nodes in each tree is between `0` and `10^4`. 2. Each node\'s value is an integer within the range `-10^5` to `10^5`. # Example Given the two trees: ``` Tree 1: 1 / 2 3 / 4 5 Tree 2: 1 / 2 3 / 4 5 ``` The function call `compare_serializations(root1, root2)` should return `True`. Given the trees: ``` Tree 1: 1 / 2 4 / 3 5 Tree 2: 1 / 2 3 / 4 5 ``` The function call `compare_serializations(root1, root2)` should return `False`. # Notes 1. You should use the given `serialize` function directly in your `compare_serializations` function. 2. Consider edge cases such as when one or both trees are empty. 3. Your solution should be efficient in both time and space complexities.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root): Encodes a tree to a single string. if not root: return \\"None\\" return f\\"{root.val},{serialize(root.left)},{serialize(root.right)}\\" def compare_serializations(root1, root2): Returns True if both trees serialize to the same string, otherwise False. return serialize(root1) == serialize(root2)"},{"question":"# Question: Create an Enhanced Histogram Function You are tasked with implementing an enhanced histogram function that not only counts occurrences of each unique element in a list but also allows users to query and manipulate the histogram. You need to: 1. Implement the basic histogram function as described. 2. Create additional functionalities to: - Query the frequency of a specific element. - Remove an element from the histogram. - Get the most frequent element(s). # Function Signature ```python class Histogram: def __init__(self, input_list: list): pass def get_histogram(self) -> dict: pass def query_frequency(self, element) -> int: pass def remove_element(self, element) -> None: pass def most_frequent(self) -> list: pass ``` # Implementation Requirements 1. **`__init__` Method**: - **Input**: A list of hashable elements. - **Action**: Initializes the histogram dictionary. - **Output**: None. 2. **`get_histogram` Method**: - **Input**: None. - **Action**: Returns the histogram representation in the form of a dictionary. - **Output**: Dictionary representing elements and their frequencies. 3. **`query_frequency` Method**: - **Input**: A single element (hashable). - **Action**: Returns the frequency of the element if it exists, otherwise returns 0. - **Output**: Integer frequency of the element. 4. **`remove_element` Method**: - **Input**: A single element (hashable). - **Action**: Removes the element from the histogram if it exists. - **Output**: None. 5. **`most_frequent` Method**: - **Input**: None. - **Action**: Returns a list of the most frequent element(s). - **Output**: List of elements with the highest frequency. # Constraints - Elements of the input list should be hashable. - An empty input list should result in an empty histogram. - Performance should be considered for lists up to the length of 10^5 elements. # Example Usage ```python # Initialize a Histogram object hist = Histogram([2, 3, 5, 5, 5, 6, 4, 3, 7]) # Retrieve the histogram print(hist.get_histogram()) # Output: {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} # Query the frequency of an element print(hist.query_frequency(5)) # Output: 3 # Remove an element hist.remove_element(5) print(hist.get_histogram()) # Output: {2: 1, 3: 2, 4: 1, 6: 1, 7: 1} # Get the most frequent element(s) print(hist.most_frequent()) # Output: [3] ```","solution":"class Histogram: def __init__(self, input_list): self.histogram = {} for element in input_list: if element in self.histogram: self.histogram[element] += 1 else: self.histogram[element] = 1 def get_histogram(self): return self.histogram def query_frequency(self, element): return self.histogram.get(element, 0) def remove_element(self, element): if element in self.histogram: del self.histogram[element] def most_frequent(self): if not self.histogram: return [] max_freq = max(self.histogram.values()) return [k for k, v in self.histogram.items() if v == max_freq]"},{"question":"# Coding Challenge: Identify the Added Character Scenario You are given two strings s and t consisting of lowercase letters. String t is generated by randomly shuffling string s and then adding one more letter at a random position. Your task is to find the additional character in t that is not present in s. Function Signature ```python def find_difference(s: str, t: str) -> str: ``` Input * **s** (1 <= |s| <= 10^5): A non-empty string containing lowercase English letters. * **t** (|t| = |s| + 1): A string obtained by shuffling s and adding one extra character. Output * Return the character that was added to t. Constraints * String s and t only contain lowercase English letters. * There will be exactly one additional character in t compared to s. Example ```python s = \\"abcde\\" t = \\"abecdd\\" find_difference(s, t) # Output: \'d\' ``` Explanation In the given example, the string `s` is \\"abcde\\" and `t` is \\"abecdd\\". The character `d` is added to `t`. Hence, the output will be `\'d\'`. Notes * Consider edge cases where the added character is at the beginning or end of the string. * Ensure that your solution efficiently handles the upper limits of the input size.","solution":"def find_difference(s: str, t: str) -> str: This function finds the additional character in string t that is not present in string s. # Using a frequency dictionary to count occurrences of each character in s char_count = {} for char in s: char_count[char] = char_count.get(char, 0) + 1 # Subtracting occurrences using the string t for char in t: if char in char_count and char_count[char] > 0: char_count[char] -= 1 else: return char # The function ends here; normally, the loop should return the added character from t."},{"question":"# Anagram Validator with Mixed-Case Handling Problem Description Given two strings `s` and `t`, write a function to determine if `t` is an anagram of `s`, considering the strings may contain lowercase and uppercase English letters. The function should be case insensitive, meaning \'A\' and \'a\' should be considered the same character. Function Signature ```python def is_anagram_case_insensitive(s: str, t: str) -> bool: :param s: A string containing alphabets (both lowercase and uppercase). :param t: A string containing alphabets (both lowercase and uppercase). :return: True if `t` is an anagram of `s`, False otherwise. ``` Example ```python # Example 1 s = \\"Anagram\\" t = \\"nagaram\\" # Output: True # Example 2 s = \\"rat\\" t = \\"car\\" # Output: False # Example 3 s = \\"Hello\\" t = \\"oLleh\\" # Output: True ``` Constraints * The string contains only alphabet characters (lowercase and uppercase). * Strings `s` and `t` can have lengths from 0 to 10000. Task Implement the function `is_anagram_case_insensitive` such that it returns `True` if `t` is an anagram of `s`, and `False` otherwise, using the following steps: 1. Convert both strings to the same case (either lower or upper) to ensure case insensitivity. 2. Use a hash map to count the frequency of each character. 3. Compare the hash maps to determine if they are anagrams.","solution":"def is_anagram_case_insensitive(s: str, t: str) -> bool: Determines if t is an anagram of s, considering case insensitivity. # Convert both strings to lower case to ensure case insensitivity s = s.lower() t = t.lower() # If lengths are different, they cannot be anagrams if len(s) != len(t): return False # Use dictionaries to count the frequency of each character char_count_s = {} char_count_t = {} for char in s: if char in char_count_s: char_count_s[char] += 1 else: char_count_s[char] = 1 for char in t: if char in char_count_t: char_count_t[char] += 1 else: char_count_t[char] = 1 # Compare the two dictionaries return char_count_s == char_count_t"},{"question":"# OrderedStack Implementation and Extension You are provided with a class called `OrderedStack` that ensures elements in the stack are always ordered such that the highest value is at the top and the lowest at the bottom. This stack is useful for situations where having sorted elements is important while still adhering to the Last In, First Out (LIFO) principle of stacks. Your task is two-fold: 1. Enhance the `OrderedStack` class by implementing a method `get_min` which always returns the smallest element currently in the stack in O(1) time. You need to ensure that your solution maintains the O(n) time complexity for the `push` method and O(1) for the `pop`, `peek`, `is_empty`, and `size` methods. 2. Write a function `combine_stacks(stack1, stack2)` that takes two `OrderedStack` instances and combines their elements into a single new `OrderedStack` while maintaining the order from both input stacks. # Method Signatures ```python class OrderedStack: def __init__(self): # initializes an empty stack def is_empty(self): # returns True if stack is empty, else False def push(self, item): # adds an item to the stack while maintaining order def pop(self): # removes and returns the top item from the stack def peek(self): # returns the top item without removing it def size(self): # returns the number of items in the stack def get_min(self): # returns the smallest item in the stack without removing it def combine_stacks(stack1: OrderedStack, stack2: OrderedStack) -> OrderedStack: # combines two OrderedStack instances into a new OrderedStack ``` # Constraints - All stack elements are integers. - The `combine_stacks` function should ensure that the resulting combined stack maintains the properties of an `OrderedStack`. # Example Usage ```python # Creating and using OrderedStack stack = OrderedStack() stack.push(5) stack.push(2) stack.push(9) print(stack.peek()) # Output: 9 print(stack.get_min()) # Output: 2 # Combining two stacks stack1 = OrderedStack() stack1.push(1) stack1.push(4) stack1.push(3) stack2 = OrderedStack() stack2.push(6) stack2.push(2) stack2.push(7) result_stack = combine_stacks(stack1, stack2) print([result_stack.pop() for _ in range(result_stack.size())]) # Output: [7, 6, 4, 3, 2, 1] ```","solution":"class OrderedStack: def __init__(self): self.stack = [] self.min_stack = [] def is_empty(self): return len(self.stack) == 0 def push(self, item): self.stack.append(item) if not self.min_stack or item <= self.min_stack[-1]: self.min_stack.append(item) def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") item = self.stack.pop() if item == self.min_stack[-1]: self.min_stack.pop() return item def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.stack[-1] def size(self): return len(self.stack) def get_min(self): if self.is_empty(): raise IndexError(\\"get_min from empty stack\\") return self.min_stack[-1] def combine_stacks(stack1: OrderedStack, stack2: OrderedStack) -> OrderedStack: combined = [] while not stack1.is_empty(): combined.append(stack1.pop()) while not stack2.is_empty(): combined.append(stack2.pop()) combined_stack = OrderedStack() for element in sorted(combined): combined_stack.push(element) return combined_stack"},{"question":"# Gnome Sort Implementation Enhancement Objective Modify and extend the provided Gnome Sort implementation to handle additional scenarios and optimize certain aspects where possible. Problem Statement You are given an unsorted array of integers. Write a function `enhanced_gnome_sort(arr)` that: 1. Sorts the array using an optimized variant of Gnome Sort. 2. Ensures the algorithm handles arrays with large distinct elements efficiently. 3. Returns the sorted array. The function must handle edge cases effectively, including: * Handling empty arrays and single-element arrays without errors. * Ensuring that the sorting operation is done in-place. Input Format * A single list `arr` of integers where: * 0 <= len(arr) <= 10^6 * -10^9 <= arr[i] <= 10^9 for all i Output Format * A list of integers representing the sorted array. Sample Input and Output **Example 1:** Input: `arr = [5, 3, 2, 8, 6]` Output: `[2, 3, 5, 6, 8]` **Example 2:** Input: `arr = [1]` Output: `[1]` **Example 3:** Input: `arr = []` Output: `[]` **Example 4:** Input: `arr = [10, -1, 7, 3, 8, -5, 0]` Output: `[-5, -1, 0, 3, 7, 8, 10]` # Constraints * Aim to reduce the number of swaps in the average case. * Ensure the implementation works within a reasonable time frame for large input sizes (up to 10^6 elements). Task Implement the function `enhanced_gnome_sort(arr)` that adheres to the above specifications. Example Code ```python def enhanced_gnome_sort(arr): n = len(arr) index = 0 while index < n: if index == 0 or arr[index] >= arr[index-1]: index = index + 1 else: arr[index], arr[index-1] = arr[index-1], arr[index] index = index - 1 return arr # Test with an example arr = [5, 3, 2, 8, 6] print(enhanced_gnome_sort(arr)) ``` **Your task is to improve the efficiency and handle the edge cases effectively.**","solution":"def enhanced_gnome_sort(arr): n = len(arr) index = 0 while index < n: if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"# Problem Scenario You work for a company that deals with user preference analysis. One of the tasks you have is to compare user interest vectors to find out how similar they are. For this purpose, you need to implement a key function that calculates the cosine similarity between two user interest vectors. # Problem Statement Implement a function `cosine_similarity` that calculates and returns the cosine similarity between two 1D lists of integers or floats. Both lists will represent vectors of user interests in different categories. # Requirements * Input: Two lists of integers or floats, `vec1` and `vec2`, representing the vectors. - Example: `vec1 = [1, 1, 1]`, `vec2 = [1, 2, -1]` * Output: A float representing the cosine similarity between the input vectors. - Example: `cosine_similarity(vec1, vec2) => 0.47140452079103173` # Constraints 1. The two input lists must have the same length (`1 ≤ len(vec1), len(vec2) ≤ 10^5`). 2. Values in the list can be negative or positive and can range between -10^6 to 10^6. 3. If the vectors have different lengths, your function should raise a `ValueError` with the message: \\"The two vectors must be the same length.\\" # Performance Your solution should be optimized to handle large vectors efficiently as mentioned in the constraints. # Function Signature ```python def cosine_similarity(vec1: List[Union[int, float]], vec2: List[Union[int, float]]) -> float: pass ``` # Example ```python print(cosine_similarity([1, 1, 1], [1, 2, -1])) # Output: 0.47140452079103173 print(cosine_similarity([1, 0, 0], [0, 1, 0])) # Output: 0.0 print(cosine_similarity([0], [0])) # Output: Raises ValueError ``` **Note**: Ensure your implementation handles edge cases, including different lengths of input vectors and vectors where one or both have zero magnitude.","solution":"from typing import List, Union import math def cosine_similarity(vec1: List[Union[int, float]], vec2: List[Union[int, float]]) -> float: if len(vec1) != len(vec2): raise ValueError(\\"The two vectors must be the same length.\\") dot_product = sum(a * b for a, b in zip(vec1, vec2)) magnitude_vec1 = math.sqrt(sum(a * a for a in vec1)) magnitude_vec2 = math.sqrt(sum(b * b for b in vec2)) if magnitude_vec1 == 0 or magnitude_vec2 == 0: return 0.0 # If either vector is zero magnitude, cosine similarity is undefined, we return 0. return dot_product / (magnitude_vec1 * magnitude_vec2)"},{"question":"# Linked List Deduplication You are given a singly linked list where each node contains a character. Your task is to write two functions: 1. **remove_dups(head)**: Removes duplicate characters from the linked list using additional space. 2. **remove_dups_without_set(head)**: Removes duplicate characters from the linked list without using any additional data structures. # Requirements: 1. Both functions should modify the linked list in place. 2. After duplicates are removed, the linked list should retain the first occurrence of each character. 3. You should also provide a helper function to print the linked list in a readable format, i.e., **print_linked_list(head)**. # Constraints: - The linked list can contain a maximum of 1000 nodes. - The characters are case-sensitive (\'A\' and \'a\' are different). # Input Format: - A linked list with node values as characters. # Output Format: - Modifies the linked list in place to remove duplicates. # Example 1: **Input linked list**: A -> A -> B -> C -> D -> C -> F -> G **Output after remove_dups**: A -> B -> C -> D -> F -> G **Output after remove_dups_without_set**: A -> B -> C -> D -> F -> G # Implementation: Define the `Node` class and implement the functions as described above. Ensure your solution is optimal for the required task. ```python # Define the Node class class Node(): def __init__(self, val = None): self.val = val self.next = None # Define the remove_dups function def remove_dups(head): # Your code here # Define the remove_dups_without_set function def remove_dups_without_set(head): # Your code here # Optionally, define the print_linked_list function for testing def print_linked_list(head): # Your code here ```","solution":"# Define the Node class class Node: def __init__(self, val=None): self.val = val self.next = None # Define the remove_dups function def remove_dups(head): if not head: return head current = head seen = set([current.val]) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next return head # Define the remove_dups_without_set function def remove_dups_without_set(head): if not head: return head current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next return head # Optional: Define the print_linked_list function for testing def print_linked_list(head): current = head output = [] while current: output.append(current.val) current = current.next print(\\" -> \\".join(output)) # Helper function to convert list to linked list def list_to_linked_list(lst): if not lst: return None head = Node(lst[0]) current = head for value in lst[1:]: current.next = Node(value) current = current.next return head # Helper function to convert linked list to list def linked_list_to_list(head): lst = [] current = head while current: lst.append(current.val) current = current.next return lst"},{"question":"# Question: Implement a Max-Stack Using ArrayStack and LinkedListStack **Scenario:** You are a software developer tasked with creating a Max-Stack, which is an extension of a regular stack. The Max-Stack supports the same operations as a standard stack but with an additional function: - **max()**: Returns the maximum value in the stack in O(1) time. To implement this, you will use two underlying stack structures: `ArrayStack` and `LinkedListStack`, both provided in the code snippets above. **Objective:** Implement a `MaxStack` class that includes: - Push: Adds a new element to the stack. - Pop: Removes and returns the top element. - Peek: Returns the top element without removing it. - Max: Returns the maximum element in the stack in O(1) time. - Is_empty: Checks if the stack is empty. You are required to leverage either `ArrayStack` or `LinkedListStack` for implementing your `MaxStack`. # Input and Output Formats: - **Input**: A sequence of operations such as `push`, `pop`, `peek`, `max`, and `is_empty`. - **Output**: Returns based on the operations: - `push(value)`: No output. - `pop()`: Returns the popped element. - `peek()`: Returns the top element. - `max()`: Returns the maximum element. - `is_empty()`: Returns a boolean for stack emptiness. # Constraints: - The stack will contain only integers. - Operations will be valid (i.e., `pop` and `peek` will not be called on empty stacks and `max` will not be called on empty stacks). **Your implementation should meet these requirements both in terms of functionality and performance.** ```python class MaxStack: def __init__(self, stack_type=\'array\', size=10): Initializes a MaxStack, choosing either ArrayStack or LinkedListStack based on \'stack_type\' parameter. Defaults to ArrayStack with given size. # Your implementation here def push(self, value: int) -> None: # Pushes value onto the stack pass def pop(self) -> int: # Pops and returns the top value of the stack pass def peek(self) -> int: # Returns the top value without removing it pass def max(self) -> int: # Returns the maximum value in the stack pass def is_empty(self) -> bool: # Checks if the stack is empty pass # Example Usage: # max_stack = MaxStack() # max_stack.push(10) # max_stack.push(20) # print(max_stack.max()) # 20 # max_stack.pop() # print(max_stack.peek()) # 10 ```","solution":"class MaxStack: def __init__(self, stack_type=\'array\', size=10): Initializes a MaxStack, choosing either ArrayStack or LinkedListStack based on \'stack_type\' parameter. Defaults to ArrayStack with given size. self.stack = [] self.max_stack = [] # This stack keeps track of maximum values def push(self, value: int) -> None: # Pushes value onto the stack self.stack.append(value) if not self.max_stack or value >= self.max_stack[-1]: self.max_stack.append(value) def pop(self) -> int: # Pops and returns the top value of the stack if not self.stack: raise IndexError(\\"pop from empty stack\\") value = self.stack.pop() if value == self.max_stack[-1]: self.max_stack.pop() return value def peek(self) -> int: # Returns the top value without removing it if not self.stack: raise IndexError(\\"peek from empty stack\\") return self.stack[-1] def max(self) -> int: # Returns the maximum value in the stack if not self.max_stack: raise IndexError(\\"max from empty stack\\") return self.max_stack[-1] def is_empty(self) -> bool: # Checks if the stack is empty return len(self.stack) == 0"},{"question":"# Huffman Coding Implementation Context Huffman coding is a popular algorithm used for lossless data compression. Your task is to implement the core functionalities of Huffman coding: the creation of the Huffman Tree, generation of Huffman codes, encoding a given message and decoding an encoded message using the generated Huffman codes. Task Complete the following functions to demonstrate your understanding of the Huffman coding algorithm. 1. **`create_huffman_tree(frequency_table)`**: * **Input**: A dictionary where keys are characters (integers for simplicity) and values are their frequencies. * **Output**: The root of a Huffman Tree constructed from the frequency table. 2. **`generate_huffman_codes(tree)`**: * **Input**: The root of the Huffman Tree. * **Output**: A dictionary where keys are characters and values are their corresponding Huffman codes. 3. **`encode_message(message, huffman_codes)`**: * **Input**: A list of characters (integers) representing the message, and a dictionary containing Huffman codes. * **Output**: A string representing the encoded message in binary format. 4. **`decode_message(encoded_message, tree)`**: * **Input**: A string representing the encoded message in binary format and the root of the Huffman Tree. * **Output**: The original message as a list of characters (integers). # Example ```python frequency_table = {97: 5, 98: 9, 99: 12, 100: 13, 101: 16, 102: 45} tree = create_huffman_tree(frequency_table) huffman_codes = generate_huffman_codes(tree) message = [97, 98, 99, 100, 101, 102] encoded_message = encode_message(message, huffman_codes) decoded_message = decode_message(encoded_message, tree) print(encoded_message) # Should print a binary string print(decoded_message) # Should print [97, 98, 99, 100, 101, 102] ``` # Constraints * You may assume that the input characters are integers in the range [0, 255] for simplicity. * You do not need to handle I/O operations (reading from or writing to files). Your Implementation Complete the following template: ```python class Node: def __init__(self, frequency=0, data=None, left=None, right=None): self.frequency = frequency self.data = data self.left = left self.right = right def create_huffman_tree(frequency_table): import heapq heap = [Node(freq, char) for char, freq in frequency_table.items()] heapq.heapify(heap) while len(heap) > 1: left = heapq.heappop(heap) right = heapq.heappop(heap) merged = Node(left.frequency + right.frequency, left=left, right=right) heapq.heappush(heap, merged) return heap[0] def generate_huffman_codes(tree, prefix=\'\', huffman_codes=None): if huffman_codes is None: huffman_codes = {} if tree.data is not None: huffman_codes[tree.data] = prefix if tree.left: generate_huffman_codes(tree.left, prefix + \'0\', huffman_codes) if tree.right: generate_huffman_codes(tree.right, prefix + \'1\', huffman_codes) return huffman_codes def encode_message(message, huffman_codes): encoded_message = \'\'.join(huffman_codes[char] for char in message) return encoded_message def decode_message(encoded_message, tree): decoded_message = [] current_node = tree for bit in encoded_message: if bit == \'0\': current_node = current_node.left else: current_node = current_node.right if current_node.data is not None: decoded_message.append(current_node.data) current_node = tree return decoded_message ```","solution":"class Node: def __init__(self, frequency=0, data=None, left=None, right=None): self.frequency = frequency self.data = data self.left = left self.right = right def __lt__(self, other): return self.frequency < other.frequency def create_huffman_tree(frequency_table): import heapq heap = [Node(freq, char) for char, freq in frequency_table.items()] heapq.heapify(heap) while len(heap) > 1: left = heapq.heappop(heap) right = heapq.heappop(heap) merged = Node(left.frequency + right.frequency, left=left, right=right) heapq.heappush(heap, merged) return heap[0] def generate_huffman_codes(tree, prefix=\'\', huffman_codes=None): if huffman_codes is None: huffman_codes = {} if tree.data is not None: huffman_codes[tree.data] = prefix if tree.left: generate_huffman_codes(tree.left, prefix + \'0\', huffman_codes) if tree.right: generate_huffman_codes(tree.right, prefix + \'1\', huffman_codes) return huffman_codes def encode_message(message, huffman_codes): encoded_message = \'\'.join(huffman_codes[char] for char in message) return encoded_message def decode_message(encoded_message, tree): decoded_message = [] current_node = tree for bit in encoded_message: if bit == \'0\': current_node = current_node.left else: current_node = current_node.right if current_node.data is not None: decoded_message.append(current_node.data) current_node = tree return decoded_message"},{"question":"Context You are given the task to optimize logistic cell tower distributions in a metropolitan area. Each requirement is translated to a value that must be minimized in terms of perfect square summations. Your goal is to write a function that achieves this efficiently. Problem Statement Implement a function `min_perfect_squares(number: int) -> int` that returns the smallest number of perfect squares that sum up to the given integer `number`. Function Signature ```python def min_perfect_squares(number: int) -> int: ``` # Input * An integer `number` (1 <= number <= 10^4). # Output * An integer between 1 and 4 that signifies the minimum count of perfect squares that sum to `number`. # Constraints 1. Solve the problem using mathematical theorems and properties. 2. No usage of additional libraries other than `math`. 3. Aim to have an overall time complexity of O(sqrt(n)). # Example ```python assert min_perfect_squares(9) == 1 assert min_perfect_squares(10) == 2 assert min_perfect_squares(12) == 3 assert min_perfect_squares(31) == 4 ``` Evaluation Criteria * Adherence to the above constraints. * Correctness with both small and large numbers. * Efficient computation within time complexity bounds. * Handling of edge cases (such as forms of 4^a(8b+7)) efficiently.","solution":"import math def min_perfect_squares(number: int) -> int: Returns the smallest number of perfect squares that sum up to \'number\'. # Check for the special form of 4^a(8b+7) while number % 4 == 0: number //= 4 if number % 8 == 7: return 4 # Check if the number is a perfect square itself if int(math.isqrt(number)) ** 2 == number: return 1 # Check if the number can be decomposed into a sum of two perfect squares for i in range(1, math.isqrt(number) + 1): if int(math.isqrt(number - i * i)) ** 2 == (number - i * i): return 2 # If none of the above checks pass, return 3 return 3"},{"question":"# Question: Finding the First Occurrence of a Number in a Sorted Array Given a sorted array of integers (in non-decreasing order), you are required to find the index of the first occurrence of a target integer. If the target integer is not present in the array, return -1. Function Signature ```python def find_first_occurrence(array: List[int], target: int) -> int: # your code here ``` Input * `array` : A list of n integers, where 1 <= n <= 10^6 * `target`: An integer representing the target number to find in the array. Output * An integer representing the index of the first occurrence of the target number in the array. If the target is not found, return -1. Constraints * The array is sorted in non-decreasing order. * You must implement the function to run with a time complexity of O(log n). Examples ```python assert find_first_occurrence([1, 2, 2, 2, 3, 4, 5], 2) == 1 assert find_first_occurrence([1, 2, 3, 4, 5], 6) == -1 assert find_first_occurrence([5, 5, 5, 5, 5], 5) == 0 assert find_first_occurrence([], 1) == -1 ``` Scenario Imagine you are working in a search and analytics team for a large dataset. One of your tasks is to find the earliest record of certain events from a sorted list of timestamps. This problem directly relates to the operation mentioned and will test your understanding of efficient searching algorithms.","solution":"from typing import List def find_first_occurrence(array: List[int], target: int) -> int: Returns the index of the first occurrence of target in the sorted array. If target is not found, returns -1. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = (left + right) // 2 if array[mid] == target: result = mid right = mid - 1 # Continue to search in the left half elif array[mid] < target: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Problem: Efficient Delivery Routing Context You are working for a delivery company that needs to optimize the delivery routes in a city. The city\'s delivery network can be represented as a graph, where intersections are vertices, and roads between intersections are edges with positive weights representing the delivery time. Objective Implement an optimized version of Dijkstra\'s algorithm to compute the shortest delivery times from a central warehouse (source node) to all other intersections in the city. Requirements * **Function Name**: `dijkstra_optimized` * **Expected Input/Output**: - **Input**: An integer `V` representing the number of vertices, an integer `src` representing the source vertex (central warehouse), and a list of edges where each edge is represented as a tuple `(u, v, w)` meaning there\'s a directed edge from `u` to `v` with weight `w`. - **Output**: A list of integers where the ith index represents the shortest delivery time from the source to the ith vertex. * **Constraints**: - The number of vertices `V` will be in the range [1, 10000]. - All edge weights are positive integers. - There will not be more than `100000` edges. * **Performance**: - Must run efficiently for large graphs, use a priority queue to optimize the selection of the minimum distance vertex. Function Signature ```python def dijkstra_optimized(V: int, src: int, edges: List[Tuple[int, int, int]]) -> List[int]: ``` Example ```python # Input V = 5 src = 0 edges = [ (0, 1, 10), (0, 2, 3), (1, 3, 2), (2, 1, 1), (2, 3, 8), (3, 4, 7) ] # Output # Shortest times from vertex 0: [0, 4, 3, 6, 13] print(dijkstra_optimized(V, src, edges)) ``` Explanation In the provided example, the delivery times from the source vertex 0 to all other vertices should be calculated, with the output representing the shortest time to each intersection. Notes - Use a priority queue to efficiently select the vertex with the smallest known distance. - Consider using an adjacency list to represent the graph for better performance.","solution":"import heapq from typing import List, Tuple def dijkstra_optimized(V: int, src: int, edges: List[Tuple[int, int, int]]) -> List[int]: Implements Dijkstra\'s algorithm to compute the shortest delivery times from a central warehouse to all other intersections in the city. # Create an adjacency list graph = [[] for _ in range(V)] for u, v, w in edges: graph[u].append((v, w)) # Initialize distances with infinity dist = [float(\'inf\')] * V dist[src] = 0 # Use a priority queue to get the vertex with the smallest distance pq = [(0, src)] # (distance, vertex) while pq: d, u = heapq.heappop(pq) # If the distance in the priority queue is bigger than the recorded distance, skip if d > dist[u]: continue # Check the neighbors for v, weight in graph[u]: if dist[u] + weight < dist[v]: dist[v] = dist[u] + weight heapq.heappush(pq, (dist[v], v)) return dist"},{"question":"Problem Statement You are given a partially implemented directed graph with nodes and edges. Your task is to extend this graph by implementing a method to detect if there is a cycle in the graph. # Problem Details A cycle in a graph is defined as a path that starts from a node and returns to the same node without repeating any edges. # Input - A dictionary `graph_dict` where keys are node names and values are lists of names of nodes that the key node has edges to. # Output - Boolean value `True` if there is at least one cycle in the graph, and `False` otherwise. # Function Signature ```python def has_cycle(graph_dict: dict) -> bool: # implement your solution here ``` # Example ```python # Example Input graph_dict = { \'A\': [\'B\', \'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'A\'], \'D\': [] } # Example Output print(has_cycle(graph_dict)) # Output: True ``` # Constraints * Assume all node names are unique. * The graph is directed. * The input dictionary will not have an invalid structure (all referenced nodes are listed as keys). # Implementation Notes * You may use depth-first search (DFS) or any other algorithm suitable for cycle detection in directed graphs. * Consider using auxiliary structures like visited nodes or recursion stack to help with cycle detection.","solution":"def has_cycle(graph_dict: dict) -> bool: def visit(node): if node in visiting: return True if node in visited: return False visiting.add(node) for neighbour in graph_dict.get(node, []): if visit(neighbour): return True visiting.remove(node) visited.add(node) return False visited = set() visiting = set() for node in graph_dict: if visit(node): return True return False"},{"question":"# Background You are tasked with developing a logistics routing system. Your goal is to ensure products are delivered from a start location to an end location using the shortest possible path. However, there may be multiple logistical routes, and it is essential to explore and analyze options based on different objectives such as finding all possible routes or the shortest one. # Challenge Implement a function that enhances the current approach for finding the shortest path in a graph. This function should incorporate memoization to optimize performance for large graphs. # Function Signature ```python def find_shortest_path_optimized(graph, start, end): graph: Dictionary representing an adjacency list of the graph. start: Starting node (key in the graph dictionary). end: Ending node (key in the graph dictionary). Returns a list of nodes forming the shortest path from start to end. If no path is found, return None. Example Input: graph = { \'A\': [\'B\', \'C\', \'E\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\', \'G\'], \'D\': [\'B\'], \'E\': [\'A\', \'B\', \'D\'], \'F\': [\'C\'], \'G\': [\'C\'] } start = \'A\' end = \'D\' Example Output: [\'A\', \'B\', \'D\'] ``` # Constraints/Requirements: * Nodes in the graph are represented as strings. * Ensure no cycles cause infinite loops. * Optimize for large graphs with memoization. * Handle cases where no path exists by returning `None`.","solution":"def find_shortest_path_optimized(graph, start, end): from collections import deque def bfs_shortest_path_memoized(graph, start, end): cache = {} queue = deque([(start, [start])]) while queue: node, path = queue.popleft() if node not in cache or len(path) < len(cache[node]): cache[node] = path if node == end: return path for neighbor in graph.get(node, []): if neighbor not in cache or len(path) < len(cache[neighbor]): queue.append((neighbor, path + [neighbor])) return None return bfs_shortest_path_memoized(graph, start, end)"},{"question":"**Context:** You\'re given a list of integers representing colors of objects. The list contains only three distinct integers: 0, 1, and 2, which represent red, white, and blue respectively. You need to sort the list so that objects of the same color are adjacent and the colors are in the order red (0), white (1), and blue (2). **Task:** Implement a function `sort_colors(nums)` in Python that sorts the provided list of integers (which only includes 0s, 1s, and 2s) in-place. The function should not use any library\'s sort method. **Constraints:** - The function should sort the list in one pass (i.e., O(n) time complexity). - It should use constant space (O(1) space complexity), meaning the sorting should be done in-place without using extra storage. - Assume that `nums` can be an empty list. - Assume that all elements in the list are either 0, 1, or 2. **Function Signature:** ```python def sort_colors(nums: List[int]) -> None: Sorts the list nums in-place so that elements are ordered as 0s, 1s, and then 2s. :param nums: List[int] - List of integers consisting of 0s, 1s, and 2s. ``` **Input/Output:** - **Input**: A list of integers `nums` where each integer is either 0, 1, or 2. - **Output**: The function does not return anything. The input list `nums` should be modified in-place to reflect the sorted order. # Example: ```python # Example usage: nums = [2, 0, 2, 1, 1, 0] sort_colors(nums) print(nums) # Output: [0, 0, 1, 1, 2, 2] ``` **Considerations:** - Think about how you can utilize multiple pointers to segregate the three different values efficiently. - Ensure your implementation handles edge cases such as an empty list or a list with just one type of value correctly.","solution":"def sort_colors(nums): Sorts the list nums in-place so that elements are ordered as 0s, 1s, and then 2s. :param nums: List[int] - List of integers consisting of 0s, 1s, and 2s. low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: # nums[mid] == 2 nums[high], nums[mid] = nums[mid], nums[high] high -= 1"},{"question":"Task You are given a binary array; your job is to write a function that finds the index of the single 0 that can be flipped to a 1 to achieve the longest sequence of contiguous 1s. If there are no zeros or turning any zero doesn\'t extend the sequence, the function should return `-1`. Function Signature ```python def max_ones_index(arr: List[int]) -> int: ``` Input - `arr` (List[int]): A list of integers where each element is either 0 or 1. Output - (int): The index of the element in the list that should be turned from 0 to 1 to get the longest contiguous sequence of 1s. If not possible, return `-1`. Constraints - The length of `arr` is between `1` and `10^5`. - Each element in `arr` is either `0` or `1`. Examples ```python assert max_ones_index([1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1]) == 3 assert max_ones_index([1, 1, 1, 1]) == -1 assert max_ones_index([0, 0, 0, 0]) == 0 assert max_ones_index([1, 1, 1, 1, 0]) == 4 ``` Scenario Consider that you\'re tasked to optimize a binary sequence in a way that allows one change to maximize sequential data without breaks, particularly used in signal strength where contiguous 1s signify strong signals. This function will assist in finding the optimal point of intervention.","solution":"from typing import List def max_ones_index(arr: List[int]) -> int: max_count = 0 max_index = -1 prev_zero_index = -1 prev_prev_zero_index = -1 for i in range(len(arr)): if arr[i] == 0: if i - prev_prev_zero_index > max_count: max_count = i - prev_prev_zero_index max_index = prev_zero_index prev_prev_zero_index = prev_zero_index prev_zero_index = i if len(arr) - prev_prev_zero_index > max_count: max_index = prev_zero_index return max_index"},{"question":"# Factorial Calculation with Custom Constraints Context In combinatorial mathematics, the factorial of a non-negative integer (n) is essential for calculating permutations and combinations. However, calculating factorials can lead to very large results that are difficult to manage. Hence, we often use the result modulo some number to keep the values manageable. Task Implement a function `optimized_factorial` that accepts three parameters: a non-negative integer (n), a boolean `mod_option`, and an integer `mod`. The function should return: - The factorial of (n) if `mod_option` is False. - The factorial of (n) modulo `mod` if `mod_option` is True. Function Signature ```python def optimized_factorial(n: int, mod_option: bool, mod: int = None) -> int: pass ``` Parameters - `n` (int): The non-negative integer to compute the factorial for. - `mod_option` (bool): A flag to determine if the result should be computed modulo `mod`. - `mod` (int): The modulo value, if `mod_option` is True. Must be a positive integer. Constraints - (0 leq n leq 10^6) - If `mod_option` is True, (1 leq mod leq 10^9) - You must handle invalid inputs by raising appropriate errors with relevant messages. Returns - An integer representing the factorial of (n) or (n! mod mod). Requirements - The solution should be efficient in terms of time and space complexity. - Your code should handle large values of (n) gracefully and ensure it doesn\'t result in overflow. - Properly handle potential error scenarios and edge cases. Example 1. `optimized_factorial(5, False)` should return `120`. 2. `optimized_factorial(5, True, 3)` should return `0`. 3. `optimized_factorial(0, False)` should return `1`. 4. `optimized_factorial(7, True, 10)` should return `4`. Important Notes - Use an iterative approach for better space efficiency. - Check for invalid inputs and handle them appropriately by raising `ValueError`. Testing Please test your function with various inputs including edge cases to ensure its correctness and efficiency.","solution":"def optimized_factorial(n: int, mod_option: bool, mod: int = None) -> int: Computes the factorial of a non-negative integer n. If mod_option is True, computes the factorial modulo `mod`. Parameters: n (int): The non-negative integer whose factorial is to be computed. mod_option (bool): Flag to determine if the result should be modulo `mod`. mod (int): The modulo value if mod_option is True. It must be a positive integer. Returns: int: The factorial of n, or n! % mod. Raises: ValueError: If n is negative, or if `mod_option` is True and `mod` is not a positive integer. if n < 0: raise ValueError(\\"n must be a non-negative integer\\") if mod_option and (mod is None or mod <= 0): raise ValueError(\\"mod must be a positive integer when `mod_option` is True\\") result = 1 for i in range(1, n + 1): result *= i if mod_option: result %= mod return result"},{"question":"# Context Stooge Sort is a highly inefficient recursive sorting algorithm with a remarkably unique approach. Due to its inefficiency, it\'s rarely used in practice, but it\'s an excellent tool for understanding recursion and divide-and-conquer strategies. # Task You need to implement the Stooge Sort algorithm in Python as a function. The function will accept an array of integers as input and sort it in ascending order using the Stooge Sort algorithm. # Input * An array of integers, `arr`, where 1 ≤ `len(arr)` ≤ 1000 and -1000 ≤ `arr[i]` ≤ 1000. # Output * The function should return the sorted version of the input array. # Function Signature ```python def stooge_sort(arr: list) -> list: pass ``` # Constraints * The implementation should use recursion as demonstrated in the provided code snippet. * Aim for correct implementation over efficiency. # Example ```python # Example 1 arr = [5, 3, 2, 8, 1] print(stooge_sort(arr)) # Output: [1, 2, 3, 5, 8] # Example 2 arr = [2, 1, 3] print(stooge_sort(arr)) # Output: [1, 2, 3] ```","solution":"def stooge_sort(arr: list, l=0, h=None) -> list: if h is None: h = len(arr) - 1 if l >= h: return arr # If first element is smaller than last, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than 2 elements in the array if h - l + 1 > 2: t = (h - l + 1) // 3 # Recursively sort first 2/3 elements stooge_sort(arr, l, h - t) # Recursively sort last 2/3 elements stooge_sort(arr, l + t, h) # Recursively sort first 2/3 elements again to confirm stooge_sort(arr, l, h - t) return arr"},{"question":"Scenario: A space mission control system logs telemetry data as an array of digits. Due to rapid incoming data, it is essential to increment the time log efficiently with each new telemetry packet processed. The number of records can be extremely large. Given a non-negative integer represented as a list of digits, increment the integer by 1. You need to handle the interstellar number efficiently as the digits might signify enormous time logs. Function Signature: ```python def increment_telemetry_log(digits: List[int]) -> List[int]: Increment a number in the form of a list of digits by one. :param digits: List[int] - The telemetry log represented as an array of digits. :return: List[int] - The incremented log. ``` Input: * A list of non-negative integers where each element is a single digit (0-9). Constraints: * The list is non-empty. * The digits are stored such that the most significant digit is at the list\'s head. # Examples: 1. `increment_telemetry_log([1, 2, 3])` should return `[1, 2, 4]` 2. `increment_telemetry_log([9, 9, 9])` should return `[1, 0, 0, 0]` 3. `increment_telemetry_log([0])` should return `[1]` # Requirements: 1. Implement an in-place algorithm if possible to optimize space usage. 2. Minimize the time complexity to ensure efficiency with extremely large arrays. Hints: 1. Consider the scenarios where carry occurs. 2. Pay attention to boundary conditions (e.g., all nines).","solution":"from typing import List def increment_telemetry_log(digits: List[int]) -> List[int]: Increment a number in the form of a list of digits by one. :param digits: List[int] - The telemetry log represented as an array of digits. :return: List[int] - The incremented log. n = len(digits) for i in range(n-1, -1, -1): # If the digit is less than 9, increment it and return the list if digits[i] < 9: digits[i] += 1 return digits # Otherwise, set the current digit to 0 (carry over) digits[i] = 0 # If we\'re here, it means all the digits were 9, so we need to add an additional digit return [1] + digits"},{"question":"# Question You are required to extend the provided Binary Search Tree (BST) class with the ability to balance itself automatically. This involves creating a balanced BST from any unbalanced BST. A balanced tree is one where the depths of the two subtrees of every node never differ by more than one. Task 1. **Implement AVL Tree**, a self-balancing binary search tree: * Enhance the `insert` method to keep the tree balanced after every insertion by performing necessary rotations (single and double rotations). * Implement the `delete` method, which similarly keeps the tree balanced after deletion by performing necessary rotations. 2. Implement the following methods: - `rotate_left` and `rotate_right`: to perform necessary rotations. - `get_height` and `get_balance`: to aid in balancing the tree. # Instructions * Implement the changes in the given BST code. * Your AVL tree class should replace the given BST class. # Example **Input:** ```python bst = AVLTree() bst.insert(10) bst.insert(20) bst.insert(30) ``` **Output:** The BST should be rebalanced to: ``` 20 / 10 30 ``` # Constraints * You can assume that no duplicated keys will be inserted. * The tree should be balanced after every insertion and deletion. # Performance Ensure your implementation: * Maintains O(log N) complexity for search, insert, and delete operations. # Testing Include appropriate test cases to verify correctness: * Insertion and balancing. * Deletion and balancing. * Edge cases like unbalanced initial insertions. You can use the given TestSuite class for testing, and expand it according to the new requirements.","solution":"class AVLNode: def __init__(self, key): self.left = None self.right = None self.key = key self.height = 1 class AVLTree: def insert(self, root, key): if not root: return AVLNode(key) if key < root.key: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) balance = self.get_balance(root) if balance > 1 and key < root.left.key: return self.rotate_right(root) if balance < -1 and key > root.right.key: return self.rotate_left(root) if balance > 1 and key > root.left.key: root.left = self.rotate_left(root.left) return self.rotate_right(root) if balance < -1 and key < root.right.key: root.right = self.rotate_right(root.right) return self.rotate_left(root) return root def delete(self, root, key): if not root: return root if key < root.key: root.left = self.delete(root.left, key) elif key > root.key: root.right = self.delete(root.right, key) else: if root.left is None: temp = root.right root = None return temp elif root.right is None: temp = root.left root = None return temp temp = self.get_min_value_node(root.right) root.key = temp.key root.right = self.delete(root.right, temp.key) if root is None: return root root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) balance = self.get_balance(root) if balance > 1 and self.get_balance(root.left) >= 0: return self.rotate_right(root) if balance < -1 and self.get_balance(root.right) <= 0: return self.rotate_left(root) if balance > 1 and self.get_balance(root.left) < 0: root.left = self.rotate_left(root.left) return self.rotate_right(root) if balance < -1 and self.get_balance(root.right) > 0: root.right = self.rotate_right(root.right) return self.rotate_left(root) return root def rotate_left(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def rotate_right(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def get_height(self, node): if not node: return 0 return node.height def get_balance(self, node): if not node: return 0 return self.get_height(node.left) - self.get_height(node.right) def get_min_value_node(self, node): current = node while current.left is not None: current = current.left return current def pre_order(self, root): result = [] if root: result.append(root.key) result = result + self.pre_order(root.left) result = result + self.pre_order(root.right) return result"},{"question":"# Bogo Sort Challenge In this challenge, you are asked to implement a highly inefficient sorting algorithm known as Bogo Sort. While this algorithm serves more as a cautionary tale of inefficiency, it provides a useful educational example of randomness in algorithmic operations. # Task Write a function `bogo_sort_optimized()` that takes in an array of integers and sorts it using the Bogo Sort algorithm. Additionally, improve this function by adding a timeout mechanism to prevent infinite execution, returning `None` if the array cannot be sorted within reasonable bounds. # Input The function will take in a single parameter: * `arr` (list): A list of integers which may be unsorted. # Output The function should return: * `list`: A sorted list of integers, or `None` if the input list cannot be sorted within a given number of attempts. # Constraints 1. The input list can contain between 0 to 100 elements inclusive. 2. Each integer in the list can be from -10<sup>6</sup> to 10<sup>6</sup> inclusive. 3. You need to add a constraint on the number of shuffles (maximum `1,000,000` shuffles, after which return `None` if unsorted). # Example Example 1 ```python input: [3, 1, 2] output: [1, 2, 3] ``` Example 2 ```python input: [5, 3, 8, 6] output: [3, 5, 6, 8] ``` Example 3 ```python input: [2, 5, 3, 1, 4] output: [1, 2, 3, 4, 5] ``` # Note For extremely unsorted or large lists, achieving the sorted state may be theoretically impractical within reasonable time. Your function should handle such scenarios gracefully by returning `None`. # Implementation Implement the `bogo_sort_optimized` function with the following signature: ```python def bogo_sort_optimized(arr: list) -> list: # Your code here pass ```","solution":"import random import time def is_sorted(arr): for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def bogo_sort_optimized(arr, max_attempts=1000000): Sorts an array using Bogo Sort algorithm with an upper limit on shuffle attempts. Parameters: arr (list): The list of integers to sort. max_attempts (int, optional): The maximum number of shuffling attempts allowed. Defaults to 1,000,000. Returns: list: The sorted list, or None if the list cannot be sorted within max_attempts attempts. attempts = 0 length = len(arr) while not is_sorted(arr): attempts += 1 if attempts > max_attempts: return None random.shuffle(arr) return arr"},{"question":"You are tasked with writing a function that improves upon the naive substring search algorithm. The goal is to create a more efficient solution, leveraging advanced search algorithms to achieve better performance for larger texts. Problem Statement Implement the **KMP (Knuth-Morris-Pratt) Substring Search Algorithm** to find the index of the first occurrence of the substring (needle) in a given string (haystack). If the needle is not part of the haystack, return -1. Function Signature ```python def kmp_search(haystack: str, needle: str) -> int: ``` Input - `haystack` (str): The main text (1 ≤ len(haystack) ≤ 10^4). - `needle` (str): The substring to search for (0 ≤ len(needle) ≤ 10^3). Output - (int): The index of the first occurrence of `needle` in `haystack`. Return -1 if `needle` is not found. Constraints - The `needle` can be an empty string. If it is, return 0. - The `haystack` will only consist of lowercase English characters. Example 1 ```python Input: haystack = \\"hello\\", needle = \\"ll\\" Output: 2 ``` Example 2 ```python Input: haystack = \\"aaaaa\\", needle = \\"bba\\" Output: -1 ``` Example 3 ```python Input: haystack = \\"mississippi\\", needle = \\"issi\\" Output: 1 ``` Performance Requirements - The implemented algorithm should have a time complexity of O(n + m), where n is the length of the `haystack` and m is the length of the `needle`. Notes The KMP algorithm reduces the time spent checking mismatches by pre-computing a \'partial match\' table (also known as \\"failure function\\") that indicates where to continue from if a mismatch occurs.","solution":"def kmp_search(haystack: str, needle: str) -> int: if not needle: return 0 def compute_lps(pattern): lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps lps = compute_lps(needle) i = 0 j = 0 while i < len(haystack): if needle[j] == haystack[i]: i += 1 j += 1 if j == len(needle): return i - j elif i < len(haystack) and needle[j] != haystack[i]: if j != 0: j = lps[j - 1] else: i += 1 return -1"},{"question":"You are given a binary tree and you need to implement an in-order traversal function that returns the values of the nodes in sorted order. There are two implementations to be completed: iterative and recursive. # Task Implement two functions `inorder_iterative(root: Node) -> List[int]` and `inorder_recursive(root: Node) -> List[int]`. The first function should use an iterative approach with a stack, and the second function should use a recursive approach without using a stack explicitly. # Input - `root`: The root node of the binary tree. # Output - A list of integers that represents the in-order traversal of the tree\'s nodes. # Constraints 1. The number of nodes in the tree is in the range [0, 10^4]. 2. The values of the nodes are unique integers. # Example ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right # Example tree: # 100 # / # 50 150 # / / # 25 75 125 175 n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 assert inorder_iterative(n1) == [25, 50, 75, 100, 125, 150, 175] assert inorder_recursive(n1) == [25, 50, 75, 100, 125, 150, 175] ``` # Notes - The tree node class is already defined and should not be modified. - Consider edge cases such as an empty tree and a tree with a single node. - Ensure your implementations are efficient and handle large inputs within the provided constraints.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def inorder_iterative(root: Node): result = [] stack = [] current = root while current or stack: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result def inorder_recursive(root: Node): result = [] def traverse(node): if not node: return traverse(node.left) result.append(node.val) traverse(node.right) traverse(root) return result"},{"question":"# Question: Implement an Alternative Partitioning Algorithm You are tasked with sorting an array of integers using an alternative partitioning algorithm similar to the Dutch National Flag problem. # Task Write a function `sort_two_colors(nums: List[int]) -> None` that takes an array of integers `nums` containing exactly two distinct values (let\'s say 4 and 9) and sorts the array in-place so that all 4s come before all 9s. # Input - `nums`: List[int] - A list of integers containing only the numbers 4 and 9. # Output - The function modifies the list in-place, such that all occurrences of 4 come before all occurrences of 9. # Constraints - The length of the array `nums` is in the range [1, 1000]. - Each element in `nums` is either 4 or 9. - Do not use any sorting library functions. # Example ```python def sort_two_colors(nums): # Your code here if __name__ == \\"__main__\\": nums = [4, 9, 4, 4, 9, 9, 4, 9, 9, 4] sort_two_colors(nums) print(nums) # Outputs: [4, 4, 4, 4, 4, 9, 9, 9, 9, 9] ``` # Explanation The function must iterate through the list using a pointer to keep track of the position for 4s. By the end of the iteration, all 4s should be moved to the front, followed by all 9s. Ensure your solution is efficient with a time complexity of O(n) and a space complexity of O(1).","solution":"from typing import List def sort_two_colors(nums: List[int]) -> None: Sorts the list nums in-place so that all 4s are at the beginning followed by all 9s. left = 0 # Initialize a pointer for the position of 4s for i in range(len(nums)): if nums[i] == 4: nums[left], nums[i] = nums[i], nums[left] left += 1"},{"question":"# Problem Description You are given an array `arr` of integers. You need to implement a **Fenwick Tree** (also known as a Binary Indexed Tree) to perform the following operations efficiently: 1. **Calculate the prefix sum** for the first `i` elements. 2. **Update the value** of a specified element in the array. # Function Signatures You need to implement a class `FenwickTree` with the following methods: 1. `__init__(self, freq: List[int]) -> None`: Initialize the Fenwick Tree with an array `freq`. 2. `get_sum(self, bit_tree: List[int], i: int) -> int`: Return the sum of the first `i+1` elements in the array. 3. `update_bit(self, bit_tree: List[int], i: int, v: int) -> None`: Update the value of the element at index `i` with `v`. 4. `construct(self) -> List[int]`: Construct the Fenwick Tree from the array. # Inputs - `freq`: A list of integers representing the frequency array. # Outputs - For the `get_sum` method, return the prefix sum of the array up to index `i`. # Constraints - `1 <= len(freq) <= 10^5` - `-10^4 <= freq[i] <= 10^4` # Example ```python # Example initialization arr = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3] fenwick_tree = FenwickTree(arr) # Construct the Fenwick Tree bit_tree = fenwick_tree.construct() # Get sum of the first 5 elements print(fenwick_tree.get_sum(bit_tree, 4)) # Output: 15 # Update the element at index 3 to 6 fenwick_tree.update_bit(bit_tree, 3, 6) # Get the new sum of the first 5 elements print(fenwick_tree.get_sum(bit_tree, 4)) # Output: 21 ``` # Additional Notes - Make sure to handle edge cases where the input array might be empty or contains extreme values. - Ensure the performance is optimized to handle large arrays efficiently.","solution":"from typing import List class FenwickTree: def __init__(self, freq: List[int]) -> None: self.freq = freq self.bit_tree = [0] * (len(freq) + 1) def get_sum(self, bit_tree: List[int], i: int) -> int: Returns the sum of the first i+1 elements. s = 0 i = i + 1 # BIT array is 1-indexed while i > 0: s += bit_tree[i] i -= i & (-i) return s def update_bit(self, bit_tree: List[int], i: int, v: int) -> None: Updates the element at index i with value v in the BIT array. i = i + 1 # BIT array is 1-indexed while i < len(bit_tree): bit_tree[i] += v i += i & (-i) def construct(self) -> List[int]: Constructs and returns the BIT array based on the frequency array. for idx, value in enumerate(self.freq): self.update_bit(self.bit_tree, idx, value) return self.bit_tree"},{"question":"# Run-Length Encoding and Decoding Function Implementation You are tasked with implementing a Run-Length Encoding (RLE) and Decoding system. The RLE compression algorithm compresses a given string by converting sequences of consecutive repeated characters into count and character pairs. You must implement two functions, `encode` and `decode`, demonstrating your understanding of the principles behind RLE. Requirements **Function 1**: `encode(input_string: str) -> str` - **Input**: - `input_string` (1 ≤ len(input_string) ≤ 1000): A non-empty string consisting of alphanumeric characters. - **Output**: - Returns the RLE-encoded string. **Function 2**: `decode(encoded_string: str) -> str` - **Input**: - `encoded_string` (1 ≤ len(encoded_string) ≤ 1000): A non-empty string representing an RLE-encoded sequence. - **Output**: - Returns the original uncompressed string. Constraints 1. The input strings for both encoding and decoding functions will be valid. 2. For the `encode` function, consider strings that might not have any consecutive characters as edge cases. 3. For the `decode` function, ensure the proper interpretation of count and characters without data loss or corruption. Example ```python # Example inputs and expected outputs: # Encoding input_string = \\"aaaabbbccdaa\\" encoded_result = encode(input_string) # Expected: \\"4a3b2c1d2a\\" # Decoding encoded_string = \\"4a3b2c1d2a\\" decoded_result = decode(encoded_string) # Expected: \\"aaaabbbccdaa\\" # Additional Test Cases # Test case 1 input_string = \\"abbcccc\\" encoded_result = encode(input_string) # Expected: \\"1a2b4c\\" # Test case 2 encoded_string = \\"1a2b4c\\" decoded_result = decode(encoded_string) # Expected: \\"abbcccc\\" # Test case 3 input_string = \\"abc\\" encoded_result = encode(input_string) # Expected: \\"1a1b1c\\" # Test case 4 encoded_string = \\"1a1b1c\\" decoded_result = decode(encoded_string) # Expected: \\"abc\\" ``` Implement both `encode` and `decode` functions to handle the above requirements and examples accurately.","solution":"def encode(input_string: str) -> str: if not input_string: return \\"\\" encoded = [] count = 1 previous_char = input_string[0] for char in input_string[1:]: if char == previous_char: count += 1 else: encoded.append(f\\"{count}{previous_char}\\") previous_char = char count = 1 encoded.append(f\\"{count}{previous_char}\\") return \\"\\".join(encoded) def decode(encoded_string: str) -> str: if not encoded_string: return \\"\\" decoded = [] count = 0 for char in encoded_string: if char.isdigit(): count = count * 10 + int(char) else: decoded.append(char * count) count = 0 return \\"\\".join(decoded)"},{"question":"# Binary Exponentiation Implementation Challenge **Problem Statement:** You are given two integers ( a ) and ( n ), where ( a ) is the base and ( n ) is the exponent. Your task is to implement both the iterative and recursive versions of the binary exponentiation algorithm that computes ( a^n ). Your implementation should also support an optional modulus operation. If a modulus ( m ) is provided, your function should return ( (a^n) mod m ). # Function Specifications: **Function 1: `power(a: int, n: int, mod: int = None) -> int`** - **Inputs**: - `a` (int): The base number which needs to be raised to the power `n`. - `n` (int): The exponent to which the base `a` should be raised. - `mod` (int, optional): The modulus to apply to the result. If not provided, the function should return `a^n`. - **Outputs**: - `int`: The result of ( a^n ) or ( (a^n) mod m ) if `mod` is provided. **Function 2: `power_recur(a: int, n: int, mod: int = None) -> int`** - **Inputs**: - `a` (int): The base number which needs to be raised to the power `n`. - `n` (int): The exponent to which the base `a` should be raised. - `mod` (int, optional): The modulus to apply to the result. If not provided, the function should return `a^n`. - **Outputs**: - `int`: The result of ( a^n ) or ( (a^n) mod m ) if `mod` is provided. # Constraints: 1. ( -10^9 leq a leq 10^9 ) 2. ( 0 leq n leq 10^9 ) 3. ( 1 leq m leq 10^9 ) (if modulus is provided) # Performance Requirements: - The time complexity should be ( O(log n) ). - The iterative version should use constant space ( O(1) ), and the recursive version should use logarithmic space ( O(log n) ). # Example: ```python >>> power(2, 10) 1024 >>> power(2, 10, 1000) 24 >>> power_recur(3, 13) 1594323 >>> power_recur(3, 13, 1000000) 54323 ``` # Scenario: Imagine you are implementing the core computation module for a cryptographic system that requires secure, efficient power computations. This could involve raising large numbers to high powers and applying modulus to prevent overflow and secure communication.","solution":"def power(a: int, n: int, mod: int = None) -> int: Iterative function to calculate a^n % mod using binary exponentiation. result = 1 base = a current_power = n if mod is not None: base %= mod while current_power > 0: if current_power % 2 == 1: result = result * base if mod is not None: result %= mod base = base * base if mod is not None: base %= mod current_power //= 2 return result def power_recur(a: int, n: int, mod: int = None) -> int: Recursive function to calculate a^n % mod using binary exponentiation. if n == 0: return 1 half = power_recur(a, n // 2, mod) if mod is not None: half = half % mod half = (half * half) % mod if mod is not None else half * half if n % 2 != 0: half = (half * a) % mod if mod is not None else half * a return half"},{"question":"# Task: Topological Sorting of a Directed Graph In this coding assessment, you will implement a function to perform a topological sort on a directed graph. Topological sorting of a directed graph is a linear ordering of its vertices such that for every directed edge ( uv ) from vertex ( u ) to vertex ( v ), ( u ) comes before ( v ) in the ordering. This is particularly useful in scenarios such as task scheduling where certain tasks must be performed before others. # Function Signature ```python def topological_sort(graph: DirectedGraph) -> list: pass ``` # Input Format - **graph**: An instance of `DirectedGraph` containing nodes and directed edges. # Output Format - **List of node names (str)** in topologically sorted order. # Constraints - The input graph will be acyclic (i.e., no cycles present). # Example Example 1 **Input**: ```python graph_dict = { \'A\': [\'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'E\'], \'D\': [\'F\'], \'E\': [\'F\'], \'F\': [] } graph = DirectedGraph(graph_dict) print(topological_sort(graph)) ``` **Output**: ```python [\'A\', \'B\', \'C\', \'D\', \'E\', \'F\'] ``` (Note: There may be multiple valid topological orderings; any correct ordering is acceptable.) # Edge Cases 1. Empty graph. 2. Nodes with no outgoing edges. 3. Disconnected subgraphs (though would still be acyclic). # Implementation Hints - You can consider using **Kahn\'s algorithm** or **DFS-based approach** for topological sorting. - Ensure that your solution handles graph initialization and node addition efficiently. # Additional Information Students should thoroughly test their implementation against a variety of graph configurations to ensure robustness.","solution":"class DirectedGraph: def __init__(self, graph_dict=None): if graph_dict is None: graph_dict = {} self.graph_dict = graph_dict def topological_sort(graph: DirectedGraph) -> list: # Helper function to perform DFS and add nodes to stack def dfs(node, visited, stack): visited.add(node) for neighbor in graph.graph_dict.get(node, []): if neighbor not in visited: dfs(neighbor, visited, stack) stack.insert(0, node) visited = set() stack = [] for node in graph.graph_dict: if node not in visited: dfs(node, visited, stack) return stack"},{"question":"# Context: You are working on a memory management system where certain allocation sizes need to be powers of two. To validate these sizes, you need to implement a function. # Task: Write a function `is_power_of_two(n)` which takes an integer `n` and returns `True` if `n` is a power of two, and `False` otherwise. # Input: * `n` (int): The integer to check. It follows the constraint: -2^31 <= n <= 2^31 - 1 # Output: * (bool): Returns `True` if `n` is a power of two, otherwise `False`. # Constraints: * Handle only integer inputs. * Consider edge cases such as 0 and negative numbers. * Ensure the function performs efficiently, ideally in O(1) time complexity. # Examples: 1. `is_power_of_two(16)` should return `True` because 16 is a power of two (2^4). 2. `is_power_of_two(18)` should return `False` because 18 is not a power of two. 3. `is_power_of_two(-16)` should return `False` because negative numbers cannot be powers of two. 4. `is_power_of_two(1)` should return `True` because 1 is a power of two (2^0). Implement the function `is_power_of_two(n)` using Python: ```python def is_power_of_two(n): :type n: int :rtype: bool # Your code here ```","solution":"def is_power_of_two(n): Returns True if n is a power of two, otherwise False. if n <= 0: return False return (n & (n - 1)) == 0"},{"question":"**Max and Min Hybrid Heap Sort** You are tasked with implementing a hybrid heap sort that combines the principles of both max heap and min heap sorting techniques to sort an array in ascending order. The objective is to take an input array and sort it using a combination of max heap and min heap transformations for educational purposes. # Function Signature ```python def hybrid_heap_sort(arr: List[int], simulation: bool = False) -> List[int]: Sorts an array of integers in ascending order using a hybrid of max heap and min heap sort. Args: - arr (List[int]): The array to be sorted. - simulation (bool): If True, prints the array at each step for simulation. Returns: - List[int]: The sorted array. ``` # Input Format - The input will be a list of integers, e.g., `[3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]`. # Output Format - The function should return a new list of integers representing the sorted array in ascending order. # Constraints - The length of the array `n` will be (1 leq n leq 10^5). - Each integer in the array will be in the range (-10^9) to (10^9). # Requirements - The function must employ a hybrid approach that uses both max heap and min heap at different stages. - If the `simulation` flag is set to `True`, the function should print the array at each iteration of the heapifying process for demonstration purposes. # Example ```python print(hybrid_heap_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5], simulation=True)) # Output should display the steps and eventually return: # [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] ``` # Explanation - Implement the `hybrid_heap_sort` function that first builds a max heap for one half of the array, sorts it, then builds a min heap for the second half, and sorts it. - Ensure that the final array is sorted in ascending order. # Note The objective is to test the understanding and implementation skills of heap sort variations and the ability to combine different sorting approaches into a single coherent algorithm.","solution":"from typing import List def hybrid_heap_sort(arr: List[int], simulation: bool = False) -> List[int]: n = len(arr) def max_heapify(arr, n, i): largest = i l = 2 * i + 1 r = 2 * i + 2 if l < n and arr[largest] < arr[l]: largest = l if r < n and arr[largest] < arr[r]: largest = r if largest != i: arr[i], arr[largest] = arr[largest], arr[i] max_heapify(arr, n, largest) def min_heapify(arr, n, i): smallest = i l = 2 * i + 1 r = 2 * i + 2 if l < n and arr[smallest] > arr[l]: smallest = l if r < n and arr[smallest] > arr[r]: smallest = r if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] min_heapify(arr, n, smallest) def build_max_heap(arr, n): for i in range(n // 2 - 1, -1, -1): max_heapify(arr, n, i) if simulation: print(\\"Max-Heapify step:\\", arr) def build_min_heap(arr, n): for i in range(n // 2 - 1, -1, -1): min_heapify(arr, n, i) if simulation: print(\\"Min-Heapify step:\\", arr) build_max_heap(arr, n // 2) for i in range(n // 2 - 1, -1, -1): arr[i], arr[0] = arr[0], arr[i] max_heapify(arr, i, 0) if simulation: print(\\"Sorting with Max-Heap:\\", arr) build_min_heap(arr[n // 2:], len(arr[n // 2:])) for i in range(n // 2, n): arr[i], arr[n // 2] = arr[n // 2], arr[i] min_heapify(arr, n, n // 2) if simulation: print(\\"Sorting with Min-Heap:\\", arr) return sorted(arr)"},{"question":"# Scenario You have a navigational system for a robot in a factory represented by a directed graph. Each node represents a workstation, and each directed edge indicates a path the robot can take from one workstation to another. Your task is to ensure that the robot can reach a target workstation starting from a specific source workstation. # Task Implement a function `is_reachable` that determines if there is a path from a source node to a target node in a directed graph. You will need to create the graph structure and apply the depth-first search algorithm to find out if such a path exists. # Implementation Details 1. **Input Format**: - `vertex_count`: The number of vertices in the graph. - `edges`: A list of tuples representing directed edges in the graph, where each tuple `(source, target)` indicates an edge from `source` to `target`. - `source`: The source node. - `target`: The target node. 2. **Output Format**: - Return `True` if there is a path from `source` to `target`, otherwise return `False`. 3. **Constraints**: - 1 <= `vertex_count` <= 1000 - 0 <= number of edges <= 5000 - 0 <= `source`, `target` < `vertex_count` # Function Signature ```python def is_reachable(vertex_count, edges, source, target): ``` # Example ```python vertex_count = 4 edges = [(0, 1), (1, 2), (2, 3), (3, 1)] source = 0 target = 3 assert is_reachable(vertex_count, edges, source, target) == True edges = [(0, 1), (1, 2), (2, 3)] assert is_reachable(vertex_count, edges, source, target) == True target = 4 assert is_reachable(vertex_count, edges, source, target) == False ``` # Notes - Ensure to handle edge cases and optimize for performance within constraints. - Consider iterative approaches to mitigate possible recursion depth issues.","solution":"def is_reachable(vertex_count, edges, source, target): Determines if there is a path from source to target in a directed graph. vertex_count: int - The number of vertices in the graph. edges: list of tuples - Each tuple (source, target) represents a directed edge from source to target. source: int - The starting node. target: int - The target node. Returns: bool - True if there is a path from source to target, False otherwise. from collections import defaultdict, deque # Create adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Perform BFS to find if there is a path from source to target visited = [False] * vertex_count queue = deque([source]) while queue: current = queue.popleft() if current == target: return True if not visited[current]: visited[current] = True for neighbor in graph[current]: if not visited[neighbor]: queue.append(neighbor) return False"},{"question":"You are tasked with extending the functionality of a histogram generation function to handle additional requirements. A histogram is an accurate representation of the distribution of numerical data. It estimates the probability distribution of a continuous variable. Your function should now take an additional parameter `sort_order` which can take values `\'asc\'` or `\'desc\'`, and return the histogram in the desired sorted order of the keys. # Function Signature ```python def get_histogram(input_list: list, sort_order: str) -> dict: Generate histogram of input_list and sort it based on the sort_order :param input_list: List with different and unordered values :param sort_order: String, either \'asc\' for ascending or \'desc\' for descending order :return: A dictionary representing the histogram of input_list, sorted based on the sort_order ``` # Input * A list of integers, `input_list`, with length n (0 <= n <= 10^6). * A string, `sort_order`, which can be either `\'asc\'` or `\'desc\'`. # Output * A dictionary where keys are the unique elements from the input list and the values are their frequencies, sorted based on the `sort_order`. # Constraints * The list can contain up to 1,000,000 elements. # Example Example 1 **Input**: ```python input_list = [3, 3, 2, 1] sort_order = \'asc\' ``` **Output**: ```python {1: 1, 2: 1, 3: 2} ``` Example 2 **Input**: ```python input_list = [2, 3, 5, 5, 5, 6, 4, 3, 7] sort_order = \'desc\' ``` **Output**: ```python {7: 1, 6: 1, 5: 3, 4: 1, 3: 2, 2: 1} ``` Example 3 **Input**: ```python input_list = [] sort_order = \'asc\' ``` **Output**: ```python {} ``` # Additional Notes * If `sort_order` is not `\'asc\'` or `\'desc\'`, return the histogram without sorting. * Your implementation should efficiently handle large input sizes.","solution":"def get_histogram(input_list: list, sort_order: str) -> dict: Generate histogram of input_list and sort it based on the sort_order :param input_list: List with different and unordered values :param sort_order: String, either \'asc\' for ascending or \'desc\' for descending order :return: A dictionary representing the histogram of input_list, sorted based on the sort_order # Creating the histogram by counting the frequency of each element histogram = {} for item in input_list: if item in histogram: histogram[item] += 1 else: histogram[item] = 1 # Sorting the histogram based on the sort_order if sort_order == \'asc\': return dict(sorted(histogram.items())) elif sort_order == \'desc\': return dict(sorted(histogram.items(), reverse=True)) else: return histogram"},{"question":"# Binary Search Tree Operations You are tasked with implementing a Binary Search Tree (BST) class with basic operations including insertion, deletion, and searching. Context A company needs to handle dynamic sets of client IDs to ensure speedy lookup and modification operations. A BST is suitable for this due to its average case efficiency. # Requirements Implement the following functions in the BST class: 1. **Insert Function** - **Input**: An integer `key` to be inserted into the BST. - **Output**: None. Modifies the BST in place. - **Behavior**: This function inserts a new node with the given `key` such that the BST property is maintained. 2. **Delete Function** - **Input**: An integer `key` to be deleted from the BST. - **Output**: None. Modifies the BST in place. - **Behavior**: This function deletes the node with the given `key` and restructures the BST to maintain its property. 3. **Search Function** - **Input**: An integer `key` to be searched in the BST. - **Output**: Returns True if the `key` is found, else returns False. - **Behavior**: This function searches for a node with the given `key` and returns whether it exists in the BST or not. ```python class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, key: int) -> None: pass def delete(self, key: int) -> None: pass def search(self, key: int) -> bool: pass ``` # Constraints - Values inserted in the BST are unique. - The initial BST is empty. - Input values for insert, delete, and search are integers. - Nodes will only hold integer values. Example ```python bst = BinarySearchTree() bst.insert(5) bst.insert(3) bst.insert(7) print(bst.search(3)) # Output: True bst.delete(3) print(bst.search(3)) # Output: False ``` Implement the above functions ensuring the BST remains valid and performs efficiently.","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, key: int) -> None: def insert_node(node, key): if not node: return TreeNode(key) if key < node.val: node.left = insert_node(node.left, key) else: node.right = insert_node(node.right, key) return node self.root = insert_node(self.root, key) def delete(self, key: int) -> None: def delete_node(node, key): if not node: return node if key < node.val: node.left = delete_node(node.left, key) elif key > node.val: node.right = delete_node(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp = find_min(node.right) node.val = temp.val node.right = delete_node(node.right, temp.val) return node def find_min(node): while node.left: node = node.left return node self.root = delete_node(self.root, key) def search(self, key: int) -> bool: def search_node(node, key): if not node: return False if key == node.val: return True elif key < node.val: return search_node(node.left, key) else: return search_node(node.right, key) return search_node(self.root, key)"},{"question":"File Path Expansion Function # Scenario You are developing a utility script to manage file paths in a cross-platform environment where users input various forms of file paths (relative paths, paths with user home directory shortcuts, etc.). To ensure consistent and reliable file path usage, you need to convert all given paths to their absolute form, correctly handling any user directory shortcuts. # Task Implement a function `resolve_absolute_path` that takes a single string argument representing a file path and returns its absolute path, converting any user directory shortcuts (`~` or `~user`) as necessary. # Requirements * Function Signature: ```python def resolve_absolute_path(file_path: str) -> str: ``` * **Input**: * `file_path` (str): A string representing the file path (could be relative, contain user shortcuts, etc.). * **Output**: * Returns a string representing the absolute path of the given file. * **Constraints**: * The function should handle an empty string by returning an empty string. * Assume that the input is a valid path (focus on handling user shortcuts and relative paths). * **Performance**: * Ensure the function operates in constant time `O(1)`. # Example Usage ```python print(resolve_absolute_path(\\"~/example.txt\\")) # Returns the absolute path to \'example.txt\' in the user home directory print(resolve_absolute_path(\\"/etc/hosts\\")) # Returns \\"/etc/hosts\\" if called on a Unix-like system print(resolve_absolute_path(\\"relative_path/file\\")) # Returns the absolute path for a relative path \'relative_path/file\' print(resolve_absolute_path(\\"\\")) # Returns \\"\\" ```","solution":"import os def resolve_absolute_path(file_path: str) -> str: Resolves the given file path to its absolute path, handling any user directory shortcuts. Parameters: - file_path (str): The file path to resolve. Returns: - str: The absolute path. if file_path == \\"\\": return \\"\\" return os.path.abspath(os.path.expanduser(file_path))"},{"question":"# Context In many applications, especially those related to data processing and storage, it is often desirable to move all zero values to the end of an array while maintaining the relative order of non-zero elements. This process helps in separate zero-padding for storage or further manipulations where zeros need no active inclusion in the primary processing logic. # Problem Statement Write a function `move_zeros_inplace` that takes an array and moves all of the zeros to the end, preserving the order of the other elements. This function should perform the operation in place, minimizing the use of additional memory. # Function Signature ```python def move_zeros_inplace(arr: list) -> None: Modifies the input list by moving all zeros to the end, while maintaining the relative order of non-zero elements. Parameters: arr (list): The list of mixed elements including integers, strings, and booleans. Returns: None: The list is modified in place. ``` # Input - `arr` (list): A list containing integers, strings, and booleans. # Output - The function modifies the input list in place and does not return anything. # Constraints - All elements that are zeros (integers) should be moved to the end of the list. - The function should handle elements of different types consistently (integers, booleans, strings). # Example ```python arr = [False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"] move_zeros_inplace(arr) print(arr) # Output should be: [False, 1, 1, 2, 1, 3, \'a\', 0, 0] ``` # Additional Requirements - The solution should have a time complexity of O(n). - The solution should have a space complexity of O(1), implying in-place modifications only. # Hints - Consider two-pointer technique to segregate zeros and non-zeros in a single pass. - Carefully consider how to handle different types of elements, ensuring only integer `0`s are moved.","solution":"def move_zeros_inplace(arr): Modifies the input list by moving all zeros to the end, while maintaining the relative order of non-zero elements. Parameters: arr (list): The list of mixed elements including integers, strings, and booleans. Returns: None: The list is modified in place. non_zero_index = 0 for i in range(len(arr)): if arr[i] != 0 or type(arr[i]) is bool: arr[non_zero_index] = arr[i] non_zero_index += 1 for i in range(non_zero_index, len(arr)): arr[i] = 0"},{"question":"Context: You are tasked with developing software for a navigation system to assist users in finding efficient routes between two locations. Your system will utilize a graph-based model of the road map, where intersections are represented as nodes and roads are edges. Problem: You need to implement a function that finds the shortest path between two intersections to direct users efficiently. Moreover, the function should handle disconnections and cycles without error, and should be optimized for real-world large graphs. Task: Implement the function `optimized_shortest_path(graph, start, end)` that finds the shortest path between two nodes in a graph, iterative and optimized for performance and memory usage. Function Signature: ```python def optimized_shortest_path(graph: dict, start: str, end: str) -> list: pass ``` Input: - **graph**: A dictionary where keys are node labels and values are lists of adjacent nodes. - Example: `{\'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\']}` - **start**: Starting node label (string). - **end**: Target node label (string). Output: - A list of nodes representing the shortest path from start to end. If no path exists, return `None`. Constraints: - All node labels are unique. - The graph may contain cycles. - The graph is not necessarily connected. - You should handle graphs with up to (10^4) nodes efficiently. Example: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } assert optimized_shortest_path(graph, \'A\', \'F\') == [\'A\', \'C\', \'F\'] assert optimized_shortest_path(graph, \'A\', \'D\') == [\'A\', \'B\', \'D\'] assert optimized_shortest_path(graph, \'A\', \'X\') == None # \'X\' does not exist assert optimized_shortest_path(graph, \'D\', \'A\') == [\'D\', \'B\', \'A\'] assert optimized_shortest_path(graph, \'A\', \'A\') == [\'A\'] ``` Performance Requirements: - Should handle graphs with up to (10^4) nodes. - Preferably return results in O(V + E) time, with V being vertices and E being edges.","solution":"import heapq def optimized_shortest_path(graph, start, end): Finds the shortest path between start and end nodes in an unweighted graph. Parameters: graph (dict): A dictionary representing the adjacency list of the graph. start (str): The starting node. end (str): The target node. Returns: list: A list representing the shortest path from start to end. Returns None if no path exists. # Edge case where start and end are the same if start == end: return [start] # Use Dijkstra\'s algorithm for finding the shortest path queue = [(0, start)] # (distance, node) distances = {start: 0} previous_nodes = {start: None} while queue: current_distance, current_node = heapq.heappop(queue) # Early exit if we reached the target node if current_node == end: path = [] while current_node is not None: path.insert(0, current_node) current_node = previous_nodes[current_node] return path for neighbor in graph.get(current_node, []): distance = current_distance + 1 # All edges have a weight of 1 if neighbor not in distances or distance < distances[neighbor]: distances[neighbor] = distance previous_nodes[neighbor] = current_node heapq.heappush(queue, (distance, neighbor)) return None # If we exhaust the queue without finding the end node"},{"question":"# Bitonic Sort Implementation Challenge You are tasked with implementing a function called `bitonic_sort` that sorts an array using the Bitonic Sort algorithm. Bitonic Sort is a type of sorting algorithm designed specifically for parallel processing but can also be implemented sequentially. Here\'s the general behavior: 1. Splits the array into two halves. 2. Sorts one half in ascending order and the other in descending order. 3. Recursively merges the two halves via the bitonic merge process. # Function Signature ```python def bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: ``` # Input - `arr`: A list of integers to be sorted. The size of the list must be a power of two. - `reverse`: A boolean indicating the sorting order. If `True`, the list should be sorted in ascending order. If `False`, the list should be sorted in descending order. # Output - Returns a new list of integers, sorted based on the input criteria. # Constraints - The input array length `n` must be a power of two (2, 4, 8, 16, ...). # Example ```python assert bitonic_sort([3, 7, 4, 8, 6, 2, 1, 5], reverse=True) == [1, 2, 3, 4, 5, 6, 7, 8] assert bitonic_sort([3, 7, 4, 8, 6, 2, 1, 5], reverse=False) == [8, 7, 6, 5, 4, 3, 2, 1] ``` # Notes - Your implementation should be robust enough to handle arrays of all valid sizes. - Remember to handle cases where the size of the array is not a power of two by raising a `ValueError`. # Objective Demonstrate your understanding of advanced sorting techniques, recursion, and handling of specific constraints through this implementation.","solution":"from typing import List def bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: def compare_and_swap(arr, i, j, dir): if (dir == (arr[i] > arr[j])): arr[i], arr[j] = arr[j], arr[i] def bitonic_merge(arr, low, cnt, dir): if cnt > 1: k = cnt // 2 for i in range(low, low + k): compare_and_swap(arr, i, i + k, dir) bitonic_merge(arr, low, k, dir) bitonic_merge(arr, low + k, k, dir) def bitonic_sort_recursive(arr, low, cnt, dir): if cnt > 1: k = cnt // 2 bitonic_sort_recursive(arr, low, k, True) bitonic_sort_recursive(arr, low + k, k, False) bitonic_merge(arr, low, cnt, dir) n = len(arr) if n & (n - 1) != 0: raise ValueError(\\"Size of input array must be a power of two.\\") bitonic_sort_recursive(arr, 0, n, reverse) return arr"},{"question":"# Context You are building a custom word filtering feature for a text editor that helps users type faster by suggesting words that can be typed using letters from only one row of the typical QWERTY keyboard. # Task Write a function `filter_keyboard_row(words)` that takes a list of words and returns a new list containing only the words that can be typed using letters of the alphabet from only one row of the keyboard. # Input * `words`: A list of strings where each string represents a word. The length of the list of words `n` can be up to 10^4 and the length of each word `m` can be up to 100. # Output * A list of strings containing the filtered words that satisfy the keyboard row constraint. # Constraints * The words consist of only alphabetic characters. * Case-insensitive; consider \'Q\' and \'q\' as the same character. * Order of words in the output should be the same as the input order. # Example ```python Input: [\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"] Output: [\\"Alaska\\", \\"Dad\\"] ``` # Instructions Implement the function `filter_keyboard_row(words)` to solve the problem. Ensure your solution adheres to the stated constraints and is optimized for performance.","solution":"def filter_keyboard_row(words): Filters words that can be typed using only one row of the keyboard. :param words: List of words :return: List of words that can be typed using letters from only one row of the keyboard # Define the sets for each keyboard row row1 = {\\"q\\", \\"w\\", \\"e\\", \\"r\\", \\"t\\", \\"y\\", \\"u\\", \\"i\\", \\"o\\", \\"p\\"} row2 = {\\"a\\", \\"s\\", \\"d\\", \\"f\\", \\"g\\", \\"h\\", \\"j\\", \\"k\\", \\"l\\"} row3 = {\\"z\\", \\"x\\", \\"c\\", \\"v\\", \\"b\\", \\"n\\", \\"m\\"} def can_type_with_one_row(word): Checks if the word can be typed using only one row lowercase_word = set(word.lower()) return lowercase_word <= row1 or lowercase_word <= row2 or lowercase_word <= row3 # Filter words that can be typed using only one row return [word for word in words if can_type_with_one_row(word)]"},{"question":"You are given an array of positive integers. Your task is to implement the `bucket_sort` function that sorts the array using the bucket sort algorithm. The function should sort the elements efficiently and handle edge cases appropriately. # Function Signature ```python def bucket_sort(arr: List[int]) -> List[int]: pass ``` # Input - `arr`: A list of `n` positive integers, where `1 <= n <= 10^5` and `0 <= arr[i] <= 10^9`. # Output - The function should return a list of integers that are sorted in non-decreasing order. # Example ```python assert bucket_sort([4, 1, 7, 3, 8, 2]) == [1, 2, 3, 4, 7, 8] assert bucket_sort([5, 3, 5, 3, 5]) == [3, 3, 5, 5, 5] assert bucket_sort([]) == [] assert bucket_sort([1]) == [1] ``` # Constraints - Ensure your solution is optimized for both time and space complexity. - You may use any sorting algorithm within the bucket sort to sort the individual buckets, but pay attention to their complexity. # Notes 1. **Normal Distribution**: Ensure that the bucket allocation is proper to distribute values uniformly. 2. **Bucket Count**: The count of buckets used should ideally match the input size for uniformly distributed inputs. 3. **Auxiliary Function**: You may implement an auxiliary sorting function if necessary within the `bucket_sort` to sort the buckets.","solution":"from typing import List def bucket_sort(arr: List[int]) -> List[int]: if not arr: return [] max_value = max(arr) # Initialize 10 empty buckets bucket_count = 10 buckets = [[] for _ in range(bucket_count)] # Determine the proper bucket for each element for num in arr: index = num * bucket_count // (max_value + 1) # Proportional index buckets[index].append(num) # Use built-in sorted() for sorting each bucket for i in range(bucket_count): buckets[i] = sorted(buckets[i]) # Concatenate the sorted buckets sorted_array = [] for bucket in buckets: sorted_array.extend(bucket) return sorted_array"},{"question":"You have been provided with a nearly-complete implementation of the Quick Sort algorithm. Your task is to complete and optimize the Quick Sort function by making improvements where necessary. The Quick Sort function should sort an array of integers in ascending order. You should ensure the algorithm handles edge cases and optimizes performance for typical input scenarios. Additionally, enhance the function to select an optimal pivot to avoid worst-case time complexity. # Function Signature ```python def optimized_quick_sort(arr: List[int], simulation: bool=False) -> List[int]: pass ``` # Input * **arr**: A list of integers that need to be sorted. * **simulation** (optional): A boolean flag. If set to `True`, the function will print the array after each iteration of partitioning for visualization. # Output * A list of integers sorted in ascending order. # Constraints * The elements in the array are unique. * The array can have up to 10^6 elements. * The integer elements are in the range -10^9 to 10^9. # Example Example 1 **Input:** ```python optimized_quick_sort([3, 5, 2, 1, 4]) ``` **Output:** ```python [1, 2, 3, 4, 5] ``` Example 2 **Input:** ```python optimized_quick_sort([10, 7, 8, 9, 1, 5]) ``` **Output:** ```python [1, 5, 7, 8, 9, 10] ``` # Performance Requirements * Ensure the function performs well on large datasets of up to 10^6 elements. * Implement optimizations to reduce the chance of hitting the worst-case time complexity. **Hint**: Consider using a pivot selection method that avoids the worst-case for already sorted or reverse-sorted arrays.","solution":"from typing import List def optimized_quick_sort(arr: List[int], simulation: bool=False) -> List[int]: def quick_sort(arr, low, high): if low < high: pi = partition(arr, low, high) quick_sort(arr, low, pi - 1) quick_sort(arr, pi + 1, high) def partition(arr, low, high): pivot_idx = median_of_three(arr, low, high) arr[high], arr[pivot_idx] = arr[pivot_idx], arr[high] pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i = i + 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] if simulation: print(arr) return i + 1 def median_of_three(arr, low, high): mid = (low + high) // 2 if arr[low] > arr[mid]: arr[low], arr[mid] = arr[mid], arr[low] if arr[low] > arr[high]: arr[low], arr[high] = arr[high], arr[low] if arr[mid] > arr[high]: arr[mid], arr[high] = arr[high], arr[mid] return mid quick_sort(arr, 0, len(arr) - 1) return arr"},{"question":"# ZigZag Iterator for Multiple Lists **Problem Statement**: You are tasked with implementing a `ZigZagIterator` that takes a list of integer lists (instead of just two lists) and iterates over them in a zigzag manner. In other words, it should return elements from each list in turn until all elements are exhausted. For example, given input lists: ``` v1 = [1, 2] v2 = [3, 4, 5, 6] v3 = [7, 8, 9] ``` The sequence of returned elements should be: 1, 3, 7, 2, 4, 8, 5, 9, 6. **Function Signatures**: Implement the following methods in the `ZigZagIterator` class: - `__init__(self, lists: List[List[int]])` - `next(self) -> int` - `has_next(self) -> bool` **Constraints**: - The number of input lists is at least 1. - The lists can be of different lengths and may contain zero elements. - Time complexity for `next()` and `has_next()` should be O(1). **Usage**: Your implementation should support code like this: ```python v1 = [1, 2] v2 = [3, 4, 5, 6] v3 = [7, 8, 9] it = ZigZagIterator([v1, v2, v3]) result = [] while it.has_next(): result.append(it.next()) print(result) # Should print [1, 3, 7, 2, 4, 8, 5, 9, 6] ``` **Notes**: - Ensure your implementation handles varying lengths of lists. - Consider edge cases such as empty lists or lists containing zero elements.","solution":"from typing import List class ZigZagIterator: def __init__(self, lists: List[List[int]]): self.queue = [] self.iters = [iter(lst) for lst in lists] for i, it in enumerate(self.iters): first_element = next(it, None) if first_element is not None: self.queue.append((i, first_element)) def next(self) -> int: if not self.has_next(): raise Exception(\\"No more elements\\") idx, value = self.queue.pop(0) next_element = next(self.iters[idx], None) if next_element is not None: self.queue.append((idx, next_element)) return value def has_next(self) -> bool: return len(self.queue) > 0"},{"question":"# Longest Common Subsequence Problem The challenge is to write a function that calculates the longest common subsequence of two given strings. The function should return the length of the longest common subsequence. Function Signature ```python def longest_common_subsequence(s_1: str, s_2: str) -> int: :param s_1: string :param s_2: string :return: length of the longest common subsequence ``` Input - `s_1` (1 ≤ |s_1| ≤ 1000): A string containing lowercase English alphabets. - `s_2` (1 ≤ |s_2| ≤ 1000): Another string containing lowercase English alphabets. Output - An integer representing the length of the longest common subsequence of the two strings. Example ```python assert longest_common_subsequence(\'abcdgh\', \'aedfhr\') == 3 # \\"adh\\" assert longest_common_subsequence(\'abc\', \'def\') == 0 # No common subsequence ``` Constraints - The function should run efficiently for the input sizes provided. - Handle edge cases such as one or both strings being empty. - Aim to write optimized and clean code with appropriate comments. Scenario You were hired to build a diff tool for a version control system. One key component requires finding the longest common subsequence between two versions of text files to help in understanding the differences. Your task is to implement the function that resolves this requirement.","solution":"def longest_common_subsequence(s_1: str, s_2: str) -> int: Returns the length of the longest common subsequence between s_1 and s_2. :param s_1: string :param s_2: string :return: length of the longest common subsequence m, n = len(s_1), len(s_2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if s_1[i - 1] == s_2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"Problem Statement: You are tasked to write a function that finds the nth digit in the sequence of infinite natural numbers – \\"123456789101112...\\" and so on. Your implementation should be efficient, especially for large values of n. Function Signature: ```python def find_nth_digit(n: int) -> int: pass ``` Input: * An integer `n` (1 ≤ n ≤ 2 × 10^9), representing the position in the sequence. Output: * A single integer, the nth digit in the sequence. Constraints: * Your solution must efficiently handle large inputs and work within memory limits. * You cannot generate the entire sequence up to `n`. Performance Requirements: * Your solution should have a time complexity better than O(n). Examples: ```python print(find_nth_digit(3)) # Output: 3 print(find_nth_digit(11)) # Output: 0 print(find_nth_digit(15)) # Output: 2 print(find_nth_digit(1000)) # Output: 3 ``` Scenario/Context: Imagine an infinite sequence composed of natural numbers concatenated together: \\"1234567891011121314...\\". Your task is to determine which digit is at the nth position in this seemingly unending stream. This is akin to locating a specific grain of sand on an endless beach but using defined mathematical methods efficiently.","solution":"def find_nth_digit(n: int) -> int: length = 1 # The length of the current range\'s numbers (1 for 1-9, 2 for 10-99, etc.) count = 9 # The count of numbers in the current range (9 for 1-9, 90 for 10-99, etc.) start = 1 # The starting number of the current range (1, 10, 100, etc.) # Find the range that the nth digit falls into while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Find the exact number that contains the nth digit start += (n - 1) // length # Find the exact digit in the number s = str(start) return int(s[(n - 1) % length])"},{"question":"You are given an array of strings `strs`. Write a function `longestCommonPrefix(strs)` to find the longest common prefix string among these strings. Input: - An array of strings `strs` (1 ≤ length of each string ≤ 200, 1 ≤ number of strings ≤ 200). Output: - A single string that represents the longest common prefix among the input strings. If there is no common prefix, return an empty string `\\"\\"`. Constraints: - You must provide the solution using at least two of the following methods: 1. **Horizontal Scanning** 2. **Vertical Scanning** 3. **Divide and Conquer** - Your solution should handle both small and large inputs efficiently. Example 1: ``` Input: [\\"flower\\",\\"flow\\",\\"flight\\"] Output: \\"fl\\" ``` Example 2: ``` Input: [\\"dog\\",\\"racecar\\",\\"car\\"] Output: \\"\\" Explanation: There is no common prefix among the input strings. ``` Performance Requirements: - Your solution should aim for a time complexity of O(S), where S is the sum of all characters in all strings. - Space complexity should be maintained at O(1) where possible, except for Divide and Conquer which may require O(m*log(n)) stack space, where m is the length of the shortest string and n is the number of strings. Implement the function `longestCommonPrefix(strs)` and demonstrate its functionality using the given examples.","solution":"def longestCommonPrefix_horizontal_scanning(strs): Finds the longest common prefix among a list of strings using horizontal scanning. if not strs: return \\"\\" prefix = strs[0] for string in strs[1:]: while string[:len(prefix)] != prefix: prefix = prefix[:-1] if not prefix: return \\"\\" return prefix def longestCommonPrefix_vertical_scanning(strs): Finds the longest common prefix among a list of strings using vertical scanning. if not strs: return \\"\\" min_length = min(len(s) for s in strs) for i in range(min_length): current_char = strs[0][i] if any(s[i] != current_char for s in strs): return strs[0][:i] return strs[0][:min_length] # Main function to use both methods def longestCommonPrefix(strs): return longestCommonPrefix_horizontal_scanning(strs)"},{"question":"# B-Tree Implementation Question You are given an implementation of a B-Tree class. The B-Tree is a self-balancing tree data structure that maintains sorted data and allows searches, insertions, and deletions in logarithmic time. The goal is to implement and test operations on this tree to ensure its efficiency and correctness across various scenarios. # Requirements 1. **Function Implementation:** Implement a method to delete a key from the B-Tree. ```python def delete_key(tree: BTree, key: int) -> None: Function to remove a key from the B-Tree. Should modify the tree in place. :param tree: BTree instance :param key: Key to remove pass ``` 2. **Constraints:** - Assume the B-Tree is initially non-empty. - Ensure that removing the key maintains the B-Tree properties. 3. **Input-Output:** Input: An instance of BTree and the key to be deleted. Output: In-place adjustment of the BTree structure. Use traversal to print tree keys in order. 4. **Performance Requirements:** - The operation should maintain the B-Tree property, ensuring logarithmic time complexity for deletion. # Scenario & Context Consider a file indexing system where each file is assigned a unique identifier, and these identifiers are maintained in a B-Tree structure to ensure efficient access and manipulation. Implement the `delete_key` operation in this B-Tree so that the system can correctly remove obsolete file identifiers while maintaining efficient access to existing ones. # Examples Example 1: Input: Insert keys [10, 20, 30, 40, 50] Operation: delete_key(tree, 30) Expected Output (tree traversal): 10 20 40 50 Example 2: Input: Insert keys [1, 2, 3, 4, 5, 6] Operation: delete_key(tree, 4) Expected Output (tree traversal): 1 2 3 5 6 Utilize the given B-Tree class structure and base code. Implement the `delete_key` method such that the above scenarios are handled efficiently.","solution":"class BTreeNode: def __init__(self, leaf=False): self.leaf = leaf self.keys = [] self.children = [] class BTree: def __init__(self, t): self.root = BTreeNode(True) self.t = t def traverse(self, node, result): if not node: return for i in range(len(node.keys)): if not node.leaf: self.traverse(node.children[i], result) result.append(node.keys[i]) if not node.leaf: self.traverse(node.children[len(node.keys)], result) def get_traversal(self): result = [] self.traverse(self.root, result) return result def search(self, node, k): i = 0 while i < len(node.keys) and k > node.keys[i]: i += 1 if i < len(node.keys) and node.keys[i] == k: return node if node.leaf: return None return self.search(node.children[i], k) def split_child(self, x, i): t = self.t y = x.children[i] z = BTreeNode(y.leaf) x.children.insert(i+1, z) x.keys.insert(i, y.keys[t-1]) z.keys = y.keys[t:(2*t-1)] y.keys = y.keys[0:(t-1)] if not y.leaf: z.children = y.children[t:(2*t)] y.children = y.children[0:t] def insert_non_full(self, x, k): i = len(x.keys) - 1 if x.leaf: x.keys.append(None) while i >= 0 and k < x.keys[i]: x.keys[i+1] = x.keys[i] i -= 1 x.keys[i+1] = k else: while i >= 0 and k < x.keys[i]: i -= 1 i += 1 if len(x.children[i].keys) == 2*self.t - 1: self.split_child(x, i) if k > x.keys[i]: i += 1 self.insert_non_full(x.children[i], k) def insert(self, k): root = self.root if len(root.keys) == 2*self.t - 1: temp = BTreeNode() self.root = temp temp.children.append(root) self.split_child(temp, 0) self.insert_non_full(temp, k) else: self.insert_non_full(root, k) def delete_key(self, k): self._delete(self.root, k) def _delete(self, node, k): t = self.t if node is None: return # Find the key in the current node idx = 0 while idx < len(node.keys) and node.keys[idx] < k: idx += 1 # If the key is in the current node if idx < len(node.keys) and node.keys[idx] == k: if node.leaf: # Case 1: Node is a leaf node node.keys.pop(idx) else: self._delete_internal_node(node, k, idx) else: if node.leaf: # Case 2: Node is a leaf node and does not contain the key return flag = (idx == len(node.keys)) # If the child where k is supposed to exist has less than t keys, fill it if len(node.children[idx].keys) < t: self._fill(node, idx) # Recur in the proper child if flag and idx > len(node.keys): self._delete(node.children[idx - 1], k) else: self._delete(node.children[idx], k) def _delete_internal_node(self, node, k, idx): t = self.t if len(node.children[idx].keys) >= t: pred = self._get_pred(node, idx) node.keys[idx] = pred self._delete(node.children[idx], pred) elif len(node.children[idx + 1].keys) >= t: succ = self._get_succ(node, idx) node.keys[idx] = succ self._delete(node.children[idx + 1], succ) else: self._merge(node, idx) self._delete(node.children[idx], k) def _get_pred(self, node, idx): cur = node.children[idx] while not cur.leaf: cur = cur.children[len(cur.keys)] return cur.keys[len(cur.keys) - 1] def _get_succ(self, node, idx): cur = node.children[idx + 1] while not cur.leaf: cur = cur.children[0] return cur.keys[0] def _fill(self, node, idx): t = self.t if idx != 0 and len(node.children[idx - 1].keys) >= t: self._borrow_from_prev(node, idx) elif idx != len(node.keys) and len(node.children[idx + 1].keys) >= t: self._borrow_from_next(node, idx) else: if idx != len(node.keys): self._merge(node, idx) else: self._merge(node, idx - 1) def _borrow_from_prev(self, node, idx): child = node.children[idx] sibling = node.children[idx - 1] for i in range(len(child.keys) - 1, -1, -1): child.keys[i + 1] = child.keys[i] if not child.leaf: for i in range(len(child.children) - 1, -1, -1): child.children[i + 1] = child.children[i] child.keys[0] = node.keys[idx - 1] if not child.leaf: child.children[0] = sibling.children[len(sibling.children) - 1] node.keys[idx - 1] = sibling.keys[len(sibling.keys) - 1] child.keys.insert(0, sibling.keys.pop()) if not sibling.leaf: child.children.insert(0, sibling.children.pop()) def _borrow_from_next(self, node, idx): child = node.children[idx] sibling = node.children[idx + 1] if not child.leaf: child.children.append(sibling.children.pop(0)) child.keys.append(node.keys[idx]) node.keys[idx] = sibling.keys.pop(0) def _merge(self, node, idx): child = node.children[idx] sibling = node.children[idx + 1] child.keys.append(node.keys.pop(idx)) node.children.pop(idx + 1) child.keys.extend(sibling.keys) if not child.leaf: child.children.extend(sibling.children)"},{"question":"# Maximum Network Flow Problem You are given a directed graph representing a network of pipes with capacities, formatted as an `n x n` adjacency matrix where `n` is the number of vertices. Each entry `adjacency_matrix[i][j]` represents the capacity of the pipe from vertex `i` to vertex `j`. Your task is to determine the maximum amount of flow that can be sent from the source vertex (0) to the sink vertex (n-1). Input: * A 2-dimensional list `adjacency_matrix` of size `n x n` where `adjacency_matrix[i][j]` is the capacity of the pipe from vertex `i` to vertex `j`. `n >= 2`. Output: * An integer representing the maximum flow that can be sent from the source vertex to the sink vertex. Constraints: * The capacities are non-negative integers. * The flow in pipes follows standard network flow properties. Guidelines: * Ensure that your solution correctly finds and augments paths until no more augmenting paths exist. * Edge cases should be considered, such as when there is no path from the source to the sink. Example: ```python graph = [[0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0]] # Expected output: Maximum flow is 23 ``` Notes: * You must ensure the accuracy of capacities updated during each iterated path exploration. * Handle any potential infinite loops or excessive memory usage by adhering to optimal path discovery operations. Implement the function `maximum_flow_dfs(adjacency_matrix)` to solve the problem described above.","solution":"def maximum_flow_dfs(adjacency_matrix): Computes the maximum flow in a flow network using the DFS-based Ford-Fulkerson method. :param adjacency_matrix: List[List[int]] - The capacity graph represented as an adjacency matrix. :return: int - Maximum flow from source (vertex 0) to sink (vertex n-1). n = len(adjacency_matrix) source = 0 sink = n - 1 max_flow = 0 parent = [-1] * n def dfs(source, sink, parent): Depth-first search to find if there is a path from source to sink in the residual graph. Also stores the path in parent array. :param source: int - Source vertex. :param sink: int - Sink vertex. :param parent: List[int] - Stores the path. :return: boolean - True if there is a path, False otherwise. visited = [False] * n stack = [source] visited[source] = True while stack: u = stack.pop() for v, capacity in enumerate(adjacency_matrix[u]): if not visited[v] and capacity > 0: stack.append(v) parent[v] = u visited[v] = True if v == sink: return True return False # Augment the flow while a path exists while dfs(source, sink, parent): # Find the maximum flow through the path found by DFS path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, adjacency_matrix[parent[s]][s]) s = parent[s] # update residual capacities of the edges and reverse edges along the path v = sink while v != source: u = parent[v] adjacency_matrix[u][v] -= path_flow adjacency_matrix[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"# Problem Description You are given an array of integers that needs to be sorted. Implement the Shell Sort algorithm with a custom gap sequence to ensure better performance on average. Your implementation should follow these guidelines: # Function Signature ```python def custom_shell_sort(arr: List[int]) -> List[int]: ``` # Input: - `arr`: A list of integers that need to be sorted. The length of the list (n) is in the range [1, 10000]. # Output: - Return the sorted list in ascending order. # Constraints: - You must use a custom gap sequence for the Shell Sort, which is the Sedgewick sequence. - The Sedgewick sequence can be defined as: gaps = {1, 5, 19, 41, 109,...} - Your solution should handle large arrays efficiently both in terms of time and space complexity. # Example ```python >>> custom_shell_sort([9, 8, 3, 7, 5, 6, 4, 1]) [1, 3, 4, 5, 6, 7, 8, 9] >>> custom_shell_sort([20, 50, 30, 10, 40]) [10, 20, 30, 40, 50] ``` # Constraints & Data Integrity - The input list will always contain integers. - Duplicates are allowed. - Negative numbers are allowed. - The function should not modify the original list in place.","solution":"from typing import List def custom_shell_sort(arr: List[int]) -> List[int]: Implements Shell Sort using Sedgewick\'s gap sequence. n = len(arr) if n < 2: return arr[:] # No need to sort # Create Sedgewick\'s gap sequence gaps = [] k = 0 while True: gap1 = 9 * (4**k - 2**k) + 1 gap2 = 2 * (2**(k+1) - 1) + 1 if gap1 < n: gaps.append(gap1) if gap2 < n and gap2 != gap1: gaps.append(gap2) if gap1 >= n and gap2 >= n: break k += 1 gaps = sorted(gaps, reverse=True) # Create a copy of the array to avoid modifying the original in place result = arr[:] # Perform shell sort using the generated gap sequence for gap in gaps: for i in range(gap, n): temp = result[i] j = i while j >= gap and result[j - gap] > temp: result[j] = result[j - gap] j -= gap result[j] = temp return result"},{"question":"**FizzBuzz Custom Implementation** Given a positive integer `N`, write a function `custom_fizzbuzz(N)` that returns a list from 1 to `N` where: 1. Numbers divisible by 3 are replaced by the string \\"Fizz\\". 2. Numbers divisible by 5 are replaced by the string \\"Buzz\\". 3. Numbers divisible by both 3 and 5 are replaced by the string \\"FizzBuzz\\". 4. For other numbers, include them as they are. Input * A single integer `N` (1 ≤ N ≤ 10^6) Output * A list of length `N` with elements as described above. Example ```python custom_fizzbuzz(15) # Output: [1, 2, \\"Fizz\\", 4, \\"Buzz\\", \\"Fizz\\", 7, 8, \\"Fizz\\", \\"Buzz\\", 11, \\"Fizz\\", 13, 14, \\"FizzBuzz\\"] ``` Constraints * Ensure your function is efficient both in terms of time and space complexity. While `O(N)` time complexity is expected, aim to minimize space usage. Edge Cases * When `N` is 1, the output should be `[1]`. * Handle invalid inputs by raising appropriate exceptions. # Requirements * Ensure input validation. * Consider possible optimizations to reduce memory usage. * Provide a robust solution encompassing edge cases and ensure all elements are correctly replaced according to the defined rules.","solution":"def custom_fizzbuzz(N): Returns a list from 1 to N where: - Numbers divisible by 3 are replaced by \\"Fizz\\". - Numbers divisible by 5 are replaced by \\"Buzz\\". - Numbers divisible by both 3 and 5 are replaced by \\"FizzBuzz\\". if not isinstance(N, int) or N < 1: raise ValueError(\\"Input must be a positive integer.\\") result = [] for i in range(1, N+1): if i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(i) return result"},{"question":"# Matrix Multiplication Challenge Context In various computer science and engineering applications, matrix multiplication is a core operation. It is essential in graphics programming, solving systems of equations, and training machine learning models. Understanding and implementing this correctly and efficiently is crucial due to its wide range of applications. Problem Write a function `matrix_multiply` that takes two matrices represented as lists of lists and returns their product. If the matrices are not compatible for multiplication, your function should raise a `ValueError` with an appropriate error message. # Function Signature ```python def matrix_multiply(multiplicand: list, multiplier: list) -> list: :param multiplicand: List[List[int]] - The first matrix to be multiplied :param multiplier: List[List[int]] - The second matrix to be multiplied :return: List[List[int]] - The resulting product matrix pass ``` # Input Format - `multiplicand`: A list of lists where each sub-list represents a row of the first matrix. - `multiplier`: A list of lists where each sub-list represents a row of the second matrix. # Output Format - Return a list of lists representing the product matrix. # Constraints - The number of columns in `multiplicand` must be equal to the number of rows in `multiplier`. - Elements of the matrices should be integers. # Example ```python multiplicand = [ [1, 2, 3], [4, 5, 6] ] multiplier = [ [7, 8], [9, 10], [11, 12] ] assert matrix_multiply(multiplicand, multiplier) == [ [58, 64], [139, 154] ] ``` # Edge Cases to Consider - Matrices with incompatible dimensions should raise a `ValueError`. - Matrices with one or more empty rows or columns. - Very large matrices to test computational efficiency. # Performance Requirements Implement the solution with a time complexity of O(n^3) and space complexity of O(n^2), ensuring basic correctness over optimization.","solution":"def matrix_multiply(multiplicand, multiplier): Multiplies two matrices. :param multiplicand: List[List[int]] - The first matrix to be multiplied :param multiplier: List[List[int]] - The second matrix to be multiplied :return: List[List[int]] - The resulting product matrix # Get matrix dimensions num_rows_multiplicand = len(multiplicand) num_cols_multiplicand = len(multiplicand[0]) num_rows_multiplier = len(multiplier) num_cols_multiplier = len(multiplier[0]) # Verify matrices can be multiplied if num_cols_multiplicand != num_rows_multiplier: raise ValueError(\\"Incompatible dimensions for matrix multiplication\\") # Initialize result matrix with zeros result = [[0 for _ in range(num_cols_multiplier)] for _ in range(num_rows_multiplicand)] # Perform matrix multiplication for i in range(num_rows_multiplicand): for j in range(num_cols_multiplier): for k in range(num_cols_multiplicand): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"# Longest Common Subsequence Finder You are tasked with implementing a function that finds the length of the longest common subsequence (not necessarily contiguous) between two strings, `s1` and `s2`. The string `s2` contains all distinct characters. # Function Signature ```python def longest_common_subsequence(s1: str, s2: str) -> int: \'\'\' This function takes two strings s1 and s2 and returns the length of the longest common subsequence. \'\'\' ``` # Input - `s1`: A string (1 <= |s1| <= 10^5) - `s2`: A string containing all distinct characters (1 <= |s2| <= 10^5) # Output - Returns an integer indicating the length of the longest common subsequence. # Constraints - Assume `s2` contains all unique characters. - The function should run in O(n log n) time complexity. # Example ```python print(longest_common_subsequence(\\"abcde\\", \\"ace\\")) # Output: 3 (Common subsequence: \\"ace\\") print(longest_common_subsequence(\\"abc\\", \\"def\\")) # Output: 0 (No common subsequence) ``` Your task is to implement this function.","solution":"def longest_common_subsequence(s1: str, s2: str) -> int: Finds the length of the longest common subsequence (not necessarily contiguous) between two strings, s1 and s2, where s2 contains all distinct characters. # Create a dictionary to store the positions of characters in s2 position = {char: index for index, char in enumerate(s2)} # Transform s1 based on the positions from s2 seq_indices = [position[char] for char in s1 if char in position] # Helper function to find the length of the longest increasing subsequence def length_of_lis(seq): if not seq: return 0 import bisect lis = [] for num in seq: pos = bisect.bisect_left(lis, num) if pos == len(lis): lis.append(num) else: lis[pos] = num return len(lis) return length_of_lis(seq_indices)"},{"question":"**Problem Statement:** Given an array of positive integers `nums` and a positive integer `target`, you are to implement two functions to find the number of different combinations that add up to the `target`. Each number in `nums` can be used multiple times in the combinations. **Functions to Implement:** 1. `def combination_sum_topdown(nums: List[int], target: int) -> int` - **Input**: - `nums`: List of positive integers with no duplicates. - `target`: Positive integer. - **Output**: Integer representing the number of possible combinations that add up to `target`. 2. `def combination_sum_bottom_up(nums: List[int], target: int) -> int` - **Input**: - `nums`: List of positive integers with no duplicates. - `target`: Positive integer. - **Output**: Integer representing the number of possible combinations that add up to `target`. **Example:** ```python nums = [1, 2, 3] target = 4 print(combination_sum_topdown(nums, target)) # Output: 7 print(combination_sum_bottom_up(nums, target)) # Output: 7 ``` **Explanation:** The possible combinations that add up to `4` are: - (1, 1, 1, 1) - (1, 1, 2) - (1, 2, 1) - (1, 3) - (2, 1, 1) - (2, 2) - (3, 1) Note: Different sequences are counted as different combinations. **Constraint:** - Arrays contain only positive integers and no duplicates. - Follow-up: How would the problem change if negative numbers are allowed in the array `nums`? What new limitations should be introduced in such cases? Your task is to implement these functions and ensure they handle edge cases effectively.","solution":"from typing import List def combination_sum_topdown(nums: List[int], target: int) -> int: def dfs(remain: int) -> int: if remain == 0: return 1 if remain < 0: return 0 if remain in memo: return memo[remain] count = 0 for num in nums: count += dfs(remain - num) memo[remain] = count return count memo = {} return dfs(target) def combination_sum_bottom_up(nums: List[int], target: int) -> int: dp = [0] * (target + 1) dp[0] = 1 for i in range(1, target + 1): for num in nums: if i - num >= 0: dp[i] += dp[i - num] return dp[target]"},{"question":"You have been tasked with modifying the existing implementation of a linear search to handle multiple target queries more efficiently. You will provide a function that takes an array and a list of queries, returning a list of indices for each query. If a query is not found, return -1 for that query. # Function Signature ```python def batch_linear_search(array: list, queries: list) -> list: pass ``` # Input * `array`: A list of integers (could be unsorted). * `queries`: A list of integers containing the elements to search for within the `array`. # Output * A list of integers where each integer represents the index of the corresponding query element in `queries` within the `array`. If an element in `queries` is not present in `array`, the corresponding index should be -1. # Constraints * The length of the array is `1 <= len(array) <= 10^6`. * The length of the queries list is `1 <= len(queries) <= 10^5`. * Elements of the array and queries are integers. # Example ```python array = [1, 4, 2, 8, 5, 7] queries = [4, 7, 10] batch_linear_search(array, queries) # Output: [1, 5, -1] ``` # Performance Requirement The function must perform efficiently since the arrays and query lists can be large. # Additional Information * Consider optimal approaches for repeated searches. * Think about space complexity when managing multiple queries.","solution":"def batch_linear_search(array: list, queries: list) -> list: Performs a batch linear search on the given array for each element in the queries list. Returns a list of indices for each query, or -1 if the query element is not found. :param array: List of integers to search through. :param queries: List of integers to search for. :return: List of indices corresponding to the queries. # Prepare a map for quick lookup of first occurrence of each element in array index_map = {} for index, value in enumerate(array): if value not in index_map: index_map[value] = index # Generate the output list containing the appropriate index or -1 result = [] for query in queries: result.append(index_map.get(query, -1)) return result"},{"question":"# Segment Tree Range Query As an experienced software engineer specializing in data structures, you are tasked with implementing a Segment Tree to efficiently handle range queries on an array. Problem Statement You need to write a class `SegmentTree` that supports: 1. Construction of the Segment Tree for a given array and an associative function. 2. Efficient range queries using the provided function. Function Signature ```python class SegmentTree: def __init__(self, arr: List[int], function: Callable[[int, int], int]): pass def query(self, L: int, R: int) -> int: pass ``` Input * `arr`: List of integers from which the Segment Tree is built. * `function`: A function that takes two integer inputs and returns an integer. Output * The `query` method takes two integers, `L` and `R` (0-based inclusive range), and returns the result of applying the function to the range `[L, R]`. Constraints * The function provided will be associative, which means `function(a, function(b, c)) == function(function(a, b), c)` for any integers `a`, `b`, `c`. * 1 ≤ len(arr) ≤ 10^5 * 0 ≤ arr[i] ≤ 10^9 * 0 ≤ L ≤ R < len(arr) # Example 1. **Example with max function**: ```python arr = [2,4,5,3,4] my_tree = SegmentTree(arr, max) print(mytree.query(2,4)) # Output: 5 print(mytree.query(0,3)) # Output: 5 ``` 2. **Example with sum function**: ```python arr = [4,5,2,3,4,43,3] mytree = SegmentTree(arr, sum) print(mytree.query(1,4)) # Output: 14 ``` Edge Cases to consider 1. Queries where L > R should return 0 or a neutral value. 2. Queries covering the entire array. 3. Single element queries. 4. Empty array input should handle gracefully (possibly returning a neutral value). Your `SegmentTree` should be optimized for both time and space efficiency.","solution":"from typing import List, Callable class SegmentTree: def __init__(self, arr: List[int], function: Callable[[int, int], int]): self.n = len(arr) self.function = function self.tree = [0] * (2 * self.n) self.build(arr) def build(self, arr: List[int]): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the rest of the tree for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[i * 2], self.tree[i * 2 + 1]) def query(self, L: int, R: int) -> int: L += self.n # Shift index to leaf R += self.n # Shift index to leaf res = None while L <= R: if L % 2 == 1: if res is None: res = self.tree[L] else: res = self.function(res, self.tree[L]) L += 1 if R % 2 == 0: if res is None: res = self.tree[R] else: res = self.function(res, self.tree[R]) R -= 1 L //= 2 R //= 2 return res"},{"question":"# B-Tree Coding Challenge **Objective**: Implement a function to efficiently insert a list of keys into a B-tree and then delete a specified set of keys without violating the B-tree properties. **Context**: Your task is to enhance the provided implementation of a B-tree to handle batch insertions and deletions efficiently. This assessment will test your understanding of balancing the tree during complex modifications. # Task 1. Implement a method `insert_keys_batch` that accepts a list of keys to be inserted into the B-Tree. 2. Implement a method `delete_keys_batch` that accepts a list of keys to be deleted from the B-Tree. # Implementation You are required to: * Extend the provided `BTree` class with two methods: * `insert_keys_batch(keys: List[int]) -> None` * `delete_keys_batch(keys: List[int]) -> None` **Input and Output Formats** * `insert_keys_batch(keys: List[int]) -> None`: * Accepts a list of integers `keys` and inserts them into the B-tree. * `delete_keys_batch(keys: List[int]) -> None`: * Accepts a list of integers `keys` and deletes them from the B-tree. **Constraints** * The input `keys` for both insertions and deletions will be a list of integers. * Ensure the B-tree remains balanced after batch operations. * Handle duplicate keys gracefully: * For insertion: ignore the duplicate if it already exists. * For deletion: ignore the key if it does not exist. **Performance Requirements** * The methods should aim to maintain an efficient performance of the B-tree during batch operations, retaining the log-time complexity characteristics. # Example Execution ```python # Initialize B-Tree btree = BTree(t_val=3) # Batch Insertions keys_to_insert = [10, 20, 5, 6, 12, 30, 7, 17] btree.insert_keys_batch(keys_to_insert) # Traverse to see the current structure btree.traverse_tree() # Output could be (depending on tree balancing): # [5, 6] 7 [10, 12] 17 [20, 30] # Batch Deletions keys_to_delete = [6, 17, 10] btree.delete_keys_batch(keys_to_delete) # Traverse to see the updated structure btree.traverse_tree() # Output could be: # [5, 7] [12, 20, 30] ```","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t self.leaf = leaf self.keys = [] self.children = [] def traverse(self): # There are n keys and n+1 children for i in range(len(self.keys)): if not self.leaf: self.children[i].traverse() print(self.keys[i], end=\\" \\") if not self.leaf: self.children[len(self.keys)].traverse() def search(self, k): i = 0 while i < len(self.keys) and k > self.keys[i]: i += 1 if i < len(self.keys) and self.keys[i] == k: return self if self.leaf: return None return self.children[i].search(k) def insert_non_full(self, k): i = len(self.keys) - 1 if self.leaf: while i >= 0 and k < self.keys[i]: i -= 1 self.keys.insert(i + 1, k) else: while i >= 0 and k < self.keys[i]: i -= 1 if len(self.children[i + 1].keys) == 2 * self.t - 1: self.split_child(i + 1, self.children[i + 1]) if k > self.keys[i + 1]: i += 1 self.children[i + 1].insert_non_full(k) def split_child(self, i, y): z = BTreeNode(y.t, y.leaf) self.children.insert(i + 1, z) self.keys.insert(i, y.keys[self.t - 1]) z.keys = y.keys[self.t: (2 * y.t) - 1] y.keys = y.keys[0: self.t - 1] if not y.leaf: z.children = y.children[self.t: (2 * y.t)] y.children = y.children[0: self.t] def delete(self, k): i = 0 while i < len(self.keys) and self.keys[i] < k: i += 1 if i < len(self.keys) and self.keys[i] == k: if self.leaf: self.keys.pop(i) else: if len(self.children[i].keys) >= self.t: predecessor = self.get_predecessor(i) self.keys[i] = predecessor self.children[i].delete(predecessor) elif len(self.children[i + 1].keys) >= self.t: successor = self.get_successor(i) self.keys[i] = successor self.children[i + 1].delete(successor) else: self.merge(i) self.children[i].delete(k) else: if self.leaf: return # Key not found flag = (i == len(self.keys)) if len(self.children[i].keys) < self.t: self.fill(i) if flag and i > len(self.keys): self.children[i - 1].delete(k) else: self.children[i].delete(k) def get_predecessor(self, i): cur = self.children[i] while not cur.leaf: cur = cur.children[-1] return cur.keys[-1] def get_successor(self, i): cur = self.children[i + 1] while not cur.leaf: cur = cur.children[0] return cur.keys[0] def merge(self, i): child = self.children[i] sibling = self.children[i + 1] child.keys.append(self.keys[i]) for j in range(self.t - 1): child.keys.append(sibling.keys[j]) if not child.leaf: for j in range(self.t): child.children.append(sibling.children[j]) self.keys.pop(i) self.children.pop(i + 1) def fill(self, i): if i != 0 and len(self.children[i - 1].keys) >= self.t: self.borrow_from_prev(i) elif i != len(self.keys) and len(self.children[i + 1].keys) >= self.t: self.borrow_from_next(i) else: if i != len(self.keys): self.merge(i) else: self.merge(i - 1) def borrow_from_prev(self, i): child = self.children[i] sibling = self.children[i - 1] for j in range(len(child.keys) - 1, -1, -1): child.keys[j + 1] = child.keys[j] if not child.leaf: for j in range(len(child.children) - 1, -1, -1): child.children[j + 1] = child.children[j] child.keys[0] = self.keys[i - 1] if not child.leaf: child.children[0] = sibling.children.pop() self.keys[i - 1] = sibling.keys.pop() def borrow_from_next(self, i): child = self.children[i] sibling = self.children[i + 1] child.keys.append(self.keys[i]) if not child.leaf: child.children.append(sibling.children.pop(0)) self.keys[i] = sibling.keys.pop(0) class BTree: def __init__(self, t): self.root = None self.t = t def traverse_tree(self): if self.root: self.root.traverse() def search_tree(self, k): return None if not self.root else self.root.search(k) def insert_tree(self, k): if not self.root: self.root = BTreeNode(self.t, True) self.root.keys.append(k) else: if len(self.root.keys) == 2 * self.t - 1: s = BTreeNode(self.t) s.children.append(self.root) s.split_child(0, self.root) i = 0 if s.keys[0] < k: i += 1 s.children[i].insert_non_full(k) self.root = s else: self.root.insert_non_full(k) def delete_tree(self, k): if not self.root: return self.root.delete(k) if len(self.root.keys) == 0: tmp = self.root if self.root.leaf: self.root = None else: self.root = self.root.children[0] def insert_keys_batch(self, keys): for key in keys: self.insert_tree(key) def delete_keys_batch(self, keys): for key in keys: self.delete_tree(key)"},{"question":"# Task: Perform Efficient Selection Sort Description You are required to enhance the given Selection Sort implementation to handle a new requirement: finding the smallest number but minimizing the number of swaps and comparisons wherever possible. Objective Write a function `efficient_selection_sort(arr: List[int]) -> List[int]` to sort an array of integers in ascending order with optimized swaps and comparisons. Specifically, if an element is already in its correct position, avoid swapping it. Input - A list `arr` of integers. Output - The sorted list `arr`. Constraints - 1 ≤ len(arr) ≤ 10^3 - -10^3 ≤ arr[i] ≤ 10^3 for any i Example ```python # Example 1 input: [64, 25, 12, 22, 11] output: [11, 12, 22, 25, 64] # Example 2 input: [5, 3, 1, 4, 2] output: [1, 2, 3, 4, 5] ``` Requirements - Minimize the number of swaps. - Optimize the number of comparisons. - Address edge cases such as already sorted lists, one element lists, and lists with duplicate elements effectively.","solution":"def efficient_selection_sort(arr): Perform an efficient selection sort on the list `arr` such that the number of swaps and comparisons are minimized when possible. n = len(arr) for i in range(n): min_index = i for j in range(i+1, n): if arr[j] < arr[min_index]: min_index = j if min_index != i: arr[i], arr[min_index] = arr[min_index], arr[i] return arr"},{"question":"# Scenario Alison is a software engineer who frequently needs to operate on binary search trees (BSTs) in her computations. She often requires the nodes of the BSTs to be accessed in increasing numerical order efficiently. To streamline her operations, she designs a specialized iterator that will allow her to traverse any BST in ascending order iteratively, without using extra space for recursion. # Task Your task is to implement Alison\'s BST iterator. You need to write a class `BSTIterator` with the following methods: 1. **`__init__(self, root)`**: Initializes an iterator object with the root of a BST. The initialization process should prepare the iterator for the next method calls. 2. **`has_next(self)`**: Returns `True` if there is at least one more node in the BST to be iterated over, `False` otherwise. 3. **`next(self)`**: Returns the value of the next node in the BST in increasing order. This method should be called only if `has_next()` returns `True`. # Function Signature ```python class BSTIterator: def __init__(self, root): pass def has_next(self): pass def next(self): pass ``` # Input and Output * **Input**: The input will be provided as the root of a binary search tree. You do not need to construct the tree; assume it is given. * **Output**: The output should be handled within the `next()` function which will return the values of the BST nodes sequentially. # Constraints * The number of nodes in the BST will be in the range [0, 10000]. * Node values will be within the range [-100000, 100000]. * Your implementation should not use more than O(h) space, where h is the height of the BST. # Example ```python # Example Tree: # 7 # / # 3 15 # / # 9 20 root = TreeNode(7, TreeNode(3), TreeNode(15, TreeNode(9), TreeNode(20))) iterator = BSTIterator(root) assert iterator.next() == 3 assert iterator.next() == 7 assert iterator.has_next() == True assert iterator.next() == 9 assert iterator.has_next() == True assert iterator.next() == 15 assert iterator.has_next() == True assert iterator.next() == 20 assert iterator.has_next() == False ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root): # Stack for the DFS traversal self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): # Add all the leftmost elements of the tree to the stack while root: self.stack.append(root) root = root.left def has_next(self): # If there are still elements in the stack, we have a next element return len(self.stack) > 0 def next(self): Returns the next smallest element in the BST # The next element is at the top of the stack topmost_node = self.stack.pop() # If the popped node has a right child, we add the leftmost child of the right subtree if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val"},{"question":"**Radix Sort Implementation and Enhancements** In this exercise, you are required to implement the Radix Sort algorithm, as well as handle some additional constraints to test your understanding of the algorithm. Task 1. Implement the `radix_sort` function to sort an input list of non-negative integers. 2. Enhance the function to handle any non-negative integers, not just small numbers. 3. Optimize the function to return the sorted list in the least amount of time. Function Signature ```python def radix_sort(arr: List[int], simulation: bool=False) -> List[int]: ``` Input * `arr` (List[int]): A list of non-negative integers to be sorted. (0 <= number <= 10^6) * `simulation` (bool): A flag to print the state of the list after each iteration of sorting (used for visualization, default is False). Output * Returns a sorted list of integers. Constraints * The length of `arr` will be between 0 and 10^5. * Maximum value in `arr` will be 10^6. Example ```python assert radix_sort([170, 45, 75, 90, 802, 24, 2, 66]) == [2, 24, 45, 66, 75, 90, 170, 802] assert radix_sort([5, 3, 8, 6, 2, 1]) == [1, 2, 3, 5, 6, 8] assert radix_sort([]) == [] ``` Requirements 1. Print the state of the list after every iteration if `simulation=True`. 2. Handle an edge case where the list might include zero elements. 3. Optimize for performance and handle possible memory bottlenecks. Notes * Focus on clean and efficient implementation. * Consider using Python\'s built-in features and libraries where appropriate. * Validate your function with additional test cases representing edge cases and typical scenarios.","solution":"from typing import List def counting_sort(arr, exp, simulation): n = len(arr) output = [0] * n count = [0] * 10 # Store count of occurrences in count[] for i in range(n): index = (arr[i] // exp) count[index % 10] += 1 # Change count[i] so that count[i] contains actual position of this digit in output[] for i in range(1, 10): count[i] += count[i - 1] # Build the output array i = n - 1 while i >= 0: index = (arr[i] // exp) output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 i -= 1 # Copy the output array to arr[], so that arr now contains sorted numbers according to current digit for i in range(n): arr[i] = output[i] if simulation: print(arr) def radix_sort(arr: List[int], simulation: bool=False) -> List[int]: if not arr: return [] # Find the maximum number to know the number of digits max_num = max(arr) # Do counting sort for every digit. Note that instead of passing digit number, # exp is passed. exp is 10^i where i is current digit number exp = 1 while max_num // exp > 0: counting_sort(arr, exp, simulation) exp *= 10 return arr"},{"question":"You are to implement a modified version of the RSA encryption algorithm that ensures better performance for key generation and encryption/decryption process. Specifically, you will use efficient algorithms for selecting prime numbers and calculating the modular multiplicative inverse. # Requirements * Implement an efficient prime-checking algorithm. * Optimize the modular inverse calculation. * Ensure the function can handle larger bit sizes (e.g., 1024 bits). # Function Signatures Implement the following functions: 1. `generate_key(k: int, seed: int = None) -> Tuple[int, int, int]` 2. `encrypt(data: int, e: int, n: int) -> int` 3. `decrypt(data: int, d: int, n: int) -> int` # Input/Output Format * **generate_key**: * Input: `k` (int): Number of bits in `n`, `seed` (optional int): Random seed for reproducibility. * Output: Tuple with three integers representing `(n, e, d)`. * **encrypt**: * Input: `data` (int): The plaintext data to encrypt, `e` (int): Public key exponent, `n` (int): Modulus. * Output: The encrypted data (int). * **decrypt**: * Input: `data` (int): The ciphertext data to decrypt, `d` (int): Private key exponent, `n` (int): Modulus. * Output: The decrypted data (int). # Constraints 1. Ensure `e` is chosen correctly (such as 65537, which is commonly used). 2. Handle edge cases with proper exceptions and validations. 3. Performance must be optimal for large values (`k >= 1024`). # Example Usage ```python # Key generation with 16-bit size (for testing purposes, use larger sizes in practice) n, e, d = generate_key(16, seed=42) # Encrypt and then decrypt data data = 1234 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data ```","solution":"from typing import Tuple import random import sympy def is_prime(num: int) -> bool: return sympy.isprime(num) def generate_large_prime(bits: int) -> int: while True: candidate = random.getrandbits(bits) if is_prime(candidate): return candidate def egcd(a: int, b: int) -> Tuple[int, int, int]: if a == 0: return b, 0, 1 gcd, x1, y1 = egcd(b % a, a) x = y1 - (b // a) * x1 y = x1 return gcd, x, y def modinv(a: int, m: int) -> int: gcd, x, _ = egcd(a, m) if gcd != 1: raise ValueError(\\"Modular inverse does not exist\\") return x % m def generate_key(k: int, seed: int = None) -> Tuple[int, int, int]: if seed is not None: random.seed(seed) e = 65537 p = generate_large_prime(k // 2) q = generate_large_prime(k // 2) n = p * q phi = (p - 1) * (q - 1) d = modinv(e, phi) return n, e, d def encrypt(data: int, e: int, n: int) -> int: return pow(data, e, n) def decrypt(data: int, d: int, n: int) -> int: return pow(data, d, n)"},{"question":"# Scenario Bogo Sort is known for its simplicity and serves as a fun example in theoretical computer science. However, due to its inefficiency, you\'ll rarely, if ever, use it in practical applications. Nevertheless, it provides good practice for understanding sorting algorithms and probabilistic processes. # Problem Statement Write a function to implement Bogo Sort, but with a constraint to limit the number of iterations. Specifically, if the array is not sorted within a certain number of shuffles, the function should return `None`. # Function Signature ```python def constrained_bogo_sort(arr, max_iterations): Sorts the array using Bogo Sort method. Parameters: arr (list[int]): The list of integers to sort. max_iterations (int): The maximum number of shuffles allowed. Returns: list[int] or None: The sorted list if sorted within max_iterations, else None. ``` # Inputs * `arr`: A list of integers to sort. * `max_iterations`: An integer representing the maximum number of shuffles allowed before giving up. # Outputs * The sorted list if it gets sorted within the given number of iterations; `None` otherwise. # Example ```python assert constrained_bogo_sort([3, 2, 1], 1000) == [1, 2, 3] or constrained_bogo_sort([3, 2, 1], 1000) == None assert constrained_bogo_sort([1, 2, 3], 1000) == [1, 2, 3] assert constrained_bogo_sort([], 10) == [] assert constrained_bogo_sort([1], 10) == [1] ``` # Constraints * The list may contain up to `10` elements (to avoid excessive execution time in testing).","solution":"import random def is_sorted(arr): Helper function to check if the array is sorted return all(arr[i] <= arr[i+1] for i in range(len(arr)-1)) def constrained_bogo_sort(arr, max_iterations): Sorts the array using Bogo Sort method. Parameters: arr (list[int]): The list of integers to sort. max_iterations (int): The maximum number of shuffles allowed. Returns: list[int] or None: The sorted list if sorted within max_iterations, else None. iterations = 0 while iterations < max_iterations: if is_sorted(arr): return arr random.shuffle(arr) iterations += 1 return None"},{"question":"# Coding Problem: Implement a Doubly Linked List with Basic Operations **Context**: Doubly Linked Lists are data structures that offer efficient insertion and deletion operations. They are often used in scenarios that require bidirectional traversal and more flexible insertions/deletions. # Task Implement a `DoublyLinkedList` class in Python with the following methods: 1. **insert_at_head(value)**: Inserts a new node with the given value at the head of the list. 2. **insert_at_tail(value)**: Inserts a new node with the given value at the tail of the list. 3. **delete_from_head()**: Deletes the node at the head of the list. 4. **delete_from_tail()**: Deletes the node at the tail of the list. 5. **search(value)**: Returns True if a node with the given value exists in the list, otherwise returns False. 6. **display()**: Returns a list of all values in the linked list from head to tail. 7. **display_reverse()**: Returns a list of all values in the linked list from tail to head. # Input/Output * **Input**: Operations and values to be performed on the doubly linked list. * **Output**: Results from the `display`, `display_reverse`, and `search` methods. # Constraints * Values in the linked list will be integers. * You may assume that delete operations will not be called on an empty list. # Example ```python dll = DoublyLinkedList() dll.insert_at_head(5) dll.insert_at_tail(10) dll.insert_at_head(3) print(dll.display()) # Output: [3, 5, 10] print(dll.display_reverse()) # Output: [10, 5, 3] print(dll.search(5)) # Output: True dll.delete_from_head() print(dll.display()) # Output: [5, 10] dll.delete_from_tail() print(dll.display()) # Output: [5] print(dll.search(10)) # Output: False ``` Write your implementation of the `DoublyLinkedList` class below:","solution":"class Node: def __init__(self, value): self.value = value self.prev = None self.next = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_at_head(self, value): new_node = Node(value) if self.head is None: self.head = self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def insert_at_tail(self, value): new_node = Node(value) if self.tail is None: self.head = self.tail = new_node else: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node def delete_from_head(self): if self.head is None: return if self.head == self.tail: # Single element in the list self.head = self.tail = None else: self.head = self.head.next self.head.prev = None def delete_from_tail(self): if self.tail is None: return if self.head == self.tail: # Single element in the list self.head = self.tail = None else: self.tail = self.tail.prev self.tail.next = None def search(self, value): current = self.head while current: if current.value == value: return True current = current.next return False def display(self): values = [] current = self.head while current: values.append(current.value) current = current.next return values def display_reverse(self): values = [] current = self.tail while current: values.append(current.value) current = current.prev return values"},{"question":"# Question: Implement and Analyze Radix Sort Your task is to implement the Radix Sort algorithm to sort a list of non-negative integers. You have been given an unsorted array of integers, and you are required to output a sorted array. # Requirements: 1. Implement the provided `radix_sort` function to sort a list of non-negative integers. 2. Analyze and handle common edge cases: a. Empty array b. Array with a single element c. Array with all identical elements 3. Ensure the algorithm is stable and non-comparative as per Radix Sort properties. 4. The function should not require more than O(n + k) additional space where `n` is the number of elements and `k` is the number of digits in the largest number. 5. You may include a simulation feature that prints the array\'s state after each iteration, but this should be optional and controlled by a parameter. # Input: * An unsorted list `arr` of non-negative integers (0 ≤ arr[i] ≤ 10^9). * An optional boolean `simulation` parameter to print the state of the list after each iteration (default set to `False`). # Output: * A sorted list of the integers from the input list. # Function Signature: ```python def radix_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` # Constraints: * The list may contain up to 10^6 elements. * Each element in the list is a non-negative integer (0 ≤ element ≤ 10^9). # Example: ```python # Example 1 input_list = [170, 45, 75, 90, 802, 24, 2, 66] output_list = radix_sort(input_list) print(output_list) # Output: [2, 24, 45, 66, 75, 90, 170, 802] # Example 2 input_list = [1, 2, 3, 4, 5] output_list = radix_sort(input_list, simulation=True) # Output with simulation enabled: # iteration 0 : 1 2 3 4 5 # iteration 1 : 1 2 3 4 5 # iteration 2 : 1 2 3 4 5 # (final sorted output) [1, 2, 3, 4, 5] ``` # Note: * Ensure your implementation handles large inputs efficiently. * Thoroughly test your function to guarantee correctness.","solution":"from typing import List def counting_sort(arr, exp, simulation): n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 for i in range(1, 10): count[i] += count[i - 1] for i in range(n - 1, -1, -1): index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 for i in range(n): arr[i] = output[i] if simulation: print(f\\"Iteration for exp={exp}: {arr}\\") def radix_sort(arr: List[int], simulation: bool = False) -> List[int]: if not arr: return [] max_val = max(arr) exp = 1 while max_val // exp > 0: counting_sort(arr, exp, simulation) exp *= 10 return arr"},{"question":"# Problem: Extended Integer Base Conversion You are required to extend the functionality of the provided base conversion functions to support any base from 2 to 62. This extends the list of digits to include lowercase letters. Implement two functions: 1. **`extended_int_to_base`**: - Convert an integer to a string representing that number in the given base. - **Input**: - `num` (integer): The number to convert. - `base` (integer): The base to convert the number into (2 to 62, inclusive). - **Output**: - `str`: The number represented in the specified base as a string. 2. **`extended_base_to_int`**: - Convert a base-represented string back to its integer form. - **Input**: - `str_to_convert` (string): The string representing the number in the given base. - `base` (integer): The base of the string’s number (2 to 62, inclusive). - **Output**: - `int`: The integer representation of the given base string. # Example ```python assert extended_int_to_base(125, 62) == \'21\' assert extended_base_to_int(\'21\', 62) == 125 ``` # Constraints 1. `num` is an integer that may be positive or negative. 2. `base` is an integer between 2 and 62, inclusive. 3. The input string `str_to_convert` will be valid and within the given base. # Performance Requirements - Ensure that the conversions handle large integers efficiently within the provided base limits. # Solution Template ```python import string def extended_int_to_base(num, base): # Your code goes here pass def extended_base_to_int(str_to_convert, base): # Your code goes here pass # Example Usage print(extended_int_to_base(125, 62)) # Expected \'21\' print(extended_base_to_int(\'21\', 62)) # Expected 125 ```","solution":"import string def extended_int_to_base(num, base): Convert an integer to a string representing that number in the given base (2-62). if base < 2 or base > 62: raise ValueError(\\"Base must be between 2 and 62, inclusive.\\") digits = string.digits + string.ascii_lowercase + string.ascii_uppercase if num == 0: return \'0\' neg = False if num < 0: num = -num neg = True result = \\"\\" while num > 0: result = digits[num % base] + result num //= base if neg: result = \\"-\\" + result return result def extended_base_to_int(str_to_convert, base): Convert a base-represented string back to its integer form (base 2-62). if base < 2 or base > 62: raise ValueError(\\"Base must be between 2 and 62, inclusive.\\") digits = string.digits + string.ascii_lowercase + string.ascii_uppercase num_dict = {ch: idx for idx, ch in enumerate(digits)} neg = False if str_to_convert[0] == \'-\': str_to_convert = str_to_convert[1:] neg = True num = 0 for char in str_to_convert: num = num * base + num_dict[char] return -num if neg else num"},{"question":"You are given two positive integers `a` and `b`. Your task is to implement a function `gcd_optimized(a, b)` that computes the greatest common divisor of `a` and `b` using the most optimized method combining both Euclid-based and bitwise approaches. Additionally, your function should handle various edge cases efficiently and return correct results even for large inputs. # Requirements 1. **Function Signature**: `def gcd_optimized(a: int, b: int) -> int:` 2. **Input**: - Two integers `a` and `b`, (1 <= a, b <= 10^9). 3. **Output**: - An integer representing the greatest common divisor of `a` and `b`. 4. **Constraints**: - Both `a` and `b` are positive. # Examples Example 1: **Input**: `a = 48`, `b = 18` **Output**: `6` **Explanation**: The GCD of 48 and 18 is 6. Example 2: **Input**: `a = 18`, `b = 30` **Output**: `6` **Explanation**: The GCD of 18 and 30 is 6. # Guidelines 1. You should handle the input validation internally in your function without assuming any pre-validation. 2. Use a combination of Euclidean algorithm and bitwise manipulations (whichever provides the best performance for the given input range). 3. Ensure your code is optimized both for time (O(log(min(a, b)))) and space (O(1)) complexities. 4. Consider edge cases when `a` is equal to `b` or when both numbers are prime.","solution":"def gcd_optimized(a: int, b: int) -> int: Returns the greatest common divisor of a and b using an optimized method combining Euclid\'s algorithm and bitwise operations. while b != 0: a, b = b, a % b return a"},{"question":"# Question You are tasked with creating a function that determines the total number of ways to decode a given encoded message using the following key: ``` \'A\' -> 1, \'B\' -> 2, ..., \'Z\' -> 26 ``` For example, the encoded message \\"12\\" could be decoded as \\"AB\\" (1 2) or \\"L\\" (12). The number of ways to decode \\"12\\" is 2. Implement the function `num_decodings(s)` that takes a string `s` comprised of digits and returns the total number of ways to decode it. To test comprehensively, ensure to handle the following constraints: 1. The input string may be empty. 2. The input string may contain digits that form invalid sequences such as \\"01\\" or \\"30\\". 3. The input string can be arbitrarily long. 4. The function should execute efficiently, i.e., in `O(n)` time with `O(1)` space complexity. Function Signature ```python def num_decodings(s: str) -> int: pass ``` # Input * A string `s` containing a sequence of digits (0-9). # Output * An integer representing the total number of ways to decode the input string. # Constraints * `0 <= len(s) <= 100` * `s` contains only digits (0-9). # Examples 1. `num_decodings(\\"12\\")` should return `2` (decodings are \\"AB\\", \\"L\\"). 2. `num_decodings(\\"226\\")` should return `3` (decodings are \\"BZ\\", \\"VF\\", \\"BBF\\"). 3. `num_decodings(\\"0\\")` should return `0` (no valid decodings). 4. `num_decodings(\\"10\\")` should return `1` (decodings are \\"J\\"). # Explanation & Edge Cases - The function should correctly identify and handle sequences starting with \'0\' as invalid. - Consecutive zeros or invalid pairs like \\"30\\" should be handled gracefully. - The function should perform optimally for large input strings.","solution":"def num_decodings(s: str) -> int: if not s or s[0] == \'0\': return 0 n = len(s) prev2 = 1 # dp[-1] prev1 = 1 # dp[0] for i in range(1, n): current = 0 if s[i] != \'0\': current = prev1 two_digit = int(s[i-1:i+1]) if 10 <= two_digit <= 26: current += prev2 prev2 = prev1 prev1 = current return prev1"},{"question":"# Problem Description You are required to implement additional functionalities to the provided Binary Search Tree (BST) class. Specifically, you need to implement a method to delete a node from the BST while ensuring that the tree properties are maintained. The depth of the tree should remain minimized as much as possible. # Function Signature ```python def delete(self, data: int) -> bool: ``` # Input - `data`: An integer value representing the node to be deleted from the BST. # Output - `True` if the node was successfully deleted. - `False` if the node was not found in the tree. # Constraints - The tree contains at most 10000 nodes. - All node values are unique. # Requirements 1. Implement the `delete` method in the provided BST class. 2. Ensure that all BST properties are maintained post-deletion. 3. Handle all edge cases such as deleting the root, handling nodes with one or no child, and nodes with two children. # Example Consider the BST constructed in the given code: ``` 10 / 6 15 / / 4 9 12 24 / / 7 20 30 / 18 ``` - Deleting node `15`: ``` 10 / 6 18 / / 4 9 12 24 / / 7 20 30 ``` - Deleting node `6`: ``` 10 / 4 18 / 12 24 / / 9 20 30 / 7 ``` # Constraints - The tree is non-empty and contains unique integer elements. - You should not use any external libraries for the BST implementation.","solution":"class TreeNode: def __init__(self, data): self.data = data self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, data): if self.root is None: self.root = TreeNode(data) else: self._insert(self.root, data) def _insert(self, node, data): if data < node.data: if node.left is None: node.left = TreeNode(data) else: self._insert(node.left, data) elif data > node.data: if node.right is None: node.right = TreeNode(data) else: self._insert(node.right, data) def delete(self, data): self.root, deleted = self._delete(self.root, data) return deleted def _delete(self, node, data): if node is None: return node, False if data < node.data: node.left, deleted = self._delete(node.left, data) elif data > node.data: node.right, deleted = self._delete(node.right, data) else: # Node to be deleted found deleted = True if node.left is None: return node.right, deleted elif node.right is None: return node.left, deleted min_larger_node = self._get_min(node.right) node.data = min_larger_node.data node.right, _ = self._delete(node.right, min_larger_node.data) return node, deleted def _get_min(self, node): while node.left is not None: node = node.left return node def inorder_traversal(self): return self._inorder_traversal(self.root, []) def _inorder_traversal(self, node, result): if node: self._inorder_traversal(node.left, result) result.append(node.data) self._inorder_traversal(node.right, result) return result"},{"question":"**Objective**: Write a function that calculates the next higher number than the given number, using the exact same set of digits. **Function Signature**: ```python def next_bigger(num: int) -> int: ``` # Problem Statement Given a positive integer, `num`, find the next higher number that uses the exact same set of digits in `num`. If no such number exists (i.e., the number is already the largest permutation of its digits), return `-1`. # Input - A single integer `num`, where `1 <= num <= 10^9`. # Output - An integer representing the next higher number using the same set of digits. # Constraints 1. Return `-1` if no higher permutation exists. 2. The number will not contain leading zeros. # Example ```python assert next_bigger(38276) == 38627 assert next_bigger(12345) == 12354 assert next_bigger(1528452) == 1528524 assert next_bigger(54321) == -1 assert next_bigger(999) == -1 assert next_bigger(5) == -1 ``` *Consider the given example `38276`*: - Finding the pivot: 7 (change required since 7 < 8). - Finding successor: 8 (smallest digit greater than 7 on the right). - Swapping: Leads to `38627`. - Reversing the suffix: Although already in descending order after the swap, it confirms `38627` is the next higher number. Implement the function. Write additional test cases to verify edge cases and validate your solution thoroughly.","solution":"def next_bigger(num: int) -> int: num_list = list(str(num)) n = len(num_list) # Start from the end of the number, find the first digit that is not in descending order for i in range(n-2, -1, -1): if num_list[i] < num_list[i + 1]: break else: # If no such digit is found, return -1 return -1 # Find the smallest digit on right side of (i-th digit) which is greater than num_list[i] for j in range(n-1, i, -1): if num_list[j] > num_list[i]: break # Swap digits at i and j num_list[i], num_list[j] = num_list[j], num_list[i] # Reverse the digits after i num_list = num_list[:i+1] + num_list[i+1:][::-1] return int(\'\'.join(num_list))"},{"question":"# Problem: Determine Strong Connectivity in a Directed Graph Context You are working on a system to analyze the robustness of network communications. A key aspect of this analysis involves checking if the network can support bidirectional communication between every pair of nodes. This problem translates into verifying whether the graph representation of the network is strongly connected. Task Write a function `is_network_strongly_connected(vertex_count, edges)` that takes: - An integer `vertex_count`, the number of vertices in the graph. - A list of tuples `edges` where each tuple (source, target) represents a directed edge from the source vertex to the target vertex. Your function should return `True` if the graph is strongly connected, and `False` otherwise. Input Format: - `vertex_count`: An integer (1 ≤ vertex_count ≤ 10^4). - `edges`: A list of tuples representing directed edges (0 ≤ len(edges) ≤ 2*10^4). Output Format: - A boolean indicating if the graph is strongly connected. Constraints: - Each node in the graph is represented by an integer ID ranging from 0 to vertex_count - 1. Example ```python # Example 1 vertex_count = 5 edges = [(0, 1), (1, 2), (2, 0), (0, 3), (3, 4), (4, 0)] print(is_network_strongly_connected(vertex_count, edges)) # Output should be True # Example 2 vertex_count = 4 edges = [(0, 1), (1, 2), (2, 3)] print(is_network_strongly_connected(vertex_count, edges)) # Output should be False ``` Requirements * The function should efficiently handle the given constraints. Hints: 1. Use Depth-First Search (DFS) to check reachability from a given node. 2. Reverse the graph and perform another DFS to ensure all nodes are mutually reachable.","solution":"def is_network_strongly_connected(vertex_count, edges): from collections import defaultdict, deque def dfs(graph, start): stack = [start] visited = [False] * vertex_count visited[start] = True while stack: node = stack.pop() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) return visited if vertex_count == 0: return True # Create adjacency list graph = defaultdict(list) reverse_graph = defaultdict(list) for src, dest in edges: graph[src].append(dest) reverse_graph[dest].append(src) # Perform DFS from vertex 0 visited = dfs(graph, 0) if not all(visited): return False # Perform DFS on the reversed graph reverse_visited = dfs(reverse_graph, 0) if not all(reverse_visited): return False return True"},{"question":"Strongly Connected Components in a Directed Graph You are given the task to implement a method that determines whether a directed graph is strongly connected. A graph is said to be **strongly connected** if every vertex is reachable from every other vertex. You will be provided with the number of vertices and a list of directed edges in the graph. # Function Signature ```python def is_strongly_connected(vertex_count: int, edges: List[Tuple[int, int]]) -> bool: pass ``` # Input * `vertex_count` (int): The number of vertices in the graph. * `edges` (List[Tuple[int, int]]): A list of directed edges where each edge is represented as a pair (source, target). # Output * Return `True` if the graph is strongly connected, otherwise `False`. # Constraints * `1 <= vertex_count <= 10^3` * `0 <= len(edges) <= (vertex_count * (vertex_count - 1))` # Example Example 1: ```python vertex_count = 4 edges = [(0, 1), (1, 2), (2, 3), (3, 0)] print(is_strongly_connected(vertex_count, edges)) # Output: True ``` Example 2: ```python vertex_count = 4 edges = [(0, 1), (1, 2), (2, 3)] print(is_strongly_connected(vertex_count, edges)) # Output: False ``` # Performance Requirements * The solution should have a time complexity of O(V + E). * The space complexity should also be kept within O(V). # Notes * Your implementation should correctly handle edge cases, including but not limited to graphs with a single node, no nodes, and disconnected graphs. * Ensure that DFS traversal handles large graphs efficiently. For this task, you are to design and implement the `is_strongly_connected` function based on the analysis and code principles provided.","solution":"from typing import List, Tuple def is_strongly_connected(vertex_count: int, edges: List[Tuple[int, int]]) -> bool: from collections import defaultdict, deque def dfs(graph, start): visited = set() stack = [start] while stack: node = stack.pop() if node not in visited: visited.add(node) stack.extend(graph[node]) return visited if vertex_count == 0: return True # Create adjacency list for the graph graph = defaultdict(list) for src, dst in edges: graph[src].append(dst) # Start DFS from the first vertex and check if all vertices are reachable visited_from_start = dfs(graph, 0) if len(visited_from_start) != vertex_count: return False # Create the transposed (reversed) graph transposed_graph = defaultdict(list) for src, dst in edges: transposed_graph[dst].append(src) # Start DFS on the transposed graph visited_from_start_reversed = dfs(transposed_graph, 0) if len(visited_from_start_reversed) != vertex_count: return False return True"},{"question":"# Question You are tasked with writing a function to reformulate a given string by removing all repeating characters such that only the first occurrences are kept, and the original order of the first occurrences is maintained. Expected Function Signature ```python def remove_duplicates(input_string: str) -> str: pass ``` Input - A single string `input_string` where `1 <= len(input_string) <= 10^5`. Output - A new string with all repeating characters removed, keeping only their first occurrences. Constraints - You must maintain the original order of characters as they first appeared. - It should be case-sensitive (e.g., \'A\' and \'a\' are considered different characters). - The performance should be optimized with a time complexity of O(n). Example ```python # Example 1 input_string = \\"google\\" output_string = \\"gole\\" # Explanation: After removing reoccurring characters, the resulting string is \\"gole\\". # Example 2 input_string = \\"abcabc\\" output_string = \\"abc\\" # Explanation: After removing reoccurring characters, the resulting string is \\"abc\\". # Example 3 input_string = \\"AaBbCc\\" output_string = \\"AaBbCc\\" # Explanation: All characters are unique when considered case-sensitive. ``` Scenario Imagine you are developing a preprocessing step for a text analysis pipeline, where the goal is to reduce data redundancy by removing duplicate characters from your text while preserving their first occurrences. This function will play a crucial role in your initial data cleaning process.","solution":"def remove_duplicates(input_string: str) -> str: Remove all duplicate characters from the input string, keeping only their first occurrences, and maintaining the original order of their first occurrences. seen = set() output_string = [] for char in input_string: if char not in seen: seen.add(char) output_string.append(char) return \'\'.join(output_string)"},{"question":"Tree Comparison Context: You are tasked to compare two binary trees, Tree P and Tree Q. These trees can either be empty or contain nodes with integer values. Your goal is to determine if Tree P and Tree Q are structurally identical and if all corresponding nodes have the same value. Task: Write a function `is_same_tree(tree_p, tree_q)` that takes two parameters, `tree_p` and `tree_q`. Each parameter represents the root node of a binary tree. The function should return `True` if the two trees are identical, and `False` otherwise. Input Format: * `tree_p`, `tree_q`: Roots of Binary Trees. Each node is represented as an object with the following attributes: * `val` (integer): the value of the node. * `left` (reference to the left child node or `None` if no left child exists). * `right` (reference to the right child node or `None` if no right child exists). Output Format: * Return a boolean value: * `True` if the trees are structurally identical and all nodes have the same values. * `False` otherwise. Constraints: * Tree node values are integers and can include negative values. * The number of nodes in each tree is in the range `[0, 10^4]`. Performance Requirements: * The solution should operate efficiently within the provided constraints. * Recursive or iterative solutions are both acceptable, but consider potential stack overflow with deep recursion. Example: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example 1: # Input: tree_p = [1,2,3], tree_q = [1,2,3] # 1 1 # / / # 2 3 2 3 # Output: True # Example 2: # Input: tree_p = [1,2], tree_q = [1,None,2] # 1 1 # / / # 2 None 2 # Output: False def is_same_tree(tree_p, tree_q): # Your implementation here ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_same_tree(tree_p, tree_q): if not tree_p and not tree_q: return True if not tree_p or not tree_q: return False if tree_p.val != tree_q.val: return False return is_same_tree(tree_p.left, tree_q.left) and is_same_tree(tree_p.right, tree_q.right)"},{"question":"You are required to implement a Binary Search Tree (BST) with the following key functionalities: insertion, search, size calculation, and traversal (preorder, inorder, postorder). The BST must handle integer values. # Function Specifications 1. **Insert** - Method: `def insert(self, data: int) -> bool` - Description: Inserts `data` into the BST. If `data` already exists, return `False`, otherwise return `True`. 2. **Search** - Method: `def search(self, data: int) -> bool` - Description: Returns `True` if `data` is found in the BST, otherwise returns `False`. 3. **Size** - Method: `def size(self) -> int` - Description: Returns the total number of nodes in the BST. 4. **Traversal** - Methods: `def preorder(self, root: Node) -> List[int]`, `def inorder(self, root: Node) -> List[int]`, `def postorder(self, root: Node) -> List[int]` - Description: Returns a list of values in preorder, inorder, and postorder sequence respectively. # Requirements 1. Use recursion for insertion, search, and traversal operations. 2. Ensure each operation respects the constraints of a BST. 3. Handle edge cases, such as: - Performing operations on an empty tree. - Duplicates during insertion. - Traversing a non-existent subtree. # Constraints - Nodes in the tree are unique and consist of integer values. - Test cases will not exceed 1000 insertions/search operations. # Example Suppose the following sequence of operations on a BST: ```python bst = BST() bst.insert(10) # True bst.insert(15) # True bst.insert(6) # True bst.insert(15) # False (duplicate) bst.search(6) # True bst.size() # 3 bst.insert(3) # True bst.insert(8) # True bst.inorder(bst.get_root()) # [3, 6, 8, 10, 15] bst.preorder(bst.get_root()) # [10, 6, 3, 8, 15] bst.postorder(bst.get_root()) # [3, 8, 6, 15, 10] ``` Write the necessary methods to demonstrate the use of the BST and validate its functionalities through given unit tests.","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None class BST: def __init__(self): self.root = None self.node_count = 0 def insert(self, data: int) -> bool: if self.root is None: self.root = Node(data) self.node_count += 1 return True else: return self._insert(self.root, data) def _insert(self, node: Node, data: int) -> bool: if data == node.data: return False elif data < node.data: if node.left is None: node.left = Node(data) self.node_count += 1 return True else: return self._insert(node.left, data) else: if node.right is None: node.right = Node(data) self.node_count += 1 return True else: return self._insert(node.right, data) def search(self, data: int) -> bool: return self._search(self.root, data) def _search(self, node: Node, data: int) -> bool: if node is None: return False if data == node.data: return True elif data < node.data: return self._search(node.left, data) else: return self._search(node.right, data) def size(self) -> int: return self.node_count def preorder(self, root: Node) -> list[int]: if root is None: return [] return [root.data] + self.preorder(root.left) + self.preorder(root.right) def inorder(self, root: Node) -> list[int]: if root is None: return [] return self.inorder(root.left) + [root.data] + self.inorder(root.right) def postorder(self, root: Node) -> list[int]: if root is None: return [] return self.postorder(root.left) + self.postorder(root.right) + [root.data] def get_root(self) -> Node: return self.root"},{"question":"You are given a singly linked list. Write a function `detect_cycle(head)` to determine if the linked list has a cycle in it. If there is a cycle, return `True`; otherwise, return `False`. # Input * `head`: The head node of the linked list, where each node is an object with the attributes `val` (the node\'s value) and `next` (a pointer to the next node). # Output * Return `True` if there is a cycle in the linked list; otherwise, return `False`. # Constraints * Do not use extra space (i.e., space complexity should be O(1)). * The number of nodes in the linked list is in the range [0, 10^4]. # Example ```plaintext Input: 1 -> 2 -> 3 -> 4 -> 5 -> 2 (cycle) Output: True Input: 1 -> 2 -> 3 -> 4 -> 5 -> None Output: False ``` # Explanation In the first example, there is a cycle linking the node with value 5 back to the node with value 2. In the second example, the list terminates without any cycles. # Function Signature ```python def detect_cycle(head: Node) -> bool: # your code here ```","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def detect_cycle(head: ListNode) -> bool: Detects if a singly linked list has a cycle in it. :param head: The head node of the linked list :return: True if there is a cycle, False otherwise if not head or not head.next: return False slow = head fast = head.next while slow != fast: if not fast or not fast.next: return False slow = slow.next fast = fast.next.next return True"},{"question":"# Matrix Transformation and Analysis As part of your understanding of matrix manipulation, you are given several matrix transformation functions. These functions perform various transformations such as rotating the matrix clockwise, counterclockwise, and inverting diagonally. Your goal is to understand these transformations and apply the correct one based on the provided transformation type. # Task: Implement the function `matrix_transform(matrix, transformation)` that performs the specified transformation on the given matrix. Your function should take two arguments: - `matrix`: A list of lists representing the numerical matrix to be transformed. - `transformation`: A string specifying the type of transformation. It can be one of the following: - `\\"rotate_clockwise\\"` - `\\"rotate_counterclockwise\\"` - `\\"top_left_invert\\"` - `\\"bottom_left_invert\\"` # Requirements: 1. Implement the appropriate transformation function based on the given transformation type. 2. Ensure the function works correctly even for non-square matrices. 3. Handle edge cases such as empty matrices appropriately. # Function Signature: ```python def matrix_transform(matrix: List[List[int]], transformation: str) -> List[List[int]]: pass ``` # Input: - `matrix`: List of Lists of integers. - `transformation`: A string indicator of the type of transformation. # Output: - A new list of lists representing the transformed matrix. # Constraints: - Assume matrix contains integers only and each sub-list will have the same length. # Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] transformation = \\"rotate_clockwise\\" expected_output = [ [7, 4, 1], [8, 5, 2], [9, 3, 0] ] matrix_transform(matrix, transformation) == expected_output ``` # Performance Requirements: - The solution should have a time complexity of O(n^2) and space complexity of O(n^2). - Consider using list comprehensions or other Python features efficiently to handle matrix manipulations. Write your function below: ```python # Here is where you would implement matrix_transform ```","solution":"from typing import List def matrix_transform(matrix: List[List[int]], transformation: str) -> List[List[int]]: if not matrix or not matrix[0]: return [] def rotate_clockwise(m): return [[m[j][i] for j in range(len(m)-1, -1, -1)] for i in range(len(m[0]))] def rotate_counterclockwise(m): return [[m[j][i] for j in range(len(m))] for i in range(len(m[0])-1, -1, -1)] def top_left_invert(m): return [[m[j][i] for j in range(len(m))] for i in range(len(m[0]))] def bottom_left_invert(m): return [[m[j][i] for j in range(len(m)-1, -1, -1)] for i in range(len(m[0])-1, -1, -1)] transformations = { \\"rotate_clockwise\\": rotate_clockwise, \\"rotate_counterclockwise\\": rotate_counterclockwise, \\"top_left_invert\\": top_left_invert, \\"bottom_left_invert\\": bottom_left_invert } return transformations[transformation](matrix)"},{"question":"# Union-Find: Number of Connected Components Background The Union-Find data structure is extensively used in managing and merging disjoint sets. In this problem, you\'ll implement the core operations of a Union-Find to count the number of connected components in a graph as edges are added. Problem Description You are given `n` nodes labeled from `0` to `n-1` and a list of edges where each edge is a pair of nodes `[u, v]`. Your task is to implement the Union-Find data structure to find the number of connected components after each edge addition. Function Signature ```python def count_components(n: int, edges: List[Tuple[int, int]]) -> List[int]: pass ``` Input * `n` (int): The number of nodes, labeled from `0` to `n-1`. * `edges` (List[Tuple[int, int]]): A list of tuples, where each tuple represents an edge between two nodes `u` and `v`. Output * Returns a list of integers, where the i-th integer represents the number of connected components after processing the first `i+1` edges. Constraints * `1 <= n <= 1000` * `0 <= len(edges) <= 1000` * `0 <= u, v < n` * `u != v` Example ```python n = 5 edges = [(0, 1), (1, 2), (3, 4), (2, 3)] expected_output = [4, 3, 2, 1] output = count_components(n, edges) # Coordinate the edge processing order: # After (0, 1) -> 4 sets [0,1], [2], [3], [4] # After (1, 2) -> 3 sets [0,1,2], [3], [4] # After (3, 4) -> 2 sets [0,1,2], [3,4] # After (2, 3) -> 1 set [0,1,2,3,4] ``` Notes * Implement the Union-Find data structure with efficient path compression and union by size/rank. * Pay special attention to handling already connected nodes to avoid unnecessary union operations. * Ensure your solution can handle the upper bound constraints effectively.","solution":"from typing import List, Tuple class UnionFind: def __init__(self, size: int): self.parent = list(range(size)) self.rank = [1] * size self.component_count = size def find(self, node: int) -> int: if self.parent[node] != node: self.parent[node] = self.find(self.parent[node]) # path compression return self.parent[node] def union(self, node1: int, node2: int) -> bool: root1 = self.find(node1) root2 = self.find(node2) if root1 != root2: if self.rank[root1] > self.rank[root2]: self.parent[root2] = root1 elif self.rank[root1] < self.rank[root2]: self.parent[root1] = root2 else: self.parent[root2] = root1 self.rank[root1] += 1 self.component_count -= 1 return True return False def count_components(n: int, edges: List[Tuple[int, int]]) -> List[int]: uf = UnionFind(n) results = [] for u, v in edges: uf.union(u, v) results.append(uf.component_count) return results"},{"question":"Minimum in Rotated Sorted Array Scenario A tech company has a series of server logs that are kept in arrays. These arrays are sorted in ascending order but, due to an error in the logging system, they are sometimes rotated. The rotation doesn\'t scramble the numbers, it simply shifts them. Now, to ensure system integrity, you need to find the smallest log entry in a rotated sorted array. Problem Statement Write a function `find_minimum_in_rotated_array` that takes a rotated sorted array of unique integers and returns the smallest integer in this array. Your solution must run in O(log N) time complexity. Function Signature ```python def find_minimum_in_rotated_array(nums: List[int]) -> int: ``` Input: * `nums`: A list of integers sorted in ascending order, then rotated. No duplicates exist in the array. The length of the array is at minimum 1, and at most 10^4. Output: Return a single integer, which is the minimum element in the array. Constraints: 1. The array should have at least 1 element and at most 10,000 elements. 2. The array is rotated at some pivot. 3. There are no duplicate elements in the array. Example: ```python assert find_minimum_in_rotated_array([4, 5, 6, 7, 0, 1, 2]) == 0 assert find_minimum_in_rotated_array([1]) == 1 assert find_minimum_in_rotated_array([2, 3, 4, 5, 6, 7, 1]) == 1 ```","solution":"def find_minimum_in_rotated_array(nums): Finds the minimum in a rotated sorted array using binary search. :param nums: List[int], a list of unique integers sorted in ascending order and then rotated :return: int, the minimum integer in the array left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[right]: left = mid + 1 else: right = mid return nums[left]"},{"question":"# Hamming Weight Calculation **Context**: You\'re working on a low-level system where efficiently determining the number of active bits in binary numbers is crucial for performance. Your task is to implement a function to calculate the Hamming weight of an unsigned integer using the given algorithm. **Function Specification**: Write a function `count_hamming_weight` that counts the number of \'1\' bits in the binary representation of an unsigned integer. **Input**: - An unsigned integer `n` (0 <= n <= 2^32 - 1). **Output**: - An integer representing the count of \'1\' bits in the binary representation of `n`. **Constraints**: - The function should have a time complexity of O(k), where k is the number of \'1\' bits. - Use constant space. **Performance Requirements**: - The function should operate efficiently even for the largest possible input values within the given constraints. **Examples**: 1. Input: 11 (binary: 00000000000000000000000000001011) - Output: 3 2. Input: 128 (binary: 00000000000000000000000010000000) - Output: 1 3. Input: 4294967295 (binary: 11111111111111111111111111111111) - Output: 32 # Implementation: You are required to: 1. Implement the function `count_hamming_weight` using Brian Kernighan’s algorithm. 2. Handle both edge cases and provided examples to ensure completeness.","solution":"def count_hamming_weight(n): Counts the number of \'1\' bits in the binary representation of an unsigned integer. :param n: an unsigned integer (0 <= n <= 2^32 - 1) :return: the number of \'1\' bits in the binary representation of `n` count = 0 while n: n &= n - 1 count += 1 return count"},{"question":"# Matrix Transformations Challenge In this problem, you are required to implement matrix transformation functions that demonstrate various operations on a 2D matrix. Objectives You need to write functions to perform the following operations on a given 2D matrix: 1. **Rotate the matrix clockwise by 90 degrees**. 2. **Rotate the matrix counterclockwise by 90 degrees**. 3. **Invert the matrix along its top-left to bottom-right diagonal**. 4. **Invert the matrix along its bottom-left to top-right diagonal**. Expected Input and Output * **Input**: A 2D list `matrix` with `n` rows and `m` columns where each element is an integer. * **Output**: A new 2D list representing the transformed matrix. Constraints 1. The input matrix can have differing row and column sizes. 2. The functions should handle edge cases such as empty input matrices. 3. The returned new matrix should not affect the original input matrix. Function Signatures Implement the required functions with the following signatures: ```python def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: # Your implementation here def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: # Your implementation here def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: # Your implementation here def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: # Your implementation here ``` Example Given a matrix: ``` [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` * **rotate_clockwise(matrix)** should return: ``` [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` * **rotate_counterclockwise(matrix)** should return: ``` [ [3, 6, 9], [2, 5, 8], [1, 4, 7] ] ``` * **top_left_invert(matrix)** should return: ``` [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] ``` * **bottom_left_invert(matrix)** should return: ``` [ [9, 6, 3], [8, 5, 2], [7, 4, 1] ] ```","solution":"from typing import List def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotate the given matrix by 90 degrees clockwise. return [list(row) for row in zip(*matrix[::-1])] def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: Rotate the given matrix by 90 degrees counter-clockwise. return [list(row) for row in zip(*matrix)][::-1] def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: Invert the given matrix along its top-left to bottom-right diagonal. n = len(matrix) m = len(matrix[0]) if n > 0 else 0 return [[matrix[j][i] for j in range(n)] for i in range(m)] def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: Invert the given matrix along its bottom-left to top-right diagonal. n = len(matrix) m = len(matrix[0]) if n > 0 else 0 return [[matrix[n - 1 - j][m - 1 - i] for j in range(n)] for i in range(m)]"},{"question":"You are tasked with improving the given nearest neighbor classifier by addressing some of its limitations and ensuring efficiency in high-dimensional data. Specifically, you should enhance the performance of the nearest neighbor search algorithm. # Task Implement a nearest neighbor search function that: 1. Uses a KD-Tree data structure for efficient nearest neighbor search. 2. Handles high-dimensional data more effectively. # Function Signature ```python def build_kd_tree(points, depth=0): Build a KD-Tree from a set of points. Parameters: points (list of tuples): The points to build the KD-Tree from. depth (int): The current depth of the tree (used for determining axis). Returns: KDTreeNode: The root node of the constructed KD-Tree. pass def kd_tree_nearest_neighbor(x, kd_tree): Find the nearest neighbor to point x using the KD-Tree. Parameters: x (tuple): The query point. kd_tree (KDTreeNode): The root node of the KD-Tree. Returns: tuple: The nearest neighbor point. pass ``` # Input - `points`: A list of tuples representing the points in the training set. - `x`: A tuple representing the query point. - `kd_tree`: The root node of a prebuilt KD-Tree from the training set. # Constraints - Assume all points are n-dimensional tuples with real-number coordinates. - The KD-Tree should be built to balance the points effectively to ensure efficient search. # Output - The function `kd_tree_nearest_neighbor` should return the nearest neighbor point to `x` using the KD-Tree. # Example ```python points = [(2, 3), (5, 4), (9, 6), (4, 7), (8, 1), (7, 2)] query_point = (9, 2) kd_tree = build_kd_tree(points) neighbor = kd_tree_nearest_neighbor(query_point, kd_tree) print(neighbor) # Expected output: (8, 1) ``` # Additional Notes 1. You may define any helper classes or functions as needed for the KD-Tree implementation. 2. Pay attention to edge cases where the training set might be highly imbalanced or have duplicate points. 3. Aim to achieve significant performance improvements over the naive implementation.","solution":"from collections import namedtuple import math KDTreeNode = namedtuple(\'KDTreeNode\', [\'point\', \'left\', \'right\']) def build_kd_tree(points, depth=0): if not points: return None k = len(points[0]) # Assume all points have the same dimension axis = depth % k points.sort(key=lambda x: x[axis]) median = len(points) // 2 return KDTreeNode( point=points[median], left=build_kd_tree(points[:median], depth + 1), right=build_kd_tree(points[median + 1:], depth + 1) ) def distance_squared(p1, p2): return sum((x - y) ** 2 for x, y in zip(p1, p2)) def kd_tree_nearest_neighbor(query, kd_tree, depth=0, best=None): if kd_tree is None: return best k = len(query) axis = depth % k next_best = None next_branch = None if best is None or distance_squared(query, kd_tree.point) < distance_squared(query, best): next_best = kd_tree.point else: next_best = best if query[axis] < kd_tree.point[axis]: next_branch = kd_tree.left opposite_branch = kd_tree.right else: next_branch = kd_tree.right opposite_branch = kd_tree.left next_best = kd_tree_nearest_neighbor(query, next_branch, depth + 1, next_best) if (query[axis] - kd_tree.point[axis]) ** 2 < distance_squared(query, next_best): next_best = kd_tree_nearest_neighbor(query, opposite_branch, depth + 1, next_best) return next_best"},{"question":"# B-tree Deletion Detailed Implementation You are given a partial implementation of a B-tree, specifically, the insertion and key manipulation parts are well defined. Your task is to focus on the deletion operations of this B-tree. Given the following requirements and specifications, implement the `_remove_key` and associated methods to handle all edge cases and ensure the B-tree properties are maintained. Requirements: 1. **Deletion**: - If the node to delete from is a leaf node and contains the key. - If the node to delete from is a non-leaf node, handle the deletion by either replacing the key with its predecessor or successor or merging children. - Ensure that after any deletion, the tree remains balanced and valid according to B-tree properties. 2. **Auxiliary Methods**: - Handle rotations and merges correctly to support the key removal process. - Ensure accurate transfer of keys and appropriate resizing of nodes. Function Signatures: ```python def remove_key(self, key: int) -> bool: Removes a key from the B-tree. Args: key (int): The key to be removed. Returns: bool: True if the key was successfully removed, False otherwise. pass def _remove_key(self, node: Node, key: int) -> bool: Helper recursive method to delete a key from a subtree rooted with node. pass def _rotate_left(self, node: Node, child_index: int): Perform a left rotation to handle key balancing during deletion. pass def _rotate_right(self, node: Node, child_index: int): Perform a right rotation to handle key balancing during deletion. pass ``` # Input & Output Format ```python # Create a B-tree with a specified degree. b_tree = BTree(t_val=2) # Insert some keys. for key in [10, 20, 5, 6, 12, 30, 7, 17]: b_tree.insert_key(key) # Remove a key and check if the B-tree properties hold. result = b_tree.remove_key(6) print(result) # Expected: True # Traverse the tree to ensure the structure is still valid. b_tree.traverse_tree() # Expected output (in some valid, balanced order for a B-tree): # Should maintain in-order traversal layout. ``` # Constraints: - Operations should maintain O(log n) complexity. - Ensure the main B-tree properties are preserved after each deletion. Implement the following methods in the provided BTree class: - `remove_key` (public) - `_remove_key` (protected) - `_rotate_left` (protected) - `_rotate_right` (protected)","solution":"class Node: def __init__(self, t, leaf=False): self.t = t self.leaf = leaf self.keys = [] self.children = [] class BTree: def __init__(self, t_val): self.t = t_val self.root = Node(t_val, leaf=True) def insert_key(self, k): if len(self.root.keys) == 2 * self.t - 1: new_node = Node(self.t, leaf=False) new_node.children.append(self.root) self._split_child(new_node, 0, self.root) self.root = new_node self._insert_non_full(self.root, k) # Helper functions for insertion def _insert_non_full(self, node, k): i = len(node.keys) - 1 if node.leaf: node.keys.append(None) while i >= 0 and k < node.keys[i]: node.keys[i + 1] = node.keys[i] i -= 1 node.keys[i + 1] = k else: while i >= 0 and k < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == 2 * self.t - 1: self._split_child(node, i, node.children[i]) if k > node.keys[i]: i += 1 self._insert_non_full(node.children[i], k) def _split_child(self, parent, i, node): new_node = Node(self.t, leaf=node.leaf) parent.children.insert(i + 1, new_node) parent.keys.insert(i, node.keys[self.t - 1]) new_node.keys = node.keys[self.t:(2 * self.t - 1)] node.keys = node.keys[0:(self.t - 1)] if not node.leaf: new_node.children = node.children[self.t:(2 * self.t)] node.children = node.children[0:self.t] def remove_key(self, key): return self._remove_key(self.root, key) def _remove_key(self, node, key): t = self.t if node.leaf: if key in node.keys: node.keys.remove(key) return True return False idx = None for i, k in enumerate(node.keys): if k == key: idx = i break if idx is not None: if node.leaf: node.keys.pop(idx) else: if len(node.children[idx].keys) >= t: node.keys[idx] = self._get_predecessor(node, idx) self._remove_key(node.children[idx], node.keys[idx]) elif len(node.children[idx + 1].keys) >= t: node.keys[idx] = self._get_successor(node, idx) self._remove_key(node.children[idx + 1], node.keys[idx]) else: self._merge(node, idx) self._remove_key(node.children[idx], key) return True else: for i in range(len(node.keys)): if key < node.keys[i]: idx = i break if idx is None: idx = len(node.keys) if len(node.children[idx].keys) < t: if idx != 0 and len(node.children[idx - 1].keys) >= t: self._rotate_right(node, idx - 1) elif idx != len(node.keys) and len(node.children[idx + 1].keys) >= t: self._rotate_left(node, idx) else: if idx != len(node.keys): self._merge(node, idx) else: self._merge(node, idx - 1) return self._remove_key(node.children[idx], key) def _get_predecessor(self, node, idx): current = node.children[idx] while not current.leaf: current = current.children[-1] return current.keys[-1] def _get_successor(self, node, idx): current = node.children[idx + 1] while not current.leaf: current = current.children[0] return current.keys[0] def _merge(self, node, idx): child1 = node.children[idx] child2 = node.children[idx + 1] child1.keys.append(node.keys[idx]) child1.keys.extend(child2.keys) if not child1.leaf: child1.children.extend(child2.children) node.children.pop(idx + 1) node.keys.pop(idx) def _rotate_left(self, node, idx): child1 = node.children[idx] child2 = node.children[idx + 1] child1.keys.append(node.keys[idx]) node.keys[idx] = child2.keys.pop(0) if not child1.leaf: child1.children.append(child2.children.pop(0)) def _rotate_right(self, node, idx): child1 = node.children[idx] child2 = node.children[idx + 1] child2.keys.insert(0, node.keys[idx]) node.keys[idx] = child1.keys.pop() if not child1.leaf: child2.children.insert(0, child1.children.pop()) def traverse_tree(self, node=None): if node is None: node = self.root for i, key in enumerate(node.keys): if not node.leaf: self.traverse_tree(node.children[i]) print(key, end=\\" \\") if not node.leaf: self.traverse_tree(node.children[len(node.keys)])"},{"question":"# Challenging Coding Question: Modular Exponential Context In cryptography and number theory, it is often necessary to compute large powers of integers with a modulus to keep the numbers manageable and prevent overflow. The function `modular_exponential` computes (base to the power of exponent) modulo a given number efficiently using the method of exponentiation by squaring. Task Write a Python function `mod_exp(base, exponent, mod)` that: 1. Computes the modular exponentiation of a given base raised to a given exponent under a modulus. 2. Handles edge cases correctly. 3. Is efficient in terms of time complexity. Input * An integer base (`0 <= base <= 10^18`). * An integer exponent (`0 <= exponent <= 10^18`). If the exponent is negative, raise a `ValueError` with the message \\"Exponent must be non-negative.\\" * An integer modulus (`1 <= mod <= 10^18`). Output * Returns an integer representing (base^exponent) % mod. Constraints * The function must run efficiently with a time complexity of O(log n), where n is the exponent. * Assume inputs are valid and do not need additional type checking beyond handling non-negative exponent values. Example ```python # Example 1 base = 2 exponent = 10 mod = 5 print(mod_exp(base, exponent, mod)) # Output: 4 # Example 2 base = 3 exponent = 0 mod = 7 print(mod_exp(base, exponent, mod)) # Output: 1 # Example 3 base = 2 exponent = -3 mod = 11 print(mod_exp(base, exponent, mod)) # Raises ValueError: Exponent must be non-negative. ``` Notes 1. Ensure your function is optimized for very large values of the base, exponent, and mod, as given in the constraints. 2. Consider edge cases such as exponent equals zero, which should return 1.","solution":"def mod_exp(base, exponent, mod): Computes (base^exponent) % mod using the method of exponentiation by squaring. Parameters: - base (int): The base value (0 <= base <= 10^18) - exponent (int): The exponent value (0 <= exponent <= 10^18) - mod (int): The modulo value (1 <= mod <= 10^18) Returns: - int: Result of (base^exponent) % mod Raises: - ValueError: If exponent is negative. if exponent < 0: raise ValueError(\\"Exponent must be non-negative.\\") result = 1 base = base % mod # Take base modulo initially to handle large numbers while exponent > 0: if exponent % 2 == 1: # If exponent is odd, multiply result with current base result = (result * base) % mod exponent = exponent >> 1 # Divide exponent by 2 base = (base * base) % mod # Square the base and take mod return result"},{"question":"# Word Search with Wildcards Design and implement a class named `WordSearch` that supports adding and searching for words in a dictionary-like structure using wildcards. You will utilize a Trie data structure to efficiently manage and search words. Class Definition ```python class WordSearch: def __init__(self): Initialize your data structure here. pass def add_word(self, word): Adds a word into the data structure. pass def search(self, word): Returns if the word is in the data structure. A word could contain the dot character \'.\' to represent any one letter. pass ``` Method Descriptions 1. `__init__()`: Initializes the Trie structure. 2. `add_word(word: str) -> None`: Adds a word to the Trie. 3. `search(word: str) -> bool`: Searches for a word. A word may contain the `.` character representing any single letter. Constraints * Words consist of only lowercase English letters. * The wildcard character `.` will not appear as the first character of the word. * Assume inputs are valid, well-formed strings. Example ```python word_search = WordSearch() word_search.add_word(\\"bad\\") word_search.add_word(\\"dad\\") word_search.add_word(\\"mad\\") print(word_search.search(\\"pad\\")) # -> False print(word_search.search(\\"bad\\")) # -> True print(word_search.search(\\".ad\\")) # -> True print(word_search.search(\\"b..\\")) # -> True ``` Performance Requirements * Efficient handling of both add and search operations. * Time complexity: Add word should be linear relative to the word length. * Space complexity: Efficient storage using minimal space expansion in Trie. # Implementation notes Focus on optimizing wild-card search within the Trie. Ensure your algorithm properly traverses nodes, especially for these cases: - Multiple wildcards in one word. - Prefix and suffix searches combined with wildcards.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordSearch: def __init__(self): Initialize the data structure here. self.root = TrieNode() def add_word(self, word): Adds a word into the data structure. current_node = self.root for char in word: if char not in current_node.children: current_node.children[char] = TrieNode() current_node = current_node.children[char] current_node.is_end_of_word = True def search(self, word): Returns if the word is in the data structure. A word could contain the dot character \'.\' to represent any one letter. return self._search_in_node(word, self.root) def _search_in_node(self, word, node): for i, char in enumerate(word): if char == \'.\': for child in node.children.values(): if self._search_in_node(word[i+1:], child): return True return False else: if char not in node.children: return False node = node.children[char] return node.is_end_of_word"},{"question":"# Question: Maximum Flow Network Optimization You are tasked with optimizing a network flow in an urban transportation system. Given a directed graph representing the transportation network with nodes as junctions and edges as roads with certain capacities, you are required to compute the maximum possible flow from a designated source junction (start of the network) to a sink junction (end of the network). Function Signature: ```python def optimized_max_flow(capacity: List[List[int]], source: int, sink: int) -> int: pass ``` Input: - `capacity`: A 2D list (n x n) where n is the number of junctions. `capacity[i][j]` represents the maximum flow capacity of the road from junction `i` to junction `j`. - `source`: An integer representing the source junction from where the flow starts. - `sink`: An integer representing the sink junction where the flow should end. Output: - An integer representing the maximum flow from the source to the sink junction. Constraints: - The number of junctions (n) will be at most 500. - The capacity of each road will be a non-negative integer and will not exceed 10^6. - There may be roads with zero capacity. Performance Requirements: - The algorithm should efficiently handle both sparse and dense graphs, optimizing for cases with potentially large max-flow values. Examples: ```python capacity = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 assert optimized_max_flow(capacity, source, sink) == 23 capacity = [ [0, 10, 10, 0, 0, 0], [0, 0, 0, 10, 0, 0], [0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 10, 10], [0, 0, 0, 0, 0, 10], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 assert optimized_max_flow(capacity, source, sink) == 15 ``` Scenario: Consider a network of roads in a city where each road has a maximum traffic carrying capacity. As the city engineer, you need to ensure that the maximum possible traffic from the starting junction to the destination junction can be handled efficiently. Implement the `optimized_max_flow` function to ensure smooth traffic flow across the network.","solution":"from typing import List def bfs(capacity, source, sink, parent): visited = [False] * len(capacity) queue = [] queue.append(source) visited[source] = True while queue: u = queue.pop(0) for idx, val in enumerate(capacity[u]): if visited[idx] == False and val > 0: queue.append(idx) visited[idx] = True parent[idx] = u if idx == sink: return True return False def optimized_max_flow(capacity: List[List[int]], source: int, sink: int) -> int: parent = [-1] * len(capacity) max_flow = 0 while bfs(capacity, source, sink, parent): path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, capacity[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] capacity[u][v] -= path_flow capacity[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"# Scenario Imagine you\'re building an order processing system where you need to manage orders based on their priority. Orders with higher priority should be processed first. To ensure you comply with the business rules, you need a stack that automatically orders items based on their priority upon insertion. # Task Implement the `OrderedStack` class with methods to push while maintaining order, pop, peek, and check the size of the stack. The stack should be ordered such that the highest value is always at the top. The `push` method should ensure this ordering while other methods should maintain the standard stack behavior. # Function Signatures ```python class OrderedStack: def __init__(self): # Initializes an empty ordered stack pass def push(self, item): # Pushes and orders the item in place pass def pop(self): # Pops the highest item from the ordered stack pass def peek(self): # Returns the highest item without removing it pass def size(self): # Returns the size of the stack pass def is_empty(self): # Checks if the stack is empty pass ``` # Constraints 1. Items added to the stack will be comparable integers. 2. The stack should preserve the ordering on each operation. 3. All operations should have efficient performance relevant to stack size constraints. 4. Ensure the stack handles underflow correctly when `pop` or `peek` methods are called on an empty stack. # Performance Requirements - `push` should maintain order efficiently but time complexity can be O(n) for the worst case. - `pop` and `peek` should both be O(1) operations. # Examples ```python os = OrderedStack() os.push(5) os.push(1) os.push(10) print(os.peek()) # Output: 10, since 10 is the highest value os.push(7) print(os.pop()) # Output: 10, after this 7 should be the new top print(os.size()) # Output: 3, elements left are 7, 5, 1 os.pop() # Removes 7 os.pop() # Removes 5 os.pop() # Removes 1 os.is_empty() # Output: True ```","solution":"class OrderedStack: def __init__(self): self.stack = [] def push(self, item): # Insert item in a sorted manner if not self.stack or item >= self.stack[-1]: self.stack.append(item) else: temp = [] while self.stack and item < self.stack[-1]: temp.append(self.stack.pop()) self.stack.append(item) while temp: self.stack.append(temp.pop()) def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self.stack.pop() def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.stack[-1] def size(self): return len(self.stack) def is_empty(self): return len(self.stack) == 0"},{"question":"You are part of a software development team working on a new system that requires robust and efficient conversion between different numeral bases. Your task is to implement functions for converting an integer to a string in any base (2 to 36) and vice versa. Functions to Implement 1. **int_to_base** - **Parameters**: - `num`: an integer. - `base`: an integer specifying the target base (2 ≤ base ≤ 36). - **Returns**: - A string representing the number `num` in the specified base. - **Constraints**: - The function should handle negative numbers. - The function should handle `base` outside the range of 2 to 36 gracefully. 2. **base_to_int** - **Parameters**: - `str_to_convert`: a string representing a number in the specified base. - `base`: an integer specifying the base of the number in the string (2 ≤ base ≤ 36). - **Returns**: - An integer that is the conversion of the string `str_to_convert` from the specified base to a base-10 integer. - **Constraints**: - The function should handle invalid characters in `str_to_convert`. Performance Requirements - Your implementation should be efficient in both computation and memory usage for large inputs. Examples ```python assert int_to_base(5, 2) == \'101\' assert base_to_int(\'101\', 2) == 5 assert int_to_base(15, 16) == \'F\' assert base_to_int(\'F\', 16) == 15 assert int_to_base(-10, 10) == \'-10\' assert base_to_int(\'-A\', 16) == -10 ``` Write these functions such that they pass the provided assertions while maintaining efficiency and correctness for all edge cases.","solution":"def int_to_base(num, base): Convert an integer `num` to a string in the given base `base`. Parameters: num (int): The integer to convert. base (int): The base for the conversion (2 ≤ base ≤ 36). Returns: str: The string representation of `num` in the specified base. if not (2 <= base <= 36): raise ValueError(f\\"Base must be in the range 2 to 36, inclusive. Given base: {base}\\") if num == 0: return \'0\' digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" is_negative = num < 0 num = abs(num) result = [] while num > 0: result.append(digits[num % base]) num //= base if is_negative: result.append(\'-\') return \'\'.join(reversed(result)) def base_to_int(str_to_convert, base): Convert a string `str_to_convert` in the given base `base` to a base-10 integer. Parameters: str_to_convert (str): The string representing the number in the given base. base (int): The base of the number in the string (2 ≤ base ≤ 36). Returns: int: The base-10 integer representation of `str_to_convert`. if not (2 <= base <= 36): raise ValueError(f\\"Base must be in the range 2 to 36, inclusive. Given base: {base}\\") str_to_convert = str_to_convert.strip().upper() if not str_to_convert: raise ValueError(\\"Input string is empty\\") digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" digit_map = {char: i for i, char in enumerate(digits)} is_negative = str_to_convert[0] == \'-\' if is_negative: str_to_convert = str_to_convert[1:] num = 0 for char in str_to_convert: if char not in digit_map or digit_map[char] >= base: raise ValueError(f\\"Invalid character in input string for base {base}: {char}\\") num = num * base + digit_map[char] return -num if is_negative else num"},{"question":"# Run-Length Encoding and Decoding You are provided with two functions: `encode_rle` and `decode_rle`, which perform run-length encoding and decoding, respectively. Your task is to implement additional functionalities to enhance the Run-Length Encoding. Implement a function `optimized_encode_rle(input)` that performs the same encoding but is optimized to handle longer sequences more efficiently. Alongside this, create a corresponding `verify_decode_rle(encoded_input, original_input)` function that verifies if the encoded string, when decoded, matches the original input string. Function Signatures ```python def optimized_encode_rle(input: str) -> str: pass def verify_decode_rle(encoded_input: str, original_input: str) -> bool: pass ``` Input/Output * `optimized_encode_rle(input: str) -> str` - **Input**: A string of data to be encoded. - **Output**: The RLE encoded string. * `verify_decode_rle(encoded_input: str, original_input: str) -> bool` - **Input**: - `encoded_input`: The RLE encoded string. - `original_input`: The original string before encoding. - **Output**: Boolean `True` if decoding the `encoded_input` results in the `original_input`, else `False`. Constraints - The input string length should be between 0 and 10⁶ characters. - Characters in the input string can be any alphanumeric character. Example ```python input_string = \\"aaabbccaa\\" optimized_encoded_string = optimized_encode_rle(input_string) # Output should be: \\"3a2b2c2a\\" assert verify_decode_rle(optimized_encoded_string, input_string) == True ``` Notes - Ensure that your optimized encoding function handles large input sizes efficiently. - The verify function must only use the decode function to compare results and not directly compare encoded strings.","solution":"def optimized_encode_rle(input: str) -> str: Perform run-length encoding on the input string, optimized for large inputs. if not input: return \'\' encoded_string = [] count = 1 prev_char = input[0] for char in input[1:]: if char == prev_char: count += 1 else: encoded_string.append(f\\"{count}{prev_char}\\") prev_char = char count = 1 encoded_string.append(f\\"{count}{prev_char}\\") return \'\'.join(encoded_string) def decode_rle(encoded_input: str) -> str: Decode a run-length encoded string. decoded_string = [] count = 0 for char in encoded_input: if char.isdigit(): count = count * 10 + int(char) else: decoded_string.append(char * count) count = 0 return \'\'.join(decoded_string) def verify_decode_rle(encoded_input: str, original_input: str) -> bool: Verify if the encoded string when decoded matches the original input string. decoded_string = decode_rle(encoded_input) return decoded_string == original_input"},{"question":"# Roman Numeral Validation and Conversion You have been given a function `roman_to_int` that converts a Roman numeral string into its corresponding integer value. This function assumes that the given Roman numeral string is always valid and within the range from 1 to 3999. However, in real-world scenarios, input values may not always be valid. We would like to enhance this function to first validate the input Roman numeral string, and only then perform the conversion. If the input is invalid, the function should return -1. # Requirements 1. Write a Python function `validate_roman(s: str) -> bool` that validates the Roman numeral string. - A valid Roman numeral string must: - Contain only the characters \'I\', \'V\', \'X\', \'L\', \'C\', \'D\', \'M\'. - Adhere to the rules of Roman numeral syntax (e.g., \'IIII\' is invalid, but \'IV\' is valid). 2. Modify the current `roman_to_int` function to call `validate_roman` first and only proceed with conversion if the input is valid. # Input and Output - **Input**: A string `s` representing the Roman numeral. - **Output**: The integer value if the input is valid; otherwise, -1. # Performance Requirements - The combined validation and conversion should maintain an overall time complexity of O(n). # Example ```python validate_roman(\\"MCMXCIV\\") # Should return True roman_to_int(\\"MCMXCIV\\") # Should return 1994 validate_roman(\\"IIII\\") # Should return False roman_to_int(\\"IIII\\") # Should return -1 validate_roman(\\"ABCD\\") # Should return False roman_to_int(\\"ABCD\\") # Should return -1 ``` # Hints - Carefully consider rules for combining and repeating Roman numerals. - Remember that certain numeral combinations are invalid, such as \'IIII\' and \'VV\'.","solution":"def validate_roman(s: str) -> bool: valid_chars = {\'I\', \'V\', \'X\', \'L\', \'C\', \'D\', \'M\'} if not s: return False if any(char not in valid_chars for char in s): return False invalid_repeats = [\\"IIII\\", \\"VV\\", \\"XXXX\\", \\"LL\\", \\"CCCC\\", \\"DD\\", \\"MMMM\\"] for repeat in invalid_repeats: if repeat in s: return False # Regex pattern to validate Roman numeral rules import re pattern = \\"^M{0,3}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})\\" if not re.match(pattern, s): return False return True def roman_to_int(s: str) -> int: if not validate_roman(s): return -1 roman_numerals = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } result = 0 prev_value = 0 for char in reversed(s): value = roman_numerals[char] if value < prev_value: result -= value else: result += value prev_value = value return result"},{"question":"# Transitive Closure of a Directed Graph Background In a directed graph, the transitive closure of a graph is a matrix that indicates whether there\'s a path between any pair of vertices. Given a directed graph, your task is to find the transitive closure matrix of the graph using Depth First Search (DFS). # Function Specification Write a function `find_transitive_closure` that takes two parameters: 1. An integer `n` representing the number of vertices in the graph. 2. A list of edges, where each edge is a tuple (source, target) representing a directed connection from `source` to `target`. The function should return a 2D list representing the transitive closure matrix of the graph. The matrix should be of size nxn, where cell (i, j) is 1 if there\'s a path from vertex i to vertex j, and 0 otherwise. # Input - `n`: an integer (1 ≤ n ≤ 100) - the number of vertices in the graph. - `edges`: a list of tuples, each tuple (source, target) representing a directed edge (0 ≤ source, target < n). # Output - A 2D list of integers representing the transitive closure matrix. # Constraints - The graph does not contain self-loops or multiple edges. - The graph may be disconnected. # Example Input ```python n = 4 edges = [(0, 1), (1, 2), (2, 3)] ``` Output ```python [ [1, 1, 1, 1], [0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1] ] ``` Explanation - From vertex 0, you can reach all other vertices (0->1->2->3). - From vertex 1, you can reach vertices 1, 2, and 3 (1->2->3). - From vertex 2, you can only reach vertices 2 and 3 (2->3). - From vertex 3, you can only reach vertex 3. # Notes - You need to use DFS to identify reachability from each vertex. - Ensure the use of appropriate data structures to store the graph and the closure matrix.","solution":"def find_transitive_closure(n, edges): def dfs(graph, start, visited): stack = [start] while stack: node = stack.pop() for neighbor in graph[node]: if not visited[start][neighbor]: visited[start][neighbor] = 1 stack.append(neighbor) # Create adjacency list for the graph graph = [[] for _ in range(n)] for source, target in edges: graph[source].append(target) # Initialize the closure matrix closure = [[0] * n for _ in range(n)] for i in range(n): closure[i][i] = 1 # Every node is reachable from itself # Compute the transitive closure for i in range(n): dfs(graph, i, closure) return closure"},{"question":"# Question **Rotated Cipher Decoder** Julius Caesar was not only known for using simple encryption but also decoding messages encrypted with his technique by his fellow Romans. In this task, you are required to write a function that will decode a given string which was encoded using a Caesar cipher. Task Write a function `decipher_caesar_cipher(s, k)` that takes a string `s` (the encoded message) and an integer `k` (the number of positions each letter in the message was shifted forward), and returns the original deciphered message. Input Format - A string `s` which consists of alphabetic characters and may include spaces, digits, or punctuation. - An integer `k` where `0 <= k <= 25`. Output Format A string representing the original deciphered message. Constraints - Each letter in the string will have been shifted by the same amount, `k`. Example ```python assert decipher_caesar_cipher(\\"ifmmp\\", 1) == \\"hello\\" assert decipher_caesar_cipher(\\"Khoor Zruog\\", 3) == \\"Hello World\\" ``` Performance Requirements - The implementation should have linear time complexity relative to the size of the input string. Additional Notes: You may assume that the provided input string is non-empty and that the shift value `k` will be within the specified bounds.","solution":"def decipher_caesar_cipher(s, k): Deciphers a given string `s` that was encoded with a Caesar cipher by shifting `k` positions. :param s: Encoded message string :param k: Number of positions each letter in the message was shifted :return: Original deciphered message deciphered_message = [] for char in s: if char.isalpha(): ascii_offset = ord(\'a\') if char.islower() else ord(\'A\') deciphered_char = chr((ord(char) - ascii_offset - k) % 26 + ascii_offset) deciphered_message.append(deciphered_char) else: deciphered_message.append(char) return \'\'.join(deciphered_message)"},{"question":"You have been given an array of integers. Your task is to implement a modified version of the linear search that not only finds the first occurrence of a target element but also counts the total number of occurrences of the target element in the array. Specifically, you need to implement the following function: ```python def advanced_linear_search(array, query): Find the index of the given element in the array and count its occurrences. Parameters: - array (list): A list of integers where the search will be performed. - query (int): The integer to be searched in the array. Returns: - tuple: A tuple (first_index, count) where: - first_index (int): The index of the first occurrence of the query element. - count (int): The total number of occurrences of the query element in the array. If the element couldn\'t be found, returns (-1, 0). pass ``` Input Format * `array`: A list of integers. (-10^9 <= array[i] <= 10^9) * `query`: An integer to be searched within the list. (-10^9 <= query <= 10^9) Output Format * Return a tuple `(first_index, count)`. If the query element is not found, `first_index` should be `-1` and `count` should be `0`. Example ```python assert advanced_linear_search([1, 2, 3, 4, 2, 5], 2) == (1, 2) assert advanced_linear_search([7, 8, 9, 7, 7, 6], 7) == (0, 3) assert advanced_linear_search([10, 20, 30, 40], 25) == (-1, 0) assert advanced_linear_search([], 1) == (-1, 0) ``` Constraints * The length of the array will not exceed 10^5. * Ensure that your solution is efficient and runs within acceptable time limits.","solution":"def advanced_linear_search(array, query): Find the index of the given element in the array and count its occurrences. Parameters: - array (list): A list of integers where the search will be performed. - query (int): The integer to be searched in the array. Returns: - tuple: A tuple (first_index, count) where: - first_index (int): The index of the first occurrence of the query element. - count (int): The total number of occurrences of the query element in the array. If the element couldn\'t be found, returns (-1, 0). first_index = -1 count = 0 for i, num in enumerate(array): if num == query: if first_index == -1: first_index = i count += 1 return (first_index, count)"},{"question":"# Roman to Integer Conversion Challenge **Problem Description:** Given a string `s` representing a Roman numeral, write a function `roman_to_int(s: str) -> int` that converts this numeral to its integer value. The input string is guaranteed to be within the range from 1 to 3999. **Input Format:** - A single string `s`, where `1 <= len(s) <= 15`. **Output Format:** - A single integer, which is the equivalent integer value of the Roman numeral. **Constraints:** - The string `s` will always be a valid Roman numeral within the range of 1 to 3999. **Example:** ```python Input: \\"DCXXI\\" Output: 621 Input: \\"MCMXCIV\\" Output: 1994 ``` **Guidelines:** - Do not use built-in functions that directly convert Roman numerals to integers. - Consider edge cases and ensure your solution is efficient. **Expected Performance:** - Time Complexity: O(n), where n is the length of the string `s`. - Space Complexity: O(1).","solution":"def roman_to_int(s: str) -> int: Converts a Roman numeral string to its integer value. roman_to_value = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } total = 0 prev_value = 0 for char in reversed(s): value = roman_to_value[char] if value >= prev_value: total += value else: total -= value prev_value = value return total"},{"question":"A friendship network is represented as an undirected graph, where people are vertices, and friendships are edges. You are given an adjacency list representation of this graph. Your task is to determine if this graph can be divided into two distinct groups such that no two connected people are in the same group. # Function Signature ```python def is_friendship_bipartite(adj_list: List[List[int]]) -> bool: Determines if a friendship network represented as an adjacency list is bipartite. Parameters: adj_list (List[List[int]]): An adjacency list where adj_list[i] is a list of indices of friends of person i. Returns: bool: True if the friendship network is bipartite, otherwise False. ``` # Input - `adj_list`: A list of lists of integers, where `adj_list[i]` is a list of indices of friends of person `i`. The length of `adj_list` is the number of people in the network. # Output - Returns `True` if the friendship network is bipartite, `False` otherwise. # Constraints 1. 1 ≤ len(adj_list) ≤ 1000 2. 0 ≤ len(adj_list[i]) ≤ 1000 # Example **Input:** ```python [[1, 3], [0, 2], [1, 3], [0, 2]] ``` **Output:** ```python True ``` This graph is bipartite as it can be divided into set {0, 2} and set {1, 3}. **Input:** ```python [[1, 2], [0, 2], [0, 1]] ``` **Output:** ```python False ``` This graph contains an odd-cycle and is therefore not bipartite. # Notes - This problem tests the student\'s understanding of graph theory, specifically bipartite graphs, and requires implementation of BFS. - Consider edge cases like graphs with self-loops and disconnected components. - You are allowed to import and use only `collections.deque` from the Python standard library for implementing BFS efficiently.","solution":"from typing import List from collections import deque def is_friendship_bipartite(adj_list: List[List[int]]) -> bool: Determines if a friendship network represented as an adjacency list is bipartite. Parameters: adj_list (List[List[int]]): An adjacency list where adj_list[i] is a list of indices of friends of person i. Returns: bool: True if the friendship network is bipartite, otherwise False. # -1: uncolored, 0: first color, 1: second color color = [-1] * len(adj_list) def bfs(start): queue = deque([start]) color[start] = 0 while queue: node = queue.popleft() current_color = color[node] for neighbor in adj_list[node]: if color[neighbor] == -1: # Color with the alternate color color[neighbor] = 1 - current_color queue.append(neighbor) elif color[neighbor] == current_color: # Found the same color on both sides of an edge return False return True for i in range(len(adj_list)): if color[i] == -1: # Check unvisited nodes (for disconnected graph) if not bfs(i): return False return True"},{"question":"Scenario You are a software developer working on a novel text editor. A critical feature requested by users is the ability to perform fast and efficient word searches within large documents. You decide to implement the Rabin-Karp algorithm to achieve this. Task Write a function `find_word_positions` that takes in two strings: `word` and `text`, and returns a list of starting positions where `word` is found in `text`. If the word is not found, return an empty list. Function Signature ```python def find_word_positions(word: str, text: str) -> List[int]: # Your implementation here ``` Input Format - `word`: A string representing the pattern to search for. - `text`: A string representing the document to search within. Output Format - A list of integers representing the starting indices of each occurrence of `word` in `text`. - Return an empty list if the word does not occur within the text. Constraints - The length of `word` will be between 1 and 10^3. - The length of `text` will be up to 10^6 characters. - Both `word` and `text` will contain only lowercase English letters. Example ```python assert find_word_positions(\\"test\\", \\"this is a test text with test cases\\") == [10, 25] assert find_word_positions(\\"abc\\", \\"abcdabcabc\\") == [0, 4, 7] assert find_word_positions(\\"pattern\\", \\"nooccurrencehere\\") == [] ``` Notes - Consider edge cases such as empty strings, non-occurent patterns, and multiple adjacent matches. - Optimize your solution to handle large inputs efficiently.","solution":"from typing import List def find_word_positions(word: str, text: str) -> List[int]: Find all starting positions where the word is found in the text using the Rabin-Karp algorithm. if not word or not text or len(word) > len(text): return [] # Base number for the rolling hash function base = 256 # A large prime number to mod the hash values prime = 101 m, n = len(word), len(text) word_hash = 0 text_hash = 0 h = 1 # Precompute the highest power of base (base^(m-1)) for _ in range(m - 1): h = (h * base) % prime # Calculate the hash value of the word and first window of text for i in range(m): word_hash = (base * word_hash + ord(word[i])) % prime text_hash = (base * text_hash + ord(text[i])) % prime result = [] # Slide the pattern over text one character at a time for i in range(n - m + 1): # Check the hash values of current window of text and pattern if word_hash == text_hash: # If the hash values match, check the characters one by one if text[i:i + m] == word: result.append(i) # Calculate hash value for the next window of text if i < n - m: text_hash = (base * (text_hash - ord(text[i]) * h) + ord(text[i + m])) % prime # We might get negative values, converting it to positive if text_hash < 0: text_hash += prime return result"},{"question":"You have been tasked with developing a feature for a travel company\'s system. The feature involves calculating the minimum travel cost from the starting station to the ending station given the costs of moving between various stations. **Problem Statement:** Given a station cost matrix where `Matrix[i][j]` denotes the cost to move from station `i` to station `j` (for `i < j`), write a function `calculate_min_cost` that returns the minimum cost to reach the last station from the first station. **Function Signature:** ```python def calculate_min_cost(cost: List[List[int]]) -> int: ``` **Inputs:** - `cost`: A 2D list (matrix) where cost[i][j] (i < j) denotes the cost to move from station i to station j. For invalid moves (i > j), the cost[i][j] will be marked as -1 or INF. The diagonal elements are always 0. **Output:** - Return an integer representing the minimum cost to reach the last station from the first station. **Constraints:** - The number of stations, N, such that 2 <= N <= 100. - Costs are non-negative integers or infinity. - `INF` is represented by float(\\"inf\\"). **Examples:** Example 1: ```python costs = [ [0, 15, 80, 90], [-1, 0, 40, 50], [-1, -1, 0, 70], [-1, -1, -1, 0] ] assert calculate_min_cost(costs) == 65 ``` Example 2: ```python costs = [ [0, 10, 75, 94], [-1, 0, 35, 50], [-1, -1, 0, 80], [-1, -1, -1, 0] ] assert calculate_min_cost(costs) == 60 ``` **Explanation:** The function should compute and return the minimum cost based on the methodology from dynamic programming, updating the cost list as iterated.","solution":"from typing import List def calculate_min_cost(cost: List[List[int]]) -> int: Calculates the minimum cost to reach the last station from the first station given a cost matrix. N = len(cost) INF = float(\'inf\') # Initialize the dp array with infinity dp = [INF] * N dp[0] = 0 # Cost to reach the first station is always 0 # Populate the dp array using dynamic programming for i in range(N): for j in range(i+1, N): if dp[i] != INF and cost[i][j] != INF: dp[j] = min(dp[j], dp[i] + cost[i][j]) return dp[-1]"},{"question":"# Fenwick Tree: Cumulative Frequency Table Implementation As an emerging data scientist, you are working on efficiently managing and updating cumulative frequency tables. A Fenwick Tree (or Binary Indexed Tree) is an optimal choice for this purpose due to its efficient update and query operations. # Task Your task is to implement a Fenwick Tree to support the following operations efficiently: 1. **Update the value at a specific index.** 2. **Query the prefix sum up to a specific index.** # Instructions 1. **Function `__init__(self, freq: List[int])`**: - **Input**: An integer list `freq` representing the initial frequency array. - **Action**: Initialize a Fenwick Tree with this array. 2. **Function `update(self, index: int, value: int)`**: - **Input**: An integer `index` representing the position in the array to update, and an integer `value` to add to the current value at the `index`. - **Action**: Update the `index` in the tree with the given `value`. 3. **Function `query(self, index: int) -> int`**: - **Input**: An integer `index` representing the position up to which the prefix sum is required. - **Output**: Returns the sum of elements from the start of the array up to the given `index`. 4. **Function `construct(self) -> List[int]`**: - **Output**: Returns the constructed Binary Indexed Tree as a list. # Example `freq = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2]` ```python # Initialize Fenwick Tree fenwick = Fenwick_Tree(freq) # Construct the BIT bit_tree = fenwick.construct() print(bit_tree) # Output: [0, 3, 5, -1, 10, 5, 9, -3, 19, 7, 9] # Update index 3 by adding value 3 fenwick.update(3, 3) # Query prefix sum up to index 5 print(fenwick.query(5)) # Output should reflect updated sum ``` # Constraints - Assume `0 ≤ index < n` where `n` is the length of the frequency array. - Values in the frequency array and updates are integer values. - The length of the frequency array can be up to 10^5. # Requirements - Your solution should complete in O(log n) time complexity for both `update` and `query` operations. - The constructor should initialize an array of size proportional to the input array length, ensuring O(n) space complexity. You should not use any additional external libraries for this implementation.","solution":"from typing import List class Fenwick_Tree: def __init__(self, freq: List[int]): self.n = len(freq) self.bit = [0] * (self.n + 1) for i in range(self.n): self.update(i, freq[i]) def update(self, index: int, value: int): index += 1 while index <= self.n: self.bit[index] += value index += index & -index def query(self, index: int) -> int: sum = 0 index += 1 while index > 0: sum += self.bit[index] index -= index & -index return sum def construct(self) -> List[int]: return self.bit[1:]"},{"question":"Array Rotation Challenge # Problem Statement You are provided with an array of integers and an integer \'k\'. Your goal is to implement a function that rotates the array to the right by \'k\' steps. # Input * An integer array `arr`. * An integer `k` representing the number of steps to rotate. # Output * The function should return the rotated array. # Constraints * The array length `n` is between 0 and 10^5. * The integer `k` is non-negative. # Performance Requirements * The solution should have a time complexity of O(n). # Scenario A common use case for array rotation is in systems where data needs to be periodically shifted or rotated. For instance, in a round-robin scheduler where tasks are cyclically distributed, this rotation algorithm can realign tasks efficiently. # Function Signature ```python def rotate_array(arr, k): Rotate the array \'arr\' to the right by \'k\' steps. :param arr: List[int] - The input array. :param k: int - Number of steps to rotate. :return: List[int] - The rotated array. # Your implementation here pass ``` # Examples 1. **Example 1:** * **Input**: `arr = [1, 2, 3, 4, 5, 6, 7]`, `k = 3` * **Output**: `[5, 6, 7, 1, 2, 3, 4]` 2. **Example 2:** * **Input**: `arr = [-1, -100, 3, 99]`, `k = 2` * **Output**: `[3, 99, -1, -100]` # Notes * The result should be returned by the function and not modify the input array in place. * Ensure to handle cases where `k` is greater than the length of the array by using `k % n`. # Solution Guidelines Try implementing a solution similar to the **rotate_v2** function described in the analysis for optimal time and space complexity, ensuring to handle all edge cases.","solution":"def rotate_array(arr, k): Rotate the array \'arr\' to the right by \'k\' steps. :param arr: List[int] - The input array. :param k: int - Number of steps to rotate. :return: List[int] - The rotated array. if not arr: return arr n = len(arr) k %= n # In case k is larger than n # Perform the rotation return arr[-k:] + arr[:-k]"},{"question":"# Context: You are tasked with organizing a list of student grades. Since the list can be chaotic, you decide to use the Gnome Sort algorithm to sort their grades in ascending order. To demonstrate your understanding of sorting algorithms, you must implement the Gnome Sort, but with a slight modification to sort the grades in descending order instead. # Task: Write a function `gnome_sort_descending(arr)` that performs Gnome Sort on a list of integers in descending order. # Input: The input to the function is a single parameter: - `arr`: A list of integers representing student grades. # Output: The function should return the sorted list of integers in descending order. # Constraints: - The array can contain between 0 and 10^4 elements. - Each element in the array is an integer in the range from 0 to 100. # Performance: Aim to implement the sorting algorithm with minimal modifications while ensuring it performs the sorting in descending order. # Example: ```python # Example input grades = [77, 65, 89, 56, 99, 85] # Function call sorted_grades = gnome_sort_descending(grades) # Example output print(sorted_grades) # Output should be: [99, 89, 85, 77, 65, 56] ```","solution":"def gnome_sort_descending(arr): Sorts the array using Gnome Sort in descending order. Parameters: arr (list): A list of integers representing student grades. Returns: list: The sorted list in descending order. index = 0 while index < len(arr): if index == 0 or arr[index] <= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"# Question: Implement an Optimized Cooley-Tukey FFT Algorithm Problem Description You are required to implement an optimized version of the Cooley-Tukey FFT algorithm. The given implementation is recursive and may not handle large datasets efficiently. Your task is to implement an iterative version of the FFT to improve its performance and handle large arrays without deep recursion. Input Format * `x`: A list of complex numbers where the length of list `N` is an integer power of 2. Output Format * Returns a list of complex numbers representing the discrete Fourier transform of the input array. Constraints * `0 < len(x) <= 2^16` - The length of the list is a power of 2. * Each element of `x` is a complex number. Performance Requirements * The implementation should have a time complexity of O(N log N). * Memory usage should be optimized to avoid unnecessary duplications. Example ```python Input: [2.0+2j, 1.0+3j, 3.0+1j, 2.0+2j] Output: [8+8j, 2j, 2-2j, -2+0j] ``` Note * Use the iterative approach to avoid deep recursion which might lead to stack overflow for large inputs.","solution":"import cmath def iterative_fft(x): Perform an Iterative Cooley-Tukey FFT algorithm. Parameters: x (list of complex): Input list of complex numbers. Length must be a power of 2. Returns: list of complex: The discrete Fourier transform of the input array. N = len(x) if N <= 1: return x # Bit reversal permutation indices = list(range(N)) j = 0 for i in range(1, N): bit = N // 2 while j >= bit: j -= bit bit //= 2 j += bit if i < j: indices[i], indices[j] = indices[j], indices[i] # Create a reordered array based on bit-reversed indices x = [x[i] for i in indices] # Iterative FFT m = 1 while m < N: wm = cmath.exp(-2j * cmath.pi / (2 * m)) for k in range(0, N, 2 * m): w = 1 for j in range(m): t = w * x[k + j + m] u = x[k + j] x[k + j] = u + t x[k + j + m] = u - t w *= wm m *= 2 return x"},{"question":"You are required to implement a sub-feature of a Red-Black Tree - the \\"Rank of an element\\". The rank of an element in a Red-Black Tree is its position in an in-order traversal of the tree. For instance, in a tree with the elements [1,2,3,4,5], the rank of the element with value 3 would be 2 (0-based indexing). You should implement a method `rank(self, value)` which will return this rank. # Function Specification: * **Input**: An integer `value` representing the value of a node in the tree. * **Output**: An integer representing the rank of the node with the given value, or -1 if the node with the given value does not exist in the tree. * **Constraints**: * All node values are unique. * The `RBTree` has already been populated with nodes before calling `rank`. # Implementation Instructions: 1. Add a method `rank(self, value)` in the `RBTree` class. 2. Ensure that the function efficiently computes the rank of a node by leveraging in-order traversal or other properties of the Red-Black Tree. # Example: ```python rb = RBTree() children = [11, 2, 14, 1, 7, 15, 5, 8, 4] for child in children: node = RBNode(child, 1) rb.insert(node) assert rb.rank(1) == 0 assert rb.rank(7) == 3 assert rb.rank(15) == 8 assert rb.rank(10) == -1 # Value not in the tree ``` Use the provided `RBTree` class as a base for your implementation. Add any helper methods if required.","solution":"class RBNode: def __init__(self, data, color, parent=None, left=None, right=None): self.data = data self.color = color self.parent = parent self.left = left self.right = right class RBTree: def __init__(self): self.TNULL = RBNode(0, 0) self.root = self.TNULL def insert(self, key): # Ordinary Binary Search Tree insertion node = RBNode(key, 1, None, self.TNULL, self.TNULL) if self.root == self.TNULL: self.root = node self.root.color = 0 self.root.parent = None else: current = self.root while current != self.TNULL: parent = current if node.data < current.data: current = current.left else: current = current.right node.parent = parent if node.data < parent.data: parent.left = node else: parent.right = node self._fix_insert(node) def _fix_insert(self, k): # To be implemented: Red-Black Tree balancing pass def rank(self, value): def in_order_traversal(node): if node == self.TNULL: return [] return in_order_traversal(node.left) + [node.data] + in_order_traversal(node.right) tree_elements = in_order_traversal(self.root) if value in tree_elements: return tree_elements.index(value) else: return -1"},{"question":"# Question: Find the nth Digit in a Sequential Number Series You are tasked with finding the nth digit in an infinite sequential number series formed by concatenating consecutive integers starting from 1 (i.e., \\"123456789101112...\\"). Function Definition ```python def find_nth_digit(n: int) -> int: Parameters: n (int): a positive integer representing the position in the series. Returns: int: the digit at the nth position in the sequence. ``` Input - The function accepts a single integer `n` (1 ≤ n ≤ 2 * 10^9). Output - The function returns an integer representing the digit at the nth position in the concatenated sequence. Example ```python assert find_nth_digit(3) == 3 assert find_nth_digit(11) == 0 ``` Constraints: - Your solution should handle large inputs efficiently within time and space constraints. Performance Requirements: - The implementation should ideally run in O(log n) time complexity and O(1) space complexity.","solution":"def find_nth_digit(n: int) -> int: Returns the nth digit in the infinite sequential number series. length = 1 count = 9 start = 1 while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 start += (n - 1) // length return int(str(start)[(n - 1) % length])"},{"question":"# Task: Filter Array Values within a Specified Range You have been provided with a function that filters elements of an array based on given minimum and maximum limits. Your task is to implement an enhanced version of this function that handles various edge cases more robustly. Function Signature ```python def limit(arr: List[float], min_lim: Optional[float]=None, max_lim: Optional[float]=None) -> List[float]: ``` Inputs * `arr`: A list of floats (can also be an empty list). * `min_lim`: An optional float value that sets the lower bound of the values to be included (default is `None`). * `max_lim`: An optional float value that sets the upper bound of the values to be included (default is `None`). Outputs * A list of floats containing the values from `arr` that are within the specified range `[min_lim, max_lim]`. Constraints * Elements of the array should be of valid numeric type (int or float). * If `min_lim` or `max_lim` is `None`, use the minimum or maximum value of the array, respectively. * The function should be able to handle mixed numeric types within the array. * The function should handle and return edge cases appropriately. Performance Requirements The solution should maintain a time complexity of O(n) where n is the number of elements in the array. Examples ```python # Example 1 arr = [1.2, 7.3, 4.5, 9.8, 15.0] min_lim = 5.0 max_lim = 10.0 # Expected output: [7.3, 9.8] print(limit(arr, min_lim, max_lim)) # Example 2 arr = [10, 20, 30, 40, 50] min_lim = None max_lim = 30 # Expected output: [10, 20, 30] print(limit(arr, min_lim, max_lim)) # Example 3 arr = [] min_lim = 0 max_lim = 10 # Expected output: [] print(limit(arr, min_lim, max_lim)) # Example 4 arr = [100, 200, 300] min_lim = 50 max_lim = 150 # Expected output: [100] print(limit(arr, min_lim, max_lim)) ``` **Your function should pass the provided test cases and be ready to handle additional edge cases for a comprehensive assessment.**","solution":"from typing import List, Optional def limit(arr: List[float], min_lim: Optional[float] = None, max_lim: Optional[float] = None) -> List[float]: Filters elements of arr based on the given minimum and maximum limits. :param arr: List of floats to be filtered. :param min_lim: Optional float value setting the lower bound (inclusive). :param max_lim: Optional float value setting the upper bound (inclusive). :return: List of floats within the specified range. if min_lim is None and len(arr) > 0: min_lim = min(arr) if max_lim is None and len(arr) > 0: max_lim = max(arr) return [x for x in arr if (min_lim is None or x >= min_lim) and (max_lim is None or x <= max_lim)]"},{"question":"# Flip Bit to Win: Maximize Sequence of 1s You are working as a software developer, and one of your tasks in an optimization project involves fine-tuned bit manipulations. Your current task is to find the longest sequence of 1s that can be obtained by flipping exactly one bit from 0 to 1 in a given integer. This will help in certain performance-critical sections of the software where binary data is processed. Function Signature ```python def flip_bit_longest_seq(num: int) -> int: pass ``` Input: - `num`: An integer, representing the number whose bits will be analyzed. Output: - An integer, representing the length of the longest sequence of 1s that can be obtained by flipping exactly one bit from 0 to 1. Example: ```python assert flip_bit_longest_seq(1775) == 8 # 1775 in binary: 11011101111 assert flip_bit_longest_seq(15) == 5 # 15 in binary: 1111 assert flip_bit_longest_seq(0) == 1 # 0 in binary: 0 ``` Constraints: - You can expect the input to be a non-negative integer. - Ensure optimal performance, aiming for O(b) time complexity where b is the number of bits in the integer. Notes: - Analyze the binary representation of the input number and determine the optimal bit to flip for maximizing the sequence of continuous 1s. - Focus on bitwise operations for an efficient solution.","solution":"def flip_bit_longest_seq(num: int) -> int: Returns the length of the longest sequence of 1s that can be obtained by flipping exactly one bit from 0 to 1 in the binary representation of num. if num == -1: return 32 # If all bits are 1s, flipping any bit keeps it as 32 consecutive 1s if num == 0: return 1 # Flipping any bit in \'0\' results in at least one 1 current_length = 0 previous_length = 0 max_length = 1 # We can always flip at least one bit while num != 0: if (num & 1) == 1: # Current bit is 1 current_length += 1 else: # Current bit is 0 # Update to account for flipping the current 0 to a 1 previous_length = current_length if (num & 2) == 2 else 0 current_length = 0 max_length = max(previous_length + current_length + 1, max_length) num >>= 1 return max_length"},{"question":"Implement a function `extended_add_binary` which adds two binary strings and returns their sum as a binary string. The function should be optimized to handle very large binary strings efficiently. # Function Signature ```python def extended_add_binary(a: str, b: str) -> str: pass ``` # Input * `a` (str): A binary string of length n (1 ≤ n ≤ 10^6). * `b` (str): A binary string of length m (1 ≤ m ≤ 10^6). # Output * A binary string representing the sum of the input binary strings. # Constraints * Both input strings are non-empty and contain only characters \'0\' or \'1\'. * The sum of the two numbers will not overflow the allocated memory of the environment. # Performance Requirements * The function should run in O(max(n, m)) time complexity. * The function should use O(max(n, m)) additional space at most. # Example ```python assert extended_add_binary(\\"11\\", \\"1\\") == \\"100\\" assert extended_add_binary(\\"1010\\", \\"1011\\") == \\"10101\\" assert extended_add_binary(\\"1101\\", \\"101\\") == \\"10010\\" ``` # Notes * Think about edge cases such as when one of the strings is significantly longer than the other or when one of the strings is \\"0\\". * Consider using a list to collect bits and then converting to a string at the end for efficient handling of very large strings.","solution":"def extended_add_binary(a: str, b: str) -> str: # Initialize pointers for both strings starting from the end i, j = len(a) - 1, len(b) - 1 # Initialize variables to store the result and the carry carry = 0 result = [] # Iterate while there are digits left in any string or there is a carry left while i >= 0 or j >= 0 or carry: # Get binary values at current positions. If position is out of bounds, use 0 bit_a = int(a[i]) if i >= 0 else 0 bit_b = int(b[j]) if j >= 0 else 0 # Calculate the sum of current bits and the carry total = bit_a + bit_b + carry # Append current bit to result (0 or 1) result.append(str(total % 2)) # Update carry (0 or 1) carry = total // 2 # Move to the next significant bit i -= 1 j -= 1 # Reverse the result list to get the correct order and join to a string return \'\'.join(reversed(result))"},{"question":"# Exponentiation by Squaring **Objective**: Implement a function that calculates (a^n mod m) efficiently using binary exponentiation. **Problem Statement**: You are given three integers (a), (n), and (m). Write two functions `power_iter(a, n, m)` and `power_recur(a, n, m)` to calculate (a^n mod m) using: 1. An iterative method 2. A recursive method Both functions should utilize the concept of binary exponentiation to achieve (O(log n)) time complexity. **Function Definitions**: ```python def power_iter(a: int, n: int, m: int) -> int: # Write your code here def power_recur(a: int, n: int, m: int) -> int: # Write your code here ``` **Input**: - (a): an integer ((1 leq a leq 10^9)) - (n): an integer ((0 leq n leq 10^9)) - (m): an integer ((1 leq m leq 10^9)) **Output**: - Both functions should return an integer which is the result of (a^n mod m). **Constraints**: - You must use binary exponentiation methods to achieve (O(log n)) time complexity. - For the recursive function, ensure to handle stack overflows or maximum recursion depth issues. **Example**: ```python power_iter(2, 10, 1000) # Output: 24 power_recur(2, 10, 1000) # Output: 24 ``` # Additional Information: You may assume that Python\'s built-in integer arithmetic can handle large numbers, but be cautious with performance when handling values up to (10^9).","solution":"def power_iter(a: int, n: int, m: int) -> int: Calculate a^n % m using an iterative binary exponentiation method. result = 1 a = a % m while n > 0: if n % 2 == 1: # If n is odd, multiply a with result result = (result * a) % m n = n // 2 # Divide n by 2 a = (a * a) % m # Square a return result def power_recur(a: int, n: int, m: int) -> int: Calculate a^n % m using a recursive binary exponentiation method. if n == 0: return 1 a = a % m half_power = power_recur(a, n // 2, m) half_power = (half_power * half_power) % m if n % 2 != 0: half_power = (half_power * a) % m return half_power"},{"question":"# Question: **Cycle Sort Implementation** You are required to implement a function that performs cycle sort on a given list of integers. The function should sort the list in ascending order using the cycle sort algorithm and return the sorted list. Cycle sort operates based on identifying cycles in the array and rotating elements of these cycles to their correct position. The goal of this exercise is to ensure you understand the intricacies of the cycle sort algorithm and its in-place sorting mechanism. Function Signature ```python def cycle_sort(arr: List[int]) -> List[int] ``` Input * An unsorted list of integers `arr` with length N, where 1 <= N <= 1000. Output * A list of integers sorted in ascending order. Constraints * The list can contain negative and positive numbers as well as zero. * You must use the cycle sort mechanism. * Aim for in-place sorting with O(1) space complexity. Example ```python print(cycle_sort([3, 1, 2])) # Output: [1, 2, 3] print(cycle_sort([4, 2, 5, 1, 3])) # Output: [1, 2, 3, 4, 5] ``` Notes * Make sure to handle edge cases such as arrays with a single element, arrays that are already sorted, and arrays containing duplicate elements. * Analyze the inherent cycle rotations carefully to avoid infinite loops and ensure all elements are correctly placed. You are encouraged to write unit tests for your function to verify the correctness before submission. --- Performance Requirements * The function should work efficiently for input size up to 1000 elements.","solution":"def cycle_sort(arr): Sorts the input list `arr` using cycle sort algorithm. Returns the sorted list. n = len(arr) # Loop through the array to find cycles to rotate. for start in range(n - 1): item = arr[start] pos = start # Find where to put the item. for i in range(start + 1, n): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == start: continue # Skip duplicates. while item == arr[pos]: pos += 1 # Put the item to its right position arr[pos], item = item, arr[pos] # Rotate the rest of the cycle while pos != start: pos = start for i in range(start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"**Context**: You are tasked with building a word frequency analyzer to assist in text-based studies. For this task, you will write a function that computes the frequency of each word in a given list of strings. Please note that words should be treated case-insensitively. **Problem Statement**: Write a function `word_histogram(text_list: List[str]) -> Dict[str, int]` that returns a histogram representing the frequency of each word in the given list. The comparison should be case-insensitive, meaning \\"Apple\\" and \\"apple\\" should be treated as the same word. **Input Format**: * A list of strings, `text_list`, where each string represents a word. Example: `[\\"apple\\", \\"banana\\", \\"Apple\\", \\"banana\\", \\"apple\\", \\"Cherry\\"]` **Output Format**: * A dictionary containing the frequency of each word in the list. Words should be keys, and their counts should be values. **Constraints**: * The length of `text_list` will not exceed 10^6. * Each string in `text_list` will contain only alphabetical characters and will have a length of 1 to 100 characters. **Performance Requirements**: * The solution should run in linear time relative to the length of `text_list`. **Example**: ```python text_list = [\\"apple\\", \\"banana\\", \\"Apple\\", \\"banana\\", \\"apple\\", \\"Cherry\\"] word_histogram(text_list) # Expected output: {\\"apple\\": 3, \\"banana\\": 2, \\"cherry\\": 1} ``` **Edge Cases**: * An empty list should return an empty dictionary: `word_histogram([]) -> {}` * A list with identical elements should return a dictionary with one key-value pair. **Implementation Note**: Consider using a case normalization strategy like converting all words to lower case before updating their frequency count.","solution":"from typing import List, Dict def word_histogram(text_list: List[str]) -> Dict[str, int]: Computes the frequency of each word in the given list of strings. The comparison is case-insensitive. histogram = {} for word in text_list: word_lower = word.lower() if word_lower in histogram: histogram[word_lower] += 1 else: histogram[word_lower] = 1 return histogram"},{"question":"# Quick Sort Implementation and Analysis Scenario You are provided with a partially implemented version of the Quick Sort algorithm. This implementation includes a `quick_sort` function that sorts an array using the Quick Sort strategy and an option to print the intermediate steps. Your task is to complete the given implementation by ensuring it correctly sorts the input array, handles edge cases effectively, and adheres to specified performance requirements. Function Definition You need to implement the function `quick_sort` which sorts an array: ```python def quick_sort(arr, simulation=False): Sorts the array \'arr\' using Quick Sort algorithm. Optionally, if \'simulation\' is True, prints intermediate arrays at each step of recursion. Parameters: - arr: List[int]. A list of integers to be sorted. - simulation: bool. A flag to indicate whether to print simulation steps (default is False). Returns: - List[int]. Sorted list. ``` Input - A list of integers `arr` where 0 <= len(arr) <= 10^5. - A boolean `simulation`. If True, each step of partitioning should be printed in the format `\\"iteration X : a b c ...\\"`. Output - Return the sorted list of integers. Constraints - Your solution should use in-place sorting. - Optimize to avoid the worst-case time complexity whenever possible. - Ensure efficient handling and testing of edge cases. Performance Requirements - Target average-case time complexity of O(n log(n)). - Space complexity should aim for O(log(n)) due to recursion depth. Example ```python >>> quick_sort([3, 2, 1, 5, 4], simulation=True) iteration 0 : 3 2 1 5 4 iteration 1 : 1 2 3 5 4 iteration 2 : 1 2 3 4 5 [1, 2, 3, 4, 5] >>> quick_sort([10, 7, 8, 9, 1, 5], simulation=False) [1, 5, 7, 8, 9, 10] ``` Notes: - Pay careful attention to choosing an appropriate pivot and handling recursion efficiently. - Test with both already sorted and completely unsorted arrays to ensure robustness.","solution":"def quick_sort(arr, simulation=False): Sorts the array \'arr\' using Quick Sort algorithm. Optionally, if \'simulation\' is True, prints intermediate arrays at each step of recursion. Parameters: - arr: List[int]. A list of integers to be sorted. - simulation: bool. A flag to indicate whether to print simulation steps (default is False). Returns: - List[int]. Sorted list. def partition(low, high, depth): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] if simulation: print(f\\"iteration {depth} : {\' \'.join(map(str, arr))}\\") return i + 1 def quick_sort_recursive(low, high, depth): if low < high: pi = partition(low, high, depth) quick_sort_recursive(low, pi - 1, depth + 1) quick_sort_recursive(pi + 1, high, depth + 1) if arr: quick_sort_recursive(0, len(arr) - 1, 0) return arr"},{"question":"# Context: Quick Sort is an efficient, in-place sorting algorithm known for its (O(n log n)) average-case time complexity. Your task is to implement an optimized version of Quick Sort that aims to avoid the worst-case performance by employing the \'median-of-three\' rule for selecting the pivot element. # Task: Write a function `optimized_quick_sort(arr: List[int], simulation: bool = False)` that sorts an array of integers using the Quick Sort algorithm. The function should enhance the pivot selection by using the median-of-three rule and provide an option to print the state of the array at each iteration if `simulation = True`. # Requirements: - **Input**: - `arr` (List[int]): The array of integers to be sorted. - `simulation` (bool): If true, print the array state at each iteration. - **Output**: - A list of integers sorted in ascending order. - **Constraints**: - The array contains at most (10^6) integers. - Elements of the array are all integers within the range (-10^9) to (10^9). # Instructions: 1. **Median-of-three pivot selection**: - For selecting a pivot, consider the first, middle, and last elements of the array and pick the median of these three as the pivot. 2. **Simulation mode**: - When `simulation` is True, print the iteration and array state. 3. **In-place sorting**: - Modify the array in place without using additional storage. # Example: ```python def optimized_quick_sort(arr: List[int], simulation: bool = False) -> List[int]: # Implementation goes here # Usage: print(optimized_quick_sort([3, 6, 8, 10, 1, 2, 1], simulation=True)) # Expected Output while printing array states: # iteration 1: [1, 2, 1, 3, 6, 8, 10] # iteration 2: [1, 1, 2, 3, 6, 8, 10] # ... # Final sorted array: [1, 1, 2, 3, 6, 8, 10] print(optimized_quick_sort([1, 1, 1, 1], simulation=False)) # Expected Final sorted array: [1, 1, 1, 1] ```","solution":"from typing import List def optimized_quick_sort(arr: List[int], simulation: bool = False) -> List[int]: if len(arr) <= 1: return arr def median_of_three(a, b, c): return sorted([a, b, c])[1] def quick_sort_helper(arr, low, high, depth=0): if low < high: pivot_index = partition(arr, low, high) if simulation: print(f\\"iteration {depth + 1}: {arr}\\") quick_sort_helper(arr, low, pivot_index - 1, depth + 1) quick_sort_helper(arr, pivot_index + 1, high, depth + 1) def partition(arr, low, high): mid = (low + high) // 2 pivot = median_of_three(arr[low], arr[mid], arr[high]) pivot_index = arr.index(pivot) arr[pivot_index], arr[high] = arr[high], arr[pivot_index] pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 quick_sort_helper(arr, 0, len(arr) - 1) return arr"},{"question":"# Interpolation Search Assessment Question As an advisor for a company\'s data retrieval system, you are tasked with optimizing the search operations on their database. The database stores large arrays of uniformly distributed integers. Given a sorted array of integers and a search key, you are to implement the Interpolation Search algorithm to efficiently locate the position of the search key within the array. Function Signature ```python def interpolation_search(array: List[int], search_key: int) -> int: ``` Input - `array`: A list of sorted integers in ascending order. (1 <= len(array) <= 10^6) - `search_key`: An integer to be searched for in the array. (-10^9 <= search_key <= 10^9) Output - Returns the index of the `search_key` in the array if it is found. - Returns -1 if the `search_key` is not in the array. Constraints - Assume the array is uniformly distributed. - The search operation needs to be efficient, leveraging the given distribution. Examples ```python assert interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) == 2 assert interpolation_search([5, 10, 12, 14, 17, 20, 21], 55) == -1 assert interpolation_search([5, 10, 12, 14, 17, 20, 21], -5) == -1 ``` Notes - Pay close attention to edge cases, including an empty array or arrays with only one element. - Ensure the implementation does not result in a division by zero. - Aim to achieve the average time complexity of O(log log n) for uniformly distributed arrays.","solution":"from typing import List def interpolation_search(array: List[int], search_key: int) -> int: Perform interpolation search on the given sorted array to find the search_key. Parameters: - array: List[int] : a list of sorted integers - search_key: int : the integer value to be searched in the array Returns: - int : the index of the search_key in the array if found, otherwise -1 low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 # Probing the position with keeping uniform distribution in mind pos = low + ((search_key - array[low]) * (high - low) // (array[high] - array[low])) if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"Question: Implement Enhanced Nearest Neighbor Classifier # Scenario You are building a classification tool that uses the nearest neighbor algorithm to categorize items based on their features. However, the initial implementation is quite basic and needs improvements to handle additional considerations. Your task is to enhance this implementation to support weighted distances and perform pre-checks for data validation. # Task Write a function `enhanced_nearest_neighbor(x, tSet, w)` that: 1. **Takes the following inputs:** - `x`: A tuple representing the feature vector of the item to classify. - `tSet`: A dictionary where each key is a tuple representing a feature vector and the corresponding value is the class/label for that vector. - `w`: A tuple of weights corresponding to the significance of each feature in the distance calculation. 2. **Returns the class/label of the nearest neighbor based on a weighted Euclidean distance measure.** # Requirements 1. Implement a modified `distance` function to use weights for each feature. 2. Validate inputs to ensure: - `x`, `tSet` keys, and `w` are all tuples of the same length. - The training set dictionary and weights tuple are not empty. 3. Make sure to handle edge cases and potential error scenarios effectively. # Input and Output Format - **Input**: - `x`: Tuple (e.g., `(1.0, 2.0, 3.5)`) - `tSet`: Dictionary (`{(1.1, 2.1, 3.6): \'A\', (4.5, 1.1, 0.0): \'B\'}`) - `w`: Tuple (e.g., `(0.5, 1.0, 1.5)`) - **Output**: The label (e.g., `\'A\'` or `\'B\'`) # Example Input: ```python x = (1.0, 2.0, 3.0) tSet = {(1.1, 2.1, 3.1): \'Cat\', (4.5, 1.1, 0.5): \'Dog\'} w = (1.0, 1.0, 1.0) ``` Output: ```python \'Cat\' ``` # Constraints - The lengths of `x`, any key in `tSet`, and `w` should be the same. - Sizes of `x` and `w` are <= 100 - Training set maximum size is 10,000 # Performance Requirements Your solution should handle the largest input sizes within a reasonable timeframe. Explorations of alternate data structures or algorithms to improve performance should be discussed or partially implemented.","solution":"import math def enhanced_nearest_neighbor(x, tSet, w): Classifies an item based on its feature vector `x` using nearest neighbor with weighted Euclidean distance. Parameters: x (tuple): Feature vector of the item to classify. tSet (dictionary): Training set with feature vectors as keys and classes/labels as values. w (tuple): Weights for each feature in distance calculation. Returns: The class/label of the nearest neighbor. # Check input validity if not isinstance(x, tuple) or not x: raise ValueError(\\"Feature vector x must be a non-empty tuple.\\") if not isinstance(tSet, dict) or not tSet: raise ValueError(\\"Training set tSet must be a non-empty dictionary.\\") if not isinstance(w, tuple) or not w: raise ValueError(\\"Weights w must be a non-empty tuple.\\") if not all(isinstance(k, tuple) and len(k) == len(x) for k in tSet.keys()): raise ValueError(\\"All keys in tSet must be tuples of the same length as x.\\") if len(w) != len(x): raise ValueError(\\"Weights tuple w must be of the same length as x.\\") # Helper function to calculate weighted Euclidean distance def weighted_distance(vec1, vec2, weights): return math.sqrt(sum(weights[i] * (vec1[i] - vec2[i]) ** 2 for i in range(len(vec1)))) min_distance = float(\'inf\') nearest_label = None for feature_vector, label in tSet.items(): dist = weighted_distance(x, feature_vector, w) if dist < min_distance: min_distance = dist nearest_label = label return nearest_label"},{"question":"# String Matching with Enhanced Error Handling Implement an enhanced version of the Knuth-Morris-Pratt (KMP) string matching algorithm. Your task is to write a function `kmp_search_with_validation` that: 1. Enhances the provided `knuth_morris_pratt` algorithm by handling additional edge cases and validating inputs. 2. If the text or pattern is empty, it should return an empty list. 3. If the pattern is longer than the text, it should return an empty list. 4. Ensure the function works correctly with overlapping patterns. Function Signature ```python from typing import Sequence, List def kmp_search_with_validation(text: Sequence, pattern: Sequence) -> List[int]: pass ``` Input - `text`: A sequence of characters (string). - `pattern`: A sequence of characters (string). Output - A list of starting indices where the pattern is found in the text. Constraints - You can assume that text and pattern only contain lowercase alphabetical characters. - The maximum length of the text and pattern will be 1,000,000. Examples ```python assert kmp_search_with_validation(\\"hello there hero!\\", \\"he\\") == [0, 7, 12] assert kmp_search_with_validation(\\"\\", \\"a\\") == [] assert kmp_search_with_validation(\\"a\\", \\"\\") == [] assert kmp_search_with_validation(\\"abxabcabcaby\\", \\"abcaby\\") == [6] assert kmp_search_with_validation(\\"aaaaa\\", \\"aa\\") == [0, 1, 2, 3] ``` Hints 1. Use the provided `knuth_morris_pratt` code as a basis, but add necessary checks for edge cases. 2. Modify the preprocessing step to handle patterns correctly, even when they overlap.","solution":"from typing import Sequence, List def compute_lps(pattern: Sequence) -> List[int]: Compute the longest prefix suffix (LPS) array used to skip characters while matching. lps = [0] * len(pattern) j = 0 # length of the previous longest prefix suffix for i in range(1, len(pattern)): while j > 0 and pattern[i] != pattern[j]: j = lps[j-1] if pattern[i] == pattern[j]: j += 1 lps[i] = j else: lps[i] = 0 return lps def kmp_search_with_validation(text: Sequence, pattern: Sequence) -> List[int]: Enhanced version of the KMP string matching algorithm with validation. Finds all occurrences of the pattern in the text. if len(pattern) == 0 or len(text) == 0 or len(pattern) > len(text): return [] lps = compute_lps(pattern) result = [] i = 0 # index for text j = 0 # index for pattern while i < len(text): if text[i] == pattern[j]: i += 1 j += 1 if j == len(pattern): result.append(i - j) j = lps[j-1] elif i < len(text) and text[i] != pattern[j]: if j != 0: j = lps[j-1] else: i += 1 return result"},{"question":"You are to implement a feature enhancement to the `SeparateChainingHashTable` to dynamically handle resizing. Specifically, your task is to extend the existing hash table implementation so that it periodically resizes itself when the load factor exceeds a certain threshold (default: 0.75). # Inputs - A series of key-value pairs to be inserted into the hash table. - Several queries to either retrieve, insert, or delete a key. # Outputs - Responses to retrieval operations: corresponding values associated with the keys. - Updated hash table after deletions or insertions. # Constraints - Initially, the hash table size should be 11. - Hash table should resize itself (i.e., double its size and rehash its contents) when the load factor exceeds 0.75. # Function Signatures ```python class HashTableWithResizing(SeparateChainingHashTable): def __init__(self, size=11): super().__init__(size) self.load_factor_threshold = 0.75 # Change this threshold to set different resizing policies def put(self, key, value): # Implement the resizing logic here followed by the insert. pass def resize(self, new_size): # Perform the resizing and rehashing of your hash table elements here. pass ``` # Example ```python # Initialize your hash table hash_table = HashTableWithResizing() # Insert elements hash_table.put(\\"a\\", 1) hash_table.put(\\"b\\", 2) hash_table.put(\\"c\\", 3) hash_table.put(\\"d\\", 4) print(len(hash_table)) # Should reflect 4 # This should trigger resizing when the load factor exceeds the threshold. hash_table.put(\\"e\\", 5) # Retrieve elements print(hash_table.get(\\"a\\")) # Outputs: 1 print(hash_table.get(\\"e\\")) # Outputs: 5 # Delete elements del hash_table[\\"a\\"] print(hash_table.get(\\"a\\")) # Outputs: None ``` # Notes - Thoroughly test your implementation, including handling edge cases like resizing while deleting elements or high collision cases. - Ensure get, put, and delete operations maintain average-case O(1) performance even after resizing.","solution":"class ListNode: def __init__(self, key, value): self.key = key self.value = value self.next = None class SeparateChainingHashTable: def __init__(self, size=11): self.size = size self.buckets = [None] * size self.count = 0 def hash(self, key): return hash(key) % self.size def put(self, key, value): index = self.hash(key) head = self.buckets[index] # Check if key exists and update current = head while current: if current.key == key: current.value = value return current = current.next # If key does not exist, insert at head new_node = ListNode(key, value) new_node.next = head self.buckets[index] = new_node self.count += 1 def get(self, key): index = self.hash(key) current = self.buckets[index] while current: if current.key == key: return current.value current = current.next return None def delete(self, key): index = self.hash(key) current = self.buckets[index] prev = None while current: if current.key == key: if prev: prev.next = current.next else: self.buckets[index] = current.next self.count -= 1 return prev = current current = current.next def __len__(self): return self.count class HashTableWithResizing(SeparateChainingHashTable): def __init__(self, size=11): super().__init__(size) self.load_factor_threshold = 0.75 def put(self, key, value): if (self.count + 1) / self.size > self.load_factor_threshold: self.resize(2 * self.size) super().put(key, value) def resize(self, new_size): old_buckets = self.buckets self.size = new_size self.buckets = [None] * new_size self.count = 0 for bucket in old_buckets: current = bucket while current: self.put(current.key, current.value) current = current.next"},{"question":"Scenario: You have been tasked with analyzing network latency in a hierarchical server setup represented as a binary tree. Each server node can have up to two child servers. The height of the tree represents the longest path from the main server to the farthest node, which helps in determining the worst-case latency scenario. Problem Statement: Write a function `height` that calculates the height of a given binary search tree. The height is defined as the number of levels from the root node to the farthest leaf. Function Signature: ```python def height(root: Node) -> int: pass ``` Input: * `root` (Node): The root node of the binary search tree. Output: * An integer representing the height of the tree. Constraints: * The number of nodes in the binary search tree will be between 0 and 10^4. * The values of the nodes are unique integers. Performance Requirements: * Your solution should have a time complexity of O(n) and a space complexity of O(h), where n is the number of nodes and h is the height of the tree. Example: ```python class Node: def __init__(self, key): self.left = None self.right = None self.val = key # Example tree: # 9 # / # 6 12 # / / # 3 8 10 15 # # 7 18 root = Node(9) root.left = Node(6) root.right = Node(12) root.left.left = Node(3) root.left.right = Node(8) root.right.left = Node(10) root.right.right = Node(15) root.left.right.left = Node(7) root.right.right.right = Node(18) print(height(root)) # Output: 4 ``` Hints: * Consider using recursion to simplify the tree traversal and height calculation. Unit Tests: Ensure you provide unit tests to validate your implementation. For example: ```python import unittest class TestHeight(unittest.TestCase): def setUp(self): self.root = Node(9) self.root.left = Node(6) self.root.right = Node(12) self.root.left.left = Node(3) self.root.left.right = Node(8) self.root.right.left = Node(10) self.root.right.right = Node(15) self.root.left.right.left = Node(7) self.root.right.right.right = Node(18) def test_empty_tree(self): self.assertEqual(height(None), 0) def test_single_node_tree(self): self.assertEqual(height(Node(5)), 1) def test_height(self): self.assertEqual(height(self.root), 4) if __name__ == \'__main__\': unittest.main() ```","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key def height(root: Node) -> int: Returns the height of the given binary search tree. if root is None: return 0 left_height = height(root.left) right_height = height(root.right) return max(left_height, right_height) + 1"},{"question":"# Balanced Binary Tree Check Context In robotics, controlling movement using decision trees ensures balanced weight distribution across robot limbs. For optimal control, we need to verify that these decision trees maintain a balanced structure. This ensures quick and consistent decision-making in robot movements. Given a binary tree, implement a function to check whether it is height-balanced. A height-balanced binary tree is defined as a binary tree in which the depth (height) of the two subtrees of every node never differs by more than 1. Function Signature ```python def is_balanced(root: TreeNode) -> bool: pass ``` Input - `root`: A `TreeNode` object representing the root of the binary tree. Each `TreeNode` has attributes `left` and `right` which point to its child nodes and a `val` attribute representing its value. Output - Returns `True` if the tree is balanced, otherwise returns `False`. Constraints 1. The number of nodes in the tree can be up to 10^4. 2. Node values can be any integer. 3. Function should be optimized to run in O(N) time complexity. Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example Tree 1: Balanced # 1 # / # 2 2 # / # 3 3 node1 = TreeNode(1) node2 = TreeNode(2) node3 = TreeNode(2) node4 = TreeNode(3) node5 = TreeNode(3) node1.left = node2 node1.right = node3 node2.left = node4 node2.right = node5 assert is_balanced(node1) == True # Example Tree 2: Not Balanced # 1 # / # 2 2 # / # 3 # / # 4 node6 = TreeNode(1) node7 = TreeNode(2) node8 = TreeNode(2) node9 = TreeNode(3) node10 = TreeNode(4) node6.left = node7 node6.right = node8 node7.left = node9 node9.left = node10 assert is_balanced(node6) == False ``` Additional Notes - Focus on writing a time-efficient solution. - Make sure to handle edge cases such as empty trees and trees with only one node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: Determines if the binary tree is height-balanced. def check(node): if not node: return 0, True left_height, left_balanced = check(node.left) right_height, right_balanced = check(node.right) current_height = 1 + max(left_height, right_height) current_balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return current_height, current_balanced _, balanced = check(root) return balanced"},{"question":"# Task: Implement a ZigZagIterator for K lists **Scenario**: You are given `k` lists of integers (where `k >= 2`). Create an iterator that alternates between elements from these lists in a zigzag fashion. The iterator should continue to traverse all lists until every list is exhausted. The elements should be fetched in a \\"round-robin\\" style across all lists. # Function Signature: ```python class ZigZagIteratorK: def __init__(self, lists: List[List[int]]): Initialize your data structure here. :type lists: List[List[int]] def next(self) -> int: :rtype: int def has_next(self) -> bool: :rtype: bool # Example Usage lists = [[1, 2, 3], [4, 5, 6, 7], [8, 9]] it = ZigZagIteratorK(lists) output = [] while it.has_next(): output.append(it.next()) print(output) # Output should be [1, 4, 8, 2, 5, 9, 3, 6, 7] ``` # Input and Output: * **Input**: A list of `k` lists of integers. * **Output**: An integer representing the next element in zigzag order. * **Constraints**: * Each sublist can have variable length. * No list will be null. # Performance Requirements: * The solution should efficiently manage multiple lists and operate within linear time relative to the total number of elements.","solution":"from collections import deque from typing import List class ZigZagIteratorK: def __init__(self, lists: List[List[int]]): Initialize your data structure here. :type lists: List[List[int]] self.queue = deque() for i, lst in enumerate(lists): if lst: # only add non-empty lists self.queue.append((i, 0)) # each entry is a tuple (list_index, element_index) self.lists = lists def next(self) -> int: :rtype: int if self.has_next(): list_index, elem_index = self.queue.popleft() value = self.lists[list_index][elem_index] if elem_index + 1 < len(self.lists[list_index]): self.queue.append((list_index, elem_index + 1)) return value raise StopIteration(\\"No more elements\\") def has_next(self) -> bool: :rtype: bool return bool(self.queue)"},{"question":"# Scenario: As a data scientist, you often need to invert matrices as part of your work with linear transformations and various algorithms. Implementing a matrix inversion function requires meticulous handling of edge cases and computational efficiency. Your task is to implement a function to invert an n x n matrix, considering the possible edge cases and ensuring that your function is optimized for performance. # Task: Implement the function `invert_matrix(m)` which takes an n x n matrix `m` and returns its inverse. Your implementation should handle edge cases and validate the input matrix properly. # Input: - A two-dimensional list `m` representing an n x n matrix. - Each element `m[i][j]` is an integer or a float. - The matrix will be at least 2x2 in size. # Output: - The function should return a two-dimensional list representing the inverted matrix if the input matrix is valid and invertible. - If the input matrix is invalid or not invertible, the function should return: - `[[ -1 ]]` for non-matrix input. - `[[ -2 ]]` for non-square matrix. - `[[ -3 ]]` for too small matrix. - `[[ -4 ]]` for singular matrix (determinant = 0). # Constraints: - You can assume that the input matrix contains only integers or floating-point numbers. - Do not use any built-in Python libraries or functions that directly compute the matrix inverse. # Examples: ```python # Example 1: matrix_2x2 = [[4, 7], [2, 6]] print(invert_matrix(matrix_2x2)) # Expected output: [[0.6, -0.7], [-0.2, 0.4]] # Example 2: matrix_3x3 = [[1, 2, 3], [0, 1, 4], [5, 6, 0]] print(invert_matrix(matrix_3x3)) # Expected output: # [[-24, 18, 5], # [20, -15, -4], # [-5, 4, 1]] # Example 3: invalid_matrix = [[1, 2], [3, 4, 5]] print(invert_matrix(invalid_matrix)) # Expected output: [[-2]] singular_matrix = [[1, 2], [2, 4]] print(invert_matrix(singular_matrix)) # Expected output: [[-4]] ``` # Notes: - Ensure that the solution is readable and well-documented with comments. - Optimize your algorithm wherever possible, especially for larger matrices. - Include validation checks and handle all edge cases gracefully.","solution":"def invert_matrix(m): def matrix_is_square(matrix): return all(len(row) == len(matrix) for row in matrix) def matrix_is_valid(matrix): return isinstance(matrix, list) and all(isinstance(row, list) and all(isinstance(ele, (int, float)) for ele in row) for row in matrix) def matrix_is_singular(matrix): det = determinant(matrix) return det == 0 def determinant(matrix): # Base case for 2x2 matrix: if len(matrix) == 2 and len(matrix[0]) == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] det = 0 for c in range(len(matrix)): det += ((-1) ** c) * matrix[0][c] * determinant(get_minor(matrix, 0, c)) return det def get_minor(matrix, i, j): return [row[:j] + row[j+1:] for row in (matrix[:i] + matrix[i+1:])] def invert(matrix): det = determinant(matrix) if det == 0: return [[-4]] if len(matrix) == 2: return [[matrix[1][1] / det, -1 * matrix[0][1] / det], [-1 * matrix[1][0] / det, matrix[0][0] / det]] cofactors = [] for r in range(len(matrix)): cofactorRow = [] for c in range(len(matrix)): minor = get_minor(matrix, r, c) cofactorRow.append(((-1) ** (r + c)) * determinant(minor)) cofactors.append(cofactorRow) cofactors = list(map(list, zip(*cofactors))) # Transpose the matrix for r in range(len(cofactors)): for c in range(len(cofactors)): cofactors[r][c] = cofactors[r][c] / det return cofactors if not matrix_is_valid(m): return [[-1]] # Invalid matrix if not matrix_is_square(m): return [[-2]] # Not a square matrix if len(m) < 2: return [[-3]] # Matrix too small if matrix_is_singular(m): return [[-4]] # Singular matrix, determinant is zero return invert(m)"},{"question":"# Scenario You are tasked with implementing and verifying the functionality of a min-heap, a pivotal data structure widely used in operations that need frequent minimum element retrieval, such as priority queues. # Task Implement a `MinHeap` class in Python that supports the following functionalities: 1. `insert(val)`: Inserts a value into the heap. 2. `remove_min()`: Removes and returns the minimum element from the heap. 3. `get_min()`: Returns the minimum element without removing it from the heap. 4. `is_empty()`: Checks if the heap is empty. # Requirements - Ensure that your implementation maintains the min-heap properties after each operation. - The `insert` and `remove_min` operations should have a time complexity of O(log N). - Raising appropriate exceptions for invalid operations, such as attempting to remove an element from an empty heap. # Expected Input and Output Formats - `insert(val: int) -> None`: Adds an integer value to the heap. - `remove_min() -> int`: Returns and removes the smallest element from the heap. Raise an exception if the heap is empty. - `get_min() -> int`: Returns the smallest element without removing it from the heap. Raise an exception if the heap is empty. - `is_empty() -> bool`: Returns `True` if the heap is empty, otherwise `False`. # Performance Requirements - Time complexity for `insert` and `remove_min` should be O(log N). - The space complexity should be O(N), where N is the number of elements in the heap. # Example ```python heap = MinHeap() heap.insert(4) heap.insert(50) heap.insert(7) heap.insert(55) heap.insert(90) heap.insert(87) print(heap.get_min()) # Output: 4 print(heap.remove_min()) # Output: 4 print(heap.get_min()) # Output: 7 ```","solution":"import heapq class MinHeap: def __init__(self): self.heap = [] def insert(self, val): heapq.heappush(self.heap, val) def remove_min(self): if self.is_empty(): raise IndexError(\\"remove_min from empty heap\\") return heapq.heappop(self.heap) def get_min(self): if self.is_empty(): raise IndexError(\\"get_min from empty heap\\") return self.heap[0] def is_empty(self): return len(self.heap) == 0"},{"question":"Given an array of integers `nums` where exactly two elements appear only once and all other elements appear exactly twice, write a function `find_unique_numbers` to identify these two unique elements. Your solution should be efficient and use bitwise operations. # Function Signature ```python def find_unique_numbers(nums: List[int]) -> List[int]: pass ``` # Input * `nums`: A list of integers where exactly two elements appear only once, and all others appear exactly twice. (1 ≤ len(nums) ≤ 10^5) # Output * A list containing the two unique elements. The order of elements in the result does not matter. # Constraints * Your solution must have a time complexity of O(N) and space complexity of O(1). # Example ```python nums = [1, 2, 1, 3, 2, 5] find_unique_numbers(nums) # Should return either [3, 5] or [5, 3] ``` # Notes * The two unique elements will always exist as per the problem constraints. * Utilize bitwise operations efficiently to ensure constant space usage. * Consider edge cases such as the smallest possible array and arrays with repeated elements.","solution":"from typing import List def find_unique_numbers(nums: List[int]) -> List[int]: # Step 1: XOR all elements to get xor of the two unique elements xor_result = 0 for num in nums: xor_result ^= num # Step 2: Find a bit that is set in xor_result # This bit must be set in one of the unique numbers and not the other diff_bit = xor_result & (-xor_result) # Step 3: Use this diff bit to split nums into two groups and find unique numbers num1, num2 = 0, 0 for num in nums: if num & diff_bit: num1 ^= num else: num2 ^= num return [num1, num2]"},{"question":"# Question: Implement a Dynamic Moving Average Class You are tasked with implementing a class `DynamicMovingAverage` that calculates the moving average of a stream of integers with a dynamic window size. Requirements: 1. The `DynamicMovingAverage` class should support BOTH fixed and variable window sizes dynamically. 2. It should provide methods to: - Append new numbers to the stream. - Adjust the window size dynamically. - Compute the moving average based on the current window size. Implementation: Implement the `DynamicMovingAverage` class with the following methods: 1. `__init__(self, initial_size) -> None`: Initializes the object with an initial window size. 2. `append(self, val: int) -> None`: Appends a new integer to the stream. 3. `set_window_size(self, size: int) -> None`: Sets the window size to a new value. 4. `calculate_average(self) -> float`: Returns the current moving average of the last `window_size` elements. If fewer elements are present, it computes the average of available elements. Constraints: - `set_window_size` should handle invalid values (e.g., zero or negative sizes) appropriately, raising an exception. - Make sure the implementation is efficient in terms of both time and space. Example: ```python dma = DynamicMovingAverage(3) dma.append(1) dma.append(10) print(dma.calculate_average()) # Output: 5.5 (average of [1, 10]) dma.append(3) print(dma.calculate_average()) # Output: 4.67 (average of [1, 10, 3]) dma.set_window_size(2) print(dma.calculate_average()) # Output: 6.5 (average of [10, 3]) dma.append(5) print(dma.calculate_average()) # Output: 4.0 (average of [3, 5]) ``` Note: The returned average should be a floating point number rounded to two decimal places.","solution":"from collections import deque class DynamicMovingAverage: def __init__(self, initial_size): # Ensure initial window size is valid if initial_size <= 0: raise ValueError(\\"Window size must be greater than zero.\\") self.window_size = initial_size self.stream = deque() self.current_sum = 0 def append(self, val: int) -> None: self.stream.append(val) self.current_sum += val # Maintain the window size by removing the oldest element if necessary if len(self.stream) > self.window_size: oldest_val = self.stream.popleft() self.current_sum -= oldest_val def set_window_size(self, size: int) -> None: # Ensure window size is valid if size <= 0: raise ValueError(\\"Window size must be greater than zero.\\") self.window_size = size # Adjust the current sum and the stream to reflect the new window size while len(self.stream) > self.window_size: oldest_val = self.stream.popleft() self.current_sum -= oldest_val def calculate_average(self) -> float: # Calculate the average based on current elements in the stream if not self.stream: return 0.0 return round(self.current_sum / len(self.stream), 2)"},{"question":"You are given a **sorted array** of integers and a target value. Your task is to implement a function that determines if the target value is present in the array. If present, return its index; otherwise, return -1. # Function Signature ```python def binary_search(nums: List[int], target: int) -> int: pass ``` # Input - `nums` (1 ≤ length of nums ≤ 10^4): A **sorted list** of integers. - `target`: An integer value to search for. # Output - Return the index of the target if found, otherwise return -1. # Constraints - The array is sorted in **ascending order**. - Achieve a time complexity of O(log n). # Example 1. **Input**: nums = [1, 2, 3, 4, 5, 6, 7, 8, 9], target = 4 **Output**: 3 2. **Input**: nums = [2, 3, 5, 7, 11, 13, 17, 23], target = 14 **Output**: -1 # Requirements - Implement both iterative and recursive versions. - Ensure edge cases are handled (e.g., empty array, array with one element, etc.).","solution":"from typing import List def binary_search(nums: List[int], target: int) -> int: Perform a binary search to find the index of target in nums. If target is not found, return -1. This implementation uses an iterative approach. left, right = 0, len(nums) - 1 while left <= right: mid = left + (right - left) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return -1 def binary_search_recursive(nums: List[int], target: int) -> int: Perform a binary search to find the index of target in nums. If target is not found, return -1. This implementation uses a recursive approach. def search(left: int, right: int) -> int: if left > right: return -1 mid = left + (right - left) // 2 if nums[mid] == target: return mid elif nums[mid] < target: return search(mid + 1, right) else: return search(left, mid - 1) return search(0, len(nums) - 1)"},{"question":"**Question:** You are tasked with creating a function that counts the number of digits in a given integer. This function should be efficient, operating in constant time regardless of the input size, and handle edge cases including zero and negative numbers correctly. # Function Signature The function signature should be: ```python def num_digits(n: int) -> int: ``` # Input - An integer `n` which can be positive, negative, or zero. # Output - An integer representing the number of digits in the absolute value of the input integer. # Constraints - The input number will be within the range of 32-bit signed integers (-2,147,483,648 to 2,147,483,647). # Example ```python >>> num_digits(123) 3 >>> num_digits(-4567) 4 >>> num_digits(0) 1 >>> num_digits(100000) 6 ``` # Requirements 1. Your implementation must use mathematical properties to determine the number of digits efficiently. 2. Ensure that your solution operates within O(1) time complexity. 3. Handle edge cases such as zero and negative inputs effectively. # Additional Context Think about how logarithms can help determine the number of digits. A logarithm in base 10 of a number \'n\' essentially gives you the power to which 10 must be raised to obtain that number. Using this property, you can deduce the number of digits in the number by slightly manipulating the result of the logarithm.","solution":"import math def num_digits(n: int) -> int: Returns the number of digits in the absolute value of the input integer n. if n == 0: return 1 return int(math.log10(abs(n))) + 1"},{"question":"# Question: Manipulate Binary Flags Context: In digital systems, binary flags are often used to manage and store multiple boolean states within a single integer. Efficient manipulation of these flags can be crucial for performance-sensitive applications. Your task is to implement functions to manipulate individual bits of an integer effectively. Task: Implement the following functions to perform specific bit operations: 1. `get_bit(num: int, i: int) -> bool`: - Get the value of the bit at index `i` in the integer `num`. 2. `set_bit(num: int, i: int) -> int`: - Set the bit at index `i` to 1 in the integer `num`. 3. `clear_bit(num: int, i: int) -> int`: - Clear the bit at index `i` to 0 in the integer `num`. 4. `update_bit(num: int, i: int, bit: int) -> int`: - Update the bit at index `i` to `bit` (which will be either 0 or 1) in the integer `num`. Input and Output: 1. **get_bit** - **Input**: An integer `num` and an integer `i`. - **Output**: A boolean value indicating whether the bit at index `i` is set (True) or not (False). 2. **set_bit** - **Input**: An integer `num` and an integer `i`. - **Output**: An integer with the bit at index `i` set to 1 in `num`. 3. **clear_bit** - **Input**: An integer `num` and an integer `i`. - **Output**: An integer with the bit at index `i` cleared to 0 in `num`. 4. **update_bit** - **Input**: An integer `num`, an integer `i`, and a bit value `bit` (0 or 1). - **Output**: An integer with the bit at index `i` updated to `bit`. Constraints: - The index `i` will be between 0 and 31 (both inclusive). - The bit value `bit` for `update_bit` will always be 0 or 1. - Assume a 32-bit signed integer representation for `num`. Example: ```python print(get_bit(5, 0)) # True (binary: 101) print(set_bit(5, 1)) # 7 (binary: 111) print(clear_bit(5, 2)) # 1 (binary: 001) print(update_bit(5, 1, 0)) # 5 (binary: 101 stays same as bit is already 0) ```","solution":"def get_bit(num: int, i: int) -> bool: Returns True if the bit at index i in num is 1, False otherwise. return (num & (1 << i)) != 0 def set_bit(num: int, i: int) -> int: Sets the bit at index i to 1 in num and returns the new integer. return num | (1 << i) def clear_bit(num: int, i: int) -> int: Clears the bit at index i to 0 in num and returns the new integer. return num & ~(1 << i) def update_bit(num: int, i: int, bit: int) -> int: Updates the bit at index i to bit value (either 0 or 1) in num and returns the new integer. mask = ~(1 << i) return (num & mask) | (bit << i)"},{"question":"You are given an integer n, and you need to find the n-th Fibonacci number. You must implement an efficient solution using dynamic programming and another using memoization to compare their performance and understand the principles behind these approaches. # Function Signature ```python def fib_dynamic(n: int) -> int: # Dynamic programming approach. O(n) time and O(n) space. pass def fib_memoization(n: int, memo: dict = {}) -> int: # Memoization approach. O(n) time and O(n) space. pass ``` # Input * `n` (1 ≤ n ≤ 10^5): An integer representing the position in the Fibonacci sequence. # Output * An integer representing the n-th Fibonacci number. # Constraints * Your solution should handle large inputs efficiently. * Implement error checking for invalid inputs. # Example ```python print(fib_dynamic(10)) # Output: 55 print(fib_memoization(10)) # Output: 55 print(fib_dynamic(100)) # Output: 354224848179261915075 print(fib_memoization(100)) # Output: 354224848179261915075 ``` # Evaluation Criteria * Correctness: Ensure the functions return correct Fibonacci numbers. * Efficiency: Ensure the time and space complexity adhere to the requirements. * Edge cases: Proper handling of edge cases and invalid inputs. * Documentation: Clear comments and explanation of the code logic.","solution":"def fib_dynamic(n: int) -> int: Calculates the n-th Fibonacci number using dynamic programming. Parameters: - n: An integer representing the position in the Fibonacci sequence. (1 ≤ n ≤ 10^5) Returns: - The n-th Fibonacci number. if n < 1: raise ValueError(\\"Input must be a positive integer.\\") if n == 1 or n == 2: return 1 dp = [0] * (n + 1) dp[1] = dp[2] = 1 for i in range(3, n + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[n] def fib_memoization(n: int, memo: dict = None) -> int: Calculates the n-th Fibonacci number using memoization. Parameters: - n: An integer representing the position in the Fibonacci sequence. (1 ≤ n ≤ 10^5) Returns: - The n-th Fibonacci number. if n < 1: raise ValueError(\\"Input must be a positive integer.\\") if memo is None: memo = {} if n in memo: return memo[n] if n == 1 or n == 2: return 1 memo[n] = fib_memoization(n - 1, memo) + fib_memoization(n - 2, memo) return memo[n]"},{"question":"Context: You are developing an optimized dynamic data structure for a database indexing system, where efficient insertions, deletions, and searches are crucial for performance. You decide to implement an AVL tree, given its self-balancing properties that guarantee O(log n) operations. Task: Write an implementation for an AVL Tree that supports the core operations: insertion, deletion, and in-order traversal. Your task is divided into two main steps: completing the deletion method and modifying the existing insertion method to handle duplicate keys (ignore duplicates). Specifications: * **Class Name**: `AVLTree` * **Methods**: * `insert(self, key: int) -> None`: Inserts a key into the tree. If the key already exists, it should be ignored. * `delete(self, key: int) -> None`: Removes a key from the tree. If the key does not exist, no action is taken. * `in_order_traverse(self) -> List[int]`: Returns the list of keys in in-order traversal order. * **TreeNode Class**: You may assume a `TreeNode` class is provided, with attributes `val`, `left`, and `right`. ```python Imports TreeNodes from tree.tree import TreeNode class AVLTree: def __init__(self): self.node = None self.height = -1 self.balance = 0 def insert(self, key: int) -> None: Insert new key into node # Your code to handle insertion with AVL rebalancing here def delete(self, key: int) -> None: Remove key from tree, maintaining AVL properties # Your deletion code here def in_order_traverse(self) -> List[int]: In-order traversal of the tree. result = [] if self.node: result.extend(self.node.left.in_order_traverse()) result.append(self.node.val) result.extend(self.node.right.in_order_traverse()) return result ``` **Constraints:** * Values for nodes are unique integers. * The tree should consistently maintain AVL height-balanced properties. * You need to ensure O(log n) complexity for insertion and deletion operations. **Example:** ```python avl = AVLTree() avl.insert(1) avl.insert(2) avl.insert(3) print(avl.in_order_traverse()) # Output: [1, 2, 3] avl.delete(2) print(avl.in_order_traverse()) # Output: [1, 3] ```","solution":"class TreeNode: def __init__(self, key: int): self.val = key self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self): self.root = None def insert(self, key: int) -> None: if not self.root: self.root = TreeNode(key) else: self.root = self._insert(self.root, key) def _insert(self, node: TreeNode, key: int) -> TreeNode: if not node: return TreeNode(key) if key < node.val: node.left = self._insert(node.left, key) elif key > node.val: node.right = self._insert(node.right, key) else: return node # duplicate keys are ignored node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and key < node.left.val: return self._rotate_right(node) if balance < -1 and key > node.right.val: return self._rotate_left(node) if balance > 1 and key > node.left.val: node.left = self._rotate_left(node.left) return self._rotate_right(node) if balance < -1 and key < node.right.val: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def delete(self, key: int) -> None: if self.root: self.root = self._delete(self.root, key) def _delete(self, node: TreeNode, key: int) -> TreeNode: if not node: return node if key < node.val: node.left = self._delete(node.left, key) elif key > node.val: node.right = self._delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp = self._get_min_value_node(node.right) node.val = temp.val node.right = self._delete(node.right, temp.val) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and self._get_balance(node.left) >= 0: return self._rotate_right(node) if balance > 1 and self._get_balance(node.left) < 0: node.left = self._rotate_left(node.left) return self._rotate_right(node) if balance < -1 and self._get_balance(node.right) <= 0: return self._rotate_left(node) if balance < -1 and self._get_balance(node.right) > 0: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def in_order_traverse(self) -> list: result = [] self._in_order_traverse(self.root, result) return result def _in_order_traverse(self, node: TreeNode, result: list) -> None: if node: self._in_order_traverse(node.left, result) result.append(node.val) self._in_order_traverse(node.right, result) def _rotate_left(self, z: TreeNode) -> TreeNode: y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _rotate_right(self, z: TreeNode) -> TreeNode: y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node: TreeNode) -> int: if not node: return 0 return node.height def _get_balance(self, node: TreeNode) -> int: if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _get_min_value_node(self, node: TreeNode) -> TreeNode: if node is None or node.left is None: return node return self._get_min_value_node(node.left)"},{"question":"# Problem Description You are given a positive integer `num`. Your task is to write a function that finds the next higher number which has the same set of digits as `num`. If no such number exists, return -1. # Function Signature ```python def next_higher_permutation(num: int) -> int: ``` # Input * A positive integer `num` within the range ( 1 leq num leq 10^9 ). # Output * Return an integer which is the next higher number with the same set of digits as `num`, or -1 if no such number exists. # Examples ```python next_higher_permutation(38276) # returns 38627 next_higher_permutation(99999) # returns -1 next_higher_permutation(12345) # returns 12354 next_higher_permutation(54321) # returns -1 next_higher_permutation(1528452) # returns 1528524 ``` # Constraints * You must solve the problem with O(n) time complexity where n is the number of digits. * Do not use any libraries or built-in functions apart from basic operations such as list manipulations, loops, and conditionals.","solution":"def next_higher_permutation(num: int) -> int: digits = list(str(num)) n = len(digits) # Step 1: Find the rightmost digit that is smaller than the digit to its right i = n - 2 while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 # If no such digit is found, return -1 as there is no higher permutation if i == -1: return -1 # Step 2: Find the smallest digit to the right of this digit that is larger than this digit j = n - 1 while digits[j] <= digits[i]: j -= 1 # Step 3: Swap these two digits digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the part of the sequence to the right of the original index digits = digits[:i+1] + digits[i+1:][::-1] # Convert back to integer and return return int(\\"\\".join(digits))"},{"question":"# Ternary Search Implementation You have been given the task of implementing a function that performs a ternary search on a sorted array to find the index of a given key. Function Signature ```python def ternary_search(arr: List[int], key: int) -> int: Perform a ternary search on the array to find the key. :param arr: List[int] - A list of sorted integers :param key: int - The integer value to find in the list :return: int - The index of the key if found; -1 if not found ``` Input * **arr**: A list of integers, sorted in ascending order. Length of the list can vary from 1 to 10^5. * **key**: An integer representing the value to be found in the array. Output * Return the index of the key if it is found in the array; otherwise, return -1. Constraints * The array `arr` will always be sorted in ascending order. * Try to achieve the best possible time complexity. Example ```python arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] key = 5 # Output: 4 arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] key = 11 # Output: -1 ``` Scenario Suppose you are building a search feature for a library\'s database system that frequently needs to search through sorted book IDs. Using ternary search, your goal is to find the index of a given book ID efficiently. **Your task** is to implement the `ternary_search` function that efficiently finds the index of a given `key` in the sorted array `arr`. Consider edge cases such as array bounds, non-existent elements, and various array sizes.","solution":"from typing import List def ternary_search(arr: List[int], key: int) -> int: Perform a ternary search on the array to find the key. :param arr: List[int] - A list of sorted integers :param key: int - The integer value to find in the list :return: int - The index of the key if found; -1 if not found def search(low, high): if low > high: return -1 third = (high - low) // 3 mid1 = low + third mid2 = high - third if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: return search(low, mid1 - 1) elif key > arr[mid2]: return search(mid2 + 1, high) else: return search(mid1 + 1, mid2 - 1) return search(0, len(arr) - 1)"},{"question":"# Detecting Cycles in Directed Graphs Objective Implement a function to determine whether a directed graph contains any cycles. Background Given a graph represented as a dictionary, you need to check for the presence of cycles in the graph. A cycle occurs when a path starting from a vertex eventually loops back to the same vertex. This can be critical in various applications such as detecting deadlocks in systems or resolving dependency issues. Function Signature ```python def contains_cycle(graph: Dict[int, List[int]]) -> bool: # Your code here ``` Input * `graph`: A dictionary where keys are vertices (integers) and values are lists of neighboring vertices (integers). * Example: ```python graph = { 0: [1, 2], 1: [2, 3], 2: [3], 3: [4], 4: [1] } ``` Output * **Returns**: A boolean value * `True` if the graph contains a cycle. * `False` if there is no cycle. Example * Input: ```python graph = { 0: [1], 1: [2], 2: [3], 3: [1] } ``` Output: `True` (A cycle exists: 1 -> 2 -> 3 -> 1) * Input: ```python graph = { 0: [1, 2], 1: [2], 2: [3], 3: [] } ``` Output: `False` (No cycle in the graph) Constraints * The vertex identifiers are unique integers. * The number of vertices and edges can each be up to 10^5. * The graph is represented as an adjacency list. # Edge Cases * An empty graph with no vertices. * Graphs with self-loops. * Large graphs to test efficiency and memory usage. Notes: * You should avoid using any built-in functions specifically designed for detecting cycles in graphs. * Ensure that your function is efficient and can handle the maximum input sizes within reasonable time limits.","solution":"from typing import List, Dict def contains_cycle(graph: Dict[int, List[int]]) -> bool: visited = set() rec_stack = set() def dfs(vertex): visited.add(vertex) rec_stack.add(vertex) for neighbor in graph.get(vertex, []): if neighbor not in visited: if dfs(neighbor): return True elif neighbor in rec_stack: return True rec_stack.remove(vertex) return False for node in graph: if node not in visited: if dfs(node): return True return False"},{"question":"You are working with a navigation system that computes the shortest routes within a city. The city is represented as a graph where intersections are vertices, roads are directed edges, and weights represent travel time. Your task is to implement a shortest-path algorithm to find the quickest route from a starting intersection to all other intersections. Function Signature ```python def shortest_path(num_vertices: int, edges: List[Tuple[int, int, int]], start: int) -> List[int]: Computes the shortest travel time from the start intersection to all other intersections Args: num_vertices: an integer, the number of intersections in the city (vertices in the graph). edges: a list of tuples, where each tuple contains three integers (u, v, w). It represents a directed road from intersection u to intersection v with travel time w. start: an integer, the starting intersection. Returns: A list of integers where the ith element is the shortest travel time from the start intersection to the ith intersection. If an intersection is unreachable, the distance should be `float(\'inf\')`. ``` # Constraints 1. `1 <= num_vertices <= 1000` 2. `0 <= u, v < num_vertices` 3. `0 <= w <= 1000` 4. `0 <= start < num_vertices` 5. Graph edges are given in a direct format: index represents the intersection number and each edge defines travel from one intersection to another with time weight. # Example ```python num_vertices = 5 edges = [ (0, 1, 10), (0, 4, 5), (1, 2, 1), (4, 1, 3), (4, 2, 9), (4, 3, 2), (2, 3, 4), (3, 2, 6) ] start = 0 print(shortest_path(num_vertices, edges, start)) # Output: [0, 8, 9, 7, 5] ``` In this example, the city has 5 intersections, and each tuple specifies directed roads with given travel times. Starting from intersection 0, you need to compute the shortest travel times to all remaining intersections. # Explanation You must use Dijkstra\'s Algorithm to solve this problem. Implement the algorithm to: 1. Initialize distances from the starting intersection to all others as infinity (`float(\'inf\')`), except the starting intersection itself which should be zero. 2. Use a min-heap (priority queue) to efficiently get the next intersection with the smallest tentative distance. 3. Continuously update the shortest travel time to neighboring intersections. 4. Return a list of shortest travel times.","solution":"import heapq from typing import List, Tuple def shortest_path(num_vertices: int, edges: List[Tuple[int, int, int]], start: int) -> List[int]: Computes the shortest travel time from the start intersection to all other intersections. Args: num_vertices: an integer, the number of intersections in the city (vertices in the graph). edges: a list of tuples, where each tuple contains three integers (u, v, w). It represents a directed road from intersection u to intersection v with travel time w. start: an integer, the starting intersection. Returns: A list of integers where the ith element is the shortest travel time from the start intersection to the ith intersection. If an intersection is unreachable, the distance should be `float(\'inf\')`. # Create adjacency list graph = [[] for _ in range(num_vertices)] for u, v, w in edges: graph[u].append((v, w)) # Distance array distance = [float(\'inf\')] * num_vertices distance[start] = 0 # Min-heap priority queue pq = [(0, start)] # (distance, vertex) while pq: current_distance, current_vertex = heapq.heappop(pq) # If the distance is not updated as expected, skip to the next if current_distance > distance[current_vertex]: continue # Examine and update the neighbors for neighbor, weight in graph[current_vertex]: distance_through_v = current_distance + weight # If a shorter path is found if distance_through_v < distance[neighbor]: distance[neighbor] = distance_through_v heapq.heappush(pq, (distance_through_v, neighbor)) return distance"},{"question":"# Context You are given a dictionary that represents a collection of objects grouped by a common initial key. Each key maps to a list of sub-elements that can be either strings or numbers. The requirement is to write a function that prints this structure in a visually appealing format. The sub-elements must be printed in a specific order as described. # Task Write a function `format_and_print(data)` that accepts a single dictionary `data` as its parameter. The function should print the contents of the dictionary in the following format: - Each top-level key followed by its sub-elements. - Use `->` for representation. - Print all sub-elements in the order they appear. - Introduce a newline and tab indentation after each successive element which is not a string (typically integers). # Input - `data`: A dictionary where keys are single characters, and values are lists containing either strings or integers. # Output - Print the formatted structure directly to the console. # Constraints - All keys in the dictionary are single lowercase letters. - Each list element within the dictionary consists of strings or integers only. # Examples ```python data = { \\"a\\": [\\"Adam\\", \\"Book\\", 4], \\"b\\": [\\"Bill\\", \\"Computer\\", 5, \\"TV\\", 6], \\"c\\": [\\"James\\", \\"Sports\\", 3], \\"d\\": [\\"Adam\\", \\"Computer\\", 3, \\"Quin\\", \\"Computer\\", 3], } Expected Output: a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 c -> James -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> Computer -> 3 ``` # Notes - Utilize efficient lookup and traversal techniques. - Ensure that the structure is accurately traversed and printed. - Maintain modular code with clear handling of different data types in the lists. # Function Signature ```python def format_and_print(data: dict) -> None: pass ```","solution":"def format_and_print(data): Print dictionary contents in a formatted fashion. Parameters: data (dict): A dictionary where keys are single lowercase letters, and values are lists of strings or integers for key, values in data.items(): prefix = f\\"{key} ->\\" for value in values: print(f\\"{prefix} {value}\\") prefix = \\" ->\\""},{"question":"Implement Enhanced Interpolation Search Context: You are given a list of integers sorted in increasing order. The list is known to be generally but not perfectly uniformly distributed. While the standard interpolation search performs well on perfectly distributed data, modifications can optimize it for slight variations in data. Task: Implement an enhanced version of the Interpolation Search algorithm. Your version should include safeguards to handle situations where the assumption of uniform distribution does not hold perfectly. Function Signature: ```python def enhanced_interpolation_search(array: List[int], search_key: int) -> int: :param array: The list of integers to be searched. :param search_key: The key to be searched for in the list. :return: The index of the search_key if found; otherwise, -1. Examples: >>> enhanced_interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) 2 >>> enhanced_interpolation_search([5, 10, 12, 14, 17, 20, 21], 55) -1 >>> enhanced_interpolation_search([5, 10, 12, 14, 17, 20, 21], 10) 1 Requirements: 1. Ensure the base logic of interpolation search is retained. 2. Implement checks to handle scenarios where the data is not perfectly uniformly distributed. 3. Ensure your implementation avoids excessive out-of-bound checks. Hints: - Consider scenarios where the estimated position might frequently be incorrect. - Implement a mechanism to prevent infinite loops if the range gets stuck. - You could hybridize the search with some fail-safes like binary search for vastly non-uniform segments. Constraints: - The input list can have up to (10^7) elements. - The elements are all integers within the range (-10^9 leq x leq 10^9). Performance Requirement: - Aim for best-case runtime around (O(log log n)) with worst-case not worse than (O(n)).","solution":"def enhanced_interpolation_search(array, search_key): Perform an enhanced version of interpolation search to find the index of search_key in the array. :param array: The list of integers to be searched. :param search_key: The key to be searched for in the list. :return: The index of the search_key if found; otherwise, -1. if not array: return -1 low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 # Compute the probe position assuming uniform distribution pos = low + ((high - low) // (array[high] - array[low] + 1) * (search_key - array[low])) # Handle out-of-bounds caused by bad probe position calculations if pos < low or pos > high: return -1 if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 # Safeguard: Fall back to binary search if interpolation fails to narrow down range if high - low <= 10: # Threshold for switching to binary search while low <= high: mid = (low + high) // 2 if array[mid] == search_key: return mid elif array[mid] < search_key: low = mid + 1 else: high = mid - 1 return -1 return -1"},{"question":"You are required to implement the functions that handle conversion between integers and their byte arrays in both big-endian and little-endian formats. 1. A function `int_to_bytes_big_endian_v2(num: int) -> bytes` that converts an integer `num` to its big-endian byte representation. 2. A function `int_to_bytes_little_endian_v2(num: int) -> bytes` that converts an integer `num` to its little-endian byte representation. 3. A function `bytes_big_endian_to_int_v2(bytestr: bytes) -> int` that converts a big-endian byte array back to its integer representation. 4. A function `bytes_little_endian_to_int_v2(bytestr: bytes) -> int` that converts a little-endian byte array back to its integer representation. # Input and Output: - Input: - `num` is a non-negative integer (0 <= num <= 2**64 - 1) - `bytestr` is a byte array of length between 1 and 8. - Output: - For `int_to_bytes_big_endian_v2` and `int_to_bytes_little_endian_v2`, the return should be a byte array (in respective endian format). - For `bytes_big_endian_to_int_v2` and `bytes_little_endian_to_int_v2`, the return should be an integer converted from the byte array. # Constraints: - You\'re expected to not use any libraries or functions that directly perform these conversions (e.g., `int.to_bytes()`, `int.from_bytes()`). - Ensure the solution is efficient and adheres to the mentioned complexities. # Example: ```python assert int_to_bytes_big_endian_v2(4660) == b\'x12x34\' assert int_to_bytes_little_endian_v2(4660) == b\'x34x12\' assert bytes_big_endian_to_int_v2(b\'x12x34\') == 4660 assert bytes_little_endian_to_int_v2(b\'x34x12\') == 4660 assert int_to_bytes_big_endian_v2(0) == b\'x00\' assert int_to_bytes_little_endian_v2(0) == b\'x00\' assert bytes_big_endian_to_int_v2(b\'x00\') == 0 assert bytes_little_endian_to_int_v2(b\'x00\') == 0 ``` # Explanation: In this problem, instead of using existing library functions for conversion, you will manually handle bitwise operations and ordering of bytes to ensure the correct implementation of both endian formats. This challenges your understanding of bit manipulation and the differences between data representation formats.","solution":"def int_to_bytes_big_endian_v2(num: int) -> bytes: Converts an integer to its big-endian byte representation. if num == 0: return b\'x00\' byte_array = bytearray() while num > 0: byte_array.append(num & 0xFF) num >>= 8 return bytes(reversed(byte_array)) def int_to_bytes_little_endian_v2(num: int) -> bytes: Converts an integer to its little-endian byte representation. if num == 0: return b\'x00\' byte_array = bytearray() while num > 0: byte_array.append(num & 0xFF) num >>= 8 return bytes(byte_array) def bytes_big_endian_to_int_v2(bytestr: bytes) -> int: Converts a big-endian byte array to its integer representation. result = 0 for byte in bytestr: result = (result << 8) | byte return result def bytes_little_endian_to_int_v2(bytestr: bytes) -> int: Converts a little-endian byte array to its integer representation. result = 0 for i, byte in enumerate(bytestr): result |= (byte << (i * 8)) return result"},{"question":"# Problem Description You are given a task to compute the n-th Fibonacci number using different methods. The Fibonacci sequence is defined as follows: F(0) = 0, F(1) = 1 F(n) = F(n-1) + F(n-2) for n >= 2 Write a function `compute_fibonacci` that takes an integer n and a string method as input. The method can be \\"recursive\\", \\"dynamic\\", or \\"iterative\\", specifying which technique to use for the computation. Return the n-th Fibonacci number as the output. # Input Format - **integer** n : The index (0-based) in the Fibonacci sequence. - **string** method : The method to use (\\"recursive\\", \\"dynamic\\", \\"iterative\\"). # Output Format - Return the n-th Fibonacci number as an integer. # Constraints - 0 <= n <= 100 - method can be one of \\"recursive\\", \\"dynamic\\", \\"iterative\\" # Example Example 1 Input: ``` compute_fibonacci(10, \\"recursive\\") ``` Output: ``` 55 ``` Example 2 Input: ``` compute_fibonacci(100, \\"dynamic\\") ``` Output: ``` 354224848179261915075 ``` (Note: Recursive approach may be impractical for large n, but dynamic and iterative methods will handle it gracefully.) Example 3 Input: ``` compute_fibonacci(7, \\"iterative\\") ``` Output: ``` 13 ``` # Instructions 1. Implement the function `compute_fibonacci` that adheres to the above specifications. 2. Ensure that the function returns the correct result for all given methods. 3. Consider performance and handle edge cases appropriately.","solution":"def compute_fibonacci(n, method): Compute the n-th Fibonacci number using the specified method. Parameters: n (int): The index in the Fibonacci sequence. method (str): The method to use for computation (\\"recursive\\", \\"dynamic\\", \\"iterative\\"). Returns: int: The n-th Fibonacci number. if method == \\"recursive\\": return fibonacci_recursive(n) elif method == \\"dynamic\\": return fibonacci_dynamic(n) elif method == \\"iterative\\": return fibonacci_iterative(n) else: raise ValueError(\\"Invalid method. Choose \'recursive\', \'dynamic\', or \'iterative\'.\\") def fibonacci_recursive(n): if n == 0: return 0 elif n == 1: return 1 else: return fibonacci_recursive(n-1) + fibonacci_recursive(n-2) def fibonacci_dynamic(n): fib_array = [0, 1] + [0] * (n - 1) for i in range(2, n + 1): fib_array[i] = fib_array[i - 1] + fib_array[i - 2] return fib_array[n] def fibonacci_iterative(n): if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"Scenario As a developer at a cybersecurity firm, you are tasked with building a tool that extracts domain names from a list of URLs. One critical component of this tool is a function that accurately extracts the main domain name from different URL formats. Due to certain security and compliance reasons, you are constrained to using basic string operations and cannot rely on external libraries such as `re` (for regular expressions) or `urllib.parse`. Problem Statement Write a function `extract_domain` that takes a string `url` as input and returns the primary domain name as a string. Ensure that your function handles various URL formats accurately, including those with \\"www\\" and different protocols (http, https). Input Format * A single string `url` representing the URL to be parsed. Output Format * A single string representing the extracted domain name. Constraints * The length of the URL string `len(url)` will not exceed 1000 characters. * The URL will always contain the protocol (`http` or `https`). Examples 1. `extract_domain(\\"http://github.com/SaadBenn\\")` should return `\\"github\\"`. 2. `extract_domain(\\"http://www.zombie-bites.com\\")` should return `\\"zombie-bites\\"`. 3. `extract_domain(\\"https://www.cnet.com\\")` should return `\\"cnet\\"`. 4. `extract_domain(\\"https://blog.github.com\\")` should return `\\"blog\\"`. Performance * Ensure your function runs efficiently with a time complexity of O(n) where n is the length of the URL string. * Minimize space utilization effectively. Edge Cases * Ensure the function correctly handles URLs with subdomains and without \\"www\\".","solution":"def extract_domain(url): Extracts the main domain name from a given URL using basic string operations. Parameters: url (str): The URL string from which to extract the domain. Returns: str: The primary domain name. # Remove protocol (http:// or https://) if url.startswith(\\"http://\\"): url = url[len(\\"http://\\"):] elif url.startswith(\\"https://\\"): url = url[len(\\"https://\\"):] # Remove \\"www.\\" if it exists if url.startswith(\\"www.\\"): url = url[len(\\"www.\\"):] # Extract the domain name up to the first \'/\' end_pos = url.find(\'/\') if end_pos != -1: url = url[:end_pos] # Extract the domain name up to the first \'.\' domain_end_pos = url.find(\'.\') if domain_end_pos != -1: domain = url[:domain_end_pos] else: domain = url return domain"},{"question":"# Scenario You are working on a simulation program that requires managing a series of operations using a stack. To ensure the integrity of your simulation, you decide to implement two different stack classes, one using an array and another using a linked list. # Task Implement functions to evaluate the following operations on two different types of stacks: 1. Determine whether the stack is empty. 2. Add (push) an element to the stack. 3. Remove (pop) the most recently added element from the stack. 4. Retrieve (peek) the value of the most recently added element without removing it. # Requirements 1. Implement the `ArrayStack` class which uses a dynamic array as the underlying data structure. 2. Implement the `LinkedListStack` class which uses a linked list as the underlying data structure. # Specifications 1. Each stack must support the following operations with the described time complexities: - `push(value)` - O(1) - `pop()` - O(1) - `peek()` - O(1) - `is_empty()` - O(1) 2. Make sure to handle edge cases where operations are performed on an empty stack. # Function Signatures ```python # Array-based stack class class ArrayStack: def __init__(self, size=10): pass def __iter__(self): pass def push(self, value): pass def pop(self): pass def peek(self): pass def is_empty(self): pass # Linked list-based stack class class LinkedListStack: def __init__(self): pass def __iter__(self): pass def push(self, value): pass def pop(self): pass def peek(self): pass def is_empty(self): pass ``` # Inputs and Outputs - **push(value)**: Adds `value` to the stack, returns nothing. - **pop()**: Removes the top element from the stack and returns that element. - **peek()**: Returns the top element without removing it. - **is_empty()**: Returns True if the stack is empty, False otherwise. # Constraints 1. The number of operations will be at most (10^6). 2. The `value` for push will be an integer within the range ([-10^9, 10^9]). # Performance Requirements * The implementation should efficiently handle a large number of stack operations in terms of both time and space.","solution":"class ArrayStack: def __init__(self, size=10): self.stack = [] self.size = size def push(self, value): self.stack.append(value) def pop(self): if not self.stack: raise IndexError(\\"pop from empty stack\\") return self.stack.pop() def peek(self): if not self.stack: raise IndexError(\\"peek from empty stack\\") return self.stack[-1] def is_empty(self): return len(self.stack) == 0 class LinkedListStack: class Node: def __init__(self, value): self.value = value self.next = None def __init__(self): self.head = None def push(self, value): new_node = self.Node(value) new_node.next = self.head self.head = new_node def pop(self): if not self.head: raise IndexError(\\"pop from empty stack\\") value = self.head.value self.head = self.head.next return value def peek(self): if not self.head: raise IndexError(\\"peek from empty stack\\") return self.head.value def is_empty(self): return self.head is None"},{"question":"# Next Permutation of Digits Problem Description Given a positive integer `num`, write a function `next_bigger(num)` that returns the next higher number that can be formed using the exact same set of digits in `num`. If no such number exists, return `-1`. Input and Output Formats * **Input**: A single positive integer `num` where `1 <= num <= 10^9`. * **Output**: The next greater integer formed using the same digits, or `-1` if no such permutation exists. Constraints 1. The input will always be a positive integer. 2. The integer can be assumed to fit within the limits of a typical 32-bit signed integer. Performance Requirements * The solution should be efficient with a time complexity of O(n), where n is the number of digits in the input number. * Space complexity should also be O(n), considering the need to store the list of digits. Example Here are some examples for expected inputs and outputs: * For `next_bigger(38276)`, the function should return `38627`. * For `next_bigger(99999)`, the function should return `-1`. * For `next_bigger(54321)`, the function should return `-1`. * For `next_bigger(12345)`, the function should return `12354`. Detailed Steps to Implement 1. Convert the number to a list of digits. 2. Starting from the end of the list, find the first digit that is smaller than the digit next to it. 3. From this digit, find the smallest digit to the right that is larger than this digit. 4. Swap these two digits. 5. Reverse the digits to the right of the initially found digit. Implement this logic carefully, considering edge cases and aiming for optimized performance.","solution":"def next_bigger(num): Returns the next higher number that can be formed using the exact same set of digits in `num`. If no such number exists, returns `-1`. # Convert the number to a list of digits digits = list(str(num)) n = len(digits) # Step 1: Find the first digit that is smaller than the digit next to it i = n - 2 while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 # If no such digit is found, no larger permutation is possible if i == -1: return -1 # Step 2: Find the smallest digit to the right of the i-th digit that is larger than digits[i] j = n - 1 while digits[j] <= digits[i]: j -= 1 # Step 3: Swap the found digit with digits[i] digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the digits to the right of the i-th digit digits = digits[:i+1] + digits[i+1:][::-1] # Convert the list of digits back to an integer return int(\'\'.join(digits))"},{"question":"You have been given two integers, `num1` and `num2`. Your task is to compute three values `s`, `t`, and `g` such that: ```plaintext num1 * s + num2 * t = g ``` where `g` is the Greatest Common Divisor (GCD) of `num1` and `num2`, and `s` and `t` are Bézout\'s coefficients. Write a function `solve_bezout(num1: int, num2: int) -> Tuple[int, int, int]` that takes two integers as inputs and returns a tuple of three integers (s, t, g). # Input: - Two integers `num1` and `num2` (|num1|, |num2| ≤ 10^9) # Output: - A tuple `(s, t, g)` where: - `s` and `t` are Bézout\'s coefficients. - `g` is the Greatest Common Divisor of `num1` and `num2`. # Constraints: - The function should perform integer arithmetic to avoid precision issues. - Input values can be positive, negative, or zero. # Examples: ```python assert solve_bezout(30, 12) == (1, -2, 6) assert solve_bezout(0, 0) == (0, 0, 0) assert solve_bezout(15, 0) == (1, 0, 15) assert solve_bezout(0, 25) == (0, 1, 25) assert solve_bezout(35, 15) == (1, -2, 5) ``` # Performance Requirements: - The algorithm should operate within O(log(min(|num1|, |num2|))) time complexity. - The space complexity should be constant, O(1).","solution":"from typing import Tuple def extended_gcd(a: int, b: int) -> Tuple[int, int, int]: Uses the Extended Euclidean Algorithm to find the Bezout coefficients (s, t) and the greatest common divisor (g) of the integers a and b. if b == 0: return (1, 0, a) else: s, t, g = extended_gcd(b, a % b) return (t, s - (a // b) * t, g) def solve_bezout(num1: int, num2: int) -> Tuple[int, int, int]: Solves for the Bezout coefficients (s, t) and the greatest common divisor (g) for the integers num1 and num2. if num1 == 0 and num2 == 0: return (0, 0, 0) return extended_gcd(num1, num2)"},{"question":"You have been tasked with writing a function that determines the number of ways an integer can be decomposed as the sum of smaller non-negative integers. You are required to write a dynamic programming solution to solve this problem and verify the correctness of your solution with different input values. # Input You will be given a single integer `n` (1 ≤ n ≤ 500), representing the number to be decomposed. # Output You should return an integer which represents the number of non-negative decompositional combinations of the input `n`. # Function Signature ```python def integer_decompose(n: int) -> int: pass ``` # Example Example 1 Input: `4` Output: `5` Explanation: ``` 4 can be decomposed into: 4 3 + 1 2 + 2 2 + 1 + 1 1 + 1 + 1 + 1 Hence, there are 5 different ways to partition 4. ``` Example 2 Input: `7` Output: `15` Explanation: ``` 7 can be decomposed into: 7 6 + 1 5 + 2 5 + 1 + 1 4 + 3 4 + 2 + 1 4 + 1 + 1 + 1 3 + 3 + 1 3 + 2 + 2 3 + 2 + 1 + 1 3 + 1 + 1 + 1 + 1 2 + 2 + 2 + 1 2 + 2 + 1 + 1 + 1 2 + 1 + 1 + 1 + 1 + 1 1 + 1 + 1 + 1 + 1 + 1 + 1 Hence, there are 15 different ways to partition 7. ``` # Constraints - Your solution should run within the time and space complexities discussed. - Ensure to handle edge cases efficiently.","solution":"def integer_decompose(n: int) -> int: Determines the number of ways an integer n can be decomposed as the sum of smaller non-negative integers using dynamic programming. # dp[i][j] will be storing the number of ways to get sum \'i\' using integers up to \'j\' dp = [[0 for _ in range(n+1)] for _ in range(n+1)] # Initialize dp[0][j] = 1 for all j, because there\'s one way to get zero sum: using no numbers for j in range(n+1): dp[0][j] = 1 # Fill the dp table for i in range(1, n+1): for j in range(1, n+1): if i - j >= 0: dp[i][j] = dp[i][j-1] + dp[i-j][j] else: dp[i][j] = dp[i][j-1] return dp[n][n]"},{"question":"# Stooge Sort Variations Given the recursive nature and high time complexity of Stooge Sort, consider its inefficiency when sorting large datasets. Your task is to transform Stooge Sort to directly use iteration for specific sections as a performance improvement and handle a specific edge case. Description Implement a modified version of Stooge Sort that: 1. Handles arrays of lengths 1 and 2 directly without recursive calls. 2. For arrays longer than 2 elements, iteratively sort the first two-thirds and last two-thirds to replace direct recursion. # Input * An unsorted list of integers (`arr`) of any length (0 <= len(arr) <= 100). * `l`: The starting index, initially 0. * `h`: The ending index, initially `len(arr) - 1`. # Output * Return the sorted array. # Function Signature ```python def optimized_stoogesort(arr: list, l: int, h: int) -> list: pass ``` # Example ```python # Input: arr = [1, 3, 64, 5, 7, 8] # Output: [1, 3, 5, 7, 8, 64] # Example function call sorted_array = optimized_stoogesort([1, 3, 64, 5, 7, 8], 0, 5) print(sorted_array) # [1, 3, 5, 7, 8, 64] ``` # Constraints * The list can be empty. * List elements can be any integer values. * Try to optimize time complexity slightly by handling smaller sections iteratively without recursion where possible. # Performance Requirements Your solution should handle the sorting of arrays with the above constraints in a reasonably efficient manner.","solution":"def optimized_stoogesort(arr: list, l: int, h: int) -> list: if l >= h: return arr # Handle arrays of length 1 or 2 directly if h - l + 1 == 2: if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] elif h - l + 1 > 2: # Calculate the one-third size t = (h - l + 1) // 3 # Iterative sorting for specific sections instead of recursion for _ in range(t + 1): if l < h - t: if arr[l] > arr[h-t]: arr[l], arr[h-t] = arr[h-t], arr[l] if l + t < h: if arr[l+t] > arr[h]: arr[l+t], arr[h] = arr[h], arr[l+t] # Recursive sorting for middle part arr = optimized_stoogesort(arr, l, h - t) arr = optimized_stoogesort(arr, l + t, h) arr = optimized_stoogesort(arr, l, h - t) return arr"},{"question":"# Problem Description You are given a singly linked list and an integer `k`. Your task is to find the `k`-th to last element in the linked list. Implement a function `kth_to_last` that takes the head of the linked list and the integer `k` and returns the value of the `k`-th to last node in the linked list. # Input - `head` (Node): The head node of a singly linked list. - `k` (int): The position from the end of the linked list. # Output - Return the value of the `k`-th to last node in the linked list. If `k` is greater than the number of nodes in the linked list, raise an `IndexError`. # Function Signature ```python def kth_to_last(head: Node, k: int) -> str: ``` # Constraints - The linked list will have at least one node and at most (10^4) nodes. - All node values will be strings consisting of lowercase and uppercase English letters. - `0 <= k < 10^4` # Example Example 1: **Input:** ```python head: A -> B -> C k: 1 ``` **Output:** ``` \\"B\\" ``` **Explanation:** When reversed from the last element, (k=1) points to \\"B\\". Example 2: **Input:** ```python head: X -> Y -> Z -> P k: 2 ``` **Output:** ``` \\"Y\\" ``` **Explanation:** When reversed from the last element, (k=2) points to \\"Y\\". # Additional Notes: - You must handle cases where `k` exceeds the length of the linked list. In such instances, raise an `IndexError`. - Optimize for both time and space complexity. Avoid unnecessary data structures. - Consider edge cases such as an empty list (ensure proper validation) and minimal input cases. # Scenario: You are working on a large-scale application where user data is logged in a linked list. Frequently, you need to retrieve information relative to the end of this log. Implementing an efficient solution will ensure your system remains performant even as the user base grows.","solution":"class Node: def __init__(self, value: str, next=None): self.value = value self.next = next def kth_to_last(head: Node, k: int) -> str: fast = head slow = head # Move `fast` k steps ahead for _ in range(k): if not fast: raise IndexError(\\"k is larger than the length of the linked list\\") fast = fast.next # Move `fast` to the end, maintaining the gap while fast and fast.next: fast = fast.next slow = slow.next # At this point, `slow` should be at the k-th to last element if not fast: raise IndexError(\\"k is larger than the length of the linked list\\") return slow.value"},{"question":"**Scenario:** You are given an array of integers, where every element appears exactly twice, except for one. Your task is to implement an algorithm to find that single unique element. The function must operate in linear time complexity and use constant space. **Function to Implement:** Write a function `single_number` that receives an array of integers `nums` and returns the unique integer. **Function Signature:** ```python def single_number(nums: List[int]) -> int: pass ``` **Input:** * `nums`: A list of integers where every integer occurs twice except for one integer. **Output:** * The single unique integer. **Constraints:** * You must not use extra memory (no additional data structures). * The solution should have linear time complexity. **Example:** ```python single_number([2, 2, 3, 3, 4, 4, 5]) # returns 5 single_number([1, 1, 2, 2, 3, 4, 4]) # returns 3 ``` **Thought Questions:** 1. Why does using XOR help find the unique element? 2. How does the order of elements affect the result?","solution":"from typing import List def single_number(nums: List[int]) -> int: Returns the single unique number in the list where every other number appears exactly twice. result = 0 for num in nums: result ^= num return result"},{"question":"# Graph Path Finding Given the `DirectedGraph` class provided in the code snippet, extend this class to include a method, `find_path`, that finds a path from a source node to a destination node if one exists. The method should use an appropriate graph traversal algorithm (e.g., Breadth-First Search). Method Signature ```python class DirectedGraph: ... def find_path(self, source: str, destination: str) -> List[str]: pass ``` Input * `source` (str): The name of the source node. * `destination` (str): The name of the destination node. Output * `List[str]`: A list of node names representing the path from the source node to the destination node, inclusive. If no path exists, return an empty list. Constraints * The graph is directed. * The source and destination nodes always exist in the graph. * There might be multiple paths between two nodes, any valid path is acceptable. * Performance constraints: The solution should be optimized for reasonably sized graphs (up to 10^3 nodes and 10^4 edges). Example ```python graph = DirectedGraph({ \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"C\\", \\"D\\"], \\"C\\": [\\"D\\"], \\"D\\": [\\"A\\"] }) path = graph.find_path(\\"A\\", \\"D\\") print(path) # Example Output: [\\"A\\", \\"B\\", \\"D\\"] path = graph.find_path(\\"B\\", \\"A\\") print(path) # Example Output: [] ``` Performance Requirements * Ensure the algorithm runs within a time complexity that respects the constraints. * Your implementation should handle edge cases such as no path available gracefully. Hint Consider using Breadth-First Search (BFS) for an efficient path-finding approach, as it guarantees the shortest path in an unweighted graph. # Implementation Note The current implementation does not include a `find_path` method. Your task is to extend the class with this method ensuring it adheres to the input-output specifications and handles edge cases effectively.","solution":"from collections import deque from typing import List, Dict, Set class DirectedGraph: def __init__(self, graph_dict: Dict[str, List[str]]): self.graph_dict = graph_dict def find_path(self, source: str, destination: str) -> List[str]: if source == destination: return [source] # Initialize a queue for BFS queue = deque([(source, [source])]) visited = set() while queue: current_node, path = queue.popleft() if current_node in visited: continue visited.add(current_node) for neighbor in self.graph_dict.get(current_node, []): if neighbor == destination: return path + [neighbor] queue.append((neighbor, path + [neighbor])) return []"},{"question":"# Scenario You have been tasked to reformat a license key into a more readable format. The license key is given as a string `key` consisting of alphanumeric characters and dashes. You are also given an integer `k`. The goal is to reformat the string such that each group contains exactly `k` characters, except for the first group which could be shorter but still contains at least one character. Hyphens should be inserted between groups as separators, and all alphabetic characters should be converted to uppercase. # Input and Output * **Input**: * `key` (str): A string consisting of alphanumeric characters (both uppercase and lowercase) and dashes. * `k` (int): An integer indicating the size of the groups. * **Output**: * A formatted string with groups of size `k` separated by hyphens. # Constraints * The input string can contain between 1 and 100,000 characters (inclusive). * `1 <= k <= len(alnum)`, where `alnum` is the list of alphanumeric characters extracted from `key`. # Performance Requirements The solution should be efficient with a time complexity of O(n) and a space complexity of O(n). # Your Task Write a function `license_number(key, k)` that takes a string `key` and an integer `k` and returns the formatted license key string. # Examples ```python # Example 1 key = \\"2-5g-3-J\\" k = 2 # The resulting formatted string should be \\"2-5G-3J\\" print(license_number(key, k)) # Example 2 key = \\"2-4A0r7-4k\\" k = 3 # The resulting formatted string should be \\"24-A0R-74K\\" print(license_number(key, k)) ``` # Notes * Ensure the function correctly handles the input case without additional libraries beyond basic string manipulation functions. * Think about edge cases such as empty string inputs or strings without any valid alphanumeric characters.","solution":"def license_number(key, k): Reformat the license key string such that each group contains exactly `k` characters, except for the first group which could be shorter but still contains at least one character. All alphabetic characters should be converted to uppercase. # Remove all dashes and convert to uppercase alnum = key.replace(\'-\', \'\').upper() # Calculate the length of the first group first_group_length = len(alnum) % k if first_group_length == 0: first_group_length = k # Start reformatted key with the first group reformatted = alnum[:first_group_length] # Append the subsequent groups for i in range(first_group_length, len(alnum), k): reformatted += \'-\' + alnum[i:i+k] return reformatted"},{"question":"You are given an array `arr` of integers, where `arr[i]` can be any integer value. You need to efficiently: 1. Compute the sum of the elements up to any index. 2. Update the value at any given index in the array. Implement a class `EfficientArray` which should: * Initialize the data structure with the given array. * Provide methods for the following operations: - `prefix_sum(index: int) -> int`: Returns the sum of elements from the start of the array to the given index (inclusive). - `update(index: int, value: int) -> None`: Updates the element at the given index to the new value. # Constraints * 1 <= `len(arr)` <= 10^5 * -10^9 <= `arr[i]` <= 10^9 * Queries for `prefix_sum` and `update` methods are called multiple times. # Requirements * Your solution must handle updates and prefix sum queries in O(log n) time. * Your implementation should use O(n) space. # Example ```python # Example usage of EfficientArray arr = [1, 2, 3, 4, 5] ea = EfficientArray(arr) print(ea.prefix_sum(3)) # Should output 10 (1 + 2 + 3 + 4) ea.update(1, 10) # Updates arr[1] to 10 print(ea.prefix_sum(3)) # Should output 18 (1 + 10 + 3 + 4) ```","solution":"class EfficientArray: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (self.n + 1) self.arr = [0] * self.n for i in range(self.n): self.update(i, arr[i]) def update(self, index, value): diff = value - self.arr[index] self.arr[index] = value i = index + 1 while i <= self.n: self.tree[i] += diff i += i & -i def prefix_sum(self, index): i = index + 1 total = 0 while i > 0: total += self.tree[i] i -= i & -i return total"},{"question":"# Sudoku Solver: Constrained Backtracking Algorithm You are given a partially filled 9x9 Sudoku board. Your task is to implement a Sudoku solver using a constrained backtracking algorithm that attempts to reduce the search space by maintaining a hash table of possible values for each empty cell. Input * A 9x9 Sudoku board represented as a list of lists, where each element is either a number from \'1\' to \'9\' or a \'.\' indicating an empty cell. Output * The same 9x9 Sudoku board with the cells filled to produce a valid solution. If no solution exists, the board should remain unchanged. Constraints * The input board is guaranteed to have at least one solution. Requirements 1. Implement a class `Sudoku` with the following methods: - `__init__(self, board: List[List[str]])`: Initialize the board and set up any necessary data structures. - `solve(self)`: Perform the backtracking search to solve the Sudoku and return `True` if solved, `False` otherwise. - `__str__(self)`: Provide a string representation of the board. 2. Use a hash table to keep track of possible values for each empty cell and optimize the search process. 3. Handle the Sudoku rules: each number 1-9 must appear exactly once in each row, column, and 3x3 subgrid. Example ```python # Input board = [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] sudoku = Sudoku(board) sudoku.solve() print(sudoku) ``` The resulting output board should show the solved Sudoku puzzle if the implementation is correct.","solution":"class Sudoku: def __init__(self, board): Initialize the Sudoku board and necessary data structures. self.board = board self.possibilities = {} # Using a hash table to keep track of possible values for each empty cell def solve(self): Solve the Sudoku using constrained backtracking. empty_positions = self.find_empty_positions() if not empty_positions: return True row, col = empty_positions[0] for number in map(str, range(1, 10)): if self.is_valid(row, col, number): self.board[row][col] = number if self.solve(): return True self.board[row][col] = \'.\' return False def find_empty_positions(self): Find all empty positions on the board and return a list of tuples (row, col). return [(i, j) for i in range(9) for j in range(9) if self.board[i][j] == \'.\'] def is_valid(self, row, col, number): Check if placing `number` at position (row, col) is valid. # Check row if any(self.board[row][j] == number for j in range(9)): return False # Check column if any(self.board[i][col] == number for i in range(9)): return False # Check 3x3 grid start_row, start_col = 3 * (row // 3), 3 * (col // 3) for i in range(start_row, start_row + 3): for j in range(start_col, start_col + 3): if self.board[i][j] == number: return False return True def __str__(self): Provide a string representation of the board. board_str = \'\' for line in self.board: board_str += \' \'.join(line) + \'n\' return board_str.strip()"},{"question":"# Programming Challenge: Edit Distance Calculation Problem Statement You are given two strings `source` and `target`, and you need to write a function to compute the minimum number of operations required to convert the `source` string into the `target` string. The allowed operations are inserting a character, deleting a character, or substituting one character for another. # Function Signature ```python def find_edit_distance(source: str, target: str) -> int: Calculates the minimum number of operations required to convert the source string into the target string. :param source: A string representing the source word. :param target: A string representing the target word. :return: An integer representing the minimum edit distance. ``` # Input * `source` and `target` are two strings with lengths `m` and `n` respectively, where `0 ≤ m, n ≤ 1000`. # Output * An integer representing the minimum number of operations needed to convert `source` into `target`. # Constraints * You may assume both `source` and `target` only contain lowercase alphabetical characters. * Optimized solutions are preferred in terms of both time and space complexity. # Example ```python assert find_edit_distance(\\"kitten\\", \\"sitting\\") == 3 # Explanation: kitten -> sitten (substitution) # sitten -> sittin (substitution) # sittin -> sitting (insertion) assert find_edit_distance(\\"intention\\", \\"execution\\") == 5 ``` # Additional Details * Handle the edge cases where one or both strings are empty. * Think about the performance and try to optimize space usage. * Your function should be efficient enough to handle inputs as large as the constraints specify.","solution":"def find_edit_distance(source: str, target: str) -> int: Calculates the minimum number of operations required to convert the source string into the target string. :param source: A string representing the source word. :param target: A string representing the target word. :return: An integer representing the minimum edit distance. m, n = len(source), len(target) if m == 0: return n if n == 0: return m # Initialize a matrix to store distances dp = [[0] * (n + 1) for _ in range(m + 1)] # Base cases: source or target being empty for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Fill dp matrix for i in range(1, m + 1): for j in range(1, n + 1): if source[i - 1] == target[j - 1]: dp[i][j] = dp[i - 1][j - 1] # No operation needed else: insert_op = dp[i][j - 1] + 1 delete_op = dp[i - 1][j] + 1 replace_op = dp[i - 1][j - 1] + 1 dp[i][j] = min(insert_op, delete_op, replace_op) return dp[m][n]"},{"question":"# Problem: Efficient Insertion Sort Scenario: You have been hired by a tech company to optimize their sorting module, which frequently needs to sort small or nearly sorted datasets. Your task is to implement an improved version of the Insertion Sort algorithm that exploits a binary search technique to find the insertion position, thereby reducing the number of comparisons. Function Signature ```python def insertion_sort(array: list) -> list: ``` Description: Implement the `insertion_sort` function to sort the given list of integers using an Insertion Sort algorithm that employs binary search to find the correct insertion point. Constraints: - The input list will contain up to 1000 integers. - Each integer in the list will be in the range `[-10^6, 10^6]`. Input: - A list of integers, `array`, where `1 <= len(array) <= 1000`. Output: - A sorted list of integers in ascending order. Examples: 1. `insertion_sort([5, 2, 9, 1, 5, 6])` should return `[1, 2, 5, 5, 6, 9]`. 2. `insertion_sort([1, 2, 3, 4, 5])` should return `[1, 2, 3, 4, 5]`. 3. `insertion_sort([5, 4, 3, 2, 1])` should return `[1, 2, 3, 4, 5]`. 4. `insertion_sort([])` should return `[]`. Hints: - Use the function `search_insert(array, val)` provided to find the insertion position using binary search. - Make sure to shift elements as needed to insert the value at the correct position. ```python def search_insert(array, val): low = 0 high = len(array) - 1 while low <= high: mid = low + (high - low) // 2 if val > array[mid]: low = mid + 1 else: high = mid - 1 return low ```","solution":"def search_insert(array, val): low = 0 high = len(array) - 1 while low <= high: mid = low + (high - low) // 2 if val > array[mid]: low = mid + 1 else: high = mid - 1 return low def insertion_sort(array): Sorts the given list of integers using an improved insertion sort algorithm with binary search for finding the insertion point. for i in range(1, len(array)): key = array[i] # Find the position where key should be inserted using binary search pos = search_insert(array[:i], key) # Move all elements greater than key to one position ahead to make space for key array = array[:pos] + [key] + array[pos:i] + array[i+1:] return array"},{"question":"# Longest Common Subsequence (LCS) Problem Scenario You are developing a software tool for biologists to compare DNA sequences. One of the key features needed in this tool is to find the longest common subsequence between two DNA sequences represented by strings. You have to implement a function to determine the length of the longest common subsequence of two given strings. Task Write a function `longest_common_subsequence(s1, s2)` that accepts two strings `s1` and `s2` (comprised of lowercase English letters) and returns the length of their longest common subsequence. Input * `s1` (string): The first string (1 <= len(s1) <= 1000). * `s2` (string): The second string (1 <= len(s2) <= 1000). Output * `int`: Length of the longest common subsequence. Constraints * Input strings consist only of lowercase English letters. Example ```python assert longest_common_subsequence(\\"abcdgh\\", \\"aedfhr\\") == 3 # Output: 3 (\\"adh\\" is the longest subsequence) assert longest_common_subsequence(\\"abc\\", \\"abc\\") == 3 # Output: 3 (\\"abc\\" is the longest subsequence) assert longest_common_subsequence(\\"abc\\", \\"def\\") == 0 # Output: 0 (No common subsequence) ``` Guidelines 1. Use a 2D list to store the results of subproblems. 2. Initialize the 2D list to zero. 3. Iterate through both strings character-by-character to fill the 2D list. 4. The value at `matrix[len(s1)][len(s2)]` will be the length of the longest common subsequence.","solution":"def longest_common_subsequence(s1, s2): Returns the length of the longest common subsequence of two given strings. m, n = len(s1), len(s2) # Create a 2D list (matrix) to store lengths of longest common subsequence. dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the matrix in bottom-up fashion. for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The length of the longest common subsequence will be in dp[m][n]. return dp[m][n]"},{"question":"# Question: Find the Extra Character You are given two strings, `s` and `t`. String `s` consists of lowercase letters, and string `t` is generated by shuffling the characters of `s` and adding one extra lowercase letter at a random position. Write a function `find_difference(s, t)` that finds the extra letter added to `t`. Function Signature ```python def find_difference(s: str, t: str) -> str: pass ``` Input - `s` (string): A string consisting of only lowercase letters. *Length: 0 <= len(s) <= 10^5*. - `t` (string): A string consisting of only lowercase letters with one additional character compared to `s`. *Length: len(s) + 1*. Output - Returns a single character that is the extra letter added to `t`. Constraints - Both strings, `s` and `t`, are non-empty and consist of lowercase letters (\'a\' to \'z\') only. - `t` is generated by shuffling `s` and adding one additional character at a random position. Example Input: ```python s = \\"abcd\\" t = \\"abecd\\" ``` Output: ```python \\"e\\" ``` # Explanation In the given example, \'e\' is the letter that was added to `t`. Additional Test Case Input: ```python s = \\"\\" t = \\"a\\" ``` Output: ```python \\"a\\" ``` Explanation: Since `s` is an empty string and `t` contains only one character `a`, the extra character is `a`. # Notes - Ensure your solution handles edge cases gracefully. - Consider performance and space efficiency in your implementation.","solution":"def find_difference(s: str, t: str) -> str: Finds the extra character added to t. :param s: Original string :param t: Shuffled string with one additional character :return: The extra character char_count = {} # Count characters in s for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Subtract counts based on characters in t for char in t: if char not in char_count or char_count[char] == 0: return char else: char_count[char] -= 1 # Example Usage: # s = \\"abcd\\" # t = \\"abecd\\" # print(find_difference(s, t)) # -> \\"e\\""},{"question":"**Matrix Inversion Challenge** # Objective Your task is to implement the function `invert_matrix` that computes the inverse of a given square n x n matrix, if it exists. The function must handle errors and edge cases effectively. # Input - An n x n matrix `m` where `2 ≤ n ≤ 10`: - The matrix is represented as a list of lists in Python, with each sublist representing a row. - Assumed elements are integers or fractions. # Output - An n x n matrix which is the inverse of the input matrix. - If the input matrix is invalid or cannot be inverted, return a specific matrix indicating the error: - `[[−1]]` if the matrix is not a matrix. - `[[−2]]` if the matrix is not square. - `[[−3]]` if the matrix is too small (n < 2). - `[[−4]]` if the matrix is singular (determinant is zero). # Function Signature ```python def invert_matrix(m): # Your code here ``` # Constraints - The function should handle matrices with integer and fraction elements. - Focus on clarity and correctness before optimizing for performance given the constraints. - Do not use any external libraries for matrix computation, only use the standard library. # Example ```python # Valid case: 2 x 2 matrix matrix = [ [4, 7], [2, 6] ] print(invert_matrix(matrix)) # Expected output: [[0.6, -0.7], [-0.2, 0.4]] # Invalid case: single element matrix matrix = [ [4] ] print(invert_matrix(matrix)) # Expected output: [[-3]] # Invalid case: singular matrix (det = 0) matrix = [ [1, 2], [2, 4] ] print(invert_matrix(matrix)) # Expected output: [[-4]] ```","solution":"def invert_matrix(m): def is_square_matrix(matrix): return all(len(row) == len(matrix) for row in matrix) def determinant(matrix): if len(matrix) == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] det = 0 for c in range(len(matrix)): sub_det = determinant([row[:c] + row[c+1:] for row in matrix[1:]]) det += ((-1)**c) * matrix[0][c] * sub_det return det def minor_matrix(matrix, i, j): return [row[:j] + row[j+1:] for row in (matrix[:i] + matrix[i+1:])] def transpose(matrix): return list(map(list, zip(*matrix))) def inverse(matrix): det = determinant(matrix) if len(matrix) == 2: return [ [ matrix[1][1]/det, -matrix[0][1]/det], [-matrix[1][0]/det, matrix[0][0]/det] ] cofactors = [] for r in range(len(matrix)): cofactor_row = [] for c in range(len(matrix)): minor = minor_matrix(matrix, r, c) cofactor_row.append(((-1)**(r+c)) * determinant(minor)) cofactors.append(cofactor_row) cofactors = transpose(cofactors) for r in range(len(cofactors)): for c in range(len(cofactors)): cofactors[r][c] = cofactors[r][c] / det return cofactors # Check if m is a list if not isinstance(m, list): return [[-1]] # Check if each row is a list if not all(isinstance(row, list) for row in m): return [[-1]] # Check if matrix is square if not is_square_matrix(m): return [[-2]] # Check if matrix is not too small if len(m) < 2: return [[-3]] # Check if matrix is singular (determinant is zero) if determinant(m) == 0: return [[-4]] # Otherwise, return the inverse matrix return inverse(m)"},{"question":"Given a string `s`, write a function `remove_duplicates` to delete any reoccurring characters and return the new string with only the first occurrence of each character retained, while preserving the original order of characters. # Input * A single string `s` (0 <= len(s) <= 10^6), which may contain alphanumeric characters and punctuation. # Output * Return the resulting string after removing all recurring characters. # Constraints * The string should be processed in linear time O(n). * Avoid using any library functions that directly solve the problem. * The function should handle edge cases gracefully such as empty string input. # Example ```python def remove_duplicates(s: str) -> str: pass assert remove_duplicates(\\"programming\\") == \\"progamin\\" assert remove_duplicates(\\"abracadabra\\") == \\"abrcd\\" assert remove_duplicates(\\"google\\") == \\"gole\\" assert remove_duplicates(\\"\\") == \\"\\" ``` # Function Signature ```python def remove_duplicates(s: str) -> str: # Implement your solution here pass ``` # Note - Maintain the order of appearance for the first occurrence of each character. - Focus on both time and space efficiency.","solution":"def remove_duplicates(s: str) -> str: seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Shell Sort Extension Challenge Given an array of integers, implement an optimized version of Shell Sort that selects gap sequences from the Sedgewick series to improve sorting efficiency. Expected Function Signature: ```python def optimized_shell_sort(arr: List[int]) -> List[int]: ``` # Scenario You are tasked with implementing an efficient sorting algorithm for a medium-sized dataset from an application logging system which needs sorting by timestamp. # Input: - An array `arr` of integers, where 1 ≤ len(arr) ≤ 10^5 and the values can be any integer. # Output: - Return the sorted version of the array `arr`. # Constraints: 1. The algorithm must utilize the Sedgewick gap sequence. 2. Aim for an overall improved time performance compared to the traditional Shell Sort. # Example: ```python print(optimized_shell_sort([23, 42, 4, 16, 8, 15])) # Expected Output: [4, 8, 15, 16, 23, 42] ``` **Performance Considerations**: 1. Optimize for best performance using the Sedgewick sequence. 2. Ensure the algorithm is generalized and can handle a wide range of integer arrays efficiently.","solution":"from typing import List def optimized_shell_sort(arr: List[int]) -> List[int]: Perform Shell Sort using the Sedgewick gap sequence. n = len(arr) # Sedgewick gap sequence gaps = [] k = 0 while True: gap1 = 9 * (4**k - 2**k) + 1 gap2 = (2**(k+2)) * (2**(k+2) - 3) + 1 if gap1 < n: gaps.append(gap1) if gap2 < n: gaps.append(gap2) if gap1 >= n and gap2 >= n: break k += 1 gaps.reverse() # Shell Sort using the Sedgewick gap sequence for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"# Binary Search Implementation and Edge Case Handling **Objective**: Implement the binary search algorithm as outlined above. Your implementation should handle the typical edge cases effectively. **Task**: Write a function that performs binary search on a given sorted array and returns the index of the target value. If the target value is not found, return -1. # Specifications: - **Function Name**: `binary_search` - **Input**: * `array` (List[int]): A list of integers sorted in ascending order. * `target` (int): The integer value to search for. - **Output**: * (int): The index of the target value in the array if found, otherwise return -1. # Constraints: - The array is sorted in ascending order. - The array length can be between 0 and 10^6. - The target value can be any integer within the bounds of the array. # Edge Cases to Handle: 1. Empty array (`[]`). 2. Target value not present in the array. 3. Target value found at the first or last index of the array. # Example: ``` Input: array = [1, 2, 3, 4, 5, 6, 7, 8, 9], target = 5 Output: 4 Input: array = [1, 2, 3, 4, 5, 6, 7, 8, 9], target = 10 Output: -1 Input: array = [], target = 1 Output: -1 ``` # Code Template: ```python def binary_search(array, target): low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == target: return mid elif array[mid] < target: low = mid + 1 else: high = mid - 1 return -1 ```","solution":"def binary_search(array, target): Perform binary search on a sorted array to find the target value. :param array: List[int] - A list of integers sorted in ascending order. :param target: int - The integer value to search for. :return: int - The index of the target value in the array if found, otherwise -1. low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == target: return mid elif array[mid] < target: low = mid + 1 else: high = mid - 1 return -1"},{"question":"Implementing and Analyzing Stooge Sort Scenario You are a software engineer assigned the task of evaluating experimental sorting algorithms for academic purposes in your organization. One of the algorithms under evaluation is the **Stooge Sort**. Your task is to understand its implementation and analyze its performance on various datasets. Problem Statement Implement the Stooge Sort algorithm in Python from scratch. Given an array of integers, your function should sort the array using the Stooge Sort algorithm. You also need to manage edge cases and ensure the algorithm handles various inputs efficiently, given its inherent complexity. Finally, test the algorithm with different test cases and describe its performance. Function Signature ```python def stooge_sort(array, left, right): # Your code goes here ``` Input - `array`: List of integers (0 to 10^6 elements) - `left`: Starting index of the subarray to sort (`0 <= left < len(array)`) - `right`: Ending index of the subarray to sort (`left <= right < len(array)`) Output - The function should sort the subarray elements in place. Constraints - Time complexity is expected to be O(n².709), given the nature of Stooge Sort. - The algorithm should not use additional space besides the input array and recursion stack up to O(n). Example ```python # Example input array = [2, 4, 5, 3, 1] stooge_sort(array, 0, len(array) - 1) print(array) # Output: [1, 2, 3, 4, 5] ``` Additional Guidelines 1. **Edge Cases**: - Single-element array. - Already sorted array. - Array with duplicate values. - Array with all elements equal. 2. **Documentation**: Comments explaining each part of your code. 3. **Testing**: Write tests for varied input sizes to observe algorithm behavior and performance.","solution":"def stooge_sort(array, left, right): Sorts the array using Stooge Sort algorithm. Parameters: array (list): List of integers to sort. left (int): Starting index of the subarray to sort. right (int): Ending index of the subarray to sort. Returns: None: The array is sorted in place. if left >= right: return # If the element at left is greater than the element at right, swap them if array[left] > array[right]: array[left], array[right] = array[right], array[left] # If there are more than two elements in the subarray, # recursively sort the first 2/3, last 2/3, and again the first 2/3 of the array if right - left + 1 > 2: third = (right - left + 1) // 3 stooge_sort(array, left, right - third) stooge_sort(array, left + third, right) stooge_sort(array, left, right - third)"},{"question":"You are given two strings, `A` and `B`. Your task is to write a function `edit_distance(A, B)` that computes the minimum number of single-character edits (insertions, deletions, substitutions) required to transform string `A` into string `B`. # Function Signature ```python def edit_distance(A: str, B: str) -> int: ``` # Input * Two non-empty strings, A and B. Each string length will be between 1 and 1000 characters. # Output * An integer representing the minimum number of edit operations to transform A into B. # Constraints * 1 ≤ len(A), len(B) ≤ 1000 * The input strings will only contain lowercase English alphabets. # Example ```python # Example 1 A = \\"kitten\\" B = \\"sitting\\" assert edit_distance(A, B) == 3 # transformations: kitten -> sitten -> sittin -> sitting # Example 2 A = \\"flaw\\" B = \\"lawn\\" assert edit_distance(A, B) == 2 # transformations: flaw -> law -> lawn ``` # Notes * Consider all different types of edits while transforming A into B. * Make sure to handle edge cases such as where one or both strings are empty. * Optimize for both time and space complexity where possible.","solution":"def edit_distance(A: str, B: str) -> int: Computes the minimum number of single-character edits (insertions, deletions, substitutions) required to transform string A into string B. # Create a DP table to memoize results m, n = len(A), len(B) dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the DP table for i in range(m + 1): dp[i][0] = i # cost of deleting from A up to i to match empty B for j in range(n + 1): dp[0][j] = j # cost of adding to A to match B up to j # Fill the DP table with edit distances for i in range(1, m + 1): for j in range(1, n + 1): if A[i - 1] == B[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no new cost else: dp[i][j] = min( dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + 1 # Substitution ) return dp[m][n]"},{"question":"# Word Dictionary with Wildcard Search You are to implement a word dictionary that supports adding new words and searching words, where the search operation may include a wildcard character `.` that can match any letter. Your task is to implement the following: 1. **addWord(word)**: Adds a word to the dictionary. 2. **search(word)**: Returns `True` if there is any string in the dictionary that matches the `word` (with or without wildcards), or `False` otherwise. Implement two classes `WordDictionaryTrie` and `WordDictionaryHashMap` that will use the trie and hash map approaches respectively. # Expected Input and Output Formats: * **addWord**: - Input: A single word string. - Output: None. * **search**: - Input: A search query string (can include `.` as wildcard). - Output: Boolean (`True`/`False`). # Constraints: - Words consist of lowercase English letters only. - The length of each word is in the range [1, 100]. - The total number of words added will not exceed 10^4. - The worst-case time complexity for searching should be manageable within the constraints. # Examples: ```python wdt = WordDictionaryTrie() wdt.addWord(\\"bad\\") wdt.addWord(\\"dad\\") wdt.addWord(\\"mad\\") assert wdt.search(\\"pad\\") == False assert wdt.search(\\"bad\\") == True assert wdt.search(\\".ad\\") == True assert wdt.search(\\"b..\\") == True wdh = WordDictionaryHashMap() wdh.addWord(\\"bad\\") wdh.addWord(\\"dad\\") wdh.addWord(\\"mad\\") assert wdh.search(\\"pad\\") == False assert wdh.search(\\"bad\\") == True assert wdh.search(\\".ad\\") == True assert wdh.search(\\"b..\\") == True ``` Your implementation will be evaluated based on correctness, efficiency, and use of appropriate data structures.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionaryTrie: def __init__(self): self.root = TrieNode() def addWord(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word): def search_from_node(word, node): for i, char in enumerate(word): if char == \'.\': for child in node.children.values(): if search_from_node(word[i+1:], child): return True return False if char not in node.children: return False node = node.children[char] return node.is_end_of_word return search_from_node(word, self.root) class WordDictionaryHashMap: def __init__(self): self.word_dict = {} def addWord(self, word): length = len(word) if length not in self.word_dict: self.word_dict[length] = [] self.word_dict[length].append(word) def search(self, word): length = len(word) if length not in self.word_dict: return False for candidate in self.word_dict[length]: if all(c == w or w == \'.\' for c, w in zip(candidate, word)): return True return False"},{"question":"Implement and Analyze Bogo Sort Background: Bogo Sort (also known as Monkey Sort) is a highly inefficient sorting algorithm that works by randomly shuffling an array until it is sorted. While impractical, it serves as a theoretical exploration of algorithm performance and randomness. Problem Statement: You are tasked with implementing Bogo Sort and analyzing its behavior on various input arrays. Requirements: 1. **Function Signature**: Implement the function `bogo_sort(arr: list, simulation: bool = False) -> list` 2. **Parameters**: - `arr`: A list of integers that need to be sorted. - `simulation`: A boolean flag. If `simulation` is set to `True`, the function should print the array in its current state after each shuffle operation. 3. **Returns**: The sorted list of integers. 4. **Constraints**: - `arr` will contain at most 10 integers due to the inefficiency of the algorithm. - The integers will range between -1000 and 1000. 5. **Edge Cases**: - Handle edge cases such as empty arrays and single-element arrays efficiently. Example: ```python input_array = [3, 1, 2] print(bogo_sort(input_array, True)) ``` Additional Tasks: 1. **Analysis of Performance**: - In your implementation file, include comments analyzing the algorithm’s performance on different input sizes. 2. **Testing with Edge Cases**: - Test your function with edge cases such as an empty array and a single-element array and describe observations. > **Note**: You should not use built-in sorting functions or libraries. Evaluation Criteria: - Correctness of the Bogo Sort implementation. - Handling of edge cases correctly. - Clear and informative output when `simulation` flag is set. - Thorough performance analysis in code comments.","solution":"import random def is_sorted(arr): Helper function to check if the array is sorted. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def bogo_sort(arr, simulation=False): Function that implements Bogo Sort. Parameters: arr (list): List of integers to be sorted. simulation (bool): If True, print the array in its current state after each shuffle. Returns: list: Sorted list of integers. tries = 0 while not is_sorted(arr): if simulation: print(f\'Shuffle {tries}: {arr}\') random.shuffle(arr) tries += 1 return arr # Performance analysis: # Bogo Sort has an average time complexity of O((n+1)!), where n is the length of the array. # The factorial nature of its time complexity makes it extremely inefficient for even moderately sized arrays. # For an array of length 10, the expected number of permutations can be up to 10!, which is 3,628,800 permutations. # Due to this, usage of Bogo Sort is generally impractical except for educational purposes."},{"question":"# Count Possible Sentences Given a string `s` and a set of dictionary words `dictionaries`, write a function `count_sentences` to determine how many valid sentences can be constructed from the string such that all the words in the sentence are contained in the dictionary. Your function should look like this: ```python def count_sentences(s: str, dictionaries: set) -> int: # Your implementation here ``` # Input * `s` : a string representing the input sentence (1 <= len(s) <= 1000) * `dictionaries` : a set of strings where each string is a valid dictionary word (1 <= len(word) <= 100) # Output The function should output an integer representing the total count of valid sentences that can be constructed. # Constraints * The dictionary will contain only lowercase alphabetic characters. * The input string will contain only lowercase alphabetic characters. # Examples ```python # Example 1 s = \\"applet\\" dictionaries = {\\"app\\", \\"let\\", \\"apple\\", \\"t\\", \\"applet\\"} print(count_sentences(s, dictionaries)) # Output: 3 # Example 2 s = \\"thing\\" dictionaries = {\\"thing\\"} print(count_sentences(s, dictionaries)) # Output: 1 # Example 3 s = \\"apple\\" dictionaries = {\\"banana\\", \\"orange\\", \\"fruit\\"} print(count_sentences(s, dictionaries)) # Output: 0 ``` # Notes * Consider edge cases such as empty strings or dictionaries that do not contain any valid substrings of the given string. * Ensure that your solution handles cases efficiently and avoids the pitfalls of excessive recursive calls.","solution":"def count_sentences(s: str, dictionaries: set) -> int: memo = {} def helper(i): if i == len(s): return 1 if i in memo: return memo[i] count = 0 for j in range(i + 1, len(s) + 1): if s[i:j] in dictionaries: count += helper(j) memo[i] = count return count return helper(0)"},{"question":"Given a binary tree, write a function to determine if it satisfies the properties of a binary search tree (BST). Function Signature: ```python def is_bst(root: TreeNode) -> bool: ``` Input: * `root`: TreeNode - the root node of the binary tree. Output: * `bool` - `True` if the tree is a valid BST, `False` otherwise. Constraints: * Each node in the binary tree contains an integer value. * The structures and values of the nodes are within the range of standard integer types. Performance Requirements: * The solution should run in O(n) time complexity. * Space complexity should be no more than O(h), where h is the height of the tree. Example: 1. Example 1: ```python # Tree structure: 2 / 1 3 # is_bst(root) should return True ``` 2. Example 2: ```python # Tree structure: 1 / 2 3 # is_bst(root) should return False ``` Scenario and Context: Imagine a scenario where you are given a representation of a binary tree and need to validate whether it qualifies as a binary search tree (BST), ensuring all its subtrees also adhere to BST properties. This check is crucial in many applications where binary search tree properties must be maintained for fast data retrieval, insertion, and deletion operations.","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_bst(root: TreeNode) -> bool: def is_valid_bst(node, left, right): if not node: return True if not (left < node.val < right): return False return is_valid_bst(node.left, left, node.val) and is_valid_bst(node.right, node.val, right) return is_valid_bst(root, float(\'-inf\'), float(\'inf\'))"},{"question":"You are tasked with writing a function to calculate the Jaccard Similarity between two lists of integers. The Jaccard Similarity is a measure of the intersection divided by the union of two sets. This metric is commonly used in natural language processing and other applications requiring set comparison. # Function Definition Implement the following function: ```python def jaccard_similarity(list1, list2): Calculate the Jaccard Similarity between two lists of integers. :param list1: List of integers :param list2: List of integers :return: Jaccard Similarity as a float Example: jaccard_similarity([1, 2, 3, 4], [2, 3, 5]) # Output: 0.4 pass ``` # Input * `list1` and `list2` are lists of integers. They can have different lengths and can contain duplicate values. # Output * A floating-point number representing the Jaccard Similarity between the two lists. # Constraints * The lists can be empty, in which case the function should return 0.0. * No external libraries apart from standard Python libraries should be used. * Approach should handle large lists efficiently in terms of time complexity. # Examples 1. `jaccard_similarity([1, 2, 3, 4], [2, 3, 5])` -> 0.4 2. `jaccard_similarity([1, 2, 3], [1, 2, 3])` -> 1.0 3. `jaccard_similarity([], [1, 2, 3])` -> 0.0 4. `jaccard_similarity([1, 2, 2, 3], [2, 2, 3, 4])` -> 0.5 # Notes * Ensure to handle edge cases such as both lists being empty, containing duplicated elements, or containing all identical elements. * Time complexity of the function should be O(n), where n is the combined length of the two lists.","solution":"def jaccard_similarity(list1, list2): Calculate the Jaccard Similarity between two lists of integers. :param list1: List of integers :param list2: List of integers :return: Jaccard Similarity as a float set1 = set(list1) set2 = set(list2) intersection = len(set1 & set2) union = len(set1 | set2) if union == 0: return 0.0 return intersection / union"},{"question":"**Context**: You are working on a pattern matching system where each character in the pattern maps uniquely to a non-empty substring in the given string. Your task is to determine if such a bijection is possible given a pattern and a string. **Task**: Write a function `pattern_match(pattern: str, string: str) -> bool` that checks whether the input pattern can be fully matched to the input string based on the described mapping rules. Input * `pattern`: A string consisting of lowercase letters representing the pattern. * `string`: A string consisting of lowercase letters representing the target string. Output * Return a boolean value `True` if the pattern can be mapped to the string, otherwise `False`. Constraints * Both `pattern` and `string` only contain lowercase English letters. * Length of the pattern and string can be up to 20 characters. Examples 1. `pattern = \\"abab\\", string = \\"redblueredblue\\"` --> Output: `True` 2. `pattern = \\"aaaa\\", string = \\"asdasdasdasd\\"` --> Output: `True` 3. `pattern = \\"aabb\\", string = \\"xyzabcxzyabc\\"` --> Output: `False` Performance Requirements The solution should be optimized to handle large inputs efficiently, making use of recursive backtracking principles with an aim to reduce unnecessary computations. Additional Notes * Consider edge cases such as empty patterns and strings. * Ensure backtracking steps correctly handle failed mapping by clearing invalid entries from the mapping dictionary.","solution":"def pattern_match(pattern: str, string: str) -> bool: def backtrack(p_idx, s_idx, p_to_s_map, used_substrings): # If we\'ve reached the end of both the pattern and the string, it means we\'ve successfully matched everything if p_idx == len(pattern) and s_idx == len(string): return True # If we\'ve reached the end of the pattern but not the string, or vice versa, no match is possible if p_idx == len(pattern) or s_idx == len(string): return False # Get the current pattern character p_char = pattern[p_idx] # If the character is already mapped to a substring if p_char in p_to_s_map: sub_str = p_to_s_map[p_char] # Check if the substring matches the relevant part of the string if string.startswith(sub_str, s_idx): # If it matches, continue to the next character return backtrack(p_idx + 1, s_idx + len(sub_str), p_to_s_map, used_substrings) else: return False # Try to map the current pattern character to every possible substring starting from s_idx for end in range(s_idx + 1, len(string) + 1): sub_str = string[s_idx:end] if sub_str in used_substrings: continue # Add the new mapping and mark the substring as used p_to_s_map[p_char] = sub_str used_substrings.add(sub_str) if backtrack(p_idx + 1, s_idx + end - s_idx, p_to_s_map, used_substrings): return True # If it didn\'t work out, remove the mapping and continue del p_to_s_map[p_char] used_substrings.remove(sub_str) return False return backtrack(0, 0, {}, set())"},{"question":"# Scenario You are given the task of maintaining a phone contact list in a simple application. Each contact has a unique name (string) and a phone number (string). You need to implement efficient operations to add new contacts, search for contacts, and delete contacts based on their names. # Task Write a Python class `ContactList` using a Binary Search Tree (BST) to manage the contacts. Implement the following operations: 1. **Add a Contact**: `add_contact(name: str, phone: str) -> bool` - Adds a new contact to the list. Returns `True` if the contact was added successfully, and `False` if a contact with the same name already exists. 2. **Search for a Contact**: `search_contact(name: str) -> Optional[str]` - Searches for a contact by name. Returns the phone number if the contact exists, otherwise returns `None`. 3. **Delete a Contact**: `delete_contact(name: str) -> bool` - Deletes a contact by name. Returns `True` if the contact was deleted successfully, and `False` if the contact does not exist. # Input and Output Formats **Input**: - Method `add_contact(name: str, phone: str) -> bool`: Two strings representing the name and phone number. - Method `search_contact(name: str) -> Optional[str]`: One string representing the contact name. - Method `delete_contact(name: str) -> bool`: One string representing the contact name. **Output**: - Method `add_contact(name: str, phone: str) -> bool`: Returns `True` or `False`. - Method `search_contact(name: str) -> Optional[str]`: Returns the phone number string or `None`. - Method `delete_contact(name: str) -> bool`: Returns `True` or `False`. # Constraints - Names and phone numbers are non-empty strings with a maximum length of 100. - Names are unique within the contact list. # Edge Cases: 1. Adding a contact with a duplicate name should return `False`. 2. Searching or deleting a non-existent contact should handle gracefully. # Example: ```python cl = ContactList() assert cl.add_contact(\\"Alice\\", \\"12345\\") == True assert cl.add_contact(\\"Bob\\", \\"67890\\") == True assert cl.search_contact(\\"Alice\\") == \\"12345\\" assert cl.delete_contact(\\"Alice\\") == True assert cl.search_contact(\\"Alice\\") == None assert cl.delete_contact(\\"Charlie\\") == False ``` # Implementation ```python class TreeNode: def __init__(self, name=\\"\\", phone=\\"\\"): self.name = name self.phone = phone self.left = None self.right = None class ContactList: def __init__(self): self.root = None def add_contact(self, name, phone): # Implement add_contact using BST insertion logic pass def search_contact(self, name): # Implement search_contact using BST search logic pass def delete_contact(self, name): # Implement delete_contact using BST deletion logic pass ``` Complete the stubs for `add_contact`, `search_contact`, and `delete_contact` methods preserving the BST properties.","solution":"class TreeNode: def __init__(self, name=\\"\\", phone=\\"\\"): self.name = name self.phone = phone self.left = None self.right = None class ContactList: def __init__(self): self.root = None def add_contact(self, name, phone): if self.root is None: self.root = TreeNode(name, phone) return True else: return self._insert(self.root, name, phone) def _insert(self, root, name, phone): if name == root.name: return False # Duplicate contact elif name < root.name: if root.left is None: root.left = TreeNode(name, phone) return True else: return self._insert(root.left, name, phone) else: if root.right is None: root.right = TreeNode(name, phone) return True else: return self._insert(root.right, name, phone) def search_contact(self, name): return self._search(self.root, name) def _search(self, root, name): if root is None: return None if name == root.name: return root.phone elif name < root.name: return self._search(root.left, name) else: return self._search(root.right, name) def delete_contact(self, name): self.root, deleted = self._delete(self.root, name) return deleted def _delete(self, root, name): if root is None: return root, False if name < root.name: root.left, deleted = self._delete(root.left, name) return root, deleted elif name > root.name: root.right, deleted = self._delete(root.right, name) return root, deleted else: if root.left is None: return root.right, True elif root.right is None: return root.left, True min_larger_node = self._get_min(root.right) root.name, root.phone = min_larger_node.name, min_larger_node.phone root.right, _ = self._delete(root.right, root.name) return root, True def _get_min(self, root): while root.left is not None: root = root.left return root"},{"question":"**Objective**: Implement an efficient breadth-first traversal of a B-Tree. B-Trees are a foundational data structure, especially critical in database and file systems. You will be implementing a function to perform a breadth-first traversal (also known as level-order traversal) on a B-Tree and return the keys in the order they are visited. Function Signature ```python def breadth_first_traversal(btree: BTree) -> List[int]: pass ``` Input * A `BTree` object, which follows the structure provided in the initial code snippet. Output * A list of integers representing the keys of the B-Tree in the order visited during a breadth-first traversal. Constraints * You can assume the `BTree` will contain at least one node. * The tree has already been populated with integers, and no operations (insertions or deletions) will modify it during the traversal. Performance Requirements * The implementation should handle traversing B-Trees with large numbers of nodes efficiently both in terms of time and space complexities. Example Given a B-Tree structured with the following keys: ``` [10, 20] / | [1, 5] [15] [25, 30, 40] ``` A breadth-first traversal should return: ```python [10, 20, 1, 5, 15, 25, 30, 40] ``` # Brief Scenario You\'ve been tasked with developing a more efficient data retrieval system for a large-scale database. Using a B-Tree for organizing your data, your next step is to implement a breadth-first traversal method to ensure that high-level operations can efficiently access data step by step from the root towards the leaves. Points to Consider * Use a queue data structure to facilitate the level-order traversal. * Ensure you capture all keys in the correct order from each level before proceeding to the next level. Implement the `breadth_first_traversal` function as described.","solution":"from collections import deque from typing import List class BTreeNode: def __init__(self, is_leaf: bool = True): self.is_leaf = is_leaf self.keys = [] self.children = [] def breadth_first_traversal(btree: BTreeNode) -> List[int]: if not btree: return [] result = [] queue = deque([btree]) while queue: node = queue.popleft() result.extend(node.keys) if not node.is_leaf: for child in node.children: queue.append(child) return result"},{"question":"Context You’ve been hired to develop a digital library system that needs to handle metadata for numeric identifiers of books. As part of the system, you need to write a function capable of determining the number of digits in numeric identifiers. These identifiers might be large, and handling them efficiently is crucial for system performance. Your task is to write a function `count_digits` that: - Handles both positive and negative integers. - Handles zero correctly. - Returns the number of digits disregarding the sign of the number. Function Signature ```python def count_digits(n: int) -> int: pass ``` Input and Output Formats - **Input**: - An integer `n` which can be positive, negative, or zero. - **Output**: - An integer representing the number of digits in the absolute value of the input integer. Constraints - The input can be any integer within the range ( -10^{18} ) to ( 10^{18} ). Example Example 1: ```python assert count_digits(12345) == 5 # Number is 12345, thus 5 digits ``` Example 2: ```python assert count_digits(-9876) == 4 # Number is -9876, thus 4 digits ignoring the sign ``` Example 3: ```python assert count_digits(0) == 1 # Number is 0, thus 1 digit ``` **Note**: You may assume that the inputs will be valid integers as per the constraints. Additional Information - Consider edge cases where n=0, and ensure negative numbers are treated correctly.","solution":"def count_digits(n: int) -> int: Returns the number of digits in the absolute value of the input integer. Parameters: n (int): The input integer, which can be positive, negative or zero. Returns: int: The number of digits in the absolute value of the input integer. return len(str(abs(n)))"},{"question":"# Question You are tasked with implementing the Run-Length Encoding (RLE) and decoding algorithms. These algorithms are useful for compressing data by replacing sequences of the same character with a single character followed by the count of repetitions. Function 1: `encode_rle` Implement a function `encode_rle(input: str) -> str` that takes a string input and returns its Run-Length Encoded representation. ```python def encode_rle(input: str) -> str: # Your implementation here ``` **Input**: - A single string `input` (0 <= len(input) <= 10^6) containing ASCII characters. **Output**: - A Run-Length Encoded string. Function 2: `decode_rle` Implement a function `decode_rle(input: str) -> str` that takes a Run-Length Encoded string and returns the original string. ```python def decode_rle(input: str) -> str: # Your implementation here ``` **Input**: - An encoded string `input` (0 <= len(input) <= 10^6). **Output**: - The decoded original string. Constraints: 1. The encoded string for `decode_rle` will always be valid. 2. The functions should handle large inputs efficiently. 3. Ensure the functions can handle empty strings and edge cases gracefully. Example ```python # Example 1: input_string = \\"aaaabbbcca\\" encoded_string = encode_rle(input_string) print(encoded_string) # Output: \\"4a3b2c1a\\" decoded_string = decode_rle(encoded_string) print(decoded_string) # Output: \\"aaaabbbcca\\" # Example 2: input_string = \\"abcd\\" encoded_string = encode_rle(input_string) print(encoded_string) # Output: \\"1a1b1c1d\\" decoded_string = decode_rle(encoded_string) print(decoded_string) # Output: \\"abcd\\" ``` Implement these functions to accurately encode and decode strings using the RLE algorithm. Ensure that your implementation efficiently handles edge cases and large inputs.","solution":"def encode_rle(input: str) -> str: if not input: return \\"\\" encoded = [] count = 1 for i in range(1, len(input)): if input[i] == input[i - 1]: count += 1 else: encoded.append(f\\"{count}{input[i - 1]}\\") count = 1 encoded.append(f\\"{count}{input[-1]}\\") return \'\'.join(encoded) def decode_rle(input: str) -> str: decoded = [] count = \\"\\" for char in input: if char.isdigit(): count += char else: decoded.append(char * int(count)) count = \\"\\" return \'\'.join(decoded)"},{"question":"Implement a Bitwise Array Manipulator Context You are tasked with manipulating an array of integers at the bit level to optimize memory usage for a performance-critical application. Specifically, you need to perform various operations on the bits of these integers in the array to facilitate efficient data storage and retrieval. Problem Write a function `bitwise_array_manipulator` that takes an array of 32-bit integers `arr` and a list of operations `ops`, and applies these operations to the array in sequence. Each operation is a tuple of the form (command, index, bit_index, value), where: - `command` is one of \\"get\\", \\"set\\", \\"clear\\", \\"update\\". - `index` is the position of the integer in the array. - `bit_index` is the specific bit within that integer. - `value` is only used with the \\"update\\" command and can be 0 or 1. The function should return a list of results for \\"get\\" operations in the order they were executed. Function Signature ```python def bitwise_array_manipulator(arr: List[int], ops: List[Tuple[str, int, int, int]]) -> List[bool]: ``` Input * `arr`: List[int] - An array of 32-bit integers. * `ops`: List[Tuple[str, int, int, int]] - A list of operations, where each operation is a tuple. Output * List[bool] - A list of results for \\"get\\" operations. Constraints * 1 <= len(arr) <= 1000 * 0 <= len(ops) <= 1000 * 0 <= index < len(arr) * 0 <= bit_index < 32 * value ∈ {0, 1} # Example ```python arr = [0, 1, 2] ops = [(\\"set\\", 0, 1, 0), (\\"get\\", 1, 0, 0), (\\"clear\\", 1, 0, 0), (\\"update\\", 2, 1, 1), (\\"get\\", 2, 1, 0)] ``` * After `set` operation, arr becomes [2, 1, 2] * After `get` operation, result is True (1st bit of 1 is set) * After `clear` operation, arr becomes [2, 0, 2] * After `update` operation, arr becomes [2, 0, 6] * After `get` operation, result is True (1st bit of 6 is set) ```python assert bitwise_array_manipulator(arr, ops) == [True, True] ``` **Note**: Ensure to handle bit manipulations efficiently and cater to edge cases.","solution":"from typing import List, Tuple def bitwise_array_manipulator(arr: List[int], ops: List[Tuple[str, int, int, int]]) -> List[bool]: results = [] for command, index, bit_index, value in ops: if command == \\"get\\": results.append((arr[index] & (1 << bit_index)) != 0) elif command == \\"set\\": arr[index] |= (1 << bit_index) elif command == \\"clear\\": arr[index] &= ~(1 << bit_index) elif command == \\"update\\": if value: arr[index] |= (1 << bit_index) else: arr[index] &= ~(1 << bit_index) return results"},{"question":"# Problem Description You are tasked with writing a function that reverses the order of words in a given string but also maintains the sequence of characters within each word. The function should be efficient, robust, and handle edge cases and performance efficiently. # Function Signature ```python def reverse_sentence_preserving_word_characters(sentence: str) -> str: pass ``` # Input * **sentence** (str): A string that represents a sentence (1 <= len(sentence) <= 10^5). # Output * **reversed_sentence** (str): The input sentence with the order of words reversed but the characters within each word preserved. # Constraints * Each word in the sentence is separated by a single space. * The sentence does not have leading or trailing spaces. * There may be punctuation marks inside words. # Examples ```python # Example 1 input_sentence = \\"I am keon kim and I like pizza\\" print(reverse_sentence_preserving_word_characters(input_sentence)) # Output: \\"pizza like I and kim keon am I\\" # Example 2 input_sentence = \\"Hello, World!\\" print(reverse_sentence_preserving_word_characters(input_sentence)) # Output: \\"World! Hello,\\" # Example 3 input_sentence = \\"\\" print(reverse_sentence_preserving_word_characters(input_sentence)) # Output: \\"\\" ``` # Explanation 1. The function should first split the sentence into individual words. 2. Then, reverse the order of these words. 3. Finally, join the reversed list of words into a single string and return it. # Performance Requirements - The solution should operate in O(N) time complexity. - It should utilize O(N) auxiliary space for storing the split words. # Additional Scenarios Ensure your function handles: 1. Empty input string. 2. Sentences with punctuation, digits, and special characters.","solution":"def reverse_sentence_preserving_word_characters(sentence: str) -> str: Reverses the order of words in the given sentence, while preserving the character sequence within each word. Args: sentence (str): The input sentence (1 <= len(sentence) <= 10^5). Returns: str: The sentence with the order of words reversed but characters within each word in the same order. if not sentence: return \\"\\" words = sentence.split() reversed_words = words[::-1] reversed_sentence = \\" \\".join(reversed_words) return reversed_sentence"},{"question":"# Question You are given an implementation for switching pairs of elements within a stack using auxiliary storage. Now, extend this implementation by writing a function that checks if it\'s possible to achieve a similar operation but with the following constraints and requirements: * Perform the transformation in place, i.e., without using any additional stack or queue (i.e., auxiliary storage structures). * Your function should accept a stack implemented via a Python list and return the modified stack. * If the number of elements in the stack is odd, the topmost element should remain in its original position. * Input will be a list of integers, where the last element corresponds to the top of the stack. * You should ensure your function has a time complexity of O(n). Example: ``` Input: [3, 8, 17, 9, 1, 10] Output: [8, 3, 9, 17, 10, 1] Input: [3, 8, 17, 9, 1] Output: [8, 3, 9, 17, 1] ``` Function Signature ```python def inplace_switch_pairs(stack: list[int]) -> list[int]: pass ``` Constraints * The stack will contain at most (10^5) elements. * Each element of the stack will be an integer in the range (-10^9) to (10^9). Your task is to implement the function `inplace_switch_pairs` that performs the specified operations efficiently.","solution":"def inplace_switch_pairs(stack): Switches pairs of elements in place within the stack list. :param stack: List of integers representing the stack. :return: List of integers representing the modified stack. n = len(stack) for i in range(0, n - 1, 2): stack[i], stack[i + 1] = stack[i + 1], stack[i] return stack"},{"question":"# Queue Data Structures Implementation Challenge **Context**: You have been tasked with extending a queue implementation to handle higher volumes of data efficiently. The Queue ADT can be implemented using either an underlying array or a linked list. Both implementations have distinct advantages and disadvantages concerning time and space complexity. # Task Implement a more efficient `ArrayQueue` where the array behaves as a circular buffer. # Specifications 1. Extend the given `ArrayQueue` so that it dynamically resizes efficiently, maintaining appended elements in a circular manner. 2. Add a `__str__` method which returns a string representation of the queue. 3. Ensure your `ArrayQueue` supports the following methods: - `enqueue(value)`: Adds a new item to the rear of the queue. - `dequeue()`: Removes the front item from the queue and returns it. - `is_empty()`: Returns a boolean indicating whether the queue is empty. - `peek()`: Returns the front item of the queue without removing it. - `__len__()`: Returns the number of items in the queue. - `__str__()`: Returns a string representation of the queue. # Input & Output Formats - `enqueue(value)`: Takes a value of any data type. - `dequeue()`: Returns the dequeued value (raises IndexError if empty). - `is_empty()`: Returns a boolean. - `peek()`: Returns the front item (raises IndexError if empty). - `__len__()`: Returns an integer. - `__str__()`: Returns a string. # Constraints - The queue should efficiently handle enqueue and dequeue operations in O(1) time amortized. # Examples Example 1: ```python q = ArrayQueue(5) q.enqueue(10) q.enqueue(20) print(q) # Output: [10, 20] print(q.dequeue()) # Output: 10 print(q) # Output: [20] ``` Example 2: ```python q.enqueue(30) q.enqueue(40) q.enqueue(50) q.enqueue(60) print(q) # Output: [20, 30, 40, 50, 60] q.dequeue() q.dequeue() q.dequeue() q.dequeue() print(q) # Output: [60] ``` # Edge Cases: 1. Dequeue or peek from an empty queue should raise an IndexError. 2. Circular wrapping of elements when the internal array is resized multiple times. Implement this `ArrayQueue` class efficiently.","solution":"class ArrayQueue: def __init__(self, initial_capacity=10): self.array = [None] * initial_capacity self.size = 0 self.front = 0 self.rear = 0 self.capacity = initial_capacity def enqueue(self, value): if self.size == self.capacity: self._resize(2 * self.capacity) self.array[self.rear] = value self.rear = (self.rear + 1) % self.capacity self.size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"dequeue from empty queue\\") value = self.array[self.front] self.array[self.front] = None # Clear the slot self.front = (self.front + 1) % self.capacity self.size -= 1 return value def is_empty(self): return self.size == 0 def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty queue\\") return self.array[self.front] def __len__(self): return self.size def __str__(self): if self.is_empty(): return \\"[]\\" elements = [] for i in range(self.size): elements.append(self.array[(self.front + i) % self.capacity]) return \\"[\\" + \\", \\".join(map(str, elements)) + \\"]\\" def _resize(self, new_capacity): old_array = self.array self.array = [None] * new_capacity for i in range(self.size): self.array[i] = old_array[(self.front + i) % self.capacity] self.front = 0 self.rear = self.size self.capacity = new_capacity"},{"question":"# Binary Tree Paths Generation Context You are working on a problem involving binary trees, where you need to generate all the root-to-leaf paths in a given binary tree. This problem is common in applications that involve decision trees or pathfinding algorithms and involves understanding tree traversal using Depth-First Search (DFS). Task Write a function `binary_tree_paths(root)` that generates all root-to-leaf paths in a binary tree. The tree nodes have the following structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Input Your function `binary_tree_paths` should take a single argument: * `root`: The root node of the binary tree. It can be `None` for an empty tree. Output The function should return: * A list of strings, where each string represents a path from the root node to a leaf node. Paths should be constructed in the format `a->b->c`, where `a`, `b`, and `c` are node values. Constraints * The number of nodes in the tree is in the range [0, 100]. * -100 <= Node.val <= 100 Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example binary tree: # 1 # / # 2 3 # # 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.right = TreeNode(5) print(binary_tree_paths(root)) # Output: [\\"1->2->5\\", \\"1->3\\"] ``` Your implementation should consider edge cases, efficiently handle deep or unbalanced trees, and construct path strings correctly.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root): if not root: return [] def dfs(node, path, paths): if not node.left and not node.right: paths.append(path) if node.left: dfs(node.left, path + f\\"->{node.left.val}\\", paths) if node.right: dfs(node.right, path + f\\"->{node.right.val}\\", paths) paths = [] dfs(root, f\\"{root.val}\\", paths) return paths"},{"question":"# Fenwick Tree Hackathon Scoring You are organizing a hackathon where each participant accumulates points based on completed challenges. You decide to use a Fenwick Tree to efficiently manage and query participant scores. In this problem, you should implement the Fenwick Tree to handle dynamic score updates and prefix sum queries. **Function Requirements**: 1. `initialize_score(n: int) -> None`: * Initializes the score array for `n` participants with all initially set to 0. 2. `update_score(index: int, value: int) -> None`: * Adds `value` to the score of the participant at position `index`. 3. `query_score(index: int) -> int`: * Returns the cumulative score from the start up to the participant at position `index`. **Input/Output formats**: * `initialize_score(n: int)`: - Input: An integer `n` where 1 ≤ n ≤ 10^5. - No output. * `update_score(index: int, value: int)`: - Input: An integer `index` (0 ≤ index < n) and an integer `value` which can be negative or positive (|value| ≤ 10^4). - No output. * `query_score(index: int)`: - Input: An integer `index` (0 ≤ index < n). - Output: An integer representing the summed score from the start to `index`. **Constraints**: 1. You must maintain the Fenwick Tree to handle modifications and queries. 2. Operations will be called in a sequence within `n` appropriately. 3. Aim for efficient O(log n) operations for updates and queries. **Scenario**: During the event, you will frequently update participant scores and query for the top `k` participants\' cumulative scores. Your implementation will help automate this process and ensure smooth event management. ```python class FenwickTreeScoring: def __init__(self): self.bit_tree = None self.n = 0 def initialize_score(self, n: int) -> None: self.n = n self.bit_tree = [0] * (n+1) def update_score(self, index: int, value: int) -> None: i = index + 1 while i <= self.n: self.bit_tree[i] += value i += i & (-i) def query_score(self, index: int) -> int: s = 0 i = index + 1 while i > 0: s += self.bit_tree[i] i -= i & (-i) return s # Example usage: # scoring = FenwickTreeScoring() # scoring.initialize_score(5) # scoring.update_score(1, 10) # scoring.update_score(2, 20) # print(scoring.query_score(2)) # Output should be 30 ``` Implement the class and its methods considering the constraints and expected efficiency.","solution":"class FenwickTreeScoring: def __init__(self): self.bit_tree = None self.n = 0 def initialize_score(self, n: int) -> None: self.n = n self.bit_tree = [0] * (n+1) def update_score(self, index: int, value: int) -> None: i = index + 1 while i <= self.n: self.bit_tree[i] += value i += i & (-i) def query_score(self, index: int) -> int: s = 0 i = index + 1 while i > 0: s += self.bit_tree[i] i -= i & (-i) return s"},{"question":"You are given two non-negative integers `num1` and `num2` represented as strings. Your task is to write a function `multiply_large_numbers(num1: str, num2: str) -> str` that returns the product of these two numbers as a string. Requirements: 1. You **must not** use any built-in BigInteger library or convert the inputs directly to integers. 2. The length of both `num1` and `num2` will be less than 110. 3. Both `num1` and `num2` contain only digits from \'0\' to \'9\'. 4. Neither `num1` nor `num2` will contain any leading zeros. Constraints: - `1 <= len(num1), len(num2) <= 109` - `num1` and `num2` each consist of digits only and do not contain leading zeros. Example: ```python assert multiply_large_numbers(\\"123\\", \\"456\\") == \\"56088\\" assert multiply_large_numbers(\\"999\\", \\"999\\") == \\"998001\\" assert multiply_large_numbers(\\"0\\", \\"12345\\") == \\"0\\" assert multiply_large_numbers(\\"1\\", \\"23\\") == \\"23\\" ``` # Guidelines: 1. Ensure that your function correctly handles edge cases such as multiplying by zero and numbers of greatly differing lengths. 2. Pay attention to performance bottlenecks. Although optimality is not the primary focus, efficiency is still important. 3. Consider how you manage intermediate results to form the final product string. **Hint**: Mimic the manual multiplication process you learned in grade school, leveraging the positional weights and summing the intermediate products at the end. Function Signature: ```python def multiply_large_numbers(num1: str, num2: str) -> str: # Your implementation here pass if __name__ == \\"__main__\\": print(multiply_large_numbers(\\"123\\", \\"456\\")) # Should output \\"56088\\" print(multiply_large_numbers(\\"999\\", \\"999\\")) # Should output \\"998001\\" print(multiply_large_numbers(\\"0\\", \\"12345\\")) # Should output \\"0\\" print(multiply_large_numbers(\\"1\\", \\"23\\")) # Should output \\"23\\" ```","solution":"def multiply_large_numbers(num1: str, num2: str) -> str: # Edge case where any number is zero if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" # Initialize result array result = [0] * (len(num1) + len(num2)) # Reverse the strings to simplify the positional multiplication num1, num2 = num1[::-1], num2[::-1] # Perform multiplication digit by digit for i in range(len(num1)): for j in range(len(num2)): mul = int(num1[i]) * int(num2[j]) result[i + j] += mul result[i + j + 1] += result[i + j] // 10 result[i + j] %= 10 # Convert result back to string while len(result) > 1 and result[-1] == 0: result.pop() result = result[::-1] return \'\'.join(map(str, result))"},{"question":"# Integer Partition Problem Given a positive integer `n`, write a function `int_divide(n)` that returns the number of different ways `n` can be partitioned into sums of smaller integer values. The partitioned numbers must be non-negative integers. Demonstrate your understanding of dynamic programming by implementing an efficient approach. Function Signature: ```python def int_divide(n: int) -> int: ``` Input: - An integer `n` (1 ≤ n ≤ 100). Output: - An integer representing the number of ways `n` can be decomposed into sums of smaller integers. Example: ```python print(int_divide(4)) # Output: 5 print(int_divide(7)) # Output: 15 ``` Explanation: For instance, given `n = 4`, there are 5 ways: - 4 - 3 + 1 - 2 + 2 - 2 + 1 + 1 - 1 + 1 + 1 + 1 **Constraints**: - Avoid recursion to handle higher input limits within time constraints efficiently. - Ensure your solution handles the edge cases within the given bounds. Additional Context: Dynamic programming should be employed to build up the solution using previously computed results to achieve a time complexity of O(n^2) and space complexity of O(n^2).","solution":"def int_divide(n: int) -> int: Returns the number of ways a positive integer n can be partitioned into sums of smaller integer values. dp = [[0] * (n + 1) for _ in range(n + 1)] # Initialize the base case: there\'s one way to partition 0 (using no number at all) dp[0][0] = 1 for i in range(1, n + 1): for j in range(n + 1): dp[i][j] = dp[i-1][j] if j >= i: dp[i][j] += dp[i][j-i] return dp[n][n]"},{"question":"# Question: Implement an Enhanced Resizable Hash Table You are asked to implement a Resizable Hash Table with some advanced features: 1. Modular Arithmetic Hash Function: - Use a different hash function that helps reduce collisions. - The initial hash function can be a simple modulus operation; however, you should incorporate enhancements for better distribution. 2. Quadratic Probing for Collision Resolution: - Implement Quadratic Probing instead of Linear Probing. 3. Resizable Capabilities: - The table should double its size when 2/3 full. - Implement an additional feature to shrink the table size by half if it is less than 1/4 full. # Requirements: - **Function Implementations**: - `put(key, value)`: Inserts key-value pair. - `get(key)`: Retrieves the value for a given key. - `del_(key)`: Deletes the key-value pair for a given key. - `resize()`: Resizes the table and rehashes all existing keys. # Input & Output: - `put(key, value)`: - Input: `key` (integer), `value` (any type), assumes unique keys. - Output: None - `get(key)`: - Input: `key` (integer) - Output: Returns the value for the given key, or `None` if not found. - `del_(key)`: - Input: `key` (integer) - Output: None # Constraints: - Use modular arithmetic with prime numbers to enhance the hash function. - Implement quadratic probing: hash_ = (initial_hash + i^2) % size - Ensure resizing operations (doubling and halving the table size) maintain efficiency. # Performance: - Average case operations for get, put, and delete should remain O(1). - Avoid worst-case performance where possible with enhanced probing and hash function. ```python class EnhancedHashTable: _empty = object() _deleted = object() MIN_SIZE = 8 def __init__(self): self.size = self.MIN_SIZE self._len = 0 self._keys = [self._empty] * self.size self._values = [self._empty] * self.size def put(self, key, value): ... # Add your implementation for put method here. ... def get(self, key): ... # Add your implementation for get method here. ... def del_(self, key): ... # Add your implementation for del method here. ... def _resize(self, new_size): ... # Add your implementation for resize method here. ... def _hash(self, key): ... # Add your implementation for new hash method here. ... def _rehash(self, old_hash, i): ... # Add your implementation for quadratic probing here. ... # Additional required methods and properties ``` Provide sample test cases to verify the functionality of the Enhanced Hash Table.","solution":"class EnhancedHashTable: _empty = object() _deleted = object() MIN_SIZE = 8 def __init__(self): self.size = self.MIN_SIZE self._len = 0 self._keys = [self._empty] * self.size self._values = [self._empty] * self.size def _hash(self, key): # Basic hash function using modular arithmetic with a prime number return key % 31 def _rehash(self, initial_hash, i): # Quadratic probing function return (initial_hash + i*i) % self.size def put(self, key, value): if self._len >= (2 * self.size) // 3: self._resize(2 * self.size) initial_hash = self._hash(key) i = 0 while self._keys[self._rehash(initial_hash, i)] not in {self._empty, self._deleted}: if self._keys[self._rehash(initial_hash, i)] == key: break # Allows update of existing value i += 1 hash_index = self._rehash(initial_hash, i) self._keys[hash_index] = key self._values[hash_index] = value self._len += 1 def get(self, key): initial_hash = self._hash(key) i = 0 while self._keys[self._rehash(initial_hash, i)] is not self._empty: if self._keys[self._rehash(initial_hash, i)] == key: return self._values[self._rehash(initial_hash, i)] i += 1 return None def del_(self, key): initial_hash = self._hash(key) i = 0 while self._keys[self._rehash(initial_hash, i)] is not self._empty: if self._keys[self._rehash(initial_hash, i)] == key: hash_index = self._rehash(initial_hash, i) self._keys[hash_index] = self._deleted self._values[hash_index] = self._deleted self._len -= 1 break i += 1 if self._len <= self.size // 4 and self.size > self.MIN_SIZE: self._resize(self.size // 2) def _resize(self, new_size): old_keys = self._keys old_values = self._values self.size = new_size self._keys = [self._empty] * self.size self._values = [self._empty] * self.size self._len = 0 for i in range(len(old_keys)): if old_keys[i] not in {self._empty, self._deleted}: self.put(old_keys[i], old_values[i])"},{"question":"# Longest Common Subsequence Problem Scenario: Suppose you are working as a software engineer in a bioinformatics company, and you need to compare DNA sequences to identify the longest common subsequences for mutation studies. One of the sequences always contains unique characters, ensuring no duplicity in the genetic codes. Problem Statement: Write a function that takes two strings `a` and `b` as input, where string `b` contains all distinct characters, and returns the length of the longest common subsequence (LCS) between them. # Function Signature: ```python def longest_common_subsequence(a: str, b: str) -> int: ``` # Input: - `a` (string): The first string (can contain duplicate characters). - `b` (string): The second string (contains all unique characters). # Output: - `int`: The length of the longest common subsequence. # Constraints: - The length of `a` and `b` will not exceed (10^4). - String `b` will always contain all unique characters. # Example: ```python assert longest_common_subsequence(\\"abcde\\", \\"ace\\") == 3 assert longest_common_subsequence(\\"abc\\", \\"abc\\") == 3 assert longest_common_subsequence(\\"abc\\", \\"def\\") == 0 assert longest_common_subsequence(\\"\\", \\"abcdef\\") == 0 assert longest_common_subsequence(\\"abcdef\\", \\"zab\\") == 2 ``` # Explanation: For `a = \\"abcde\\"` and `b = \\"ace\\"`, the longest common subsequence is \\"ace\\", thus the length is 3. # Performance Requirements: - Target complexity: O(n log m), where `n` is the length of `a` and `m` is the length of `b`. - Optimize to handle strings up to length (10^4). **Implementation Note**: Consider using binary search or dynamic programming techniques for optimal performance.","solution":"def longest_common_subsequence(a: str, b: str) -> int: Function to find the length of the longest common subsequence (LCS) between two strings `a` and `b`, where string `b` contains all unique characters. m, n = len(a), len(b) # Create a table to store lengths of longest common subsequence # of substrings. table[i][j] contains the length of LCS of `a[:i]` and `b[:j]` table = [[0] * (n + 1) for _ in range(m + 1)] # Build the table in bottom-up fashion for i in range(1, m + 1): for j in range(1, n + 1): if a[i - 1] == b[j - 1]: table[i][j] = table[i - 1][j - 1] + 1 else: table[i][j] = max(table[i - 1][j], table[i][j - 1]) return table[m][n]"},{"question":"# Question You are tasked with implementing a function to determine if one binary tree is a subtree of another binary tree. Given two binary trees `big` and `small`, write a function `is_subtree(big, small)` that returns `True` if `small` is a subtree of `big`, and `False` otherwise. Input - `big`: The root node of the larger binary tree. - `small`: The root node of the smaller binary tree. Output - Returns `True` if `small` is a subtree of `big`, otherwise `False`. Constraints - Both `big` and `small` can be empty (in which case the function should return `False`). - Treenodes are defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Scenario Consider you are designing a hierarchical file system verification tool where you need to check if a directory structure (represented as a tree) is part of another larger directory structure. This function will help you verify such hierarchical substructures efficiently. Examples 1. Given `big`: 3 / 4 5 / 1 2 and `small`: 4 / 1 2 Output: `True`. 2. Given `big`: 3 / 4 5 / 1 2 / 0 and `small`: 4 / 1 2 Output: `False` as `small` does not include the node with value `0`. Function Signature ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_subtree(big: TreeNode, small: TreeNode) -> bool: # Your implementation here ``` You need to complete the implementation of the `is_subtree` function based on the analysis provided.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_subtree(big: TreeNode, small: TreeNode) -> bool: if not small: return True # An empty tree is always a subtree if not big: return False # big is empty and small is not, so it cannot be a subtree if are_identical(big, small): return True # Check for small in either left subtree or right subtree of big return is_subtree(big.left, small) or is_subtree(big.right, small) def are_identical(root1: TreeNode, root2: TreeNode) -> bool: if not root1 and not root2: return True # Both trees are empty if not root1 or not root2: return False # One tree is empty, the other is not # Check if the data of both nodes is the same and data of left and right subtrees are the same return (root1.val == root2.val and are_identical(root1.left, root2.left) and are_identical(root1.right, root2.right))"},{"question":"Search in a Row and Column Sorted Matrix Given a m x n matrix where each row is sorted in non-decreasing order and each column is also sorted in non-decreasing order, write a function: ```python def search_in_a_sorted_matrix(mat: List[List[int]], key: int) -> str: ``` **Inputs**: - `mat` (list of list of ints): A 2D list representing the matrix of dimensions m x n. - `key` (int): The integer key to be searched for in the matrix. **Outputs**: - A string indicating the location of the key in the format `Key {key} found at row- {row} column- {column}`. - If the key is not found, return `Key {key} not found`. **Constraints**: 1. The number of rows in the matrix will be between 1 and 1000. 2. The number of columns in the matrix will be between 1 and 1000. 3. All the integers in the matrix and the key will be between -10^6 and 10^6. You are expected to implement a solution with time complexity O(m + n) where m is the number of rows and n is the number of columns. **Scenarios to Consider**: 1. The key is present in the matrix. 2. The key is not present in the matrix. 3. The key is the smallest or largest element in the matrix. 4. The matrix has only one row or one column. 5. The given matrix is empty (though constraints specify matrix will always have at least one row and column). **Example**: ```python mat = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] key = 13 search_in_a_sorted_matrix(mat, key) # Output: \'Key 13 found at row- 2 column- 3\' key = 10 search_in_a_sorted_matrix(mat, key) # Output: \'Key 10 not found\' ```","solution":"from typing import List def search_in_a_sorted_matrix(mat: List[List[int]], key: int) -> str: Searches for a given key in a row and column sorted matrix. Args: mat (List[List[int]]): 2D list representing the matrix of dimensions m x n. key (int): Integer key to be searched in the matrix. Returns: str: Location of the key in the format \\"Key {key} found at row-{row} column-{column}\\" or \\"Key {key} not found\\". if not mat or not mat[0]: return f\\"Key {key} not found\\" m, n = len(mat), len(mat[0]) row, col = 0, n - 1 while row < m and col >= 0: if mat[row][col] == key: return f\\"Key {key} found at row- {row + 1} column- {col + 1}\\" elif mat[row][col] > key: col -= 1 else: row += 1 return f\\"Key {key} not found\\""},{"question":"# Maximum Sum of Contiguous Subsequence As a data analyst, you have been given a list of stock prices representing the net change in stock prices daily. Your task is to find the best possible gain one could achieve by buying and selling stock once, based on these price changes. Given: ```text An array of integers, where each element represents the net daily change in stock prices. ``` You need to write a function: ```python def max_contiguous_subsequence_sum(arr: List[int]) -> int: pass ``` # Input * **arr**: List of integers (negative, positive, and zero values are allowed). # Output * Return the maximum sum of a contiguous subsequence in the array. # Constraints * The array can have up to 10^6 elements. * Each element in the array can have a magnitude up to 10^3. # Requirements 1. Your solution should run in linear time, O(n). 2. Use O(1) extra space. 3. Handle edge cases such as empty arrays or arrays with all negative numbers. # Example ```python print(max_contiguous_subsequence_sum([-2, 3, 8, -1, 4])) # Output: 14 print(max_contiguous_subsequence_sum([-1, 1, 0])) # Output: 1 print(max_contiguous_subsequence_sum([-1, -3, -4])) # Output: -1 print(max_contiguous_subsequence_sum([-2, 3, 8, -12, 8, 4])) # Output: 12 print(max_contiguous_subsequence_sum([])) # Output: 0 print(max_contiguous_subsequence_sum([-1])) # Output: -1 ``` Consider the given problem scenario and constraints, and write a solution function `max_contiguous_subsequence_sum` that uses Kadane\'s Algorithm efficiently.","solution":"def max_contiguous_subsequence_sum(arr): Returns the maximum sum of a contiguous subsequence in the array. If the array is empty, returns 0. if not arr: return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"Level Order Traversal of a Binary Tree Scenario You are working on a feature to analyze binary tree structures efficiently. One essential task is to perform a level order traversal of the tree and output the values of nodes level by level. Task Write a function `level_order_traversal` that takes in the root node of a binary tree and returns a list of lists, with each inner list containing the values of nodes at each level from left to right. Function Signature ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: TreeNode) -> List[List[int]]: # your code here ``` Input - `root` (TreeNode): The root of the binary tree. Output - List[List[int]]: A list of lists, where each inner list contains the values of the nodes at a specific tree level. Constraints - The number of nodes in the tree is in the range `[0, 2000]`. - The value of each node is an integer in the range `[-10^4, 10^4]`. Example ```python # Example 1: # Given binary tree [3, 9, 20, null, null, 15, 7], # 3 # / # 9 20 # / # 15 7 # The expected output is: [ # [3], # [9, 20], # [15, 7] # ] root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) print(level_order_traversal(root)) # Output: [[3], [9, 20], [15, 7]] # Example 2: # For an empty tree (null input), # The expected output is: [] print(level_order_traversal(None)) # Output: [] ``` Make sure your solution handles edge cases such as an empty tree and a single-node tree correctly.","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: Perform level order traversal of a binary tree and return a list of lists of node values by level. if not root: return [] result = [] queue = deque([root]) while queue: level_length = len(queue) level_nodes = [] for _ in range(level_length): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"You are tasked with implementing a modified version of a priority queue with additional functionalities. The priority queue should efficiently manage elements with varying priorities and allow retrieval of the highest priority element. # Function Implementations You need to implement the following functions within the priority queue class: 1. **Remove Item** * `remove(item: Any) -> bool`: Remove a specific item from the priority queue. Return `True` if the item was successfully removed, and `False` if the item does not exist in the queue. 2. **Peek Highest Priority Item** * `peek() -> Any`: Return the data of the highest priority item without removing it from the queue. If the queue is empty, return `None`. The `PriorityQueue` class and its methods should maintain the existing properties and functionalities as outlined in the original code. Input and Output Formats * **remove(item: Any) -> bool** * **Input**: An item to be removed from the priority queue. * **Output**: Boolean indicating the success of the operation. * **peek() -> Any** * **Output**: The highest priority item in the queue. Return `None` if the queue is empty. # Constraints * You may assume the priority values of items are unique. * Operations should maintain the given time complexities of the existing priority queue. # Example ```python pq = PriorityQueue([4, 1, 3], [4, 1, 3]) print(pq) # PriorityQueue([4: 4, 3: 3, 1: 1]) pq.push(5, 2) print(pq) # PriorityQueue([4: 4, 3: 3, 5: 2, 1: 1]) print(pq.peek()) # 4 print(pq.remove(3)) # True print(pq) # PriorityQueue([4: 4, 5: 2, 1: 1]) print(pq.remove(6)) # False ``` Implement the additional functions and test them against the example cases.","solution":"import heapq class PriorityQueue: def __init__(self, items=None, priorities=None): self.queue = [] self.entry_finder = {} self.REMOVED = \'<removed-item>\' if items and priorities: for item, priority in zip(items, priorities): self.push(item, priority) def push(self, item, priority): \'Add a new item or update the priority of an existing item\' if item in self.entry_finder: self.remove(item) entry = [priority, item] self.entry_finder[item] = entry heapq.heappush(self.queue, entry) def pop(self): \'Remove and return the highest priority item. Raise KeyError if empty.\' while self.queue: priority, item = heapq.heappop(self.queue) if item != self.REMOVED: del self.entry_finder[item] return item raise KeyError(\'pop from an empty priority queue\') def remove(self, item): \'Mark an existing item as REMOVED. Return True if successfully removed, False otherwise\' if item in self.entry_finder: entry = self.entry_finder.pop(item) entry[-1] = self.REMOVED return True return False def peek(self): \'Return the highest priority item without removing it. Return None if empty.\' while self.queue: priority, item = self.queue[0] if item != self.REMOVED: return item else: heapq.heappop(self.queue) return None def __repr__(self): \'Returns string representation of the priority queue\' return f\\"PriorityQueue({[entry for entry in self.queue if entry[-1] != self.REMOVED]})\\""},{"question":"# Scenario You are given the task of developing a simple recommendation system. The recommendation system utilizes the nearest neighbor algorithm to recommend the most similar items to a user based on their preference vector. # Task Implement a function `recommend` that takes a user preference vector and a dictionary (representing items with their feature vectors) and returns the item closest to the user\'s preference. # Input - **user_vector (tuple)**: A non-empty tuple representing the user\'s preference vector. - **item_dict (dict)**: A non-empty dictionary where keys are tuples representing item feature vectors and values are item names. Assume all vectors have the same length. # Output - **Recommended Item (str)**: The item name from `item_dict` that is closest to the `user_vector`. # Constraints - The user vector and each item feature vector will have a size no larger than 100. - The number of items in the item dictionary will be no larger than 1000. # Function Signature ```python def recommend(user_vector: tuple, item_dict: dict) -> str: pass ``` # Example Input ```python user_vector = (1, 2, 3) item_dict = { (2, 2, 2): \'Item A\', (1, 2, 1): \'Item B\', (4, 4, 4): \'Item C\' } ``` Output ``` \'Item B\' ``` Explanation The distance of the user vector (1, 2, 3) to each item vector is calculated as follows: - Distance to (2, 2, 2): sqrt((1-2)^2 + (2-2)^2 + (3-2)^2) = sqrt(1 + 0 + 1) = sqrt(2) - Distance to (1, 2, 1): sqrt((1-1)^2 + (2-2)^2 + (3-1)^2) = sqrt(0 + 0 + 4) = sqrt(4) - Distance to (4, 4, 4): sqrt((1-4)^2 + (2-4)^2 + (3-4)^2) = sqrt(9 + 4 + 1) = sqrt(14) Therefore, \'Item B\' is the nearest neighbor to the user\'s preference vector.","solution":"import math def euclidean_distance(vec1, vec2): Computes the Euclidean distance between two vectors. return math.sqrt(sum((x - y) ** 2 for x, y in zip(vec1, vec2))) def recommend(user_vector: tuple, item_dict: dict) -> str: Recommends the closest item to the user vector from the item dictionary. closest_item = None min_distance = float(\'inf\') for item_vector, item_name in item_dict.items(): distance = euclidean_distance(user_vector, item_vector) if distance < min_distance: min_distance = distance closest_item = item_name return closest_item"},{"question":"Context You are part of a team working on the backend of a data retrieval system. The system stores crucial performance data in arrays that are sorted in ascending order but might be rotated around a pivot. This rotation is done at random intervals, and the arrays can contain up to one million elements. To quickly retrieve particular elements from the data arrays, you need to implement a highly efficient search function. Problem Statement Given an array of integers that is sorted in ascending order and then rotated at a certain pivot, write a function to search for a target value in the array. If the target exists, return its index. Otherwise, return -1. You must achieve this with a time complexity of O(log n). Function Signature ```python def find_target_in_rotated_array(arr: List[int], target: int) -> int: pass ``` Example ```plaintext Input: arr = [4, 5, 6, 7, 0, 1, 2], target = 0 Output: 4 Input: arr = [4, 5, 6, 7, 0, 1, 2], target = 3 Output: -1 Input: arr = [1], target = 0 Output: -1 ``` Constraints - `1 <= len(arr) <= 1,000,000` - `-10^4 <= arr[i] <= 10^4` - `arr` contains distinct integers. - The array will be rotated an unknown number of times before being provided. Requirements - Implement both an iterative solution and a recursive solution within the function. - Ensure that both implementations handle edge cases and maintain the required O(log n) time complexity. - Enforce correctness through comprehensive boundary checks and thoughtful division of search space.","solution":"from typing import List def find_target_in_rotated_array(arr: List[int], target: int) -> int: def iterative_search(arr: List[int], target: int) -> int: left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid # Determine which part is ordered if arr[left] <= arr[mid]: if arr[left] <= target < arr[mid]: right = mid - 1 else: left = mid + 1 else: if arr[mid] < target <= arr[right]: left = mid + 1 else: right = mid - 1 return -1 def recursive_search(arr: List[int], target: int, left: int, right: int) -> int: if left > right: return -1 mid = (left + right) // 2 if arr[mid] == target: return mid # Determine which part is ordered if arr[left] <= arr[mid]: if arr[left] <= target < arr[mid]: return recursive_search(arr, target, left, mid - 1) else: return recursive_search(arr, target, mid + 1, right) else: if arr[mid] < target <= arr[right]: return recursive_search(arr, target, mid + 1, right) else: return recursive_search(arr, target, left, mid - 1) # You can call either iterative_search or recursive_search based on preference return iterative_search(arr, target)"},{"question":"Roman Numerals Conversion and Validation You are given a task to write a function that converts a Roman numeral into an integer. Additionally, your implementation should handle and report invalid Roman numeral strings. **Function Signature**: ```python def roman_to_int(s: str) -> int: ``` **Input**: * `s` - a string representing a Roman numeral. The string may contain invalid characters or sequences. **Output**: * An integer representing the converted Roman numeral if the input is valid. * If the input is invalid, the function should raise a `ValueError` with the message \\"Invalid Roman numeral\\". **Constraints**: * The input string will have a maximum length of 15 characters. * The valid Roman numeral values are within the range from 1 to 3999. **Performance Requirements**: * The solution must run in O(n) time where n is the length of the input string. * The space complexity should be O(1). **Examples**: 1. `roman_to_int(\\"III\\")` should return 3. 2. `roman_to_int(\\"IV\\")` should return 4. 3. `roman_to_int(\\"IX\\")` should return 9. 4. `roman_to_int(\\"LVIII\\")` should return 58. 5. `roman_to_int(\\"MCMXCIV\\")` should return 1994. 6. `roman_to_int(\\"MMMM\\")` should raise a ValueError with the message \\"Invalid Roman numeral\\". 7. `roman_to_int(\\"XYZ\\")` should raise a ValueError with the message \\"Invalid Roman numeral\\". **Notes**: 1. Account for valid Roman numeral patterns and order rules. 2. Implement a helper function if necessary to keep the main function clean and understandable. 3. Ensure that your code is readable and well-documented. **Scenario**: You are developing an application for historians to digitize historical documents. These documents often use Roman numerals. To aid historians in handling these documents, your task is to create a reliable function to convert Roman numerals to integers and identify any input errors.","solution":"def roman_to_int(s: str) -> int: roman_values = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } invalid_sequences = [ \\"IIII\\", \\"VV\\", \\"XXXX\\", \\"LL\\", \\"CCCC\\", \\"DD\\", \\"MMMM\\", \\"IL\\", \\"IC\\", \\"ID\\", \\"IM\\", \\"VX\\", \\"VL\\", \\"VC\\", \\"VD\\", \\"VM\\", \\"XD\\", \\"XM\\", \\"LC\\", \\"LD\\", \\"LM\\", \\"DM\\" ] def is_valid_roman_string(rs: str) -> bool: for seq in invalid_sequences: if seq in rs: return False return True if not is_valid_roman_string(s): raise ValueError(\\"Invalid Roman numeral\\") total = 0 prev_value = 0 for char in reversed(s): if char not in roman_values: raise ValueError(\\"Invalid Roman numeral\\") value = roman_values[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"You are given an array of integers that needs to be sorted in non-decreasing order using the merge sort algorithm. However, to demonstrate your understanding and skill, you have to modify the classic merge sort implementation by including an additional feature: the merge process should explicitly count and return the number of \\"inversions\\" in the array. An inversion is a situation where a larger element precedes a smaller element in the array (i.e., for indices i < j, arr[i] > arr[j]). Write a function `merge_sort_with_inversions` that sorts the array and returns a tuple containing the sorted array and the count of inversions. # Input * `arr`: A list of integers, `arr`. # Output * A tuple where the first element is a sorted list of integers in non-decreasing order, and the second element is the integer count of inversions in the original array. # Constraints * `1 <= len(arr) <= 10^5` * `-10^9 <= arr[i] <= 10^9` # Examples Example 1: ```python input: [2, 3, 8, 6, 1] output: ([1, 2, 3, 6, 8], 5) ``` Example 2: ```python input: [5, 4, 3, 2, 1] output: ([1, 2, 3, 4, 5], 10) ``` # Instructions 1. Implement the `merge_sort_with_inversions` function. 2. Ensure your implementation efficiently handles the input size constraint. 3. Consider all edge cases during the merge phase. # Function Signature ```python def merge_sort_with_inversions(arr: List[int]) -> Tuple[List[int], int]: pass ```","solution":"from typing import List, Tuple def merge_sort_with_inversions(arr: List[int]) -> Tuple[List[int], int]: def merge(left: List[int], right: List[int]) -> Tuple[List[int], int]: result = [] i = j = 0 inversions = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) inversions += len(left) - i j += 1 result.extend(left[i:]) result.extend(right[j:]) return result, inversions def merge_sort(arr: List[int]) -> Tuple[List[int], int]: if len(arr) < 2: return arr, 0 mid = len(arr) // 2 left, left_inversions = merge_sort(arr[:mid]) right, right_inversions = merge_sort(arr[mid:]) merged, merge_inversions = merge(left, right) total_inversions = left_inversions + right_inversions + merge_inversions return merged, total_inversions sorted_array, inversions = merge_sort(arr) return sorted_array, inversions"},{"question":"# Question Scenario: Suppose you are tasked with optimizing a game’s level design where each level\'s complexity is represented by an integer. For each level, the complexity should be broken down into the minimum number of perfect square tiles. You are required to implement a function that computes this efficiently. The goal is to minimize the number of perfect square tiles used to represent the complexity score of each level. Task: Write a function `min_perfect_squares(number: int) -> int` that takes a positive integer `number` representing the level complexity and returns the minimum number of perfect squares that sum up to `number`. Input: * A single integer `number` (1 <= number <= 10^4). Output: * A single integer representing the minimum number of perfect squares that sum to `number`. Constraints: * Clearly handle the smallest and largest values within the range. * Ensure the algorithm runs efficiently within the provided input limits. * Your implementation should accommodate typical scenarios described, utilizing insights from the Lagrange\'s four-square theorem. Example: ```python assert min_perfect_squares(9) == 1 # 3^2 assert min_perfect_squares(12) == 3 # 2^2 + 2^2 + 2^2 assert min_perfect_squares(31) == 4 # 5^2 + 2^2 + 1^2 + 1^2 ``` Implement the function in Python: ```python def min_perfect_squares(number: int) -> int: import math if int(math.sqrt(number))**2 == number: return 1 while number % 4 == 0: number /= 4 if number % 8 == 7: return 4 for i in range(1, int(math.sqrt(number)) + 1): if int(math.sqrt(number - i**2))**2 == number - i**2: return 2 return 3 ``` Provide test cases within your solution to ensure the function\'s performance and correctness.","solution":"def min_perfect_squares(number: int) -> int: import math # Check if the number itself is a perfect square. if int(math.sqrt(number))**2 == number: return 1 # Applying the Lagrange\'s Four Square theorem # Reduce number by removing factors of 4 while number % 4 == 0: number //= 4 # Check if the reduced number is of the form (8b+7) if number % 8 == 7: return 4 # Check if the number can be expressed as the sum of two squares for i in range(1, int(math.sqrt(number)) + 1): if int(math.sqrt(number - i**2))**2 == (number - i**2): return 2 # If not, the number must be the sum of three squares return 3"},{"question":"# Question You are tasked with implementing a simple encryption algorithm called the Atbash Cipher. The Atbash Cipher is a type of substitution cipher where each letter of the English alphabet is mapped to its opposite counterpart. For example, \'A\' is substituted with \'Z\', \'B\' is substituted with \'Y\', \'a\' is substituted with \'z\', \'b\' is substituted with \'y\', and so on. Non-alphabet characters should remain unchanged. **Function Signature** ```python def atbash_cipher(s: str) -> str: ``` **Input** * `s` (string): A string of length n (1 ≤ n ≤ 10^5) containing alphanumeric characters and symbols. **Output** * Returns a string where each letter in the input string is substituted with its Atbash equivalent, and all other characters remain unchanged. **Constraints** * Alphabet characters should be converted according to the Atbash substitution. * Case of input alphabet characters should be preserved in the output. **Example** ``` Input: \\"Attack at dawn! 123\\" Output: \\"Zggzxp zg wzdm! 123\\" Input: \\"Hello, World!\\" Output: \\"Svool, Dliow!\\" Input: \\"Atbash Cipher 2023\\" Output: \\"Zgyzhs Xrksvi 2023\\" ``` **Explanation** In the first example, - \'A\' (uppercase) is mapped to \'Z\', - \'t\' (lowercase) is mapped to \'g\', - \'d\' (lowercase) is mapped to \'w\', - Non-alphabet characters \\"!\\" and \\"123\\" remain unchanged. In the second example, - \'H\' is mapped to \'S\', - \'e\' is mapped to \'v\', - \'o\' is mapped to \'l\', - \',\' and \'!\' remain unchanged. In the third example, - \'A\' is mapped to \'Z\', - \'t\' is mapped to \'g\', - \'b\' is mapped to \'y\', - \'a\' is mapped to \'z\', - \'s\' is mapped to \'h\', - Non-alphabet characters and numbers \\"Xrksvi 2023\\" remain unchanged. Write an efficient function that solves this problem within constraints.","solution":"def atbash_cipher(s: str) -> str: Encrypts the input string using the Atbash Cipher. def transform_character(c): if \'A\' <= c <= \'Z\': return chr(155 - ord(c)) # \'A\' is 65 and \'Z\' is 90, so 155 = \'A\' + \'Z\' = 65 + 90 elif \'a\' <= c <= \'z\': return chr(219 - ord(c)) # \'a\' is 97 and \'z\' is 122, so 219 = \'a\' + \'z\' = 97 + 122 else: return c return \'\'.join(transform_character(c) for c in s)"},{"question":"Problem Statement You have been tasked with implementing a custom sorting algorithm that efficiently sorts an array of floating-point numbers. The sorting technique you\'re implementing is a variation of the Bucket Sort, using a specified secondary sorting algorithm within each bucket. Your goal is to complete the implementation of the `bucket_sort` function by using selection sort, instead of insertion sort, in the `bucket_sort` function. Function Signature ```python def bucket_sort(arr): \'\'\' Sorts an array of floating-point numbers using the Bucket Sort algorithm with Selection Sort as the secondary sorting mechanism. :param arr: List[float] - A list of floating-point numbers to be sorted. :return: List[float] - The sorted list of floating-point numbers. \'\'\' ``` Detailed Specification 1. **Input Format**: * A list of `n` floating-point numbers, where 1 ≤ `n` ≤ 10^5. * Each floating-point number is within the range [0, 1). 2. **Output Format**: * A list of `n` floating-point numbers, sorted in non-decreasing order. 3. **Constraints**: * Use the Bucket Sort algorithm with Selection Sort as the sorting mechanism within each bucket. * The range of input numbers is from 0 to just below 1 (0 ≤ num < 1). 4. **Performance Requirements**: * The algorithm should aim for average-case time complexity of O(n) with uniform distribution. Example ```python # Example input arr = [0.23, 0.45, 0.12, 0.68, 0.34] # Example output [0.12, 0.23, 0.34, 0.45, 0.68] ``` Notes If the secondary sorting (selection sort) is not familiar: * **Selection Sort**: 1. Traverse the array and find the minimum element. 2. Swap the minimum element with the first element of the array. 3. Repeat the process for the remaining array.","solution":"def selection_sort(arr): Performs selection sort on the given list. n = len(arr) for i in range(n - 1): min_index = i for j in range(i + 1, n): if arr[j] < arr[min_index]: min_index = j arr[i], arr[min_index] = arr[min_index], arr[i] def bucket_sort(arr): Sorts an array of floating-point numbers using the Bucket Sort algorithm with Selection Sort as the secondary sorting mechanism. :param arr: List[float] - A list of floating-point numbers to be sorted. :return: List[float] - The sorted list of floating-point numbers. if not arr: return [] # Create buckets bucket_count = len(arr) buckets = [[] for _ in range(bucket_count)] # Distribute input array values into buckets for num in arr: bucket_index = int(num * bucket_count) buckets[bucket_index].append(num) # Sort individual buckets using selection sort for bucket in buckets: selection_sort(bucket) # Concatenate all sorted buckets sorted_arr = [] for bucket in buckets: sorted_arr.extend(bucket) return sorted_arr"},{"question":"Context Matrix decomposition is a fundamental operation in numerical analysis and linear algebra involving breaking down a matrix into simpler, constituent components. One widely-used technique for this purpose is Crout\'s matrix decomposition, which factors a given square matrix ( A ) into a lower triangular matrix ( L ) and an upper triangular matrix ( U ) such that ( L times U = A ). Problem Statement Write a function named `crout_matrix_decomposition` that takes a square matrix ( A ) (a list of lists) as input and returns two matrices ( L ) and ( U ) representing the lower triangular matrix and upper triangular matrix from Crout\'s decomposition. # Input - A square matrix ( A ) having dimensions ( n times n ). # Output - Two matrices ( L ) and ( U ) (as lists of lists) such that ( L times U = A ). # Constraints - ( 1 leq n leq 100 ) - Elements of ( A ) are floating-point numbers. - If any diagonal element of ( L ) is zero, substitute it with ( 0.1^{40} ) to avoid division errors. # Example ```python A = [ [1.0, 2.0, 3.0], [3.0, 4.0, 5.0], [6.0, 7.0, 8.0] ] L, U = crout_matrix_decomposition(A) # L should be: # [ # [1.0, 0.0, 0.0], # [3.0, -2.0, 0.0], # [6.0, -5.0, 0.0] # ] # U should be: # [ # [1.0, 2.0, 3.0], # [0.0, 1.0, 2.0], # [0.0, 0.0, 1.0] # ] ``` # Function Signature ```python def crout_matrix_decomposition(A: List[List[float]]) -> Tuple[List[List[float]], List[List[float]]]: pass ``` # Note 1. Think about edge cases, for example, if your matrix includes zeros, close-to-zero values, or has special values like negative numbers. 2. Verify your implementation against several test cases to ensure correctness and robustness.","solution":"from typing import List, Tuple def crout_matrix_decomposition(A: List[List[float]]) -> Tuple[List[List[float]], List[List[float]]]: n = len(A) L = [[0.0] * n for _ in range(n)] U = [[0.0] * n for _ in range(n)] for i in range(n): U[i][i] = 1.0 # Diagonal elements of U are 1, as per Crout\'s method for j in range(n): for i in range(j, n): L[i][j] = A[i][j] - sum(L[i][k] * U[k][j] for k in range(j)) for i in range(j+1, n): if L[j][j] == 0: L[j][j] = 1e-40 # Replace zero diagonal element if found U[j][i] = (A[j][i] - sum(L[j][k] * U[k][i] for k in range(j))) / L[j][j] return L, U"},{"question":"# ZigZag Iterator Enhancement You are given a ZigZag Iterator which alternates between two lists. Extend this iterator to handle `k` lists instead of just two. Implement a `ZigZagKIterator` class that will iterate over `k` lists in a zigzag manner. # Function Specifications `__init__(self, lists: List[List[int]])` * **Purpose**: Initialize the iterator with `k` non-empty lists. * **Input**: A list of `k` lists where `k >= 2`. `next(self) -> int` * **Purpose**: Retrieve the next element in the zigzag order. * **Output**: An integer, the next number in the zigzag order. `has_next(self) -> bool` * **Purpose**: Check whether there are still elements to iterate over. * **Output**: A boolean indicating if there are more elements to iterate over. # Constraints * The total number of integers across all lists does not exceed 10000. * The number of lists, `k`, does not exceed 100. # Example ```python input_lists = [ [1, 2, 3], [4, 5, 6, 7], [8, 9] ] zigzag = ZigZagKIterator(input_lists) output = [] while zigzag.has_next(): output.append(zigzag.next()) print(output) # Output should be [1, 4, 8, 2, 5, 9, 3, 6, 7] ``` # Requirements 1. You should correctly handle zigzagging over multiple (k) lists. 2. Handle varying list lengths efficiently. **Hint**: Utilize a queue or deque to manage the iteration state across multiple lists.","solution":"from collections import deque from typing import List class ZigZagKIterator: def __init__(self, lists: List[List[int]]): self.queue = deque((i, 0) for i in range(len(lists)) if lists[i]) self.lists = lists def next(self) -> int: if not self.has_next(): raise StopIteration(\\"No more elements to iterate.\\") i, j = self.queue.popleft() result = self.lists[i][j] # Update index to point to the next element j += 1 if j < len(self.lists[i]): # There are more elements in the current list self.queue.append((i, j)) return result def has_next(self) -> bool: return bool(self.queue)"},{"question":"You are requested to implement an optimized version of the Quick Sort algorithm. The primary goal is to ensure that the algorithm performs well even in the worst-case scenarios (e.g., already sorted arrays). To achieve this, you should implement a randomized version of Quick Sort. This version will select a random pivot to improve the average time complexity performance. Function Signature: ```python def randomized_quick_sort(arr: List[int]) -> List[int]: pass ``` # Input: - `arr`: List of integers that need to be sorted. # Output: - A sorted list of integers in non-decreasing order. # Constraints: - `1 <= len(arr) <= 10^5` - `-10^9 <= arr[i] <= 10^9` for every integer `arr[i]` # Requirements: - Implement the Quick Sort algorithm with pivot chosen randomly. - Ensure to avoid stack overflow for large inputs by implementing a non-recursive variant of Quick Sort using an explicit stack. - The implementation should handle edge cases such as empty arrays, arrays with a single element, and arrays with duplicate elements efficiently. # Example: ```python >>> print(randomized_quick_sort([3, 6, 8, 10, 1, 2, 1])) [1, 1, 2, 3, 6, 8, 10] >>> print(randomized_quick_sort([10, 7, 8, 9, 1, 5])) [1, 5, 7, 8, 9, 10] ``` # Performance Requirements: - Expected Time Complexity: O(n log(n)) on average. - Expected Space Complexity: O(log(n)). # Scenario: You are responsible for building a high-performance sorting module within a data processing system. The system processes large data sets requiring efficient sorting within a tight time frame. Implementing an optimized version of Quick Sort ensures robust and efficient sorting key to meeting performance benchmarks.","solution":"import random from typing import List def randomized_quick_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr def partition(low, high): pivot_index = random.randint(low, high) arr[low], arr[pivot_index] = arr[pivot_index], arr[low] pivot = arr[low] left = low + 1 right = high while True: while left <= right and arr[left] <= pivot: left += 1 while left <= right and arr[right] >= pivot: right -= 1 if left <= right: arr[left], arr[right] = arr[right], arr[left] else: break arr[low], arr[right] = arr[right], arr[low] return right def iterative_quick_sort(): stack = [] stack.append((0, len(arr) - 1)) while stack: low, high = stack.pop() if low < high: p = partition(low, high) stack.append((low, p - 1)) stack.append((p + 1, high)) iterative_quick_sort() return arr"},{"question":"You are given a list of integers and a commutative function, and your task is to implement a `SegmentTree` class to efficiently handle range queries and updates. The segment tree should be able to: 1. Initialize and build the tree from a given array. 2. Perform range queries efficiently using the provided function. 3. Update elements in the array and reflect these changes in the tree. # Function Signatures ```python class SegmentTree: def __init__(self, arr: List[int], function: Callable[[int, int], int]): # Constructs the segment tree from the given array using the function. pass def update(self, index: int, value: int): # Updates the element at the given index to the given value. pass def query(self, left: int, right: int) -> int: # Returns the result of the function applied over the range [left, right]. pass ``` # Example ```python # Sample commutative functions def max_func(a, b): return max(a, b) def add_func(a, b): return a + b # Initialize a segment tree with the max function arr = [2, 4, 5, 3, 4] tree = SegmentTree(arr, max_func) print(tree.query(2, 4)) # Output: 5 tree.update(3, 6) print(tree.query(0, 3)) # Output: 6 # Initialize a segment tree with the addition function arr = [4, 5, 2, 3, 4, 43, 3] tree = SegmentTree(arr, add_func) print(tree.query(0, 6)) # Output: 64 tree.update(2, -10) print(tree.query(0, 6)) # Output: 52 ``` # Constraints 1. `1 <= len(arr) <= 10^5` 2. `-10^9 <= arr[i] <= 10^9` 3. Queries and updates will be performed in a reasonable number. # Guidelines * Ensure your implementation works within the given constraints. * Optimize for time and space complexity. * Handle edge cases mentioned in the analysis correctly.","solution":"class SegmentTree: def __init__(self, arr, function): self.n = len(arr) self.function = function self.tree = [0] * (2 * self.n) # Initialize the leaves of the segment tree for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the tree by calculating parent nodes for i in range(self.n - 1, 0, -1): self.tree[i] = function(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, index, value): # Update the leaf node index += self.n self.tree[index] = value # Update the internal nodes while index > 1: index //= 2 self.tree[index] = self.function(self.tree[index * 2], self.tree[index * 2 + 1]) def query(self, left, right): left += self.n right += self.n + 1 res_left = None res_right = None while left < right: if left % 2 == 1: if res_left is None: res_left = self.tree[left] else: res_left = self.function(res_left, self.tree[left]) left += 1 if right % 2 == 1: right -= 1 if res_right is None: res_right = self.tree[right] else: res_right = self.function(res_right, self.tree[right]) left //= 2 right //= 2 if res_left is None: return res_right if res_right is None: return res_left return self.function(res_left, res_right)"},{"question":"# **Coding Question** Problem Statement: You are given a stack of integers, and your task is to write a function `efficient_stutter` that takes a stack as an input and modifies it by replacing every value in the stack with two occurrences of that value using a single auxiliary storage of your choice (either stack or queue). Requirements: 1. **Input**: The function should accept a stack (list) of integers as parameter. 2. **Output**: The function should return the modified stack with each value duplicated. 3. **Constraints**: - The original stack must be modified in place. - You can only use either a single stack or a single queue as auxiliary storage. - You should achieve this in O(n) time complexity where n is the total number of elements in the input stack. - Space complexity should be O(n) as auxiliary storage will hold at most n elements at any time. Function Signature: ```python def efficient_stutter(stack: list) -> list: pass ``` Example: ```python # Example 1 stack = [3, 7, 1, 14, 9] print(efficient_stutter(stack)) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] # Example 2 stack = [] print(efficient_stutter(stack)) # Output: [] # Example 3 stack = [1] print(efficient_stutter(stack)) # Output: [1, 1] ``` Hints: * You can use any auxiliary data structure defined in the collections module. * Ensure to handle edge cases such as an empty stack.","solution":"from collections import deque def efficient_stutter(stack: list) -> list: Takes a stack as input and modifies it by replacing every value in the stack with two occurrences of that value using a single auxiliary storage. # Queue auxiliary storage queue = deque() # Phase 1: Move elements from stack to queue and duplicate them while stack: elem = stack.pop() queue.appendleft(elem) queue.appendleft(elem) # Phase 2: Move elements back from queue to stack (duplicated) while queue: stack.append(queue.popleft()) return stack"},{"question":"# Bipartite Graph Check with Graph Components **Scenario:** You are a system designer tasked with ensuring efficient resource allocation in a project where tasks need to be divided into two non-conflicting groups. To achieve this, you need to verify if a given project task dependency graph is bipartite. This problem will help in systematically grouping tasks into two sets ensuring no conflicts within the same group. # Task: Write a function `is_bipartite_graph(adj_list: List[List[int]]) -> bool` that takes in an adjacency list of an undirected graph and returns `True` if the graph is bipartite and `False` otherwise. # Input: - `adj_list`: A list of lists representing the adjacency list of the graph. `adj_list[i]` contains integers which are indices of vertices adjacent to vertex `i`. # Output: - Return `True` if the graph is bipartite, otherwise `False`. # Constraints: - The graph does not contain any self-loops. - The number of vertices |V| and number of edges |E| are such that 0 ≤ |V|, |E| ≤ 10^4. # Example: - Input: `[[1, 3], [0, 2], [1, 3], [0, 2]]` - Representing the following graph: ``` 0 -- 1 | | 3 -- 2 ``` - Output: `True` (Graph is bipartite, sets {0, 2} and {1, 3}). - Input: `[[1, 2], [0, 2], [0, 1]]` - Representing the following graph: ``` 0 -- 1 / 2 ``` - Output: `False` (Graph is not bipartite because it contains an odd cycle). # Additional Context: A bipartite graph is a graph whose vertices can be divided into two disjoint sets such that no two vertices within the same set are adjacent. This problem typically involves checking if the graph can be colored using two colors (e.g., 0 and 1) without adjacent vertices sharing the same color. **Note:** Take into account handling of disconnected graph components as they might affect the bipartite check. **Function Signature:** ```python def is_bipartite_graph(adj_list: List[List[int]]) -> bool: # Your code here ```","solution":"from collections import deque from typing import List def is_bipartite_graph(adj_list: List[List[int]]) -> bool: n = len(adj_list) # -1 means uncolored, 0 and 1 will be the two colors color = [-1] * n def bfs(source): queue = deque([source]) color[source] = 0 while queue: node = queue.popleft() for neighbor in adj_list[node]: if color[neighbor] == -1: # If not colored, paint with opposite color color[neighbor] = 1 - color[node] queue.append(neighbor) elif color[neighbor] == color[node]: # If neighbor has the same color return False return True for i in range(n): if color[i] == -1: # Not yet visited if not bfs(i): return False return True"},{"question":"# Context You are tasked with building an accounting software that performs arithmetic operations on very large numbers. The built-in integer handling libraries of your language cannot be used due to compatibility reasons across different systems. # Task Write a function `multiply_strings(num1: str, num2: str) -> str` that multiplies two non-negative integers represented as strings and returns the product, also as a string. # Function Signature ```python def multiply_strings(num1: str, num2: str) -> str: ``` # Inputs and Outputs Input * `num1`: A string representing a non-negative integer. * `num2`: A string representing a non-negative integer. Output * A string representing the product of `num1` and `num2`. # Constraints * The length of both `num1` and `num2` is < 110. * Both `num1` and `num2` contain only digits 0-9. * Both `num1` and `num2` do not contain any leading zero. # Requirements * You must not use any built-in BigInteger library or convert the inputs to integers directly. * Ensure handling of intermediary calculations efficiently to avoid overflow and ensure precision. # Example ```python assert multiply_strings(\\"2\\", \\"3\\") == \\"6\\" assert multiply_strings(\\"123\\", \\"456\\") == \\"56088\\" ``` Design your implementation considering edge cases and potential performance bottlenecks. This function could be an integral part of larger systems where accuracy and efficiency are pivotal.","solution":"def multiply_strings(num1: str, num2: str) -> str: # Handle special cases where either number is \\"0\\" if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" # Initialize the result array with zeros result = [0] * (len(num1) + len(num2)) # Reverse both numbers to simplify the position handling num1, num2 = num1[::-1], num2[::-1] # Perform multiplication digit by digit for i in range(len(num1)): for j in range(len(num2)): # Multiply and add to the corresponding position in the result array result[i + j] += int(num1[i]) * int(num2[j]) # Carry handling result[i + j + 1] += result[i + j] // 10 result[i + j] %= 10 # Remove leading zeros and convert list of digits to a string while len(result) > 1 and result[-1] == 0: result.pop() # Convert the result back to a string return \'\'.join(map(str, result[::-1]))"},{"question":"# Scenario Imagine you are developing a multi-threaded server that handles requests from multiple clients. To fairly distribute the processing of these requests, you decide to use a queue to manage the incoming requests. Depending on different server architectures, you might need to use either an array-based or linked-list-based queue. # Task Implement a `CircularArrayQueue` class that continues the `ArrayQueue` but uses a circular array to efficiently manage queue elements without unnecessary resizing. # Requirements * Implement the `CircularArrayQueue` class by inheriting from `AbstractQueue`. * The class should override the following methods: - `enqueue(self, value)`: Adds a newly arrived request to the rear. - `dequeue(self)`: Processes the oldest request and removes it from the queue. - `peek(self)`: Returns the oldest request without removing it. - `__iter__(self)`: Iterates over the elements in the queue. * Ensure that your queue can expand its capacity if it gets full. * Your implementation should be efficient, with each operation having an average time complexity of O(1). # Constraints * You can assume that the initial capacity of the queue is 10. * All methods (except dimension resizing in the background) should execute in O(1) time complexity. ```python class CircularArrayQueue(AbstractQueue): def __init__(self, capacity=10): Initializes the queue with the capacity of 10 or user given input. Uses a circular array to efficiently manage elements. super().__init__() # Complete this method def __iter__(self): # Complete this method pass def enqueue(self, value): # Complete this method pass def dequeue(self): # Complete this method pass def peek(self): # Complete this method pass def _expand(self): Expands size of the array, when it\'s full. Time Complexity: O(n) # Complete this method ``` # Example Usage ```python q = CircularArrayQueue() q.enqueue(1) q.enqueue(2) q.enqueue(3) print(q.dequeue()) # Output: 1 print(q.peek()) # Output: 2 print(len(q)) # Output: 2 ```","solution":"class CircularArrayQueue: def __init__(self, capacity=10): Initializes the queue with the given capacity. Uses a circular array to efficiently manage elements. self.capacity = capacity self.array = [None] * capacity self.front = 0 self.rear = 0 self.size = 0 def __iter__(self): Iterates over the elements in the queue. idx = self.front count = 0 while count < self.size: yield self.array[idx] idx = (idx + 1) % self.capacity count += 1 def enqueue(self, value): Adds a newly arrived request to the rear. if self.size == self.capacity: self._expand() self.array[self.rear] = value self.rear = (self.rear + 1) % self.capacity self.size += 1 def dequeue(self): Processes the oldest request and removes it from the queue. if self.size == 0: raise IndexError(\\"dequeue from an empty queue\\") value = self.array[self.front] self.array[self.front] = None # Optional: clear the slot self.front = (self.front + 1) % self.capacity self.size -= 1 return value def peek(self): Returns the oldest request without removing it. if self.size == 0: raise IndexError(\\"peek from an empty queue\\") return self.array[self.front] def _expand(self): Expands size of the array when it\'s full. new_capacity = self.capacity * 2 new_array = [None] * new_capacity for i in range(self.size): new_array[i] = self.array[(self.front + i) % self.capacity] self.array = new_array self.capacity = new_capacity self.front = 0 self.rear = self.size"},{"question":"# Coding Problem: Implement a Custom Bitwise Operation Function Problem Statement You are required to implement a function `bitwise_sum` that performs a bitwise addition on two positive integers and returns the result. This bitwise addition should utilize only the fundamental bit operations provided. Function Signature ```python def bitwise_sum(a: int, b: int) -> int: pass ``` Input * `a`, `b`: Two positive integers, where `1 <= a, b <= 10^9` Output * An integer representing the result of the bitwise addition of `a` and `b`. Explanation & Example Bitwise addition mimics the binary addition where each bit is added with a carry from the previous bit addition. You should use the provided bit manipulation functions to achieve this. Example ```python assert bitwise_sum(4, 5) == 9 # 4 (0100) + 5 (0101) = 9 (1001) assert bitwise_sum(15, 27) == 42 # 15 (01111) + 27 (11011) = 42 (101010) assert bitwise_sum(100, 200) == 300 # 100 (1100100) + 200 (11001000) = 300 (100101100) assert bitwise_sum(1, 1) == 2 # 1 (1) + 1 (1) = 2 (10) ``` Constraints * You must only use the basic bit operations (`get_bit`, `set_bit`, `clear_bit`, `update_bit`) provided above. * You are not allowed to use arithmetic operators like `+`, `-`, `*`, `/` for addition. * Ensure efficient handling for up to the maximum input values. Additional Notes This problem will test your understanding of: * Basic bit manipulation. * Handling carry-over in binary addition. * Implementing a function under given constraints.","solution":"def bitwise_sum(a: int, b: int) -> int: while b != 0: carry = a & b a = a ^ b b = carry << 1 return a"},{"question":"Implement a function to validate the current state of a Sudoku board. # Function Signature ```python def is_valid_sudoku(board: List[List[str]]) -> bool: ``` Input * `board`: A 9x9 list of lists containing characters from \'1\' to \'9\' and \'.\' representing empty cells. Output * Returns `True` if the Sudoku board is valid according to Sudoku rules; otherwise, returns `False`. # Constraints * The board is always a 9x9 grid. * The characters in the board are limited to \'1\'-\'9\' and \'.\'. # Performance Requirements * The implementation should be optimally designed to handle validation in O(N^2) time complexity and O(N^2) space complexity. # Description To ensure the Sudoku board is valid: 1. Each row must contain numbers 1-9 without repetition. 2. Each column must contain numbers 1-9 without repetition. 3. Each of the nine 3x3 sub-boxes must contain numbers 1-9 without repetition. # Scenario Consider a Sudoku game where you need to validate whether a player’s input maintains the board\'s validity. Utilize this function within a larger Sudoku game engine to ensure each move\'s legality. # Example For the given board: ```python board = [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] ``` The function should return `True` since this board follows Sudoku rules.","solution":"def is_valid_sudoku(board): Returns True if the given 9x9 Sudoku board is valid. Otherwise, returns False. def is_valid_unit(unit): Returns True if a row, column, or 3x3 box contains no duplicates except \'.\'. unit = [i for i in unit if i != \'.\'] return len(unit) == len(set(unit)) # Check all rows for row in board: if not is_valid_unit(row): return False # Check all columns for col in range(9): if not is_valid_unit([board[row][col] for row in range(9)]): return False # Check all 3x3 sub-boxes for box_row in range(3): for box_col in range(3): if not is_valid_unit([ board[r][c] for r in range(box_row * 3, box_row * 3 + 3) for c in range(box_col * 3, box_col * 3 + 3) ]): return False return True"},{"question":"# Coding Task: Repeated Substring Pattern Checker Scenario You are working on a DNA sequence analysis tool. One of the tasks is to identify if a given DNA sequence (a string) can be formed by repeating a smaller substring multiple times. This information is crucial in identifying patterns or mutations within the genome. Problem Statement Write a function `is_repeated_substring_pattern(sequence)` that determines whether the given DNA sequence can be constructed by repeating a substring. Function Signature ```python def is_repeated_substring_pattern(sequence: str) -> bool: pass ``` Input * `sequence`: A non-empty string of length `1 <= len(sequence) <= 10^4` containing only lowercase English letters. Output * Return `True` if the given sequence can be constructed by repeating a substring, otherwise return `False`. Constraints * The function should handle sequences of varied lengths efficiently. * Avoid using any built-in functions that directly solve the problem to encourage algorithmic thinking. Examples Example 1: ```python sequence = \\"abab\\" print(is_repeated_substring_pattern(sequence)) # Output: True ``` Example 2: ```python sequence = \\"aba\\" print(is_repeated_substring_pattern(sequence)) # Output: False ``` Example 3: ```python sequence = \\"abcabcabcabc\\" print(is_repeated_substring_pattern(sequence)) # Output: True ``` Notes * Consider edge cases like single character strings and strings where no repeating pattern exists. * Aim to optimize your code for time and space complexity, given the constraint that the input length can be up to 10,000 characters.","solution":"def is_repeated_substring_pattern(sequence: str) -> bool: Determines whether the given sequence can be constructed by repeating a smaller substring. length = len(sequence) for i in range(1, length // 2 + 1): if length % i == 0: # Check if i is a divisor of length if sequence[:i] * (length // i) == sequence: # Check if the repeated substring forms the sequence return True return False"},{"question":"# In-order Traversal of a Binary Search Tree Background: In a Binary Search Tree (BST), each node has at most two children referred to as the left child and the right child. A node\'s left child contains a value less than the node\'s value, and its right child contains a value greater than or equal to the node\'s value. In-order traversal is a depth-first traversal where we visit the left subtree, the root node, and then the right subtree. For BSTs, this traversal returns elements in non-decreasing order. Task: You are required to implement an in-order traversal of a BST, both iteratively and recursively. Instructions: - Implement two functions: - `def inorder(root):` where the root is the root node of a BST. This function should return the in-order traversal of the tree as a list of integers, iteratively. - `def inorder_rec(root):` where the root is the root node of a BST. This function should return the in-order traversal of the tree as a list of integers, recursively. Constraints: - The number of nodes in the tree is any non-negative integer. - The value of each node is a unique integer. Input Format: - The root node of the BST. Output Format: - A list of integers representing the in-order traversal of the BST. Example: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right # Example Tree # 100 # / # 50 150 # / / # 25 75 125 175 n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 # In-order traversal (Iterative) assert inorder(n1) == [25, 50, 75, 100, 125, 150, 175] # In-order traversal (Recursive) assert inorder_rec(n1) == [25, 50, 75, 100, 125, 150, 175] ```","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def inorder(root): Returns the in-order traversal of the BST iteratively. stack, result = [], [] current = root while stack or current: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result def inorder_rec(root): Returns the in-order traversal of the BST recursively. result = [] def helper(node): if node: helper(node.left) result.append(node.val) helper(node.right) helper(root) return result"},{"question":"# Context The Longest Common Prefix is a significant concept in string processing. Given a set of strings, it is useful in applications requiring consistent matching and can serve as a preprocessing step in more complex algorithms. # Task You are required to implement three different algorithms to find the longest common prefix among an array of strings, based on the principles of Horizontal Scanning, Vertical Scanning, and Divide and Conquer. # Function Definitions * **Horizontal Scanning** ```python def longest_common_prefix_horizontal(strs: List[str]) -> str: Returns the longest common prefix from the array of strings using horizontal scanning. :param strs: List of strings. :return: Longest common prefix or an empty string if no common prefix exists. ``` * **Vertical Scanning** ```python def longest_common_prefix_vertical(strs: List[str]) -> str: Returns the longest common prefix from the array of strings using vertical scanning. :param strs: List of strings. :return: Longest common prefix or an empty string if no common prefix exists. ``` * **Divide and Conquer** ```python def longest_common_prefix_divide_and_conquer(strs: List[str]) -> str: Returns the longest common prefix from the array of strings using divide and conquer. :param strs: List of strings. :return: Longest common prefix or an empty string if no common prefix exists. ``` # Constraints - 1 <= number of strings <= 200 - 0 <= length of any string <= 200 - All input strings contain only lowercase English letters. # Example Cases 1. **Example 1** - **Input**: ```python [\\"flower\\", \\"flow\\", \\"flight\\"] ``` - **Output**: ```python \\"fl\\" ``` 2. **Example 2** - **Input**: ```python [\\"dog\\", \\"racecar\\", \\"car\\"] ``` - **Output**: ```python \\"\\" ``` - **Explanation**: There is no common prefix among the input strings.","solution":"from typing import List def longest_common_prefix_horizontal(strs: List[str]) -> str: if not strs: return \\"\\" prefix = strs[0] for s in strs[1:]: while not s.startswith(prefix): prefix = prefix[:-1] if not prefix: return \\"\\" return prefix def longest_common_prefix_vertical(strs: List[str]) -> str: if not strs: return \\"\\" for i in range(len(strs[0])): char = strs[0][i] for string in strs[1:]: if i == len(string) or string[i] != char: return strs[0][:i] return strs[0] def longest_common_prefix_divide_and_conquer(strs: List[str]) -> str: def lcp(strs, l, r): if l == r: return strs[l] else: mid = (l + r) // 2 lcpLeft = lcp(strs, l, mid) lcpRight = lcp(strs, mid + 1, r) return common_prefix(lcpLeft, lcpRight) def common_prefix(left, right): min_length = min(len(left), len(right)) for i in range(min_length): if left[i] != right[i]: return left[:i] return left[:min_length] if not strs: return \\"\\" return lcp(strs, 0, len(strs) - 1)"},{"question":"# Question In the realm of high-frequency data processing, we\'re often faced with datasets where most elements repeat in a structured manner, with a few outliers needing identification. Suppose you\'re given an array of integers where every element appears three times except for one, which appears exactly once. Your goal is to identify that unique element. Write a function `find_unique_number(nums: List[int]) -> int` that accepts an array of integers, `nums`, and returns the single distinct integer. # Function Signature ```python def find_unique_number(nums: List[int]) -> int: pass ``` # Input - `nums`: A list of integers where each integer appears exactly three times except for one which appears exactly once. The length of the list ranges from 1 to (10^4). # Output - Return a single integer that appears only once in the array. # Constraints - Your algorithm must have a linear runtime complexity (O(n)). - You must not use extra memory (space complexity must be (O(1))). # Example 1. **Input**: `nums = [2, 2, 3, 2]` **Output**: `3` 2. **Input**: `nums = [0, 1, 0, 1, 0, 1, 99]` **Output**: `99` # Notes - Make sure to handle edge cases effectively. Your solution should be robust and handle different scenarios including negative numbers, and varying array lengths. - Consider the properties of bitwise operations carefully to come up with an efficient solution.","solution":"from typing import List def find_unique_number(nums: List[int]) -> int: Finds the single unique number in a list where every other number appears three times. # Using bitwise operations to achieve O(n) time complexity and O(1) space complexity ones, twos = 0, 0 for num in nums: # `twos` tracks all numbers that appear twice twos |= ones & num # `ones` tracks all numbers that appear once excluding those in `twos` ones ^= num # `threes` are all the numbers that appear three times threes = ones & twos # Remove the `threes` from `ones` and `twos` ones &= ~threes twos &= ~threes return ones"},{"question":"# Polynomial Addition, Multiplication, and Evaluation You are given two classes, `Monomial` and `Polynomial`, which represent mathematical monomials and polynomials. Your task is to add a feature to handle the addition of polynomials and multiply them efficiently. Furthermore, you need to provide a method to evaluate polynomials with given variable values. Input and Output Format 1. **Polynomial Addition** * **Input**: Two polynomials, represented as lists of tuples. Each tuple consists of a dictionary representing the variables and their powers, and a coefficient. * **Output**: A polynomial represented in the same format that reflects the sum of the input polynomials. 2. **Polynomial Multiplication** * **Input**: Two polynomials, represented as lists of tuples. * **Output**: A polynomial represented in the same format, reflecting the product of the input polynomials. 3. **Polynomial Evaluation** * **Input**: A polynomial (as a list of tuples) and a dictionary mapping variables to their values. * **Output**: The evaluated result as a `Fraction`. Function Signatures You need to implement the following functions: ```python def add_polynomials(p1: List[Tuple[Dict[int, int], Union[int, float, Fraction]]], p2: List[Tuple[Dict[int, int], Union[int, float, Fraction]]]) -> List[Tuple[Dict[int, int], Union[int, float, Fraction]]]: ... def multiply_polynomials(p1: List[Tuple[Dict[int, int], Union[int, float, Fraction]]], p2: List[Tuple[Dict[int, int], Union[int, float, Fraction]]]) -> List[Tuple[Dict[int, int], Union[int, float, Fraction]]]: ... def evaluate_polynomial(p: List[Tuple[Dict[int, int], Union[int, float, Fraction]]], values: Dict[int, Union[int, float, Fraction]]) -> Fraction: ... ``` Constraints * Coefficients and evaluated results will be managed as Fractions to maintain precision. * The addition and multiplication of polynomials must handle variable powers and combine like terms appropriately. * Inputs will be valid per the format described, no need to handle invalid inputs. # Examples 1. **Polynomial Addition** - **Input**: `p1 = [({1: 1}, 3), ({2: 2}, 4)]`, `p2 = [({1: 1}, 2), ({2: 1}, 5)]` - **Output**: `[({1: 1}, 5), ({2: 2}, 4), ({2: 1}, 5)]` 2. **Polynomial Multplication** - **Input**: `p1 = [({1: 1}, 3)]`, `p2 = [({2: 1}, 5)]` - **Output**: `[({1: 1, 2: 1}, 15)]` 3. **Polynomial Evaluation** - **Input**: `p = [({1: 2}, 4)]`, `values = {1: 3}` - **Output**: `36` Notes - For Polynomial Evaluation, ensure you handle each term correctly by raising the value to the appropriate power. - You should utilize existing methods within the `Monomial` and `Polynomial` classes to assist in performing necessary operations.","solution":"from typing import List, Tuple, Dict, Union from fractions import Fraction from collections import defaultdict def combine_monomials(monomials): combined = defaultdict(Fraction) for vars_exp, coeff in monomials: vars_exp_tuple = tuple(sorted(vars_exp.items())) combined[vars_exp_tuple] += Fraction(coeff) return [(dict(var_exp), coeff) for var_exp, coeff in combined.items() if coeff != 0] def add_polynomials(p1: List[Tuple[Dict[int, int], Union[int, float, Fraction]]], p2: List[Tuple[Dict[int, int], Union[int, float, Fraction]]]) -> List[Tuple[Dict[int, int], Union[int, float, Fraction]]]: return combine_monomials(p1 + p2) def multiply_polynomials(p1: List[Tuple[Dict[int, int], Union[int, float, Fraction]]], p2: List[Tuple[Dict[int, int], Union[int, float, Fraction]]]) -> List[Tuple[Dict[int, int], Union[int, float, Fraction]]]: product_monomials = [] for vars_exp1, coeff1 in p1: for vars_exp2, coeff2 in p2: combined_vars_exp = vars_exp1.copy() for var, exp in vars_exp2.items(): if var in combined_vars_exp: combined_vars_exp[var] += exp else: combined_vars_exp[var] = exp product_monomials.append((combined_vars_exp, Fraction(coeff1) * Fraction(coeff2))) return combine_monomials(product_monomials) def evaluate_polynomial(p: List[Tuple[Dict[int, int], Union[int, float, Fraction]]], values: Dict[int, Union[int, float, Fraction]]) -> Fraction: result = Fraction(0) for vars_exp, coeff in p: term_value = Fraction(coeff) for var, exp in vars_exp.items(): term_value *= Fraction(values[var]) ** exp result += term_value return result"},{"question":"# Question You are required to implement a function named `fibonacci` which computes the n-th Fibonacci number in an efficient manner. Your implementation should handle large values of n efficiently, avoiding the pitfalls of excessive space or time complexity. **Function Signature**: ```python def fibonacci(n: int) -> int: Computes the n-th Fibonacci number efficiently. Arguments: n : int : The position of the Fibonacci number to compute. Returns: int : The n-th Fibonacci number. ``` **Input**: * An integer `n` (0 <= n <= 10^6) representing the position of the Fibonacci number in the sequence. **Output**: * Returns an integer which is the n-th Fibonacci number. **Constraints**: * You are expected to use an efficient approach with respect to both time and space complexity. * The solution should handle large inputs up to `n = 10^6` within a reasonable performance time. # Example: ```python assert fibonacci(0) == 0 assert fibonacci(1) == 1 assert fibonacci(10) == 55 assert fibonacci(50) == 12586269025 ``` --- # Scenario In financial modeling, the Fibonacci sequence often is used to compute projections based on incremental growth. Your task is to design an algorithm that can compute very large Fibonacci numbers efficiently to help the team quickly predict stock market trends based on historical Fibonacci pattern analysis.","solution":"def fibonacci(n: int) -> int: Computes the n-th Fibonacci number efficiently using an iterative approach. Arguments: n : int : The position of the Fibonacci number to compute. Returns: int : The n-th Fibonacci number. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Context You are developing a financial application that frequently needs to handle large numbers represented as arrays of digits. Your task is to implement an efficient function to increment these numbers by one. This challenge helps ensure that basic arithmetic operations are accurately and efficiently handled even with very large numbers. # Problem Statement Given a non-negative number represented as an array of digits, increment the number by one and return the resulting array of digits. # Requirements 1. Implement a function **`plus_one(digits: List[int]) -> List[int]`**. 2. The input list **`digits`** represents a non-negative integer where each element is a digit. 3. The digits are stored in big-endian order, meaning the most significant digit is at the head of the list. 4. Do not use in-built functions for directly converting the list of digits to a number or vice versa (e.g., `int` or `str`). # Constraints * **Input**: A list of non-negative single-digit integers `[0-9]`. * **Output**: A new list of integers representing the original number incremented by one. * **Performance**: * Time Complexity: O(n) * Space Complexity: O(1) (modifications should be in-place or near-constant space allowed) # Examples Example 1: ```python Input: digits = [1, 2, 3] Output: [1, 2, 4] ``` Example 2: ```python Input: digits = [9, 9, 9] Output: [1, 0, 0, 0] ``` Example 3: ```python Input: digits = [0] Output: [1] ``` # Edge Cases 1. Incrementing from 9 to 10. 2. An input list of `[9, 9, 9, 9]` leading to `[1, 0, 0, 0, 0]`. 3. Single element lists like `[0]`, `[9]`. # Implementation Plan Implement your solution under the constraints given, ensuring it is optimized for performance in both time and space.","solution":"from typing import List def plus_one(digits: List[int]) -> List[int]: Given a non-negative number represented as an array of digits, increment the number by one. :param digits: List of digits representing the number. :return: A new list of digits representing the number incremented by one. n = len(digits) # Start from the last digit and work backwards for i in range(n-1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 # If all digits are 9, resulting number would be \'100...0\' return [1] + [0] * n"},{"question":"Question: Find Plans with Target Savings in Retirement Planning # Context You are building an application that helps users plan for retirement by modeling various investment paths. Imagine you have a hierarchical representation of possible savings/investment strategies, where each node represents a potential yearly savings amount and has connections (edges) to subsequent yearly savings options. # Problem Given a hierarchical structure (binary tree) of possible savings paths where each node\'s value represents the savings for one year, write a function to find all investment paths that match a target financial goal over several years. Each path must start at the root (start of retirement planning) and end at a leaf node (specific retirement year). # Function Signature ```python def find_savings_paths(root, target): :param root: A TreeNode representing the root of the binary tree. :param target: An integer representing the target savings amount. :return: A list of lists, where each list represents a path\'s yearly savings amounts summing to the target. ``` # Constraints - The tree could be empty. - Each node value is a non-negative integer. - Ensure efficient memory usage and avoid excess recursion-depth errors. # Example Given the following binary tree and target = 22: ``` 5 / 4 8 / / 11 13 4 / / 7 2 5 1 ``` The function should return: ``` [ [5,4,11,2], [5,8,4,5] ] ``` # Notes - Ensure to handle edge cases, such as an empty tree, a tree with only one node, and nodes with large/small values. - Consider both recursive and iterative solutions. Good luck and happy coding!","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_savings_paths(root, target): def dfs(node, current_path, current_sum): if not node: return current_path.append(node.value) current_sum += node.value if not node.left and not node.right and current_sum == target: result.append(list(current_path)) else: dfs(node.left, current_path, current_sum) dfs(node.right, current_path, current_sum) current_path.pop() result = [] dfs(root, [], 0) return result"},{"question":"# Selection Sort Improvement & Edge Case Handling Scenario You are part of a software development team tasked with improving the robustness of an existing sorting algorithm. The algorithm uses Selection Sort, which you know is straightforward but has performance concerns with larger datasets. You are to write a function that not only implements Selection Sort but also improves its handling of edge cases and provides an early exit mechanism when the array is already sorted. Task Write a function `improved_selection_sort` that sorts an array of integers in non-decreasing order using Selection Sort with the following improvements: 1. **Early Exit**: If the array is already sorted at any point, the function should stop further unnecessary iterations. 2. **Edge Case Handling**: Ensure that the function can handle special cases such as: - Empty array `[]` - Array with one element `[x]` - Array that is already sorted `[1, 2, 3, 4, 5]` - Array with all elements the same `[5, 5, 5, 5, 5]` Input/Output Specifications * **Input**: A list of integers `arr` which can be empty or contain integers. * **Output**: A sorted list of integers in non-decreasing order. Constraints - The input array length can be up to 10,000 elements. - Assume all integer values fit within typical integer limits in Python. Function Signature ```python def improved_selection_sort(arr: List[int]) -> List[int]: pass ``` Example ```python # Example 1: Basic Case print(improved_selection_sort([64, 25, 12, 22, 11])) # Output: [11, 12, 22, 25, 64] # Example 2: Already Sorted Case print(improved_selection_sort([1, 2, 3, 4, 5])) # Output: [1, 2, 3, 4, 5] # Example 3: Empty Array print(improved_selection_sort([])) # Output: [] # Example 4: Single Element print(improved_selection_sort([42])) # Output: [42] # Example 5: All Elements The Same print(improved_selection_sort([5, 5, 5, 5, 5])) # Output: [5, 5, 5, 5, 5] ```","solution":"def improved_selection_sort(arr): Sorts an array in non-decreasing order using an improved Selection Sort. Includes early exit if the array is already sorted at any point. Handles edge cases such as empty array, single element array, already sorted array, and all elements are the same. n = len(arr) if n <= 1: return arr # An empty array or a single element array is already sorted for i in range(n): min_index = i already_sorted = True for j in range(i + 1, n): if arr[j] < arr[min_index]: min_index = j if arr[j - 1] > arr[j]: already_sorted = False if already_sorted: break arr[i], arr[min_index] = arr[min_index], arr[i] return arr"},{"question":"You are given a sorted array and a series of queries. Each query is a target value for which you need to determine the index at which it should be inserted to maintain the sorted order. Write a function `insert_positions(sorted_array, queries)` that takes two arguments: 1. `sorted_array`: A list of distinct integers sorted in ascending order. 2. `queries`: A list of integers representing the values to be queried. The function should return a list of indices corresponding to the insertion points of each target value from the `queries` in the `sorted_array`. # Input: * `sorted_array`: A list of integers [a1, a2, ..., an] (1 ≤ n ≤ 10^5). * `queries`: A list of integers [q1, q2, ..., qm] (1 ≤ m ≤ 10^5). # Output: * A list of integers where each integer represents the insertion index for the corresponding value in the `queries`. # Constraints: * Both `sorted_array` and `queries` can contain negative and positive integers. * All elements in `sorted_array` are distinct. * The solution should aim for a time complexity of O(m log n). # Example: ```python sorted_array = [1, 3, 5, 6] queries = [5, 2, 7, 0] insert_positions(sorted_array, queries) # Output: [2, 1, 4, 0] ``` # Explanation: - For the query `5`, it is found at index `2`. - For the query `2`, it would be placed at index `1`, between `1` and `3`. - For the query `7`, it would be placed at index `4`, after `6`. - For the query `0`, it would be placed at index `0`, before `1`.","solution":"from bisect import bisect_left def insert_positions(sorted_array, queries): Returns the list of indices where each query should be inserted in the sorted_array to maintain sorted order. return [bisect_left(sorted_array, query) for query in queries]"},{"question":"You are tasked with implementing a function to find the first occurrence of a string (`needle`) inside another string (`haystack`). This task tests your understanding of string searching algorithms and requires careful handling of edge cases and performance considerations. Function Signature ```python def contain_string(haystack: str, needle: str) -> int: ``` Input - `haystack`: A string, the text in which we are searching. - `needle`: A string, the text we are searching for within `haystack`. Output - An integer, representing the index of the first occurrence of `needle` in `haystack`. If `needle` is not present in `haystack`, return -1. Constraints - The length of `needle` will be `m` and the length of `haystack` will be `n`. - 0 <= m <= n <= 10^4 - Both `haystack` and `needle` may contain any printable ASCII character. Performance Requirements Your solution should be efficient enough to handle input sizes up to the given constraints comfortably. Example ```python # Example 1: assert contain_string(\\"hello\\", \\"ll\\") == 2 # Example 2: assert contain_string(\\"aaaaa\\", \\"bba\\") == -1 # Example 3: assert contain_string(\\"abc\\", \\"\\") == 0 # Example 4: assert contain_string(\\"\\", \\"a\\") == -1 ``` You are required to thoroughly test edge cases, particularly involving empty strings or strings of different lengths. Ensure that your code is efficient and handles large inputs within a reasonable time frame. # Hint Consider cases where the `needle` is either an empty string or longer than the `haystack`. Review how your code handles these scenarios to avoid incorrect results or performance degradation.","solution":"def contain_string(haystack: str, needle: str) -> int: Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. if needle == \\"\\": return 0 return haystack.find(needle)"},{"question":"# Linked List Sorted Validation You are given a singly linked list, and your task is to implement a function that verifies if the list is in non-decreasing (sorted) order. Function Signature ```python def is_sorted(head: ListNode) -> bool: ``` Input - `head`: The head node of a singly linked list. Each node `ListNode` has two attributes: - `val`: an integer value of the node. - `next`: a reference to the next node in the list or `None` if it is the last node. Output - Returns `True` if the list is sorted in non-decreasing order, else `False`. Constraints - The list can contain negative values and duplicate entries. - The number of nodes in the linked list can range from `0` to `10^5`. Performance Requirements - The implementation should run in linear time, O(n), and use constant space, O(1). Example ```text Input: 1 -> 2 -> 3 -> 4 Output: True Input: 1 -> 2 -> -1 -> 3 Output: False Input: None Output: True ``` Considerations - The implementation should handle edge cases such as an empty list (which is considered sorted) and a single-element list (also considered sorted). - Ensure that the linked list is intact and operates within the prescribed constraints.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_sorted(head: ListNode) -> bool: Returns True if the linked list is in non-decreasing order, otherwise False. current = head while current and current.next: if current.val > current.next.val: return False current = current.next return True"},{"question":"Cycle Detection in Directed Graph Objective: Implement a function that determines whether a given directed graph contains a cycle using depth-first search (DFS) and vertex traversal states. Function Signature: ```python def detect_cycle(graph: dict) -> bool: ``` Input: * `graph`: A dictionary representing a directed graph where keys are vertex labels and values are lists of adjacent vertices. Output: * Returns `True` if the graph contains at least one cycle, otherwise `False`. Example: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } print(detect_cycle(graph)) # Output: True graph2 = { \'A\': [\'B\', \'C\'], \'B\': [], \'C\': [\'D\'], \'D\': [] } print(detect_cycle(graph2)) # Output: False ``` Constraints: * Assume the graph does not contain any self-loops or parallel edges. * The graph can have up to `10^3` vertices and `10^4` edges. * Vertex labels are unique and represented as strings. Hints: * Use Depth-First Search (DFS) to traverse the graph. * Track the state of each vertex using the states WHITE (unvisited), GRAY (being visited), and BLACK (visited and processed completely). * Be mindful of disconnected components in the graph. Solution Template: ```python from enum import Enum class TraversalState(Enum): WHITE = 0 GRAY = 1 BLACK = 2 def detect_cycle(graph): def is_in_cycle(graph, traversal_states, vertex): if traversal_states[vertex] == TraversalState.GRAY: return True traversal_states[vertex] = TraversalState.GRAY for neighbor in graph[vertex]: if is_in_cycle(graph, traversal_states, neighbor): return True traversal_states[vertex] = TraversalState.BLACK return False traversal_states = {vertex: TraversalState.WHITE for vertex in graph} for vertex in graph: if traversal_states[vertex] == TraversalState.WHITE and is_in_cycle(graph, traversal_states, vertex): return True return False ``` # Notes: * Ensure your solution handles all edge cases, including graphs with no edges, disconnected graphs, and graphs with complex cycles. * Provide a clear and concise implementation within the given constraints.","solution":"from enum import Enum class TraversalState(Enum): WHITE = 0 GRAY = 1 BLACK = 2 def detect_cycle(graph): def is_in_cycle(graph, traversal_states, vertex): if traversal_states[vertex] == TraversalState.GRAY: return True if traversal_states[vertex] == TraversalState.BLACK: return False traversal_states[vertex] = TraversalState.GRAY for neighbor in graph.get(vertex, []): if is_in_cycle(graph, traversal_states, neighbor): return True traversal_states[vertex] = TraversalState.BLACK return False traversal_states = {vertex: TraversalState.WHITE for vertex in graph} for vertex in graph: if traversal_states[vertex] == TraversalState.WHITE: if is_in_cycle(graph, traversal_states, vertex): return True return False"},{"question":"# Run-Length Encoding and Decoding **Background**: Run-length encoding (RLE) is a simple and efficient data compression algorithm especially effective for datasets where data values repeat consecutive identical values. **Problem**: You are required to implement two functions, one to encode a given input string using run-length encoding and another to decode a run-length encoded string back to its original form. **Function Definitions**: 1. `def encode_rle(input: str) -> str` 2. `def decode_rle(input: str) -> str` **Input Format**: - `encode_rle` function expects a string `input` which consists of any printable characters. - `decode_rle` function expects a string `input` which follows the RLE format (i.e., count followed by the character). **Output Format**: - `encode_rle` should return a run-length encoded string. - `decode_rle` should return the original string after decoding the RLE format. **Constraints**: - The input string length will be between 0 and 10^5. - Characters can include any printable characters. **Example**: ```python # Encoding input_str = \\"aaabbccccd\\" assert encode_rle(input_str) == \\"3a2b4c1d\\" # Decoding encoded_str = \\"3a2b4c1d\\" assert decode_rle(encoded_str) == \\"aaabbccccd\\" ``` **Hint**: Ensure proper handling of single characters and empty strings.","solution":"def encode_rle(input: str) -> str: if not input: return \\"\\" encoded_str = \\"\\" count = 1 prev_char = input[0] for char in input[1:]: if char == prev_char: count += 1 else: encoded_str += f\\"{count}{prev_char}\\" count = 1 prev_char = char encoded_str += f\\"{count}{prev_char}\\" return encoded_str def decode_rle(input: str) -> str: if not input: return \\"\\" decoded_str = \\"\\" count = \\"\\" for char in input: if char.isdigit(): count += char else: decoded_str += char * int(count) count = \\"\\" return decoded_str"},{"question":"Enhanced Linear Search Context A company is building a search functionality for a small, real-time analytics dashboard where records can frequently change and adding/deleting records is as common as searching for them. Given that the dataset is relatively small and dynamic, a simple search algorithm like linear search might be appropriate for finding records. However, to better handle updates and reduce frequent scans, an extended task involves handling these search functionalities more efficiently. Task **Part A**: Implement a `linear_search` function for an array of records. Each record is a dictionary containing at least an `id` and `value` field. Your function should find and return the dictionary record by its `id`. **Part B**: Now, improve the search operation by maintaining a lookup dictionary (hash map) to store the index positions of each record based on their `id`. This would allow for more efficient lookups. Requirements: * **Function Name**: `linear_search(arr, query_id)` * **Input**: * `arr` (list): List of dictionaries each having at least `id` and `value` fields. * `query_id` (int): The `id` of the record to search for. * **Output**: * The dictionary that contains the given `id` or `None` if not found. * **Constraints**: * The function must handle arrays of varied lengths efficiently. Further Expectations: * Ensure your function handles typical edge cases such as: * Empty list. * `id` not present in the list. * Optimize your code to enhance search performance as described in Part B. **Example**: ```python data = [ {\\"id\\": 1, \\"value\\": \\"record1\\"}, {\\"id\\": 2, \\"value\\": \\"record2\\"}, {\\"id\\": 3, \\"value\\": \\"record3\\"} ] # Part A print(linear_search(data, 2)) # Output: {\\"id\\": 2, \\"value\\": \\"record2\\"} # Part B # Additional steps require maintaining a lookup dictionary ```","solution":"def linear_search(arr, query_id): Returns the dictionary that contains the given query_id or None if not found. Parameters: arr (list): List of dictionaries each having at least `id` and `value` fields. query_id (int): The `id` of the record to search for. Returns: dict or None: The dictionary containing the given query_id or None if not found. for record in arr: if record[\'id\'] == query_id: return record return None # Part B: Efficient search using a lookup dictionary class EfficientSearcher: def __init__(self, records): self.records = records self.lookup = {record[\'id\']: record for record in records} def search(self, query_id): Returns the dictionary that contains the given query_id or None if not found. Parameters: query_id (int): The `id` of the record to search for. Returns: dict or None: The dictionary containing the given query_id or None if not found. return self.lookup.get(query_id)"},{"question":"Implement a Modified Bitonic Sort Given the recursive sorting mechanism of **Bitonic Sort**, you are to **enhance and modify the existing implementation** to handle arrays of any arbitrary length (n). This involves: 1. Extending and pre-processing the input array such that its length becomes the next power of two while conserving the original elements. Use infinity or a very large number for padding values. 2. Implementing an **in-place sorting** to minimize space complexity. # Function Signature Complete the function: ```python def modified_bitonic_sort(arr, reverse=False): pass ``` # Input * **arr**: List of integers. * **reverse**: Boolean, default is `False`. If `False`, the array should be sorted in ascending order. If `True`, the array should be sorted in descending order. # Output * The function should return a new list which is the sorted representation of the input list `arr`. # Constraints * The length of `arr` will be within the range [0, 10^3]. * When padding, use Python\'s `float(\'inf\')` or a suitably large constant value. # Examples 1. **Example 1**: ```python arr = [3, 7, 2, 5] print(modified_bitonic_sort(arr)) # Output: [2, 3, 5, 7] ``` 2. **Example 2**: ```python arr = [10, 30, 11, 20, 4, 9] print(modified_bitonic_sort(arr, reverse=True)) # Output: [30, 20, 11, 10, 9, 4] ``` # Notes * You must handle cases where the length of `arr` is not a power of two by padding appropriately. * You are encouraged to use and adapt parts of the provided bitonic sort code for better understanding and efficiency.","solution":"def bitonic_compare_and_swap(arr, i, j, direction): if direction == (arr[i] > arr[j]): arr[i], arr[j] = arr[j], arr[i] def bitonic_merge(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 for i in range(low, low + k): bitonic_compare_and_swap(arr, i, i + k, direction) bitonic_merge(arr, low, k, direction) bitonic_merge(arr, low + k, k, direction) def bitonic_sort_recursive(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 bitonic_sort_recursive(arr, low, k, True) # Sort in ascending order bitonic_sort_recursive(arr, low + k, k, False) # Sort in descending order bitonic_merge(arr, low, cnt, direction) def next_power_of_two(x): return 1 if x == 0 else 2 ** (x - 1).bit_length() def modified_bitonic_sort(arr, reverse=False): n = len(arr) if n == 0: return [] # Extend the array to the next power of two size next_pow_two = next_power_of_two(n) extended_arr = arr + [float(\'inf\')] * (next_pow_two - n) # Perform bitonic sort bitonic_sort_recursive(extended_arr, 0, next_pow_two, not reverse) # Remove the padding and return the sorted array sorted_arr = [x for x in extended_arr if x != float(\'inf\')] return sorted_arr"}]'),O={name:"App",components:{PoemCard:N},data(){return{searchQuery:"",visibleCount:4,poemsData:A,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},C={class:"search-container"},F={class:"card-container"},z={key:0,class:"empty-state"},L=["disabled"],R={key:0},Y={key:1};function j(r,e,l,p,s,a){const f=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",C,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",F,[(n(!0),i(b,null,v(a.displayedPoems,(o,m)=>(n(),w(f,{key:m,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",z,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",Y,"Loading...")):(n(),i("span",R,"See more"))],8,L)):u("",!0)])}const B=c(O,[["render",j],["__scopeId","data-v-90cacbd5"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/53.md","filePath":"library/53.md"}'),P={name:"library/53.md"},H=Object.assign(P,{setup(r){return(e,l)=>(n(),i("div",null,[x(B)]))}});export{M as __pageData,H as default};
