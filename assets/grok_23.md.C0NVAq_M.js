import{_,o as s,c as r,a as t,m as c,t as d,C as h,M as g,U as b,f as u,F as y,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},A={class:"review-title"},L={class:"review-content"};function R(i,e,l,m,n,a){return s(),r("div",q,[t("div",T,[t("div",A,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",L,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(l.poem.solution),1)])])])}const C=_(k,[["render",R],["__scopeId","data-v-5301c0a3"]]),F=JSON.parse(`[{"question":"import numpy as np from sklearn.metrics.pairwise import cosine_similarity from sklearn.preprocessing import StandardScaler class RecommendationSystem: def __init__(self): self.user_ratings = None self.product_features = None self.user_profiles = None def preprocess_data(self, user_ratings, product_features): Preprocesses the raw user and product data. def build_user_profiles(self): Builds user profiles based on their ratings and browsing history. def recommend_products(self, user_id, top_n=5): Recommends top_n products for a given user based on their profile. def evaluate_recommendations(self, actual_ratings, predicted_ratings): Evaluates the recommendation system using Mean Squared Error. def handle_cold_start(self, new_user_ratings, new_product_features): Handles cold-start problems for new users or products. def ensure_user_privacy(self): Ensures user privacy by anonymizing user data. from solution import RecommendationSystem import numpy as np def test_preprocess_data(): recommender = RecommendationSystem() user_ratings = np.array([[4, 5, 2], [3, 2, 4], [5, 4, 3]]) product_features = np.array([[0.5, 1], [0.2, 0.8], [0.7, 0.9]]) recommender.preprocess_data(user_ratings, product_features) assert recommender.user_ratings.shape == user_ratings.shape assert recommender.product_features.shape == product_features.shape def test_build_user_profiles(): recommender = RecommendationSystem() user_ratings = np.array([[4, 5, 2], [3, 2, 4], [5, 4, 3]]) product_features = np.array([[0.5, 1], [0.2, 0.8], [0.7, 0.9]]) recommender.preprocess_data(user_ratings, product_features) recommender.build_user_profiles() assert recommender.user_profiles.shape == (3, 2) def test_recommend_products(): recommender = RecommendationSystem() user_ratings = np.array([[4, 5, 2], [3, 2, 4], [5, 4, 3]]) product_features = np.array([[0.5, 1], [0.2, 0.8], [0.7, 0.9]]) recommender.preprocess_data(user_ratings, product_features) recommender.build_user_profiles() recommendations = recommender.recommend_products(0, top_n=2) assert len(recommendations) == 2 def test_evaluate_recommendations(): recommender = RecommendationSystem() actual_ratings = np.array([5, 3, 4]) predicted_ratings = np.array([4.5, 3.2, 3.9]) mse = recommender.evaluate_recommendations(actual_ratings, predicted_ratings) assert mse < 0.5 def test_handle_cold_start(): recommender = RecommendationSystem() user_ratings = np.array([[4, 5, 2], [3, 2, 4], [5, 4, 3]]) product_features = np.array([[0.5, 1], [0.2, 0.8], [0.7, 0.9]]) recommender.preprocess_data(user_ratings, product_features) new_user_ratings = np.array([[2, 3, 4]]) new_user_profiles = recommender.handle_cold_start(new_user_ratings, None) assert new_user_profiles.shape == (1, recommender.product_features.shape[1]) def test_ensure_user_privacy(): recommender = RecommendationSystem() user_ratings = np.array([[4, 5, 2], [3, 2, 4], [5, 4, 3]]) recommender.preprocess_data(user_ratings, np.array([[0.5, 1], [0.2, 0.8], [0.7, 0.9]])) anonymized_data = recommender.ensure_user_privacy() assert anonymized_data.shape == user_ratings.shape assert not np.array_equal(anonymized_data, user_ratings)","solution":"import numpy as np from sklearn.metrics.pairwise import cosine_similarity from sklearn.preprocessing import StandardScaler class RecommendationSystem: def __init__(self): self.user_ratings = None self.product_features = None self.user_profiles = None def preprocess_data(self, user_ratings, product_features): Preprocesses the raw user and product data. self.user_ratings = StandardScaler().fit_transform(user_ratings) self.product_features = StandardScaler().fit_transform(product_features) def build_user_profiles(self): Builds user profiles based on their ratings and browsing history. # Here we assume that user ratings matrix is user x products self.user_profiles = np.dot(self.user_ratings, self.product_features) def recommend_products(self, user_id, top_n=5): Recommends top_n products for a given user based on their profile. user_profile = self.user_profiles[user_id, :] product_scores = cosine_similarity(user_profile.reshape(1, -1), self.product_features)[0] recommended_product_indices = np.argsort(-product_scores)[:top_n] return recommended_product_indices def evaluate_recommendations(self, actual_ratings, predicted_ratings): Evaluates the recommendation system using Mean Squared Error. mse = np.mean((actual_ratings - predicted_ratings) ** 2) return mse def handle_cold_start(self, new_user_ratings, new_product_features): Handles cold-start problems for new users or products. if new_user_ratings is not None: new_user_ratings = StandardScaler().fit_transform(new_user_ratings) new_user_profiles = np.dot(new_user_ratings, self.product_features) return new_user_profiles if new_product_features is not None: new_product_features = StandardScaler().fit_transform(new_product_features) new_recommendations = cosine_similarity(self.user_profiles, new_product_features) return new_recommendations def ensure_user_privacy(self): Ensures user privacy by anonymizing user data. anonymized_data = np.random.permutation(self.user_ratings) return anonymized_data"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def diameter_of_binary_tree(root: TreeNode) -> int: Returns the diameter of the binary tree. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> diameter_of_binary_tree(root) 3 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> diameter_of_binary_tree(root) 2 >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> diameter_of_binary_tree(root) 2 >>> diameter_of_binary_tree(None) 0","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def diameter_of_binary_tree(root: TreeNode) -> int: Returns the diameter of the binary tree. def depth(node: TreeNode) -> int: nonlocal max_diameter if not node: return 0 left_depth = depth(node.left) right_depth = depth(node.right) max_diameter = max(max_diameter, left_depth + right_depth) return max(left_depth, right_depth) + 1 max_diameter = 0 depth(root) return max_diameter"},{"question":"def all_palindromes_and_length(lst: list, min_length: int) -> bool: Returns True if all strings in the list lst are palindromes and the length of the list exceeds min_length. >>> all_palindromes_and_length([\\"madam\\", \\"racecar\\", \\"level\\"], 2) True >>> all_palindromes_and_length([\\"hello\\", \\"world\\"], 1) False >>> all_palindromes_and_length([\\"deified\\", \\"civic\\", \\"radar\\"], 3) False","solution":"def all_palindromes_and_length(lst: list, min_length: int) -> bool: Returns True if all strings in the list lst are palindromes and the length of the list exceeds min_length. return all(s == s[::-1] for s in lst) and len(lst) > min_length"},{"question":"def is_palindrome(s: str) -> bool: Checks if the given string is a palindrome, considering only alphanumeric characters and ignoring cases. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"A\\") True >>> is_palindrome(\\"No lemon, no melon\\") True >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"123456\\") False","solution":"def is_palindrome(s: str) -> bool: Checks if the given string is a palindrome, considering only alphanumeric characters and ignoring cases. # Filter only alphanumeric characters and transform to lowercase filtered_chars = [char.lower() for char in s if char.isalnum()] # Check if the filtered characters form a palindrome return filtered_chars == filtered_chars[::-1]"},{"question":"def first_non_repeating_char(input_str: str) -> str: Returns the first non-repeating character in the input string. If all characters repeat, or the string is empty, returns an underscore ('_'). Examples: >>> first_non_repeating_char(\\"swiss\\") 'w' >>> first_non_repeating_char(\\"teeter\\") 'r' >>> first_non_repeating_char(\\"aabbcc\\") '_' >>> first_non_repeating_char(\\"aA\\") 'a' >>> first_non_repeating_char(\\"Aa\\") 'A' >>> first_non_repeating_char(\\"x\\") 'x' >>> first_non_repeating_char(\\"Z\\") 'Z' >>> first_non_repeating_char(\\"ab@cc@b\\") 'a' >>> first_non_repeating_char(\\"!!ab!!\\") 'a'","solution":"def first_non_repeating_char(input_str): Returns the first non-repeating character in the input string. If all characters repeat, or the string is empty, returns an underscore ('_'). char_count = {} # Count the occurrences of each character in the input string for char in input_str: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first non-repeating character for char in input_str: if char_count[char] == 1: return char return '_'"},{"question":"def is_palindrome(s: str) -> bool: Returns True if the given string is a palindrome, ignoring spaces, punctuation, and capitalization. Returns False otherwise. >>> is_palindrome('racecar') True >>> is_palindrome('madam') True >>> is_palindrome('A man, a plan, a canal, Panama') True >>> is_palindrome('hello') False >>> is_palindrome('') True >>> is_palindrome('12321') True >>> is_palindrome('12345') False","solution":"def is_palindrome(s): Returns True if the given string is a palindrome, ignoring spaces, punctuation, and capitalization. Returns False otherwise. # Filter out non-alphanumeric characters and convert to lowercase filtered_chars = [char.lower() for char in s if char.isalnum()] # Initialize pointers for the two ends of the filtered list left, right = 0, len(filtered_chars) - 1 while left < right: if filtered_chars[left] != filtered_chars[right]: return False left += 1 right -= 1 return True"},{"question":"class Theater: A simple ticket booking system for a small theater. Attributes: rows (int): Number of rows in the theater. cols (int): Number of columns in the theater. seats (List[List[bool]]): 2D list representing the seating arrangement where True indicates available seats and False indicates occupied seats. def __init__(self, rows, cols): Initialize the theater with given rows and columns as a grid of available seats (denoted by True). def book_seat(self, row, col): Tries to book a seat at the specified row and column. Returns a message indicating if the seat was successfully booked or if it was already occupied. Args: row (int): Row index of the requested seat. col (int): Column index of the requested seat. Returns: str: Booking status message. Raises: ValueError: If the seat request is out of bounds. def reset_seating(self): Resets all seats to be available. # Example usage theater = Theater(5, 5) print(theater.book_seat(1, 1)) # Should print \\"Seat successfully booked.\\" print(theater.book_seat(1, 1)) # Should print \\"Seat is already occupied.\\" print(theater.book_seat(6, 6)) # Should print \\"Seat request is out of bounds!\\" theater.reset_seating() # Test cases def test_theater_initial_booking(): theater = Theater(5, 5) assert theater.book_seat(2, 3) == \\"Seat successfully booked.\\" assert not theater.seats[2][3] # seat should now be occupied def test_theater_rebook_same_seat(): theater = Theater(5, 5) theater.book_seat(2, 3) assert theater.book_seat(2, 3) == \\"Seat is already occupied.\\" def test_theater_out_of_bounds_booking(): theater = Theater(5, 5) assert theater.book_seat(5, 5) == \\"Seat request is out of bounds!\\" assert theater.book_seat(6, 0) == \\"Seat request is out of bounds!\\" assert theater.book_seat(0, 6) == \\"Seat request is out of bounds!\\" def test_theater_reset_seating(): theater = Theater(5, 5) theater.book_seat(2, 3) theater.book_seat(4, 4) theater.reset_seating() assert theater.seats[2][3] # seat should now be available assert theater.seats[4][4] # seat should now be available def test_theater_booking_after_reset(): theater = Theater(5, 5) theater.book_seat(2, 3) theater.reset_seating() assert theater.book_seat(2, 3) == \\"Seat successfully booked.\\"","solution":"class Theater: def __init__(self, rows, cols): Initialize the theater with given rows and columns as a grid of available seats (denoted by True). self.rows = rows self.cols = cols self.seats = [[True for _ in range(cols)] for _ in range(rows)] def book_seat(self, row, col): Tries to book a seat at the specified row and column. Returns a message indicating if the seat was successfully booked or if it was already occupied. if row >= self.rows or col >= self.cols: return \\"Seat request is out of bounds!\\" if self.seats[row][col]: self.seats[row][col] = False return \\"Seat successfully booked.\\" else: return \\"Seat is already occupied.\\" def reset_seating(self): Resets all seats to be available. self.seats = [[True for _ in range(self.cols)] for _ in range(self.rows)] # Example usage theater = Theater(5, 5) print(theater.book_seat(1, 1)) # Should print \\"Seat successfully booked.\\" print(theater.book_seat(1, 1)) # Should print \\"Seat is already occupied.\\" print(theater.book_seat(6, 6)) # Should print \\"Seat request is out of bounds!\\" theater.reset_seating()"},{"question":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring of the input string s. >>> longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] >>> longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" >>> longest_palindromic_substring(\\"a\\") == \\"a\\" >>> longest_palindromic_substring(\\"\\") == \\"\\" >>> longest_palindromic_substring(\\"ac\\") == \\"a\\" >>> longest_palindromic_substring(\\"racecar\\") == \\"racecar\\" >>> longest_palindromic_substring(\\"abacdfgdcaba\\") in [\\"aba\\", \\"cdc\\"] >>> longest_palindromic_substring(\\"Aba\\") == \\"A\\"","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring of the input string s. def expand_from_center(left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] if not s: return \\"\\" longest = \\"\\" for i in range(len(s)): # Odd length palindrome odd_palindrome = expand_from_center(i, i) if len(odd_palindrome) > len(longest): longest = odd_palindrome # Even length palindrome even_palindrome = expand_from_center(i, i + 1) if len(even_palindrome) > len(longest): longest = even_palindrome return longest"},{"question":"def odd_even(numbers: list) -> dict: Returns a dictionary with the keys 'odd' and 'even'. The 'odd' key should have a list of all odd numbers from the input list, and the 'even' key should have a list of all even numbers. Raises a ValueError if the list contains non-numeric values. Args: numbers (list): A list of integers. Returns: dict: A dictionary with keys 'odd' and 'even'. Raises: ValueError: If any element in the list is not a number. Examples: >>> odd_even([1, 2, 3, 4, 5, 6]) {'odd': [1, 3, 5], 'even': [2, 4, 6]} >>> odd_even([1, 'two', 3]) Traceback (most recent call last): ... ValueError: All elements must be numbers >>> odd_even([2.0, 3.5, 4.5]) {'odd': [3.5, 4.5], 'even': [2.0]}","solution":"def odd_even(numbers): Returns a dictionary with the keys 'odd' and 'even'. The 'odd' key should have a list of all odd numbers from the input list, and the 'even' key should have a list of all even numbers. Raises a ValueError if the list contains non-numeric values. Args: numbers (list): A list of integers. Returns: dict: A dictionary with keys 'odd' and 'even'. Raises: ValueError: If any element in the list is not a number. odd = [] even = [] for number in numbers: if not isinstance(number, (int, float)): raise ValueError(\\"All elements must be numbers\\") if number % 2 == 0: even.append(number) else: odd.append(number) return {'odd': odd, 'even': even}"},{"question":"from typing import List def unique_paths(grid: List[List[int]]) -> int: Determine the number of unique paths a robot can take to reach the bottom-right corner of the grid, avoiding obstacles. >>> unique_paths([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 2 >>> unique_paths([ ... [0, 1], ... [0, 0] ... ]) == 1 >>> unique_paths([ ... [1, 0], ... [0, 0] ... ]) == 0 >>> unique_paths([ ... [0, 0], ... [0, 1] ... ]) == 0 >>> unique_paths([ ... [0, 1, 0], ... [1, 1, 0], ... [0, 0, 0] ... ]) == 0 >>> unique_paths([ ... [0, 0, 0, 0], ... [1, 1, 1, 0], ... [0, 0, 0, 0], ... [0, 1, 1, 0] ... ]) == 1","solution":"from typing import List def unique_paths(grid: List[List[int]]) -> int: n = len(grid) if grid[0][0] == 1 or grid[n-1][n-1] == 1: return 0 dp = [[0]*n for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"from typing import List def find_pairs(arr: List[int], target: int) -> List[List[int]]: Write a function that accepts an array of integers and a target sum as inputs and returns an array of all unique pairs of integers that sum up to the target. The input array may contain duplicates, and each pair should be sorted in non-decreasing order. The output array should contain these pairs sorted lexicographically. >>> find_pairs([1, 2, -1, 0, 2, -1, 3], 2) [[-1, 3], [0, 2]] >>> find_pairs([1, 1, 1], 5) [] >>> find_pairs([1, 2, 3, 4, 5], 5) [[1, 4], [2, 3]] >>> find_pairs([-2, -1, 0, 1, 2], 0) [[-2, 2], [-1, 1]] >>> find_pairs([2, 3, 3, -1, 4, -1, 1], 3) [[-1, 4], [1, 2]] >>> find_pairs([1, 2, 1, 2], 4) [[2, 2]] >>> find_pairs([], 3) []","solution":"from typing import List def find_pairs(arr: List[int], target: int) -> List[List[int]]: Returns a list of all unique pairs of integers from the array that sum up to the target value. arr.sort() seen = set() pairs = set() for number in arr: complement = target - number if complement in seen: pairs.add((min(number, complement), max(number, complement))) seen.add(number) return [list(pair) for pair in sorted(pairs)]"},{"question":"import math from typing import List, Any def calculate_factorials(numbers: List[Any]) -> List[int]: Returns a new list containing the factorial of each integer in the original list. Non-integer elements are skipped. >>> calculate_factorials([3, 4]) [6, 24] >>> calculate_factorials([5, 'a', None]) [120] >>> calculate_factorials([0]) [1] >>> calculate_factorials([10]) [3628800] >>> calculate_factorials([3, -2, -1]) [6] >>> calculate_factorials([]) [] >>> calculate_factorials(['a', None, [], {}]) []","solution":"import math def calculate_factorials(numbers): Returns a new list containing the factorial of each integer in the original list. Non-integer elements are skipped. def factorial(n): return math.factorial(n) factorial_list = [] for num in numbers: try: result = factorial(int(num)) factorial_list.append(result) except (ValueError, TypeError): continue return factorial_list"},{"question":"from typing import List def filter_primes(input_list: List[int]) -> List[int]: Returns a sorted list of prime numbers from the input list. If the input list is empty, or contains non-integer elements, an appropriate error should be raised. >>> filter_primes([29, 15, 3, 8, 23, 76, 5]) [3, 5, 23, 29] >>> filter_primes([4, 6, 8, 10]) [] >>> filter_primes([]) [] >>> filter_primes([2, 3, 5, 7, 11]) [2, 3, 5, 7, 11] pass","solution":"def is_prime(n): Check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(input_list): Returns a sorted list of prime numbers from the input list. if not isinstance(input_list, list): raise ValueError(\\"Input should be a list\\") for element in input_list: if not isinstance(element, int): raise ValueError(\\"All elements in the input list should be integers\\") # Filter prime numbers and sort the result primes = sorted([num for num in input_list if is_prime(num)]) return primes"},{"question":"def is_palindrome(s: str) -> bool: Determines if the given string s is a palindrome, ignoring case and non-alphabetic characters. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") == True >>> is_palindrome(\\"RaceCar\\") == True >>> is_palindrome(\\"Hello, World!\\") == False >>> is_palindrome(\\"Was it a car or a cat I saw\\") == True >>> is_palindrome(\\"\\") == True >>> is_palindrome(\\"a\\") == True >>> is_palindrome(\\"No 'x' in Nixon\\") == True","solution":"def is_palindrome(s): Determines if the given string s is a palindrome, ignoring case and non-alphabetic characters. Args: s (str): Input string Returns: bool: True if s is a palindrome, False otherwise. cleaned_str = ''.join(char.lower() for char in s if char.isalpha()) return cleaned_str == cleaned_str[::-1] # Example usage: # s = \\"A man, a plan, a canal, Panama\\" # print(is_palindrome(s)) # Output: True"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Returns a list where each element is the product of all numbers in the input list except for the number at that position. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_except_self([1, 0, 3, 4]) [0, 12, 0, 0] >>> product_except_self([5]) [1] >>> product_except_self([]) [] >>> product_except_self([1, 1, 1, 1]) [1, 1, 1, 1] >>> product_except_self([-1, 2, -3, 4]) [-24, 12, -8, 6] >>> product_except_self([1, -2, 3, -4, 5]) [120, -60, 40, -30, 24]","solution":"def product_except_self(nums): Returns a list where each element is the product of all numbers in the input list except for the number at that position. n = len(nums) if n == 0: return [] # Initialize the left and right product lists left_products = [1] * n right_products = [1] * n # Fill in left_products where left_products[i] is the product of all elements to the left of index i for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] # Fill in right_products where right_products[i] is the product of all elements to the right of index i for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Calculate the result by multiplying corresponding elements of left_products and right_products result = [1] * n for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"def longest_palindromic_substring(s: str) -> str: Find the longest palindromic substring in a given string without using built-in substring functions. >>> longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> longest_palindromic_substring(\\"cbbd\\") \\"bb\\"","solution":"def longest_palindromic_substring(s): if not s: return \\"\\" n = len(s) start = 0 end = 0 def expand_around_center(s, left, right): while left >= 0 and right < n and s[left] == s[right]: left -= 1 right += 1 return left + 1, right - 1 for i in range(n): left1, right1 = expand_around_center(s, i, i) left2, right2 = expand_around_center(s, i, i + 1) if right1 - left1 > end - start: start, end = left1, right1 if right2 - left2 > end - start: start, end = left2, right2 return s[start:end + 1]"},{"question":"def island_perimeter(grid: List[List[int]]) -> int: Given a grid representing land (1) and water (0), calculates the perimeter of the island. >>> island_perimeter([[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]) 16 >>> island_perimeter([[1,0]]) 4 >>> island_perimeter([[1]]) 4 >>> island_perimeter([[1,1,1,1]]) 10 >>> island_perimeter([[0,0,0,0],[0,1,1,0],[0,1,1,0],[0,0,0,0]]) 8 >>> grid = [[0]*100 for _ in range(100)]; grid[50][50] = 1; island_perimeter(grid) 4 >>> island_perimeter([[1,0],[1,0]]) 6","solution":"def island_perimeter(grid): Given a grid representing land (1) and water (0), calculates the perimeter of the island. Parameters: grid (List[List[int]]): A binary matrix where 1 represents land and 0 represents water. Returns: int: The perimeter of the island. rows = len(grid) cols = len(grid[0]) perimeter = 0 for i in range(rows): for j in range(cols): if grid[i][j] == 1: # Check for water or grid edges at the top, bottom, left and right if i == 0 or grid[i-1][j] == 0: # Top perimeter += 1 if i == rows-1 or grid[i+1][j] == 0: # Bottom perimeter += 1 if j == 0 or grid[i][j-1] == 0: # Left perimeter += 1 if j == cols-1 or grid[i][j+1] == 0: # Right perimeter += 1 return perimeter"},{"question":"def is_palindrome(s: str) -> bool: Recursively checks whether a given string is a palindrome. Ignores spaces, punctuation, and capitalization. >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"A man a plan a canal Panama\\") True >>> is_palindrome(\\"No 'x' in Nixon\\") True >>> is_palindrome(\\"MadamInEdenImAdam\\") True >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"Not a palindrome!\\") False","solution":"def is_palindrome(s): Recursively checks whether a given string is a palindrome. Ignores spaces, punctuation, and capitalization. s = ''.join(char.lower() for char in s if char.isalnum()) def check_palindrome(low, high): if low >= high: return True if s[low] != s[high]: return False return check_palindrome(low + 1, high - 1) return check_palindrome(0, len(s) - 1)"},{"question":"def create_playlist(songs: List[Tuple[int, str]]) -> List[int]: Create a playlist of 'N' songs where no two songs of the same genre are placed consecutively. Args: songs (List[Tuple[int, str]]): List of tuples where each tuple contains length of the song and its genre. Returns: List[int]: Order of song indices to be played or an empty list if not possible. Examples: >>> create_playlist([(200, 'pop'), (180, 'rock'), (120, 'pop'), (250, 'jazz'), (90, 'rock')]) [0, 1, 3, 2, 4] or any other combination that satisfies the genre constraint. from solution import create_playlist def test_example_case(): songs = [(200, 'pop'), (180, 'rock'), (120, 'pop'), (250, 'jazz'), (90, 'rock')] result = create_playlist(songs) for i in range(1, len(result)): assert songs[result[i]][1] != songs[result[i-1]][1] def test_single_genre(): songs = [(200, 'pop'), (120, 'pop'), (150, 'pop')] assert create_playlist(songs) == [] def test_alternate_genres(): songs = [(200, 'pop'), (180, 'rock'), (150, 'pop'), (170, 'rock')] result = create_playlist(songs) for i in range(1, len(result)): assert songs[result[i]][1] != songs[result[i-1]][1] def test_unique_genres(): songs = [(200, 'pop'), (180, 'rock'), (120, 'jazz')] assert create_playlist(songs) == [0, 1, 2] def test_no_songs(): assert create_playlist([]) == [] def test_impossible_case(): songs = [(200, 'pop'), (150, 'pop'), (100, 'pop'), (50, 'rock')] assert create_playlist(songs) == []","solution":"from collections import defaultdict from typing import List, Tuple def create_playlist(songs: List[Tuple[int, str]]) -> List[int]: if not songs: # If the input list is empty, return an empty list return [] # Step 1: Group the songs by their genres genre_dict = defaultdict(list) for i, (length, genre) in enumerate(songs): genre_dict[genre].append(i) # Check if there is any genre that has more than half of the total songs. max_genre_count = max(len(genre_songs) for genre_songs in genre_dict.values()) if max_genre_count > (len(songs) + 1) // 2: return [] # It's not possible to create the playlist result = [] # Create a list of genres sorted by the number of songs in descending order sorted_genres = sorted(genre_dict.keys(), key=lambda g: -len(genre_dict[g])) # Use two pointers to interleave songs from the genres pointers = {genre: 0 for genre in sorted_genres} for i in range(len(songs)): for j in range(len(sorted_genres)): genre = sorted_genres[j] if pointers[genre] < len(genre_dict[genre]): if not result or songs[result[-1]][1] != genre: result.append(genre_dict[genre][pointers[genre]]) pointers[genre] += 1 break return result"},{"question":"class ShoppingCart: A class representing a shopping cart, which allows adding and removing items, and calculates the total cost. Each item has a name, price, and quantity. >>> cart = ShoppingCart() >>> cart.add_item(\\"apple\\", 1.0, 3) >>> cart.get_items() [{'name': 'apple', 'price': 1.0, 'quantity': 3}] >>> cart.total_cost() 3.0 >>> cart.add_item(\\"banana\\", 0.5, 5) >>> cart.get_items() [{'name': 'apple', 'price': 1.0, 'quantity': 3}, {'name': 'banana', 'price': 0.5, 'quantity': 5}] >>> cart.total_cost() 5.5 >>> cart.remove_item(\\"apple\\") >>> cart.get_items() [{'name': 'banana', 'price': 0.5, 'quantity': 5}] >>> cart.remove_item(\\"apple\\") Traceback (most recent call last): ... ValueError: Item not in the cart >>> cart.add_item(\\"banana\\", -0.5, 5) Traceback (most recent call last): ... ValueError: Price and quantity must be non-negative def __init__(self): self.items = [] def add_item(self, name: str, price: float, quantity: int): Adds an item to the cart. def remove_item(self, name: str): Removes an item from the cart. def get_items(self): Returns the list of items currently in the cart. def total_cost(self): Calculates the total cost of the items in the cart.","solution":"class ShoppingCart: def __init__(self): self.items = [] def add_item(self, name, price, quantity): if price < 0 or quantity < 0: raise ValueError(\\"Price and quantity must be non-negative\\") for item in self.items: if item['name'] == name: item['quantity'] += quantity return self.items.append({'name': name, 'price': price, 'quantity': quantity}) def remove_item(self, name): for item in self.items: if item['name'] == name: self.items.remove(item) return raise ValueError(\\"Item not in the cart\\") def get_items(self): return self.items def total_cost(self): return sum(item['price'] * item['quantity'] for item in self.items)"},{"question":"def flip_matrix_diagonally(matrix): Flips the matrix across its main diagonal in place. :param matrix: List of lists representing the square matrix >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> flip_matrix_diagonally(matrix) >>> matrix [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> matrix = [ ... [1, 2], ... [3, 4] ... ] >>> flip_matrix_diagonally(matrix) >>> matrix [[1, 3], [2, 4]]","solution":"def flip_matrix_diagonally(matrix): Flips the matrix across its main diagonal in place. :param matrix: List of lists representing the square matrix n = len(matrix) for i in range(n): for j in range(i + 1, n): # Swap elements across the main diagonal matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]"},{"question":"import pytest class MalformedKeyException(Exception): def __init__(self, message): super().__init__(message) def create_nested_dict(key_list): Create a nested dictionary from a list of strings with hierarchical keys separated by dots. >>> create_nested_dict([\\"a.b.c\\", \\"a.b.d\\", \\"a.e\\", \\"f\\"]) {'a': {'b': {'c': {}, 'd': {}}, 'e': {}}, 'f': {}} >>> create_nested_dict([\\"a\\"]) {'a': {}} >>> create_nested_dict([\\"a.b.c\\", \\"a.b.c\\"]) MalformedKeyException: Duplicated key 'c' at the same level found in 'a.b.c' >>> create_nested_dict([\\"\\"]) MalformedKeyException: Malformed key '' found. Keys must not be empty or have leading/trailing dots. >>> create_nested_dict([\\".a\\"]) MalformedKeyException: Malformed key '.a' found. Keys must not be empty or have leading/trailing dots. >>> create_nested_dict([\\"a.\\"]) MalformedKeyException: Malformed key 'a.' found. Keys must not be empty or have leading/trailing dots. def test_create_nested_dict(): key_list = [\\"a.b.c\\", \\"a.b.d\\", \\"a.e\\", \\"f\\"] expected_output = { \\"a\\": { \\"b\\": { \\"c\\": {}, \\"d\\": {} }, \\"e\\": {} }, \\"f\\": {} } assert create_nested_dict(key_list) == expected_output def test_single_key(): key_list = [\\"a\\"] expected_output = { \\"a\\": {} } assert create_nested_dict(key_list) == expected_output def test_duplicate_key(): key_list = [\\"a.b.c\\", \\"a.b.c\\"] with pytest.raises(MalformedKeyException, match=\\"Duplicated key 'c' at the same level found in 'a.b.c'\\"): create_nested_dict(key_list) def test_empty_string_key(): key_list = [\\"\\"] with pytest.raises(MalformedKeyException, match=\\"Malformed key '' found. Keys must not be empty or have leading/trailing dots.\\"): create_nested_dict(key_list) def test_leading_dot_key(): key_list = [\\".a\\"] with pytest.raises(MalformedKeyException, match=\\"Malformed key '.a' found. Keys must not be empty or have leading/trailing dots.\\"): create_nested_dict(key_list) def test_trailing_dot_key(): key_list = [\\"a.\\"] with pytest.raises(MalformedKeyException, match=\\"Malformed key 'a.' found. Keys must not be empty or have leading/trailing dots.\\"): create_nested_dict(key_list)","solution":"class MalformedKeyException(Exception): def __init__(self, message): super().__init__(message) def create_nested_dict(key_list): nested_dict = {} for key in key_list: if not key or key.startswith('.') or key.endswith('.'): raise MalformedKeyException( f\\"Malformed key '{key}' found. Keys must not be empty or have leading/trailing dots.\\" ) keys = key.split('.') d = nested_dict for part in keys[:-1]: if part not in d: d[part] = {} d = d[part] if keys[-1] in d: raise MalformedKeyException( f\\"Duplicated key '{keys[-1]}' at the same level found in '{key}'.\\" ) d[keys[-1]] = {} return nested_dict"},{"question":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates a given matrix 90 degrees clockwise. :param matrix: A 2D list representing the matrix. :return: A new 2D list representing the rotated matrix. >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == [ ... [7, 4, 1], ... [8, 5, 2], ... [9, 6, 3] ... ] >>> rotate_matrix([ ... [1, 2, 3, 4], ... [5, 6, 7, 8] ... ]) == [ ... [5, 1], ... [6, 2], ... [7, 3], ... [8, 4] ... ] >>> rotate_matrix([ ... [1] ... ]) == [ ... [1] ... ] >>> rotate_matrix([]) == [] >>> rotate_matrix([[]]) == [] >>> rotate_matrix([ ... [1], ... [2] ... ]) == [ ... [2, 1] ... ] >>> rotate_matrix([ ... [1, 2] ... ]) == [ ... [1], ... [2] ... ]","solution":"def rotate_matrix(matrix): Rotates a given matrix 90 degrees clockwise. :param matrix: A 2D list representing the matrix. :return: A new 2D list representing the rotated matrix. if not matrix or not matrix[0]: return [] row_count = len(matrix) col_count = len(matrix[0]) # Create a new matrix with swapped rows and columns rotated_matrix = [[0] * row_count for _ in range(col_count)] for r in range(row_count): for c in range(col_count): rotated_matrix[c][row_count - 1 - r] = matrix[r][c] return rotated_matrix"},{"question":"def standard_deviation_of_sample_mean(stdev_population: float, sample_size: int) -> float: Calculate the standard deviation of the sample mean for a given population standard deviation and sample size. :param stdev_population: Standard deviation of the population :param sample_size: Size of the sample :returns: Standard deviation of the sample mean >>> standard_deviation_of_sample_mean(150, 16) 37.5 >>> standard_deviation_of_sample_mean(120, 9) 40.0 >>> standard_deviation_of_sample_mean(100, 25) 20.0 >>> standard_deviation_of_sample_mean(80, 4) 40.0","solution":"def standard_deviation_of_sample_mean(stdev_population, sample_size): Returns the standard deviation of the sample mean. :param stdev_population: Standard deviation of the population :param sample_size: Size of the sample :return: Standard deviation of the sample mean return stdev_population / (sample_size ** 0.5) # Given parameters stdev_population = 150 sample_size = 16 # Calculate the standard deviation of the sample mean std_dev_sample_mean = standard_deviation_of_sample_mean(stdev_population, sample_size) std_dev_sample_mean"},{"question":"def longest_continuous_activity(timestamps: List[int]) -> int: Identify the longest stretch of continuous user activity given a list of timestamps in seconds. Activity is considered continuous if the difference between consecutive timestamps does not exceed 5 seconds. >>> longest_continuous_activity([]) == 0 >>> longest_continuous_activity([5]) == 0 >>> longest_continuous_activity([1, 10, 20, 30]) == 0 >>> longest_continuous_activity([1, 2, 3, 4, 5]) == 4 >>> longest_continuous_activity([10, 13, 15, 16, 25, 26, 27, 30, 50]) == 6 >>> longest_continuous_activity([1, 2, 3, 10, 11, 12, 20, 21]) == 2 >>> longest_continuous_activity([1, 2, 3, 10, 11, 12, 20, 21, 22, 23, 24, 25, 26]) == 6","solution":"def longest_continuous_activity(timestamps): if not timestamps: return 0 timestamps.sort() max_duration = 0 current_start = timestamps[0] current_end = timestamps[0] for i in range(1, len(timestamps)): if timestamps[i] - current_end <= 5: current_end = timestamps[i] else: max_duration = max(max_duration, current_end - current_start) current_start = timestamps[i] current_end = timestamps[i] max_duration = max(max_duration, current_end - current_start) return max_duration"},{"question":"def rotate_matrix_90_degrees_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates an NxN matrix 90 degrees clockwise. Args: matrix (list of lists): The NxN matrix to rotate. Returns: list of lists: The rotated NxN matrix. >>> rotate_matrix_90_degrees_clockwise([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix_90_degrees_clockwise([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotate_matrix_90_degrees_clockwise([[1]]) [[1]] >>> rotate_matrix_90_degrees_clockwise([]) [] pass","solution":"def rotate_matrix_90_degrees_clockwise(matrix): Rotates an NxN matrix 90 degrees clockwise. Args: matrix (list of lists): The NxN matrix to rotate. Returns: list of lists: The rotated NxN matrix. n = len(matrix) # Create a new matrix with the same dimensions rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n-1-i] = matrix[i][j] return rotated_matrix"},{"question":"def findDuplicates(nums): Finds all duplicate elements in the array \`nums\` where the elements range from 0 to n-1. :param nums: List[int] - List of integers where integers are in range 0 to n-1 :return: List[int] - List of duplicate integers >>> findDuplicates([4, 5, 6, 3, 2, 5, 1, 3, 0]) [5, 3] >>> findDuplicates([0, 1, 2, 3, 4]) []","solution":"def findDuplicates(nums): Finds all duplicate elements in the array \`nums\` where the elements range from 0 to n-1. :param nums: List[int] - List of integers where integers are in range 0 to n-1 :return: List[int] - List of duplicate integers duplicates = [] for i in range(len(nums)): index = abs(nums[i]) if nums[index] >= 0: nums[index] = -nums[index] else: duplicates.append(index) return duplicates"},{"question":"def generate_spiral_matrix(n: int, m: int) -> List[List[int]]: Generates an n x m matrix filled with integers in a clockwise spiral pattern. >>> generate_spiral_matrix(4, 3) [[1, 2, 3], [10, 11, 4], [9, 12, 5], [8, 7, 6]] >>> generate_spiral_matrix(3, 4) [[1, 2, 3, 4], [10, 11, 12, 5], [9, 8, 7, 6]] >>> generate_spiral_matrix(1, 1) [[1]] >>> generate_spiral_matrix(2, 2) [[1, 2], [4, 3]] >>> generate_spiral_matrix(3, 2) [[1, 2], [6, 3], [5, 4]]","solution":"def generate_spiral_matrix(n, m): Generates an n x m matrix filled with integers in a clockwise spiral pattern. matrix = [[0 for _ in range(m)] for _ in range(n)] num = 1 left, right = 0, m - 1 top, bottom = 0, n - 1 while left <= right and top <= bottom: for i in range(left, right + 1): # Move from left to right matrix[top][i] = num num += 1 top += 1 for i in range(top, bottom + 1): # Move from top to bottom matrix[i][right] = num num += 1 right -= 1 if top <= bottom: for i in range(right, left - 1, -1): # Move from right to left matrix[bottom][i] = num num += 1 bottom -= 1 if left <= right: for i in range(bottom, top - 1, -1): # Move from bottom to top matrix[i][left] = num num += 1 left += 1 return matrix"},{"question":"from collections import deque from typing import List def is_one_letter_different(word1: str, word2: str) -> bool: Returns True if word1 and word2 differ by exactly one letter. if len(word1) != len(word2): return False diff_count = 0 for c1, c2 in zip(word1, word2): if c1 != c2: diff_count += 1 if diff_count > 1: return False return diff_count == 1 def find_shortest_transformation(word_list: List[str], target_word: str) -> List[str]: Finds the shortest sequence of transformations from the given word list that converts the target word to another word in the list. Each transformation must change exactly one character and must create a valid word present in the given word list. >>> find_shortest_transformation([\\"cat\\", \\"bat\\", \\"hat\\", \\"bad\\", \\"had\\", \\"dad\\"], \\"cat\\") [\\"cat\\", \\"bat\\", \\"bad\\", \\"dad\\"] >>> find_shortest_transformation([\\"bat\\", \\"hat\\", \\"bad\\", \\"had\\", \\"dad\\"], \\"xyz\\") [] >>> find_shortest_transformation([\\"bat\\", \\"hat\\", \\"bad\\", \\"had\\", \\"dad\\"], \\"bat\\") [\\"bat\\", \\"bad\\", \\"dad\\"] >>> find_shortest_transformation([\\"cat\\"], \\"cat\\") [] >>> find_shortest_transformation([\\"cat\\", \\"bat\\", \\"bit\\", \\"bet\\", \\"bot\\"], \\"cat\\") in [[\\"cat\\", \\"bat\\", \\"bot\\"], [\\"cat\\", \\"bat\\", \\"bit\\", \\"bot\\"]] True","solution":"from collections import deque def is_one_letter_different(word1, word2): Returns True if word1 and word2 differ by exactly one letter. if len(word1) != len(word2): return False diff_count = 0 for c1, c2 in zip(word1, word2): if c1 != c2: diff_count += 1 if diff_count > 1: return False return diff_count == 1 def find_shortest_transformation(word_list, target_word): Finds the shortest transformation sequence from the target_word to another word in word_list where each transformation must change exactly one character to form a valid word in the list. if target_word not in word_list: word_list.insert(0, target_word) word_set = set(word_list) queue = deque([(target_word, [target_word])]) visited = set(target_word) while queue: current_word, path = queue.popleft() for word in word_set: if word not in visited and is_one_letter_different(current_word, word): if word != target_word: queue.append((word, path + [word])) visited.add(word) if word == target_word: break return path if len(path) > 1 else [] # Example input word_list = [\\"cat\\", \\"bat\\", \\"hat\\", \\"bad\\", \\"had\\", \\"dad\\"] target_word = \\"cat\\" print(find_shortest_transformation(word_list, target_word)) # Output: [\\"cat\\", \\"bat\\", \\"bad\\", \\"dad\\"]"},{"question":"from typing import List def find_missing_number(arr: List[int]) -> int: Returns the missing number in the sequence from 1 to N. >>> find_missing_number([3, 7, 1, 2, 8, 4, 5]) 6 >>> find_missing_number([1, 2, 3, 5]) 4 >>> find_missing_number([1, 3]) 2 >>> find_missing_number([2]) 1 >>> find_missing_number([1, 2, 4, 5, 6, 3, 8, 9, 7]) 10 >>> find_missing_number([2, 3, 4, 5, 6, 7, 8, 9, 10]) 1","solution":"from typing import List def find_missing_number(arr: List[int]) -> int: Returns the missing number in the sequence from 1 to N. n = len(arr) + 1 total_sum = n * (n + 1) // 2 actual_sum = sum(arr) return total_sum - actual_sum"},{"question":"def longest_contiguous_subarray(nums): Returns the length of the longest contiguous subarray with identical elements. Parameters: nums (list): A list of integers. Returns: int: The length of the longest contiguous subarray where all elements have the same value. Examples: >>> longest_contiguous_subarray([1, 1, 2, 2, 2, 3, 3]) 3 >>> longest_contiguous_subarray([4, 4, 4, 4, 4, 5, 5, 5, 6, 6, 6, 6]) 5 >>> longest_contiguous_subarray([1]) 1 >>> longest_contiguous_subarray([2, 2, 3, 3, 3, 1, 1]) 3","solution":"def longest_contiguous_subarray(nums): Returns the length of the longest contiguous subarray with identical elements. if not nums: return 0 max_length = 1 current_length = 1 for i in range(1, len(nums)): if nums[i] == nums[i-1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def is_bipartite(graph: Dict[Any, List[Any]]) -> bool: Determine whether the given graph is bipartite. The graph is represented as an adjacency list. :param graph: Dictionary representing the graph (node -> list of adjacent nodes) :return: True if graph is bipartite, False otherwise >>> graph = { ... \\"A\\": [\\"B\\", \\"C\\"], ... \\"B\\": [\\"A\\", \\"D\\"], ... \\"C\\": [\\"A\\", \\"D\\"], ... \\"D\\": [\\"B\\", \\"C\\"] ... } >>> is_bipartite(graph) True >>> graph = { ... \\"A\\": [\\"B\\", \\"C\\"], ... \\"B\\": [\\"A\\", \\"C\\"], ... \\"C\\": [\\"A\\", \\"B\\"] ... } >>> is_bipartite(graph) False >>> graph = { ... \\"A\\": [] ... } >>> is_bipartite(graph) True >>> graph = {} >>> is_bipartite(graph) True >>> graph = { ... \\"A\\": [\\"B\\"], ... \\"B\\": [\\"A\\"], ... \\"C\\": [\\"D\\"], ... \\"D\\": [\\"C\\"] ... } >>> is_bipartite(graph) True >>> graph = { ... 1: [2, 3], ... 2: [1, 4], ... 3: [1, 4], ... 4: [2, 3], ... 5: [6], ... 6: [5] ... } >>> is_bipartite(graph) True >>> graph = { ... 1: [2, 3], ... 2: [1, 3], ... 3: [1, 2, 4], ... 4: [3, 5], ... 5: [4] ... } >>> is_bipartite(graph) False pass","solution":"def is_bipartite(graph): Determine whether the given graph is bipartite. The graph is represented as an adjacency list. :param graph: Dictionary representing the graph (node -> list of adjacent nodes) :return: True if graph is bipartite, False otherwise def bfs_check(node): queue = [node] color[node] = 0 # Assign the first color while queue: current = queue.pop(0) current_color = color[current] for neighbor in graph.get(current, []): if neighbor in color: if color[neighbor] == current_color: return False else: color[neighbor] = 1 - current_color queue.append(neighbor) return True color = {} for node in graph: if node not in color: if not bfs_check(node): return False return True"},{"question":"def are_parentheses_balanced(expression: str) -> bool: Create a Python function that accepts a string containing an expression with nested parentheses and verifies if the parentheses are balanced. >>> are_parentheses_balanced(\\"((a+b)*(c-d))\\") True >>> are_parentheses_balanced(\\"((a+b)*(c-d)\\") False # Your implementation here","solution":"def are_parentheses_balanced(expression): Returns True if the parentheses in the expression are balanced, False otherwise. stack = [] for char in expression: if char == '(': stack.append(char) elif char == ')': if not stack: # if stack is empty return False stack.pop() return len(stack) == 0 # return True if stack is empty, meaning all parentheses were balanced"},{"question":"from typing import List, Tuple def identify_trend(sales_data: List[int]) -> Tuple[float, float]: Identifies the trend in sales data over the days using linear regression. sales_data: List of daily sales figures. Returns: - The slope of the trend line (positive indicates an upward trend, negative indicates a downward trend). - The intercept of the trend line. >>> identify_trend([10, 20, 30, 40, 50]) (positive slope, intercept) >>> identify_trend([50, 40, 30, 20, 10]) (negative slope, intercept) >>> identify_trend([30, 30, 30, 30, 30]) (0, intercept) >>> identify_trend([10, 20, 20, 20, 10]) (0, intercept)","solution":"def identify_trend(sales_data): Identifies the trend in sales data over the days using linear regression. sales_data: List of daily sales figures. Returns: - The slope of the trend line (positive indicates an upward trend, negative indicates a downward trend). - The intercept of the trend line. from scipy.stats import linregress days = list(range(1, len(sales_data) + 1)) slope, intercept, r_value, p_value, std_err = linregress(days, sales_data) return slope, intercept"},{"question":"def find_substring(s, words): This function identifies the starting indices of substrings in 's' that are concatenations of all the words in the list 'words' without any intervening characters. Words are concatenated in any order and each word from the list 'words' appears exactly once in a concatenated substring. Parameters: s (str): The input string. words (list of str): List of words to form the concatenated substring. Returns: list of int: A list of starting indices of all concatenated substrings. Examples: >>> find_substring('barfoothefoobarman', ['foo', 'bar']) [0, 9] >>> find_substring('wordgoodgoodgoodbestword', ['word', 'good', 'best', 'word']) []","solution":"def find_substring(s, words): from collections import Counter if not s or not words: return [] word_len = len(words[0]) # All words are assumed to be of the same length num_words = len(words) substring_len = word_len * num_words word_count = Counter(words) result = [] for i in range(len(s) - substring_len + 1): seen = Counter() for j in range(num_words): word_index = i + j * word_len word = s[word_index:word_index + word_len] if word in word_count: seen[word] += 1 if seen[word] > word_count[word]: break else: break if seen == word_count: result.append(i) return result"},{"question":"def find_triplets(nums: List[int]) -> List[List[int]]: Returns a list of all unique triplets in the list that sum to zero. >>> find_triplets([-1, 0, 1, 2, -1, -4]) # [[-1, -1, 2], [-1, 0, 1]] >>> find_triplets([1, 2, 3, 4]) # [] >>> find_triplets([-1, -1, 2]) # [[-1, -1, 2]] >>> find_triplets([0, 0, 0, 0]) # [[0, 0, 0]] >>> find_triplets([-2, -1, 0, 1, 2, 3]) # [[-2, -1, 3], [-2, 0, 2], [-1, 0, 1]]","solution":"def find_triplets(nums): Returns a list of all unique triplets in the list that sum to zero. nums.sort() triplets = [] for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, len(nums) - 1 while left < right: sum_triplet = nums[i] + nums[left] + nums[right] if sum_triplet == 0: triplets.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif sum_triplet < 0: left += 1 else: right -= 1 return triplets"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Returns the largest sum of a contiguous subarray using Kadane's algorithm. >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([-1]) -1 >>> max_subarray_sum([1, 2, 3, 4]) 10 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) 6 >>> max_subarray_sum([3, -2, 5, -1]) 6 >>> max_subarray_sum([]) Traceback (most recent call last): ... ValueError: The input array must contain at least one element.","solution":"def max_subarray_sum(nums): Returns the largest sum of a contiguous subarray. The function uses Kadane's algorithm to find the maximum sum. if not nums: raise ValueError(\\"The input array must contain at least one element.\\") max_end_here = max_so_far = nums[0] for num in nums[1:]: max_end_here = max(num, max_end_here + num) max_so_far = max(max_so_far, max_end_here) return max_so_far"},{"question":"from typing import List def longest_increasing_subsequence(arr: List[int]) -> int: Implement a function that takes a list of integers and returns the length of the longest subsequence that is strictly increasing. >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 >>> longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) 1 def test_example_cases(): assert longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) == 4 assert longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) == 4 assert longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) == 1 def test_single_element(): assert longest_increasing_subsequence([10]) == 1 def test_empty_list(): assert longest_increasing_subsequence([]) == 0 def test_all_increasing(): assert longest_increasing_subsequence([1, 2, 3, 4, 5]) == 5 def test_all_decreasing(): assert longest_increasing_subsequence([5, 4, 3, 2, 1]) == 1 def test_mixed_numbers(): assert longest_increasing_subsequence([3, 4, -1, 0, 6, 2, 3]) == 4 def test_complex_case(): assert longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) == 6","solution":"from typing import List def longest_increasing_subsequence(arr: List[int]) -> int: Returns the length of the longest strictly increasing subsequence. if not arr: return 0 n = len(arr) dp = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"from typing import List def maxSubarrayProduct(nums: List[int]) -> int: Given an array of integers, find the maximum product of any subarray within the array. A subarray is a contiguous part of the array, and the product of a subarray is the result of multiplying all elements within the subarray. Args: nums (List[int]): An array of integers, where 1 <= nums.length <= 10^4 and -10 <= nums[i] <= 10. Returns: int: The maximum product of any subarray. Example: >>> maxSubarrayProduct([2, 3, -2, 4]) 6 >>> maxSubarrayProduct([-2, 0, -1]) 0","solution":"def maxSubarrayProduct(nums): if not nums: return 0 max_so_far = nums[0] min_so_far = nums[0] result = max_so_far for i in range(1, len(nums)): current = nums[i] temp_max = max(current, max_so_far * current, min_so_far * current) min_so_far = min(current, max_so_far * current, min_so_far * current) max_so_far = temp_max result = max(result, max_so_far) return result"},{"question":"def longest_substring_with_at_least_k_repeating_characters(s: str, k: int) -> int: Find the length of the longest substring of \`s\` such that the frequency of each character in this substring is at least \`k\`. >>> longest_substring_with_at_least_k_repeating_characters(\\"aaabb\\", 3) 3 >>> longest_substring_with_at_least_k_repeating_characters(\\"ababbc\\", 2) 5","solution":"def longest_substring_with_at_least_k_repeating_characters(s, k): from collections import Counter def helper(start, end): if end - start < k: return 0 count = Counter(s[start:end]) for mid in range(start, end): if count[s[mid]] < k: next_mid = mid + 1 while next_mid < end and count[s[next_mid]] < k: next_mid += 1 return max(helper(start, mid), helper(next_mid, end)) return end - start return helper(0, len(s))"},{"question":"def rearrange_odds_first(nums: List[int]) -> List[int]: Rearranges the list so that all odd numbers come before all even numbers, preserving the relative order within odd and even numbers. >>> rearrange_odds_first([1, 2, 3, 4, 5, 6]) == [1, 3, 5, 2, 4, 6] >>> rearrange_odds_first([2, 4, 6, 8]) == [2, 4, 6, 8] >>> rearrange_odds_first([]) == [] >>> rearrange_odds_first([1]) == [1] >>> rearrange_odds_first([2]) == [2] >>> rearrange_odds_first([2, 1, 2, 3, 4, 3]) == [1, 3, 3, 2, 2, 4] >>> rearrange_odds_first([1, 3, 5, 7]) == [1, 3, 5, 7]","solution":"def rearrange_odds_first(nums): Rearranges the list so that all odd numbers come before all even numbers, preserving the relative order within odd and even numbers. odds = [num for num in nums if num % 2 != 0] evens = [num for num in nums if num % 2 == 0] return odds + evens"},{"question":"def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: Merges two sorted lists (list1 and list2) and returns a single list which is sorted and contains no duplicate integers. >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([1, 2, 2, 3], [2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> merge_sorted_lists([], [1, 2, 3]) == [1, 2, 3] >>> merge_sorted_lists([1, 2, 3], []) == [1, 2, 3] >>> merge_sorted_lists([], []) == [] >>> merge_sorted_lists([1, 2, 3], [1, 2, 3]) == [1, 2, 3] >>> merge_sorted_lists([-3, -1, 2, 4], [-2, -1, 3, 5]) == [-3, -2, -1, 2, 3, 4, 5] >>> merge_sorted_lists([10**5, 10**6, 10**7], [10**5, 10**6, 10**7, 10**8]) == [10**5, 10**6, 10**7, 10**8]","solution":"def merge_sorted_lists(list1, list2): Merges two sorted lists (list1 and list2) and returns a single list which is sorted and contains no duplicate integers. merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] < list2[j]: if not merged_list or merged_list[-1] != list1[i]: merged_list.append(list1[i]) i += 1 elif list1[i] > list2[j]: if not merged_list or merged_list[-1] != list2[j]: merged_list.append(list2[j]) j += 1 else: # list1[i] == list2[j] if not merged_list or merged_list[-1] != list1[i]: merged_list.append(list1[i]) i += 1 j += 1 while i < len(list1): if not merged_list or merged_list[-1] != list1[i]: merged_list.append(list1[i]) i += 1 while j < len(list2): if not merged_list or merged_list[-1] != list2[j]: merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"from typing import List def transform_numbers(nums: List[int]) -> List[int]: Returns a new list with the squares of the even numbers and the cubes of the odd numbers from the input list. Args: nums (list): A list of integers. Returns: list: A list where even numbers are squared and odd numbers are cubed. >>> transform_numbers([1, 2, 3, 4]) [1, 4, 27, 16] >>> transform_numbers([-1, -2, -3, -4]) [-1, 4, -27, 16] >>> transform_numbers([0, 1, -2, -3]) [0, 1, 4, -27] >>> transform_numbers([2, 4, 6, 8]) [4, 16, 36, 64] >>> transform_numbers([1, 3, 5, 7]) [1, 27, 125, 343] >>> transform_numbers([]) []","solution":"def transform_numbers(nums): Returns a new list with the squares of the even numbers and the cubes of the odd numbers from the input list. Args: nums (list): A list of integers. Returns: list: A list where even numbers are squared and odd numbers are cubed. return [x**2 if x % 2 == 0 else x**3 for x in nums]"},{"question":"from typing import List def is_anagram(str1: str, str2: str) -> bool: Determines if two strings are anagrams of each other. Parameters: str1 (str): The first string to compare. str2 (str): The second string to compare. Returns: bool: True if str1 and str2 are anagrams, False otherwise. >>> is_anagram(\\"listen\\", \\"silent\\") True >>> is_anagram(\\"hello\\", \\"world\\") False >>> is_anagram(\\"\\", \\"\\") True >>> is_anagram(\\"Listen\\", \\"Silent\\") True >>> is_anagram(\\"conversation\\", \\"voices rant on\\") True >>> is_anagram(\\"a1b2c!\\", \\"!c2b1a\\") True >>> is_anagram(\\"12345\\", \\"54321\\") True >>> is_anagram(\\"abcd\\", \\"abcde\\") False","solution":"def is_anagram(str1, str2): Determines if two strings are anagrams of each other. Parameters: str1 (str): The first string to compare. str2 (str): The second string to compare. Returns: bool: True if str1 and str2 are anagrams, False otherwise. # Remove whitespace and convert to lower case to handle case-insensitivity str1 = str1.replace(\\" \\", \\"\\").lower() str2 = str2.replace(\\" \\", \\"\\").lower() return sorted(str1) == sorted(str2) # Example usage: str1 = \\"listen\\" str2 = \\"silent\\" print(is_anagram(str1, str2)) # Should return True str1 = \\"hello\\" str2 = \\"world\\" print(is_anagram(str1, str2)) # Should return False"},{"question":"import csv from datetime import datetime from collections import defaultdict import numpy as np def read_temperature_data(file_path): Reads the temperature data from the file and returns a dictionary with dates as keys and lists of (timestamp, temperature) tuples as values. Args: file_path (str): Path to the input temperature data file. Returns: dict: A dictionary where the keys are dates and the values are lists of tuples containing timestamps and temperature readings. pass def calculate_daily_statistics(data): Calculates the daily average, maximum, minimum temperatures and identifies outliers for each day. Args: data (dict): Dictionary containing dates as keys and lists of (timestamp, temperature) tuples as values. Returns: list: A list of tuples containing (date, average_temp, max_temp, min_temp, outliers) pass def write_summary_to_csv(summary, output_file): Writes the daily temperature summary to a CSV file. Args: summary (list): List of tuples containing the daily temperature statistics. output_file (str): Path to the output CSV file. pass def generate_temperature_report(file_path, output_file): Generates the temperature report by reading data, calculating statistics, and writing the summary to a CSV file. Args: file_path (str): Path to the input temperature data file. output_file (str): Path to the output CSV file. pass # Example usage: # generate_temperature_report('temperature_data.txt', 'summary.csv')","solution":"import csv from datetime import datetime from collections import defaultdict import numpy as np def read_temperature_data(file_path): data = defaultdict(list) with open(file_path, 'r') as f: reader = csv.reader(f) for row in reader: timestamp = datetime.strptime(row[0], '%Y-%m-%d %H:%M:%S') temp = float(row[1]) data[timestamp.date()].append((timestamp, temp)) return data def calculate_daily_statistics(data): summary = [] for date, readings in data.items(): temperatures = [temp for _, temp in readings] avg_temp = np.mean(temperatures) max_temp = np.max(temperatures) min_temp = np.min(temperatures) q1, q3 = np.percentile(temperatures, [25, 75]) iqr = q3 - q1 lower_bound = q1 - 1.5 * iqr upper_bound = q3 + 1.5 * iqr outliers = [(timestamp, temp) for timestamp, temp in readings if temp < lower_bound or temp > upper_bound] outliers_str = \\"; \\".join([f\\"{timestamp}: {temp}\\" for timestamp, temp in outliers]) if not outliers_str: outliers_str = \\"None\\" summary.append((date, avg_temp, max_temp, min_temp, outliers_str)) return summary def write_summary_to_csv(summary, output_file): with open(output_file, 'w', newline='') as f: writer = csv.writer(f) writer.writerow([\\"Date\\", \\"Average Temp\\", \\"Max Temp\\", \\"Min Temp\\", \\"Outliers\\"]) for date, avg_temp, max_temp, min_temp, outliers in summary: writer.writerow([date, avg_temp, max_temp, min_temp, outliers]) def generate_temperature_report(file_path, output_file): data = read_temperature_data(file_path) summary = calculate_daily_statistics(data) write_summary_to_csv(summary, output_file)"},{"question":"from typing import List def kth_largest_element(nums: List[int], k: int) -> int: Finds the k-th largest element in the list nums. >>> kth_largest_element([3, 2, 1, 5, 6, 4], 2) 5 >>> kth_largest_element([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 4","solution":"import heapq from typing import List def kth_largest_element(nums: List[int], k: int) -> int: Finds the k-th largest element in the list nums. Uses a min-heap of size k to keep track of the k largest elements encountered so far. # Create a min-heap with the first k elements. min_heap = nums[:k] heapq.heapify(min_heap) # Iterate over the rest of the elements. for num in nums[k:]: if num > min_heap[0]: heapq.heappushpop(min_heap, num) return min_heap[0]"},{"question":"def books_to_rewrap(fiction_books: int, non_fiction_books: int, fiction_defect_rate: float, non_fiction_defect_rate: float) -> int: Calculate the total number of books that need rewrapping. Parameters: fiction_books (int): Number of fiction books. non_fiction_books (int): Number of non-fiction books. fiction_defect_rate (float): Defect rate for fiction books. non_fiction_defect_rate (float): Defect rate for non-fiction books. Returns: int: Total number of books that need rewrapping. Examples: >>> books_to_rewrap(45, 35, 0.2, 0.4) 23 >>> books_to_rewrap(45, 35, 0.0, 0.0) 0 >>> books_to_rewrap(45, 35, 1.0, 1.0) 80 >>> books_to_rewrap(1, 1, 0.5, 0.5) 1 >>> books_to_rewrap(0, 0, 0.2, 0.4) 0","solution":"def books_to_rewrap(fiction_books, non_fiction_books, fiction_defect_rate, non_fiction_defect_rate): Calculate the total number of books that need rewrapping. Parameters: fiction_books (int): Number of fiction books. non_fiction_books (int): Number of non-fiction books. fiction_defect_rate (float): Defect rate for fiction books. non_fiction_defect_rate (float): Defect rate for non-fiction books. Returns: int: Total number of books that need rewrapping. fiction_defect_books = fiction_books * fiction_defect_rate non_fiction_defect_books = non_fiction_books * non_fiction_defect_rate total_defects = fiction_defect_books + non_fiction_defect_books return int(total_defects) # Example usage fiction_books = 45 non_fiction_books = 35 fiction_defect_rate = 0.20 non_fiction_defect_rate = 0.40 books_needing_rewrap = books_to_rewrap(fiction_books, non_fiction_books, fiction_defect_rate, non_fiction_defect_rate) books_needing_rewrap"},{"question":"def most_frequent_word(s: str) -> str: Create a function called \`most_frequent_word\` that takes a string as input and returns the word that appears most frequently. If there are multiple words with the same highest frequency, return the one that appears first in the string. Assume the input string contains only letters and spaces. >>> most_frequent_word(\\"hello\\") 'hello' >>> most_frequent_word(\\"one two one two\\") 'one' >>> most_frequent_word(\\"cat bat cat rat bat bat cat\\") 'cat' >>> most_frequent_word(\\"a b a b c c\\") 'a' >>> most_frequent_word(\\"Cat cat CAT\\") 'Cat' >>> most_frequent_word(\\" \\") '' >>> most_frequent_word(\\"\\") '' >>> most_frequent_word(\\"apple orange banana apple orange orange banana apple\\") 'apple' >>> most_frequent_word(\\"cat dog cat rat\\") 'cat'","solution":"def most_frequent_word(s): Returns the most frequent word in the string. If there is a tie, the word that appears first is returned. words = s.split() frequency = {} max_count = 0 frequent_word = \\"\\" for word in words: if word not in frequency: frequency[word] = 1 else: frequency[word] += 1 if frequency[word] > max_count: max_count = frequency[word] frequent_word = word elif frequency[word] == max_count: if words.index(frequent_word) > words.index(word): frequent_word = word return frequent_word"},{"question":"def sort_string(s: str) -> str: Returns a new string with the characters from the input string sorted in ascending order based on their ASCII values. Time complexity: O(n log n), where n is the length of the input string. >>> sort_string(\\"\\") == \\"\\" >>> sort_string(\\"dcba\\") == \\"abcd\\" >>> sort_string(\\"DCBA\\") == \\"ABCD\\" >>> sort_string(\\"DcBa\\") == \\"BDac\\" >>> sort_string(\\"a!b@c#\\") == \\"!#@abc\\" >>> sort_string(\\"a1b2c3\\") == \\"123abc\\" # Implement the function that sorts the characters of the input string.","solution":"def sort_string(s): Returns a new string with the characters from the input string sorted in ascending order based on their ASCII values. return ''.join(sorted(s)) # The sorted() function in Python uses Timsort algorithm which has a time complexity of O(n log n), # where n is the length of the input string."},{"question":"class Inventory: def __init__(self): Initialize the inventory data structure. pass def add_product(self, product_id, name, quantity): Add a new product to the inventory. Parameters: product_id (int): Unique identifier for the product. name (str): Name of the product. quantity (int): Quantity of the product in stock. Returns: None pass def update_stock(self, product_id, quantity): Update the stock quantity of an existing product. Parameters: product_id (int): Unique identifier for the product. quantity (int): New quantity of the product in stock. Returns: None pass def remove_product(self, product_id): Remove a product from the inventory by its ID. Parameters: product_id (int): Unique identifier for the product. Returns: None pass def get_stock(self, product_id): Retrieve the current stock level of a specific product by its ID. Parameters: product_id (int): Unique identifier for the product. Returns: int: The quantity of the product in stock. pass # Sample usage inventory = Inventory() inventory.add_product(1, \\"Apple\\", 50) inventory.add_product(2, \\"Banana\\", 30) inventory.update_stock(1, 20) current_stock = inventory.get_stock(1) # should return 20 inventory.remove_product(2) # Unit Test import pytest from solution import Inventory def test_add_product(): inventory = Inventory() inventory.add_product(1, \\"Apple\\", 50) assert inventory.inventory == {1: {\\"name\\": \\"Apple\\", \\"quantity\\": 50}} def test_add_product_existing_id(): inventory = Inventory() inventory.add_product(1, \\"Apple\\", 50) with pytest.raises(ValueError): inventory.add_product(1, \\"Banana\\", 30) def test_update_stock(): inventory = Inventory() inventory.add_product(1, \\"Apple\\", 50) inventory.update_stock(1, 20) assert inventory.inventory[1][\\"quantity\\"] == 20 def test_update_nonexistent_product(): inventory = Inventory() with pytest.raises(KeyError): inventory.update_stock(1, 20) def test_remove_product(): inventory = Inventory() inventory.add_product(1, \\"Apple\\", 50) inventory.remove_product(1) assert inventory.inventory == {} def test_remove_nonexistent_product(): inventory = Inventory() with pytest.raises(KeyError): inventory.remove_product(1) def test_get_stock(): inventory = Inventory() inventory.add_product(1, \\"Apple\\", 50) assert inventory.get_stock(1) == 50 def test_get_stock_nonexistent_product(): inventory = Inventory() with pytest.raises(KeyError): inventory.get_stock(1)","solution":"class Inventory: def __init__(self): # Initialize the inventory as an empty dictionary self.inventory = {} def add_product(self, product_id, name, quantity): Adds a new product to the inventory. Parameters: product_id (int): Unique identifier for the product. name (str): Name of the product. quantity (int): Quantity of the product in stock. Returns: None if product_id in self.inventory: raise ValueError(f\\"Product ID {product_id} already exists in the inventory.\\") self.inventory[product_id] = {\\"name\\": name, \\"quantity\\": quantity} def update_stock(self, product_id, quantity): Updates the stock of an existing product. Parameters: product_id (int): Unique identifier for the product. quantity (int): New quantity of the product in stock. Returns: None if product_id not in self.inventory: raise KeyError(f\\"Product ID {product_id} does not exist in the inventory.\\") self.inventory[product_id][\\"quantity\\"] = quantity def remove_product(self, product_id): Removes a product from the inventory by its ID. Parameters: product_id (int): Unique identifier for the product. Returns: None if product_id not in self.inventory: raise KeyError(f\\"Product ID {product_id} does not exist in the inventory.\\") del self.inventory[product_id] def get_stock(self, product_id): Retrieves the current stock level of a specific product by its ID. Parameters: product_id (int): Unique identifier for the product. Returns: int: The quantity of the product in stock. if product_id not in self.inventory: raise KeyError(f\\"Product ID {product_id} does not exist in the inventory.\\") return self.inventory[product_id][\\"quantity\\"]"},{"question":"def is_balanced(expression: str) -> bool: Returns True if the parentheses, brackets, and braces in the expression are correctly balanced and nested, otherwise returns False. >>> is_balanced(\\"[(2+3)*5]\\") == True >>> is_balanced(\\"{[()]}\\") == True >>> is_balanced(\\"({[]})\\") == True >>> is_balanced(\\"[(2+3]*5)\\") == False >>> is_balanced(\\"{[(])}\\") == False >>> is_balanced(\\"([)]\\") == False >>> is_balanced(\\"\\") == True >>> is_balanced(\\"()\\") == True >>> is_balanced(\\"[]\\") == True >>> is_balanced(\\"{}\\") == True >>> is_balanced(\\"(()\\") == False >>> is_balanced(\\"{[\\") == False >>> is_balanced(\\"[(2+3)*5]-{2/3}\\") == True >>> is_balanced(\\"[(2+3]*5)-{2/3}\\") == False","solution":"def is_balanced(expression): Returns True if the parentheses, brackets, and braces in the expression are correctly balanced and nested, otherwise returns False. stack = [] pairs = {')': '(', ']': '[', '}': '{'} for char in expression: if char in pairs.values(): stack.append(char) elif char in pairs.keys(): if not stack or pairs[char] != stack.pop(): return False return not stack"},{"question":"def is_anagram(str1: str, str2: str) -> bool: Checks if two given strings are anagrams of each other. >>> is_anagram(\\"listen\\", \\"silent\\") True >>> is_anagram(\\"hello\\", \\"world\\") False >>> is_anagram(\\"Listen\\", \\"Silent\\") True >>> is_anagram(\\"\\", \\"\\") True >>> is_anagram(\\"a\\", \\"\\") False >>> is_anagram(\\"abc\\", \\"abcd\\") False","solution":"def is_anagram(str1, str2): Checks if two given strings are anagrams. Args: str1 (str): First string. str2 (str): Second string. Returns: bool: True if str1 and str2 are anagrams, False otherwise. # Convert both strings to lower case to handle case insensitivity str1 = str1.lower() str2 = str2.lower() # Return True if sorted characters of both strings are equal, else False return sorted(str1) == sorted(str2)"},{"question":"import re from collections import Counter def most_common_word(file_path): This function reads the content of a file at file_path and returns the most common word in the file. The function ignores punctuation and is case-insensitive. Returns None if the file is empty or contains no words. pass import tempfile def test_most_common_word_normal_case(): content = \\"Hello world! The world is full of amazing things. Hello again, world.\\" with tempfile.NamedTemporaryFile(delete=False) as tf: tf.write(content.encode('utf-8')) tf_path = tf.name assert most_common_word(tf_path) == 'world' def test_most_common_word_empty_file(): with tempfile.NamedTemporaryFile(delete=False) as tf: tf.write(b'') tf_path = tf.name assert most_common_word(tf_path) == None def test_most_common_word_no_words(): content = \\"!!! ??? ,,, ;;:\\" with tempfile.NamedTemporaryFile(delete=False) as tf: tf.write(content.encode('utf-8')) tf_path = tf.name assert most_common_word(tf_path) == None def test_most_common_word_case_insensitivity(): content = \\"APPLE apple ApPlE!\\" with tempfile.NamedTemporaryFile(delete=False) as tf: tf.write(content.encode('utf-8')) tf_path = tf.name assert most_common_word(tf_path) == 'apple' def test_most_common_word_with_punctuation(): content = \\"Milestone, milestone; Milestone! milestone.\\" with tempfile.NamedTemporaryFile(delete=False) as tf: tf.write(content.encode('utf-8')) tf_path = tf.name assert most_common_word(tf_path) == 'milestone'","solution":"import re from collections import Counter def most_common_word(file_path): This function reads the content of a file at file_path and returns the most common word in the file. The function ignores punctuation and is case-insensitive. Returns None if the file is empty or contains no words. with open(file_path, 'r') as file: text = file.read() # Remove punctuation and convert to lower case words = re.findall(r'bw+b', text.lower()) if not words: return None # Use Counter to find the most common word word_counts = Counter(words) most_common = word_counts.most_common(1) return most_common[0][0] if most_common else None"},{"question":"from typing import List def sum_adjacent(elements: List[int]) -> List[int]: Takes a list of integers and returns a new list where each integer is replaced with the sum of its own value and the values of its adjacent elements. >>> sum_adjacent([1, 2, 3, 4, 5]) [3, 6, 9, 12, 9] >>> sum_adjacent([1]) [1] >>> sum_adjacent([-5]) [-5] >>> sum_adjacent([1, 2]) [3, 3] >>> sum_adjacent([-1, -2, -3]) [-3, -6, -5] >>> sum_adjacent([1, -2, 3, -4, 5]) [-1, 2, -3, 4, 1] >>> sum_adjacent([]) [] >>> sum_adjacent([0, 0, 0]) [0, 0, 0]","solution":"def sum_adjacent(elements): Takes a list of integers and returns a new list where each integer is replaced with the sum of its own value and the values of its adjacent elements. if not elements: return [] new_elements = [] for i in range(len(elements)): left = elements[i-1] if i > 0 else 0 right = elements[i+1] if i < len(elements)-1 else 0 new_elements.append(left + elements[i] + right) return new_elements"},{"question":"def gcd(a: int, b: int) -> int: Returns the greatest common divisor (GCD) of a and b. >>> gcd(48, 18) 6 >>> gcd(54, 24) 6 >>> gcd(0, 5) 5 >>> gcd(5, 0) 5 >>> gcd(7, 7) 7 >>> gcd(12, 36) 12 >>> gcd(5, 9) 1","solution":"def gcd(a, b): Returns the greatest common divisor (GCD) of a and b. while b: a, b = b, a % b return a"},{"question":"from typing import List def add_lists(list1: List[int], list2: List[int]) -> List[int]: Returns a new list representing the digits of the sum of two non-negative integers represented by the input lists. >>> add_lists([1, 2, 3], [9, 8, 7]) [1, 1, 1, 0] >>> add_lists([9, 8, 7], [5, 6]) [1, 0, 4, 3] >>> add_lists([9, 9, 9], [1]) [1, 0, 0, 0] >>> add_lists([1, 2, 3], [4, 5, 6]) [5, 7, 9] >>> add_lists([5], [5]) [1, 0] >>> add_lists([0, 0, 1], [0, 0, 0]) [0, 0, 1]","solution":"def add_lists(list1, list2): Returns the list of digits representing the sum of the integers represented by list1 and list2. list1 = list1[::-1] list2 = list2[::-1] result = [] carry = 0 for i in range(max(len(list1), len(list2))): digit1 = list1[i] if i < len(list1) else 0 digit2 = list2[i] if i < len(list2) else 0 total = digit1 + digit2 + carry carry = total // 10 result.append(total % 10) if carry != 0: result.append(carry) return result[::-1]"},{"question":"import numpy as np import pandas as pd import matplotlib.pyplot as plt def generate_dataframe_and_plot(): Import the numpy and pandas libraries in Python. Create a pandas dataframe with two columns: 'date' and 'count', where 'date' contains the dates from January 1st, 2023 to January 31st, 2023, and 'count' contains random integer values between 50 and 150. Generate a line plot using matplotlib.pyplot, with 'date' as the x-axis and 'count' as the y-axis. Set the title of the plot to 'Daily Counts for January 2023' and ensure the dates on the x-axis are formatted as 'YYYY-MM-DD'. >>> df = generate_dataframe_and_plot() >>> len(df) 31 >>> df['date'].iloc[0] Timestamp('2023-01-01 00:00:00') >>> df['date'].iloc[-1] Timestamp('2023-01-31 00:00:00') >>> df['count'].min() >= 50 and df['count'].max() <= 150 True","solution":"import numpy as np import pandas as pd import matplotlib.pyplot as plt def generate_dataframe_and_plot(): # Generate a date range from January 1st, 2023 to January 31st, 2023 date_range = pd.date_range(start='2023-01-01', end='2023-01-31') # Generate random integer values between 50 and 150 np.random.seed(0) # For reproducibility count_values = np.random.randint(50, 151, size=len(date_range)) # Create the dataframe df = pd.DataFrame({'date': date_range, 'count': count_values}) # Create the plot plt.figure(figsize=(10, 5)) plt.plot(df['date'], df['count'], marker='o') # Set the title and labels plt.title('Daily Counts for January 2023') plt.xlabel('Date') plt.ylabel('Count') # Format the x-axis dates plt.gca().xaxis.set_major_formatter(plt.FixedFormatter(date_range.strftime('%Y-%m-%d'))) plt.xticks(rotation=45, ha='right') # Display the plot plt.tight_layout() plt.show() return df"},{"question":"def is_anagram(str1: str, str2: str) -> bool: Check if str1 is an anagram of str2, ignoring spaces, punctuation, and capitalization. >>> is_anagram(\\"Listen\\", \\"Silent\\") == True >>> is_anagram(\\"A gentleman\\", \\"Elegant man\\") == True >>> is_anagram(\\"Clint Eastwood\\", \\"Old West Action.\\") == True >>> is_anagram(\\"Hello\\", \\"World\\") == False >>> is_anagram(\\"\\", \\"\\") == True >>> is_anagram(\\"!!!\\", \\" \\") == True >>> is_anagram(\\"Astronomer\\", \\"Moon starer\\") == True >>> is_anagram(\\"a\\", \\"A\\") == True >>> is_anagram(\\"a\\", \\"b\\") == False","solution":"def is_anagram(str1, str2): Check if str1 is an anagram of str2, ignoring spaces, punctuation, and capitalization. # Removing spaces, punctuation, and converting to lowercase filtered_str1 = ''.join(filter(str.isalpha, str1)).lower() filtered_str2 = ''.join(filter(str.isalpha, str2)).lower() # Sorting and comparing return sorted(filtered_str1) == sorted(filtered_str2)"},{"question":"def categorize_string(input_string: str) -> str: Analyze the frequencies of characters in a given string and classify it into three categories. Args: input_string (str): The input string containing lowercase, uppercase letters, digits, and special characters. Returns: str: The category the string belongs to: \\"Balanced\\", \\"Dominant\\", or \\"Unbalanced\\". Examples: >>> categorize_string(\\"aA1!aA1!a!\\") == \\"Balanced\\" >>> categorize_string(\\"aAaAaA111!!!\\") == \\"Balanced\\" >>> categorize_string(\\"aaaaAAA111!!!\\") == \\"Balanced\\" >>> categorize_string(\\"aaaaAAAaaa!!!\\") == \\"Dominant\\" >>> categorize_string(\\"1111111aaaa\\") == \\"Dominant\\" >>> categorize_string(\\"!!!!!aaA1\\") == \\"Dominant\\" >>> categorize_string(\\"aaaaAAA111!\\") == \\"Unbalanced\\" >>> categorize_string(\\"aaaAAA111!!!!!11\\") == \\"Unbalanced\\" >>> categorize_string(\\"aA1!!!\\") == \\"Unbalanced\\"","solution":"def categorize_string(input_string: str) -> str: num_lower = sum(1 for c in input_string if c.islower()) num_upper = sum(1 for c in input_string if c.isupper()) num_digits = sum(1 for c in input_string if c.isdigit()) num_specials = len(input_string) - num_lower - num_upper - num_digits total_chars = len(input_string) max_count = max(num_lower, num_upper, num_digits, num_specials) min_count = min(num_lower, num_upper, num_digits, num_specials) if max_count > total_chars / 2: return \\"Dominant\\" if max_count - min_count <= 1: return \\"Balanced\\" return \\"Unbalanced\\""},{"question":"import numpy as np import matplotlib.pyplot as plt # Parameters for the simulation mean_temperature = 20 std_deviation_temperature = 5 num_days = 30 def generate_temperatures(mean_temperature: int, std_deviation_temperature: int, num_days: int) -> np.ndarray: Generate a sequence of random daily temperatures for a month following a normal distribution. >>> len(generate_temperatures(20, 5, 30)) == 30 True def plot_temperatures(temperatures: np.ndarray, mean_temperature: int, std_deviation_temperature: int) -> None: Plot the daily temperatures and their 7-day rolling average. Parameters: temperatures (np.ndarray): Array of daily temperatures mean_temperature (int): Mean temperature for the normal distribution std_deviation_temperature (int): Standard deviation for the normal distribution Returns: None def calculate_rolling_average(temperatures: np.ndarray) -> np.ndarray: Calculate the 7-day rolling average for the provided temperatures. Parameters: temperatures (np.ndarray): Array of daily temperatures Returns: np.ndarray: Array of rolling average values # Using the functions # Generate random daily temperatures temperatures = generate_temperatures(mean_temperature, std_deviation_temperature, num_days) # Plot the temperatures and rolling average plot_temperatures(temperatures, mean_temperature, std_deviation_temperature)","solution":"import numpy as np import matplotlib.pyplot as plt # Generate random daily temperatures for a month mean_temperature = 20 std_deviation_temperature = 5 num_days = 30 temperatures = np.random.normal(mean_temperature, std_deviation_temperature, num_days) # Plot the temperatures as a time series plt.figure(figsize=(10, 5)) plt.plot(temperatures, label='Daily Temperatures') # Calculate and plot the rolling average (7-day window) rolling_avg = np.convolve(temperatures, np.ones(7)/7, mode='valid') plt.plot(range(6, num_days), rolling_avg, color='orange', label='7-Day Rolling Average') # Labels and title plt.xlabel('Day of the Month') plt.ylabel('Temperature (°C)') plt.title('Daily Temperatures and Rolling Average in a Month') plt.legend() plt.grid(True) # Display the plot plt.show() # Discussion on trends and patterns summary = The plot shows daily temperatures over a 30-day period that follow a normal distribution around 20°C with a 5°C standard deviation. There are noticeable fluctuations from day to day, as expected with random variations. The 7-day rolling average curve provides a smoother trend line, which helps in identifying the overall temperature trend. It appears that there are periods where the temperature tends to stay below or above the mean temperature of 20°C. No significant anomalies are observed, and the variations look naturally distributed. print(summary)"},{"question":"import pandas as pd import numpy as np import matplotlib.pyplot as plt import argparse def load_data(file_path): Load the dataset from the given CSV file. >>> data = load_data(\\"path/to/data.csv\\") >>> isinstance(data, pd.DataFrame) True pass def analyze_column(data, column_name): Compute and display statistics for a given numerical column, and plot a histogram. >>> data = load_data(\\"path/to/data.csv\\") >>> analyze_column(data, 'column_name') pass def main(): parser = argparse.ArgumentParser(description=\\"Analyze numerical column in a CSV file\\") parser.add_argument(\\"file_path\\", help=\\"Path to the CSV file\\") parser.add_argument(\\"column_name\\", help=\\"Name of the column to analyze\\") args = parser.parse_args() data = load_data(args.file_path) analyze_column(data, args.column_name) if __name__ == \\"__main__\\": main() import pytest import pandas as pd from io import StringIO def test_load_data_valid_file(): csv_data = \\"a,b,cn1,2,3n4,5,6\\" data = load_data(StringIO(csv_data)) assert not data.empty assert list(data.columns) == ['a', 'b', 'c'] def test_load_data_invalid_file(): with pytest.raises(ValueError): load_data(\\"invalid/path/to/data.csv\\") def test_analyze_column_nonexistent_column(): csv_data = \\"a,b,cn1,2,3n4,5,6\\" data = load_data(StringIO(csv_data)) with pytest.raises(ValueError): analyze_column(data, 'd') def test_analyze_column_non_numerical_column(): csv_data = \\"a,b,cn1,2,threen4,5,six\\" data = load_data(StringIO(csv_data)) with pytest.raises(ValueError): analyze_column(data, 'c') def test_analyze_column_numerical(): csv_data = \\"a,b,cn1,2,3n4,5,6n7,8,9\\" data = load_data(StringIO(csv_data)) analyze_column(data, 'b') if __name__ == \\"__main__\\": pytest.main()","solution":"import pandas as pd import numpy as np import matplotlib.pyplot as plt import argparse def load_data(file_path): Load the dataset from the given CSV file. try: data = pd.read_csv(file_path) return data except Exception as e: raise ValueError(f\\"Could not load data from {file_path}: {e}\\") def analyze_column(data, column_name): Compute and display statistics for a given numerical column, and plot a histogram. if column_name not in data.columns: raise ValueError(f\\"Column '{column_name}' does not exist in the dataset\\") # Handle missing data column_data = data[column_name].dropna() if not np.issubdtype(column_data.dtype, np.number): raise ValueError(f\\"Column '{column_name}' is not numerical\\") mean_value = column_data.mean() median_value = column_data.median() std_dev_value = column_data.std() print(f\\"Statistics for column '{column_name}':\\") print(f\\"Mean: {mean_value}\\") print(f\\"Median: {median_value}\\") print(f\\"Standard Deviation: {std_dev_value}\\") plt.hist(column_data, bins=30, edgecolor='k') plt.title(f'Histogram of {column_name}') plt.xlabel(column_name) plt.ylabel('Frequency') plt.show() def main(): parser = argparse.ArgumentParser(description=\\"Analyze numerical column in a CSV file\\") parser.add_argument(\\"file_path\\", help=\\"Path to the CSV file\\") parser.add_argument(\\"column_name\\", help=\\"Name of the column to analyze\\") args = parser.parse_args() data = load_data(args.file_path) analyze_column(data, args.column_name) if __name__ == \\"__main__\\": main()"},{"question":"from typing import List def extract_digits(strings: List[str]) -> List[int]: Extract all the digits from each string, concatenate them, and return a list of these concatenated digits as integers. Example: >>> extract_digits([\\"a1b2\\", \\"c3d4\\"]) [12, 34] >>> extract_digits([\\"a1\\", \\"b2\\", \\"c3\\"]) [1, 2, 3] >>> extract_digits([\\"a12b\\", \\"34cd\\"]) [12, 34] # Your code here # Test cases print(extract_digits([\\"a1b2\\", \\"c3d4\\"])) # Output: [12, 34] print(extract_digits([\\"a1\\", \\"b2\\", \\"c3\\"])) # Output: [1, 2, 3] print(extract_digits([\\"a12b\\", \\"34cd\\"])) # Output: [12, 34]","solution":"def extract_digits(strings): Function to extract all digits from each string in a list, concatenate them, and return a list of these concatenated digits as integers. :param strings: List of strings containing a combination of letters and digits. :return: List of integers where each integer is formed by concatenating the digits from corresponding string in input list. result = [] for s in strings: digits = ''.join(filter(str.isdigit, s)) result.append(int(digits)) return result"},{"question":"from typing import List def longest_consecutive_subsequence(nums: List[int]) -> List[int]: Given a list of integers, finds and returns the longest consecutive subsequence. The consecutive numbers can appear in any order in the list and the elements themselves must not be rearranged. >>> longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) [1, 2, 3, 4] >>> longest_consecutive_subsequence([]) [] >>> longest_consecutive_subsequence([10]) [10] >>> longest_consecutive_subsequence([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> longest_consecutive_subsequence([5, 6, 7, 8, 10, 11, 12]) [5, 6, 7, 8] >>> longest_consecutive_subsequence([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> longest_consecutive_subsequence([10, 1, 11, 2, 12, 3, 13, 4]) [10, 11, 12, 13] >>> longest_consecutive_subsequence([8, 1, 9, 4, 6, 0, 7, 2, 5, 3]) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]","solution":"def longest_consecutive_subsequence(nums): Finds the longest consecutive subsequence in the list 'nums'. if not nums: return [] num_set = set(nums) longest_streak = [] for num in nums: # Only start a new sequence if num-1 is not in set (indicating num is the start of a sequence) if num - 1 not in num_set: current_streak = [] current_num = num while current_num in num_set: current_streak.append(current_num) current_num += 1 if len(current_streak) > len(longest_streak): longest_streak = current_streak return longest_streak"},{"question":"def char_frequency(s: str) -> dict: Given a string, calculate the frequency of each character in the string and return a dictionary containing these frequencies. The function should ignore spaces and be case-insensitive. >>> char_frequency(\\"Hello World\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> char_frequency(\\"Hello, World!!!\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> char_frequency(\\"\\") {} >>> char_frequency(\\" \\") {} >>> char_frequency(\\"aA\\") {'a': 2} >>> char_frequency(\\"1234!@#\\") {}","solution":"def char_frequency(s): Return a dictionary containing the frequency of each character in the string, ignoring spaces and case-insensitive. freq_dict = {} for char in s.lower(): if char.isalpha(): if char in freq_dict: freq_dict[char] += 1 else: freq_dict[char] = 1 return freq_dict"},{"question":"import random class Minesweeper: def __init__(self, size, mines): Initialize the Minesweeper game with given grid size and number of mines. Args: size (int): The width and height of the square grid. mines (int): The total number of mines to be placed on the grid. def generate_mines(self): Randomly place mines on the grid. def compute_adjacency(self): Compute the number of adjacent mines for each cell. def reveal(self, row, col): Reveal the cell at (row, col). If the cell is a mine, game ends. Args: row (int): The row index of the cell. col (int): The column index of the cell. Returns: A string message indicating game status or None if the game continues. def flood_fill(self, row, col): Recursively reveal empty cells adjacent to the revealed cell. Args: row (int): The row index of the cell. col (int): The column index of the cell. def mark_mine(self, row, col): Mark or unmark a cell as a potential mine location. Args: row (int): The row index of the cell. col (int): The column index of the cell. def check_win(self): Check if all mines have been correctly marked. Returns: bool: True if all mines are marked, False otherwise. def display_grid(self): Display the current state of the game grid. Returns: A 2D list representing the game grid. # Unit tests def test_initial_grid(): size = 5 mines = 5 game = Minesweeper(size, mines) initial_grid = game.display_grid() for row in initial_grid: assert all(cell == '*' for cell in row) def test_reveal_mine(): size = 5 mines = 5 game = Minesweeper(size, mines) for (row, col) in game.mine_positions: assert game.reveal(row, col) == 'Game Over! You hit a mine.' def test_mark_mine(): game = Minesweeper(5, 5) mine_pos = next(iter(game.mine_positions)) game.mark_mine(mine_pos[0], mine_pos[1]) disp_grid = game.display_grid() assert disp_grid[mine_pos[0]][mine_pos[1]] == 'F' def test_mark_and_unmark_mine(): game = Minesweeper(5, 5) mine_pos = next(iter(game.mine_positions)) game.mark_mine(mine_pos[0], mine_pos[1]) disp_grid = game.display_grid() assert disp_grid[mine_pos[0]][mine_pos[1]] == 'F' game.mark_mine(mine_pos[0], mine_pos[1]) disp_grid = game.display_grid() assert disp_grid[mine_pos[0]][mine_pos[1]] == '*' def test_flood_fill_no_mines(): game = Minesweeper(5, 0) result = game.reveal(0, 0) assert result != 'Game Over! You hit a mine.' for row in game.revealed: assert all(row) for cell in row: assert cell is True def test_win_game(): size = 5 mines = 5 game = Minesweeper(size, mines) for (row, col) in game.mine_positions: game.mark_mine(row, col) assert game.check_win() is True def test_no_win_game(): size = 5 mines = 5 game = Minesweeper(size, mines) for (row, col) in game.mine_positions: game.mark_mine(row, col) break assert game.check_win() is False","solution":"import random class Minesweeper: def __init__(self, size, mines): self.size = size self.mines = mines self.grid = [[' ' for _ in range(size)] for _ in range(size)] self.revealed = [[False for _ in range(size)] for _ in range(size)] self.marked = [[False for _ in range(size)] for _ in range(size)] self.mine_positions = set() self.generate_mines() self.compute_adjacency() def generate_mines(self): while len(self.mine_positions) < self.mines: row = random.randint(0, self.size - 1) col = random.randint(0, self.size - 1) self.mine_positions.add((row, col)) self.grid[row][col] = 'M' def compute_adjacency(self): directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] for row in range(self.size): for col in range(self.size): if self.grid[row][col] != 'M': mine_count = 0 for d in directions: new_row, new_col = row + d[0], col + d[1] if 0 <= new_row < self.size and 0 <= new_col < self.size and self.grid[new_row][new_col] == 'M': mine_count += 1 self.grid[row][col] = str(mine_count) if mine_count > 0 else ' ' def reveal(self, row, col): if self.marked[row][col]: return if self.grid[row][col] == 'M': return 'Game Over! You hit a mine.' if self.revealed[row][col]: return self.revealed[row][col] = True self.flood_fill(row, col) if self.check_win(): return 'Congratulations! You win.' return self.display_grid() def flood_fill(self, row, col): if self.grid[row][col] != ' ': return directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] self.revealed[row][col] = True for d in directions: new_row, new_col = row + d[0], col + d[1] if 0 <= new_row < self.size and 0 <= new_col < self.size and not self.revealed[new_row][new_col]: self.reveal(new_row, new_col) def mark_mine(self, row, col): self.marked[row][col] = not self.marked[row][col] def check_win(self): for row, col in self.mine_positions: if not self.marked[row][col]: return False return True def display_grid(self): disp_grid = [[' ' for _ in range(self.size)] for _ in range(self.size)] for row in range(self.size): for col in range(self.size): if self.revealed[row][col]: disp_grid[row][col] = self.grid[row][col] elif self.marked[row][col]: disp_grid[row][col] = 'F' else: disp_grid[row][col] = '*' return disp_grid # Example usage # game = Minesweeper(5, 5) # print(game.display_grid()) # print(game.reveal(0, 0)) # game.mark_mine(1, 1) # print(game.reveal(2, 2))"},{"question":"def sorted_squares(nums: List[int]) -> List[int]: Given an array of integers sorted in non-decreasing order, returns an array of the squares of each number, also sorted in non-decreasing order. >>> sorted_squares([-4, -1, 0, 3, 10]) [0, 1, 9, 16, 100] >>> sorted_squares([1, 2, 3, 4, 5]) [1, 4, 9, 16, 25] >>> sorted_squares([-5, -4, -3, -2, -1]) [1, 4, 9, 16, 25]","solution":"def sorted_squares(nums): Given an array of integers sorted in non-decreasing order, returns an array of the squares of each number, also sorted in non-decreasing order. n = len(nums) result = [0] * n left, right = 0, n - 1 index = n - 1 while left <= right: if abs(nums[left]) > abs(nums[right]): result[index] = nums[left] ** 2 left += 1 else: result[index] = nums[right] ** 2 right -= 1 index -= 1 return result"},{"question":"def calculate_final_grades(students: list) -> dict: Processes a list of course records and returns a summary of student final grades. Arguments: students -- List of dictionaries containing student information and their assignments. Returns: Dictionary with student IDs as keys and their final percentage as values. # Write your code here pass # Unit Tests def test_calculate_final_grades_all_assignments(): students = [ { \\"name\\": \\"Alice\\", \\"student_id\\": \\"S001\\", \\"assignments\\": [ {\\"name\\": \\"Assignment 1\\", \\"max_score\\": 100, \\"score\\": 90}, {\\"name\\": \\"Assignment 2\\", \\"max_score\\": 100, \\"score\\": 85} ] }, { \\"name\\": \\"Bob\\", \\"student_id\\": \\"S002\\", \\"assignments\\": [ {\\"name\\": \\"Assignment 1\\", \\"max_score\\": 100, \\"score\\": 80} ] }, { \\"name\\": \\"Charlie\\", \\"student_id\\": \\"S003\\", \\"assignments\\": [] } ] expected = { \\"S001\\": 87.5, \\"S002\\": 80.0, \\"S003\\": 0.0 } assert calculate_final_grades(students) == expected def test_calculate_final_grades_missing_scores(): students = [ { \\"name\\": \\"Dave\\", \\"student_id\\": \\"S004\\", \\"assignments\\": [ {\\"name\\": \\"Assignment 1\\", \\"max_score\\": 100, \\"score\\": 0}, {\\"name\\": \\"Assignment 2\\", \\"max_score\\": 100, \\"score\\": 0} ] } ] expected = { \\"S004\\": 0.0 } assert calculate_final_grades(students) == expected def test_calculate_final_grades_partial_scores(): students = [ { \\"name\\": \\"Eve\\", \\"student_id\\": \\"S005\\", \\"assignments\\": [ {\\"name\\": \\"Assignment 1\\", \\"max_score\\": 100, \\"score\\": 50}, {\\"name\\": \\"Assignment 2\\", \\"max_score\\": 200, \\"score\\": 100} ] } ] expected = { \\"S005\\": 50.0 } assert calculate_final_grades(students) == expected def test_calculate_final_grades_zero_max_score(): students = [ { \\"name\\": \\"Frank\\", \\"student_id\\": \\"S006\\", \\"assignments\\": [ {\\"name\\": \\"Assignment 1\\", \\"max_score\\": 0, \\"score\\": 0} ] } ] expected = { \\"S006\\": 0.0 } assert calculate_final_grades(students) == expected def test_calculate_final_grades_mix(): students = [ { \\"name\\": \\"Grace\\", \\"student_id\\": \\"S007\\", \\"assignments\\": [ {\\"name\\": \\"Assignment 1\\", \\"max_score\\": 100, \\"score\\": 90}, {\\"name\\": \\"Assignment 2\\", \\"max_score\\": 100, \\"score\\": 85}, {\\"name\\": \\"Assignment 3\\", \\"max_score\\": 200, \\"score\\": 150}, {\\"name\\": \\"Assignment 4\\", \\"max_score\\": 0, \\"score\\": 0}, ] } ] expected = { \\"S007\\": 81.25 } assert calculate_final_grades(students) == expected","solution":"def calculate_final_grades(students): Processes a list of course records and returns a summary of student final grades. Arguments: students -- List of dictionaries containing student information and their assignments. Returns: Dictionary with student IDs as keys and their final percentage as values. final_grades = {} for student in students: student_id = student['student_id'] assignments = student['assignments'] if not assignments: # Case where student has no assignments final_grades[student_id] = 0.0 continue total_score = 0 total_max_score = 0 for assignment in assignments: total_score += assignment.get('score', 0) total_max_score += assignment.get('max_score', 0) if total_max_score == 0: final_percentage = 0.0 else: final_percentage = (total_score / total_max_score) * 100 final_grades[student_id] = round(final_percentage, 2) return final_grades"},{"question":"def update_reviews(reviews, new_review): Updates the reviews dataset with the new review. If a review by the same user for the same product already exists, updates the rating and comment of that existing review. If no such review exists, adds the new review to the dataset. Returns the updated dataset. :param reviews: List of dictionaries, each representing an existing review. :param new_review: Dictionary representing the new review to be added or updated. :return: The updated reviews list. >>> reviews = [ ... {\\"username\\": \\"user1\\", \\"product_id\\": 101, \\"rating\\": 4, \\"comment\\": \\"Good quality\\"}, ... {\\"username\\": \\"user2\\", \\"product_id\\": 101, \\"rating\\": 3, \\"comment\\": \\"Satisfactory\\"}, ... {\\"username\\": \\"user1\\", \\"product_id\\": 102, \\"rating\\": 5, \\"comment\\": \\"Excellent!\\"} ... ] >>> new_review = {\\"username\\": \\"user1\\", \\"product_id\\": 101, \\"rating\\": 5, \\"comment\\": \\"Great product\\"} >>> update_reviews(reviews, new_review) [ {\\"username\\": \\"user1\\", \\"product_id\\": 101, \\"rating\\": 5, \\"comment\\": \\"Great product\\"}, {\\"username\\": \\"user2\\", \\"product_id\\": 101, \\"rating\\": 3, \\"comment\\": \\"Satisfactory\\"}, {\\"username\\": \\"user1\\", \\"product_id\\": 102, \\"rating\\": 5, \\"comment\\": \\"Excellent!\\"} ] # Your code here return reviews # Example usage reviews = [ {\\"username\\": \\"user1\\", \\"product_id\\": 101, \\"rating\\": 4, \\"comment\\": \\"Good quality\\"}, {\\"username\\": \\"user2\\", \\"product_id\\": 101, \\"rating\\": 3, \\"comment\\": \\"Satisfactory\\"}, {\\"username\\": \\"user1\\", \\"product_id\\": 102, \\"rating\\": 5, \\"comment\\": \\"Excellent!\\"} ] new_review = {\\"username\\": \\"user1\\", \\"product_id\\": 101, \\"rating\\": 5, \\"comment\\": \\"Great product\\"} print(update_reviews(reviews, new_review))","solution":"def update_reviews(reviews, new_review): Updates the reviews dataset with the new review. :param reviews: List of dictionaries, each representing an existing review. :param new_review: Dictionary representing the new review to be added or updated. :return: The updated reviews list. for review in reviews: if review['username'] == new_review['username'] and review['product_id'] == new_review['product_id']: review['rating'] = new_review['rating'] if 'comment' in new_review: review['comment'] = new_review['comment'] return reviews # If no existing review found for the same user and product, append the new review reviews.append(new_review) return reviews"},{"question":"from typing import List def is_permutation_of_palindrome(s: str) -> bool: Check if permutations of a string can form a palindrome considering constraints. Constraints: 1 <= length of string <= 10^5, only lowercase letters and spaces are allowed >>> is_permutation_of_palindrome(\\"taco cat\\") True >>> is_permutation_of_palindrome(\\"atco cta\\") True >>> is_permutation_of_palindrome(\\"abc\\") False >>> is_permutation_of_palindrome(\\"aabb\\") True >>> is_permutation_of_palindrome(\\"aabbcc\\") True pass def test_is_permutation_of_palindrome_with_palindromic_permutation(): assert is_permutation_of_palindrome(\\"taco cat\\") == True assert is_permutation_of_palindrome(\\"atco cta\\") == True def test_is_permutation_of_palindrome_with_non_palindromic_permutation(): assert is_permutation_of_palindrome(\\"abc\\") == False def test_is_permutation_of_palindrome_with_even_characters(): assert is_permutation_of_palindrome(\\"aabb\\") == True def test_is_permutation_of_palindrome_with_multiple_odd_characters(): assert is_permutation_of_palindrome(\\"aabbcc\\") == True def test_is_permutation_of_palindrome_with_spaces_and_same_characters(): assert is_permutation_of_palindrome(\\"abcc ba\\") == True def test_is_permutation_of_palindrome_with_single_character(): assert is_permutation_of_palindrome(\\"a\\") == True assert is_permutation_of_palindrome(\\" \\") == True def test_is_permutation_of_palindrome_with_mixed_case_letters(): assert is_permutation_of_palindrome(\\"Taco Cat\\") == True assert is_permutation_of_palindrome(\\"Atco Cta\\") == True def test_is_permutation_of_palindrome_with_empty_string(): assert is_permutation_of_palindrome(\\"\\") == True","solution":"def is_permutation_of_palindrome(s: str) -> bool: Check if permutations of a string can form a palindrome considering constraints. Constraints: 1 <= length of string <= 10^5, only lowercase letters and spaces are allowed >>> is_permutation_of_palindrome(\\"taco cat\\") True >>> is_permutation_of_palindrome(\\"atco cta\\") True >>> is_permutation_of_palindrome(\\"abc\\") False >>> is_permutation_of_palindrome(\\"aabb\\") True >>> is_permutation_of_palindrome(\\"aabbcc\\") True from collections import Counter # Remove spaces and convert to lowercase cleaned_string = s.replace(\\" \\", \\"\\").lower() # Count character frequencies char_counter = Counter(cleaned_string) # Check number of characters with odd counts odd_count = sum(1 for count in char_counter.values() if count % 2 == 1) # For the string to be a permutation of a palindrome, it can have at most one character with an odd frequency return odd_count <= 1"},{"question":"def find_substring_indices(text: str, pattern: str) -> list: Write a Python function named \`find_substring_indices\` that takes two string arguments \`text\` and \`pattern\`, and returns a list of starting indices where the \`pattern\` is found within the \`text\`. If the pattern is not found, return an empty list. Your implementation should be case-sensitive. >>> find_substring_indices(\\"abracadabra\\", \\"abr\\") [0, 7] >>> find_substring_indices(\\"hello world\\", \\"o\\") [4, 7] >>> find_substring_indices(\\"abcdefgh\\", \\"xyz\\") []","solution":"def find_substring_indices(text, pattern): Returns a list of starting indices where the pattern is found within the text. Parameters: text (str): The string to search within. pattern (str): The substring to search for. Returns: list: A list of starting indices where the pattern is found in the text. indices = [] pattern_length = len(pattern) for i in range(len(text) - pattern_length + 1): if text[i:i+pattern_length] == pattern: indices.append(i) return indices"},{"question":"from typing import List def longest_consecutive_subsequence(arr: List[int]) -> List[int]: Finds the longest subsequence of consecutive integers in an unsorted array. Args: arr: List[int] - The input array of integers Returns: List[int] - The longest subsequence of consecutive integers Examples: >>> longest_consecutive_subsequence([4, 2, 1, 6, 5]) [4, 5, 6] >>> longest_consecutive_subsequence([]) [] >>> longest_consecutive_subsequence([1]) [1] >>> longest_consecutive_subsequence([10, 30, 20, 40]) [10] or [30] or [20] or [40] >>> longest_consecutive_subsequence([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> longest_consecutive_subsequence([3, 7, 2, 1, 9, 8, 6, 10]) [6, 7, 8, 9, 10]","solution":"def longest_consecutive_subsequence(arr): Finds the longest subsequence of consecutive integers in an unsorted array. Args: arr: List[int] - The input array of integers Returns: List[int] - The longest subsequence of consecutive integers if not arr: return [] arr = list(set(arr)) arr.sort() longest = [] current = [arr[0]] for i in range(1, len(arr)): if arr[i] == arr[i-1] + 1: current.append(arr[i]) else: if len(current) > len(longest): longest = current current = [arr[i]] if len(current) > len(longest): longest = current return longest"},{"question":"def is_sum_of_digits_divisible_by_4(s: str) -> bool: Check if the sum of the digits in the input string s is divisible by 4 Args: s (str): Input string consisting of digits Returns: bool: True if the sum of digits is divisible by 4, False otherwise Examples: >>> is_sum_of_digits_divisible_by_4(\\"1232\\") True >>> is_sum_of_digits_divisible_by_4(\\"0004\\") True >>> is_sum_of_digits_divisible_by_4(\\"1235\\") False >>> is_sum_of_digits_divisible_by_4(\\"0000\\") True >>> is_sum_of_digits_divisible_by_4(\\"1234567890\\") False >>> is_sum_of_digits_divisible_by_4(\\"4\\") True >>> is_sum_of_digits_divisible_by_4(\\"2\\") False >>> is_sum_of_digits_divisible_by_4(\\"0\\") True","solution":"def is_sum_of_digits_divisible_by_4(s): Check if the sum of the digits in the input string s is divisible by 4 Args: s (str): Input string consisting of digits Returns: bool: True if the sum of digits is divisible by 4, False otherwise # Calculate sum of digits sum_of_digits = sum(int(char) for char in s) # Check if the sum is divisible by 4 return sum_of_digits % 4 == 0"},{"question":"def prime_numbers_up_to_n(n: int) -> List[int]: Optimize the function to improve both its efficiency and readability. This function takes an integer n as input and returns a list of all prime numbers less than or equal to n. >>> prime_numbers_up_to_n(10) [2, 3, 5, 7] >>> prime_numbers_up_to_n(20) [2, 3, 5, 7, 11, 13, 17, 19] from solution import prime_numbers_up_to_n def test_prime_numbers_up_to_10(): assert prime_numbers_up_to_n(10) == [2, 3, 5, 7] def test_prime_numbers_up_to_20(): assert prime_numbers_up_to_n(20) == [2, 3, 5, 7, 11, 13, 17, 19] def test_prime_numbers_up_to_1(): assert prime_numbers_up_to_n(1) == [] def test_prime_numbers_up_to_0(): assert prime_numbers_up_to_n(0) == [] def test_prime_numbers_up_to_2(): assert prime_numbers_up_to_n(2) == [2] def test_prime_numbers_up_to_100(): assert prime_numbers_up_to_n(100) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]","solution":"def prime_numbers_up_to_n(n): This function takes an integer n as input and returns a list of all prime numbers less than or equal to n using the Sieve of Eratosthenes algorithm. >>> prime_numbers_up_to_n(10) [2, 3, 5, 7] >>> prime_numbers_up_to_n(20) [2, 3, 5, 7, 11, 13, 17, 19] if n < 2: return [] sieve = [True] * (n + 1) sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n + 1, start): sieve[multiple] = False return [num for num in range(2, n + 1) if sieve[num]]"},{"question":"def second_smallest(input_list: List[int]) -> int: Returns the second smallest distinct number in the list. If fewer than two distinct elements are present, returns an error message. >>> second_smallest([4, 2, 2, 8, 7, 6]) == 4 >>> second_smallest([4, 4, 4, 8, 1, 1]) == 4 >>> second_smallest([1, 2]) == 2 >>> second_smallest([-5, -3, -1, -4, -6]) == -5 >>> second_smallest([5]) == \\"Error: List must contain at least two distinct elements\\" >>> second_smallest([7, 7, 7, 7]) == \\"Error: List must contain at least two distinct elements\\"","solution":"def second_smallest(input_list): Returns the second smallest distinct number in the list. If fewer than two distinct elements are present, returns an error message. distinct_elements = list(set(input_list)) if len(distinct_elements) < 2: return \\"Error: List must contain at least two distinct elements\\" distinct_elements.sort() return distinct_elements[1]"},{"question":"def calculate_total_cost(items): Calculate the total cost of all items in the dictionary, multiplying price and quantity. Args: items (dict): A dictionary where keys are item names and values are tuples (price, quantity). Returns: float: Total cost of all items. >>> calculate_total_cost({ \\"apple\\": (1.0, 10), \\"banana\\": (0.5, 20), \\"cherry\\": (2.0, 5) }) == 35.0 >>> calculate_total_cost({ \\"apple\\": (1.0, 10), \\"banana\\": (\\"0.5\\", 20), \\"cherry\\": (2.0, \\"5\\") }) == 10.0 >>> calculate_total_cost({ \\"apple\\": (\\"one\\", 10), \\"banana\\": (0.5, \\"twenty\\"), \\"cherry\\": (\\"two\\", \\"five\\") }) == 0.0 >>> calculate_total_cost({}) == 0.0","solution":"def calculate_total_cost(items): Calculate the total cost of all items in the dictionary, multiplying price and quantity. Args: items (dict): A dictionary where keys are item names and values are tuples (price, quantity). Returns: float: Total cost of all items. total_cost = 0.0 for name, (price, quantity) in items.items(): if isinstance(price, (int, float)) and isinstance(quantity, (int, float)): total_cost += price * quantity return total_cost"},{"question":"import xml.etree.ElementTree as ET import json import logging import time def parse_and_process_xml(xml_file, output_json_file, datatype, attribute): Parses an XML file, extracts data based on the provided datatype and attribute criteria, processes the data, and saves it to a JSON file. Additionally, logs processing time and errors encountered. logging.basicConfig(filename='xml_processing.log', level=logging.INFO) start_time = time.time() # XML parsing and exception handling needed # Processing and extracting data based on datatype and attribute # Saving data to JSON file with proper formatting and encoding # Logging the processing time and any errors encountered during execution end_time = time.time() logging.info(f\\"Processing completed in {end_time - start_time} seconds\\") return extracted_data # Unit tests import os import pytest def test_parse_and_process_valid_xml(): xml_content = '''<?xml version=\\"1.0\\"?> <root xmlns=\\"http://example.com\\"> <datatype attribute=\\"value1\\"/> <datatype attribute=\\"value2\\"/> </root>''' with open('test.xml', 'w') as file: file.write(xml_content) expected_output = ['value1', 'value2'] output = parse_and_process_xml('test.xml', 'output.json', 'datatype', 'attribute') assert output == expected_output assert os.path.exists('output.json') os.remove('test.xml') os.remove('output.json') def test_parse_and_process_invalid_xml(): xml_content = '''<root xmlns=\\"http://example.com\\"> <datatype attribute=\\"value1\\" </root>''' with open('test.xml', 'w') as file: file.write(xml_content) output = parse_and_process_xml('test.xml', 'output.json', 'datatype', 'attribute') assert output == None assert not os.path.exists('output.json') os.remove('test.xml') def test_parse_and_process_missing_file(): output = parse_and_process_xml('missing.xml', 'output.json', 'datatype', 'attribute') assert output == None assert not os.path.exists('output.json') def test_parse_and_process_with_no_matching_attribute(): xml_content = '''<?xml version=\\"1.0\\"?> <root xmlns=\\"http://example.com\\"> <datatype other_attribute=\\"value1\\"/> </root>''' with open('test.xml', 'w') as file: file.write(xml_content) expected_output = [] output = parse_and_process_xml('test.xml', 'output.json', 'datatype', 'attribute') assert output == expected_output assert os.path.exists('output.json') with open('output.json', 'r') as file: json_data = json.load(file) assert json_data == expected_output os.remove('test.xml') os.remove('output.json')","solution":"import xml.etree.ElementTree as ET import json import logging import time def parse_and_process_xml(xml_file, output_json_file, datatype, attribute): Parses an XML file, extracts data based on the provided datatype and attribute criteria, processes the data, and saves it to a JSON file. logging.basicConfig(filename='xml_processing.log', level=logging.INFO) start_time = time.time() try: tree = ET.parse(xml_file) root = tree.getroot() except ET.ParseError as e: logging.error(f\\"XML parsing error: {e}\\") return except FileNotFoundError: logging.error(f\\"XML file {xml_file} not found\\") return except Exception as e: logging.error(f\\"Unexpected error: {e}\\") return namespace = {'ns': root.tag.split('}')[0].strip('{')} extracted_data = [] try: for elem in root.findall(f\\".//ns:{datatype}\\", namespaces=namespace): if attribute in elem.attrib: extracted_data.append(elem.attrib[attribute]) with open(output_json_file, 'w', encoding='utf-8') as json_file: json.dump(extracted_data, json_file, ensure_ascii=False, indent=4) except Exception as e: logging.error(f\\"Error during processing: {e}\\") end_time = time.time() logging.info(f\\"Processing completed in {end_time - start_time} seconds\\") return extracted_data"},{"question":"def filter_and_sort_strings(str_list: List[str], n: int) -> List[str]: Filters and sorts a list of strings based on the length condition and sorts them in descending order by length. Parameters: str_list (list): List of strings to be filtered and sorted. n (int): Minimum length of the strings to be included in the returned list. Returns: list: A new list containing strings with at least n characters, sorted by length in descending order. Raises: ValueError: If n is not a positive integer. TypeError: If str_list contains non-string elements. Examples: >>> filter_and_sort_strings([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"], 6) ['banana', 'cherry'] >>> filter_and_sort_strings([\\"hi\\", \\"hello\\", \\"yes\\", 12345], 2) TypeError: str_list must contain only strings >>> filter_and_sort_strings([\\"one\\", \\"two\\", \\"three\\", \\"four\\"], -1) ValueError: n must be a positive integer >>> filter_and_sort_strings([\\"abc\\", \\"de\\", \\"fghi\\"], 5) [''] >>> filter_and_sort_strings([], 3) [''] >>> filter_and_sort_strings([\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\"], 1) [\\"abcd\\", \\"abc\\", \\"ab\\", \\"a\\"] >>> filter_and_sort_strings([\\"ab\\", \\"bc\\", \\"cd\\", \\"de\\"], 2) [\\"ab\\", \\"bc\\", \\"cd\\", \\"de\\"] >>> filter_and_sort_strings([\\"apple\\"], \\"three\\") ValueError: n must be a positive integer","solution":"def filter_and_sort_strings(str_list, n): Filters and sorts a list of strings based on the length condition and sorts them in descending order by length. Parameters: str_list (list): List of strings to be filtered and sorted. n (int): Minimum length of the strings to be included in the returned list. Returns: list: A new list containing strings with at least n characters, sorted by length in descending order. # Check for input errors if not isinstance(n, int) or n <= 0: raise ValueError(\\"n must be a positive integer\\") for item in str_list: if not isinstance(item, str): raise TypeError(\\"str_list must contain only strings\\") # Filter strings of at least length n filtered_list = [s for s in str_list if len(s) >= n] # Return list with single empty string if filtered list is empty if len(filtered_list) == 0: return [\\"\\"] # Sort strings by length in descending order filtered_list.sort(key=lambda x: len(x), reverse=True) return filtered_list"},{"question":"def matrix_diagonal_difference(matrix): Returns the absolute difference between the sums of the primary and secondary diagonals of a square matrix. :param matrix: List of lists containing integers, representing a square matrix. :return: Absolute difference between the sums of the primary and secondary diagonals. >>> matrix_diagonal_difference([[1, 2], [3, 4]]) == 0 >>> matrix_diagonal_difference([[11, 2, 4], [4, 5, 6], [10, 8, -12]]) == 15 >>> matrix_diagonal_difference([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) == 0 >>> matrix_diagonal_difference([[5]]) == 0 >>> with pytest.raises(ValueError): matrix_diagonal_difference([[1, 2, 3], [4, 5, 6]]) >>> with pytest.raises(ValueError): matrix_diagonal_difference([]) >>> with pytest.raises(ValueError): matrix_diagonal_difference([[1, 2], [3, 4, 5]])","solution":"def matrix_diagonal_difference(matrix): Returns the absolute difference between the sums of the primary and secondary diagonals of a square matrix. :param matrix: List of lists containing integers, representing a square matrix. :return: Absolute difference between the sums of the primary and secondary diagonals. if not matrix or not all(len(row) == len(matrix) for row in matrix): raise ValueError(\\"The input must be a square matrix.\\") n = len(matrix) primary_diagonal_sum = sum(matrix[i][i] for i in range(n)) secondary_diagonal_sum = sum(matrix[i][n-1-i] for i in range(n)) return abs(primary_diagonal_sum - secondary_diagonal_sum)"},{"question":"import csv import pandas as pd from statistics import mean def parse_csv(file_path): Reads a CSV file, processes the products and their prices, and returns a dictionary of products with prices, the top 5 expensive products, the average price, and the products with price above the average price. >>> parse_csv(\\"example.csv\\") # Assuming example.csv exists with appropriate data { 'products': {'Product1': 10.0, 'Product2': 20.0, 'Product3': 30.0}, 'top_5_expensive': [('Product3', 30.0), ('Product2', 20.0), ('Product1', 10.0)], 'average_price': 20.0, 'above_average_price': ['Product3'] } # Your code goes here","solution":"import csv import pandas as pd from statistics import mean def parse_csv(file_path): Reads a CSV file, processes the products and their prices, and returns a dictionary of products with prices, the top 5 expensive products, the average price, and the products with price above the average price. products = {} try: # Using pandas to read the CSV file df = pd.read_csv(file_path) # Check if needed columns are present if 'product' not in df.columns or 'price' not in df.columns: raise ValueError(\\"CSV file must contain 'product' and 'price' columns\\") # Storing products and their prices in a dictionary for _, row in df.iterrows(): product = row['product'] price = row['price'] if pd.isna(price) or price < 0: continue # Skip invalid prices products[product] = price # Calculate the top 5 most expensive products top_5_expensive = sorted(products.items(), key=lambda item: item[1], reverse=True)[:5] # Calculate the average price average_price = mean(products.values()) # Identify products priced above the average above_average_price = [product for product, price in products.items() if price > average_price] except FileNotFoundError: return \\"CSV file not found.\\" return { 'products': products, 'top_5_expensive': top_5_expensive, 'average_price': average_price, 'above_average_price': above_average_price }"},{"question":"def is_magic_square(matrix: List[List[int]]) -> bool: Check if a given two-dimensional square matrix is a Magic Square. A Magic Square is one where the sum of every row, column, and both main diagonals are the same. >>> is_magic_square([[2, 7, 6],[9, 5, 1],[4, 3, 8]]) True >>> is_magic_square([[2, 7, 6],[9, 5, 1],[4, 3, 9]]) False >>> is_magic_square([[2, 7, 12],[9, 5, 1],[4, 3, 8]]) False >>> is_magic_square([[2, 7, 6],[9, 4, 1],[4, 3, 8]]) False >>> is_magic_square([[1]]) True >>> is_magic_square([]) False","solution":"def is_magic_square(matrix): Check if a given two-dimensional square matrix is a Magic Square. A Magic Square is one where the sum of every row, column, and both main diagonals are the same. n = len(matrix) if n == 0: # Empty matrix is not considered a magic square return False sum_diag1 = sum(matrix[i][i] for i in range(n)) sum_diag2 = sum(matrix[i][n - 1 - i] for i in range(n)) # If diagonals do not match, it's not a magic square if sum_diag1 != sum_diag2: return False # Set the target sum to be the diagonal sum target_sum = sum_diag1 for i in range(n): # Check sum of each row if sum(matrix[i]) != target_sum: return False # Check sum of each column if sum(matrix[j][i] for j in range(n)) != target_sum: return False return True"},{"question":"def letter_combinations(digits: str) -> List[str]: Given a mapping of digit to letters (just like on a telephone buttons) and a digit string, return all possible letter combinations that the number could represent. Your function should utilize backtracking to explore all possibilities. The mapping is given below: 2: abc 3: def 4: ghi 5: jkl 6: mno 7: pqrs 8: tuv 9: wxyz The digits 0 and 1 do not map to any letters. The input string will only contain digits from 2 to 9. The length of the input string is at most 4. >>> letter_combinations(\\"23\\") [\\"ad\\",\\"ae\\",\\"af\\",\\"bd\\",\\"be\\",\\"bf\\",\\"cd\\",\\"ce\\",\\"cf\\"] >>> letter_combinations(\\"\\") [] >>> letter_combinations(\\"2\\") [\\"a\\", \\"b\\", \\"c\\"] >>> letter_combinations(\\"79\\") [\\"pw\\",\\"px\\",\\"py\\",\\"pz\\",\\"qw\\",\\"qx\\",\\"qy\\",\\"qz\\",\\"rw\\",\\"rx\\",\\"ry\\",\\"rz\\",\\"sw\\",\\"sx\\",\\"sy\\",\\"sz\\"] >>> letter_combinations(\\"234\\") ['adg', 'adh', 'adi', 'aeg', 'aeh', 'aei', 'afg', 'afh', 'afi', 'bdg', 'bdh', 'bdi', 'beg', 'beh', 'bei', 'bfg', 'bfh', 'bfi', 'cdg', 'cdh', 'cdi', 'ceg', 'ceh', 'cei', 'cfg', 'cfh', 'cfi'] >>> letter_combinations(\\"2345\\") ['adgj', 'adgk', 'adgl', 'adhj', 'adhk', 'adhl', 'adij', 'adik', 'adil', 'aegj', 'aegk', 'aegl', 'aehj', 'aehk', 'aehl', 'aeij', 'aeik', 'aeil', 'afgj', 'afgk', 'afgl', 'afhj', 'afhk', 'afhl', 'afij', 'afik', 'afil', 'bdgj', 'bdgk', 'bdgl', 'bdhj', 'bdhk', 'bdhl', 'bdij', 'bdik', 'bdil', 'begj', 'begk', 'begl', 'behj', 'behk', 'behl', 'beij', 'beik', 'beil', 'bfgj', 'bfgk', 'bfgl', 'bfhj', 'bfhk', 'bfhl', 'bfij', 'bfik', 'bfil', 'cdgj', 'cdgk', 'cdgl', 'cdhj', 'cdhk', 'cdhl', 'cdij', 'cdik', 'cdil', 'cegj', 'cegk', 'cegl', 'cehj', 'cehk', 'cehl', 'ceij', 'ceik', 'ceil', 'cfgj', 'cfgk', 'cfgl', 'cfhj', 'cfhk', 'cfhl', 'cfij', 'cfik', 'cfil']","solution":"def letter_combinations(digits): Given a digit string, return all possible letter combinations that the number could represent. if not digits: return [] digit_to_char = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' } def backtrack(index, path): if index == len(digits): combinations.append(''.join(path)) return possible_letters = digit_to_char[digits[index]] for letter in possible_letters: path.append(letter) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return sorted(combinations)"},{"question":"from typing import List def find_duplicates(original_list: List[int]) -> List[int]: Returns a list of elements that appear more than once in the original_list. >>> find_duplicates([1, 2, 3, 4, 5, 1, 2, 6, 7, 8, 6]) == [1, 2, 6] >>> find_duplicates([1, 2, 3, 4, 5]) == [] >>> find_duplicates([2, 2, 2, 2, 2]) == [2] >>> find_duplicates([7, 3, 9, 3, 7, 9, 7]) == [7, 3, 9] >>> find_duplicates([]) == [] >>> find_duplicates([1]) == [] >>> find_duplicates([1, 1]) == [1] # Erroneous code duplicates = [] for i in range(len(original_list)): for j in range(i + 1, len(original_list)): if original_list[i] == original_list[j] and original_list[i] not in duplicates: duplicates.append(original_list[i]) return duplicates","solution":"def find_duplicates(original_list): Returns a list of elements that appear more than once in the original_list. count_dict = {} duplicates = [] # Count the occurrences of each element for element in original_list: if element in count_dict: count_dict[element] += 1 else: count_dict[element] = 1 # Add elements to duplicates list that appear more than once for key, value in count_dict.items(): if value > 1: duplicates.append(key) return duplicates"},{"question":"def longest_increasing_subsequence(sequence): Calculate the longest increasing subsequence (LIS) from a given list of integers. Args: sequence (List[int]): The input list of integers. Returns: int: The length of the longest increasing subsequence. Raises: ValueError: If input is not a list of integers. Examples: >>> longest_increasing_subsequence([]) 0 >>> longest_increasing_subsequence([10]) 1 >>> longest_increasing_subsequence([5, 5, 5, 5]) 1 >>> longest_increasing_subsequence([-1, -2, -3, -4, -5]) 1 >>> longest_increasing_subsequence([-5, -4, -3, -2, -1]) 5 >>> longest_increasing_subsequence([3, 10, 2, 1, 20]) 3 >>> longest_increasing_subsequence([50, 3, 10, 7, 40, 80]) 4 >>> longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) 6 >>> longest_increasing_subsequence(\\"not a list\\") \\"Input should be a list of integers\\" >>> longest_increasing_subsequence(123) \\"Input should be a list of integers\\" >>> longest_increasing_subsequence([10, '20', 30]) \\"Input should be a list of integers\\"","solution":"def longest_increasing_subsequence(sequence): if not isinstance(sequence, list) or not all(isinstance(i, int) for i in sequence): return \\"Input should be a list of integers\\" if not sequence: return 0 lis = [1] * len(sequence) for i in range(1, len(sequence)): for j in range(i): if sequence[i] > sequence[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return max(lis)"},{"question":"from typing import List def remove_duplicates_and_sort(nums: List[int]) -> List[int]: Removes duplicate elements from the list and returns the remaining elements sorted in ascending order. Args: nums (List[int]): A list of integers that may contain duplicates. Returns: List[int]: A new list with duplicates removed and elements sorted in ascending order. Examples: >>> remove_duplicates_and_sort([4, 2, 5, 2, 3, 4]) [2, 3, 4, 5] >>> remove_duplicates_and_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates_and_sort([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates_and_sort([4, -2, 5, -2, 3, 4]) [-2, 3, 4, 5] >>> remove_duplicates_and_sort([]) [] >>> remove_duplicates_and_sort([1]) [1]","solution":"from typing import List def remove_duplicates_and_sort(nums: List[int]) -> List[int]: Removes duplicate elements from the list and returns the remaining elements sorted in ascending order. Args: nums (List[int]): A list of integers that may contain duplicates. Returns: List[int]: A new list with duplicates removed and elements sorted in ascending order. return sorted(set(nums))"},{"question":"def find_substring_indices(main_string: str, substring: str) -> List[int]: Returns a list of starting indices where the substring is found within the main string. >>> find_substring_indices(\\"hello world\\", \\"world\\") == [6] >>> find_substring_indices(\\"hello world\\", \\"hello\\") == [0] >>> find_substring_indices(\\"banana\\", \\"ana\\") == [1, 3] >>> find_substring_indices(\\"hi\\", \\"hello\\") == [] >>> find_substring_indices(\\"hello\\", \\"\\") == [0, 1, 2, 3, 4, 5] >>> find_substring_indices(\\"\\", \\"hello\\") == [] >>> find_substring_indices(\\"\\", \\"\\") == [0] >>> find_substring_indices(\\"abcdefg\\", \\"hi\\") == []","solution":"def find_substring_indices(main_string, substring): Returns a list of starting indices where the substring is found within the main string. if not substring: return [i for i in range(len(main_string) + 1)] if main_string else [0] indices = [] len_main = len(main_string) len_sub = len(substring) for i in range(len_main - len_sub + 1): if main_string[i:i + len_sub] == substring: indices.append(i) return indices"},{"question":"import time class OnlineAuction: def __init__(self, max_bids=None, duration=None): Initialize the auction with optional maximum number of bids and duration in seconds. pass def place_bid(self, user, amount): Place a bid with the user's name and the bid amount. Ensure the bid is higher than the current highest bid. Args: user (str): The name of the user placing the bid. amount (int): The amount of the bid. Returns: str: A message indicating whether the bid was placed successfully or if it was too low. >>> auction = OnlineAuction() >>> auction.place_bid(\\"Alice\\", 100) 'Bid placed successfully.' >>> auction.place_bid(\\"Bob\\", 90) 'Bid should be higher than the current highest bid.' pass def end_auction(self): End the auction and return the highest bid and the highest bidder. Returns: tuple or str: The name of the highest bidder and the highest bid, or 'No bids placed' if there are no bids. >>> auction = OnlineAuction() >>> auction.end_auction() 'No bids placed' pass","solution":"import time class OnlineAuction: def __init__(self, max_bids=None, duration=None): Initialize the auction with optional maximum number of bids and duration in seconds. self.bids = [] self.max_bids = max_bids self.end_time = time.time() + duration if duration is not None else None def place_bid(self, user, amount): Place a bid with the user's name and the bid amount. Ensure the bid is higher than the current highest bid. if self.end_time is not None and time.time() > self.end_time: return \\"The auction has ended.\\" if self.max_bids is not None and len(self.bids) >= self.max_bids: return \\"The auction has reached the maximum number of bids.\\" if not self.bids or amount > self.bids[-1][1]: self.bids.append((user, amount)) return \\"Bid placed successfully.\\" else: return \\"Bid should be higher than the current highest bid.\\" def end_auction(self): End the auction and return the highest bid and the highest bidder. if not self.bids: return \\"No bids placed\\" highest_bidder, highest_bid = self.bids[-1] return highest_bidder, highest_bid"},{"question":"def group_strings_by_length(strings): Returns a dictionary where the keys are the lengths of the strings and the values are lists of strings of that specific length. >>> group_strings_by_length([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\", \\"egg\\", \\"fig\\", \\"grape\\"]) {5: [\\"apple\\", \\"grape\\"], 6: [\\"banana\\", \\"cherry\\"], 4: [\\"date\\"], 3: [\\"egg\\", \\"fig\\"]} >>> group_strings_by_length([]) {} >>> group_strings_by_length([\\"bat\\", \\"cat\\", \\"hat\\", \\"mat\\"]) {3: [\\"bat\\", \\"cat\\", \\"hat\\", \\"mat\\"]} >>> group_strings_by_length([\\"one\\", \\"three\\", \\"five\\", \\"two\\", \\"four\\", \\"three\\"]) {3: [\\"one\\", \\"two\\"], 5: [\\"three\\", \\"three\\"], 4: [\\"five\\", \\"four\\"]} >>> group_strings_by_length([\\"a\\", \\"bb\\", \\"ccc\\", \\"dddd\\", \\"eeeee\\", \\"ffffff\\"]) {1: [\\"a\\"], 2: [\\"bb\\"], 3: [\\"ccc\\"], 4: [\\"dddd\\"], 5: [\\"eeeee\\"], 6: [\\"ffffff\\"]}","solution":"from collections import defaultdict def group_strings_by_length(strings): Returns a dictionary where the keys are the lengths of the strings and the values are lists of strings of that specific length. result = defaultdict(list) for string in strings: result[len(string)].append(string) return dict(result)"},{"question":"def calculate_average_scores(student_scores: dict) -> dict: Calculate the average score for each student. :param student_scores: Dictionary where the keys are student names and values are lists of scores. :return: Dictionary with student names as keys and their average scores as values. >>> calculate_average_scores({\\"Alice\\": [90, 80, 85], \\"Bob\\": [70, 75, 65], \\"Charlie\\": [100, 100, 100]}) {'Alice': 85.0, 'Bob': 70.0, 'Charlie': 100.0} >>> calculate_average_scores({\\"Alice\\": [90, 80, 85], \\"Bob\\": []}) {'Alice': 85.0, 'Bob': 0.0} >>> calculate_average_scores({\\"Alice\\": [100], \\"Bob\\": [50]}) {'Alice': 100.0, 'Bob': 50.0} >>> calculate_average_scores({\\"Alice\\": [90, 85, 80], \\"Bob\\": [70, 75, 65], \\"Charlie\\": [100, 90, 80]}) {'Alice': 85.0, 'Bob': 70.0, 'Charlie': 90.0} >>> calculate_average_scores({\\"Alice\\": [], \\"Bob\\": []}) {'Alice': 0.0, 'Bob': 0.0}","solution":"def calculate_average_scores(student_scores): Calculate the average score for each student. :param student_scores: Dictionary where the keys are student names and values are lists of scores. :return: Dictionary with student names as keys and their average scores as values. average_scores = {} for student, scores in student_scores.items(): if scores: # Check if the list is not empty average_scores[student] = sum(scores) / len(scores) else: average_scores[student] = 0.0 # Define behavior for students with no scores return average_scores"},{"question":"def second_highest(numbers: List[int]) -> int: Returns the second highest number in the list. If there is no second highest number, return None. >>> second_highest([1, 3, 4, 5, 0, 2]) 4 >>> second_highest([7, 7, 7, 7]) None","solution":"def second_highest(numbers): Returns the second highest number in the list. If there is no second highest number, (e.g. the list contains duplicates of a single integer or is empty), return None. if len(numbers) < 2: return None unique_numbers = list(set(numbers)) if len(unique_numbers) < 2: return None unique_numbers.sort(reverse=True) return unique_numbers[1]"},{"question":"def shift_string(input_str: str) -> (str, int): Shifts each alphabetical character to the next character in the ASCII table, wraps 'z' to 'a' and 'Z' to 'A', and counts the number of vowels in the modified string. Non-alphabetic characters remain unchanged. Args: input_str (str): The input string Returns: tuple: A tuple containing the modified string and the number of vowels in it >>> shift_string(\\"abc\\") == (\\"bcd\\", 0) >>> shift_string(\\"xyz\\") == (\\"yza\\", 1) >>> shift_string(\\"hello\\") == (\\"ifmmp\\", 1) >>> shift_string(\\"ABC\\") == (\\"BCD\\", 0) >>> shift_string(\\"XYZ\\") == (\\"YZA\\", 1) >>> shift_string(\\"AbcXyZ\\") == (\\"BcdYzA\\", 1) >>> shift_string(\\"HelloWorld\\") == (\\"IfmmpXpsme\\", 2) >>> shift_string(\\"123!\\") == (\\"123!\\", 0) >>> shift_string(\\"a1b2c3!\\") == (\\"b1c2d3!\\", 0) >>> shift_string(\\"z#Z@\\") == (\\"a#A@\\", 2) >>> shift_string(\\"\\") == (\\"\\", 0)","solution":"def shift_string(input_str): Shifts each alphabetical character to the next character in the ASCII table, wraps 'z' to 'a' and 'Z' to 'A', and counts the number of vowels in the modified string. Non-alphabetic characters remain unchanged. Args: input_str (str): The input string Returns: tuple: A tuple containing the modified string and the number of vowels in it modified_str = [] vowels = 'aeiouAEIOU' vowels_count = 0 for char in input_str: if 'a' <= char <= 'y' or 'A' <= char <= 'Y': new_char = chr(ord(char) + 1) elif char == 'z': new_char = 'a' elif char == 'Z': new_char = 'A' else: new_char = char if new_char in vowels: vowels_count += 1 modified_str.append(new_char) return ''.join(modified_str), vowels_count"},{"question":"def is_valid_format(s: str) -> bool: This function takes a string s and returns True if it adheres to the following rules: 1. The string must start with a capital letter. 2. The string must contain at least one digit. 3. The string must end with a punctuation mark (.,!,?) >>> is_valid_format(\\"Hello123.\\") == True >>> is_valid_format(\\"Hello123!\\") == True >>> is_valid_format(\\"Goodbye456?\\") == True >>> is_valid_format(\\"hello123.\\") == False >>> is_valid_format(\\"HelloWorld!\\") == False >>> is_valid_format(\\"Hello123\\") == False >>> is_valid_format(\\"\\") == False >>> is_valid_format(\\"hello\\") == False >>> is_valid_format(\\"HELLO\\") == False >>> is_valid_format(\\"hello.\\") == False >>> is_valid_format(\\"Hello.\\") == False >>> is_valid_format(\\"A1.\\") == True >>> is_valid_format(\\"B2!\\") == True >>> is_valid_format(\\"C3?\\") == True","solution":"def is_valid_format(s): This function takes a string s and returns True if it adheres to the following rules: 1. The string must start with a capital letter. 2. The string must contain at least one digit. 3. The string must end with a punctuation mark (.,!,?) Parameters: s (str): Input string to check against the formatting rules. Returns: bool: True if the string adheres to all rules, otherwise False. if not s: return False if not s[0].isupper(): return False if not any(char.isdigit() for char in s): return False if s[-1] not in '.!?': return False return True"},{"question":"def dijkstra(adj_matrix, start, end): Returns the shortest path from start node to end node in a weighted directional graph. If there is no path, returns an empty list. Parameters: adj_matrix (list of list of int): The adjacency matrix representing the graph. start (int): The starting node. end (int): The target node. Returns: list of int: The shortest path from start node to end node. pass # Unit Tests def test_dijkstra_simple_graph(): adj_matrix = [ [0, 1, 4, 0], [0, 0, 4, 2], [0, 0, 0, 5], [0, 0, 0, 0] ] assert dijkstra(adj_matrix, 0, 3) == [0, 1, 3] def test_dijkstra_disconnected(): adj_matrix = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert dijkstra(adj_matrix, 0, 2) == [] def test_dijkstra_invalid_input(): adj_matrix = [ [0, 1], [1, 0] ] assert dijkstra(adj_matrix, -1, 1) == [] assert dijkstra(adj_matrix, 0, 2) == [] assert dijkstra([], 0, 1) == [] def test_dijkstra_zero_weight_edges(): adj_matrix = [ [0, 1, 0], [0, 0, 1], [0, 0, 0] ] assert dijkstra(adj_matrix, 0, 2) == [0, 1, 2] def test_dijkstra_single_node_graph(): adj_matrix = [ [0] ] assert dijkstra(adj_matrix, 0, 0) == [0] def test_dijkstra_no_path(): adj_matrix = [ [0, 1, 0], [0, 0, 0], [0, 2, 0] ] assert dijkstra(adj_matrix, 0, 2) == []","solution":"import heapq def dijkstra(adj_matrix, start, end): Returns the shortest path from start node to end node in a weighted directional graph. If there is no path, returns an empty list. Parameters: adj_matrix (list of list of int): The adjacency matrix representing the graph. start (int): The starting node. end (int): The target node. Returns: list of int: The shortest path from start node to end node. # Number of nodes in the graph num_nodes = len(adj_matrix) # Handle invalid inputs if not adj_matrix or not isinstance(adj_matrix, list) or start < 0 or end < 0 or start >= num_nodes or end >= num_nodes: return [] # Min-heap to store minimum weight edges heap = [(0, start)] # Distance array to store the shortest distance to each node distances = [float('inf')] * num_nodes distances[start] = 0 # Array to store the path previous_nodes = [None] * num_nodes while heap: current_distance, current_node = heapq.heappop(heap) # Stop processing if we've reached the end node if current_node == end: break # Explore neighbors for neighbor, weight in enumerate(adj_matrix[current_node]): if weight > 0: # there is an edge distance = current_distance + weight # Only consider this path if it's better if distance < distances[neighbor]: distances[neighbor] = distance previous_nodes[neighbor] = current_node heapq.heappush(heap, (distance, neighbor)) # Reconstruct the shortest path path = [] current_node = end while current_node is not None: path.insert(0, current_node) current_node = previous_nodes[current_node] if path[0] == start: return path else: return []"},{"question":"from typing import List def increment_by_unique_count(lst: List[int]) -> List[int]: Takes a list of integers and returns a new list with each integer incremented by the number of unique integers in the input list. Args: lst (List[int]): A list of integers. Returns: List[int]: A new list with each integer incremented by the number of unique integers. Raises: TypeError: If the input is not a list or if the elements in the list are not all integers. # Test cases def test_increment_by_unique_count_normal_case(): assert increment_by_unique_count([1, 2, 2, 3]) == [4, 5, 5, 6] def test_increment_by_unique_count_empty_list(): assert increment_by_unique_count([]) == [] def test_increment_by_unique_count_single_element(): assert increment_by_unique_count([5]) == [6] def test_increment_by_unique_count_all_same_elements(): assert increment_by_unique_count([4, 4, 4, 4]) == [5, 5, 5, 5] def test_increment_by_unique_count_negative_numbers(): assert increment_by_unique_count([-1, -2, -2, -3]) == [2, 1, 1, 0] def test_increment_by_unique_count_mixed_numbers(): assert increment_by_unique_count([-1, 0, 1, 2]) == [3, 4, 5, 6] def test_increment_by_unique_count_invalid_input_not_list(): with pytest.raises(TypeError): increment_by_unique_count(\\"not a list\\") def test_increment_by_unique_count_invalid_input_not_integers(): with pytest.raises(TypeError): increment_by_unique_count([1, 2, \\"three\\"])","solution":"def increment_by_unique_count(lst): Takes a list of integers and returns a new list with each integer incremented by the number of unique integers in the input list. Args: lst (list): A list of integers. Returns: list: A new list with each integer incremented by the number of unique integers. Raises: TypeError: If the input is not a list or if the elements in the list are not all integers. if not isinstance(lst, list): raise TypeError(\\"Input must be a list.\\") if not all(isinstance(i, int) for i in lst): raise TypeError(\\"All elements in the list must be integers.\\") unique_count = len(set(lst)) return [i + unique_count for i in lst]"},{"question":"def extract_even_numbers(numbers: List[int]) -> List[int]: Returns a list of even numbers from the given list of integers. :param numbers: List of integers :return: List of even integers >>> extract_even_numbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [2, 4, 6, 8, 10] >>> extract_even_numbers([2, 4, 6, 8, 10]) == [2, 4, 6, 8, 10] >>> extract_even_numbers([1, 3, 5, 7, 9]) == [] >>> extract_even_numbers([]) == [] >>> extract_even_numbers([-2, -4, -6]) == [-2, -4, -6] >>> extract_even_numbers([-10, -7, -4, -2, 1, 2, 4, 5]) == [-10, -4, -2, 2, 4] >>> extract_even_numbers([1000000000, 1000000001, 1000000002]) == [1000000000, 1000000002]","solution":"def extract_even_numbers(numbers): Returns a list of even numbers from the given list of integers. :param numbers: List of integers :return: List of even integers return [number for number in numbers if number % 2 == 0]"},{"question":"import numpy as np import pandas as pd from sklearn.metrics.pairwise import cosine_similarity class CollaborativeFilteringRecommender: def __init__(self, ratings_df): Initialize the recommender with a DataFrame containing user-item ratings. The DataFrame should have columns: 'user_id', 'item_id', 'rating'. pass def prepare_matrices(self): Prepare the user similarity and prediction matrices. pass def recommend(self, user_id, top_n=5): Recommend top N items for a given user. Returns a list of item_ids. pass def update_ratings(self, new_ratings_df): Update the ratings matrix with new ratings. pass # Example usage # ratings = pd.DataFrame({ # 'user_id': [1, 1, 1, 2, 2, 2, 3, 3, 3], # 'item_id': [1, 2, 3, 1, 2, 3, 1, 2, 4], # 'rating': [4, 5, 2, 3, 3, 4, 2, 5, 4] # }) # recommender = CollaborativeFilteringRecommender(ratings) # print(recommender.recommend(user_id=1, top_n=3))","solution":"import numpy as np import pandas as pd from sklearn.metrics.pairwise import cosine_similarity class CollaborativeFilteringRecommender: def __init__(self, ratings_df): Initialize the recommender with a DataFrame containing user-item ratings. The DataFrame should have columns: 'user_id', 'item_id', 'rating'. self.ratings_df = ratings_df self.user_similarity_matrix = None self.prediction_matrix = None self.prepare_matrices() def prepare_matrices(self): Prepare the user similarity and prediction matrices. user_item_matrix = self.ratings_df.pivot(index='user_id', columns='item_id', values='rating').fillna(0) self.user_item_matrix = user_item_matrix.to_numpy() # Compute user similarity matrix based on cosine similarity self.user_similarity_matrix = cosine_similarity(self.user_item_matrix) # Predict ratings self.prediction_matrix = np.dot(self.user_similarity_matrix, self.user_item_matrix) # Filter out already rated items rated_matrix = (self.user_item_matrix > 0).astype(float) self.prediction_matrix *= (1 - rated_matrix) def recommend(self, user_id, top_n=5): Recommend top N items for a given user. Returns a list of item_ids. if user_id not in self.ratings_df['user_id'].unique(): raise ValueError(\\"User ID not found in dataset\\") user_idx = self.ratings_df['user_id'].unique().tolist().index(user_id) # Get the predicted ratings for the user user_predictions = self.prediction_matrix[user_idx] # Sort the predictions recommended_items_idx = (-user_predictions).argsort()[:top_n] # Get the item_ids for the top_n recommendations item_ids = self.ratings_df['item_id'].unique()[recommended_items_idx].tolist() return item_ids def update_ratings(self, new_ratings_df): Update the ratings matrix with new ratings. self.ratings_df = pd.concat([self.ratings_df, new_ratings_df]) self.prepare_matrices() # Example usage # ratings = pd.DataFrame({ # 'user_id': [1, 1, 1, 2, 2, 2, 3, 3, 3], # 'item_id': [1, 2, 3, 1, 2, 3, 1, 2, 4], # 'rating': [4, 5, 2, 3, 3, 4, 2, 5, 4] # }) # recommender = CollaborativeFilteringRecommender(ratings) # print(recommender.recommend(user_id=1, top_n=3))"},{"question":"class Node: def __init__(self, data): self.data = data self.next = None def reverse_list(head): Reverses a singly linked list. :param head: The head node of the singly linked list. :return: The new head node of the reversed singly linked list. prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev def test_reverse_empty_list(): assert reverse_list(None) == None def test_reverse_single_element_list(): head = Node(1) new_head = reverse_list(head) assert new_head.data == 1 assert new_head.next == None def test_reverse_two_element_list(): head = Node(1) head.next = Node(2) new_head = reverse_list(head) assert new_head.data == 2 assert new_head.next.data == 1 assert new_head.next.next == None def test_reverse_multiple_element_list(): head = Node(1) head.next = Node(2) head.next.next = Node(3) new_head = reverse_list(head) assert new_head.data == 3 assert new_head.next.data == 2 assert new_head.next.next.data == 1 assert new_head.next.next.next == None","solution":"class Node: def __init__(self, data): self.data = data self.next = None def reverse_list(head): Reverses a singly linked list. :param head: The head node of the singly linked list. :return: The new head node of the reversed singly linked list. prev = None current = head while current: next_node = current.next # Correct variable name to avoid conflict and clarifying purpose. current.next = prev prev = current current = next_node return prev # The correct new head of the reversed list is \`prev\`, not \`current\`. # Creating a linked list: 1 -> 2 -> 3 -> None head = Node(1) head.next = Node(2) head.next.next = Node(3) # Attempt to reverse the linked list reversed_head = reverse_list(head) # Function to print linked list def print_list(node): while node: print(node.data, end=\\" -> \\" if node.next else \\"n\\") node = node.next # Print reversed linked list, output should be: 3 -> 2 -> 1 -> None print_list(reversed_head)"},{"question":"import heapq from typing import List, Dict, Tuple def dijkstra(city_map: Dict[str, Dict[str, int]], start_city: str, end_city: str ) -> Tuple[List[str], int]: Finds the shortest path between two cities using Dijkstra's algorithm. Args: city_map (dict): A dictionary where keys are city names and values are dictionaries of neighboring cities and their respective distances. start_city (str): The starting city name. end_city (str): The destination city name. Returns: tuple: A tuple containing the shortest path (list of city names) and the total distance (int). Returns ([], float('inf')) if no path exists. Example: >>> city_map = { \\"A\\": {\\"B\\": 1, \\"C\\": 4}, \\"B\\": {\\"A\\": 1, \\"C\\": 2, \\"D\\": 5}, \\"C\\": {\\"A\\": 4, \\"B\\": 2, \\"D\\": 1}, \\"D\\": {\\"B\\": 5, \\"C\\": 1, \\"E\\": 3}, \\"E\\": {\\"D\\": 3} } >>> dijkstra(city_map, \\"A\\", \\"E\\") ([\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"E\\"], 7) >>> dijkstra(city_map, \\"C\\", \\"A\\") ([\\"C\\", \\"B\\", \\"A\\"], 3) >>> isolated_city_map = { \\"A\\": {\\"B\\": 1, \\"C\\": 4}, \\"B\\": {\\"A\\": 1, \\"C\\": 2}, \\"C\\": {\\"A\\": 4, \\"B\\": 2}, \\"D\\": {\\"B\\": 5, \\"C\\": 1} } >>> dijkstra(isolated_city_map, \\"A\\", \\"E\\") ([], float('inf'))","solution":"import heapq def dijkstra(city_map, start_city, end_city): Finds the shortest path between two cities using Dijkstra's algorithm. Args: city_map (dict): A dictionary where keys are city names and values are dictionaries of neighboring cities and their respective distances. start_city (str): The starting city name. end_city (str): The destination city name. Returns: tuple: A tuple containing the shortest path (list of city names) and the total distance (int). Returns ([], float('inf')) if no path exists. # Priority queue to hold cities to explore queue = [(0, start_city, [])] # Dictionary to keep track of visited cities visited = set() while queue: (cost, city, path) = heapq.heappop(queue) if city in visited: continue # Add current city to the path path = path + [city] visited.add(city) # If we reached the end city, return the result if city == end_city: return (path, cost) # Explore neighboring cities for neighbor, distance in city_map.get(city, {}).items(): if neighbor not in visited: heapq.heappush(queue, (cost + distance, neighbor, path)) # If path doesn't exist return ([], float('inf')) # Sample data city_map = { \\"A\\": {\\"B\\": 1, \\"C\\": 4}, \\"B\\": {\\"A\\": 1, \\"C\\": 2, \\"D\\": 5}, \\"C\\": {\\"A\\": 4, \\"B\\": 2, \\"D\\": 1}, \\"D\\": {\\"B\\": 5, \\"C\\": 1, \\"E\\": 3}, \\"E\\": {\\"D\\": 3} }"},{"question":"def count_pairs(nums, k): Write a function that takes a list of integers and an integer \`k\`, and returns the number of pairs of integers in the list that sum up to \`k\`. Each pair should be counted only once, regardless of the order of the integers. >>> count_pairs([1, 2, 3, 4], 5) 2 >>> count_pairs([1, 1, 1, 1], 2) 1 >>> count_pairs([1, 2, 3], 7) 0 >>> count_pairs([1, 5, 7, -1], 6) 2 >>> count_pairs([1000000000, -1000000000, 0], 0) 1 >>> count_pairs([], 5) 0","solution":"def count_pairs(nums, k): Returns the number of unique pairs of integers in the list that sum up to k. if not nums: return 0 count = 0 num_set = set() visited = set() for num in nums: target = k - num if target in num_set and (target, num) not in visited and (num, target) not in visited: count += 1 visited.add((num, target)) num_set.add(num) return count"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a mathematical expression containing integers, operators (+, -, *, /), and parentheses and return the result as an integer. The integer division should truncate toward zero. >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\" 3/2 \\") 1 >>> evaluate_expression(\\" (1+(4+5+2)-3)+(6+8) \\") 23 >>> evaluate_expression(\\"(2+3)*4-5\\") 15 >>> evaluate_expression(\\"3+2*2-8/(2+2)\\") 5 >>> evaluate_expression(\\"((2+3)*(4-2))\\") 10 >>> evaluate_expression(\\"3-5\\") -2 from solution import evaluate_expression def test_simple_addition(): assert evaluate_expression(\\"3+2\\") == 5 def test_leading_space(): assert evaluate_expression(\\" 3+2 \\") == 5 def test_addition_and_multiplication(): assert evaluate_expression(\\" 3+2*2 \\") == 7 def test_division(): assert evaluate_expression(\\"3/2\\") == 1 def test_complex_expression_with_parentheses(): assert evaluate_expression(\\" (1+(4+5+2)-3)+(6+8) \\") == 23 def test_multiple_operations(): assert evaluate_expression(\\"(2+3)*4-5\\") == 15 assert evaluate_expression(\\"3+2*2-8/(2+2)\\") == 5 def test_nested_parentheses(): assert evaluate_expression(\\"((2+3)*(4-2))\\") == 10 def test_negative_result(): assert evaluate_expression(\\"3-5\\") == -2","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing integers, operators (+, -, *, /), and parentheses and returns the result as an integer. def operate(a, b, operator): if operator == '+': return a + b elif operator == '-': return a - b elif operator == '*': return a * b elif operator == '/': return int(a / b) # Truncate toward zero def precedence(operator): if operator in ('+', '-'): return 1 elif operator in ('*', '/'): return 2 return 0 def shunting_yard(expression): output = [] operators = [] i = 0 n = len(expression) while i < n: if expression[i].isdigit(): num = 0 while i < n and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 output.append(num) i -= 1 # the for loop will increment it again elif expression[i] == '(': operators.append(expression[i]) elif expression[i] == ')': while operators and operators[-1] != '(': output.append(operators.pop()) operators.pop() elif expression[i] in ('+', '-', '*', '/'): while operators and precedence(operators[-1]) >= precedence(expression[i]): output.append(operators.pop()) operators.append(expression[i]) i += 1 while operators: output.append(operators.pop()) return output def evaluate_rpn(tokens): stack = [] for token in tokens: if isinstance(token, int): stack.append(token) else: b = stack.pop() a = stack.pop() stack.append(operate(a, b, token)) return stack[0] expression = expression.replace(' ', '') rpn = shunting_yard(expression) return evaluate_rpn(rpn)"},{"question":"import string class URLShortener: A simple URL shortening service that converts a long URL into a shortened version, and vice versa. def __init__(self): self.url_dict = {} self.counter = 0 self.characters = string.ascii_letters + string.digits def encode(self, long_url): Encodes a long URL into a short URL. >>> shortener = URLShortener() >>> short_url = shortener.encode(\\"https://www.example.com\\") >>> short_url != \\"\\" True def decode(self, short_url): Decodes a short URL back into the original long URL. >>> shortener = URLShortener() >>> short_url = shortener.encode(\\"https://www.example.com\\") >>> shortener.decode(short_url) == \\"https://www.example.com\\" True def _base62_encode(self, num): Encodes a number into a base62 string. >>> shortener = URLShortener() >>> shortener._base62_encode(0) == \\"a\\" True","solution":"import string class URLShortener: def __init__(self): self.url_dict = {} self.counter = 0 self.characters = string.ascii_letters + string.digits def encode(self, long_url): Encodes a long URL into a short URL. short_url = self._base62_encode(self.counter) self.url_dict[short_url] = long_url self.counter += 1 return short_url def decode(self, short_url): Decodes a short URL back into the original long URL. return self.url_dict.get(short_url, \\"\\") def _base62_encode(self, num): Encodes a number into a base62 string. if num == 0: return self.characters[0] base62 = [] while num: num, rem = divmod(num, 62) base62.append(self.characters[rem]) return ''.join(reversed(base62))"},{"question":"def is_valid_parentheses(input_str: str) -> bool: Determines if the input_str contains valid arrangements of parentheses, brackets, and braces. Args: input_str (str): The input string containing parentheses, brackets, and braces. Returns: bool: True if the string is valid, otherwise False. Examples: >>> is_valid_parentheses(\\"{[()()]}\\") True >>> is_valid_parentheses(\\"()[]{}\\") True >>> is_valid_parentheses(\\"{[(])}\\") False >>> is_valid_parentheses(\\"([)]\\") False >>> is_valid_parentheses(\\"{[}\\") False >>> is_valid_parentheses(\\"\\") True >>> is_valid_parentheses(\\"((((\\") False >>> is_valid_parentheses(\\"()()\\") True","solution":"def is_valid_parentheses(input_str): Determines if the input_str contains valid arrangements of parentheses, brackets, and braces. Args: input_str (str): The input string containing parentheses, brackets, and braces. Returns: bool: True if the string is valid, otherwise False. stack = [] mapping = {\\")\\": \\"(\\", \\"}\\": \\"{\\", \\"]\\": \\"[\\"} for char in input_str: if char in mapping: top_element = stack.pop() if stack else '#' if mapping[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"from datetime import datetime import json def analyze_transactions(json_data, start_date, end_date): Analyze and process a list of bank transactions stored in a JSON object. Parameters: - json_data: JSON string containing the list of transactions. - start_date: Start date in the format \\"YYYY-MM-DD\\". - end_date: End date in the format \\"YYYY-MM-DD\\". Returns: - summary: A dictionary containing the filtered transactions list and the total amounts for each type. pass # Unit tests json_data = ''' { \\"transactions\\": [ { \\"transaction_id\\": \\"t1\\", \\"amount\\": 150.00, \\"date\\": \\"2023-01-10\\", \\"type\\": \\"DEBIT\\" }, { \\"transaction_id\\": \\"t2\\", \\"amount\\": 200.00, \\"date\\": \\"2023-02-14\\", \\"type\\": \\"CREDIT\\" }, { \\"transaction_id\\": \\"t3\\", \\"amount\\": 100.00, \\"date\\": \\"2023-03-15\\", \\"type\\": \\"DEBIT\\" }, { \\"transaction_id\\": \\"t4\\", \\"amount\\": 300.00, \\"date\\": \\"2023-04-18\\", \\"type\\": \\"CREDIT\\" } ] } ''' def test_analyze_transactions_all_range(): result = analyze_transactions(json_data, '2023-01-01', '2023-12-31') assert len(result['transactions']) == 4 assert result['total_debit'] == 250.00 assert result['total_credit'] == 500.00 def test_analyze_transactions_partial_range(): result = analyze_transactions(json_data, '2023-02-01', '2023-03-31') assert len(result['transactions']) == 2 assert result['total_debit'] == 100.00 assert result['total_credit'] == 200.00 def test_analyze_transactions_single_transaction(): result = analyze_transactions(json_data, '2023-04-18', '2023-04-18') assert len(result['transactions']) == 1 assert result['total_debit'] == 0.00 assert result['total_credit'] == 300.00 def test_analyze_transactions_no_transactions(): result = analyze_transactions(json_data, '2024-01-01', '2024-12-31') assert len(result['transactions']) == 0 assert result['total_debit'] == 0.00 assert result['total_credit'] == 0.00","solution":"from datetime import datetime import json def analyze_transactions(json_data, start_date, end_date): Analyze and process a list of bank transactions stored in a JSON object. Parameters: - json_data: JSON string containing the list of transactions. - start_date: Start date in the format \\"YYYY-MM-DD\\". - end_date: End date in the format \\"YYYY-MM-DD\\". Returns: - summary: A dictionary containing the filtered transactions list and the total amounts for each type. data = json.loads(json_data) transactions = data['transactions'] filtered_transactions = [] total_debit = 0.0 total_credit = 0.0 start_date_dt = datetime.strptime(start_date, '%Y-%m-%d') end_date_dt = datetime.strptime(end_date, '%Y-%m-%d') for transaction in transactions: transaction_date_dt = datetime.strptime(transaction['date'], '%Y-%m-%d') if start_date_dt <= transaction_date_dt <= end_date_dt: filtered_transactions.append(transaction) if transaction['type'] == \\"DEBIT\\": total_debit += transaction['amount'] elif transaction['type'] == \\"CREDIT\\": total_credit += transaction['amount'] summary = { 'transactions': filtered_transactions, 'total_debit': total_debit, 'total_credit': total_credit } return summary"},{"question":"from typing import List, Union def evaluate_rpn(expression: List[Union[int, str]]) -> int: Evaluate arithmetic expressions given in Reverse Polish Notation (RPN). >>> evaluate_rpn([2, 1, '+', 3, '*']) 9 >>> evaluate_rpn([4, 13, 5, '/', '+']) 6 >>> evaluate_rpn([10, 6, 9, 3, '+', -11, '*', '/', '*', 17, '+', 5, '+']) 22 >>> evaluate_rpn([42]) 42 >>> evaluate_rpn([5, 1, 2, '+', 4, '*', '+', 3, '-']) 14 >>> evaluate_rpn([7, 3, '/']) 2 >>> evaluate_rpn([7, -3, '/']) -2 >>> evaluate_rpn([-7, 3, '/']) -2 >>> evaluate_rpn([-7, -3, '/']) 2 >>> evaluate_rpn([100, 200, '+', 2, '/', 5, '*', 7, '+']) 757","solution":"from typing import List, Union def evaluate_rpn(expression: List[Union[int, str]]) -> int: stack = [] for token in expression: if isinstance(token, int): stack.append(token) else: b = stack.pop() a = stack.pop() if token == '+': stack.append(a + b) elif token == '-': stack.append(a - b) elif token == '*': stack.append(a * b) elif token == '/': stack.append(int(a / b)) # int to truncate towards zero return stack[0]"},{"question":"def apples_kept_by_sarah(total_apples, num_friends): Returns the number of apples Sarah keeps for herself after sharing the apples among her friends. Sarah keeps 2 more apples than each friend. >>> apples_kept_by_sarah(60, 4) 14 >>> apples_kept_by_sarah(60, 0) 62 >>> apples_kept_by_sarah(60, 1) 32 >>> apples_kept_by_sarah(50, 4) 12 >>> apples_kept_by_sarah(120, 3) 32 >>> apples_kept_by_sarah(50, 5) 10 pass def sarahs_apples(): Sarah decided to share her collection of 60 apples equally among her 4 friends. However, she also wants to keep a certain number of apples for herself, which is exactly 2 more than the number of apples each friend gets. For the specific case: >>> sarahs_apples() 14 pass","solution":"def apples_kept_by_sarah(total_apples, num_friends): Returns the number of apples Sarah keeps for herself after sharing the apples among her friends. Sarah keeps 2 more apples than each friend. apples_per_friend = total_apples // (num_friends + 1) # Sarah is considered as one additional person apples_sarah_keeps = apples_per_friend + 2 return apples_sarah_keeps # Specific case def sarahs_apples(): return apples_kept_by_sarah(60, 4)"},{"question":"def combination_sum(candidates: List[int], target: int) -> List[List[int]]: Given an integer array 'candidates' and an integer 'target', return all unique combinations of 'candidates' where the chosen numbers sum to 'target'. Each number in 'candidates' may be used an unlimited number of times in the combination. >>> combination_sum([2, 3, 6, 7], 7) [[2, 2, 3], [7]] >>> combination_sum([2, 4, 6], 5) [] >>> combination_sum([2, 3, 5], 8) [[2, 2, 2, 2], [2, 3, 3], [3, 5]] >>> combination_sum([], 7) [] >>> combination_sum([2, 3, 6, 7], 0) [] >>> combination_sum([2, 3, 6, 7], -5) []","solution":"def combination_sum(candidates, target): Given an integer array 'candidates' and an integer 'target', return all unique combinations of 'candidates' where the chosen numbers sum to 'target'. Each number in 'candidates' may be used an unlimited number of times in the combination. :param candidates: List of integers :param target: Target integer value :return: List of unique combinations where each combination's elements sum up to the target def backtrack(start, remain, path): if remain == 0: result.append(list(path)) return elif remain < 0: return for i in range(start, len(candidates)): path.append(candidates[i]) backtrack(i, remain - candidates[i], path) path.pop() if not candidates or target <= 0: return [] candidates.sort() result = [] backtrack(0, target, []) return result"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def zigzagLevelOrder(root): Traverse the binary tree in a zigzag level order. First level is traversed from left to right, the second level from right to left, and so on. Args: root (TreeNode): The root of the binary tree. Returns: List[List[int]]: A list of lists, where each list contains the node values at each level in zigzag order. Example: >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> zigzagLevelOrder(root) [[1], [3, 2], [4, 5, 6, 7]]","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def zigzagLevelOrder(root): if not root: return [] result, current_level, direction = [], [root], 1 while current_level: level_values = [node.value for node in current_level][::direction] result.append(level_values) direction *= -1 next_level = [] for node in current_level: if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) current_level = next_level return result"},{"question":"def longest_concatenated_word(words: List[str]) -> str: Implement a function in Python that receives a list of words and returns the longest word that can be constructed by concatenating other words from the list. If no such word can be formed, return an empty string. You are permitted to use each word from the list multiple times if necessary. >>> longest_concatenated_word([\\"cat\\", \\"banana\\", \\"dog\\", \\"nana\\", \\"walk\\", \\"walker\\", \\"dogwalker\\"]) == \\"dogwalker\\" >>> longest_concatenated_word([\\"cat\\", \\"banana\\", \\"dog\\", \\"walk\\"]) == \\"\\" >>> longest_concatenated_word([\\"cat\\", \\"cats\\", \\"catsdog\\", \\"dog\\", \\"dogcat\\", \\"catdogcat\\"]) == \\"catdogcat\\" >>> longest_concatenated_word([\\"word\\"]) == \\"\\" >>> longest_concatenated_word([]) == \\"\\"","solution":"def can_construct(word, word_set): if word in word_set: return True for i in range(1, len(word)): prefix = word[:i] suffix = word[i:] if prefix in word_set and can_construct(suffix, word_set): return True return False def longest_concatenated_word(words): word_set = set(words) max_word = \\"\\" for word in words: word_set.remove(word) # Temporarily remove the current word from the set if can_construct(word, word_set): if len(word) > len(max_word): max_word = word word_set.add(word) # Add the word back to the set return max_word"},{"question":"from typing import List def is_prime(n: int) -> bool: Checks if a number is a prime number. # Function implementation goes here pass def filter_unique_primes(nums: List[int]) -> List[int]: Returns a list of unique prime numbers from the given list of integers. >>> filter_unique_primes([11, 4, 5, 17, 11, 18, 5, 23]) == [5, 11, 17, 23] >>> filter_unique_primes([2, 3, 5, 7, 11, 13]) == [2, 3, 5, 7, 11, 13] >>> filter_unique_primes([1, 4, 6, 8, 10]) == [] >>> filter_unique_primes([29, 23, 19, 17, 19, 13, 11, 29, 2]) == [2, 11, 13, 17, 19, 23, 29] >>> filter_unique_primes([4, 6, 8, 9, 10, 12, 14, 15, 16, 18]) == [] # Function implementation goes here pass","solution":"def is_prime(n): Checks if a number is a prime number. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False p = 3 while p * p <= n: if n % p == 0: return False p += 2 return True def filter_unique_primes(nums): Returns a list of unique prime numbers from the given list of integers. primes = set() for num in nums: if is_prime(num): primes.add(num) return sorted(primes)"},{"question":"def remove_duplicates(lst): Returns a new list with all duplicates removed, preserving the order of their first appearance. Example: >>> remove_duplicates([1, 2, 3, 1, 2, 4, 5, 3]) [1, 2, 3, 4, 5] >>> remove_duplicates([1, 1, 1, 1, 1]) [1] # Unit Tests def test_remove_duplicates_all_unique(): assert remove_duplicates([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_remove_duplicates_some_duplicates(): assert remove_duplicates([1, 2, 3, 1, 2, 4, 5, 3]) == [1, 2, 3, 4, 5] def test_remove_duplicates_all_duplicates(): assert remove_duplicates([1, 1, 1, 1, 1]) == [1] def test_remove_duplicates_empty_list(): assert remove_duplicates([]) == [] def test_remove_duplicates_single_element(): assert remove_duplicates([1]) == [1] def test_remove_duplicates_with_negative_numbers(): assert remove_duplicates([1, -1, 2, -2, 1, -1]) == [1, -1, 2, -2] def test_remove_duplicates_with_mixed_sign_numbers(): assert remove_duplicates([1, -1, 1, 2, 2, -1, 3]) == [1, -1, 2, 3]","solution":"def remove_duplicates(lst): Returns a new list with all duplicates removed, preserving the order of their first appearance. seen = [] result = [] for item in lst: if item not in seen: seen.append(item) result.append(item) return result"},{"question":"def square_integers(int_list: List[int]) -> Dict[int, int]: Returns a dictionary where the keys are the integers from the input list and the values are the squares of the corresponding integers. >>> square_integers([1, 2, 3]) {1: 1, 2: 4, 3: 9} >>> square_integers([0, 1, 2]) {0: 0, 1: 1, 2: 4} >>> square_integers([-1, -2, -3]) {-1: 1, -2: 4, -3: 9} >>> square_integers([-1, 0, 1, 2]) {-1: 1, 0: 0, 1: 1, 2: 4} >>> square_integers([]) {}","solution":"def square_integers(int_list): Returns a dictionary where the keys are the integers from the input list and the values are the squares of the corresponding integers. return {x: x**2 for x in int_list}"},{"question":"def max_subarray_sum(arr): Develop a function that calculates the maximum sum of a contiguous subarray within the given list of integers, utilizing Kadane's algorithm. Ensure optimal performance for large input sizes. Example Usage: max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) ➞ 6 max_subarray_sum([1]) ➞ 1 max_subarray_sum([5, 4, -1, 7, 8]) ➞ 23 max_subarray_sum([-1, -2, -3, -4]) ➞ -1","solution":"def max_subarray_sum(arr): Calculates the maximum sum of a contiguous subarray within the given list of integers, using Kadane's algorithm. if not arr: return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def count_characters(s: str) -> dict: Takes a string composed of lowercase and uppercase letters as input and returns a dictionary where the keys are individual characters and the values are the counts of each character's occurrence in the string. The function treats uppercase and lowercase characters as distinct. >>> count_characters(\\"aAbBcC\\") {'a': 1, 'A': 1, 'b': 1, 'B': 1, 'c': 1, 'C': 1} >>> count_characters(\\"abcabc\\") {'a': 2, 'b': 2, 'c': 2} >>> count_characters(\\"ABCABC\\") {'A': 2, 'B': 2, 'C': 2} >>> count_characters(\\"\\") {} >>> count_characters(\\"a1A2b3B4\\") {'a': 1, '1': 1, 'A': 1, '2': 1, 'b': 1, '3': 1, 'B': 1, '4': 1} >>> count_characters(\\"a@#A%b^&B*()\\") {'a': 1, '@': 1, '#': 1, 'A': 1, '': 1, '%': 1, 'b': 1, '^': 1, '&': 1, 'B': 1, '*': 1, '(': 1, ')': 1}","solution":"def count_characters(s): Returns a dictionary containing the counts of each character's occurrence in the string. The function treats uppercase and lowercase characters as distinct. char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 return char_count"},{"question":"from typing import List def filter_primes(numbers: List[int]) -> List[int]: Write a Python function that takes a list of integers as input and returns a new list containing only the prime numbers from the original list. Use an efficient algorithm to check for prime numbers. Avoid using built-in functions that directly identify prime numbers. >>> filter_primes([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> filter_primes([2, 3, 5, 7, 11, 13, 17]) [2, 3, 5, 7, 11, 13, 17] >>> filter_primes([4, 6, 8, 10, 12]) [] >>> filter_primes([-1, -2, -3, -4, -5, -6, -7, -8, -9, -10]) [] >>> filter_primes([-10, -7, -5, -3, 0, 2, 3, 5, 8]) [2, 3, 5] >>> filter_primes(list(range(90, 100))) [97]","solution":"def is_prime(n): Checks if n is a prime number. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n ** 0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(numbers): Returns a new list containing only the prime numbers from the original list. return [num for num in numbers if is_prime(num)]"},{"question":"def flatten_list(nested_list): Flatten a list containing sub-lists into a single list. Arguments: nested_list -- list that can contain nested sub-lists Returns: A single, flattened list with all the elements. >>> flatten_list([1, [2, [3, 4], 5], 6, [[7]], 8]) == [1, 2, 3, 4, 5, 6, 7, 8] >>> flatten_list([1, [], 2, [3, []], [4, [], 5], 6]) == [1, 2, 3, 4, 5, 6] >>> flatten_list([]) == [] >>> flatten_list([1]) == [1] >>> flatten_list([1, [\\"a\\", [\\"b\\", 2], 3.0, [None]], \\"end\\"]) == [1, \\"a\\", \\"b\\", 2, 3.0, None, \\"end\\"] >>> flatten_list([1, [2, [3, [4, [5]]]], 6]) == [1, 2, 3, 4, 5, 6]","solution":"def flatten_list(nested_list): Flatten a list containing sub-lists into a single list. Arguments: nested_list -- list that can contain nested sub-lists Returns: A single, flattened list with all the elements. flat_list = [] for element in nested_list: if isinstance(element, list): flat_list.extend(flatten_list(element)) else: flat_list.append(element) return flat_list"},{"question":"def intersection_list(list1, list2): Create a function that takes two lists of integers and returns a new list containing only the integers that are present in both input lists, without duplicates. Ensure that the order of integers in the resulting list follows their order of first appearance in the first input list. >>> intersection_list([1, 2, 3], [3, 2, 1]) [1, 2, 3] >>> intersection_list([1, 2, 3], [4, 2, 5]) [2] >>> intersection_list([1, 2, 3], [4, 5, 6]) [] >>> intersection_list([1, 2, 2, 3], [2, 2, 3]) [2, 3] >>> intersection_list([1, 2, 3], [2, 2, 3, 3]) [2, 3] >>> intersection_list([], [1, 2, 3]) [] >>> intersection_list([1, 2, 3], []) [] >>> intersection_list([], []) []","solution":"def intersection_list(list1, list2): Returns a list of integers that are present in both input lists, without duplicates, and in the order of their appearance in the first list. set2 = set(list2) result = [] seen = set() for num in list1: if num in set2 and num not in seen: result.append(num) seen.add(num) return result"},{"question":"def ink_used_by_mike(s: int) -> int: Returns the amount of ink used by Mike, given the amount used by Sarah. Mike used 3 milliliters less than twice the amount Sarah used. If Sarah used 's' milliliters, calculate the amount Mike used 'm'. >>> ink_used_by_mike(0) -3 >>> ink_used_by_mike(5) 7 >>> ink_used_by_mike(100) 197 >>> ink_used_by_mike(1) -1 >>> ink_used_by_mike(-3) -9","solution":"def ink_used_by_mike(s): Returns the amount of ink used by Mike, given the amount used by Sarah. m = 2 * s - 3 return m"},{"question":"def validate_email(email: str) -> bool: This function takes a string representing an email address and returns a boolean indicating whether the email is valid according to the following criteria: 1. The email address must contain exactly one '@' character. 2. The local part (before the '@') must contain only alphanumeric characters and may include dots ('.'), but dots cannot be consecutive or at the start or end of the local part. 3. The domain part (after the '@') must contain only alphanumeric characters and dots ('.'), but dots cannot be consecutive or at the start or end of the domain part. 4. The domain part must include at least one dot ('.') separating the domain name and the top-level domain. Examples: >>> validate_email(\\"john.doe@example.com\\") True >>> validate_email(\\"john.doe..@example.com\\") False >>> validate_email(\\"john@.example.com\\") False >>> validate_email(\\"john.doe@example..com\\") False >>> validate_email(\\"john..doe@example.com\\") False >>> validate_email(\\"john.doe@examplecom\\") False >>> validate_email(\\"john.doe@sub.example.com\\") True","solution":"import re def validate_email(email): Validates an email address based on specific rules. # Define the regex pattern for a valid email address. pattern = r\\"^[A-Za-z0-9]+(.[A-Za-z0-9]+)*@[A-Za-z0-9]+(.[A-Za-z0-9]+)+\\" return bool(re.match(pattern, email))"},{"question":"def sqrt(x: int, tolerance: float) -> float: Compute the square root of a given non-negative integer x to within a specified tolerance. Parameters: x (int): The number to compute the square root for. tolerance (float): The acceptable error range for the result. Returns: float: The computed square root of x within the given tolerance. >>> sqrt(0, 0.001) 0 >>> sqrt(1, 0.001) 1 >>> abs(sqrt(9, 0.001) - 3) < 0.001 True >>> abs(sqrt(2, 0.0001) - 1.4142) < 0.0001 True >>> abs(sqrt(10000, 0.0001) - 100) < 0.0001 True >>> abs(sqrt(50, 1e-10) - 7.071067811865475) < 1e-10 True >>> abs(sqrt(50, 0.01) - 7.071067811865475) < 0.01 True","solution":"def sqrt(x, tolerance): Compute the square root of a given non-negative integer x to within a specified tolerance. Parameters: x (int): The number to compute the square root for. tolerance (float): The acceptable error range for the result. Returns: float: The computed square root of x within the given tolerance. if x == 0 or x == 1: return x # Implementing the Newton-Raphson method estimate = x while True: previous_estimate = estimate estimate = (estimate + x / estimate) / 2 if abs(estimate - previous_estimate) < tolerance: break return estimate"},{"question":"def find_anagrams(words: List[str], target: str) -> List[str]: Finds all anagrams of the target word within the provided list of words. >>> find_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"notanagram\\"], \\"inlets\\") [\\"listen\\", \\"silent\\", \\"enlist\\"] >>> find_anagrams([\\"angel\\", \\"glean\\", \\"lane\\", \\"angle\\", \\"galen\\", \\"lean\\"], \\"glean\\") [\\"angel\\", \\"glean\\", \\"angle\\", \\"galen\\"]","solution":"def find_anagrams(words, target): Finds all anagrams of the target word within the provided list of words. parameters: words (list of str): List of words to check for anagrams. target (str): Target word for which we need to find anagrams. returns: list of str: List of anagrams of the target word found in the list of words. from collections import Counter target_counter = Counter(target) anagrams = [] for word in words: if Counter(word) == target_counter: anagrams.append(word) return anagrams"},{"question":"from typing import List def find_max_subarray_sum(arr: List[int]) -> int: Finds the maximum sum of any contiguous subarray within the input list of integers. Implements Kadane's Algorithm. Args: arr (List[int]): A list of integers. Returns: int: The maximum sum of any contiguous subarray. Examples: >>> find_max_subarray_sum([1, -3, 2, 1, -1]) 3 >>> find_max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) 7 >>> find_max_subarray_sum([5, 4, -1, 7, 8]) 23 >>> find_max_subarray_sum([-1, -2, -3, -4]) -1 # Your implementation here def test_find_max_subarray_sum_positive_and_negative(): assert find_max_subarray_sum([1, -3, 2, 1, -1]) == 3 def test_find_max_subarray_sum_mixed(): assert find_max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7 def test_find_max_subarray_sum_all_positive(): assert find_max_subarray_sum([5, 4, -1, 7, 8]) == 23 def test_find_max_subarray_sum_all_negative(): assert find_max_subarray_sum([-1, -2, -3, -4]) == -1 def test_find_max_subarray_sum_single_element_list(): assert find_max_subarray_sum([3]) == 3 assert find_max_subarray_sum([-3]) == -3 def test_find_max_subarray_sum_small_list(): assert find_max_subarray_sum([2, 1]) == 3 assert find_max_subarray_sum([2, -1]) == 2","solution":"def find_max_subarray_sum(arr): Finds the maximum sum of any contiguous subarray within the input list of integers. Implements Kadane's Algorithm. max_ending_here = max_so_far = arr[0] for num in arr[1:]: max_ending_here = max(num, max_ending_here + num) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"def is_prime(n: int) -> bool: Returns True if n is a prime number, else False. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(5) == True >>> is_prime(10) == False >>> is_prime(13) == True >>> is_prime(1) == False >>> is_prime(0) == False >>> is_prime(-5) == False def count_primes_in_range(a: int, b: int) -> int: Counts the number of prime numbers between a and b, inclusive. >>> count_primes_in_range(1, 10) == 4 # primes are 2, 3, 5, 7 >>> count_primes_in_range(10, 20) == 4 # primes are 11, 13, 17, 19 >>> count_primes_in_range(20, 30) == 2 # primes are 23, 29 >>> count_primes_in_range(0, 0) == 0 # No primes in this range >>> count_primes_in_range(17, 17) == 1 # 17 is a prime number >>> count_primes_in_range(24, 28) == 0 # No primes in this range","solution":"def is_prime(n): Returns True if n is a prime number, else False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def count_primes_in_range(a, b): Counts the number of prime numbers between a and b, inclusive. count = 0 for num in range(a, b + 1): if is_prime(num): count += 1 return count"},{"question":"import string def longest_word_length(s: str) -> int: Returns the length of the longest word in the string \`s\`. Punctuation is ignored and case differences are not considered. >>> longest_word_length(\\"I love programming in Python\\") == 11 >>> longest_word_length(\\"I love, programming in Python!\\") == 11 >>> longest_word_length(\\"\\") == 0 >>> longest_word_length(\\"Programming\\") == 11 >>> longest_word_length(\\"Python python PYTHON programming\\") == 11 >>> longest_word_length(\\"!@#%^&*()\\") == 0","solution":"import string def longest_word_length(s): Returns the length of the longest word in the string \`s\`. Punctuation is ignored and case differences are not considered. # Remove punctuation s = s.translate(str.maketrans('', '', string.punctuation)) # Split the string into words and normalize to lowercase words = s.lower().split() # Find the longest word length max_length = 0 for word in words: if len(word) > max_length: max_length = len(word) return max_length"},{"question":"import csv from collections import defaultdict def calculate_average_grades(input_csv, output_csv): Reads an input CSV file with student grades, calculates the average grade for each student, and writes the results to an output CSV file. :param input_csv: Path to the input CSV file with student grade data :param output_csv: Path to the output CSV file to write the average grades pass # Example usage: # calculate_average_grades('input.csv', 'output.csv')","solution":"import csv from collections import defaultdict def calculate_average_grades(input_csv, output_csv): Reads an input CSV file with student grades, calculates the average grade for each student, and writes the results to an output CSV file. :param input_csv: Path to the input CSV file with student grade data :param output_csv: Path to the output CSV file to write the average grades student_grades = defaultdict(list) # Read the input CSV and aggregate grades for each student with open(input_csv, mode='r', newline='') as infile: reader = csv.reader(infile) next(reader) # Skip header for row in reader: student_id, subject, grade = row student_grades[student_id].append(float(grade)) # Calculate average grades averages = {student_id: sum(grades) / len(grades) for student_id, grades in student_grades.items()} # Write the results to the output CSV with open(output_csv, mode='w', newline='') as outfile: writer = csv.writer(outfile) writer.writerow(['student_id', 'average_grade']) for student_id, avg_grade in averages.items(): writer.writerow([student_id, avg_grade])"},{"question":"def is_alphanumeric(s: str) -> bool: Verifies if a given string contains only alphanumeric characters (letters and numbers) and no special symbols. Args: s (str): The string to be verified. Returns: bool: True if the string is purely alphanumeric, False otherwise. Examples: >>> is_alphanumeric(\\"Hello123\\") True >>> is_alphanumeric(\\"Hello 123\\") False >>> is_alphanumeric(\\"Hello@123\\") False","solution":"def is_alphanumeric(s: str) -> bool: Returns True if the string contains only alphanumeric characters (letters and numbers), otherwise False. return s.isalnum()"},{"question":"def square_evens(nums: list) -> list: Takes a list of integers and returns a list containing squares of the even integers in the same order. >>> square_evens([1, 2, 3, 4, 5]) [4, 16] >>> square_evens([10, 11, 12, 13]) [100, 144] >>> square_evens([7, 8, 9, 14, 17]) [64, 196]","solution":"def square_evens(nums: list) -> list: Takes a list of integers and returns a list containing squares of the even integers in the same order. return [x**2 for x in nums if x % 2 == 0]"},{"question":"def find_anagrams(words): Returns a dictionary where keys are words from the original list and values are lists of anagrams from the same list. >>> find_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"goo\\"]) == { ... 'listen': ['listen', 'silent', 'enlist'], ... 'silent': ['listen', 'silent', 'enlist'], ... 'enlist': ['listen', 'silent', 'enlist'], ... 'google': ['google'], ... 'goo': ['goo'] ... } >>> find_anagrams([\\"Listen\\", \\"Silent\\", \\"Enlist\\", \\"Google\\", \\"Goo\\"]) == { ... 'Listen': ['Listen', 'Silent', 'Enlist'], ... 'Silent': ['Listen', 'Silent', 'Enlist'], ... 'Enlist': ['Listen', 'Silent', 'Enlist'], ... 'Google': ['Google'], ... 'Goo': ['Goo'] ... } >>> find_anagrams([\\"apple\\", \\"banana\\", \\"carrot\\"]) == { ... 'apple': ['apple'], ... 'banana': ['banana'], ... 'carrot': ['carrot'] ... } >>> find_anagrams([]) == {} >>> find_anagrams([\\"test\\"]) == {'test': ['test']}","solution":"def find_anagrams(words): Returns a dictionary where keys are words from the original list and values are lists of anagrams from the same list. anagrams = {} for word in words: # Normalize letters to lowercase and sort sorted_word = ''.join(sorted(word.lower())) if sorted_word not in anagrams: anagrams[sorted_word] = [] anagrams[sorted_word].append(word) result = {word: anagrams[''.join(sorted(word.lower()))] for word in words} return result"},{"question":"def longest_unique_substring(s: str) -> str: Returns the longest substring without repeating characters. >>> longest_unique_substring(\\"abcabcbb\\") == \\"abc\\" >>> longest_unique_substring(\\"bbbbb\\") == \\"b\\" >>> longest_unique_substring(\\"pwwkew\\") == \\"wke\\" >>> longest_unique_substring(\\"abcdabc\\") == \\"abcd\\" >>> longest_unique_substring(\\"\\") == \\"\\" >>> longest_unique_substring(\\"a\\") == \\"a\\" >>> longest_unique_substring(\\"abcdefg\\") == \\"abcdefg\\" >>> longest_unique_substring(\\"abba\\") == \\"ab\\"","solution":"def longest_unique_substring(s): Returns the longest substring without repeating characters. if not s: return \\"\\" start = 0 max_len = 0 max_substr = \\"\\" used_char = {} for index, char in enumerate(s): if char in used_char and start <= used_char[char]: start = used_char[char] + 1 else: current_len = index - start + 1 if current_len > max_len: max_len = current_len max_substr = s[start:index + 1] used_char[char] = index return max_substr"},{"question":"def most_frequent_char(s: str) -> str: Create a function that takes a string as input and returns the most frequent character in the string. In case of a tie, return the character that appears first in the string. You may assume that the input string will contain at least one character. Examples: >>> most_frequent_char(\\"hello\\") 'l' >>> most_frequent_char(\\"aabbbcccc\\") 'c'","solution":"def most_frequent_char(s: str) -> str: Returns the most frequent character in the string s. In case of a tie, returns the character that appears first. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Find the character with the maximum frequency # In case of a tie, the one that appears first in the string will be chosen most_frequent = max(char_count, key=lambda char: (char_count[char], -s.index(char))) return most_frequent"},{"question":"def rotate_matrix(matrix): Rotates a given N x N matrix by 90 degrees clockwise in-place. :param matrix: List of lists representing the NxN matrix >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) >>> matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix = [ ... [1, 2], ... [3, 4] ... ] >>> rotate_matrix(matrix) >>> matrix [[3, 1], [4, 2]] >>> matrix = [ ... [1] ... ] >>> rotate_matrix(matrix) >>> matrix [[1]]","solution":"def rotate_matrix(matrix): Rotates a given N x N matrix by 90 degrees clockwise in-place. :param matrix: List of lists representing the NxN matrix n = len(matrix) for layer in range(n // 2): first = layer last = n - layer - 1 for i in range(first, last): offset = i - first # save top top = matrix[first][i] # left -> top matrix[first][i] = matrix[last - offset][first] # bottom -> left matrix[last - offset][first] = matrix[last][last - offset] # right -> bottom matrix[last][last - offset] = matrix[i][last] # top -> right matrix[i][last] = top"},{"question":"from typing import List def compress_string(input_string: str) -> str: Compresses the input_string using Run-Length Encoding (RLE). >>> compress_string('aaabbccccd') 'a3b2c4d' >>> compress_string('abcd') 'abcd' >>> compress_string('aabbcc') 'a2b2c2' >>> compress_string('') '' >>> compress_string('a') 'a' pass def decompress_string(encoded_string: str) -> str: Decompresses the encoded_string using Run-Length Encoding (RLE). >>> decompress_string('a3b2c4d') 'aaabbccccd' >>> decompress_string('abcd') 'abcd' >>> decompress_string('a2b2c2') 'aabbcc' >>> decompress_string('') '' >>> decompress_string('a1') 'a' pass if __name__ == \\"__main__\\": input_string = 'aaabbccccd' expected_output = 'a3b2c4d' assert compress_string(input_string) == expected_output input_string = 'abcd' expected_output = 'abcd' assert compress_string(input_string) == expected_output encoded_string = 'a3b2c4d' expected_output = 'aaabbccccd' assert decompress_string(encoded_string) == expected_output encoded_string = 'abcd' expected_output = 'abcd' assert decompress_string(encoded_string) == expected_output","solution":"def compress_string(input_string: str) -> str: Compresses the input_string using Run-Length Encoding (RLE). if not input_string: return \\"\\" compressed = [] current_char = input_string[0] count = 1 for char in input_string[1:]: if char == current_char: count += 1 else: if count > 1: compressed.append(f\\"{current_char}{count}\\") else: compressed.append(current_char) current_char = char count = 1 if count > 1: compressed.append(f\\"{current_char}{count}\\") else: compressed.append(current_char) return ''.join(compressed) def decompress_string(encoded_string: str) -> str: Decompresses the encoded_string using Run-Length Encoding (RLE). if not encoded_string: return \\"\\" decompressed = [] i = 0 while i < len(encoded_string): char = encoded_string[i] i += 1 count = 1 # If no digit follows, the count is implicitly 1 if i < len(encoded_string) and encoded_string[i].isdigit(): count_str = [] while i < len(encoded_string) and encoded_string[i].isdigit(): count_str.append(encoded_string[i]) i += 1 count = int(''.join(count_str)) decompressed.append(char * count) return ''.join(decompressed)"},{"question":"from typing import List, Dict def recommend_content(user_id: int, users: List[Dict], content: List[Dict], num_recommendations: int = 5) -> List[str]: Recommends content based on user preferences and viewing history. :param user_id: The ID of the user for whom recommendations are being generated. :param users: List of users with viewing history. :param content: List of available content with metadata. :param num_recommendations: Number of recommendations to generate. :return: List of recommended content titles. >>> users = [ >>> {\\"user_id\\": 1, \\"name\\": \\"Alice\\", \\"viewing_history\\": [\\"Movie A\\", \\"Movie C\\", \\"TV Show B\\"]}, >>> {\\"user_id\\": 2, \\"name\\": \\"Bob\\", \\"viewing_history\\": [\\"Movie B\\", \\"Movie D\\", \\"TV Show A\\"]}, >>> {\\"user_id\\": 3, \\"name\\": \\"Carol\\", \\"viewing_history\\": [\\"Movie A\\", \\"Movie E\\", \\"TV Show C\\"]}, >>> ] >>> content = [ >>> {\\"title\\": \\"Movie A\\", \\"genre\\": \\"Action\\", \\"actors\\": [\\"Actor 1\\", \\"Actor 2\\"], \\"director\\": \\"Director 1\\", \\"release_year\\": 2020, \\"ratings\\": 4.5}, >>> {\\"title\\": \\"Movie B\\", \\"genre\\": \\"Comedy\\", \\"actors\\": [\\"Actor 3\\", \\"Actor 4\\"], \\"director\\": \\"Director 2\\", \\"release_year\\": 2019, \\"ratings\\": 3.8}, >>> {\\"title\\": \\"Movie C\\", \\"genre\\": \\"Drama\\", \\"actors\\": [\\"Actor 1\\", \\"Actor 5\\"], \\"director\\": \\"Director 3\\", \\"release_year\\": 2021, \\"ratings\\": 4.7}, >>> {\\"title\\": \\"Movie D\\", \\"genre\\": \\"Action\\", \\"actors\\": [\\"Actor 2\\", \\"Actor 6\\"], \\"director\\": \\"Director 1\\", \\"release_year\\": 2018, \\"ratings\\": 4.2}, >>> {\\"title\\": \\"Movie E\\", \\"genre\\": \\"Horror\\", \\"actors\\": [\\"Actor 7\\", \\"Actor 8\\"], \\"director\\": \\"Director 4\\", \\"release_year\\": 2022, \\"ratings\\": 3.9}, >>> {\\"title\\": \\"TV Show A\\", \\"genre\\": \\"Comedy\\", \\"actors\\": [\\"Actor 3\\", \\"Actor 4\\"], \\"director\\": \\"Director 2\\", \\"release_year\\": 2019, \\"ratings\\": 4.0}, >>> {\\"title\\": \\"TV Show B\\", \\"genre\\": \\"Drama\\", \\"actors\\": [\\"Actor 5\\", \\"Actor 9\\"], \\"director\\": \\"Director 3\\", \\"release_year\\": 2020, \\"ratings\\": 4.6}, >>> {\\"title\\": \\"TV Show C\\", \\"genre\\": \\"Action\\", \\"actors\\": [\\"Actor 1\\", \\"Actor 10\\"], \\"director\\": \\"Director 5\\", \\"release_year\\": 2021, \\"ratings\\": 4.1}, >>> ] >>> recommend_content(1, users, content, num_recommendations=3) [ ... recommendations for user with ID 1 ... ]","solution":"from collections import Counter from typing import List, Dict def recommend_content(user_id: int, users: List[Dict], content: List[Dict], num_recommendations: int = 5): Recommends content based on user preferences and viewing history. :param user_id: The ID of the user for whom recommendations are being generated. :param users: List of users with viewing history. :param content: List of available content with metadata. :param num_recommendations: Number of recommendations to generate. :return: List of recommended content titles. # Find the user user = next(user for user in users if user[\\"user_id\\"] == user_id) # Extract genres, actors, and directors from viewing history genres = [] actors = [] directors = [] for title in user[\\"viewing_history\\"]: for c in content: if c[\\"title\\"] == title: genres.append(c[\\"genre\\"]) actors += c[\\"actors\\"] directors.append(c[\\"director\\"]) # Create counters for genres, actors, and directors genre_counter = Counter(genres) actor_counter = Counter(actors) director_counter = Counter(directors) # Score content based on user preferences content_scores = [] for c in content: score = 0 if c[\\"title\\"] not in user[\\"viewing_history\\"]: score += genre_counter[c[\\"genre\\"]] * 5 score += sum(actor_counter[actor] * 3 for actor in c[\\"actors\\"]) score += director_counter[c[\\"director\\"]] * 2 score += c[\\"ratings\\"] content_scores.append((score, c[\\"title\\"])) # Sort content by scores and return the top recommendations content_scores.sort(reverse=True, key=lambda x: x[0]) recommended_titles = [title for _, title in content_scores[:num_recommendations]] return recommended_titles"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression with + and - operators only. :param expression: str : The expression to be evaluated (e.g., \\"3 + 5 - 2 + 8\\") :return: int : The result of the expression, or an error message if the expression is invalid pass # Test cases def test_evaluate_expression_simple(): assert evaluate_expression(\\"3+5-2+8\\") == 14 def test_evaluate_expression_with_whitespace(): assert evaluate_expression(\\" 3 + 5 - 2 + 8 \\") == 14 def test_evaluate_expression_only_whitespace(): assert evaluate_expression(\\" \\") == \\"Error: Invalid expression\\" def test_evaluate_expression_invalid_characters(): assert evaluate_expression(\\"3&5-2+8\\") == \\"Error: Invalid characters in the expression\\" def test_evaluate_expression_with_multiple_whitespace(): assert evaluate_expression(\\" 3 + 5 - 2+ 8 \\") == 14 def test_evaluate_expression_invalid_symbols(): assert evaluate_expression(\\"3+5-2+8*2\\") == \\"Error: Invalid characters in the expression\\" def test_evaluate_expression_with_no_operators(): assert evaluate_expression(\\"35\\") == 35 def test_evaluate_expression_with_empty_string(): assert evaluate_expression(\\"\\") == \\"Error: Invalid expression\\" def test_evaluate_expression_with_negative_numbers(): assert evaluate_expression(\\"5-10+3\\") == -2 def test_evaluate_expression_invalid_start_character(): assert evaluate_expression(\\"+5-3\\") == 2 # should work as integers typically accept leading + in Python def test_evaluate_expression_invalid_end_character(): assert evaluate_expression(\\"5+5-\\") == \\"Error: Invalid expression\\"","solution":"def evaluate_expression(expression): Evaluates a mathematical expression with + and - operators only. :param expression: str : The expression to be evaluated (e.g., \\"3 + 5 - 2 + 8\\") :return: int : The result of the expression, or an error message if the expression is invalid try: # Remove whitespace from the expression expression = expression.replace(\\" \\", \\"\\") # Validate the cleaned expression if not all(char.isdigit() or char in '+-' for char in expression): return \\"Error: Invalid characters in the expression\\" # Evaluate the expression result = eval(expression) return result if isinstance(result, int) else \\"Error: Evaluation did not return an integer\\" except: return \\"Error: Invalid expression\\""},{"question":"def longest_subarray_with_sum(arr: List[int], S: int) -> List[int]: Write a Python function that takes a list of integers and returns the longest contiguous subarray that sums up to a given number \`S\`. If there are multiple subarrays with the same maximum length, return the one that appears first. If no such subarray exists, return an empty list. >>> longest_subarray_with_sum([1, 2, 3, 7, 5], 12) [2, 3, 7] >>> longest_subarray_with_sum([1, 2, 3, 4, 5, 6, 7, 8, 9], 15) [1, 2, 3, 4, 5] >>> longest_subarray_with_sum([1, 2, 3, 4, 5], 20) [] >>> longest_subarray_with_sum([1, 2, 3, 4, 5], 15) [1, 2, 3, 4, 5] >>> longest_subarray_with_sum([], 1) [] >>> longest_subarray_with_sum([4], 4) [4] >>> longest_subarray_with_sum([4], 5) []","solution":"def longest_subarray_with_sum(arr, S): Returns the longest contiguous subarray that sums up to a given number S. max_length = 0 start_index = 0 curr_sum = 0 sum_dict = {} for i in range(len(arr)): curr_sum += arr[i] if curr_sum == S: if i + 1 > max_length: max_length = i + 1 start_index = 0 if curr_sum - S in sum_dict: if i - sum_dict[curr_sum - S] > max_length: max_length = i - sum_dict[curr_sum - S] start_index = sum_dict[curr_sum - S] + 1 if curr_sum not in sum_dict: sum_dict[curr_sum] = i if max_length == 0: return [] return arr[start_index:start_index + max_length]"},{"question":"from typing import List, Tuple, Optional def most_frequent_and_second_most_frequent(numbers: List[int]) -> Tuple[Optional[int], Optional[int]]: Returns the most frequently occurring integer in the sequence and, if there are ties (multiple numbers with the same highest frequency), it returns the smallest integer among them. It also returns the second most frequently occurring integer. >>> most_frequent_and_second_most_frequent([1, 1, 1, 1]) (1, None) >>> most_frequent_and_second_most_frequent([1, 2, 3, 4]) (1, 2) >>> most_frequent_and_second_most_frequent([4, 4, 2, 2, 1]) (2, 4) >>> most_frequent_and_second_most_frequent([4, 4, 2, 2, 1, 1, 1, 3, 3, 3]) (1, 3) >>> most_frequent_and_second_most_frequent([0, 0, -1, -1, -2, -2, -1, 0]) (-1, 0) >>> most_frequent_and_second_most_frequent([]) (None, None) >>> most_frequent_and_second_most_frequent([1]) (1, None)","solution":"from collections import Counter def most_frequent_and_second_most_frequent(numbers): Returns the most frequently occurring integer in the sequence and even there are ties (multiple numbers with the same highest frequency), it returns the smallest integer among them. It also returns the second most frequently occurring integer. if not numbers: return None, None count = Counter(numbers) most_common = count.most_common() # Find the most frequent max_count = most_common[0][1] candidates = [num for num, freq in most_common if freq == max_count] most_frequent = min(candidates) # Find the second most frequent if len(most_common) > 1: second_max_count = most_common[1][1] second_candidates = [num for num, freq in most_common if freq == second_max_count] if second_max_count != max_count: second_most_frequent = min(second_candidates) else: second_most_frequent = min([num for num in second_candidates if num != most_frequent]) else: second_most_frequent = None return most_frequent, second_most_frequent"},{"question":"import re def is_palindrome(s: str) -> bool: Checks if the given string is a palindrome, ignoring spaces, punctuation, and case differences. >>> is_palindrome('') == True >>> is_palindrome('a') == True >>> is_palindrome('AibohPhoBiA') == True >>> is_palindrome('A man a plan a canal Panama') == True >>> is_palindrome('No lemon, no melon') == True >>> is_palindrome('Hello World') == False","solution":"import re def is_palindrome(s): Checks if the given string is a palindrome, ignoring spaces, punctuation, and case differences. Parameters: s (str): the string to check. Returns: bool: True if s is a palindrome, False otherwise. # Remove non-alphanumeric characters and convert to lowercase cleaned_s = re.sub(r'[^A-Za-z0-9]', '', s).lower() # Check if the string is equal to its reverse return cleaned_s == cleaned_s[::-1]"},{"question":"def max_sum_of_k_consecutive_elements(arr: List[int], k: int) -> int: Returns the maximum sum of k consecutive elements in the array. If the length of the array is less than k, it returns 0. >>> max_sum_of_k_consecutive_elements([1, 4, 2, 10, 23, 3, 1, 0, 20], 4) == 39 >>> max_sum_of_k_consecutive_elements([1, 2, 3], 4) == 0 >>> max_sum_of_k_consecutive_elements([5, 1, 9, 3], 4) == 18 >>> max_sum_of_k_consecutive_elements([1, 2, 3, 4, 5], 0) == 0 >>> max_sum_of_k_consecutive_elements([7, 3, 5, 6, 2], 1) == 7 >>> max_sum_of_k_consecutive_elements([], 3) == 0 >>> max_sum_of_k_consecutive_elements([-1, -2, -3, -4, -5], 2) == -3 >>> max_sum_of_k_consecutive_elements([1, -2, 3, 4, -1, 2, 1, -5, 4], 3) == 6 pass","solution":"def max_sum_of_k_consecutive_elements(arr, k): Returns the maximum sum of k consecutive elements in the array. If the length of the array is less than k, it returns 0. n = len(arr) if n < k: return 0 max_sum = sum(arr[:k]) current_sum = max_sum for i in range(k, n): current_sum += arr[i] - arr[i-k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"class Rectangle: def __init__(self, length: int, width: int): Initialize the rectangle with length and width. self.length = length self.width = width def area(self) -> int: Calculate the area of the rectangle. def perimeter(self) -> int: Calculate the perimeter of the rectangle. def is_square(self) -> bool: Check if the rectangle is a square. def scale(self, factor: float): Scale the size of the rectangle by a given factor. The factor must be a positive non-zero number.","solution":"class Rectangle: def __init__(self, length, width): self.length = length self.width = width def area(self): return self.length * self.width def perimeter(self): return 2 * (self.length + self.width) def is_square(self): return self.length == self.width def scale(self, factor): if factor > 0: self.length *= factor self.width *= factor else: return \\"Factor must be a positive non-zero number\\" # Demonstration rect = Rectangle(4, 2) print(\\"Is square:\\", rect.is_square()) rect.scale(2) print(\\"Scaled length:\\", rect.length) print(\\"Scaled width:\\", rect.width) print(\\"Area:\\", rect.area()) print(\\"Perimeter:\\", rect.perimeter())"},{"question":"def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: Merges two pre-sorted lists of integers into a single sorted list. >>> merge_sorted_lists([], []) == [] >>> merge_sorted_lists([], [1, 2, 3]) == [1, 2, 3] >>> merge_sorted_lists([5, 6, 7], []) == [5, 6, 7] >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([1, 3, 5], [1, 4, 5]) == [1, 1, 3, 4, 5, 5] >>> merge_sorted_lists([1, 2, 2, 3], [2, 4]) == [1, 2, 2, 2, 3, 4] >>> merge_sorted_lists([1, 2, 3, 4, 5, 6], [3, 4, 5]) == [1, 2, 3, 3, 4, 4, 5, 5, 6] >>> merge_sorted_lists([3, 4, 5], [1, 2, 3, 4, 5, 6]) == [1, 2, 3, 3, 4, 4, 5, 5, 6]","solution":"def merge_sorted_lists(list1, list2): Merges two pre-sorted lists of integers into a single sorted list. merged_list = [] i, j = 0, 0 # Traverse both lists and insert smaller value from list1 or list2 while i < len(list1) and j < len(list2): if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # If there are remaining elements in list1 while i < len(list1): merged_list.append(list1[i]) i += 1 # If there are remaining elements in list2 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"def is_strictly_increasing(sequence: List[int]) -> bool: Check if the given list of integers is a strictly increasing sequence. Args: sequence (list): A list of integers. Returns: bool: True if the sequence is strictly increasing, False otherwise. Examples: >>> is_strictly_increasing([]) False >>> is_strictly_increasing([1]) False >>> is_strictly_increasing([1, 2, 3, 4, 5]) True >>> is_strictly_increasing([1, 2, 3, 3, 5]) False >>> is_strictly_increasing([5, 4, 3, 2, 1]) False >>> is_strictly_increasing([-1, 0, 2, 3]) True >>> is_strictly_increasing([-5, -4, -3, -2, -1]) True >>> is_strictly_increasing([0, 1]) True >>> is_strictly_increasing([2, 2]) False","solution":"def is_strictly_increasing(sequence): Check if the given list of integers is a strictly increasing sequence. Args: sequence (list): A list of integers. Returns: bool: True if the sequence is strictly increasing, False otherwise. # An empty list or a list with one element is not strictly increasing if len(sequence) <= 1: return False # Check if every element is less than the next one in the sequence for i in range(len(sequence) - 1): if sequence[i] >= sequence[i+1]: return False return True"},{"question":"def find_anagrams(words: List[str], target: str) -> List[str]: Create a function that takes a list of strings and a target string, and returns a list of all strings from the input list that are anagrams of the target string. It should handle case sensitivity, spaces, and punctuation. >>> find_anagrams(['listen', 'enlist', 'google', 'inlets', 'banana'], 'silent') ['listen', 'enlist', 'inlets'] >>> find_anagrams(['Listen!', 'enlist.', 'Google,', 'inlets ', 'B@NANA'], 'silent!!') ['Listen!', 'enlist.', 'inlets '] >>> find_anagrams(['Listen', 'ENLIST', 'googLe', 'InLeTs', 'Banana'], 'Silent') ['Listen', 'ENLIST', 'InLeTs'] >>> find_anagrams(['cat', 'dog', 'bird'], 'silent') [] >>> find_anagrams([], 'silent') [] >>> find_anagrams(['listen', 'enlist', 'inlets'], '') []","solution":"import re from collections import Counter def clean_string(s): Cleans the input string by removing spaces, punctuation, and converting to lowercase. return ''.join(re.findall(r'w', s)).lower() def find_anagrams(words, target): Returns a list of all strings from the input list that are anagrams of the target string. cleaned_target = clean_string(target) target_counter = Counter(cleaned_target) anagrams = [] for word in words: if Counter(clean_string(word)) == target_counter: anagrams.append(word) return anagrams"},{"question":"def count_characters(s: str) -> dict: Takes in a string and returns a dictionary where keys are the characters and values are the counts of each character's occurrences. Ignores spaces and is case-insensitive. >>> count_characters(\\"Hello World\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> count_characters(\\"\\") {} >>> count_characters(\\" H e l l o \\") {'h': 1, 'e': 1, 'l': 2, 'o': 1} >>> count_characters(\\"aA\\") {'a': 2} >>> count_characters(\\"Hello HelLo WoRlD\\") {'h': 2, 'e': 2, 'l': 5, 'o': 3, 'w': 1, 'r': 1, 'd': 1}","solution":"def count_characters(s): Takes in a string and returns a dictionary where keys are the characters and values are the counts of each character's occurrences. Ignores spaces and is case-insensitive. s = s.replace(\\" \\", \\"\\").lower() char_dict = {} for char in s: if char in char_dict: char_dict[char] += 1 else: char_dict[char] = 1 return char_dict"},{"question":"class InventoryManagementSystem: A simple inventory management system for a warehouse. Allows adding, deleting, updating, and displaying items. >>> ims = InventoryManagementSystem() >>> ims.add_item(\\"001\\", \\"ItemA\\", 100, 20.5) 'Item added successfully.' >>> ims.add_item(\\"001\\", \\"ItemB\\", 50, 15.0) 'Item code already exists.' >>> ims.delete_item(\\"001\\") 'Item deleted successfully.' >>> ims.delete_item(\\"002\\") 'Item code does not exist.' >>> ims.update_item(\\"001\\", 200, 25.0) 'Item updated successfully.' >>> ims.update_item(\\"002\\", 100, 15.0) 'Item code does not exist.' >>> ims.display_items() {'ItemCode1': {'ItemName': 'ItemA', 'Quantity': 100, 'Price': 20.5}} def __init__(self): self.inventory = {} def add_item(self, item_code, item_name, quantity, price): pass def delete_item(self, item_code): pass def update_item(self, item_code, quantity=None, price=None): pass def display_items(self): pass def test_add_item(): ims = InventoryManagementSystem() assert ims.add_item(\\"001\\", \\"ItemA\\", 100, 20.5) == \\"Item added successfully.\\" assert ims.add_item(\\"001\\", \\"ItemB\\", 50, 15.0) == \\"Item code already exists.\\" def test_delete_item(): ims = InventoryManagementSystem() ims.add_item(\\"001\\", \\"ItemA\\", 100, 20.5) assert ims.delete_item(\\"001\\") == \\"Item deleted successfully.\\" assert ims.delete_item(\\"002\\") == \\"Item code does not exist.\\" def test_update_item(): ims = InventoryManagementSystem() ims.add_item(\\"001\\", \\"ItemA\\", 100, 20.5) assert ims.update_item(\\"001\\", 200, 25.0) == \\"Item updated successfully.\\" assert ims.update_item(\\"002\\", 100, 15.0) == \\"Item code does not exist.\\" assert ims.inventory[\\"001\\"][\\"Quantity\\"] == 200 assert ims.inventory[\\"001\\"][\\"Price\\"] == 25.0 def test_display_items(): ims = InventoryManagementSystem() ims.add_item(\\"001\\", \\"ItemA\\", 100, 20.5) ims.add_item(\\"002\\", \\"ItemB\\", 200, 30.0) inventory = ims.display_items() assert inventory[\\"001\\"][\\"ItemName\\"] == \\"ItemA\\" assert inventory[\\"002\\"][\\"Price\\"] == 30.0","solution":"class InventoryManagementSystem: def __init__(self): self.inventory = {} def add_item(self, item_code, item_name, quantity, price): if item_code in self.inventory: return \\"Item code already exists.\\" self.inventory[item_code] = { \\"ItemName\\": item_name, \\"Quantity\\": quantity, \\"Price\\": price } return \\"Item added successfully.\\" def delete_item(self, item_code): if item_code not in self.inventory: return \\"Item code does not exist.\\" del self.inventory[item_code] return \\"Item deleted successfully.\\" def update_item(self, item_code, quantity=None, price=None): if item_code not in self.inventory: return \\"Item code does not exist.\\" if quantity is not None: self.inventory[item_code][\\"Quantity\\"] = quantity if price is not None: self.inventory[item_code][\\"Price\\"] = price return \\"Item updated successfully.\\" def display_items(self): return self.inventory"},{"question":"def number_generator(): Yield numbers from 1 to 5 using a generator. >>> list(number_generator()) [1, 2, 3, 4, 5] for i in range(1, 6): yield i def number_list(): Return a list of numbers from 1 to 5. >>> number_list() [1, 2, 3, 4, 5] from solution import number_generator, number_list def test_number_generator(): gen = number_generator() result = [num for num in gen] assert result == [1, 2, 3, 4, 5] def test_number_list(): result = number_list() assert result == [1, 2, 3, 4, 5] def test_number_generator_empty(): empty_gen = number_generator() for _ in range(5): # Exhaust the generator next(empty_gen) # If we now convert to list, it should be empty since generator is exhausted assert list(empty_gen) == [] def test_generator_vs_list_comparison(): gen_result = list(number_generator()) list_result = number_list() assert gen_result == list_result","solution":"def number_generator(): for i in range(1, 6): yield i def number_list(): return [i for i in range(1, 6)]"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression string which can include integers, +, -, *, / operations, and parentheses. Raises appropriate errors in case of invalid expressions. >>> evaluate_expression(\\"3+5\\") == 8 >>> evaluate_expression(\\"10-2\\") == 8 >>> evaluate_expression(\\"4*3\\") == 12 >>> evaluate_expression(\\"12/4\\") == 3 >>> evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\") == 23 >>> evaluate_expression(\\"3+5*2\\") == 13 >>> evaluate_expression(\\"100/(2*5)\\") == 10 >>> evaluate_expression(\\"(3+5\\") raises IndexError >>> evaluate_expression(\\"10 / 0\\") raises ZeroDivisionError pass","solution":"def evaluate_expression(expression): Evaluates a mathematical expression string which can include integers, +, -, *, / operations, and parentheses. import operator import re def parse_expression(expression): tokens = re.findall(r'd+|[+/*()-]', expression) return tokens def precedence(op): if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 return 0 def apply_operation(operands, operators): right = operands.pop() left = operands.pop() op = operators.pop() if op == '+': operands.append(operator.add(left, right)) elif op == '-': operands.append(operator.sub(left, right)) elif op == '*': operands.append(operator.mul(left, right)) elif op == '/': if right == 0: raise ZeroDivisionError(\\"Division by zero.\\") operands.append(operator.truediv(left, right)) def evaluate(tokens): operands = [] operators = [] i = 0 while i < len(tokens): token = tokens[i] if token.isdigit(): operands.append(int(token)) i += 1 elif token == '(': operators.append(token) i += 1 elif token == ')': while operators and operators[-1] != '(': apply_operation(operands, operators) operators.pop() i += 1 else: while (operators and operators[-1] != '(' and precedence(operators[-1]) >= precedence(token)): apply_operation(operands, operators) operators.append(token) i += 1 while operators: apply_operation(operands, operators) return operands[0] tokens = parse_expression(expression) return evaluate(tokens)"},{"question":"def is_valid_bracket_sequence(s: str) -> bool: Returns True if the input string contains a valid sequence of brackets, and False otherwise. >>> is_valid_bracket_sequence(\\"()\\") == True >>> is_valid_bracket_sequence(\\"(){}[]\\") == True >>> is_valid_bracket_sequence(\\"{[()]}\\") == True >>> is_valid_bracket_sequence(\\"\\") == True >>> is_valid_bracket_sequence(\\"(]\\") == False >>> is_valid_bracket_sequence(\\"([)]\\") == False >>> is_valid_bracket_sequence(\\"{[}\\") == False >>> is_valid_bracket_sequence(\\"((((\\") == False >>> is_valid_bracket_sequence(\\"a(b)c\\") == True >>> is_valid_bracket_sequence(\\"[a+b*(c-d)]\\") == True >>> is_valid_bracket_sequence(\\"a{b[c)d]\\") == False >>> is_valid_bracket_sequence(\\"a{b(c]d}e\\") == False","solution":"def is_valid_bracket_sequence(s: str) -> bool: Returns True if the input string contains a valid sequence of brackets, and False otherwise. stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_map.values(): stack.append(char) elif char in bracket_map.keys(): if stack == [] or bracket_map[char] != stack.pop(): return False else: continue return stack == []"},{"question":"def can_attend_all_meetings(intervals: list[tuple[int, int]]) -> bool: Determine if a person can attend all meetings without overlap. Args: intervals (list of tuple): A list of meeting time intervals Returns: bool: True if a person can attend all the meetings without overlap, else False Example: >>> can_attend_all_meetings([(1, 3), (2, 4), (5, 6)]) False >>> can_attend_all_meetings([(1, 3), (4, 5), (6, 7)]) True >>> can_attend_all_meetings([(1, 2), (2, 3), (3, 4)]) True >>> can_attend_all_meetings([(1, 2)]) True >>> can_attend_all_meetings([]) True >>> can_attend_all_meetings([(1, 5), (5, 6), (6.01, 7)]) True >>> can_attend_all_meetings([(1, 2), (2, 4), (2, 3)]) False","solution":"def can_attend_all_meetings(intervals): Determine if a person can attend all meetings without overlap. Args: intervals (list of tuple): A list of meeting time intervals Returns: bool: True if a person can attend all the meetings without overlap, else False # Sort intervals by the start time intervals.sort(key=lambda x: x[0]) for i in range(len(intervals) - 1): # If the end time of the current meeting is greater than the start time # of the next meeting, they overlap. if intervals[i][1] > intervals[i + 1][0]: return False return True"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given a list of integers, returns a list where each element is the product of all other elements except for the element at that position. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 5, 9]) [45, 18, 10] >>> product_except_self([1, -2, 3, -4]) [24, -12, 8, -6]","solution":"def product_except_self(nums): Given a list of integers, returns a list where each element is the product of all other elements except for the element at that position. n = len(nums) # Initialize the result array with ones result = [1] * n # Calculate products of elements to the left of each element left_product = 1 for i in range(n): result[i] = left_product left_product *= nums[i] # Calculate products of elements to the right of each element and multiply with the left products right_product = 1 for i in range(n-1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"def find_second_highest(numbers: List[int]) -> Optional[int]: Given an unsorted list of integers, return the second-highest unique value in the list. If the list contains less than two unique values, return None. Fix the issue in the provided erroneous code. Should implement own sorting without using sorted(). >>> find_second_highest([45, 23, 12, 67, 45, 23, 99]) == 67 >>> find_second_highest([1, 1, 1, 1, 1]) == None >>> find_second_highest([10, 10, 20]) == 10 >>> find_second_highest([5]) == None >>> find_second_highest([5, -2, -3, 5, -2]) == -2","solution":"def find_second_highest(numbers): Returns the second-highest unique value in the list. If the list contains less than two unique values, returns None. unique_numbers = list(set(numbers)) for i in range(len(unique_numbers)): for j in range(0, len(unique_numbers) - i - 1): if unique_numbers[j] > unique_numbers[j + 1]: unique_numbers[j], unique_numbers[j + 1] = unique_numbers[j + 1], unique_numbers[j] if len(unique_numbers) < 2: return None else: return unique_numbers[-2]"},{"question":"def evaluate(expression: str) -> int: Evaluates an algebraic expression containing integers, +, and * operators. Respects standard operator precedence (multiplication before addition). >>> evaluate(\\"2+3\\") == 5 >>> evaluate(\\"2*3\\") == 6 >>> evaluate(\\"2+3*4\\") == 14 >>> evaluate(\\"2*3+4\\") == 10 >>> evaluate(\\"1+2*3+4*5+6\\") == 1 + 6 + 20 + 6 >>> evaluate(\\"3*2*2+1+4*3\\") == 12 + 1 + 12","solution":"def evaluate(expression): Evaluates an algebraic expression containing integers, +, and * operators. Respects standard operator precedence (multiplication before addition). def evaluate_multiplication(expression): parts = expression.split('*') result = 1 for part in parts: result *= int(part) return result add_parts = expression.split('+') total = 0 for part in add_parts: if '*' in part: total += evaluate_multiplication(part) else: total += int(part) return total"},{"question":"from typing import List def sort_by_vowel_count(strings: List[str]) -> List[str]: Write a function that takes a list of strings and returns a new list with the strings sorted by the number of vowels they contain, in descending order. In the case of a tie (when two strings have the same number of vowels), maintain the relative order of those strings as they appeared in the input list. >>> sort_by_vowel_count([\\"hello\\", \\"world\\", \\"python\\", \\"programming\\"]) [\\"programming\\", \\"hello\\", \\"world\\", \\"python\\"] >>> sort_by_vowel_count([\\"abc\\", \\"xyz\\", \\"a\\", \\"b\\"]) [\\"abc\\", \\"a\\", \\"xyz\\", \\"b\\"] >>> sort_by_vowel_count([\\"abc\\", \\"def\\", \\"ghi\\", \\"jkl\\"]) [\\"abc\\", \\"def\\", \\"ghi\\", \\"jkl\\"] >>> sort_by_vowel_count([\\"brr\\", \\"tsk\\", \\"rhythm\\"]) [\\"brr\\", \\"tsk\\", \\"rhythm\\"] >>> sort_by_vowel_count([]) [] >>> sort_by_vowel_count([\\"example\\"]) [\\"example\\"]","solution":"def sort_by_vowel_count(strings): def count_vowels(s): return sum(1 for char in s if char in 'aeiouAEIOU') return sorted(strings, key=lambda s: (-count_vowels(s), strings.index(s)))"},{"question":"from typing import List def knapsack(weights: List[int], values: List[int], capacity: int) -> int: Solves the knapsack problem using dynamic programming. Parameters: weights (list of int): Weights of the items. values (list of int): Values of the items. capacity (int): Maximum weight the knapsack can carry. Returns: int: Maximum value that can be carried by the knapsack. >>> knapsack([1, 3, 4, 5], [1, 4, 5, 7], 7) 9 >>> knapsack([1, 3, 4, 5], [1, 4, 5, 7], 0) 0 >>> knapsack([], [], 10) 0 >>> knapsack([2], [3], 2) 3 >>> knapsack([3], [4], 2) 0 >>> knapsack([5, 4, 6, 3], [10, 40, 30, 50], 10) 90","solution":"def knapsack(weights, values, capacity): Solves the knapsack problem using dynamic programming. Parameters: weights (list of int): Weights of the items. values (list of int): Values of the items. capacity (int): Maximum weight the knapsack can carry. Returns: int: Maximum value that can be carried by the knapsack. n = len(weights) dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)] for i in range(1, n + 1): for w in range(capacity + 1): if weights[i - 1] <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1]) else: dp[i][w] = dp[i - 1][w] return dp[n][capacity]"},{"question":"from typing import List def find_palindromes(start: int, end: int) -> List[int]: Generate a list of all palindromic numbers within a given range [start, end]. Parameters: start (int): The start of the range. end (int): The end of the range. Returns: List[int]: A list containing all palindromic numbers within the range. Example: >>> find_palindromes(100, 150) [101, 111, 121, 131, 141] >>> find_palindromes(500, 600) [505, 515, 525, 535, 545, 555, 565, 575, 585, 595]","solution":"from typing import List def find_palindromes(start: int, end: int) -> List[int]: Returns a list of all palindromic numbers within the range [start, end], inclusive. palindromes = [] for number in range(start, end + 1): if str(number) == str(number)[::-1]: palindromes.append(number) return palindromes"},{"question":"def most_frequent(lst): Returns the most frequently occurring element in the given list. If there is a tie, returns any one of the most frequent elements. If the list is empty, returns None. >>> most_frequent([1, 2, 2, 'a', 'b', 'a']) in [2, 'a'] True >>> most_frequent([4, 4, 'test', 'test']) in [4, 'test'] True >>> most_frequent([]) is None True >>> most_frequent(['x']) == 'x' True >>> most_frequent([1, 2, 3]) in [1, 2, 3] True","solution":"from collections import Counter def most_frequent(lst): Returns the most frequently occurring element in the given list. If there is a tie, returns any one of the most frequent elements. If the list is empty, returns None. if not lst: return None counter = Counter(lst) max_count = max(counter.values()) return next(item for item, count in counter.items() if count == max_count)"},{"question":"def k_most_frequent_strings(strings: List[str], k: int) -> List[str]: Returns a list of the k most frequent strings in descending order of frequency. In case of a tie, the strings are sorted alphabetically. Parameters: strings (List[str]): A list of strings k (int): Number of most frequent strings to return Returns: List[str]: list of the k most frequent strings in descending order of frequency >>> k_most_frequent_strings([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\", \\"kiwi\\"], 2) ['apple', 'banana'] >>> k_most_frequent_strings([\\"apple\\", \\"apple\\", \\"banana\\"], 1) ['apple']","solution":"def k_most_frequent_strings(strings, k): Returns a list of the k most frequent strings in descending order of frequency. In case of a tie, the strings are sorted alphabetically. Parameters: strings (List[str]): A list of strings k (int): Number of most frequent strings to return Returns: List[str]: list of the k most frequent strings in descending order of frequency # Count the frequency of each string frequency = {} for string in strings: if string in frequency: frequency[string] += 1 else: frequency[string] = 1 # Convert frequency dictionary to a list of tuples and sort sorted_strings = sorted(frequency.items(), key=lambda item: (-item[1], item[0])) # Extract the k most frequent strings result = [item[0] for item in sorted_strings[:k]] return result"},{"question":"def find_kth_smallest(arr, k): Develop a function that takes an unsorted integer array and an integer k, and returns the k-th smallest element in the array without using any in-built sorting functions. Parameters: arr (list): The unsorted list of integers. k (int): The desired rank of the smallest element. Returns: int: The k-th smallest element in the array. >>> find_kth_smallest([7, 10, 4, 3, 20, 15], 3) == 7 >>> find_kth_smallest([7, 10, 4, 3, 20, 15], 1) == 3 >>> find_kth_smallest([7, 10, 4, 3, 20, 15], 6) == 20 >>> find_kth_smallest([1, 2], 1) == 1 >>> find_kth_smallest([5], 1) == 5 >>> find_kth_smallest([8, 3, 5, 7, 6, 2, 1, 4, 9], 5) == 5 >>> find_kth_smallest([2, 1], 2) == 2 >>> find_kth_smallest([-1, -3, -2, -4, -5], 4) == -2 >>> find_kth_smallest([3, 3, 3, 3, 3], 3) == 3 >>> find_kth_smallest([5, 8, 4, 7], 4) == 8","solution":"def find_kth_smallest(arr, k): Returns the k-th smallest element in the array. Parameters: arr (list): The unsorted list of integers. k (int): The desired rank of the smallest element. Returns: int: The k-th smallest element in the array. def quickselect(low, high, k): if low == high: return arr[low] pivot_index = partition(low, high) if k == pivot_index: return arr[k] elif k < pivot_index: return quickselect(low, pivot_index - 1, k) else: return quickselect(pivot_index + 1, high, k) def partition(low, high): pivot = arr[high] i = low for j in range(low, high): if arr[j] < pivot: arr[i], arr[j] = arr[j], arr[i] i += 1 arr[i], arr[high] = arr[high], arr[i] return i return quickselect(0, len(arr) - 1, k - 1)"},{"question":"def split_even_odd_indices(lst): Splits a list into two lists: one containing the elements at even indices, and the other containing the elements at odd indices. Args: lst: A list of integers. Returns: A tuple of two lists. The first list contains the elements at even indices, while the second list contains the elements at odd indices. >>> split_even_odd_indices([10, 15, 20, 25, 30, 35]) ([10, 20, 30], [15, 25, 35]) >>> split_even_odd_indices([]) ([], []) >>> split_even_odd_indices([1]) ([1], []) >>> split_even_odd_indices([1, 2]) ([1], [2]) >>> split_even_odd_indices([2, 4, 6, 8, 10, 12]) ([2, 6, 10], [4, 8, 12]) >>> split_even_odd_indices([1, 3, 5, 7, 9, 11]) ([1, 5, 9], [3, 7, 11])","solution":"def split_even_odd_indices(lst): Splits a list into two lists: one containing the elements at even indices, and the other containing the elements at odd indices. Args: lst: A list of integers. Returns: A tuple of two lists. The first list contains the elements at even indices, while the second list contains the elements at odd indices. even_indexed = [lst[i] for i in range(len(lst)) if i % 2 == 0] odd_indexed = [lst[i] for i in range(len(lst)) if i % 2 == 1] return (even_indexed, odd_indexed)"},{"question":"def words_with_lengths(s: str) -> str: Returns a string in which each word is replaced by a tuple consisting of the word itself and its length. Parameters: s (str): The input string consisting of a series of words separated by spaces. Returns: str: A new string with each word replaced by a tuple of (word, length). >>> words_with_lengths(\\"Hello, world! How's everything?\\") \\"('Hello,', 6) ('world!', 6) ('How's', 5) ('everything?', 11)\\" >>> words_with_lengths(\\"\\") \\"\\" >>> words_with_lengths(\\"Python\\") \\"('Python', 6)\\" >>> words_with_lengths(\\"Hello world!\\") \\"('Hello', 5) ('world!', 6)\\" >>> words_with_lengths(\\"Good morning, John!\\") \\"('Good', 4) ('morning,', 8) ('John!', 5)\\"","solution":"def words_with_lengths(s): Returns a string in which each word is replaced by a tuple consisting of the word itself and its length. Parameters: s (str): The input string consisting of a series of words separated by spaces. Returns: str: A new string with each word replaced by a tuple of (word, length). words = s.split() result = ' '.join(f\\"('{word}', {len(word)})\\" for word in words) return result"},{"question":"def nested_list_depth(nested_list: list) -> int: Calculate the maximum depth of a given nested list. >>> nested_list_depth([1, [2, [3]], 4]) 3 >>> nested_list_depth([]) 1 >>> nested_list_depth([1, 2, [3, 4, [5]], [6], 7]) 3 >>> nested_list_depth([1, [2, [3, [4, [5]]]]]) 5 >>> nested_list_depth([['a', ['b', ['c', ['d', ['e']]]]], 'f']) 5","solution":"def nested_list_depth(nested_list: list) -> int: Calculate the maximum depth of a given nested list. if not isinstance(nested_list, list): return 0 if not nested_list: return 1 max_depth = 0 for item in nested_list: max_depth = max(max_depth, nested_list_depth(item)) return max_depth + 1"},{"question":"def filter_divisibles_and_k(nums: List[int], k: int) -> List[int]: Returns a list of integers from the original list where each element is either divisible by \`k\` or is itself \`k\`. Parameters: nums (list): List of integers. k (int): The integer k. Returns: list: A list of integers satisfying the conditions. >>> filter_divisibles_and_k([1, 2, 3], 5) == [] >>> filter_divisibles_and_k([5, 10, 15, 20], 5) == [5, 10, 15, 20] >>> filter_divisibles_and_k([1, 2, 3, 4, 5, 6, 7, 10, 15], 5) == [5, 10, 15] >>> filter_divisibles_and_k([], 3) == [] >>> filter_divisibles_and_k([2, 4, 6, 8, 10, 12], 6) == [6, 12] >>> filter_divisibles_and_k([-10, -5, 0, 5, 10], 5) == [-10, -5, 0, 5, 10]","solution":"def filter_divisibles_and_k(nums, k): Returns a list of integers from the original list where each element is either divisible by \`k\` or is itself \`k\`. Parameters: nums (list): List of integers. k (int): The integer k. Returns: list: A list of integers satisfying the conditions. result = [] for num in nums: if num == k or num % k == 0: result.append(num) return result"},{"question":"def four_sum(nums: List[int], target: int) -> List[List[int]]: Find all unique quadruplets in a given list of integers that sum up to a target value. >>> four_sum([1, 0, -1, 0, -2, 2], 0) [[-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] >>> four_sum([1, 2, 3, 4], 50) [] >>> four_sum([-3, -1, 0, 2, 4, 5], 2) [[-3, -1, 2, 4]] >>> four_sum([1, 1, 1, 1, 1, 1, 1, 1], 4) [[1, 1, 1, 1]] >>> four_sum([10000, 10000, 10000, 10000, -10000, -10000, -10000, -10000], 0) [[-10000, -10000, 10000, 10000]]","solution":"def four_sum(nums, target): nums.sort() quadruplets = set() n = len(nums) for i in range(n-3): for j in range(i+1, n-2): left = j + 1 right = n - 1 while left < right: current_sum = nums[i] + nums[j] + nums[left] + nums[right] if current_sum == target: quadruplets.add((nums[i], nums[j], nums[left], nums[right])) left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return [list(quadruplet) for quadruplet in quadruplets]"},{"question":"def check_permutation_substring(s1: str, s2: str) -> bool: Determine if s2 contains any permutation of s1 as a substring. Args: s1 (str): The string whose permutations are to be checked. s2 (str): The string to be checked for containing any permutation of s1. Returns: bool: True if any permutation of s1 is a substring of s2, False otherwise. Examples: >>> check_permutation_substring(\\"ab\\", \\"eidbaooo\\") True >>> check_permutation_substring(\\"ab\\", \\"eidboaoo\\") False","solution":"from collections import Counter def check_permutation_substring(s1: str, s2: str) -> bool: Determine if s2 contains any permutation of s1 as a substring. Args: s1 (str): The string whose permutations are to be checked. s2 (str): The string to be checked for containing any permutation of s1. Returns: bool: True if any permutation of s1 is a substring of s2, False otherwise. len_s1, len_s2 = len(s1), len(s2) if len_s1 > len_s2: return False s1_count = Counter(s1) window_count = Counter(s2[:len_s1]) for i in range(len_s2 - len_s1 + 1): if i > 0: # Update the current window window_count[s2[i - 1]] -= 1 if window_count[s2[i - 1]] == 0: del window_count[s2[i - 1]] window_count[s2[i + len_s1 - 1]] += 1 if window_count == s1_count: return True return False"},{"question":"def find_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: Create a function that receives an array of integers and an integer target value. The function should find all unique pairs of integers within the array whose sum matches the target value. The pairs should be returned as a list of tuples, with each tuple containing two integers. Ensure that each pair (a, b) follows the convention that a < b, and that the pairs are listed in ascending order based on their first element. If multiple pairs have the same first element, order them by the second element. If there are no such pairs, return an empty list. >>> find_pairs([1, 2, 3, 4, 5], 5) [(1, 4), (2, 3)] >>> find_pairs([1, 2, 3], 7) [] >>> find_pairs([-1, -2, -3, -4, -5], -5) [(-4, -1), (-3, -2)] >>> find_pairs([-1, -2, 3, 4, 5], 3) [(-2, 5), (-1, 4)] >>> find_pairs([1, 1, 2, 2, 3, 3], 4) [(1, 3), (2, 2)] >>> find_pairs([-1, 0, 1, 2], 0) [(-1, 1)] >>> find_pairs([1, 2, 1, 2, 3, 3], 4) [(1, 3), (2, 2)]","solution":"def find_pairs(nums, target): Find all unique pairs in the array whose sum matches the target value. :param nums: List of integers. :param target: Integer target value. :return: List of tuples containing unique pairs. pairs = set() seen = set() for num in nums: complement = target - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) # Return the sorted list of pairs return sorted(list(pairs))"},{"question":"import numpy as np import pandas as pd from sklearn.metrics.pairwise import cosine_similarity class CollaborativeFilteringRecommender: def __init__(self, ratings_df, user_col, item_col, rating_col): Initializes the recommender system with the provided ratings data. Parameters: - ratings_df: DataFrame containing user ratings for items - user_col: Column name for user IDs - item_col: Column name for item IDs - rating_col: Column name for ratings self.ratings_df = ratings_df self.user_col = user_col self.item_col = item_col self.rating_col = rating_col self.user_item_matrix = self._create_user_item_matrix() self.user_sim_matrix = self._compute_user_similarity() self.item_sim_matrix = self._compute_item_similarity() def _create_user_item_matrix(self): Creates a user-item matrix from the ratings data. >>> recommender = CollaborativeFilteringRecommender(sample_ratings, 'user_id', 'item_id', 'rating') >>> user_item_matrix = recommender._create_user_item_matrix() >>> user_item_matrix.shape == (4, 3) True pass # Implementation goes here def _compute_user_similarity(self): Computes the user similarity matrix. >>> recommender = CollaborativeFilteringRecommender(sample_ratings, 'user_id', 'item_id', 'rating') >>> user_sim_matrix = recommender._compute_user_similarity() >>> user_sim_matrix.shape == (4, 4) True pass # Implementation goes here def _compute_item_similarity(self): Computes the item similarity matrix. >>> recommender = CollaborativeFilteringRecommender(sample_ratings, 'user_id', 'item_id', 'rating') >>> item_sim_matrix = recommender._compute_item_similarity() >>> item_sim_matrix.shape == (3, 3) True pass # Implementation goes here def predict_user_based(self, user_id, item_id, k=5): Predicts the rating a user would give to an item using user-based collaborative filtering. Parameters: - user_id: ID of the user for whom the prediction is to be made - item_id: ID of the item for which the prediction is to be made - k: Number of similar users to consider >>> recommender = CollaborativeFilteringRecommender(sample_ratings, 'user_id', 'item_id', 'rating') >>> predicted_rating = recommender.predict_user_based(1, 'C', k=2) >>> 0 <= predicted_rating <= 5 True pass # Implementation goes here def predict_item_based(self, user_id, item_id, k=5): Predicts the rating a user would give to an item using item-based collaborative filtering. Parameters: - user_id: ID of the user for whom the prediction is to be made - item_id: ID of the item for which the prediction is to be made - k: Number of similar items to consider >>> recommender = CollaborativeFilteringRecommender(sample_ratings, 'user_id', 'item_id', 'rating') >>> predicted_rating = recommender.predict_item_based(1, 'C', k=2) >>> 0 <= predicted_rating <= 5 True pass # Implementation goes here","solution":"import numpy as np import pandas as pd from sklearn.metrics.pairwise import cosine_similarity from scipy.sparse import csr_matrix class CollaborativeFilteringRecommender: def __init__(self, ratings_df, user_col, item_col, rating_col): self.ratings_df = ratings_df self.user_col = user_col self.item_col = item_col self.rating_col = rating_col self.user_item_matrix = self._create_user_item_matrix() self.user_sim_matrix = self._compute_user_similarity() self.item_sim_matrix = self._compute_item_similarity() def _create_user_item_matrix(self): user_item_matrix = self.ratings_df.pivot( index=self.user_col, columns=self.item_col, values=self.rating_col ).fillna(0) return user_item_matrix def _compute_user_similarity(self): user_sim_matrix = cosine_similarity(self.user_item_matrix) np.fill_diagonal(user_sim_matrix, 0) # To avoid self-similarity return user_sim_matrix def _compute_item_similarity(self): item_sim_matrix = cosine_similarity(self.user_item_matrix.T) np.fill_diagonal(item_sim_matrix, 0) # To avoid self-similarity return item_sim_matrix def predict_user_based(self, user_id, item_id, k=5): try: user_index = self.user_item_matrix.index.get_loc(user_id) item_index = self.user_item_matrix.columns.get_loc(item_id) except KeyError: return None # User or item not found sim_users = self.user_sim_matrix[user_index] sim_users_indices = np.argsort(sim_users)[-k:] user_ratings = self.user_item_matrix.iloc[sim_users_indices, item_index] sim_scores = sim_users[sim_users_indices] weighted_avg_rating = np.dot(user_ratings, sim_scores) / np.sum(sim_scores) return weighted_avg_rating def predict_item_based(self, user_id, item_id, k=5): try: user_index = self.user_item_matrix.index.get_loc(user_id) item_index = self.user_item_matrix.columns.get_loc(item_id) except KeyError: return None # User or item not found sim_items = self.item_sim_matrix[item_index] sim_items_indices = np.argsort(sim_items)[-k:] item_ratings = self.user_item_matrix.iloc[user_index, sim_items_indices] sim_scores = sim_items[sim_items_indices] weighted_avg_rating = np.dot(item_ratings, sim_scores) / np.sum(sim_scores) return weighted_avg_rating"},{"question":"def get_kth_permutation(s: str, k: int) -> str: Returns the k-th permutation of the string characters in lexicographic order. If k is invalid (out of range), returns an error message. >>> get_kth_permutation(\\"abc\\", 1) == \\"abc\\" >>> get_kth_permutation(\\"abc\\", 2) == \\"acb\\" >>> get_kth_permutation(\\"abc\\", 3) == \\"bac\\" >>> get_kth_permutation(\\"abc\\", 4) == \\"bca\\" >>> get_kth_permutation(\\"abc\\", 5) == \\"cab\\" >>> get_kth_permutation(\\"abc\\", 6) == \\"cba\\" >>> get_kth_permutation(\\"abc\\", 0) == \\"Error: k is out of valid range\\" >>> get_kth_permutation(\\"abc\\", 7) == \\"Error: k is out of valid range\\" >>> get_kth_permutation(\\"abcd\\", 1) == \\"abcd\\" >>> get_kth_permutation(\\"abcd\\", 24) == \\"dcba\\" >>> get_kth_permutation(\\"zyxw\\", 1) == \\"wxyz\\" >>> get_kth_permutation(\\"zyxw\\", 24) == \\"zyxw\\" >>> get_kth_permutation(\\"a\\", 1) == \\"a\\" >>> get_kth_permutation(\\"ab\\", 2) == \\"ba\\"","solution":"import math def get_kth_permutation(s, k): Returns the k-th permutation of the string characters in lexicographic order. If k is invalid (out of range), returns an error message. # Error checking for invalid k n = len(s) total_permutations = math.factorial(n) if not (1 <= k <= total_permutations): return \\"Error: k is out of valid range\\" # Initialize variables k -= 1 # Convert to zero-index characters = sorted(s) permutation = [] # Generate k-th permutation while characters: n = len(characters) factorial = math.factorial(n - 1) index = k // factorial k = k % factorial permutation.append(characters.pop(index)) return ''.join(permutation)"},{"question":"def sum_of_diagonals(matrix: List[List[int]]) -> Tuple[int, int]: Implement a function that takes a square matrix of integers and returns a tuple containing the sum of the primary diagonal and the sum of the secondary diagonal. The primary diagonal runs from the top left to the bottom right, while the secondary diagonal runs from the top right to the bottom left. >>> sum_of_diagonals([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) (15, 15) >>> sum_of_diagonals([[1, 2], [3, 4]]) (5, 5) >>> sum_of_diagonals([[5]]) (5, 5) >>> sum_of_diagonals([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) (34, 34) >>> sum_of_diagonals([[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]) (-15, -15)","solution":"def sum_of_diagonals(matrix): Returns a tuple (sum_primary_diagonal, sum_secondary_diagonal) containing the sum of the primary diagonal and the secondary diagonal of a square matrix. n = len(matrix) sum_primary_diagonal = sum(matrix[i][i] for i in range(n)) sum_secondary_diagonal = sum(matrix[i][n - 1 - i] for i in range(n)) return (sum_primary_diagonal, sum_secondary_diagonal) # Example # Input: # [ # [1, 2, 3], # [4, 5, 6], # [7, 8, 9] # ] # Primary Diagonal: 1 + 5 + 9 = 15 # Secondary Diagonal: 3 + 5 + 7 = 15 # Output: (15, 15)"},{"question":"def filter_greater_than(arr, n): Filters elements from the input array that are greater than n. Args: arr (list): List of integers. n (int): The integer threshold. Returns: list: A new list containing elements from arr that are greater than n. >>> filter_greater_than([1, 3, 5, 7, 9], 4) [5, 7, 9] >>> filter_greater_than([10, 20, 30, 40], 25) [30, 40] >>> filter_greater_than([2, 4, 6, 8], 6) [8] >>> filter_greater_than([], 3) [] >>> filter_greater_than([10, 11, 12, 13], 5) [10, 11, 12, 13] >>> filter_greater_than([1, 2, 3], 0) [1, 2, 3] >>> filter_greater_than([1, 2, 3, 4], 5) [] >>> filter_greater_than([0, -1, -2, -3], 1) [] >>> filter_greater_than([1, -1, 2, -2, 3, -3], 0) [1, 2, 3] >>> filter_greater_than([-1, -2, -3, -4], -3) [-1, -2] >>> filter_greater_than([0, 1], 0) [1] >>> filter_greater_than([0, -1], -1) [0]","solution":"def filter_greater_than(arr, n): Filters elements from the input array that are greater than n. Args: arr (list): List of integers. n (int): The integer threshold. Returns: list: A new list containing elements from arr that are greater than n. return [x for x in arr if x > n]"},{"question":"def flatten_dict(d: dict, parent_key: str = '', sep: str = '.') -> dict: Flattens a nested dictionary such that the keys in the flattened dictionary are the concatenation of the nested keys separated by a specified separator. Parameters: ----------- d : dict The nested dictionary to flatten. parent_key : str, optional A prefix to prepend to the keys of the flattened dictionary (default is ''). sep : str, optional The separator to use between different levels of key concatenation (default is '.'). Returns: -------- dict A flattened dictionary. Raises: ------- TypeError: If the structure contains unsupported types. Examples: >>> flatten_dict({ ... \\"a\\": 1, ... \\"b\\": { ... \\"c\\": 2, ... \\"d\\": { ... \\"e\\": 3, ... \\"f\\": [4, 5, 6] ... }, ... \\"g\\": 7 ... }, ... \\"h\\": [8, 9] ... }) {'a': 1, 'b.c': 2, 'b.d.e': 3, 'b.d.f': [4, 5, 6], 'b.g': 7, 'h': [8, 9]} >>> flatten_dict({}) {} >>> flatten_dict({ ... \\"a\\": 1, ... \\"b\\": 2 ... }) {'a': 1, 'b': 2} >>> flatten_dict({ ... \\"x\\": { ... \\"y\\": [\\"a\\", \\"b\\", \\"c\\"] ... }, ... \\"z\\": \\"end\\" ... }) {'x.y': [\\"a\\", \\"b\\", \\"c\\"], 'z': \\"end\\"} >>> try: ... flatten_dict({ ... \\"a\\": 1, ... \\"b\\": { ... \\"c\\": 2, ... \\"d\\": { ... \\"e\\": 3, ... \\"f\\": set([4, 5, 6]) # Unsupported type (set) ... }, ... \\"g\\": 7 ... }, ... \\"h\\": [8, 9] ... }) ... except TypeError as e: ... assert str(e) == \\"Unsupported data type: <class 'set'> in key b.d.f\\" ... else: ... raise AssertionError(\\"Expected TypeError not raised\\")","solution":"def flatten_dict(d, parent_key='', sep='.'): Flattens a nested dictionary such that the keys in the flattened dictionary are the concatenation of the nested keys separated by a specified separator. Parameters: ----------- d : dict The nested dictionary to flatten. parent_key : str, optional A prefix to prepend to the keys of the flattened dictionary (default is ''). sep : str, optional The separator to use between different levels of key concatenation (default is '.'). Returns: -------- dict A flattened dictionary. Raises: ------- TypeError: If the structure contains unsupported types. items = [] for k, v in d.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(flatten_dict(v, new_key, sep=sep).items()) elif isinstance(v, list) or isinstance(v, (str, int, float)): items.append((new_key, v)) else: raise TypeError(f\\"Unsupported data type: {type(v)} in key {new_key}\\") return dict(items)"},{"question":"class Library: A class to manage a library's book checkouts. >>> library = Library() >>> library.checkout_book('patron1', 'isbn123', 'Book Title', 'Author Name', date(2023, 10, 1)) >>> library.return_book('isbn123', date(2023, 10, 2)) >>> library.generate_report() >>> library.search_checkouts('patron1') def __init__(self): # Initialize the data structures to manage books and checkouts. pass def checkout_book(self, patron_id, isbn, title, author, checkout_date): Check out a book to a patron. - patron_id: str - isbn: str - title: str - author: str - checkout_date: date pass def return_book(self, isbn, return_date): Return a book. - isbn: str - return_date: date pass def generate_report(self): Generate a report of all currently checked-out books. pass def search_checkouts(self, search_term): Search and filter checkouts based on patron ID, book title, or author name. - search_term: str pass","solution":"from datetime import date class Library: def __init__(self): self.books = {} self.checkouts = [] def checkout_book(self, patron_id, isbn, title, author, checkout_date): if isbn in self.books and 'return_date' not in self.books[isbn]: raise ValueError(\\"Book is already checked out.\\") self.books[isbn] = { 'title': title, 'author': author, 'patron_id': patron_id, 'checkout_date': checkout_date } self.checkouts.append({ 'isbn': isbn, 'patron_id': patron_id, 'checkout_date': checkout_date }) def return_book(self, isbn, return_date): if isbn not in self.books or 'return_date' in self.books[isbn]: raise ValueError(\\"Invalid return. Either the book is not checked out or already returned.\\") self.books[isbn]['return_date'] = return_date def generate_report(self): report = [] for isbn, details in self.books.items(): if 'return_date' not in details: report.append({ 'isbn': isbn, 'title': details['title'], 'author': details['author'], 'patron_id': details['patron_id'], 'checkout_date': details['checkout_date'] }) return report def search_checkouts(self, search_term): results = [] for checkout in self.checkouts: book_details = self.books[checkout['isbn']] if search_term in book_details['title'] or search_term in book_details['author'] or search_term == checkout['patron_id']: results.append(checkout) return results"},{"question":"def print_staircase(n: int) -> None: Prints a right-aligned staircase of height \`n\`. Each level of the staircase consists of hashtag ('#') characters, with the number of hashtags increasing from 1 to \`n\` from the top level to the bottom level. For example, if \`n\` is 5, the staircase will look like: # # # pass # Your implementation here # Test cases def test_staircase_size_1(): captured_output = io.StringIO() # Create a stringIO stream to capture the output sys.stdout = captured_output # Redirect stdout to the stream print_staircase(1) sys.stdout = sys.__stdout__ # Reset stdout assert captured_output.getvalue() == \\"#n\\" def test_staircase_size_2(): captured_output = io.StringIO() sys.stdout = captured_output print_staircase(2) sys.stdout = sys.__stdout__ assert captured_output.getvalue() == \\" #nn\\" def test_staircase_size_3(): captured_output = io.StringIO() sys.stdout = captured_output print_staircase(3) sys.stdout = sys.__stdout__ assert captured_output.getvalue() == \\" #n n#n\\" def test_staircase_size_4(): captured_output = io.StringIO() sys.stdout = captured_output print_staircase(4) sys.stdout = sys.__stdout__ assert captured_output.getvalue() == \\" #n n #nn\\" def test_staircase_size_5(): captured_output = io.StringIO() sys.stdout = captured_output print_staircase(5) sys.stdout = sys.__stdout__ assert captured_output.getvalue() == \\" #n n #n n#n\\"","solution":"def print_staircase(n: int) -> None: Prints a right-aligned staircase of height \`n\`. for i in range(1, n + 1): print(' ' * (n - i) + '#' * i)"},{"question":"def find_largest(nums: List[int]) -> int: Returns the largest number in the list. If the list is empty, returns None. >>> find_largest([]) is None >>> find_largest([42]) == 42 >>> find_largest([1, 2, 3, 4, 5]) == 5 >>> find_largest([5, 1, 2, 3, 4]) == 5 >>> find_largest([1, 5, 2, 3, 4]) == 5 >>> find_largest([-1, -2, -3, -4, -5]) == -1 >>> find_largest([3, -1, 4, 1, 5, 9, -2]) == 9 >>> find_largest([7, 7, 7, 7, 7, 7]) == 7 pass","solution":"def find_largest(nums): Returns the largest number in the list. If the list is empty, returns None. if not nums: # Check if the list is empty return None max_num = nums[0] # Initialize the first element as the maximum for num in nums[1:]: # Iterate over the rest of the elements if num > max_num: # Update max_num if the current element is larger max_num = num return max_num"},{"question":"def categorize_words(word_list): Categorize words from the input list based on their starting letter. Parameters: word_list (list): List of words (strings). Returns: dict: Dictionary where keys are the alphabet letters (in lower case) and values are the lists of words starting with that letter. >>> categorize_words([\\"apple\\", \\"apricot\\", \\"avocado\\"]) {\\"a\\": [\\"apple\\", \\"apricot\\", \\"avocado\\"]} >>> categorize_words([\\"banana\\", \\"blueberry\\", \\"carrot\\", \\"cherry\\"]) {\\"b\\": [\\"banana\\", \\"blueberry\\"], \\"c\\": [\\"carrot\\", \\"cherry\\"]} >>> categorize_words([]) {} >>> categorize_words([\\"Apple\\", \\"apricot\\", \\"Avocado\\"]) {\\"a\\": [\\"Apple\\", \\"apricot\\", \\"Avocado\\"]} >>> categorize_words([\\"apple\\", \\"banana\\", \\"apricot\\", \\"cherry\\", \\"avocado\\", \\"blueberry\\", \\"carrot\\"]) {\\"a\\": [\\"apple\\", \\"apricot\\", \\"avocado\\"], \\"b\\": [\\"banana\\", \\"blueberry\\"], \\"c\\": [\\"cherry\\", \\"carrot\\"]} >>> categorize_words([\\"apple\\", \\"apple\\", \\"apricot\\", \\"banana\\"]) {\\"a\\": [\\"apple\\", \\"apple\\", \\"apricot\\"], \\"b\\": [\\"banana\\"]}","solution":"def categorize_words(word_list): Categorize words from the input list based on their starting letter. Parameters: word_list (list): List of words (strings). Returns: dict: Dictionary where keys are the alphabet letters (in lower case) and values are the lists of words starting with that letter. from collections import defaultdict categorized_dict = defaultdict(list) for word in word_list: first_letter = word[0].lower() categorized_dict[first_letter].append(word) return dict(categorized_dict)"},{"question":"def is_alphabetical_order(words: List[str]) -> bool: Determines if the elements in the given list of strings are in alphabetical order. Parameters: words (list): List of strings to be checked. Returns: bool: True if the list is in alphabetical order, False otherwise. >>> is_alphabetical_order([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"]) True >>> is_alphabetical_order([\\"banana\\", \\"apple\\", \\"cherry\\", \\"date\\"]) False >>> is_alphabetical_order([]) True >>> is_alphabetical_order([\\"apple\\"]) True >>> is_alphabetical_order([\\"1apple\\", \\"2banana\\", \\"3cherry\\", \\"4date\\"]) True >>> is_alphabetical_order([\\"apple\\", \\"apple\\", \\"apple\\"]) True >>> is_alphabetical_order([\\" apple\\", \\"banana\\", \\"cherry\\", \\"date\\"]) True >>> is_alphabetical_order([\\"Apple\\", \\"banana\\", \\"Cherry\\", \\"date\\"]) False","solution":"def is_alphabetical_order(words): Determines if the elements in the given list of strings are in alphabetical order. Parameters: words (list): List of strings to be checked. Returns: bool: True if the list is in alphabetical order, False otherwise. return words == sorted(words)"},{"question":"def calculate_factorial(n): Calculates the factorial of a given non-negative integer n. Raises ValueError if n is not a non-negative integer. ... import pytest def test_calculate_factorial(): # Test valid inputs assert calculate_factorial(0) == 1 assert calculate_factorial(1) == 1 assert calculate_factorial(5) == 120 assert calculate_factorial(10) == 3628800 # Test invalid input: negative number with pytest.raises(ValueError): calculate_factorial(-5) # Test invalid input: non-integer with pytest.raises(ValueError): calculate_factorial(3.5)","solution":"def calculate_factorial(n): Calculates the factorial of a given non-negative integer n. Raises ValueError if n is not a non-negative integer. if not isinstance(n, int) or n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if n == 0 or n == 1: return 1 factorial = 1 for i in range(2, n+1): factorial *= i return factorial"},{"question":"def square_dict_values(input_dict: Dict[str, int]) -> Dict[str, int]: Returns a new dictionary with the same keys as input_dict, but with squared values. >>> square_dict_values({\\"a\\": 2, \\"b\\": 3}) {\\"a\\": 4, \\"b\\": 9} >>> square_dict_values({\\"x\\": 10, \\"y\\": 20}) {\\"x\\": 100, \\"y\\": 400} >>> square_dict_values({\\"a\\": 0, \\"b\\": 0}) {\\"a\\": 0, \\"b\\": 0} >>> square_dict_values({\\"zero\\": 0}) {\\"zero\\": 0} >>> square_dict_values({\\"a\\": -2, \\"b\\": 3}) {\\"a\\": 4, \\"b\\": 9} >>> square_dict_values({\\"neg\\": -5, \\"pos\\": 5}) {\\"neg\\": 25, \\"pos\\": 25} >>> square_dict_values({\\"a\\": -2, \\"b\\": -3}) {\\"a\\": 4, \\"b\\": 9} >>> square_dict_values({\\"neg\\": -4, \\"neg_ten\\": -10}) {\\"neg\\": 16, \\"neg_ten\\": 100}","solution":"def square_dict_values(input_dict): Returns a new dictionary with the same keys as input_dict, but with squared values. return {k: v**2 for k, v in input_dict.items()}"},{"question":"from typing import List, Tuple from datetime import datetime def merge_intervals(intervals: List[Tuple[str, str]]) -> List[Tuple[str, str]]: Merges overlapping intervals and returns a new list of merged intervals. :param intervals: List of tuples where each tuple contains start and end times in \\"HH:MM\\" format. :return: List of tuples with merged intervals in \\"HH:MM\\" format. >>> merge_intervals([(\\"09:00\\", \\"11:30\\"), (\\"10:00\\", \\"13:00\\"), (\\"12:30\\", \\"14:00\\"), (\\"16:00\\", \\"18:00\\")]) [('09:00', '14:00'), ('16:00', '18:00')] >>> merge_intervals([(\\"09:00\\", \\"10:00\\"), (\\"11:00\\", \\"12:00\\")]) [(\\"09:00\\", \\"10:00\\"), (\\"11:00\\", \\"12:00\\")] pass def test_no_overlap(): assert merge_intervals([(\\"09:00\\", \\"10:00\\"), (\\"11:00\\", \\"12:00\\")]) == [(\\"09:00\\", \\"10:00\\"), (\\"11:00\\", \\"12:00\\")] def test_full_overlap(): assert merge_intervals([(\\"09:00\\", \\"12:00\\"), (\\"10:00\\", \\"11:00\\")]) == [(\\"09:00\\", \\"12:00\\")] def test_partial_overlap(): assert merge_intervals([(\\"09:00\\", \\"11:30\\"), (\\"10:00\\", \\"13:00\\")]) == [(\\"09:00\\", \\"13:00\\")] def test_complex_merge(): intervals = [(\\"09:00\\", \\"11:30\\"), (\\"10:00\\", \\"13:00\\"), (\\"12:30\\", \\"14:00\\"), (\\"16:00\\", \\"18:00\\")] expected = [(\\"09:00\\", \\"14:00\\"), (\\"16:00\\", \\"18:00\\")] assert merge_intervals(intervals) == expected def test_contained_intervals(): intervals = [(\\"09:00\\", \\"14:00\\"), (\\"10:00\\", \\"11:00\\"), (\\"11:30\\", \\"13:00\\"), (\\"16:00\\", \\"18:00\\")] expected = [(\\"09:00\\", \\"14:00\\"), (\\"16:00\\", \\"18:00\\")] assert merge_intervals(intervals) == expected def test_same_intervals(): intervals = [(\\"09:00\\", \\"11:00\\"), (\\"09:00\\", \\"11:00\\"), (\\"12:00\\", \\"13:00\\")] expected = [(\\"09:00\\", \\"11:00\\"), (\\"12:00\\", \\"13:00\\")] assert merge_intervals(intervals) == expected","solution":"from datetime import datetime def merge_intervals(intervals): Merges overlapping intervals and returns a new list of merged intervals. :param intervals: List of tuples where each tuple contains start and end times in \\"HH:MM\\" format. :return: List of tuples with merged intervals in \\"HH:MM\\" format. # Convert time strings to datetime objects for comparison intervals = [(datetime.strptime(start, \\"%H:%M\\"), datetime.strptime(end, \\"%H:%M\\")) for start, end in intervals] # Sort intervals by start time intervals.sort(key=lambda x: x[0]) merged = [] for interval in intervals: # If merged list is empty or current interval does not overlap with the last merged interval if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: # There is overlap, so we merge the current interval with the last merged interval merged[-1] = (merged[-1][0], max(merged[-1][1], interval[1])) # Convert datetime objects back to \\"HH:MM\\" strings merged = [(start.strftime(\\"%H:%M\\"), end.strftime(\\"%H:%M\\")) for start, end in merged] return merged"},{"question":"class CustomStack: A custom stack data structure that supports push, pop, and increment operations. Attributes: maxSize (int): The maximum capacity of the stack. Methods: push(value: int): Adds the given value onto the stack. pop() -> int: Removes and returns the element on the top of the stack. If the stack is empty, returns -1. increment(k: int, val: int): Increments the bottom k elements of the stack by val. def __init__(self, maxSize: int): Initialize the CustomStack with a maximum size. def push(self, value: int) -> None: Adds the given value onto the stack if the stack has not reached its maximum size. def pop(self) -> int: Removes and returns the element on the top of the stack. If the stack is empty, returns -1. def increment(self, k: int, val: int) -> None: Increments the bottom k elements of the stack by val. If there are fewer than k elements, increment all the elements.","solution":"class CustomStack: def __init__(self, maxSize: int): self.stack = [] self.maxSize = maxSize def push(self, value: int) -> None: if len(self.stack) < self.maxSize: self.stack.append(value) def pop(self) -> int: if not self.stack: return -1 return self.stack.pop() def increment(self, k: int, val: int) -> None: for i in range(min(k, len(self.stack))): self.stack[i] += val"},{"question":"def fibonacci(n, memo={}): Returns the nth Fibonacci number. Uses memoization to cache previously calculated results for efficiency. >>> fibonacci(1) == 0 >>> fibonacci(2) == 1 >>> fibonacci(10) == 34 >>> fibonacci(50) == 7778742049 >>> fibonacci(0) # should raise ValueError","solution":"def fibonacci(n, memo={}): Returns the nth Fibonacci number. Uses memoization to cache previously calculated results for efficiency. if n <= 0: raise ValueError(\\"Input must be a positive integer\\") if n in memo: return memo[n] if n == 1: return 0 if n == 2: return 1 memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo) return memo[n]"},{"question":"class User: def __init__(self, user_id, name, liked_songs): Create a new User object. Args: user_id (int): The unique identifier for the user. name (str): The name of the user. liked_songs (list): A list of song ids that the user likes. self.user_id = user_id self.name = name self.liked_songs = liked_songs class Song: def __init__(self, song_id, title, artist, genre, duration): Create a new Song object. Args: song_id (int): The unique identifier for the song. title (str): The title of the song. artist (str): The artist of the song. genre (str): The genre of the song. duration (float): The duration in minutes of the song. self.song_id = song_id self.title = title self.artist = artist self.genre = genre self.duration = duration class CollaborativeFiltering: def find_similar_users(self, user): Find similar users based on listening history. Args: user (User): The user for which similar users need to be found. Returns: list: List of similar users. pass def recommend(self, user): Recommend songs to a user based on similar users' preferences. Args: user (User): The user for which recommendations need to be generated. Returns: list: List of recommended song ids. pass class ContentBasedFiltering: def analyze_song(self, song): Analyze a song to extract metadata. Args: song (Song): The song to be analyzed. Returns: dict: Dictionary containing metadata of the song. pass def recommend(self, user): Recommend songs to a user based on song metadata. Args: user (User): The user for which recommendations need to be generated. Returns: list: List of recommended song ids. pass class RecommendationSystem: def __init__(self): Initialize the recommendation system with empty user and song lists. self.users = [] self.songs = [] self.collaborative_filtering = CollaborativeFiltering() self.content_based_filtering = ContentBasedFiltering() def add_user(self, user): Add a new user to the recommendation system. Args: user (User): The user to be added. self.users.append(user) def add_song(self, song): Add a new song to the recommendation system. Args: song (Song): The song to be added. self.songs.append(song) def recommend_songs(self, user_id): Recommend songs to a user based on collaborative and content-based filtering. Args: user_id (int): The unique identifier of the user. Returns: list: List of recommended song ids. pass def recommend_playlists(self, user_id): Recommend playlists to a user based on collaborative filtering. Args: user_id (int): The unique identifier of the user. Returns: list: List of recommended song ids. pass import pytest from solution import User, Song, RecommendationSystem def test_add_user(): rs = RecommendationSystem() user = User(1, \\"Alice\\", [101, 102]) rs.add_user(user) assert len(rs.users) == 1 assert rs.users[0].user_id == 1 def test_add_song(): rs = RecommendationSystem() song = Song(201, \\"Song1\\", \\"Artist1\\", \\"Pop\\", 3.5) rs.add_song(song) assert len(rs.songs) == 1 assert rs.songs[0].title == \\"Song1\\" def test_recommend_songs(): rs = RecommendationSystem() user = User(1, \\"Alice\\", [101, 102]) rs.add_user(user) song1 = Song(101, \\"Song1\\", \\"Artist1\\", \\"Pop\\", 3.5) song2 = Song(102, \\"Song2\\", \\"Artist2\\", \\"Rock\\", 4.0) rs.add_song(song1) rs.add_song(song2) recommendations = rs.recommend_songs(1) assert recommendations == [101, 102] def test_recommend_playlists(): rs = RecommendationSystem() user = User(1, \\"Alice\\", [101, 102]) rs.add_user(user) song1 = Song(101, \\"Song1\\", \\"Artist1\\", \\"Pop\\", 3.5) song2 = Song(102, \\"Song2\\", \\"Artist2\\", \\"Rock\\", 4.0) rs.add_song(song1) rs.add_song(song2) playlists = rs.recommend_playlists(1) assert playlists == [101, 102] if __name__ == \\"__main__\\": pytest.main()","solution":"class User: def __init__(self, user_id, name, liked_songs): self.user_id = user_id self.name = name self.liked_songs = liked_songs class Song: def __init__(self, song_id, title, artist, genre, duration): self.song_id = song_id self.title = title self.artist = artist self.genre = genre self.duration = duration class CollaborativeFiltering: def find_similar_users(self, user): # Dummy implementation for demo purposes return [user] def recommend(self, user): # Dummy implementation for demo purposes return user.liked_songs class ContentBasedFiltering: def analyze_song(self, song): # Dummy implementation for demo purposes return {\\"genre\\": song.genre, \\"artist\\": song.artist} def recommend(self, user): # Dummy implementation for demo purposes return user.liked_songs class RecommendationSystem: def __init__(self): self.users = [] self.songs = [] self.collaborative_filtering = CollaborativeFiltering() self.content_based_filtering = ContentBasedFiltering() def add_user(self, user): self.users.append(user) def add_song(self, song): self.songs.append(song) def recommend_songs(self, user_id): user = next((u for u in self.users if u.user_id == user_id), None) if not user: return [] similar_users = self.collaborative_filtering.find_similar_users(user) recommendations_cf = self.collaborative_filtering.recommend(user) recommendations_cbf = self.content_based_filtering.recommend(user) recommendations = list(set(recommendations_cf + recommendations_cbf)) return recommendations def recommend_playlists(self, user_id): user = next((u for u in self.users if u.user_id == user_id), None) if not user: return [] return self.collaborative_filtering.recommend(user)"},{"question":"def find_shortest_word(s: str) -> str: Takes a string consisting of words separated by spaces, and returns the shortest word in the string. If there are multiple words with the same shortest length, it returns the first one that appears. >>> find_shortest_word(\\"Python is a great programming language\\") \\"a\\" >>> find_shortest_word(\\"The quick brown fox jumps over the lazy dog\\") \\"The\\" >>> find_shortest_word(\\"May the force be with you\\") \\"be\\" def test_single_word(): assert find_shortest_word(\\"Python\\") == \\"Python\\" def test_multiple_words(): assert find_shortest_word(\\"Python is a great programming language\\") == \\"a\\" assert find_shortest_word(\\"The quick brown fox jumps over the lazy dog\\") == \\"The\\" assert find_shortest_word(\\"May the force be with you\\") == \\"be\\" def test_all_same_length(): assert find_shortest_word(\\"cat dog bat\\") == \\"cat\\" def test_first_and_last_same_length(): assert find_shortest_word(\\"go to bed early\\") == \\"go\\" def test_no_spaces(): assert find_shortest_word(\\"Abcdef\\") == \\"Abcdef\\"","solution":"def find_shortest_word(s: str) -> str: Takes a string consisting of words separated by spaces, and returns the shortest word in the string. If there are multiple words with the same shortest length, it returns the first one that appears. words = s.split() shortest_word = min(words, key=len) return shortest_word"},{"question":"import re from typing import Dict def analyze_text(text: str) -> Dict[str, int]: Analyzes the input text and returns a dictionary with counts of various types of characters. >>> analyze_text(\\"Hello, World! 123\\") {\\"total_chars\\": 17, \\"alphabets\\": 10, \\"digits\\": 3, \\"spaces\\": 2, \\"punctuations\\": 2} >>> analyze_text(\\"\\") {\\"total_chars\\": 0, \\"alphabets\\": 0, \\"digits\\": 0, \\"spaces\\": 0, \\"punctuations\\": 0} >>> analyze_text(\\"!@#%^&*()\\") {\\"total_chars\\": 10, \\"alphabets\\": 0, \\"digits\\": 0, \\"spaces\\": 0, \\"punctuations\\": 10} >>> analyze_text(\\"abcXYZ\\") {\\"total_chars\\": 6, \\"alphabets\\": 6, \\"digits\\": 0, \\"spaces\\": 0, \\"punctuations\\": 0} >>> analyze_text(\\"1234567890\\") {\\"total_chars\\": 10, \\"alphabets\\": 0, \\"digits\\": 10, \\"spaces\\": 0, \\"punctuations\\": 0} >>> analyze_text(\\" \\") {\\"total_chars\\": 3, \\"alphabets\\": 0, \\"digits\\": 0, \\"spaces\\": 3, \\"punctuations\\": 0} # Your code here","solution":"import re def analyze_text(text): Analyzes the input text and returns a dictionary with counts of various types of characters. Args: - text (str): The text to be analyzed. Returns: - dict: A dictionary with counts for total_chars, alphabets, digits, spaces, and punctuations. total_chars = len(text) alphabets = len(re.findall(r'[a-zA-Z]', text)) digits = len(re.findall(r'd', text)) spaces = len(re.findall(r's', text)) punctuations = len(re.findall(r'[^ws]', text)) return { \\"total_chars\\": total_chars, \\"alphabets\\": alphabets, \\"digits\\": digits, \\"spaces\\": spaces, \\"punctuations\\": punctuations }"},{"question":"def is_palindrome(s: str) -> bool: Checks whether the string is a palindrome, ignoring spaces, punctuation, and capitalization. >>> is_palindrome(\\"A man, a plan, a canal, Panama!\\") True >>> is_palindrome(\\"No lemon, no melon\\") True >>> is_palindrome(\\"Hello, World!\\") False","solution":"def is_palindrome(s: str) -> bool: Checks whether the string is a palindrome, ignoring spaces, punctuation, and capitalization. # Filter out non-alphanumeric characters and convert to lower case filtered_s = ''.join(char.lower() for char in s if char.isalnum()) # Check if the filtered string is equal to its reverse return filtered_s == filtered_s[::-1]"},{"question":"class SimpleTextEditor: def __init__(self): Initialize the SimpleTextEditor with an empty text string and an empty history list. pass def insert(self, string): Insert string at the end of the current text. Example: >>> editor = SimpleTextEditor() >>> editor.insert(\\"Hello\\") >>> editor.get_text() 'Hello' pass def delete(self, k): Delete the last k characters from the current text. Example: >>> editor = SimpleTextEditor() >>> editor.insert(\\"Hello\\") >>> editor.delete(2) >>> editor.get_text() 'Hel' pass def undo(self): Undo the last operation. Example: >>> editor = SimpleTextEditor() >>> editor.insert(\\"Hello\\") >>> editor.undo() >>> editor.get_text() '' pass def get_text(self): Returns the current text. Example: >>> editor = SimpleTextEditor() >>> editor.insert(\\"Hello\\") >>> editor.get_text() 'Hello' pass # Unit Tests def test_insert_text(): editor = SimpleTextEditor() editor.insert(\\"Hello\\") assert editor.get_text() == \\"Hello\\" def test_delete_text(): editor = SimpleTextEditor() editor.insert(\\"Hello\\") editor.delete(2) assert editor.get_text() == \\"Hel\\" def test_undo_insert(): editor = SimpleTextEditor() editor.insert(\\"Hello\\") editor.undo() assert editor.get_text() == \\"\\" def test_undo_delete(): editor = SimpleTextEditor() editor.insert(\\"Hello\\") editor.delete(2) editor.undo() assert editor.get_text() == \\"Hello\\" def test_multiple_operations(): editor = SimpleTextEditor() editor.insert(\\"Hello\\") editor.insert(\\" World\\") assert editor.get_text() == \\"Hello World\\" editor.delete(6) assert editor.get_text() == \\"Hello\\" editor.undo() assert editor.get_text() == \\"Hello World\\" editor.undo() assert editor.get_text() == \\"Hello\\" editor.undo() assert editor.get_text() == \\"\\" def test_long_undo_chain(): editor = SimpleTextEditor() operations = [\\"inserted\\", \\"some\\", \\"random\\", \\"text\\"] for op in operations: editor.insert(op) for op in reversed(operations): assert editor.get_text().endswith(op) editor.undo() assert editor.get_text() == \\"\\" def test_delete_more_than_text_length(): editor = SimpleTextEditor() editor.insert(\\"short\\") editor.delete(10) # More than text length assert editor.get_text() == \\"\\"","solution":"class SimpleTextEditor: def __init__(self): self.text = \\"\\" self.history = [] def insert(self, string): Insert string at the end of the current text. self.history.append(self.text) self.text += string def delete(self, k): Delete the last k characters from the current text. self.history.append(self.text) self.text = self.text[:-k] def undo(self): Undo the last operation. if self.history: self.text = self.history.pop() def get_text(self): Returns the current text. return self.text"},{"question":"def categorize_words_by_length(words: List[str]) -> Dict[int, List[str]]: Categorizes words by their lengths and returns a dictionary with word lengths as keys and sorted lists of words as values. Arguments: words -- a list of words (list of strings) Returns: A dictionary with word lengths as keys and sorted lists of words as values. pass # Example usage and test cases if __name__ == \\"__main__\\": def test_empty_list(): assert categorize_words_by_length([]) == {} def test_single_word(): assert categorize_words_by_length([\\"word\\"]) == {4: [\\"word\\"]} def test_words_of_different_lengths(): words = [\\"apple\\", \\"bat\\", \\"ball\\", \\"cat\\", \\"dog\\", \\"elephant\\"] expected_output = {3: [\\"bat\\", \\"cat\\", \\"dog\\"], 4: [\\"ball\\"], 5: [\\"apple\\"], 8: [\\"elephant\\"]} assert categorize_words_by_length(words) == expected_output def test_words_of_same_length(): words = [\\"apple\\", \\"brave\\", \\"candy\\", \\"dandy\\"] expected_output = {5: [\\"apple\\", \\"brave\\", \\"candy\\", \\"dandy\\"]} assert categorize_words_by_length(words) == expected_output def test_mixed_sorted_words(): words = [\\"bat\\", \\"ball\\", \\"apple\\", \\"cat\\", \\"dog\\", \\"elephant\\"] expected_output = {3: [\\"bat\\", \\"cat\\", \\"dog\\"], 4: [\\"ball\\"], 5: [\\"apple\\"], 8: [\\"elephant\\"]} assert categorize_words_by_length(words) == expected_output def test_duplicates_handle(): words = [\\"zebra\\", \\"alpha\\", \\"omega\\", \\"zebra\\"] expected_output = {5: [\\"alpha\\", \\"omega\\", \\"zebra\\", \\"zebra\\"]} assert categorize_words_by_length(words) == expected_output","solution":"def categorize_words_by_length(words): Categorizes words by their lengths and returns a dictionary with word lengths as keys and sorted lists of words as values. Arguments: words -- a list of words (list of strings) Returns: A dictionary with word lengths as keys and sorted lists of words as values. from collections import defaultdict length_dict = defaultdict(list) for word in words: length_dict[len(word)].append(word) # Sort words in each length category for key in length_dict: length_dict[key] = sorted(length_dict[key]) return dict(length_dict)"},{"question":"def intersection(list1, list2): Returns a list containing only the elements that are present in both input lists, without duplicates. >>> set(intersection([1, 2, 3, 4, 5], [3, 4, 5, 6, 7])) == {3, 4, 5} True >>> set(intersection([1, 2, 2, 3, 3, 4, 5], [3, 4, 4, 5, 6, 7])) == {3, 4, 5} True >>> intersection([1, 2, 3], [4, 5, 6]) == [] True >>> set(intersection([1, 2, 3], [1, 2, 3])) == {1, 2, 3} True >>> intersection([], []) == [] True >>> intersection([1, 2, 3], []) == [] True >>> intersection([], [4, 5, 6]) == [] True >>> try: ... intersection([1, 2, 3], \\"123\\") ... except ValueError as ve: ... ve.args[0] == \\"Both inputs must be lists of integers\\" True >>> try: ... intersection(\\"123\\", [1, 2, 3]) ... except ValueError as ve: ... ve.args[0] == \\"Both inputs must be lists of integers\\" True >>> try: ... intersection(123, 321) ... except ValueError as ve: ... ve.args[0] == \\"Both inputs must be lists of integers\\" True >>> try: ... intersection([1, 2, 3], [3, 4, 'a']) ... except ValueError as ve: ... ve.args[0] == \\"Both inputs must be lists of integers\\" True","solution":"def intersection(list1, list2): Returns a list containing only the elements that are present in both input lists, without duplicates. try: set1 = set(list1) set2 = set(list2) intersection_set = set1.intersection(set2) return list(intersection_set) except TypeError: raise ValueError(\\"Both inputs must be lists of integers\\")"},{"question":"def second_largest(numbers: List[int]) -> int: Returns the second largest number in the list. If the list has fewer than two unique elements, returns None. >>> second_largest([1, 3, 4, 5, 3, 5]) == 4 >>> second_largest([1, 2, 2, 3, 3, 3]) == 2 >>> second_largest([10, 10, 10, 10]) == None >>> second_largest([5]) == None >>> second_largest([]) == None >>> second_largest([-10, -20, -30, -10, -20]) == -20 >>> second_largest([-10, 0, 10, 5, -5]) == 5","solution":"def second_largest(numbers): Returns the second largest number in the list. If the list has fewer than two unique elements, returns None. :param numbers: List of integers :return: The second largest integer or None unique_numbers = list(set(numbers)) if len(unique_numbers) < 2: return None unique_numbers.sort(reverse=True) return unique_numbers[1]"},{"question":"class LRUCache: Simulates the functionality of a Least Recently Used (LRU) cache. Methods: - __init__(self, capacity: int): Initializes the cache with a given capacity. - get(self, key: int) -> int: Retrieves an item from the cache. - put(self, key: int, value: int) -> None: Adds an item to the cache. >>> cache = LRUCache(2) >>> cache.put(1, 1) >>> cache.put(2, 2) >>> cache.get(1) 1 >>> cache.put(3, 3) >>> cache.get(2) -1 >>> cache.put(4, 4) >>> cache.get(1) -1 >>> cache.get(3) 3 >>> cache.get(4) 4 def __init__(self, capacity: int): pass def get(self, key: int) -> int: pass def put(self, key: int, value: int) -> None: pass","solution":"class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.order = [] def get(self, key: int) -> int: if key in self.cache: self.order.remove(key) self.order.append(key) return self.cache[key] return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self.cache[key] = value self.order.remove(key) self.order.append(key) else: if len(self.cache) >= self.capacity: oldest_key = self.order.pop(0) del self.cache[oldest_key] self.cache[key] = value self.order.append(key)"},{"question":"import re class Vehicle: Base class for vehicles def __init__(self, make, model, year, registration_number): self.make = make self.model = model self.year = year self.registration_number = registration_number def display_info(self): Display the vehicle's info return f\\"Make: {self.make}, Model: {self.model}, Year: {self.year}, Registration Number: {self.registration_number}\\" def update_registration_number(self, new_registration): Update the registration number if re.match(\\"^[A-Za-z0-9]+\\", new_registration): self.registration_number = new_registration else: raise ValueError(\\"Invalid registration number. It should be a combination of letters and numbers.\\") def calculate_license_fee(self): Calculate the vehicle's license fee return \\"Base license fee calculation for generic vehicle.\\" class Car(Vehicle): Subclass representing a car def __init__(self, make, model, year, registration_number, number_of_doors): super().__init__(make, model, year, registration_number) self.number_of_doors = number_of_doors def get_number_of_doors(self): Get the car's number of doors return self.number_of_doors def set_number_of_doors(self, number_of_doors): Set the car's number of doors self.number_of_doors = number_of_doors def display_info(self): Display the car's full information info = super().display_info() return f\\"{info}, Number of doors: {self.number_of_doors}\\" def update_registration_number(self, new_registration): Update the car's registration number with validation if len(new_registration) < 8: raise ValueError(\\"Car registration number must be at least 8 characters long.\\") super().update_registration_number(new_registration) def calculate_license_fee(self): Calculate the car's license fee return f\\"License fee for car: {50 + (self.number_of_doors * 10)}\\" class Truck(Vehicle): Subclass representing a truck def __init__(self, make, model, year, registration_number, cargo_capacity): super().__init__(make, model, year, registration_number) self.cargo_capacity = cargo_capacity def get_cargo_capacity(self): Get the truck's cargo capacity return self.cargo_capacity def set_cargo_capacity(self, cargo_capacity): Set the truck's cargo capacity self.cargo_capacity = cargo_capacity def display_info(self): Display the truck's full information info = super().display_info() return f\\"{info}, Cargo capacity: {self.cargo_capacity}kg\\" def update_registration_number(self, new_registration): Update the truck's registration number with validation if not new_registration.startswith(\\"TRK\\"): raise ValueError(\\"Truck registration number must start with 'TRK'.\\") super().update_registration_number(new_registration) def calculate_license_fee(self): Calculate the truck's license fee return f\\"License fee for truck: {100 + (self.cargo_capacity * 0.1)}\\" if __name__ == \\"__main__\\": # Test cases vehicle = Vehicle(\\"Toyota\\", \\"Corolla\\", 2020, \\"ABC123\\") print(vehicle.display_info()) vehicle.update_registration_number(\\"XYZ789\\") print(vehicle.display_info()) car = Car(\\"Honda\\", \\"Civic\\", 2019, \\"HONDA123\\", 4) print(car.display_info()) car.set_number_of_doors(2) print(car.display_info()) car.update_registration_number(\\"NEWREG234\\") print(car.display_info()) print(car.calculate_license_fee()) truck = Truck(\\"Ford\\", \\"F150\\", 2018, \\"TRK1234\\", 5000) print(truck.display_info()) truck.set_cargo_capacity(7000) print(truck.display_info()) truck.update_registration_number(\\"TRK9876\\") print(truck.display_info()) print(truck.calculate_license_fee())","solution":"import re class Vehicle: def __init__(self, make, model, year, registration_number): self.make = make self.model = model self.year = year self.registration_number = registration_number def display_info(self): return f\\"Make: {self.make}, Model: {self.model}, Year: {self.year}, Registration Number: {self.registration_number}\\" def update_registration_number(self, new_registration): if re.match(\\"^[A-Za-z0-9]+\\", new_registration): self.registration_number = new_registration else: raise ValueError(\\"Invalid registration number. It should be a combination of letters and numbers.\\") def calculate_license_fee(self): return \\"Base license fee calculation for generic vehicle.\\" class Car(Vehicle): def __init__(self, make, model, year, registration_number, number_of_doors): super().__init__(make, model, year, registration_number) self.number_of_doors = number_of_doors def get_number_of_doors(self): return self.number_of_doors def set_number_of_doors(self, number_of_doors): self.number_of_doors = number_of_doors def display_info(self): info = super().display_info() return f\\"{info}, Number of doors: {self.number_of_doors}\\" def update_registration_number(self, new_registration): if len(new_registration) < 8: raise ValueError(\\"Car registration number must be at least 8 characters long.\\") super().update_registration_number(new_registration) def calculate_license_fee(self): return f\\"License fee for car: {50 + (self.number_of_doors * 10)}\\" class Truck(Vehicle): def __init__(self, make, model, year, registration_number, cargo_capacity): super().__init__(make, model, year, registration_number) self.cargo_capacity = cargo_capacity def get_cargo_capacity(self): return self.cargo_capacity def set_cargo_capacity(self, cargo_capacity): self.cargo_capacity = cargo_capacity def display_info(self): info = super().display_info() return f\\"{info}, Cargo capacity: {self.cargo_capacity}kg\\" def update_registration_number(self, new_registration): if not new_registration.startswith(\\"TRK\\"): raise ValueError(\\"Truck registration number must start with 'TRK'.\\") super().update_registration_number(new_registration) def calculate_license_fee(self): return f\\"License fee for truck: {100 + (self.cargo_capacity * 0.1)}\\""},{"question":"class FileSystem: Implement a File System with Limited Storage and Path Tracking. createPath(string path, int value): Creates a new path with the given value in the file system. The path will always start with '/' and consist of lowercase English letters, such as \\"/a\\", \\"/a/b\\", etc. The value will be an integer. If the path already exists, return false. If the parent path does not exist, return false. Otherwise, return true. getPathValue(string path): Returns the value associated with the given path. If the path does not exist, return -1. setPathValue(string path, int value): Sets the value for an existing path in the file system. If the path does not exist, return false. Otherwise, return true. listPaths(): Returns a list of all paths currently created in the file system in lexicographical order. >>> fs = FileSystem() >>> fs.createPath(\\"/a\\", 1) True >>> fs.createPath(\\"/a/b\\", 2) True >>> fs.createPath(\\"/a/b/c\\", 3) True >>> fs.createPath(\\"/a/b\\", 4) False >>> fs.getPathValue(\\"/a/b\\") 2 >>> fs.getPathValue(\\"/a/b/c\\") 3 >>> fs.getPathValue(\\"/a/d\\") -1 >>> fs.setPathValue(\\"/a/b\\", 10) True >>> fs.getPathValue(\\"/a/b\\") 10 >>> fs.setPathValue(\\"/a/e\\", 5) False >>> fs.listPaths() [\\"/a\\", \\"/a/b\\", \\"/a/b/c\\"]","solution":"class FileSystem: def __init__(self): self.paths = {} # Initialize an empty dictionary to store path-value pairs def createPath(self, path, value): if not path or path == \\"/\\" or path in self.paths: return False parent = path[:path.rfind('/')] if len(parent) > 1 and parent not in self.paths: return False self.paths[path] = value return True def getPathValue(self, path): return self.paths.get(path, -1) def setPathValue(self, path, value): if path not in self.paths: return False self.paths[path] = value return True def listPaths(self): return sorted(self.paths.keys())"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression string containing non-negative integers and +, - operators. >>> evaluate_expression(\\"3+5\\") == 8 >>> evaluate_expression(\\"10-4\\") == 6 >>> evaluate_expression(\\"3+5-2+8\\") == 14 >>> evaluate_expression(\\"42\\") == 42 >>> evaluate_expression(\\"0-5+3\\") == -2 >>> evaluate_expression(\\"1000+2000-1500\\") == 1500","solution":"def evaluate_expression(expression): Evaluates a mathematical expression string containing non-negative integers and +, - operators. return eval(expression)"},{"question":"from typing import Tuple import pandas as pd from sklearn.model_selection import train_test_split from sklearn.preprocessing import StandardScaler from sklearn.neighbors import KNeighborsClassifier from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, confusion_matrix def load_and_preprocess_data(url: str) -> Tuple[pd.DataFrame, pd.DataFrame, pd.Series, pd.Series]: Load and preprocess the wine dataset from the provided URL. Parameters: url (str): The URL of the wine dataset Returns: Tuple containing the training and test sets for features and target variable. pass def train_knn_classifier(X_train: pd.DataFrame, X_test: pd.DataFrame, y_train: pd.Series, y_test: pd.Series, n_neighbors: int = 3) -> Tuple[float, float, float, float, pd.DataFrame]: Train a K-Nearest Neighbors classifier on the training data and evaluate it on the test data. Parameters: X_train (pd.DataFrame): The training set features X_test (pd.DataFrame): The test set features y_train (pd.Series): The training set target y_test (pd.Series): The test set target n_neighbors (int): Number of neighbors to use for KNN Returns: Tuple containing accuracy, precision, recall, F1-score, and confusion matrix of the model on the test set. pass","solution":"import pandas as pd from sklearn.model_selection import train_test_split from sklearn.preprocessing import StandardScaler from sklearn.neighbors import KNeighborsClassifier from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, confusion_matrix def load_and_preprocess_data(url): # Load dataset df = pd.read_csv(url, header=None) # Assign column names based on UCI dataset description df.columns = ['Class', 'Alcohol', 'Malic_acid', 'Ash', 'Alcalinity_of_ash', 'Magnesium', 'Total_phenols', 'Flavanoids', 'Nonflavanoid_phenols', 'Proanthocyanins', 'Color_intensity', 'Hue', 'OD280/OD315_of_diluted_wines', 'Proline'] # Separate features and target X = df.drop('Class', axis=1) y = df['Class'] # Normalize the features scaler = StandardScaler() X_scaled = scaler.fit_transform(X) return train_test_split(X_scaled, y, test_size=0.2, random_state=42) def train_knn_classifier(X_train, X_test, y_train, y_test, n_neighbors=3): # Instantiate KNN classifier knn = KNeighborsClassifier(n_neighbors=n_neighbors) # Fit the model knn.fit(X_train, y_train) # Predict on the test set y_pred = knn.predict(X_test) # Calculate metrics accuracy = accuracy_score(y_test, y_pred) precision = precision_score(y_test, y_pred, average='weighted') recall = recall_score(y_test, y_pred, average='weighted') f1 = f1_score(y_test, y_pred, average='weighted') cm = confusion_matrix(y_test, y_pred) return accuracy, precision, recall, f1, cm # URL of the dataset url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/wine/wine.data' # Load and preprocess data X_train, X_test, y_train, y_test = load_and_preprocess_data(url) # Train the KNN classifier and get performance metrics accuracy, precision, recall, f1, cm = train_knn_classifier(X_train, X_test, y_train, y_test) # Output results accuracy, precision, recall, f1, cm"},{"question":"def find_median(numbers): Given a list of integers, returns the median of the list. The median is the middle number in a sorted, ascending list of numbers. If the list has an odd number of elements, the median is the element in the middle of the list. If the list has an even number of elements, the median is calculated by taking the average of the two middle numbers. Args: numbers (List[int]): the list of integers Returns: float or int: the median of the list, or None if the list is empty Examples: >>> find_median([3, 1, 4, 1, 5, 9, 2]) 3 >>> find_median([1, 2, 3, 4]) 2.5 >>> find_median([]) None >>> find_median([1]) 1 pass # TODO: Implement this function # Unit tests def test_empty_list(): assert find_median([]) == None def test_single_element_list(): assert find_median([5]) == 5 assert find_median([10]) == 10 def test_odd_number_of_elements(): assert find_median([3, 1, 4, 1, 5, 9, 2]) == 3 assert find_median([1, 5, 3]) == 3 def test_even_number_of_elements(): assert find_median([3, 1, 4, 1, 5, 2]) == (3 + 2) / 2 assert find_median([1, 2, 3, 4]) == (2 + 3) / 2 def test_repeated_elements(): assert find_median([4, 4, 4, 4, 4]) == 4 assert find_median([1, 1, 2, 2, 3, 3, 4, 4]) == (2 + 3) / 2","solution":"def find_median(numbers): if not numbers: return None numbers.sort() n = len(numbers) if n % 2 == 1: return numbers[n // 2] else: mid1, mid2 = numbers[(n // 2) - 1], numbers[n // 2] return (mid1 + mid2) / 2"},{"question":"def count_words(file_path): Optimize the word count function to efficiently handle large text files. This function reads a text file and counts the occurrence of each word. It returns a dictionary with words as keys and their respective counts as values. Args: file_path (str): The path to the text file. Returns: dict: A dictionary with words as keys and their counts as values. >>> count_words('sample.txt') {'hello': 2, 'world': 2} word_count = {} with open(file_path, 'r') as file: for line in file: words = line.split() for word in words: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 return word_count import pytest def test_count_words_with_sample_text_file(tmp_path): sample_text = \\"hello worldnhellonworld\\" file_path = tmp_path / \\"sample.txt\\" file_path.write_text(sample_text) expected_output = {'hello': 2, 'world': 2} assert count_words(str(file_path)) == expected_output def test_count_words_with_empty_file(tmp_path): file_path = tmp_path / \\"empty.txt\\" file_path.write_text(\\"\\") expected_output = {} assert count_words(str(file_path)) == expected_output def test_count_words_with_single_word_file(tmp_path): file_path = tmp_path / \\"single_word.txt\\" file_path.write_text(\\"test\\") expected_output = {'test': 1} assert count_words(str(file_path)) == expected_output def test_count_words_with_repeating_words(tmp_path): sample_text = \\"test test testnsample sample\\" file_path = tmp_path / \\"repeating_words.txt\\" file_path.write_text(sample_text) expected_output = {'test': 3, 'sample': 2} assert count_words(str(file_path)) == expected_output def test_count_words_case_insensitivity(tmp_path): sample_text = \\"Hello hello HELLO\\" file_path = tmp_path / \\"case_insensitive.txt\\" file_path.write_text(sample_text) expected_output = {'Hello': 1, 'hello': 1, 'HELLO': 1} assert count_words(str(file_path)) == expected_output","solution":"from collections import defaultdict def count_words(file_path): word_count = defaultdict(int) with open(file_path, 'r') as file: for line in file: words = line.split() for word in words: word_count[word] += 1 return dict(word_count)"},{"question":"def eval_math_expression(expression: str) -> float: Evaluates a mathematical expression given as a string and returns the result as a float. Assumes the expression contains only non-negative integers and +, -, *, / operators. >>> eval_math_expression(\\"2+3\\") 5.0 >>> eval_math_expression(\\"2+3-1\\") 4.0 >>> eval_math_expression(\\"2*3/6\\") 1.0 >>> eval_math_expression(\\"2+3*4\\") 14.0 >>> eval_math_expression(\\"2*3+4\\") 10.0 >>> eval_math_expression(\\"2+3*4/2-1\\") 7.0 >>> eval_math_expression(\\"10+20*30/15-5\\") 45.0 >>> eval_math_expression(\\"10/1\\") 10.0 >>> eval_math_expression(\\"0+0\\") 0.0 >>> eval_math_expression(\\"0+5\\") 5.0","solution":"def eval_math_expression(expression): Evaluates a mathematical expression given as a string and returns the result as a float. Assumes the expression contains only non-negative integers and +, -, *, / operators. def get_precedence(op): if op in ['+', '-']: return 1 if op in ['*', '/']: return 2 return 0 def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) elif operator == '/': values.append(left / right) def to_postfix(expression): operators = [] values = [] index = 0 while index < len(expression): if expression[index].isdigit(): num = 0 while index < len(expression) and expression[index].isdigit(): num = num * 10 + int(expression[index]) index += 1 values.append(num) else: while (operators and get_precedence(operators[-1]) >= get_precedence(expression[index])): apply_operator(operators, values) operators.append(expression[index]) index += 1 while operators: apply_operator(operators, values) return values.pop() return float(to_postfix(expression))"},{"question":"def filter_primes(numbers: List[int]) -> List[int]: Returns a list of prime numbers from the input list. >>> filter_primes([2, 3, 5, 7, 11, 13]) [2, 3, 5, 7, 11, 13] >>> filter_primes([1, 4, 6, 8, 10, 12]) [] >>> filter_primes([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> filter_primes(list(range(1, 101))) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] >>> filter_primes([-10, -3, -1, 0, 2, 3, 5]) [2, 3, 5] pass","solution":"def filter_primes(numbers): Returns a list of prime numbers from the input list. :param numbers: List[int] - A list of integers. :return: List[int] - A list of prime numbers from the input list. def is_prime(n): Checks if a number is prime. :param n: int - The number to check. :return: bool - True if the number is prime, False otherwise. if n <= 1: return False if n == 2 or n == 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True return [num for num in numbers if is_prime(num)]"},{"question":"def rotate_list(nums, k): Rotates the elements of the list 'nums' in place to the right by 'k' steps. :param nums: List of integers. :param k: Number of steps to rotate the list. >>> rotate_list([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate_list([-1, -100, 3, 99], 2) [3, 99, -1, -100] >>> rotate_list([], 1) [] >>> rotate_list([1], 10) [1] >>> rotate_list([1, 2, 3], 5) [2, 3, 1] >>> rotate_list([1, 2, 3], 0) [1, 2, 3] >>> rotate_list([1, 2, 3, 4, 5], 999) [2, 3, 4, 5, 1]","solution":"def rotate_list(nums, k): Rotates the elements of the list 'nums' in place to the right by 'k' steps. :param nums: List of integers. :param k: Number of steps to rotate the list. n = len(nums) if n == 0: return nums k = k % n # In case k is larger than the length of the list # Reverse the entire list reverse(nums, 0, n - 1) # Reverse the first k elements reverse(nums, 0, k - 1) # Reverse the remaining elements reverse(nums, k, n - 1) return nums def reverse(nums, start, end): Reverses the elements of the list 'nums' from index 'start' to 'end' in place. :param nums: List of integers. :param start: Starting index of the segment to reverse. :param end: Ending index of the segment to reverse. while start < end: nums[start], nums[end] = nums[end], nums[start] start += 1 end -= 1"},{"question":"def is_prime(n: int) -> bool: Checks if a number is prime. ... def extract_primes_and_sum(int_list: List[int]) -> Tuple[List[int], int]: Takes a list of integers as input and returns a tuple with two elements: 1. A list of prime numbers from the input list. 2. The sum of the extracted prime numbers. >>> extract_primes_and_sum([2, 3, 5, 7, 11]) == ([2, 3, 5, 7, 11], 28) >>> extract_primes_and_sum([1, 2, 3, 4, 5, 6, 7]) == ([2, 3, 5, 7], 17) >>> extract_primes_and_sum([4, 6, 8, 9, 10]) == ([], 0) >>> extract_primes_and_sum([0, -1, -2, 3, 5]) == ([3, 5], 8) >>> extract_primes_and_sum([7]) == ([7], 7) >>> extract_primes_and_sum([29, 30, 31, 32]) == ([29, 31], 60) ...","solution":"def is_prime(n): Checks if a number is prime. if n <= 1: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True def extract_primes_and_sum(int_list): Takes a list of integers as input and returns a tuple with two elements: 1. A list of prime numbers from the input list. 2. The sum of the extracted prime numbers. primes = [num for num in int_list if is_prime(num)] prime_sum = sum(primes) return (primes, prime_sum)"},{"question":"from typing import List def sort_positive_keep_negative_positions(input_list: List[int]) -> List[int]: Returns a list with the elements sorted in ascending order, but keeping all the negative numbers in their original positions. >>> sort_positive_keep_negative_positions([3, -1, 5, -2, 4]) [3, -1, 4, -2, 5] >>> sort_positive_keep_negative_positions([5, 3, 2, 1, 4]) [1, 2, 3, 4, 5] >>> sort_positive_keep_negative_positions([-5, -3, -2, -1, -4]) [-5, -3, -2, -1, -4] >>> sort_positive_keep_negative_positions([0, -1, 5, 3, -2, 4, -3]) [0, -1, 3, 4, -2, 5, -3] >>> sort_positive_keep_negative_positions([]) [] >>> sort_positive_keep_negative_positions([-1, -2, -3]) [-1, -2, -3]","solution":"def sort_positive_keep_negative_positions(input_list): Returns a list with the elements sorted in ascending order, but keeping all the negative numbers in their original positions. # Extract positive numbers and their indices positive_numbers = [num for num in input_list if num >= 0] positive_numbers.sort() # Create a new list to store the result result = [] positive_index = 0 # Iterate through the original list for num in input_list: if num < 0: # Keep the negative numbers in their original positions result.append(num) else: # Replace the original positive numbers with the sorted ones result.append(positive_numbers[positive_index]) positive_index += 1 return result"},{"question":"import numpy as np def initialize_centroids(X, K): Randomly initialize K centroids from the dataset X. pass def assign_clusters(X, centroids): Assign each data point in X to the closest centroid. pass def update_centroids(X, labels, K): Update the centroids to the mean of the assigned points. pass def compute_sse(X, centroids, labels): Compute the Sum of Squared Errors (SSE) for the clustering. pass def k_means(X, K, max_iters=100, tol=1e-4): Perform K-means clustering. pass # Example dataset X = np.array([[1.1, 2.2], [1.5, 1.8], [5.4, 6.3], [1.0, 1.7], [0.9, 1.2], [4.5, 5.8], [5.2, 5.9], [3.9, 4.5], [9.1, 8.7], [8.1, 9.0]]) # Example usage: # labels, centroids, sse = k_means(X, 3) # Unit Tests def test_initialize_centroids(): centroids = initialize_centroids(X, 2) assert centroids.shape == (2, 2) assert centroids[0] in X and centroids[1] in X def test_assign_clusters(): centroids = np.array([[1.0, 1.0], [5.0, 5.0]]) labels = assign_clusters(X, centroids) assert labels.shape == (X.shape[0],) assert set(labels) <= {0, 1} def test_update_centroids(): labels = np.array([0, 0, 1, 0, 0, 1, 1, 1, 1, 1]) new_centroids = update_centroids(X, labels, 2) assert new_centroids.shape == (2, 2) assert np.allclose(new_centroids[0], np.mean(X[labels == 0], axis=0)) assert np.allclose(new_centroids[1], np.mean(X[labels == 1], axis=0)) def test_compute_sse(): centroids = np.array([[1.1, 2.0], [5.0, 5.0]]) labels = assign_clusters(X, centroids) sse = compute_sse(X, centroids, labels) assert isinstance(sse, float) assert sse > 0 def test_k_means(): labels, centroids, sse = k_means(X, 3) assert labels.shape == (X.shape[0],) assert centroids.shape == (3, 2) assert isinstance(sse, float) # Ensure the sum of squared errors decreases after running k-means clustering initial_sse = compute_sse(X, initialize_centroids(X, 3), labels) final_sse = compute_sse(X, centroids, labels) assert final_sse <= initial_sse","solution":"import numpy as np def initialize_centroids(X, K): Randomly initialize K centroids from the dataset X. np.random.seed(42) # For reproducible results random_indices = np.random.permutation(X.shape[0]) centroids = X[random_indices[:K]] return centroids def assign_clusters(X, centroids): Assign each data point in X to the closest centroid. distances = np.linalg.norm(X[:, np.newaxis] - centroids, axis=2) return np.argmin(distances, axis=1) def update_centroids(X, labels, K): Update the centroids to the mean of the assigned points. new_centroids = np.array([X[labels == k].mean(axis=0) for k in range(K)]) return new_centroids def compute_sse(X, centroids, labels): Compute the Sum of Squared Errors (SSE) for the clustering. sse = 0.0 for k in range(centroids.shape[0]): sse += np.sum((X[labels == k] - centroids[k]) ** 2) return sse def k_means(X, K, max_iters=100, tol=1e-4): Perform K-means clustering. centroids = initialize_centroids(X, K) for _ in range(max_iters): labels = assign_clusters(X, centroids) new_centroids = update_centroids(X, labels, K) # Convergence check if np.all(np.abs(new_centroids - centroids) < tol): break centroids = new_centroids sse = compute_sse(X, centroids, labels) return labels, centroids, sse"},{"question":"def sieve_of_eratosthenes(n: int) -> list: Generate a list of prime numbers up to n using the Sieve of Eratosthenes algorithm. Parameters: n (int): The upper limit for generating prime numbers. Returns: list: A list of prime numbers less than or equal to n. >>> sieve_of_eratosthenes(10) [2, 3, 5, 7] >>> sieve_of_eratosthenes(1) [] >>> sieve_of_eratosthenes(0) [] >>> sieve_of_eratosthenes(2) [2] >>> sieve_of_eratosthenes(50) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] >>> sieve_of_eratosthenes(-10) [] pass","solution":"def sieve_of_eratosthenes(n): Generate a list of prime numbers up to n using the Sieve of Eratosthenes algorithm. Parameters: n (int): The upper limit for generating prime numbers. Returns: list: A list of prime numbers less than or equal to n. if n < 2: return [] primes = [True] * (n + 1) primes[0] = primes[1] = False # 0 and 1 are not prime numbers p = 2 while p * p <= n: if primes[p]: for i in range(p * p, n + 1, p): primes[i] = False p += 1 return [i for i in range(n + 1) if primes[i]]"},{"question":"def shift_letters(input_string: str) -> str: Given a string containing a combination of letters and digits, return a new string where all the letters are swapped with their next letter in the alphabet and all digits remain unchanged. 'z' or 'Z' wraps around to 'a' or 'A' respectively. The function handles both uppercase and lowercase letters. >>> shift_letters(\\"a1b2c3zZ\\") 'b1c2d3aA' >>> shift_letters(\\"abcdefghijklmnopqrstuvwxyz\\") 'bcdefghijklmnopqrstuvwxyza' >>> shift_letters(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\") 'BCDEFGHIJKLMNOPQRSTUVWXYZA' >>> shift_letters(\\"aBcDeFgHiJkLmNoPqRsTuVwXyZ\\") 'bCdEfGhIjKlMnOpQrStUvWxYzA' >>> shift_letters(\\"1234567890\\") '1234567890' >>> shift_letters(\\"\\") '' >>> shift_letters(\\"azAZ\\") 'baBA'","solution":"def shift_letters(input_string): Returns a new string where all the letters are shifted to their next letter in the alphabet and all digits remain unchanged. 'z' or 'Z' wraps around to 'a' or 'A' respectively. def shift_char(c): if c.isalpha(): if c == 'z': return 'a' elif c == 'Z': return 'A' else: return chr(ord(c) + 1) else: return c return ''.join(shift_char(c) for c in input_string)"},{"question":"def count_occurrences(arr: List[int]) -> Dict[int, int]: Returns a dictionary with distinct integers from the list as keys and their corresponding counts as values. >>> count_occurrences([1]) == {1: 1} >>> count_occurrences([1, 2, 3]) == {1: 1, 2: 1, 3: 1} >>> count_occurrences([1, 2, 2, 3, 3, 3]) == {1: 1, 2: 2, 3: 3} >>> count_occurrences([]) == {} >>> count_occurrences([4, 5, 4, 5, 4, 6, 6, 7]) == {4: 3, 5: 2, 6: 2, 7: 1} >>> count_occurrences([-1, -2, -1, -2, -1, -3, -3, -4]) == {-1: 3, -2: 2, -3: 2, -4: 1}","solution":"def count_occurrences(arr): Returns a dictionary with distinct integers from the list as keys and their corresponding counts as values. occurrence_dict = {} for num in arr: if num in occurrence_dict: occurrence_dict[num] += 1 else: occurrence_dict[num] = 1 return occurrence_dict"},{"question":"from typing import List, Tuple import itertools def find_even_sum_and_product_pairs(numbers: List[int]) -> List[Tuple[int, int]]: Takes a list of integers and returns a list of tuples where each tuple contains a pair of numbers whose sum and product are both even. >>> find_even_sum_and_product_pairs([1, 2, 3, 4, 5, 6, 7, 8, 9]) [(2, 4), (2, 6), (2, 8), (4, 6), (4, 8), (6, 8)] >>> find_even_sum_and_product_pairs([]) [] >>> find_even_sum_and_product_pairs([2]) [] pass def count_even_sum_and_product_pairs(pairs: List[Tuple[int, int]]) -> int: Takes a list of pairs and returns the count of these pairs. >>> count_even_sum_and_product_pairs([(2, 4), (2, 6), (2, 8), (4, 6), (4, 8), (6, 8)]) 6 pass def visualize_pairs(pairs: List[Tuple[int, int]]) -> None: Takes a list of pairs and generates a scatter plot. >>> visualize_pairs([(2, 4), (2, 6), (2, 8), (4, 6), (4, 8), (6, 8)]) pass","solution":"import itertools def find_even_sum_and_product_pairs(numbers): Takes a list of integers and returns a list of tuples where each tuple contains a pair of numbers whose sum and product are both even. valid_pairs = [] for a, b in itertools.combinations(numbers, 2): if (a + b) % 2 == 0 and (a * b) % 2 == 0: valid_pairs.append((a, b)) return valid_pairs def count_even_sum_and_product_pairs(pairs): Takes a list of pairs and returns the count of these pairs. return len(pairs) def visualize_pairs(pairs): Takes a list of pairs and generates a scatter plot. import matplotlib.pyplot as plt x_vals = [pair[0] for pair in pairs] y_vals = [pair[1] for pair in pairs] plt.scatter(x_vals, y_vals) plt.xlabel('First number') plt.ylabel('Second number') plt.title('Scatter plot of pairs with even sum and product') plt.show()"},{"question":"def sieve_of_eratosthenes(n: int) -> List[int]: Returns a list of all prime numbers less than n using the Sieve of Eratosthenes algorithm. >>> sieve_of_eratosthenes(0) [] >>> sieve_of_eratosthenes(1) [] >>> sieve_of_eratosthenes(10) [2, 3, 5, 7]","solution":"def sieve_of_eratosthenes(n): Returns a list of all prime numbers less than n using the Sieve of Eratosthenes algorithm. if n <= 2: return [] sieve = [True] * n sieve[0] = sieve[1] = False for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n, start): sieve[multiple] = False return [num for num in range(n) if sieve[num]]"},{"question":"def int_to_roman(num: int) -> str: Convert an integer to a Roman numeral. Args: num (int): The integer value to convert. Should be in the range from 1 to 3999. Returns: str: The Roman numeral representation of the integer. >>> int_to_roman(1987) 'MCMLXXXVII' >>> int_to_roman(1) 'I' >>> int_to_roman(3999) 'MMMCMXCIX' >>> int_to_roman(4) 'IV' >>> int_to_roman(9) 'IX' >>> int_to_roman(58) 'LVIII' >>> int_to_roman(44) 'XLIV'","solution":"def int_to_roman(num): Convert an integer to a Roman numeral. Args: num (int): The integer value to convert. Should be in the range from 1 to 3999. Returns: str: The Roman numeral representation of the integer. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = '' i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syb[i] num -= val[i] i += 1 return roman_num"},{"question":"def max_pairwise_product(numbers: List[int]) -> int: Returns the maximum product of any two distinct integers from the list. >>> max_pairwise_product([1, 2, 3]) -> 6 >>> max_pairwise_product([7, 5, 14, 2, 8, 8, 10, 1, 2, 3]) -> 140 >>> max_pairwise_product([0, -1, -2, -3, -4]) -> 12 >>> max_pairwise_product([1, 3, -5, 7, 9]) -> 63 >>> max_pairwise_product([-10, -20, 5, 3, 2, 1]) -> 200 >>> max_pairwise_product([1, 2]) -> 2 >>> max_pairwise_product([-1, -2, -3, -4, 5, 6, 7]) -> 42 >>> max_pairwise_product([0, 0, 1, 2]) -> 2 >>> max_pairwise_product([100, 1000, 10, -1]) -> 100000","solution":"def max_pairwise_product(numbers): Returns the maximum product of any two distinct integers from the list. if len(numbers) < 2: return None # Initialize maximum and second maximum with the lowest possible integer max1, max2 = float('-inf'), float('-inf') # Initialize minimum and second minimum to handle negative numbers min1, min2 = float('inf'), float('inf') for number in numbers: # Update max1 and max2 if number > max1: max1, max2 = number, max1 elif number > max2: max2 = number # Update min1 and min2 if number < min1: min1, min2 = number, min1 elif number < min2: min2 = number # The maximum product could be from the two largest numbers or two smallest numbers return max(max1 * max2, min1 * min2) # Examples print(max_pairwise_product([1, 2, 3])) # Output: 6 (2*3) print(max_pairwise_product([7, 5, 14, 2, 8, 8, 10, 1, 2, 3])) # Output: 140 (14*10) print(max_pairwise_product([0, -1, -2, -3, -4])) # Output: 12 (-2*-3)"},{"question":"def rotate_list(lst, k): Rotates the list lst to the right by k positions. Parameters: lst (list): A list of integers. k (int): A positive integer indicating the number of positions to rotate. Returns: list: A new list that has been rotated. Examples: >>> rotate_list([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_list([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3]","solution":"def rotate_list(lst, k): Rotates the list lst to the right by k positions. Parameters: lst (list): A list of integers. k (int): A positive integer indicating the number of positions to rotate. Returns: list: A new list that has been rotated. n = len(lst) k = k % n # Normalize k to avoid unnecessary full rotations return lst[-k:] + lst[:-k]"},{"question":"class MinHeap: A class that implements a min-heap data structure. def __init__(self): Initializes an empty heap. self.heap = [] def insert(self, val): Inserts a value into the min-heap. def extract_min(self): Removes and returns the smallest value from the min-heap. def peek_min(self): Returns the smallest value without removing it. def size(self): Returns the number of elements currently in the heap. def _heapify_up(self, index): Maintains the heap property from the given index upwards. def _heapify_down(self, index): Maintains the heap property from the given index downwards. # Example usage: # heap = MinHeap() # heap.insert(10) # heap.insert(7) # heap.insert(15) # heap.insert(5) # print(heap.peek_min()) # Outputs: 5 # print(heap.extract_min()) # Outputs: 5 # print(heap.peek_min()) # Outputs: 7 # print(heap.size()) # Outputs: 3","solution":"class MinHeap: def __init__(self): self.heap = [] def insert(self, val): Inserts a value into the min-heap. self.heap.append(val) self._heapify_up(len(self.heap) - 1) def extract_min(self): Removes and returns the smallest value from the min-heap. if self.size() == 0: return None min_val = self.heap[0] if self.size() > 1: self.heap[0] = self.heap.pop() self._heapify_down(0) else: self.heap.pop() return min_val def peek_min(self): Returns the smallest value without removing it. if self.size() == 0: return None return self.heap[0] def size(self): Returns the number of elements currently in the heap. return len(self.heap) def _heapify_up(self, index): Maintains the heap property from the given index upwards. parent_index = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._heapify_up(parent_index) def _heapify_down(self, index): Maintains the heap property from the given index downwards. left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 smallest = index if left_child_index < self.size() and self.heap[left_child_index] < self.heap[smallest]: smallest = left_child_index if right_child_index < self.size() and self.heap[right_child_index] < self.heap[smallest]: smallest = right_child_index if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._heapify_down(smallest)"},{"question":"def sum_with_neighbors(lst: List[int]) -> List[int]: Returns a list where each element is the sum of its adjacent neighbors and itself. For edge elements, assume the outside neighbor is zero. >>> sum_with_neighbors([1, 2, 3, 4]) [3, 6, 9, 7] >>> sum_with_neighbors([10, 20, 30, 40]) [30, 60, 90, 70] >>> sum_with_neighbors([5]) [5] >>> sum_with_neighbors([0]) [0] >>> sum_with_neighbors([1, 2]) [3, 3] >>> sum_with_neighbors([10, 20]) [30, 30] >>> sum_with_neighbors([]) [] >>> sum_with_neighbors([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) [3, 6, 9, 12, 15, 18, 21, 24, 27, 19]","solution":"def sum_with_neighbors(lst): Returns a list where each element is the sum of its adjacent neighbors and itself. For edge elements, assume the outside neighbor is zero. if not lst: return [] result = [] n = len(lst) for i in range(n): left = lst[i - 1] if i > 0 else 0 center = lst[i] right = lst[i + 1] if i < n - 1 else 0 result.append(left + center + right) return result"},{"question":"def fibonacci(n: int) -> int: Calculates the nth Fibonacci number. The Fibonacci sequence is defined such that each number is the sum of the two preceding ones, starting with 0 and 1. Parameters: n (int): The position in the Fibonacci sequence to retrieve. Returns: int: The nth Fibonacci number. >>> fibonacci(0) == 0 >>> fibonacci(1) == 1 >>> fibonacci(2) == 1 >>> fibonacci(3) == 2 >>> fibonacci(4) == 3 >>> fibonacci(5) == 5 >>> fibonacci(10) == 55 >>> fibonacci(15) == 610 >>> fibonacci(20) == 6765","solution":"def fibonacci(n): Returns the nth Fibonacci number. Parameters: n (int): The position in the Fibonacci sequence to retrieve. Returns: int: The nth Fibonacci number. if n < 0: raise ValueError(\\"Input should be a non-negative integer\\") a, b = 0, 1 for _ in range(n): a, b = b, a + b return a"},{"question":"def atm_withdrawal(requested_amount): Simulates the withdrawal of money from an ATM. The function checks if the requested amount can be dispensed based on the available denominations (50, 20, 10, 5, 1). It should return the count of each denomination to dispense the exact requested amount if possible, or an error message if the amount cannot be dispensed. >>> atm_withdrawal(187) {50: 3, 20: 1, 10: 1, 5: 1, 1: 2} >>> atm_withdrawal(65) {50: 1, 10: 1, 5: 1} >>> atm_withdrawal(230) {50: 4, 20: 1, 10: 1} >>> atm_withdrawal(1) {1: 1} >>> atm_withdrawal(0) \\"Invalid amount\\" >>> atm_withdrawal(-5) \\"Invalid amount\\" >>> atm_withdrawal(1234567) {50: 24691, 10: 1, 5: 1, 1: 2} >>> atm_withdrawal(3) {1: 3}","solution":"def atm_withdrawal(requested_amount): Simulates the withdrawal of money from an ATM. The function checks if the requested amount can be dispensed based on the available denominations (50, 20, 10, 5, 1). It should return the count of each denomination to dispense the exact requested amount if possible, or an error message if the amount cannot be dispensed. denominations = [50, 20, 10, 5, 1] result = {} if requested_amount <= 0: return \\"Invalid amount\\" for denom in denominations: count, requested_amount = divmod(requested_amount, denom) if count > 0: result[denom] = count return result if requested_amount == 0 else \\"Cannot dispense the exact amount with available denominations\\""},{"question":"from typing import List import heapq def find_kth_largest(nums: List[int], k: int) -> int: Given an array of integers, find the k-th largest element in the array. Assume k is always valid, 1 ≤ k ≤ array's length. >>> find_kth_largest([3, 2, 1, 5, 6, 4], 2) 5 >>> find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 4 >>> find_kth_largest([1], 1) 1 >>> find_kth_largest([1, 2, 3, 4, 5, 6], 3) 4 >>> find_kth_largest([6, 5, 4, 3, 2, 1], 2) 5","solution":"import heapq def find_kth_largest(nums, k): Returns the k-th largest element in the array. return heapq.nlargest(k, nums)[-1]"},{"question":"def sum_primes(n: int) -> int: Given an integer n, return the sum of all prime numbers less than or equal to n. >>> sum_primes(10) 17 >>> sum_primes(1) 0 >>> sum_primes(2) 2 >>> sum_primes(20) 77 >>> sum_primes(100) 1060 >>> sum_primes(0) 0 >>> sum_primes(-10) 0","solution":"def sum_primes(n): if n < 2: return 0 sieve = [True] * (n + 1) sieve[0] = sieve[1] = False for start in range(2, int(n**0.5) + 1): if sieve[start]: for i in range(start * start, n + 1, start): sieve[i] = False return sum(index for index, is_prime in enumerate(sieve) if is_prime)"},{"question":"def four_sum(nums: List[int], target: int) -> List[List[int]]: Returns a list of unique quadruplets [a, b, c, d] such that a + b + c + d equals the target. >>> four_sum([1, 0, -1, 0, -2, 2], 0) == sorted([ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]) >>> four_sum([1, 2, 3, 4, 5], 50) == [] >>> four_sum([1, 1, 1, 1, 1, 1, 1], 4) == [[1, 1, 1, 1]] >>> four_sum([2, 2, 2, 2, 2], 8) == [[2, 2, 2, 2]] >>> four_sum([2, 2, 2, 2, 2], 9) == [] >>> four_sum([1, 0, -1, 0, -2, 2, 2, -1], 0) == sorted([ [-2, -1, 1, 2], [-2, 0, 0, 2], [-1, -1, 0, 2], [-1, 0, 0, 1] ])","solution":"def four_sum(nums, target): Returns a list of unique quadruplets [a, b, c, d] such that a + b + c + d equals the target. nums.sort() quadruplets = [] n = len(nums) for i in range(n - 3): if i > 0 and nums[i] == nums[i - 1]: continue for j in range(i + 1, n - 2): if j > i + 1 and nums[j] == nums[j - 1]: continue left, right = j + 1, n - 1 while left < right: quad_sum = nums[i] + nums[j] + nums[left] + nums[right] if quad_sum == target: quadruplets.append([nums[i], nums[j], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif quad_sum < target: left += 1 else: right -= 1 return quadruplets"},{"question":"import json import os def load_json_data(json_file): Loads JSON data from a file and returns it. # Your code here def count_students(json_file): Returns the number of students in the JSON data file. >>> count_students('students.json') == 4 # Your code here def get_students_above_age(json_file, age): Returns a list of names of students older than a specified age. >>> get_students_above_age('students.json', 22) == [\\"Alice\\", \\"David\\"] # Your code here def calculate_average_grade(json_file, city): Returns the average grade of students from a specified city. >>> calculate_average_grade('students.json', 'New York') == (85 + 90 + 78 + 70 + 75 + 80) / 6 >>> calculate_average_grade('students.json', 'Los Angeles') == (82 + 88 + 84) / 3 >>> calculate_average_grade('students.json', 'Boston') == (90 + 92 + 89) / 3 >>> calculate_average_grade('students.json', 'NonExistentCity') == 0 # Your code here def save_students_above_grade(json_file, grade_threshold, output_file): Saves a new JSON file containing only the records of students who have grades above the specified threshold. >>> save_students_above_grade('students.json', 79, 'high_grades.json') # Your code here","solution":"import json import os def load_json_data(json_file): Loads JSON data from a file and returns it. if not os.path.exists(json_file): raise FileNotFoundError(f\\"The file {json_file} does not exist.\\") with open(json_file, 'r') as f: data = json.load(f) return data def count_students(json_file): Returns the number of students in the JSON data file. data = load_json_data(json_file) return len(data) def get_students_above_age(json_file, age): Returns a list of names of students older than a specified age. data = load_json_data(json_file) return [student['name'] for student in data if student['age'] > age] def calculate_average_grade(json_file, city): Returns the average grade of students from a specified city. data = load_json_data(json_file) grades = [ grade for student in data if student['city'] == city for grade in student['grades'] ] if not grades: return 0 return sum(grades) / len(grades) def save_students_above_grade(json_file, grade_threshold, output_file): Saves a new JSON file containing only the records of students who have grades above the specified threshold. data = load_json_data(json_file) filtered_data = [ student for student in data if all(grade > grade_threshold for grade in student['grades']) ] with open(output_file, 'w') as f: json.dump(filtered_data, f, indent=4)"},{"question":"def is_rotated_version(s1: str, s2: str) -> bool: Determines if the second string is a rotated version of the first string. Args: s1 (str): the original string. s2 (str): the string to check if it is a rotated version of s1. Returns: bool: True if s2 is a rotated version of s1, False otherwise. >>> is_rotated_version(\\"waterbottle\\", \\"erbottlewat\\") True >>> is_rotated_version(\\"abcde\\", \\"cdeab\\") True >>> is_rotated_version(\\"12345\\", \\"45123\\") True >>> is_rotated_version(\\"waterbottle\\", \\"bottleerwat\\") False >>> is_rotated_version(\\"abcde\\", \\"abcd\\") False >>> is_rotated_version(\\"12345\\", \\"54321\\") False >>> is_rotated_version(\\"\\", \\"\\") True >>> is_rotated_version(\\"aaaaa\\", \\"aaaaa\\") True >>> is_rotated_version(\\"Waterbottle\\", \\"erbottlewat\\") False >>> is_rotated_version(\\"waterbottle\\", \\"ERBOTTLEWAT\\") False","solution":"def is_rotated_version(s1, s2): Determines if s2 is a rotated version of s1. Args: s1 (str): the original string. s2 (str): the string to check if it is a rotated version of s1. Returns: bool: True if s2 is a rotated version of s1, False otherwise. if len(s1) != len(s2): return False return s2 in (s1 + s1)"},{"question":"def most_common_substring(arr: List[str]) -> Tuple[str, int]: Given an array of strings, returns the most common substring and its count. If there is a tie, return any one of the most common substrings. If the array is empty, raise a ValueError. >>> most_common_substring(['apple', 'banana', 'apple', 'orange', 'banana', 'apple']) ('apple', 3) >>> most_common_substring(['apple', 'banana', 'apple', 'banana']) ('apple', 2) >>> most_common_substring(['apple']) ('apple', 1) >>> most_common_substring(['apple', 'banana', 'cherry', 'date']) ('apple', 1) >>> most_common_substring([]) Traceback (most recent call last): ... ValueError: empty array","solution":"def most_common_substring(arr): Returns the most common substring and its count from the array. substring_count = {} # Count the occurrences of each substring for substring in arr: if substring in substring_count: substring_count[substring] += 1 else: substring_count[substring] = 1 # Find the substring with the maximum count most_common_substring = max(substring_count, key=substring_count.get) return (most_common_substring, substring_count[most_common_substring])"},{"question":"def findMajorityElement(nums: List[int]) -> Optional[int]: Finds the majority element in the array, which is the element that appears more than half of the size of the array. If no such element exists, returns None. >>> findMajorityElement([3, 3, 4, 2, 4, 4, 2, 4, 4]) == 4 >>> findMajorityElement([2, 2, 1, 1, 1, 2, 2]) == 2 >>> findMajorityElement([1, 2, 3, 4, 5, 6]) is None >>> findMajorityElement([]) is None >>> findMajorityElement([1]) == 1 >>> findMajorityElement([7, 7, 7, 7, 7]) == 7 >>> findMajorityElement([4] * 5000 + [2] * 4999) == 4","solution":"def findMajorityElement(nums): Finds the majority element in the array, which is the element that appears more than half the size of the array. If no such element exists, returns None. candidate = None count = 0 # Boyer-Moore Voting Algorithm for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) # Verify if the candidate is the majority element if nums.count(candidate) > len(nums) // 2: return candidate else: return None"},{"question":"def remove_duplicates_and_sort(numbers: List[int]) -> List[int]: Takes a list of integers, removes duplicate values, sorts the remaining numbers, and returns the sorted list. >>> remove_duplicates_and_sort([3, 1, 2, 3, 4, 1, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates_and_sort([3, 1, 2, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates_and_sort([]) [] >>> remove_duplicates_and_sort([10]) [10] >>> remove_duplicates_and_sort([1, 1, 1, 1, 1]) [1] >>> remove_duplicates_and_sort([-1, -3, -2, -3, -1, -5]) [-5, -3, -2, -1] >>> remove_duplicates_and_sort([-1, 3, -2, 0, 3, -2, 1]) [-2, -1, 0, 1, 3] unique_numbers = [] for number in numbers: if not number in unique_numbers: unique_numbers.append(number) return unique_numbers.sort()","solution":"def remove_duplicates_and_sort(numbers): Takes a list of integers, removes duplicate values, sorts the remaining numbers, and returns the sorted list. unique_numbers = list(set(numbers)) # Converts the list to a set to remove duplicates, then back to a list unique_numbers.sort() # Sorts the list in ascending order return unique_numbers # Returns the sorted list"},{"question":"def find_longest_palindromic_substring(s: str) -> str: Return the longest palindromic substring in the input string. >>> find_longest_palindromic_substring(\\"babad\\") 'bab' >>> find_longest_palindromic_substring(\\"cbbd\\") 'bb' >>> find_longest_palindromic_substring(\\"a\\") 'a' >>> find_longest_palindromic_substring(\\"ac\\") 'a' >>> find_longest_palindromic_substring(\\"forgeeksskeegfor\\") 'geeksskeeg' def is_palindrome(sub: str) -> bool: # Helper function to check if a given substring is a palindrome without slicing left, right = 0, len(sub)-1 while left < right: if sub[left] != sub[right]: return False left += 1 right -= 1 return True print(find_longest_palindromic_substring(\\"babad\\")) # Expected output: 'bab' print(find_longest_palindromic_substring(\\"cbbd\\")) # Expected output: 'bb' print(find_longest_palindromic_substring(\\"a\\")) # Expected output: 'a' print(find_longest_palindromic_substring(\\"ac\\")) # Expected output: 'a' print(find_longest_palindromic_substring(\\"forgeeksskeegfor\\")) # Expected output: 'geeksskeeg'","solution":"def find_longest_palindromic_substring(s: str) -> str: Return the longest palindromic substring in the input string. >>> find_longest_palindromic_substring(\\"babad\\") 'bab' >>> find_longest_palindromic_substring(\\"cbbd\\") 'bb' >>> find_longest_palindromic_substring(\\"a\\") 'a' >>> find_longest_palindromic_substring(\\"ac\\") 'a' >>> find_longest_palindromic_substring(\\"forgeeksskeegfor\\") 'geeksskeeg' def is_palindrome(sub: str) -> bool: # Helper function to check if a given substring is a palindrome without slicing left, right = 0, len(sub)-1 while left < right: if sub[left] != sub[right]: return False left += 1 right -= 1 return True max_length = 0 longest_palindrome = \\"\\" for i in range(len(s)): for j in range(i, len(s)): # construct substr from s[i] to s[j] without slicing substr = \\"\\" for k in range(i, j + 1): substr += s[k] if is_palindrome(substr): if len(substr) > max_length: max_length = len(substr) longest_palindrome = substr return longest_palindrome"},{"question":"import logging # Configure logging logging.basicConfig(level=logging.ERROR, format='%(asctime)s - %(levelname)s - %(message)s') def factorial(n): Calculates the factorial of a number using recursion with exception handling. Handle invalid inputs and log details. Args: n (int): The number to calculate the factorial for. Must be a non-negative integer. Returns: int: The factorial of the number. Raises: ValueError: If n is negative or not an integer. >>> factorial(5) 120 >>> factorial(0) 1 >>> factorial(-3) Traceback (most recent call last): ... ValueError: Negative numbers are not allowed. >>> factorial(3.5) Traceback (most recent call last): ... ValueError: Factorial is not defined for non-integer values. >>> factorial(\\"Five\\") Traceback (most recent call last): ... ValueError: Factorial is not defined for non-integer values. import pytest from solution import factorial def test_factorial_positive_integers(): assert factorial(5) == 120 assert factorial(0) == 1 assert factorial(3) == 6 def test_factorial_negative_integers(): with pytest.raises(ValueError, match=\\"Negative numbers are not allowed\\"): factorial(-3) def test_factorial_non_integer_values(): with pytest.raises(ValueError, match=\\"Factorial is not defined for non-integer values\\"): factorial(3.5) def test_factorial_string_input(): with pytest.raises(ValueError, match=\\"Factorial is not defined for non-integer values\\"): factorial(\\"Five\\") def test_factorial_logging_negative_integer(caplog): with caplog.at_level(logging.ERROR): with pytest.raises(ValueError): factorial(-3) assert \\"Negative numbers are not allowed\\" in caplog.text def test_factorial_logging_non_integer(caplog): with caplog.at_level(logging.ERROR): with pytest.raises(ValueError): factorial(3.5) assert \\"Factorial is not defined for non-integer values\\" in caplog.text def test_factorial_logging_string_input(caplog): with caplog.at_level(logging.ERROR): with pytest.raises(ValueError): factorial(\\"Five\\") assert \\"Factorial is not defined for non-integer values\\" in caplog.text","solution":"import logging # Configure logging logging.basicConfig(level=logging.ERROR, format='%(asctime)s - %(levelname)s - %(message)s') def factorial(n): try: if not isinstance(n, int): raise ValueError(\\"Factorial is not defined for non-integer values.\\") if n < 0: raise ValueError(\\"Negative numbers are not allowed.\\") if n == 0: return 1 else: return n * factorial(n - 1) except Exception as e: logging.error(f\\"Invalid input: {n}. Error: {str(e)}\\") raise"},{"question":"from typing import List, Dict def count_friends(people: List[Dict[str, List[str]]]) -> Dict[str, int]: Takes a list of people objects and returns a dictionary mapping each person's name to the number of friends they have. >>> people = [ ... {\\"name\\": \\"Alice\\", \\"friends\\": [\\"Bob\\", \\"Charlie\\"]}, ... {\\"name\\": \\"Bob\\", \\"friends\\": [\\"Alice\\"]}, ... {\\"name\\": \\"Charlie\\", \\"friends\\": []} ... ] >>> count_friends(people) {'Alice': 2, 'Bob': 1, 'Charlie': 0} >>> people = [] >>> count_friends(people) {} >>> people = [ ... {\\"name\\": \\"Alice\\", \\"friends\\": []}, ... {\\"name\\": \\"Bob\\", \\"friends\\": []}, ... {\\"name\\": \\"Charlie\\", \\"friends\\": []} ... ] >>> count_friends(people) {'Alice': 0, 'Bob': 0, 'Charlie': 0} >>> people = [ ... {\\"name\\": \\"Alice\\", \\"friends\\": [\\"Bob\\", \\"David\\"]}, ... {\\"name\\": \\"Bob\\", \\"friends\\": [\\"Alice\\", \\"Eve\\"]}, ... {\\"name\\": \\"Charlie\\", \\"friends\\": []} ... ] >>> count_friends(people) {'Alice': 1, 'Bob': 1, 'Charlie': 0} >>> people = [ ... {\\"name\\": \\"Alice\\", \\"friends\\": [\\"Bob\\"]}, ... {\\"name\\": \\"Bob\\", \\"friends\\": [\\"Alice\\"]} ... ] >>> count_friends(people) {'Alice': 1, 'Bob': 1}","solution":"def count_friends(people): Takes a list of people objects and returns a dictionary mapping each person's name to the number of friends they have. # Create a set of valid person names valid_names = {person['name'] for person in people} # Create the result dictionary friends_count = {} for person in people: # Only count friends that are also in the valid names set valid_friends = [friend for friend in person['friends'] if friend in valid_names] friends_count[person['name']] = len(valid_friends) return friends_count"},{"question":"import pandas as pd from sklearn.ensemble import RandomForestClassifier from sklearn.model_selection import cross_val_score, train_test_split from sklearn.metrics import confusion_matrix, classification_report import numpy as np def user_conversion_analysis(data_path): Load user interaction data from the given CSV file path. Build a random forest classifier to predict user conversion (binary classification: 0 for no, 1 for yes). Evaluate the model using cross-validation, and provide a confusion matrix. Perform feature importance analysis to identify the top three features influencing conversion. Args: data_path (str): The path to the CSV file containing the dataset with user interaction features. Returns: dict: A dictionary containing the cross-validation scores, confusion matrix, classification report, feature importances, and the top three most important features. Test examples: >>> from solution import user_conversion_analysis >>> import pandas as pd >>> import numpy as np >>> np.random.seed(42) >>> data = { >>> 'time_on_site': np.random.rand(1000), >>> 'num_pages_visited': np.random.randint(1, 10, 1000), >>> 'bounce_rate': np.random.rand(1000), >>> 'conversion': np.random.randint(0, 2, 1000) >>> } >>> df = pd.DataFrame(data) >>> data_path = 'test_data.csv' >>> df.to_csv(data_path, index=False) >>> results = user_conversion_analysis(data_path) >>> len(results['cross_val_scores']) == 5 True >>> results['confusion_matrix'].shape == (2, 2) True >>> 'precision' in results['classification_report'] True >>> 'recall' in results['classification_report'] True >>> 'f1-score' in results['classification_report'] True >>> len(results['feature_importances']) == 3 True >>> len(results['top_three_features']) == 3 True >>> all(feature in ['time_on_site', 'num_pages_visited', 'bounce_rate'] for feature in results['top_three_features']) True","solution":"from sklearn.ensemble import RandomForestClassifier from sklearn.model_selection import cross_val_score, train_test_split from sklearn.metrics import confusion_matrix, classification_report import pandas as pd import numpy as np def user_conversion_analysis(data_path): # Load the data data = pd.read_csv(data_path) # Assume the last column is the target X = data.iloc[:, :-1] y = data.iloc[:, -1] # Create train and test splits X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Initialize and train the model clf = RandomForestClassifier(random_state=42) clf.fit(X_train, y_train) # Evaluate the model using cross-validation cv_scores = cross_val_score(clf, X, y, cv=5) # Generate predictions y_pred = clf.predict(X_test) # Confusion matrix cm = confusion_matrix(y_test, y_pred) # Classification report report = classification_report(y_test, y_pred) # Feature importance feature_importances = clf.feature_importances_ sorted_indices = np.argsort(feature_importances)[::-1] top_three_features = [X.columns[i] for i in sorted_indices[:3]] return { \\"cross_val_scores\\": cv_scores, \\"confusion_matrix\\": cm, \\"classification_report\\": report, \\"feature_importances\\": feature_importances, \\"top_three_features\\": top_three_features }"},{"question":"def find_largest_product(digits: str, k: int) -> int: Finds the largest product of k consecutive digits in the string. If the string contains non-digit characters, raises ValueError. >>> find_largest_product(\\"123456789\\", 2) 72 >>> find_largest_product(\\"12304a5678\\", 3) ValueError pass import pytest def test_find_largest_product_normal_case(): assert find_largest_product(\\"123456789\\", 2) == 72 def test_find_largest_product_with_identical_digits(): assert find_largest_product(\\"1111111\\", 3) == 1 def test_find_largest_product_with_zeros(): assert find_largest_product(\\"1230456078\\", 2) == 56 def test_find_largest_product_full_length(): assert find_largest_product(\\"987654\\", 3) == 504 def test_find_largest_product_single_digit(): assert find_largest_product(\\"987654\\", 1) == 9 def test_find_largest_product_non_digit_characters(): with pytest.raises(ValueError): find_largest_product(\\"12a34\\", 2) def test_find_largest_product_string_length_equals_k(): assert find_largest_product(\\"123456\\", 6) == 720","solution":"def find_largest_product(digits: str, k: int) -> int: Finds the largest product of k consecutive digits in the string. If the string contains non-digit characters, raises ValueError. # Validate input containing only digits if not digits.isdigit(): raise ValueError(\\"Input string contains non-digit characters.\\") max_product = 0 length = len(digits) for i in range(length - k + 1): # Compute product of the k consecutive digits product = 1 for j in range(k): product *= int(digits[i + j]) # Update max product if the current one is greater if product > max_product: max_product = product return max_product"},{"question":"def first_n_primes(n: int) -> Tuple[List[int], int]: Implement a function that takes an integer \`n\` as input and returns the first \`n\` prime numbers in a list, along with the sum of these prime numbers. Handle cases where the input \`n\` is less than 1 by returning an empty list and a sum of 0. >>> first_n_primes(5) ([2, 3, 5, 7, 11], 28) >>> first_n_primes(0) ([], 0) >>> first_n_primes(-1) ([], 0) >>> first_n_primes(1) ([2], 2) >>> first_n_primes(3) ([2, 3, 5], 10)","solution":"def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def first_n_primes(n): if n < 1: return ([], 0) primes = [] num = 2 while len(primes) < n: if is_prime(num): primes.append(num) num += 1 return (primes, sum(primes))"},{"question":"def is_balanced_parentheses(s: str) -> str: Determines if the parentheses in the string \`s\` are balanced. :param s: A string containing only parentheses characters '(' and ')' :return: \\"Balanced\\" if the string is balanced, otherwise \\"Not Balanced\\" >>> is_balanced_parentheses(\\"()\\") == \\"Balanced\\" >>> is_balanced_parentheses(\\"(())\\") == \\"Balanced\\" >>> is_balanced_parentheses(\\"(()(()))\\") == \\"Balanced\\" >>> is_balanced_parentheses(\\"\\") == \\"Balanced\\" >>> is_balanced_parentheses(\\"(\\") == \\"Not Balanced\\" >>> is_balanced_parentheses(\\")\\") == \\"Not Balanced\\" >>> is_balanced_parentheses(\\"(()\\") == \\"Not Balanced\\" >>> is_balanced_parentheses(\\")(\\") == \\"Not Balanced\\" >>> is_balanced_parentheses(\\"(()())))\\") == \\"Not Balanced\\" >>> is_balanced_parentheses(\\"()\\" * 1000) == \\"Balanced\\" >>> is_balanced_parentheses(\\"()\\" * 999 + \\"(\\") == \\"Not Balanced\\"","solution":"def is_balanced_parentheses(s): Determines if the parentheses in the string \`s\` are balanced. :param s: A string containing only parentheses characters '(' and ')' :return: \\"Balanced\\" if the string is balanced, otherwise \\"Not Balanced\\" stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return \\"Not Balanced\\" stack.pop() if not stack: return \\"Balanced\\" else: return \\"Not Balanced\\""},{"question":"from typing import List, Optional class Ticket: def __init__(self, ticket_id: int, description: str, priority: str): self.ticket_id = ticket_id self.description = description self.priority = self._priority_to_int(priority) def _priority_to_int(self, priority: str) -> int: if priority == \\"high\\": return 1 elif priority == \\"medium\\": return 2 elif priority == \\"low\\": return 3 else: raise ValueError(\\"Invalid priority level\\") def __lt__(self, other: 'Ticket') -> bool: return self.priority < other.priority class TicketManager: def __init__(self): Initialize a new TicketManager with an empty heap. >>> tm = TicketManager() self.heap = [] def add_ticket(self, ticket_id: int, description: str, priority: str): Add a new ticket to the manager. >>> tm = TicketManager() >>> tm.add_ticket(1, \\"First ticket\\", \\"medium\\") >>> tm.add_ticket(2, \\"Second ticket\\", \\"high\\") >>> len(tm.heap) == 2 True ticket = Ticket(ticket_id, description, priority) # Your implementation goes here def get_highest_priority_ticket(self) -> Optional[Ticket]: Retrieve the highest priority ticket without removing it. >>> tm = TicketManager() >>> tm.add_ticket(1, \\"First ticket\\", \\"medium\\") >>> tm.add_ticket(2, \\"Second ticket\\", \\"high\\") >>> ticket = tm.get_highest_priority_ticket() >>> ticket.ticket_id == 2 True # Your implementation goes here def remove_ticket(self, ticket_id: int): Remove a ticket by its ID. >>> tm = TicketManager() >>> tm.add_ticket(1, \\"First ticket\\", \\"medium\\") >>> tm.add_ticket(2, \\"Second ticket\\", \\"high\\") >>> tm.add_ticket(3, \\"Third ticket\\", \\"low\\") >>> tm.remove_ticket(2) >>> len(tm.heap) == 2 True # Your implementation goes here","solution":"import heapq class Ticket: def __init__(self, ticket_id, description, priority): self.ticket_id = ticket_id self.description = description self.priority = self._priority_to_int(priority) def _priority_to_int(self, priority): if priority == \\"high\\": return 1 elif priority == \\"medium\\": return 2 elif priority == \\"low\\": return 3 else: raise ValueError(\\"Invalid priority level\\") def __lt__(self, other): return self.priority < other.priority class TicketManager: def __init__(self): self.heap = [] def add_ticket(self, ticket_id, description, priority): ticket = Ticket(ticket_id, description, priority) heapq.heappush(self.heap, ticket) def get_highest_priority_ticket(self): if not self.heap: return None return self.heap[0] def remove_ticket(self, ticket_id): for i in range(len(self.heap)): if self.heap[i].ticket_id == ticket_id: self.heap.pop(i) heapq.heapify(self.heap) return raise ValueError(\\"Ticket not found\\")"},{"question":"import os def calculate_file_sizes(directory: str) -> dict: Given a directory path, it calculates the total size of all files in the directory and its subdirectories. The function categorizes the files based on their extensions and calculates the cumulative size for each category. It handles nested directories and manages any file read errors gracefully. Args: directory (str): Path to the directory. Returns: dict: A dictionary with file extensions as keys and cumulative sizes as values, and 'total' key for the cumulative size of all files. >>> calculate_file_sizes('/path/to/directory') {'total': 1048576, '.txt': 524288, '.jpg': 524288} Unit Test: from solution import calculate_file_sizes import os def test_calculate_total_size_single_file(tmpdir): # Create a single file and check size file = tmpdir.join(\\"test.txt\\") file.write(\\"hello world\\") expected_size = file.size() result = calculate_file_sizes(tmpdir.strpath) assert result['.txt'] == expected_size assert result['total'] == expected_size def test_calculate_total_size_multiple_files(tmpdir): # Create multiple files with different extensions file1 = tmpdir.join(\\"test1.txt\\") file2 = tmpdir.join(\\"test2.jpg\\") file1.write(\\"hello world\\") file2.write(\\"this is an image\\") expected_size_txt = file1.size() expected_size_jpg = file2.size() expected_total_size = expected_size_txt + expected_size_jpg result = calculate_file_sizes(tmpdir.strpath) assert result['.txt'] == expected_size_txt assert result['.jpg'] == expected_size_jpg assert result['total'] == expected_total_size def test_calculate_total_size_nested_directories(tmpdir): # Create nested directories with files subdir = tmpdir.mkdir(\\"subdir\\") file1 = tmpdir.join(\\"test1.txt\\") file2 = subdir.join(\\"test2.txt\\") file1.write(\\"hello world\\") file2.write(\\"nested file\\") expected_size_txt = file1.size() + file2.size() result = calculate_file_sizes(tmpdir.strpath) assert result['.txt'] == expected_size_txt assert result['total'] == expected_size_txt def test_calculate_total_size_handle_read_error(tmpdir, monkeypatch): # Simulate a read error file = tmpdir.join(\\"test.txt\\") file.write(\\"hello world\\") expected_size = file.size() def mock_getsize(path): if path == file.strpath: raise OSError(\\"File read error\\") return os.path.getsize(file.strpath) monkeypatch.setattr(os.path, 'getsize', mock_getsize) result = calculate_file_sizes(tmpdir.strpath) assert result.get('.txt', 0) == 0 assert result.get('total', 0) == 0","solution":"import os def calculate_file_sizes(directory: str) -> dict: Given a directory path, it calculates the total size of all files in the directory and its subdirectories. The function categorizes the files based on their extensions and calculates the cumulative size for each category. It handles nested directories and manages any file read errors gracefully. Args: directory (str): Path to the directory. Returns: dict: A dictionary with file extensions as keys and cumulative sizes as values, and 'total' key for the cumulative size of all files. sizes = {} for root, dirs, files in os.walk(directory): for file in files: file_path = os.path.join(root, file) try: file_size = os.path.getsize(file_path) file_extension = os.path.splitext(file)[1].lower() if file_extension not in sizes: sizes[file_extension] = 0 sizes[file_extension] += file_size if 'total' not in sizes: sizes['total'] = 0 sizes['total'] += file_size except OSError: # Gracefully ignore files that cannot be read pass return sizes"},{"question":"def reverse_and_sum(arr): Calculate the sum of the elements in the array when it is reversed. Args: arr (List[int]): An array of integers with length between 1 and 100, inclusive. Returns: int: The sum of the elements. >>> reverse_and_sum([5]) 5 >>> reverse_and_sum([1, 2, 3, 4, 5]) 15 >>> reverse_and_sum([-1, -2, -3, -4, -5]) -15 >>> reverse_and_sum([1, -2, 3, -4, 5]) 3 >>> reverse_and_sum([]) 0 def reverse_and_sum_optimized(arr): Calculate the sum of the elements in the array when it is reversed using an optimized approach. Args: arr (List[int]): An array of integers with length between 1 and 100, inclusive. Returns: int: The sum of the elements. >>> reverse_and_sum_optimized([5]) 5 >>> reverse_and_sum_optimized([1, 2, 3, 4, 5]) 15 >>> reverse_and_sum_optimized([-1, -2, -3, -4, -5]) -15 >>> reverse_and_sum_optimized([1, -2, 3, -4, 5]) 3 >>> reverse_and_sum_optimized([]) 0","solution":"def reverse_and_sum(arr): total = 0 for i in range(len(arr)): total += arr[-(i+1)] # Corrected the indexing to access the reversed elements properly return total # Optimized version using Python built-in functions for better readability def reverse_and_sum_optimized(arr): return sum(arr[::-1])"},{"question":"def is_balanced_parentheses(s: str) -> bool: Checks if the given string s is a balanced parentheses expression. Examples: >>> is_balanced_parentheses(\\"([]){}\\") True >>> is_balanced_parentheses(\\"(([{]))\\") False >>> is_balanced_parentheses(\\"(({}))\\") True >>> is_balanced_parentheses(\\"({[)]}\\") False >>> is_balanced_parentheses(\\"\\") True","solution":"def is_balanced_parentheses(s): Checks if the given string s is a balanced parentheses expression. stack = [] matching_bracket = {')': '(', '}': '{', ']': '['} for char in s: if char in '({[': stack.append(char) elif char in ')}]': if not stack or stack[-1] != matching_bracket[char]: return False stack.pop() return not stack"},{"question":"def pack_books(weights: List[int], max_weight: int) -> List[List[int]]: Packs books into the fewest number of boxes possible without exceeding the maximum weight capacity per box. Parameters: weights (list of int): A list of book weights. max_weight (int): Maximum weight capacity per box. Returns: list of list of int: A list where each sublist contains the weights of books in one box. >>> pack_books([3], 5) [[3]] >>> pack_books([2, 3], 5) [[3, 2]] >>> pack_books([2, 2, 2, 2], 6) [[2, 2, 2], [2]] >>> pack_books([4, 4, 4], 4) [[4], [4], [4]] >>> pack_books([1, 2, 3, 4, 5], 5) [[5], [4, 1], [3, 2]] >>> pack_books(list(range(1, 11)), 15) [[10, 5], [9, 6], [8, 7], [4, 3, 2, 1]] >>> pack_books([], 10) [] >>> pack_books([5, 5, 5], 5) [[5], [5], [5]] >>> pack_books([1, 2, 2, 2], 4) [[2, 2], [2, 1]]","solution":"def pack_books(weights, max_weight): Packs books into the fewest number of boxes possible without exceeding the maximum weight capacity per box. Parameters: weights (list of int): A list of book weights. max_weight (int): Maximum weight capacity per box. Returns: list of list of int: A list where each sublist contains the weights of books in one box. weights.sort(reverse=True) packed_boxes = [] while weights: current_box = [] current_weight = 0 for weight in weights[:]: if current_weight + weight <= max_weight: current_box.append(weight) current_weight += weight weights.remove(weight) packed_boxes.append(current_box) return packed_boxes"},{"question":"def longest_uniform_subarray(arr: List[int]) -> int: This function finds the length of the longest contiguous subarray such that all elements in the array have the same value. >>> longest_uniform_subarray([1, 1, 2, 2, 2, 3, 3]) 3 >>> longest_uniform_subarray([]) 0 >>> longest_uniform_subarray([5]) 1 >>> longest_uniform_subarray([3, 3, 3, 3, 3]) 5 >>> longest_uniform_subarray([1, 1, 2, 2, 2, 3, 3, 4, 4, 4, 4, 4, 2, 2, 2]) 5 >>> longest_uniform_subarray([4, 4, 4, 4, 2, 2, 2]) 4 >>> longest_uniform_subarray([2, 2, 2, 3, 3, 4, 4, 4, 4]) 4 >>> longest_uniform_subarray([1, 1, 2, 2, 1, 1, 1, 2, 2]) 3","solution":"def longest_uniform_subarray(arr): This function finds the length of the longest contiguous subarray such that all elements in the array have the same value. # Return 0 for an empty list if not arr: return 0 # Initialize variables to track the longest subarray and current count longest = 0 current_count = 1 # Iterate through the list starting from the second element for i in range(1, len(arr)): if arr[i] == arr[i-1]: # If current element is the same as previous current_count += 1 else: longest = max(longest, current_count) current_count = 1 # Reset count for the new subarray # Compare for the last segment of the array longest = max(longest, current_count) return longest"},{"question":"def combination_sum2(candidates, target): Given a list of integers and a target sum, returns all unique combinations of candidates that add up to the target. Each number in the list may only be used once in the combination. :param candidates: List[int] - list of integers :param target: int - target sum :return: List[List[int]] - list of lists of integers >>> combination_sum2([10, 1, 2, 7, 6, 1, 5], 8) [[1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] >>> combination_sum2([], 8) [] >>> combination_sum2([3, 9, 12], 8) [] >>> combination_sum2([8], 8) [[8]]","solution":"def combination_sum2(candidates, target): Given a list of integers and a target sum, returns all unique combinations of candidates that add up to the target. Each number in the list may only be used once in the combination. :param candidates: List[int] - list of integers :param target: int - target sum :return: List[List[int]] - list of lists of integers def backtrack(start, path, target): if target == 0: res.append(path[:]) return if target < 0: return for i in range(start, len(candidates)): if i > start and candidates[i] == candidates[i-1]: continue path.append(candidates[i]) backtrack(i + 1, path, target - candidates[i]) path.pop() candidates.sort() res = [] backtrack(0, [], target) return res"},{"question":"import pandas as pd def process_transactions(df): Process a dataframe containing customer transaction data to ensure data is clean, convert dates, and summarize transaction amounts by year. Parameters: df (pd.DataFrame): Dataframe containing transaction data with the columns: 'transaction_id' (int), 'customer_id' (int), 'transaction_date' (datetime), 'amount' (float) Returns: pd.DataFrame: A new dataframe with 'customer_id', 'year', and 'total_amount', where 'total_amount' is the sum of 'amount' for each 'customer_id' per year. Example: >>> import pandas as pd >>> from io import StringIO >>> data = StringIO( ... transaction_id,customer_id,transaction_date,amount ... 1,101,2022-01-15,150.00 ... 2,101,2021-12-22,200.50 ... 3,102,2022-02-17,-100.00 ... 4,103,2021-11-30,500.00 ... 5,103,2022-01-20,300.75 ... ) >>> df = pd.read_csv(data) >>> process_transactions(df) customer_id year total_amount 0 101 2021 200.50 1 101 2022 150.00 2 102 2022 -100.00 3 103 2021 500.00 4 103 2022 300.75 pass # Test cases to validate the solution import pandas as pd from io import StringIO import pytest # Helper function to create dataframe for testing def create_test_dataframe(): data = StringIO( transaction_id,customer_id,transaction_date,amount 1,101,2022-01-15,150.00 2,101,2021-12-22,200.50 3,102,2022-02-17,-100.00 4,103,2021-11-30,500.00 5,103,2022-01-20,300.75 ) df = pd.read_csv(data) return df def test_no_missing_values(): df = create_test_dataframe() result = process_transactions(df) assert 'total_amount' in result.columns def test_invalid_date_format(): df = create_test_dataframe() df.loc[0, 'transaction_date'] = 'invalid_date' with pytest.raises(ValueError, match=r\\"Invalid date format detected\\"): process_transactions(df) def test_additional_column_year(): df = create_test_dataframe() result = process_transactions(df) assert 'year' in result.columns def test_total_amount_calculation(): df = create_test_dataframe() result = process_transactions(df) assert (result[(result['customer_id']==101) & (result['year'] == 2021)]['total_amount'].values[0] == 200.50) assert (result[(result['customer_id']==101) & (result['year'] == 2022)]['total_amount'].values[0] == 150.00) assert (result[(result['customer_id']==102) & (result['year'] == 2022)]['total_amount'].values[0] == -100.00) assert (result[(result['customer_id']==103) & (result['year'] == 2021)]['total_amount'].values[0] == 500.00) assert (result[(result['customer_id']==103) & (result['year'] == 2022)]['total_amount'].values[0] == 300.75) def test_missing_values_raises_error(): df = create_test_dataframe() df.loc[0, 'amount'] = None with pytest.raises(ValueError, match=r\\"Missing values detected in the dataframe.\\"): process_transactions(df)","solution":"import pandas as pd def process_transactions(df): # Step 1: Ensure no missing values if df.isnull().values.any(): raise ValueError(\\"Missing values detected in the dataframe.\\") # Step 2: Convert 'transaction_date' to datetime if not already in datetime format if df['transaction_date'].dtype != 'datetime64[ns]': try: df['transaction_date'] = pd.to_datetime(df['transaction_date']) except Exception as e: raise ValueError(f\\"Invalid date format detected: {e}\\") # Step 3: Add a new column 'year' extracting the year from the transaction_date df['year'] = df['transaction_date'].dt.year # Step 4: Group by 'customer_id' and 'year', summing the 'amount' result = df.groupby(['customer_id', 'year']).agg(total_amount=('amount', 'sum')).reset_index() # Step 5: Return the new dataframe return result"},{"question":"def filter_and_sort(lst: List[int], n: int) -> List[int]: Create a function that takes a list of integers and an integer n, and returns a new list containing only the elements that are greater than n. Additionally, sort the returned list in ascending order. >>> filter_and_sort([1, 5, 8, 12, -3, 7], 5) [7, 8, 12] >>> filter_and_sort([1, 5, 8, 12, -3, 7], 8) [12] >>> filter_and_sort([1, 5, 8, 12, -3, 7], 12) [] >>> filter_and_sort([1, 5, 8, 12, -3, 7], -3) [1, 5, 7, 8, 12] >>> filter_and_sort([], 5) [] >>> filter_and_sort([2, 3, 4], 1) [2, 3, 4] >>> filter_and_sort([1, 1, 1, 1], 1) [] >>> filter_and_sort([10, 20, 30, 40, 50, 60], 25) [30, 40, 50, 60] pass","solution":"def filter_and_sort(lst, n): Returns a new list containing only the elements that are greater than n, sorted in ascending order. :param lst: List of integers :param n: Integer threshold :return: Sorted list of integers greater than n return sorted([x for x in lst if x > n])"},{"question":"import random class RandomizedCollection: A data structure that supports O(1) average time complexity for insert and delete operations. Methods: - insert(value): Inserts the value into the data structure. - delete(value): Deletes one occurrence of the value from the data structure. - getRandom(): Returns a random value from the data structure. - getAllValues(): Returns a list of all values in the data structure. def __init__(self): Initialize your data structure here. pass def insert(self, value: int) -> None: Inserts a value to the data structure. pass def delete(self, value: int) -> None: Removes a value from the data structure. Do nothing if the value is not found. pass def getRandom(self) -> int: Returns a random value from the current set of elements. pass def getAllValues(self) -> list: Returns all the values currently present in the data structure. pass def test_insert_and_get_all_values(): collection = RandomizedCollection() collection.insert(1) collection.insert(2) collection.insert(3) assert sorted(collection.getAllValues()) == [1, 2, 3] def test_insert_duplicates_and_get_all_values(): collection = RandomizedCollection() collection.insert(1) collection.insert(1) collection.insert(2) assert sorted(collection.getAllValues()) == [1, 1, 2] def test_delete_and_get_all_values(): collection = RandomizedCollection() collection.insert(1) collection.insert(2) collection.insert(3) collection.delete(2) assert sorted(collection.getAllValues()) == [1, 3] def test_delete_all_occurrences_and_get_all_values(): collection = RandomizedCollection() collection.insert(1) collection.insert(1) collection.insert(2) collection.delete(1) collection.delete(1) assert sorted(collection.getAllValues()) == [2] def test_get_random(): collection = RandomizedCollection() collection.insert(1) collection.insert(2) collection.insert(3) value = collection.getRandom() assert value in [1, 2, 3] def test_get_random_with_duplicates(): collection = RandomizedCollection() collection.insert(1) collection.insert(1) collection.insert(2) value = collection.getRandom() assert value in [1, 2] def test_delete_non_existent_value(): collection = RandomizedCollection() collection.insert(1) collection.insert(2) collection.delete(3) # This should not alter the collection assert sorted(collection.getAllValues()) == [1, 2]","solution":"import random class RandomizedCollection: def __init__(self): Initialize your data structure here. self.value_list = [] self.value_to_indices = {} def insert(self, value: int) -> None: Inserts a value to the data structure. if value in self.value_to_indices: self.value_to_indices[value].add(len(self.value_list)) else: self.value_to_indices[value] = {len(self.value_list)} self.value_list.append(value) def delete(self, value: int) -> None: Removes a value from the data structure. Do nothing if the value is not found. if value in self.value_to_indices and self.value_to_indices[value]: # Get an index of the value to be removed remove_idx = self.value_to_indices[value].pop() # Move the last element to the remove_idx if it's not the last element last_val = self.value_list[-1] self.value_list[remove_idx] = last_val # Update the moved element's index set if self.value_to_indices[last_val]: self.value_to_indices[last_val].add(remove_idx) self.value_to_indices[last_val].remove(len(self.value_list) - 1) # Remove the last element in the list self.value_list.pop() # Remove the entry from the dictionary if it's empty if not self.value_to_indices[value]: del self.value_to_indices[value] def getRandom(self) -> int: Returns a random value from the current set of elements. return random.choice(self.value_list) def getAllValues(self) -> list: Returns all the values currently present in the data structure. return self.value_list[:]"},{"question":"def longest_substring_with_k_distinct(input_str: str, k: int) -> int: Returns the length of the longest substring that contains exactly k distinct characters. If no such substring exists, returns 0. >>> longest_substring_with_k_distinct(\\"eceba\\", 2) 3 >>> longest_substring_with_k_distinct(\\"aa\\", 1) 2 >>> longest_substring_with_k_distinct(\\"aabcd\\", 3) 4 from solution import longest_substring_with_k_distinct def test_with_two_distinct(): assert longest_substring_with_k_distinct(\\"eceba\\", 2) == 3 # \\"ece\\" def test_with_all_same_characters(): assert longest_substring_with_k_distinct(\\"aa\\", 1) == 2 # \\"aa\\" def test_with_three_distinct(): assert longest_substring_with_k_distinct(\\"aabcd\\", 3) == 4 # \\"aabc\\" def test_with_zero_k(): assert longest_substring_with_k_distinct(\\"abc\\", 0) == 0 # No valid substring def test_with_empty_string(): assert longest_substring_with_k_distinct(\\"\\", 2) == 0 # No valid substring def test_with_large_k(): assert longest_substring_with_k_distinct(\\"abcdef\\", 10) == 0 # k is larger than unique chars in string def test_single_character(): assert longest_substring_with_k_distinct(\\"aaaa\\", 1) == 4 # \\"aaaa\\" def test_distinct_characters(): assert longest_substring_with_k_distinct(\\"abcde\\", 3) == 3 # Any three characters def test_exact_number_of_distinct_characters(): assert longest_substring_with_k_distinct(\\"aabbcc\\", 2) == 4 # \\"aabb\\" or \\"bbcc\\"","solution":"def longest_substring_with_k_distinct(input_str, k): Returns the length of the longest substring with exactly k distinct characters. If no such substring exists, returns 0. if k == 0 or not input_str: return 0 n = len(input_str) window_start = 0 max_length = 0 char_frequency = {} for window_end in range(n): right_char = input_str[window_end] if right_char not in char_frequency: char_frequency[right_char] = 0 char_frequency[right_char] += 1 while len(char_frequency) > k: left_char = input_str[window_start] char_frequency[left_char] -= 1 if char_frequency[left_char] == 0: del char_frequency[left_char] window_start += 1 if len(char_frequency) == k: max_length = max(max_length, window_end - window_start + 1) return max_length"},{"question":"def rotate_matrix_90_clockwise(matrix): Rotates an NxN matrix 90 degrees clockwise. Args: matrix (list of list of int): NxN matrix to be rotated. Returns: list of list of int: New NxN matrix that is the result of the rotation. Raises: ValueError: If the input is not a square matrix. Examples: >>> rotate_matrix_90_clockwise([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix_90_clockwise([ ... [1, 2], ... [3, 4] ... ]) [[3, 1], [4, 2]]","solution":"def rotate_matrix_90_clockwise(matrix): Rotates an NxN matrix 90 degrees clockwise. Args: matrix (list of list of int): NxN matrix to be rotated. Returns: list of list of int: New NxN matrix that is the result of the rotation. if not matrix or not all(len(row) == len(matrix) for row in matrix): raise ValueError(\\"Input should be a square matrix.\\") n = len(matrix) # Rotate the matrix 90 degrees clockwise rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n - 1 - i] = matrix[i][j] return rotated_matrix"},{"question":"def consecutive_character_count(s: str) -> List[Tuple[str, int]]: Implement a function \`consecutive_character_count\` that takes a string and returns a list of tuples, where each tuple contains a character from the string and the number of consecutive occurrences of that character. Do not include spaces in the output. >>> consecutive_character_count(\\"aabbcccddee\\") [('a', 2), ('b', 2), ('c', 3), ('d', 2), ('e', 2)] >>> consecutive_character_count(\\"aaBBccCdDee\\") [('a', 2), ('B', 2), ('c', 2), ('C', 1), ('d', 1), ('D', 1), ('e', 2)] >>> consecutive_character_count(\\" aabb ccc ddee \\") [('a', 2), ('b', 2), ('c', 3), ('d', 2), ('e', 2)] >>> consecutive_character_count(\\"abcdef\\") [('a', 1), ('b', 1), ('c', 1), ('d', 1), ('e', 1), ('f', 1)] >>> consecutive_character_count(\\" \\") [] >>> consecutive_character_count(\\"\\") []","solution":"def consecutive_character_count(s): Returns a list of tuples, where each tuple contains a character from the string and the number of consecutive occurrences of that character, excluding spaces. if not s: return [] result = [] prev_char = '' count = 0 for char in s: if char == ' ': continue if char == prev_char: count += 1 else: if prev_char: result.append((prev_char, count)) prev_char = char count = 1 if prev_char: result.append((prev_char, count)) return result"},{"question":"def remove_adjacent_duplicates(s: str) -> str: Removes duplicate adjacent characters from the given string. Parameters: s (str): The input string. Returns: str: The string with adjacent duplicates removed. Examples: >>> remove_adjacent_duplicates(\\"abcde\\") 'abcde' >>> remove_adjacent_duplicates(\\"aabbcc\\") 'abc' >>> remove_adjacent_duplicates(\\"\\") '' >>> remove_adjacent_duplicates(\\"aabbccddeeff\\") 'abcdef' >>> remove_adjacent_duplicates(\\"a\\") 'a' >>> remove_adjacent_duplicates(\\"aaabbbccc\\") 'abc' >>> remove_adjacent_duplicates(\\"abababab\\") 'abababab' >>> remove_adjacent_duplicates(\\"aaaaaa\\") 'a' >>> remove_adjacent_duplicates(\\"aabbaa\\") 'aba'","solution":"def remove_adjacent_duplicates(s): Removes duplicate adjacent characters from the given string. Parameters: s (str): The input string. Returns: str: The string with adjacent duplicates removed. if not s: return s result = [s[0]] for char in s[1:]: if char != result[-1]: result.append(char) return ''.join(result)"},{"question":"def books_by_genre(books, genre=None): Returns a list of book titles that belong to the specified genre. If genre is not provided, returns all book titles. Args: books (list): List of dictionaries where each dictionary represents a book. genre (str, optional): The genre to filter books by. Defaults to None. Returns: list: List of book titles that match the specified genre or all titles if no genre is provided.","solution":"def books_by_genre(books, genre=None): Returns a list of book titles that belong to the specified genre. If genre is not provided, returns all book titles. Args: books (list): List of dictionaries where each dictionary represents a book. genre (str, optional): The genre to filter books by. Defaults to None. Returns: list: List of book titles that match the specified genre or all titles if no genre is provided. if genre is None: return [book['title'] for book in books] titles = [] for book in books: if 'genres' in book and genre in book['genres']: titles.append(book['title']) return titles"},{"question":"def remove_duplicates(nums): Removes duplicate elements from the list while maintaining order of first appearance. Parameters: nums (list of int): The list from which to remove duplicates. Returns: list of int: A new list with duplicates removed. # Your code here # Example Usage and Tests if __name__ == \\"__main__\\": input_list = [1, 3, 2, 3, 4, 2, 1, 5] print(remove_duplicates(input_list)) # expected output: [1, 3, 2, 4, 5] def test_remove_duplicates_typical_case(): assert remove_duplicates([1, 3, 2, 3, 4, 2, 1, 5]) == [1, 3, 2, 4, 5] def test_remove_duplicates_no_duplicates(): assert remove_duplicates([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_remove_duplicates_all_duplicates(): assert remove_duplicates([1, 1, 1, 1, 1]) == [1] def test_remove_duplicates_empty_list(): assert remove_duplicates([]) == [] def test_remove_duplicates_large_input(): large_input = list(range(1000)) + list(range(500)) expected_output = list(range(1000)) assert remove_duplicates(large_input) == expected_output # Run tests test_remove_duplicates_typical_case() test_remove_duplicates_no_duplicates() test_remove_duplicates_all_duplicates() test_remove_duplicates_empty_list() test_remove_duplicates_large_input()","solution":"def remove_duplicates(nums): Removes duplicate elements from the list while maintaining order of first appearance. Parameters: nums (list of int): The list from which to remove duplicates. Returns: list of int: A new list with duplicates removed. seen = set() result = [] for num in nums: if num not in seen: result.append(num) seen.add(num) return result"},{"question":"def can_form_palindrome(s: str) -> bool: Check if a given string can be rearranged to form a palindrome. A string can form a palindrome if at most one character appears an odd number of times; all other characters must appear an even number of times. The function handles edge cases such as empty strings, strings with only one character, and input types other than strings. It also recognizes and handles large input strings effectively without compromising performance. Args: s (str): The input string to check. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. >>> can_form_palindrome(\\"\\") True >>> can_form_palindrome(\\"a\\") True >>> can_form_palindrome(\\"aabbcc\\") True >>> can_form_palindrome(\\"aabbc\\") True >>> can_form_palindrome(\\"aabbcd\\") False >>> can_form_palindrome(\\"aA\\") False >>> can_form_palindrome(\\"Aa\\") False # Erroneous code example if not isinstance(s, str): raise ValueError(\\"Input must be a string\\") char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 return odd_count < 2 # Incorrect logic for checking odd character counts","solution":"def can_form_palindrome(s): Check if a given string can be rearranged to form a palindrome. Args: s (str): The input string to check. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. if not isinstance(s, str): raise ValueError(\\"Input must be a string\\") if s == \\"\\": return True from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"def count_unique_characters(input_string: str) -> dict: Develop a function in Python that takes a string as an input and returns the count of each unique character in the string. The function should return a dictionary where the keys are the unique characters and the values are their respective counts. Consider all edge cases, such as an empty string or strings with spaces, punctuation, and varying cases (i.e., treat 'A' and 'a' as different characters). >>> count_unique_characters(\\"Hello, World!\\") {'H': 1, 'e': 1, 'l': 3, 'o': 2, ',': 1, ' ': 1, 'W': 1, 'r': 1, 'd': 1, '!': 1} >>> count_unique_characters(\\"\\") {} >>> count_unique_characters(\\"aabc!! \\") {'a': 2, 'b': 1, 'c': 1, '!': 2, ' ': 2} >>> count_unique_characters(\\"AaBbCc\\") {'A': 1, 'a': 1, 'B': 1, 'b': 1, 'C': 1, 'c': 1} >>> count_unique_characters(\\"112233\\") {'1': 2, '2': 2, '3': 2}","solution":"def count_unique_characters(input_string): Returns a dictionary with the count of each unique character in the input string. char_count = {} for char in input_string: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 return char_count"},{"question":"def filter_greater_than_mean(numbers: list) -> list: Create a function that receives a list of numbers and returns a new list containing only the elements that are larger than the arithmetic mean of the original list. Args: numbers: A list of numbers. Returns: A list of numbers greater than the arithmetic mean of the original list. Examples: >>> filter_greater_than_mean([1, 5, 3, 7, 2, 6]) [5, 7, 6] >>> filter_greater_than_mean([4, 4, 4, 4]) [] >>> filter_greater_than_mean([]) [] >>> filter_greater_than_mean([10]) [] >>> filter_greater_than_mean([-1, -3, 0, 2, 4, 6]) [2, 4, 6] >>> filter_greater_than_mean([1, 2, 2, 2]) [2, 2, 2] >>> filter_greater_than_mean([1.5, 2.5, 3.5, 5.0]) [3.5, 5.0]","solution":"def filter_greater_than_mean(numbers: list) -> list: Returns a new list containing only the elements that are larger than the arithmetic mean of the original list. Args: numbers: A list of numbers. Returns: A list of numbers greater than the arithmetic mean of the original list. if not numbers: return [] arithmetic_mean = sum(numbers) / len(numbers) return [x for x in numbers if x > arithmetic_mean]"},{"question":"def find_pairs_with_sum(nums: list, target: int) -> (list, int): Write a function that takes an unordered list of integers, identifies all the pairs of integers whose sum is equal to a given target, and returns these pairs as a list of tuples. Each pair should be listed only once, even if there are duplicate elements that can form the same sum. Additionally, it should work correctly even if the input list contains negative numbers and zero. If no such pairs exist, the function should return an empty list. The function should also include a feature to return the count of total unique pairs found. Parameters: nums (list of int): The list of integers. target (int): The target sum for pairs. Returns: list of tuple: A list containing tuples of unique pairs that add up to the target sum. int: The total unique pairs found. >>> find_pairs_with_sum([1, 2, 3, 4, 5], 5) ([(1, 4), (2, 3)], 2) >>> find_pairs_with_sum([-1, -2, 0, 1, 2, 3, 4, 5], 3) ([(-2, 5), (0, 3), (-1, 4), (1, 2)], 4) >>> find_pairs_with_sum([1, 1, 2, 2, 3, 3, 4, 4], 5) ([(1, 4), (2, 3)], 2) >>> find_pairs_with_sum([], 10) ([], 0) >>> find_pairs_with_sum([1, 2, 3], 7) ([], 0)","solution":"def find_pairs_with_sum(nums, target): Finds unique pairs in the list \`nums\` that sum up to \`target\`. Parameters: nums (list of int): The list of integers. target (int): The target sum for pairs. Returns: list of tuple: A list containing tuples of unique pairs that add up to the target sum. int: The total unique pairs found. if not nums: return [], 0 nums_set = set(nums) pairs = set() for num in nums_set: complement = target - num if complement in nums_set: pair = tuple(sorted((num, complement))) pairs.add(pair) return list(pairs), len(pairs)"},{"question":"from typing import List from collections import Counter def is_anagram_of_palindrome(s: str) -> bool: Check if the given string is an anagram of a palindrome. >>> is_anagram_of_palindrome(\\"civic\\") True >>> is_anagram_of_palindrome(\\"ivicc\\") True >>> is_anagram_of_palindrome(\\"hello\\") False >>> is_anagram_of_palindrome(\\"A man a plan a canal Panama\\") True pass def filter_anagrams_of_palindrome(lst: List[str]) -> List[str]: Returns a list of strings that are anagrams of a palindrome. >>> filter_anagrams_of_palindrome([\\"civic\\", \\"ivicc\\", \\"hello\\", \\"banana\\"]) [\\"civic\\", \\"ivicc\\"] pass def add_and_filter_anagrams_of_palindrome(lst: List[str], extra_strs: List[str]) -> List[str]: Adds extra strings to the list and returns a list of strings that are anagrams of a palindrome. Also removes any strings from either list that are not valid strings. >>> add_and_filter_anagrams_of_palindrome([\\"civic\\", \\"apple\\", \\"banana\\"], [\\"radar\\", \\"rotor\\", \\"hello\\"]) [\\"civic\\", \\"radar\\", \\"rotor\\"] >>> add_and_filter_anagrams_of_palindrome([\\"civic\\", 123, None], [\\"radar\\", True, \\"hello\\"]) [\\"civic\\", \\"radar\\"] >>> add_and_filter_anagrams_of_palindrome([], []) [] pass","solution":"from collections import Counter def is_anagram_of_palindrome(s): Check if the given string is an anagram of a palindrome. s = s.lower().replace(' ', '') count = Counter(s) odd_count = sum(1 for val in count.values() if val % 2 != 0) return odd_count <= 1 def filter_anagrams_of_palindrome(lst): Returns a list of strings that are anagrams of a palindrome. return [s for s in lst if is_anagram_of_palindrome(s)] def add_and_filter_anagrams_of_palindrome(lst, extra_strs): Adds extra strings to the list and returns a list of strings that are anagrams of a palindrome. Also removes any strings from either list that are not valid strings. valid_strings = [s for s in lst + extra_strs if isinstance(s, str) and s] return filter_anagrams_of_palindrome(valid_strings)"},{"question":"def double_primes(arr): Function to double the prime numbers in a list while keeping non-prime numbers unchanged. Constraints: - 1 <= len(arr) <= 10^5 - -10^9 <= arr[i] <= 10^9 >>> double_primes([2, 3, 4, 5, 6, 7, 8, 9]) [4, 6, 4, 10, 6, 14, 8, 9] >>> double_primes([11, 13, 17, 19, 23]) [22, 26, 34, 38, 46] >>> double_primes([1, 4, 6, 8, 10]) [1, 4, 6, 8, 10] >>> double_primes([31, 33, 37, 39, 41]) [62, 33, 74, 39, 82] >>> double_primes([-3, -5, -7, 0, 1]) [6, 10, 14, 0, 1]","solution":"def double_primes(arr): Function to double the prime numbers in a list while keeping non-prime numbers unchanged. Args: arr (list of int): The list of integers. Returns: list of int: A new list where prime numbers are doubled and non-prime numbers are unchanged. def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True return [2 * x if is_prime(abs(x)) else x for x in arr]"},{"question":"def check_special_chars(s: str) -> bool: Verify if a given string contains any of the special characters !, @, #, , %, ^, &, *, (, ). >>> check_special_chars(\\"hello\\") == False >>> check_special_chars(\\"world!\\") == True >>> check_special_chars(\\"good@morning\\") == True >>> check_special_chars(\\"happy#day\\") == True >>> check_special_chars(\\"pythonis\\") == True >>> check_special_chars(\\"great%^\\") == True >>> check_special_chars(\\"let&us\\") == True >>> check_special_chars(\\"code*\\") == True >>> check_special_chars(\\"(together)\\") == True >>> check_special_chars(\\"make)it(happen\\") == True >>> check_special_chars(\\"\\") == False >>> check_special_chars(\\"!@#%^&*()\\") == True","solution":"def check_special_chars(s): Checks if the given string contains any special characters. Special characters to check: !, @, #, , %, ^, &, *, (, ) Args: s (str): The string to check. Returns: bool: True if any special character is found, False otherwise. special_chars = \\"!@#%^&*()\\" return any(char in special_chars for char in s)"},{"question":"class BankAccount: A class representing a bank account. Attributes: account_number (str): The account number of the bank account. account_holder (str): The name of the account holder. balance (float): The current balance of the bank account. Methods: deposit(amount): Adds the specified amount to the account balance. withdraw(amount): Deducts the specified amount from the account balance if sufficient funds are available. display_balance(): Returns the current account balance. validate_account_number(account_number): Validates that the account number is a string. validate_account_holder(account_holder): Validates that the account holder is a string. validate_balance(balance): Validates that the balance is a non-negative float. def __init__(self, account_number: str, account_holder: str, balance: float) -> None: self.validate_account_number(account_number) self.validate_account_holder(account_holder) self.validate_balance(balance) self.account_number = account_number self.account_holder = account_holder self.balance = balance def deposit(self, amount: float) -> None: Deposits the specified amount to the account balance. pass # Implementation goes here. def withdraw(self, amount: float) -> None: Withdraws the specified amount from the account balance. pass # Implementation goes here. def display_balance(self) -> float: Displays the current balance. pass # Implementation goes here. @staticmethod def validate_account_number(account_number: str) -> None: Validates that the account number is a string. pass # Implementation goes here. @staticmethod def validate_account_holder(account_holder: str) -> None: Validates that the account holder is a string. pass # Implementation goes here. @staticmethod def validate_balance(balance: float) -> None: Validates that the balance is a non-negative float. pass # Implementation goes here.","solution":"class BankAccount: def __init__(self, account_number, account_holder, balance) -> None: self.validate_account_number(account_number) self.validate_account_holder(account_holder) self.validate_balance(balance) self.account_number = account_number self.account_holder = account_holder self.balance = balance def deposit(self, amount): if amount <= 0: raise ValueError(\\"Deposit amount must be positive\\") self.balance += amount def withdraw(self, amount): if amount <= 0: raise ValueError(\\"Withdrawal amount must be positive\\") if amount > self.balance: raise ValueError(\\"Insufficient balance\\") self.balance -= amount def display_balance(self): return self.balance @staticmethod def validate_account_number(account_number): if not isinstance(account_number, str): raise ValueError(\\"Account number must be a string\\") @staticmethod def validate_account_holder(account_holder): if not isinstance(account_holder, str): raise ValueError(\\"Account holder must be a string\\") @staticmethod def validate_balance(balance): if not isinstance(balance, (int, float)) or balance < 0: raise ValueError(\\"Balance must be a non-negative number\\")"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def binary_tree_paths_and_sums(root): Returns all the paths from root to each leaf node and their sums in the form of two lists. :param root: TreeNode, the root of the binary tree. :return: tuple of two lists, (paths, sums) >>> paths, sums = binary_tree_paths_and_sums(None) >>> paths == [] and sums == [] True >>> root = TreeNode(1) >>> paths, sums = binary_tree_paths_and_sums(root) >>> paths == [[1]] and sums == [1] True >>> root = TreeNode(5) >>> root.left = TreeNode(4) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(11) >>> root.left.left.left = TreeNode(7) >>> root.left.left.right = TreeNode(2) >>> root.right.left = TreeNode(13) >>> root.right.right = TreeNode(4) >>> root.right.right.right = TreeNode(1) >>> paths, sums = binary_tree_paths_and_sums(root) >>> expected_paths = [[5, 4, 11, 7], [5, 4, 11, 2], [5, 8, 13], [5, 8, 4, 1]] >>> expected_sums = [27, 22, 26, 18] >>> paths == expected_paths and sums == expected_sums True >>> root = TreeNode(3) >>> root.left = TreeNode(1) >>> root.right = TreeNode(2) >>> paths, sums = binary_tree_paths_and_sums(root) >>> expected_paths = [[3, 1], [3, 2]] >>> expected_sums = [4, 5] >>> paths == expected_paths and sums == expected_sums True >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.left.left = TreeNode(3) >>> paths, sums = binary_tree_paths_and_sums(root) >>> expected_paths = [[10, 5, 3]] >>> expected_sums = [18] >>> paths == expected_paths and sums == expected_sums True >>> root = TreeNode(10) >>> root.right = TreeNode(20) >>> root.right.right = TreeNode(30) >>> paths, sums = binary_tree_paths_and_sums(root) >>> expected_paths = [[10, 20, 30]] >>> expected_sums = [60] >>> paths == expected_paths and sums == expected_sums True pass","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def binary_tree_paths_and_sums(root): Returns all the paths from root to each leaf node and their sums in the form of two lists. :param root: TreeNode, the root of the binary tree. :return: tuple of two lists, (paths, sums) def dfs(node, path, paths, sums): if not node: return path.append(node.value) if not node.left and not node.right: paths.append(list(path)) sums.append(sum(path)) else: if node.left: dfs(node.left, path, paths, sums) if node.right: dfs(node.right, path, paths, sums) path.pop() paths = [] sums = [] dfs(root, [], paths, sums) return paths, sums"},{"question":"import heapq import asyncio class IntelligentSorter: An intelligent sorting algorithm capable of managing large data sets that are dynamically updated. The algorithm ensures efficient time complexity and adaptability to continuous data input. def __init__(self): self.min_heap = [] def add_number(self, number): Add a number to the sorter. pass def get_sorted_list(self): Retrieve the sorted list of all numbers added so far. pass async def simulate_data_stream(sorter, data_stream): Simulate asynchronous data stream input. pass async def main(): Main function to demonstrate the sorting algorithm with a sample data stream. pass def test_intelligent_sorter_simple(): Test with a simple data stream. sorter = IntelligentSorter() data_stream = [5, 1, 3, 9, 7, 2, 6, 4, 8] asyncio.run(simulate_data_stream(sorter, data_stream)) sorted_list = sorter.get_sorted_list() assert sorted_list == sorted(data_stream) def test_intelligent_sorter_already_sorted(): Test with an already sorted data stream. sorter = IntelligentSorter() data_stream = [1, 2, 3, 4, 5, 6, 7, 8, 9] asyncio.run(simulate_data_stream(sorter, data_stream)) sorted_list = sorter.get_sorted_list() assert sorted_list == sorted(data_stream) def test_intelligent_sorter_reversed(): Test with a reversed data stream. sorter = IntelligentSorter() data_stream = [9, 8, 7, 6, 5, 4, 3, 2, 1] asyncio.run(simulate_data_stream(sorter, data_stream)) sorted_list = sorter.get_sorted_list() assert sorted_list == sorted(data_stream) def test_main_function(): Test the main function with a sample data stream. sorted_list = asyncio.run(main()) assert sorted_list == [1, 2, 3, 4, 5, 6, 7, 8, 9]","solution":"import heapq class IntelligentSorter: def __init__(self): self.min_heap = [] def add_number(self, number): heapq.heappush(self.min_heap, number) def get_sorted_list(self): return [heapq.heappop(self.min_heap) for _ in range(len(self.min_heap))] # Demo function to simulate asynchronous data stream input and sorting import asyncio async def simulate_data_stream(sorter, data_stream): for number in data_stream: await asyncio.sleep(0.1) # Simulate delay in data stream sorter.add_number(number) async def main(): sorter = IntelligentSorter() data_stream = [5, 1, 3, 9, 7, 2, 6, 4, 8] await simulate_data_stream(sorter, data_stream) sorted_list = sorter.get_sorted_list() return sorted_list"},{"question":"def words_length(words: List[str]) -> Dict[str, int]: Returns a dictionary where the keys are the words sorted alphabetically ignoring case, and the values are the lengths of these words. >>> words_length([\\"Apple\\", \\"banana\\", \\"Cherry\\", \\"date\\"]) == {\\"Apple\\": 5, \\"banana\\": 6, \\"Cherry\\": 6, \\"date\\": 4} >>> words_length([\\"Zebra\\", \\"apple\\", \\"Mango\\"]) == {\\"apple\\": 5, \\"Mango\\": 5, \\"Zebra\\": 5} >>> words_length([]) == {} # Function implementation here def longest_words(words: List[str]) -> List[str]: Returns a list of the longest word(s) in the original list. >>> longest_words([\\"Apple\\", \\"banana\\", \\"Cherry\\", \\"date\\"]) == [\\"banana\\", \\"Cherry\\"] >>> longest_words([\\"elephant\\", \\"cat\\", \\"dog\\", \\"whale\\"]) == [\\"elephant\\"] >>> longest_words([\\"one\\", \\"two\\", \\"three\\", \\"fourteen\\"]) == [\\"fourteen\\"] >>> longest_words([]) == [] >>> longest_words([\\"short\\", \\"longer\\", \\"biggest\\", \\"biggest\\", \\"lengthiest\\", \\"lengthiest\\"]) == [\\"lengthiest\\", \\"lengthiest\\"] # Function implementation here from typing import List, Dict import unittest class TestStringMethods(unittest.TestCase): def test_words_length(self): self.assertEqual(words_length([\\"Apple\\", \\"banana\\", \\"Cherry\\", \\"date\\"]), {\\"Apple\\": 5, \\"banana\\": 6, \\"Cherry\\": 6, \\"date\\": 4}) self.assertEqual(words_length([\\"Zebra\\", \\"apple\\", \\"Mango\\"]), {\\"apple\\": 5, \\"Mango\\": 5, \\"Zebra\\": 5}) self.assertEqual(words_length([]), {}) def test_longest_words(self): self.assertEqual(longest_words([\\"Apple\\", \\"banana\\", \\"Cherry\\", \\"date\\"]), [\\"banana\\", \\"Cherry\\"]) self.assertEqual(longest_words([\\"elephant\\", \\"cat\\", \\"dog\\", \\"whale\\"]), [\\"elephant\\"]) self.assertEqual(longest_words([\\"one\\", \\"two\\", \\"three\\", \\"fourteen\\"]), [\\"fourteen\\"]) self.assertEqual(longest_words([]), []) def test_longest_words_with_ties(self): self.assertEqual(longest_words([\\"short\\", \\"longer\\", \\"biggest\\", \\"biggest\\", \\"lengthiest\\", \\"lengthiest\\"]), [\\"lengthiest\\", \\"lengthiest\\"]) if __name__ == \\"__main__\\": unittest.main()","solution":"def words_length(words): Returns a dictionary where the keys are the words sorted alphabetically ignoring case, and the values are the lengths of these words. sorted_words = sorted(words, key=lambda word: word.lower()) return {word: len(word) for word in sorted_words} def longest_words(words): Returns a list of the longest word(s) in the original list. if not words: return [] max_length = max(len(word) for word in words) return [word for word in words if len(word) == max_length]"},{"question":"import csv from collections import defaultdict def analyze_sales(csv_file_path, start_date, end_date): Analyzes the sales data from the given CSV file and returns the total sales for each item, the item with the highest sales, and the item with the highest quantity sold. Args: csv_file_path (str): The path to the CSV file. start_date (str): The start date in the format 'YYYY-MM-DD'. end_date (str): The end date in the format 'YYYY-MM-DD'. Returns: tuple: A tuple containing: - total_sales (dict): A dictionary with item names as keys and total sales as values. - highest_sales_item (str): The item with the highest sales. - highest_quantity_item (str): The item with the highest quantity sold. # Unit tests import pytest import csv from solution import analyze_sales def create_csv(file_path, data): with open(file_path, mode='w', newline='') as file: writer = csv.DictWriter(file, fieldnames=data[0].keys()) writer.writeheader() writer.writerows(data) def test_analyze_sales(): data = [ {\\"Item\\": \\"Apple\\", \\"Price\\": \\"1.0\\", \\"Quantity\\": \\"10\\", \\"Date\\": \\"2023-01-01\\"}, {\\"Item\\": \\"Banana\\", \\"Price\\": \\"0.5\\", \\"Quantity\\": \\"20\\", \\"Date\\": \\"2023-01-01\\"}, {\\"Item\\": \\"Apple\\", \\"Price\\": \\"1.0\\", \\"Quantity\\": \\"15\\", \\"Date\\": \\"2023-01-02\\"}, {\\"Item\\": \\"Banana\\", \\"Price\\": \\"0.5\\", \\"Quantity\\": \\"5\\", \\"Date\\": \\"2023-01-02\\"}, {\\"Item\\": \\"Cherry\\", \\"Price\\": \\"2.0\\", \\"Quantity\\": \\"8\\", \\"Date\\": \\"2023-01-01\\"}, ] create_csv(\\"test_sales.csv\\", data) total_sales, highest_sales_item, highest_quantity_item = analyze_sales(\\"test_sales.csv\\", \\"2023-01-01\\", \\"2023-01-02\\") assert total_sales == {\\"Apple\\": 25.0, \\"Banana\\": 12.5, \\"Cherry\\": 16.0} assert highest_sales_item == \\"Apple\\" assert highest_quantity_item == \\"Apple\\" def test_analyze_sales_no_data(): data = [ {\\"Item\\": \\"Apple\\", \\"Price\\": \\"1.0\\", \\"Quantity\\": \\"10\\", \\"Date\\": \\"2023-01-01\\"}, {\\"Item\\": \\"Banana\\", \\"Price\\": \\"0.5\\", \\"Quantity\\": \\"20\\", \\"Date\\": \\"2023-01-01\\"}, ] create_csv(\\"test_no_data_sales.csv\\", data) with pytest.raises(ValueError, match=\\"No sales data found in the specified date range.\\"): analyze_sales(\\"test_no_data_sales.csv\\", \\"2023-02-01\\", \\"2023-02-28\\") def test_file_not_found(): with pytest.raises(FileNotFoundError, match=\\"The specified file was not found.\\"): analyze_sales(\\"non_existent_file.csv\\", \\"2023-01-01\\", \\"2023-01-02\\") def test_malformed_data(): data = [ {\\"Item\\": \\"Apple\\", \\"Price\\": \\"1.0\\", \\"Quantity\\": \\"10\\", \\"Date\\": \\"2023-01-01\\"}, {\\"Item\\": \\"Banana\\", \\"Price\\": \\"invalid_price\\", \\"Quantity\\": \\"20\\", \\"Date\\": \\"2023-01-01\\"}, ] create_csv(\\"test_malformed_sales.csv\\", data) total_sales, highest_sales_item, highest_quantity_item = analyze_sales(\\"test_malformed_sales.csv\\", \\"2023-01-01\\", \\"2023-01-02\\") assert total_sales == {\\"Apple\\": 10.0} assert highest_sales_item == \\"Apple\\" assert highest_quantity_item == \\"Apple\\"","solution":"import csv from collections import defaultdict def analyze_sales(csv_file_path, start_date, end_date): Analyzes the sales data from the given CSV file and returns the total sales for each item, the item with the highest sales, and the item with the highest quantity sold. Args: csv_file_path (str): The path to the CSV file. start_date (str): The start date in the format 'YYYY-MM-DD'. end_date (str): The end date in the format 'YYYY-MM-DD'. Returns: tuple: A tuple containing: - total_sales (dict): A dictionary with item names as keys and total sales as values. - highest_sales_item (str): The item with the highest sales. - highest_quantity_item (str): The item with the highest quantity sold. total_sales = defaultdict(float) total_quantity = defaultdict(int) try: with open(csv_file_path, mode='r') as file: reader = csv.DictReader(file) for row in reader: try: item = row['Item'] price = float(row['Price']) quantity = int(row['Quantity']) date = row['Date'] if start_date <= date <= end_date: total_sales[item] += price * quantity total_quantity[item] += quantity except (ValueError, KeyError) as e: print(f\\"Skipping row due to malformed data: {row}, Error: {e}\\") if not total_sales: raise ValueError(\\"No sales data found in the specified date range.\\") highest_sales_item = max(total_sales, key=total_sales.get) highest_quantity_item = max(total_quantity, key=total_quantity.get) return total_sales, highest_sales_item, highest_quantity_item except FileNotFoundError: raise FileNotFoundError(\\"The specified file was not found.\\") except Exception as e: raise e"},{"question":"from typing import List def primes_less_than(n: int) -> List[int]: Returns a list of all prime numbers less than n using the Sieve of Eratosthenes algorithm. >>> primes_less_than(10) [2, 3, 5, 7] >>> primes_less_than(20) [2, 3, 5, 7, 11, 13, 17, 19] pass def test_primes_less_than_10(): assert primes_less_than(10) == [2, 3, 5, 7] def test_primes_less_than_20(): assert primes_less_than(20) == [2, 3, 5, 7, 11, 13, 17, 19] def test_primes_less_than_100(): assert primes_less_than(100) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] def test_primes_less_than_small_n(): assert primes_less_than(0) == [] assert primes_less_than(1) == [] assert primes_less_than(2) == [] assert primes_less_than(3) == [2] assert primes_less_than(4) == [2, 3] def test_primes_less_than_large_n(): primes = primes_less_than(10000) assert len(primes) == 1229 assert primes[-1] == 9973 # The largest prime less than 10000","solution":"from typing import List def primes_less_than(n: int) -> List[int]: Returns a list of all prime numbers less than n using the Sieve of Eratosthenes algorithm. if n <= 2: return [] # Initialize a list to track the primality of numbers sieve = [True] * n sieve[0] = sieve[1] = False p = 2 while (p * p <= n): if sieve[p]: # Updating all multiples of p to False for i in range(p * p, n, p): sieve[i] = False p += 1 return [num for num, is_prime in enumerate(sieve) if is_prime]"},{"question":"import re from collections import Counter from typing import List def most_frequent_word(text: str) -> str: Process a large text document and identify the most frequently occurring word. The function ignores punctuation, is case-insensitive, and handles ties. Args: text (str): A large text document provided as a single string. Returns: str: The most frequently occurring word or an empty string if no valid word is found. >>> most_frequent_word(\\"Hello world! Hello.\\") 'hello' >>> most_frequent_word(\\"Cat, bat! Mat. Cat, bat? Bat.\\") 'bat' >>> most_frequent_word(\\"\\") '' >>> most_frequent_word(\\"!!!,,,\\") '' >>> most_frequent_word(\\"Tie tie this or that or this\\") 'tie' >>> most_frequent_word(\\"Apple apple APPLE\\") 'apple'","solution":"import re from collections import Counter def most_frequent_word(text): Process a large text document and identify the most frequently occurring word. The function ignores punctuation, is case-insensitive, and handles ties. Args: text (str): A large text document provided as a single string. Returns: str: The most frequently occurring word or an empty string if no valid word is found. if not text: return \\"\\" # Convert to lowercase and remove punctuation text = text.lower() words = re.findall(r'bw+b', text) if not words: return \\"\\" word_counts = Counter(words) most_common_word = word_counts.most_common(1)[0][0] return most_common_word"},{"question":"def sieve_of_eratosthenes(n: int) -> List[int]: Returns a list of all prime numbers less than n using the Sieve of Eratosthenes algorithm. >>> sieve_of_eratosthenes(2) == [] >>> sieve_of_eratosthenes(10) == [2, 3, 5, 7] >>> sieve_of_eratosthenes(20) == [2, 3, 5, 7, 11, 13, 17, 19] >>> sieve_of_eratosthenes(1) == [] >>> sieve_of_eratosthenes(30) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] >>> sieve_of_eratosthenes(100) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]","solution":"def sieve_of_eratosthenes(n): Returns a list of all prime numbers less than n using the Sieve of Eratosthenes algorithm. if n < 2: return [] sieve = [True] * n sieve[0] = sieve[1] = False # 0 and 1 are not primes for i in range(2, int(n ** 0.5) + 1): if sieve[i]: for j in range(i * i, n, i): sieve[j] = False return [i for i in range(n) if sieve[i]]"},{"question":"class CircularQueue: Implements a circular queue of fixed size. The queue supports the following operations: - enqueue: Adds value to the end of the queue. If the queue is full, removes the oldest element to make space. - dequeue: Removes the oldest element from the queue and returns it. Returns None if the queue is empty. - peek: Returns the oldest element without removing it. Returns None if the queue is empty. - is_empty: Returns True if the queue is empty, otherwise False. - is_full: Returns True if the queue is full, otherwise False. def __init__(self, size): Initialize the queue with a fixed size. pass def enqueue(self, value): Adds value to the end of the queue. If the queue is full, it removes the oldest element to make space. pass def dequeue(self): Removes the oldest element from the queue and returns it. If the queue is empty, returns None. pass def peek(self): Returns the oldest element without removing it. If the queue is empty, returns None. pass def is_empty(self): Returns True if the queue is empty, otherwise False. pass def is_full(self): Returns True if the queue is full, otherwise False. pass import unittest class TestCircularQueue(unittest.TestCase): def test_enqueue_dequeue(self): queue = CircularQueue(3) self.assertTrue(queue.is_empty()) queue.enqueue(10) queue.enqueue(20) queue.enqueue(30) self.assertTrue(queue.is_full()) queue.enqueue(40) self.assertEqual(queue.dequeue(), 20) queue.enqueue(50) self.assertEqual(queue.dequeue(), 30) self.assertEqual(queue.dequeue(), 40) self.assertEqual(queue.dequeue(), 50) self.assertIsNone(queue.dequeue()) def test_peek(self): queue = CircularQueue(3) self.assertIsNone(queue.peek()) queue.enqueue(10) queue.enqueue(20) self.assertEqual(queue.peek(), 10) queue.dequeue() self.assertEqual(queue.peek(), 20) queue.dequeue() self.assertIsNone(queue.peek()) def test_is_empty(self): queue = CircularQueue(3) self.assertTrue(queue.is_empty()) queue.enqueue(10) self.assertFalse(queue.is_empty()) queue.dequeue() self.assertTrue(queue.is_empty()) def test_is_full(self): queue = CircularQueue(3) self.assertFalse(queue.is_full()) queue.enqueue(10) self.assertFalse(queue.is_full()) queue.enqueue(20) queue.enqueue(30) self.assertTrue(queue.is_full()) queue.dequeue() self.assertFalse(queue.is_full()) if __name__ == \\"__main__\\": unittest.main()","solution":"class CircularQueue: def __init__(self, size): Initializes the queue with a fixed size. self.size = size self.queue = [None] * size self.head = self.tail = -1 def enqueue(self, value): Adds value to the end of the queue. If the queue is full, it removes the oldest element to make space. if (self.tail + 1) % self.size == self.head: self.head = (self.head + 1) % self.size # Move head to remove the oldest element if self.head == -1: # First inserted element self.head = 0 self.tail = (self.tail + 1) % self.size self.queue[self.tail] = value def dequeue(self): Removes the oldest element from the queue and returns it. If the queue is empty, returns None. if self.head == -1: return None # Queue is empty value = self.queue[self.head] if self.head == self.tail: self.head = self.tail = -1 # Queue is now empty else: self.head = (self.head + 1) % self.size return value def peek(self): Returns the oldest element without removing it. If the queue is empty, returns None. if self.head == -1: return None # Queue is empty return self.queue[self.head] def is_empty(self): Returns True if the queue is empty, otherwise False. return self.head == -1 def is_full(self): Returns True if the queue is full, otherwise False. return (self.tail + 1) % self.size == self.head"},{"question":"def is_prime(n: int) -> bool: Helper function to check if a number is a prime number. def filter_primes(numbers: List[int]) -> List[int]: Returns a new list containing only the prime numbers from the original list. >>> filter_primes([]) [] >>> filter_primes([1, 4, 6, 8, 9, 10]) [] >>> filter_primes([2, 3, 5, 7, 11, 13]) [2, 3, 5, 7, 11, 13] >>> filter_primes([2, 4, 6, 7, 9, 11]) [2, 7, 11] >>> filter_primes([101, 103, 107, 109, 113, 117, 121, 123]) [101, 103, 107, 109, 113] >>> filter_primes([0]) [] >>> filter_primes([1]) [] >>> filter_primes([2]) [2] >>> filter_primes([3]) [3] >>> filter_primes([4]) []","solution":"def is_prime(n): Helper function to check if a number is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while (i * i) <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(numbers): Returns a list of prime numbers from the provided list of integers. return [num for num in numbers if is_prime(num)]"},{"question":"def longest_subarray_with_k_distinct(nums: List[int], k: int) -> List[int]: Write a Python function that takes a list of integers and returns the longest contiguous subarray that contains exactly k distinct integers. If there are multiple such subarrays, return the one which starts first. >>> longest_subarray_with_k_distinct([1, 2, 1, 2, 3], 2) == [1, 2, 1, 2] >>> longest_subarray_with_k_distinct([1, 2, 1, 2, 3], 3) == [1, 2, 1, 2, 3] >>> longest_subarray_with_k_distinct([1, 2, 1, 2, 1], 2) == [1, 2, 1, 2, 1] >>> longest_subarray_with_k_distinct([1, 2, 3, 4, 5], 3) == [1, 2, 3]","solution":"from typing import List, Dict def longest_subarray_with_k_distinct(nums: List[int], k: int) -> List[int]: if k == 0: return [] n = len(nums) left = 0 right = 0 max_length = 0 max_subarray = [] current_subarray: Dict[int, int] = {} while right < n: if len(current_subarray) <= k: current_subarray[nums[right]] = current_subarray.get(nums[right], 0) + 1 right += 1 while len(current_subarray) > k: current_subarray[nums[left]] -= 1 if current_subarray[nums[left]] == 0: del current_subarray[nums[left]] left += 1 if len(current_subarray) == k and (right - left) > max_length: max_length = right - left max_subarray = nums[left:right] return max_subarray"},{"question":"def increment_numbers_in_string(s) -> str: Given a string s, this function returns the string with all numbers incremented by 1 (9 should become 0), while leaving other characters unchanged. If the input is not a string, it returns a message indicating invalid input. Examples: >>> increment_numbers_in_string(\\"abc123!\\") 'abc234!' >>> increment_numbers_in_string(\\"xyz789!\\") 'xyz890!' >>> increment_numbers_in_string(\\"1234567890\\") '2345678901' >>> increment_numbers_in_string(\\"!@#%^&*()\\") '!@#%^&*()' >>> increment_numbers_in_string(\\"\\") '' >>> increment_numbers_in_string(\\"a1b2c3d4!\\") 'a2b3c4d5!' >>> increment_numbers_in_string(123) 'Invalid input, expected a string.' >>> increment_numbers_in_string(None) 'Invalid input, expected a string.' >>> increment_numbers_in_string([1, 2, 3]) 'Invalid input, expected a string.'","solution":"def increment_numbers_in_string(s): Given a string s, this function returns the string with all numbers incremented by 1 (9 should become 0), while leaving other characters unchanged. If the input is not a string, it returns a message indicating invalid input. if not isinstance(s, str): return \\"Invalid input, expected a string.\\" def increment_char(c): if c.isdigit(): return str((int(c) + 1) % 10) return c return ''.join(increment_char(c) for c in s)"},{"question":"from typing import List def maximum_occurrences(arr: List[int]) -> int: Write a function that takes a list of integers as input and returns the integer with the most occurrences in the list. If there is a tie, return the smallest one. The function should handle lists with a size of up to 10^5 elements. >>> maximum_occurrences([3, 2, 3, 2, 1, 2, 3, 4, 4, 4]) 3 >>> maximum_occurrences([1]) 1 >>> maximum_occurrences([2, 2, 2]) 2 >>> maximum_occurrences([1, 2, 3, 1, 2, 1, 2, 1]) 1 # Your code here pass","solution":"def maximum_occurrences(arr): Returns the integer with the most occurrences in the list. If there is a tie, returns the smallest one. from collections import Counter counts = Counter(arr) # Find the maximum occurrence count max_occurrence = max(counts.values()) # Filter numbers that have the maximum occurrence count most_common_numbers = [num for num, count in counts.items() if count == max_occurrence] # Return the smallest number among them return min(most_common_numbers)"},{"question":"def balanced_string_index(s): Return the index of the character that achieves a balanced state for the first time in the string. A balanced state means every opening parenthesis and bracket has a corresponding closing one in the correct order. Examples: >>> balanced_string_index(\\"([])\\") == 3 >>> balanced_string_index(\\"([)]\\") == -1 >>> balanced_string_index(\\"[()]\\") == 3 >>> balanced_string_index(\\"\\") == -1 >>> balanced_string_index(\\"([[]]())\\") == 7","solution":"def balanced_string_index(s): Return the index of the character that achieves a balanced state for the first time in the string. A balanced state means every opening parenthesis and bracket has a corresponding closing one in the correct order. stack = [] matching = {')': '(', ']': '['} for i, char in enumerate(s): if char in '([': stack.append((char, i)) elif char in ')]': if stack and stack[-1][0] == matching[char]: stack.pop() if not stack: return i else: return -1 return -1"},{"question":"from typing import List, Tuple def convex_hull(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Find the convex hull of the given set of points using the Graham scan algorithm. The convex hull of a set of points is the smallest convex polygon that contains all the points. Args: points (List[Tuple[int, int]]): A list of tuples, where each tuple represents the coordinates (x, y) of a point. Returns: List[Tuple[int, int]]: A list of tuples representing the vertices of the convex hull in counter-clockwise order, starting from the vertex with the lowest y-coordinate (if there's a tie, the lowest x-coordinate). Examples: >>> points = [(0, 0), (1, 1), (2, 2), (2, 0), (4, 2), (2, 4)] >>> convex_hull(points) [(0, 0), (2, 0), (4, 2), (2, 4)] >>> points = [(0, 0), (1, 1), (0, 2)] >>> convex_hull(points) [(0, 0), (1, 1), (0, 2)]","solution":"from typing import List, Tuple import math def convex_hull(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]: # Find the point with the lowest y-coordinate, break ties by x-coordinate start = min(points, key=lambda p: (p[1], p[0])) # Sort the points by polar angle with the start point def polar_angle(p): return math.atan2(p[1] - start[1], p[0] - start[0]) sorted_points = sorted(points, key=lambda p: (polar_angle(p), (start[0] - p[0])**2 + (start[1] - p[1])**2)) # Function to return the cross product of vectors OA and OB def cross(o, a, b): return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]) hull = [] for p in sorted_points: while len(hull) > 1 and cross(hull[-2], hull[-1], p) <= 0: hull.pop() hull.append(p) return hull"},{"question":"def compare_lists(list1: List[int], list2: List[int]) -> List[int]: Returns a list containing elements present in list1 but not in list2. >>> compare_lists([1, 2, 3, 4, 5], [2, 4]) [1, 3, 5] >>> compare_lists([1, 2, 3], [4, 5, 6]) [1, 2, 3] >>> compare_lists([1, 2, 3], [1, 2, 3]) [] >>> compare_lists([1, 2, 2, 3, 4, 4, 5], [2, 4]) [1, 3, 5] >>> compare_lists([], [1, 2, 3]) [] >>> compare_lists([1, 2, 3], []) [1, 2, 3] >>> compare_lists([-1, -2, 3, 4], [3, 4, 5]) [-1, -2] >>> compare_lists([0, -1, 1, 2, -2], [1, -2]) [0, -1, 2]","solution":"from typing import List def compare_lists(list1: List[int], list2: List[int]) -> List[int]: Returns a list containing elements present in list1 but not in list2. set2 = set(list2) return [item for item in list1 if item not in set2]"},{"question":"def is_prime(n: int) -> bool: Returns True if n is a prime number, else False. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(17) == True >>> is_prime(18) == False >>> is_prime(19) == True >>> is_prime(-1) == False >>> is_prime(0) == False >>> is_prime(1) == False def prime_list(int_list: List[int]) -> List[bool]: Takes a list of integers and returns a list of booleans indicating whether each integer is a prime number. >>> prime_list([2, 3, 4, 17, 18, 19, -1, 0, 1]) == [True, True, False, True, False, True, False, False, False] >>> prime_list([]) == [] >>> prime_list([23, 29, 31, 37, 41, 43, 47]) == [True, True, True, True, True, True, True] >>> prime_list([25, 35, 45, 55, 65, 75, 85]) == [False, False, False, False, False, False, False]","solution":"def is_prime(n): Returns True if n is a prime number, else False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def prime_list(int_list): Takes a list of integers and returns a list of booleans indicating whether each integer is a prime number. return [is_prime(num) for num in int_list]"},{"question":"def categorize_students(students: dict, passing_grade: int) -> dict: Categorizes students into \\"pass\\" or \\"fail\\" based on the given passing grade threshold. Parameters: - students (dict): A dictionary where keys are student names and values are their respective grades. - passing_grade (int): The grade threshold for passing. Returns: - dict: A dictionary with keys \\"pass\\" and \\"fail\\", mapping to lists of student names. >>> categorize_students({\\"John\\": 85, \\"Jane\\": 60, \\"Doe\\": 55, \\"Anna\\": 75}, 50) {\\"pass\\": [\\"John\\", \\"Jane\\", \\"Doe\\", \\"Anna\\"], \\"fail\\": []} >>> categorize_students({\\"John\\": 45, \\"Jane\\": 40, \\"Doe\\": 47, \\"Anna\\": 35}, 50) {\\"pass\\": [], \\"fail\\": [\\"John\\", \\"Jane\\", \\"Doe\\", \\"Anna\\"]} >>> categorize_students({\\"John\\": 85, \\"Jane\\": 60, \\"Doe\\": 47, \\"Anna\\": 75}, 50) {\\"pass\\": [\\"John\\", \\"Jane\\", \\"Anna\\"], \\"fail\\": [\\"Doe\\"]} >>> categorize_students({\\"John\\": 50, \\"Jane\\": 50, \\"Doe\\": 47, \\"Anna\\": 50}, 50) {\\"pass\\": [\\"John\\", \\"Jane\\", \\"Anna\\"], \\"fail\\": [\\"Doe\\"]} >>> categorize_students({}, 50) {\\"pass\\": [], \\"fail\\": []}","solution":"def categorize_students(students, passing_grade): Categorizes students into \\"pass\\" or \\"fail\\" based on the given passing grade threshold. Parameters: - students (dict): A dictionary where keys are student names and values are their respective grades. - passing_grade (int): The grade threshold for passing. Returns: - dict: A dictionary with keys \\"pass\\" and \\"fail\\", mapping to lists of student names. categorized = {\\"pass\\": [], \\"fail\\": []} for name, grade in students.items(): if grade >= passing_grade: categorized[\\"pass\\"].append(name) else: categorized[\\"fail\\"].append(name) return categorized"},{"question":"import random import matplotlib.pyplot as plt def roll_dice_and_plot_histogram(): Simulates rolling a pair of dice 10,000 times and plots a histogram of the sums. The histogram should have appropriate labels for the axes and a title, making it clear and easy to interpret.","solution":"import random import matplotlib.pyplot as plt def roll_dice_and_plot_histogram(): Simulates rolling a pair of dice 10,000 times and plots a histogram of the sums. # Roll the dice 10,000 times and compute the sum of the faces for each roll rolls = [random.randint(1, 6) + random.randint(1, 6) for _ in range(10000)] # Create a histogram of the sums plt.hist(rolls, bins=range(2, 14), edgecolor='black', align='left') # Set the title and labels plt.title('Histogram of Dice Rolls (10,000 rolls)') plt.xlabel('Sum of Dice') plt.ylabel('Frequency') # Display the histogram plt.show()"},{"question":"from typing import List import heapq from collections import Counter def top_k_frequent_elements(numbers: List[int], k: int) -> List[int]: Returns the k most frequent elements in a given list of integers. >>> top_k_frequent_elements([1, 1, 1, 2, 2, 3], 2) [1, 2] >>> top_k_frequent_elements([4, 4, 4, 6, 6, 1, 1, 1, 1], 1) [1] >>> top_k_frequent_elements([1, 2, 3, 4, 5], 3) [1, 2, 3] >>> top_k_frequent_elements([1, 2, 3, 1, 2, 3, 1], 3) [1, 2, 3] >>> top_k_frequent_elements([1, 2, 2, 1, 1, 3, 3], 2) [1, 2] >>> top_k_frequent_elements([], 0) [] >>> top_k_frequent_elements([5, 5, 5, 5], 1) [5]","solution":"from collections import Counter import heapq def top_k_frequent_elements(numbers, k): Returns the k most frequent elements in the given list of integers, 'numbers'. count = Counter(numbers) return heapq.nlargest(k, count.keys(), key=count.get)"},{"question":"import numpy as np import matplotlib.pyplot as plt from sklearn.cluster import KMeans from sklearn.preprocessing import StandardScaler from sklearn.metrics import silhouette_score def normalize_data(data): Normalize the data to ensure efficient convergence of the k-means algorithm. Parameters: data (numpy array): The data to be normalized. Returns: numpy array: The normalized data. pass def elbow_method(data, range_n_clusters): Use the elbow method to determine the optimal number of clusters. Parameters: data (numpy array): The dataset to be clustered. range_n_clusters (range): A range of the number of clusters to try. Returns: list: The sum of squared distances for each number of clusters. pass def k_means_clustering(data, n_clusters): Perform k-means clustering on the data. Parameters: data (numpy array): The dataset to be clustered. n_clusters (int): The number of clusters to form. Returns: tuple: The cluster labels and the cluster centroids. pass def silhouette_evaluation(data, labels): Evaluate the clustering performance using silhouette scores. Parameters: data (numpy array): The clustered data. labels (numpy array): The cluster labels. Returns: float: The silhouette score. pass def plot_clusters(data, labels, centroids): Plot the clusters and their centroids on a 2D plot. Parameters: data (numpy array): The dataset to be plotted. labels (numpy array): The cluster labels. centroids (numpy array): The cluster centroids. pass # Example dataset of city coordinates for testing purposes sample_data = np.array([ [1, 2], [2, 3], [3, 1], [8, 8], [9, 9], [10, 10], [5, 5], [6, 6], [7, 7], [12, 11] ]) # Normalize the data normalized_data = normalize_data(sample_data) # Determine optimal number of clusters using the elbow method range_n = range(1, 11) sse = elbow_method(normalized_data, range_n) # Plot the elbow method result plt.plot(range_n, sse) plt.xlabel('Number of clusters') plt.ylabel('Sum of squared distances') plt.title('Elbow Method For Optimal k') plt.show() # Perform k-means clustering for optimal number of clusters (e.g., identified as 3) n_clusters_optimal = 3 labels, centroids = k_means_clustering(normalized_data, n_clusters_optimal) # Evaluate the clustering sil_score = silhouette_evaluation(normalized_data, labels) print(f'Silhouette Score: {sil_score}') # Plot clusters and centroids plot_clusters(normalized_data, labels, centroids)","solution":"import numpy as np import matplotlib.pyplot as plt from sklearn.cluster import KMeans from sklearn.preprocessing import StandardScaler from sklearn.metrics import silhouette_score def normalize_data(data): Normalize the data to ensure efficient convergence of the k-means algorithm. Parameters: data (numpy array): The data to be normalized. Returns: numpy array: The normalized data. scaler = StandardScaler() return scaler.fit_transform(data) def elbow_method(data, range_n_clusters): Use the elbow method to determine the optimal number of clusters. Parameters: data (numpy array): The dataset to be clustered. range_n_clusters (range): A range of the number of clusters to try. Returns: list: The sum of squared distances for each number of clusters. sse = [] for k in range_n_clusters: kmeans = KMeans(n_clusters=k) kmeans.fit(data) sse.append(kmeans.inertia_) return sse def k_means_clustering(data, n_clusters): Perform k-means clustering on the data. Parameters: data (numpy array): The dataset to be clustered. n_clusters (int): The number of clusters to form. Returns: tuple: The cluster labels and the cluster centroids. kmeans = KMeans(n_clusters=n_clusters) kmeans.fit(data) return kmeans.labels_, kmeans.cluster_centers_ def silhouette_evaluation(data, labels): Evaluate the clustering performance using silhouette scores. Parameters: data (numpy array): The clustered data. labels (numpy array): The cluster labels. Returns: float: The silhouette score. return silhouette_score(data, labels) def plot_clusters(data, labels, centroids): Plot the clusters and their centroids on a 2D plot. Parameters: data (numpy array): The dataset to be plotted. labels (numpy array): The cluster labels. centroids (numpy array): The cluster centroids. plt.scatter(data[:, 0], data[:, 1], c=labels, s=50, cmap='viridis') plt.scatter(centroids[:, 0], centroids[:, 1], c='red', s=200, alpha=0.5) plt.show() # Example dataset of city coordinates for testing purposes sample_data = np.array([ [1, 2], [2, 3], [3, 1], [8, 8], [9, 9], [10, 10], [5, 5], [6, 6], [7, 7], [12, 11] ]) # Normalize the data normalized_data = normalize_data(sample_data) # Determine optimal number of clusters using the elbow method range_n = range(1, 11) sse = elbow_method(normalized_data, range_n) # Plot the elbow method result plt.plot(range_n, sse) plt.xlabel('Number of clusters') plt.ylabel('Sum of squared distances') plt.title('Elbow Method For Optimal k') plt.show() # Perform k-means clustering for optimal number of clusters (e.g., identified as 3) n_clusters_optimal = 3 labels, centroids = k_means_clustering(normalized_data, n_clusters_optimal) # Evaluate the clustering sil_score = silhouette_evaluation(normalized_data, labels) print(f'Silhouette Score: {sil_score}') # Plot clusters and centroids plot_clusters(normalized_data, labels, centroids)"},{"question":"from typing import List def merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]: Merge two sorted arrays into a single sorted array. >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([1, 2, 3, 4], [2, 6]) [1, 2, 2, 3, 4, 6] >>> merge_sorted_arrays([1, 3], [2, 4, 5, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([-5, 1, 3], [-4, 2, 4]) [-5, -4, 1, 2, 3, 4] >>> merge_sorted_arrays([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_arrays([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_arrays([1, 1, 1], [1, 1, 1]) [1, 1, 1, 1, 1, 1]","solution":"def merge_sorted_arrays(arr1, arr2): Merge two sorted arrays into a single sorted array. result = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: result.append(arr1[i]) i += 1 else: result.append(arr2[j]) j += 1 # Append remaining elements if any while i < len(arr1): result.append(arr1[i]) i += 1 while j < len(arr2): result.append(arr2[j]) j += 1 return result"},{"question":"from typing import List, Optional from collections import defaultdict import math class TemperatureTracker: Class to track temperature readings and provide temperature-related functionalities. Methods: - insert(temp): Inserts a new temperature reading into the tracker. - get_max() -> Optional[float]: Returns the highest temperature reading inserted so far. - get_min() -> Optional[float]: Returns the lowest temperature reading inserted so far. - get_mean() -> Optional[float]: Returns the mean of the temperature readings inserted so far. - get_mode() -> Optional[List[float]]: Returns a list of the mode(s) of the temperature readings. def insert(self, temp): Inserts a new temperature reading into the tracker. pass def get_max(self) -> Optional[float]: Returns the highest temperature reading inserted so far. If no readings are available, return None. pass def get_min(self) -> Optional[float]: Returns the lowest temperature reading inserted so far. If no readings are available, return None. pass def get_mean(self) -> Optional[float]: Returns the mean of the temperature readings inserted so far. If no readings are available, return None. pass def get_mode(self) -> Optional[List[float]]: Returns a list of the mode(s) of the temperature readings inserted so far. If no readings are available, return None. pass # Unit tests def test_insert_and_get_methods(): tracker = TemperatureTracker() # Test initial conditions assert tracker.get_max() == None assert tracker.get_min() == None assert tracker.get_mean() == None assert tracker.get_mode() == None # Insert first temperature tracker.insert(30) assert tracker.get_max() == 30 assert tracker.get_min() == 30 assert math.isclose(tracker.get_mean(), 30.0, rel_tol=1e-9) assert tracker.get_mode() == [30] # Insert second temperature tracker.insert(20) assert tracker.get_max() == 30 assert tracker.get_min() == 20 assert math.isclose(tracker.get_mean(), 25.0, rel_tol=1e-9) assert tracker.get_mode() == [30, 20] # Insert third temperature tracker.insert(20) assert tracker.get_max() == 30 assert tracker.get_min() == 20 assert math.isclose(tracker.get_mean(), 23.333333, rel_tol=1e-6) assert tracker.get_mode() == [20] # Insert fourth temperature tracker.insert(40) assert tracker.get_max() == 40 assert tracker.get_min() == 20 assert math.isclose(tracker.get_mean(), 27.5, rel_tol=1e-9) assert tracker.get_mode() == [20] def test_edge_cases(): tracker = TemperatureTracker() # Insert negative temperatures tracker.insert(-10) tracker.insert(0) tracker.insert(-5) tracker.insert(-10) assert tracker.get_max() == 0 assert tracker.get_min() == -10 assert math.isclose(tracker.get_mean(), -6.25, rel_tol=1e-9) assert tracker.get_mode() == [-10] # Insert multiple modes tracker.insert(-5) assert tracker.get_mode() == [-10, -5]","solution":"from collections import defaultdict import math class TemperatureTracker: def __init__(self): self.temperatures = [] self.counts = defaultdict(int) self.total_sum = 0 def insert(self, temp): self.temperatures.append(temp) self.counts[temp] += 1 self.total_sum += temp def get_max(self): if not self.temperatures: return None return max(self.temperatures) def get_min(self): if not self.temperatures: return None return min(self.temperatures) def get_mean(self): if not self.temperatures: return None return self.total_sum / len(self.temperatures) def get_mode(self): if not self.temperatures: return None max_count = max(self.counts.values()) mode = [key for key, count in self.counts.items() if count == max_count] return mode"},{"question":"def generate_fibonacci_series(n: int): Generates the first n numbers in the Fibonacci series. If n is less than 1, returns an error message. pass # Example test cases def test_generate_fibonacci_series_standard_case(): assert generate_fibonacci_series(6) == [0, 1, 1, 2, 3, 5] def test_generate_fibonacci_series_minimum_input(): assert generate_fibonacci_series(1) == [0] def test_generate_fibonacci_series_two_elements(): assert generate_fibonacci_series(2) == [0, 1] def test_generate_fibonacci_series_negative_input(): assert generate_fibonacci_series(-1) == \\"Error: n should be a positive integer.\\" def test_generate_fibonacci_series_zero_input(): assert generate_fibonacci_series(0) == \\"Error: n should be a positive integer.\\"","solution":"def generate_fibonacci_series(n): Generates the first n numbers in the Fibonacci series. If n is less than 1, returns an error message. if n < 1: return \\"Error: n should be a positive integer.\\" fibonacci_series = [] a, b = 0, 1 for _ in range(n): fibonacci_series.append(a) a, b = b, a + b return fibonacci_series"},{"question":"def dfs(graph: dict, start: str) -> set: Depth-First Search implementation. >>> dfs({ 'A': ['B', 'C'], 'B': ['D', 'E'], 'C': ['F'], 'D': [], 'E': ['F'], 'F': [] }, 'A') == {'A', 'B', 'C', 'D', 'E', 'F'} >>> dfs({ 'A': ['B'], 'B': [], 'C': ['D'], 'D': [] }, 'A') == {'A', 'B'} >>> dfs({ 'A': ['B'], 'B': ['C'], 'C': ['A'], }, 'A') == {'A', 'B', 'C'} pass def bfs(graph: dict, start: str) -> set: Breadth-First Search implementation. >>> bfs({ 'A': ['B', 'C'], 'B': ['D', 'E'], 'C': ['F'], 'D': [], 'E': ['F'], 'F': [] }, 'A') == {'A', 'B', 'C', 'D', 'E', 'F'} >>> bfs({ 'A': ['B'], 'B': [], 'C': ['D'], 'D': [] }, 'A') == {'A', 'B'} >>> bfs({ 'A': ['B'], 'B': ['C'], 'C': ['A'], }, 'A') == {'A', 'B', 'C'} pass","solution":"def dfs(graph, start): Depth-First Search implementation. visited = set() stack = [start] while stack: node = stack.pop() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: stack.append(neighbor) return visited def bfs(graph, start): Breadth-First Search implementation. visited = set() queue = [start] while queue: node = queue.pop(0) if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return visited"},{"question":"def longest_distinct_substring(s: str) -> str: Write a program that takes a string as input and identifies the longest substring containing distinct characters. Your program should account for edge cases such as empty strings or strings with all identical characters. Optimize your solution to run in linear time, O(n). Args: s (str): The input string. Returns: str: The longest substring with all distinct characters. >>> longest_distinct_substring(\\"\\") == \\"\\" >>> longest_distinct_substring(\\"a\\") == \\"a\\" >>> longest_distinct_substring(\\"aaaaa\\") == \\"a\\" >>> longest_distinct_substring(\\"abcabcbb\\") == \\"abc\\" >>> longest_distinct_substring(\\"abcdef\\") == \\"abcdef\\" >>> longest_distinct_substring(\\"abccdefgh\\") == \\"cdefgh\\" >>> longest_distinct_substring(\\"abcdabcda\\") in [\\"abcd\\", \\"bcda\\"] >>> longest_distinct_substring(\\"AbCDefGahIjKlm\\") == \\"AbCDefGahIjKlm\\"","solution":"def longest_distinct_substring(s): Finds the longest substring with all distinct characters. Args: s (str): The input string. Returns: str: The longest substring with all distinct characters. if not s: return \\"\\" start = 0 max_start = 0 max_length = 0 char_index_map = {} for end in range(len(s)): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end if end - start + 1 > max_length: max_start = start max_length = end - start + 1 return s[max_start:max_start + max_length]"},{"question":"def rotate_matrix_90_clockwise(matrix): Rotates a given 2D matrix 90 degrees clockwise. :param matrix: List of lists where each list represents a row of integers. :returns: Rotated matrix 90 degrees clockwise. >>> rotate_matrix_90_clockwise([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix_90_clockwise([[1, 2, 3], [4, 5, 6]]) [[4, 1], [5, 2], [6, 3]] >>> rotate_matrix_90_clockwise([[1, 2, 3]]) [[1], [2], [3]] >>> rotate_matrix_90_clockwise([[1], [2], [3]]) [[3, 2, 1]] >>> rotate_matrix_90_clockwise([]) [] >>> rotate_matrix_90_clockwise([[0, 2, 0], [4, 0, 6], [0, 8, 0]]) [[0, 4, 0], [8, 0, 2], [0, 6, 0]] >>> rotate_matrix_90_clockwise([[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]) [[-7, -4, -1], [-8, -5, -2], [-9, -6, -3]]","solution":"def rotate_matrix_90_clockwise(matrix): Rotates a given 2D matrix 90 degrees clockwise. :param matrix: List of lists where each list represents a row of integers. :returns: Rotated matrix 90 degrees clockwise. if not matrix or not matrix[0]: return [] num_rows, num_columns = len(matrix), len(matrix[0]) rotated_matrix = [[0] * num_rows for _ in range(num_columns)] for i in range(num_rows): for j in range(num_columns): rotated_matrix[j][num_rows - 1 - i] = matrix[i][j] return rotated_matrix"},{"question":"def find_first_repeating_char(s: str) -> str: Returns the first repeating character in the string. If there is no repeating character, returns None. Args: s (str): A string consisting of lowercase and uppercase characters. Returns: str: The first repeating character or None if no repeating character exists. Examples: >>> find_first_repeating_char(\\"hello\\") # should return 'l' >>> find_first_repeating_char(\\"abcdef\\") # should return None >>> find_first_repeating_char(\\"aabbcc\\") # should return 'a'","solution":"def find_first_repeating_char(s: str) -> str: Returns the first repeating character in the string. If there is no repeating character, returns None. char_set = set() for char in s: if char in char_set: return char char_set.add(char) return None"},{"question":"def find_pair(numbers, target): Find two numbers in the list that add up to the target. :param numbers: List of integers :param target: Target sum :return: Tuple of two integers that add up to the target or None if no such pair exists >>> find_pair([2, 7, 11, 15], 9) (2, 7) or (7, 2) >>> find_pair([1, 2, 3, 4], 8) None >>> find_pair([-2, 1, 4, 9], 7) (-2, 9) or (9, -2) >>> find_pair([1, 5, 7, -1, 5], 6) (1, 5) or (5, 1) >>> find_pair([1000000, 500000, 1500000], 2000000) (500000, 1500000) or (1500000, 500000)","solution":"def find_pair(numbers, target): Find two numbers in the list that add up to the target. :param numbers: List of integers :param target: Target sum :return: Tuple of two integers that add up to the target or None if no such pair exists seen = {} for num in numbers: complement = target - num if complement in seen: return (complement, num) seen[num] = True return None"},{"question":"def can_form_palindrome(input_string: str) -> bool: Determines if the given string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"carrace\\") True >>> can_form_palindrome(\\"hello\\") False","solution":"def can_form_palindrome(input_string): Determines if the given string can be rearranged to form a palindrome. Args: input_string (str): The string to check. Returns: bool: True if the string can be rearranged to form a palindrome, otherwise False. char_count = {} for char in input_string: char_count[char] = char_count.get(char, 0) + 1 odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 # A string can form a palindrome if it has at most one character with an odd count return odd_count <= 1"},{"question":"from typing import List def top_k_frequent(nums: List[int], k: int) -> List[int]: Returns the k most frequent elements from the list of integers. If multiple elements have the same frequency, the smaller elements are returned first. >>> top_k_frequent([1, 1, 1, 2, 2, 3], 2) [1, 2] >>> top_k_frequent([4, 1, -1, 2, -1, 2, 3], 2) [-1, 2] >>> top_k_frequent([5], 1) [5] >>> top_k_frequent([1, 2, 3, 1, 2, 3, 4], 2) [1, 2] >>> top_k_frequent([6, 7, 8, 9, 10], 3) [6, 7, 8]","solution":"from typing import List from collections import Counter import heapq def top_k_frequent(nums: List[int], k: int) -> List[int]: Returns the k most frequent elements from the list of integers. If multiple elements have the same frequency, the smaller elements are returned first. count = Counter(nums) # Using a heap to get the k most frequent elements heap = [(-freq, num) for num, freq in count.items()] heapq.heapify(heap) result = [] for _ in range(k): result.append(heapq.heappop(heap)[1]) result.sort() return result"},{"question":"def fibonacci(n: int) -> int: Returns the n-th Fibonacci number. >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(3) 2 >>> fibonacci(4) 3 >>> fibonacci(5) 5 >>> fibonacci(10) 55 >>> fibonacci(15) 610 >>> fibonacci(20) 6765 >>> fibonacci(25) 75025","solution":"def fibonacci(n): Returns the n-th Fibonacci number. if n == 0: return 0 elif n == 1: return 1 else: return fibonacci(n - 1) + fibonacci(n - 2)"},{"question":"def truncate_strings(strings: List[str], k: int) -> List[str]: Truncates each string in the input list to the length k. If k is greater than the length of any string, the string is left unchanged. :param strings: List of strings to be truncated :param k: Maximum length for each string :return: List of truncated strings >>> truncate_strings([\\"apple\\", \\"banana\\", \\"cherry\\"], 10) == [\\"apple\\", \\"banana\\", \\"cherry\\"] >>> truncate_strings([\\"apple\\", \\"banana\\", \\"cherry\\"], 3) == [\\"app\\", \\"ban\\", \\"che\\"] >>> truncate_strings([\\"apple\\", \\"banana\\", \\"cherry\\"], 5) == [\\"apple\\", \\"banan\\", \\"cherr\\"] >>> truncate_strings([\\"apple\\", \\"\\", \\"cherry\\"], 3) == [\\"app\\", \\"\\", \\"che\\"] >>> truncate_strings([\\"apple\\", \\"banana\\", \\"cherry\\"], 0) == [\\"\\", \\"\\", \\"\\"]","solution":"def truncate_strings(strings, k): Truncates each string in the input list to the length k. If k is greater than the length of any string, the string is left unchanged. :param strings: List of strings to be truncated :param k: Maximum length for each string :return: List of truncated strings return [s[:k] if len(s) > k else s for s in strings]"},{"question":"def custom_sort(arr): Sorts the list in ascending order and keeps track of the original indices. Parameters: arr (list of int): The list to be sorted. Returns: tuple: A tuple containing two lists - the sorted list and the list of original indices. Examples: >>> custom_sort([10, 1, 15, 3, 7]) ([1, 3, 7, 10, 15], [1, 3, 4, 0, 2]) >>> custom_sort([5, 2, 9, 4]) ([2, 4, 5, 9], [1, 3, 0, 2]) pass # Unit Tests def test_custom_sort_with_sample_case(): sorted_list, index_mapping = custom_sort([10, 1, 15, 3, 7]) assert sorted_list == [1, 3, 7, 10, 15] assert index_mapping == [1, 3, 4, 0, 2] def test_custom_sort_with_all_positive_numbers(): sorted_list, index_mapping = custom_sort([5, 2, 9, 4]) assert sorted_list == [2, 4, 5, 9] assert index_mapping == [1, 3, 0, 2] def test_custom_sort_with_negative_and_positive_numbers(): sorted_list, index_mapping = custom_sort([-5, -1, 0, 7, 3]) assert sorted_list == [-5, -1, 0, 3, 7] assert index_mapping == [0, 1, 2, 4, 3] def test_custom_sort_with_duplicates(): sorted_list, index_mapping = custom_sort([10, 10, 10]) assert sorted_list == [10, 10, 10] assert index_mapping == [0, 1, 2] # order should not change since all values are equal def test_custom_sort_with_empty_list(): sorted_list, index_mapping = custom_sort([]) assert sorted_list == [] assert index_mapping == [] def test_custom_sort_with_single_element(): sorted_list, index_mapping = custom_sort([42]) assert sorted_list == [42] assert index_mapping == [0]","solution":"def custom_sort(arr): Sorts the list in ascending order and keeps track of the original indices. Parameters: arr (list of int): The list to be sorted. Returns: tuple: A tuple containing two lists - the sorted list and the list of original indices. # Create a list of tuples where each tuple is (element, index) indexed_arr = [(val, idx) for idx, val in enumerate(arr)] # Sort the list of tuples based on the element value sorted_indexed_arr = sorted(indexed_arr, key=lambda x: x[0]) # Extract the sorted values and their original indices sorted_arr = [val for val, idx in sorted_indexed_arr] original_indices = [idx for val, idx in sorted_indexed_arr] return sorted_arr, original_indices"},{"question":"def fibonacci(n): Calculate the nth term in the Fibonacci sequence efficiently. >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(3) 2 >>> fibonacci(4) 3 >>> fibonacci(5) 5 >>> fibonacci(20) 6765 >>> fibonacci(30) 832040","solution":"def fibonacci(n, memo=None): if memo is None: memo = {} if n in memo: return memo[n] if n <= 0: return 0 elif n == 1: return 1 else: result = fibonacci(n-1, memo) + fibonacci(n-2, memo) memo[n] = result return result"},{"question":"def is_valid(s: str) -> bool: Determine if the input string of brackets is valid. An input string is considered valid if: 1. Open brackets are closed by the same type of brackets. 2. Open brackets are closed in the correct order. 3. Each closing bracket has a corresponding and preceding opening bracket. Examples: >>> is_valid(\\"()\\") True >>> is_valid(\\"()[]{}\\") True >>> is_valid(\\"(]\\") False >>> is_valid(\\"([)]\\") False >>> is_valid(\\"{[]}\\") True :param s: Input string containing '(', ')', '{', '}', '[' and ']' :return: Boolean indicating whether the string is valid # Unit Tests def test_valid_single_pairs(): assert is_valid(\\"()\\") == True assert is_valid(\\"{}\\") == True assert is_valid(\\"[]\\") == True def test_valid_nested_pairs(): assert is_valid(\\"()[]{}\\") == True assert is_valid(\\"{[]}\\") == True assert is_valid(\\"{[()]}\\") == True def test_invalid_pairs(): assert is_valid(\\"(]\\") == False assert is_valid(\\"([)]\\") == False assert is_valid(\\"{[}]\\") == False def test_unbalanced_pairs(): assert is_valid(\\"(\\") == False assert is_valid(\\"{\\") == False assert is_valid(\\"[\\") == False assert is_valid(\\"}\\") == False assert is_valid(\\"}\\") == False assert is_valid(\\"]\\") == False def test_mixed_characters(): assert is_valid(\\"([]{[]})\\") == True assert is_valid(\\"[({])}\\") == False assert is_valid(\\"[{(})]\\") == False","solution":"def is_valid(s: str) -> bool: Determine if the input string of brackets is valid. :param s: Input string containing '(', ')', '{', '}', '[' and ']' :return: Boolean indicating whether the string is valid stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_map: top_element = stack.pop() if stack else '#' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"from sklearn.datasets import load_wine from sklearn.model_selection import train_test_split, GridSearchCV from sklearn.preprocessing import MinMaxScaler from sklearn.tree import DecisionTreeClassifier, plot_tree from sklearn.metrics import classification_report, accuracy_score import matplotlib.pyplot as plt import pandas as pd def decision_tree_classifier(): Create a decision tree classifier on the 'wine' dataset from sklearn. Split the dataset into training and testing sets with a ratio of 8:2. Implement data normalization using Min-Max scaling. Alongside the basic decision tree, apply grid search cross-validation to find the best hyperparameters such as maximum depth, minimum samples split, and minimum samples leaf. Use the optimized parameters to train the final model. Generate a detailed classification report including accuracy, precision, recall, and F1-score. Additionally, visualize the decision tree and plot the feature importance. Discuss the significance of the selected hyperparameters and feature importance in the final model performance. Returns: best_params (dict): The best hyperparameters found using grid search. accuracy (float): The accuracy of the final model. class_report (str): A detailed classification report. best_dt (DecisionTreeClassifier): The trained decision tree model with the best parameters.","solution":"from sklearn.datasets import load_wine from sklearn.model_selection import train_test_split, GridSearchCV from sklearn.preprocessing import MinMaxScaler from sklearn.tree import DecisionTreeClassifier, plot_tree from sklearn.metrics import classification_report, accuracy_score import matplotlib.pyplot as plt import pandas as pd def decision_tree_classifier(): # Load the dataset wine = load_wine() X = wine.data y = wine.target # Split the dataset X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Normalize the dataset scaler = MinMaxScaler() X_train = scaler.fit_transform(X_train) X_test = scaler.transform(X_test) # Implement Decision Tree Classifier dt = DecisionTreeClassifier(random_state=42) # Setup GridSearchCV param_grid = { 'max_depth': [None, 10, 20, 30, 40, 50], 'min_samples_split': [2, 5, 10, 20], 'min_samples_leaf': [1, 2, 5, 10] } grid_search = GridSearchCV(dt, param_grid, cv=5, scoring='accuracy') grid_search.fit(X_train, y_train) # Get the best parameters best_params = grid_search.best_params_ best_dt = grid_search.best_estimator_ # Train the final model best_dt.fit(X_train, y_train) # Predict the test set y_pred = best_dt.predict(X_test) # Classification report class_report = classification_report(y_test, y_pred, target_names=wine.target_names) accuracy = accuracy_score(y_test, y_pred) # Print Classification report and accuracy print(\\"Classification Report:n\\", class_report) print(\\"Accuracy: \\", accuracy) print(\\"Best Parameters: \\", best_params) # Visualize the decision tree plt.figure(figsize=(20, 10)) plot_tree(best_dt, feature_names=wine.feature_names, class_names=wine.target_names, filled=True) plt.title(\\"Decision Tree Visualization\\") plt.show() # Plot feature importance feature_importances = pd.Series(best_dt.feature_importances_, index=wine.feature_names).sort_values(ascending=False) feature_importances.plot(kind='bar') plt.title(\\"Feature Importances\\") plt.show() return best_params, accuracy, class_report, best_dt # Run the decision tree classifier function decision_tree_classifier()"},{"question":"def find_highest_priced_item(items: List[str]) -> Optional[str]: This function takes a list of strings, where each string represents an item and its price in the format \\"item:price\\", and returns the item with the highest price. In the case of a tie, it returns the lexicographically smallest item name. >>> find_highest_priced_item([\\"apple:3\\"]) == \\"apple\\" >>> find_highest_priced_item([\\"apple:3\\", \\"banana:2\\", \\"carrot:3\\", \\"date:2\\"]) == \\"apple\\" >>> find_highest_priced_item([\\"apple:2\\", \\"banana:2\\"]) == \\"apple\\" >>> find_highest_priced_item([\\"apple:1\\", \\"banana:3\\", \\"carrot:2\\"]) == \\"banana\\" >>> find_highest_priced_item([\\"cherry:5\\", \\"banana:5\\", \\"apple:5\\"]) == \\"apple\\" >>> find_highest_priced_item([]) == None >>> find_highest_priced_item([\\"apple:3\\", \\"banana:\\", \\"carrot:2:extra\\", \\"date:four\\"]) == \\"apple\\" >>> find_highest_priced_item([\\"apple\\", \\"banana:\\", \\"carrot:two\\", \\"date:4:extra\\"]) == None","solution":"def find_highest_priced_item(items): This function takes a list of strings, where each string represents an item and its price in the format \\"item:price\\", and returns the item with the highest price. In the case of a tie, it returns the lexicographically smallest item name. if not items: return None highest_priced_item = None highest_price = float('-inf') for item in items: try: name, price_str = item.split(':') price = int(price_str) if price > highest_price or (price == highest_price and name < highest_priced_item): highest_priced_item = name highest_price = price except (ValueError, IndexError): continue return highest_priced_item"},{"question":"import pandas as pd from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.model_selection import GridSearchCV, train_test_split from sklearn.svm import SVC from sklearn.pipeline import Pipeline from sklearn.metrics import classification_report def preprocess_and_train_model(reviews, sentiments): Preprocess the textual reviews, extract features using TF-IDF vectorization, and optimize an SVM classifier using grid search for sentiment analysis. Parameters: reviews (list): List of review texts. sentiments (list): List of sentiment labels corresponding to the reviews. Returns: dict: Classification report after grid search. >>> reviews = [ >>> \\"I loved the service\\", >>> \\"The product was terrible\\", >>> \\"Great experience, I would come back again!\\", >>> \\"Not worth the money\\", >>> \\"Fantastic, loved every bit of it\\", >>> \\"Horrible, I will never buy this again\\", >>> \\"It was okay, nothing special\\", >>> \\"Absolutely wonderful, I am very satisfied\\", >>> \\"This is the worst product I have ever bought\\", >>> \\"Not too good, not too bad\\" >>> ] >>> sentiments = [1, 0, 1, 0, 1, 0, 1, 1, 0, 1] >>> report = preprocess_and_train_model(reviews, sentiments) >>> isinstance(report, dict) True >>> 'accuracy' in report True >>> '1' in report True >>> '0' in report True","solution":"import pandas as pd from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.model_selection import GridSearchCV, train_test_split from sklearn.svm import SVC from sklearn.pipeline import Pipeline from sklearn.metrics import classification_report def preprocess_and_train_model(reviews, sentiments): Preprocess the textual reviews, extract features using TF-IDF vectorization, and optimize an SVM classifier using grid search for sentiment analysis. Parameters: reviews (list): List of review texts. sentiments (list): List of sentiment labels corresponding to the reviews. Returns: dict: Classification report after grid search. # Split dataset into training and testing sets X_train, X_test, y_train, y_test = train_test_split(reviews, sentiments, test_size=0.2, random_state=42) # Creating a pipeline with TF-IDF Vectorizer and SVM classifier pipeline = Pipeline([ ('tfidf', TfidfVectorizer()), ('svm', SVC()) ]) # Parameters for Grid Search parameters = { 'tfidf__max_df': [0.8, 0.9, 1.0], 'tfidf__min_df': [1, 2, 3], 'svm__kernel': ['linear', 'rbf'], 'svm__C': [0.1, 1, 10, 100] } # Grid Search with 5-fold cross-validation grid_search = GridSearchCV(pipeline, parameters, cv=5, n_jobs=-1, scoring='accuracy') grid_search.fit(X_train, y_train) # Evaluate the model on the test set y_pred = grid_search.predict(X_test) report = classification_report(y_test, y_pred, output_dict=True) return report"},{"question":"def calculate_bonuses(scores: list[int]) -> list[int]: Calculate the minimum number of bonus units distributed to each employee based on performance scores. Parameters: scores (list of int): List of integer performance scores of employees. Returns: list of int: List of bonuses corresponding to each employee. Examples: >>> calculate_bonuses([1, 2, 2, 3, 1]) [1, 2, 1, 2, 1] >>> calculate_bonuses([5]) [1] >>> calculate_bonuses([4, 4, 4, 4]) [1, 1, 1, 1] >>> calculate_bonuses([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> calculate_bonuses([5, 4, 3, 2, 1]) [5, 4, 3, 2, 1] >>> calculate_bonuses([3, 2, 1, 2, 3]) [3, 2, 1, 2, 3] >>> calculate_bonuses([1, 2, 3, 2, 1]) [1, 2, 3, 2, 1] >>> calculate_bonuses([]) []","solution":"def calculate_bonuses(scores): Calculate the minimum number of bonus units distributed to each employee based on performance scores. Parameters: scores (list of int): List of integer performance scores of employees. Returns: list of int: List of bonuses corresponding to each employee. if not scores: return [] n = len(scores) bonuses = [1] * n # Traverse from left to right for i in range(1, n): if scores[i] > scores[i-1]: bonuses[i] = bonuses[i-1] + 1 # Traverse from right to left for i in range(n-2, -1, -1): if scores[i] > scores[i+1]: bonuses[i] = max(bonuses[i], bonuses[i+1] + 1) return bonuses"},{"question":"def max_product_of_three(nums): Returns the maximum product of any three integers in the list nums. If the list contains fewer than three integers, return None. >>> max_product_of_three([1, 10, 2, 6, 5, 3]) 300 >>> max_product_of_three([-10, -10, 1, 3, 2]) 300 >>> max_product_of_three([-5, -6, -3, -4]) -60 >>> max_product_of_three([-5, 5, -6, 7, 2]) 210 >>> max_product_of_three([1, 2]) None >>> max_product_of_three([3, 2, 1]) 6 >>> max_product_of_three([-10, 1, 2]) -20 >>> max_product_of_three([5, 4, 3]) 60 >>> max_product_of_three([-10, -10, -1, -2]) -20 >>> max_product_of_three([0, 1, 2, 3, 4]) 24 # Your code here","solution":"def max_product_of_three(nums): Returns the maximum product of any three integers in the list nums. If the list contains fewer than three integers, return None. if len(nums) < 3: return None nums.sort() # The maximum product of three numbers could be from: # 1. The product of the three largest numbers # 2. The product of the two smallest numbers and the largest number max_product = max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1]) return max_product"},{"question":"from typing import List def daily_temperatures(temperatures: List[int]) -> List[int]: Given a list of daily temperatures, output a list where each element is the number of days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead. >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures([70, 70, 70, 70]) [0, 0, 0, 0] >>> daily_temperatures([30, 40, 50, 60]) [1, 1, 1, 0] >>> daily_temperatures([60, 50, 40, 30]) [0, 0, 0, 0] >>> daily_temperatures([50]) [0] >>> daily_temperatures([70, 71, 70, 71, 70, 71]) [1, 0, 1, 0, 1, 0]","solution":"from typing import List def daily_temperatures(temperatures: List[int]) -> List[int]: Given a list of daily temperatures, output a list where each element is the number of days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead. n = len(temperatures) answer = [0] * n stack = [] # This will store indices of the temperatures list. for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: idx = stack.pop() answer[idx] = i - idx stack.append(i) return answer"},{"question":"def fibonacci(n): Returns the nth Fibonacci number. >>> fibonacci(10) 55 >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(20) 6765 >>> fibonacci(30) 832040 >>> fibonacci(50) 12586269025 from solution import fibonacci def test_fibonacci_base_cases(): assert fibonacci(0) == 0 assert fibonacci(1) == 1 assert fibonacci(2) == 1 def test_fibonacci_recursive_cases(): assert fibonacci(3) == 2 assert fibonacci(4) == 3 assert fibonacci(5) == 5 assert fibonacci(10) == 55 assert fibonacci(20) == 6765 assert fibonacci(30) == 832040 def test_fibonacci_large_numbers(): assert fibonacci(50) == 12586269025 assert fibonacci(100) == 354224848179261915075 def test_fibonacci_edge_cases(): try: fibonacci(-1) except ValueError as e: assert str(e) == \\"n must be a non-negative integer.\\"","solution":"def fibonacci(n): Returns the nth Fibonacci number using an iterative approach. if n < 0: raise ValueError(\\"n must be a non-negative integer.\\") elif n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def binary_tree_to_doubly_linked_list(root: TreeNode) -> TreeNode: Convert a binary tree to a doubly linked list that represents the in-order traversal of the tree. >>> root = TreeNode(10) >>> root.left = TreeNode(6) >>> root.right = TreeNode(14) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(8) >>> root.right.left = TreeNode(12) >>> root.right.right = TreeNode(16) >>> head = binary_tree_to_doubly_linked_list(root) >>> def get_doubly_linked_list_values(head): >>> values = [] >>> while head: >>> values.append(head.value) >>> head = head.right >>> return values >>> get_doubly_linked_list_values(head) [4, 6, 8, 10, 12, 14, 16] # Your code here","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def binary_tree_to_doubly_linked_list(root: TreeNode) -> TreeNode: def inorder(node): nonlocal last, first if not node: return # Traverse the left subtree inorder(node.left) # Process the current node if last: last.right = node node.left = last else: first = node last = node # Traverse the right subtree inorder(node.right) if not root: return None first, last = None, None inorder(root) return first"},{"question":"def is_special(lst): Returns True if the list is special, otherwise False. A list is special if the sum of each pair of consecutive integers is odd. >>> is_special([1, 2, 3]) True >>> is_special([2, 2, 4]) False >>> is_special([5, 6, 7]) True >>> is_special([1]) True >>> is_special([]) True def make_special(size): Generates and returns a special list of the given size. If it is impossible to create such a list, return an empty list. >>> make_special(0) [] >>> make_special(1) [1] >>> len(make_special(5)) 5 >>> is_special(make_special(2)) True >>> is_special(make_special(5)) True","solution":"def is_special(lst): Returns True if the list is special, otherwise False. A list is special if the sum of each pair of consecutive integers is odd. for i in range(len(lst) - 1): if (lst[i] + lst[i + 1]) % 2 == 0: return False return True def make_special(size): Generates and returns a special list of the given size. If it is impossible to create such a list, returns an empty list. if size == 0: return [] if size == 1: return [1] # single element can be any odd number # For a list to be special, we need alternating odd/even numbers. # An even number count + 1 of an odd number count makes the size ==> size must be <= 2 special_list = [] for i in range(size): if i % 2 == 0: special_list.append(1) # Odd number else: special_list.append(2) # Even number return special_list"},{"question":"from collections import Counter import heapq def rearrange_string(s: str) -> str: Rearranges the input string such that no two adjacent characters are the same. If it is not possible, returns an empty string. >>> rearrange_string(\\"aab\\") 'aba' >>> rearrange_string(\\"aaab\\") '' pass","solution":"from collections import Counter import heapq def rearrange_string(s): Rearranges the input string such that no two adjacent characters are the same. If it is not possible, returns an empty string. freq = Counter(s) max_heap = [(-count, char) for char, count in freq.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, '' result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count = count + 1 # decrement count (i.e., increase the negative counter) prev_char = char return ''.join(result) if len(result) == len(s) else ''"},{"question":"class Book: def __init__(self, isbn, title, author): Initializes a new book with the given ISBN, title, and author. >>> book = Book('12345', 'Python Programming', 'Author A') >>> book.isbn '12345' >>> book.title 'Python Programming' >>> book.author 'Author A' >>> book.available True class Library: def __init__(self): Initializes a new library with an empty list of books. >>> library = Library() >>> len(library.books) 0 def add_book(self, isbn, title, author): Adds a new book to the library. >>> library = Library() >>> library.add_book('12345', 'Python Programming', 'Author A') >>> len(library.books) 1 >>> library.books[0].isbn '12345' def borrow_book(self, isbn): Borrows a book from the library. Raises an exception if the book is not available. >>> library = Library() >>> library.add_book('12345', 'Python Programming', 'Author A') >>> library.borrow_book('12345') 'You have borrowed: Python Programming' >>> library.books[0].available False def return_book(self, isbn): Returns a borrowed book to the library. Raises an exception if the book is not found. >>> library = Library() >>> library.add_book('12345', 'Python Programming', 'Author A') >>> library.borrow_book('12345') >>> library.return_book('12345') 'You have returned: Python Programming' >>> library.books[0].available True def list_books(self): Lists all available books in the library. >>> library = Library() >>> library.add_book('12345', 'Python Programming', 'Author A') >>> library.add_book('67890', 'Machine Learning', 'Author B') >>> library.borrow_book('12345') >>> available_books = library.list_books() >>> len(available_books) 1 >>> available_books[0].title 'Machine Learning'","solution":"class Book: def __init__(self, isbn, title, author): self.isbn = isbn self.title = title self.author = author self.available = True def __repr__(self): return f\\"Book(ISBN: {self.isbn}, Title: {self.title}, Author: {self.author}, Available: {self.available})\\" class Library: def __init__(self): self.books = [] def add_book(self, isbn, title, author): new_book = Book(isbn, title, author) self.books.append(new_book) def borrow_book(self, isbn): for book in self.books: if book.isbn == isbn: if book.available: book.available = False return f\\"You have borrowed: {book.title}\\" else: raise Exception(\\"This book is already borrowed.\\") raise Exception(\\"Book with the given ISBN not found.\\") def return_book(self, isbn): for book in self.books: if book.isbn == isbn: book.available = True return f\\"You have returned: {book.title}\\" raise Exception(\\"Book with the given ISBN not found.\\") def list_books(self): available_books = [book for book in self.books if book.available] return available_books"},{"question":"def find_smallest_missing_positive(nums: List[int]) -> int: Find the smallest positive integer that is missing from the list. >>> find_smallest_missing_positive([3, 4, -1, 1]) # expected output: 2 >>> find_smallest_missing_positive([1, 2, 0]) # expected output: 3 >>> find_smallest_missing_positive([-1, -2, -3]) # expected output: 1","solution":"def find_smallest_missing_positive(nums): n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[i] != nums[nums[i] - 1]: correct_idx = nums[i] - 1 nums[i], nums[correct_idx] = nums[correct_idx], nums[i] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"def fibonacci_sequence(n: int) -> List[int]: Write a function that takes an integer \`n\` and returns a list containing the first \`n\` numbers of the Fibonacci sequence. The Fibonacci sequence is defined such that each number is the sum of the two preceding ones, starting from 0 and 1. >>> fibonacci_sequence(5) [0, 1, 1, 2, 3] >>> fibonacci_sequence(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","solution":"def fibonacci_sequence(n): Returns a list of the first n numbers in the Fibonacci sequence. if n <= 0: return [] sequence = [0, 1] for i in range(2, n): sequence.append(sequence[-1] + sequence[-2]) return sequence[:n]"},{"question":"from typing import List def trap(height: List[int]) -> int: Write a function that takes a list of integers representing an elevation map, where the width of each bar is 1, and computes how much water it is able to trap after raining. :param height: List[int] - A list of non-negative integers representing the elevation map. :return: int - The total amount of water that can be trapped. Example: >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap([4, 2, 0, 3, 2, 5]) 9","solution":"def trap(height): Given a list of integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. :param height: List[int] - A list of non-negative integers representing the elevation map. :return: int - The total amount of water that can be trapped. if not height or len(height) < 3: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] water_trapped = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, height[left]) water_trapped += max(0, left_max - height[left]) else: right -= 1 right_max = max(right_max, height[right]) water_trapped += max(0, right_max - height[right]) return water_trapped"},{"question":"def count_islands(grid): Given a 2D grid of '1's (land) and '0's (water), count the number of islands. An island is formed by connecting adjacent lands horizontally or vertically. Example usage: >>> count_islands([ ... ['1', '1', '0', '0', '0'], ... ['1', '1', '0', '0', '0'], ... ['0', '0', '1', '0', '0'], ... ['0', '0', '0', '1', '1'] ... ]) 3 >>> count_islands([ ... ['0', '0', '0'], ... ['0', '0', '0'], ... ['0', '0', '0'] ... ]) 0 pass def test_single_island(): grid = [ ['1', '1', '1', '1', '0'], ['1', '1', '0', '1', '0'], ['1', '1', '0', '0', '0'], ['0', '0', '0', '0', '0'] ] assert count_islands(grid) == 1 def test_multiple_islands(): grid = [ ['1', '1', '0', '0', '0'], ['1', '1', '0', '0', '0'], ['0', '0', '1', '0', '0'], ['0', '0', '0', '1', '1'] ] assert count_islands(grid) == 3 def test_no_island(): grid = [ ['0', '0', '0'], ['0', '0', '0'], ['0', '0', '0'] ] assert count_islands(grid) == 0 def test_entire_island(): grid = [ ['1', '1', '1'], ['1', '1', '1'], ['1', '1', '1'] ] assert count_islands(grid) == 1 def test_single_cell_islands(): grid = [ ['1', '0', '1', '0', '1'], ['0', '1', '0', '1', '0'], ['1', '0', '1', '0', '1'], ['0', '1', '0', '1', '0'], ['1', '0', '1', '0', '1'] ] assert count_islands(grid) == 13 def test_edge_case_empty_grid(): grid = [] assert count_islands(grid) == 0","solution":"def count_islands(grid): Given a 2D grid of '1's (land) and '0's (water), count the number of islands. An island is formed by connecting adjacent lands horizontally or vertically. if not grid: return 0 rows, cols = len(grid), len(grid[0]) def dfs(x, y): Depth-First Search to mark all parts of the island starting from (x, y) if x < 0 or x >= rows or y < 0 or y >= cols or grid[x][y] != '1': return grid[x][y] = '0' # Mark the land cell as visited by setting it to '0' directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # (down, up, right, left) for dx, dy in directions: dfs(x + dx, y + dy) island_count = 0 for i in range(rows): for j in range(cols): if grid[i][j] == '1': island_count += 1 dfs(i, j) return island_count"},{"question":"import numpy as np import pandas as pd from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.metrics.pairwise import linear_kernel import random def collaborative_filtering(user_item_matrix, user_id, item_id, k=20): Collaborative Filtering using user-item matrix and matrix factorization (SVD). Args: user_item_matrix (np.ndarray): The user-item matrix. user_id (int): The user ID for which to predict the rating. item_id (int): The item ID for which to predict the rating. k (int, optional): The number of nearest neighbors to consider. Defaults to 20. Returns: float: The predicted rating for the specified user and item. pass def content_based_filtering(item_data, item_id, top_n=10): Content-based Filtering using item data. Args: item_data (pd.DataFrame): The item data, typically containing item descriptions. item_id (int): The item ID for which to find similar items. top_n (int, optional): The number of top similar items to return. Defaults to 10. Returns: pd.DataFrame: DataFrame containing the top_n similar items. pass def hybrid_recommendation(user_item_matrix, item_data, user_id, item_id, k_cf=20, top_n_cb=10): Hybrid recommendation system combining collaborative filtering and content-based filtering. Args: user_item_matrix (np.ndarray): The user-item matrix. item_data (pd.DataFrame): The item data, typically containing item descriptions. user_id (int): The user ID for whom to provide recommendations. item_id (int): The item ID for which to find recommendations. k_cf (int, optional): The number of nearest neighbors to consider in collaborative filtering. Defaults to 20. top_n_cb (int, optional): The number of top content-based recommendations to return. Defaults to 10. Returns: pd.DataFrame: DataFrame containing the top combined recommendations. pass def generate_synthetic_data(num_users, num_items): Generate synthetic data for testing. Args: num_users (int): The number of users. num_items (int): The number of items. Returns: tuple: A tuple containing user IDs, item IDs, user-item matrix, and item data. pass # Example test cases def test_collaborative_filtering(): num_users, num_items = 10, 5 user_ids, item_ids, user_item_matrix, _ = generate_synthetic_data(num_users, num_items) user_id, item_id = 0, 0 prediction = collaborative_filtering(user_item_matrix, user_id, item_id) assert isinstance(prediction, float) def test_content_based_filtering(): num_users, num_items = 10, 5 user_ids, item_ids, _, item_data = generate_synthetic_data(num_users, num_items) item_id = 0 top_n = 3 recommendations = content_based_filtering(item_data, item_id, top_n=top_n) assert len(recommendations) == top_n def test_hybrid_recommendation(): num_users, num_items = 10, 5 user_ids, item_ids, user_item_matrix, item_data = generate_synthetic_data(num_users, num_items) user_id, item_id = 0, 0 top_n = 3 recommendations = hybrid_recommendation(user_item_matrix, item_data, user_id, item_id, top_n_cb=top_n) assert len(recommendations) == top_n","solution":"import numpy as np import pandas as pd from sklearn.metrics import mean_squared_error, mean_absolute_error from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.metrics.pairwise import linear_kernel from sklearn.model_selection import train_test_split import random # Collaborative Filtering using user-item matrix and matrix factorization (SVD) def collaborative_filtering(user_item_matrix, user_id, item_id, k=20): user_ratings = user_item_matrix[user_id, :] sim_scores = np.zeros(user_item_matrix.shape[0]) for other_user in range(user_item_matrix.shape[0]): sim_scores[other_user] = np.dot(user_ratings, user_item_matrix[other_user, :]) k_nearest_neighbors = np.argsort(sim_scores)[-k:] predicted_score = np.dot(user_item_matrix[k_nearest_neighbors, item_id], sim_scores[k_nearest_neighbors]) / (np.abs(sim_scores[k_nearest_neighbors]).sum() + 1e-8) return predicted_score # Content-based Filtering using item data def content_based_filtering(item_data, item_id, top_n=10): tfidf = TfidfVectorizer(stop_words='english') tfidf_matrix = tfidf.fit_transform(item_data['description']) cosine_similarities = linear_kernel(tfidf_matrix[item_id], tfidf_matrix).flatten() related_items_indices = cosine_similarities.argsort()[:-top_n-1:-1] return item_data.iloc[related_items_indices] # Hybrid Approach def hybrid_recommendation(user_item_matrix, item_data, user_id, item_id, k_cf=20, top_n_cb=10): cf_prediction = collaborative_filtering(user_item_matrix, user_id, item_id, k=k_cf) cb_recommendations = content_based_filtering(item_data, item_id, top_n=top_n_cb) final_recommendations = cb_recommendations.head(top_n_cb) final_recommendations['cf_score'] = cf_prediction final_recommendations = final_recommendations.sort_values(by='cf_score', ascending=False) return final_recommendations # Generating synthetic data for testing def generate_synthetic_data(num_users, num_items): user_ids = [f\\"user_{i}\\" for i in range(num_users)] item_ids = [f\\"item_{i}\\" for i in range(num_items)] user_item_matrix = np.random.rand(num_users, num_items) item_data = pd.DataFrame({ 'item_id': item_ids, 'description': [f\\"Description of item {i}\\" for i in range(num_items)] }) return user_ids, item_ids, user_item_matrix, item_data # Evaluate performance def evaluate_model(user_item_matrix, user_ids, item_ids): mse_scores = [] mae_scores = [] for _ in range(100): # Sample 100 random test cases user_id = random.choice(range(len(user_ids))) item_id = random.choice(range(len(item_ids))) true_rating = user_item_matrix[user_id, item_id] predicted_rating = collaborative_filtering(user_item_matrix, user_id, item_id) mse_scores.append((predicted_rating - true_rating) ** 2) mae_scores.append(abs(predicted_rating - true_rating)) mse = np.mean(mse_scores) mae = np.mean(mae_scores) return mse, mae # Generating synthetic data num_users = 100 num_items = 50 user_ids, item_ids, user_item_matrix, item_data = generate_synthetic_data(num_users, num_items) # Evaluate the collaborative filtering model mse, mae = evaluate_model(user_item_matrix, user_ids, item_ids) print(f\\"Collaborative Filtering - MSE: {mse}, MAE: {mae}\\")"},{"question":"def frequency_counter(s: str) -> dict: Returns the frequency of each character in the given string. The frequencies are case insensitive and the result is a dictionary sorted by the characters (keys). For example: >>> frequency_counter('Hello World') == {' ': 1, 'd': 1, 'e': 1, 'h': 1, 'l': 3, 'o': 2, 'r': 1, 'w': 1} >>> frequency_counter('') == {}","solution":"def frequency_counter(s): Returns the frequency of each character in the given string. The frequencies are case insensitive and the result is a dictionary sorted by the characters (keys). For example: >>> frequency_counter('Hello World') == {' ': 1, 'd': 1, 'e': 1, 'h': 1, 'l': 3, 'o': 2, 'r': 1, 'w': 1} >>> frequency_counter('') == {} freq_dict = {} for char in s.lower(): if char in freq_dict: freq_dict[char] += 1 else: freq_dict[char] = 1 return dict(sorted(freq_dict.items()))"},{"question":"def findLongestPath(grid: List[List[int]]) -> int: Write a function that takes a 2D grid of integers and returns the length of the longest increasing path in the grid. Each cell can move to any of its four adjacent cells (up, down, left, or right) if the value in the next cell is greater. Ensure that you account for grids that may have cycles or have cells with equal values. >>> findLongestPath([ ... [9, 9, 4], ... [6, 6, 8], ... [2, 1, 1] ... ]) 4 >>> findLongestPath([ ... [3, 4, 5], ... [3, 2, 6], ... [2, 2, 1] ... ]) 4 >>> findLongestPath([ ... [1, 2, 3], ... [6, 5, 4], ... [7, 8, 9] ... ]) 9 >>> findLongestPath([[1]]) 1 >>> findLongestPath([]) 0 >>> findLongestPath([[1, 1], [1, 1]]) 1","solution":"def findLongestPath(grid): if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) cache = [[-1] * cols for _ in range(rows)] def dfs(x, y): if cache[x][y] != -1: return cache[x][y] max_len = 1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] > grid[x][y]: max_len = max(max_len, 1 + dfs(nx, ny)) cache[x][y] = max_len return cache[x][y] result = 0 for i in range(rows): for j in range(cols): result = max(result, dfs(i, j)) return result"},{"question":"from typing import List def is_prime(n: int) -> bool: Determine whether a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(-1) False >>> is_prime(11) True pass def filter_and_sort_primes(numbers: List[int]) -> List[int]: Takes an unsorted list of integers and returns a new list containing only the prime numbers, sorted in increasing order. >>> filter_and_sort_primes([10, 3, 5, -1, -5, 0, 2, 1]) [2, 3, 5] >>> filter_and_sort_primes([4, 6, 8, 9, 10]) [] >>> filter_and_sort_primes([2, 13, 5, 7, 3]) [2, 3, 5, 7, 13] >>> filter_and_sort_primes([]) [] >>> filter_and_sort_primes([29, 23, 2, 3, 19, 17, 11, 13, 5, 7]) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] >>> filter_and_sort_primes([-2, -3, 0, 1, 3, 7, 9, 11]) [3, 7, 11] pass def test_is_prime(): assert is_prime(2) == True assert is_prime(3) == True assert is_prime(4) == False assert is_prime(11) == True assert is_prime(1) == False assert is_prime(0) == False assert is_prime(-1) == False assert is_prime(-11) == False def test_filter_and_sort_primes(): assert filter_and_sort_primes([10, 3, 5, -1, -5, 0, 2, 1]) == [2, 3, 5] assert filter_and_sort_primes([4, 6, 8, 9, 10]) == [] assert filter_and_sort_primes([2, 13, 5, 7, 3]) == [2, 3, 5, 7, 13] assert filter_and_sort_primes([]) == [] assert filter_and_sort_primes([29, 23, 2, 3, 19, 17, 11, 13, 5, 7]) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] assert filter_and_sort_primes([-2, -3, 0, 1, 3, 7, 9, 11]) == [3, 7, 11]","solution":"def is_prime(n): Returns True if n is a prime number, False otherwise. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_and_sort_primes(numbers): Returns a list of prime numbers from the input list, sorted in increasing order. primes = [num for num in numbers if is_prime(num)] return sorted(primes)"},{"question":"class Deque: A double-ended queue (deque) implementation. >>> d = Deque() >>> d.is_empty() True >>> d.add_front(1) >>> d.add_front(2) >>> d.items [2, 1] >>> d.add_rear(3) >>> d.items [2, 1, 3] >>> d.remove_front() 2 >>> d.items [1, 3] >>> d.remove_rear() 3 >>> d.is_empty() False >>> d.remove_front() 1 >>> d.is_empty() True def __init__(self): self.items = [] def is_empty(self): return len(self.items) == 0 def add_front(self, item): pass def add_rear(self, item): pass def remove_front(self): pass def remove_rear(self): pass","solution":"class Deque: def __init__(self): self.items = [] def is_empty(self): return len(self.items) == 0 def add_front(self, item): self.items.insert(0, item) def add_rear(self, item): self.items.append(item) def remove_front(self): if self.is_empty(): raise IndexError(\\"remove_front from empty deque\\") return self.items.pop(0) def remove_rear(self): if self.is_empty(): raise IndexError(\\"remove_rear from empty deque\\") return self.items.pop()"},{"question":"import keyword def is_valid_identifier(s): This function takes a string \`s\` and checks if it qualifies as a valid identifier according to the Python language rules. Examples: >>> is_valid_identifier(\\"var_1\\") True >>> is_valid_identifier(\\"_var\\") True >>> is_valid_identifier(\\"1_var\\") False >>> is_valid_identifier(\\"var1\\") True >>> is_valid_identifier(\\"if\\") False >>> is_valid_identifier(\\"else\\") False","solution":"import keyword def is_valid_identifier(s): ''' This function takes a string \`s\` and checks if it qualifies as a valid identifier according to the Python language rules. Examples: is_valid_identifier(\\"var_1\\") == True is_valid_identifier(\\"_var\\") == True is_valid_identifier(\\"1_var\\") == False is_valid_identifier(\\"var1\\") == True is_valid_identifier(\\"if\\") == False is_valid_identifier(\\"else\\") == False ''' # Check if the string is a keyword if keyword.iskeyword(s): return False # Check if the string is a valid identifier if not s.isidentifier(): return False # If the string passes both checks, return True return True"},{"question":"def most_frequent_integer(nums: List[int]) -> int: Returns the most frequent integer in the list. If there is a tie, returns the smallest integer among the most frequent ones. >>> most_frequent_integer([1, 3, 2, 3, 4, 1, 5, 1]) 1 >>> most_frequent_integer([4, 4, 5, 5, 6, 6, 3]) 4 >>> most_frequent_integer([]) None >>> most_frequent_integer([5]) 5 >>> most_frequent_integer([2, 2, 2, 2, 2]) 2 >>> most_frequent_integer([-1, -1, -2, -2, -3, -3, -1]) -1 >>> most_frequent_integer([1, 2, 2, -1, -1, 2, 3, 3, -1, -1]) -1","solution":"def most_frequent_integer(nums): Returns the most frequent integer in the list. If there is a tie, returns the smallest integer among the most frequent ones. from collections import Counter if not nums: return None # Handle empty list count = Counter(nums) most_frequent_count = max(count.values()) most_frequent_numbers = [num for num, freq in count.items() if freq == most_frequent_count] return min(most_frequent_numbers)"},{"question":"def extract_even_digits(input_string: str) -> str: Write a function in Python that accepts a string containing digits and returns a new string that only contains the even digits, in the same order as they appear in the input string. The provided string will only contain digits (0-9) and will not be empty. Args: input_string (str): The input string containing digits. Returns: str: A string containing only the even digits from the input string. Examples: >>> extract_even_digits(\\"1234567890\\") == \\"24680\\" >>> extract_even_digits(\\"13579\\") == \\"\\" >>> extract_even_digits(\\"8642\\") == \\"8642\\"","solution":"def extract_even_digits(input_string: str) -> str: Returns a string containing only the even digits from the input string. even_digits = \\"02468\\" result = \\"\\" for char in input_string: if char in even_digits: result += char return result"},{"question":"from typing import List def sort_numbers(numbers: List[int]) -> List[int]: Sorts a list of numbers in ascending order using the bubble sort algorithm. >>> sort_numbers([34, 23, 12, 45, 9]) [9, 12, 23, 34, 45] >>> sort_numbers([5, 3, 8, 4, 2]) [2, 3, 4, 5, 8] >>> sort_numbers([]) [] >>> sort_numbers([1]) [1] >>> sort_numbers([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> sort_numbers([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5]","solution":"def sort_numbers(numbers): Sorts the list of numbers in ascending order using bubble sort algorithm. n = len(numbers) for i in range(n): for j in range(0, n - i - 1): if numbers[j] > numbers[j + 1]: numbers[j], numbers[j + 1] = numbers[j + 1], numbers[j] return numbers unsorted_numbers = [34, 23, 12, 45, 9] sorted_numbers = sort_numbers(unsorted_numbers) print(f'Sorted list: {sorted_numbers}')"},{"question":"from typing import List, Dict def count_words(strings: List[str]) -> Dict[str, int]: Takes a list of strings and returns a dictionary mapping each unique word to the number of times it appears in the list. Ignores case and punctuation. Parameters: strings (list of str): The list of input strings. Returns: dict: Dictionary with words as keys and their counts as values. >>> count_words([]) {} >>> count_words([\\"hello\\"]) {\\"hello\\": 1} >>> count_words([\\"hello world\\", \\"hello\\"]) {\\"hello\\": 2, \\"world\\": 1} >>> count_words([\\"Hello\\", \\"HELLO\\", \\"hello\\"]) {\\"hello\\": 3} >>> count_words([\\"hello, world!\\", \\"hello world.\\"]) {\\"hello\\": 2, \\"world\\": 2} >>> count_words([\\"Hello, world!\\", \\"HELLO\\", \\"world.\\"]) {\\"hello\\": 2, \\"world\\": 2} >>> count_words([ \\"It was the best of times, it was the worst of times.\\", \\"It was the age of wisdom, it was the age of foolishness.\\", ]) { \\"it\\": 4, \\"was\\": 4, \\"the\\": 4, \\"best\\": 1, \\"of\\": 4, \\"times\\": 2, \\"worst\\": 1, \\"age\\": 2, \\"wisdom\\": 1, \\"foolishness\\": 1 }","solution":"import re from collections import defaultdict def count_words(strings): Takes a list of strings and returns a dictionary mapping each unique word to the number of times it appears in the list. Ignores case and punctuation. Parameters: strings (list of str): The list of input strings. Returns: dict: Dictionary with words as keys and their counts as values. word_count = defaultdict(int) for string in strings: # Remove punctuation and make lowercase cleaned_string = re.sub(r'[^a-zA-Zs]', '', string).lower() words = cleaned_string.split() for word in words: word_count[word] += 1 return dict(word_count)"},{"question":"def calculate_total(cart): Calculate the total cost of items in the cart, applying a discount of 10% if the total cost exceeds 100. If the cart is empty, return 0. Parameters: cart (list of tuples): A list where each tuple contains a product name and its price. Returns: float: The total cost after applying any applicable discount. >>> calculate_total([]) == 0.0 >>> calculate_total([(\\"item1\\", 25), (\\"item2\\", 35), (\\"item3\\", 30)]) == 90.0 >>> calculate_total([(\\"item1\\", 50), (\\"item2\\", 40), (\\"item3\\", 30)]) == 108.0 >>> calculate_total([(\\"item1\\", 40), (\\"item2\\", 60)]) == 100.0 >>> calculate_total([(\\"expensive_item\\", 150)]) == 135.0 >>> calculate_total([(\\"cheap_item\\", 5), (\\"expensive_item\\", 150)]) == 139.5 >>> calculate_total([(\\"item1\\", 0), (\\"item2\\", 0)]) == 0.0","solution":"def calculate_total(cart): Calculate the total cost of items in the cart, applying a discount of 10% if the total cost exceeds 100. If the cart is empty, return 0. Parameters: cart (list of tuples): A list where each tuple contains a product name and its price. Returns: float: The total cost after applying any applicable discount. if not cart: return 0.0 total = sum(price for item, price in cart) if total > 100: total *= 0.9 return total"},{"question":"class Node: def __init__(self, data=None): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def addNode(self, data): Add a node with the given data to the end of the list. new_node = Node(data) if self.head is None: self.head = new_node return last = self.head while last.next: last = last.next last.next = new_node def getIntersectionNode(list1, list2): Determine and return the intersection point of list1 and list2. pass # Tests import pytest def test_intersection(): # Create first linked list: 4 -> 1 -> 8 -> 4 -> 5 list1 = LinkedList() list1.addNode(4) list1.addNode(1) list1.addNode(8) list1.addNode(4) list1.addNode(5) # Create second linked list: 5 -> 0 -> 1 list2 = LinkedList() list2.addNode(5) list2.addNode(0) list2.addNode(1) # Attach the rest of the list to create an intersection list2.head.next.next.next = list1.head.next.next # Point to 8 assert getIntersectionNode(list1, list2) == 8 def test_no_intersection(): # Create first linked list: 4 -> 1 -> 8 -> 4 -> 5 list1 = LinkedList() list1.addNode(4) list1.addNode(1) list1.addNode(8) list1.addNode(4) list1.addNode(5) # Create second linked list: 5 -> 0 -> 1 -> 7 list2 = LinkedList() list2.addNode(5) list2.addNode(0) list2.addNode(1) list2.addNode(7) assert getIntersectionNode(list1, list2) == None def test_one_list_empty(): # Create first linked list: 4 -> 1 -> 8 -> 4 -> 5 list1 = LinkedList() list1.addNode(4) list1.addNode(1) list1.addNode(8) list1.addNode(4) list1.addNode(5) # Create empty second linked list list2 = LinkedList() assert getIntersectionNode(list1, list2) == None assert getIntersectionNode(list2, list1) == None def test_both_lists_empty(): # Create two empty linked lists list1 = LinkedList() list2 = LinkedList() assert getIntersectionNode(list1, list2) == None pytest.main()","solution":"class Node: def __init__(self, data=None): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def addNode(self, data): Add a node with the given data to the end of the list. new_node = Node(data) if self.head is None: self.head = new_node return last = self.head while last.next: last = last.next last.next = new_node def getIntersectionNode(list1, list2): Determine and return the intersection point of list1 and list2. if list1.head is None or list2.head is None: return None # Get the lengths of both lists list1_len = list1.head list2_len = list2.head len1, len2 = 0, 0 while list1_len: len1 += 1 list1_len = list1_len.next while list2_len: len2 += 1 list2_len = list2_len.next # Reset heads list1_len = list1.head list2_len = list2.head # Adjust starting point for the longer list if len1 > len2: for _ in range(len1 - len2): list1_len = list1_len.next else: for _ in range(len2 - len1): list2_len = list2_len.next # Find intersection point while list1_len and list2_len: if list1_len == list2_len: return list1_len.data # Intersection found list1_len = list1_len.next list2_len = list2_len.next return None # No intersection"},{"question":"def letter_count(s: str) -> dict: Returns a dictionary with the count of each unique letter in the input string. Ignores case and non-letter characters. >>> letter_count(\\"Hello World!\\") == {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> letter_count(\\"AAA\\") == {'a': 3} >>> letter_count(\\"123 ABC abc!\\") == {'a': 2, 'b': 2, 'c': 2} >>> letter_count(\\"\\") == {} >>> letter_count(\\"aAabB\\") == {'a': 3, 'b': 2} >>> letter_count(\\"1234567890!@#%^&*()_+\\") == {}","solution":"def letter_count(s: str) -> dict: Returns a dictionary with the count of each unique letter in the input string. Ignores case and non-letter characters. from collections import Counter # Convert the string to lower case and filter out non-letter characters cleaned_str = ''.join(filter(str.isalpha, s.lower())) # Use Counter to count occurrences of each letter return dict(Counter(cleaned_str))"},{"question":"from typing import List, Optional def second_largest_unique(nums: List[int]) -> Optional[int]: Create a function that takes a list of integers as input and returns the second largest unique integer from the list. If the list contains fewer than two unique integers, the function should return None. >>> second_largest_unique([4, 2, 10, 10, 2, 2, 4, 5]) 5 >>> second_largest_unique([1, 1, 1, 1]) None >>> second_largest_unique([7, 3, 7, 3, 8]) 7","solution":"from typing import List, Optional def second_largest_unique(nums: List[int]) -> Optional[int]: Returns the second largest unique integer from the list. If there are fewer than two unique integers, returns None. unique_nums = set(nums) if len(unique_nums) < 2: return None largest = max(unique_nums) unique_nums.remove(largest) second_largest = max(unique_nums) return second_largest"},{"question":"def min_subarray_len(nums: list[int], k: int) -> int: Returns the minimum length of a contiguous subarray whose sum equals k. If no such subarray exists, returns 0. Example 1: >>> min_subarray_len([1, 1, 1, 2, 4, 3], 6) 2 Example 2: >>> min_subarray_len([1, 2, 3], 3) 1 Example 3: >>> min_subarray_len([1, 1, 1, 1, 1], 5) 5 Constraints: 1. \`1 <= nums.length <= 10^4\` 2. \`-10^5 <= nums[i] <= 10^5\` 3. \`-10^5 <= k <= 10^5\` from solution import min_subarray_len def test_example_1(): assert min_subarray_len([1, 1, 1, 2, 4, 3], 6) == 2 def test_example_2(): assert min_subarray_len([1, 2, 3], 3) == 1 def test_example_3(): assert min_subarray_len([1, 1, 1, 1, 1], 5) == 5 def test_no_subarray(): assert min_subarray_len([1, 2, 3], 7) == 0 def test_large_negative_numbers(): assert min_subarray_len([1, -1, 2, -2, 3, -3, 4], -1) == 1 def test_entire_array_match(): assert min_subarray_len([2, 4, 1, -3, 3, 4, -1], 10) == 7 def test_subarray_in_middle(): assert min_subarray_len([3, 1, -2, 5, 6], 4) == 2 def test_multiple_possible_subarrays(): assert min_subarray_len([1, 2, 3, 1, 1, 1, 2, 4], 5) == 2","solution":"def min_subarray_len(nums, k): Returns the minimum length of a contiguous subarray whose sum equals k. If no such subarray exists, returns 0. current_sum = 0 min_length = float('inf') prefix_sum_map = {0: -1} for i, num in enumerate(nums): current_sum += num if current_sum - k in prefix_sum_map: min_length = min(min_length, i - prefix_sum_map[current_sum - k]) if current_sum not in prefix_sum_map: prefix_sum_map[current_sum] = i return min_length if min_length != float('inf') else 0"},{"question":"def longest_unique_substring(s: str) -> str: Design a function in Python that takes a string as input and returns the longest substring without repeating characters. Your solution should be efficient, working within linear time complexity. Ensure to handle edge cases such as an empty string and strings with all identical characters. >>> longest_unique_substring(\\"\\") == \\"\\" >>> longest_unique_substring(\\"a\\") == \\"a\\" >>> longest_unique_substring(\\"aaaa\\") == \\"a\\" >>> longest_unique_substring(\\"abcdef\\") == \\"abcdef\\" >>> longest_unique_substring(\\"abcabcbb\\") == \\"abc\\" >>> longest_unique_substring(\\"bbbbb\\") == \\"b\\" >>> longest_unique_substring(\\"pwwkew\\") == \\"wke\\" >>> longest_unique_substring(\\"abcaabcdbb\\") == \\"abcd\\"","solution":"def longest_unique_substring(s: str) -> str: Returns the longest substring without repeating characters from the input string. if not s: return \\"\\" start = 0 max_len = 0 max_substring = \\"\\" char_index_map = {} for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i current_len = i - start + 1 if current_len > max_len: max_len = current_len max_substring = s[start:i+1] return max_substring"},{"question":"import csv def count_unique_values_in_column(file_path: str, column_name: str) -> int: Reads a CSV file and returns the number of unique values in a specified column, ignoring rows where the column has missing values. Arguments: file_path -- The path to the CSV file. column_name -- The name of the column to count unique values for. Returns: int -- The number of unique values in the specified column. pass # Example Test Cases def create_csv(file_path, headers, rows): Helper function to create a CSV file for testing. with open(file_path, mode='w', newline='', encoding='utf-8') as file: writer = csv.DictWriter(file, fieldnames=headers) writer.writeheader() for row in rows: writer.writerow(row) def test_count_unique_values_empty_file(): file_path = \\"empty.csv\\" create_csv(file_path, headers=[\\"id\\", \\"name\\"], rows=[]) assert count_unique_values_in_column(file_path, \\"name\\") == 0 def test_count_unique_values_all_missing_values(): file_path = \\"all_missing.csv\\" create_csv(file_path, headers=[\\"id\\", \\"name\\"], rows=[{\\"id\\": \\"1\\", \\"name\\": \\"\\"}, {\\"id\\": \\"2\\", \\"name\\": \\"\\"}]) assert count_unique_values_in_column(file_path, \\"name\\") == 0 def test_count_unique_values_with_some_missing_values(): file_path = \\"some_missing.csv\\" create_csv(file_path, headers=[\\"id\\", \\"name\\"], rows=[{\\"id\\": \\"1\\", \\"name\\": \\"Alice\\"}, {\\"id\\": \\"2\\", \\"name\\": \\"\\"}, {\\"id\\": \\"3\\", \\"name\\": \\"Bob\\"}]) assert count_unique_values_in_column(file_path, \\"name\\") == 2 def test_count_unique_values_no_missing_values(): file_path = \\"no_missing.csv\\" create_csv(file_path, headers=[\\"id\\", \\"name\\"], rows=[{\\"id\\": \\"1\\", \\"name\\": \\"Alice\\"}, {\\"id\\": \\"2\\", \\"name\\": \\"Bob\\"}, {\\"id\\": \\"3\\", \\"name\\": \\"Alice\\"}]) assert count_unique_values_in_column(file_path, \\"name\\") == 2 def test_count_unique_values_non_existent_file(): assert count_unique_values_in_column(\\"non_existent.csv\\", \\"name\\") == 0","solution":"import csv def count_unique_values_in_column(file_path, column_name): Reads a CSV file and returns the number of unique values in a specified column, ignoring rows where the column has missing values. Arguments: file_path -- The path to the CSV file. column_name -- The name of the column to count unique values for. Returns: int -- The number of unique values in the specified column. unique_values = set() try: with open(file_path, newline='', encoding='utf-8') as csvfile: reader = csv.DictReader(csvfile) for row in reader: value = row.get(column_name) if value: unique_values.add(value) except FileNotFoundError: print(f\\"The file {file_path} does not exist.\\") return 0 return len(unique_values)"},{"question":"from typing import List def find_duplicates(nums: List[int]) -> List[int]: Returns a list containing elements that appear more than once in the input list. The order of elements in the returned list is the same as their first appearance in the original list. Parameters: nums (list): A list of integers. Returns: list: A list of integers containing elements that appear more than once in the input list. pass def test_find_duplicates_empty_list(): assert find_duplicates([]) == [] def test_find_duplicates_no_duplicates(): assert find_duplicates([1, 2, 3, 4, 5]) == [] def test_find_duplicates_single_duplicate(): assert find_duplicates([1, 2, 2, 3, 4]) == [2] def test_find_duplicates_multiple_duplicates(): assert find_duplicates([1, 2, 2, 3, 3, 4, 1]) == [1, 2, 3] def test_find_duplicates_all_duplicates(): assert find_duplicates([1, 1, 1, 1]) == [1] def test_find_duplicates_unsorted_list(): assert find_duplicates([4, 5, 6, 4, 4, 5, 5, 6, 6]) == [4, 5, 6] def test_find_duplicates_with_negative_numbers(): assert find_duplicates([-1, -2, -2, -3, -1]) == [-1, -2] def test_find_duplicates_large_list(): large_list = [i for i in range(1000)] + [999] assert find_duplicates(large_list) == [999]","solution":"def find_duplicates(nums): Returns a list containing elements that appear more than once in the input list. The order of elements in the returned list is the same as their first appearance in the original list. Parameters: nums (list): A list of integers. Returns: list: A list of integers containing elements that appear more than once in the input list. from collections import defaultdict count = defaultdict(int) duplicates = [] seen = set() # Count the occurrences of each number in the list for num in nums: count[num] += 1 # Find numbers that appear more than once for num in nums: if count[num] > 1 and num not in seen: duplicates.append(num) seen.add(num) return duplicates"},{"question":"from typing import List, Union, Tuple def highest_product_of_three(nums: List[int]) -> Union[Tuple[int, List[int]], None]: Write a Python function that takes in a list of integers and returns a tuple containing two elements: the highest product of three different numbers in the list and a list of the three numbers that form this product. If there are less than three integers in the list, return None. >>> highest_product_of_three([1, 10, 2, 6, 5, 3]) (300, [10, 6, 5]) >>> highest_product_of_three([1, -10, -2, 6, 5, 3]) (120, [-10, -2, 6]) >>> highest_product_of_three([1, 2]) None","solution":"from typing import List, Union, Tuple def highest_product_of_three(nums: List[int]) -> Union[Tuple[int, List[int]], None]: Returns the highest product of three different numbers in the list and a list of those numbers. If there are less than three integers in the list, returns None. if len(nums) < 3: return None nums.sort() # The highest product can be: # 1. Product of the three largest numbers # 2. Product of the two smallest numbers (both could be negative) and the largest number max1 = nums[-1] * nums[-2] * nums[-3] max2 = nums[0] * nums[1] * nums[-1] if max1 > max2: return (max1, [nums[-1], nums[-2], nums[-3]]) else: return (max2, [nums[0], nums[1], nums[-1]])"},{"question":"def find_permutations_matching_words(s: str, words: list[str]) -> list[str]: Returns a list of all the distinct permutations of the string that match any of the words in the list. Ignores case and assumes input string contains only alphabetic characters. :param s: The input string :param words: The list of words to match against :return: A list of words from the given list that are permutations of the input string >>> find_permutations_matching_words(\\"listen\\", [\\"enlist\\", \\"silent\\", \\"inlets\\", \\"google\\"]) ['enlist', 'silent', 'inlets'] >>> find_permutations_matching_words(\\"LiStEn\\", [\\"EnLiSt\\", \\"sIlEnT\\"]) ['EnLiSt', 'sIlEnT'] >>> find_permutations_matching_words(\\"listen\\", [\\"google\\"]) [] >>> find_permutations_matching_words(\\"\\", [\\"\\"]) [\\"\\"] >>> find_permutations_matching_words(\\"aabbcc\\", [\\"aab\\", \\"abccba\\", \\"abcabc\\"]) ['abccba', 'abcabc'] pass","solution":"def find_permutations_matching_words(s: str, words: list[str]) -> list[str]: Returns a list of all the distinct permutations of the string that match any of the words in the list. Ignores case and assumes input string contains only alphabetic characters. :param s: The input string :param words: The list of words to match against :return: A list of words from the given list that are permutations of the input string from collections import Counter # Convert the input string to lower case and count character frequencies s_counter = Counter(s.lower()) def is_permutation(word): # Convert the word to lower case and count character frequencies return s_counter == Counter(word.lower()) # Filter the words that are permutations of the string return [word for word in words if is_permutation(word)]"},{"question":"def shift_string(input_string: str) -> str: Shifts alphabet characters by one position and replaces numeric characters with their successive digits. - 'a' becomes 'b', 'z' becomes 'a' - 'A' becomes 'B', 'Z' becomes 'A' - '0' becomes '1', '9' becomes '0' # Your code here # Test Cases def test_shift_string_only_alphabets(): assert shift_string('abcde') == 'bcdef' assert shift_string('xyz') == 'yza' assert shift_string('ABCDE') == 'BCDEF' assert shift_string('XYZ') == 'YZA' def test_shift_string_only_numbers(): assert shift_string('0123456789') == '1234567890' assert shift_string('789') == '890' assert shift_string('9') == '0' def test_shift_string_alphabets_and_numbers(): assert shift_string('a1b2c3') == 'b2c3d4' assert shift_string('zZ9') == 'aA0' assert shift_string('x2z9y1') == 'y3a0z2' def test_shift_string_with_special_characters(): assert shift_string('a!2?z') == 'b!3?a' assert shift_string('@#5%X') == '@#6%Y' def test_shift_string_empty(): assert shift_string('') == '' def test_shift_string_mixed(): assert shift_string('aB3xY9mZ0') == 'bC4yZ0nA1'","solution":"def shift_string(input_string): Shifts alphabet characters by one position and replaces numeric characters with their successive digits. - 'a' becomes 'b', 'z' becomes 'a' - 'A' becomes 'B', 'Z' becomes 'A' - '0' becomes '1', '9' becomes '0' result = [] for char in input_string: if 'a' <= char <= 'z': if char == 'z': result.append('a') else: result.append(chr(ord(char) + 1)) elif 'A' <= char <= 'Z': if char == 'Z': result.append('A') else: result.append(chr(ord(char) + 1)) elif '0' <= char <= '9': if char == '9': result.append('0') else: result.append(chr(ord(char) + 1)) else: result.append(char) return ''.join(result)"},{"question":"def total_expenditure(transactions, customer_name): Calculate the total expenditure of a given customer based on the list of transactions. :param transactions: List[Dict], a list of transactions where each transaction is a dictionary :param customer_name: String, the name of the customer :return: int, total amount spent by the given customer >>> transactions = [ ... {'customer': 'Alice', 'product': 'Panasonic Boombox', 'subcategory': 'Stereo Systems', 'price': 150}, ... {'customer': 'Bob', 'product': 'Sony Headphones', 'subcategory': 'Audio Accessories', 'price': 45}, ... {'customer': 'Alice', 'product': 'JBL Speaker', 'subcategory': 'Stereo Systems', 'price': 100}, ... {'customer': 'Bob', 'product': 'Bose Speaker', 'subcategory': 'Stereo Systems', 'price': 200}, ... {'customer': 'Alice', 'product': 'Apple AirPods', 'subcategory': 'Audio Accessories', 'price': 160} ... ] >>> total_expenditure(transactions, 'Alice') 410 >>> total_expenditure(transactions, 'Bob') 245 >>> total_expenditure(transactions, 'Charlie') 0 >>> total_expenditure([], 'Alice') 0 >>> transactions = [ ... {'customer': 'Alice', 'product': 'Panasonic Boombox', 'subcategory': 'Stereo Systems'}, ... {'customer': 'Alice', 'product': 'JBL Speaker', 'subcategory': 'Stereo Systems', 'price': 100} ... ] >>> total_expenditure(transactions, 'Alice') 100","solution":"def total_expenditure(transactions, customer_name): Calculate the total expenditure of a given customer based on the list of transactions. :param transactions: List[Dict], a list of transactions where each transaction is a dictionary :param customer_name: String, the name of the customer :return: int, total amount spent by the given customer total = 0 for transaction in transactions: if transaction.get('customer') == customer_name: total += transaction.get('price', 0) return total"},{"question":"from typing import List def find_unique_numbers(nums: List[int]) -> List[int]: Returns a list of integers that appear exactly once in the input list, in the order they first appeared. >>> find_unique_numbers([4, 5, 4, 5, 7, 8, 8, 9]) == [7, 9] >>> find_unique_numbers([1, 1, 2, 2, 3, 4, 5, 6]) == [3, 4, 5, 6] >>> find_unique_numbers([]) == [] >>> find_unique_numbers([10, 20, 30, 40]) == [10, 20, 30, 40] >>> find_unique_numbers([999]) == [999] >>> find_unique_numbers([2, 3, 2, 4, 5, 3]) == [4, 5] >>> find_unique_numbers([-1, -2, -2, -1, 0]) == [0] pass","solution":"from typing import List def find_unique_numbers(nums: List[int]) -> List[int]: Returns a list of integers that appear exactly once in the input list, in the order they first appeared. count_map = {} # Count the occurrence of each number for num in nums: if num in count_map: count_map[num] += 1 else: count_map[num] = 1 # Collect numbers that appear exactly once unique_numbers = [] for num in nums: if count_map[num] == 1: unique_numbers.append(num) return unique_numbers"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def mergeTwoLists(l1, l2): Merge two sorted linked lists into one sorted linked list and return the head of the merged list. >>> l1 = create_linked_list([1, 2, 4]) >>> l2 = create_linked_list([1, 3, 4]) >>> merged_list = mergeTwoLists(l1, l2) >>> linked_list_to_list(merged_list) [1, 1, 2, 3, 4, 4] >>> l1 = create_linked_list([]) >>> l2 = create_linked_list([]) >>> merged_list = mergeTwoLists(l1, l2) >>> linked_list_to_list(merged_list) [] >>> l1 = create_linked_list([]) >>> l2 = create_linked_list([0]) >>> merged_list = mergeTwoLists(l1, l2) >>> linked_list_to_list(merged_list) [0] >>> l1 = create_linked_list([2, 5, 7]) >>> l2 = create_linked_list([1, 3, 4]) >>> merged_list = mergeTwoLists(l1, l2) >>> linked_list_to_list(merged_list) [1, 2, 3, 4, 5, 7] # Your code here return dummy.next # Helper function to create linked list from a list def create_linked_list(lst): if not lst: return None head = ListNode(lst[0]) current = head for value in lst[1:]: current.next = ListNode(value) current = current.next return head # Helper function to convert linked list to list def linked_list_to_list(node): result = [] while node: result.append(node.val) node = node.next return result","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def mergeTwoLists(l1, l2): dummy = ListNode(0) current = dummy while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next if l1: current.next = l1 else: current.next = l2 return dummy.next # Helper function to create linked list from a list def create_linked_list(lst): if not lst: return None head = ListNode(lst[0]) current = head for value in lst[1:]: current.next = ListNode(value) current = current.next return head # Helper function to convert linked list to list def linked_list_to_list(node): result = [] while node: result.append(node.val) node = node.next return result"},{"question":"def flatten_dict(d: dict) -> dict: Flatten a nested dictionary such that the keys are concatenations of the nested keys, separated by dots. >>> flatten_dict({\\"a\\": 1, \\"b\\": {\\"c\\": 2, \\"d\\": {\\"e\\": 3}}}) {\\"a\\": 1, \\"b.c\\": 2, \\"b.d.e\\": 3} >>> flatten_dict({\\"a\\": 1, \\"b\\": 2}) {\\"a\\": 1, \\"b\\": 2} >>> flatten_dict({}) {}","solution":"def flatten_dict(d): Flatten a nested dictionary such that the keys are concatenations of the nested keys, separated by dots. result = {} def flatten(current, key_prefix=\\"\\"): for key, value in current.items(): full_key = f\\"{key_prefix}.{key}\\" if key_prefix else key if isinstance(value, dict): flatten(value, full_key) else: result[full_key] = value flatten(d) return result"},{"question":"def most_frequent_element(lst): Find and return the most frequent element in a given list of numbers. >>> most_frequent_element([1, 3, 1, 3, 2, 1]) 1 >>> most_frequent_element([1, 1, 1, 1, 1]) 1 >>> most_frequent_element([1, 2, 1, 2]) 1 or 2 >>> most_frequent_element([]) None >>> most_frequent_element([5]) 5 >>> large_list = [1]*1000 + [2]*500 + [3]*300 >>> most_frequent_element(large_list) 1","solution":"def most_frequent_element(lst): count_dict = {} for num in lst: if num not in count_dict: count_dict[num] = 1 else: count_dict[num] += 1 max_count = -1 most_frequent = None for key in count_dict: if count_dict[key] > max_count: max_count = count_dict[key] most_frequent = key return most_frequent # Test case print(most_frequent_element([1, 3, 1, 3, 2, 1])) # Expected output: 1"},{"question":"def rotate_matrix_90_degrees(matrix): Your task is to rotate a given \`n x n\` matrix by 90 degrees clockwise in place. Parameters: matrix (list of list of int): 2D list representing the matrix to be rotated. Examples: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix_90_degrees(matrix) >>> matrix == [ ... [7, 4, 1], ... [8, 5, 2], ... [9, 6, 3] ... ] >>> matrix = [ ... [1, 2], ... [3, 4] ... ] >>> rotate_matrix_90_degrees(matrix) >>> matrix == [ ... [3, 1], ... [4, 2] ... ]","solution":"def rotate_matrix_90_degrees(matrix): n = len(matrix) for i in range(n // 2): for j in range(i, n - i - 1): temp = matrix[i][j] matrix[i][j] = matrix[n - j - 1][i] matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1] matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1] matrix[j][n - i - 1] = temp"},{"question":"import datetime class Device: def __init__(self, name): self.name = name self.is_on = False self.status = {} def turn_on(self): self.is_on = True self.log_action(\\"turned on\\") def turn_off(self): self.is_on = False self.log_action(\\"turned off\\") def get_status(self): return {\\"is_on\\": self.is_on, **self.status} def log_action(self, action): timestamp = datetime.datetime.now().strftime(\\"%Y-%m-%d %H:%M:%S\\") print(f\\"[{timestamp}] {self.name}: {action}\\") class Light(Device): def __init__(self, name, brightness=100): super().__init__(name) self.status[\\"brightness\\"] = brightness def adjust_brightness(self, brightness): self.status[\\"brightness\\"] = brightness self.log_action(f\\"brightness adjusted to {brightness}\\") class Thermostat(Device): def __init__(self, name, temperature=70): super().__init__(name) self.status[\\"temperature\\"] = temperature def adjust_temperature(self, temperature): self.status[\\"temperature\\"] = temperature self.log_action(f\\"temperature adjusted to {temperature}\\") class Camera(Device): def __init__(self, name, resolution=\\"1080p\\"): super().__init__(name) self.status[\\"resolution\\"] = resolution def adjust_resolution(self, resolution): self.status[\\"resolution\\"] = resolution self.log_action(f\\"resolution adjusted to {resolution}\\") class SmartHomeController: def __init__(self): self.devices = [] def add_device(self, device): self.devices.append(device) print(f\\"Device {device.name} added to the system\\") def remove_device(self, device_name): self.devices = [device for device in self.devices if device.name != device_name] print(f\\"Device {device_name} removed from the system\\") def batch_operation(self, device_type, action, *args, **kwargs): for device in self.devices: if isinstance(device, device_type): getattr(device, action)(*args, **kwargs) def get_all_status(self): return {device.name: device.get_status() for device in self.devices} # Unit tests def test_light_operations(): light = Light(\\"Living Room Light\\") light.turn_on() assert light.is_on == True light.adjust_brightness(75) assert light.status[\\"brightness\\"] == 75 light.turn_off() assert light.is_on == False def test_thermostat_operations(): thermostat = Thermostat(\\"Main Thermostat\\") thermostat.turn_on() assert thermostat.is_on == True thermostat.adjust_temperature(68) assert thermostat.status[\\"temperature\\"] == 68 thermostat.turn_off() assert thermostat.is_on == False def test_camera_operations(): camera = Camera(\\"Front Door Camera\\") camera.turn_on() assert camera.is_on == True camera.adjust_resolution(\\"4K\\") assert camera.status[\\"resolution\\"] == \\"4K\\" camera.turn_off() assert camera.is_on == False def test_smart_home_controller(): controller = SmartHomeController() light = Light(\\"Living Room Light\\") thermostat = Thermostat(\\"Main Thermostat\\") camera = Camera(\\"Front Door Camera\\") controller.add_device(light) controller.add_device(thermostat) controller.add_device(camera) controller.batch_operation(Light, \\"turn_on\\") assert light.is_on == True controller.batch_operation(Thermostat, \\"turn_off\\") assert thermostat.is_on == False controller.batch_operation(Camera, \\"adjust_resolution\\", \\"720p\\") assert camera.status[\\"resolution\\"] == \\"720p\\" status = controller.get_all_status() assert status[\\"Living Room Light\\"][\\"is_on\\"] == True assert status[\\"Main Thermostat\\"][\\"is_on\\"] == False assert status[\\"Front Door Camera\\"][\\"resolution\\"] == \\"720p\\" controller.remove_device(\\"Main Thermostat\\") assert len(controller.devices) == 2 assert all(device.name != \\"Main Thermostat\\" for device in controller.devices)","solution":"import datetime class Device: def __init__(self, name): self.name = name self.is_on = False self.status = {} def turn_on(self): self.is_on = True self.log_action(\\"turned on\\") def turn_off(self): self.is_on = False self.log_action(\\"turned off\\") def get_status(self): return {\\"is_on\\": self.is_on, **self.status} def log_action(self, action): timestamp = datetime.datetime.now().strftime(\\"%Y-%m-%d %H:%M:%S\\") print(f\\"[{timestamp}] {self.name}: {action}\\") class Light(Device): def __init__(self, name, brightness=100): super().__init__(name) self.status[\\"brightness\\"] = brightness def adjust_brightness(self, brightness): self.status[\\"brightness\\"] = brightness self.log_action(f\\"brightness adjusted to {brightness}\\") class Thermostat(Device): def __init__(self, name, temperature=70): super().__init__(name) self.status[\\"temperature\\"] = temperature def adjust_temperature(self, temperature): self.status[\\"temperature\\"] = temperature self.log_action(f\\"temperature adjusted to {temperature}\\") class Camera(Device): def __init__(self, name, resolution=\\"1080p\\"): super().__init__(name) self.status[\\"resolution\\"] = resolution def adjust_resolution(self, resolution): self.status[\\"resolution\\"] = resolution self.log_action(f\\"resolution adjusted to {resolution}\\") class SmartHomeController: def __init__(self): self.devices = [] def add_device(self, device): self.devices.append(device) print(f\\"Device {device.name} added to the system\\") def remove_device(self, device_name): self.devices = [device for device in self.devices if device.name != device_name] print(f\\"Device {device_name} removed from the system\\") def batch_operation(self, device_type, action, *args, **kwargs): for device in self.devices: if isinstance(device, device_type): getattr(device, action)(*args, **kwargs) def get_all_status(self): return {device.name: device.get_status() for device in self.devices}"},{"question":"import re from collections import Counter def read_file(filename: str) -> str: Reads the entire content of the file and returns it as a string. pass def process_words(text: str) -> List[str]: Processes the text by converting it to lower case, removing punctuation, and excluding stop words. pass def top_three_words(words: List[str]) -> List[Tuple[str, int]]: Returns the top three most frequent words in the list. pass # Example usage: # filename = 'sample.txt' # text = read_file(filename) # processed_words = process_words(text) # print(top_three_words(processed_words))","solution":"import re from collections import Counter def read_file(filename): Reads the entire content of the file and returns it as a string. with open(filename, 'r') as file: text = file.read() return text def process_words(text): Processes the text by converting it to lower case, removing punctuation, and excluding stop words. stop_words = {'the', 'is', 'in', 'and', 'of', 'to', 'a', 'that', 'it', 'with', 'as', 'for', 'was', 'on', 'at', 'by', 'an'} # Use regex to find all words considering ignore punctuation and other non-alphabetic characters words = re.findall(r'bw+b', text.lower()) filtered_words = [word for word in words if word not in stop_words] return filtered_words def top_three_words(words): Returns the top three most frequent words in the list. word_counter = Counter(words) top_words = word_counter.most_common(3) return top_words # Example usage: # filename = 'sample.txt' # text = read_file(filename) # processed_words = process_words(text) # print(top_three_words(processed_words))"},{"question":"def longest_increasing_subsequence(arr: List[int]) -> int: Returns the length of the longest increasing subsequence in the given list of integers. >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 >>> longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) 1","solution":"def longest_increasing_subsequence(arr): Returns the length of the longest increasing subsequence in the given list of integers. if not arr: return 0 n = len(arr) lis = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return max(lis)"},{"question":"def calculate_average_marks(students): Takes a list of dictionaries each representing a student's record with keys 'name', 'id', and 'marks'. Returns a dictionary where the keys are student ids and the values are the average marks of the respective students. >>> calculate_average_marks([{'name': 'Alice', 'id': 1, 'marks': [80, 90, 100]}, {'name': 'Bob', 'id': 2, 'marks': [70, 85, 75]}, {'name': 'Charlie', 'id': 3, 'marks': [60, 75, 65]}]) {1: 90.0, 2: 76.66666666666667, 3: 66.66666666666667} >>> calculate_average_marks([{'name': 'Alice', 'id': 1, 'marks': []}]) {1: 0} >>> calculate_average_marks([{'name': 'Alice', 'id': 1, 'marks': [50, 70]}]) {1: 60.0} >>> calculate_average_marks([{'name': 'Alice', 'id': 1, 'marks': [100]}]) {1: 100.0} >>> calculate_average_marks([]) {}","solution":"def calculate_average_marks(students): Takes a list of dictionaries each representing a student's record with keys 'name', 'id', and 'marks'. Returns a dictionary where the keys are student ids and the values are the average marks of the respective students. average_marks = {} for student in students: student_id = student['id'] marks = student['marks'] average_marks[student_id] = sum(marks) / len(marks) if marks else 0 return average_marks"},{"question":"def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates an NxN matrix by 90 degrees clockwise. Parameters: matrix (list of list of int): The input 2D matrix. Returns: list of list of int: The rotated matrix. >>> rotate_matrix( ... [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] ... ) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> rotate_matrix([[1]]) [[1]] >>> rotate_matrix([]) []","solution":"def rotate_matrix(matrix): Rotates an NxN matrix by 90 degrees clockwise. Parameters: matrix (list of list of int): The input 2D matrix. Returns: list of list of int: The rotated matrix. n = len(matrix) return [[matrix[n - j - 1][i] for j in range(n)] for i in range(n)]"},{"question":"def find_anagrams(words: List[str]) -> List[List[str]]: Returns a list of all potential anagram groups present in the original list. The groups are sorted alphabetically based on the first word of each group. Only groups with at least two anagrams are included. >>> find_anagrams([\\"listen\\", \\"enlist\\", \\"google\\", \\"silent\\", \\"inlets\\", \\"abc\\", \\"bca\\", \\"loan\\"]) [['abc', 'bca'], ['enlist', 'inlets', 'listen', 'silent']] >>> find_anagrams([\\"one\\", \\"two\\", \\"three\\"]) [] >>> find_anagrams([\\"abc\\", \\"bca\\", \\"cab\\"]) [['abc', 'bca', 'cab']] >>> find_anagrams([\\"Listen\\", \\"SILENT\\", \\"EnLisT\\", \\"GoOgLe\\"]) [['EnLisT', 'Listen', 'SILENT']] >>> find_anagrams([]) [] >>> find_anagrams([\\"TeSt\\", \\"tEsT\\", \\"setT\\"]) [['TeSt', 'setT', 'tEsT']] pass","solution":"from collections import defaultdict def find_anagrams(words): Returns a list of all potential anagram groups present in the original list. The groups are sorted alphabetically based on the first word of each group. Only groups with at least two anagrams are included. anagram_dict = defaultdict(list) for word in words: sorted_word = ''.join(sorted(word.lower())) anagram_dict[sorted_word].append(word) anagram_groups = [sorted(group) for group in anagram_dict.values() if len(group) > 1] return sorted(anagram_groups, key=lambda group: group[0].lower())"},{"question":"def count_integers(numbers): Processes a list of integers and returns a dictionary with the count of each unique integer in the list. Handles invalid inputs by returning an error message, and logs the error details into a separate list. >>> count_integers([1, 2, 2, 3, 1, 4]) ({1: 2, 2: 2, 3: 1, 4: 1}, []) >>> count_integers([1, 2, 'a', 3]) (\\"Invalid Input\\", [\\"List must contain only integers.\\"]) >>> count_integers([]) ({}, []) >>> count_integers(\\"not a list\\") (\\"Invalid Input\\", [\\"Input must be a list.\\"]) >>> count_integers([1, 'string', 2, 2.5]) (\\"Invalid Input\\", [\\"List must contain only integers.\\"])","solution":"def count_integers(numbers): Processes a list of integers and returns a dictionary with the count of each unique integer in the list. Handles invalid inputs by returning an error message, and logs the error details into a separate list. error_log = [] try: if not isinstance(numbers, list): raise ValueError(\\"Input must be a list.\\") if not all(isinstance(n, int) for n in numbers): raise ValueError(\\"List must contain only integers.\\") count_dict = {} for num in numbers: if num in count_dict: count_dict[num] += 1 else: count_dict[num] = 1 return count_dict, error_log except ValueError as e: error_log.append(str(e)) return \\"Invalid Input\\", error_log finally: if error_log: print(\\"Errors occurred. Check error_log for details.\\") else: print(\\"Processing completed without errors.\\")"},{"question":"def is_route_available(grid): Determine if there is a valid route from the top-left corner (start) to the bottom-right corner (end) of the grid. The truck can only travel on roads (1) and can move up, down, left, or right but cannot move diagonally. Parameters: grid (List[List[int]]): A 2D list of integers representing the grid where 1 is a road and 0 is a building. Returns: bool: True if there is a route available, False otherwise. >>> grid_1 = [ ... [1, 0, 1, 1], ... [1, 1, 1, 0], ... [0, 1, 0, 0], ... [1, 1, 1, 1] ... ] >>> is_route_available(grid_1) True >>> grid_2 = [ ... [1, 0, 0, 0], ... [0, 1, 0, 1], ... [1, 1, 1, 1], ... [0, 0, 0, 1] ... ] >>> is_route_available(grid_2) False","solution":"def is_route_available(grid): from collections import deque if not grid or not grid[0]: return False rows, cols = len(grid), len(grid[0]) if grid[0][0] == 0 or grid[rows - 1][cols - 1] == 0: return False directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (rows - 1, cols - 1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and grid[nx][ny] == 1: visited.add((nx, ny)) queue.append((nx, ny)) return False"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression string containing non-negative integers and the operators +, -, *, / and returns the result of the expression. It handles operator precedence correctly. >>> evaluate_expression(\\"2+3\\") == 5 >>> evaluate_expression(\\"2+3*4-8/2\\") == 10 >>> evaluate_expression(\\"1+2+3+4\\") == 10 >>> evaluate_expression(\\"10-1-2-3\\") == 4 >>> evaluate_expression(\\"4*5/2\\") == 10 >>> evaluate_expression(\\"002+03\\") == 5 >>> evaluate_expression(\\"999*999\\") == 998001 >>> evaluate_expression(\\"1+2*3-4/2\\") == 5 >>> evaluate_expression(\\"5\\") == 5 >>> evaluate_expression(\\"5+10/5\\") == 7 pass","solution":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression string containing non-negative integers and the operators +, -, *, / and returns the result of the expression. It handles operator precedence correctly. def operate(op, second, first): if op == '+': return first + second if op == '-': return first - second if op == '*': return first * second if op == '/': return first // second # Two stacks: one for numbers and one for operators num_stack = [] op_stack = [] i = 0 while i < len(expression): if expression[i].isdigit(): num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 num_stack.append(num) i -= 1 else: while (op_stack and op_stack[-1] in \\"*/\\" and expression[i] in \\"+-*/\\") or (op_stack and expression[i] in \\"+-\\" and op_stack[-1] in \\"+-\\"): num_stack.append(operate(op_stack.pop(), num_stack.pop(), num_stack.pop())) op_stack.append(expression[i]) i += 1 while op_stack: num_stack.append(operate(op_stack.pop(), num_stack.pop(), num_stack.pop())) return num_stack[0]"},{"question":"def max_profit(sales): Returns the maximum difference between any two sales figures where the lower sales figure comes earlier in the list than the higher sales figure. Example: >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([5, 4, 3, 2, 1]) 0","solution":"def max_profit(sales): Returns the maximum difference between any two sales figures where the lower sales figure comes earlier in the list than the higher sales figure. if not sales or len(sales) < 2: return 0 min_price = sales[0] max_diff = 0 for price in sales[1:]: if price < min_price: min_price = price else: max_diff = max(max_diff, price - min_price) return max_diff"},{"question":"def strings_to_indices(input_list: List[str]) -> Dict[str, List[int]]: Takes a list of strings as input and returns a dictionary where the keys are unique strings from the list and the values are lists of indices where each string appears in the input list. >>> strings_to_indices([\\"apple\\", \\"banana\\", \\"apple\\", \\"cherry\\", \\"banana\\", \\"apple\\"]) == { >>> \\"apple\\": [0, 2, 5], >>> \\"banana\\": [1, 4], >>> \\"cherry\\": [3] >>> }","solution":"def strings_to_indices(input_list): Takes a list of strings as input and returns a dictionary where the keys are unique strings from the list and the values are lists of indices where each string appears in the input list. :param input_list: List of strings :return: Dictionary with strings as keys and lists of indices as values index_dict = {} for index, string in enumerate(input_list): if string in index_dict: index_dict[string].append(index) else: index_dict[string] = [index] return index_dict"},{"question":"def sum_positive_negative(numbers: List[int]) -> Dict[str, int]: Returns the sum of all positive numbers and the sum of all negative numbers in a dictionary. The function ignores zeros. Parameters: numbers (list): A list of integers. Returns: dict: A dictionary with the keys 'positive_sum' and 'negative_sum'. >>> sum_positive_negative([1, -2, 3, 4, -5, 0, -6]) {'positive_sum': 8, 'negative_sum': -13} >>> sum_positive_negative([1, 5, 3, 7]) {'positive_sum': 16, 'negative_sum': 0} >>> sum_positive_negative([-1, -5, -3, -7]) {'positive_sum': 0, 'negative_sum': -16} >>> sum_positive_negative([0, 0, 1, -1]) {'positive_sum': 1, 'negative_sum': -1} >>> sum_positive_negative([]) {'positive_sum': 0, 'negative_sum': 0} >>> sum_positive_negative([0, 0, 0]) {'positive_sum': 0, 'negative_sum': 0}","solution":"def sum_positive_negative(numbers): Returns the sum of all positive numbers and the sum of all negative numbers in a dictionary. The function ignores zeros. Parameters: numbers (list): A list of integers. Returns: dict: A dictionary with the keys 'positive_sum' and 'negative_sum'. positive_sum = sum(n for n in numbers if n > 0) negative_sum = sum(n for n in numbers if n < 0) return {'positive_sum': positive_sum, 'negative_sum': negative_sum}"},{"question":"def find_single(nums): ''' This function takes in a sorted list of integers, \`nums\`, where each integer occurs exactly twice, except for one unique integer that appears exactly once. The function should employ a logarithmic time complexity solution to identify and return the unique integer. Parameters: nums (List[int]): A sorted list of integers where every element appears twice except for one. Returns: int: The single integer that appears exactly once. Examples: >>> find_single([1, 1, 2, 3, 3, 4, 4, 8, 8]) 2 >>> find_single([1, 1, 2, 2, 3, 3, 4, 5, 5]) 4 >>> find_single([0, 1, 1]) 0 >>> find_single([2, 3, 3]) 2 ''' pass","solution":"def find_single(nums): This function takes in a sorted list of integers, \`nums\`, where each integer occurs exactly twice, except for one unique integer that appears exactly once. The function should employ a logarithmic time complexity solution to identify and return the unique integer. Parameters: nums (List[int]): A sorted list of integers where every element appears twice except for one. Returns: int: The single integer that appears exactly once. left, right = 0, len(nums) - 1 while left < right: mid = left + (right - left) // 2 if mid % 2 == 1: mid -= 1 if nums[mid] == nums[mid + 1]: left = mid + 2 else: right = mid return nums[left]"},{"question":"def find_max(arr): Returns the maximum value in the array. >>> find_max([3, 5, 1, 2, 4]) == 5 >>> find_max([-1, -3, -5, -2]) == -1 >>> find_max([7]) == 7 >>> find_max([]) raises ValueError(\\"Array is empty\\") def find_min(arr): Returns the minimum value in the array. >>> find_min([3, 5, 1, 2, 4]) == 1 >>> find_min([-1, -3, -5, -2]) == -5 >>> find_min([7]) == 7 >>> find_min([]) raises ValueError(\\"Array is empty\\")","solution":"def find_max(arr): Returns the maximum value in the array. if not arr: raise ValueError(\\"Array is empty\\") max_val = arr[0] for num in arr: if num > max_val: max_val = num return max_val def find_min(arr): Returns the minimum value in the array. if not arr: raise ValueError(\\"Array is empty\\") min_val = arr[0] for num in arr: if num < min_val: min_val = num return min_val # Example usage: # arr = [3, 5, 1, 2, 4] # print(\\"Max:\\", find_max(arr)) # print(\\"Min:\\", find_min(arr))"},{"question":"import matplotlib.pyplot as plt import matplotlib.animation as animation import numpy as np def simulate_bouncing_ball(): Simulates and visualizes the movement of a bouncing ball within a 2D box using matplotlib. The ball starts at a random position within the box and moves with a constant velocity. When the ball hits the boundary of the box, it should bounce off in the opposite direction. The box has a fixed size of 100x100 units and the ball has a velocity of 1 unit per update. >>> simulate_bouncing_ball() # This will open a window with the animation pass import pytest def test_ball_starts_within_boundary(): box_size = 100 ball_radius = 1 ball_position = np.random.rand(2) * (box_size - 2*ball_radius) + ball_radius assert ball_radius <= ball_position[0] <= box_size - ball_radius, \\"Ball x-coordinate is out of bounds\\" assert ball_radius <= ball_position[1] <= box_size - ball_radius, \\"Ball y-coordinate is out of bounds\\" def test_ball_velocity_within_range(): ball_velocity = np.random.rand(2) * 2 - 1 # random velocity (-1 to 1) for x and y direction assert -1 <= ball_velocity[0] <= 1, \\"Ball x-velocity is out of range\\" assert -1 <= ball_velocity[1] <= 1, \\"Ball y-velocity is out of range\\" def test_ball_bounce(): box_size = 100 ball_radius = 1 dt = 1 # Simulate a ball at the edge to test bounce ball_position = np.array([ball_radius, box_size - ball_radius]) ball_velocity = np.array([-1, -1]) # Expected to bounce and change direction if ball_position[0] <= ball_radius or ball_position[0] >= box_size - ball_radius: ball_velocity[0] *= -1 if ball_position[1] <= ball_radius or ball_position[1] >= box_size - ball_radius: ball_velocity[1] *= -1 assert ball_velocity[0] == 1, \\"Ball x-velocity did not bounce correctly\\" assert ball_velocity[1] == 1, \\"Ball y-velocity did not bounce correctly\\" if __name__ == \\"__main__\\": pytest.main()","solution":"import matplotlib.pyplot as plt import matplotlib.animation as animation import numpy as np def simulate_bouncing_ball(): box_size = 100 ball_radius = 1 dt = 1 ball_position = np.random.rand(2) * (box_size - 2*ball_radius) + ball_radius ball_velocity = np.random.rand(2) * 2 - 1 # random velocity (-1 to 1) for x and y direction fig, ax = plt.subplots() ax.set_xlim(0, box_size) ax.set_ylim(0, box_size) ball, = plt.plot([], [], 'bo', ms=8) def init(): ball.set_data([], []) return ball, def update(frame): nonlocal ball_position, ball_velocity ball_position += ball_velocity * dt # Check for collisions and update velocity accordingly if ball_position[0] <= ball_radius or ball_position[0] >= box_size - ball_radius: ball_velocity[0] *= -1 if ball_position[1] <= ball_radius or ball_position[1] >= box_size - ball_radius: ball_velocity[1] *= -1 ball.set_data(ball_position[0], ball_position[1]) return ball, ani = animation.FuncAnimation(fig, update, frames=200, init_func=init, blit=True, interval=20, repeat=False) plt.show() # Example usage simulate_bouncing_ball()"},{"question":"def evaluate_expression(expression): Evaluates a mathematical expression provided as a string. The expression will contain non-negative integers, operators (+, -, *, /), and parentheses. The expression should be evaluated with the correct precedence of operators and parentheses. Division should be performed using integer division. This is what the implementation should produce: >>> evaluate_expression(\\"3+2*2\\") == 7 >>> evaluate_expression(\\" 3/2 \\") == 1 >>> evaluate_expression(\\" 3+5 / 2 \\") == 5 >>> evaluate_expression(\\"(2+6*3+5-(3*14/7+2)*5)+3\\") == -12 # Your code goes here.","solution":"def evaluate_expression(expression): Evaluates a mathematical expression provided as a string. The expression contains non-negative integers, operators (+, -, *, /), and parentheses. The expression is evaluated according to operator precedence and parentheses. Division is performed as integer division. :param expression: A string containing the mathematical expression. :return: The integer result of the evaluated expression. def calculate(operators, operands): right = operands.pop() left = operands.pop() operator = operators.pop() if operator == '+': operands.append(left + right) elif operator == '-': operands.append(left - right) elif operator == '*': operands.append(left * right) elif operator == '/': operands.append(left // right) # Integer division def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 operators, operands = [], [] i = 0 while i < len(expression): if expression[i] == ' ': i += 1 continue elif expression[i] == '(': operators.append(expression[i]) elif expression[i].isdigit(): num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 operands.append(num) i -= 1 elif expression[i] == ')': while operators and operators[-1] != '(': calculate(operators, operands) operators.pop() else: while operators and precedence(operators[-1]) >= precedence(expression[i]): calculate(operators, operands) operators.append(expression[i]) i += 1 while operators: calculate(operators, operands) return operands[-1]"},{"question":"def is_prime(n): Check if a number is prime. Args: n (int): The number to check. Returns: bool: True if n is a prime number, False otherwise. if n <= 1: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True def find_primes_in_range(start, end): Finds and prints all prime numbers in the range [start, end]. For each prime number found, also prints the number of prime factors (which is 2). >>> find_primes_in_range(10, 20) 11 is a prime number and has 2 prime factors. 13 is a prime number and has 2 prime factors. 17 is a prime number and has 2 prime factors. 19 is a prime number and has 2 prime factors. >>> find_primes_in_range(20, 10) Invalid range: Starting number should be less than or equal to the ending number. import pytest def test_is_prime(): assert is_prime(2) == True assert is_prime(3) == True assert is_prime(4) == False assert is_prime(17) == True assert is_prime(0) == False assert is_prime(1) == False assert is_prime(-5) == False def test_find_primes_in_range_no_primes(capsys): find_primes_in_range(1, 1) captured = capsys.readouterr() assert captured.out == \\"\\" def test_find_primes_in_range_single_prime(capsys): find_primes_in_range(2, 2) captured = capsys.readouterr() assert captured.out == \\"2 is a prime number and has 2 prime factors.n\\" def test_find_primes_in_range_multiple_primes(capsys): find_primes_in_range(10, 20) captured = capsys.readouterr() assert captured.out == ( \\"11 is a prime number and has 2 prime factors.n\\" \\"13 is a prime number and has 2 prime factors.n\\" \\"17 is a prime number and has 2 prime factors.n\\" \\"19 is a prime number and has 2 prime factors.n\\" ) def test_find_primes_in_range_invalid_range(capsys): find_primes_in_range(20, 10) captured = capsys.readouterr() assert captured.out == \\"Invalid range: Starting number should be less than or equal to the ending number.n\\" def test_find_primes_in_range_non_integer_input(capsys): find_primes_in_range(\\"a\\", 20) captured = capsys.readouterr() assert captured.out == \\"Invalid input: Please enter integer values for the range.n\\" find_primes_in_range(10, \\"b\\") captured = capsys.readouterr() assert captured.out == \\"Invalid input: Please enter integer values for the range.n\\"","solution":"def is_prime(n): Returns True if n is a prime number, otherwise False. if n <= 1: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True def find_primes_in_range(start, end): Finds and prints all prime numbers in the range [start, end]. For each prime number found, also prints the number of prime factors (which is 2). try: start = int(start) end = int(end) except ValueError: print(\\"Invalid input: Please enter integer values for the range.\\") return if start > end: print(\\"Invalid range: Starting number should be less than or equal to the ending number.\\") return for num in range(start, end + 1): if is_prime(num): print(f\\"{num} is a prime number and has 2 prime factors.\\")"},{"question":"from typing import List, Dict def map_indices(lst: List[int]) -> Dict[int, List[int]]: Returns a dictionary mapping each unique integer in the list to a list of its indices in the original list. >>> map_indices([4, 3, 2, 3, 1, 2, 4, 4]) {4: [0, 6, 7], 3: [1, 3], 2: [2, 5], 1: [4]} >>> map_indices([1, 2, 3, 4, 5]) {1: [0], 2: [1], 3: [2], 4: [3], 5: [4]} >>> map_indices([]) {} >>> map_indices([1, 1, 1, 1]) {1: [0, 1, 2, 3]} >>> map_indices([-1, 2, -3, 2, -1, -3]) {-1: [0, 4], 2: [1, 3], -3: [2, 5]}","solution":"def map_indices(lst): Returns a dictionary mapping each unique integer in lst to a list of its indices. Parameters: lst (list): The list of integers Returns: dict: A dictionary where keys are unique integers from the list and values are lists of indices index_map = {} for index, value in enumerate(lst): if value not in index_map: index_map[value] = [] index_map[value].append(index) return index_map"},{"question":"def destination_city(journeys: List[List[str]]) -> str: Returns the destination city with no outgoing journeys. :param journeys: List[List[str]], each sublist represents a direct journey from cityAi to cityBi :return: str, the city with no outgoing journey >>> destination_city([[\\"Paris\\", \\"Berlin\\"], [\\"Berlin\\", \\"Moscow\\"], [\\"Moscow\\", \\"Tokyo\\"]]) 'Tokyo' >>> destination_city([[\\"X\\", \\"Y\\"], [\\"Y\\", \\"Z\\"], [\\"A\\", \\"X\\"], [\\"B\\", \\"A\\"]]) 'Z' >>> destination_city([[\\"A\\", \\"B\\"], [\\"B\\", \\"C\\"], [\\"C\\", \\"D\\"], [\\"D\\", \\"E\\"], [\\"F\\", \\"G\\"]]) 'E' >>> destination_city([[\\"A\\", \\"B\\"]]) 'B' >>> destination_city([[\\"A\\", \\"B\\"], [\\"C\\", \\"B\\"], [\\"B\\", \\"D\\"], [\\"E\\", \\"D\\"]]) 'D'","solution":"def destination_city(journeys): Returns the destination city with no outgoing journeys. :param journeys: List[List[str]], each sublist represents a direct journey from cityAi to cityBi :return: str, the city with no outgoing journey cities_with_departure = set() all_cities = set() for journey in journeys: cityA, cityB = journey cities_with_departure.add(cityA) all_cities.add(cityA) all_cities.add(cityB) # The destination city will be in all_cities but not in cities_with_departure for city in all_cities: if city not in cities_with_departure: return city"},{"question":"def can_transform(str1: str, str2: str) -> bool: Given two strings str1 and str2, return true if they can be transformed into the same string by only removing characters. Specifically, you can remove characters from any part of the string, but cannot rearrange the order of remaining characters. >>> can_transform(\\"abcat\\", \\"act\\") True >>> can_transform(\\"edit\\", \\"tide\\") False >>> can_transform(\\"hello\\", \\"oeh\\") False >>> can_transform(\\"flowchart\\", \\"fcht\\") True","solution":"def can_transform(str1, str2): Returns True if str1 can be transformed to str2 by only deleting characters. m, n = len(str1), len(str2) i, j = 0, 0 while i < m and j < n: if str1[i] == str2[j]: j += 1 i += 1 return j == n"},{"question":"from typing import List, Tuple def sum_diagonal_and_count_primes(matrix: List[List[int]]) -> Tuple[int, int]: Write a function that receives an n x n matrix consisting of positive integers and returns the sum of the diagonal elements of the matrix along with the count of prime numbers in the matrix. The function should handle matrices of various sizes efficiently. Ensure that the solution exhibits good time complexity suitable for large matrices. >>> sum_diagonal_and_count_primes([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) (15, 4) >>> sum_diagonal_and_count_primes([[5]]) (5, 1) >>> sum_diagonal_and_count_primes([[2, 3], [5, 7]]) (9, 4) >>> sum_diagonal_and_count_primes([[4, 6, 8], [10, 12, 14], [16, 18, 20]]) (36, 0) >>> sum_diagonal_and_count_primes([[2, 3, 5], [7, 11, 13], [17, 19, 23]]) (36, 9)","solution":"import math def is_prime(num): Helper function to check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def sum_diagonal_and_count_primes(matrix): Returns the sum of the diagonal elements of the matrix and the count of prime numbers in the matrix. n = len(matrix) diagonal_sum = 0 prime_count = 0 for i in range(n): diagonal_sum += matrix[i][i] for j in range(n): if is_prime(matrix[i][j]): prime_count += 1 return diagonal_sum, prime_count"},{"question":"def swap_case(s: str) -> str: Returns a new string where each character's case is swapped (uppercase becomes lowercase, and vice versa). >>> swap_case(\\"UPPERCASE\\") 'uppercase' >>> swap_case(\\"lowercase\\") 'LOWERCASE' >>> swap_case(\\"HeLLo WoRLD\\") 'hEllO wOrld' >>> swap_case(\\"HeLLo! WoRLD!\\") 'hEllO! wOrld!' >>> swap_case(\\"\\") '' >>> swap_case(\\"123abcXYZ\\") '123ABCxyz' >>> swap_case(\\"!@#%^&*()\\") '!@#%^&*()'","solution":"def swap_case(s): Returns a new string where each character's case is swapped (uppercase becomes lowercase, and vice versa). Parameters: s (str): The input string containing a mix of uppercase and lowercase letters. Returns: str: A new string with each character's case swapped. return s.swapcase()"},{"question":"def sum_border(matrix): Implement a function that takes a matrix of integers and returns the sum of the elements on the border of the matrix. >>> sum_border([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) 40 >>> sum_border([[1, 2, 3, 4], [5, 6, 7, 8]]) 36 >>> sum_border([[1, 2, 3, 4]]) 10 >>> sum_border([[1], [2], [3], [4]]) 10 >>> sum_border([[5]]) 5 >>> sum_border([]) 0 # Your code here","solution":"def sum_border(matrix): Returns the sum of the elements on the border of the matrix. if not matrix or not matrix[0]: return 0 rows = len(matrix) cols = len(matrix[0]) border_sum = 0 # handle single row or single column case if rows == 1: return sum(matrix[0]) if cols == 1: return sum(row[0] for row in matrix) # Sum the first and last rows border_sum += sum(matrix[0]) border_sum += sum(matrix[rows - 1]) # Sum the first and last columns (excluding already added corners) for r in range(1, rows - 1): border_sum += matrix[r][0] + matrix[r][cols - 1] return border_sum"},{"question":"def students_above_threshold(students: List[dict], threshold: int) -> List[str]: Returns a list of names of students whose average grade is above the given threshold. Args: students (list of dict): List of student records where each record is a dictionary with keys 'name' and 'grades'. threshold (int): The grade threshold. Returns: list: List of names of students whose average grade is above the threshold. >>> students_above_threshold([ ... {'name': 'Alice', 'grades': [85, 90, 78]}, ... {'name': 'Bob', 'grades': [70, 85, 65]}, ... {'name': 'Charlie', 'grades': [95, 100, 100]} ... ], 80) ['Alice', 'Charlie'] >>> students_above_threshold([ ... {'name': 'Alice', 'grades': [55, 60, 58]}, ... {'name': 'Bob', 'grades': [62, 65, 67]}, ... {'name': 'Charlie', 'grades': [45, 50, 52]} ... ], 80) [] >>> students_above_threshold([], 80) []","solution":"def students_above_threshold(students, threshold): Returns a list of names of students whose average grade is above the given threshold. Args: students (list of dict): List of student records where each record is a dictionary with keys 'name' and 'grades'. threshold (int): The grade threshold. Returns: list: List of names of students whose average grade is above the threshold. result = [] for student in students: avg_grade = sum(student['grades']) / len(student['grades']) if avg_grade > threshold: result.append(student['name']) return result"},{"question":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxPathSum(root: Optional[TreeNode]) -> int: Returns the maximum path sum in the binary tree. >>> tree = TreeNode(1) >>> tree.left = TreeNode(2) >>> tree.right = TreeNode(3) >>> maxPathSum(tree) 6 >>> tree = TreeNode(-10) >>> tree.left = TreeNode(9) >>> tree.right = TreeNode(20) >>> tree.right.left = TreeNode(15) >>> tree.right.right = TreeNode(7) >>> maxPathSum(tree) 42 def test_single_node(): tree = TreeNode(1) assert maxPathSum(tree) == 1 def test_all_positive(): tree = TreeNode(1) tree.left = TreeNode(2) tree.right = TreeNode(3) assert maxPathSum(tree) == 6 def test_all_negative(): tree = TreeNode(-10) tree.left = TreeNode(-2) tree.right = TreeNode(-3) assert maxPathSum(tree) == -2 def test_mixed_values(): tree = TreeNode(-10) tree.left = TreeNode(9) tree.right = TreeNode(20) tree.right.left = TreeNode(15) tree.right.right = TreeNode(7) assert maxPathSum(tree) == 42 def test_with_zero(): tree = TreeNode(0) tree.left = TreeNode(-2) tree.right = TreeNode(3) assert maxPathSum(tree) == 3 def test_complete_tree(): tree = TreeNode(1) tree.left = TreeNode(2) tree.right = TreeNode(3) tree.left.left = TreeNode(4) tree.left.right = TreeNode(5) tree.right.left = TreeNode(6) tree.right.right = TreeNode(7) assert maxPathSum(tree) == 18 def test_single_negative_node(): tree = TreeNode(-3) assert maxPathSum(tree) == -3","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxPathSum(root: Optional[TreeNode]) -> int: Returns the maximum path sum in the binary tree. def helper(node): nonlocal max_sum if not node: return 0 # Compute the maximum path sum with/without the left child left_max = max(helper(node.left), 0) # Compute the maximum path sum with/without the right child right_max = max(helper(node.right), 0) # Compute the maximum path value at the current node current_max_path = node.val + left_max + right_max # Update the maximum path sum found so far max_sum = max(max_sum, current_max_path) # Return the maximum path sum starting at the current node return node.val + max(left_max, right_max) max_sum = float('-inf') helper(root) return max_sum"},{"question":"from typing import Optional class FileSystem: def __init__(self): Initializes a new file system. self.files = {} def create(self, path: str, content: str) -> None: Creates or overwrites a file at the specified path with the given content. Parameters: path (str): The path of the file. content (str): The content to be written in the file. self.files[path] = content def read(self, path: str) -> Optional[str]: Reads the content of a file at the specified path. Parameters: path (str): The path of the file. Returns: Optional[str]: The content of the file if it exists, otherwise None. return self.files.get(path, None) def update(self, path: str, content: str) -> None: Updates the content of an existing file at the specified path. If the file does not exist, no action is performed. Parameters: path (str): The path of the file to be updated. content (str): The new content to be written in the file. if path in self.files: self.files[path] = content def delete(self, path: str) -> None: Deletes the file at the specified path. If the file does not exist, no action is performed. Parameters: path (str): The path of the file to be deleted. if path in self.files: del self.files[path] # Unit tests def test_filesystem_create_read(): fs = FileSystem() fs.create('/root/file1.txt', 'Hello, World!') assert fs.read('/root/file1.txt') == 'Hello, World!' def test_filesystem_update(): fs = FileSystem() fs.create('/root/file1.txt', 'Hello, World!') fs.update('/root/file1.txt', 'Updated Content') assert fs.read('/root/file1.txt') == 'Updated Content' def test_filesystem_delete(): fs = FileSystem() fs.create('/root/file1.txt', 'Hello, World!') fs.delete('/root/file1.txt') assert fs.read('/root/file1.txt') is None def test_filesystem_create_overwrite(): fs = FileSystem() fs.create('/root/file1.txt', 'Original Content') fs.create('/root/file1.txt', 'New Content') assert fs.read('/root/file1.txt') == 'New Content' def test_filesystem_read_nonexistent(): fs = FileSystem() assert fs.read('/nonexistent/file.txt') is None def test_filesystem_update_nonexistent(): fs = FileSystem() fs.update('/nonexistent/file.txt', 'Nonexistent Content') assert fs.read('/nonexistent/file.txt') is None def test_filesystem_delete_nonexistent(): fs = FileSystem() fs.delete('/nonexistent/file.txt') # Ensure no exception is raised and no state is changed assert fs.read('/nonexistent/file.txt') is None","solution":"from typing import Optional class FileSystem: def __init__(self): self.files = {} def create(self, path: str, content: str) -> None: Creates or overwrites a file at the specified path with the given content. self.files[path] = content def read(self, path: str) -> Optional[str]: Reads the content of a file at the specified path. Returns the content of the file if it exists, otherwise returns None. return self.files.get(path, None) def update(self, path: str, content: str) -> None: Updates the content of an existing file at the specified path. If the file does not exist, no action is performed. if path in self.files: self.files[path] = content def delete(self, path: str) -> None: Deletes the file at the specified path. If the file does not exist, no action is performed. if path in self.files: del self.files[path]"},{"question":"def square_positive_elements(arr): This function processes the given list of integers and returns a list of tuples. Each tuple contains a number from the input list and its squared value, but only includes numbers that are strictly positive. Parameters: arr (list): A list of integers to be processed. Returns: list: A list of tuples containing the positive integers and their squares. Example: >>> square_positive_elements([1, -2, 3, 0]) == [(1, 1), (3, 9)] >>> square_positive_elements([-1, -2, -3]) == [] >>> square_positive_elements([7, 8, 9]) == [(7, 49), (8, 64), (9, 81)] from solution import square_positive_elements def test_square_positive_elements_mixed_values(): assert square_positive_elements([1, -2, 3, 0]) == [(1, 1), (3, 9)] def test_square_positive_elements_all_negative(): assert square_positive_elements([-1, -2, -3]) == [] def test_square_positive_elements_all_positive(): assert square_positive_elements([7, 8, 9]) == [(7, 49), (8, 64), (9, 81)] def test_square_positive_elements_empty_list(): assert square_positive_elements([]) == [] def test_square_positive_elements_contains_zero(): assert square_positive_elements([0, 0, 0]) == [] def test_square_positive_elements_single_positive(): assert square_positive_elements([10]) == [(10, 100)] def test_square_positive_elements_single_negative(): assert square_positive_elements([-10]) == [] def test_square_positive_elements_mixed_with_zero(): assert square_positive_elements([-1, 0, 5, -3, 7, 0]) == [(5, 25), (7, 49)]","solution":"def square_positive_elements(arr): This function processes the given list of integers and returns a list of tuples. Each tuple contains a number from the input list and its squared value, but only includes numbers that are strictly positive. Parameters: arr (list): A list of integers to be processed. Returns: list: A list of tuples containing the positive integers and their squares. Example: >>> square_positive_elements([1, -2, 3, 0]) == [(1, 1), (3, 9)] >>> square_positive_elements([-1, -2, -3]) == [] >>> square_positive_elements([7, 8, 9]) == [(7, 49), (8, 64), (9, 81)] return [(x, x*x) for x in arr if x > 0]"},{"question":"def max_gems_collected(grid: List[List[int]]) -> int: A robot navigates a grid to collect the maximum number of gems. The grid is represented as a 2D list of integers where each element indicates the number of gems at that cell. The robot can move only right or down, starting from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1). >>> max_gems_collected([ ... [1, 3, 1], ... [2, 0, 0], ... [4, 2, 1] ... ]) 10 >>> max_gems_collected([[5]]) 5 >>> max_gems_collected([[1, 2, 3, 4]]) 10 >>> max_gems_collected([ ... [1], ... [2], ... [3], ... [4] ... ]) 10 >>> max_gems_collected([[]]) 0 >>> max_gems_collected([]) 0 >>> max_gems_collected([ ... [0, 0], ... [0, 0] ... ]) 0 >>> max_gems_collected([[1 for _ in range(100)] for _ in range(100)]) 199","solution":"from typing import List def max_gems_collected(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Create a 2D dp array with the same dimensions as grid dp = [[0] * n for _ in range(m)] # Initialize the start point dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner will have the result return dp[m-1][n-1]"},{"question":"def longest_common_prefix(strs): Finds the longest common prefix string amongst an array of strings. Returns an empty string if no common prefix exists. Parameters: strs (List[str]): The list of strings. Returns: str: The longest common prefix. pass # Unit Tests def test_common_prefix_example(): assert longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) == \\"fl\\" def test_no_common_prefix(): assert longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) == \\"\\" def test_all_strings_same(): assert longest_common_prefix([\\"repeat\\", \\"repeat\\", \\"repeat\\"]) == \\"repeat\\" def test_one_empty_string(): assert longest_common_prefix([\\"\\", \\"b\\"]) == \\"\\" def test_empty_list(): assert longest_common_prefix([]) == \\"\\" def test_single_string_in_list(): assert longest_common_prefix([\\"single\\"]) == \\"single\\" def test_common_prefix_with_special_characters(): assert longest_common_prefix([\\"car@#12\\", \\"car@\\", \\"car@#\\"]) == \\"car@\\" def test_case_sensitive(): assert longest_common_prefix([\\"case\\", \\"Case\\"]) == \\"\\"","solution":"def longest_common_prefix(strs): Finds the longest common prefix string amongst an array of strings. Returns an empty string if no common prefix exists. Parameters: strs (List[str]): The list of strings. Returns: str: The longest common prefix. if not strs: return \\"\\" # Take the first string as the initial prefix prefix = strs[0] for string in strs[1:]: # Compare the current string with the prefix and reduce prefix until they match while string.find(prefix) != 0: prefix = prefix[:-1] if not prefix: return \\"\\" return prefix # Example usage: # strs = [\\"flower\\", \\"flow\\", \\"flight\\"] # print(longest_common_prefix(strs)) # Output: \\"fl\\""},{"question":"def longest_subarray_with_two_distinct(nums): Returns the length of the longest subarray with at most two distinct integers. >>> longest_subarray_with_two_distinct([1, 2, 1, 2, 3]) 4 >>> longest_subarray_with_two_distinct([1, 1, 1, 1, 1]) 5 >>> longest_subarray_with_two_distinct([1, 2, 3, 4, 5]) 2 >>> longest_subarray_with_two_distinct([]) 0 >>> longest_subarray_with_two_distinct([1, 2, 1, 2, 1]) 5 >>> longest_subarray_with_two_distinct([10]) 1 >>> longest_subarray_with_two_distinct([10, 20]) 2 >>> longest_subarray_with_two_distinct([-1, -2, -1, -3]) 3","solution":"def longest_subarray_with_two_distinct(nums): Returns the length of the longest subarray with at most two distinct integers. if not nums: return 0 max_len = 0 left = 0 count = {} for right in range(len(nums)): count[nums[right]] = count.get(nums[right], 0) + 1 while len(count) > 2: count[nums[left]] -= 1 if count[nums[left]] == 0: del count[nums[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def first_missing_positive(nums): Write a function that takes a list of integers and returns the first missing positive integer that does not appear in the list. The function should have a time complexity of O(n). For example, given the input [3, 4, -1, 1], the function should return 2. >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([1, 2, 3, 4, 5]) 6 >>> first_missing_positive([7, 8, 9, 11, 12]) 1 >>> first_missing_positive([-1, -2, 0, 2, 3]) 1 >>> first_missing_positive([-1, -2, -3]) 1 >>> first_missing_positive([1, 2, 2, 4]) 3 >>> first_missing_positive([]) 1","solution":"def first_missing_positive(nums): Returns the first missing positive integer from the list nums. n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"from typing import List def is_prime(n: int) -> bool: Returns True if n is a prime number, otherwise False. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(5) == True >>> is_prime(10) == False >>> is_prime(23) == True >>> is_prime(1) == False >>> is_prime(0) == False >>> is_prime(-5) == False def get_primes_from_list(nums: List[int]) -> List[int]: Returns a new list containing only the prime numbers from the original list. Preserves the order of numbers in the original list. >>> get_primes_from_list([2, 4, 5, 6, 7, 8, 9]) == [2, 5, 7] >>> get_primes_from_list([11, 13, 17, 19, 23]) == [11, 13, 17, 19, 23] >>> get_primes_from_list([0, 1, 4, 6, 8, 9]) == [] >>> get_primes_from_list([2, 3, 5, 7, 11]) == [2, 3, 5, 7, 11] >>> get_primes_from_list([]) == [] >>> get_primes_from_list([4, 6, 8, 10]) == [] >>> get_primes_from_list([2, 2, 3, 3, 4, 4, 5, 5]) == [2, 2, 3, 3, 5, 5]","solution":"def is_prime(n): Returns True if n is a prime number, otherwise False. if n <= 1: return False if n == 2: return True # 2 is a prime number if n % 2 == 0: return False # if n is even and not 2, it's not a prime number for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def get_primes_from_list(nums): Returns a new list containing only the prime numbers from the original list. Preserves the order of numbers in the original list. return [num for num in nums if is_prime(num)]"},{"question":"def even_integers_sorted(lst: List[int]) -> List[int]: Returns a new list consisting of only the even integers from the original list, sorted in non-decreasing order. >>> even_integers_sorted([1, 3, 5, 7]) [] >>> even_integers_sorted([4, 1, 3, 2, 6, 9, 8]) [2, 4, 6, 8] >>> even_integers_sorted([10, 4, 6, 2]) [2, 4, 6, 10] >>> even_integers_sorted([]) [] >>> even_integers_sorted([-4, -3, -2, 0, 5, 8]) [-4, -2, 0, 8]","solution":"def even_integers_sorted(lst): Returns a new list consisting of only the even integers from the original list, sorted in non-decreasing order. evens = [num for num in lst if num % 2 == 0] # Implementing bubble sort for educational purposes n = len(evens) for i in range(n): for j in range(0, n-i-1): if evens[j] > evens[j+1]: evens[j], evens[j+1] = evens[j+1], evens[j] return evens"},{"question":"def aggregate_sales(data): Takes a list of sales data and returns a dictionary aggregating total sales for each product across all regions. data: List[Dict] A list of dictionaries where each dictionary contains 'region', 'product_id', and 'sales' keys. returns: Dict A dictionary with product IDs as keys and their aggregated total sales as values. >>> sales_data = [ ... {\\"region\\": \\"North\\", \\"product_id\\": 101, \\"sales\\": 150}, ... {\\"region\\": \\"South\\", \\"product_id\\": 101, \\"sales\\": 200}, ... {\\"region\\": \\"East\\", \\"product_id\\": 102, \\"sales\\": 300}, ... {\\"region\\": \\"West\\", \\"product_id\\": 103, \\"sales\\": 250}, ... {\\"region\\": \\"North\\", \\"product_id\\": 102, \\"sales\\": 100}, ... {\\"region\\": \\"South\\", \\"product_id\\": 103, \\"sales\\": 300}, ... ] >>> aggregate_sales(sales_data) {101: 350, 102: 400, 103: 550} import pytest sales_data = [ {\\"region\\": \\"North\\", \\"product_id\\": 101, \\"sales\\": 150}, {\\"region\\": \\"South\\", \\"product_id\\": 101, \\"sales\\": 200}, {\\"region\\": \\"East\\", \\"product_id\\": 102, \\"sales\\": 300}, {\\"region\\": \\"West\\", \\"product_id\\": 103, \\"sales\\": 250}, {\\"region\\": \\"North\\", \\"product_id\\": 102, \\"sales\\": 100}, {\\"region\\": \\"South\\", \\"product_id\\": 103, \\"sales\\": 300}, ] expected_output = { 101: 350, 102: 400, 103: 550, } additional_sales_data = [ {\\"region\\": \\"North\\", \\"product_id\\": 104, \\"sales\\": 50}, {\\"region\\": \\"West\\", \\"product_id\\": 104, \\"sales\\": 150}, {\\"region\\": \\"South\\", \\"product_id\\": 105, \\"sales\\": 500}, {\\"region\\": \\"East\\", \\"product_id\\": 105, \\"sales\\": 300}, ] expected_output_additional = { 104: 200, 105: 800, } def test_aggregate_sales_sample_data(): assert aggregate_sales(sales_data) == expected_output def test_additional_sales_data(): assert aggregate_sales(additional_sales_data) == expected_output_additional def test_empty_sales_data(): assert aggregate_sales([]) == {} def test_single_entry_sales_data(): single_entry_data = [{\\"region\\": \\"North\\", \\"product_id\\": 101, \\"sales\\": 150}] expected_single_entry_output = {101: 150} assert aggregate_sales(single_entry_data) == expected_single_entry_output def test_multiple_entries_same_product(): multiple_entries_same_product = [ {\\"region\\": \\"North\\", \\"product_id\\": 101, \\"sales\\": 100}, {\\"region\\": \\"South\\", \\"product_id\\": 101, \\"sales\\": 100}, {\\"region\\": \\"East\\", \\"product_id\\": 101, \\"sales\\": 100}, ] expected_output_multiple_entries = {101: 300} assert aggregate_sales(multiple_entries_same_product) == expected_output_multiple_entries","solution":"def aggregate_sales(data): Takes a list of sales data and returns a dictionary aggregating total sales for each product across all regions. data: List[Dict] A list of dictionaries where each dictionary contains 'region', 'product_id', and 'sales' keys. returns: Dict A dictionary with product IDs as keys and their aggregated total sales as values. aggregated_sales = {} for entry in data: product_id = entry['product_id'] sales = entry['sales'] if product_id in aggregated_sales: aggregated_sales[product_id] += sales else: aggregated_sales[product_id] = sales return aggregated_sales # Sample sales data sales_data = [ {\\"region\\": \\"North\\", \\"product_id\\": 101, \\"sales\\": 150}, {\\"region\\": \\"South\\", \\"product_id\\": 101, \\"sales\\": 200}, {\\"region\\": \\"East\\", \\"product_id\\": 102, \\"sales\\": 300}, {\\"region\\": \\"West\\", \\"product_id\\": 103, \\"sales\\": 250}, {\\"region\\": \\"North\\", \\"product_id\\": 102, \\"sales\\": 100}, {\\"region\\": \\"South\\", \\"product_id\\": 103, \\"sales\\": 300}, ] # Expected output expected_output = { 101: 350, 102: 400, 103: 550, } # Testing the function with the sample data print(aggregate_sales(sales_data)) # should print expected_output"},{"question":"class StudentRecordSystem: A simple student record system that supports adding, retrieving, updating, and calculating average grades for student records. >>> system = StudentRecordSystem() >>> system.add_student(1, \\"John Doe\\", [90, 80, 85]) >>> system.get_student(1) {'name': 'John Doe', 'grades': [90, 80, 85]} >>> system.update_student(1, name=\\"John Smith\\", grades=[88, 92]) >>> system.get_student(1) {'name': 'John Smith', 'grades': [88, 92]} >>> system.calculate_average_grade(1) 90.0","solution":"class StudentRecordSystem: def __init__(self): self.records = {} def add_student(self, student_id, name, grades): if student_id in self.records: raise ValueError(\\"Student ID already exists.\\") self.records[student_id] = {\\"name\\": name, \\"grades\\": grades} def get_student(self, student_id): if student_id not in self.records: raise ValueError(\\"Student ID does not exist.\\") return self.records[student_id] def update_student(self, student_id, name=None, grades=None): if student_id not in self.records: raise ValueError(\\"Student ID does not exist.\\") if name is not None: self.records[student_id][\\"name\\"] = name if grades is not None: self.records[student_id][\\"grades\\"] = grades def calculate_average_grade(self, student_id): if student_id not in self.records: raise ValueError(\\"Student ID does not exist.\\") grades = self.records[student_id][\\"grades\\"] if not grades: raise ValueError(\\"No grades available for the student.\\") return sum(grades) / len(grades)"},{"question":"def reverse_alphabets_only(s: str) -> str: Returns a new string containing only the alphabetical characters from the original string, but in reversed order. >>> reverse_alphabets_only(\\"a1b2c3!@#\\") == \\"cba\\" >>> reverse_alphabets_only(\\"abcdef\\") == \\"fedcba\\" >>> reverse_alphabets_only(\\"123!@#\\") == \\"\\" >>> reverse_alphabets_only(\\"AbC!9&Xz\\") == \\"zXCbA\\" >>> reverse_alphabets_only(\\"\\") == \\"\\" >>> reverse_alphabets_only(\\" a b c! \\") == \\"cba\\"","solution":"def reverse_alphabets_only(s): Returns a new string containing only the alphabetical characters from the original string, but in reversed order. return ''.join([char for char in s if char.isalpha()][::-1])"},{"question":"def character_count(s: str) -> dict: Returns a dictionary with each unique character (case-insensitive) as keys, and the count of their occurrences as values. Ignores spaces and special characters. >>> character_count(\\"Hello, World!\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> character_count(\\"AaBbCc\\") {'a': 2, 'b': 2, 'c': 2} >>> character_count(\\" \\") {} >>> character_count(\\"\\") {}","solution":"def character_count(s): Returns a dictionary with each unique character (case-insensitive) as keys, and the count of their occurrences as values. Ignores spaces and special characters. import string s = s.lower() char_dict = {} for char in s: if char in string.ascii_lowercase: # Only consider alphabet characters char_dict[char] = char_dict.get(char, 0) + 1 return char_dict"},{"question":"import random from typing import List, Tuple def simulate_dice_rolls(num_rolls: int = 1000) -> List[Tuple[int, int, float]]: Simulates the rolling of a pair of six-sided dice for a specified number of times. Counts and returns the frequency and percentage of each possible outcome in a tabulated format. >>> results = simulate_dice_rolls(1000) >>> 99.9 <= sum(percentage for outcome, frequency, percentage in results) <= 100.1 True >>> all(2 <= outcome <= 12 for outcome, frequency, percentage in results) True pass # Example test code if __name__ == \\"__main__\\": results = simulate_dice_rolls(1000) for outcome, frequency, percentage in results: print(f\\"Outcome: {outcome}, Frequency: {frequency}, Percentage: {percentage:.2f}%\\")","solution":"import random def simulate_dice_rolls(num_rolls=1000): outcomes = {i: 0 for i in range(2, 13)} for _ in range(num_rolls): die1 = random.randint(1, 6) die2 = random.randint(1, 6) outcome = die1 + die2 outcomes[outcome] += 1 results = [] for outcome, frequency in sorted(outcomes.items()): percentage = (frequency / num_rolls) * 100 results.append((outcome, frequency, percentage)) return results"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a mathematical expression containing integers, addition (+), and multiplication (*). The function follows standard operator precedence (i.e., multiplication before addition). >>> evaluate_expression(\\"2+3*4\\") == 14 >>> evaluate_expression(\\"10+20*30\\") == 610 >>> evaluate_expression(\\"1+2+3\\") == 6 >>> evaluate_expression(\\"2*3*4\\") == 24 >>> evaluate_expression(\\"1+2*3+4\\") == 11 >>> evaluate_expression(\\"2+3*4+5*6\\") == 44 >>> evaluate_expression(\\"42\\") == 42 >>> evaluate_expression(\\"0+0*0\\") == 0","solution":"def evaluate_expression(expression): Evaluate a mathematical expression containing integers, addition (+), and multiplication (*). The function follows standard operator precedence (i.e., multiplication before addition). def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == '+': values.append(left + right) elif operator == '*': values.append(left * right) operators = [] values = [] i = 0 while i < len(expression): if expression[i].isdigit(): num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 values.append(num) continue elif expression[i] in \\"+*\\": while (operators and operators[-1] in \\"*\\"): apply_operator(operators, values) operators.append(expression[i]) i += 1 while operators: apply_operator(operators, values) return values[0]"},{"question":"def count_unique_characters(input_str: str) -> dict: Returns a dictionary with each unique alphanumeric character in the input string as the key and the number of times it appears in the string as the value. Ignores case and discards spaces, punctuation, and other special characters. >>> count_unique_characters(\\"Hello, World! 123\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1, '1': 1, '2': 1, '3': 1} >>> count_unique_characters(\\"\\") {} >>> count_unique_characters(\\"!@#%^&*()\\") {} >>> count_unique_characters(\\"AaAaBbBb\\") {'a': 4, 'b': 4} >>> count_unique_characters(\\"112233\\") {'1': 2, '2': 2, '3': 2} >>> count_unique_characters(\\"AbCdEfGh\\") {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'e': 1, 'f': 1, 'g': 1, 'h': 1}","solution":"import re from collections import defaultdict def count_unique_characters(input_str): Returns a dictionary with each unique alphanumeric character in the input string as the key and the number of times it appears in the string as the value. Ignores case and discards spaces, punctuation, and other special characters. # Convert the string to lowercase input_str = input_str.lower() # Remove all non-alphanumeric characters cleaned_str = re.sub(r'[^a-z0-9]', '', input_str) # Initialize a default dictionary to store character counts char_count = defaultdict(int) # Count each character in the cleaned string for char in cleaned_str: char_count[char] += 1 # Convert defaultdict to a regular dictionary and return return dict(char_count)"},{"question":"def add_task(task_list, new_task): Adds a new task to the task list if no task with the same title exists. If a task with the same title already exists, raises a ValueError pass def complete_task(task_list, task_title): Marks the task with the given title as completed. If no such task exists, raises a ValueError pass def pending_tasks(task_list): Returns a list of titles of all tasks that are not completed yet, sorted by their priority in descending order. pass # Unit Tests def test_add_task(): task_list = [{'title': 'Task 1', 'priority': 5, 'completed': False}] new_task = {'title': 'Task 2', 'priority': 3, 'completed': False} add_task(task_list, new_task) assert len(task_list) == 2 assert task_list[1] == new_task def test_add_task_duplicate_title(): task_list = [{'title': 'Task 1', 'priority': 5, 'completed': False}] new_task = {'title': 'Task 1', 'priority': 3, 'completed': False} try: add_task(task_list, new_task) except ValueError as e: assert str(e) == \\"Task with the same title already exists\\" def test_complete_task(): task_list = [{'title': 'Task 1', 'priority': 5, 'completed': False}] complete_task(task_list, 'Task 1') assert task_list[0]['completed'] == True def test_complete_task_not_exists(): task_list = [{'title': 'Task 1', 'priority': 5, 'completed': False}] try: complete_task(task_list, 'Task 2') except ValueError as e: assert str(e) == \\"Task with the given title does not exist\\" def test_pending_tasks(): task_list = [ {'title': 'Task 1', 'priority': 5, 'completed': False}, {'title': 'Task 2', 'priority': 3, 'completed': True}, {'title': 'Task 3', 'priority': 4, 'completed': False} ] result = pending_tasks(task_list) expected = ['Task 1', 'Task 3'] assert result == expected","solution":"def add_task(task_list, new_task): Adds a new task to the task list if no task with the same title exists. If a task with the same title already exists, raises a ValueError for task in task_list: if task['title'] == new_task['title']: raise ValueError(\\"Task with the same title already exists\\") task_list.append(new_task) def complete_task(task_list, task_title): Marks the task with the given title as completed. If no such task exists, raises a ValueError for task in task_list: if task['title'] == task_title: task['completed'] = True return raise ValueError(\\"Task with the given title does not exist\\") def pending_tasks(task_list): Returns a list of titles of all tasks that are not completed yet, sorted by their priority in descending order. pending = [task['title'] for task in task_list if not task['completed']] pending_sorted = sorted(pending, key=lambda title: next(task['priority'] for task in task_list if task['title'] == title), reverse=True) return pending_sorted"},{"question":"def longest_increasing_path(matrix: List[List[int]]) -> int: Find the longest increasing path in a matrix where each move is to one of the four cardinal directions (left, right, up, or down), and each cell must be strictly larger than the previous cell. Args: matrix (List[List[int]]): A 2D list representing the matrix. Returns: int: The length of the longest increasing path. Examples: >>> longest_increasing_path([ ... [9,9,4], ... [6,6,8], ... [2,1,1] ... ]) == 4 >>> longest_increasing_path([ ... [3,4,5], ... [3,2,6], ... [2,2,1] ... ]) == 4 from solution import longest_increasing_path def test_example_1(): matrix = [ [9,9,4], [6,6,8], [2,1,1] ] assert longest_increasing_path(matrix) == 4 def test_example_2(): matrix = [ [3,4,5], [3,2,6], [2,2,1] ] assert longest_increasing_path(matrix) == 4 def test_single_element_matrix(): matrix = [ [1] ] assert longest_increasing_path(matrix) == 1 def test_empty_matrix(): matrix = [] assert longest_increasing_path(matrix) == 0 def test_flat_matrix(): matrix = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert longest_increasing_path(matrix) == 1 def test_large_increasing_rectangle(): matrix = [ [1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6], [4, 5, 6, 7] ] assert longest_increasing_path(matrix) == 7 def test_same_value(): matrix = [ [7, 7, 7], [7, 7, 7], [7, 7, 7] ] assert longest_increasing_path(matrix) == 1","solution":"def longest_increasing_path(matrix): if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) memo = [[-1] * n for _ in range(m)] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def dfs(x, y): if memo[x][y] != -1: return memo[x][y] max_length = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and matrix[nx][ny] > matrix[x][y]: max_length = max(max_length, 1 + dfs(nx, ny)) memo[x][y] = max_length return max_length result = 0 for i in range(m): for j in range(n): result = max(result, dfs(i, j)) return result"},{"question":"from typing import List, Tuple def closest_pairs(points: List[Tuple[int, int]]) -> List[Tuple[Tuple[int, int], Tuple[int, int]]]: Given a list of points represented as tuples of (x, y), return a list of pairs of points (tuples of tuples) that are closest to each other. Each point must appear in exactly one pair. >>> closest_pairs([(1, 1), (2, 2), (3, 3), (4, 4)]) [((1, 1), (2, 2)), ((3, 3), (4, 4))] >>> closest_pairs([(0, 0), (1, 1), (3, 3), (4, 4)]) [((0, 0), (1, 1)), ((3, 3), (4, 4))] >>> closest_pairs([(1, 1), (4, 4), (2, 2), (3, 3)]) [((1, 1), (2, 2)), ((3, 3), (4, 4))] >>> closest_pairs([(1, 1), (2, 2)]) [((1, 1), (2, 2))] >>> closest_pairs([(1, 1)]) []","solution":"from itertools import combinations import math def euclidean_distance(p1, p2): Calculate the Euclidean distance between two points p1 and p2. return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def closest_pairs(points): Given a list of points represented as tuples of (x, y), return a list of pairs of points (tuples of tuples) that are closest to each other. Each point must appear in exactly one pair. if len(points) < 2: return [] # Sort the points to have a deterministic order required by the task points = sorted(points) # Dictionary to store the minimum pair and their distance min_distance_pairs = [] while points: min_distance = float('inf') closest_pair = None for p1, p2 in combinations(points, 2): distance = euclidean_distance(p1, p2) if distance < min_distance: min_distance = distance closest_pair = (p1, p2) if closest_pair: min_distance_pairs.append(closest_pair) points.remove(closest_pair[0]) points.remove(closest_pair[1]) return min_distance_pairs"},{"question":"def longestKDistinctSubstring(s: str, k: int) -> (int, str): Given a string s and an integer k, find the length of the longest substring of s that contains at most k distinct characters. If there are multiple substrings of the same maximum length, return the first one by considering the earliest occurrence. >>> longestKDistinctSubstring(\\"eceba\\", 2) (3, \\"ece\\") >>> longestKDistinctSubstring(\\"aa\\", 1) (2, \\"aa\\") >>> longestKDistinctSubstring(\\"abdeefff\\", 3) (6, \\"deefff\\") >>> longestKDistinctSubstring(\\"\\", 1) (0, \\"\\") >>> longestKDistinctSubstring(\\"abc\\", 0) (0, \\"\\") >>> longestKDistinctSubstring(\\"abcdefg\\", 7) (7, \\"abcdefg\\") >>> longestKDistinctSubstring(\\"aaaa\\", 1) (4, \\"aaaa\\")","solution":"def longestKDistinctSubstring(s, k): from collections import defaultdict n = len(s) if n == 0 or k == 0: return 0, \\"\\" char_count = defaultdict(int) left = 0 max_len = 0 max_substr = \\"\\" for right in range(n): char_count[s[right]] += 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 if right - left + 1 > max_len: max_len = right - left + 1 max_substr = s[left:right+1] return max_len, max_substr"},{"question":"def unique_integers_sum_to_zero(n: int) -> List[int]: Implement a function that takes a single integer \`n\` and returns a list of \`n\` unique integers that sum up to zero. If \`n\` is odd, the result should include zero, otherwise, it should not. Ensure that the list maintains unique elements and handles both odd and even values of \`n\` effectively. >>> unique_integers_sum_to_zero(3) [-1, 0, 1] >>> unique_integers_sum_to_zero(4) [-2, -1, 1, 2] >>> unique_integers_sum_to_zero(1) [0] >>> unique_integers_sum_to_zero(6) [-3, -2, -1, 1, 2, 3] >>> unique_integers_sum_to_zero(0) []","solution":"def unique_integers_sum_to_zero(n): Returns a list of n unique integers that sum to zero. result = [] # If n is odd, add 0 to the list if n % 2 != 0: result.append(0) n -= 1 # Add pairs of negative and positive integers for i in range(1, n // 2 + 1): result.extend([-i, i]) return result"},{"question":"def filter_students_by_attendance_and_grade(students: List[Dict[str, Any]], threshold: float) -> List[Dict[str, float]]: Filters students by attendance and average grade above a specified threshold. :param students: List of student records where each record is a dictionary with keys 'name', 'grades', and 'attendance'. :param threshold: A numerical value representing the grade threshold. :return: A list of dictionaries containing 'name' and 'average_grade' of students meeting the criteria. >>> students = [ ... {'name': 'Alice', 'grades': [90, 85, 88], 'attendance': True}, ... {'name': 'Bob', 'grades': [70, 75, 78], 'attendance': False}, ... {'name': 'Charlie', 'grades': [95, 90, 93], 'attendance': True}, ... {'name': 'David', 'grades': [60, 62, 68], 'attendance': True} ... ] >>> threshold = 85 >>> filter_students_by_attendance_and_grade(students, threshold) [{'name': 'Charlie', 'average_grade': 92.67}, {'name': 'Alice', 'average_grade': 87.67}] filtered_students = [] # Your code here return filtered_students","solution":"def filter_students_by_attendance_and_grade(students, threshold): Filters students by attendance and average grade above a specified threshold. :param students: List of student records where each record is a dictionary with keys 'name', 'grades', and 'attendance'. :param threshold: A numerical value representing the grade threshold. :return: A list of dictionaries containing 'name' and 'average_grade' of students meeting the criteria. filtered_students = [] for student in students: if student['attendance']: avg_grade = sum(student['grades']) / len(student['grades']) if avg_grade > threshold: filtered_students.append({ 'name': student['name'], 'average_grade': round(avg_grade, 2) }) # Sort the students by average_grade in descending order filtered_students.sort(key=lambda x: x['average_grade'], reverse=True) return filtered_students"},{"question":"def normalize_phone_number(phone_number: str) -> str: Normalizes phone numbers into the (XXX) XXX-XXXX format. >>> normalize_phone_number(\\"123-456-7890\\") \\"(123) 456-7890\\" >>> normalize_phone_number(\\"(123) 456-7890\\") \\"(123) 456-7890\\" >>> normalize_phone_number(\\"123.456.7890\\") \\"(123) 456-7890\\" >>> normalize_phone_number(\\"123 456 7890\\") \\"(123) 456-7890\\" >>> normalize_phone_number(\\"+1-123-456-7890\\") \\"(123) 456-7890\\" >>> normalize_phone_number(\\"+1 (123) 456-7890\\") \\"(123) 456-7890\\" >>> normalize_phone_number(\\"+1.123.456.7890\\") \\"(123) 456-7890\\" >>> normalize_phone_number(\\"+1 123 456 7890\\") \\"(123) 456-7890\\"","solution":"import re def normalize_phone_number(phone_number: str) -> str: Normalizes phone numbers into the (XXX) XXX-XXXX format. # Remove all non-digit characters digits = re.sub(r'D', '', phone_number) # Extract the last 10 digits assuming they represent the US phone number normalized_digits = digits[-10:] # Format the digits into the (XXX) XXX-XXXX format normalized_phone_number = f\\"({normalized_digits[:3]}) {normalized_digits[3:6]}-{normalized_digits[6:]}\\" return normalized_phone_number"},{"question":"from typing import List, Tuple def total_volume(dimensions: List[Tuple[int, int, int]]) -> int: Returns the total volume of all toys given their dimensions. Parameters: dimensions (List[Tuple[int, int, int]]): A list of dimensions where each tuple contains length, width, and height of a toy. Returns: int: The total volume of all toys. Examples: >>> total_volume([(2, 3, 4)]) 24 >>> total_volume([(2, 3, 4), (1, 2, 1)]) 26 >>> total_volume([]) 0 >>> total_volume([(10, 20, 30)]) 6000 >>> total_volume([(2, 2, 2), (1, 1, 1), (3, 3, 3)]) 36","solution":"from typing import List, Tuple def total_volume(dimensions: List[Tuple[int, int, int]]) -> int: Returns the total volume of all toys given their dimensions. Parameters: dimensions (List[Tuple[int, int, int]]): A list of dimensions where each tuple contains length, width, and height of a toy. Returns: int: The total volume of all toys. total = 0 for length, width, height in dimensions: total += length * width * height return total"},{"question":"def character_count(string: str) -> dict: Design a function that takes a string as an input and returns a dictionary where the keys are the characters in the string, and the values are the number of times each character appears in the string. The function should ignore spaces and be case-insensitive. >>> character_count(\\"a\\") == {'a': 1} >>> character_count(\\"aaa\\") == {'a': 3} >>> character_count(\\"a a a\\") == {'a': 3} >>> character_count(\\"aA\\") == {'a': 2} >>> character_count(\\"Hello World\\") == {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> character_count(\\"\\") == {} >>> character_count(\\"a1a1b2\\") == {'a': 2, '1': 2, 'b': 1, '2': 1} >>> character_count(\\"1!2@3#\\") == {'1': 1, '!': 1, '2': 1, '@': 1, '3': 1, '#': 1} pass","solution":"def character_count(string): Returns a dictionary with the count of each character in the string, ignoring spaces and case-insensitive. # Converting the string to lower case and removing spaces string = string.replace(\\" \\", \\"\\").lower() # Initializing an empty dictionary to hold the count of each character char_count = {} # Iterating over each character in the string for char in string: # If the character is already a key in the dictionary, increment its value by 1 if char in char_count: char_count[char] += 1 # Otherwise, add the character as a key to the dictionary and set its value to 1 else: char_count[char] = 1 return char_count"},{"question":"def has_zero_sum_subarray(arr: List[int]) -> bool: Determines if a continuous subarray sums to zero. :param arr: List[int], input array of integers :return: bool, True if there is a continuous subarray that sums to zero, False otherwise >>> has_zero_sum_subarray([1, 2, 3, 4, 5]) == False >>> has_zero_sum_subarray([0, 1, 2, 3, 4]) == True >>> has_zero_sum_subarray([4, 2, -3, 1, 6]) == True >>> has_zero_sum_subarray([0, 0, 0, 0]) == True >>> has_zero_sum_subarray([3, 4, -7, 1, 2, -6]) == True >>> has_zero_sum_subarray([5]) == False >>> has_zero_sum_subarray([0]) == True >>> has_zero_sum_subarray([1, -1]) == True >>> has_zero_sum_subarray([10**8, -10**8]) == True >>> has_zero_sum_subarray([1, 2, -2, 3, -3, 4]) == True","solution":"def has_zero_sum_subarray(arr): Checks if there is a continuous subarray that sums to zero in the given array. :param arr: List[int], input array of integers :return: bool, True if there is a continuous subarray that sums to zero, False otherwise sum_set = set() curr_sum = 0 for num in arr: curr_sum += num if curr_sum == 0 or curr_sum in sum_set: return True sum_set.add(curr_sum) return False"},{"question":"from typing import List def filter_primes(numbers: List[int]) -> List[int]: Takes in a list of integers and returns a new list containing only the prime numbers from the original list. Negative numbers and zero are not considered prime. >>> filter_primes([2, 3, 5, 7, 11]) [2, 3, 5, 7, 11] >>> filter_primes([4, 6, 8, 10, 12]) [] >>> filter_primes([29, 15, -7, 13, 6, 23, -2]) [29, 13, 23] >>> filter_primes([-2, -3, -5, -7]) [] >>> filter_primes([]) [] >>> large_input = list(range(100)) >>> filter_primes(large_input) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]","solution":"def is_prime(n): Check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False max_divisor = int(n ** 0.5) + 1 for d in range(3, max_divisor, 2): if n % d == 0: return False return True def filter_primes(numbers): Filters the list of numbers and returns a list of prime numbers. return [num for num in numbers if num > 0 and is_prime(num)]"},{"question":"def k_largest_unique_elements(lst: List[int], k: int) -> List[int]: Write a function that takes a list of integers and an integer \`k\` as inputs, and returns the \`k\` largest unique elements from the list in descending order. If the list contains fewer than \`k\` unique elements, return all the unique elements in descending order. Ensure the function can handle negative integers and large lists efficiently. >>> k_largest_unique_elements([3, 1, 5, 12, 2, 11, 5, 12, 11], 3) [12, 11, 5] >>> k_largest_unique_elements([4, 4, 4, 4, 4], 2) [4] >>> k_largest_unique_elements([3, 1, 2, 4], 4) [4, 3, 2, 1] >>> k_largest_unique_elements([7, 2, 5, 3, 5, 3, 1], 5) [7, 5, 3, 2, 1] >>> k_largest_unique_elements([-10, -3, -7, -1, -4], 2) [-1, -3] >>> k_largest_unique_elements([-5, 3, -1, 7, -3, 3, 7], 4) [7, 3, -1, -3]","solution":"def k_largest_unique_elements(lst, k): Returns the k largest unique elements from the list in descending order. If the list contains fewer than k unique elements, return all the unique elements in descending order. unique_elements = list(set(lst)) unique_elements.sort(reverse=True) return unique_elements[:k]"},{"question":"from typing import List, Tuple import pytz from datetime import datetime import logging def convert_and_sort_dates(date_tuples: List[Tuple[str, str]]) -> List[Tuple[str, str]]: Sorts a list of tuples by the date in descending order and converts each date to the 'US/Eastern' timezone. Parameters: date_tuples (List[Tuple[str, str]]): List of tuples with a date string and timezone string Returns: List[Tuple[str, str]]: Sorted and converted dates maintaining the original tuple structure >>> convert_and_sort_dates([('2023-10-01', 'Europe/London'), ('2022-12-31', 'Australia/Sydney')]) [('2023-09-30', 'US/Eastern'), ('2022-12-30', 'US/Eastern')] >>> convert_and_sort_dates([('2023-10-01', 'Invalid/Timezone'), ('2022-12-32', 'Australia/Sydney')]) []","solution":"import pytz from datetime import datetime import logging def convert_and_sort_dates(date_tuples): Sorts a list of tuples by the date in descending order and converts each date to the 'US/Eastern' timezone. Parameters: date_tuples (list of tuples): List of tuples with a date string and timezone string Returns: List of tuples: Sorted and converted dates maintaining the original tuple structure eastern_tz = pytz.timezone('US/Eastern') converted_dates = [] for date_str, tz_str in date_tuples: try: # Localize the date with given timezone local_tz = pytz.timezone(tz_str) local_date = local_tz.localize(datetime.strptime(date_str, '%Y-%m-%d')) # Convert to US/Eastern timezone eastern_date = local_date.astimezone(eastern_tz) converted_dates.append((eastern_date.strftime('%Y-%m-%d'), 'US/Eastern')) except (pytz.UnknownTimeZoneError, ValueError) as e: logging.error(f\\"Error processing {date_str} in timezone {tz_str}: {e}\\") # Sort dates in descending order converted_dates.sort(key=lambda x: datetime.strptime(x[0], '%Y-%m-%d'), reverse=True) return converted_dates"},{"question":"class StockMarket: def __init__(self, stocks): Initialize stock market with available stocks. :param stocks: Dictionary with stock information. E.g. {'AAPL': {'price': 150, 'available_shares': 100}} self.stocks = stocks def update_price(self, stock_symbol, new_price): Update the price of a specific stock. :param stock_symbol: Stock ticker symbol (str) :param new_price: New price of the stock (float) if stock_symbol in self.stocks: self.stocks[stock_symbol]['price'] = new_price class User: def __init__(self, name, balance): Initialize user with name and balance. :param name: Name of the user (str) :param balance: Initial balance of the user (float) self.name = name self.balance = balance self.portfolio = {} def buy(self, stock_market, stock_symbol, shares): Buy shares of a specific stock. :param stock_market: StockMarket instance :param stock_symbol: Stock ticker symbol (str) :param shares: Number of shares to buy (int) pass def sell(self, stock_market, stock_symbol, shares): Sell shares of a specific stock. :param stock_market: StockMarket instance :param stock_symbol: Stock ticker symbol (str) :param shares: Number of shares to sell (int) pass def display_portfolio(self): Display current portfolio of the user including the cash balance. pass import pytest def test_user_buy_sell_actions(): stock_market = StockMarket({'AAPL': {'price': 150, 'available_shares': 100}, 'GOOGL': {'price': 2800, 'available_shares': 50}}) user = User(name='John Doe', balance=10000) # Test buying shares user.buy(stock_market, 'AAPL', 10) assert user.balance == 8500 assert user.portfolio == {'AAPL': 10} assert stock_market.stocks['AAPL']['available_shares'] == 90 # Test selling shares user.sell(stock_market, 'AAPL', 5) assert user.balance == 9250 assert user.portfolio == {'AAPL': 5} assert stock_market.stocks['AAPL']['available_shares'] == 95 def test_insufficient_balance(): stock_market = StockMarket({'AAPL': {'price': 150, 'available_shares': 100}}) user = User(name='John Doe', balance=100) with pytest.raises(ValueError, match='Insufficient balance to buy shares'): user.buy(stock_market, 'AAPL', 10) def test_insufficient_shares_in_market(): stock_market = StockMarket({'AAPL': {'price': 150, 'available_shares': 5}}) user = User(name='John Doe', balance=10000) with pytest.raises(ValueError, match='Not enough shares available in the market'): user.buy(stock_market, 'AAPL', 10) def test_insufficient_shares_in_portfolio(): stock_market = StockMarket({'AAPL': {'price': 150, 'available_shares': 100}}) user = User(name='John Doe', balance=10000) user.buy(stock_market, 'AAPL', 10) with pytest.raises(ValueError, match='Not enough shares in the portfolio to sell'): user.sell(stock_market, 'AAPL', 20) def test_update_prices(): stock_market = StockMarket({'AAPL': {'price': 150, 'available_shares': 100}}) stock_market.update_price('AAPL', 200) assert stock_market.stocks['AAPL']['price'] == 200 def test_display_portfolio(capsys): stock_market = StockMarket({'AAPL': {'price': 150, 'available_shares': 100}}) user = User(name='John Doe', balance=10000) user.buy(stock_market, 'AAPL', 10) user.display_portfolio() captured = capsys.readouterr() assert captured.out == \\"John Doe's Portfolio:nAAPL: 10 sharesnCash balance: 8500.00n\\"","solution":"class StockMarket: def __init__(self, stocks): Initialize stock market with available stocks. :param stocks: Dictionary with stock information. E.g. {'AAPL': {'price': 150, 'available_shares': 100}} self.stocks = stocks def update_price(self, stock_symbol, new_price): Update the price of a specific stock. :param stock_symbol: Stock ticker symbol (str) :param new_price: New price of the stock (float) if stock_symbol in self.stocks: self.stocks[stock_symbol]['price'] = new_price class User: def __init__(self, name, balance): Initialize user with name and balance. :param name: Name of the user (str) :param balance: Initial balance of the user (float) self.name = name self.balance = balance self.portfolio = {} def buy(self, stock_market, stock_symbol, shares): Buy shares of a specific stock. :param stock_market: StockMarket instance :param stock_symbol: Stock ticker symbol (str) :param shares: Number of shares to buy (int) if stock_symbol not in stock_market.stocks: raise ValueError(\\"Stock not available in the market\\") stock = stock_market.stocks[stock_symbol] if shares > stock['available_shares']: raise ValueError(\\"Not enough shares available in the market\\") total_cost = stock['price'] * shares if total_cost > self.balance: raise ValueError(\\"Insufficient balance to buy shares\\") self.balance -= total_cost stock_market.stocks[stock_symbol]['available_shares'] -= shares if stock_symbol in self.portfolio: self.portfolio[stock_symbol] += shares else: self.portfolio[stock_symbol] = shares def sell(self, stock_market, stock_symbol, shares): Sell shares of a specific stock. :param stock_market: StockMarket instance :param stock_symbol: Stock ticker symbol (str) :param shares: Number of shares to sell (int) if stock_symbol not in self.portfolio or self.portfolio[stock_symbol] < shares: raise ValueError(\\"Not enough shares in the portfolio to sell\\") stock = stock_market.stocks[stock_symbol] total_gain = stock['price'] * shares self.balance += total_gain stock_market.stocks[stock_symbol]['available_shares'] += shares self.portfolio[stock_symbol] -= shares if self.portfolio[stock_symbol] == 0: del self.portfolio[stock_symbol] def display_portfolio(self): Display current portfolio of the user including the cash balance. print(f\\"{self.name}'s Portfolio:\\") for stock_symbol, shares in self.portfolio.items(): print(f\\"{stock_symbol}: {shares} shares\\") print(f\\"Cash balance: {self.balance:.2f}\\")"},{"question":"def is_palindrome_recursive(s: str) -> bool: Determines if a given string is a valid palindrome, ignoring non-alphanumeric characters and case differences. This function uses recursion and has O(n) space complexity. >>> is_palindrome_recursive(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome_recursive(\\"race a car\\") False >>> is_palindrome_recursive(\\"\\") True >>> is_palindrome_recursive(\\"a\\") True >>> is_palindrome_recursive(\\"Z\\") True >>> is_palindrome_recursive(\\"1a2b2a1\\") True >>> is_palindrome_recursive(\\"1a2b3a1\\") False >>> is_palindrome_recursive(\\"Aa\\") True >>> is_palindrome_recursive(\\"aA\\") True >>> is_palindrome_recursive(\\"!@#%^&*()_+\\") True >>> is_palindrome_recursive(\\"A Santa at NASA\\") True >>> is_palindrome_recursive(\\"No lemon, no melon\\") True","solution":"def is_palindrome_recursive(s): Determines if a given string is a valid palindrome, ignoring non-alphanumeric characters and case differences. This function uses recursion and has O(n) space complexity. def helper(left, right): while left < right and not s[left].isalnum(): left += 1 while left < right and not s[right].isalnum(): right -= 1 if left >= right: return True if s[left].lower() != s[right].lower(): return False return helper(left + 1, right - 1) return helper(0, len(s) - 1)"},{"question":"def is_palindrome(input_str): Determines if an input string is a palindrome, ignoring non-alphanumeric characters and treating uppercase and lowercase letters as equivalent. Raises a ValueError if the input is not a string or is empty. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"No 'x' in Nixon\\") True >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"world\\") False >>> is_palindrome(\\"12345\\") False >>> is_palindrome(\\"\\") ValueError: Input must be a non-empty string >>> is_palindrome(12345) ValueError: Input must be a non-empty string >>> is_palindrome(None) ValueError: Input must be a non-empty string >>> is_palindrome([]) ValueError: Input must be a non-empty string >>> is_palindrome(\\"Madam, I'm Adam\\") True >>> is_palindrome(\\"Able was I, I saw elba\\") True >>> is_palindrome(\\"#@@!!&^!!@@#\\") True >>> is_palindrome(\\"Was it a car or a cat I saw?\\") True","solution":"def is_palindrome(input_str): Checks if the input string is a palindrome, ignoring non-alphanumeric characters and treating uppercase and lowercase letters as equivalent. if not isinstance(input_str, str) or not input_str: raise ValueError('Input must be a non-empty string') filtered_str = ''.join(char.lower() for char in input_str if char.isalnum()) return filtered_str == filtered_str[::-1]"},{"question":"def calculate_average_scores(students: list) -> list: Calculates the average score for each student and returns a new list of dictionaries with their name and average score. If a student has no scores, the average score is None. Args: - students: List of dictionaries, where each dictionary contains 'name' (str), 'age' (int), and 'scores' (list of int). Returns: - List of dictionaries, where each dictionary contains 'name' (str) and 'average_score' (float or None). def test_calculate_average_scores(): students = [ {\\"name\\": \\"Alice\\", \\"age\\": 20, \\"scores\\": [90, 85, 88]}, {\\"name\\": \\"Bob\\", \\"age\\": 21, \\"scores\\": [72, 75, 68]}, {\\"name\\": \\"Charlie\\", \\"age\\": 19, \\"scores\\": []}, ] expected = [ {\\"name\\": \\"Alice\\", \\"average_score\\": 87.67}, {\\"name\\": \\"Bob\\", \\"average_score\\": 71.67}, {\\"name\\": \\"Charlie\\", \\"average_score\\": None}, ] assert calculate_average_scores(students) == expected def test_calculate_average_scores_single_student_with_scores(): students = [{\\"name\\": \\"David\\", \\"age\\": 22, \\"scores\\": [60, 70, 80]}] expected = [{\\"name\\": \\"David\\", \\"average_score\\": 70.0}] assert calculate_average_scores(students) == expected def test_calculate_average_scores_single_student_no_scores(): students = [{\\"name\\": \\"Eve\\", \\"age\\": 23, \\"scores\\": []}] expected = [{\\"name\\": \\"Eve\\", \\"average_score\\": None}] assert calculate_average_scores(students) == expected def test_calculate_average_scores_multiple_students_mixed_scores(): students = [ {\\"name\\": \\"Fred\\", \\"age\\": 20, \\"scores\\": [88, 92]}, {\\"name\\": \\"George\\", \\"age\\": 21, \\"scores\\": [100]}, {\\"name\\": \\"Hank\\", \\"age\\": 22, \\"scores\\": []}, ] expected = [ {\\"name\\": \\"Fred\\", \\"average_score\\": 90.0}, {\\"name\\": \\"George\\", \\"average_score\\": 100.0}, {\\"name\\": \\"Hank\\", \\"average_score\\": None}, ] assert calculate_average_scores(students) == expected def test_calculate_average_scores_empty_input(): students = [] expected = [] assert calculate_average_scores(students) == expected","solution":"def calculate_average_scores(students: list) -> list: Calculates the average score for each student and returns a new list of dictionaries with their name and average score. If a student has no scores, the average score is None. Args: - students: List of dictionaries, where each dictionary contains 'name' (str), 'age' (int), and 'scores' (list of int). Returns: - List of dictionaries, where each dictionary contains 'name' (str) and 'average_score' (float or None). result = [] for student in students: name = student['name'] scores = student['scores'] if scores: avg_score = round(sum(scores) / len(scores), 2) else: avg_score = None result.append({\\"name\\": name, \\"average_score\\": avg_score}) return result"},{"question":"from typing import List, Optional def find_non_repeating_element(arr: List[int]) -> Optional[int]: Write a function find_non_repeating_element that takes a list of integers as input and returns the first non-repeating element from the list. If there are no non-repeating elements, return None. The function should have a linear time complexity. >>> find_non_repeating_element([4, 5, 4, 3, 5, 6, 3]) 6 >>> find_non_repeating_element([1, 2, 2, 1, 3, 4, 3, 4, 5]) 5 >>> find_non_repeating_element([1, 1, 1, 1]) None","solution":"from typing import List, Optional def find_non_repeating_element(arr: List[int]) -> Optional[int]: Returns the first non-repeating element from the list. If there are no non-repeating elements, returns None. count = {} # First pass to count occurrences of each element for num in arr: if num in count: count[num] += 1 else: count[num] = 1 # Second pass to find the first element with a count of 1 for num in arr: if count[num] == 1: return num return None"},{"question":"def is_palindrome(s: str) -> bool: Helper function to check if a string is a palindrome. length = len(s) for i in range(length // 2): if s[i] != s[length - 1 - i]: return False return True def filter_palindromes(strings: List[str]) -> List[str]: Returns a list containing only the palindromes from the input list of strings. >>> filter_palindromes([\\"madam\\", \\"racecar\\", \\"level\\"]) [\\"madam\\", \\"racecar\\", \\"level\\"] >>> filter_palindromes([\\"hello\\", \\"radar\\", \\"world\\", \\"deified\\"]) [\\"radar\\", \\"deified\\"] >>> filter_palindromes([\\"apple\\", \\"banana\\", \\"carrot\\"]) [] >>> filter_palindromes([]) [] >>> filter_palindromes([\\"a\\", \\"b\\", \\"c\\"]) [\\"a\\", \\"b\\", \\"c\\"]","solution":"def is_palindrome(s): Helper function to check if a string is a palindrome. length = len(s) for i in range(length // 2): if s[i] != s[length - 1 - i]: return False return True def filter_palindromes(strings): Returns a list containing only the palindromes from the input list of strings. palindromes = [] for string in strings: if is_palindrome(string): palindromes.append(string) return palindromes"},{"question":"from typing import List from collections import Counter def can_form_palindrome(s: str) -> str: Given a string, determine if it can be rearranged to form a palindrome. If possible, return one such palindrome. If not, return an empty string. The string contains only lowercase alphabets. >>> can_form_palindrome(\\"racecar\\") 'racecar' >>> can_form_palindrome(\\"aabb\\") 'abba' >>> can_form_palindrome(\\"abc\\") '' >>> can_form_palindrome(\\"aa\\") 'aa'","solution":"from collections import Counter def can_form_palindrome(s): Returns one possible palindrome that can be formed using the characters in the string s. If it is not possible to form a palindrome, returns an empty string. # Count the frequency of each character in the string char_count = Counter(s) # Count the number of characters with an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # Palindrome can be formed if at most one character has an odd frequency if odd_count > 1: return \\"\\" # Form the first half and the middle character (if any) of the palindrome first_half = [] middle_char = \\"\\" for char, count in char_count.items(): if count % 2 != 0: middle_char = char first_half.append(char * (count // 2)) # Join the first half and its reverse to form the palindrome first_half = \\"\\".join(first_half) return first_half + middle_char + first_half[::-1]"},{"question":"import math from typing import List def is_prime(n: int) -> bool: Checks if a number n is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes_greater_than_10(numbers: List[int]) -> List[int]: Returns a list containing only the integers from the input list that are both prime and greater than 10. >>> filter_primes_greater_than_10([2, 17, 4, 19, 23, 6, 20]) [17, 19, 23] >>> filter_primes_greater_than_10([11, 13, 15, 17, 18, 19]) [11, 13, 17, 19] >>> filter_primes_greater_than_10([29, 31, 33]) [29, 31] >>> filter_primes_greater_than_10([10, 20, 30]) [] >>> filter_primes_greater_than_10([]) [] >>> filter_primes_greater_than_10([5, 3, 2]) [] >>> filter_primes_greater_than_10([11, 22, 33, 44, 55]) [11]","solution":"import math def is_prime(n): Checks if a number n is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes_greater_than_10(numbers): Returns a list containing only the integers from the input list that are both prime and greater than 10. return [num for num in numbers if num > 10 and is_prime(num)]"},{"question":"class NegativeNumberError(Exception): Custom exception raised when a list contains negative numbers. pass def is_prime(number: int) -> bool: Helper function to check if a number is prime. >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(1) False pass def filter_primes(numbers: List[int]) -> List[int]: Returns a list of prime numbers from the given list. Raises NegativeNumberError if any negative number is present in the list. >>> filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> filter_primes([11, 13, 17, 19, 23, 29]) [11, 13, 17, 19, 23, 29] >>> filter_primes([2, -3, 4, 5]) Traceback (most recent call last): ... NegativeNumberError: The list contains negative numbers. pass","solution":"class NegativeNumberError(Exception): Custom exception raised when a list contains negative numbers. pass def is_prime(number): Helper function to check if a number is prime. if number < 2: return False for i in range(2, int(number ** 0.5) + 1): if number % i == 0: return False return True def filter_primes(numbers): Returns a list of prime numbers from the given list. Raises NegativeNumberError if any negative number is present in the list. if any(n < 0 for n in numbers): raise NegativeNumberError(\\"The list contains negative numbers.\\") primes = [n for n in numbers if is_prime(n)] return primes"},{"question":"def evaluate_postfix(expression: str) -> int: Evaluates a postfix expression (Reverse Polish Notation) and returns its result. Args: expression (str): A string containing the postfix expression with single-digit integers and operators, separated by spaces. Returns: int: Result of the postfix expression. >>> evaluate_postfix(\\"5 3 +\\") 8 >>> evaluate_postfix(\\"5 3 -\\") 2 >>> evaluate_postfix(\\"5 3 *\\") 15 >>> evaluate_postfix(\\"8 2 /\\") 4 >>> evaluate_postfix(\\"5 3 + 8 2 / *\\") 32 >>> evaluate_postfix(\\"2 3 * 5 4 * +\\") 26 >>> evaluate_postfix(\\"3 4 + 2 * 7 /\\") 2","solution":"def evaluate_postfix(expression): Evaluates a postfix expression (Reverse Polish Notation) and returns its result. Args: expression (str): A string containing the postfix expression with single-digit integers and operators, separated by spaces. Returns: int: Result of the postfix expression. stack = [] for token in expression.split(): if token.isdigit(): # If the token is an operand stack.append(int(token)) else: # If the token is an operator operand2 = stack.pop() operand1 = stack.pop() if token == '+': stack.append(operand1 + operand2) elif token == '-': stack.append(operand1 - operand2) elif token == '*': stack.append(operand1 * operand2) elif token == '/': stack.append(operand1 // operand2) # Use floor division for integer division return stack[0]"},{"question":"class ContactManager: A small contact management system to store and manage contacts. Each contact has a name and a phone number. This system supports adding, deleting, searching contacts, and displaying all contacts sorted alphabetically by their names. Example usage: cm = ContactManager() cm.AddContact(\\"John Doe\\", \\"555-1234\\") cm.AddContact(\\"Jane Doe\\", \\"555-5678\\") print(cm.SearchContact(\\"John Doe\\")) # Output: \\"555-1234\\" print(cm.SearchContact(\\"Jane Doe\\")) # Output: \\"555-5678\\" cm.DeleteContact(\\"John Doe\\") print(cm.SearchContact(\\"John Doe\\")) # Output: \\"Not found\\" cm.AddContact(\\"Alice\\", \\"111-2222\\") cm.AddContact(\\"Bob\\", \\"333-4444\\") cm.AddContact(\\"Charlie\\", \\"555-6666\\") print(cm.DisplayContacts()) # Output: [(\\"Alice\\", \\"111-2222\\"), (\\"Bob\\", \\"333-4444\\"), (\\"Charlie\\", \\"555-6666\\")] cm.AddContact(\\"Bob\\", \\"777-8888\\") print(cm.DisplayContacts()) # Output: [(\\"Alice\\", \\"111-2222\\"), (\\"Bob\\", \\"777-8888\\"), (\\"Charlie\\", \\"555-6666\\")] cm.DeleteContact(\\"Alice\\") print(cm.DisplayContacts()) # Output: [(\\"Bob\\", \\"777-8888\\"), (\\"Charlie\\", \\"555-6666\\")] def __init__(self): # Initializes the contact manager pass def AddContact(self, name: str, phone: str) -> None: # Adds or updates a contact pass def DeleteContact(self, name: str) -> None: # Deletes a contact pass def SearchContact(self, name: str) -> str: # Searches and returns the phone number if found pass def DisplayContacts(self) -> list: # Returns the list of all contacts sorted alphabetically by name pass import pytest def test_add_and_search_contacts(): cm = ContactManager() cm.AddContact(\\"John Doe\\", \\"555-1234\\") cm.AddContact(\\"Jane Doe\\", \\"555-5678\\") assert cm.SearchContact(\\"John Doe\\") == \\"555-1234\\" assert cm.SearchContact(\\"Jane Doe\\") == \\"555-5678\\" assert cm.SearchContact(\\"Jacob Doe\\") == \\"Not found\\" def test_delete_contact(): cm = ContactManager() cm.AddContact(\\"John Doe\\", \\"555-1234\\") cm.DeleteContact(\\"John Doe\\") assert cm.SearchContact(\\"John Doe\\") == \\"Not found\\" def test_display_contacts(): cm = ContactManager() cm.AddContact(\\"Alice\\", \\"111-2222\\") cm.AddContact(\\"Bob\\", \\"333-4444\\") cm.AddContact(\\"Charlie\\", \\"555-6666\\") assert cm.DisplayContacts() == [(\\"Alice\\", \\"111-2222\\"), (\\"Bob\\", \\"333-4444\\"), (\\"Charlie\\", \\"555-6666\\")] cm.AddContact(\\"Bob\\", \\"777-8888\\") assert cm.DisplayContacts() == [(\\"Alice\\", \\"111-2222\\"), (\\"Bob\\", \\"777-8888\\"), (\\"Charlie\\", \\"555-6666\\")] cm.DeleteContact(\\"Alice\\") assert cm.DisplayContacts() == [(\\"Bob\\", \\"777-8888\\"), (\\"Charlie\\", \\"555-6666\\")] def test_add_contact_updates_phone_number(): cm = ContactManager() cm.AddContact(\\"John Doe\\", \\"555-1234\\") cm.AddContact(\\"John Doe\\", \\"555-5678\\") assert cm.SearchContact(\\"John Doe\\") == \\"555-5678\\"","solution":"class ContactManager: def __init__(self): # Initializes the contact manager self.contacts = {} def AddContact(self, name: str, phone: str) -> None: # Adds or updates a contact self.contacts[name] = phone def DeleteContact(self, name: str) -> None: # Deletes a contact if name in self.contacts: del self.contacts[name] def SearchContact(self, name: str) -> str: # Searches and returns the phone number if found return self.contacts.get(name, \\"Not found\\") def DisplayContacts(self) -> list: # Returns the list of all contacts sorted alphabetically by name return sorted(self.contacts.items(), key=lambda x: x[0])"},{"question":"def common_elements(list1: List[int], list2: List[int]) -> List[int]: Returns a list of common elements between list1 and list2 without duplicates. The order of elements in the resulting list reflects their first appearance in input lists. >>> common_elements([1, 2, 3, 4, 4, 5], [4, 4, 5, 6, 7]) [4, 5] >>> common_elements([1, 2, 3], [4, 5, 6]) [] >>> common_elements([1, 2, 3], [1, 2, 3]) [1, 2, 3] >>> common_elements([], []) [] >>> common_elements([1, 2, 3], []) [] >>> common_elements([1, 1, 2, 2], [2, 2, 3, 3]) [2]","solution":"def common_elements(list1, list2): Returns a list of common elements between list1 and list2 without duplicates. The order of elements in the resulting list reflects their first appearance in input lists. set1 = set(list1) set2 = set(list2) common_set = set1 & set2 result = [] seen = set() for element in list1 + list2: if element in common_set and element not in seen: result.append(element) seen.add(element) return result"},{"question":"class Book: Class to represent a book in the library. Attributes: title (str): The title of the book. author (str): The author of the book. isbn (str): The ISBN of the book. checked_out (bool): Indicates if the book is checked out, initially set to False. def __init__(self, title: str, author: str, isbn: str): pass def checkout(self): Set the checked_out attribute to True. pass def return_book(self): Set the checked_out attribute to False. pass class Member: Class to represent a member of the library. Attributes: name (str): The name of the member. member_id (str): The unique ID of the member. books_checked_out (list): A list of books that the member has checked out. def __init__(self, name: str, member_id: str): pass def checkout_book(self, book: Book) -> bool: Checkout a book and add it to the books_checked_out collection. Args: book (Book): The book to be checked out. Returns: bool: True if the book was successfully checked out, False otherwise. pass def return_book(self, book: Book) -> bool: Return a book to the library and remove it from the books_checked_out collection. Args: book (Book): The book to be returned. Returns: bool: True if the book was successfully returned, False otherwise. pass class Library: Class to represent the library system. Attributes: books (list): A list of all books in the library. members (list): A list of all members in the library. def __init__(self): pass def add_book(self, book: Book): Add a book to the library's collection. pass def register_member(self, member: Member): Add a member to the list of members. pass def checkout_to_member(self, member_id: str, isbn: str) -> bool: Checkout a book to a member if possible. Args: member_id (str): The ID of the member. isbn (str): The ISBN of the book. Returns: bool: True if the book was successfully checked out to the member, False otherwise. pass # Unit tests def test_book(): book = Book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", \\"1234567890\\") assert book.title == \\"The Great Gatsby\\" assert book.author == \\"F. Scott Fitzgerald\\" assert book.isbn == \\"1234567890\\" assert not book.checked_out book.checkout() assert book.checked_out book.return_book() assert not book.checked_out def test_member(): book1 = Book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", \\"1234567890\\") book2 = Book(\\"1984\\", \\"George Orwell\\", \\"0987654321\\") member = Member(\\"John Doe\\", \\"001\\") assert member.name == \\"John Doe\\" assert member.member_id == \\"001\\" assert len(member.books_checked_out) == 0 assert member.checkout_book(book1) == True assert len(member.books_checked_out) == 1 assert member.books_checked_out[0].title == \\"The Great Gatsby\\" assert not member.checkout_book(book1) assert len(member.books_checked_out) == 1 assert member.return_book(book1) == True assert len(member.books_checked_out) == 0 assert not member.return_book(book1) def test_library(): book1 = Book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", \\"1234567890\\") book2 = Book(\\"1984\\", \\"George Orwell\\", \\"0987654321\\") member1 = Member(\\"John Doe\\", \\"001\\") member2 = Member(\\"Jane Doe\\", \\"002\\") library = Library() assert len(library.books) == 0 assert len(library.members) == 0 library.add_book(book1) library.add_book(book2) assert len(library.books) == 2 library.register_member(member1) library.register_member(member2) assert len(library.members) == 2 assert library.checkout_to_member(\\"001\\", \\"1234567890\\") == True assert library.checkout_to_member(\\"001\\", \\"1234567890\\") == False assert library.checkout_to_member(\\"002\\", \\"1234567890\\") == False assert library.checkout_to_member(\\"002\\", \\"0987654321\\") == True # Return books to library assert member1.return_book(book1) == True assert member2.return_book(book2) == True # Now checking out should work again assert library.checkout_to_member(\\"001\\", \\"1234567890\\") == True assert library.checkout_to_member(\\"002\\", \\"0987654321\\") == True","solution":"class Book: def __init__(self, title, author, isbn): self.title = title self.author = author self.isbn = isbn self.checked_out = False def checkout(self): self.checked_out = True def return_book(self): self.checked_out = False class Member: def __init__(self, name, member_id): self.name = name self.member_id = member_id self.books_checked_out = [] def checkout_book(self, book): if not book.checked_out: book.checkout() self.books_checked_out.append(book) return True return False def return_book(self, book): if book in self.books_checked_out: book.return_book() self.books_checked_out.remove(book) return True return False class Library: def __init__(self): self.books = [] self.members = [] def add_book(self, book): self.books.append(book) def register_member(self, member): self.members.append(member) def checkout_to_member(self, member_id, isbn): member = next((m for m in self.members if m.member_id == member_id), None) book = next((b for b in self.books if b.isbn == isbn), None) if member and book and not book.checked_out: return member.checkout_book(book) return False"},{"question":"from typing import List def extend_and_filter(numbers: List[int], start: int, end: int, divisor: int) -> List[int]: Extends the given list of numbers to include a new range from \`start\` to \`end\`, and then filters out numbers that are divisible by \`divisor\`. Parameters: - numbers: A list of integers. - start: The starting integer for the new range. - end: The ending integer for the new range. - divisor: The integer divisor used for filtering. Returns: A list of integers where numbers divisible by \`divisor\` are filtered out. Example: >>> extend_and_filter(list(range(10)), 10, 30, 3) [1, 2, 4, 5, 7, 8, 10, 11, 13, 14, 16, 17, 19, 20, 22, 23, 25, 26, 28, 29] >>> extend_and_filter([], 10, 30, 3) [10, 11, 13, 14, 16, 17, 19, 20, 22, 23, 25, 26, 28, 29] pass import pytest def test_extend_and_filter_basic(): assert extend_and_filter(list(range(10)), 10, 30, 3) == [ 1, 2, 4, 5, 7, 8, 10, 11, 13, 14, 16, 17, 19, 20, 22, 23, 25, 26, 28, 29 ] def test_extend_and_filter_empty_initial_list(): assert extend_and_filter([], 10, 30, 3) == [ 10, 11, 13, 14, 16, 17, 19, 20, 22, 23, 25, 26, 28, 29 ] def test_extend_and_filter_no_divisor_filtering(): assert extend_and_filter(list(range(10)), 10, 13, 1) == [] def test_extend_and_filter_no_elements_divisible(): assert extend_and_filter([1, 2, 4, 5], 10, 12, 7) == [1, 2, 4, 5, 10, 11] def test_extend_and_filter_divisor_as_zero(): with pytest.raises(ZeroDivisionError): extend_and_filter([1, 2, 4, 5], 10, 12, 0)","solution":"def extend_and_filter(numbers, start, end, divisor): Extends the given list of numbers range up to a new range from \`start\` to \`end\`, and then filters out numbers that are divisible by \`divisor\`. Parameters: - numbers: A list of numbers. - start: The starting integer for the new range. - end: The ending integer for the new range. - divisor: The integer divisor used for filtering. Returns: A list of numbers where numbers divisible by \`divisor\` are filtered out. extended_numbers = numbers + list(range(start, end)) filtered_numbers = [num for num in extended_numbers if num % divisor != 0] return filtered_numbers # Example usage my_numbers = list(range(10)) extended_and_filtered_numbers = extend_and_filter(my_numbers, 10, 30, 3) print(extended_and_filtered_numbers)"},{"question":"def check_palindrome(s: str) -> str: Determines if the string s is a palindrome and identifies the first character that does not match when checked from both ends. >>> check_palindrome(\\"madam\\") \\"Palindrome\\" >>> check_palindrome(\\"racecar\\") \\"Palindrome\\" >>> check_palindrome(\\"hello\\") ('h', 0) >>> check_palindrome(\\"abccba\\") \\"Palindrome\\" >>> check_palindrome(\\"abcbba\\") ('c', 2)","solution":"def check_palindrome(s): Determines if the string s is a palindrome and identifies the first character that does not match when checked from both ends. If the string is a palindrome, returns \\"Palindrome\\". If not, returns the first non-matching character and its index from the start of the string. left = 0 right = len(s) - 1 while left < right: if s[left] != s[right]: return (s[left], left) left += 1 right -= 1 return \\"Palindrome\\""},{"question":"from typing import List def lengthOfLIS(nums: List[int]) -> int: Returns the length of the longest increasing subsequence in the list of integers nums. >>> lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> lengthOfLIS([10]) 1 >>> lengthOfLIS([]) 0 >>> lengthOfLIS([1, 2, 3, 4, 5]) 5 >>> lengthOfLIS([5, 4, 3, 2, 1]) 1 >>> lengthOfLIS([3, 10, 2, 1, 20]) 3 >>> lengthOfLIS([3, 4, -1, 0, 6, 2, 3]) 4 >>> lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) 1","solution":"def lengthOfLIS(nums): Returns the length of the longest increasing subsequence in the list of integers nums. if not nums: return 0 dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Returns the indices of the two numbers from the list that add up to the target. Args: nums: A list of integers. target: An integer representing the target sum. Returns: A list containing the indices of the two numbers that add up to the target. Examples: >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([3, 3], 6) [0, 1]","solution":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Returns the indices of the two numbers from the list that add up to the target. num_map = {} for index, num in enumerate(nums): complement = target - num if complement in num_map: return [num_map[complement], index] num_map[num] = index return []"},{"question":"from typing import List def find_pair_with_sum(nums: List[int], k: int) -> bool: Determine if there are any two distinct indices i and j in the array such that nums[i] + nums[j] equals k. >>> find_pair_with_sum([1, 2, 3, 4], 5) True >>> find_pair_with_sum([1, 2, 3, 4], 8) False","solution":"from typing import List def find_pair_with_sum(nums: List[int], k: int) -> bool: Determines if there are any two distinct indices i and j in the array nums such that nums[i] + nums[j] equals k. seen = set() for num in nums: if k - num in seen: return True seen.add(num) return False"},{"question":"def factorial(n: int, memo: dict = None) -> int: Compute the factorial of a given non-negative integer n using recursion and memoization. >>> factorial(0) == 1 >>> factorial(1) == 1 >>> factorial(2) == 2 >>> factorial(3) == 6 >>> factorial(4) == 24 if memo is None: memo = {} # Add your optimized factorial function implementation here from solution import factorial def test_factorial_base_cases(): assert factorial(0) == 1 assert factorial(1) == 1 def test_factorial_small_numbers(): assert factorial(2) == 2 assert factorial(3) == 6 assert factorial(4) == 24 def test_factorial_medium_numbers(): assert factorial(5) == 120 assert factorial(6) == 720 def test_factorial_large_numbers(): assert factorial(10) == 3628800 assert factorial(20) == 2432902008176640000 # Test a larger number to check memoization efficacy assert factorial(100) == 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000","solution":"def factorial(n, memo={}): Returns the factorial of a non-negative integer n. if n in memo: return memo[n] if n == 0 or n == 1: return 1 else: memo[n] = n * factorial(n - 1, memo) return memo[n]"},{"question":"def sum_even_unique_numbers(lst: List[int]) -> int: Write a function that takes a list of integers and returns the sum of all unique even numbers. If there are no even numbers in the list, the function should return 0. >>> sum_even_unique_numbers([1, 2, 2, 3, 4]) 6 >>> sum_even_unique_numbers([1, 3, 5]) 0 >>> sum_even_unique_numbers([2, 2, 4, 4, 6]) 12 # Test cases print(sum_even_unique_numbers([1, 2, 2, 3, 4])) # Output: 6 (since unique evens are 2 and 4) print(sum_even_unique_numbers([1, 3, 5])) # Output: 0 (no even numbers) print(sum_even_unique_numbers([2, 2, 4, 4, 6])) # Output: 12 (since unique evens are 2, 4, and 6)","solution":"def sum_even_unique_numbers(lst): Returns the sum of all unique even numbers in the list. If there are no even numbers, returns 0. # Find the set of unique numbers unique_numbers = set(lst) # Filter out even numbers and sum them up sum_of_evens = sum(number for number in unique_numbers if number % 2 == 0) return sum_of_evens"},{"question":"from typing import Dict, List def get_unique_languages(people_languages: Dict[str, List[str]]) -> int: Calculates the total number of unique languages spoken across the list. >>> get_unique_languages({'Alice': ['English', 'Spanish'], 'Bob': ['French'], 'Charlie': ['Spanish', 'French'], 'David': ['English', 'Spanish', 'French']}) 3 def get_language_speakers(people_languages: Dict[str, List[str]]) -> Dict[str, int]: Determine the number of people speaking each language. >>> get_language_speakers({'Alice': ['English', 'Spanish'], 'Bob': ['French'], 'Charlie': ['Spanish', 'French'], 'David': ['English', 'Spanish', 'French']}) {'English': 2, 'Spanish': 3, 'French': 3} def languages_spoken_by_at_least_n_people(people_languages: Dict[str, List[str]], n: int) -> List[str]: Identify all languages spoken by at least a specified number of people. >>> languages_spoken_by_at_least_n_people({'Alice': ['English', 'Spanish'], 'Bob': ['French'], 'Charlie': ['Spanish', 'French'], 'David': ['English', 'Spanish', 'French']}, 3) ['Spanish', 'French'] def find_other_people_with_same_languages(people_languages: Dict[str, List[str]]) -> Dict[str, List[str]]: For each person, find and list other people who speak the same set of languages. >>> find_other_people_with_same_languages({'Alice': ['English', 'Spanish'], 'Bob': ['English', 'Spanish'], 'Charlie': ['Spanish', 'French'], 'David': ['English', 'Spanish', 'French']}) {'Alice': ['Bob'], 'Bob': ['Alice'], 'Charlie': [], 'David': []} >>> find_other_people_with_same_languages({'Alice': ['English', 'Spanish'], 'Bob': ['French'], 'Charlie': ['Spanish', 'French'], 'David': ['English', 'Spanish', 'French']}) {'Alice': [], 'Bob': [], 'Charlie': [], 'David': []}","solution":"def get_unique_languages(people_languages): Calculates the total number of unique languages spoken across the list. unique_languages = set() for languages in people_languages.values(): for language in languages: unique_languages.add(language) return len(unique_languages) def get_language_speakers(people_languages): Determine the number of people speaking each language. language_speakers = {} for languages in people_languages.values(): for language in languages: if language in language_speakers: language_speakers[language] += 1 else: language_speakers[language] = 1 return language_speakers def languages_spoken_by_at_least_n_people(people_languages, n): Identify all languages spoken by at least a specified number of people. language_speakers = get_language_speakers(people_languages) result = [language for language, count in language_speakers.items() if count >= n] return result def find_other_people_with_same_languages(people_languages): For each person, find and list other people who speak the same set of languages. from collections import defaultdict language_sets = defaultdict(list) for person, languages in people_languages.items(): language_set = frozenset(languages) language_sets[language_set].append(person) result = {} for person, languages in people_languages.items(): language_set = frozenset(languages) result[person] = [p for p in language_sets[language_set] if p != person] return result"},{"question":"def can_form_palindrome(s: str) -> bool: Check if the string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"carrace\\") True >>> can_form_palindrome(\\"hello\\") False","solution":"def can_form_palindrome(s): Returns True if the string can be rearranged to form a palindrome, otherwise returns False. from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # Count the number of characters with odd frequency odd_count = sum(1 for count in freq.values() if count % 2 != 0) # A string can form a palindrome if it has at most one character with an odd frequency return odd_count <= 1"},{"question":"def is_prime(n): Check if a number is a prime number. pass def evaluate_sequence(num_list): Given a list of integers, the function should return a list of unique prime numbers that are greater than 10. If there are no such prime numbers, it should return the count of all even numbers that are multiples of 3. >>> evaluate_sequence([2, 3, 5, 7, 13, 19, 23]) == [13, 19, 23] >>> evaluate_sequence([6, 9, 12, 15, 18, 21]) == 3 >>> evaluate_sequence([4, 8, 10, 12, 14]) == 1 >>> evaluate_sequence([6, 13, 9, 12, 15, 19, 21, 22]) == [13, 19] >>> evaluate_sequence([4, 8, 10, 77]) == 0 pass","solution":"def is_prime(n): Check if a number is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def evaluate_sequence(num_list): Given a list of integers, the function returns a list of unique prime numbers that are greater than 10. If there are no such prime numbers, it returns the count of all even numbers that are multiples of 3. primes = [num for num in set(num_list) if num > 10 and is_prime(num)] if primes: return primes else: even_multiples_of_three_count = sum(1 for num in num_list if num % 6 == 0) return even_multiples_of_three_count"},{"question":"from datetime import datetime from typing import List, Dict def missedDeadlines(tasks: List[Dict[str, str]]) -> List[str]: Returns a list of task names for tasks that missed their deadlines. >>> missedDeadlines([ ... {'task_name': 'Project Report', 'deadline': '2023-09-10', 'completed': True}, ... {'task_name': 'Team Meeting', 'deadline': '2023-09-08', 'completed': False}, ... {'task_name': 'Code Review', 'deadline': '2023-09-07', 'completed': False}, ... {'task_name': 'Presentation', 'deadline': '2023-09-12', 'completed': True} ... ]) ['Team Meeting', 'Code Review'] >>> missedDeadlines([ ... {'task_name': 'Task1', 'deadline': '2023-09-10', 'completed': False}, ... {'task_name': 'Task2', 'deadline': '2023-09-08', 'completed': False} ... ]) ['Task1', 'Task2']","solution":"from datetime import datetime def missedDeadlines(tasks): Returns a list of task names for tasks that missed their deadlines. Arguments: tasks -- list of dictionaries each containing 'task_name', 'deadline' (str), and 'completed' (bool) Returns: A list of task_name for tasks that have not been completed by their deadlines. current_date = datetime.now().date() missed_tasks = [] for task in tasks: deadline = datetime.strptime(task['deadline'], '%Y-%m-%d').date() if not task['completed'] and deadline < current_date: missed_tasks.append(task['task_name']) return missed_tasks"},{"question":"import string def word_frequencies(words: List[str]) -> Dict[str, int]: Returns a dictionary with each unique word as the key and the number of times it appears in the list as the value, ignoring case and punctuation. >>> word_frequencies([\\"Hello\\", \\"world!\\", \\"HELLO\\", \\"world\\", \\"hello,\\", \\"WORLD!\\"]) {'hello': 3, 'world': 3} >>> word_frequencies([\\"Test.\\", \\"test!\\", \\"TEST,\\", \\"teSt:\\", \\"tEst;\\"]) {'test': 5} >>> word_frequencies([]) {} >>> word_frequencies([\\"hello!\\"]) {'hello': 1} >>> word_frequencies([\\"123\\", \\"word!\\", \\"456\\", \\"woRd,\\", \\"789\\", \\"WORD.\\"]) {'123': 1, 'word': 3, '456': 1, '789': 1}","solution":"import string def word_frequencies(words): Returns a dictionary with each unique word as the key and the number of times it appears in the list as the value, ignoring case and punctuation. frequencies = {} translator = str.maketrans('', '', string.punctuation) for word in words: # Normalize word to lowercase and remove punctuation clean_word = word.lower().translate(translator) if clean_word in frequencies: frequencies[clean_word] += 1 else: frequencies[clean_word] = 1 return frequencies"},{"question":"def calculate_results(scores): You are given a list of strings representing sports scores in the format \\"TeamA vs TeamB: ScoreA-ScoreB\\". Write a Python function that takes this list and returns a dictionary with team names as keys and a dictionary of their wins, losses, and draws as the values. >>> scores = [ ... \\"TeamA vs TeamB: 1-0\\", ... \\"TeamA vs TeamC: 2-2\\", ... \\"TeamB vs TeamC: 3-1\\" ... ] >>> calculate_results(scores) {'TeamA': {'wins': 1, 'losses': 0, 'draws': 1}, 'TeamB': {'wins': 1, 'losses': 1, 'draws': 0}, 'TeamC': {'wins': 0, 'losses': 1, 'draws': 1}} from solution import calculate_results def test_all_wins(): scores = [ \\"TeamA vs TeamB: 1-0\\", \\"TeamC vs TeamD: 2-1\\" ] expected = { \\"TeamA\\": {\\"wins\\": 1, \\"losses\\": 0, \\"draws\\": 0}, \\"TeamB\\": {\\"wins\\": 0, \\"losses\\": 1, \\"draws\\": 0}, \\"TeamC\\": {\\"wins\\": 1, \\"losses\\": 0, \\"draws\\": 0}, \\"TeamD\\": {\\"wins\\": 0, \\"losses\\": 1, \\"draws\\": 0} } assert calculate_results(scores) == expected def test_all_draws(): scores = [ \\"TeamA vs TeamB: 1-1\\", \\"TeamC vs TeamD: 2-2\\" ] expected = { \\"TeamA\\": {\\"wins\\": 0, \\"losses\\": 0, \\"draws\\": 1}, \\"TeamB\\": {\\"wins\\": 0, \\"losses\\": 0, \\"draws\\": 1}, \\"TeamC\\": {\\"wins\\": 0, \\"losses\\": 0, \\"draws\\": 1}, \\"TeamD\\": {\\"wins\\": 0, \\"losses\\": 0, \\"draws\\": 1} } assert calculate_results(scores) == expected def test_mixed_results(): scores = [ \\"TeamA vs TeamB: 1-0\\", \\"TeamA vs TeamC: 2-2\\", \\"TeamB vs TeamC: 3-1\\" ] expected = { \\"TeamA\\": {\\"wins\\": 1, \\"losses\\": 0, \\"draws\\": 1}, \\"TeamB\\": {\\"wins\\": 1, \\"losses\\": 1, \\"draws\\": 0}, \\"TeamC\\": {\\"wins\\": 0, \\"losses\\": 1, \\"draws\\": 1} } assert calculate_results(scores) == expected def test_empty_scores(): scores = [] expected = {} assert calculate_results(scores) == expected def test_multiple_matches_between_teams(): scores = [ \\"TeamA vs TeamB: 1-0\\", \\"TeamA vs TeamB: 0-2\\", \\"TeamA vs TeamB: 1-1\\" ] expected = { \\"TeamA\\": {\\"wins\\": 1, \\"losses\\": 1, \\"draws\\": 1}, \\"TeamB\\": {\\"wins\\": 1, \\"losses\\": 1, \\"draws\\": 1} } assert calculate_results(scores) == expected","solution":"def calculate_results(scores): results = {} for score in scores: teams_and_scores = score.split(\\":\\") teams = teams_and_scores[0].split(\\" vs \\") scores = list(map(int, teams_and_scores[1].split(\\"-\\"))) team_a, team_b = teams score_a, score_b = scores # Initialize the team results if they do not exist yet if team_a not in results: results[team_a] = {\\"wins\\": 0, \\"losses\\": 0, \\"draws\\": 0} if team_b not in results: results[team_b] = {\\"wins\\": 0, \\"losses\\": 0, \\"draws\\": 0} if score_a > score_b: results[team_a][\\"wins\\"] += 1 results[team_b][\\"losses\\"] += 1 elif score_a < score_b: results[team_a][\\"losses\\"] += 1 results[team_b][\\"wins\\"] += 1 else: results[team_a][\\"draws\\"] += 1 results[team_b][\\"draws\\"] += 1 return results"},{"question":"def reverse_words_in_list(str_list): Reverses each word in the list of strings, keeping the overall string order unchanged. Parameters: str_list (list of str): List of strings to be processed. Returns: list of str: List with each word reversed. >>> reverse_words_in_list([\\"這是\\", \\"一次編程\\", \\"測試\\"]) == [\\"是這\\", \\"程編次一\\", \\"試測\\"] >>> reverse_words_in_list([]) == [] >>> reverse_words_in_list([\\"測試\\"]) == [\\"試測\\"] >>> reverse_words_in_list([\\"測試\\", \\"測試\\", \\"測試\\"]) == [\\"試測\\", \\"試測\\", \\"試測\\"] >>> reverse_words_in_list([\\"a\\", \\"bb\\", \\"ccc\\"]) == [\\"a\\", \\"bb\\", \\"ccc\\"] >>> reverse_words_in_list([\\"hello!\\", \\"world?\\"]) == [\\"!olleh\\", \\"?dlrow\\"] >>> reverse_words_in_list([\\"123\\", \\"456\\"]) == [\\"321\\", \\"654\\"]","solution":"def reverse_words_in_list(str_list): Reverses each word in the list of strings, keeping the overall string order unchanged. Parameters: str_list (list of str): List of strings to be processed. Returns: list of str: List with each word reversed. def reverse_word(word): # Create a new reversed word manually reversed_word = \\"\\" for char in word: reversed_word = char + reversed_word return reversed_word return [reverse_word(word) for word in str_list]"},{"question":"def read_transactions(file_path): Read a file containing transaction data and return a dictionary where the keys are customer IDs and the values are lists of transaction amounts sorted in ascending order. >>> read_transactions('test_transactions.txt') { 'C001': [100.0, 150.0], 'C002': [50.0, 200.0], 'C003': [300.0] } def total_transaction_amounts(transactions): Compute the total transaction amount for each customer and return a dictionary with customer IDs as keys and total transaction amounts as values. >>> total_transaction_amounts({'C001': [100.0, 150.0], 'C002': [50.0, 200.0], 'C003': [300.0]}) { 'C001': 250.0, 'C002': 250.0, 'C003': 300.0 }","solution":"def read_transactions(file_path): transactions = {} try: with open(file_path, 'r') as file: for line in file: try: transaction_id, customer_id, transaction_amount, transaction_date = line.strip().split(',') transaction_amount = float(transaction_amount) if customer_id not in transactions: transactions[customer_id] = [] transactions[customer_id].append(transaction_amount) except ValueError: continue # Skip lines with incorrect format for customer_id in transactions: transactions[customer_id].sort() return transactions except IOError: raise Exception(\\"Error reading the file\\") def total_transaction_amounts(transactions): totals = {} for customer_id, amounts in transactions.items(): totals[customer_id] = sum(amounts) return totals"},{"question":"from typing import List def find_unique_number(nums: List[int]) -> int: Given a list of integers where every number appears exactly twice except for one number which appears only once, this function finds and returns the single number that appears only once. Implement the function with an optimal time complexity. >>> find_unique_number([2, 3, 2, 4, 4, 5, 3]) 5 >>> find_unique_number([1]) 1 >>> find_unique_number([-1, -2, -3, -1, -2]) -3 >>> find_unique_number([2, 3, 2, 3, 4]) 4 >>> find_unique_number(list(range(1, 10000)) * 2 + [9999]) 9999","solution":"def find_unique_number(nums): Given a list of integers where every number appears exactly twice except for one number which appears only once, this function finds and returns the single number that appears only once. unique_number = 0 for num in nums: unique_number ^= num return unique_number # Example usage nums = [2, 3, 2, 4, 4, 5, 3] print(find_unique_number(nums)) # Output should be 5"},{"question":"def analyze_student_marks(students_marks): Accepts a dictionary where keys are student names and values are lists of their marks. Returns a new dictionary with the same keys, where the values are tuples containing the average marks, the maximum marks, and the minimum marks for each student. Raises ValueError if any student's list of marks is empty. >>> analyze_student_marks({'Alice': [85, 90, 78], 'Bob': [92, 73, 66], 'Charlie': [89, 91, 94]}) {'Alice': (84.33, 90, 78), 'Bob': (77.0, 92, 66), 'Charlie': (91.33, 94, 89)} >>> analyze_student_marks({'Alice': [72, 85, 91, 89, 76], 'Bob': [95, 85, 91]}) {'Alice': (82.6, 91, 72), 'Bob': (90.33, 95, 85)} analyzed_marks = {} for student, marks in students_marks.items(): if not marks: raise ValueError(f\\"No marks available for student: {student}\\") average_marks = sum(marks) / len(marks) max_marks = max(marks) min_marks = min(marks) analyzed_marks[student] = (average_marks, max_marks, min_marks) return analyzed_marks # Example usage students_marks = { 'Alice': [85, 90, 78], 'Bob': [92, 73, 66], 'Charlie': [89, 91, 94], 'David': [] } print(analyze_student_marks(students_marks))","solution":"def analyze_student_marks(students_marks): Accepts a dictionary where keys are student names and values are lists of their marks. Returns a new dictionary with the same keys, where the values are tuples containing the average marks, the maximum marks, and the minimum marks for each student. Raises ValueError if any student's list of marks is empty. analyzed_marks = {} for student, marks in students_marks.items(): if not marks: raise ValueError(f\\"No marks available for student: {student}\\") average_marks = round(sum(marks) / len(marks), 2) max_marks = max(marks) min_marks = min(marks) analyzed_marks[student] = (average_marks, max_marks, min_marks) return analyzed_marks"},{"question":"def max_subarray_sum(arr: List[int]) -> int: Returns the maximum sum of any contiguous subarray within a given list of integers. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([3, -2, 5, -1, 6, -3, 2, 7, -2, 3]) 18 from solution import max_subarray_sum def test_empty_array(): assert max_subarray_sum([]) == 0 def test_single_element(): assert max_subarray_sum([1]) == 1 assert max_subarray_sum([-1]) == -1 def test_all_positive_numbers(): assert max_subarray_sum([1, 2, 3, 4, 5]) == 15 def test_all_negative_numbers(): assert max_subarray_sum([-1, -2, -3, -4, -5]) == -1 def test_mixed_numbers(): assert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 assert max_subarray_sum([3, -2, 5, -1, 6, -3, 2, 7, -2, 3]) == 18 def test_subarray_at_beginning(): assert max_subarray_sum([4, -1, 2, 1, -5, -2, -1]) == 6 def test_subarray_at_end(): assert max_subarray_sum([-2, -5, -1, 2, 3, 4, 5]) == 14","solution":"def max_subarray_sum(arr): Returns the maximum sum of any contiguous subarray within a given list of integers. if not arr: return 0 current_sum = arr[0] max_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def binary_tree_sum(node): Compute the sum of all the node values in a binary tree. Args: node (TreeNode): The root of the binary tree. Returns: int: The sum of all node values. Examples: >>> binary_tree_sum(TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5)))) 15 >>> binary_tree_sum(TreeNode(-10, TreeNode(20, None, TreeNode(-30)), TreeNode(10))) -10 >>> binary_tree_sum(None) 0 >>> binary_tree_sum(TreeNode(1)) 1 >>> binary_tree_sum(TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5, TreeNode(6))))) 21","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def binary_tree_sum(node): Returns the sum of all values in the binary tree rooted at \`node\`. An empty tree has a sum of 0. if node is None: return 0 # Recursively compute sum of left subtree, right subtree and root node return node.value + binary_tree_sum(node.left) + binary_tree_sum(node.right)"},{"question":"from typing import List, Dict def list_to_factorial_dict(lst: List[int]) -> Dict[int, int]: Design a function that takes a list of integers as input and returns a dictionary where each key is an integer from the list, and each value is the factorial of that integer. If the input list contains repeated integers, the dictionary should only contain unique keys. Example: >>> list_to_factorial_dict([3, 4, 5, 3]) {3: 6, 4: 24, 5: 120} >>> list_to_factorial_dict([1, 2, 3, 4]) {1: 1, 2: 2, 3: 6, 4: 24}","solution":"from math import factorial def list_to_factorial_dict(lst): Returns a dictionary where each key is a unique integer from the input list, and each value is the factorial of that integer. return {num: factorial(num) for num in set(lst)}"},{"question":"def longest_consecutive(nums: List[int]) -> int: Computes the length of the longest consecutive subsequence in an unsorted array of integers. :param nums: List of integers :return: Length of the longest consecutive subsequence >>> longest_consecutive([]) == 0 >>> longest_consecutive([1]) == 1 >>> longest_consecutive([10, 5, 3]) == 1 >>> longest_consecutive([100, 4, 200, 1, 3, 2]) == 4 >>> longest_consecutive([9, 1, 4, 7, 3, -1, 0, 5, 8, -1, 6]) == 7 >>> longest_consecutive([1, 2, 2, 3]) == 3 >>> longest_consecutive([-1, -2, -3, -4, 0, 1, 2, 3]) == 8 pass","solution":"def longest_consecutive(nums): Computes the length of the longest consecutive subsequence in an unsorted array of integers. :param nums: List of integers :return: Length of the longest consecutive subsequence if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: if num - 1 not in num_set: # start of a new sequence current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def most_frequent_char(s: str) -> str: Returns the most frequently occurring character in the string. If there is a tie, returns the alphabetical character that comes first. Ignores spaces and treats uppercase and lowercase versions of characters as the same. >>> most_frequent_char(\\"a\\") == 'a' >>> most_frequent_char(\\"AaBbCcAa\\") == 'a' >>> most_frequent_char(\\"abac\\") == 'a' >>> most_frequent_char(\\"a b c a b c a\\") == 'a' >>> most_frequent_char(\\"\\") is None >>> most_frequent_char(\\"bbbb\\") == 'b' >>> most_frequent_char(\\"test\\") == 't' >>> most_frequent_char(\\"A\\") == 'a'","solution":"def most_frequent_char(s): Returns the most frequently occurring character in the string. If there is a tie, returns the alphabetical character that comes first. Ignores spaces and treats uppercase and lowercase versions of characters as the same. from collections import Counter # Normalize the string: remove spaces and convert to lower case s = s.replace(' ', '').lower() if not s: return None # Count character frequencies char_counts = Counter(s) # Find the most frequent character (alphabetically first in case of tie) most_frequent = min(char_counts.items(), key=lambda item: (-item[1], item[0])) return most_frequent[0]"},{"question":"def categorize_students_by_grades(student_records): Categorizes students based on their grades. Parameters: student_records (list): A list of student records. Each record is a list containing the student's name, grade, and age. Returns: dict: A dictionary where the keys are grades and the values are lists of students' names in that grade. >>> categorize_students_by_grades([['Alice', 'A', 15], ['Bob', 'B', 16], ['Charlie', 'A', 15], ['David', 'C', 17], ['Eve', 'B', 16]]) {'A': ['Alice', 'Charlie'], 'B': ['Bob', 'Eve'], 'C': ['David']} >>> categorize_students_by_grades([]) {} >>> categorize_students_by_grades([['Alice', 'A', 15]]) {'A': ['Alice']} >>> categorize_students_by_grades([['Alice', 'A', 15], ['Bob', 'C', 16], ['Charlie', 'B', 15], ['David', 'B', 17], ['Eve', 'A', 16]]) {'A': ['Alice', 'Eve'], 'B': ['Charlie', 'David'], 'C': ['Bob']}","solution":"def categorize_students_by_grades(student_records): Categorizes students based on their grades. Parameters: student_records (list): A list of student records. Each record is a list containing the student's name, grade, and age. Returns: dict: A dictionary where the keys are grades and the values are lists of students' names in that grade. grade_categories = {} for record in student_records: name, grade, age = record if grade not in grade_categories: grade_categories[grade] = [] grade_categories[grade].append(name) return grade_categories"},{"question":"def largest_number(digits: List[int]) -> str: Returns the largest number possible by concatenating the list of digits. Parameters: digits (list): List of integers. Returns: str: The largest number possible by concatenating the given digits. >>> largest_number([3, 30, 34, 5, 9]) == \\"9534330\\" >>> largest_number([1, 1, 1, 1]) == \\"1111\\" >>> largest_number([0, 0, 0, 0]) == \\"0\\" >>> largest_number([12, 121]) == \\"12121\\" >>> largest_number([10, 2]) == \\"210\\" >>> largest_number([999, 99, 9, 0]) == \\"9999990\\" >>> largest_number([824, 938, 1399, 5607, 6973, 5703, 9609, 4398, 8247]) == \\"9609938824824769735703560743981399\\" pass","solution":"from functools import cmp_to_key def largest_number(digits): Returns the largest number possible by concatenating the list of digits. Parameters: digits (list): List of integers. Returns: str: The largest number possible by concatenating the given digits. def compare(x, y): return (y + x) > (x + y) # Convert integers to strings for comparison str_digits = list(map(str, digits)) # Sort with custom comparator str_digits.sort(key=cmp_to_key(lambda x, y: 1 if compare(x, y) else -1)) # Join the sorted array largest_num = ''.join(str_digits) # Handle the case where the result is multiple zeros if largest_num[0] == '0': return '0' return largest_num"},{"question":"from typing import List def canRearrange(arr: List[int]) -> bool: Determine if it is possible to rearrange the elements of the array such that no two adjacent elements have the same parity (evenness or oddness). >>> canRearrange([2, 3, 4, 7, 8]) True >>> canRearrange([1, 3, 5, 7]) False >>> canRearrange([1, 2, 3, 4, 5, 6]) True","solution":"from typing import List def canRearrange(arr: List[int]) -> bool: count_even = sum(1 for x in arr if x % 2 == 0) count_odd = len(arr) - count_even return abs(count_even - count_odd) <= 1"},{"question":"from typing import List def increment_by_index(int_list: List[int]) -> List[int]: Given a list of integers, returns a new list where each element is incremented by the index of that element. Parameters: int_list (list): List of integers. Returns: list: New list with incremented values. >>> increment_by_index([1, 2, 3]) [1, 3, 5] >>> increment_by_index([]) [] >>> increment_by_index([-1, -2, -3]) [-1, -1, -1] >>> increment_by_index([-1, 0, 1]) [-1, 1, 3] >>> increment_by_index([10]) [10] >>> increment_by_index([100, 200, 300]) [100, 201, 302]","solution":"def increment_by_index(int_list): Given a list of integers, returns a new list where each element is incremented by the index of that element. Parameters: int_list (list): List of integers. Returns: list: New list with incremented values. return [value + idx for idx, value in enumerate(int_list)]"},{"question":"class TemperatureConverter: def __init__(self): self._celsius = 0 self._fahrenheit = 32 self._kelvin = 273.15 def set_celsius(self, value): Sets the temperature in Celsius and updates Fahrenheit and Kelvin. if value < -273.15: raise ValueError(\\"Temperature cannot be below absolute zero (-273.15°C)\\") pass def get_celsius(self): Returns the temperature in Celsius. pass def set_fahrenheit(self, value): Sets the temperature in Fahrenheit and updates Celsius and Kelvin. if value < -459.67: raise ValueError(\\"Temperature cannot be below absolute zero (-459.67°F)\\") pass def get_fahrenheit(self): Returns the temperature in Fahrenheit. pass def set_kelvin(self, value): Sets the temperature in Kelvin and updates Celsius and Fahrenheit. if value < 0: raise ValueError(\\"Temperature cannot be below absolute zero (0K)\\") pass def get_kelvin(self): Returns the temperature in Kelvin. pass def display_temperatures(self): Returns a string with the temperature in Celsius, Fahrenheit, and Kelvin. pass # Test Cases import pytest def test_set_and_get_celsius(): converter = TemperatureConverter() converter.set_celsius(100) assert converter.get_celsius() == 100 assert converter.get_fahrenheit() == pytest.approx(212) assert converter.get_kelvin() == pytest.approx(373.15) def test_set_and_get_fahrenheit(): converter = TemperatureConverter() converter.set_fahrenheit(32) assert converter.get_celsius() == pytest.approx(0) assert converter.get_fahrenheit() == 32 assert converter.get_kelvin() == pytest.approx(273.15) def test_set_and_get_kelvin(): converter = TemperatureConverter() converter.set_kelvin(0) assert converter.get_celsius() == pytest.approx(-273.15) assert converter.get_fahrenheit() == pytest.approx(-459.67) assert converter.get_kelvin() == 0 def test_invalid_celsius(): converter = TemperatureConverter() with pytest.raises(ValueError): converter.set_celsius(-274) def test_invalid_fahrenheit(): converter = TemperatureConverter() with pytest.raises(ValueError): converter.set_fahrenheit(-460) def test_invalid_kelvin(): converter = TemperatureConverter() with pytest.raises(ValueError): converter.set_kelvin(-1) def test_display_temperatures(): converter = TemperatureConverter() converter.set_celsius(25) display = converter.display_temperatures() assert \\"Temperature in Celsius: 25.00 °C\\" in display assert \\"Temperature in Fahrenheit: 77.00 °F\\" in display assert \\"Temperature in Kelvin: 298.15 K\\" in display","solution":"class TemperatureConverter: def __init__(self): self._celsius = 0 self._fahrenheit = 32 self._kelvin = 273.15 def set_celsius(self, value): if value < -273.15: raise ValueError(\\"Temperature cannot be below absolute zero (-273.15°C)\\") self._celsius = value self._fahrenheit = (value * 9/5) + 32 self._kelvin = value + 273.15 def get_celsius(self): return self._celsius def set_fahrenheit(self, value): if value < -459.67: raise ValueError(\\"Temperature cannot be below absolute zero (-459.67°F)\\") self._fahrenheit = value self._celsius = (value - 32) * 5/9 self._kelvin = (value + 459.67) * 5/9 def get_fahrenheit(self): return self._fahrenheit def set_kelvin(self, value): if value < 0: raise ValueError(\\"Temperature cannot be below absolute zero (0K)\\") self._kelvin = value self._celsius = value - 273.15 self._fahrenheit = (value * 9/5) - 459.67 def get_kelvin(self): return self._kelvin def display_temperatures(self): return ( f'Temperature in Celsius: {self._celsius:.2f} °Cn' f'Temperature in Fahrenheit: {self._fahrenheit:.2f} °Fn' f'Temperature in Kelvin: {self._kelvin:.2f} K' )"},{"question":"def longest_common_subsequence(str1: str, str2: str) -> str: Returns the longest common subsequence (LCS) between two strings. If there are multiple LCS of the same length, return the one that appears first lexicographically. >>> longest_common_subsequence(\\"AGGTAB\\", \\"GXTXAYB\\") \\"GTAB\\" >>> longest_common_subsequence(\\"ABC\\", \\"DEF\\") \\"\\" >>> longest_common_subsequence(\\"ABCDEFG\\", \\"ABCDEFG\\") \\"ABCDEFG\\" >>> longest_common_subsequence(\\"ABC\\", \\"BAC\\") \\"AC\\" >>> longest_common_subsequence(\\"ABCD\\", \\"AEBDFD\\") \\"ABD\\" >>> longest_common_subsequence(\\"\\", \\"ABC\\") \\"\\" >>> longest_common_subsequence(\\"ABC\\", \\"\\") \\"\\" >>> longest_common_subsequence(\\"A\\", \\"A\\") \\"A\\" >>> longest_common_subsequence(\\"A\\", \\"B\\") \\"\\"","solution":"def longest_common_subsequence(str1, str2): Returns the longest common subsequence (LCS) between two strings. If there are multiple LCS of the same length, returns the one that appears first lexicographically. n, m = len(str1), len(str2) dp = [[\\"\\" for _ in range(m + 1)] for __ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + str1[i - 1] else: if len(dp[i - 1][j]) > len(dp[i][j - 1]): dp[i][j] = dp[i - 1][j] elif len(dp[i - 1][j]) < len(dp[i][j - 1]): dp[i][j] = dp[i][j - 1] else: # same length, pick the lexicographically smaller one dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) return dp[n][m]"},{"question":"from typing import List def transform_list(numbers: List[int]) -> List[int]: Takes a list of integers and returns a new list where each element is the square of the original list element if it is even, and the cube if it is odd. >>> transform_list([2, 4, 6]) [4, 16, 36] >>> transform_list([1, 3, 5]) [1, 27, 125] >>> transform_list([1, 2, 3, 4]) [1, 4, 27, 16] >>> transform_list([0, 1, -2, -3]) [0, 1, 4, -27] >>> transform_list([]) [] >>> transform_list([8]) [64] >>> transform_list([7]) [343] >>> transform_list([10**6, 10**6 + 1]) [10**12, (10**6+1)**3]","solution":"def transform_list(numbers): Takes a list of integers and returns a new list where: - each even number is squared - each odd number is cubed return [x**2 if x % 2 == 0 else x**3 for x in numbers]"},{"question":"from typing import List def is_prime(n: int) -> bool: Returns True if n is a prime number, False otherwise. >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(13) True def filter_primes(lst: List[int]) -> List[int]: Returns a new list containing only the prime numbers from the original list. >>> filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> filter_primes([2, 3, 5, 7, 11]) [2, 3, 5, 7, 11] >>> filter_primes([4, 6, 8, 10, 12]) [] >>> filter_primes([]) [] >>> filter_primes([7]) [7] >>> filter_primes([9]) []","solution":"def is_prime(n): Returns True if n is a prime number, False otherwise. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(lst): Returns a new list containing only the prime numbers from the original list. return [num for num in lst if is_prime(num)]"},{"question":"def longest_consecutive(nums: List[int]) -> int: Find the length of the longest consecutive elements sequence in an unsorted list of integers. >>> longest_consecutive([]) == 0 >>> longest_consecutive([5]) == 1 >>> longest_consecutive([1, 2]) == 2 >>> longest_consecutive([1, 3]) == 1 >>> longest_consecutive([100, 4, 200, 1, 3, 2]) == 4 >>> longest_consecutive([10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]) == 11 >>> longest_consecutive([9, 1, 4, 7, 3, 2, 6, 0, 5, 8]) == 10 >>> longest_consecutive([1, 2, 2, 3, 4, 4, 5]) == 5 >>> longest_consecutive([1000, 999, 1001, 1002, 998]) == 5","solution":"def longest_consecutive(nums): Returns the length of the longest consecutive elements sequence in an unsorted list. Parameters: nums (list): List of integers. Returns: int: Length of the longest consecutive sequence. if not nums: return 0 num_set = set(nums) longest_length = 0 for num in nums: if num - 1 not in num_set: # Starting point of a sequence current_length = 1 current_num = num while current_num + 1 in num_set: current_length += 1 current_num += 1 longest_length = max(longest_length, current_length) return longest_length"},{"question":"def compress_string(s: str) -> str: Compress the given string by transforming it into the form of substring and the number of its consecutive repetitions. If the compressed string is not shorter than the original, return the original string. >>> compress_string(\\"aaabbcc\\") 'a3b2c2' >>> compress_string(\\"abcd\\") 'abcd' >>> compress_string(\\"aabbccddd\\") 'a2b2c2d3' >>> compress_string(\\"\\") '' >>> compress_string(\\"a\\") 'a' >>> compress_string(\\"aaaaaa\\") 'a6' >>> compress_string(\\"ab\\") 'ab'","solution":"def compress_string(s): Compress the given string by transforming it into the form of substring and the number of its consecutive repetitions. If the compressed string is not shorter than the original, return the original string. if not s: return s compressed_string = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed_string.append(s[i - 1] + str(count)) count = 1 compressed_string.append(s[-1] + str(count)) compressed = ''.join(compressed_string) return compressed if len(compressed) < len(s) else s"},{"question":"def count_vowels(s: str, additional_vowels=None) -> int: Counts the number of vowels in a given string. The function is case-insensitive and can handle both English vowels ('a', 'e', 'i', 'o', 'u') and optional additional vowels provided by the user. Args: s (str): The string to count vowels in. additional_vowels (iterable, optional): Additional vowels to be considered. Defaults to None. Returns: int: The number of vowels in the string. Raises: TypeError: If the input is not a string or the additional_vowels is not an iterable. >>> count_vowels(\\"hello\\") 2 >>> count_vowels(\\"HELLO\\") 2 >>> count_vowels(\\"hällo\\", additional_vowels=['ä']) 2 >>> count_vowels(\\"\\") 0 >>> count_vowels(\\"bcdfg\\") 0","solution":"def count_vowels(s, additional_vowels=None): Counts the number of vowels in a given string. The function is case-insensitive and can handle both English vowels ('a', 'e', 'i', 'o', 'u') and optional additional vowels provided by the user. Args: s (str): The string to count vowels in. additional_vowels (iterable, optional): Additional vowels to be considered. Defaults to None. Returns: int: The number of vowels in the string. Raises: TypeError: If the input is not a string or the additional_vowels is not an iterable. if not isinstance(s, str): raise TypeError(\\"Input must be a string.\\") if additional_vowels is not None: if not hasattr(additional_vowels, \\"__iter__\\") or isinstance(additional_vowels, str): raise TypeError(\\"Additional vowels must be an iterable, but not a string.\\") vowels = set('aeiouAEIOU') if additional_vowels is not None: vowels.update(v.lower() for v in additional_vowels) vowels.update(v.upper() for v in additional_vowels) return sum(1 for char in s if char in vowels)"},{"question":"def tribonacci(n: int) -> int: Returns the n-th Tribonacci number. The Tribonacci sequence is a sequence of numbers where each number is the sum of the previous three numbers, starting with 0, 1, and 1. Parameters: n (int): The position in the Tribonacci sequence to retrieve. Returns: int: The n-th Tribonacci number. Raises: ValueError: If the input is not a non-negative integer. >>> tribonacci(0) 0 >>> tribonacci(1) 1 >>> tribonacci(2) 1 >>> tribonacci(3) 2 >>> tribonacci(4) 4 >>> tribonacci(-1) Traceback (most recent call last): ... ValueError: Input must be a non-negative integer >>> tribonacci(\\"five\\") Traceback (most recent call last): ... ValueError: Input must be a non-negative integer >>> tribonacci(5.5) Traceback (most recent call last): ... ValueError: Input must be a non-negative integer","solution":"def tribonacci(n): Returns the n-th Tribonacci number. The Tribonacci sequence is a sequence of numbers where each number is the sum of the previous three numbers, starting with 0, 1, and 1. Parameters: n (int): The position in the Tribonacci sequence to retrieve. Returns: int: The n-th Tribonacci number. # Error handling for invalid inputs if not isinstance(n, int) or n < 0: raise ValueError(\\"Input must be a non-negative integer\\") # Base cases if n == 0: return 0 elif n == 1 or n == 2: return 1 # Initialize the base values trib = [0, 1, 1] # Use dynamic programming to build the sequence up to n for i in range(3, n + 1): next_val = trib[-1] + trib[-2] + trib[-3] trib.append(next_val) return trib[n]"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Returns a list where each element is the product of all other elements in the original list. >>> product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) == [60, 40, 30, 24] >>> product_except_self([1, 2, 0, 4]) == [0, 0, 8, 0] >>> product_except_self([0, 0, 0, 4]) == [0, 0, 0, 0] >>> product_except_self([]) == [] >>> product_except_self([10]) == [1] >>> product_except_self([-1, -2, -3, -4]) == [-24, -12, -8, -6] >>> product_except_self([1, -2, 3, -4]) == [24, -12, 8, -6] >>> product_except_self([-1, 2, -3, 4]) == [-24, 12, -8, 6]","solution":"def product_except_self(nums): Returns a list where each element is the product of all other elements in the original list. length = len(nums) # Initialize the result list with 1s result = [1] * length # Calculate the prefix products prefix = 1 for i in range(length): result[i] = prefix prefix *= nums[i] # Calculate the postfix products and multiply with the prefix products postfix = 1 for i in range(length - 1, -1, -1): result[i] *= postfix postfix *= nums[i] return result"},{"question":"def fibonacci(n: int) -> int: Calculate the nth Fibonacci number using memoization. >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(3) 2 >>> fibonacci(4) 3 >>> fibonacci(10) 55 >>> fibonacci(20) 6765 >>> fibonacci(30) 832040","solution":"def fibonacci(n, memo = {}): Returns the nth Fibonacci number using memoization. if n in memo: return memo[n] if n == 0: return 0 if n == 1: return 1 memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo) return memo[n]"},{"question":"from typing import List def max_product_of_three(nums: List[int]) -> int: Returns the largest product that can be obtained from any three integers in the list. >>> max_product_of_three([1, 10, 2, 6, 5, 3]) 300 >>> max_product_of_three([-10, -10, 5, 2]) 500","solution":"from typing import List def max_product_of_three(nums: List[int]) -> int: Returns the largest product that can be obtained from any three integers in the list. nums.sort() # The maximum product can be either: # 1. The product of the three largest numbers # 2. The product of the two smallest numbers (which can be negative, thus resulting in a positive product) and the largest number return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"def string_compression(s: str) -> str: Given a string 's', compress it using the counts of repeated characters. If the compressed string is not shorter than the original, return the original string. Constraints: The string will only contain uppercase and lowercase letters (a-z and A-Z). >>> string_compression(\\"aabcccccaaa\\") 'a2b1c5a3' >>> string_compression(\\"abcdef\\") 'abcdef' >>> string_compression(\\"aaAAaaaAAA\\") 'a2A2a3A3'","solution":"def string_compression(s: str) -> str: Given a string 's', compress it using the counts of repeated characters. If the compressed string is not shorter than the original, return the original string. Args: s (str): Input string containing only uppercase and lowercase letters. Returns: str: Compressed string or the original string if the compressed string is not shorter. if not s: return s compressed = [] count_consecutive = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count_consecutive += 1 else: compressed.append(s[i - 1]) compressed.append(str(count_consecutive)) count_consecutive = 1 compressed.append(s[-1]) compressed.append(str(count_consecutive)) compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"def generate_maze(width, height): Generates a maze using Depth-First Search (DFS) algorithm. Parameters: width (int): The width of the maze height (int): The height of the maze Returns: List[List[int]]: The generated maze represented as a 2D list def print_maze(maze): Visualizes the maze by printing it, where walls are denoted by '#' and paths by spaces. Parameters: maze (List[List[int]]): The maze represented as a 2D list from generate_maze import generate_maze, print_maze def test_generate_small_maze(): maze = generate_maze(5, 5) assert len(maze) == 5 assert len(maze[0]) == 5 def test_generate_unique_paths(): maze = generate_maze(7, 7) path_count = sum(row.count(1) for row in maze) assert path_count > 0 def test_generate_entry_and_exit(): width, height = 10, 10 maze = generate_maze(width, height) assert maze[1][0] == 1 # Entry point assert maze[-2][-1] == 1 # Exit point def test_print_maze(): maze = [[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]] expected_output = \\"#n# #n# # #n# #n#\\" import io from contextlib import redirect_stdout f = io.StringIO() with redirect_stdout(f): print_maze(maze) output = f.getvalue().strip() assert output == expected_output","solution":"import random def generate_maze(width, height): Generates a maze using Depth-First Search (DFS) algorithm. Parameters: width (int): The width of the maze height (int): The height of the maze Returns: List[List[int]]: The generated maze represented as a 2D list maze = [[0 for _ in range(width)] for _ in range(height)] start_x, start_y = (random.randrange(1, width - 1, 2), random.randrange(1, height - 1, 2)) def dfs(x, y): directions = [(2, 0), (-2, 0), (0, 2), (0, -2)] random.shuffle(directions) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 < nx < width and 0 < ny < height and maze[ny][nx] == 0: maze[ny][nx] = 1 maze[ny - dy//2][nx - dx//2] = 1 dfs(nx, ny) maze[start_y][start_x] = 1 dfs(start_x, start_y) # Make sure the entry and exit are open maze[1][0] = 1 maze[-2][-1] = 1 return maze def print_maze(maze): Visualizes the maze by printing it, where walls are denoted by '#' and paths by spaces. Parameters: maze (List[List[int]]): The maze represented as a 2D list for row in maze: print(''.join(' ' if cell == 1 else '#' for cell in row))"},{"question":"def longest_common_subsequence(str1: str, str2: str) -> (int, str): Returns the length of the longest common subsequence and one possible LCS string. >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") == (3, \\"ace\\") >>> longest_common_subsequence(\\"abcdef\\", \\"abdf\\") == (4, \\"abdf\\") >>> longest_common_subsequence(\\"\\", \\"\\") == (0, \\"\\") >>> longest_common_subsequence(\\"abc\\", \\"\\") == (0, \\"\\") >>> longest_common_subsequence(\\"\\", \\"abc\\") == (0, \\"\\") >>> longest_common_subsequence(\\"abc\\", \\"abc\\") == (3, \\"abc\\") >>> longest_common_subsequence(\\"AGGTAB\\", \\"GXTXAYB\\") == (4, \\"GTAB\\") def longest_common_subsequence_mistake(str1: str, str2: str) -> (int, str): Returns the length of the longest common subsequence but potentially wrong LCS string due to a mistake. >>> longest_common_subsequence_mistake(\\"AGGTAB\\", \\"GXTXAYB\\") != (4, \\"GTAB\\") def test_lcs_both_strings_empty(): assert longest_common_subsequence(\\"\\", \\"\\") == (0, \\"\\") def test_lcs_one_string_empty(): assert longest_common_subsequence(\\"abc\\", \\"\\") == (0, \\"\\") assert longest_common_subsequence(\\"\\", \\"abc\\") == (0, \\"\\") def test_lcs_no_common_subsequence(): assert longest_common_subsequence(\\"abc\\", \\"def\\") == (0, \\"\\") def test_lcs_common_subsequence(): assert longest_common_subsequence(\\"abcde\\", \\"ace\\") == (3, \\"ace\\") assert longest_common_subsequence(\\"abc\\", \\"abc\\") == (3, \\"abc\\") assert longest_common_subsequence(\\"abcdef\\", \\"abdf\\") == (4, \\"abdf\\") def test_lcs_typical_case(): assert longest_common_subsequence(\\"AGGTAB\\", \\"GXTXAYB\\") == (4, \\"GTAB\\") def test_lcs_mistake(): assert longest_common_subsequence_mistake(\\"AGGTAB\\", \\"GXTXAYB\\") != (4, \\"GTAB\\")","solution":"def longest_common_subsequence(str1, str2): Returns the length of the longest common subsequence and one possible LCS string. m, n = len(str1), len(str2) dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the dp table for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Reconstruct LCS string from dp table lcs_str = \\"\\" i, j = m, n while i > 0 and j > 0: if str1[i - 1] == str2[j - 1]: lcs_str = str1[i - 1] + lcs_str i -= 1 j -= 1 elif dp[i - 1][j] > dp[i][j - 1]: i -= 1 else: j -= 1 return dp[m][n], lcs_str # Typical mistake def longest_common_subsequence_mistake(str1, str2): Returns the length of the longest common subsequence but potentially wrong LCS string due to a mistake. m, n = len(str1), len(str2) dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the dp table for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Reconstruct LCS string from dp table (Mistake here) lcs_str = \\"\\" i, j = m, n while i > 0 and j > 0: if dp[i - 1][j] > dp[i][j - 1]: i -= 1 else: j -= 1 if str1[i - 1] == str2[j - 1]: lcs_str = str1[i - 1] + lcs_str i -= 1 j -= 1 return dp[m][n], lcs_str"},{"question":"def square_evens(numbers: List[int]) -> List[int]: Returns a list of squares of the even numbers from the original list. Args: numbers: List of integers. Returns: List of squares of even integers. >>> square_evens([1, 2, 3, 4, 5, 6]) [4, 16, 36] >>> square_evens([1, 3, 5]) [] >>> square_evens([2, 4, 6]) [4, 16, 36] >>> square_evens([-2, -4, -6]) [4, 16, 36] >>> square_evens([]) [] >>> square_evens([5]) [] >>> square_evens([4]) [16] pass","solution":"def square_evens(numbers): Returns a list of squares of the even numbers from the original list. Args: numbers: List of integers. Returns: List of squares of even integers. return [num ** 2 for num in numbers if num % 2 == 0]"},{"question":"def find_max_consecutive_sum(arr, k): Returns the maximum sum of k consecutive elements in the list arr. If k is greater than the length of the list, returns None. >>> find_max_consecutive_sum([1, 2, 3, 4], 5) == None >>> find_max_consecutive_sum([1, 2, 3, 4], 4) == 10 >>> find_max_consecutive_sum([1, 2, 3, 4], 1) == 4 >>> find_max_consecutive_sum([1, 2, 3, 4, 5, 6], 2) == 11 >>> find_max_consecutive_sum([1, 2, 3, 4, 5, 6], 3) == 15 >>> find_max_consecutive_sum([-1, -2, 3, 4, -5, 6], 3) == 5 >>> find_max_consecutive_sum([-1, -2, -3, -4, -5, -6], 2) == -3","solution":"def find_max_consecutive_sum(arr, k): Returns the maximum sum of k consecutive elements in the list arr. If k is greater than the length of the list, returns None. n = len(arr) if k > n: return None max_sum = sum(arr[:k]) current_sum = max_sum for i in range(k, n): current_sum += arr[i] - arr[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def classify_and_sum_numbers(numbers: List[int]): Classifies the list of numbers and computes their sum: - \\"All positive\\" if all numbers are positive - \\"All negative\\" if all numbers are negative - \\"Mixed numbers\\" if there are both positive and negative numbers Additionally, returns the sum of all numbers in the list. >>> classify_and_sum_numbers([1, 2, 3, 4, 5]) All positive Sum: 15 >>> classify_and_sum_numbers([-1, -2, -3, -4, -5]) All negative Sum: -15 >>> classify_and_sum_numbers([1, -2, 3, -4, 5]) Mixed numbers Sum: 3 >>> classify_and_sum_numbers([1, -1]) Mixed numbers Sum: 0","solution":"def classify_and_sum_numbers(numbers): Classifies the list of numbers and computes their sum: - \\"All positive\\" if all numbers are positive - \\"All negative\\" if all numbers are negative - \\"Mixed numbers\\" if there are both positive and negative numbers Additionally, returns the sum of all numbers in the list. total_sum = sum(numbers) if all(num > 0 for num in numbers): print(\\"All positive\\") elif all(num < 0 for num in numbers): print(\\"All negative\\") else: print(\\"Mixed numbers\\") print(f\\"Sum: {total_sum}\\")"},{"question":"from typing import List from collections import Counter def k_most_frequent(nums: List[int], k: int) -> List[int]: Write a function that takes a list of integers and an integer k and returns the k most frequent elements in the list. If there is a tie for the k-th frequent element, include all tied elements in the result. The function should return the elements in ascending order. If the list is empty or the value of k is 0, return an empty list. >>> k_most_frequent([1, 1, 1, 2, 2, 3], 2) [1, 2] >>> k_most_frequent([1, 1, 2, 2, 3, 3], 2) [1, 2, 3] >>> k_most_frequent([1, 1, 1, 1, 1], 1) [1] >>> k_most_frequent([1, 2, 3, 4], 5) [1, 2, 3, 4] >>> k_most_frequent([1, 1, 2, 3], 0) [] >>> k_most_frequent([], 3) [] >>> k_most_frequent([4], 1) [4] >>> k_most_frequent([4], 0) []","solution":"from collections import Counter def k_most_frequent(nums, k): Returns the k most frequent elements in the list 'nums'. If there is a tie for the k-th frequent element, it includes all tied elements in the result. The result is returned in ascending order. if not nums or k == 0: return [] count = Counter(nums) freq = count.most_common() # If k is greater than the number of unique elements, reduce it k = min(k, len(freq)) # Frequent elements sorted by frequency and then by value freq.sort(key=lambda x: (-x[1], x[0])) result = [] current_freq = None for num, cnt in freq: if current_freq is None: current_freq = cnt if len(result) < k or current_freq == cnt: result.append(num) else: break return sorted(result)"},{"question":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Returns indices of the two numbers in nums that add up to the target. Args: nums: List of integers. target: Target integer. Returns: List of two indices if a solution exists, otherwise [-1, -1]. Examples: >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([3, 3], 6) [0, 1] >>> two_sum([1, 2, 3, 4], 8) [-1, -1] def test_two_sum_example_1(): assert two_sum([2, 7, 11, 15], 9) == [0, 1] def test_two_sum_example_2(): assert two_sum([3, 2, 4], 6) == [1, 2] def test_two_sum_example_3(): assert two_sum([3, 3], 6) == [0, 1] def test_two_sum_no_solution(): assert two_sum([1, 2, 3, 4], 8) == [-1, -1] def test_two_sum_single_element(): assert two_sum([1], 2) == [-1, -1] def test_two_sum_empty_list(): assert two_sum([], 0) == [-1, -1] def test_two_sum_large_numbers(): assert two_sum([1, 2, 3, 4, 1000000], 1000003) == [2, 4] def test_two_sum_with_negative_numbers(): assert two_sum([1, -2, 3, 4], 2) == [1, 3]","solution":"def two_sum(nums, target): Returns indices of the two numbers in nums that add up to the target. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return [-1, -1]"},{"question":"def remove_occurrences(numbers: list, x: int) -> list: Removes all occurrences of x from the list of integers numbers. Parameters: numbers (list): A list of integers. x (int): An integer value to be removed from the list. Returns: list: The modified list with all occurrences of x removed. Examples: >>> remove_occurrences([1, 2, 3, 4, 2, 2, 5], 2) [1, 3, 4, 5] >>> remove_occurrences([1, 2, 3, 4, 2, 2, 5], 3) [1, 2, 4, 2, 2, 5] >>> remove_occurrences([], 3) [] >>> remove_occurrences([1, 1, 1, 1], 1) [] >>> remove_occurrences([1, 2, 3, 4, 5], 6) [1, 2, 3, 4, 5] >>> remove_occurrences([1, -1, 2, -1, 3, -1], -1) [1, 2, 3] >>> remove_occurrences([0, 0, 0, 0], 0) [] >>> remove_occurrences([x * 1000 for x in range(5)], 3000) [0, 1000, 2000, 4000]","solution":"def remove_occurrences(numbers, x): Removes all occurrences of x from the list of integers numbers. Parameters: numbers (list): A list of integers. x (int): An integer value to be removed from the list. Returns: list: The modified list with all occurrences of x removed. return [num for num in numbers if num != x]"},{"question":"from typing import List def no_duplicate_chars(strings: List[str]) -> List[str]: Takes a list of strings and returns a new list containing only the strings that have no duplicate characters. >>> no_duplicate_chars([\\"hello\\", \\"world\\", \\"abc\\", \\"deed\\"]) [\\"world\\", \\"abc\\"] >>> no_duplicate_chars([\\"aabb\\", \\"ccdd\\", \\"eeee\\"]) [] >>> no_duplicate_chars([\\"abcd\\", \\"efg\\", \\"hij\\"]) [\\"abcd\\", \\"efg\\", \\"hij\\"] >>> no_duplicate_chars([\\"\\"]) [\\"\\"] >>> no_duplicate_chars([]) [] >>> no_duplicate_chars([\\"a\\", \\"b\\", \\"c\\"]) [\\"a\\", \\"b\\", \\"c\\"]","solution":"def no_duplicate_chars(strings): Takes a list of strings and returns a new list containing only the strings that have no duplicate characters. def has_no_duplicates(s): return len(s) == len(set(s)) return [s for s in strings if has_no_duplicates(s)]"},{"question":"import re def sum_of_integers(s: str) -> int: Takes in a string containing multiple positive integers separated by various delimiters and returns the sum of these integers. Non-numeric characters and delimiters are ignored in the sum computation. >>> sum_of_integers(\\"1, 2, 3 4 5\\") 15 >>> sum_of_integers(\\"1;2;3n4n5\\") 15 >>> sum_of_integers(\\"a1b c2d e3f, g4h 5i\\") 15 >>> sum_of_integers(\\"1000000000,2000000000,3000000000\\") 6000000000 >>> sum_of_integers(\\"\\") 0 >>> sum_of_integers(\\"abc, def; ghi\\") 0 >>> sum_of_integers(\\"42\\") 42","solution":"import re def sum_of_integers(s): Takes in a string containing multiple positive integers separated by various delimiters and returns the sum of these integers. Non-numeric characters and delimiters are ignored in the sum computation. # Use regex to find all sequences of digits in the input string numbers = re.findall(r'd+', s) # Convert all found digit sequences to integers and sum them up return sum(map(int, numbers))"},{"question":"from sklearn.datasets import load_iris from sklearn.model_selection import train_test_split from sklearn.neighbors import KNeighborsClassifier from sklearn.metrics import accuracy_score, precision_score, recall_score def iris_knn_classification(): Use the Iris dataset from scikit-learn and implement a classification model using K-Nearest Neighbors (KNN). Evaluate the performance of your model using accuracy, precision, and recall metrics. >>> accuracy, precision, recall = iris_knn_classification() >>> isinstance(accuracy, float) and 0 <= accuracy <= 1 True >>> isinstance(precision, float) and 0 <= precision <= 1 True >>> isinstance(recall, float) and 0 <= recall <= 1 True","solution":"from sklearn.datasets import load_iris from sklearn.model_selection import train_test_split from sklearn.neighbors import KNeighborsClassifier from sklearn.metrics import accuracy_score, precision_score, recall_score def iris_knn_classification(): # Load the Iris dataset iris = load_iris() X, y = iris.data, iris.target # Split the data into training and testing sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Create and train the KNN classifier knn = KNeighborsClassifier(n_neighbors=3) knn.fit(X_train, y_train) # Make predictions on the test set y_pred = knn.predict(X_test) # Calculate accuracy, precision, and recall accuracy = accuracy_score(y_test, y_pred) precision = precision_score(y_test, y_pred, average='macro') recall = recall_score(y_test, y_pred, average='macro') return accuracy, precision, recall"},{"question":"from typing import List from collections import Counter def most_frequent_word(sentence: str) -> str: Returns the most frequent word in the sentence. If there is a tie for the most frequent word, returns any one of the most frequent words. >>> most_frequent_word(\\"hello\\") == \\"hello\\" >>> most_frequent_word(\\"the quick brown fox jumps over the lazy dog the\\") == \\"the\\" >>> most_frequent_word(\\"every word here is unique\\") in [\\"every\\", \\"word\\", \\"here\\", \\"is\\", \\"unique\\"] >>> most_frequent_word(\\"a a b b c c\\") in [\\"a\\", \\"b\\", \\"c\\"] >>> most_frequent_word(\\"it was the best of times it was the worst of times\\") in [\\"it\\", \\"was\\", \\"the\\", \\"of\\", \\"times\\"]","solution":"from collections import Counter def most_frequent_word(sentence): Returns the most frequent word in the sentence. If there is a tie, returns any of the most frequent words. words = sentence.split() word_counts = Counter(words) most_common_word, _ = word_counts.most_common(1)[0] return most_common_word"},{"question":"def next_palindrome(n: int) -> int: Returns the next number that is a palindrome after the given number n. >>> next_palindrome(123) 131 >>> next_palindrome(121) 131 >>> next_palindrome(8) 9 >>> next_palindrome(11) 22 >>> next_palindrome(1234) 1331 >>> next_palindrome(1000) 1001 >>> next_palindrome(100) 101","solution":"def next_palindrome(n: int) -> int: Returns the next number that is a palindrome after the given number n. def is_palindrome(x: int) -> bool: s = str(x) return s == s[::-1] while True: n += 1 if is_palindrome(n): return n"},{"question":"def can_dry_reservoir(rains: List[int]) -> bool: Determines if it's possible to dry every lake that filled up due to the rain. >>> can_dry_reservoir([1, 2, 0, 0, 1, 2, 3, 0, 2]) True >>> can_dry_reservoir([-1, -2, 2, 1, 0, 0, -1, -1]) False","solution":"from typing import List def can_dry_reservoir(rains: List[int]) -> bool: lakes = {} sunny_days = [] for day, lake in enumerate(rains): if lake < 0: # rain day lake = -lake if lake in lakes and lakes[lake] > 0: if not sunny_days: return False dry_day = None for sd in sunny_days: if sd > lakes[lake]: # find the sunny day after it rained on this lake dry_day = sd break if dry_day is None: return False sunny_days.remove(dry_day) lakes[lake] = day + 1 else: # sunny day sunny_days.append(day + 1) return True"},{"question":"def evaluate_expressions(expr_list, d): Evaluates a list of arithmetic expressions, handling potential errors and ignoring any expressions with errors. Parameters: expr_list (list): A list of arithmetic expressions as strings. d (int): The depth of the nested list. Returns: list: A list of evaluation results, with erroneous expressions ignored. Examples: >>> evaluate_expressions([\\"1 + 1\\", \\"2 * 3\\", \\"4 / 2\\"], 1) [2, 6, 2.0] >>> evaluate_expressions([\\"1 + 1\\", \\"invalid expression\\", \\"4 / 0\\"], 1) [2] >>> evaluate_expressions([\\"1 + 1\\", [\\"2 * 3\\", \\"4 / 2\\", \\"8 / 0\\"]], 2) [2, 6, 2.0] >>> evaluate_expressions([\\"1 + 1\\", [\\"2 * 3\\", [\\"4 + 4\\", \\"10 / 2\\"]], \\"9-3\\"], 3) [2, 6, 8, 5.0, 6] >>> evaluate_expressions([\\"1 + 1\\", 123, True, \\"4 - 2\\"], 1) [2, 2] >>> evaluate_expressions([[\\"1 + 2\\", \\"2 + 2\\"], [[\\"4 * 4\\"]], \\"9 / 3\\"], 3) [3, 4, 16, 3.0]","solution":"def evaluate_expressions(expr_list, d): Evaluates a list of arithmetic expressions, handling potential errors. Parameters: expr_list (list): A list of arithmetic expressions as strings. d (int): The depth of the nested list. Returns: list: A list of evaluation results, with erroneous expressions ignored. results = [] def evaluate(expr): Evaluates a single expression and returns its result. try: return eval(expr) except (ZeroDivisionError, SyntaxError, TypeError, NameError): return None def process_list(lst, depth): Recursively process each list up to the specified depth. if depth < 0: return for item in lst: if isinstance(item, list): process_list(item, depth - 1) elif isinstance(item, str): result = evaluate(item) if result is not None: results.append(result) process_list(expr_list, d) return results"},{"question":"def shift_string_forward(input_string: str) -> str: Shifts each character in the string forward by one position in the alphabet. Spaces should be preserved. >>> shift_string_forward(\\"hello world\\") \\"ifmmp xpsme\\" >>> shift_string_forward(\\"xyz\\") \\"yza\\" >>> shift_string_forward(\\"a\\") \\"b\\" >>> shift_string_forward(\\"z\\") \\"a\\" >>> shift_string_forward(\\"hi there\\") \\"ij uifsf\\" >>> shift_string_forward(\\"\\") \\"\\" >>> shift_string_forward(\\"aaaa\\") \\"bbbb\\" >>> shift_string_forward(\\"zzzz\\") \\"aaaa\\"","solution":"def shift_string_forward(input_string): Shifts each character in the string forward by one position in the alphabet. output_string = \\"\\" for char in input_string: if char == ' ': output_string += ' ' else: output_string += chr((ord(char) - ord('a') + 1) % 26 + ord('a')) return output_string"},{"question":"def max_profit(prices: List[int]) -> int: Calculates the maximum profit from buying and selling one stock. :param prices: List[int] - List of stock prices. :return: int - Maximum possible profit, or 0 if no profit is possible. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([3, 3, 5, 0, 0, 3, 1, 4]) 4 pass # Unit tests def test_max_profit_example_cases(): assert max_profit([7, 1, 5, 3, 6, 4]) == 5 assert max_profit([7, 6, 4, 3, 1]) == 0 assert max_profit([3, 3, 5, 0, 0, 3, 1, 4]) == 4 def test_max_profit_no_prices(): assert max_profit([]) == 0 def test_max_profit_single_day(): assert max_profit([10]) == 0 def test_max_profit_all_increasing(): assert max_profit([1, 2, 3, 4, 5]) == 4 def test_max_profit_all_decreasing(): assert max_profit([5, 4, 3, 2, 1]) == 0 def test_max_profit_variable_prices(): assert max_profit([2, 1, 2, 0, 1]) == 1 assert max_profit([1, 2, 3, 4, 3, 2, 5, 0, 6]) == 6 assert max_profit([10, 7, 5, 8, 11, 9]) == 6 # Call test functions to validate the solution test_max_profit_example_cases() test_max_profit_no_prices() test_max_profit_single_day() test_max_profit_all_increasing() test_max_profit_all_decreasing() test_max_profit_variable_prices()","solution":"def max_profit(prices): Calculates the maximum profit from buying and selling one stock. :param prices: List[int] - List of stock prices. :return: int - Maximum possible profit, or 0 if no profit is possible. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"from typing import List def generate_words(words: List[str], target_length: int) -> List[str]: Write a function that takes a list of words and a target word length. The function should return a list of all possible words that can be constructed using only the letters from the original list of words and where each word meets the target word length. The returned list of words should contain no duplicate entries and be sorted in alphabetical order. >>> generate_words([], 3) [] >>> generate_words([\\"cat\\", \\"dog\\"], 10) [] >>> generate_words([\\"cat\\"], 2) [\\"ac\\", \\"at\\", \\"ca\\", \\"ct\\", \\"ta\\", \\"tc\\"] >>> generate_words([\\"cat\\", \\"dog\\", \\"bird\\"], 3) [\\"acg\\", \\"act\\", \\"adg\\", \\"adt\\", \\"aet\\", ...] # expected output truncated >>> generate_words([\\"cat\\", \\"dog\\"], 1) [\\"a\\", \\"c\\", \\"d\\", \\"g\\", \\"o\\", \\"t\\"] >>> generate_words([\\"cat\\", \\"bat\\"], 3) [\\"aac\\", \\"aab\\", \\"aad\\", \\"aat\\", \\"abc\\", ...] # expected output truncated >>> generate_words([\\"a\\", \\"b\\"], 3) []","solution":"from typing import List from itertools import permutations def generate_words(words: List[str], target_length: int) -> List[str]: # Concatenate all the words into one string of characters all_chars = ''.join(words) # Use permutations to get all possible combinations of the given length possible_words = {''.join(p) for p in permutations(all_chars, target_length)} # Return the sorted list of unique possible words return sorted(possible_words)"},{"question":"def merge_sorted_lists(list1, list2): Merges two sorted lists into one sorted list without using any built-in or library functions with a time complexity of O(m + n) where m and n are the lengths of the two lists respectively. >>> merge_sorted_lists([1, 3, 5, 7], [2, 4, 6, 8]) [1, 2, 3, 4, 5, 6, 7, 8] >>> merge_sorted_lists([-5, -3, -1], [-4, -2, 0]) [-5, -4, -3, -2, -1, 0] >>> merge_sorted_lists([1, 3, 3, 5], [2, 3, 4, 4]) [1, 2, 3, 3, 3, 4, 4, 5] >>> merge_sorted_lists([], [2, 4, 6, 8]) [2, 4, 6, 8] >>> merge_sorted_lists([1, 3, 5], []) [1, 3, 5] >>> merge_sorted_lists([], []) []","solution":"def merge_sorted_lists(list1, list2): Merges two sorted lists into one sorted list without using any built-in or library functions. merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"def transform_string(s: str) -> str: Write a function that takes a string as input and returns a new string where all the uppercase letters have been converted to lowercase, and all the lowercase letters have been converted to uppercase. Additionally, replace all digit characters with a hash symbol (#). Punctuation and whitespace characters should remain unchanged. >>> transform_string(\\"Hello World! 123\\") \\"hELLO wORLD! #\\" >>> transform_string(\\"Python3.8 is Awesome!\\") \\"pYTHON#.# IS aWESOME!\\"","solution":"def transform_string(s: str) -> str: transformed = [] for char in s: if char.isupper(): transformed.append(char.lower()) elif char.islower(): transformed.append(char.upper()) elif char.isdigit(): transformed.append('#') else: transformed.append(char) return ''.join(transformed)"},{"question":"def can_form_palindrome(s: str) -> bool: Determine if the input string can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if and only if the number of characters with an odd count is at most one. >>> can_form_palindrome(\\"carrace\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"\\") True >>> can_form_palindrome(\\"a\\") True >>> can_form_palindrome(\\"aa\\") True >>> can_form_palindrome(\\"ab\\") False >>> can_form_palindrome(\\"Aa\\") False","solution":"from collections import Counter def can_form_palindrome(s: str) -> bool: Determine if the input string can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if and only if the number of characters with an odd count is at most one. char_count = Counter(s) odd_counts = sum(1 for count in char_count.values() if count % 2 != 0) return odd_counts <= 1"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. char_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_map and char_map[s[right]] >= left: left = char_map[s[right]] + 1 char_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"from typing import List def find_elements_appearing_twice(arr: List[int]) -> List[int]: Identifies and returns a list of all unique elements that appear exactly twice in the array. :param arr: List of integers (input array) :return: List of integers containing all unique elements that appear exactly twice >>> find_elements_appearing_twice([1, 2, 3, 2, 4, 5, 1, 6]) [1, 2] >>> find_elements_appearing_twice([4, 3, 5, 6, 4, 3, 7, 8]) [4, 3] >>> find_elements_appearing_twice([1, 2, 3, 4, 5, 6, 7, 8]) [] >>> find_elements_appearing_twice([]) [] >>> find_elements_appearing_twice([1, 1, 2, 2, 3, 3]) [1, 2, 3] >>> find_elements_appearing_twice([1, 1, 1, 2, 2, 3, 4, 4]) [2, 4] >>> find_elements_appearing_twice([1]) [] >>> find_elements_appearing_twice([10, 20, 20, 10, 30, 30, 30]) [10, 20]","solution":"from typing import List def find_elements_appearing_twice(arr: List[int]) -> List[int]: Identifies and returns a list of all unique elements that appear exactly twice in the array. :param arr: List of integers (input array) :return: List of integers containing all unique elements that appear exactly twice element_count = {} result = [] # Step 1: Count the occurrences of each element for num in arr: if num in element_count: element_count[num] += 1 else: element_count[num] = 1 # Step 2: Collect elements that appear exactly twice for num, count in element_count.items(): if count == 2: result.append(num) return result"},{"question":"from typing import Dict, List, Union def median_of_categories(input_dict: Dict[str, List[int]]) -> Dict[str, Union[int, float, None]]: Write a Python function that takes a dictionary as input, where the keys are strings representing category names and the values are lists of integers. The function should return a new dictionary where each key is the category name and the value is the median of the integers in that category. Params: input_dict (dict): Dictionary where the keys are category names (str) and the values are lists of integers. Returns: dict: New dictionary with category names as keys and median values as values. Example: >>> median_of_categories({\\"category1\\": [1, 3, 2, 4, 5], \\"category2\\": [10, 8, 9], \\"category3\\": [7, 7, 8, 8, 7]}) {\\"category1\\": 3, \\"category2\\": 9, \\"category3\\": 7}","solution":"import statistics def median_of_categories(input_dict): Returns a new dictionary where each key is the category name and the value is the median of the integers in that category. Params: input_dict (dict): Dictionary where the keys are category names (str) and the values are lists of integers. Returns: dict: New dictionary with category names as keys and median values as values. result = {} for category, numbers in input_dict.items(): if len(numbers) > 0: result[category] = statistics.median(numbers) else: result[category] = None # Handle empty lists if needed return result"},{"question":"import re from collections import Counter import matplotlib.pyplot as plt def read_and_visualize_word_counts(file_path): Reads a text file, counts the number of occurrences of each word, and creates a bar chart displaying the 10 most frequently occurring words. Args: file_path (str): Path to the text file.","solution":"import re from collections import Counter import matplotlib.pyplot as plt def read_and_visualize_word_counts(file_path): Reads a text file, counts the number of occurrences of each word, and creates a bar chart displaying the 10 most frequently occurring words. Args: file_path (str): Path to the text file. # Read the file with open(file_path, 'r', encoding='utf-8') as file: text = file.read() # Remove punctuation and make all words lowercase text = re.sub(r'[^ws]', '', text).lower() # Split the text into words words = text.split() # Count the occurrences of each word word_counts = Counter(words) # Get the 10 most common words most_common_words = word_counts.most_common(10) # Separate words and counts for plotting words, counts = zip(*most_common_words) # Create the bar chart plt.figure(figsize=(10, 5)) plt.bar(words, counts, color='blue') plt.xlabel('Words') plt.ylabel('Counts') plt.title('10 Most Frequently Occurring Words') plt.xticks(rotation=45) plt.show()"},{"question":"class Inventory: Implements a basic inventory management system for a warehouse. It supports adding new items, removing items, and checking stock levels. def add_item(item_id: str, quantity: int): Adds the specified quantity of the item to the inventory. If the item does not exist, it should be added to the inventory. Example: >>> inventory.add_item(\\"item1\\", 10) def remove_item(item_id: str, quantity: int): Decreases the specified quantity of the item from the inventory. If the quantity to be removed exceeds the current stock, it should remove as much as possible without going into negative stock. Example: >>> inventory.remove_item(\\"item1\\", 5) def check_stock(item_id: str) -> int: Returns the current stock level of the specified item. If the item does not exist, it should return 0. Example: >>> inventory.check_stock(\\"item1\\") 10 Unit Tests: from solution import Inventory def test_add_new_item(): inventory = Inventory() inventory.add_item(\\"item1\\", 10) assert inventory.check_stock(\\"item1\\") == 10 def test_add_existing_item(): inventory = Inventory() inventory.add_item(\\"item1\\", 10) inventory.add_item(\\"item1\\", 5) assert inventory.check_stock(\\"item1\\") == 15 def test_remove_item(): inventory = Inventory() inventory.add_item(\\"item1\\", 10) inventory.remove_item(\\"item1\\", 4) assert inventory.check_stock(\\"item1\\") == 6 def test_remove_item_below_zero(): inventory = Inventory() inventory.add_item(\\"item1\\", 10) inventory.remove_item(\\"item1\\", 15) assert inventory.check_stock(\\"item1\\") == 0 def test_remove_item_not_existing(): inventory = Inventory() inventory.remove_item(\\"item1\\", 5) assert inventory.check_stock(\\"item1\\") == 0 def test_check_stock_non_existing_item(): inventory = Inventory() assert inventory.check_stock(\\"new_item\\") == 0 def test_large_number_of_operations(): inventory = Inventory() for i in range(100): item_id = f\\"item{i}\\" inventory.add_item(item_id, i * 10) assert inventory.check_stock(\\"item50\\") == 500 inventory.remove_item(\\"item50\\", 200) assert inventory.check_stock(\\"item50\\") == 300 inventory.add_item(\\"item50\\", 100) assert inventory.check_stock(\\"item50\\") == 400","solution":"class Inventory: def __init__(self): self.items = {} def add_item(self, item_id: str, quantity: int): if item_id in self.items: self.items[item_id] += quantity else: self.items[item_id] = quantity def remove_item(self, item_id: str, quantity: int): if item_id in self.items: self.items[item_id] = max(0, self.items[item_id] - quantity) def check_stock(self, item_id: str) -> int: return self.items.get(item_id, 0)"},{"question":"import random import matplotlib.pyplot as plt def simulate_coin_toss(n: int) -> dict: Simulates the tossing of a fair coin n times. Returns a dictionary with counts of 'Heads' and 'Tails'. Also generates a pie chart showing the distribution of heads and tails. :param n: int, number of times the coin will be tossed :return: dict with keys 'Heads' and 'Tails' >>> simulate_coin_toss(0) {'Heads': 0, 'Tails': 0} >>> simulate_coin_toss(10) {'Heads': 5, 'Tails': 5}","solution":"import random import matplotlib.pyplot as plt def simulate_coin_toss(n): Simulates the tossing of a fair coin n times. Returns a dictionary with counts of 'Heads' and 'Tails'. Also generates a pie chart showing the distribution of heads and tails. :param n: int, number of times the coin will be tossed :return: dict with keys 'Heads' and 'Tails' if n <= 0: return {'Heads': 0, 'Tails': 0} counts = {'Heads': 0, 'Tails': 0} for _ in range(n): toss = 'Heads' if random.random() < 0.5 else 'Tails' counts[toss] += 1 # Plot pie chart labels = 'Heads', 'Tails' sizes = [counts['Heads'], counts['Tails']] colors = ['gold', 'lightcoral'] explode = (0.1, 0) # explode 1st slice (Heads) plt.pie(sizes, explode=explode, labels=labels, colors=colors, autopct='%1.1f%%', shadow=True, startangle=140) plt.axis('equal') # Equal aspect ratio ensures that pie is drawn as a circle. plt.title('Distribution of Heads and Tails') plt.show() return counts"},{"question":"def merge_alternately(str1: str, str2: str) -> str: Returns a merged string by alternating characters from str1 and str2. If one string is longer, append the remaining characters at the end. >>> merge_alternately(\\"abc\\", \\"defgh\\") 'adbecfgh' >>> merge_alternately(\\"\\", \\"\\") '' >>> merge_alternately(\\"abc\\", \\"\\") 'abc' >>> merge_alternately(\\"\\", \\"def\\") 'def' >>> merge_alternately(\\"a\\", \\"z\\") 'az'","solution":"def merge_alternately(str1, str2): Returns a merged string by alternating characters from str1 and str2. If one string is longer, append the remaining characters at the end. merged_str = [] len1, len2 = len(str1), len(str2) for i in range(max(len1, len2)): if i < len1: merged_str.append(str1[i]) if i < len2: merged_str.append(str2[i]) return ''.join(merged_str)"},{"question":"def max_frequency_char(s: str) -> str: Create a function in Python that takes a string as input and returns the character that appears the maximum number of times. If multiple characters have the same highest frequency, return the one that appears first in the string. Handle both uppercase and lowercase letters as distinct characters. >>> max_frequency_char(\\"a\\") == \\"a\\" >>> max_frequency_char(\\"abcdef\\") == \\"a\\" >>> max_frequency_char(\\"abracadabra\\") == \\"a\\" >>> max_frequency_char(\\"aabbaacc\\") == \\"a\\" >>> max_frequency_char(\\"hello world\\") == \\"l\\" >>> max_frequency_char(\\"a quick brown fox\\") == \\" \\" >>> max_frequency_char(\\"AaBbCc\\") == \\"A\\" >>> max_frequency_char(\\"BBbb\\") == \\"B\\" >>> max_frequency_char(\\"\\") == \\"\\" >>> max_frequency_char(\\"1122334455\\") == \\"1\\" >>> max_frequency_char(\\"11122333\\") == \\"1\\"","solution":"def max_frequency_char(s): Returns the character that appears the maximum number of times in the input string. If multiple characters have the same highest frequency, returns the one that appears first in the string. char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 max_freq = 0 max_char = '' for char in s: if char_count[char] > max_freq: max_freq = char_count[char] max_char = char return max_char"},{"question":"def top_three_grades(grades): Returns the top three highest grades from the list. If the list contains fewer than three grades, return the list itself sorted in descending order. If the list is empty, return an empty list. >>> top_three_grades([85, 92, 88, 73, 96, 81, 99]) [99, 96, 92] >>> top_three_grades([85, 92]) [92, 85] >>> top_three_grades([92]) [92] >>> top_three_grades([]) [] >>> top_three_grades([85, 85, 85]) [85, 85, 85] >>> top_three_grades([50, 75, 75, 100, 50, 50]) [100, 75, 75]","solution":"def top_three_grades(grades): Returns the top three highest grades from the list. If the list contains fewer than three grades, return the list sorted in descending order. If the list is empty, return an empty list. if not grades: return [] sorted_grades = sorted(grades, reverse=True) return sorted_grades[:3]"},{"question":"def are_permutations(str1: str, str2: str) -> bool: This function checks if one string is a permutation of the other. >>> are_permutations(\\"abc\\", \\"abc\\") True >>> are_permutations(\\"abc\\", \\"bca\\") True >>> are_permutations(\\"abc\\", \\"abd\\") False >>> are_permutations(\\"abc\\", \\"abcd\\") False >>> are_permutations(\\"\\", \\"\\") True >>> are_permutations(\\"a\\", \\"\\") False >>> are_permutations(\\"aabbcc\\", \\"abcabc\\") True >>> are_permutations(\\"aabbcc\\", \\"aabbbc\\") False","solution":"def are_permutations(str1, str2): This function checks if str1 is a permutation of str2. if len(str1) != len(str2): return False return sorted(str1) == sorted(str2)"},{"question":"def remove_duplicates(lst: List[int]) -> List[int]: Removes duplicates from the list while preserving the order of the original elements. :param lst: List of integers :return: A new list with duplicates removed >>> remove_duplicates([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([4, 5, 4, 6, 7, 5, 6]) [4, 5, 6, 7] >>> remove_duplicates([1, 1, 1, 1]) [1] >>> remove_duplicates([]) [] >>> remove_duplicates([10, 10, 20, 30, 30, 20, 10]) [10, 20, 30]","solution":"def remove_duplicates(lst): Removes duplicates from the list while preserving the order of the original elements. :param lst: List of integers :return: A new list with duplicates removed seen = set() result = [] for item in lst: if item not in seen: seen.add(item) result.append(item) return result # Example usage: remove_duplicates([4, 5, 4, 6, 7, 5, 6]) # Expected output: [4, 5, 6, 7]"},{"question":"from typing import List def products_except_self(nums: List[int]) -> List[int]: Given a list of numbers, returns a list where each element is the product of all other elements in the original list except the one at the same index. This function should not use division and should handle both positive and negative integers as well as zero. >>> products_except_self([1, 2, 3, 4, 5]) [120, 60, 40, 30, 24] >>> products_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0] >>> products_except_self([3, 5, 7, 9, 11]) [3465, 2079, 1485, 1155, 945] >>> products_except_self([0, 0, 0]) [0, 0, 0] >>> products_except_self([2]) [1] >>> products_except_self([]) [] >>> products_except_self([1]) [1]","solution":"def products_except_self(nums): Given a list of numbers, returns a list where each element is the product of all other elements in the original list except the one at the same index. if not nums: return [] length = len(nums) left_products = [1] * length right_products = [1] * length result = [1] * length for i in range(1, length): left_products[i] = nums[i - 1] * left_products[i - 1] for j in range(length - 2, -1, -1): right_products[j] = nums[j + 1] * right_products[j + 1] for k in range(length): result[k] = left_products[k] * right_products[k] return result"},{"question":"def count_vowels(strings: List[str]) -> Dict[str, int]: Write a function that accepts a list of strings and returns a dictionary where the keys are the strings, and the values are the number of vowels (a, e, i, o, u) in each string. The function should ignore case when counting vowels and should handle an empty string by returning a count of zero. Additionally, the function should handle edge cases where the input list is empty or contains non-string elements by skipping those elements and processing the rest. >>> count_vowels(['apple', 'banana', 'Umbrella']) == {'apple': 2, 'banana': 3, 'Umbrella': 3} >>> count_vowels(['']) == {'': 0} >>> count_vowels(['APPLE', 'bAnaNa', 'uMBRELLA']) == {'APPLE': 2, 'bAnaNa': 3, 'uMBRELLA': 3} >>> count_vowels(['bcd', 'fgh']) == {'bcd': 0, 'fgh': 0} >>> count_vowels([]) == {} >>> count_vowels(['apple', 123, 'banana', None, 'Umbrella', {}, []]) == {'apple': 2, 'banana': 3, 'Umbrella': 3}","solution":"def count_vowels(strings): Returns a dictionary where the keys are the strings from the input list, and the values are the count of vowels in each string. Vowels are counted case-insensitively. vowels = 'aeiou' result = {} for string in strings: if isinstance(string, str): count = sum(1 for char in string.lower() if char in vowels) result[string] = count return result"},{"question":"from typing import List def get_subsequences(S: str) -> List[str]: Using a given string S, return a list of all possible subsequences of S in which the subsequences have their characters in non-decreasing order. >>> get_subsequences(\\"abc\\") == [\\"a\\", \\"ab\\", \\"abc\\", \\"ac\\", \\"b\\", \\"bc\\", \\"c\\"] >>> get_subsequences(\\"aab\\") == [\\"a\\", \\"a\\", \\"b\\", \\"aa\\", \\"ab\\", \\"ab\\", \\"aab\\"] Unit Test: from solution import get_subsequences def test_empty_string(): assert get_subsequences(\\"\\") == [] def test_single_character(): assert get_subsequences(\\"a\\") == [\\"a\\"] def test_two_characters(): assert get_subsequences(\\"ab\\") == [\\"a\\", \\"b\\", \\"ab\\"] def test_three_characters(): assert get_subsequences(\\"abc\\") == [\\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"ac\\", \\"bc\\", \\"abc\\"] def test_repeated_characters(): assert get_subsequences(\\"aab\\") == [\\"a\\", \\"a\\", \\"b\\", \\"aa\\", \\"ab\\", \\"ab\\", \\"aab\\"] def test_non_continuous_characters(): assert get_subsequences(\\"bca\\") == [\\"b\\", \\"c\\", \\"a\\", \\"bc\\", \\"ba\\", \\"ca\\", \\"bca\\"]","solution":"from itertools import combinations def get_subsequences(S): Returns a list of all possible subsequences of S in which the subsequences have their characters in non-decreasing order. subsequences = [] for r in range(1, len(S) + 1): for combo in combinations(S, r): subsequences.append(''.join(combo)) return subsequences"},{"question":"def is_prime(num: int) -> bool: Check if a number is a prime number. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(11) True >>> is_prime(12) False >>> is_prime(1) False >>> is_prime(0) False >>> is_prime(-1) False def sum_of_primes(n: int) -> int: Calculate the sum of all prime numbers less than a given positive integer n. >>> sum_of_primes(10) 17 >>> sum_of_primes(20) 77 >>> sum_of_primes(1) 0 >>> sum_of_primes(2) 0 >>> sum_of_primes(50) 328 >>> sum_of_primes(3) 2 from solution import is_prime, sum_of_primes def test_is_prime(): assert is_prime(2) == True assert is_prime(3) == True assert is_prime(4) == False assert is_prime(5) == True assert is_prime(11) == True assert is_prime(12) == False assert is_prime(1) == False assert is_prime(0) == False assert is_prime(-1) == False def test_sum_of_primes_less_than_10(): assert sum_of_primes(10) == 17 def test_sum_of_primes_less_than_20(): assert sum_of_primes(20) == 77 def test_sum_of_primes_less_than_1(): assert sum_of_primes(1) == 0 def test_sum_of_primes_less_than_2(): assert sum_of_primes(2) == 0 def test_sum_of_primes_large_number(): assert sum_of_primes(50) == 328 def test_sum_of_primes_edge_case(): assert sum_of_primes(3) == 2","solution":"def is_prime(num): Check if a number is a prime number. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while (i * i) <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def sum_of_primes(n): Calculate the sum of all prime numbers less than a given number n. sum_primes = 0 for num in range(2, n): if is_prime(num): sum_primes += num return sum_primes"},{"question":"def is_prime(n: int) -> bool: Determine if a number is prime. pass def filter_primes(lst: List[int]) -> List[int]: Takes a list of integers and returns a new list containing only the prime numbers. >>> filter_primes([]) == [] >>> filter_primes([0, 1, 4, 6, 8, 9, 10]) == [] >>> filter_primes([2, 3, 5, 7, 11, 13]) == [2, 3, 5, 7, 11, 13] >>> filter_primes([2, 4, 6, 7, 9, 10, 13]) == [2, 7, 13] >>> filter_primes([5]) == [5] >>> filter_primes([10]) == [] pass","solution":"def is_prime(n): Helper function to determine if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(lst): Takes a list of integers and returns a new list containing only the prime numbers. return [num for num in lst if is_prime(num)]"},{"question":"from datetime import datetime class BankAccount: Class representing a bank account. Attributes: balance (float): The current balance of the bank account. transactions (list): A list to store the transaction history of the bank account. account_id (int): A unique identifier for the bank account. def __init__(self, initial_balance: float): Creates a new bank account with an initial balance. Args: initial_balance (float): The initial balance of the bank account. pass def deposit(self, amount: float) -> bool: Deposits money into the account. Args: amount (float): The amount to deposit. Returns: bool: True if the deposit is successful, False otherwise. pass def withdraw(self, amount: float) -> bool: Withdraws money from the account. Args: amount (float): The amount to withdraw. Returns: bool: True if the withdrawal is successful, False otherwise. pass def transfer(self, recipient_account: 'BankAccount', amount: float) -> bool: Transfers money to another account. Args: recipient_account (BankAccount): The recipient bank account. amount (float): The amount to transfer. Returns: bool: True if the transfer is successful, False otherwise. pass def transaction_history(self) -> list: Returns the transaction history of the account. Returns: list: A list of transaction history records. pass # Unit tests for the BankAccount class def test_create_account_with_initial_balance(): account = BankAccount(100) assert account.balance == 100 def test_create_account_with_negative_initial_balance(): try: account = BankAccount(-100) except ValueError as e: assert str(e) == \\"Initial balance cannot be negative\\" def test_deposit_positive_amount(): account = BankAccount(100) assert account.deposit(50) == True assert account.balance == 150 def test_deposit_negative_amount(): account = BankAccount(100) assert account.deposit(-50) == False assert account.balance == 100 def test_withdraw_amount_with_sufficient_balance(): account = BankAccount(100) assert account.withdraw(50) == True assert account.balance == 50 def test_withdraw_amount_with_insufficient_balance(): account = BankAccount(100) assert account.withdraw(150) == False assert account.balance == 100 def test_transfer_with_sufficient_balance(): account1 = BankAccount(500) account2 = BankAccount(1000) assert account1.transfer(account2, 200) == True assert account1.balance == 300 assert account2.balance == 1200 def test_transfer_with_insufficient_balance(): account1 = BankAccount(100) account2 = BankAccount(1000) assert account1.transfer(account2, 200) == False assert account1.balance == 100 assert account2.balance == 1000 def test_transaction_history(): account = BankAccount(100) account.deposit(50) account.withdraw(30) history = account.transaction_history() assert len(history) == 2 assert history[0]['type'] == 'deposit' assert history[1]['type'] == 'withdrawal'","solution":"from datetime import datetime class BankAccount: __account_id_counter = 0 def __init__(self, initial_balance: float): if initial_balance < 0: raise ValueError(\\"Initial balance cannot be negative\\") self.balance = initial_balance self.transactions = [] BankAccount.__account_id_counter += 1 self.account_id = BankAccount.__account_id_counter def deposit(self, amount: float) -> bool: if amount <= 0: return False self.balance += amount self.transactions.append({ \\"timestamp\\": datetime.now().strftime(\\"%Y-%m-%d %H:%M:%S\\"), \\"type\\": \\"deposit\\", \\"amount\\": amount, \\"description\\": f\\"Deposit of {amount}\\" }) return True def withdraw(self, amount: float) -> bool: if amount <= 0 or self.balance < amount: return False self.balance -= amount self.transactions.append({ \\"timestamp\\": datetime.now().strftime(\\"%Y-%m-%d %H:%M:%S\\"), \\"type\\": \\"withdrawal\\", \\"amount\\": amount, \\"description\\": f\\"Withdrawal of {amount}\\" }) return True def transfer(self, recipient_account: 'BankAccount', amount: float) -> bool: if amount <= 0 or self.balance < amount: return False self.balance -= amount recipient_account.balance += amount self.transactions.append({ \\"timestamp\\": datetime.now().strftime(\\"%Y-%m-%d %H:%M:%S\\"), \\"type\\": \\"transfer\\", \\"amount\\": amount, \\"description\\": f\\"Transfer of {amount} to account ID {recipient_account.account_id}\\" }) recipient_account.transactions.append({ \\"timestamp\\": datetime.now().strftime(\\"%Y-%m-%d %H:%M:%S\\"), \\"type\\": \\"transfer\\", \\"amount\\": amount, \\"description\\": f\\"Transfer of {amount} from account ID {self.account_id}\\" }) return True def transaction_history(self) -> list: return self.transactions"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Finds the maximum sum of a contiguous subarray in the given list of integers. The function implements Kadane's Algorithm to achieve a time complexity of O(n). Args: nums (list of int): The list of integers. Returns: int: The maximum sum of a contiguous subarray. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([1, 2, 3, 4]) 10 >>> max_subarray_sum([4]) 4 >>> max_subarray_sum([-4]) -4 >>> max_subarray_sum([]) 0 >>> max_subarray_sum([0, 0, 0, 0]) 0 >>> max_subarray_sum([0, -1, 2, 0, -3, 4, 0]) 4","solution":"def max_subarray_sum(nums): Finds the maximum sum of a contiguous subarray in the given list of integers. The function implements Kadane's Algorithm to achieve a time complexity of O(n). Args: nums (list of int): The list of integers. Returns: int: The maximum sum of a contiguous subarray. if not nums: return 0 max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_lists(l1: ListNode, l2: ListNode) -> ListNode: Merges two sorted linked lists (l1 and l2) into one sorted linked list. Returns the head of the merged sorted linked list. pass # Unit tests def list_to_nodes(lst): # Helper function to convert a list to linked list nodes. dummy = ListNode() current = dummy for value in lst: current.next = ListNode(value) current = current.next return dummy.next def nodes_to_list(node): # Helper function to convert linked list nodes to a list. result = [] current = node while current: result.append(current.val) current = current.next return result def test_merge_two_lists_both_empty(): assert merge_two_lists(None, None) == None def test_merge_two_lists_first_empty(): l2 = list_to_nodes([1, 3, 5]) result = merge_two_lists(None, l2) assert nodes_to_list(result) == [1, 3, 5] def test_merge_two_lists_second_empty(): l1 = list_to_nodes([2, 4, 6]) result = merge_two_lists(l1, None) assert nodes_to_list(result) == [2, 4, 6] def test_merge_two_lists_both_non_empty(): l1 = list_to_nodes([1, 2, 4]) l2 = list_to_nodes([1, 3, 4]) result = merge_two_lists(l1, l2) assert nodes_to_list(result) == [1, 1, 2, 3, 4, 4] def test_merge_two_lists_with_overlapping_elements(): l1 = list_to_nodes([1, 5, 7]) l2 = list_to_nodes([2, 3, 6, 8]) result = merge_two_lists(l1, l2) assert nodes_to_list(result) == [1, 2, 3, 5, 6, 7, 8] def test_merge_two_lists_same_value_nodes(): l1 = list_to_nodes([2, 2, 2]) l2 = list_to_nodes([2, 2, 2]) result = merge_two_lists(l1, l2) assert nodes_to_list(result) == [2, 2, 2, 2, 2, 2]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_lists(l1, l2): Merges two sorted linked lists (l1 and l2) into one sorted linked list. # Create a dummy node to act as the starting point of the merged linked list. dummy = ListNode() # Create a pointer to the current node, initially set to the dummy node. current = dummy # Loop until either l1 or l2 becomes None (indicating the end of either list). while l1 and l2: # Compare the current nodes of l1 and l2. if l1.val < l2.val: # If the node from l1 is smaller, add it to the merged list. current.next = l1 l1 = l1.next else: # If the node from l2 is smaller or equal, add it to the merged list. current.next = l2 l2 = l2.next # Move the current pointer to the next node. current = current.next # After the loop, append the rest of the remaining nodes (if any) from l1 or l2. current.next = l1 if l1 is not None else l2 # Return the next node of the dummy, which is the head of the merged list. return dummy.next"},{"question":"def find_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: Returns all unique pairs of integers within the array that sum up to the target. >>> find_pairs([1, 2, 3, 4, 5, 6, 7, 8, 9], 10) [(1, 9), (2, 8), (3, 7), (4, 6)] >>> find_pairs([], 10) [] >>> find_pairs([4], 10) [] >>> find_pairs([-5, -4, -3, -2, -1], -5) [(-4, -1), (-3, -2)] >>> find_pairs([1, 2, 3, 4, 5], 6) [(1, 5), (2, 4)] >>> find_pairs([1, 2, 3, 4, 5], 10) [] >>> find_pairs([1, 3, 2, 2, 3, 4], 5) [(1, 4), (2, 3)]","solution":"def find_pairs(nums, target): Returns all unique pairs of integers within the array that sum up to the target. if len(nums) < 2: return [] nums.sort() pairs = set() seen = set() for num in nums: complement = target - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return list(pairs)"},{"question":"def find_pairs_with_sum(arr, S): Identifies all unique pairs of numbers from the array that add up to the given target sum S. Parameters: arr (list): List of integers. S (int): Target sum. Returns: list: List of tuples where each tuple represents a unique pair of numbers adding up to S. Examples: >>> set(find_pairs_with_sum([1, 2, 3, 4, 5, 6], 7)) {(1, 6), (2, 5), (3, 4)} >>> find_pairs_with_sum([1, 2, 3], 10) [] >>> set(find_pairs_with_sum([1, 2, 2, 3, 4, 5, 6], 7)) {(1, 6), (2, 5), (3, 4)} >>> set(find_pairs_with_sum([-3, -2, -1, 0, 1, 2, 3], 0)) {(-3, 3), (-2, 2), (-1, 1)} >>> set(find_pairs_with_sum([2, 2, 3, 3, 4, 4, 5, 5], 7)) {(2, 5), (3, 4)} >>> find_pairs_with_sum([], 5) [] >>> find_pairs_with_sum([5], 5) []","solution":"def find_pairs_with_sum(arr, S): Identifies all unique pairs of numbers from the array that add up to the given target sum S. Parameters: arr (list): List of integers. S (int): Target sum. Returns: list: List of tuples where each tuple represents a unique pair of numbers adding up to S. seen = set() pairs = set() for number in arr: difference = S - number if difference in seen: pairs.add(tuple(sorted((number, difference)))) seen.add(number) return list(pairs)"},{"question":"def remove_duplicates(nums: List[int]) -> List[int]: Takes a list of integers and returns a new list with duplicates removed, keeping the order of their first appearance in the original list. >>> remove_duplicates([1, 2, 2, 3, 4, 4, 5]) == [1, 2, 3, 4, 5] >>> remove_duplicates([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> remove_duplicates([5, 5, 5, 5, 5]) == [5] >>> remove_duplicates([]) == [] >>> remove_duplicates([1, 2, 1, 3, 2, 4]) == [1, 2, 3, 4] >>> remove_duplicates([-1, -2, -2, 0, 1, -1, 1, 2]) == [-1, -2, 0, 1, 2] # Implement your solution here","solution":"def remove_duplicates(nums): Takes a list of integers and returns a new list with duplicates removed, keeping the order of their first appearance in the original list. seen = set() unique_nums = [] for num in nums: if num not in seen: seen.add(num) unique_nums.append(num) return unique_nums"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findMode(root: TreeNode) -> List[int]: Given a binary tree, find the mode(s) (the most frequently occurring element(s)) in the tree. Implement a function to return a list of the mode(s) in ascending order. Example: >>> root = TreeNode(1, right=TreeNode(2, left=TreeNode(2))) >>> findMode(root) [2] def findLevel(root: TreeNode, value: int, level: int = 1) -> int: Given a binary tree and a node value, find the level of the node in the tree. The level of the root node is 1. Example: >>> root = TreeNode(3, TreeNode(2, TreeNode(1)), TreeNode(4)) >>> findLevel(root, 1) 3 # Unit tests def test_findMode_single_node(): root = TreeNode(1) assert findMode(root) == [1] def test_findMode_multiple_modes(): root = TreeNode(1, right=TreeNode(2, left=TreeNode(2))) assert findMode(root) == [2] def test_findMode_multiple_modes_sorted(): root = TreeNode(1, right=TreeNode(2, left=TreeNode(2))) root.left = TreeNode(1) assert findMode(root) == [1, 2] def test_findLevel_root(): root = TreeNode(0) assert findLevel(root, 0) == 1 def test_findLevel_deep_node(): root = TreeNode(1) root.right = TreeNode(2) root.right.left = TreeNode(3) assert findLevel(root, 3) == 3 def test_findLevel_missing_node(): root = TreeNode(1) root.right = TreeNode(2, left=TreeNode(2)) assert findLevel(root, 4) == -1","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findMode(root): from collections import defaultdict def in_order(node): if node: in_order(node.left) counts[node.val] += 1 in_order(node.right) counts = defaultdict(int) in_order(root) max_count = max(counts.values()) return sorted([val for val in counts if counts[val] == max_count]) def findLevel(root, value, level=1): if not root: return -1 if root.val == value: return level left = findLevel(root.left, value, level + 1) if left != -1: return left return findLevel(root.right, value, level + 1)"},{"question":"def count_unique_substrings(s: str) -> int: Calculate the number of unique substrings in a given string. Parameters: s (str): a string consisting of lowercase English letters. Returns: int: the number of unique substrings. Examples: >>> count_unique_substrings(\\"abc\\") 6 >>> count_unique_substrings(\\"aaa\\") 3","solution":"def count_unique_substrings(s: str) -> int: Returns the number of unique substrings in the given string s. unique_substrings = set() for i in range(len(s)): for j in range(i + 1, len(s) + 1): unique_substrings.add(s[i:j]) return len(unique_substrings)"},{"question":"def rotate_matrix(matrix: list): Rotate the NxN matrix 90 degrees clockwise in place without using extra space. Args: matrix (list of lists): NxN matrix to be rotated. Example: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) >>> matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]]","solution":"def rotate_matrix(matrix: list): Rotate the NxN matrix 90 degrees clockwise in place without using extra space. Args: matrix (list of lists): NxN matrix to be rotated. Example: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) >>> matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] n = len(matrix) for i in range(n // 2): for j in range(i, n - i - 1): temp = matrix[i][j] matrix[i][j] = matrix[n - j - 1][i] matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1] matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1] matrix[j][n - i - 1] = temp"},{"question":"def are_anagrams(str1: str, str2: str) -> bool: Determines if two strings are anagrams of each other, ignoring case and non-alphabet characters. Parameters: str1 (str): The first string to compare. str2 (str): The second string to compare. Returns: bool: True if the strings are anagrams of each other, False otherwise. >>> are_anagrams(\\"listen\\", \\"listen\\") True >>> are_anagrams(\\"Listen\\", \\"Silent\\") True >>> are_anagrams(\\"conversation\\", \\"voices rant on\\") True >>> are_anagrams(\\"a gentleman\\", \\"elegant man!\\") True >>> are_anagrams(\\"hello\\", \\"world\\") False >>> are_anagrams(\\"\\", \\"\\") True >>> are_anagrams(\\"\\", \\"abc\\") False","solution":"def are_anagrams(str1, str2): Determines if two strings are anagrams of each other, ignoring case and non-alphabet characters. Parameters: str1 (str): The first string to compare. str2 (str): The second string to compare. Returns: bool: True if the strings are anagrams of each other, False otherwise. import re str1_cleaned = re.sub('[^a-zA-Z]', '', str1).lower() str2_cleaned = re.sub('[^a-zA-Z]', '', str2).lower() return sorted(str1_cleaned) == sorted(str2_cleaned)"},{"question":"from typing import List, Tuple import random def create_board(rows: int, cols: int, mines: int) -> List[List[int]]: Creates a Minesweeper board of given dimensions with a specified number of mines. board = [[0 for _ in range(cols)] for _ in range(rows)] return board def update_adjacent_cells(board: List[List[int]], row: int, col: int, rows: int, cols: int) -> None: Updates the count of adjacent mines for the cells surrounding a mine. pass def print_board(board: List[List[int]], reveal: bool = False) -> None: Prints the Minesweeper board. If reveal is True, all cells are shown. pass def make_move(board: List[List[int]], revealed: List[List[bool]], row: int, col: int) -> str: Processes the user's move, revealing cells and updating the board state. return 'continue' def reveal_cells(board: List[List[int]], revealed: List[List[bool]], row: int, col: int, rows: int, cols: int) -> None: Reveals cells starting from the given cell. If the cell has no adjacent mines, it recursively reveals its neighbors. pass def init_revealed_board(rows: int, cols: int) -> List[List[bool]]: Initializes a board to keep track of revealed cells. return [[False for _ in range(cols)] for _ in range(rows)] # Example usage: board = create_board(5, 5, 5) # 5x5 board with 5 mines print_board(board) # Move simulation: rows, cols, mines = 5, 5, 5 revealed = init_revealed_board(rows, cols) move_result = make_move(board, revealed, 2, 3) print_board(board, reveal=True if move_result == 'lost' else False)","solution":"import random def create_board(rows, cols, mines): Creates a Minesweeper board of given dimensions with a specified number of mines. # Initialize an empty board board = [[0 for _ in range(cols)] for _ in range(rows)] # Place mines randomly mines_placed = 0 while mines_placed < mines: r = random.randint(0, rows - 1) c = random.randint(0, cols - 1) if board[r][c] != '*': board[r][c] = '*' mines_placed += 1 update_adjacent_cells(board, r, c, rows, cols) return board def update_adjacent_cells(board, row, col, rows, cols): Updates the count of adjacent mines for the cells surrounding a mine. for i in range(-1, 2): for j in range(-1, 2): r = row + i c = col + j if 0 <= r < rows and 0 <= c < cols and board[r][c] != '*': board[r][c] += 1 def print_board(board, reveal=False): Prints the Minesweeper board. If reveal is True, all cells are shown. for row in board: print(\\" \\".join(str(cell) if cell == '*' or reveal else '.' for cell in row)) def make_move(board, revealed, row, col): Processes the user's move, revealing cells and updating the board state. rows, cols = len(board), len(board[0]) if board[row][col] == '*': return 'lost' reveal_cells(board, revealed, row, col, rows, cols) if all(revealed[i][j] or board[i][j] == '*' for i in range(rows) for j in range(cols)): return 'won' return 'continue' def reveal_cells(board, revealed, row, col, rows, cols): Reveals cells starting from the given cell. If the cell has no adjacent mines, it recursively reveals its neighbors. if not (0 <= row < rows and 0 <= col < cols) or revealed[row][col]: return revealed[row][col] = True if board[row][col] == 0: for i in range(-1, 2): for j in range(-1, 2): if i != 0 or j != 0: reveal_cells(board, revealed, row + i, col + j, rows, cols) def init_revealed_board(rows, cols): Initializes a board to keep track of revealed cells. return [[False for _ in range(cols)] for _ in range(rows)]"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Implement a function in Python that takes a list of integers as an argument and returns a new list where each element is the product of all the numbers in the original list except the one at the current position. Do not use division in your solution. >>> product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] >>> product_except_self([1]) == [1] >>> product_except_self([3, 4]) == [4, 3] >>> product_except_self([0, 1, 2, 3]) == [6, 0, 0, 0] >>> product_except_self([1, 2, 0, 4]) == [0, 0, 8, 0] >>> product_except_self([-1, 2, -3, 4]) == [-24, 12, -8, 6] >>> product_except_self([-1, 0, 2]) == [0, -2, 0]","solution":"def product_except_self(nums): Returns a list where each element is the product of all the numbers in the original list except the one at the current position. length = len(nums) result = [1] * length left = 1 for i in range(length): result[i] = left left *= nums[i] right = 1 for i in range(length - 1, -1, -1): result[i] *= right right *= nums[i] return result"},{"question":"def longest_subarray_with_sum(array, target): Finds the longest contiguous subarray that sums up to the specified target value and returns its length. If no such subarray exists, returns 0. >>> longest_subarray_with_sum([1, -1, 5, -2, 3], 3) 4 >>> longest_subarray_with_sum([-2, -1, 2, 1], 1) 2 from solution import longest_subarray_with_sum def test_case_1(): array = [1, -1, 5, -2, 3] target = 3 assert longest_subarray_with_sum(array, target) == 4 def test_case_2(): array = [-2, -1, 2, 1] target = 1 assert longest_subarray_with_sum(array, target) == 2 def test_case_3(): array = [1, 2, 3] target = 3 assert longest_subarray_with_sum(array, target) == 2 def test_case_4(): array = [1, 2, 3] target = 7 assert longest_subarray_with_sum(array, target) == 0 def test_case_5(): array = [1, -1, 1, -1, 1] target = 0 assert longest_subarray_with_sum(array, target) == 4 def test_case_6(): array = [3, 4, 7, 2, -3, 1, 4, 2] target = 7 assert longest_subarray_with_sum(array, target) == 4","solution":"def longest_subarray_with_sum(array, target): Finds the longest contiguous subarray that sums up to the specified target value and returns its length. If no such subarray exists, returns 0. sum_to_index = {0: -1} current_sum = 0 max_length = 0 for i, num in enumerate(array): current_sum += num if current_sum - target in sum_to_index: max_length = max(max_length, i - sum_to_index[current_sum - target]) if current_sum not in sum_to_index: sum_to_index[current_sum] = i return max_length"},{"question":"def find_non_repeating(arr): Returns the first non-repeating integer in the list. If all integers are repeating or the list is empty, it returns None. >>> find_non_repeating([1]) == 1 >>> find_non_repeating([2, 2, 2, 2]) == None >>> find_non_repeating([4, 5, 4, 6, 5, 7]) == 6 >>> find_non_repeating([10, 20, 10, 30, 20]) == 30 >>> find_non_repeating([8, 8, 3, 3, 1, 1, 5]) == 5 >>> find_non_repeating([1, 2, 2, 3, 1, 4, 5, 4]) == 3 >>> find_non_repeating([]) == None >>> find_non_repeating([3, 4, 5, 6, 7]) == 3","solution":"def find_non_repeating(arr): Returns the first non-repeating integer in the list. If all integers are repeating or the list is empty, it returns None. # Dictionary to keep count of elements count_dict = {} # First pass to count all elements for num in arr: if num in count_dict: count_dict[num] += 1 else: count_dict[num] = 1 # Second pass to find the first non-repeating element for num in arr: if count_dict[num] == 1: return num return None"},{"question":"def reverse_words(input_string: str) -> str: Takes an input string consisting of words separated by spaces and returns a new string where each word in the input string is replaced by its reverse. >>> reverse_words(\\"Hello World\\") 'olleH dlroW' >>> reverse_words(\\"Hello, World!\\") ',olleH !dlroW' >>> reverse_words(\\"Python\\") 'nohtyP' >>> reverse_words(\\"\\") '' >>> reverse_words(\\"Hello World\\") 'olleH dlroW' >>> reverse_words(\\" \\") ' '","solution":"def reverse_words(input_string): Takes an input string consisting of words separated by spaces and returns a new string where each word in the input string is replaced by its reverse. words = input_string.split(' ') reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words)"},{"question":"def resource_collection_combinations() -> List[Tuple[int, int, int, int]]: Determine the possible combinations of collection times for wood, stone, gold, and emeralds that lead to exactly 100 units of resources within a total collection time of 30 minutes. The function returns a list of tuples, each tuple containing four integers representing the minutes spent collecting wood, stone, gold, and emeralds respectively. Constraints: 1. The total collection time must not exceed 30 minutes. 2. Collection times are measured in integer minutes. 3. Players can spend zero minutes collecting a certain type of resource. 4. The total units of resources collected must be exactly 100 units. >>> combinations = resource_collection_combinations() >>> all(wood + stone + gold + emerald <= 30 for wood, stone, gold, emerald in combinations) True >>> all((10 * wood) + (5 * stone) + (2 * gold) + emerald == 100 for wood, stone, gold, emerald in combinations) True","solution":"def resource_collection_combinations(): results = [] for wood_minutes in range(31): for stone_minutes in range(31 - wood_minutes): for gold_minutes in range(31 - wood_minutes - stone_minutes): emerald_minutes = 30 - wood_minutes - stone_minutes - gold_minutes total_resources = (10 * wood_minutes) + (5 * stone_minutes) + (2 * gold_minutes) + emerald_minutes if total_resources == 100: results.append((wood_minutes, stone_minutes, gold_minutes, emerald_minutes)) return results # Example usage combinations = resource_collection_combinations() print(combinations)"},{"question":"def shortest_unsorted_subarray(arr) -> list: Identify the shortest subarray that needs to be sorted, ensuring the entire array is sorted in ascending order. Parameters: arr (list): A list of integers. Returns: list: A list representing the shortest unsorted subarray. If the array is already sorted, return an empty list. Examples: shortest_unsorted_subarray([2, 6, 4, 8, 10, 9, 15]) = [6, 4, 8, 10, 9] shortest_unsorted_subarray([1, 2, 3, 4, 5]) = [] shortest_unsorted_subarray([1, 3, 2, 2, 2]) = [3, 2, 2, 2] from solution import shortest_unsorted_subarray def test_sorted_array(): assert shortest_unsorted_subarray([1, 2, 3, 4, 5]) == [] def test_entire_array_unsorted(): assert shortest_unsorted_subarray([5, 4, 3, 2, 1]) == [5, 4, 3, 2, 1] def test_subarray_in_middle(): assert shortest_unsorted_subarray([1, 2, 6, 4, 5, 8, 9]) == [6, 4, 5] def test_single_element_array(): assert shortest_unsorted_subarray([1]) == [] def test_array_with_duplicates(): assert shortest_unsorted_subarray([1, 3, 2, 2, 2]) == [3, 2, 2, 2] def test_subarray_at_end(): assert shortest_unsorted_subarray([1, 3, 5, 4, 2]) == [3, 5, 4, 2] def test_subarray_at_start(): assert shortest_unsorted_subarray([4, 3, 2, 1, 5, 6, 7]) == [4, 3, 2, 1]","solution":"def shortest_unsorted_subarray(arr): Identify the shortest subarray that needs to be sorted, ensuring the entire array is sorted in ascending order. Parameters: arr (list): A list of integers. Returns: list: A list representing the shortest unsorted subarray. If the array is already sorted, return an empty list. n = len(arr) if n <= 1: return [] start, end = -1, -1 # Find the first element which is out of order from the beginning for i in range(n - 1): if arr[i] > arr[i + 1]: start = i break # If no such element is found, the array is already sorted if start == -1: return [] # Find the first element which is out of order from the end for i in range(n - 1, 0, -1): if arr[i] < arr[i - 1]: end = i break sub_max = max(arr[start:end+1]) sub_min = min(arr[start:end+1]) # Extend the start point to the left if needed while start > 0 and arr[start - 1] > sub_min: start -= 1 # Extend the end point to the right if needed while end < n - 1 and arr[end + 1] < sub_max: end += 1 return arr[start:end+1]"},{"question":"def has_pair_with_sum(arr, target): Determines whether there are two distinct integers in the array that add up to the target sum. :param arr: List[int] - array of integers :param target: int - target sum :return: bool - True if such a pair exists, otherwise False >>> has_pair_with_sum([4, 7, 1, 12, 5], 9) True >>> has_pair_with_sum([4, 7, 1, 12, 5], 20) False >>> has_pair_with_sum([], 9) False >>> has_pair_with_sum([9], 9) False >>> has_pair_with_sum([1, 2, 3, 4], 10) False >>> has_pair_with_sum([-1, -2, -3, -4, -5], -8) True >>> has_pair_with_sum([-1, 4, 3, -2, 5], 3) True >>> has_pair_with_sum([5, 5, 4, 4], 9) True >>> has_pair_with_sum([0, 0, 0, 0], 0) True >>> has_pair_with_sum([1, 2, 3, 4, 5], 8) True","solution":"def has_pair_with_sum(arr, target): Determines whether there are two distinct integers in the array that add up to the target sum. :param arr: List[int] - array of integers :param target: int - target sum :return: bool - True if such a pair exists, otherwise False seen = set() for number in arr: complement = target - number if complement in seen: return True seen.add(number) return False"},{"question":"def calculate_average_sales(sales_data: dict) -> (dict, tuple): Calculate the average sales per month for each employee and determine the employee with the highest average monthly sales. Args: sales_data (dict): A dictionary where the keys are employee names and the values are lists of their monthly sales. Returns: tuple: A dictionary with the average sales per month for each employee and a tuple with the employee name and their highest average monthly sales. pass # Unit Tests def test_calculate_average_sales(): sales_data = { 'John': [2500, 3200, 2100], 'Emma': [3100, 3400, 2900], 'Liam': [2700, 2800, 2600] } avg_sales, highest_avg_sales = calculate_average_sales(sales_data) assert avg_sales == {'John': 2600.0, 'Emma': 3133.3333333333335, 'Liam': 2700.0} assert highest_avg_sales == ('Emma', 3133.3333333333335) def test_calculate_average_sales_single_employee(): sales_data = { 'John': [2500, 3200, 2100], } avg_sales, highest_avg_sales = calculate_average_sales(sales_data) assert avg_sales == {'John': 2600.0} assert highest_avg_sales == ('John', 2600.0) def test_calculate_average_sales_all_same(): sales_data = { 'John': [3000, 3000, 3000], 'Emma': [3000, 3000, 3000], 'Liam': [3000, 3000, 3000] } avg_sales, highest_avg_sales = calculate_average_sales(sales_data) assert avg_sales == {'John': 3000.0, 'Emma': 3000.0, 'Liam': 3000.0} assert highest_avg_sales == ('John', 3000.0) or ('Emma', 3000.0) or ('Liam', 3000.0) def test_calculate_average_sales_empty(): sales_data = {} avg_sales, highest_avg_sales = calculate_average_sales(sales_data) assert avg_sales == {} assert highest_avg_sales == ('', 0) def test_calculate_average_sales_varied_length(): sales_data = { 'John': [2500, 3200], 'Emma': [3100, 3400, 2900], 'Liam': [2700] } avg_sales, highest_avg_sales = calculate_average_sales(sales_data) assert avg_sales == {'John': 2850.0, 'Emma': 3133.3333333333335, 'Liam': 2700.0} assert highest_avg_sales == ('Emma', 3133.3333333333335)","solution":"def calculate_average_sales(sales_data): Calculate the average sales per month for each employee and determine the employee with the highest average monthly sales. Args: sales_data (dict): A dictionary where the keys are employee names and the values are lists of their monthly sales. Returns: tuple: A dictionary with the average sales per month for each employee and a tuple with the employee name and their highest average monthly sales. average_sales = {} highest_avg_sales = ('', 0) for employee, sales in sales_data.items(): avg_sales = sum(sales) / len(sales) average_sales[employee] = avg_sales if avg_sales > highest_avg_sales[1]: highest_avg_sales = (employee, avg_sales) return average_sales, highest_avg_sales"},{"question":"def is_harshad_number(n: int) -> bool: Returns True if \`n\` is a Harshad number, otherwise returns False. A Harshad number is an integer that is divisible by the sum of its digits. >>> is_harshad_number(18) # True, 1+8 = 9, 18 % 9 == 0 True >>> is_harshad_number(21) # True, 2+1 = 3, 21 % 3 == 0 True >>> is_harshad_number(19) # False, 1+9 = 10, 19 % 10 != 0 False >>> is_harshad_number(0) # False, 0 is not considered a Harshad number False >>> is_harshad_number(1) # True, 1 is a Harshad number True >>> is_harshad_number(152) # True, 1+5+2 = 8, 152 % 8 == 0 True >>> is_harshad_number(101) # False, 1+0+1 = 2, 101 % 2 != 0 False","solution":"def is_harshad_number(n): Returns True if \`n\` is a Harshad number, otherwise returns False. A Harshad number is an integer that is divisible by the sum of its digits. if n == 0: return False digit_sum = sum(int(digit) for digit in str(n)) return n % digit_sum == 0"},{"question":"def longest_increasing_subsequence(arr): Function to find the length of the longest increasing subsequence (LIS) and one possible LIS in an unsorted array. >>> longest_increasing_subsequence([]) (0, []) >>> longest_increasing_subsequence([10]) (1, [10]) >>> longest_increasing_subsequence([3, 10, 2, 1, 20]) (3, [3, 10, 20]) >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) (5, [1, 2, 3, 4, 5]) >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) (1, [5]) # other single element outputs are also valid >>> longest_increasing_subsequence([10, 3, 5, 2, 8, 7, 6]) (3, [3, 5, 8]) # other valid outputs are [3, 5, 7], [2, 6, 8], [5, 6, 8]","solution":"def longest_increasing_subsequence(arr): Function to find the length of the longest increasing subsequence (LIS) and one possible LIS in an unsorted array. if not arr: return 0, [] n = len(arr) dp = [1] * n predecessor = [-1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j] and dp[i] < dp[j] + 1: dp[i] = dp[j] + 1 predecessor[i] = j max_length = max(dp) lis_index = dp.index(max_length) lis = [] while lis_index != -1: lis.append(arr[lis_index]) lis_index = predecessor[lis_index] lis.reverse() return max_length, lis"},{"question":"from typing import List class Warehouse: def __init__(self): self.products = [] def add_product(self, weight: int) -> None: Adds a product to the warehouse by its weight, maintaining the order of products by their weights. pass # Implement the functionality here def get_products(self) -> List[int]: Returns a list of weights of all products in the warehouse in ascending order. pass # Implement the functionality here # Example usage: # wh = Warehouse() # wh.add_product(4) # wh.add_product(1) # wh.add_product(3) # wh.add_product(2) # print(wh.get_products()) # Output: [1, 2, 3, 4] # Unit tests: def test_add_single_product(): wh = Warehouse() wh.add_product(5) assert wh.get_products() == [5] def test_add_multiple_products_ordered(): wh = Warehouse() wh.add_product(2) wh.add_product(4) wh.add_product(6) assert wh.get_products() == [2, 4, 6] def test_add_multiple_products_unordered(): wh = Warehouse() wh.add_product(10) wh.add_product(1) wh.add_product(5) assert wh.get_products() == [1, 5, 10] def test_add_duplicate_weights(): wh = Warehouse() wh.add_product(3) wh.add_product(7) wh.add_product(3) assert wh.get_products() == [3, 3, 7] def test_add_products_to_existing(): wh = Warehouse() wh.add_product(8) wh.add_product(2) wh.add_product(6) wh.add_product(4) assert wh.get_products() == [2, 4, 6, 8] wh.add_product(5) assert wh.get_products() == [2, 4, 5, 6, 8]","solution":"from typing import List class Warehouse: def __init__(self): self.products = [] def add_product(self, weight: int) -> None: Adds a product to the warehouse by its weight, maintaining the order of products by their weights. # Find the right position to insert the new weight if not self.products: self.products.append(weight) else: for i in range(len(self.products)): if self.products[i] > weight: self.products.insert(i, weight) break else: self.products.append(weight) def get_products(self) -> List[int]: Returns a list of weights of all products in the warehouse in ascending order. return self.products"},{"question":"from typing import List def anagram_groups(words: List[str]) -> List[List[str]]: Groups words into lists where each list contains anagrams of each other. Returns a list of these lists, each sorted in alphabetical order and the overall structure sorted by the smallest word in each group. >>> anagram_groups([\\"listen\\", \\"silent\\", \\"enlist\\", \\"eat\\", \\"tea\\", \\"tan\\", \\"ant\\"]) == [[\\"ant\\", \\"tan\\"], [\\"eat\\", \\"tea\\"], [\\"enlist\\", \\"listen\\", \\"silent\\"]] >>> anagram_groups([\\"rat\\", \\"tar\\", \\"art\\", \\"star\\", \\"tars\\", \\"rats\\", \\"car\\", \\"arc\\"]) == [[\\"arc\\", \\"car\\"], [\\"art\\", \\"rat\\", \\"tar\\"], [\\"rats\\", \\"star\\", \\"tars\\"]] >>> anagram_groups([]) == [] >>> anagram_groups([\\"hello\\", \\"world\\"]) == [[\\"hello\\"], [\\"world\\"]] >>> anagram_groups([\\"abc\\", \\"bca\\", \\"cab\\"]) == [[\\"abc\\", \\"bca\\", \\"cab\\"]] >>> anagram_groups([\\"cat\\", \\"tac\\", \\"act\\", \\"dog\\", \\"god\\"]) == [[\\"act\\", \\"cat\\", \\"tac\\"], [\\"dog\\", \\"god\\"]] >>> anagram_groups([\\"word\\"]) == [[\\"word\\"]]","solution":"from typing import List from collections import defaultdict def anagram_groups(words: List[str]) -> List[List[str]]: Groups words into lists where each list contains anagrams of each other. Returns a list of these lists, each sorted in alphabetical order and the overall structure sorted by the smallest word in each group. anagram_dict = defaultdict(list) for word in words: sorted_word = ''.join(sorted(word)) anagram_dict[sorted_word].append(word) grouped_anagrams = [sorted(group) for group in anagram_dict.values()] return sorted(grouped_anagrams, key=lambda x: x[0]) # Example use cases print(anagram_groups([\\"listen\\", \\"silent\\", \\"enlist\\", \\"eat\\", \\"tea\\", \\"tan\\", \\"ant\\"])) print(anagram_groups([\\"rat\\", \\"tar\\", \\"art\\", \\"star\\", \\"tars\\", \\"rats\\", \\"car\\", \\"arc\\"]))"},{"question":"from typing import List, Dict, Tuple def count_occurrences(lst: List[int]) -> Dict[int, int]: Receive a list of integers and return a dictionary where the keys are unique integers from the list and the values are the counts of their occurrences in the list. >>> count_occurrences([1, 2, 2, 3, 3, 3]) {1: 1, 2: 2, 3: 3} >>> count_occurrences([4, 4, 4, 4]) {4: 4} # Your code here def filter_and_sort_odd_counts(count_dict: Dict[int, int]) -> List[Tuple[int, int]]: Take a dictionary of integer counts and return a list of tuples, each containing an integer and its count, but only for integers that appear an odd number of times in the original list. Sort this list of tuples in descending order by their counts. >>> filter_and_sort_odd_counts({1: 1, 2: 2, 3: 3}) [(3, 3), (1, 1)] >>> filter_and_sort_odd_counts({4: 4, 5: 5}) [(5, 5)] # Your code here","solution":"def count_occurrences(lst): Returns a dictionary with the counts of each unique integer in the list. counts = {} for num in lst: if num in counts: counts[num] += 1 else: counts[num] = 1 return counts def filter_and_sort_odd_counts(count_dict): Takes a dictionary of integer counts and returns a sorted list of tuples (integer, count) for integers that appear an odd number of times. odd_count_tuples = [(num, count) for num, count in count_dict.items() if count % 2 != 0] odd_count_tuples.sort(key=lambda x: x[1], reverse=True) return odd_count_tuples"},{"question":"def count_paths(m, n): Calculates the number of unique paths in a grid from the top-left corner to the bottom-right corner. You can only move either down or right. :param m: Number of rows in the grid :param n: Number of columns in the grid :return: Number of unique paths >>> count_paths(3, 7) 28 >>> count_paths(3, 2) 3 # Edge case when there's only one cell if m == 1 or n == 1: return 1 # Initialize a 2D array with 1s dp = [[1] * n for _ in range(m)] # Fill dp with the number of unique paths for i in range(1, m): for j in range(1, n): # Each cell is the sum of the cell above and the cell to the left dp[i][j] = dp[i - 1][j] + dp[i][j - 1] # The bottom-right cell contains the result return dp[m - 1][n - 1]","solution":"def count_paths(m, n): Calculates the number of unique paths in a grid from the top-left corner to the bottom-right corner. You can only move either down or right. :param m: Number of rows in the grid :param n: Number of columns in the grid :return: Number of unique paths # Edge case when there's only one cell if m == 1 or n == 1: return 1 # Initialize a 2D array with 1s dp = [[1] * n for _ in range(m)] # Fill dp with the number of unique paths for i in range(1, m): for j in range(1, n): # Each cell is the sum of the cell above and the cell to the left dp[i][j] = dp[i - 1][j] + dp[i][j - 1] # The bottom-right cell contains the result return dp[m - 1][n - 1]"},{"question":"import numpy as np def weather_forecast(historical_data, day_of_year): Simulates a weather forecasting model. Parameters: historical_data (dict): Dictionary containing historical data with keys 'temperature', 'humidity', 'wind_speed', 'pressure'. Each key contains a list of values representing past recorded data. All lists must have the same length. day_of_year (int): The day of year (1-365) Returns: forecast (float): Predicted temperature for the given day.","solution":"import numpy as np def weather_forecast(historical_data, day_of_year): Simulates a weather forecasting model. Parameters: historical_data (dict): Dictionary containing historical data with keys 'temperature', 'humidity', 'wind_speed', 'pressure'. Each key contains a list of values representing past recorded data. All lists must have the same length. day_of_year (int): The day of year (1-365) Returns: forecast (float): Predicted temperature for the given day. temperature_data = historical_data['temperature'] humidity_data = historical_data['humidity'] wind_speed_data = historical_data['wind_speed'] pressure_data = historical_data['pressure'] num_data_points = len(temperature_data) # Normalizing the day_of_year for seasonal variation (sinusoidal pattern) seasonal_variation = np.sin(2 * np.pi * day_of_year / 365) # Calculating mean and standard deviation of each historical factor temp_mean = np.mean(temperature_data) temp_std = np.std(temperature_data) humidity_mean = np.mean(humidity_data) humidity_std = np.std(humidity_data) wind_speed_mean = np.mean(wind_speed_data) wind_speed_std = np.std(wind_speed_data) pressure_mean = np.mean(pressure_data) pressure_std = np.std(pressure_data) # Creating weights for each factor humidity_weight = 0.25 wind_speed_weight = 0.25 pressure_weight = 0.25 seasonal_weight = 0.25 # Simulate temperature variation using normalized weights predicted_temperature = ( temp_mean + humidity_weight * (humidity_data[-1] - humidity_mean) / humidity_std + wind_speed_weight * (wind_speed_data[-1] - wind_speed_mean) / wind_speed_std + pressure_weight * (pressure_data[-1] - pressure_mean) / pressure_std + seasonal_weight * seasonal_variation * temp_std ) return predicted_temperature"},{"question":"def next_square_number(sequence): Given a sequence of square numbers, return the next number in the sequence. >>> next_square_number([1, 4, 9, 16, 25, 36]) == 49 >>> next_square_number([1]) == 4 >>> next_square_number([1, 4]) == 9 >>> next_square_number([1, 4, 9]) == 16 >>> next_square_number([1, 4, 9, 64, 81]) == 36","solution":"def next_square_number(sequence): Given a sequence of square numbers, return the next number in the sequence. n = len(sequence) + 1 next_number = n * n return next_number"},{"question":"import re from collections import Counter from typing import List, Tuple def analyze_documents(documents: List[str], top_n: int, stop_words: List[str] = None, min_word_length: int = 1) -> List[Tuple[str, int]]: Analyzes a collection of text documents to identify the most frequently occurring words. Parameters: - documents: List of strings, each representing a text document. - top_n: Number of top frequent words to return. - stop_words: List of words to be excluded from the analysis. - min_word_length: Minimum length of words to be included in the frequency count. Returns: - List of tuples with top N words and their respective counts. >>> analyze_documents([\\"The quick brown fox jumps over the lazy dog\\", ... \\"The quick blue fox leaps over the sleeping cat\\"], top_n=3) [('the', 4), ('quick', 2), ('fox', 2)] >>> analyze_documents([\\"The quick brown fox jumps over the lazy dog\\", ... \\"The quick blue fox leaps over the sleeping cat\\"], top_n=3, stop_words=['the', 'over']) [('quick', 2), ('fox', 2), ('brown', 1)] >>> analyze_documents([\\"The quick brown fox\\", \\"the QUICK brown fox\\"], top_n=2) [('the', 2), ('quick', 2)] >>> analyze_documents([\\"a quick brown fox jumps a over lazy dog\\", ... \\"the quick brown jumps over dog\\"], top_n=2, min_word_length=4) [('quick', 2), ('brown', 2)] >>> analyze_documents([], top_n=3) [] >>> analyze_documents([\\"Hello, world! Hello!!!\\", \\"Hello? Are you there...\\"], top_n=1) [('hello', 3)]","solution":"import re from collections import Counter from typing import List, Tuple def analyze_documents(documents: List[str], top_n: int, stop_words: List[str] = None, min_word_length: int = 1) -> List[Tuple[str, int]]: Analyzes a collection of text documents to identify the most frequently occurring words. Parameters: - documents: List of strings, each representing a text document. - top_n: Number of top frequent words to return. - stop_words: List of words to be excluded from the analysis. - min_word_length: Minimum length of words to be included in the frequency count. Returns: - List of tuples with top N words and their respective counts. if stop_words is None: stop_words = [] # Combine all documents into one large string combined_text = ' '.join(documents) # Normalize the text: remove punctuation, special characters and convert to lower case normalized_text = re.sub(r'[^a-zA-Zs]', '', combined_text).lower() # Split the text into words words = normalized_text.split() # Filter out stop words and short words filtered_words = [word for word in words if word not in stop_words and len(word) >= min_word_length] # Count the frequency of each word word_counts = Counter(filtered_words) # Return the top N most common words return word_counts.most_common(top_n)"},{"question":"def game_of_life(grid: List[List[int]]) -> List[List[int]]: Simulates a basic version of Conway's Game of Life. :param grid: A 2D list representing the current state of the grid where 1 represents an alive cell and 0 represents a dead cell. :return: A 2D list representing the next state of the grid. >>> game_of_life([ ... [0, 1, 0], ... [0, 0, 1], ... [1, 1, 1], ... [0, 0, 0] ... ]) [[0, 0, 0], [1, 0, 1], [0, 1, 1], [0, 1, 0]] >>> game_of_life([ ... [1, 1], ... [1, 1] ... ]) [[1, 1], [1, 1]] pass","solution":"from typing import List def game_of_life(grid: List[List[int]]) -> List[List[int]]: def get_live_neighbors(x, y): directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] live_neighbors = 0 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 1: live_neighbors += 1 return live_neighbors rows = len(grid) cols = len(grid[0]) new_grid = [[0] * cols for _ in range(rows)] for r in range(rows): for c in range(cols): live_neighbors = get_live_neighbors(r, c) if grid[r][c] == 1: if live_neighbors < 2 or live_neighbors > 3: new_grid[r][c] = 0 else: new_grid[r][c] = 1 else: if live_neighbors == 3: new_grid[r][c] = 1 return new_grid"},{"question":"import numpy as np import pandas as pd from sklearn.cluster import KMeans import matplotlib.pyplot as plt from sklearn.preprocessing import StandardScaler def kmeans_clustering(file_path): Performs K-means clustering on the customer dataset to categorize retail customers into different segments. Args: file_path (str): Path to the CSV file containing the dataset. Returns: dict: A dictionary containing cluster labels and the optimal number of clusters. pass import pytest import pandas as pd def create_test_dataset(): data = { 'Customer ID': range(1, 11), 'Frequency of Purchases': [5, 3, 2, 8, 7, 10, 6, 1, 4, 9], 'Average Purchase Value': [100, 150, 200, 50, 300, 250, 400, 180, 220, 110], 'Age of the Customer': [25, 35, 45, 20, 60, 55, 40, 30, 50, 65], 'Customer Rating': [7, 8, 9, 6, 4, 5, 8, 7, 6, 9] } df = pd.DataFrame(data) df.to_csv('test_customers.csv', index=False) @pytest.fixture(scope='module') def setup_test_dataset(): create_test_dataset() def test_kmeans_clustering(setup_test_dataset): result = kmeans_clustering('test_customers.csv') # Check the optimal number of clusters assert result['optimal_k'] == 4 # Check the length of clusters clusters = result['clusters'] assert len(clusters) == 10 # Validate the returned records structure expected_keys = {'Customer ID', 'Frequency of Purchases', 'Average Purchase Value', 'Age of the Customer', 'Customer Rating', 'Cluster'} for record in clusters: assert set(record.keys()) == expected_keys","solution":"import numpy as np import pandas as pd from sklearn.cluster import KMeans import matplotlib.pyplot as plt from sklearn.preprocessing import StandardScaler def kmeans_clustering(file_path): Performs K-means clustering on the customer dataset to categorize retail customers into different segments. Args: file_path (str): Path to the CSV file containing the dataset. Returns: dict: A dictionary containing cluster labels and the optimal number of clusters. # Load dataset df = pd.read_csv(file_path) # Extract relevant features X = df[['Frequency of Purchases', 'Average Purchase Value', 'Age of the Customer', 'Customer Rating']] # Normalize the data scaler = StandardScaler() X_scaled = scaler.fit_transform(X) # Find the optimal number of clusters using the elbow method wcss = [] for i in range(1, 11): kmeans = KMeans(n_clusters=i, init='k-means++', max_iter=300, n_init=10, random_state=42) kmeans.fit(X_scaled) wcss.append(kmeans.inertia_) # Plot the elbow method plt.plot(range(1, 11), wcss) plt.title('Elbow Method') plt.xlabel('Number of clusters') plt.ylabel('WCSS') plt.show() # From the elbow plot, we observe the optimal number of clusters (k) # For demonstration, let's assume k=4 based on the plot optimal_k = 4 # Apply K-means to the dataset using optimal_k kmeans = KMeans(n_clusters=optimal_k, init='k-means++', max_iter=300, n_init=10, random_state=42) kmeans.fit(X_scaled) df['Cluster'] = kmeans.labels_ # Sort data by cluster df = df.sort_values('Cluster') # Return the clusters and optimal k return {'clusters': df.to_dict(orient='records'), 'optimal_k': optimal_k}"},{"question":"from typing import List def is_prime(n: int) -> bool: Checks if a number n is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False p = 3 while p * p <= n: if n % p == 0: return False p += 2 return True def filter_primes(numbers: List[int]) -> List[int]: Filters out the prime numbers from the given list of numbers. >>> filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> filter_primes([]) [] >>> filter_primes([1]) [] >>> filter_primes([2]) [2] >>> filter_primes([1, 4, 6, 8, 9, 10, 12]) [] >>> filter_primes([2, 3, 5, 7, 11, 13, 17]) [2, 3, 5, 7, 11, 13, 17]","solution":"def is_prime(n): Checks if a number n is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False p = 3 while p * p <= n: if n % p == 0: return False p += 2 return True def filter_primes(numbers): Filters out the prime numbers from the given list of numbers. return [num for num in numbers if is_prime(num)]"},{"question":"def average_scores(records: list) -> dict: Calculate the average scores for each person and return a sorted dictionary. Args: records (list): A list of dictionaries with 'name' and 'score' keys. Returns: dict: A dictionary with names as keys and their average scores as values, sorted by average scores in descending order, and alphabetically if tied. >>> average_scores([ {'name': 'Alice', 'score': 85}, {'name': 'Bob', 'score': 90}, {'name': 'Alice', 'score': 95}, {'name': 'Bob', 'score': 85}, {'name': 'Charlie', 'score': 70} ]) {'Alice': 90.0, 'Bob': 87.5, 'Charlie': 70.0}","solution":"def average_scores(records): Calculate the average scores for each person and return a sorted dictionary. Args: records (list): A list of dictionaries with 'name' and 'score' keys. Returns: dict: A dictionary with names as keys and their average scores as values, sorted by average scores in descending order, and alphabetically if tied. from collections import defaultdict import statistics scores_dict = defaultdict(list) # Collect all scores for each person. for record in records: scores_dict[record['name']].append(record['score']) # Compute average scores and round to two decimal places. avg_scores = {name: round(statistics.mean(scores), 2) for name, scores in scores_dict.items()} # Sort by average scores (descending) and names (alphabetically) if tied. sorted_avg_scores = dict(sorted(avg_scores.items(), key=lambda x: (-x[1], x[0]))) return sorted_avg_scores"},{"question":"from typing import List def longestZigzag(arr: List[int]) -> int: Returns the length of the longest Zigzag subsequence in the list of integers. A sequence of numbers is called a Zigzag sequence if the differences between successive numbers strictly alternate between positive and negative. Args: arr (List[int]): A list of integers. Returns: int: The length of the longest Zigzag subsequence. Examples: >>> longestZigzag([1, 7, 4, 9, 2, 5]) 6 >>> longestZigzag([1, 4, 7, 2, 5]) 4 >>> longestZigzag([1, 2, 3, 4, 5, 6, 7, 8, 9]) 2 def test_longestZigzag_basic(): assert longestZigzag([1, 7, 4, 9, 2, 5]) == 6 assert longestZigzag([1, 4, 7, 2, 5]) == 4 assert longestZigzag([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 2 def test_longestZigzag_single_element(): assert longestZigzag([10]) == 1 def test_longestZigzag_two_elements(): assert longestZigzag([1, 2]) == 2 assert longestZigzag([2, 1]) == 2 def test_longestZigzag_all_same_elements(): assert longestZigzag([3, 3, 3, 3, 3]) == 1 def test_longestZigzag_alternating(): assert longestZigzag([5, 1, 5, 1, 5, 1, 5]) == 7 def test_longestZigzag_increasing_decreasing(): assert longestZigzag([1, 3, 2, 4, 3, 5, 4]) == 7 def test_longestZigzag_large_input(): arr = list(range(1, 1001)) # strictly increasing assert longestZigzag(arr) == 2 arr = list(range(1000, 0, -1)) # strictly decreasing assert longestZigzag(arr) == 2 def test_longestZigzag_pattern(): arr = [1, 3, 2, 4, 1, 5, 3, 7, 2, 8] assert longestZigzag(arr) == 10","solution":"from typing import List def longestZigzag(arr: List[int]) -> int: if len(arr) < 2: return len(arr) up = down = 1 # start with the first element being alone for i in range(1, len(arr)): if arr[i] > arr[i-1]: up = down + 1 elif arr[i] < arr[i-1]: down = up + 1 return max(up, down)"},{"question":"def convert_to_binary_array(n: int) -> List[str]: Create a function that takes a positive integer \`n\` and returns an array representing the binary equivalent of all numbers from 1 to \`n\`. Each element in the array should be a string representing the binary number. >>> convert_to_binary_array(1) [\\"1\\"] >>> convert_to_binary_array(3) [\\"1\\", \\"10\\", \\"11\\"] >>> convert_to_binary_array(5) [\\"1\\", \\"10\\", \\"11\\", \\"100\\", \\"101\\"] >>> convert_to_binary_array(8) [\\"1\\", \\"10\\", \\"11\\", \\"100\\", \\"101\\", \\"110\\", \\"111\\", \\"1000\\"] >>> convert_to_binary_array(0) []","solution":"def convert_to_binary_array(n): Returns an array representing the binary equivalent of all numbers from 1 to n. Params: n (int): A positive integer to generate binary representations for numbers from 1 to n. Returns: List[str]: List of binary representations of numbers from 1 to n as strings. return [bin(i)[2:] for i in range(1, n + 1)]"},{"question":"def order_deck_of_cards(cards: List[str]) -> List[str]: Write a function \`order_deck_of_cards(cards)\` that takes a list of strings representing a deck of cards and returns the ordered deck according to the following rules: - Each card is represented by a two-character string. The first character is the rank and the second character is the suit. - Ranks are '2-9', 'T', 'J', 'Q', 'K', 'A'. - Suits are 'C', 'D', 'H', 'S' representing Clubs, Diamonds, Hearts, and Spades respectively. - Cards should be ordered first by suit in the order 'C', 'D', 'H', 'S' and then by rank in the order '2-9', 'T', 'J', 'Q', 'K', 'A'. >>> order_deck_of_cards([\\"2H\\", \\"3D\\", \\"AS\\", \\"TC\\", \\"KH\\", \\"7D\\", \\"9S\\", \\"5C\\"]) [\\"5C\\", \\"TC\\", \\"3D\\", \\"7D\\", \\"2H\\", \\"KH\\", \\"9S\\", \\"AS\\"] >>> order_deck_of_cards([\\"2H\\", \\"KH\\", \\"6H\\", \\"TH\\"]) [\\"2H\\", \\"6H\\", \\"TH\\", \\"KH\\"] >>> order_deck_of_cards([\\"AS\\"]) [\\"AS\\"] >>> full_deck = [ ... \\"2C\\", \\"3C\\", \\"4C\\", \\"5C\\", \\"6C\\", \\"7C\\", \\"8C\\", \\"9C\\", \\"TC\\", \\"JC\\", \\"QC\\", \\"KC\\", \\"AC\\", ... \\"2D\\", \\"3D\\", \\"4D\\", \\"5D\\", \\"6D\\", \\"7D\\", \\"8D\\", \\"9D\\", \\"TD\\", \\"JD\\", \\"QD\\", \\"KD\\", \\"AD\\", ... \\"2H\\", \\"3H\\", \\"4H\\", \\"5H\\", \\"6H\\", \\"7H\\", \\"8H\\", \\"9H\\", \\"TH\\", \\"JH\\", \\"QH\\", \\"KH\\", \\"AH\\", ... \\"2S\\", \\"3S\\", \\"4S\\", \\"5S\\", \\"6S\\", \\"7S\\", \\"8S\\", \\"9S\\", \\"TS\\", \\"JS\\", \\"QS\\", \\"KS\\", \\"AS\\" ...] >>> sorted_deck = [ ... \\"2C\\", \\"3C\\", \\"4C\\", \\"5C\\", \\"6C\\", \\"7C\\", \\"8C\\", \\"9C\\", \\"TC\\", \\"JC\\", \\"QC\\", \\"KC\\", \\"AC\\", ... \\"2D\\", \\"3D\\", \\"4D\\", \\"5D\\", \\"6D\\", \\"7D\\", \\"8D\\", \\"9D\\", \\"TD\\", \\"JD\\", \\"QD\\", \\"KD\\", \\"AD\\", ... \\"2H\\", \\"3H\\", \\"4H\\", \\"5H\\", \\"6H\\", \\"7H\\", \\"8H\\", \\"9H\\", \\"TH\\", \\"JH\\", \\"QH\\", \\"KH\\", \\"AH\\", ... \\"2S\\", \\"3S\\", \\"4S\\", \\"5S\\", \\"6S\\", \\"7S\\", \\"8S\\", \\"9S\\", \\"TS\\", \\"JS\\", \\"QS\\", \\"KS\\", \\"AS\\" ...] >>> order_deck_of_cards(full_deck) == sorted_deck True >>> order_deck_of_cards([\\"AH\\", \\"2H\\", \\"TS\\", \\"3D\\", \\"5S\\", \\"8C\\", \\"7H\\", \\"9D\\"]) [\\"8C\\", \\"3D\\", \\"9D\\", \\"2H\\", \\"7H\\", \\"AH\\", \\"5S\\", \\"TS\\"]","solution":"def order_deck_of_cards(cards): Orders a deck of cards based on suit and rank. # Custom sort key suit_order = {'C': 0, 'D': 1, 'H': 2, 'S': 3} rank_order = {'2': 0, '3': 1, '4': 2, '5': 3, '6': 4, '7': 5, '8': 6, '9': 7, 'T': 8, 'J': 9, 'Q': 10, 'K': 11, 'A': 12} def card_key(card): rank = card[0] suit = card[1] return (suit_order[suit], rank_order[rank]) return sorted(cards, key=card_key)"},{"question":"class Robot: DIRECTIONS = ['N', 'E', 'S', 'W'] def __init__(self, x, y, orientation, grid_width, grid_height): self.x = x self.y = y self.orientation = orientation self.grid_width = grid_width self.grid_height = grid_height def turn_left(self): current_index = self.DIRECTIONS.index(self.orientation) self.orientation = self.DIRECTIONS[(current_index - 1) % 4] def turn_right(self): current_index = self.DIRECTIONS.index(self.orientation) self.orientation = self.DIRECTIONS[(current_index + 1) % 4] def move_forward(self): if self.orientation == 'N' and self.y < self.grid_height: self.y += 1 elif self.orientation == 'E' and self.x < self.grid_width: self.x += 1 elif self.orientation == 'S' and self.y > 0: self.y -= 1 elif self.orientation == 'W' and self.x > 0: self.x -= 1 def initialize_grid(width, height): Initializes the grid with the given dimensions. return {'width': width, 'height': height, 'robots': []} def add_robot(grid, x, y, orientation): Adds a new robot at the specified position and orientation. if x > grid['width'] or y > grid['height'] or x < 0 or y < 0: raise ValueError(\\"Robot position out of grid bounds\\") for robot in grid['robots']: if robot.x == x and robot.y == y: raise ValueError(\\"Another robot already at this position\\") grid['robots'].append(Robot(x, y, orientation, grid['width'], grid['height'])) def execute_commands(grid, robot_index, commands): Executes a command string for the specified robot. robot = grid['robots'][robot_index] for command in commands: if command == 'L': robot.turn_left() elif command == 'R': robot.turn_right() elif command == 'F': robot.move_forward() else: raise ValueError(\\"Invalid command\\") def get_robot_position(grid, robot_index): Returns the current position and orientation of the specified robot. robot = grid['robots'][robot_index] return (robot.x, robot.y, robot.orientation) # Unit tests def test_simple_movement(): grid = initialize_grid(5, 5) add_robot(grid, 1, 2, 'N') execute_commands(grid, 0, \\"LFLFLFLFF\\") assert get_robot_position(grid, 0) == (1, 3, 'N') def test_movement_with_two_robots(): grid = initialize_grid(5, 5) add_robot(grid, 1, 2, 'N') add_robot(grid, 3, 3, 'E') execute_commands(grid, 0, \\"LFLFLFLFF\\") execute_commands(grid, 1, \\"FFRFFRFRRF\\") assert get_robot_position(grid, 0) == (1, 3, 'N') assert get_robot_position(grid, 1) == (5, 1, 'E') def test_robot_stops_at_grid_edge(): grid = initialize_grid(5, 5) add_robot(grid, 0, 0, 'S') execute_commands(grid, 0, \\"FFFF\\") assert get_robot_position(grid, 0) == (0, 0, 'S') add_robot(grid, 5, 5, 'N') execute_commands(grid, 1, \\"FFFF\\") assert get_robot_position(grid, 1) == (5, 5, 'N') def test_invalid_commands(): grid = initialize_grid(5, 5) add_robot(grid, 1, 1, 'N') try: execute_commands(grid, 0, \\"X\\") except ValueError as e: assert str(e) == \\"Invalid command\\" def test_initial_robot_overlap(): grid = initialize_grid(5, 5) add_robot(grid, 1, 1, 'N') try: add_robot(grid, 1, 1, 'E') except ValueError as e: assert str(e) == \\"Another robot already at this position\\" def test_out_of_bounds_robot(): grid = initialize_grid(5, 5) try: add_robot(grid, 6, 6, 'N') except ValueError as e: assert str(e) == \\"Robot position out of grid bounds\\"","solution":"class Robot: DIRECTIONS = ['N', 'E', 'S', 'W'] def __init__(self, x, y, orientation, grid_width, grid_height): self.x = x self.y = y self.orientation = orientation self.grid_width = grid_width self.grid_height = grid_height def turn_left(self): current_index = self.DIRECTIONS.index(self.orientation) self.orientation = self.DIRECTIONS[(current_index - 1) % 4] def turn_right(self): current_index = self.DIRECTIONS.index(self.orientation) self.orientation = self.DIRECTIONS[(current_index + 1) % 4] def move_forward(self): if self.orientation == 'N' and self.y < self.grid_height: self.y += 1 elif self.orientation == 'E' and self.x < self.grid_width: self.x += 1 elif self.orientation == 'S' and self.y > 0: self.y -= 1 elif self.orientation == 'W' and self.x > 0: self.x -= 1 def initialize_grid(width, height): return {'width': width, 'height': height, 'robots': []} def add_robot(grid, x, y, orientation): if x > grid['width'] or y > grid['height'] or x < 0 or y < 0: raise ValueError(\\"Robot position out of grid bounds\\") for robot in grid['robots']: if robot.x == x and robot.y == y: raise ValueError(\\"Another robot already at this position\\") grid['robots'].append(Robot(x, y, orientation, grid['width'], grid['height'])) def execute_commands(grid, robot_index, commands): robot = grid['robots'][robot_index] for command in commands: if command == 'L': robot.turn_left() elif command == 'R': robot.turn_right() elif command == 'F': robot.move_forward() else: raise ValueError(\\"Invalid command\\") def get_robot_position(grid, robot_index): robot = grid['robots'][robot_index] return (robot.x, robot.y, robot.orientation)"},{"question":"import re def is_palindrome(s: str) -> bool: Checks if a given string is a palindrome, ignoring spaces, punctuation, and capitalization. >>> is_palindrome(\\"madam\\") True >>> is_palindrome(\\"nurses run\\") True >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"This is not a palindrome\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"Able was I, ere I saw Elba!\\") True >>> is_palindrome(\\"123456\\") False","solution":"import re def is_palindrome(s): Checks if a given string is a palindrome, ignoring spaces, punctuation, and capitalization. # Remove all non-alphanumeric characters and convert to lowercase. cleaned_s = re.sub(r'[^A-Za-z0-9]', '', s).lower() # Check if the cleaned string is equal to its reverse. return cleaned_s == cleaned_s[::-1]"},{"question":"from typing import List, Dict def count_domains(emails: List[str]) -> Dict[str, int]: Extract the domains from a list of email addresses and count their occurrences. >>> count_domains([\\"user1@example.com\\", \\"user2@example.com\\", \\"user3@example.com\\"]) {'example.com': 3} >>> count_domains([ \\"alice@example.com\\", \\"bob@example.com\\", \\"charlie@anotherdomain.com\\", \\"david@anotherdomain.com\\", \\"eve@example.com\\" ]) {'example.com': 3, 'anotherdomain.com': 2} >>> count_domains([ \\"alice@Example.com\\", \\"bob@EXAMPLE.com\\", \\"charlie@AnotherDomain.com\\", \\"david@anotherdomain.com\\" ]) {'example.com': 2, 'anotherdomain.com': 2} >>> count_domains([ \\"alice@one.com\\", \\"bob@two.com\\", \\"charlie@three.com\\", \\"david@four.com\\" ]) {'one.com': 1, 'two.com': 1, 'three.com': 1, 'four.com': 1} >>> count_domains([\\"user@unique.com\\"]) {'unique.com': 1}","solution":"from typing import List, Dict def count_domains(emails: List[str]) -> Dict[str, int]: domain_count = {} for email in emails: domain = email.split('@')[1].lower() if domain in domain_count: domain_count[domain] += 1 else: domain_count[domain] = 1 return domain_count"},{"question":"def highest_grades(students): Returns a new dictionary where each student name maps to their highest grade. If a student has no grades, they should map to \`None\`. Parameters: students (dict): A dictionary with student names as keys and lists of grades as values. Returns: dict: A dictionary with student names as keys and their highest grade or \`None\` as values. >>> highest_grades({\\"Alice\\": [85, 92, 78], \\"Bob\\": [70, 88], \\"Charlie\\": []}) == {\\"Alice\\": 92, \\"Bob\\": 88, \\"Charlie\\": None} >>> highest_grades({\\"Alice\\": [], \\"Bob\\": [], \\"Charlie\\": []}) == {\\"Alice\\": None, \\"Bob\\": None, \\"Charlie\\": None} >>> highest_grades({\\"Alice\\": [100], \\"Bob\\": [], \\"Charlie\\": [95, 80]}) == {\\"Alice\\": 100, \\"Bob\\": None, \\"Charlie\\": 95} >>> highest_grades({\\"Alice\\": [60, 70, 80]}) == {\\"Alice\\": 80} >>> highest_grades({\\"Alice\\": []}) == {\\"Alice\\": None}","solution":"def highest_grades(students): Returns a new dictionary where each student name maps to their highest grade. If a student has no grades, they should map to \`None\`. Parameters: students (dict): A dictionary with student names as keys and lists of grades as values. Returns: dict: A dictionary with student names as keys and their highest grade or \`None\` as values. return {student: max(grades) if grades else None for student, grades in students.items()}"},{"question":"def is_anagram(str1, str2): Determines if two strings are anagrams, ignoring spaces, punctuation, and capitalization. >>> is_anagram(\\"listen\\", \\"silent\\") True >>> is_anagram(\\"conversation\\", \\"voices rant on\\") True >>> is_anagram(\\"A gentleman!\\", \\"Elegant man!\\") True >>> is_anagram(\\"Astronomer\\", \\"Moon starer\\") True >>> is_anagram(\\"hello\\", \\"world\\") False >>> is_anagram(\\"123abcd\\", \\"d2a3bc1\\") True >>> is_anagram(\\"\\", \\"\\") True >>> is_anagram(\\"a\\", \\"ab\\") False","solution":"def is_anagram(str1, str2): Determines if two strings are anagrams, ignoring spaces, punctuation, and capitalization. def clean_string(s): return ''.join(e for e in s if e.isalnum()).lower() cleaned_str1 = clean_string(str1) cleaned_str2 = clean_string(str2) return sorted(cleaned_str1) == sorted(cleaned_str2)"},{"question":"from typing import List from collections import Counter def second_most_frequent(numbers: List[int]) -> int: Write a Python function that takes a list of integers and returns the second most frequent element in the list. If there is a tie for the second most frequent element, return the smallest one. If there are less than two distinct elements, return None. >>> second_most_frequent([1, 3, 3, 3, 2, 2, 4, 4, 4, 6, 6]) 3 >>> second_most_frequent([1, 1, 2, 2]) 1 >>> second_most_frequent([5]) None # your implementation here from solution import second_most_frequent def test_second_most_frequent_normal_case(): assert second_most_frequent([1, 3, 3, 3, 2, 2, 4, 4, 4, 6, 6]) == 3 def test_second_most_frequent_tie_case(): assert second_most_frequent([1, 1, 2, 2]) == 1 def test_second_most_frequent_single_element(): assert second_most_frequent([5]) == None def test_second_most_frequent_two_elements(): assert second_most_frequent([1, 2]) == 1 def test_second_most_frequent_all_unique(): assert second_most_frequent([1,2,3,4,5]) == 1 def test_second_most_frequent_multiple_ties(): assert second_most_frequent([1,2,2,3,3,4,4]) == 2","solution":"from collections import Counter def second_most_frequent(numbers): Returns the second most frequent element in the list If there is a tie for the second most frequent element, return the smallest one. If there are less than two distinct elements, return None. if len(set(numbers)) < 2: return None count = Counter(numbers) most_common = count.most_common() if len(most_common) < 2: return None # The second most frequent value can be in a tie second_most_freq_val = most_common[1][1] candidates = [num for num, freq in most_common if freq == second_most_freq_val] return min(candidates)"},{"question":"def k_most_frequent_words(words: List[str], k: int) -> List[str]: Returns the k most frequent words in the list. In case of a tie, sorts the words alphabetically. >>> k_most_frequent_words([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"], 2) ['apple', 'banana'] >>> k_most_frequent_words([\\"apple\\", \\"banana\\", \\"orange\\"], 2) ['apple', 'banana'] >>> k_most_frequent_words([\\"apple\\", \\"banana\\", \\"orange\\", \\"pear\\", \\"grape\\"], 3) ['apple', 'banana', 'grape'] >>> k_most_frequent_words([\\"apple\\", \\"banana\\", \\"banana\\", \\"orange\\", \\"apple\\", \\"orange\\", \\"apple\\"], 1) ['apple'] >>> k_most_frequent_words([\\"apple\\", \\"banana\\", \\"banana\\", \\"orange\\", \\"apple\\", \\"orange\\", \\"apple\\", \\"grape\\", \\"pear\\"], 4) ['apple', 'banana', 'orange', 'grape']","solution":"from collections import Counter def k_most_frequent_words(words, k): Returns the k most frequent words in the list. In case of a tie, sorts the words alphabetically. # Count the frequency of each word word_count = Counter(words) # Create a sorted list of words based on frequency, # with ties broken by alphabetic order sorted_words = sorted(word_count.items(), key=lambda item: (-item[1], item[0])) # Extract the top k words return [word for word, count in sorted_words[:k]]"},{"question":"def get_users_with_transactions_over_threshold(transactions: List[dict], threshold: int) -> List[str]: Returns the IDs of the users who have made transactions over the given threshold. >>> transactions = [ ... {'user_id': 'A123', 'amount': 200, 'timestamp': '2023-01-01T10:00:00Z'}, ... {'user_id': 'B456', 'amount': 50, 'timestamp': '2023-01-01T11:00:00Z'}, ... {'user_id': 'A123', 'amount': 300, 'timestamp': '2023-01-02T10:00:00Z'}, ... {'user_id': 'C789', 'amount': 400, 'timestamp': '2023-01-03T10:00:00Z'}, ... ] ... threshold = 250 ... get_users_with_transactions_over_threshold(transactions, threshold) ['A123', 'C789']","solution":"def get_users_with_transactions_over_threshold(transactions, threshold): Returns the IDs of the users who have made transactions over the given threshold. user_ids = set() for transaction in transactions: if transaction['amount'] > threshold: user_ids.add(transaction['user_id']) return sorted(user_ids)"},{"question":"from collections import Counter import string def analyze_frequency(lists_of_strings): Takes multiple lists of strings as input and analyzes the frequency of each character across all the strings combined. Returns a dictionary where keys represent input lists and values are tuples of the three most frequent characters (with their counts) and a boolean indicating if all characters in the input list are letters. >>> analyze_frequency([[\\"a\\", \\"ab\\", \\"b\\", \\"bc\\"]]) {0: ([(\\"b\\", 3), (\\"a\\", 2), (\\"c\\", 1)], True)} >>> analyze_frequency([[\\"a\\", \\"ab\\", \\"b\\", \\"bc\\"], [\\"a1\\", \\"a2\\", \\"b3\\"]]) {0: ([(\\"b\\", 3), (\\"a\\", 2), (\\"c\\", 1)], True), 1: ([(\\"a\\", 2), (\\"1\\", 1), (\\"2\\", 1)], False)} >>> analyze_frequency([[\\"a\\", \\"abc\\", 123, None]]) {0: ([(\\"a\\", 2), (\\"b\\", 1), (\\"c\\", 1)], True)} >>> analyze_frequency([[\\"\\", \\"\\"]]) {0: ([], False)} >>> analyze_frequency([[]]) {0: ([], False)} >>> analyze_frequency([[\\"aA\\", \\"Aa\\"]]) {0: ([(\\"a\\", 2), (\\"A\\", 2)], True)}","solution":"from collections import Counter import string def analyze_frequency(lists_of_strings): Takes multiple lists of strings as input and analyzes the frequency of each character across all the strings combined. Returns a dictionary where keys represent input lists and values are tuples of the three most frequent characters (with their counts) and a boolean indicating if all characters in the input list are letters. result = {} for i, strings_list in enumerate(lists_of_strings): # Combine all strings into a single string combined = \\"\\".join([str(s) for s in strings_list if isinstance(s, str)]) if not combined: # Handle empty strings list result[i] = ([], False) continue # Analyze the frequency of each character counter = Counter(combined) # Find top 3 most frequent characters most_common = counter.most_common(3) # Check if all characters are letters all_letters = all(c in string.ascii_letters for c in combined) # Save result result[i] = (most_common, all_letters) return result"},{"question":"def power_of_threes(n): Returns a list of the first n powers of 3 in ascending order. Parameters: n (int): The number of powers of 3 to return. Returns: List[int]: A list containing the first n powers of 3. >>> power_of_threes(5) [1, 3, 9, 27, 81] >>> power_of_threes(0) [] >>> power_of_threes(-3) [] >>> power_of_threes(1) [1] >>> power_of_threes(10) [1, 3, 9, 27, 81, 243, 729, 2187, 6561, 19683] >>> power_of_threes(2) [1, 3] >>> power_of_threes(3) [1, 3, 9]","solution":"def power_of_threes(n): Returns a list of the first n powers of 3 in ascending order. Parameters: n (int): The number of powers of 3 to return. Returns: List[int]: A list containing the first n powers of 3. if n <= 0: return [] result = [3 ** i for i in range(n)] return result"},{"question":"import requests def get_items(api_url): Fetches a list of items from the API and returns the list. >>> get_items(\\"http://mock-api.com/items\\") # Expect a list of items from the API # Implement GET request here def post_item(api_url, item_data): Submits a new item to the API and returns the response. >>> post_item(\\"http://mock-api.com/items\\", {\\"name\\": \\"New Item\\"}) # Expect the response with new item details # Implement POST request here","solution":"import requests def get_items(api_url): Fetches a list of items from the API and returns the list. try: response = requests.get(api_url) response.raise_for_status() except requests.RequestException as e: raise SystemExit(e) return response.json() def post_item(api_url, item_data): Submits a new item to the API and returns the response. try: response = requests.post(api_url, json=item_data) response.raise_for_status() except requests.RequestException as e: raise SystemExit(e) return response.json()"},{"question":"def evaluate_postfix(expression: str) -> float: Evaluates a postfix (Reverse Polish) notation expression and returns the result as a float. Parameters: expression (str): The postfix expression to evaluate. Returns: float: The result of the evaluation. >>> evaluate_postfix(\\"3 4 +\\") 7.0 >>> evaluate_postfix(\\"5 2 -\\") 3.0 >>> evaluate_postfix(\\"6 3 *\\") 18.0 >>> evaluate_postfix(\\"8 4 /\\") 2.0 >>> evaluate_postfix(\\"3 4 + 2 * 7 /\\") 2.0 >>> evaluate_postfix(\\"5 1 2 + 4 * + 3 -\\") 14.0 >>> evaluate_postfix(\\"9\\") 9.0","solution":"def evaluate_postfix(expression): Evaluates a postfix (Reverse Polish) notation expression and returns the result as a float. Parameters: expression (str): The postfix expression to evaluate. Returns: float: The result of the evaluation. stack = [] tokens = expression.split() for token in tokens: if token.isdigit(): stack.append(int(token)) else: b = stack.pop() a = stack.pop() if token == '+': result = a + b elif token == '-': result = a - b elif token == '*': result = a * b elif token == '/': result = a / b stack.append(result) return float(stack.pop())"},{"question":"def is_palindrome(s: str) -> bool: Checks if the given string is a palindrome, considering only alphanumeric characters and ignoring cases. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"race a car\\") False","solution":"def is_palindrome(s): Checks if the given string is a palindrome, considering only alphanumeric characters and ignoring cases. # Filter out non-alphanumeric characters and convert to lower case filtered_chars = [char.lower() for char in s if char.isalnum()] # Compare filtered list with its reversed version return filtered_chars == filtered_chars[::-1]"},{"question":"from typing import List def coprime_sequence(N: int) -> List[int]: Generate the first N terms of the sequence where: a_1 = 1, a_2 = 2, and for n >= 3, a_n is the smallest positive integer that has not appeared earlier in the sequence and is coprime with a_{n-1}. >>> coprime_sequence(5) -> [1, 2, 3, 4, 5] >>> coprime_sequence(10) -> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]","solution":"from typing import List from math import gcd def coprime_sequence(N: int) -> List[int]: Generate the first N terms of the sequence where: a_1 = 1, a_2 = 2, and for n >= 3, a_n is the smallest positive integer that has not appeared earlier in the sequence and is coprime with a_{n-1}. if N == 1: return [1] if N == 2: return [1, 2] sequence = [1, 2] for _ in range(3, N+1): last = sequence[-1] candidate = 1 while candidate in sequence or gcd(candidate, last) != 1: candidate += 1 sequence.append(candidate) return sequence"},{"question":"def maximum_product_of_three(nums: List[int]) -> int: Returns the maximum product that can be obtained by multiplying any three distinct numbers from the list. If the list contains fewer than three integers, return None. >>> maximum_product_of_three([1, 2, 3]) 6 >>> maximum_product_of_three([1, 2, 3, 4]) 24 >>> maximum_product_of_three([-10, -10, 1, 3, 2]) 300 >>> maximum_product_of_three([-10, -10, 5, 2]) 500 >>> maximum_product_of_three([1, 2]) None >>> maximum_product_of_three([]) None >>> maximum_product_of_three([10**5, 10**5, 10**5, 1]) 10**15 >>> maximum_product_of_three([3, 3, 3, 3]) 27","solution":"def maximum_product_of_three(nums): Returns the maximum product that can be obtained by multiplying any three distinct numbers from the list. If the list contains fewer than three integers, return None. if len(nums) < 3: return None nums.sort() return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"def person_playing_saxophone(): Returns the name of the person who is known for their expertise with the saxophone. >>> person_playing_saxophone() \\"Nina\\"","solution":"def person_playing_saxophone(): Returns the name of the person who is known for their expertise with the saxophone. return \\"Nina\\""},{"question":"from itertools import permutations from typing import List def string_permutations(s: str) -> List[str]: Generate all unique permutations of a given string s. :param s: Input string. :return: List of unique permutations. >>> sorted(string_permutations(\\"ABC\\")) ['ABC', 'ACB', 'BAC', 'BCA', 'CAB', 'CBA'] >>> sorted(string_permutations(\\"AAB\\")) ['AAB', 'ABA', 'BAA'] >>> string_permutations(\\"A\\") ['A'] >>> string_permutations(\\"AAA\\") ['AAA'] >>> string_permutations(\\"\\") [''] >>> sorted(string_permutations(\\"ABCA\\")) ['AABC', 'AACB', 'ABAC', 'ABCA', 'ACAB', 'ACBA', 'BAAC', 'BACA', 'BCAA', 'CAAB', 'CABA', 'CBAA']","solution":"from itertools import permutations def string_permutations(s): Generate all unique permutations of a given string s. :param s: Input string. :return: List of unique permutations. return list(set([''.join(p) for p in permutations(s)]))"},{"question":"def summarize_list_elements(lst: List[int]) -> Dict[str, int]: Takes a list of integers and returns a dictionary summarizing the list's elements. :param lst: List of integers :return: Dictionary with counts of 'positive', 'negative', 'zero', 'even', 'odd', and the 'sum' of the list >>> summarize_list_elements([1, -1, 0, 2, 3]) {'positive': 3, 'negative': 1, 'zero': 1, 'even': 2, 'odd': 3, 'sum': 5} >>> summarize_list_elements([0, 1, 2, -1, -2]) {'positive': 2, 'negative': 2, 'zero': 1, 'even': 3, 'odd': 2, 'sum': 0} >>> summarize_list_elements([0, 0, 0]) {'positive': 0, 'negative': 0, 'zero': 3, 'even': 3, 'odd': 0, 'sum': 0}","solution":"def summarize_list_elements(lst): Takes a list of integers and returns a dictionary summarizing the list's elements. :param lst: List of integers :return: Dictionary with counts of 'positive', 'negative', 'zero', 'even', 'odd', and the 'sum' of the list summary = { 'positive': 0, 'negative': 0, 'zero': 0, 'even': 0, 'odd': 0, 'sum': 0 } for num in lst: if num > 0: summary['positive'] += 1 elif num < 0: summary['negative'] += 1 else: summary['zero'] += 1 if num % 2 == 0: summary['even'] += 1 else: summary['odd'] += 1 summary['sum'] += num return summary"},{"question":"def count_occurrences(lst: List[int]) -> Dict[int, int]: Takes a list of integers and returns a dictionary where the keys are the unique integers from the list and the values are the number of times each integer appeared in the list. >>> count_occurrences([1, 2, 2, 3, 3, 3, 4]) == {1: 1, 2: 2, 3: 3, 4: 1} >>> count_occurrences([]) == {} >>> count_occurrences([5]) == {5: 1} >>> count_occurrences([1, 1, 1, 2, 2, 3]) == {1: 3, 2: 2, 3: 1} >>> count_occurrences([7, 7, 7, 7]) == {7: 4} >>> count_occurrences([-1, -2, -2, -3, -3, -3]) == {-1: 1, -2: 2, -3: 3} >>> count_occurrences([-1, -1, 1, 2, -2, 2]) == {-1: 2, 1: 1, 2: 2, -2: 1}","solution":"def count_occurrences(lst): Returns a dictionary with unique integers from the list as keys and their occurrences as values. occurrence_dict = {} for num in lst: if num in occurrence_dict: occurrence_dict[num] += 1 else: occurrence_dict[num] = 1 return occurrence_dict"},{"question":"def solve_sudoku(board): Solves a Sudoku puzzle by filling the board in place. :param board: 9x9 2D list, representing the Sudoku board with 0s indicating empty cells. :return: True if the board is solvable and solved, False otherwise. >>> board = [ ... [5, 3, 0, 0, 7, 0, 0, 0, 0], ... [6, 0, 0, 1, 9, 5, 0, 0, 0], ... [0, 9, 8, 0, 0, 0, 0, 6, 0], ... [8, 0, 0, 0, 6, 0, 0, 0, 3], ... [4, 0, 0, 8, 0, 3, 0, 0, 1], ... [7, 0, 0, 0, 2, 0, 0, 0, 6], ... [0, 6, 0, 0, 0, 0, 2, 8, 0], ... [0, 0, 0, 4, 1, 9, 0, 0, 5], ... [0, 0, 0, 0, 8, 0, 0, 7, 9] ... ] >>> solve_sudoku(board) >>> board [[5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9]]","solution":"def solve_sudoku(board): Solves a Sudoku puzzle by filling the board in place. :param board: 9x9 2D list, representing the Sudoku board with 0s indicating empty cells. :return: True if the board is solvable and solved, False otherwise. def is_valid(board, row, col, num): for i in range(9): if board[row][i] == num or board[i][col] == num: return False if board[row//3*3 + i//3][col//3*3 + i%3] == num: return False return True def solve(board): for row in range(9): for col in range(9): if board[row][col] == 0: for num in range(1, 10): if is_valid(board, row, col, num): board[row][col] = num if solve(board): return True board[row][col] = 0 return False return True return solve(board)"},{"question":"def find_longest_substring(s: str) -> str: Returns the longest substring without repeating characters. If there are multiple such substrings of the same length, returns the one that appears first. >>> find_longest_substring(\\"abcabcbb\\") 'abc' >>> find_longest_substring(\\"bbbbb\\") 'b' >>> find_longest_substring(\\"pwwkew\\") 'wke' >>> find_longest_substring(\\" \\") ' ' >>> find_longest_substring(\\"dvdf\\") 'vdf' >>> find_longest_substring(\\"\\") '' >>> find_longest_substring(\\"abcdefg\\") 'abcdefg' >>> find_longest_substring(\\"aab\\") 'ab' >>> find_longest_substring(\\"abccba\\") 'abc'","solution":"def find_longest_substring(s: str) -> str: Returns the longest substring without repeating characters. If there are multiple such substrings of the same length, returns the one that appears first. start = max_length = 0 used_chars = {} longest_substr = \\"\\" for i, char in enumerate(s): if char in used_chars and start <= used_chars[char]: start = used_chars[char] + 1 else: if i - start + 1 > max_length: max_length = i - start + 1 longest_substr = s[start:i + 1] used_chars[char] = i return longest_substr"},{"question":"def is_palindrome(num: int) -> bool: Check if a number is a palindrome. >>> is_palindrome(121) True >>> is_palindrome(123) False pass def find_largest_palindrome(n: int) -> int: Identify the largest palindromic number that is less than or equal to n. >>> find_largest_palindrome(12321) 12321 >>> find_largest_palindrome(132) 131 >>> find_largest_palindrome(9) 9 >>> find_largest_palindrome(-10) -1 >>> find_largest_palindrome(0) 0 pass","solution":"def is_palindrome(num): Helper function to check if a number is a palindrome. return str(num) == str(num)[::-1] def find_largest_palindrome(n): Function to find the largest palindromic number less than or equal to a given number n. for i in range(n, -1, -1): if is_palindrome(i): return i return -1"},{"question":"from typing import List, Tuple, Optional def count_words(filepath: str) -> Optional[List[Tuple[str, int]]]: Reads a file and counts the occurrence of each unique word (case-insensitive). Parameters: filepath (str): The path to the input file. Returns: Optional[List[Tuple[str, int]]]: A list of tuples where each tuple contains a word and its corresponding count, sorted in descending order by count. Returns None if the file cannot be read. Examples: >>> count_words(\\"path_to_file.txt\\") # Assuming the file contains \\"Hello worldnHello Python world\\" [('hello', 2), ('world', 2), ('python', 1)] >>> count_words(\\"non_existing_file.txt\\") None pass","solution":"import collections import re def count_words(filepath): Reads a file and counts the occurrence of each unique word in a case-insensitive manner. Parameters: filepath (str): The path to the input file. Returns: list of tuples: A list of tuples where each tuple contains a word and its corresponding count, sorted in descending order by count. try: with open(filepath, 'r', encoding='utf-8') as file: text = file.read().lower() words = re.findall(r'bw+b', text) word_counts = collections.Counter(words) sorted_word_counts = word_counts.most_common() return sorted_word_counts except FileNotFoundError: print(f\\"Error: The file at '{filepath}' was not found.\\") except IOError: print(f\\"Error: Cannot read the file at '{filepath}'.\\") # Example usage # result = count_words('path_to_file.txt') # for word, count in result: # print(f\\"{word}: {count}\\")"},{"question":"def most_frequent_char(s: str) -> str: Write a function in Python that takes a string as an input and returns the most frequently occurring character. If there are multiple characters with the same highest frequency, return the one that appears first in the input string. Your implementation should not utilize any external libraries and should achieve the solution with O(n) time complexity where n is the length of the string. >>> most_frequent_char(\\"a\\") == \\"a\\" >>> most_frequent_char(\\"abcdef\\") == \\"a\\" >>> most_frequent_char(\\"abacabad\\") == \\"a\\" >>> most_frequent_char(\\"abcabc\\") == \\"a\\" >>> most_frequent_char(\\"\\") == None >>> most_frequent_char(\\"a bb ccc\\") == \\"c\\" >>> most_frequent_char(\\"!!aab!!bb\\") == \\"!\\" >>> most_frequent_char(\\"a\\" * 10000 + \\"b\\" * 9999) == \\"a\\"","solution":"def most_frequent_char(s): Returns the most frequently occurring character in the string 's'. If there are multiple characters with the same highest frequency, returns the one that appears first in the input string. if not s: return None char_count = {} max_count = 0 max_char = '' for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Check if this character now has the highest count if char_count[char] > max_count: max_count = char_count[char] max_char = char return max_char"},{"question":"def longest_digit_substring(s: str) -> str: Returns the longest contiguous substring that contains only digits. If there are multiple substrings of maximum length, return the first one encountered. >>> longest_digit_substring(\\"\\") == \\"\\" >>> longest_digit_substring(\\"abcdef\\") == \\"\\" >>> longest_digit_substring(\\"a1b2c3\\") == \\"1\\" >>> longest_digit_substring(\\"abc12345def678\\") == \\"12345\\" >>> longest_digit_substring(\\"1234abcd5678efghi\\") == \\"1234\\" >>> longest_digit_substring(\\"1234567890\\") == \\"1234567890\\" >>> longest_digit_substring(\\"abcd1234\\") == \\"1234\\" >>> longest_digit_substring(\\"1234abcd\\") == \\"1234\\" >>> longest_digit_substring(\\"!@#123%^45&*(\\") == \\"123\\"","solution":"def longest_digit_substring(s): Returns the longest contiguous substring that contains only digits. If there are multiple substrings of maximum length, return the first one encountered. max_length = 0 current_length = 0 start_index = 0 max_start_index = -1 for i, char in enumerate(s): if char.isdigit(): current_length += 1 if current_length > max_length: max_length = current_length max_start_index = start_index else: current_length = 0 start_index = i + 1 if max_start_index == -1: return \\"\\" return s[max_start_index:max_start_index + max_length]"},{"question":"def int_to_roman(num: int) -> str: Convert an integer to a Roman numeral. Convert a given positive integer to its Roman numeral representation. The function ensures numbers are within the range of 1 to 3999, inclusive. If the number is not within this range, return \\"Invalid input\\". >>> int_to_roman(3549) \\"MMMDXLIX\\" >>> int_to_roman(944) \\"CMXLIV\\" >>> int_to_roman(1023) \\"MXXIII\\" >>> int_to_roman(0) \\"Invalid input\\" >>> int_to_roman(-5) \\"Invalid input\\" >>> int_to_roman(4000) \\"Invalid input\\" >>> int_to_roman(1) \\"I\\" >>> int_to_roman(3999) \\"MMMCMXCIX\\"","solution":"def int_to_roman(num): Convert an integer to a Roman numeral. :param num: A positive integer :return: A Roman numeral string representation of the number if num <= 0 or num > 3999: return \\"Invalid input\\" val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1] syb = [\\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\"] roman_num = \\"\\" i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syb[i] num -= val[i] i += 1 return roman_num"},{"question":"def sort_by_age(people): Sorts a list of people by age in descending order. Args: people (list of tuples): A list where each tuple contains a name (str) and a birth year (int). Returns: list: A list of names sorted by age in descending order. >>> sort_by_age([(\\"Alice\\", 1990), (\\"Bob\\", 1985), (\\"Charlie\\", 2000)]) ['Bob', 'Alice', 'Charlie'] >>> sort_by_age([(\\"Alice\\", 1990), (\\"Bob\\", 1990), (\\"Charlie\\", 2000)]) ['Alice', 'Bob', 'Charlie'] >>> sort_by_age([(\\"Alice\\", 1990)]) ['Alice'] >>> sort_by_age([]) [] >>> sort_by_age([(\\"Alice\\", 2010), (\\"Bob\\", 2015), (\\"Charlie\\", 2020)]) ['Alice', 'Bob', 'Charlie'] # TODO: Implement the function pass","solution":"def sort_by_age(people): Sorts a list of people by age in descending order. Args: people (list of tuples): A list where each tuple contains a name (str) and a birth year (int). Returns: list: A list of names sorted by age in descending order. current_year = 2023 # Sort the list of tuples by age (current year - birth year) in descending order sorted_people = sorted(people, key=lambda person: current_year - person[1], reverse=True) # Extract and return the names from the sorted list return [person[0] for person in sorted_people]"},{"question":"def two_sum(nums: list, target: int) -> list: Finds two distinct numbers in the array that add up to the target sum. Parameters: nums (list): List of integers. target (int): Target sum. Returns: list: Indices of the two numbers that add up to the target sum. If no such pair exists, returns [-1, -1]. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([1, 2, 3, 4], 8) [-1, -1] >>> two_sum([-3, 4, 3, 90], 0) [0, 2]","solution":"def two_sum(nums, target): Finds two distinct numbers in the array that add up to the target sum. Parameters: nums (list): List of integers. target (int): Target sum. Returns: list: Indices of the two numbers that add up to the target sum. If no such pair exists, returns [-1, -1]. index_map = {} for i, num in enumerate(nums): complement = target - num if complement in index_map: return [index_map[complement], i] index_map[num] = i return [-1, -1]"},{"question":"def calculate_change(prices: List[float], cash_given: float) -> Union[Dict[float, int], str]: Create a function \`calculate_change\` that takes in a list of integer prices of items and an integer amount of cash given. The function should return a dictionary of the minimum number of banknotes and coins required to give the exact change. Assume denominations in the system are 50, 20, 10, 5, 1 coins, and 25c, 10c, 5c, and 1c coins. If the amount of cash given is insufficient to cover the total price of items, the function should return a message indicating insufficient funds. >>> calculate_change([20, 30], 50) == {} # No change required >>> calculate_change([20, 30], 100) == {50: 1} >>> calculate_change([19.75, 30.25], 100) == {50: 1} >>> calculate_change([19, 31], 100) == {50: 1} >>> calculate_change([50, 40], 80) == \\"Insufficient funds\\" >>> calculate_change([19.99], 20) == {0.01: 1} >>> calculate_change([20], 20.03) == {0.01: 3} >>> calculate_change([8.75], 50) == {20: 2, 1: 1, 0.25: 1}","solution":"def calculate_change(prices, cash_given): Returns a dictionary of the minimum number of banknotes and coins required to give the exact change. If the cash given is insufficient to cover the total price of items, returns a message indicating insufficient funds. denominations = [50, 20, 10, 5, 1, 0.25, 0.10, 0.05, 0.01] total_price = sum(prices) change = cash_given - total_price if change < 0: return \\"Insufficient funds\\" change_distribution = {} for denomination in denominations: count = int(change // denomination) if count > 0: change_distribution[denomination] = count change -= round(denomination * count, 2) # To avoid floating-point arithmetic issues return change_distribution"},{"question":"def is_quasi_palindrome(s: str) -> bool: Implement a function that determines whether a given string is a \\"quasi-palindrome.\\" A quasi-palindrome is defined as a string that can be transformed into a palindrome by removing exactly one character. Args: s (str): The input string. Returns: bool: True if the string can be transformed into a palindrome by removing exactly one character; False otherwise. Examples: >>> is_quasi_palindrome(\\"abca\\") True >>> is_quasi_palindrome(\\"racecar\\") False >>> is_quasi_palindrome(\\"abcdef\\") False","solution":"def is_palindrome(s: str) -> bool: Helper function to check if the given string is a palindrome. return s == s[::-1] def is_quasi_palindrome(s: str) -> bool: Returns whether a string is a quasi-palindrome, meaning it can be transformed into a palindrome by removing exactly one character. left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Attempt to remove one character from either side and check for palindrome skip_left = s[left + 1:right + 1] skip_right = s[left:right] return is_palindrome(skip_left) or is_palindrome(skip_right) left += 1 right -= 1 return False"},{"question":"import re from collections import Counter import string from typing import List, Tuple def read_file(file_path: str) -> str: Reads the content of a file and returns it. If the file cannot be read, an exception is raised. :param file_path: Path to the text file :return: Content of the file as a string try: with open(file_path, 'r') as f: return f.read() except FileNotFoundError: raise FileNotFoundError(f\\"The file {file_path} does not exist.\\") def preprocess_text(text: str) -> List[str]: Preprocesses the text by converting to lowercase and removing punctuation. :param text: The input text to be processed :return: List of words after preprocessing text = text.lower() text = re.sub(f\\"[{string.punctuation}]\\", \\"\\", text) words = text.split() return words def get_word_frequency(words: List[str]) -> dict: Counts the frequency of each word in the list. :param words: List of words :return: Dictionary with words as keys and their frequencies as values return Counter(words) def get_top_n_words(word_counts: dict, n: int = 5) -> List[Tuple[str, int]]: Returns the top n most frequent words and their counts. :param word_counts: Dictionary with words as keys and their frequencies as values :param n: Number of top elements to return :return: List of tuples containing top n words and their counts return word_counts.most_common(n) def analyze_text_file(file_path: str) -> List[Tuple[str, int]]: Analyzes the text file to find the top five most frequent words and their counts, considering case insensitivity and ignoring punctuation. :param file_path: Path to the text file :return: List of tuples containing the top five most frequent words and their counts content = read_file(file_path) words = preprocess_text(content) word_counts = get_word_frequency(words) top_words = get_top_n_words(word_counts) return top_words Example Usage if __name__ == \\"__main__\\": print(analyze_text_file(\\"example.txt\\")) Test Cases def test_read_file(): with pytest.raises(FileNotFoundError): read_file(\\"non_existing_file.txt\\") def test_preprocess_text(): assert preprocess_text(\\"Hello, World!\\") == [\\"hello\\", \\"world\\"] assert preprocess_text(\\"Multiple words, with punctuation!\\") == [\\"multiple\\", \\"words\\", \\"with\\", \\"punctuation\\"] def test_get_word_frequency(): words = [\\"hello\\", \\"hello\\", \\"world\\"] assert get_word_frequency(words) == {\\"hello\\": 2, \\"world\\": 1} def test_get_top_n_words(): word_counts = Counter({\\"hello\\": 2, \\"world\\": 1}) assert get_top_n_words(word_counts) == [(\\"hello\\", 2), (\\"world\\", 1)] def test_analyze_text_file(tmp_path): file = tmp_path / \\"test.txt\\" file.write_text(\\"Hello world! Hello everyone.\\") assert analyze_text_file(file) == [(\\"hello\\", 2), (\\"world\\", 1), (\\"everyone\\", 1)]","solution":"import re from collections import Counter import string def read_file(file_path): Reads the content of a file and returns it. If the file cannot be read, an exception is raised. :param file_path: Path to the text file :return: Content of the file as a string try: with open(file_path, 'r') as f: return f.read() except FileNotFoundError: raise FileNotFoundError(f\\"The file {file_path} does not exist.\\") def preprocess_text(text): Preprocesses the text by converting to lowercase and removing punctuation. :param text: The input text to be processed :return: List of words after preprocessing text = text.lower() text = re.sub(f\\"[{string.punctuation}]\\", \\"\\", text) words = text.split() return words def get_word_frequency(words): Counts the frequency of each word in the list. :param words: List of words :return: Dictionary with words as keys and their frequencies as values return Counter(words) def get_top_n_words(word_counts, n=5): Returns the top n most frequent words and their counts. :param word_counts: Dictionary with words as keys and their frequencies as values :param n: Number of top elements to return :return: List of tuples containing top n words and their counts return word_counts.most_common(n) def analyze_text_file(file_path): Analyzes the text file to find the top five most frequent words and their counts, considering case insensitivity and ignoring punctuation. :param file_path: Path to the text file :return: List of tuples containing the top five most frequent words and their counts content = read_file(file_path) words = preprocess_text(content) word_counts = get_word_frequency(words) top_words = get_top_n_words(word_counts) return top_words"},{"question":"from fastapi import FastAPI, WebSocket, WebSocketDisconnect from typing import List app = FastAPI() class ConnectionManager: def __init__(self): self.active_connections: List[WebSocket] = [] async def connect(self, websocket: WebSocket): Handle new WebSocket connection. await websocket.accept() self.active_connections.append(websocket) def disconnect(self, websocket: WebSocket): Handle WebSocket disconnection. self.active_connections.remove(websocket) async def broadcast(self, message: str): Send message to all active connections. for connection in self.active_connections: await connection.send_text(message) manager = ConnectionManager() @app.websocket(\\"/ws/chat\\") async def chat_endpoint(websocket: WebSocket): WebSocket endpoint for real-time chat. Handles: - Connecting new clients - Broadcasting messages - Disconnecting clients await manager.connect(websocket) try: while True: data = await websocket.receive_text() await manager.broadcast(data) except WebSocketDisconnect: manager.disconnect(websocket)","solution":"from fastapi import FastAPI, WebSocket, WebSocketDisconnect from typing import List app = FastAPI() class ConnectionManager: def __init__(self): self.active_connections: List[WebSocket] = [] async def connect(self, websocket: WebSocket): await websocket.accept() self.active_connections.append(websocket) def disconnect(self, websocket: WebSocket): self.active_connections.remove(websocket) async def broadcast(self, message: str): for connection in self.active_connections: await connection.send_text(message) manager = ConnectionManager() @app.websocket(\\"/ws/chat\\") async def chat_endpoint(websocket: WebSocket): await manager.connect(websocket) try: while True: data = await websocket.receive_text() await manager.broadcast(data) except WebSocketDisconnect: manager.disconnect(websocket)"},{"question":"def calculate(s: str) -> int: Evaluate a mathematical expression string involving non-negative integers and the operators +, -, *, and / (without parentheses). Parameters: s (str): The input string representing the expression. Returns: int: The result of evaluating the expression. >>> calculate(\\"3+2*2\\") 7 >>> calculate(\\" 3/2 \\") 1 >>> calculate(\\" 3+5 / 2 \\") 5","solution":"def calculate(s: str) -> int: Evaluate a mathematical expression string involving non-negative integers and the operators +, -, *, and / (without parentheses). Parameters: s (str): The input string representing the expression. Returns: int: The result of evaluating the expression. s = s.replace(\\" \\", \\"\\") num_stack = [] num = 0 sign = '+' i = 0 while i < len(s): char = s[i] if char.isdigit(): num = num * 10 + int(char) if char in '+-*/' or i == len(s) - 1: if sign == '+': num_stack.append(num) elif sign == '-': num_stack.append(-num) elif sign == '*': num_stack.append(num_stack.pop() * num) elif sign == '/': top = num_stack.pop() if top < 0: num_stack.append(-(-top // num)) else: num_stack.append(top // num) sign = char num = 0 i += 1 return sum(num_stack)"},{"question":"def parse_items_price(input_string: str) -> dict: Parses a string containing comma-separated values representing a list of items and their prices, and returns a dictionary with the items as keys and their prices as values. Args: input_string (str): A string in the format \\"item1:price1, item2:price2, ...\\" Returns: dict: A dictionary with items as keys and their prices as values. pass def test_parse_simple_input(): input_string = \\"apple:0.99, banana:0.50, avocado:1.25, pear: 0.75 \\" expected_output = { \\"apple\\": 0.99, \\"banana\\": 0.50, \\"avocado\\": 1.25, \\"pear\\": 0.75 } assert parse_items_price(input_string) == expected_output def test_parse_input_with_extra_spaces(): input_string = \\" apple : 0.99 , banana :0.50, avocado:1.25 , pear : 0.75 \\" expected_output = { \\"apple\\": 0.99, \\"banana\\": 0.50, \\"avocado\\": 1.25, \\"pear\\": 0.75 } assert parse_items_price(input_string) == expected_output def test_parse_input_with_int_prices(): input_string = \\"apple:1, banana:2, avocado:3, pear: 4\\" expected_output = { \\"apple\\": 1.0, \\"banana\\": 2.0, \\"avocado\\": 3.0, \\"pear\\": 4.0 } assert parse_items_price(input_string) == expected_output def test_parse_input_with_only_one_item(): input_string = \\"apple:0.99\\" expected_output = { \\"apple\\": 0.99 } assert parse_items_price(input_string) == expected_output","solution":"def parse_items_price(input_string): Parses a string containing comma-separated values representing a list of items and their prices, and returns a dictionary with the items as keys and their prices as values. Args: input_string (str): A string in the format \\"item1:price1, item2:price2, ...\\" Returns: dict: A dictionary with items as keys and their prices as values. items_prices = {} pairs = input_string.split(',') for pair in pairs: item, price = pair.strip().split(':') items_prices[item.strip()] = float(price.strip()) return items_prices"},{"question":"def maximum_product_of_three(nums: List[int]) -> int: Create a function that takes a list of integers and returns the maximum product that can be obtained from any three of the integers. If the list contains fewer than three integers, raises a ValueError. >>> maximum_product_of_three([1, 2, 3]) == 6 >>> maximum_product_of_three([1, 2, 3, 4]) == 24 >>> maximum_product_of_three([-10, -10, 1, 3, 2]) == 300 >>> maximum_product_of_three([-10, -10, 1, 2, -20]) == 400 >>> maximum_product_of_three([-1, -2, -3, -4]) == -6 >>> maximum_product_of_three([5, 6, 7, 8, 9]) == 504 >>> maximum_product_of_three([-4, -3, -2, -1, 60]) == 720 pass import pytest def test_maximum_product_of_three(): assert maximum_product_of_three([1, 2, 3]) == 6 assert maximum_product_of_three([1, 2, 3, 4]) == 24 assert maximum_product_of_three([-10, -10, 1, 3, 2]) == 300 assert maximum_product_of_three([-10, -10, 1, 2, -20]) == 400 assert maximum_product_of_three([-1, -2, -3, -4]) == -6 assert maximum_product_of_three([5, 6, 7, 8, 9]) == 504 assert maximum_product_of_three([-4, -3, -2, -1, 60]) == 720 def test_edge_cases(): with pytest.raises(ValueError): maximum_product_of_three([1, 2]) with pytest.raises(ValueError): maximum_product_of_three([1]) with pytest.raises(ValueError): maximum_product_of_three([])","solution":"def maximum_product_of_three(nums): Returns the maximum product of any three integers in the list. If the list contains fewer than three integers, raises a ValueError. if len(nums) < 3: raise ValueError(\\"List must contain at least three integers.\\") max1 = max2 = max3 = float('-inf') min1 = min2 = float('inf') for num in nums: if num > max1: max3 = max2 max2 = max1 max1 = num elif num > max2: max3 = max2 max2 = num elif num > max3: max3 = num if num < min1: min2 = min1 min1 = num elif num < min2: min2 = num return max(max1 * max2 * max3, max1 * min1 * min2)"},{"question":"import socket import threading def handle_client(client_socket, clients): Handles communication with a client. addr = client_socket.getpeername() print(f\\"[NEW CONNECTION] {addr} connected.\\") while True: try: message = client_socket.recv(1024).decode('utf-8') if not message: break broadcast(message, client_socket, clients) except: break # Clean up client connection and notify other clients with clients_lock: clients.remove(client_socket) client_socket.close() broadcast(f\\"[DISCONNECTION] {addr} disconnected.\\", None, clients) print(f\\"[DISCONNECTION] {addr} disconnected.\\") def broadcast(message, client_socket, clients): Broadcasts a message to all clients except the sender. with clients_lock: for client in clients: if client != client_socket: try: client.send(message.encode('utf-8')) except: client.close() clients.remove(client) def server_program(): Sets up the server and starts accepting client connections. server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server_socket.bind(('0.0.0.0', 12345)) server_socket.listen(10) print(\\"[SERVER STARTED] Waiting for clients to connect...\\") while True: client_socket, addr = server_socket.accept() with clients_lock: clients.add(client_socket) threading.Thread(target=handle_client, args=(client_socket, clients)).start() if __name__ == '__main__': clients = set() clients_lock = threading.Lock() server_program() def client_program(): Connects to the server, and sends and receives messages. client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client_socket.connect(('127.0.0.1', 12345)) def receive_messages(): while True: try: message = client_socket.recv(1024).decode('utf-8') if not message: break print(message) except: break client_socket.close() recv_thread = threading.Thread(target=receive_messages) recv_thread.start() try: while True: message = input() if message.lower() == 'exit': break client_socket.send(message.encode('utf-8')) except: pass finally: client_socket.close()","solution":"import socket import threading # Server code def handle_client(client_socket, clients): Handles communication with a client. addr = client_socket.getpeername() print(f\\"[NEW CONNECTION] {addr} connected.\\") while True: try: message = client_socket.recv(1024).decode('utf-8') if not message: break broadcast(message, client_socket, clients) except: break # Clean up client connection and notify other clients with clients_lock: clients.remove(client_socket) client_socket.close() broadcast(f\\"[DISCONNECTION] {addr} disconnected.\\", None, clients) print(f\\"[DISCONNECTION] {addr} disconnected.\\") def broadcast(message, client_socket, clients): Broadcasts a message to all clients except the sender. with clients_lock: for client in clients: if client != client_socket: try: client.send(message.encode('utf-8')) except: client.close() clients.remove(client) def server_program(): Sets up the server and starts accepting client connections. server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server_socket.bind(('0.0.0.0', 12345)) server_socket.listen(10) print(\\"[SERVER STARTED] Waiting for clients to connect...\\") while True: client_socket, addr = server_socket.accept() with clients_lock: clients.add(client_socket) threading.Thread(target=handle_client, args=(client_socket, clients)).start() if __name__ == '__main__': clients = set() clients_lock = threading.Lock() server_program() # Simple client code for testing (run this in separate terminal instances) def client_program(): Connects to the server, and sends and receives messages. client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client_socket.connect(('127.0.0.1', 12345)) def receive_messages(): while True: try: message = client_socket.recv(1024).decode('utf-8') if not message: break print(message) except: break client_socket.close() recv_thread = threading.Thread(target=receive_messages) recv_thread.start() try: while True: message = input() if message.lower() == 'exit': break client_socket.send(message.encode('utf-8')) except: pass finally: client_socket.close() if __name__ == '__main__': client_program()"},{"question":"def three_sum(nums: List[int]) -> List[List[int]]: Finds all unique triplets in the array which gives the sum of zero. >>> three_sum([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] >>> three_sum([1, 2, 3, 4, 5]) [] >>> three_sum([0, 0, 0, 0]) [[0, 0, 0]] >>> three_sum([1, -1, -1, 0]) [[-1, 0, 1]] >>> three_sum([-2, 0, 1, 1, 2]) [[-2, 0, 2], [-2, 1, 1]] >>> three_sum([-1, -1, 2, 2]) [[-1, -1, 2]]","solution":"def three_sum(nums): Finds all unique triplets in the array which gives the sum of zero. :param nums: List[int] - A list of integers :return: List[List[int]] - A list of unique triplets which sum to zero nums.sort() result = [] n = len(nums) for i in range(n-2): if i > 0 and nums[i] == nums[i-1]: continue left, right = i+1, n-1 while left < right: total = nums[i] + nums[left] + nums[right] if total == 0: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return result"},{"question":"def repeat_characters(s: str) -> str: Returns a new string where each character in the original string is repeated once. >>> repeat_characters(\\"hello\\") \\"hheelllloo\\" >>> repeat_characters(\\"Coding\\") \\"CCooddiinngg\\"","solution":"def repeat_characters(s): Returns a new string where each character in the original string is repeated once. result = \\"\\" for char in s: result += char * 2 return result"},{"question":"def group_by_digit_length(int_list): Groups integers by the number of their digits. Parameters: int_list (list of int): List of integers to be grouped. Returns: dict: A dictionary where keys are digit lengths and values are lists of integers with that digit length. Examples: >>> group_by_digit_length([1, 23, 456, 78, 9, 1234]) {1: [1, 9], 2: [23, 78], 3: [456], 4: [1234]} >>> group_by_digit_length([10, 20, 300, 4000]) {2: [10, 20], 3: [300], 4: [4000]}","solution":"def group_by_digit_length(int_list): Groups integers by the number of their digits. Parameters: int_list (list of int): List of integers to be grouped. Returns: dict: A dictionary where keys are digit lengths and values are lists of integers with that digit length. digit_dict = {} for num in int_list: digit_length = len(str(num)) if digit_length not in digit_dict: digit_dict[digit_length] = [] digit_dict[digit_length].append(num) return digit_dict"},{"question":"class Inventory: def __init__(self): self.inventory = {} def add_item(self, item: str, quantity: int) -> None: Adds a new item to the inventory with a specified quantity. >>> inv = Inventory() >>> inv.add_item('apple', 10) >>> inv.get_quantity('apple') 10 >>> inv.add_item('apple', 5) >>> inv.get_quantity('apple') 15 def remove_item(self, item: str) -> None: Removes an item completely from the inventory. >>> inv = Inventory() >>> inv.add_item('banana', 5) >>> inv.remove_item('banana') >>> inv.get_quantity('banana') 0 def update_quantity(self, item: str, quantity: int) -> None: Updates the quantity of an existing item (increase or decrease). >>> inv = Inventory() >>> inv.add_item('orange', 10) >>> inv.update_quantity('orange', -7) >>> inv.get_quantity('orange') 3 >>> inv.update_quantity('orange', -5) >>> inv.get_quantity('orange') 0 def get_quantity(self, item: str) -> int: Provides the current quantity of a specific item. >>> inv = Inventory() >>> inv.get_quantity('non_existing_item') 0 def get_items_below_threshold(self, threshold: int) -> list: Returns a list of all items whose quantity is below a specified threshold. >>> inv = Inventory() >>> inv.add_item('apple', 3) >>> inv.add_item('banana', 5) >>> inv.add_item('orange', 2) >>> inv.get_items_below_threshold(4) ['apple', 'orange'] >>> inv.get_items_below_threshold(6) ['apple', 'banana', 'orange']","solution":"class Inventory: def __init__(self): self.inventory = {} def add_item(self, item, quantity): if item in self.inventory: self.inventory[item] += quantity else: self.inventory[item] = quantity def remove_item(self, item): if item in self.inventory: del self.inventory[item] def update_quantity(self, item, quantity): if item in self.inventory: self.inventory[item] = max(0, self.inventory[item] + quantity) def get_quantity(self, item): return self.inventory.get(item, 0) def get_items_below_threshold(self, threshold): return [item for item, qty in self.inventory.items() if qty < threshold]"},{"question":"def longest_substring_k_distinct(s: str, k: int) -> int: Returns the length of the longest substring that contains at most k distinct characters. Args: s: str : input string consisting of lowercase English letters. k: int : maximum number of distinct characters allowed in the substring. Returns: int: length of the longest substring with at most k distinct characters. Example Usage: >>> longest_substring_k_distinct(\\"\\", 2) 0 >>> longest_substring_k_distinct(\\"abc\\", 0) 0 >>> longest_substring_k_distinct(\\"eceba\\", 2) 3 >>> longest_substring_k_distinct(\\"abcdef\\", 3) 3 >>> longest_substring_k_distinct(\\"aaaa\\", 1) 4 >>> longest_substring_k_distinct(\\"a\\", 1) 1 >>> longest_substring_k_distinct(\\"aaabbb\\", 10) 6","solution":"def longest_substring_k_distinct(s, k): Returns the length of the longest substring that contains at most k distinct characters. Args: s: str : input string consisting of lowercase English letters. k: int : maximum number of distinct characters allowed in the substring. Returns: int: length of the longest substring with at most k distinct characters. if k == 0 or not s: return 0 max_len = 0 char_count = {} left = 0 for right in range(len(s)): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def advanced_sort(lst): The task is to accept a list of tuples where each tuple contains a string and a number. Return the list sorted primarily by the string in alphabetical order, and secondarily by the number in descending order, in case of ties. Additionally, handle possible incorrect inputs like elements that are not tuples or tuples that do not follow the (string, number) format. >>> advanced_sort([('apple', 3), ('banana', 1), ('apple', 2), ('orange', 5)]) [('apple', 3), ('apple', 2), ('banana', 1), ('orange', 5)] >>> advanced_sort([('cat', 4), ('dog', 2), ('cat', 2), ('elephant', 5)]) [('cat', 4), ('cat', 2), ('dog', 2), ('elephant', 5)] >>> advanced_sort([('ball', 3), ('ball', 'two'), ('dog', 1)]) 'Error' >>> advanced_sort([('ball', 3), 'ball', ('dog', 1)]) 'Error' >>> advanced_sort([('ball', 3), (2, 'ball'), ('dog', 1)]) 'Error'","solution":"def advanced_sort(lst): The task is to accept a list of tuples where each tuple contains a string and a number. Return the list sorted primarily by the string in alphabetical order, and secondarily by the number in descending order, in case of ties. Additionally, handle possible incorrect inputs like elements that are not tuples or tuples that do not follow the (string, number) format. if not all(isinstance(item, tuple) and len(item) == 2 and isinstance(item[0], str) and isinstance(item[1], (int, float)) for item in lst): return \\"Error\\" # Sort the list primarily by the first element (string) and secondarily by the second element (number) in descending order return sorted(lst, key=lambda x: (x[0], -x[1]))"},{"question":"from typing import List def find_smallest_non_sum(arr: List[int]) -> int: Returns the smallest positive integer that is not the sum of a subset of the given array. >>> find_smallest_non_sum([1, 2, 3, 10]) == 7 >>> find_smallest_non_sum([1, 1, 1, 1]) == 5 >>> find_smallest_non_sum([1, 2, 2, 5]) == 11 >>> find_smallest_non_sum([]) == 1 >>> find_smallest_non_sum([1]) == 2 >>> find_smallest_non_sum([2]) == 1 >>> find_smallest_non_sum([2, 2, 2, 2]) == 1 >>> find_smallest_non_sum([10, 20, 30, 40]) == 1 >>> find_smallest_non_sum([1, 2, 3, 4, 5]) == 16 >>> find_smallest_non_sum([1, 2, 4, 8, 16]) == 32","solution":"from typing import List def find_smallest_non_sum(arr: List[int]) -> int: Returns the smallest positive integer that is not the sum of a subset of the given array. arr.sort() smallest_non_sum = 1 for num in arr: if num > smallest_non_sum: break smallest_non_sum += num return smallest_non_sum"},{"question":"from typing import List, Tuple, Dict def group_and_sort_scores(students_scores: List[Tuple[str, int]]) -> Dict[str, List[int]]: Takes a list of tuples containing student names and their scores, and returns a dictionary with unique student names as keys and lists of their scores sorted in ascending order as values. :param students_scores: List[Tuple[str, int]] :return: Dict[str, List[int]] >>> group_and_sort_scores([('Alice', 88)]) {'Alice': [88]} >>> group_and_sort_scores([('Alice', 90), ('Bob', 85)]) {'Alice': [90], 'Bob': [85]} >>> group_and_sort_scores([('Alice', 88), ('Bob', 72), ('Alice', 91), ('Charlie', 85), ('Bob', 78), ('Charlie', 82)]) {'Alice': [88, 91], 'Bob': [72, 78], 'Charlie': [82, 85]} >>> group_and_sort_scores([('Alice', 88), ('Alice', 92), ('Alice', 87)]) {'Alice': [87, 88, 92]} >>> group_and_sort_scores([]) {} >>> group_and_sort_scores([('Charlie', 70), ('Charlie', 90), ('Charlie', 60)]) {'Charlie': [60, 70, 90]}","solution":"def group_and_sort_scores(students_scores): Takes a list of tuples containing student names and their scores, and returns a dictionary with unique student names as keys and lists of their scores sorted in ascending order as values. :param students_scores: List[Tuple[str, int]] :return: Dict[str, List[int]] result = {} for student, score in students_scores: if student not in result: result[student] = [] result[student].append(score) # Sort the scores for each student for student in result: result[student].sort() return result"},{"question":"class BankAccount: A class that represents a Bank Account. Attributes: account_number (str): The account number of the bank account. account_holder_name (str): The name of the account holder. balance (float): The current balance of the account. Methods: deposit(amount): Deposits a specific amount to the account. withdraw(amount): Withdraws a specific amount from the account. compute_interest(interest_rate): Computes the interest on the current balance based on a specified interest rate. display_account_details(): Displays the account details. def __init__(self, account_number, account_holder_name, balance=0.0): pass def deposit(self, amount): pass def withdraw(self, amount): pass def compute_interest(self, interest_rate): pass def display_account_details(self): pass","solution":"class BankAccount: def __init__(self, account_number, account_holder_name, balance=0.0): self.account_number = account_number self.account_holder_name = account_holder_name self.balance = balance def deposit(self, amount): self.balance += amount def withdraw(self, amount): if amount <= self.balance: self.balance -= amount else: raise ValueError('Insufficient funds') def compute_interest(self, interest_rate): return self.balance * interest_rate / 100 def display_account_details(self): return { \\"account_number\\": self.account_number, \\"account_holder_name\\": self.account_holder_name, \\"balance\\": self.balance }"},{"question":"class Account: def __init__(self, account_number, customer_name): self.account_number = account_number self.customer_name = customer_name self.balance = 0.0 class SimpleBankingSystem: def __init__(self): self.accounts = {} self.next_account_number = 1 def create_account(self, customer_name): Create a new account with the given customer name. pass def check_balance(self, account_number): Check the balance of the account with the given account number. pass def deposit(self, account_number, amount): Deposit the given amount into the account with the given account number. pass def withdraw(self, account_number, amount): Withdraw the given amount from the account with the given account number. pass # Example usage: # bank = SimpleBankingSystem() # account_number = bank.create_account(\\"Alice\\") # print(\\"Account number:\\", account_number) # print(\\"Current balance:\\", bank.check_balance(account_number)) # bank.deposit(account_number, 500.00) # print(\\"New balance after deposit:\\", bank.check_balance(account_number)) # bank.withdraw(account_number, 100.00) # print(\\"New balance after withdrawal:\\", bank.check_balance(account_number))","solution":"class Account: def __init__(self, account_number, customer_name): self.account_number = account_number self.customer_name = customer_name self.balance = 0.0 class SimpleBankingSystem: def __init__(self): self.accounts = {} self.next_account_number = 1 def create_account(self, customer_name): account_number = f\\"A{self.next_account_number:06d}\\" self.accounts[account_number] = Account(account_number, customer_name) self.next_account_number += 1 return account_number def check_balance(self, account_number): account = self.accounts.get(account_number) if account: return account.balance else: raise ValueError(\\"Invalid account number\\") def deposit(self, account_number, amount): if amount <= 0: raise ValueError(\\"Deposit amount must be positive\\") account = self.accounts.get(account_number) if account: account.balance += amount return account.balance else: raise ValueError(\\"Invalid account number\\") def withdraw(self, account_number, amount): if amount <= 0: raise ValueError(\\"Withdraw amount must be positive\\") account = self.accounts.get(account_number) if account: if account.balance >= amount: account.balance -= amount return account.balance else: raise ValueError(\\"Insufficient funds\\") else: raise ValueError(\\"Invalid account number\\")"},{"question":"def merge_lists(list1, list2): Merges two lists into a new list containing tuples of elements from the respective positions of the original lists. Stops pairing once the end of the shortest list is reached. Returns an empty list if either of the lists is empty. >>> merge_lists([1, 2, 3], ['a', 'b', 'c']) [(1, 'a'), (2, 'b'), (3, 'c')] >>> merge_lists([1, 2, 3, 4], ['a', 'b', 'c']) [(1, 'a'), (2, 'b'), (3, 'c')] >>> merge_lists([1, 2, 3], ['a', 'b', 'c', 'd']) [(1, 'a'), (2, 'b'), (3, 'c')] >>> merge_lists([], ['a', 'b', 'c']) [] >>> merge_lists([1, 2, 3], []) [] >>> merge_lists([], []) []","solution":"def merge_lists(list1, list2): Merges two lists into a new list containing tuples of elements from the respective positions of the original lists. Stops pairing once the end of the shortest list is reached. Returns an empty list if either of the lists is empty. if not list1 or not list2: return [] min_length = min(len(list1), len(list2)) return [(list1[i], list2[i]) for i in range(min_length)]"},{"question":"def find_anagrams(str1: str, str2: str) -> bool: Returns whether str1 and str2 are anagrams of each other. An anagram is a rearrangement of the letters of one word to form another word. This function is case-sensitive. >>> find_anagrams('listen', 'silent') True >>> find_anagrams('Listen', 'Silent') False >>> find_anagrams('apple', 'apples') False >>> find_anagrams('', '') True >>> find_anagrams('a+b+c', 'c+b+a') True >>> find_anagrams('hello', 'world') False # Main program to prompt user for input and check for anagrams if __name__ == \\"__main__\\": str1 = input(\\"Enter the first string: \\") str2 = input(\\"Enter the second string: \\") if find_anagrams(str1, str2): print(f'\\"{str1}\\" and \\"{str2}\\" are anagrams.') else: print(f'\\"{str1}\\" and \\"{str2}\\" are not anagrams.')","solution":"def find_anagrams(str1, str2): Returns whether str1 and str2 are anagrams of each other. An anagram is a rearrangement of the letters of one word to form another word. This function is case-sensitive. # Convert both strings to lists of their characters list1 = list(str1) list2 = list(str2) # Sort the lists list1.sort() list2.sort() # Compare the sorted lists return list1 == list2 # Main program to prompt user for input and check for anagrams if __name__ == \\"__main__\\": str1 = input(\\"Enter the first string: \\") str2 = input(\\"Enter the second string: \\") if find_anagrams(str1, str2): print(f'\\"{str1}\\" and \\"{str2}\\" are anagrams.') else: print(f'\\"{str1}\\" and \\"{str2}\\" are not anagrams.')"},{"question":"import json from typing import Dict def calculate_average_grades(json_string: str) -> Dict[str, float]: Transforms a JSON string representing a record of student grades into a dictionary and calculates the average grade for each student. :param json_string: A JSON string of student grades :return: A dictionary with each student's name as a key and their average grade as the value >>> json_input = ''' [ {\\"name\\": \\"Alice\\", \\"math\\": 85, \\"science\\": 92, \\"english\\": 78}, {\\"name\\": \\"Bob\\", \\"math\\": 79, \\"science\\": 85, \\"english\\": 88}, {\\"name\\": \\"Charlie\\", \\"math\\": 92, \\"science\\": 90, \\"english\\": 85} ] ''' >>> calculate_average_grades(json_input) {'Alice': 85.0, 'Bob': 84.0, 'Charlie': 89.0} >>> json_input_varied = ''' [ {\\"name\\": \\"Dave\\", \\"math\\": 70, \\"science\\": 80, \\"english\\": 90, \\"history\\": 60}, {\\"name\\": \\"Eve\\", \\"math\\": 100, \\"science\\": 100, \\"english\\": 100} ] ''' >>> calculate_average_grades(json_input_varied) {'Dave': 75.0, 'Eve': 100.0} >>> json_input_single_student = ''' [ {\\"name\\": \\"Frank\\", \\"math\\": 78, \\"science\\": 82, \\"english\\": 88} ] ''' >>> calculate_average_grades(json_input_single_student) {'Frank': 82.66666666666667} >>> calculate_average_grades('[]') {}","solution":"import json def calculate_average_grades(json_string): Transforms a JSON string representing a record of student grades into a dictionary and calculates the average grade for each student. :param json_string: A JSON string of student grades :return: A dictionary with each student's name as a key and their average grade as the value student_records = json.loads(json_string) student_averages = {} for record in student_records: name = record.pop('name') grades = list(record.values()) average_grade = sum(grades) / len(grades) student_averages[name] = average_grade return student_averages"},{"question":"def combine_strings(strings): Combines multiple strings into a single sentence with proper capitalization and spacing. Ensures each string contains only alphabetic characters. Parameters: strings (list of str): list of input strings Returns: str: Combined sentence >>> combine_strings([\\"hello\\", \\"world\\"]) 'Hello World' >>> combine_strings([\\"this\\", \\"is\\", \\"a\\", \\"test\\"]) 'This Is A Test' >>> combine_strings([\\"one\\"]) 'One'","solution":"def combine_strings(strings): Combines multiple strings into a single sentence with proper capitalization and spacing. Ensures each string contains only alphabetic characters. Parameters: strings (list of str): list of input strings Returns: str: Combined sentence # Check for non-alphabetic characters in each string for s in strings: if not s.isalpha(): raise ValueError(f\\"String '{s}' contains non-alphabetic characters.\\") # Capitalize the first letter of each string capitalized_strings = [s.capitalize() for s in strings] return ' '.join(capitalized_strings)"},{"question":"class Library: def __init__(self): self.books = [] def add_book(self, title, author, isbn): Adds a new book to the library. pass def remove_book(self, isbn): Removes a book from the library by its ISBN number. pass def search_books(self, keyword): Searches for books by title or author containing the keyword. pass def display_books(self): Displays all books sorted by their title in alphabetical order. pass # Example usage: # library = Library() # library.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", \\"1234567890\\") # library.add_book(\\"1984\\", \\"George Orwell\\", \\"2345678901\\") # print(library.display_books()) # print(library.search_books(\\"George\\")) # library.remove_book(\\"1234567890\\") # print(library.display_books())","solution":"class Library: def __init__(self): self.books = [] def add_book(self, title, author, isbn): Adds a new book to the library. if not any(book['isbn'] == isbn for book in self.books): self.books.append({'title': title, 'author': author, 'isbn': isbn}) else: raise ValueError(\\"A book with the given ISBN already exists.\\") def remove_book(self, isbn): Removes a book from the library by its ISBN number. for book in self.books: if book['isbn'] == isbn: self.books.remove(book) return raise ValueError(\\"The book with the given ISBN does not exist.\\") def search_books(self, keyword): Searches for books by title or author containing the keyword. result = [book for book in self.books if keyword.lower() in book['title'].lower() or keyword.lower() in book['author'].lower()] return result def display_books(self): Displays all books sorted by their title in alphabetical order. return sorted(self.books, key=lambda book: book['title']) # Example usage: # library = Library() # library.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", \\"1234567890\\") # library.add_book(\\"1984\\", \\"George Orwell\\", \\"2345678901\\") # print(library.display_books()) # print(library.search_books(\\"George\\")) # library.remove_book(\\"1234567890\\") # print(library.display_books())"},{"question":"def find_pairs_with_sum(input_list: List[int], target_sum: int) -> List[Tuple[int, int]]: Returns a list of unique tuples with two distinct integers from the input list that add up to the target sum. >>> find_pairs_with_sum([2, 4, 3, 5, 7, 8], 9) [(2, 7), (4, 5)] >>> find_pairs_with_sum([1, 2, 3, 4], 10) []","solution":"def find_pairs_with_sum(input_list, target_sum): Returns a list of unique tuples with two distinct integers from the input list that add up to the target sum. seen = set() pairs = set() for number in input_list: complement = target_sum - number if complement in seen: pair = tuple(sorted((number, complement))) pairs.add(pair) seen.add(number) return list(pairs)"},{"question":"def is_prime(n: int) -> bool: Determines if a given positive integer is a prime number. A prime number is a number greater than 1 that has no positive divisors other than 1 and itself. Args: n (int): The integer to check for primality. Returns: bool: True if n is a prime number, False otherwise. >>> is_prime(1) False >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(17) True # Your code here # Unit Tests def test_is_prime_with_non_prime_numbers(): assert is_prime(1) == False # 1 is not a prime number assert is_prime(4) == False # 4 is divisible by 2 assert is_prime(6) == False # 6 is divisible by 2 and 3 assert is_prime(8) == False # 8 is divisible by 2 and 4 assert is_prime(9) == False # 9 is divisible by 3 def test_is_prime_with_prime_numbers(): assert is_prime(2) == True # 2 is a prime number assert is_prime(3) == True # 3 is a prime number assert is_prime(5) == True # 5 is a prime number assert is_prime(7) == True # 7 is a prime number assert is_prime(11) == True # 11 is a prime number def test_is_prime_with_large_prime_number(): assert is_prime(29) == True # 29 is a prime number def test_is_prime_with_large_non_prime_number(): assert is_prime(30) == False # 30 is divisible by 2, 3, 5 def test_is_prime_edge_cases(): assert is_prime(0) == False # 0 is not a prime number assert is_prime(-1) == False # Negative numbers are not prime # Testing the is_prime function with range 1 to 20 def test_is_prime_range(): results = [False, True, True, False, True, False, True, False, False, False, True, False, True, False, False, False, True, False, True, False] for num in range(1, 21): assert is_prime(num) == results[num-1]","solution":"def is_prime(n): Checks if a given positive integer n is a prime number. Args: n (int): The integer to check for primality. Returns: bool: True if n is a prime number, False otherwise. # Edge case: 1 is not a prime number if n <= 1: return False # Check for factors up to the square root of n # If n is divisible by any number other than 1 and itself, it's not a prime. for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True"},{"question":"def first_non_repeating_character(s: str) -> str: Given a string containing only lowercase alphabets, find the first non-repeating character. If there is no non-repeating character, return an empty string. >>> first_non_repeating_character(\\"swiss\\") == \\"w\\" >>> first_non_repeating_character(\\"abcdefg\\") == \\"a\\" >>> first_non_repeating_character(\\"aabbccdd\\") == \\"\\" >>> first_non_repeating_character(\\"\\") == \\"\\" >>> first_non_repeating_character(\\"aabbccd\\") == \\"d\\"","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the string s. If there is no non-repeating character, returns an empty string. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Find and return the first non-repeating character for char in s: if char_count[char] == 1: return char return \\"\\""},{"question":"def count_unique_elements(arrays: List[List[int]]) -> List[int]: Returns a list of counts of unique elements for each input array. Parameters: arrays (list of list of int): A list containing arrays of integers. Returns: list of int: A list containing the count of unique elements for each array. >>> count_unique_elements([[1, 2, 3, 4, 5]]) [5] >>> count_unique_elements([[1, 2, 2, 3], [4, 4, 4, 4], [1, 1, 2, 2]]) [3, 1, 2] >>> count_unique_elements([[], [], []]) [0, 0, 0] >>> count_unique_elements([[1, 2], [], [1, 1, 3, 4, 6, 6], [0, -1, -1, 0, 1]]) [2, 0, 4, 3] >>> count_unique_elements([[1], [2], [3], [4]]) [1, 1, 1, 1]","solution":"def count_unique_elements(arrays): Returns a list of counts of unique elements for each input array. Parameters: arrays (list of list of int): A list containing arrays of integers. Returns: list of int: A list containing the count of unique elements for each array. return [len(set(arr)) for arr in arrays]"},{"question":"def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: Merges two sorted lists into a single sorted list. >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([1, 2, 3], [4, 5, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_lists([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_lists([], []) [] >>> merge_sorted_lists([1, 1, 1], [1, 1, 1]) [1, 1, 1, 1, 1, 1] >>> merge_sorted_lists([-3, -1, 0, 2], [-2, 1, 3]) [-3, -2, -1, 0, 1, 2, 3]","solution":"def merge_sorted_lists(list1, list2): Merges two sorted lists into a single sorted list. Args: list1: A sorted list of integers. list2: A sorted list of integers. Returns: A merged sorted list of integers. merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"def single_number(arr: List[int]) -> int: Finds the element that appears exactly once in an array where every other element appears three times. >>> single_number([2, 2, 3, 2]) 3 >>> single_number([1]) 1 >>> single_number([-1, -1, -1, -50]) -50 >>> single_number([-1, -1, -1, 7]) 7 >>> single_number([42]*99999 + [13]) 13","solution":"def single_number(arr): Finds the element that appears exactly once in an array where every other element appears three times. ones, twos = 0, 0 for num in arr: # \`ones\` will hold the unique bits of all the numbers we have seen so far ones = (ones ^ num) & ~twos # \`twos\` will hold the bits that have appeared twice so far twos = (twos ^ num) & ~ones return ones"},{"question":"from typing import Dict, List def calculate_average_scores(user_scores: Dict[str, List[int]]) -> Dict[str, float]: Calculate the average score for each user. Parameters: user_scores (dict): A dictionary where keys are usernames (str) and values are lists of scores (int). Returns: dict: A dictionary where keys are usernames and values are the respective average scores. pass # Unit Tests import pytest def test_average_scores(): assert calculate_average_scores({\\"user1\\": [10, 20, 30], \\"user2\\": [5, 15, 25]}) == {\\"user1\\": 20.0, \\"user2\\": 15.0} def test_empty_user_scores(): assert calculate_average_scores({\\"user1\\": [], \\"user2\\": [5]}) == {\\"user1\\": 0, \\"user2\\": 5.0} def test_zero_scores(): assert calculate_average_scores({\\"user1\\": [0, 0, 0], \\"user2\\": [0]}) == {\\"user1\\": 0.0, \\"user2\\": 0.0} def test_non_integer_scores(): with pytest.raises(ValueError): calculate_average_scores({\\"user1\\": [1, \\"a\\", 3]}) def test_non_list_scores(): with pytest.raises(ValueError): calculate_average_scores({\\"user1\\": \\"not a list\\"}) def test_non_dict_input(): with pytest.raises(ValueError): calculate_average_scores([\\"this\\", \\"is\\", \\"not\\", \\"a\\", \\"dict\\"]) def test_single_user_single_score(): assert calculate_average_scores({\\"user1\\": [10]}) == {\\"user1\\": 10.0} def test_single_user_no_score(): assert calculate_average_scores({\\"user1\\": []}) == {\\"user1\\": 0} def test_empty_input(): assert calculate_average_scores({}) == {}","solution":"def calculate_average_scores(user_scores): Calculate the average score for each user. Parameters: user_scores (dict): A dictionary where keys are usernames (str) and values are lists of scores (int). Returns: dict: A dictionary where keys are usernames and values are the respective average scores. if not isinstance(user_scores, dict): raise ValueError(\\"Input should be a dictionary\\") averages = {} for user, scores in user_scores.items(): if not isinstance(user, str) or not isinstance(scores, list): raise ValueError(f\\"Invalid format for user {user}\\") if not all(isinstance(score, int) for score in scores): raise ValueError(f\\"All scores should be integers for user {user}\\") if len(scores) == 0: averages[user] = 0 else: averages[user] = sum(scores) / len(scores) return averages"},{"question":"def find_closest_pair(nums, target): Write a function called \`find_closest_pair\` that takes a list of integers and a target integer as input and returns the pair of integers from the list whose sum is closest to the target value. If multiple pairs have the same closest sum, return the first such pair found. >>> find_closest_pair([10, 22, 28, 29, 30, 40], 54) (22, 30) >>> find_closest_pair([1, 2], 3) (1, 2) >>> find_closest_pair([1, 2, 3, 4, 5], 7) (2, 5) >>> find_closest_pair([], 5) None >>> find_closest_pair([1], 2) None >>> find_closest_pair([-10, -5, 1, 3, 7], -2) (-5, 3) >>> find_closest_pair([0, 0, 0, 0], 0) (0, 0)","solution":"def find_closest_pair(nums, target): if not nums or len(nums) < 2: return None nums.sort() closest_pair = (None, None) min_diff = float('inf') left, right = 0, len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] current_diff = abs(current_sum - target) if current_diff < min_diff: min_diff = current_diff closest_pair = (nums[left], nums[right]) if current_sum < target: left += 1 else: right -= 1 return closest_pair"},{"question":"def is_unique(s: str) -> bool: Checks if all characters in the string are unique. >>> is_unique(\\"abc\\") True >>> is_unique(\\"aba\\") False >>> is_unique(\\"\\") True pass def can_concatenate(s1: str, s2: str) -> bool: Checks if two strings can be concatenated without having repeating characters. >>> can_concatenate(\\"abc\\", \\"def\\") True >>> can_concatenate(\\"abc\\", \\"cde\\") False >>> can_concatenate(\\"abc\\", \\"\\") True >>> can_concatenate(\\"\\", \\"def\\") True pass def get_longest_unique_concatenation(strings: list) -> str: Returns the longest string that can be made by concatenating unique characters from the list without repeating any character. >>> get_longest_unique_concatenation([\\"abc\\", \\"def\\", \\"ghi\\"]) \\"abcdefghi\\" >>> get_longest_unique_concatenation([\\"abc\\", \\"def\\", \\"ghi\\", \\"abcdefg\\"]) \\"abcdefghi\\" >>> get_longest_unique_concatenation([\\"ab\\", \\"cd\\", \\"ef\\", \\"ac\\"]) \\"cdefab\\" # order might vary >>> get_longest_unique_concatenation([]) \\"\\" >>> get_longest_unique_concatenation([\\"ab\\", \\"a\\", \\"abcdefg\\"]) \\"abcdefg\\" >>> get_longest_unique_concatenation([\\"aaa\\", \\"bbb\\", \\"ccc\\"]) \\"\\" >>> get_longest_unique_concatenation([\\"a\\", \\"bc\\", \\"def\\", \\"ghij\\"]) \\"defghijbc\\" # order might vary depending on combinations pass","solution":"def is_unique(s: str) -> bool: Checks if all characters in the string are unique. return len(s) == len(set(s)) def can_concatenate(s1: str, s2: str) -> bool: Checks if two strings can be concatenated without having repeating characters. return len(set(s1).intersection(set(s2))) == 0 def get_longest_unique_concatenation(strings: list) -> str: Returns the longest string that can be made by concatenating unique characters from the list without repeating any character. # Handle invalid input if not strings or not isinstance(strings, list) or any(not isinstance(s, str) for s in strings): return \\"\\" # Filter out strings that do not have all unique characters valid_strings = [s for s in strings if is_unique(s)] # Generate all combinations of valid strings and check their concatenation from itertools import combinations longest = \\"\\" for r in range(1, len(valid_strings) + 1): for combo in combinations(valid_strings, r): concat = ''.join(combo) if is_unique(concat) and len(concat) > len(longest): longest = concat return longest"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a string arithmetic expression involving +, -, *, / and parentheses. The function should handle integer and floating-point numbers and ensure that the division by zero is properly managed by raising an appropriate exception. Parameters: expression (str): The arithmetic expression to evaluate. Returns: float: The result of evaluating the expression. Raises: ZeroDivisionError: If there is a division by zero in the expression. >>> evaluate_expression(\\"3+5\\") 8.0 >>> evaluate_expression(\\"10-2\\") 8.0 >>> evaluate_expression(\\"6*3\\") 18.0 >>> evaluate_expression(\\"8/2\\") 4.0 >>> evaluate_expression(\\"3+5*2\\") 13.0 >>> evaluate_expression(\\"(3+5)*2\\") 16.0 >>> evaluate_expression(\\"10+(2*5)\\") 20.0 >>> evaluate_expression(\\"10-2/2\\") 9.0 >>> evaluate_expression(\\"3.5+2.1\\") 5.6 >>> evaluate_expression(\\"10-7.5\\") 2.5 >>> evaluate_expression(\\"6*0.5\\") 3.0 >>> evaluate_expression(\\"8/4\\") 2.0 >>> evaluate_expression(\\"3/0\\") ZeroDivisionError: division by zero >>> evaluate_expression(\\"3+(2*2)\\") 7.0 >>> evaluate_expression(\\"(3+2)*2\\") 10.0 >>> evaluate_expression(\\"10/(5-3)\\") 5.0 >>> evaluate_expression(\\"5+6-3*2/1\\") 5.0 >>> evaluate_expression(\\"10+3*5/(16-4)\\") 11.25 >>> evaluate_expression(\\"10/(3*2-4)\\") 5.0","solution":"import math def evaluate_expression(expression): Evaluates a string arithmetic expression involving +, -, *, / and parenthesis. Parameters: expression (str): The arithmetic expression to evaluate Returns: float: The result of evaluating the expression. Raises: ZeroDivisionError: If there is a division by zero in the expression. def parse_expression(expression): Parse an expression into tokens for easier handling number = '' tokens = [] for char in expression: if char in '0123456789.': number += char else: if number: tokens.append(float(number)) number = '' if char in '+-*/()': tokens.append(char) if number: tokens.append(float(number)) return tokens def apply_operator(operators, values): Apply an operator to the top of the value stack operator = operators.pop() right = values.pop() left = values.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) elif operator == '/': if right == 0: raise ZeroDivisionError(\\"division by zero\\") values.append(left / right) def precedence(operator): Return the precedence of an operator if operator in '+-': return 1 if operator in '*/': return 2 return 0 tokens = parse_expression(expression) operators = [] values = [] for token in tokens: if isinstance(token, float): values.append(token) elif token == '(': operators.append(token) elif token == ')': while operators and operators[-1] != '(': apply_operator(operators, values) operators.pop() # popping the '(' else: while (operators and precedence(operators[-1]) >= precedence(token)): apply_operator(operators, values) operators.append(token) while operators: apply_operator(operators, values) return values[0]"},{"question":"def reverse_string(s: str) -> str: Returns the given string reversed. >>> reverse_string(\\"hello\\") \\"olleh\\" >>> reverse_string(\\"\\") \\"\\" >>> reverse_string(\\"a\\") \\"a\\" >>> reverse_string(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\") \\"ZYXWVUTSRQPONMLKJIHGFEDCBA\\" >>> reverse_string(\\"1234567890\\") \\"0987654321\\" >>> reverse_string(\\"racecar\\") \\"racecar\\" # Palindrome test","solution":"def reverse_string(s): Returns the given string reversed. return s[::-1] # Explanation: # The original function had logical errors. The primary issues were: # 1. The for-loop range was set to len(s) + 1 which would cause an IndexError. # 2. The loop was trying to concatenate the next character of the string instead of constructing it in reverse. # # The corrected version uses string slicing to reverse the string which is more efficient and concise. # # Time complexity: O(n), where n is the length of the string. # Space complexity: O(n), where n is the length of the string, for storing the reversed string."},{"question":"def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: Merges two sorted lists into a single sorted list. >>> merge_sorted_lists([], []) == [] >>> merge_sorted_lists([], [1, 2, 3]) == [1, 2, 3] >>> merge_sorted_lists([1, 2, 3], []) == [1, 2, 3] >>> merge_sorted_lists([1, 2, 3], [4, 5, 6]) == [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([1], [2]) == [1, 2] >>> merge_sorted_lists([2], [1]) == [1, 2] >>> merge_sorted_lists([1, 3, 3], [2, 3, 4]) == [1, 2, 3, 3, 3, 4] >>> merge_sorted_lists(list(range(0, 10000, 2)), list(range(1, 10000, 2))) == list(range(10000))","solution":"def merge_sorted_lists(list1, list2): Merges two sorted lists into a single sorted list. merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # Add remaining elements from list1 while i < len(list1): merged_list.append(list1[i]) i += 1 # Add remaining elements from list2 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"from typing import List def normalize(values: List[float]) -> List[float]: Normalizes a list of numerical values to the range [0, 1]. Args: values (List[float]): A list of numerical values to be normalized. Returns: List[float]: A new list with values normalized to the range [0, 1]. >>> normalize([10, 20, 30, 40, 50]) [0.0, 0.25, 0.5, 0.75, 1.0] >>> normalize([]) [] >>> normalize([42]) [0.0] >>> normalize([5, 5, 5, 5]) [0.0, 0.0, 0.0, 0.0] >>> normalize([-50, -25, 0, 25, 50]) [0.0, 0.25, 0.5, 0.75, 1.0] >>> normalize([2.5, 5.0, 7.5]) [0.0, 0.5, 1.0] >>> normalize([-10, -5, 0, 5, 10]) [0.0, 0.25, 0.5, 0.75, 1.0] >>> normalize([100, 200, 300, 400, 500]) [0.0, 0.25, 0.5, 0.75, 1.0]","solution":"from typing import List def normalize(values: List[float]) -> List[float]: Normalizes a list of numerical values to the range [0, 1]. Args: values (List[float]): A list of numerical values to be normalized. Returns: List[float]: A new list with values normalized to the range [0, 1]. if not values: return [] min_value = min(values) max_value = max(values) # If all values in list are the same, return a list with zeros if min_value == max_value: return [0.0] * len(values) normalized_values = [(value - min_value) / (max_value - min_value) for value in values] return normalized_values"},{"question":"from typing import List def lengthOfLIS(nums: List[int]) -> int: Returns the length of the longest strict increasing subsequence of nums. >>> lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> lengthOfLIS([0, 1, 0, 3, 2, 3]) 4 def test_example1(): assert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4 def test_example2(): assert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4 def test_single_element(): assert lengthOfLIS([10]) == 1 def test_decreasing_order(): assert lengthOfLIS([5, 4, 3, 2, 1]) == 1 def test_all_same_elements(): assert lengthOfLIS([2, 2, 2, 2, 2]) == 1 def test_ascending_order(): assert lengthOfLIS([1, 2, 3, 4, 5]) == 5 def test_empty_list(): assert lengthOfLIS([]) == 0 def test_mixed_sign_numbers(): assert lengthOfLIS([-1, 2, 3, -2, 5, -3, 6]) == 5","solution":"def lengthOfLIS(nums): Returns the length of the longest strict increasing subsequence of nums. if not nums: return 0 n = len(nums) dp = [1] * n # Initialize the dp array with 1s for i in range(1, n): for j in range(0, i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"import requests from typing import Tuple def process_weather_data(api_key: str, city_id: str) -> Tuple[float, str]: Processes weather information to determine the average temperature for the next 7 days and identifies the day with the highest predicted rainfall. Parameters: api_key (str): API key for the weather API city_id (str): City ID to get the weather information for Returns: tuple: (average_temperature, day_with_highest_rainfall) # Make a request to the weather API response = requests.get(f\\"https://api.openweathermap.org/data/2.5/forecast?id={city_id}&appid={api_key}&units=metric\\") # Handle potential response errors if response.status_code != 200: raise Exception(\\"Failed to retrieve data from the weather API\\") weather_data = response.json() total_temperature = 0 total_days = 0 highest_rainfall = 0 day_with_highest_rainfall = None for entry in weather_data.get('list', []): try: date = entry['dt_txt'][:10] # Extract date (YYYY-MM-DD) temperature = entry['main']['temp'] rainfall = entry.get('rain', {}).get('3h', 0) if rainfall > highest_rainfall: highest_rainfall = rainfall day_with_highest_rainfall = date total_temperature += temperature total_days += 1 except (KeyError, TypeError, ValueError) as e: # Handle missing or corrupted data entries gracefully print(f\\"Data anomaly encountered: {e}, skipping entry\\") average_temperature = total_temperature / total_days if total_days > 0 else 0 return average_temperature, day_with_highest_rainfall # Unit Test def test_process_weather_data(monkeypatch): class MockResponse: @staticmethod def json(): return { \\"list\\": [ {\\"dt_txt\\": \\"2022-10-01 12:00:00\\", \\"main\\": {\\"temp\\": 15}, \\"rain\\": {\\"3h\\": 2}}, {\\"dt_txt\\": \\"2022-10-02 12:00:00\\", \\"main\\": {\\"temp\\": 16}, \\"rain\\": {\\"3h\\": 3}}, {\\"dt_txt\\": \\"2022-10-03 12:00:00\\", \\"main\\": {\\"temp\\": 17}, \\"rain\\": {\\"3h\\": 5}}, {\\"dt_txt\\": \\"2022-10-04 12:00:00\\", \\"main\\": {\\"temp\\": 18}}, {\\"dt_txt\\": \\"2022-10-05 12:00:00\\", \\"main\\": {\\"temp\\": 19}, \\"rain\\": {\\"3h\\": 1}}, {\\"dt_txt\\": \\"2022-10-06 12:00:00\\", \\"main\\": {\\"temp\\": 20}, \\"rain\\": {\\"3h\\": 4}}, {\\"dt_txt\\": \\"2022-10-07 12:00:00\\", \\"main\\": {\\"temp\\": 21}, \\"rain\\": {\\"3h\\": 2}} ] } @property def status_code(self): return 200 def mock_get(*args, **kwargs): return MockResponse() monkeypatch.setattr(\\"requests.get\\", mock_get) api_key = \\"fake_api_key\\" city_id = \\"fake_city_id\\" avg_temp, day_with_highest_rainfall = process_weather_data(api_key, city_id) assert avg_temp == 18 assert day_with_highest_rainfall == \\"2022-10-03\\" def test_process_weather_data_with_anomalies(monkeypatch): class MockResponse: @staticmethod def json(): return { \\"list\\": [ {\\"dt_txt\\": \\"2022-10-01 12:00:00\\", \\"main\\": {\\"temp\\": 15}, \\"rain\\": {\\"3h\\": 2}}, {\\"dt_txt\\": \\"2022-10-02 12:00:00\\", \\"main\\": {\\"temp\\": 16}, \\"rain\\": {\\"3h\\": 3}}, {\\"dt_txt\\": \\"2022-10-03 12:00:00\\", \\"main\\": {\\"temp\\": 17}, \\"rain\\": {\\"3h\\": 5}}, {\\"dt_txt\\": \\"2022-10-04 12:00:00\\", \\"main\\": {\\"temp\\": 18}, \\"rain\\": {\\"3h\\": \\"NaN\\"}}, # Corrupted rain data {\\"dt_txt\\": \\"2022-10-05 12:00:00\\", \\"main\\": {\\"temp\\": 19}}, # Missing rain data {\\"dt_txt\\": \\"2022-10-06 12:00:00\\", \\"main\\": {\\"temp\\": 20, \\"incorrect_key\\": \\"value\\"}}, # Corrupted data {\\"dt_txt\\": \\"2022-10-07 12:00:00\\", \\"main\\": {\\"temp\\": 21}, \\"rain\\": {\\"3h\\": 2}} ] } @property def status_code(self): return 200 def mock_get(*args, **kwargs): return MockResponse() monkeypatch.setattr(\\"requests.get\\", mock_get) api_key = \\"fake_api_key\\" city_id = \\"fake_city_id\\" avg_temp, day_with_highest_rainfall = process_weather_data(api_key, city_id) assert avg_temp == 18 assert day_with_highest_rainfall == \\"2022-10-03\\"","solution":"import requests import json def process_weather_data(api_key, city_id): Processes weather information to determine the average temperature for the next 7 days and identifies the day with the highest predicted rainfall. Parameters: api_key (str): API key for the weather API city_id (str): City ID to get the weather information for Returns: tuple: (average_temperature, day_with_highest_rainfall) # Get weather data response = requests.get(f\\"https://api.openweathermap.org/data/2.5/forecast?id={city_id}&appid={api_key}&units=metric\\") # Handle potential request errors if response.status_code != 200: raise Exception(\\"Failed to retrieve data from the weather API\\") weather_data = response.json() # Initialize variables total_temperature = 0 total_days = 0 highest_rainfall = 0 day_with_highest_rainfall = None # Process weather data for entry in weather_data.get('list', []): try: date = entry['dt_txt'][:10] # Extract date (YYYY-MM-DD) temperature = entry['main']['temp'] rainfall = entry.get('rain', {}).get('3h', 0) if rainfall > highest_rainfall: highest_rainfall = rainfall day_with_highest_rainfall = date total_temperature += temperature total_days += 1 except (KeyError, TypeError, ValueError) as e: # Handle missing or corrupted data entries gracefully print(f\\"Data anomaly encountered: {e}, skipping entry\\") # Determine average temperature average_temperature = total_temperature / total_days if total_days > 0 else 0 return average_temperature, day_with_highest_rainfall"},{"question":"import string def is_palindrome(s: str) -> bool: Checks whether the given string is a palindrome, ignoring case, spaces, and punctuation. Args: s (str): The input string to be checked. Returns: bool: True if the string is a palindrome, False otherwise. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") == True >>> is_palindrome(\\"No lemon, no melon\\") == True >>> is_palindrome(\\"Level\\") == True >>> is_palindrome(\\"Hello, World!\\") == False >>> is_palindrome(\\"\\") == True >>> is_palindrome(\\"@@!\\") == True >>> is_palindrome(\\".,.!\\") == True # Empty string after filtering non-alphanumeric chars","solution":"import string def is_palindrome(s): Checks whether the given string is a palindrome, ignoring case, spaces, and punctuation. Args: s (str): The input string to be checked. Returns: bool: True if the string is a palindrome, False otherwise. s = s.lower() s = ''.join(e for e in s if e.isalnum()) return s == s[::-1]"},{"question":"def longest_common_subsequence(str1: str, str2: str) -> tuple: Find and return the longest common subsequence (LCS) of two strings and its length. Parameters: str1 (str): The first string. str2 (str): The second string. Returns: tuple: The LCS string and its length. Examples: >>> longest_common_subsequence(\\"AGGTAB\\", \\"GXTXAYB\\") (\\"GTAB\\", 4) >>> longest_common_subsequence(\\"ABC\\", \\"DEF\\") (\\"\\", 0) >>> longest_common_subsequence(\\"HELLO\\", \\"HELLO\\") (\\"HELLO\\", 5) >>> longest_common_subsequence(\\"\\", \\"HELLO\\") (\\"\\", 0) >>> longest_common_subsequence(\\"WORLD\\", \\"\\") (\\"\\", 0) >>> longest_common_subsequence(\\"ABCD\\", \\"ABXY\\") (\\"AB\\", 2) >>> longest_common_subsequence(\\"ABCD\\", \\"XYCD\\") (\\"CD\\", 2)","solution":"def longest_common_subsequence(str1, str2): Find and return the longest common subsequence (LCS) of two strings and its length. Parameters: str1 (str): The first string. str2 (str): The second string. Returns: tuple: The LCS string and its length. # Create a matrix to store the lengths of LCS m, n = len(str1), len(str2) dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp matrix for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Reconstruct the LCS from the dp matrix index = dp[m][n] lcs = [\\"\\"] * index i, j = m, n while i > 0 and j > 0: if str1[i - 1] == str2[j - 1]: lcs[index - 1] = str1[i - 1] i -= 1 j -= 1 index -= 1 elif dp[i - 1][j] > dp[i][j - 1]: i -= 1 else: j -= 1 lcs_string = \\"\\".join(lcs) return lcs_string, len(lcs_string)"},{"question":"import math def logistic_regression_probability(satisfaction_level, last_evaluation_score, num_projects, avg_monthly_hours, time_spent_at_company, work_accident, promotion_last_5_years): Calculate the probability of an employee leaving the company using the logistic regression model. :param satisfaction_level: Satisfaction level of the employee. :param last_evaluation_score: Last evaluation score of the employee. :param num_projects: Number of projects the employee is involved in. :param avg_monthly_hours: Average monthly hours the employee works. :param time_spent_at_company: Number of years the employee has been at the company. :param work_accident: Whether the employee had a work accident (1 if yes, 0 if no). :param promotion_last_5_years: Whether the employee got a promotion in the last 5 years (1 if yes, 0 if no). :return: Probability of the employee leaving the company. >>> logistic_regression_probability(0.5, 0.7, 3, 150, 3, 0, 1) def test_logistic_regression_probability(): # Test case based on given example row and checking the calculated probability probability = logistic_regression_probability( satisfaction_level=0.5, last_evaluation_score=0.7, num_projects=3, avg_monthly_hours=150, time_spent_at_company=3, work_accident=0, promotion_last_5_years=1 ) expected_probability = 1 / (1 + math.exp(-(-1.25 + (-3.1 * 0.5) + (0.8 * 0.7) + (0.5 * 3) + (0.01 * 150) + (0.2 * 3) + (-0.5 * 0) + (-0.3 * 1)))) assert math.isclose(probability, expected_probability, rel_tol=1e-9)","solution":"import math def logistic_regression_probability(satisfaction_level, last_evaluation_score, num_projects, avg_monthly_hours, time_spent_at_company, work_accident, promotion_last_5_years): Calculate the probability of an employee leaving the company using the logistic regression model. :param satisfaction_level: Satisfaction level of the employee. :param last_evaluation_score: Last evaluation score of the employee. :param num_projects: Number of projects the employee is involved in. :param avg_monthly_hours: Average monthly hours the employee works. :param time_spent_at_company: Number of years the employee has been at the company. :param work_accident: Whether the employee had a work accident (1 if yes, 0 if no). :param promotion_last_5_years: Whether the employee got a promotion in the last 5 years (1 if yes, 0 if no). :return: Probability of the employee leaving the company. # Coefficients from the logistic regression model intercept = -1.25 coeffs = { \\"satisfaction_level\\": -3.1, \\"last_evaluation_score\\": 0.8, \\"num_projects\\": 0.5, \\"avg_monthly_hours\\": 0.01, \\"time_spent_at_company\\": 0.2, \\"work_accident\\": -0.5, \\"promotion_last_5_years\\": -0.3 } # Calculate linear combination (z) z = (intercept + coeffs[\\"satisfaction_level\\"] * satisfaction_level + coeffs[\\"last_evaluation_score\\"] * last_evaluation_score + coeffs[\\"num_projects\\"] * num_projects + coeffs[\\"avg_monthly_hours\\"] * avg_monthly_hours + coeffs[\\"time_spent_at_company\\"] * time_spent_at_company + coeffs[\\"work_accident\\"] * work_accident + coeffs[\\"promotion_last_5_years\\"] * promotion_last_5_years) # Calculate the probability using the sigmoid function probability = 1 / (1 + math.exp(-z)) return probability # Example row from the dataset probability = logistic_regression_probability( satisfaction_level=0.5, last_evaluation_score=0.7, num_projects=3, avg_monthly_hours=150, time_spent_at_company=3, work_accident=0, promotion_last_5_years=1 ) print(f\\"Probability of the employee leaving the company: {probability}\\")"},{"question":"def find_pairs_with_sum(numbers: List[int], k: int) -> List[Tuple[int, int]]: Finds all unique pairs of integers from the list that sum up to k. Each pair is returned as a tuple sorted in non-decreasing order, and the list of pairs is sorted in lexicographical order. >>> find_pairs_with_sum([1, 5, 3, 7, 9, 2], 10) [(1, 9), (3, 7)] >>> find_pairs_with_sum([2, 2, 4, 4], 6) [(2, 4)] >>> find_pairs_with_sum([1, 2, 3, 4], 8) [] >>> find_pairs_with_sum([1, -1, 2, -2, 3, 0], 0) [(-2, 2), (-1, 1)] >>> find_pairs_with_sum([1, 9, 1, 9, 8, 2], 10) [(1, 9), (2, 8)] >>> find_pairs_with_sum([5], 10) [] >>> find_pairs_with_sum([-3, 1, 2, 5, -2, 3, 4], 1) [(-3, 4), (-2, 3)]","solution":"def find_pairs_with_sum(numbers, k): Finds all unique pairs of integers from the list that sum up to k. Each pair is returned as a tuple sorted in non-decreasing order, and the list of pairs is sorted in lexicographical order. :param numbers: List of integers. :param k: Target sum integer. :return: List of unique pairs (tuples) that sum up to k. pairs = set() seen = set() for num in numbers: complement = k - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return sorted(pairs)"},{"question":"def get_top_students(students: dict) -> list: Given a dictionary that represents a collection of student names and their corresponding scores in a class, return the names of students whose scores are at or above the average score of the class. The output should be a list of names sorted in descending order of their scores. If multiple students have the same score, their names should appear in alphabetical order. :param students: Dictionary containing student names as keys and scores as values :return: List of student names sorted based on criteria Example: >>> students = { ... 'Alice': 78, ... 'Bob': 92, ... 'Charlie': 87, ... 'David': 94, ... 'Eva': 65, ... 'Frank': 78, ... 'Grace': 84 ... } >>> get_top_students(students) ['David', 'Bob', 'Charlie', 'Grace'] pass # Example usage and test data students = { 'Alice': 78, 'Bob': 92, 'Charlie': 87, 'David': 94, 'Eva': 65, 'Frank': 78, 'Grace': 84 } print(get_top_students(students)) # Should print: ['David', 'Bob', 'Charlie', 'Grace'] def test_get_top_students(): students = { 'Alice': 78, 'Bob': 92, 'Charlie': 87, 'David': 94, 'Eva': 65, 'Frank': 78, 'Grace': 84 } assert get_top_students(students) == ['David', 'Bob', 'Charlie', 'Grace'] def test_all_equal_scores(): students = { 'Alice': 80, 'Bob': 80, 'Charlie': 80, 'David': 80 } assert get_top_students(students) == ['Alice', 'Bob', 'Charlie', 'David'] def test_one_student(): students = { 'Alice': 100 } assert get_top_students(students) == ['Alice'] def test_no_students_above_average(): students = { 'Alice': 50, 'Bob': 50, 'Charlie': 50 } assert get_top_students(students) == ['Alice', 'Bob', 'Charlie'] def test_some_students_below_average(): students = { 'Alice': 60, 'Bob': 70, 'Charlie': 80, 'David': 90 } assert get_top_students(students) == ['David', 'Charlie'] def test_tie_scores(): students = { 'Alice': 85, 'Bob': 85, 'Charlie': 70, 'David': 90 } assert get_top_students(students) == ['David', 'Alice', 'Bob']","solution":"def get_top_students(students): Returns a list of student names whose scores are at or above the average score, sorted in descending order of their scores. In case of ties, names are sorted alphabetically. :param students: Dictionary containing student names as keys and scores as values :return: List of student names sorted based on criteria # Calculate the average score avg_score = sum(students.values()) / len(students) # Filter students whose scores are at or above the average top_students = {name: score for name, score in students.items() if score >= avg_score} # Sort the students first by score in descending order, then by name alphabetically sorted_top_students = sorted(top_students.items(), key=lambda x: (-x[1], x[0])) # Extract and return the names from the sorted list of tuples result = [name for name, score in sorted_top_students] return result"},{"question":"def remove_duplicates(num_list): Removes duplicates from a list of integers, preserving order of first occurrences. Args: num_list (list): List of integers Returns: List of integers with duplicates removed Raises: TypeError: If input is not a list or contains non-integer values pass import pytest def test_remove_duplicates_with_valid_list(): assert remove_duplicates([1, 2, 2, 3, 4, 5, 5, 6, 7, 8, 8, 9, 10]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] assert remove_duplicates([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] assert remove_duplicates([10, 9, 8, 8, 7, 6, 5, 5, 4, 3, 2, 1]) == [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] def test_remove_duplicates_with_empty_list(): assert remove_duplicates([]) == [] def test_remove_duplicates_with_single_element_list(): assert remove_duplicates([1]) == [1] def test_remove_duplicates_with_invalid_input(): with pytest.raises(TypeError): remove_duplicates(\\"not a list\\") with pytest.raises(TypeError): remove_duplicates(12345) with pytest.raises(TypeError): remove_duplicates([1, 2, 3, \\"four\\", 5]) def test_remove_duplicates_with_mixed_valid_elements(): assert remove_duplicates([1, 1, 1, 2, 3, 3, 3, 4, 5, 5]) == [1, 2, 3, 4, 5]","solution":"def remove_duplicates(num_list): Removes duplicates from a list of integers, preserving order of first occurrences. Args: num_list (list): List of integers Returns: List of integers with duplicates removed Raises: TypeError: If input is not a list or contains non-integer values if not isinstance(num_list, list): raise TypeError(\\"Input should be a list\\") if not all(isinstance(num, int) for num in num_list): raise TypeError(\\"All elements in the list should be integers\\") result = [] for num in num_list: if num not in result: result.append(num) return result"},{"question":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Write a function that takes an array of integers and a target value as input and returns the indices of the two numbers that add up to the target value. The function should assume that each input would have exactly one solution and may not reuse the same element twice. Ensure the solution has a time complexity of O(n). Args: nums: List[int] - List of integers. target: int - The target value to find the sum. Returns: List[int] - Indices of the two numbers. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 3], 6) [0, 1] >>> two_sum([0, 4, 3, 0], 0) [0, 3] >>> two_sum([-3, 4, 3, 90], 0) [0, 2] >>> two_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 19) [8, 9]","solution":"def two_sum(nums, target): Returns the indices of the two numbers that add up to the target value. Args: nums: List[int] - List of integers. target: int - The target value to find the sum. Returns: List[int] - Indices of the two numbers. num_to_index = {} for index, number in enumerate(nums): complement = target - number if complement in num_to_index: return [num_to_index[complement], index] num_to_index[number] = index"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxDepth(root): Returns the maximum depth of a binary tree. >>> tree = TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))) >>> maxDepth(tree) 3 >>> tree = None >>> maxDepth(tree) 0 >>> tree = TreeNode(1, None, TreeNode(2)) >>> maxDepth(tree) 2 >>> tree = TreeNode(0) >>> maxDepth(tree) 1 >>> tree = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4)))) >>> maxDepth(tree) 4 >>> tree = TreeNode(1, None, TreeNode(2, None, TreeNode(3, None, TreeNode(4)))) >>> maxDepth(tree) 4 >>> tree = TreeNode(1, TreeNode(2), TreeNode(3)) >>> maxDepth(tree) 2","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxDepth(root): Returns the maximum depth of a binary tree. if not root: return 0 left_depth = maxDepth(root.left) right_depth = maxDepth(root.right) return max(left_depth, right_depth) + 1"},{"question":"def merge_sort(arr): Sorts a list of integers using the Merge Sort algorithm, implemented using recursion without any helper functions or built-in sort methods. >>> merge_sort([]) == [] >>> merge_sort([1]) == [1] >>> merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] >>> merge_sort([2, 3, 1, 4, 2, 2, 1]) == [1, 1, 2, 2, 2, 3, 4]","solution":"def merge_sort(arr): Sorts a list of integers using the Merge Sort algorithm. if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left, right): Merges two sorted lists into one sorted list. if not left: return right if not right: return left if left[0] <= right[0]: return [left[0]] + merge(left[1:], right) else: return [right[0]] + merge(left, right[1:])"},{"question":"def sum_of_squares_of_even(lst: List[int]) -> int: Returns the sum of the squares of only the even numbers in the list. >>> sum_of_squares_of_even([2, 4, 6]) == 56 >>> sum_of_squares_of_even([1, 2, 3, 4, 5, 6]) == 56 >>> sum_of_squares_of_even([1, 3, 5]) == 0 >>> sum_of_squares_of_even([]) == 0 pass def sum_of_squares(lst: List[int]) -> int: Returns the sum of the squares of only the even numbers in the list. >>> sum_of_squares([2, 4, 6]) == 56 >>> sum_of_squares([1, 2, 3, 4, 5, 6]) == 56 >>> sum_of_squares([1, 3, 5]) == 0 >>> sum_of_squares([]) == 0 pass","solution":"def sum_of_squares_of_even(lst): Returns the sum of the squares of only the even numbers in the list. return sum(x ** 2 for x in lst if x % 2 == 0) # Fixed version of the erroneous code def sum_of_squares(lst): Returns the sum of the squares of only the even numbers in the list. total = 0 for num in lst: if num % 2 == 0: total += num ** 2 return total # Example usage numbers = [1, 2, 3, 4, 5, 6] print(sum_of_squares(numbers)) # Output: 56"},{"question":"def min_coins(coins: List[int], amount: int) -> int: Returns the minimum number of coins required to make the given amount using the provided coin denominations. >>> min_coins([1, 2, 5], 11) == 3 # 11 can be made with 5+5+1 >>> min_coins([2], 3) == -1 # Cannot make amount 3 with coin 2 >>> min_coins([1], 0) == 0 # 0 coins needed to make amount 0 >>> min_coins([1], 1) == 1 # 1 coin of 1 needed >>> min_coins([1], 2) == 2 # 2 coins of 1 needed >>> min_coins([1, 3, 4], 6) == 2 # 6 can be made with 3+3 >>> min_coins([1, 2, 5], 100) == 20 # 100 can be made with 20 coins of 5 >>> min_coins([1, 7, 10], 14) == 2 # 14 can be made with 7+7 pass","solution":"def min_coins(coins, amount): Returns the minimum number of coins required to make the given amount using the provided coin denominations. :param coins: List of coin denominations :param amount: The amount of money :return: Minimum number of coins required, or -1 if it is not possible to make the amount # Create a list to store the solution to sub-problems dp = [float('inf')] * (amount + 1) # Base case: 0 coins are needed to make the amount 0 dp[0] = 0 # Solve the problem for all amounts from 1 to amount for i in range(1, amount + 1): for coin in coins: if i - coin >= 0: dp[i] = min(dp[i], dp[i - coin] + 1) # If dp[amount] is still infinity, it means we cannot make the amount return dp[amount] if dp[amount] != float('inf') else -1"},{"question":"class Customer: Represents a customer in the e-commerce system. Attributes: - customer_id: int - name: str - email: str def __init__(self, customer_id: int, name: str, email: str): self.customer_id = customer_id self.name = name self.email = email class Product: Represents a product in the e-commerce system. Attributes: - product_id: int - name: str - price: float def __init__(self, product_id: int, name: str, price: float): self.product_id = product_id self.name = name self.price = price class Order: Represents an order in the e-commerce system. Attributes: - order_id: int - customer: Customer - products: List[Product] - total_amount: float def __init__(self, order_id: int, customer: Customer): self.order_id = order_id self.customer = customer self.products = [] self.total_amount = 0.0 def add_product(self, product: Product): Adds a product to the order and updates the total amount. - product: Product self.products.append(product) self.total_amount += product.price def print_order_details(order: Order): Prints order details including customer name, list of product names, and total amount. - order: Order print(f\\"Order ID: {order.order_id}\\") print(f\\"Customer: {order.customer.name}\\") print(\\"Products:\\") for product in order.products: print(f\\" - {product.name}: {product.price}\\") print(f\\"Total Amount: {order.total_amount}\\") print(\\"\\") # Sample operations customer1 = Customer(1, \\"John Doe\\", \\"john.doe@example.com\\") customer2 = Customer(2, \\"Jane Smith\\", \\"jane.smith@example.com\\") product1 = Product(1, \\"Laptop\\", 999.99) product2 = Product(2, \\"Smartphone\\", 599.99) order1 = Order(1, customer1) order1.add_product(product1) order1.add_product(product2) order2 = Order(2, customer2) order2.add_product(product2) # Print order details print_order_details(order1) print_order_details(order2)","solution":"class Customer: def __init__(self, customer_id, name, email): self.customer_id = customer_id self.name = name self.email = email class Product: def __init__(self, product_id, name, price): self.product_id = product_id self.name = name self.price = price class Order: def __init__(self, order_id, customer): self.order_id = order_id self.customer = customer self.products = [] self.total_amount = 0 def add_product(self, product): self.products.append(product) self.total_amount += product.price # Sample operations customer1 = Customer(1, \\"John Doe\\", \\"john.doe@example.com\\") customer2 = Customer(2, \\"Jane Smith\\", \\"jane.smith@example.com\\") product1 = Product(1, \\"Laptop\\", 999.99) product2 = Product(2, \\"Smartphone\\", 599.99) order1 = Order(1, customer1) order1.add_product(product1) order1.add_product(product2) order2 = Order(2, customer2) order2.add_product(product2) # Print order details def print_order_details(order): print(f\\"Order ID: {order.order_id}\\") print(f\\"Customer: {order.customer.name}\\") print(\\"Products:\\") for product in order.products: print(f\\" - {product.name}: {product.price}\\") print(f\\"Total Amount: {order.total_amount}\\") print(\\"\\") print_order_details(order1) print_order_details(order2)"},{"question":"class DynamicArray: A custom dynamic array implementation in Python that supports append, pop, insert, remove, and get operations efficiently. >>> da = DynamicArray() >>> da.append(1) >>> da.append(2) >>> len(da) 2 >>> str(da) '[1, 2]' >>> da.pop() 2 >>> len(da) 1 >>> str(da) '[1]' >>> da.insert(1, 3) >>> len(da) 2 >>> str(da) '[1, 3]' >>> da.remove(1) >>> str(da) '[3]' >>> da.get(0) 3 def __init__(self): pass def append(self, value): pass def pop(self): pass def insert(self, index, value): pass def remove(self, value): pass def get(self, index): pass def __len__(self): pass def __str__(self): pass","solution":"class DynamicArray: def __init__(self): self._capacity = 1 self._size = 0 self._array = [None] * self._capacity def _resize(self, new_capacity): new_array = [None] * new_capacity for i in range(self._size): new_array[i] = self._array[i] self._array = new_array self._capacity = new_capacity def append(self, value): if self._size == self._capacity: self._resize(2 * self._capacity) self._array[self._size] = value self._size += 1 def pop(self): if self._size == 0: raise IndexError(\\"pop from empty array\\") value = self._array[self._size - 1] self._size -= 1 self._array[self._size] = None if self._size > 0 and self._size <= self._capacity // 4: self._resize(self._capacity // 2) return value def insert(self, index, value): if index < 0 or index >= self._size: raise IndexError(\\"index out of range\\") if self._size == self._capacity: self._resize(2 * self._capacity) for i in range(self._size, index, -1): self._array[i] = self._array[i-1] self._array[index] = value self._size += 1 def remove(self, value): for i in range(self._size): if self._array[i] == value: for j in range(i, self._size - 1): self._array[j] = self._array[j+1] self._array[self._size - 1] = None self._size -= 1 if self._size > 0 and self._size <= self._capacity // 4: self._resize(self._capacity // 2) return raise ValueError(\\"value not found in array\\") def get(self, index): if index < 0 or index >= self._size: raise IndexError(\\"index out of range\\") return self._array[index] def __len__(self): return self._size def __str__(self): return str([self._array[i] for i in range(self._size)])"},{"question":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root: TreeNode) -> int: Returns the maximum path sum in the binary tree. pass def test_single_node(): root = TreeNode(10) assert max_path_sum(root) == 10 def test_two_levels(): root = TreeNode(10, TreeNode(5), TreeNode(8)) assert max_path_sum(root) == 18 def test_three_levels(): root = TreeNode(10, TreeNode(5, TreeNode(12), TreeNode(4)), TreeNode(8, TreeNode(3), TreeNode(2))) assert max_path_sum(root) == 27 def test_unbalanced_tree(): root = TreeNode(10, TreeNode(5, TreeNode(12)), TreeNode(8)) assert max_path_sum(root) == 27 def test_large_tree(): root = TreeNode(10, TreeNode(5, TreeNode(4, TreeNode(3), TreeNode(2)), TreeNode(7, TreeNode(5), TreeNode(1))), TreeNode(15, TreeNode(9), TreeNode(21))) assert max_path_sum(root) == 46","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root: TreeNode) -> int: Returns the maximum path sum in the binary tree. def helper(node: TreeNode) -> int: if not node: return 0 # Calculate max path sum from both left and right subtrees left_max = helper(node.left) right_max = helper(node.right) # Return the max path sum rooted at current node return node.val + max(left_max, right_max) return helper(root)"},{"question":"def banking_system(transactions): Processes a list of banking transactions and returns a list of balances after each transaction. Args: - transactions: List of tuples, where each tuple contains ('action', amount). Returns: - List of balances after each transaction. # Example usage: transactions = [ ('deposit', 100), ('withdraw', 50), ('balance', 0), ('withdraw', 100), ('deposit', 200), ('balance', 0) ] print(banking_system(transactions)) # Output: [100, 50, 50, 50, 250, 250]","solution":"def banking_system(transactions): Processes a list of banking transactions and returns a list of balances after each transaction. Args: - transactions: List of tuples, where each tuple contains ('action', amount). Returns: - List of balances after each transaction. balance = 0 balances = [] for action, amount in transactions: if action == 'deposit': balance += amount balances.append(balance) elif action == 'withdraw': if amount <= balance: balance -= amount balances.append(balance) elif action == 'balance': balances.append(balance) return balances"},{"question":"def max_min_diff(numbers: List[int]) -> int: Returns the difference between the maximum and minimum values in the list. >>> max_min_diff([1, 2, 3, 4, 5]) == 4 >>> max_min_diff([-10, -20, -30, -5, -15]) == 25 >>> max_min_diff([5, -3, 4, 7, -1]) == 10 >>> max_min_diff([42]) == 0 >>> max_min_diff([3, 3, 3, 3, 3]) == 0 >>> import pytest >>> with pytest.raises(ValueError): >>> max_min_diff([])","solution":"def max_min_diff(numbers): Returns the difference between the maximum and minimum values in the list. :param numbers: List of integers :return: Integer difference between the maximum and minimum values if not numbers: raise ValueError(\\"The list should not be empty\\") return max(numbers) - min(numbers)"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"abcdef\\") == 6 >>> length_of_longest_substring(\\"aaaaaa\\") == 1 >>> length_of_longest_substring(\\"\\") == 0 >>> length_of_longest_substring(\\"b\\") == 1 >>> length_of_longest_substring(\\"pwwkew\\") == 3","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_map and char_map[s[right]] >= left: left = char_map[s[right]] + 1 char_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"def rotate_matrix(matrix): Rotates the given n x n matrix by 90 degrees clockwise in place. Args: matrix (List[List[int]]): The n x n matrix to be rotated. Returns: List[List[int]]: The rotated matrix. Examples: >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> rotate_matrix([ ... [5, 1, 9, 11], ... [2, 4, 8, 10], ... [13, 3, 6, 7], ... [15, 14, 12, 16] ... ]) [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] >>> rotate_matrix([ ... [1] ... ]) [ [1] ] >>> rotate_matrix([ ... [1, 2], ... [3, 4] ... ]) [ [3, 1], [4, 2] ] pass","solution":"def rotate_matrix(matrix): Rotates the given n x n matrix by 90 degrees clockwise in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. Args: s (str): The input string to evaluate. Returns: int: The length of the longest substring with all unique characters. Examples: >>> longest_unique_substring(\\"abcabcbb\\") 3 >>> longest_unique_substring(\\"bbbbb\\") 1 >>> longest_unique_substring(\\"pwwkew\\") 3 >>> longest_unique_substring(\\"\\") 0 >>> longest_unique_substring(\\"abcdef\\") 6 pass if __name__ == \\"__main__\\": print(longest_unique_substring(\\"abcabcbb\\")) # Output: 3 from solution import longest_unique_substring def test_longest_unique_substring(): assert longest_unique_substring(\\"abcabcbb\\") == 3 assert longest_unique_substring(\\"bbbbb\\") == 1 assert longest_unique_substring(\\"pwwkew\\") == 3 assert longest_unique_substring(\\"\\") == 0 assert longest_unique_substring(\\"abcdef\\") == 6 assert longest_unique_substring(\\"aab\\") == 2 assert longest_unique_substring(\\"dvdf\\") == 3 def test_single_character_strings(): assert longest_unique_substring(\\"a\\") == 1 assert longest_unique_substring(\\"aaaaaaa\\") == 1 def test_mixed_characters(): assert longest_unique_substring(\\"abc!@#abc!@#\\") == 6 assert longest_unique_substring(\\"a1b2c3d4e5\\") == 10","solution":"def longest_unique_substring(s): Returns the length of the longest substring with all unique characters. chars = set() longest = 0 start = 0 for end in range(len(s)): while s[end] in chars: chars.remove(s[start]) start += 1 chars.add(s[end]) longest = max(longest, end - start + 1) return longest # Example usage print(longest_unique_substring(\\"abcabcbb\\")) # Output: 3"},{"question":"def evaluate_postfix(expression: str) -> int: Evaluate a postfix expression. :param expression: A string containing a space-separated postfix expression. :return: The result of evaluating the postfix expression as an integer. >>> evaluate_postfix(\\"3 4 + 2 * 7 /\\") 2 >>> evaluate_postfix(\\"5 1 2 + 4 * + 3 -\\") 14 >>> evaluate_postfix(\\"42\\") 42 >>> evaluate_postfix(\\"-3 -4 +\\") -7 >>> evaluate_postfix(\\"10 3 - 5 -\\") 2 >>> evaluate_postfix(\\"10 3 /\\") 3 >>> evaluate_postfix(\\"10 -3 /\\") -3 >>> evaluate_postfix(\\"-10 3 /\\") -3 >>> evaluate_postfix(\\"-10 -3 /\\") 3","solution":"def evaluate_postfix(expression): Evaluate a postfix expression. :param expression: A string containing a space-separated postfix expression. :return: The result of evaluating the postfix expression as an integer. stack = [] tokens = expression.split() for token in tokens: if token.isdigit() or (token[0] == '-' and token[1:].isdigit()): # Handling negative numbers stack.append(int(token)) else: b = stack.pop() a = stack.pop() if token == '+': stack.append(a + b) elif token == '-': stack.append(a - b) elif token == '*': stack.append(a * b) elif token == '/': stack.append(int(a / b)) # Truncates towards zero return stack[0] # Sample usages print(evaluate_postfix(\\"3 4 + 2 * 7 /\\")) # Expected output: 2 print(evaluate_postfix(\\"5 1 2 + 4 * + 3 -\\")) # Expected output: 14"},{"question":"def merge_dicts(dict1: dict, dict2: dict) -> dict: Merges two dictionaries into one. If both dictionaries have the same key, the value from the second dictionary should overwrite the value from the first dictionary. Args: dict1 (dict): The first dictionary to merge. dict2 (dict): The second dictionary to merge. Returns: dict: A new dictionary containing all keys from both input dictionaries. >>> merge_dicts({'a': 1, 'b': 2}, {'b': 4, 'c': 3}) {'a': 1, 'b': 4, 'c': 3} >>> merge_dicts({}, {'a': 1}) {'a': 1} >>> merge_dicts({'a': 1}, {}) {'a': 1} >>> merge_dicts({}, {}) {} # Your code here pass # Test cases def test_merge_dicts_no_overlapping_keys(): dict1 = {'a': 1, 'b': 2} dict2 = {'c': 3, 'd': 4} merged = merge_dicts(dict1, dict2) assert merged == {'a': 1, 'b': 2, 'c': 3, 'd': 4} def test_merge_dicts_some_overlapping_keys(): dict1 = {'a': 1, 'b': 2, 'c': 3} dict2 = {'b': 4, 'c': 5, 'd': 6} merged = merge_dicts(dict1, dict2) assert merged == {'a': 1, 'b': 4, 'c': 5, 'd': 6} def test_merge_dicts_with_integer_values(): dict1 = {1: 'one', 2: 'two'} dict2 = {2: 'TWO', 3: 'three'} merged = merge_dicts(dict1, dict2) assert merged == {1: 'one', 2: 'TWO', 3: 'three'} def test_merge_dicts_with_different_value_types(): dict1 = {'a': 1, 'b': 'two', 'c': [3, 4]} dict2 = {'b': 'two updated', 'c': 'new value', 'd': 5} merged = merge_dicts(dict1, dict2) assert merged == {'a': 1, 'b': 'two updated', 'c': 'new value', 'd': 5} def test_merge_dicts_empty_dict1(): dict1 = {} dict2 = {'a': 1, 'b': 2} merged = merge_dicts(dict1, dict2) assert merged == {'a': 1, 'b': 2} def test_merge_dicts_empty_dict2(): dict1 = {'a': 1, 'b': 2} dict2 = {} merged = merge_dicts(dict1, dict2) assert merged == {'a': 1, 'b': 2} def test_merge_dicts_both_empty(): dict1 = {} dict2 = {} merged = merge_dicts(dict1, dict2) assert merged == {}","solution":"def merge_dicts(dict1, dict2): Merges two dictionaries into one. Args: dict1 (dict): The first dictionary to merge. dict2 (dict): The second dictionary to merge. Returns: dict: A new dictionary containing all keys from both input dictionaries. merged_dict = dict1.copy() # Start with the first dictionary's contents merged_dict.update(dict2) # Update with the second dictionary's contents, which will overwrite duplicates return merged_dict"},{"question":"from typing import List from collections import Counter def k_most_frequent(nums: List[int], k: int) -> List[int]: Returns the k most frequent elements in nums in decreasing order of their frequency. Elements with the same frequency are returned in ascending order. Args: nums (List[int]): List of integers. k (int): Number of frequent elements to return. Returns: List[int]: The k most frequent elements in descending order of their frequency. Examples: >>> k_most_frequent([1,1,1,2,2,3], 2) [1, 2] >>> k_most_frequent([4,4,4,5,5,6,6,6,7,7,7,7], 3) [7, 4, 6] >>> k_most_frequent([1], 1) [1]","solution":"from collections import Counter def k_most_frequent(nums, k): Returns the k most frequent elements in nums in decreasing order of their frequency. Elements with the same frequency are returned in ascending order. counts = Counter(nums) # Sort first by frequency in descending order, then by value in ascending order sorted_elements = sorted(counts.items(), key=lambda x: (-x[1], x[0])) # Extract the elements return [element for element, count in sorted_elements[:k]]"},{"question":"from typing import List, Tuple def consecutive_letter_count(s: str) -> List[Tuple[str, int]]: Write a function that takes a string consisting only of lowercase letters and returns a list of tuples. Each tuple should contain a letter from the string and the number of times that letter appears consecutively. >>> consecutive_letter_count(\\"aaabbcccdc\\") [('a', 3), ('b', 2), ('c', 3), ('d', 1), ('c', 1)] >>> consecutive_letter_count(\\"a\\") [('a', 1)] >>> consecutive_letter_count(\\"abcd\\") [('a', 1), ('b', 1), ('c', 1), ('d', 1)] >>> consecutive_letter_count(\\"\\") [] >>> consecutive_letter_count(\\"aaaabbbbcccc\\") [('a', 4), ('b', 4), ('c', 4)] >>> consecutive_letter_count(\\"aabcccdeeff\\") [('a', 2), ('b', 1), ('c', 3), ('d', 1), ('e', 2), ('f', 2)] >>> consecutive_letter_count(\\"z\\") [('z', 1)] >>> consecutive_letter_count(\\"zzzzz\\") [('z', 5)]","solution":"from typing import List, Tuple def consecutive_letter_count(s: str) -> List[Tuple[str, int]]: if not s: return [] result = [] count = 1 previous_char = s[0] for current_char in s[1:]: if current_char == previous_char: count += 1 else: result.append((previous_char, count)) previous_char = current_char count = 1 result.append((previous_char, count)) return result"},{"question":"def is_leap_year(year: int) -> bool: Determine if a given year is a leap year. A leap year is divisible by 4, but if it is divisible by 100, it should also be divisible by 400 to be considered a leap year. Args: year (int): The year to be checked. Returns: bool: True if the year is a leap year, False otherwise. Examples: >>> is_leap_year(2020) True >>> is_leap_year(1900) False >>> is_leap_year(2000) True >>> is_leap_year(2021) False def test_is_leap_year(): # Leap years assert is_leap_year(2020) == True assert is_leap_year(2000) == True assert is_leap_year(1600) == True assert is_leap_year(2400) == True assert is_leap_year(4) == True # Non-leap years assert is_leap_year(1900) == False assert is_leap_year(2021) == False assert is_leap_year(2100) == False assert is_leap_year(1800) == False assert is_leap_year(7) == False # Edge cases assert is_leap_year(1) == False assert is_leap_year(400) == True assert is_leap_year(1000) == False assert is_leap_year(99996) == True","solution":"def is_leap_year(year: int) -> bool: Returns True if the given year is a leap year, otherwise returns False. A leap year is divisible by 4. However, if the year is also divisible by 100, it must also be divisible by 400 to be a leap year. if year % 4 == 0: if year % 100 == 0: if year % 400 == 0: return True else: return False else: return True else: return False"},{"question":"def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Write a function that takes a square matrix as input and returns the matrix rotated 90 degrees clockwise. The matrix is represented as a list of lists, where each inner list represents a row. You are not allowed to use any additional libraries or functions for matrix rotation. Example: Input: [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] Output: [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] Constraints: - The input matrix will have dimensions n x n where 1 <= n <= 100. - Each element of the matrix will be an integer in the range -1000 to 1000. - Do not modify the input matrix; return a new matrix with the elements rotated. >>> rotate_matrix([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotate_matrix([[1]]) [[1]] >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]]","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates the given n x n matrix 90 degrees clockwise. Parameters: matrix (List[List[int]]): The matrix to rotate. Returns: List[List[int]]: New matrix rotated 90 degrees clockwise. n = len(matrix) rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n - 1 - i] = matrix[i][j] return rotated_matrix"},{"question":"def build_dict(keys, values): Builds a dictionary from two lists of keys and values. If the lists have different lengths, missing values are filled with None. Args: keys (list): List of keys. values (list): List of values. Returns: dict: Dictionary constructed from keys and values. >>> build_dict(['a', 'b', 'c'], [1, 2, 3]) {'a': 1, 'b': 2, 'c': 3} >>> build_dict(['a', 'b', 'c', 'd'], [1, 2, 3]) {'a': 1, 'b': 2, 'c': 3, 'd': None} >>> build_dict(['a', 'b'], [1, 2, 3, 4]) {'a': 1, 'b': 2} >>> build_dict([], [1, 2, 3]) {} >>> build_dict(['a', 'b', 'c'], []) {'a': None, 'b': None, 'c': None} >>> build_dict([], []) {}","solution":"def build_dict(keys, values): Builds a dictionary from two lists of keys and values. If the lists have different lengths, missing values are filled with None. Args: keys (list): List of keys. values (list): List of values. Returns: dict: Dictionary constructed from keys and values. # Extend the values list with None if it is shorter than the keys list if len(keys) > len(values): values.extend([None] * (len(keys) - len(values))) return dict(zip(keys, values))"},{"question":"def decode_message(encoded_message: str, decoding_dict: dict) -> str: Decode the given encoded message using the provided dictionary. >>> decode_message(\\"abccba\\", {'a': '1', 'b': '2', 'c': '3'}) '123321' >>> decode_message(\\"\\", {'a': '1', 'b': '2', 'c': '3'}) '' >>> decode_message(\\"a\\", {'a': '1', 'b': '2', 'c': '3'}) '1' >>> decode_message(\\"aa\\", {'a': '1', 'b': '2', 'c': '3'}) '11' >>> try: ... decode_message(\\"abcd\\", {'a': '1', 'b': '2', 'c': '3'}) ... assert False, \\"Expected KeyError\\" ... except KeyError: ... assert True","solution":"def decode_message(encoded_message, decoding_dict): Decodes an encoded message using the provided decoding dictionary. Parameters: encoded_message (str): The encoded string to be decoded. decoding_dict (dict): A dictionary mapping encoded characters to their corresponding decoded characters. Returns: str: The decoded string. decoded_message = ''.join(decoding_dict[char] for char in encoded_message) return decoded_message"},{"question":"def merge_alternate(list1, list2): Merge two lists in an alternating fashion. If one list is longer, append the remaining elements to the end. Parameters: list1 (list): The first list of integers. list2 (list): The second list of integers. Returns: list: The merged list. >>> merge_alternate([1, 2, 3], [4, 5, 6]) [1, 4, 2, 5, 3, 6] >>> merge_alternate([1, 2, 3, 9, 10], [4, 5, 6]) [1, 4, 2, 5, 3, 6, 9, 10] >>> merge_alternate([1, 2, 3], [4, 5, 6, 7, 8]) [1, 4, 2, 5, 3, 6, 7, 8] >>> merge_alternate([], [4, 5, 6]) [4, 5, 6] >>> merge_alternate([1, 2, 3], []) [1, 2, 3] >>> merge_alternate([], []) [] >>> merge_alternate([1], [2]) [1, 2] >>> merge_alternate([1], [2, 3, 4]) [1, 2, 3, 4] >>> merge_alternate([1, 2, 3], [4]) [1, 4, 2, 3]","solution":"def merge_alternate(list1, list2): Merge two lists in an alternating fashion. If one list is longer, append the remaining elements to the end. Parameters: list1 (list): The first list of integers. list2 (list): The second list of integers. Returns: list: The merged list. merged_list = [] len1, len2 = len(list1), len(list2) for i in range(min(len1, len2)): merged_list.append(list1[i]) merged_list.append(list2[i]) # Append remaining elements, if any if len1 > len2: merged_list.extend(list1[len2:]) else: merged_list.extend(list2[len1:]) return merged_list"},{"question":"from collections import OrderedDict def remove_duplicates(lst: list) -> list: Removes duplicates from the list while preserving the order of their first appearance. Args: lst (list): A list of integers. Returns: list: A new list with duplicates removed. >>> remove_duplicates([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([1, 1, 1, 1]) [1] >>> remove_duplicates([5, 4, 3, 2, 1, 1, 2, 3, 4, 5]) [5, 4, 3, 2, 1] >>> remove_duplicates([]) [] >>> remove_duplicates([1]) [1] # Your implementation here def performance_test(): Tests the time efficiency of the remove_duplicates function using a large dataset. This function generates a list of random integers, measures the time taken for remove_duplicates to process this list, and prints out the time taken. import random import time # Your implementation here","solution":"from collections import OrderedDict def remove_duplicates(lst): Removes duplicates from the list while preserving the order of their first appearance. Args: lst (list): A list of integers. Returns: list: A new list with duplicates removed. return list(OrderedDict.fromkeys(lst)) def performance_test(): import random import time # Generate a list of 1 million random integers between 1 and 1000 large_list = [random.randint(1, 1000) for _ in range(1000000)] start_time = time.time() result = remove_duplicates(large_list) end_time = time.time() print(f\\"Time taken to remove duplicates: {end_time - start_time} seconds\\")"},{"question":"def longest_palindrome_substring(s: str) -> str: Returns the longest palindrome substring within the input string s. If there are multiple palindromes of the same maximum length, return the first one encountered. >>> longest_palindrome_substring(\\"a\\") 'a' >>> longest_palindrome_substring(\\"abcde\\") 'a' >>> longest_palindrome_substring(\\"racecar\\") 'racecar' >>> longest_palindrome_substring(\\"forgeeksskeegfor\\") 'geeksskeeg' >>> longest_palindrome_substring(\\"abacdfgdcaba\\") 'aba' >>> longest_palindrome_substring(\\"abccba\\") 'abccba' >>> longest_palindrome_substring(\\"Aba\\") 'A'","solution":"def longest_palindrome_substring(s): Returns the longest palindrome substring within the input string s. If there are multiple palindromes of the same maximum length, return the first one encountered. def expand_around_center(left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] longest_palindrome = \\"\\" for i in range(len(s)): # Odd length palindromes odd_palindrome = expand_around_center(i, i) if len(odd_palindrome) > len(longest_palindrome): longest_palindrome = odd_palindrome # Even length palindromes even_palindrome = expand_around_center(i, i + 1) if len(even_palindrome) > len(longest_palindrome): longest_palindrome = even_palindrome return longest_palindrome"},{"question":"def find_longest_palindrome(s: str) -> str: Design a function named \`find_longest_palindrome\`, which receives a single string input and returns the longest palindromic substring within the input string. A palindrome is a sequence of characters that reads the same forward and backward. You need to consider edge cases, such as strings with no palindromic substring longer than one character or strings of considerable length. Optimize the function for efficiency since string lengths could be substantial. Examples: >>> find_longest_palindrome(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> find_longest_palindrome(\\"a\\") == \\"a\\" True >>> find_longest_palindrome(\\"racecar\\") == \\"racecar\\" True >>> find_longest_palindrome(\\"abc\\") in [\\"a\\", \\"b\\", \\"c\\"] True >>> find_longest_palindrome(\\"cbbd\\") == \\"bb\\" True >>> find_longest_palindrome(\\"\\") == \\"\\" True >>> find_longest_palindrome(\\"abacdfgdcaba\\") == \\"aba\\" True >>> find_longest_palindrome(\\"abacdedcaba\\") == \\"abacdedcaba\\" True >>> find_longest_palindrome(\\"A man, a plan, a canal, Panama\\") == \\" a \\" True >>> long_string = \\"a\\" * 1000 >>> find_longest_palindrome(long_string) == long_string True","solution":"def find_longest_palindrome(s: str) -> str: Finds the longest palindromic substring in the given string. Parameters: s (str): The input string Returns: str: The longest palindromic substring if not s: return \\"\\" n = len(s) start, end = 0, 0 def expand_around_center(left: int, right: int) -> (int, int): while left >= 0 and right < n and s[left] == s[right]: left -= 1 right += 1 return left + 1, right - 1 for i in range(n): # Odd length palindrome l1, r1 = expand_around_center(i, i) # Even length palindrome l2, r2 = expand_around_center(i, i + 1) if r1 - l1 > end - start: start, end = l1, r1 if r2 - l2 > end - start: start, end = l2, r2 return s[start:end + 1]"},{"question":"import re def longest_word(sentence: str) -> str: Returns the longest word in the given sentence. If multiple words have the same length, returns the one that appears first. Punctuation is ignored, and handling is case-insensitive. >>> longest_word(\\"The quick brown fox jumps over the lazy dog.\\") 'quick' >>> longest_word(\\"A boy, named Sam, came home with absolutely fantastic news!\\") 'absolutely' >>> longest_word(\\"We are going to a neighborhood watch meeting tonight.\\") 'neighborhood' >>> longest_word(\\"Extraordinary!\\") 'Extraordinary' >>> longest_word(\\"\\") '' >>> longest_word(\\"I am running in the rain.\\") 'running' >>> longest_word(\\"Supercalifragilisticexpialidocious is a long word.\\") 'Supercalifragilisticexpialidocious'","solution":"import re def longest_word(sentence): Returns the longest word in the given sentence. If multiple words have the same length, returns the one that appears first. Punctuation is ignored, and handling is case-insensitive. # Remove punctuation and split sentence into words words = re.findall(r'bw+b', sentence) # Initialize the longest word variable longest = \\"\\" for word in words: if len(word) > len(longest): longest = word return longest"},{"question":"def longest_subarray_equal_even_odd(nums: List[int]) -> int: Returns the length of the longest contiguous subarray with an equal number of even and odd numbers. >>> longest_subarray_equal_even_odd([2, 4, 6, 8]) == 0 >>> longest_subarray_equal_even_odd([1, 3, 5, 7]) == 0 >>> longest_subarray_equal_even_odd([1, 2, 3, 4]) == 4 >>> longest_subarray_equal_even_odd([1, 2, 2, 1]) == 4 >>> longest_subarray_equal_even_odd([1, 2, 1, 2, 1, 2, 1]) == 6 >>> longest_subarray_equal_even_odd([]) == 0 >>> longest_subarray_equal_even_odd([1, 1, 1, 1]) == 0 >>> longest_subarray_equal_even_odd([2, 2, 2, 2]) == 0 >>> longest_subarray_equal_even_odd([1, 2]) == 2 >>> longest_subarray_equal_even_odd([1, 2, 1, 2]) == 4 >>> longest_subarray_equal_even_odd([2, 2, 1, 1, 1]) == 4","solution":"def longest_subarray_equal_even_odd(nums): Returns the length of the longest contiguous subarray with an equal number of even and odd numbers. count_dict = {0: -1} even_odd_diff = 0 max_length = 0 for index, num in enumerate(nums): if num % 2 == 0: even_odd_diff += 1 else: even_odd_diff -= 1 if even_odd_diff in count_dict: max_length = max(max_length, index - count_dict[even_odd_diff]) else: count_dict[even_odd_diff] = index return max_length"},{"question":"def count_string_occurrences(input_list): Takes a list of strings and returns a dictionary with the counts of occurrences of each string. Args: input_list (list): List of strings to count occurrences. Returns: dict: Dictionary with strings as keys and their occurrence counts as values. Raises: ValueError: If input_list is not a list of strings. Examples: >>> count_string_occurrences([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"]) {\\"apple\\": 3, \\"banana\\": 2, \\"orange\\": 1} >>> count_string_occurrences([\\"dog\\", \\"cat\\", \\"dog\\", \\"dog\\", \\"cat\\"]) {\\"dog\\": 3, \\"cat\\": 2}","solution":"def count_string_occurrences(input_list): Takes a list of strings and returns a dictionary with the counts of occurrences of each string. Args: input_list (list): List of strings to count occurrences. Returns: dict: Dictionary with strings as keys and their occurrence counts as values. Raises: ValueError: If input_list is not a list of strings. if not isinstance(input_list, list) or not all(isinstance(item, str) for item in input_list): raise ValueError(\\"Input must be a list of strings\\") occurrence_dict = {} for item in input_list: if item in occurrence_dict: occurrence_dict[item] += 1 else: occurrence_dict[item] = 1 return occurrence_dict"},{"question":"class ShoppingCart: Simulate a basic online shopping cart system with functionalities to add items, remove items, view the current items in the cart, calculate the total cost, and apply a discount. add_item(name: str, price: float, quantity: int): Add an item to the cart with the given name, price, and quantity. remove_item(name: str): Remove an item from the cart by its name. view_items() -> List[Dict[str, Union[str, float, int]]]: View all items currently in the cart. calculate_total() -> float: Calculate the total cost of items in the cart. apply_discount(discount_percentage: float) -> float: Apply a discount to the total cost. Unit Test: def test_add_item(): cart = ShoppingCart() cart.add_item(\\"apple\\", 1.0, 3) assert cart.view_items() == [{'name': 'apple', 'price': 1.0, 'quantity': 3}] def test_remove_item(): cart = ShoppingCart() cart.add_item(\\"apple\\", 1.0, 3) cart.add_item(\\"banana\\", 0.5, 5) cart.remove_item(\\"apple\\") assert cart.view_items() == [{'name': 'banana', 'price': 0.5, 'quantity': 5}] def test_view_items(): cart = ShoppingCart() cart.add_item(\\"apple\\", 1.0, 3) cart.add_item(\\"banana\\", 0.5, 5) assert cart.view_items() == [ {'name': 'apple', 'price': 1.0, 'quantity': 3}, {'name': 'banana', 'price': 0.5, 'quantity': 5} ] def test_calculate_total(): cart = ShoppingCart() cart.add_item(\\"apple\\", 1.0, 3) cart.add_item(\\"banana\\", 0.5, 5) assert cart.calculate_total() == 5.5 def test_apply_discount(): cart = ShoppingCart() cart.add_item(\\"apple\\", 1.0, 3) cart.add_item(\\"banana\\", 0.5, 5) total_after_discount = cart.apply_discount(10) assert total_after_discount == 4.95","solution":"class ShoppingCart: def __init__(self): self.cart = [] def add_item(self, name, price, quantity): Add an item to the cart with the given name, price, and quantity. self.cart.append({'name': name, 'price': price, 'quantity': quantity}) def remove_item(self, name): Remove an item from the cart by its name. self.cart = [item for item in self.cart if item['name'] != name] def view_items(self): View all items currently in the cart. return self.cart def calculate_total(self): Calculate the total cost of items in the cart. return sum(item['price'] * item['quantity'] for item in self.cart) def apply_discount(self, discount_percentage): Apply a discount to the total cost. total = self.calculate_total() discount = total * (discount_percentage / 100) return total - discount"},{"question":"from typing import List, Tuple def process_student_grades(student_grades: List[Tuple[str, int]]) -> Tuple[float, List[str], List[str]]: Processes a list of student names and their grades to calculate and display the average grade for the class, the student(s) with the highest grade, and the student(s) with the lowest grade. Args: student_grades (list of tuples): A list of tuples where each tuple contains a student's name (str) and their grade (int). Returns: tuple: A tuple containing the average grade (float), a list of students with the highest grade (list of str), and a list of students with the lowest grade (list of str). >>> process_student_grades([]) (0.0, [], []) >>> process_student_grades([(\\"Alice\\", 90)]) (90.0, [\\"Alice\\"], [\\"Alice\\"]) >>> process_student_grades([(\\"Alice\\", 78), (\\"Bob\\", 92), (\\"Catherine\\", 85), (\\"David\\", 92)]) (86.75, [\\"Bob\\", \\"David\\"], [\\"Alice\\"]) >>> process_student_grades([(\\"Alice\\", 90), (\\"Bob\\", 90), (\\"Catherine\\", 90), (\\"David\\", 90)]) (90.0, [\\"Alice\\", \\"Bob\\", \\"Catherine\\", \\"David\\"], [\\"Alice\\", \\"Bob\\", \\"Catherine\\", \\"David\\"]) >>> process_student_grades([(\\"Alice\\", 60), (\\"Bob\\", 80)]) (70.0, [\\"Bob\\"], [\\"Alice\\"])","solution":"def process_student_grades(student_grades): Processes a list of student names and their grades to calculate and display the average grade for the class, the student(s) with the highest grade, and the student(s) with the lowest grade. Args: student_grades (list of tuples): A list of tuples where each tuple contains a student's name (str) and their grade (int). Returns: tuple: A tuple containing the average grade (float), a list of students with the highest grade (list of str), and a list of students with the lowest grade (list of str). if not student_grades: return (0.0, [], []) total_grade = 0 max_grade = -1 min_grade = 101 highest_grade_students = [] lowest_grade_students = [] for name, grade in student_grades: total_grade += grade if grade > max_grade: max_grade = grade highest_grade_students = [name] elif grade == max_grade: highest_grade_students.append(name) if grade < min_grade: min_grade = grade lowest_grade_students = [name] elif grade == min_grade: lowest_grade_students.append(name) average_grade = round(total_grade / len(student_grades), 2) return (average_grade, highest_grade_students, lowest_grade_students)"},{"question":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Given a list of unique integers \`nums\` and an integer \`target\`, return the indices of the two numbers such that they add up to \`target\`. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([-3, 4, 3, 90], 0) [0, 2] >>> two_sum([1, 2, 3, 4, 5], 9) [3, 4] >>> two_sum([0, 4, 3, 0], 0) [0, 3] >>> two_sum([123456789, 987654321], 1111111110) [0, 1]","solution":"def two_sum(nums, target): Returns the indices of the two numbers in the list \`nums\` that add up to \`target\`. lookup = {} for i, num in enumerate(nums): complement = target - num if complement in lookup: return [lookup[complement], i] lookup[num] = i"},{"question":"def filter_odd_numbers(int_list): Filters out even numbers from a list of integers and returns the resulting list of all odd numbers. Handles both positive and negative integers and maintains the original order of the odd numbers. If the input is not a list of integers, returns an error message. >>> filter_odd_numbers([10, 21, 4, -3, 15, -8, 0, 33, 7]) == [21, -3, 15, 33, 7] >>> filter_odd_numbers([1, 3, 5, 7, 9]) == [1, 3, 5, 7, 9] >>> filter_odd_numbers([2, 4, 6, 8, 10]) == [] >>> filter_odd_numbers([]) == [] >>> filter_odd_numbers(\\"not a list\\") == \\"Invalid input, please provide a list of integers.\\" >>> filter_odd_numbers([1, 2, '3', 4]) == \\"Invalid input, please provide a list of integers.\\"","solution":"def filter_odd_numbers(int_list): Filters out even numbers from a list of integers and returns the resulting list of all odd numbers. Handles both positive and negative integers and maintains the original order of the odd numbers. If the input is not a list of integers, returns an error message. if not isinstance(int_list, list) or not all(isinstance(x, int) for x in int_list): return \\"Invalid input, please provide a list of integers.\\" return [x for x in int_list if x % 2 != 0]"},{"question":"from typing import List def generate_primes(n: int) -> List[int]: Generates a list of prime numbers less than or equal to \`n\`. >>> generate_primes(10) [2, 3, 5, 7] >>> generate_primes(20) [2, 3, 5, 7, 11, 13, 17, 19]","solution":"from typing import List def generate_primes(n: int) -> List[int]: Generates a list of prime numbers less than or equal to \`n\`. if n < 2: return [] is_prime = [True] * (n + 1) is_prime[0] = is_prime[1] = False for i in range(2, int(n**0.5) + 1): if is_prime[i]: for j in range(i * i, n + 1, i): is_prime[j] = False return [i for i in range(n + 1) if is_prime[i]]"},{"question":"def find_words(input_list: List[str], target_word: str) -> List[str]: Returns a list of words from input_list that can be formed using the letters of target_word. >>> find_words([\\"apple\\", \\"plea\\", \\"lap\\", \\"peel\\", \\"pal\\"], \\"apple\\") [\\"apple\\", \\"plea\\", \\"lap\\", \\"pal\\"] >>> find_words([\\"banana\\", \\"orange\\", \\"grape\\"], \\"apple\\") []","solution":"def can_form_word(word, target_counts): Helper function to check if a word can be formed using the letters of the target word. word_counts = {} for char in word: if char in word_counts: word_counts[char] += 1 else: word_counts[char] = 1 for char in word_counts: if word_counts[char] > target_counts.get(char, 0): return False return True def find_words(input_list, target_word): Returns a list of words from input_list that can be formed using the letters of target_word. target_counts = {} for char in target_word: if char in target_counts: target_counts[char] += 1 else: target_counts[char] = 1 result = [] for word in input_list: if can_form_word(word, target_counts): result.append(word) return result"},{"question":"def remove_duplicates(input_string: str) -> str: Write a function that takes a string as input and returns a new string where all duplicate characters have been removed. The order of characters in the new string should be the same as they first appear in the input string. Ensure that your solution handles upper and lower case characters as distinct. >>> remove_duplicates(\\"abcdefg\\") 'abcdefg' >>> remove_duplicates(\\"Programming\\") 'Progamin' >>> remove_duplicates(\\"Mississippi\\") 'Misp' >>> remove_duplicates(\\"\\") '' >>> remove_duplicates(\\"a1b2c3a1b2c3\\") 'a1b2c3' >>> remove_duplicates(\\"a!b@c#a!b@\\") 'a!b@c#'","solution":"def remove_duplicates(input_string): Returns a new string where all duplicate characters have been removed. The order of characters in the new string is the same as they first appear in the input string. seen = set() result = [] for char in input_string: if char not in seen: seen.add(char) result.append(char) return ''.join(result)"},{"question":"def most_frequent_integer(file_path: str) -> int: Reads a text file containing a list of integers (one per line) and finds the integer that appears most frequently in the file. If there is a tie, returns the smallest integer among them. Handles potential I/O errors and ensures the file content is valid. >>> with open('tempfile.txt', 'w') as f: f.write(\\"3n7n3n9n2n3n2n7n7n\\") >>> most_frequent_integer('tempfile.txt') 3 >>> with open('tempfile.txt', 'w') as f: f.write(\\"1n2n2n3n1n3n\\") >>> most_frequent_integer('tempfile.txt') 1 >>> with open('tempfile.txt', 'w') as f: f.write(\\"1n2n3n4n\\") >>> most_frequent_integer('tempfile.txt') 1 >>> with open('tempfile.txt', 'w') as f: f.write(\\"\\") >>> most_frequent_integer('tempfile.txt') None >>> with open('tempfile.txt', 'w') as f: f.write(\\"anbncn1n2n2n\\") >>> most_frequent_integer('tempfile.txt') 2 >>> most_frequent_integer('non_existent_file.txt') None # Your code here","solution":"def most_frequent_integer(file_path): from collections import Counter try: with open(file_path, 'r') as file: numbers = file.readlines() numbers = list(map(str.strip, numbers)) numbers = list(filter(str.isnumeric, numbers)) numbers = list(map(int, numbers)) if not numbers: raise ValueError(\\"File contains no valid integers.\\") frequency = Counter(numbers) most_common = frequency.most_common() max_frequency = most_common[0][1] most_frequent_numbers = [num for num, freq in most_common if freq == max_frequency] return min(most_frequent_numbers) except IOError: print(f\\"Error: Unable to read file {file_path}.\\") except ValueError as ve: print(f\\"Error: {ve}\\") # Example usage: # Assuming \`numbers.txt\` contains the numbers from the sample input file. # most_frequent_integer('numbers.txt')"},{"question":"def intersect_dicts(dict1: dict, dict2: dict) -> dict: Takes two dictionaries as input and returns a new dictionary containing only the keys that are present in both input dictionaries, with values being the sum of the values from the two input dictionaries. >>> intersect_dicts({'a': 1, 'b': 2, 'c': 3}, {'b': 3, 'c': 4, 'd': 5}) {'b': 5, 'c': 7} >>> intersect_dicts({'a': 1, 'b': 2}, {'c': 3, 'd': 4}) {} >>> intersect_dicts({}, {}) {} >>> intersect_dicts({'a': 1, 'b': 2, 'c': 3}, {}) {} >>> intersect_dicts({'a': -1, 'b': -2, 'c': 3}, {'b': 3, 'c': -4, 'd': 5}) {'b': 1, 'c': -1} >>> intersect_dicts({'a': 1, 'b': 2, 'c': 3}, {'a': 1, 'b': 2, 'c': 3}) {'a': 2, 'b': 4, 'c': 6}","solution":"def intersect_dicts(dict1, dict2): Takes two dictionaries as input and returns a new dictionary containing only the keys that are present in both input dictionaries, with values being the sum of the values from the two input dictionaries. :param dict1: First input dictionary :param dict2: Second input dictionary :return: Dictionary with common keys and summed values result = {key: dict1[key] + dict2[key] for key in dict1 if key in dict2} return result"},{"question":"def healthy_foods(food_calories: dict, calorie_limit: int) -> list: Evaluate the healthiness of food choices based on a given dictionary of foods and their corresponding calorie counts. Args: food_calories (dict): A dictionary where keys are food names and values are integers representing the calories. calorie_limit (int): An integer representing the maximum allowable calories for a healthy food. Returns: list: A list of string names of foods with calorie counts below the calorie limit. Examples: >>> healthy_foods({\\"Apple\\": 95, \\"Banana\\": 112, \\"Carrot\\": 41, \\"Doughnut\\": 195}, 100) ['Apple', 'Carrot'] >>> healthy_foods({\\"Salad\\": 300, \\"Pizza\\": 600, \\"Granola Bar\\": 130, \\"Orange\\": 45}, 150) ['Granola Bar', 'Orange'] >>> healthy_foods({\\"Burger\\": 500, \\"Fries\\": 365, \\"Milkshake\\": 360}, 400) ['Fries', 'Milkshake'] >>> healthy_foods({\\"Burger\\": 500, \\"Pizza\\": 800, \\"Ice Cream\\": 250}, 200) [] >>> healthy_foods({\\"Fruit Salad\\": 150, \\"Yogurt\\": 120, \\"Oatmeal\\": 140}, 160) ['Fruit Salad', 'Yogurt', 'Oatmeal'] >>> healthy_foods({\\"Apple\\": 95, \\"Banana\\": 112, \\"Carrot\\": 41, \\"Doughnut\\": 195}, 0) [] >>> healthy_foods({\\"Apple\\": 95, \\"Banana\\": 112, \\"Carrot\\": 41, \\"Doughnut\\": 195}, 95) ['Carrot']","solution":"def healthy_foods(food_calories: dict, calorie_limit: int) -> list: Returns the list of foods with calorie counts below the given calorie limit. Args: food_calories (dict): A dictionary where keys are food names and values are integers representing the calories. calorie_limit (int): An integer representing the maximum allowable calories for a healthy food. Returns: list: A list of string names of foods with calorie counts below the calorie limit. return [food for food, calories in food_calories.items() if calories < calorie_limit]"},{"question":"import numpy as np import matplotlib.pyplot as plt from sklearn import datasets from sklearn.model_selection import train_test_split, cross_val_score from sklearn.neighbors import KNeighborsClassifier from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score def load_iris_data(): Load the Iris dataset and split it into training and testing sets. iris = datasets.load_iris() X = iris.data[:, :2] # For visualization purposes, we use only 2 features y = iris.target return train_test_split(X, y, test_size=0.3, random_state=42) def find_optimal_k(X_train, y_train, max_k=20): Find the optimal value for k using cross-validation. Args: X_train (np.ndarray): Training data. y_train (np.ndarray): Training labels. max_k (int): Maximum value for k to test. Returns: int: Optimal value of k. list: Cross-validation scores for all values of k. pass # Your implementation here def evaluate_model(knn, X_test, y_test): Evaluate the model's performance on the test data. Args: knn (KNeighborsClassifier): Trained KNN model. X_test (np.ndarray): Test data. y_test (np.ndarray): Test labels. Returns: float: Accuracy score. float: Precision score. float: Recall score. float: F1 score. pass # Your implementation here def plot_decision_boundaries(knn, X, y): Visualize the decision boundaries of the KNN model. Args: knn (KNeighborsClassifier): Trained KNN model. X (np.ndarray): Data features. y (np.ndarray): Data labels. pass # Your implementation here","solution":"import numpy as np import matplotlib.pyplot as plt from sklearn import datasets from sklearn.model_selection import train_test_split, cross_val_score from sklearn.neighbors import KNeighborsClassifier from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score def load_iris_data(): iris = datasets.load_iris() X = iris.data[:, :2] # For visualization purposes, we use only 2 features y = iris.target return train_test_split(X, y, test_size=0.3, random_state=42) def find_optimal_k(X_train, y_train, max_k=20): k_range = range(1, max_k + 1) k_scores = [] for k in k_range: knn = KNeighborsClassifier(n_neighbors=k) scores = cross_val_score(knn, X_train, y_train, cv=5, scoring='accuracy') k_scores.append(scores.mean()) optimal_k = k_range[np.argmax(k_scores)] return optimal_k, k_scores def evaluate_model(knn, X_test, y_test): y_pred = knn.predict(X_test) accuracy = accuracy_score(y_test, y_pred) precision = precision_score(y_test, y_pred, average='weighted') recall = recall_score(y_test, y_pred, average='weighted') f1 = f1_score(y_test, y_pred, average='weighted') return accuracy, precision, recall, f1 def plot_decision_boundaries(knn, X, y): h = .02 # step size in the mesh x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1 y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1 xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h)) Z = knn.predict(np.c_[xx.ravel(), yy.ravel()]) Z = Z.reshape(xx.shape) plt.figure(figsize=(8, 6)) plt.contourf(xx, yy, Z, cmap=plt.cm.Paired) plt.scatter(X[:, 0], X[:, 1], c=y, edgecolor='k', cmap=plt.cm.Paired) plt.xlabel('Sepal length') plt.ylabel('Sepal width') plt.title('K-Nearest Neighbors decision boundaries') plt.show() # Main execution X_train, X_test, y_train, y_test = load_iris_data() optimal_k, k_scores = find_optimal_k(X_train, y_train) print(f\\"The optimal value of k is: {optimal_k}\\") knn = KNeighborsClassifier(n_neighbors=optimal_k) knn.fit(X_train, y_train) accuracy, precision, recall, f1 = evaluate_model(knn, X_test, y_test) print(f\\"Accuracy: {accuracy}\\") print(f\\"Precision: {precision}\\") print(f\\"Recall: {recall}\\") print(f\\"F1 Score: {f1}\\") # Plot decision boundaries plot_decision_boundaries(knn, np.vstack((X_train, X_test)), np.hstack((y_train, y_test)))"},{"question":"import re from collections import defaultdict def count_unique_words(file_path): Reads a list of words from a text file, determines all unique words, and returns a dictionary with the counts of each word's occurrence. The function is case-insensitive and ignores numerical words. Parameters: file_path (str): The path to the text file. Returns: dict: A dictionary where keys are unique words and values are their counts. >>> count_unique_words('example.txt') { 'hello': 2, 'world': 1, 'everyone': 1, 'this': 1, 'is': 1, 'a': 1, 'test': 1 } >>> count_unique_words('numbers.txt') { 'there': 1, 'are': 1, 'apples': 1, 'and': 1, 'oranges': 1 }","solution":"import re from collections import defaultdict def count_unique_words(file_path): Reads a list of words from a text file, determines all unique words, and returns a dictionary with the counts of each word's occurrence. Parameters: file_path (str): The path to the text file. Returns: dict: A dictionary where keys are unique words and values are their counts. word_counts = defaultdict(int) with open(file_path, 'r') as file: for line in file: # Use regex to split by any non-alphanumeric characters words = re.split(r'W+', line) for word in words: cleaned_word = word.strip().lower() if cleaned_word and not cleaned_word.isnumeric(): word_counts[cleaned_word] += 1 return dict(word_counts)"},{"question":"def is_valid_parentheses(s: str) -> bool: Check if the input string contains only valid parentheses, brackets, and curly braces in the correct order. :param s: String containing parentheses, brackets, and curly braces :return: True if the string is valid, False otherwise >>> is_valid_parentheses(\\"()\\") True >>> is_valid_parentheses(\\"()[]{}\\") True >>> is_valid_parentheses(\\"{[()]}\\") True >>> is_valid_parentheses(\\"(]\\") False >>> is_valid_parentheses(\\"([)]\\") False >>> is_valid_parentheses(\\"((((((\\") False >>> is_valid_parentheses(\\"\\") True >>> is_valid_parentheses(\\"abc\\") True >>> is_valid_parentheses(\\"a(b)c\\") True >>> is_valid_parentheses(\\"[a]\\") True >>> is_valid_parentheses(\\"{a}\\") True >>> is_valid_parentheses(\\"{[a(b)c]d}\\") True >>> is_valid_parentheses(\\"{[a(b]c)})\\") False >>> is_valid_parentheses(\\"{[()()]}\\") True >>> is_valid_parentheses(\\"{[(())]}\\") True >>> is_valid_parentheses(\\"{[(())]((\\") False","solution":"def is_valid_parentheses(s): Check if the input string contains only valid parentheses, brackets, and curly braces in the correct order. :param s: String containing parentheses, brackets, and curly braces :return: True if the string is valid, False otherwise # Stack to keep track of opening parentheses stack = [] # Dictionary to map closing parentheses to corresponding opening ones matching_bracket = {')': '(', '}': '{', ']': '['} for char in s: if char in matching_bracket.values(): # If it's an opening bracket, push to stack stack.append(char) elif char in matching_bracket.keys(): # If it's a closing bracket, check for correct matching if stack == [] or matching_bracket[char] != stack.pop(): return False # Valid if stack is empty at the end (all opened brackets are closed) return not stack # Space Complexity: O(n) - In the worst case, all characters in the input string are opening brackets. # Time Complexity: O(n) - We traverse the input string once."},{"question":"def remove_k_most_frequent_chars(s: str, k: int) -> str: Removes the k most frequent characters from the string. If two characters have the same frequency, the lexicographically smaller one is removed first. >>> remove_k_most_frequent_chars(\\"aabbcc\\", 2) == \\"cc\\" >>> remove_k_most_frequent_chars(\\"aabbcc\\", 10) == \\"\\" >>> remove_k_most_frequent_chars(\\"aabbcc\\", 0) == \\"aabbcc\\" >>> remove_k_most_frequent_chars(\\"aaaa\\", 1) == \\"\\" >>> remove_k_most_frequent_chars(\\"abcabc\\", 2) == \\"cc\\" >>> remove_k_most_frequent_chars(\\"bcaabc\\", 2) == \\"cc\\" >>> remove_k_most_frequent_chars(\\"\\", 3) == \\"\\"","solution":"from collections import Counter def remove_k_most_frequent_chars(s, k): Removes the k most frequent characters from the string. If two characters have the same frequency, the lexicographically smaller one is removed first. if not s: return \\"\\" # Count frequencies of characters freq = Counter(s) # Sort characters first by frequency (descending) then by lexicographical order (ascending) sorted_chars = sorted(freq, key=lambda x: (-freq[x], x)) # Remove up to k characters chars_to_remove = set() for i in range(k): if i < len(sorted_chars): chars_to_remove.add(sorted_chars[i]) # Build the new string without the k most frequent characters result = ''.join([char for char in s if char not in chars_to_remove]) return result # Example usage: # s = \\"aabbcc\\" # k = 2 # remove_k_most_frequent_chars(s, k) should return \\"cc\\""},{"question":"class Book: def __init__(self, title: str, author: str, isbn: str): Initializes a book with title, author, ISBN and available status. self.__title = title self.__author = author self.__isbn = isbn self.__available = True def borrow(self): Sets the book's availability to False if it's available, otherwise prints that the book is already borrowed. pass def return_book(self): Sets the book's availability to True if it's not available, otherwise prints that the book was not borrowed. pass def display_info(self) -> dict: Returns a dictionary with the book's title, author, ISBN, and availability status. pass class Library: def __init__(self): Initializes the Library with an empty list of books. self.__books = [] def add_book(self, book: Book): Adds a Book object to the Library's list of books. pass def remove_book(self, isbn: str): Removes the book with the given ISBN from the Library's list of books if it exists. pass def find_book_by_title(self, title: str) -> list: Returns a list of dictionaries with details of books matching the given title, or an empty list if no books match. pass def find_book_by_author(self, author: str) -> list: Returns a list of dictionaries with details of books matching the given author, or an empty list if no books match. pass import pytest def test_book_initialization(): book = Book(\\"Harry Potter\\", \\"J.K. Rowling\\", \\"123456\\") info = book.display_info() assert info['title'] == \\"Harry Potter\\" assert info['author'] == \\"J.K. Rowling\\" assert info['isbn'] == \\"123456\\" assert info['available'] == True def test_book_borrow(): book = Book(\\"Harry Potter\\", \\"J.K. Rowling\\", \\"123456\\") book.borrow() assert book.display_info()['available'] == False book.borrow() def test_book_return(): book = Book(\\"Harry Potter\\", \\"J.K. Rowling\\", \\"123456\\") book.borrow() book.return_book() assert book.display_info()['available'] == True book.return_book() def test_add_and_remove_book(): library = Library() book1 = Book(\\"Harry Potter\\", \\"J.K. Rowling\\", \\"123456\\") book2 = Book(\\"The Hobbit\\", \\"J.R.R. Tolkien\\", \\"654321\\") library.add_book(book1) library.add_book(book2) assert len(library._Library__books) == 2 library.remove_book(\\"123456\\") assert len(library._Library__books) == 1 assert library._Library__books[0].display_info()['isbn'] == \\"654321\\" def test_find_book_by_title(): library = Library() book1 = Book(\\"Harry Potter\\", \\"J.K. Rowling\\", \\"123456\\") library.add_book(book1) books = library.find_book_by_title(\\"Harry Potter\\") assert len(books) == 1 assert books[0]['title'] == \\"Harry Potter\\" books2 = library.find_book_by_title(\\"The Hobbit\\") assert len(books2) == 0 def test_find_book_by_author(): library = Library() book1 = Book(\\"Harry Potter\\", \\"J.K. Rowling\\", \\"123456\\") book2 = Book(\\"Fantastic Beasts\\", \\"J.K. Rowling\\", \\"654321\\") library.add_book(book1) library.add_book(book2) books = library.find_book_by_author(\\"J.K. Rowling\\") assert len(books) == 2 assert books[0]['author'] == \\"J.K. Rowling\\" books2 = library.find_book_by_author(\\"George Orwell\\") assert len(books2) == 0","solution":"class Book: def __init__(self, title, author, isbn): self.__title = title self.__author = author self.__isbn = isbn self.__available = True def borrow(self): if self.__available: self.__available = False else: print(f\\"The book '{self.__title}' is already borrowed.\\") def return_book(self): if not self.__available: self.__available = True else: print(f\\"The book '{self.__title}' was not borrowed.\\") def display_info(self): return { 'title': self.__title, 'author': self.__author, 'isbn': self.__isbn, 'available': self.__available } class Library: def __init__(self): self.__books = [] def add_book(self, book): self.__books.append(book) def remove_book(self, isbn): for book in self.__books: if book.display_info()['isbn'] == isbn: self.__books.remove(book) break def find_book_by_title(self, title): return [book.display_info() for book in self.__books if book.display_info()['title'].lower() == title.lower()] def find_book_by_author(self, author): return [book.display_info() for book in self.__books if book.display_info()['author'].lower() == author.lower()]"},{"question":"def increase_age_and_filter(data: dict) -> dict: Returns a new dictionary with ages increased by one year and removes entries where the original age was above 100. Parameters: data (dict): A dictionary with names as keys and ages as values. Returns: dict: A dictionary with names as keys and updated ages as values. >>> increase_age_and_filter({'Alice': 25, 'Bob': 30, 'Catherine': 110, 'Daniel': 99}) {'Alice': 26, 'Bob': 31, 'Daniel': 100} >>> increase_age_and_filter({'Alice': 20, 'Bob': 40, 'Eve': 99}) {'Alice': 21, 'Bob': 41, 'Eve': 100} >>> increase_age_and_filter({'Alice': 101, 'Bob': 150}) {} >>> increase_age_and_filter({'Alice': 100, 'Bob': 99}) {'Alice': 101, 'Bob': 100} >>> increase_age_and_filter({}) {} >>> increase_age_and_filter({'Alice': 0}) {'Alice': 1} >>> large_input = {'Person' + str(i): i for i in range(101)} >>> increase_age_and_filter(large_input) {'Person0': 1, 'Person1': 2, 'Person2': 3, ..., 'Person100': 101}","solution":"def increase_age_and_filter(data): Returns a new dictionary with ages increased by one year and removes entries where the original age was above 100. Parameters: data (dict): A dictionary with names as keys and ages as values. Returns: dict: A dictionary with names as keys and updated ages as values. return {name: age + 1 for name, age in data.items() if age <= 100}"},{"question":"def find_missing_number(nums): Implement a function \`find_missing_number\` that takes in a list of numbers \`nums\`, which contains \`n\` unique integers ranging from 1 to \`n+1\` inclusive, with one number missing. The function should return the missing number. Example: >>> find_missing_number([5, 3, 1, 2]) 4 >>> find_missing_number([1, 2, 3, 5]) 4 >>> find_missing_number([2, 3, 4, 5, 6, 1, 8]) 7 >>> find_missing_number([1, 2]) 3 >>> find_missing_number([2, 3, 4]) 1 >>> find_missing_number([1, 3]) 2 >>> find_missing_number([2]) 1 >>> find_missing_number([]) 1","solution":"def find_missing_number(nums): Returns the missing number from the list of numbers ranging from 1 to n+1. :param nums: List of unique integers ranging from 1 to n+1 with one number missing :return: The missing integer n = len(nums) + 1 total_sum = n * (n + 1) // 2 actual_sum = sum(nums) return total_sum - actual_sum"},{"question":"def jaccard_similarity(str1: str, str2: str) -> float: Calculate the Jaccard similarity between two strings. Args: str1: A string containing words separated by spaces. str2: Another string containing words separated by spaces. Returns: A float representing the Jaccard similarity between the two strings. Example: >>> jaccard_similarity(\\"I love programming\\", \\"programming is fun\\") 0.2 >>> jaccard_similarity(\\"Hello World\\", \\"hello world\\") 1.0 >>> jaccard_similarity(\\"Hello,\\", \\"Hello\\") 0.0 >>> jaccard_similarity(\\"apple orange\\", \\"banana mango\\") 0.0 >>> jaccard_similarity(\\"test string identical\\", \\"test string identical\\") 1.0 >>> jaccard_similarity(\\"\\", \\"\\") 0.0 >>> jaccard_similarity(\\"non empty\\", \\"\\") 0.0","solution":"def jaccard_similarity(str1: str, str2: str) -> float: Calculate the Jaccard similarity between two strings. Args: str1: A string containing words separated by spaces. str2: Another string containing words separated by spaces. Returns: A float representing the Jaccard similarity between the two strings. # Convert both strings to sets of words, ignoring case set1 = set(str1.lower().split()) set2 = set(str2.lower().split()) # Calculate intersection and union of both sets intersection = set1 & set2 union = set1 | set2 # Return the Jaccard similarity if not union: return 0.0 return len(intersection) / len(union)"},{"question":"from typing import List def find_duplicates(arr: List[int]) -> List[int]: Find the duplicate elements in an array. Return a list of all duplicates in the order they first appear. >>> find_duplicates([1, 2, 3, 4, 1, 2, 3]) [1, 2, 3] >>> find_duplicates([5, 6, 7, 8, 9]) [] >>> find_duplicates([10, 20, 10, 30, 20, 30]) [10, 20, 30] pass def test_find_duplicates_with_duplicates(): assert find_duplicates([1, 2, 3, 4, 1, 2, 3]) == [1, 2, 3] def test_find_duplicates_no_duplicates(): assert find_duplicates([5, 6, 7, 8, 9]) == [] def test_find_duplicates_all_unique(): assert find_duplicates([10, 20, 30, 40, 50]) == [] def test_find_duplicates_multiple_occurrences(): assert find_duplicates([10, 20, 10, 30, 20, 30]) == [10, 20, 30] def test_find_duplicates_no_elements(): assert find_duplicates([]) == [] def test_find_duplicates_single_element(): assert find_duplicates([1]) == [] def test_find_duplicates_large_numbers(): assert find_duplicates([10**5, -10**5, 10**5, -10**5, 10**5]) == [10**5, -10**5] def test_find_duplicates_negative_numbers(): assert find_duplicates([-1, -2, -3, -1, -2, -1]) == [-1, -2] def test_find_duplicates_mixed_positive_and_negative(): assert find_duplicates([1, -1, 2, -2, 1, 2, -2]) == [1, 2, -2]","solution":"from typing import List from collections import Counter def find_duplicates(arr: List[int]) -> List[int]: This function returns a list of integers in the input list that appear more than once. count = Counter(arr) duplicates = [element for element, cnt in count.items() if cnt > 1] return duplicates"},{"question":"def find_single_number(nums: list) -> int: Finds the element in the list that appears exactly once. Args: nums (list): A list of integers where each element appears twice except for one. Returns: int: The single number that appears only once. # complete the implementation # Example usage: nums = [4, 1, 2, 1, 2] print(find_single_number(nums)) # Output: 4","solution":"def find_single_number(nums: list) -> int: Finds the element in the list that appears exactly once. Args: nums (list): A list of integers where each element appears twice except for one. Returns: int: The single number that appears only once. count = {} for num in nums: if num in count: count[num] += 1 else: count[num] = 1 for num in nums: if count[num] == 1: return num"},{"question":"import re from collections import Counter class InvalidInputException(Exception): pass def is_permutation_of_palindrome(s): Determine if a given string is a permutation of a palindrome. Ignore spaces, punctuation, and case differences. Raise InvalidInputException when the input string contains numerical digits. >>> is_permutation_of_palindrome(\\"Tact Coa\\") True >>> is_permutation_of_palindrome(\\"A man a plan a canal Panama\\") True >>> is_permutation_of_palindrome(\\"No lemon no melon\\") True >>> is_permutation_of_palindrome(\\"Hello World\\") False >>> is_permutation_of_palindrome(\\"Python\\") False >>> is_permutation_of_palindrome(\\"\\") True >>> is_permutation_of_palindrome(\\"Tact! Coa.\\") True >>> is_permutation_of_palindrome(\\"!A ma@n a pl%an a can*al, Pan.ama!\\") True >>> is_permutation_of_palindrome(\\"Tact Coa 123\\") Traceback (most recent call last): ... InvalidInputException: Input string contains numerical digits >>> is_permutation_of_palindrome(\\"4A man a plan 5a canal6 Panama\\") Traceback (most recent call last): ... InvalidInputException: Input string contains numerical digits","solution":"import re from collections import Counter class InvalidInputException(Exception): pass def is_permutation_of_palindrome(s): Determine if a given string is a permutation of a palindrome. Ignore spaces, punctuation, and case differences. Raise InvalidInputException when the input string contains numerical digits. if any(char.isdigit() for char in s): raise InvalidInputException(\\"Input string contains numerical digits\\") # Remove non-alphabetical characters and convert to lowercase s = re.sub(r'[^a-zA-Z]', '', s).lower() # Count character frequencies char_count = Counter(s) # Check for at most one odd-count character odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"def sum_of_unique_elements(arr): Given an integer array, write a function to find the sum of all the unique elements in the array. >>> sum_of_unique_elements([1, 2, 2, 3, 4]) 10 >>> sum_of_unique_elements([1, 1, 1, 1]) 1 >>> sum_of_unique_elements([]) 0 >>> sum_of_unique_elements([5, 5, 4, 4, 3, 3, 2, 2, 1, 1]) 15 >>> sum_of_unique_elements([-1, -2, -2, -3, -4]) -10 >>> sum_of_unique_elements([0, 0, 0, 0]) 0 >>> sum_of_unique_elements([0, 1, 2, 2, 3]) 6","solution":"def sum_of_unique_elements(arr): Returns the sum of all unique elements in the given array. Parameters: arr (list): A list of integers. Returns: int: The sum of unique elements. return sum(set(arr))"},{"question":"def min_path_sum(matrix): Calculates the minimum cost path in a matrix from the top-left to the bottom-right corner using dynamic programming. Parameters: matrix (list of list of int): The cost matrix where each cell value represents the cost to step onto it. Returns: int: The minimum possible sum of the costs along the path from top-left to bottom-right, or -1 if the input is invalid. >>> min_path_sum([]) -1 >>> min_path_sum([[1, 2], [3, 4, 5]]) -1 >>> min_path_sum([[5]]) 5 >>> min_path_sum([[1, 2], [1, 1]]) 3 >>> min_path_sum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> min_path_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 21 # Your code here","solution":"def min_path_sum(matrix): Calculates the minimum cost path in a matrix from the top-left to the bottom-right corner. Parameters: matrix (list of list of int): The cost matrix where each cell value represents the cost to step onto it. Returns: int: The minimum possible sum of the costs along the path, or -1 if the input is invalid. # Check if matrix is non-empty and rectangular if not matrix or not all(len(row) == len(matrix[0]) for row in matrix): return -1 rows = len(matrix) cols = len(matrix[0]) # Initialize a 2D list to store the cost of the minimum path to each cell dp = [[0] * cols for _ in range(rows)] dp[0][0] = matrix[0][0] # Fill the first row for j in range(1, cols): dp[0][j] = dp[0][j-1] + matrix[0][j] # Fill the first column for i in range(1, rows): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the rest of the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = matrix[i][j] + min(dp[i-1][j], dp[i][j-1]) return dp[rows-1][cols-1]"},{"question":"def string_permutation(s1: str, s2: str) -> bool: Implement a function that takes two strings s1 and s2, and returns True if one string is a permutation of the other, and False otherwise. A permutation is a rearrangement of characters. The function should be case-sensitive. If the two strings are not the same length, they cannot be permutations of each other. >>> string_permutation(\\"abc\\", \\"cab\\") True >>> string_permutation(\\"hello\\", \\"bello\\") False","solution":"def string_permutation(s1: str, s2: str) -> bool: Returns True if s1 is a permutation of s2, and False otherwise. if len(s1) != len(s2): return False return sorted(s1) == sorted(s2)"},{"question":"class Book: def __init__(self, book_id: int, title: str, author: str, year: int, genre: str): Initialize a book object with given details. self.book_id = book_id self.title = title self.author = author self.year = year self.genre = genre class BookCollection: def __init__(self): Initialize an empty book collection. self.books = {} def add_book(self, book: Book): Add a new book to the collection. If the book ID already exists, raise a ValueError. def remove_book(self, book_id: int): Remove a book from the collection by its unique ID. If the book ID does not exist, raise a ValueError. def search_books(self, **kwargs): Search for books by title, author, or year of publication. Accepts keyword arguments for filtering (title, author, year). def display_books(self): Display the details of the entire book collection sorted by year of publication in ascending order. # Test cases def test_add_book(): collection = BookCollection() book1 = Book(1, \\"Title1\\", \\"Author1\\", 2000, \\"Genre1\\") collection.add_book(book1) assert collection.books[1] == book1 def test_add_book_with_duplicate_id(): collection = BookCollection() book1 = Book(1, \\"Title1\\", \\"Author1\\", 2000, \\"Genre1\\") collection.add_book(book1) book2 = Book(1, \\"Title2\\", \\"Author2\\", 2001, \\"Genre2\\") try: collection.add_book(book2) except ValueError as e: assert str(e) == \\"Book ID already exists.\\" def test_remove_book(): collection = BookCollection() book1 = Book(1, \\"Title1\\", \\"Author1\\", 2000, \\"Genre1\\") collection.add_book(book1) collection.remove_book(1) assert 1 not in collection.books def test_remove_nonexistent_book(): collection = BookCollection() try: collection.remove_book(1) except ValueError as e: assert str(e) == \\"Book ID does not exist.\\" def test_search_books_by_title(): collection = BookCollection() book1 = Book(1, \\"Title1\\", \\"Author1\\", 2000, \\"Genre1\\") book2 = Book(2, \\"Title2\\", \\"Author1\\", 2001, \\"Genre1\\") collection.add_book(book1) collection.add_book(book2) result = collection.search_books(title=\\"Title1\\") assert result == [book1] def test_search_books_by_author(): collection = BookCollection() book1 = Book(1, \\"Title1\\", \\"Author1\\", 2000, \\"Genre1\\") book2 = Book(2, \\"Title2\\", \\"Author1\\", 2001, \\"Genre1\\") collection.add_book(book1) collection.add_book(book2) result = collection.search_books(author=\\"Author1\\") assert result == [book1, book2] def test_display_books_order(): collection = BookCollection() book1 = Book(1, \\"Title1\\", \\"Author1\\", 2000, \\"Genre1\\") book2 = Book(2, \\"Title2\\", \\"Author2\\", 1999, \\"Genre2\\") book3 = Book(3, \\"Title3\\", \\"Author3\\", 2005, \\"Genre3\\") collection.add_book(book1) collection.add_book(book2) collection.add_book(book3) result = collection.display_books() assert result == [book2, book1, book3]","solution":"class Book: def __init__(self, book_id, title, author, year, genre): self.book_id = book_id self.title = title self.author = author self.year = year self.genre = genre class BookCollection: def __init__(self): self.books = {} def add_book(self, book): if book.book_id in self.books: raise ValueError(\\"Book ID already exists.\\") self.books[book.book_id] = book def remove_book(self, book_id): if book_id not in self.books: raise ValueError(\\"Book ID does not exist.\\") del self.books[book_id] def search_books(self, **kwargs): result = [] for book in self.books.values(): match = True for key, value in kwargs.items(): if getattr(book, key) != value: match = False break if match: result.append(book) return result def display_books(self): sorted_books = sorted(self.books.values(), key=lambda x: x.year) return sorted_books"},{"question":"def filter_and_sort_books(books): Filters books published before the year 2000 and returns the remaining books sorted by their publication year in ascending order. :param books: list of dictionaries, each representing a book with keys 'title', 'author', and 'year' :return: list of dictionaries of filtered and sorted books pass def test_filter_and_sort_books_all_before_2000(): assert filter_and_sort_books([ {'title': 'Book A', 'author': 'Author A', 'year': 1999}, {'title': 'Book D', 'author': 'Author D', 'year': 1995} ]) == [] def test_filter_and_sort_books_all_after_2000(): assert filter_and_sort_books([ {'title': 'Book B', 'author': 'Author B', 'year': 2001}, {'title': 'Book C', 'author': 'Author C', 'year': 2003} ]) == [ {'title': 'Book B', 'author': 'Author B', 'year': 2001}, {'title': 'Book C', 'author': 'Author C', 'year': 2003} ] def test_filter_and_sort_books_mixed_years(): assert filter_and_sort_books([ {'title': 'Book A', 'author': 'Author A', 'year': 1999}, {'title': 'Book B', 'author': 'Author B', 'year': 2001}, {'title': 'Book C', 'author': 'Author C', 'year': 2005}, {'title': 'Book D', 'author': 'Author D', 'year': 1995}, {'title': 'Book E', 'author': 'Author E', 'year': 2010} ]) == [ {'title': 'Book B', 'author': 'Author B', 'year': 2001}, {'title': 'Book C', 'author': 'Author C', 'year': 2005}, {'title': 'Book E', 'author': 'Author E', 'year': 2010} ] def test_filter_and_sort_books_duplicate_years(): assert filter_and_sort_books([ {'title': 'Book X', 'author': 'Author X', 'year': 2010}, {'title': 'Book Y', 'author': 'Author Y', 'year': 2000}, {'title': 'Book Z', 'author': 'Author Z', 'year': 2010} ]) == [ {'title': 'Book Y', 'author': 'Author Y', 'year': 2000}, {'title': 'Book X', 'author': 'Author X', 'year': 2010}, {'title': 'Book Z', 'author': 'Author Z', 'year': 2010} ]","solution":"def filter_and_sort_books(books): Filters books published before the year 2000 and returns the remaining books sorted by their publication year in ascending order. :param books: list of dictionaries, each representing a book with keys 'title', 'author', and 'year' :return: list of dictionaries of filtered and sorted books filtered_books = [book for book in books if book['year'] >= 2000] sorted_books = sorted(filtered_books, key=lambda x: x['year']) return sorted_books"},{"question":"def max_profit(prices: List[int]) -> int: Analyzes a list of stock prices and determines the maximum possible profit by buying the stock on a particular day and selling it later. Returns -1 if no profit can be made. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) -1 from solution import max_profit def test_max_profit_example_1(): prices = [7, 1, 5, 3, 6, 4] assert max_profit(prices) == 5 def test_max_profit_example_2(): prices = [7, 6, 4, 3, 1] assert max_profit(prices) == -1 def test_max_profit_no_prices(): prices = [] assert max_profit(prices) == -1 def test_max_profit_constant_prices(): prices = [5, 5, 5, 5, 5] assert max_profit(prices) == -1 def test_max_profit_increasing_prices(): prices = [1, 2, 3, 4, 5] assert max_profit(prices) == 4 def test_max_profit_decreasing_then_increasing_prices(): prices = [9, 7, 4, 3, 7, 8] assert max_profit(prices) == 5 def test_max_profit_multiple_peaks(): prices = [3, 5, 1, 10, 2, 20] assert max_profit(prices) == 19 def test_max_profit_single_price(): prices = [10] assert max_profit(prices) == -1","solution":"def max_profit(prices): Returns the maximum profit achievable from buying at one day and selling at a later day. If no profit can be made, returns -1. if not prices: return -1 min_price = prices[0] max_profit = 0 for price in prices[1:]: if price < min_price: min_price = price else: profit = price - min_price if profit > max_profit: max_profit = profit return max_profit if max_profit > 0 else -1"},{"question":"def rotate(nums, k): Rotates the array to the right by k steps. Args: nums: List[int] -- the array of integers to rotate. k: int -- the number of steps to rotate the array. Returns: None -- the function rotates the array in place. # To be implemented: in-place rotation using sequence of reversals def test_rotate_example_1(): nums = [1, 2, 3, 4, 5, 6, 7] k = 3 rotate(nums, k) assert nums == [5, 6, 7, 1, 2, 3, 4] def test_rotate_example_2(): nums = [-1, -100, 3, 99] k = 2 rotate(nums, k) assert nums == [3, 99, -1, -100] def test_rotate_example_3(): nums = [1] k = 0 rotate(nums, k) assert nums == [1] def test_rotate_with_k_greater_than_length(): nums = [1, 2, 3, 4, 5, 6, 7] k = 10 rotate(nums, k) assert nums == [5, 6, 7, 1, 2, 3, 4] def test_rotate_with_large_array(): nums = list(range(1, 101)) # Array with elements from 1 to 100 k = 15 rotate(nums, k) expected = list(range(86, 101)) + list(range(1, 86)) # Expected after rotation assert nums == expected def test_rotate_with_k_equal_to_length(): nums = [1, 2, 3, 4, 5, 6, 7] k = len(nums) rotate(nums, k) assert nums == [1, 2, 3, 4, 5, 6, 7] def test_rotate_no_rotation_needed(): nums = [1, 2, 3, 4, 5, 6, 7] k = 0 rotate(nums, k) assert nums == [1, 2, 3, 4, 5, 6, 7]","solution":"def rotate(nums, k): Rotates the array to the right by k steps. Args: nums: List[int] -- the array of integers to rotate. k: int -- the number of steps to rotate the array. Returns: None -- the function rotates the array in place. n = len(nums) k %= n # in case k is greater than the length of the array def reverse(start, end): Reverses elements in the nums array from index start to end (inclusive). Args: start: int -- the starting index. end: int -- the ending index. while start < end: nums[start], nums[end] = nums[end], nums[start] start += 1 end -= 1 # Step 1: Reverse the entire array reverse(0, n - 1) # Step 2: Reverse the first k elements reverse(0, k - 1) # Step 3: Reverse the rest reverse(k, n - 1)"},{"question":"from typing import List, Tuple def find_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: Design a Python function that accepts a list of integers and a target sum, and returns a list of all unique pairs of integers from the list that add up to the target sum. The same pair of integers should not appear more than once, and each pair should be sorted in non-decreasing order. >>> find_pairs([1, 2, 3, 4, 3, 2, 1], 5) [(1, 4), (2, 3)] >>> find_pairs([1, 2, 3], 7) [] # Example Usage: print(find_pairs([1, 2, 3, 4, 3, 2, 1], 5)) # Output: [(1, 4), (2, 3)]","solution":"def find_pairs(nums, target): Returns a list of all unique pairs of integers from nums that sum up to target. Each pair is sorted in non-decreasing order and no pair appears more than once. nums.sort() # Sorting the list to ensure pairs are in non-decreasing order pairs = set() seen = set() for num in nums: complement = target - num if complement in seen: pairs.add((min(complement, num), max(complement, num))) seen.add(num) return list(pairs)"},{"question":"def basic_calculator(expression: str) -> int: Simulates a basic calculator capable of performing addition, subtraction, multiplication, and division operations given as a string. The function should follow the standard order of operations (PEMDAS/BODMAS). Args: expression (str): A string containing a mathematical expression Returns: int: Result of the evaluated mathematical expression Examples: >>> basic_calculator(\\"3+5*2\\") 13 >>> basic_calculator(\\"10+2*6\\") 22 >>> basic_calculator(\\"100*2-38\\") 162 >>> basic_calculator(\\"14/2+1\\") 8","solution":"def basic_calculator(expression: str) -> int: Simulates a basic calculator capable of performing addition, subtraction, multiplication and division operations in an expression string. It follows the standard order of operations. def operate(operand1, operator, operand2): if operator == '+': return operand1 + operand2 elif operator == '-': return operand1 - operand2 elif operator == '*': return operand1 * operand2 elif operator == '/': return operand1 // operand2 if operand1 * operand2 >= 0 else -(abs(operand1) // abs(operand2)) # Operator precedence map precedence = {'+': 1, '-': 1, '*': 2, '/': 2} def shunting_yard(expression): output = [] operators = [] i = 0 while i < len(expression): if expression[i].isdigit(): num = '' while i < len(expression) and expression[i].isdigit(): num += expression[i] i += 1 output.append(int(num)) i -= 1 elif expression[i] in precedence: while (operators and operators[-1] in precedence and precedence[operators[-1]] >= precedence[expression[i]]): output.append(operators.pop()) operators.append(expression[i]) i += 1 while operators: output.append(operators.pop()) return output def evaluate_rpn(rpn): stack = [] for token in rpn: if isinstance(token, int): stack.append(token) else: operand2 = stack.pop() operand1 = stack.pop() stack.append(operate(operand1, token, operand2)) return stack[0] rpn = shunting_yard(expression) return evaluate_rpn(rpn)"},{"question":"def reverse_string(s: str) -> str: Reverse the given string, including special characters and numbers. >>> reverse_string(\\"hello\\") \\"olleh\\" >>> reverse_string(\\"!@#123abc\\") \\"cba321#@!\\" >>> reverse_string(\\"hello world\\") \\"dlrow olleh\\" >>> reverse_string(\\"123! abc! 456\\") \\"654 !cba !321\\" >>> reverse_string(\\"\\") \\"\\" >>> reverse_string(\\"a\\") \\"a\\" >>> reverse_string(\\"madam\\") \\"madam\\"","solution":"def reverse_string(s): Returns the reversed string of s, handling special characters and numbers. return s[::-1]"},{"question":"import math from typing import List, Tuple def euclidean_distance(coord1: Tuple[float, float], coord2: Tuple[float, float]) -> float: Calculate the Euclidean distance between two coordinates. return math.sqrt((coord1[0] - coord2[0]) ** 2 + (coord1[1] - coord2[1]) ** 2) def nearest_neighbor_algorithm(cities: List[Tuple[str, Tuple[float, float]]]) -> Tuple[List[Tuple[str, Tuple[float, float]]], float]: Develop a program that takes as input a list of cities with their respective coordinates and returns the shortest route that visits each city exactly once, starting and ending at the same city using a nearest neighbor heuristic approach. >>> nearest_neighbor_algorithm([(\\"A\\", (0, 0)), (\\"B\\", (1, 1)), (\\"C\\", (2, 2))]) ([('A', (0, 0)), ('B', (1, 1)), ('C', (2, 2)), ('A', (0, 0))], 4.8284271247461903) >>> nearest_neighbor_algorithm([(\\"A\\", (0, 0))]) ([('A', (0, 0))], 0) pass # Unit Tests def test_single_city(): cities = [(\\"A\\", (0, 0))] route, distance = nearest_neighbor_algorithm(cities) assert route == [(\\"A\\", (0, 0))] and distance == 0 def test_two_cities(): cities = [(\\"A\\", (0, 0)), (\\"B\\", (1, 1))] route, distance = nearest_neighbor_algorithm(cities) assert route == [(\\"A\\", (0, 0)), (\\"B\\", (1, 1)), (\\"A\\", (0, 0))] assert math.isclose(distance, 2 * math.sqrt(2)) def test_three_cities(): cities = [(\\"A\\", (0, 0)), (\\"B\\", (1, 1)), (\\"C\\", (2, 2))] route, distance = nearest_neighbor_algorithm(cities) assert route == [(\\"A\\", (0, 0)), (\\"B\\", (1, 1)), (\\"C\\", (2, 2)), (\\"A\\", (0, 0))] assert math.isclose(distance, 4 * math.sqrt(2)) def test_four_cities(): cities = [(\\"A\\", (0, 0)), (\\"B\\", (1, 1)), (\\"C\\", (2, 2)), (\\"D\\", (3, 3))] route, distance = nearest_neighbor_algorithm(cities) assert route == [(\\"A\\", (0, 0)), (\\"B\\", (1, 1)), (\\"C\\", (2, 2)), (\\"D\\", (3, 3)), (\\"A\\", (0, 0))] assert math.isclose(distance, 6 * math.sqrt(2))","solution":"import itertools import math def euclidean_distance(coord1, coord2): return math.sqrt((coord1[0] - coord2[0]) ** 2 + (coord1[1] - coord2[1]) ** 2) def nearest_neighbor_algorithm(cities): if len(cities) <= 1: return cities, 0 start = cities[0] unvisited = cities[:] visited = [start] unvisited.remove(start) total_distance = 0 current_city = start while unvisited: nearest_city = min(unvisited, key=lambda city: euclidean_distance(current_city[1], city[1])) total_distance += euclidean_distance(current_city[1], nearest_city[1]) current_city = nearest_city visited.append(current_city) unvisited.remove(current_city) total_distance += euclidean_distance(current_city[1], start[1]) # return back to start visited.append(start) return visited, total_distance"},{"question":"def find_equilibrium_index(arr): ''' Create a function that returns the equilibrium index of an array. The equilibrium index is defined as an index such that the sum of elements at lower indices is equal to the sum of elements at higher indices. If no such index exists, return -1. If there are multiple equilibrium indices, return the first one. Example: find_equilibrium_index([1, 3, 5, 2, 2]) ➞ 2 find_equilibrium_index([1, 2, 3, 4, 5]) ➞ -1 find_equilibrium_index([2, 4, 2]) ➞ 1 ''' from solution import find_equilibrium_index def test_find_equilibrium_index_example1(): assert find_equilibrium_index([1, 3, 5, 2, 2]) == 2 def test_find_equilibrium_index_example2(): assert find_equilibrium_index([1, 2, 3, 4, 5]) == -1 def test_find_equilibrium_index_example3(): assert find_equilibrium_index([2, 4, 2]) == 1 def test_find_equilibrium_index_single_element(): assert find_equilibrium_index([1]) == 0 def test_find_equilibrium_index_no_elements(): assert find_equilibrium_index([]) == -1 def test_find_equilibrium_index_all_same_elements(): assert find_equilibrium_index([1, 1, 1, 1, 1, 1, 1]) == 3 def test_find_equilibrium_index_two_elements(): assert find_equilibrium_index([1, 1]) == -1 def test_find_equilibrium_index_negative_numbers(): assert find_equilibrium_index([-7, 1, 5, 2, -4, 3, 0]) == 3 def test_find_equilibrium_index_no_equilibrium(): assert find_equilibrium_index([1, 2, 3, 4, 5, 6]) == -1","solution":"def find_equilibrium_index(arr): ''' Create a function that returns the equilibrium index of an array. The equilibrium index is defined as an index such that the sum of elements at lower indices is equal to the sum of elements at higher indices. If no such index exists, return -1. If there are multiple equilibrium indices, return the first one. Example: find_equilibrium_index([1, 3, 5, 2, 2]) ➞ 2 find_equilibrium_index([1, 2, 3, 4, 5]) ➞ -1 find_equilibrium_index([2, 4, 2]) ➞ 1 ''' total_sum = sum(arr) left_sum = 0 for i, num in enumerate(arr): total_sum -= num if left_sum == total_sum: return i left_sum += num return -1"},{"question":"from typing import List, Dict def banking_system(operations: List[str]) -> Dict[int, int]: Implement a function to simulate a basic banking system. Handles operations such as creating accounts, depositing money, withdrawing money, and checking balances. Each account is represented by an account number (a unique integer) and an initial balance of 0 when created. The following operations will be provided in the list: - \\"create account {account_number}\\": Creates a new account with the specified account number. - \\"deposit {account_number} {amount}\\": Deposits the specified amount into the given account. - \\"withdraw {account_number} {amount}\\": Withdraws the specified amount from the given account. If the account does not have sufficient funds, ignore the withdraw operation. - \\"balance {account_number}\\": Returns the balance of the given account. Args: <<List[str]>> operations: List of operations define above. Returns: <<Dict[int, int]>>: A dictionary where key represents each account number, and value represents the final balance for that account. pass # Example Test Cases def test_create_single_account(): operations = [ \\"create account 101\\" ] expected = { 101: 0 } assert banking_system(operations) == expected def test_create_multiple_accounts(): operations = [ \\"create account 101\\", \\"create account 102\\", \\"create account 103\\" ] expected = { 101: 0, 102: 0, 103: 0 } assert banking_system(operations) == expected def test_deposit_to_account(): operations = [ \\"create account 101\\", \\"deposit 101 500\\" ] expected = { 101: 500 } assert banking_system(operations) == expected def test_withdraw_from_account_with_sufficient_funds(): operations = [ \\"create account 101\\", \\"deposit 101 500\\", \\"withdraw 101 200\\" ] expected = { 101: 300 } assert banking_system(operations) == expected def test_withdraw_from_account_with_insufficient_funds(): operations = [ \\"create account 101\\", \\"deposit 101 500\\", \\"withdraw 101 600\\" ] expected = { 101: 500 } assert banking_system(operations) == expected def test_balance_check_does_not_change_state(): operations = [ \\"create account 101\\", \\"deposit 101 500\\", \\"balance 101\\" ] expected = { 101: 500 } assert banking_system(operations) == expected def test_multiple_operations(): operations = [ \\"create account 101\\", \\"deposit 101 500\\", \\"create account 102\\", \\"deposit 102 200\\", \\"withdraw 101 100\\", \\"balance 101\\", \\"balance 102\\" ] expected = { 101: 400, 102: 200 } assert banking_system(operations) == expected","solution":"from typing import List, Dict def banking_system(operations: List[str]) -> Dict[int, int]: accounts = {} for operation in operations: parts = operation.split() command = parts[0] if command == \\"create\\": account_number = int(parts[2]) accounts[account_number] = 0 elif command == \\"deposit\\": account_number = int(parts[1]) amount = int(parts[2]) if account_number in accounts: accounts[account_number] += amount elif command == \\"withdraw\\": account_number = int(parts[1]) amount = int(parts[2]) if account_number in accounts and accounts[account_number] >= amount: accounts[account_number] -= amount elif command == \\"balance\\": # Balance checking does not alter the account so we skip any operation here pass return accounts"},{"question":"def remove_vowels(input_string: str) -> str: Write a function that takes an input string and returns a string with all the vowels removed. The function should preserve the case of all characters and maintain the order of the remaining characters in the string. :param input_string: The input string :return: A string with all vowels removed >>> remove_vowels(\\"Hello World!\\") == \\"Hll Wrld!\\" >>> remove_vowels(\\"Beautiful Day! Isn't it?\\") == \\"Btfl Dy! sn't t?\\" >>> remove_vowels(\\"Rhythm\\") == \\"Rhythm\\" >>> remove_vowels(\\"Grrr!\\") == \\"Grrr!\\" >>> remove_vowels(\\"\\") == \\"\\" >>> remove_vowels(\\"bcdfghjklmnpqrstvwxyz\\") == \\"bcdfghjklmnpqrstvwxyz\\" >>> remove_vowels(\\"BCDFGHJKLMNPQRSTVWXYZ\\") == \\"BCDFGHJKLMNPQRSTVWXYZ\\" >>> remove_vowels(\\"aEiOuB\\") == \\"B\\" >>> remove_vowels(\\"HEllo\\") == \\"Hll\\"","solution":"def remove_vowels(input_string): Returns a string with all vowels removed. :param input_string: The input string :return: A string with all vowels removed vowels = \\"aeiouAEIOU\\" return ''.join([char for char in input_string if char not in vowels]) # Example usage input_string = \\"Hello World!\\" print(remove_vowels(input_string)) # Output: \\"Hll Wrld!\\""},{"question":"def filter_and_square_evens(numbers: list) -> list: Filters out all the even numbers from the list, squares each of the filtered even numbers, and returns the resultant list. Args: numbers (list): A list of integers. Returns: list: A list of squared even numbers. >>> filter_and_square_evens([2, 4, 6]) [4, 16, 36] >>> filter_and_square_evens([1, 2, 3, 4, 5, 6]) [4, 16, 36] >>> filter_and_square_evens([1, 3, 5, 7]) [] >>> filter_and_square_evens([]) [] >>> filter_and_square_evens([4]) [16] >>> filter_and_square_evens([3]) []","solution":"def filter_and_square_evens(numbers): Filters out all the even numbers from the list, squares each of the filtered even numbers, and returns the resultant list. Args: numbers (list): A list of integers. Returns: list: A list of squared even numbers. # Using list comprehension to filter even numbers and square them return [x**2 for x in numbers if x % 2 == 0]"},{"question":"import json from typing import List def parse_books(json_data: str) -> str: Parses the given JSON data representing a collection of books and returns a summary. If any book entry has incorrect data types or missing fields, those entries will be skipped. The summary is printed in a tabular format with the column headers: 'Title', 'Author', 'Year', 'ISBN'. Args: json_data (str): JSON data representing a collection of books. Returns: str: A formatted string summarizing the book information in tabular format. Examples: >>> json_data = ''' ... [ ... {\\"title\\": \\"Book One\\", \\"author\\": \\"Author A\\", \\"year\\": \\"2001\\", \\"isbn\\": \\"123-4567890123\\"}, ... {\\"title\\": \\"Book Two\\", \\"author\\": \\"Author B\\", \\"year\\": 2003, \\"isbn\\": \\"456-7890123456\\"} ... ] ... ''' >>> print(parse_books(json_data)) Title Author Year ISBN -------------------------------------------------- Book One Author A 2001 123-4567890123 Book Two Author B 2003 456-7890123456 >>> json_data = ''' ... [ ... {\\"title\\": \\"Book One\\", \\"author\\": \\"Author A\\", \\"year\\": \\"2001\\", \\"isbn\\": \\"123-4567890123\\"}, ... {\\"title\\": \\"Book Two\\", \\"author\\": \\"Author B\\", \\"year\\": \\"year_net_given\\", \\"isbn\\": \\"456-7890123456\\"} ... ] ... ''' >>> print(parse_books(json_data)) # Book with invalid year should be skipped Title Author Year ISBN -------------------------------------------------- Book One Author A 2001 123-4567890123 pass import pytest def test_parse_books_valid_entries(): json_data = ''' [ {\\"title\\": \\"Book One\\", \\"author\\": \\"Author A\\", \\"year\\": \\"2001\\", \\"isbn\\": \\"123-4567890123\\"}, {\\"title\\": \\"Book Two\\", \\"author\\": \\"Author B\\", \\"year\\": 2003, \\"isbn\\": \\"456-7890123456\\"} ] ''' result = parse_books(json_data) assert \\"Book OnetAuthor At2001t123-4567890123\\" in result assert \\"Book TwotAuthor Bt2003t456-7890123456\\" in result def test_parse_books_invalid_year(): json_data = ''' [ {\\"title\\": \\"Book One\\", \\"author\\": \\"Author A\\", \\"year\\": \\"2001\\", \\"isbn\\": \\"123-4567890123\\"}, {\\"title\\": \\"Book Two\\", \\"author\\": \\"Author B\\", \\"year\\": \\"year_net_given\\", \\"isbn\\": \\"456-7890123456\\"} ] ''' result = parse_books(json_data) assert \\"Book OnetAuthor At2001t123-4567890123\\" in result assert \\"Book TwotAuthor Bt2003t456-7890123456\\" not in result def test_parse_books_missing_fields(): json_data = ''' [ {\\"title\\": \\"Book One\\", \\"year\\": \\"2001\\", \\"isbn\\": \\"123-4567890123\\"}, {\\"title\\": \\"Book Two\\", \\"author\\": \\"Author B\\", \\"year\\": 2003} ] ''' result = parse_books(json_data) assert \\"TitlettAuthorttYeartISBN\\" in result assert \\"Book One\\" not in result assert \\"Book Two\\" not in result def test_parse_books_mixed_valid_invalid_entries(): json_data = ''' [ {\\"title\\": \\"Book One\\", \\"author\\": \\"Author A\\", \\"year\\": \\"2001\\", \\"isbn\\": \\"123-4567890123\\"}, {\\"title\\": \\"Book Two\\", \\"author\\": \\"Author B\\", \\"year\\": \\"year_net_given\\", \\"isbn\\": \\"456-7890123456\\"}, {\\"title\\": \\"Book Three\\", \\"author\\": \\"Author C\\", \\"year\\": 2003, \\"isbn\\": \\"789-0123456789\\"} ] ''' result = parse_books(json_data) assert \\"Book OnetAuthor At2001t123-4567890123\\" in result assert \\"Book Two\\" not in result assert \\"Book ThreetAuthor Ct2003t789-0123456789\\" in result # Assuming this is the provided JSON data json_data = ''' [ {\\"title\\": \\"Book One\\", \\"author\\": \\"Author A\\", \\"year\\": \\"2001\\", \\"isbn\\": \\"123-4567890123\\"}, {\\"title\\": \\"Book Two\\", \\"author\\": \\"Author B\\", \\"year\\": 2003, \\"isbn\\": \\"456-7890123456\\"}, {\\"title\\": \\"Book Three\\", \\"author\\": \\"Author C\\", \\"year\\": \\"year_net_given\\", \\"isbn\\": \\"789-0123456789\\"} ] ''' # Display the summary print(parse_books(json_data))","solution":"import json def parse_books(json_data): Parses the JSON data representing the collection of books and returns a formatted summary. If any book entry has incorrect data types or missing fields, those entries will be skipped. books = json.loads(json_data) valid_books = [] for book in books: try: title = book['title'] author = book['author'] year = int(book['year']) # This will raise ValueError for non-integer values isbn = book['isbn'] valid_books.append(book) except (KeyError, ValueError): continue # Create summary in a tabular format summary = \\"TitlettAuthorttYeartISBNn\\" summary += \\"-\\" * 50 + \\"n\\" for book in valid_books: summary += f\\"{book['title']}t{book['author']}t{book['year']}t{book['isbn']}n\\" return summary # Assuming this is the provided JSON data json_data = ''' [ {\\"title\\": \\"Book One\\", \\"author\\": \\"Author A\\", \\"year\\": \\"2001\\", \\"isbn\\": \\"123-4567890123\\"}, {\\"title\\": \\"Book Two\\", \\"author\\": \\"Author B\\", \\"year\\": 2003, \\"isbn\\": \\"456-7890123456\\"}, {\\"title\\": \\"Book Three\\", \\"author\\": \\"Author C\\", \\"year\\": \\"year_net_given\\", \\"isbn\\": \\"789-0123456789\\"} ] ''' # Display the summary print(parse_books(json_data))"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_sort_linked_list(head: ListNode) -> ListNode: Create a function that takes as input the head of a singly linked list and returns the head of the sorted linked list using the merge sort algorithm. >>> head = build_linked_list([4, 2, 1, 3]) >>> sorted_head = merge_sort_linked_list(head) >>> linked_list_to_list(sorted_head) [1, 2, 3, 4] >>> head = build_linked_list([4, 2, 1, 3, 2]) >>> sorted_head = merge_sort_linked_list(head) >>> linked_list_to_list(sorted_head) [1, 2, 2, 3, 4] >>> head = None >>> sorted_head = merge_sort_linked_list(head) >>> sorted_head None >>> head = build_linked_list([1]) >>> sorted_head = merge_sort_linked_list(head) >>> linked_list_to_list(sorted_head) [1] >>> head = build_linked_list([1, 2, 3, 4]) >>> sorted_head = merge_sort_linked_list(head) >>> linked_list_to_list(sorted_head) [1, 2, 3, 4] >>> head = build_linked_list([4, 3, 2, 1]) >>> sorted_head = merge_sort_linked_list(head) >>> linked_list_to_list(sorted_head) [1, 2, 3, 4]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_sort_linked_list(head): if not head or not head.next: return head def find_middle(node): slow = node fast = node.next while fast and fast.next: slow = slow.next fast = fast.next.next return slow def merge(left, right): dummy = ListNode() tail = dummy while left and right: if left.val < right.val: tail.next = left left = left.next else: tail.next = right right = right.next tail = tail.next if left: tail.next = left if right: tail.next = right return dummy.next # Step 1: Find the middle point to split the list into two halves middle = find_middle(head) right_head = middle.next middle.next = None left_head = head # Step 2: Recursively sort the two halves left_sorted = merge_sort_linked_list(left_head) right_sorted = merge_sort_linked_list(right_head) # Step 3: Merge the two sorted halves return merge(left_sorted, right_sorted)"},{"question":"def next_permutation(nums: List[int]) -> List[int]: Rearranges the list of integers into the next lexicographical permutation. If the given list is the highest possible permutation, rearrange to the lowest permutation. >>> next_permutation([1, 2, 3]) [1, 3, 2] >>> next_permutation([3, 2, 1]) [1, 2, 3] >>> next_permutation([1, 1, 5]) [1, 5, 1] >>> next_permutation([1]) [1] >>> next_permutation([1, 5, 1]) [5, 1, 1]","solution":"def next_permutation(nums): Rearranges the list of integers into the next lexicographical permutation. If the given list is the highest possible permutation, rearrange to the lowest permutation. # Find the longest non-increasing suffix and identify the pivot i = len(nums) - 2 while i >= 0 and nums[i] >= nums[i + 1]: i -= 1 if i >= 0: j = len(nums) - 1 while nums[j] <= nums[i]: j -= 1 nums[i], nums[j] = nums[j], nums[i] # Reverse the suffix to get the next permutation nums[i + 1:] = reversed(nums[i + 1:]) return nums"},{"question":"from typing import List, Optional def first_non_repeating_integer(arr: List[int]) -> Optional[int]: Returns the first non-repeating integer in the array. If all integers are repeating, returns None. Example: >>> first_non_repeating_integer([4, 5, 1, 2, 0, 4]) 5 >>> first_non_repeating_integer([1, 1, 1, 1]) None pass # Unit Tests def test_first_non_repeating_integer(): assert first_non_repeating_integer([4, 5, 1, 2, 0, 4]) == 5 assert first_non_repeating_integer([1, 1, 1, 1]) == None assert first_non_repeating_integer([9, 4, 9, 6, 7, 4]) == 6 assert first_non_repeating_integer([1, 2, 2, 3, 3]) == 1 assert first_non_repeating_integer([4, 4, 4, 5, 5, 5]) == None assert first_non_repeating_integer([10, 20, 30, 10, 40, 30]) == 20","solution":"def first_non_repeating_integer(arr): Returns the first non-repeating integer in the array. If all integers are repeating, returns None. from collections import Counter count = Counter(arr) for num in arr: if count[num] == 1: return num return None # Example use: # print(first_non_repeating_integer([4, 5, 1, 2, 0, 4])) # Should return 5 # print(first_non_repeating_integer([1, 1, 1, 1])) # Should return None"},{"question":"from typing import List def max_subarray(nums: List[int]) -> int: Determines the maximum sum of a contiguous subarray using the divide and conquer approach. >>> max_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray([1]) 1 >>> max_subarray([5, 4, -1, 7, 8]) 23","solution":"def max_crossing_sum(nums, left, mid, right): A utility function to find the maximum sum of the subarray crossing the midpoint. # Include elements on left of mid. sum_left = float('-inf') total = 0 for i in range(mid, left - 1, -1): total += nums[i] if total > sum_left: sum_left = total # Include elements on right of mid. sum_right = float('-inf') total = 0 for i in range(mid + 1, right + 1): total += nums[i] if total > sum_right: sum_right = total # Return sum of elements on left and right of mid. return sum_left + sum_right def max_subarray_sum(nums, left, right): Use the divide and conquer approach to find the maximum subarray sum. if left == right: return nums[left] mid = (left + right) // 2 return max( max_subarray_sum(nums, left, mid), max_subarray_sum(nums, mid + 1, right), max_crossing_sum(nums, left, mid, right) ) def max_subarray(nums): Returns the maximum sum of a contiguous subarray using the divide and conquer approach. return max_subarray_sum(nums, 0, len(nums) - 1)"},{"question":"from typing import List def most_frequent_word(text: str) -> str: Returns the word that appears the most frequently in the text. In case of a tie, returns the word that comes first lexicographically. >>> most_frequent_word(\\"apple banana apple orange banana banana\\") \\"banana\\" >>> most_frequent_word(\\"hello hello world\\") \\"hello\\" >>> most_frequent_word(\\"a b c d e f g a b c a b c d e f a\\") \\"a\\"","solution":"from collections import Counter def most_frequent_word(text: str) -> str: Returns the word that appears the most frequently in the text. In case of a tie, returns the word that comes first lexicographically. words = text.split() count = Counter(words) max_count = max(count.values()) most_frequent_words = [word for word, freq in count.items() if freq == max_count] return min(most_frequent_words)"},{"question":"def compress_string(input_string: str) -> str: Compresses the input string by replacing groups of consecutive identical characters with that character followed by the number of times it appears consecutively. Returns the original string if the compressed version is not shorter. >>> compress_string(\\"aaabbccc\\") \\"a3b2c3\\" >>> compress_string(\\"abcdef\\") \\"abcdef\\" >>> compress_string(\\"aabcccccaaa\\") \\"a2b1c5a3\\" >>> compress_string(\\"a\\") \\"a\\" >>> compress_string(\\"bb\\") \\"bb\\"","solution":"def compress_string(input_string: str) -> str: Compresses the input string by replacing groups of consecutive identical characters with that character followed by the number of times it appears consecutively. Returns the original string if the compressed version is not shorter. if not input_string: return input_string compressed = [] count = 1 previous_char = input_string[0] for i in range(1, len(input_string)): if input_string[i] == previous_char: count += 1 else: compressed.append(previous_char + str(count)) previous_char = input_string[i] count = 1 compressed.append(previous_char + str(count)) compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(input_string) else input_string"},{"question":"from typing import List def is_prime(n: int) -> bool: Determines if a number is prime. >>> is_prime(2) True >>> is_prime(4) False def filter_primes(lst: List[int]) -> List[int]: Filters the prime numbers from a list of integers. >>> filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> filter_primes([11, 12, 13, 14, 15, 16, 17]) [11, 13, 17]","solution":"def is_prime(n): Determines if a number is prime. Args: n (int): The number to check. Returns: bool: True if n is a prime number, else False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(lst): Filters the prime numbers from a list of integers. Args: lst (list): List of integers. Returns: list: A new list containing only the prime numbers from the original list. return [x for x in lst if is_prime(x)]"},{"question":"class Point: def __init__(self, x, y): self.x = x self.y = y def __str__(self): return f\\"({self.x}, {self.y})\\" def distance_to(self, other): return ((self.x - other.x) ** 2 + (self.y - other.y) ** 2) ** 0.5 class Polygon: Represents a polygon defined by multiple points. def __init__(self, points): Initializes the Polygon with a list of Point objects. def __str__(self): Returns a string representation of the Polygon as a list of points. def perimeter(self): Returns the perimeter of the Polygon. Example: >>> points = [Point(0, 0), Point(4, 0), Point(4, 3)] >>> polygon = Polygon(points) >>> print(polygon) (0, 0) -> (4, 0) -> (4, 3) -> (0, 0) >>> print(polygon.perimeter()) 12.0 def test_point_creation(): p = Point(1, 2) assert p.x == 1 assert p.y == 2 def test_point_str(): p = Point(3, 4) assert str(p) == \\"(3, 4)\\" def test_distance_to(): p1 = Point(0, 0) p2 = Point(3, 4) assert p1.distance_to(p2) == 5.0 def test_polygon_creation(): points = [Point(0, 0), Point(4, 0), Point(4, 3)] polygon = Polygon(points) assert len(polygon.points) == 3 def test_polygon_creation_invalid(): points = [Point(0, 0), Point(4, 0)] try: Polygon(points) assert False, \\"Expected ValueError\\" except ValueError as e: assert str(e) == \\"A polygon must have at least 3 points\\" def test_polygon_str(): points = [Point(0, 0), Point(4, 0), Point(4, 3)] polygon = Polygon(points) expected_output = \\"(0, 0) -> (4, 0) -> (4, 3) -> (0, 0)\\" assert str(polygon) == expected_output def test_polygon_perimeter(): points = [Point(0, 0), Point(4, 0), Point(4, 3)] polygon = Polygon(points) assert polygon.perimeter() == 12.0 def test_polygon_perimeter_with_more_points(): points = [Point(0, 0), Point(4, 0), Point(4, 3), Point(0, 3)] polygon = Polygon(points) assert polygon.perimeter() == 14.0","solution":"class Point: def __init__(self, x, y): self.x = x self.y = y def __str__(self): return f\\"({self.x}, {self.y})\\" def distance_to(self, other): return ((self.x - other.x) ** 2 + (self.y - other.y) ** 2) ** 0.5 class Polygon: def __init__(self, points): if len(points) < 3: raise ValueError(\\"A polygon must have at least 3 points\\") self.points = points def __str__(self): return \\" -> \\".join(str(point) for point in self.points) + f\\" -> {str(self.points[0])}\\" def perimeter(self): perimeter = 0.0 for i in range(len(self.points)): next_point = self.points[(i + 1) % len(self.points)] perimeter += self.points[i].distance_to(next_point) return perimeter"},{"question":"def palindromic_substrings(s: str) -> int: Returns the number of palindromic substrings in the given string. >>> palindromic_substrings(\\"a\\") 1 >>> palindromic_substrings(\\"aaa\\") 6 >>> palindromic_substrings(\\"abc\\") 3 >>> palindromic_substrings(\\"racecar\\") 10 >>> palindromic_substrings(\\"abcd\\") 4 >>> palindromic_substrings(\\"aba\\") 4 >>> palindromic_substrings(\\"\\") 0","solution":"def palindromic_substrings(s): Returns the number of palindromic substrings in the given string. n = len(s) count = 0 # Function to count palindromes centered at left and right def count_palindromes_around_center(left, right): nonlocal count while left >= 0 and right < n and s[left] == s[right]: count += 1 left -= 1 right += 1 for center in range(n): # Odd-length palindromes count_palindromes_around_center(center, center) # Even-length palindromes count_palindromes_around_center(center, center + 1) return count"},{"question":"def merge_alternate_elements(list1, list2): Merges two lists by alternating elements. If one list is longer, append the remaining elements of the longer list. Parameters: - list1: The first list. - list2: The second list. Returns: - A new list containing elements from list1 and list2 alternately. >>> merge_alternate_elements([1, 2, 3], ['a', 'b', 'c', 'd', 'e']) [1, 'a', 2, 'b', 3, 'c', 'd', 'e'] >>> merge_alternate_elements([], [1, 2, 3]) [1, 2, 3] >>> merge_alternate_elements(['a', 'b', 'c'], []) ['a', 'b', 'c'] >>> merge_alternate_elements([], []) [] >>> merge_alternate_elements([1, 2], ['a', 'b', 'c', 'd']) [1, 'a', 2, 'b', 'c', 'd'] >>> merge_alternate_elements([1, 2, 3, 4], ['a', 'b']) [1, 'a', 2, 'b', 3, 4] >>> merge_alternate_elements([1], ['a']) [1, 'a'] >>> merge_alternate_elements([1], ['a', 'b', 'c']) [1, 'a', 'b', 'c'] >>> merge_alternate_elements([1, 2, 3], ['a']) [1, 'a', 2, 3] >>> merge_alternate_elements([1, 'b', 3.5], ['a', {}, []]) [1, 'a', 'b', {}, 3.5, []]","solution":"def merge_alternate_elements(list1, list2): Merges two lists by alternating elements. If one list is longer, append the remaining elements of the longer list. Parameters: - list1: The first list. - list2: The second list. Returns: - A new list containing elements from list1 and list2 alternately. merged_list = [] len1, len2 = len(list1), len(list2) min_length = min(len1, len2) for i in range(min_length): merged_list.append(list1[i]) merged_list.append(list2[i]) if len1 > min_length: merged_list.extend(list1[min_length:]) if len2 > min_length: merged_list.extend(list2[min_length:]) return merged_list"},{"question":"def fibonacci(n: int) -> int: Returns the nth number in the Fibonacci sequence. The Fibonacci sequence is characterized by the fact that every number after the first two is the sum of the two preceding ones, starting from 0 and 1. Args: n (int): The position in the Fibonacci sequence (0-indexed). Returns: int: The nth Fibonacci number. >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(5) 5 >>> fibonacci(6) 8","solution":"def fibonacci(n): Returns the nth number in the Fibonacci sequence. if n < 0: raise ValueError(\\"Input should be a non-negative integer\\") elif n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"from typing import List def merge_and_sort_descending(list1: List[int], list2: List[int]) -> List[int]: Merges two lists into a single list, sorts it in descending order, and removes duplicate values. >>> merge_and_sort_descending([3, 1, 4, 4, 7], [9, 2, 2, 5]) [9, 7, 5, 4, 3, 2, 1] >>> merge_and_sort_descending([], [9, 2, 2, 5]) [9, 5, 2] >>> merge_and_sort_descending([6, 3, 8, 5], [2, 7, 1, 4]) [8, 7, 6, 5, 4, 3, 2, 1] >>> merge_and_sort_descending([1, 1, 1], [1, 1, 1]) [1] >>> merge_and_sort_descending([3, -1, 4, -4, 7], [9, -2, 2, -5]) [9, 7, 4, 3, 2, -1, -2, -4, -5]","solution":"def merge_and_sort_descending(list1, list2): Merges two lists into a single list, sorts it in descending order, and removes duplicate values. # Use set to remove duplicates and combine the lists combined_set = set(list1).union(set(list2)) # Convert set back to list and sort in descending order using a sorting algorithm (quick sort) combined_list = list(combined_set) def quick_sort_descending(arr): if len(arr) <= 1: return arr pivot = arr[0] left = [x for x in arr[1:] if x > pivot] right = [x for x in arr[1:] if x <= pivot] return quick_sort_descending(left) + [pivot] + quick_sort_descending(right) return quick_sort_descending(combined_list)"},{"question":"from typing import List def find_single_number(nums: List[int]) -> int: Returns the integer that appears only once in the list. Every other integer appears exactly twice. This implementation should use O(n) time complexity and O(1) extra space. >>> find_single_number([4, 1, 2, 1, 2]) 4 >>> find_single_number([2, 2, 1]) 1 >>> find_single_number([99]) 99 >>> find_single_number([-1, -2, -2, -1, -3]) -3 >>> find_single_number([1, -1, 2, -2, 3, 3, -2, 2, 1]) -1","solution":"from typing import List def find_single_number(nums: List[int]) -> int: Returns the integer that appears only once in the list. Every other integer appears exactly twice. This implementation uses XOR to achieve O(n) time complexity and O(1) extra space. single_number = 0 for num in nums: single_number ^= num return single_number"},{"question":"from typing import List def sum_of_non_primes(numbers: List[int]) -> int: This function takes a list of integers and filters out all prime numbers. It then returns the sum of the remaining integers. If there are no non-prime numbers, it returns 0. >>> sum_of_non_primes([2, 3, 5, 7, 10, 12]) 22 >>> sum_of_non_primes([13, 17, 19, 23]) 0 >>> sum_of_non_primes([4, 6, 8, 9, 10]) 37 pass def test_sum_of_non_primes_with_mixed_numbers(): assert sum_of_non_primes([2, 3, 5, 7, 10, 12]) == 22 def test_sum_of_non_primes_with_all_prime_numbers(): assert sum_of_non_primes([13, 17, 19, 23]) == 0 def test_sum_of_non_primes_with_all_non_prime_numbers(): assert sum_of_non_primes([4, 6, 8, 9, 10]) == 37 def test_sum_of_non_primes_with_mixed_prime_and_non_prime(): assert sum_of_non_primes([1, 4, 6, 7, 9, 11, 15]) == 35 def test_sum_of_non_primes_with_empty_list(): assert sum_of_non_primes([]) == 0 def test_sum_of_non_primes_with_all_ones(): assert sum_of_non_primes([1, 1, 1]) == 3 def test_sum_of_non_primes_with_single_prime(): assert sum_of_non_primes([7]) == 0 def test_sum_of_non_primes_with_single_non_prime(): assert sum_of_non_primes([4]) == 4","solution":"from typing import List def is_prime(n: int) -> bool: Helper function to determine if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def sum_of_non_primes(numbers: List[int]) -> int: This function takes a list of integers and filters out all prime numbers. It then returns the sum of the remaining integers. If there are no non-prime numbers, it returns 0. non_primes = [n for n in numbers if not is_prime(n)] return sum(non_primes)"},{"question":"def find_nth_fibonacci(n: int) -> int: Returns the nth Fibonacci number. If n is negative, returns -1. :param n: The position in the Fibonacci sequence. :return: The nth Fibonacci number or -1 if n is negative. >>> find_nth_fibonacci(0) 0 >>> find_nth_fibonacci(1) 1 >>> find_nth_fibonacci(2) 1 >>> find_nth_fibonacci(3) 2 >>> find_nth_fibonacci(10) 55 >>> find_nth_fibonacci(-1) -1 >>> find_nth_fibonacci(20) 6765","solution":"def find_nth_fibonacci(n): Returns the nth Fibonacci number. :param n: The position in the Fibonacci sequence. :return: The nth Fibonacci number or -1 if n is negative. if n < 0: return -1 elif n == 0: return 0 elif n == 1: return 1 prev, curr = 0, 1 for _ in range(2, n + 1): prev, curr = curr, prev + curr return curr"},{"question":"from typing import List def find_most_frequent(nums: List[int]) -> int: Returns the integer that appears most frequently in the list. If there is a tie, return the smallest integer with the highest frequency. >>> find_most_frequent([1, 3, 3, 2, 1, 3, 1, 2, 1]) 1 >>> find_most_frequent([4, 5, 6, 7, 6, 5, 6, 4, 4]) 4 >>> find_most_frequent([10, 9, 8, 9, 10, 7, 8, 8]) 8 from solution import find_most_frequent def test_single_most_frequent_element(): assert find_most_frequent([1, 3, 3, 2, 1, 3, 1, 2, 1]) == 1 def test_tie_favors_smallest_element(): assert find_most_frequent([4, 5, 6, 7, 6, 5, 6, 4, 4]) == 4 assert find_most_frequent([10, 9, 8, 9, 10, 7, 8, 8]) == 8 def test_single_element_list(): assert find_most_frequent([1]) == 1 def test_all_elements_unique(): assert find_most_frequent([1, 2, 3, 4, 5]) == 1 def test_multiple_most_frequent_elements(): assert find_most_frequent([10, 10, 20, 20, 30, 30]) == 10 assert find_most_frequent([5, 5, 5, 4, 4, 4, 4]) == 4 def test_large_input(): large_input = [5] * 1000 + [4] * 1001 assert find_most_frequent(large_input) == 4","solution":"from typing import List from collections import Counter def find_most_frequent(nums: List[int]) -> int: Returns the integer that appears most frequently in the list. If there is a tie, return the smallest integer with the highest frequency. counter = Counter(nums) most_common = counter.most_common() max_freq = most_common[0][1] most_frequent_candidates = [num for num, freq in most_common if freq == max_freq] return min(most_frequent_candidates)"},{"question":"import torch import torch.nn as nn import torch.optim as optim from sklearn.metrics import mean_absolute_error class HousePricePredictor(nn.Module): def __init__(self, input_dim): super(HousePricePredictor, self).__init__() self.fc1 = nn.Linear(input_dim, 128) self.fc2 = nn.Linear(128, 64) self.fc3 = nn.Linear(64, 32) self.fc4 = nn.Linear(32, 1) def forward(self, x): x = torch.relu(self.fc1(x)) x = torch.relu(self.fc2(x)) x = torch.relu(self.fc3(x)) x = self.fc4(x) return x def train_model(model, dataloader, epochs=100): Train the neural network model. Parameters: model (nn.Module): The neural network model to be trained. dataloader (DataLoader): Training data loader. epochs (int): Number of epochs to train. Returns: nn.Module: The trained model. criterion = nn.MSELoss() optimizer = optim.Adam(model.parameters(), lr=0.001) for epoch in range(epochs): for inputs, targets in dataloader: optimizer.zero_grad() outputs = model(inputs) loss = criterion(outputs, targets) loss.backward() optimizer.step() return model def evaluate_model(model, X_test, y_test): Evaluate the neural network model. Parameters: model (nn.Module): The trained neural network model. X_test (Tensor): Test features. y_test (Tensor): True test target values. Returns: float: Mean Absolute Error between the model predictions and true values. model.eval() with torch.no_grad(): predictions = model(X_test).numpy() return mean_absolute_error(y_test, predictions)","solution":"import torch import torch.nn as nn import torch.optim as optim from sklearn.metrics import mean_absolute_error class HousePricePredictor(nn.Module): def __init__(self, input_dim): super(HousePricePredictor, self).__init__() self.fc1 = nn.Linear(input_dim, 128) self.fc2 = nn.Linear(128, 64) self.fc3 = nn.Linear(64, 32) self.fc4 = nn.Linear(32, 1) def forward(self, x): x = torch.relu(self.fc1(x)) x = torch.relu(self.fc2(x)) x = torch.relu(self.fc3(x)) x = self.fc4(x) return x def train_model(model, dataloader, epochs=100): criterion = nn.MSELoss() optimizer = optim.Adam(model.parameters(), lr=0.001) for epoch in range(epochs): for inputs, targets in dataloader: optimizer.zero_grad() outputs = model(inputs) loss = criterion(outputs, targets) loss.backward() optimizer.step() return model def evaluate_model(model, X_test, y_test): model.eval() with torch.no_grad(): predictions = model(X_test).numpy() return mean_absolute_error(y_test, predictions)"},{"question":"def sieve_of_eratosthenes(n: int) -> List[int]: Develop a function that takes an integer \`n\` and returns a list of all prime numbers less than \`n\`. The function should implement an efficient algorithm for finding prime numbers, such as the Sieve of Eratosthenes. >>> sieve_of_eratosthenes(0) [] >>> sieve_of_eratosthenes(1) [] >>> sieve_of_eratosthenes(2) [] >>> sieve_of_eratosthenes(10) [2, 3, 5, 7] >>> sieve_of_eratosthenes(20) [2, 3, 5, 7, 11, 13, 17, 19]","solution":"def sieve_of_eratosthenes(n): Returns a list of all prime numbers less than n using the Sieve of Eratosthenes algorithm. if n < 2: return [] # Initialize a boolean array indicating primality of each number < n is_prime = [True] * n is_prime[0], is_prime[1] = False, False # 0 and 1 are not prime numbers p = 2 while (p * p < n): # If p is still marked as prime if is_prime[p]: # Mark all multiples of p as not prime for i in range(p * p, n, p): is_prime[i] = False p += 1 # Collect all prime numbers primes = [i for i, prime in enumerate(is_prime) if prime] return primes"},{"question":"from typing import List def longest_increasing_span(temperatures: List[int]) -> int: Returns the length of the longest span of consecutive days with increasing temperatures. >>> longest_increasing_span([73, 74, 75, 71, 69, 72, 76, 73]) 3 >>> longest_increasing_span([30, 31, 32, 33, 34]) 5 >>> longest_increasing_span([40, 38, 35, 33, 35, 40, 45, 50, 55, 40]) 6","solution":"def longest_increasing_span(temperatures): Returns the length of the longest span of consecutive days with increasing temperatures. if not temperatures: return 0 max_span = 1 current_span = 1 for i in range(1, len(temperatures)): if temperatures[i] > temperatures[i - 1]: current_span += 1 max_span = max(max_span, current_span) else: current_span = 1 return max_span"},{"question":"from typing import List import matplotlib.pyplot as plt def find_primes(arr: List[int]) -> List[int]: Returns a list of prime numbers from the given list 'arr'. >>> find_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) == [2, 3, 5, 7] >>> find_primes([0, 1, 11, 13, 17]) == [11, 13, 17] >>> find_primes([15, 22, 33, 35]) == [] >>> find_primes([29, 29, 29, 29]) == [29, 29, 29, 29] >>> find_primes([]) == [] >>> find_primes([2, 4, 6, 8, 10]) == [2] def plot_prime_frequencies(prime_list: List[int]): Plots the frequencies of prime numbers in the prime_list using a bar chart. >>> plot_prime_frequencies([2, 3, 2, 5, 3, 7]) >>> plot_prime_frequencies([11, 13, 11, 17]) >>> plot_prime_frequencies([])","solution":"import matplotlib.pyplot as plt def sieve_of_eratosthenes(n): Generates all prime numbers up to n using the Sieve of Eratosthenes algorithm. sieve = [True] * (n+1) p = 2 while (p * p <= n): if sieve[p]: for i in range(p * p, n+1, p): sieve[i] = False p += 1 return [p for p in range(2, n+1) if sieve[p]] def find_primes(arr): Returns a list of prime numbers from the given list 'arr'. if not arr: return [] max_val = max(arr) primes = sieve_of_eratosthenes(max_val) return [x for x in arr if x in primes] def plot_prime_frequencies(prime_list): Plots the frequencies of prime numbers in the prime_list using a bar chart. prime_counts = {} for prime in prime_list: if prime in prime_counts: prime_counts[prime] += 1 else: prime_counts[prime] = 1 primes = list(prime_counts.keys()) frequencies = list(prime_counts.values()) plt.figure(figsize=(10, 6)) plt.bar(primes, frequencies, color='blue') plt.xlabel('Prime Numbers') plt.ylabel('Frequencies') plt.title('Frequency of Prime Numbers in the List') plt.show()"},{"question":"def sum_of_products(lst1, lst2): This function returns the sum of the product of elements at corresponding positions in two lists. >>> sum_of_products([1, 2, 3], [4, 5, 6]) 32 >>> sum_of_products([2], [3]) 6 >>> sum_of_products([0, 1, 2], [3, 0, 1]) 2 >>> sum_of_products([], []) 0 >>> sum_of_products([1, 2], [1]) 'The lengths of both lists should be equal.' >>> sum_of_products([-1, -2, -3], [1, 2, 3]) -14 >>> sum_of_products([1, -2, 3], [-1, 2, -3]) -14","solution":"def sum_of_products(lst1, lst2): # Check if the lengths of both lists are equal if len(lst1) != len(lst2): return 'The lengths of both lists should be equal.' product_sum = 0 # Iterate over the elements of the lists for i in range(len(lst1)): product_sum += lst1[i] * lst2[i] return product_sum"},{"question":"def compile_words(text: str, length: int) -> str: Returns a string containing all words from the input text that are longer than the given length, separated by a single space. >>> compile_words(\\"The quick brown fox jumps over the lazy dog\\", 3) \\"quick brown jumps over lazy\\" >>> compile_words(\\"\\", 3) \\"\\" >>> compile_words(\\"a an on in\\", 2) \\"\\" >>> compile_words(\\"elephant giraffe kangaroo\\", 3) \\"elephant giraffe kangaroo\\" >>> compile_words(\\"Hello! Are you ready to go?\\", 3) \\"Hello! ready\\" >>> compile_words(\\"antidisestablishmentarianism\\", 5) \\"antidisestablishmentarianism\\" >>> compile_words(\\"Python python PYTHON\\", 5) \\"Python python PYTHON\\"","solution":"def compile_words(text, length): Returns a string containing all words from text that are longer than the given length, separated by a single space. Parameters: - text (str): The input string containing words. - length (int): The minimum word length to include. Returns: - str: A string of words longer than the given length, separated by a single space. words = text.split() long_words = [word for word in words if len(word) > length] return ' '.join(long_words)"},{"question":"def second_largest_unique(numbers: List[int]) -> Optional[int]: Returns the second largest unique number in the list. If there is no second largest unique number, or if the list is empty, return None. >>> second_largest_unique([3, 5, 7, 5, 6, 7]) 6 >>> second_largest_unique([5, 5, 5]) None >>> second_largest_unique([]) None >>> second_largest_unique([1]) None >>> second_largest_unique([1, 2]) 1 >>> second_largest_unique([-1, -2, -3, -4]) -2 >>> second_largest_unique([3, 3, 3, 3, 2, 2, 1, 1]) 2 >>> second_largest_unique([2, 2, 2, 2]) None >>> second_largest_unique([4, 4, 4, 4, 4]) None >>> second_largest_unique([8, 4, 6, 3, 9, 7]) 8 >>> second_largest_unique([-10, 5, -3, -2, 7, 9, -1, 9]) 7","solution":"def second_largest_unique(numbers): Returns the second largest unique number in the list. If there is no second largest unique number, or if the list is empty, return None. if not numbers: return None unique_numbers = set(numbers) if len(unique_numbers) < 2: return None max_num = float('-inf') second_max_num = float('-inf') for num in unique_numbers: if num > max_num: second_max_num = max_num max_num = num elif num > second_max_num: second_max_num = num return second_max_num"},{"question":"def matrix_diagonal(matrix: List[List[int]]) -> List[int]: Returns the elements from the main diagonal of the square matrix. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> matrix_diagonal(matrix) [1, 5, 9] >>> matrix = [ ... [10, 20], ... [30, 40] ... ] >>> matrix_diagonal(matrix) [10, 40] >>> matrix = [ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ] >>> matrix_diagonal(matrix) [1, 6, 11, 16] >>> matrix = [ ... [42] ... ] >>> matrix_diagonal(matrix) [42] >>> matrix = [ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ] >>> matrix_diagonal(matrix) [-1, -5, -9]","solution":"def matrix_diagonal(matrix): Returns the elements from the main diagonal of the square matrix. return [matrix[i][i] for i in range(len(matrix))]"},{"question":"from typing import List def is_prime(num: int) -> bool: Check if a number is prime. if num < 2: return False for i in range(2, int(num ** 0.5) + 1): if num % i == 0: return False return True def filter_primes(arr: List[int]) -> List[int]: Returns an array containing only the prime numbers from the original array in the same order. >>> filter_primes([10, 29, 15, 17, 93, 97]) [29, 17, 97] >>> filter_primes([4, 6, 8, 10]) [] pass # Unit Tests def test_filter_primes_all_primes(): assert filter_primes([2, 3, 5, 7]) == [2, 3, 5, 7] def test_filter_primes_no_primes(): assert filter_primes([4, 6, 8, 10]) == [] def test_filter_primes_mixed_numbers(): assert filter_primes([10, 29, 15, 17, 93, 97]) == [29, 17, 97] assert filter_primes([18, 19, 21, 23, 24]) == [19, 23] def test_filter_primes_empty_array(): assert filter_primes([]) == [] def test_filter_primes_single_prime(): assert filter_primes([11]) == [11] def test_filter_primes_single_non_prime(): assert filter_primes([1]) == []","solution":"def is_prime(num): Check if a number is prime. if num < 2: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True def filter_primes(arr): Returns an array containing only the prime numbers from the original array in the same order. return [x for x in arr if is_prime(x)]"},{"question":"import pandas as pd import matplotlib.pyplot as plt def generate_sales_report(employees): Takes a list of dictionaries representing employees and their respective sales data, and generates a sales report. Parameters: employees (list): A list of dictionaries with keys 'name' and 'sales'. Returns: dict: A dictionary containing total sales per employee, average sales per employee, and top performer. >>> generate_sales_report([{'name': 'Alice', 'sales': 150}]) == { ... 'total_sales': {'Alice': 150}, ... 'average_sales': {'Alice': 150.0}, ... 'top_performer': 'Alice' ... } >>> generate_sales_report([ ... {'name': 'Alice', 'sales': 150}, ... {'name': 'Bob', 'sales': 200}, ... {'name': 'Alice', 'sales': 300}, ... {'name': 'Bob', 'sales': 100} ... ]) == { ... 'total_sales': {'Alice': 450, 'Bob': 300}, ... 'average_sales': {'Alice': 225.0, 'Bob': 150.0}, ... 'top_performer': 'Alice' ... }","solution":"import pandas as pd import matplotlib.pyplot as plt def generate_sales_report(employees): Takes a list of dictionaries representing employees and their respective sales data, and generates a sales report. Parameters: employees (list): A list of dictionaries with keys 'name' and 'sales'. Returns: dict: A dictionary containing total sales per employee, average sales per employee, and top performer. df = pd.DataFrame(employees) total_sales = df.groupby('name')['sales'].sum().to_dict() average_sales = df.groupby('name')['sales'].mean().to_dict() top_performer = df.groupby('name')['sales'].sum().idxmax() # Visualization df.groupby('name')['sales'].sum().plot(kind='bar', title='Total Sales per Employee') plt.xlabel('Employee') plt.ylabel('Total Sales') plt.show() report = { 'total_sales': total_sales, 'average_sales': average_sales, 'top_performer': top_performer } return report"},{"question":"def find_pairs(nums: List[int], k: int) -> List[Tuple[int, int]]: Returns a list of unique pairs from nums that sum up to k. Args: nums (List[int]): List of integers. k (int): Target sum for the pairs. Returns: List[Tuple[int, int]]: List of unique pairs that sum up to k. Examples: >>> find_pairs([2, 4, 3, 5, 7, 8, 9], 7) [(2, 5), (3, 4)] >>> find_pairs([1, 2, 3], 10) [] >>> find_pairs([1, 2, 3, 4, 3, 2, 1], 5) [(1, 4), (2, 3)] >>> find_pairs([1, 2, 3, 3, 4, 5], 6) [(1, 5), (2, 4), (3, 3)] >>> find_pairs([], 5) [] >>> find_pairs([-3, -2, -1, 0, 1, 2, 3], 0) [(-3, 3), (-2, 2), (-1, 1)]","solution":"def find_pairs(nums, k): Returns a list of unique pairs from nums that sum up to k. seen = set() unique_pairs = set() for num in nums: target = k - num if target in seen: unique_pairs.add(tuple(sorted((num, target)))) seen.add(num) return list(unique_pairs)"},{"question":"def max_profit(prices: List[int]) -> int: Computes the maximum profit from a list of daily stock prices. Parameters: prices (list): A list of integers representing daily stock prices. Returns: int: The maximum profit that can be achieved by buying and then selling one share of stock. Returns 0 if no profit can be made. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([1]) 0 >>> max_profit([]) 0 >>> max_profit([5, 5, 5, 5]) 0 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([10, 7, 5, 8, 11, 9]) 6","solution":"def max_profit(prices): Computes the maximum profit from a list of daily stock prices. Parameters: prices (list): A list of integers representing daily stock prices. Returns: int: The maximum profit that can be achieved by buying and then selling one share of stock. Returns 0 if no profit can be made. if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: current_profit = price - min_price if current_profit > max_profit: max_profit = current_profit if price < min_price: min_price = price return max_profit"},{"question":"from typing import List, Tuple def shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: Determines the shortest path from a starting point to a destination within a 2D grid while circumventing obstacles. >>> grid = [ ... [0, 0, 1, 0], ... [0, 0, 1, 0], ... [0, 0, 0, 0], ... [1, 1, 1, 0] ... ] >>> shortest_path(grid, (0, 0), (3, 3)) 6 >>> grid = [ ... [0, 1, 1], ... [1, 0, 1], ... [1, 1, 0] ... ] >>> shortest_path(grid, (0, 0), (2, 2)) -1 >>> grid = [ ... [1, 0], ... [0, 0] ... ] >>> shortest_path(grid, (0, 0), (1, 1)) -1 >>> grid = [ ... [0, 0], ... [0, 1] ... ] >>> shortest_path(grid, (0, 0), (1, 1)) -1 >>> grid = [ ... [0] ... ] >>> shortest_path(grid, (0, 0), (0, 0)) 0 >>> grid = [ ... [0, 0, 0, 0] ... ] >>> shortest_path(grid, (0, 0), (0, 3)) 3 >>> grid = [ ... [0], ... [0], ... [0], ... [0] ... ] >>> shortest_path(grid, (0, 0), (3, 0)) 3","solution":"from collections import deque def shortest_path(grid, start, end): Finds the shortest path from the start point to the end within a 2D grid. Returns the length of the path, or -1 if no such path exists. if grid[start[0]][start[1]] == 1 or grid[end[0]][end[1]] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(start[0], start[1], 0)]) visited = set() visited.add((start[0], start[1])) while queue: x, y, dist = queue.popleft() if (x, y) == end: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 0: queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"def isValidIP(ip: str) -> bool: Returns True if the given string is a valid IPv4 address, False otherwise. Examples: >>> isValidIP(\\"192.168.0.1\\") True >>> isValidIP(\\"255.255.255.255\\") True >>> isValidIP(\\"256.100.50.25\\") False >>> isValidIP(\\"192.168.01.1\\") False >>> isValidIP(\\"192.168.0.\\") False >>> isValidIP(\\"192..168.0.1\\") False >>> isValidIP(\\"192.168.0.1.1\\") False","solution":"def isValidIP(ip): Returns True if the given string is a valid IPv4 address, False otherwise. parts = ip.split('.') if len(parts) != 4: return False for part in parts: if not part.isdigit(): return False if len(part) > 1 and part[0] == '0': return False if not (0 <= int(part) <= 255): return False return True"},{"question":"class LibraryBook: A class to represent a book in a library. Attributes: - title: The title of the book - author: The author of the book - year: The year of publication Class Attributes: - all_books: Class attribute to store all book instances all_books = [] def __init__(self, title: str, author: str, year: int): self.title = title self.author = author self.year = year @classmethod def add_book(cls, title: str, author: str, year: int): Add a new book to the collection. # Your code here @classmethod def get_total_books(cls) -> int: Get the total number of books in the collection. # Your code here @classmethod def find_book_by_title(cls, title: str): Find a book by its title in the collection. # Your code here # Example usage: book1 = LibraryBook.add_book('1984', 'George Orwell', 1949) book2 = LibraryBook.add_book('To Kill a Mockingbird', 'Harper Lee', 1960) print(LibraryBook.get_total_books()) # Output: 2 found_book = LibraryBook.find_book_by_title('1984') if found_book: print(f'Found book: {found_book.title} by {found_book.author}') # Output: Found book: 1984 by George Orwell","solution":"class LibraryBook: A class to represent a book in a library. all_books = [] def __init__(self, title, author, year): self.title = title self.author = author self.year = year @classmethod def add_book(cls, title, author, year): Class method to add a new book to the collection. new_book = cls(title, author, year) cls.all_books.append(new_book) return new_book @classmethod def get_total_books(cls): Class method to get the total number of books in the collection. return len(cls.all_books) @classmethod def find_book_by_title(cls, title): Class method to find a book by its title from the collection. for book in cls.all_books: if book.title == title: return book return None # Demonstrate the usage of the LibraryBook class book1 = LibraryBook.add_book('1984', 'George Orwell', 1949) book2 = LibraryBook.add_book('To Kill a Mockingbird', 'Harper Lee', 1960) print(LibraryBook.get_total_books()) # Output: 2 found_book = LibraryBook.find_book_by_title('1984') if found_book: print(f'Found book: {found_book.title} by {found_book.author}') # Output: Found book: 1984 by George Orwell"},{"question":"def intersection(list1, list2): Returns a list of integers that appear in both list1 and list2, maintaining the order of elements as they appear in list1. >>> intersection([1, 2, 2, 3, 4], [2, 2, 3, 5]) [2, 2, 3] >>> intersection([1, 2, 3], [4, 5, 6]) [] >>> intersection([], [1, 2, 3]) [] >>> intersection([1, 2, 3], []) [] >>> intersection([1, 2, 3], [1, 2, 3]) [1, 2, 3] >>> intersection([1, 1, 2, 2, 3, 3], [1, 2, 2, 3]) [1, 2, 2, 3] >>> intersection([1, 2, 3, 4], [1, 1, 2, 2, 3, 3, 4, 4]) [1, 2, 3, 4] >>> intersection([4, 3, 2, 1], [1, 2, 3, 4]) [4, 3, 2, 1] >>> intersection([5, 5, 5, 6], [5, 6, 6, 6]) [5, 6]","solution":"def intersection(list1, list2): Returns a list of integers that appear in both list1 and list2, maintaining the order of elements as they appear in list1. result = [] list2_count = {} # Count occurrences of elements in list2 for num in list2: if num in list2_count: list2_count[num] += 1 else: list2_count[num] = 1 # Find intersection while maintaining order of list1 for num in list1: if num in list2_count and list2_count[num] > 0: result.append(num) list2_count[num] -= 1 return result"},{"question":"def primes_less_than(n: int) -> (List[int], int): Returns a list of all prime numbers less than n and the count of these prime numbers. >>> primes_less_than(10) # ([2, 3, 5, 7], 4) >>> primes_less_than(20) # ([2, 3, 5, 7, 11, 13, 17, 19], 8)","solution":"def primes_less_than(n): Returns a list of all prime numbers less than n and the count of these prime numbers. if n <= 2: return [], 0 sieve = [True] * n sieve[0], sieve[1] = False, False # 0 and 1 are not prime numbers for start in range(2, int(n ** 0.5) + 1): if sieve[start]: for multiple in range(start*start, n, start): sieve[multiple] = False primes = [num for num, is_prime in enumerate(sieve) if is_prime] return primes, len(primes) # Examples print(primes_less_than(10)) # Output: ([2, 3, 5, 7], 4) print(primes_less_than(20)) # Output: ([2, 3, 5, 7, 11, 13, 17, 19], 8)"},{"question":"def longest_unique_substring(s: str) -> str: Return the longest substring without repeated characters from the given string, treating uppercase and lowercase as distinct, without using inherent Python string functions. >>> longest_unique_substring(\\"abcabcbb\\") 'abc' >>> longest_unique_substring(\\"bbbbb\\") 'b' >>> longest_unique_substring(\\"pwwkew\\") 'wke' >>> longest_unique_substring(\\"dvdf\\") 'vdf' >>> longest_unique_substring(\\"AaBbCc\\") 'AaBbCc'","solution":"def longest_unique_substring(s: str) -> str: Returns the longest substring without repeated characters from the given string, treating uppercase and lowercase as distinct, without using inherent Python string functions. n = len(s) if n == 0: return \\"\\" char_index = {} longest_substr = \\"\\" start = 0 for i in range(n): if s[i] in char_index and char_index[s[i]] >= start: start = char_index[s[i]] + 1 char_index[s[i]] = i if len(longest_substr) < i - start + 1: longest_substr = s[start:i+1] return longest_substr"},{"question":"def rotate(nums: List[int], k: int) -> None: Rotates the array to the right by k steps in-place. >>> nums = [1, 2, 3, 4, 5, 6, 7] >>> rotate(nums, 3) >>> nums [5, 6, 7, 1, 2, 3, 4] >>> nums = [1, 2, 3, 4, 5, 6, 7] >>> rotate(nums, 10) >>> nums [5, 6, 7, 1, 2, 3, 4] >>> nums = [1, 2, 3, 4, 5, 6, 7] >>> rotate(nums, 0) >>> nums [1, 2, 3, 4, 5, 6, 7] >>> nums = [1] >>> rotate(nums, 3) >>> nums [1] >>> nums = [1, 2] >>> rotate(nums, 1) >>> nums [2, 1] >>> rotate(nums, 2) >>> nums [2, 1] >>> nums = [1, 2, 3, 4, 5] >>> rotate(nums, 2) >>> nums [4, 5, 1, 2, 3]","solution":"def rotate(nums, k): Rotates the array to the right by k steps. n = len(nums) k = k % n # In case k is greater than the array length nums[:] = nums[-k:] + nums[:-k] # Slice and concatenate the rotated parts"},{"question":"def merge_alternate(a: List[int], b: List[int]) -> List[int]: Merges two lists \`a\` and \`b\` alternately. If one list is longer, append the remaining elements. >>> merge_alternate([1, 2, 3], [4, 5, 6]) == [1, 4, 2, 5, 3, 6] >>> merge_alternate([1, 2, 3, 7, 8], [4, 5, 6]) == [1, 4, 2, 5, 3, 6, 7, 8] >>> merge_alternate([1, 2], [3, 4, 5, 6]) == [1, 3, 2, 4, 5, 6] >>> merge_alternate([], [1, 2, 3]) == [1, 2, 3] >>> merge_alternate([1, 2, 3], []) == [1, 2, 3] >>> merge_alternate([], []) == [] >>> merge_alternate([1], [2]) == [1, 2] >>> merge_alternate([1], []) == [1] >>> merge_alternate([], [2]) == [2]","solution":"def merge_alternate(a, b): Merges two lists \`a\` and \`b\` alternately. If one list is longer, append the remaining elements. result = [] len_a, len_b = len(a), len(b) min_len = min(len_a, len_b) for i in range(min_len): result.append(a[i]) result.append(b[i]) if len_a > len_b: result.extend(a[min_len:]) else: result.extend(b[min_len:]) return result"},{"question":"def two_sum(nums: List[int], target: int) -> Tuple[int, int]: Returns a tuple of indices of two numbers from the list such that they add up to the target. :param nums: List of integers :param target: Integer target sum :return: Tuple of indices of the two numbers >>> two_sum([2, 7, 11, 15], 9) (0, 1) >>> two_sum([3, 2, 4], 6) (1, 2) >>> two_sum([3, 3], 6) (0, 1)","solution":"def two_sum(nums, target): Returns a tuple of indices of two numbers from the list such that they add up to the target. :param nums: List of integers :param target: Integer target sum :return: Tuple of indices of the two numbers num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i # We assume there's exactly one solution as per the problem statement. return (-1, -1)"},{"question":"def bubble_sort(lst: List[int]) -> List[int]: Sorts a list of integers in ascending order using the bubble sort algorithm. Bubble sort algorithm works by repeatedly stepping through the list, comparing adjacent elements and swapping them if they are in the wrong order. The pass through the list is repeated until the list is sorted. The time complexity of bubble sort is O(n^2) in the worst case. Args: lst (list of int): The list of integers to sort. Returns: list of int: The sorted list in ascending order. >>> bubble_sort([]) == [] >>> bubble_sort([1]) == [1] >>> bubble_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> bubble_sort([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90] >>> bubble_sort([3, 6, 9, 3, 5, 3]) == [3, 3, 3, 5, 6, 9] >>> bubble_sort([-3, 6, -9, 3, 0, -2]) == [-9, -3, -2, 0, 3, 6] >>> bubble_sort([-1, 2, -3, 4, -5, 6]) == [-5, -3, -1, 2, 4, 6]","solution":"def bubble_sort(lst): Sorts a list of integers in ascending order using the bubble sort algorithm. Args: lst (list of int): The list of integers to sort. Returns: list of int: The sorted list in ascending order. n = len(lst) for i in range(n): # Track if any swap was made in this pass swapped = False for j in range(0, n - i - 1): if lst[j] > lst[j + 1]: # Swap if the element found is greater lst[j], lst[j + 1] = lst[j + 1], lst[j] swapped = True # If no two elements were swapped in the last pass, the list is sorted if not swapped: break return lst"},{"question":"def unique_elements(lst): Returns a new list containing only the unique elements from the original list, preserving their order of first appearance. >>> unique_elements([1, 2, 3, 1, 2, 4]) == [1, 2, 3, 4] >>> unique_elements([1, 2, 3]) == [1, 2, 3] >>> unique_elements([1, 1, 1, 1]) == [1] >>> unique_elements([]) == [] >>> unique_elements([1, -1, -2, 3, 2, -1, 3, -2]) == [1, -1, -2, 3, 2]","solution":"def unique_elements(lst): Returns a new list containing only the unique elements from the original list, preserving their order of first appearance. seen = set() unique_lst = [] for item in lst: if item not in seen: seen.add(item) unique_lst.append(item) return unique_lst"},{"question":"def reverse_words(s: str) -> str: Given a string containing a sequence of words separated by spaces, reverse the order of the words and return the modified string. Ensure the function maintains the original whitespace separating the words. >>> reverse_words(\\"Hello\\") 'Hello' >>> reverse_words(\\"Hello world\\") 'world Hello' >>> reverse_words(\\"Hello world this is coding\\") 'coding is this world Hello' >>> reverse_words(\\"Hello world this is coding\\") 'coding is this world Hello' >>> reverse_words(\\" Hello world this is coding \\") 'coding is this world Hello' >>> reverse_words(\\"\\") '' >>> reverse_words(\\" \\") '' >>> reverse_words(\\"Hello WoRld thIs is cOdIng\\") 'cOdIng is thIs WoRld Hello' >>> reverse_words(\\"Hello, world! This is... coding.\\") 'coding. is... This world! Hello,'","solution":"def reverse_words(s): Reverses the order of words in a string while maintaining the original whitespace. :param s: The input string containing a sequence of words separated by spaces :type s: str :return: The modified string with words in reverse order :rtype: str words = s.split() reversed_words = words[::-1] reversed_sentence = ' '.join(reversed_words) return reversed_sentence"},{"question":"def separate_even_odd(nums: list) -> tuple: Separates the input list into two lists: even numbers and odd numbers. Parameters: nums (list): List of integers to be separated. Returns: tuple: A tuple containing two lists - first list with even numbers and second list with odd numbers. Examples: >>> separate_even_odd([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) ([2, 4, 6, 8, 10], [1, 3, 5, 7, 9]) >>> separate_even_odd([2, 4, 6, 8, 10]) ([2, 4, 6, 8, 10], []) >>> separate_even_odd([1, 3, 5, 7, 9]) ([], [1, 3, 5, 7, 9]) >>> separate_even_odd([]) ([], []) >>> separate_even_odd([2]) ([2], []) >>> separate_even_odd([1]) ([], [1])","solution":"def separate_even_odd(nums): Separates the input list into two lists: even numbers and odd numbers. Parameters: nums (list): List of integers to be separated. Returns: tuple: A tuple containing two lists - first list with even numbers and second list with odd numbers. evens = [num for num in nums if num % 2 == 0] odds = [num for num in nums if num % 2 != 0] return evens, odds"},{"question":"def longest_contig_subarray(arr: List[int]) -> int: Returns the length of the longest subarray with contiguous elements. >>> longest_contig_subarray([]) == 0 >>> longest_contig_subarray([1]) == 1 >>> longest_contig_subarray([1, 3, 5, 7]) == 1 >>> longest_contig_subarray([1, 9, 3, 10, 4, 20, 2]) == 4 >>> longest_contig_subarray([1, 2, 2, 3, 4]) == 4 >>> longest_contig_subarray([4, 2, 1, 3]) == 4 >>> longest_contig_subarray(list(range(100000))) == 100000","solution":"def longest_contig_subarray(arr): Returns the length of the longest subarray with contiguous elements. if not arr: return 0 max_len = 0 arr_set = set(arr) for num in arr: # If the number is the start of a contiguous sequence if num - 1 not in arr_set: current_num = num current_len = 1 # Count the length of contiguous sequence while current_num + 1 in arr_set: current_num += 1 current_len += 1 max_len = max(max_len, current_len) return max_len"},{"question":"def sum_with_neighbors(numbers): Takes a list of integers and returns a new list where each element is the sum of the original element and its adjacent elements. For the first and last element, consider the non-existent neighbor as zero. :param numbers: List of integers :return: New list of integers >>> sum_with_neighbors([]) == [] >>> sum_with_neighbors([5]) == [5] >>> sum_with_neighbors([1, 2]) == [3, 3] >>> sum_with_neighbors([1, 2, 3, 4]) == [3, 6, 9, 7] >>> sum_with_neighbors([-1, -2, -3, -4]) == [-3, -6, -9, -7] >>> sum_with_neighbors([1, -2, 3, -4]) == [-1, 2, -3, -1]","solution":"def sum_with_neighbors(numbers): Takes a list of integers and returns a new list where each element is the sum of the original element and its adjacent elements. For the first and last element, consider the non-existent neighbor as zero. :param numbers: List of integers :return: New list of integers if not numbers: return [] n = len(numbers) result = [] for i in range(n): if i == 0: result.append(numbers[i] + (numbers[i + 1] if i + 1 < n else 0)) elif i == n - 1: result.append(numbers[i] + (numbers[i - 1] if i - 1 >= 0 else 0)) else: result.append(numbers[i - 1] + numbers[i] + numbers[i + 1]) return result"},{"question":"def word_lengths(s: str) -> dict: Returns a dictionary where each key is a unique word from the input string \`s\` and the corresponding value is the length of that word, sorted by word lengths in ascending order. >>> word_lengths(\\"hello\\") == {\\"hello\\": 5} >>> word_lengths(\\"hello world\\") == {\\"hello\\": 5, \\"world\\": 5} >>> word_lengths(\\"a quick brown fox jumps\\") == {\\"a\\": 1, \\"fox\\": 3, \\"quick\\": 5, \\"brown\\": 5, \\"jumps\\": 5} >>> word_lengths(\\"big red box\\") == {\\"big\\": 3, \\"red\\": 3, \\"box\\": 3} >>> word_lengths(\\"the quick brown the\\") == {\\"the\\": 3, \\"quick\\": 5, \\"brown\\": 5} >>> word_lengths(\\"\\") == {}","solution":"def word_lengths(s): Returns a dictionary where each key is a unique word from the input string \`s\` and the corresponding value is the length of that word, sorted by word lengths in ascending order. words = s.split() # Split the input string into words word_dict = {word: len(word) for word in words} # Create a dictionary with word lengths # Sort the dictionary by the word length in ascending order sorted_word_dict = dict(sorted(word_dict.items(), key=lambda item: item[1])) return sorted_word_dict"},{"question":"def get_primes_up_to(n: int) -> list: Develop a Python function that takes an integer \`n\` as an input and returns a list of all prime numbers less than or equal to \`n\`. Ensure that your function is optimized for performance, utilizing efficient algorithms for prime identification such as the Sieve of Eratosthenes. >>> get_primes_up_to(10) [2, 3, 5, 7] >>> get_primes_up_to(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> get_primes_up_to(2) [2] >>> get_primes_up_to(0) []","solution":"def get_primes_up_to(n): Returns a list of prime numbers less than or equal to n using the Sieve of Eratosthenes. if n < 2: return [] sieve = [True] * (n + 1) sieve[0] = sieve[1] = False for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiples in range(start*start, n + 1, start): sieve[multiples] = False return [num for num in range(n + 1) if sieve[num]]"},{"question":"from typing import List def filter_primes(lst: List[int]) -> List[int]: Returns a list containing only the prime numbers from the original list. >>> filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) -> [2, 3, 5, 7] >>> filter_primes([15, 23, 31, 50, 37]) -> [23, 31, 37] >>> filter_primes([1, 2, 3, 4, 9, 11, 13]) -> [2, 3, 11, 13] def test_filter_primes_basic(): assert filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) == [2, 3, 5, 7] def test_filter_primes_some_primes(): assert filter_primes([15, 23, 31, 50, 37]) == [23, 31, 37] def test_filter_primes_mixed_numbers(): assert filter_primes([1, 2, 3, 4, 9, 11, 13]) == [2, 3, 11, 13] def test_filter_primes_no_primes(): assert filter_primes([4, 6, 8, 10, 12]) == [] def test_filter_primes_all_primes(): assert filter_primes([2, 3, 5, 7, 11, 13, 17, 19, 23]) == [2, 3, 5, 7, 11, 13, 17, 19, 23] def test_filter_primes_empty_list(): assert filter_primes([]) == [] def test_filter_primes_single_prime(): assert filter_primes([11]) == [11] def test_filter_primes_single_non_prime(): assert filter_primes([4]) == [] def test_filter_primes_large_numbers(): # List includes large prime number: 104729 (which is the 10000th prime) assert filter_primes([104729, 104730, 104731]) == [104729]","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(lst): Returns a list containing only the prime numbers from the original list. return [x for x in lst if is_prime(x)]"},{"question":"def is_palindrome(s: str) -> bool: Determines if a given string is a valid palindrome after removing all non-alphanumeric characters and ignoring cases. :param s: Input string to be checked :return: Boolean value indicating whether the string is a palindrome >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"race a car\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"A\\") True >>> is_palindrome(\\"@#!@#!\\") True >>> is_palindrome(\\"ab@c#dc@b#a\\") True >>> is_palindrome(\\"No 'x' in Nixon\\") True >>> is_palindrome(\\"Was it a car or a cat I saw?\\") True >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"123456\\") False >>> is_palindrome(\\"A1B2C3c2b1a\\") True >>> is_palindrome(\\"A1B2C3d2b1a\\") False","solution":"def is_palindrome(s): Determines if a given string is a valid palindrome after removing all non-alphanumeric characters and ignoring cases. :param s: Input string to be checked :return: Boolean value indicating whether the string is a palindrome cleaned_s = ''.join(c for c in s if c.isalnum()).lower() return cleaned_s == cleaned_s[::-1]"},{"question":"from typing import List def is_prime(n: int) -> bool: Checks if a number is prime. >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(17) True # Your code here def filter_primes(nums: List[int]) -> List[int]: Returns a new list containing only the prime numbers from the input list. >>> filter_primes([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> filter_primes([4, 6, 8, 9, 10]) [] >>> filter_primes([29, 49, 77, 97, 101, 103, 104]) [29, 97, 101, 103] # Your code here","solution":"def is_prime(n): Checks if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(nums): Returns a new list containing only the prime numbers from the input list. return [num for num in nums if is_prime(num)] # Brief explanation: # The \`is_prime\` function checks for primality using a few optimizations: # 1. Immediately returns False for numbers <= 1 and returns True for 2 and 3. # 2. Checks divisibility by 2 and 3 to eliminate multiples of these small numbers. # 3. Uses a loop that checks divisibility starting from 5 in steps of 6, # which skips the even numbers and multiples of 3 to reduce the number # of iterations while ensuring accurate primality checking. # This method ensures efficient checking for primality, especially for larger numbers. # The \`filter_primes\` function applies this primality check to each element # in the input list and composes a new list of primes."},{"question":"def sort_students_by_grades(students: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Given a list of student-grade pairs (tuples), return the list sorted by grades in descending order. If two students have the same grade, sort them alphabetically by their names. >>> sort_students_by_grades([(\\"John\\", 88), (\\"Emma\\", 95), (\\"Sophia\\", 85), (\\"Jacob\\", 78)]) [(\\"Emma\\", 95), (\\"John\\", 88), (\\"Sophia\\", 85), (\\"Jacob\\", 78)] >>> sort_students_by_grades([(\\"John\\", 88), (\\"Emma\\", 88), (\\"Sophia\\", 88), (\\"Jacob\\", 88)]) [(\\"Emma\\", 88), (\\"Jacob\\", 88), (\\"John\\", 88), (\\"Sophia\\", 88)] >>> sort_students_by_grades([(\\"John\\", 88), (\\"Emma\\", 95), (\\"Sophia\\", 88), (\\"Jacob\\", 78)]) [(\\"Emma\\", 95), (\\"John\\", 88), (\\"Sophia\\", 88), (\\"Jacob\\", 78)] >>> sort_students_by_grades([(\\"John\\", 0), (\\"Emma\\", 0), (\\"Sophia\\", 0), (\\"Jacob\\", 0)]) [(\\"Emma\\", 0), (\\"Jacob\\", 0), (\\"John\\", 0), (\\"Sophia\\", 0)] >>> sort_students_by_grades([]) []","solution":"def sort_students_by_grades(students): Given a list of student-grade pairs (tuples), returns the list sorted by grades in descending order. If two students have the same grade, sort them alphabetically by their names. return sorted(students, key=lambda student: (-student[1], student[0]))"},{"question":"def merge_sorted_lists(list1, list2): Write a Python function called \`merge_sorted_lists\` that takes two sorted lists of integers as input and returns a new list that contains all the elements from both input lists in sorted order. Your implementation should ensure that the final list remains sorted and should not use any built-in sort functions. >>> merge_sorted_lists([1, 3, 5, 7], [2, 4, 6, 8]) [1, 2, 3, 4, 5, 6, 7, 8] >>> merge_sorted_lists([10, 20, 30], [15, 25, 35]) [10, 15, 20, 25, 30, 35] >>> merge_sorted_lists([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_lists([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_lists([], []) [] >>> merge_sorted_lists([1, 3, 5], [2, 4, 6, 8, 10]) [1, 2, 3, 4, 5, 6, 8, 10] >>> merge_sorted_lists([1, 2, 3, 4, 5], [6, 7]) [1, 2, 3, 4, 5, 6, 7] >>> merge_sorted_lists([-5, -3, -1], [-4, -2, 0, 1]) [-5, -4, -3, -2, -1, 0, 1]","solution":"def merge_sorted_lists(list1, list2): Merges two sorted lists into a single sorted list. merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # If there are remaining elements in list1 while i < len(list1): merged_list.append(list1[i]) i += 1 # If there are remaining elements in list2 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"import csv from collections import defaultdict from typing import List, Dict, Tuple def read_csv(filename: str) -> List[Dict[str, str]]: Reads a CSV file and returns a list of dictionaries representing each row. with open(filename, mode='r') as file: reader = csv.DictReader(file) data = [row for row in reader] return data def student_average(data: List[Dict[str, str]]) -> Dict[str, float]: Calculate and return each student's average grade. >>> data = [ ... {'Student Name': 'Alice Johnson', 'Subject': 'Math', 'Grade': '88'}, ... {'Student Name': 'Alice Johnson', 'Subject': 'Science', 'Grade': '92'}, ... {'Student Name': 'Bob Smith', 'Subject': 'Math', 'Grade': '75'}, ... {'Student Name': 'Bob Smith', 'Subject': 'Science', 'Grade': '85'}, ... {'Student Name': 'Charlie Brown', 'Subject': 'Math', 'Grade': '90'}, ... {'Student Name': 'Charlie Brown', 'Subject': 'Science', 'Grade': '78'}, ... ] >>> student_average(data) {'Alice Johnson': 90.0, 'Bob Smith': 80.0, 'Charlie Brown': 84.0} def subject_extremes(data: List[Dict[str, str]]) -> Dict[str, Dict[str, Tuple[str, float]]]: Determine the highest and lowest grades per subject, along with the student who achieved them. >>> data = [ ... {'Student Name': 'Alice Johnson', 'Subject': 'Math', 'Grade': '88'}, ... {'Student Name': 'Alice Johnson', 'Subject': 'Science', 'Grade': '92'}, ... {'Student Name': 'Bob Smith', 'Subject': 'Math', 'Grade': '75'}, ... {'Student Name': 'Bob Smith', 'Subject': 'Science', 'Grade': '85'}, ... {'Student Name': 'Charlie Brown', 'Subject': 'Math', 'Grade': '90'}, ... {'Student Name': 'Charlie Brown', 'Subject': 'Science', 'Grade': '78'}, ... ] >>> subject_extremes(data) {'Math': {'highest': ('Charlie Brown', 90.0), 'lowest': ('Bob Smith', 75.0)}, 'Science': {'highest': ('Alice Johnson', 92.0), 'lowest': ('Charlie Brown', 78.0)}} def overall_class_average(data: List[Dict[str, str]]) -> float: Provide the overall class average grade. >>> data = [ ... {'Student Name': 'Alice Johnson', 'Subject': 'Math', 'Grade': '88'}, ... {'Student Name': 'Alice Johnson', 'Subject': 'Science', 'Grade': '92'}, ... {'Student Name': 'Bob Smith', 'Subject': 'Math', 'Grade': '75'}, ... {'Student Name': 'Bob Smith', 'Subject': 'Science', 'Grade': '85'}, ... {'Student Name': 'Charlie Brown', 'Subject': 'Math', 'Grade': '90'}, ... {'Student Name': 'Charlie Brown', 'Subject': 'Science', 'Grade': '78'}, ... ] >>> overall_class_average(data) 84.66666666666667 def class_performance_summary(filename: str) -> Dict[str, any]: Summarizes class performance based on a given CSV file containing student records. Example CSV file content: Student Name,Subject,Grade Alice Johnson,Math,88 Alice Johnson,Science,92 Bob Smith,Math,75 Bob Smith,Science,85 Charlie Brown,Math,90 Charlie Brown,Science,78","solution":"import csv from collections import defaultdict def read_csv(filename): with open(filename, mode='r') as file: reader = csv.DictReader(file) data = [row for row in reader] return data def student_average(data): student_grades = defaultdict(list) for record in data: student_grades[record['Student Name']].append(float(record['Grade'])) student_averages = {student: sum(grades)/len(grades) for student, grades in student_grades.items()} return student_averages def subject_extremes(data): subjects = defaultdict(list) for record in data: subjects[record['Subject']].append((record['Student Name'], float(record['Grade']))) subject_high_low = {} for subject, grades in subjects.items(): highest = max(grades, key=lambda x: x[1]) lowest = min(grades, key=lambda x: x[1]) subject_high_low[subject] = { 'highest': highest, 'lowest': lowest } return subject_high_low def overall_class_average(data): total_grade = 0 total_count = 0 for record in data: total_grade += float(record['Grade']) total_count += 1 class_average = total_grade / total_count return class_average def class_performance_summary(filename): data = read_csv(filename) student_averages = student_average(data) subject_high_low = subject_extremes(data) class_average = overall_class_average(data) summary = { 'student_averages': student_averages, 'subject_high_low': subject_high_low, 'class_average': class_average } return summary"},{"question":"from typing import List, Tuple, Dict def categorize_books(books: List[Tuple[str, str]]) -> Dict[str, List[str]]: Categorizes books into genres. :param books: List of tuples where each tuple contains a book title and its genre. :return: Dictionary where each key is a genre and the value is a list of books in that genre. >>> categorize_books([ ... ('Pride and Prejudice', 'Romance'), ... ('To Kill a Mockingbird', 'Fiction'), ... ('The Great Gatsby', 'Fiction'), ... ('The Fault in Our Stars', 'Romance') ... ]) == { ... 'Romance': ['Pride and Prejudice', 'The Fault in Our Stars'], ... 'Fiction': ['To Kill a Mockingbird', 'The Great Gatsby'] ... }","solution":"from typing import List, Tuple, Dict def categorize_books(books: List[Tuple[str, str]]) -> Dict[str, List[str]]: Categorizes books into genres. :param books: List of tuples where each tuple contains a book title and its genre. :return: Dictionary where each key is a genre and the value is a list of books in that genre. genre_dict = {} for title, genre in books: if genre not in genre_dict: genre_dict[genre] = [] genre_dict[genre].append(title) return genre_dict"},{"question":"import re def sentence_with_most_unique_words(text): This function takes a string of text containing multiple sentences and returns the sentence with the highest number of unique words. Sentences are separated by '.', '!', or '?'. The function ignores case and punctuation. If there are multiple sentences with the same highest number of unique words, return the first one. Handle possible errors such as an empty string or incorrect input types gracefully by returning a meaningful error message. >>> sentence_with_most_unique_words(\\"This is a test. This sentence has many unique words! Does it really? We'll see.\\") 'This sentence has many unique words' >>> sentence_with_most_unique_words(\\"\\") \\"Error: Input string is empty.\\" >>> sentence_with_most_unique_words(12345) \\"Error: Input should be a string.\\" >>> sentence_with_most_unique_words(\\"A quick brown fox. The quick brown dog.\\") 'A quick brown fox' >>> sentence_with_most_unique_words(\\"Only one sentence here.\\") 'Only one sentence here' >>> sentence_with_most_unique_words(\\"Hello! HELLO, baby! Baby, hello.\\") 'HELLO, baby' >>> sentence_with_most_unique_words(\\"aaaa. bbbb! cccc.\\") 'aaaa'","solution":"import re def sentence_with_most_unique_words(text): This function takes a string of text containing multiple sentences and returns the sentence with the highest number of unique words. Sentences are separated by '.', '!', or '?'. The function ignores case and punctuation. if not isinstance(text, str): return \\"Error: Input should be a string.\\" if not text.strip(): return \\"Error: Input string is empty.\\" sentences = re.split(r'[.!?]', text) max_unique_words = 0 result_sentence = \\"\\" for sentence in sentences: words = re.findall(r'bw+b', sentence.lower()) unique_words = set(words) if len(unique_words) > max_unique_words: max_unique_words = len(unique_words) result_sentence = sentence.strip() if result_sentence: return result_sentence else: return \\"Error: No valid sentences found in the input text.\\""},{"question":"def sort_even_odd_descending(lst: List[int]) -> List[int]: Returns a list of integers such that even numbers are first in descending order, followed by odd numbers in descending order. >>> sort_even_odd_descending([3, 1, 2, 4, 7, 5, 6]) [6, 4, 2, 7, 5, 3, 1] >>> sort_even_odd_descending([8, 3, 11, 2, 7, 4, 5]) [8, 4, 2, 11, 7, 5, 3] >>> sort_even_odd_descending([1, 3, 5, 7, 9]) [9, 7, 5, 3, 1] >>> sort_even_odd_descending([2, 4, 6, 8]) [8, 6, 4, 2] >>> sort_even_odd_descending([]) [] >>> sort_even_odd_descending([2]) [2] >>> sort_even_odd_descending([1]) [1] def faulty_sort_even_odd(lst: List[int]) -> List[int]: This function does not correctly segregate and sort even and odd numbers. return sorted(lst, reverse=True)","solution":"def sort_even_odd_descending(lst): Returns a list of integers such that even numbers are first in descending order, followed by odd numbers in descending order. evens = sorted([x for x in lst if x % 2 == 0], reverse=True) odds = sorted([x for x in lst if x % 2 != 0], reverse=True) return evens + odds # Common mistake snippet def faulty_sort_even_odd(lst): This function does not correctly segregate and sort even and odd numbers. return sorted(lst, reverse=True)"},{"question":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array without using built-in sorting functions. >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([1, 3, 5], [1, 2, 3, 4, 5, 6]) [1, 1, 2, 3, 3, 4, 5, 5, 6] >>> merge_sorted_arrays([], [2, 4, 6]) [2, 4, 6] >>> merge_sorted_arrays([1, 3, 5], []) [1, 3, 5] >>> merge_sorted_arrays([], []) [] >>> merge_sorted_arrays([1], [2]) [1, 2] >>> merge_sorted_arrays([2], [1]) [1, 2]","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array. merged_array = [] i = 0 j = 0 while i < len(arr1) and j < len(arr2): if arr1[i] <= arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 while i < len(arr1): merged_array.append(arr1[i]) i += 1 while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"def matrix_multiply(matrix1, matrix2): Performs matrix multiplication on two 2D lists. Args: matrix1: List[List[int]], the first matrix with each sub-list representing a row. matrix2: List[List[int]], the second matrix with each sub-list representing a row. Returns: The resultant matrix after multiplication as a List[List[int]]. Raises: ValueError: If the number of columns in matrix1 does not equal the number of rows in matrix2. Example: >>> matrix1 = [ >>> [1, 2, 3], >>> [4, 5, 6] >>> ] >>> matrix2 = [ >>> [7, 8], >>> [9, 10], >>> [11, 12] >>> ] >>> matrix_multiply(matrix1, matrix2) >>> [[58, 64], [139, 154]]","solution":"def matrix_multiply(matrix1, matrix2): Performs matrix multiplication on two 2D lists. Args: matrix1: list of lists, where each sub-list represents a row in the matrix matrix2: list of lists, where each sub-list represents a row in the matrix Returns: The resultant matrix after multiplication. Raises: ValueError: If the number of columns in matrix1 does not equal the number of rows in matrix2. # Validate matrix dimensions if len(matrix1[0]) != len(matrix2): raise ValueError(\\"Number of columns in matrix1 must equal the number of rows in matrix2\\") # Number of rows in resultant matrix result_rows = len(matrix1) # Number of columns in resultant matrix result_cols = len(matrix2[0]) # Initialize the resultant matrix with zeros result_matrix = [[0 for _ in range(result_cols)] for _ in range(result_rows)] # Perform matrix multiplication for i in range(result_rows): for j in range(result_cols): for k in range(len(matrix1[0])): result_matrix[i][j] += matrix1[i][k] * matrix2[k][j] return result_matrix # Example matrix1 = [ [1, 2, 3], [4, 5, 6] ] matrix2 = [ [7, 8], [9, 10], [11, 12] ] # Expected output: # [ # [58, 64], # [139, 154] # ] print(matrix_multiply(matrix1, matrix2))"},{"question":"def longest_substring_with_two_distinct_characters(s: str) -> str: Returns the longest substring that contains exactly 2 distinct characters. Args: s (str): input string Returns: str: the longest substring with exactly 2 distinct characters >>> longest_substring_with_two_distinct_characters(\\"abcbbbbcccbdddadacb\\") 'bcbbbbcccb' >>> longest_substring_with_two_distinct_characters(\\"aaaa\\") 'aaaa' >>> longest_substring_with_two_distinct_characters(\\"a\\") 'a' >>> longest_substring_with_two_distinct_characters(\\"ab\\") 'ab' >>> longest_substring_with_two_distinct_characters(\\"\\") '' >>> longest_substring_with_two_distinct_characters(\\"abcd\\") 'ab' >>> longest_substring_with_two_distinct_characters(\\"abaccc\\") 'accc'","solution":"def longest_substring_with_two_distinct_characters(s): Returns the longest substring that contains exactly 2 distinct characters. Args: s (str): input string Returns: str: the longest substring with exactly 2 distinct characters start = 0 max_length = 0 max_substring = \\"\\" char_count = {} for end in range(len(s)): if s[end] in char_count: char_count[s[end]] += 1 else: char_count[s[end]] = 1 while len(char_count) > 2: char_count[s[start]] -= 1 if char_count[s[start]] == 0: del char_count[s[start]] start += 1 if end - start + 1 > max_length: max_length = end - start + 1 max_substring = s[start:end+1] return max_substring"},{"question":"import pandas as pd import matplotlib.pyplot as plt def plot_total_sales_by_region(csv_file): Read sales data from a CSV file and create a bar plot showing the total sales by region. Args: csv_file (str): The path to the CSV file containing the sales data. Requirements: * The CSV file (e.g., 'sales_data.csv') should have columns: 'Date', 'Region', 'Sales'. * The plot should have regions on the x-axis, total sales on the y-axis. * Each bar should be displayed with a different color. * The plot should include a title 'Total Sales by Region'. >>> plot_total_sales_by_region('sales_data.csv')","solution":"import pandas as pd import matplotlib.pyplot as plt def plot_total_sales_by_region(csv_file): Reads sales data from a CSV file and creates a bar plot showing the total sales by region. Args: csv_file (str): The path to the CSV file containing the sales data. # Load the CSV file into a DataFrame df = pd.read_csv(csv_file) # Group the data by Region and sum the Sales region_sales = df.groupby('Region')['Sales'].sum() # Create the bar plot region_sales.plot(kind='bar', color=plt.cm.tab20.colors) # Set title and labels plt.title('Total Sales by Region') plt.xlabel('Region') plt.ylabel('Total Sales') # Display the plot plt.show()"},{"question":"def reverse_words(s: str) -> str: Reverses the order of words in a given string. >>> reverse_words(\\"hello world from code\\") \\"code from world hello\\" >>> reverse_words(\\"hello\\") \\"hello\\" >>> reverse_words(\\"hello world\\") \\"world hello\\" >>> reverse_words(\\"a b c d\\") \\"d c b a\\" >>> reverse_words(\\"hello, world!\\") \\"world! hello,\\"","solution":"def reverse_words(s): Reverses the order of words in a given string. Parameters: s (str): The input string with words separated by a single space. Returns: str: The string with the words' order reversed. return ' '.join(s.split()[::-1])"},{"question":"import random def roll_until_target(target: int) -> int: Simulates the roll of a pair of dice until the sum matches the target value. Args: target (int): Target sum to achieve with the dice rolls. Returns: int: Number of rolls required to reach the target sum. >>> roll_until_target(1) ValueError: Target sum must be between 2 and 12 >>> roll_until_target(7) > 0 True","solution":"import random def roll_until_target(target): Simulates the roll of a pair of dice until the sum matches the target value. Args: target (int): Target sum to achieve with the dice rolls. Returns: int: Number of rolls required to reach the target sum. if target < 2 or target > 12: raise ValueError(\\"Target sum must be between 2 and 12\\") rolls = 0 while True: roll_1 = random.randint(1, 6) roll_2 = random.randint(1, 6) rolls += 1 if roll_1 + roll_2 == target: return rolls"},{"question":"def canFormPalindrome(string): Determines if a given string can be rearranged to form a palindrome. Parameters: string (str): The input string to check. Returns: bool: True if the string can be rearranged to form a palindrome, otherwise False. Raises: ValueError: If the input is not a string. pass import pytest def test_can_form_palindrome_valid_string(): assert canFormPalindrome(\\"carrace\\") == True assert canFormPalindrome(\\"racecar\\") == True assert canFormPalindrome(\\"aabbcc\\") == True assert canFormPalindrome(\\"abcabc\\") == True def test_can_form_palindrome_single_characters(): assert canFormPalindrome(\\"a\\") == True assert canFormPalindrome(\\"aa\\") == True assert canFormPalindrome(\\"aaa\\") == True def test_can_form_palindrome_empty_string(): assert canFormPalindrome(\\"\\") == True def test_can_form_palindrome_invalid_string(): assert canFormPalindrome(\\"abcde\\") == False assert canFormPalindrome(\\"abcda\\") == False def test_can_form_palindrome_raises_value_error(): with pytest.raises(ValueError): canFormPalindrome(1234) with pytest.raises(ValueError): canFormPalindrome(None) with pytest.raises(ValueError): canFormPalindrome([1, 2, 3, 4]) def test_can_form_palindrome_with_special_characters(): assert canFormPalindrome(\\"taco cat\\") == False # space character breaks the palindrome assert canFormPalindrome(\\"tacocat\\") == True assert canFormPalindrome(\\"taco#cat\\") == False # special character assert canFormPalindrome(\\"tacocat\\") == True assert canFormPalindrome(\\"a!!a\\") == True def test_can_form_palindrome_mixed_case(): assert canFormPalindrome(\\"Aa\\") == False assert canFormPalindrome(\\"AaaA\\") == True","solution":"def canFormPalindrome(string): Determines if a given string can be rearranged to form a palindrome. Parameters: string (str): The input string to check. Returns: bool: True if the string can be rearranged to form a palindrome, otherwise False. Raises: ValueError: If the input is not a string. if not isinstance(string, str): raise ValueError(\\"Input must be a string\\") # Count the occurrences of each character char_count = {} for char in string: char_count[char] = char_count.get(char, 0) + 1 # A string can be rearranged to form a palindrome if at most one character has an odd count odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 return odd_count <= 1"},{"question":"def most_frequent(lst): Returns the integer that appears the most times in the list. If there is a tie, returns a list of the integers that occur most frequently. >>> most_frequent([1, 2, 3, 1, 2, 1]) == 1 >>> most_frequent([1, 2, 2, 3, 3]) == [2, 3] >>> most_frequent([4]) == 4 >>> most_frequent([]) == [] >>> most_frequent([5, 5, 5, 5]) == 5 >>> most_frequent([1, 2, 1, 2, 3, 3]) == [1, 2, 3] >>> most_frequent([-1, -2, -2, -3, -1, -1]) == -1 >>> most_frequent([1000, 5000, 1000, 10000, 10000, 1000]) == 1000","solution":"def most_frequent(lst): Returns the integer that appears the most times in the list. If there is a tie, returns a list of the integers that occur most frequently. freq = {} for i in lst: freq[i] = freq.get(i, 0) + 1 if not freq: return [] max_freq = max(freq.values()) most_freq_int = [k for k, v in freq.items() if v == max_freq] return most_freq_int if len(most_freq_int) > 1 else most_freq_int[0]"},{"question":"def are_anagrams(str1: str, str2: str) -> bool: Determine if two strings are anagrams of each other. Args: str1 (str): First input string. str2 (str): Second input string. Returns: bool: True if str1 and str2 are anagrams, False otherwise. Examples: >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"aabb\\", \\"bbaa \\") False >>> are_anagrams(\\"aabbcc\\", \\"abcabc\\") True >>> are_anagrams(\\"\\", \\"\\") True >>> are_anagrams(\\"a\\", \\"a\\") True >>> are_anagrams(\\"a\\", \\"b\\") False >>> are_anagrams(\\"a b c\\", \\"c b a\\") True >>> are_anagrams(\\"Listen\\", \\"Silent\\") False","solution":"def are_anagrams(str1, str2): Determine if two strings are anagrams of each other. Args: str1 (str): First input string. str2 (str): Second input string. Returns: bool: True if str1 and str2 are anagrams, False otherwise. # Early exit if lengths are different if len(str1) != len(str2): return False # Count characters in both strings from collections import Counter return Counter(str1) == Counter(str2)"},{"question":"def indices_of_elements(lst: List[int]) -> dict: Create a Python function that takes a list of integers as input and returns a dictionary. The dictionary should have keys corresponding to each unique integer in the list. The value for each key should be a list of indices where that integer appears in the input list. Your function should account for the possibility of an empty list and handle it by returning an empty dictionary. >>> indices_of_elements([]) == {} >>> indices_of_elements([1]) == {1: [0]} >>> indices_of_elements([1, 2, 3]) == {1: [0], 2: [1], 3: [2]} >>> indices_of_elements([1, 2, 1, 2, 1]) == {1: [0, 2, 4], 2: [1, 3]} >>> indices_of_elements([1, 1, 1, 1]) == {1: [0, 1, 2, 3]} >>> indices_of_elements([4, 5, 6, 5, 4]) == {4: [0, 4], 5: [1, 3], 6: [2]}","solution":"def indices_of_elements(lst): Returns a dictionary with keys as unique integers from the list and values as lists of indices where those integers appear in the input list. Parameters: lst (list): A list of integers. Returns: dict: A dictionary with unique integers as keys and their indices as values. result = {} for index, value in enumerate(lst): if value in result: result[value].append(index) else: result[value] = [index] return result"},{"question":"def fibonacci_sum(n): Calculates the sum of the first n Fibonacci numbers using an iterative approach. The Fibonacci sequence starts with 0 and 1. :param n: The number of Fibonacci numbers to sum up :return: The sum of the first n Fibonacci numbers >>> fibonacci_sum(5) 7 >>> fibonacci_sum(10) 88 >>> fibonacci_sum(0) 0 >>> fibonacci_sum(1) 0","solution":"def fibonacci_sum(n): Calculates the sum of the first n Fibonacci numbers using an iterative approach. The Fibonacci sequence starts with 0 and 1. :param n: The number of Fibonacci numbers to sum up :return: The sum of the first n Fibonacci numbers if n == 0: return 0 elif n == 1: return 0 a, b = 0, 1 total_sum = a # Start with 0 which is the first Fibonacci number for _ in range(1, n): total_sum += b a, b = b, a + b return total_sum # Example usages print(fibonacci_sum(5)) # Output: 7 print(fibonacci_sum(10)) # Output: 88 print(fibonacci_sum(0)) # Output: 0 print(fibonacci_sum(1)) # Output: 0"},{"question":"def find_primes(n: int) -> List[int]: Returns a list of all prime numbers less than n. >>> find_primes(10) [2, 3, 5, 7] >>> find_primes(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> find_primes(1) [] >>> find_primes(2) [] >>> find_primes(3) [2] >>> find_primes(13) [2, 3, 5, 7, 11] >>> find_primes(50) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]","solution":"from typing import List def find_primes(n: int) -> List[int]: Returns a list of all prime numbers less than n. if n <= 2: return [] is_prime = [True] * n is_prime[0], is_prime[1] = False, False p = 2 while p * p < n: if is_prime[p]: for multiple in range(p * p, n, p): is_prime[multiple] = False p += 1 return [i for i in range(n) if is_prime[i]]"},{"question":"import csv def process_employee_file(file_path): Read a CSV file with employee information and perform the following operations: 1. Print the total number of employees. 2. Calculate the average salary of all employees and print the result. 3. Identify and print the details (employee ID, name, and salary) of the employee(s) with the highest salary. Args: file_path (str): The path to the CSV file containing employee information. Example: >>> process_employee_file('employees.csv') Total number of employees: 4 Average salary: 56250.0 Employee(s) with the highest salary: 2, Jane Smith, 60000.0 4, Bob Brown, 60000.0","solution":"import csv def process_employee_file(file_path): employees = [] with open(file_path, mode='r') as file: reader = csv.reader(file) for row in reader: if row: # Check if the row is not empty employee_id, name, salary = row employees.append((int(employee_id), name, float(salary))) if not employees: print(\\"No employee data found.\\") return total_employees = len(employees) total_salary = sum(e[2] for e in employees) average_salary = total_salary / total_employees highest_salary = max(e[2] for e in employees) highest_salary_employees = [e for e in employees if e[2] == highest_salary] print(f\\"Total number of employees: {total_employees}\\") print(f\\"Average salary: {average_salary:.2f}\\") print(\\"Employee(s) with the highest salary:\\") for employee in highest_salary_employees: print(f\\"{employee[0]}, {employee[1]}, {employee[2]:.2f}\\") # Example usage # process_employee_file('employees.csv')"},{"question":"import pandas as pd import matplotlib.pyplot as plt import datetime as dt def compute_avg_retention_plot(csv_url: str) -> pd.DataFrame: Load a CSV file, compute the average retention time per department, and plot a bar chart of the results. Args: csv_url (str): URL to the CSV file. Returns: pd.DataFrame: DataFrame with average retention time per department. Example: >>> url = \\"https://example.com/employee_retention.csv\\" >>> avg_retention = compute_avg_retention_plot(url) >>> avg_retention Department RetentionTime 0 Finance 7.550634 1 HR 5.456522 2 IT 3.426710 # Load CSV file data = pd.read_csv(csv_url, parse_dates=['JoinDate', 'LeaveDate']) # Calculate retention time current_date = dt.datetime.now() data['LeaveDate'].fillna(current_date, inplace=True) data['RetentionTime'] = (data['LeaveDate'] - data['JoinDate']).dt.days / 365.25 # Convert to years # Compute average retention time per department avg_retention_per_department = data.groupby('Department')['RetentionTime'].mean().reset_index() # Plot the bar chart plt.figure(figsize=(10,6)) plt.bar(avg_retention_per_department['Department'], avg_retention_per_department['RetentionTime'], color='skyblue') plt.xlabel('Department') plt.ylabel('Average Retention Time (years)') plt.title('Average Retention Time per Department') plt.xticks(rotation=45) plt.tight_layout() plt.show() return avg_retention_per_department","solution":"import pandas as pd import matplotlib.pyplot as plt import datetime as dt def compute_avg_retention_plot(csv_url): Load a CSV file, compute the average retention time per department, and plot a bar chart of the results. Args: csv_url (str): URL to the CSV file. Returns: avg_retention_per_department (pd.DataFrame): DataFrame with average retention time per department. # Load CSV file data = pd.read_csv(csv_url, parse_dates=['JoinDate', 'LeaveDate']) # Calculate retention time current_date = dt.datetime.now() data['LeaveDate'].fillna(current_date, inplace=True) data['RetentionTime'] = (data['LeaveDate'] - data['JoinDate']).dt.days / 365.25 # Convert to years # Compute average retention time per department avg_retention_per_department = data.groupby('Department')['RetentionTime'].mean().reset_index() # Plot the bar chart plt.figure(figsize=(10,6)) plt.bar(avg_retention_per_department['Department'], avg_retention_per_department['RetentionTime'], color='skyblue') plt.xlabel('Department') plt.ylabel('Average Retention Time (years)') plt.title('Average Retention Time per Department') plt.xticks(rotation=45) plt.tight_layout() plt.show() return avg_retention_per_department"},{"question":"def print_student_performance(students): Takes a list of dictionaries where each dictionary represents a student with fields \\"name\\" (string) and \\"grades\\" (list of integers). Calculates and prints the average grade of each student and categorizes them as 'Excellent', 'Good', 'Average', or 'Poor' based on their average grade. Also handles cases where \\"grades\\" list is empty and invalid data gracefully. pass # Example usage and test cases: students = [ {'name': 'Alice', 'grades': [85, 90, 78]}, {'name': 'Bob', 'grades': [95, 92, 93]}, {'name': 'Charlie', 'grades': [70, 60, 65]}, {'name': 'David', 'grades': [40, 42, 38]}, {'name': 'Eve', 'grades': []}, {'name': 'Frank', 'grades': [80, 70]}, {'name': 123, 'grades': [80, 70]}, # invalid name {'name': 'Grace', 'grades': 'invalid'}, # invalid grades ] print_student_performance(students) # Expected output: # Alice: Average Grade = 84.33, Performance = Good # Bob: Average Grade = 93.33, Performance = Excellent # Charlie: Average Grade = 65.00, Performance = Average # David: Average Grade = 40.00, Performance = Poor # No grades available for Eve. # Frank: Average Grade = 75.00, Performance = Good # Invalid data for a student: {'name': 123, 'grades': [80, 70]} # Invalid data for a student: {'name': 'Grace', 'grades': 'invalid'}","solution":"def print_student_performance(students): Takes a list of dictionaries where each dictionary represents a student with fields \\"name\\" (string) and \\"grades\\" (list of integers). Calculates and prints the average grade of each student and categorizes them as 'Excellent', 'Good', 'Average', or 'Poor' based on their average grade. Also handles cases where \\"grades\\" list is empty. for student in students: name = student.get('name') grades = student.get('grades', []) if not name or not isinstance(name, str) or not isinstance(grades, list): print(f\\"Invalid data for a student: {student}\\") continue if not grades: print(f\\"No grades available for {name}.\\") continue average_grade = sum(grades) / len(grades) if average_grade > 90: performance = 'Excellent' elif 75 <= average_grade <= 90: performance = 'Good' elif 50 <= average_grade < 75: performance = 'Average' else: performance = 'Poor' print(f\\"{name}: Average Grade = {average_grade:.2f}, Performance = {performance}\\")"},{"question":"from typing import List def longest_increasing_subsequence(arr: List[int]) -> List[int]: Create a program that finds the longest increasing subsequence in a list of integers. >>> longest_increasing_subsequence([5, 2, 8, 6, 3, 6, 9, 7]) [2, 3, 6, 9] >>> longest_increasing_subsequence([]) [] >>> longest_increasing_subsequence([10]) [10] >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) [5] >>> longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) [10, 22, 33, 50, 60, 80] >>> longest_increasing_subsequence([3, 4, 5, 5, 10]) [3, 4, 5, 10]","solution":"def longest_increasing_subsequence(arr): Finds the longest increasing subsequence in a list of integers. if not arr: return [] n = len(arr) dp = [1] * n parent = [-1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j] and dp[i] < dp[j] + 1: dp[i] = dp[j] + 1 parent[i] = j # Find the index of the maximum value in dp max_index = 0 max_value = dp[0] for i in range(1, n): if dp[i] > max_value: max_value = dp[i] max_index = i # Trace back the LIS from the parent array lis = [] while max_index != -1: lis.append(arr[max_index]) max_index = parent[max_index] return lis[::-1] # Reverse the lis to get the correct order"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def range_sum_bst(root: TreeNode, L: int, R: int) -> int: Return the sum of all nodes with a value within a given range (inclusive) in a binary search tree. >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.right = TreeNode(15) >>> root.left.left = TreeNode(3) >>> root.left.right = TreeNode(7) >>> root.right.right = TreeNode(18) >>> range_sum_bst(root, 7, 15) 32 >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.right = TreeNode(15) >>> root.left.left = TreeNode(3) >>> root.left.right = TreeNode(7) >>> root.left.left.left = TreeNode(1) >>> root.left.right.left = TreeNode(6) >>> root.right.left = TreeNode(13) >>> root.right.right = TreeNode(18) >>> range_sum_bst(root, 6, 10) 23 pass","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def range_sum_bst(root: TreeNode, L: int, R: int) -> int: if not root: return 0 total_sum = 0 if L <= root.val <= R: total_sum += root.val if root.val > L: total_sum += range_sum_bst(root.left, L, R) if root.val < R: total_sum += range_sum_bst(root.right, L, R) return total_sum"},{"question":"def quickselect(arr, k): Returns the k-th smallest element in an unsorted list using the Quickselect algorithm. >>> quickselect([10, 2, 6, 8, 5, 4, 9, 7, 3, 1], 4) 4 >>> quickselect([1], 1) 1 >>> quickselect([3, 3, 3, 3, 3], 2) 3 >>> quickselect(list(range(1, 101)), 50) 50 >>> quickselect([10, 2, 6, 8, 5, 4, 9, 7, 3, 1], 10) 10 >>> quickselect([10, 2, 6, 8, 5, 4, 9, 7, 3, 1], 1) 1","solution":"def quickselect(arr, k): Returns the k-th smallest element in an unsorted list using the Quickselect algorithm. if k < 1 or k > len(arr): raise ValueError(\\"k is out of bounds\\") def partition(left, right, pivot_index): pivot_value = arr[pivot_index] arr[pivot_index], arr[right] = arr[right], arr[pivot_index] store_index = left for i in range(left, right): if arr[i] < pivot_value: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 arr[right], arr[store_index] = arr[store_index], arr[right] return store_index def select(left, right, k_smallest): if left == right: return arr[left] pivot_index = left pivot_index = partition(left, right, pivot_index) if k_smallest == pivot_index: return arr[k_smallest] elif k_smallest < pivot_index: return select(left, pivot_index - 1, k_smallest) else: return select(pivot_index + 1, right, k_smallest) return select(0, len(arr) - 1, k - 1)"},{"question":"def longest_increasing_subsequence(arr: List[int]) -> int: Write a function that implements the dynamic programming approach to solve the \\"Longest Increasing Subsequence\\" problem. Given an unsorted array of integers, your task is to find the length of the longest strictly increasing subsequence within this array. Your function should return the length as an integer. Additionally, provide an analysis of the time and space complexity of your solution. >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) == 4 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) == 5 >>> longest_increasing_subsequence([10]) == 1 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) == 1 >>> longest_increasing_subsequence([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]) == 6 >>> longest_increasing_subsequence([]) == 0","solution":"def longest_increasing_subsequence(arr): Returns the length of the longest strictly increasing subsequence in the array. :param arr: List[int] - The input array of integers. :return: int - The length of the longest increasing subsequence. if not arr: return 0 # Initialize the dp array where dp[i] represents the length of the longest # increasing subsequence that ends with arr[i] dp = [1] * len(arr) # Construct the dp array for i in range(1, len(arr)): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) # The length of the longest increasing subsequence is the maximum value in dp array return max(dp)"},{"question":"def can_form_palindrome(s: str) -> bool: Determines whether any permutation of the input string can be rearranged into a palindrome. >>> can_form_palindrome(\\"A man, a plan, a canal, Panama!\\") == True >>> can_form_palindrome(\\"racecar\\") == True >>> can_form_palindrome(\\"abcba\\") == True >>> can_form_palindrome(\\"No 'x' in Nixon\\") == True >>> can_form_palindrome(\\"a\\") == True >>> can_form_palindrome(\\"abba\\") == True >>> can_form_palindrome(\\"abcd\\") == False >>> can_form_palindrome(\\"!!!...,,,\\") == True >>> can_form_palindrome(\\"\\") == True","solution":"def can_form_palindrome(s): Determines whether any permutation of the input string can be rearranged into a palindrome. A string can be rearranged into a palindrome if at most one character has an odd frequency count, and all other characters have even frequency counts. Non-alphanumeric characters are ignored, and uppercase and lowercase letters are treated as equivalent. :param s: The input string :return: True if the input string can be rearranged into a palindrome, False otherwise from collections import Counter # Normalize the string: remove non-alphanumeric characters and convert to lowercase s = ''.join(e for e in s if e.isalnum()).lower() # Count frequency of each character char_count = Counter(s) # Check how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be permuted to form a palindrome if there is at most one character with an odd count return odd_count <= 1"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression string containing digits, '+', '-', '*', '/', and parentheses. >>> evaluate_expression(\\"3 + 2\\") == 5.0 >>> evaluate_expression(\\"10 - 5\\") == 5.0 >>> evaluate_expression(\\"6 * 3\\") == 18.0 >>> evaluate_expression(\\"8 / 2\\") == 4.0 >>> evaluate_expression(\\"3 + 2 * 2\\") == 7.0 >>> evaluate_expression(\\"(3 + 2) * 2\\") == 10.0 >>> evaluate_expression(\\"3 + (2 - 1) * 5 / 2\\") == 5.5 >>> evaluate_expression(\\"((3 + 2) * (2 + 3))\\") == 25.0","solution":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression string containing digits, '+', '-', '*', '/', and parentheses. def parse_expression(expr): Helper function to parse the expression and get a result. ops = [] nums = [] i = 0 while i < len(expr): if expr[i].isdigit(): num = 0 while i < len(expr) and expr[i].isdigit(): num = num * 10 + int(expr[i]) i += 1 nums.append(num) elif expr[i] in \\"+-*/\\": while (ops and ops[-1] in \\"*/\\" and expr[i] in \\"+-\\") or (ops and ops[-1] in \\"*/\\" and expr[i] in \\"*/\\"): perform_operation(nums, ops) ops.append(expr[i]) i += 1 elif expr[i] == \\"(\\": ops.append(expr[i]) i += 1 elif expr[i] == \\")\\": while ops and ops[-1] != \\"(\\": perform_operation(nums, ops) ops.pop() # Remove the \\"(\\" i += 1 else: i += 1 while ops: perform_operation(nums, ops) return nums[0] def perform_operation(nums, ops): Helper function to perform an operation. right = nums.pop() left = nums.pop() op = ops.pop() if op == '+': nums.append(left + right) elif op == '-': nums.append(left - right) elif op == '*': nums.append(left * right) elif op == '/': nums.append(left / right) clean_expr = expression.replace(\\" \\", \\"\\") return parse_expression(clean_expr)"},{"question":"def length_of_longest_substring(s: str) -> int: Finds the length of the longest substring without repeating characters in the given string \`s\`. Handles edge cases such as empty string or strings containing special characters. >>> length_of_longest_substring(\\"\\") == 0 >>> length_of_longest_substring(\\"a\\") == 1 >>> length_of_longest_substring(\\"abcdef\\") == 6 >>> length_of_longest_substring(\\"abca\\") == 3 >>> length_of_longest_substring(\\"bbbbb\\") == 1 >>> length_of_longest_substring(\\"!@#%^^&&\\") == 4 >>> length_of_longest_substring(\\"pwwkew\\") == 3 >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"dvdf\\") == 3 >>> length_of_longest_substring(\\"a b c a b\\") == 3","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters in \`s\`. chars = set() left = 0 result = 0 for right in range(len(s)): while s[right] in chars: chars.remove(s[left]) left += 1 chars.add(s[right]) result = max(result, right - left + 1) return result # Explanation: # The function \`length_of_longest_substring\` uses a sliding window approach to find the longest substring without repeating characters. # - We maintain a set called \`chars\` to store characters in the current window. # - The \`left\` pointer starts at the beginning of the string and moves to the right whenever a duplicate character is found. # - The \`right\` pointer moves through each character in the string. # - If a duplicate character is found (i.e., \`s[right]\` is in \`chars\`), we remove characters from the set starting from the \`left\` pointer until the duplicate character is removed. # - We update the length of the longest substring by comparing the current substring length (\`right - left + 1\`) with the previously recorded length (\`result\`). # Time Complexity: O(n) where n is the length of the input string. Each character is visited at most twice (once by the \`right\` pointer and once by the \`left\` pointer). # Space Complexity: O(min(m, n)) where n is the length of the input string and m is the size of the character set."},{"question":"from typing import List, Dict def average_salary(employees: List[Dict[str, any]]) -> float: Calculate the average salary of employees who meet the criteria: - age greater than 25 - more than 2 years of experience - job title is either 'Manager' or 'Developer' If no employees meet the criteria, return 0. >>> employees = [ ... {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"experience\\": 5, \\"job_title\\": \\"Manager\\", \\"salary\\": 80000}, ... {\\"name\\": \\"Bob\\", \\"age\\": 23, \\"experience\\": 2, \\"job_title\\": \\"Developer\\", \\"salary\\": 60000}, ... {\\"name\\": \\"Charlie\\", \\"age\\": 26, \\"experience\\": 3, \\"job_title\\": \\"Tester\\", \\"salary\\": 50000}, ... {\\"name\\": \\"David\\", \\"age\\": 28, \\"experience\\": 4, \\"job_title\\": \\"Developer\\", \\"salary\\": 70000}, ... ] >>> average_salary(employees) 75000","solution":"def average_salary(employees): Calculate the average salary of employees who meet the criteria: - age greater than 25 - more than 2 years of experience - job title is either 'Manager' or 'Developer' eligible_employees = [ emp['salary'] for emp in employees if emp['age'] > 25 and emp['experience'] > 2 and emp['job_title'] in ['Manager', 'Developer'] ] if not eligible_employees: return 0 return sum(eligible_employees) / len(eligible_employees)"},{"question":"class Graph: def __init__(self): self.graph = {} def add_edge(self, vertex, edge): Add an edge to the graph. pass def dfs(self, start): Perform a depth-first search (DFS) starting from the given vertex. >>> g = Graph() >>> g.add_edge(0, 1) >>> g.add_edge(0, 2) >>> g.add_edge(1, 2) >>> g.add_edge(2, 0) >>> g.add_edge(2, 3) >>> g.add_edge(3, 3) >>> g.dfs(2) [2, 0, 1, 3] pass def bfs(self, start): Perform a breadth-first search (BFS) starting from the given vertex. >>> g = Graph() >>> g.add_edge(0, 1) >>> g.add_edge(0, 2) >>> g.add_edge(1, 2) >>> g.add_edge(2, 0) >>> g.add_edge(2, 3) >>> g.add_edge(3, 3) >>> g.bfs(2) [2, 0, 3, 1] pass","solution":"class Graph: def __init__(self): self.graph = {} def add_edge(self, vertex, edge): if vertex in self.graph: self.graph[vertex].append(edge) else: self.graph[vertex] = [edge] def dfs(self, start): visited = set() result = [] def _dfs(vertex): if vertex not in visited: visited.add(vertex) result.append(vertex) for neighbor in self.graph.get(vertex, []): _dfs(neighbor) _dfs(start) return result def bfs(self, start): visited = set() queue = [start] result = [] while queue: vertex = queue.pop(0) if vertex not in visited: visited.add(vertex) result.append(vertex) queue.extend(neighbor for neighbor in self.graph.get(vertex, []) if neighbor not in visited) return result"},{"question":"def first_non_repeating_character(s: str) -> str: Returns the first non-repeating character in the string s. If no such character exists, returns an underscore '_'. >>> first_non_repeating_character(\\"a\\") ==> \\"a\\" >>> first_non_repeating_character(\\"aabbcc\\") ==> \\"_\\" >>> first_non_repeating_character(\\"aabcc\\") ==> \\"b\\" >>> first_non_repeating_character(\\"aabbc\\") ==> \\"c\\" >>> first_non_repeating_character(\\"\\") ==> \\"_\\" >>> first_non_repeating_character(\\"abcd\\") ==> \\"a\\" >>> first_non_repeating_character(\\"swiss\\") ==> \\"w\\" >>> first_non_repeating_character(\\" a b a\\") ==> \\"b\\"","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the string s. If no such character exists, returns an underscore '_'. for char in s: if s.count(char) == 1: return char return '_'"},{"question":"from typing import List, Tuple from math import factorial def factorial_tuples(int_list: List[int]) -> List[Tuple[int, int]]: Returns a list of tuples, where each tuple contains an integer from the input list and its corresponding factorial. Args: int_list (list): A list of integers. Returns: list of tuples: Each tuple contains (integer, factorial of integer). >>> factorial_tuples([0, 1, 2, 3, 4, 5]) [(0, 1), (1, 1), (2, 2), (3, 6), (4, 24), (5, 120)] >>> factorial_tuples([]) [] >>> factorial_tuples([4]) [(4, 24)] >>> factorial_tuples([5]) [(5, 120)] >>> factorial_tuples([10]) [(10, 3628800)] >>> factorial_tuples([20]) [(20, 2432902008176640000)] >>> factorial_tuples([0, 1, 10, 15]) [(0, 1), (1, 1), (10, 3628800), (15, 1307674368000)]","solution":"from math import factorial def factorial_tuples(int_list): Returns a list of tuples, where each tuple contains an integer from the input list and its corresponding factorial. Args: int_list (list): A list of integers. Returns: list of tuples: Each tuple contains (integer, factorial of integer). return [(num, factorial(num)) for num in int_list]"},{"question":"def is_prime(num: int) -> bool: Check if the given number is prime. >>> is_prime(2) True >>> is_prime(4) False def filter_primes(numbers: List[int]) -> List[int]: Returns a new list containing only the prime numbers from the original list. >>> filter_primes([10, 15, 17, 19, 24, 29]) [17, 19, 29] from solution import filter_primes def test_filter_primes_all_primes(): assert filter_primes([2, 3, 5, 7, 11, 13]) == [2, 3, 5, 7, 11, 13] def test_filter_primes_mixed(): assert filter_primes([10, 15, 17, 19, 24, 29]) == [17, 19, 29] def test_filter_primes_no_primes(): assert filter_primes([4, 6, 8, 10, 12]) == [] def test_filter_primes_empty_list(): assert filter_primes([]) == [] def test_filter_primes_edge_cases(): assert filter_primes([1, 2, 3, 4, 5]) == [2, 3, 5] assert filter_primes([0, 1, -1, -10, 23]) == [23]","solution":"def is_prime(num): if num <= 1: return False for i in range(2, int(num ** 0.5) + 1): if num % i == 0: return False return True def filter_primes(numbers): Returns a new list containing only the prime numbers from the original list. return [num for num in numbers if is_prime(num)]"},{"question":"from typing import List, Tuple def closest_pair_of_points(points: List[Tuple[int, int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]: Find the closest pair of points from a list of given 2D points. >>> closest_pair_of_points([(1, 2), (2, 3), (3, 4), (1, 1)]) ((1, 2), (1, 1)) >>> closest_pair_of_points([(0, 0), (5, 5), (4, 4)]) ((5, 5), (4, 4))","solution":"from typing import List, Tuple import math def closest_pair_of_points(points: List[Tuple[int, int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]: def euclidean_distance(p1, p2): return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) min_distance = float('inf') closest_pair = (points[0], points[1]) for i in range(len(points)): for j in range(i + 1, len(points)): distance = euclidean_distance(points[i], points[j]) if distance < min_distance: min_distance = distance closest_pair = (points[i], points[j]) return closest_pair"},{"question":"def evaluate_expression(expression: str) -> Union[int, str]: Design a function that takes a string containing an arithmetic expression in infix notation and returns the result of evaluating the expression. The expression can contain non-negative integers and the operators '+', '-', '*', and '/'. Operator precedence should be respected and parentheses are not allowed. Additionally, handle any divide-by-zero errors by returning an error message. Examples: >>> evaluate_expression(\\"3+5*2\\") 13 >>> evaluate_expression(\\"10+20/2\\") 20 >>> evaluate_expression(\\"8*3-2\\") 22 >>> evaluate_expression(\\"4/0\\") \\"Error: Division by zero\\" >>> evaluate_expression(\\"100-50*2+3\\") 3 pass # Unit Tests def test_evaluate_expression_multiplication(): assert evaluate_expression(\\"3+5*2\\") == 13 def test_evaluate_expression_division(): assert evaluate_expression(\\"10+20/2\\") == 20 def test_evaluate_expression_subtraction(): assert evaluate_expression(\\"8*3-2\\") == 22 def test_evaluate_expression_divide_by_zero(): assert evaluate_expression(\\"4/0\\") == \\"Error: Division by zero\\" def test_evaluate_expression_complex(): assert evaluate_expression(\\"100-50*2+3\\") == 3 def test_evaluate_expression_single_number(): assert evaluate_expression(\\"7\\") == 7 def test_evaluate_expression_all_operations(): assert evaluate_expression(\\"2+3*4/2-1\\") == 7 def test_evaluate_expression_multiple_digit_numbers(): assert evaluate_expression(\\"123*456\\") == 56088 def test_evaluate_expression_no_operations(): assert evaluate_expression(\\"456\\") == 456","solution":"from typing import Union def evaluate_expression(expression: str) -> Union[int, str]: def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) elif operator == '/': if right == 0: raise ZeroDivisionError(\\"division by zero\\") values.append(left // right) def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 operators = [] values = [] i = 0 while i < len(expression): if expression[i].isdigit(): val = 0 while i < len(expression) and expression[i].isdigit(): val = (val * 10) + int(expression[i]) i += 1 values.append(val) i -= 1 else: while (operators and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, values) operators.append(expression[i]) i += 1 while operators: try: apply_operator(operators, values) except ZeroDivisionError: return \\"Error: Division by zero\\" return values[0]"},{"question":"from typing import List def can_construct(target: str, word_bank: List[str]) -> bool: Determine if the target string can be constructed from the word bank elements. >>> can_construct(\\"abcdef\\", [\\"ab\\", \\"abc\\", \\"cd\\", \\"def\\", \\"abcd\\"]) True >>> can_construct(\\"skateboard\\", [\\"bo\\", \\"rd\\", \\"ate\\", \\"t\\", \\"ska\\", \\"sk\\", \\"boar\\"]) False >>> can_construct(\\"enterapotentpot\\", [\\"a\\", \\"p\\", \\"ent\\", \\"enter\\", \\"ot\\", \\"o\\", \\"t\\"]) True >>> can_construct(\\"\\", [\\"cat\\", \\"dog\\", \\"mouse\\"]) True >>> can_construct(\\"hello\\", [\\"cat\\", \\"dog\\", \\"mouse\\"]) False >>> can_construct(\\"aaaaaa\\", [\\"a\\", \\"aa\\", \\"aaa\\"]) True >>> can_construct(\\"aaaaaab\\", [\\"a\\", \\"aa\\", \\"aaa\\"]) False >>> can_construct(\\"bird\\", [\\"bird\\"]) True >>> can_construct(\\"birdd\\", [\\"bird\\"]) False >>> can_construct(\\"applepie\\", [\\"pie\\", \\"apple\\", \\"apple\\"]) True","solution":"from typing import List def can_construct(target: str, word_bank: List[str]) -> bool: Determine if the target string can be constructed from the word bank elements. memo = {} def can_construct_memo(target): if target in memo: return memo[target] if target == \\"\\": return True for word in word_bank: if target.startswith(word): suffix = target[len(word):] if can_construct_memo(suffix): memo[target] = True return True memo[target] = False return False return can_construct_memo(target)"},{"question":"def factorial(n): Calculate the factorial of a given positive integer n. Parameters: n (int): A non-negative integer whose factorial is to be calculated. Returns: int: The factorial of the given number n. str: Error message in case of invalid input. >>> factorial(0) 1 >>> factorial(1) 1 >>> factorial(5) 120 >>> factorial(-1) 'Input must be a non-negative integer.' >>> factorial(\\"string\\") 'Input must be a non-negative integer.' >>> factorial(None) 'Input must be a non-negative integer.' # Implementation here","solution":"def factorial(n): Calculate the factorial of a given positive integer n. Parameters: n (int): A non-negative integer whose factorial is to be calculated. Returns: int: The factorial of the given number n. str: Error message in case of invalid input. if not isinstance(n, int) or n < 0: return \\"Input must be a non-negative integer.\\" if n == 0 or n == 1: return 1 result = 1 for i in range(2, n + 1): result *= i return result"},{"question":"def char_count(s: str) -> dict: Returns a dictionary containing the count of each character in the input string. Ignores spaces and is case-insensitive. Parameters: s (str): The input string. Returns: dict: Dictionary containing the count of each character. >>> char_count(\\"a\\") == {'a': 1} >>> char_count(\\"Character\\") == {'c': 2, 'h': 1, 'a': 2, 'r': 2, 't': 1, 'e': 1} >>> char_count(\\"character discourse\\") == {'c': 3, 'h': 1, 'a': 2, 'r': 3, 't': 1, 'e': 2, 'd': 1, 'i': 1, 's': 2, 'o': 1, 'u': 1} >>> char_count(\\"a a a\\") == {'a': 3} >>> char_count(\\"\\") == {} >>> char_count(\\" \\") == {} >>> char_count(\\"!@# %^ &*()\\") == {'!': 1, '@': 1, '#': 1, '': 1, '%': 1, '^': 1, '&': 1, '*': 1, '(': 1, ')': 1}","solution":"def char_count(s): Returns a dictionary containing the count of each character in the input string. Ignores spaces and is case-insensitive. Parameters: s (str): The input string. Returns: dict: Dictionary containing the count of each character. count = {} for char in s.replace(\\" \\", \\"\\").lower(): count[char] = count.get(char, 0) + 1 return count"},{"question":"def is_prime(n: int) -> bool: Helper function to check if a number is prime. Args: - n (int): The number to check for primality. Returns: - bool: True if n is a prime number, otherwise False. if n <= 1: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True def process_numbers(numbers: List[int]) -> dict: Processes a list of integers to separate primes and non-primes, sort each list, and calculate their sums. Returns a dictionary with primes, non_primes, prime_sum, and non_prime_sum. Args: - numbers (List[int]): List of integers to process. Returns: - dict: A dictionary with keys 'primes', 'non_primes', 'prime_sum', 'non_prime_sum'. >>> process_numbers([10, 3, 5, 8, 13, 4, 16]) {'primes': [3, 5, 13], 'non_primes': [4, 8, 10, 16], 'prime_sum': 21, 'non_prime_sum': 38} >>> process_numbers([2, 3, 5, 7, 11]) {'primes': [2, 3, 5, 7, 11], 'non_primes': [], 'prime_sum': 28, 'non_prime_sum': 0} >>> process_numbers([1, 4, 6, 8, 10]) {'primes': [], 'non_primes': [1, 4, 6, 8, 10], 'prime_sum': 0, 'non_prime_sum': 29} >>> process_numbers([7]) {'primes': [7], 'non_primes': [], 'prime_sum': 7, 'non_prime_sum': 0} >>> process_numbers([4]) {'primes': [], 'non_primes': [4], 'prime_sum': 0, 'non_prime_sum': 4} >>> process_numbers([1, 2, 3, 4, 5]) {'primes': [2, 3, 5], 'non_primes': [1, 4], 'prime_sum': 10, 'non_prime_sum': 5}","solution":"def is_prime(n): Return True if n is a prime number, otherwise False. if n <= 1: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True def process_numbers(numbers): Processes a list of integers to separate primes and non-primes, sort each list, and calculate their sums. Returns a dictionary with primes, non_primes, prime_sum, and non_prime_sum. primes = [] non_primes = [] for number in numbers: if is_prime(number): primes.append(number) else: non_primes.append(number) primes.sort() non_primes.sort() return { 'primes': primes, 'non_primes': non_primes, 'prime_sum': sum(primes), 'non_prime_sum': sum(non_primes) }"},{"question":"def longest_divisible_subsequence(arr: List[int]) -> int: Write a function in Python that accepts a list of integers and returns the length of the longest subsequence where each integer is divisible by the previous integer in the subsequence. For instance, given the list [3, 6, 7, 12, 24, 30], the function should return 4 since the longest subsequence is [3, 6, 12, 24]. >>> longest_divisible_subsequence([3, 6, 7, 12, 24, 30]) 4 >>> longest_divisible_subsequence([10]) 1 >>> longest_divisible_subsequence([5, 7, 11]) 1 >>> longest_divisible_subsequence([1, 2, 4, 8]) 4 >>> longest_divisible_subsequence([10, 5, 20, 10, 100, 50, 25]) 3 >>> longest_divisible_subsequence([]) 0","solution":"def longest_divisible_subsequence(arr): if not arr: return 0 n = len(arr) # Initialize the dp array where dp[i] will store the length of the longest divisible subsequence ending at index i dp = [1] * n max_length = 1 # Fill dp array in a bottom-up manner for i in range(1, n): for j in range(0, i): if arr[i] % arr[j] == 0 and dp[i] < dp[j] + 1: dp[i] = dp[j] + 1 max_length = max(max_length, dp[i]) return max_length"},{"question":"def maximalRectangle(matrix: List[str]) -> int: Determine the largest rectangle of 1's in a 2D binary matrix filled with 0's and 1's. >>> maximalRectangle([ ... \\"10100\\", ... \\"10111\\", ... \\"11111\\", ... \\"10010\\" ... ]) 6 >>> maximalRectangle([ ... \\"0\\" ... ]) 0 >>> maximalRectangle([ ... \\"01\\", ... \\"10\\" ... ]) 1","solution":"def maximalRectangle(matrix): if not matrix or not matrix[0]: return 0 num_cols = len(matrix[0]) heights = [0] * (num_cols + 1) max_area = 0 for row in matrix: for col in range(num_cols): if row[col] == '1': heights[col] += 1 else: heights[col] = 0 stack = [-1] for i in range(num_cols + 1): while heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i - 1 - stack[-1] max_area = max(max_area, h * w) stack.append(i) return max_area"},{"question":"def second_smallest_unique(nums: List[int]) -> int: Returns the second smallest unique integer in the given list of integers. If there are fewer than two unique integers, the function returns None. >>> second_smallest_unique([4, 1, 2, 2, 3, 1]) 2 >>> second_smallest_unique([4, 4, 4, 4]) None >>> second_smallest_unique([7, 7]) None >>> second_smallest_unique([8]) None >>> second_smallest_unique([9, 9, 3, 3]) 9 >>> second_smallest_unique([2, 5]) 5 >>> second_smallest_unique([10, 8, 10, 6, 8]) 8 >>> second_smallest_unique([1, 2, 3, 4, 5]) 2 >>> second_smallest_unique([-1, -2, -3, -4, -5]) -4 >>> second_smallest_unique([-4, -4, -2, -3, -2]) -3 >>> second_smallest_unique([]) None","solution":"def second_smallest_unique(nums): Returns the second smallest unique integer in the given list of integers. If there are fewer than two unique integers, the function returns None. unique_nums = list(set(nums)) # Get the unique numbers if len(unique_nums) < 2: return None # Fewer than two unique integers unique_nums.sort() return unique_nums[1] # Return the second smallest unique number"},{"question":"def decode_compressed(compressed: str) -> str: Decode a run-length encoded string of integer and character pairs into the original string. >>> decode_compressed('') '' >>> decode_compressed('3a2b') 'aaabb' >>> decode_compressed('1a5b1c') 'abbbbbc' >>> decode_compressed('4z3y') 'zzzzyyy' >>> decode_compressed('10a') 'aaaaaaaaaa' >>> decode_compressed('100b2c') 'bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbcc' >>> decode_compressed('3a2') 'aaa' >>> decode_compressed('0a3b') 'bbb' >>> decode_compressed('0a0b0c') ''","solution":"def decode_compressed(compressed: str) -> str: Decode a run-length encoded string of integer and character pairs into the original string decoded_string = \\"\\" i = 0 while i < len(compressed): # Read the count (which can be more than one digit) count = 0 while i < len(compressed) and compressed[i].isdigit(): count = count * 10 + int(compressed[i]) i += 1 # Assuming the next character is the one to be repeated if i < len(compressed): char = compressed[i] decoded_string += char * count i += 1 return decoded_string"},{"question":"def character_frequency(text: str) -> dict: Returns the frequency of each character in the given text, ignoring spaces and considering uppercase and lowercase versions of a character as the same character. >>> character_frequency(\\"Hello World\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> character_frequency(\\"\\") {} >>> character_frequency(\\" \\") {} >>> character_frequency(\\"HELLO WORLD\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> character_frequency(\\"HeLLo WoRLd\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> character_frequency(\\"Hello123\\") {'h': 1, 'e': 1, 'l': 2, 'o': 1, '1': 1, '2': 1, '3': 1} >>> character_frequency(\\"Hello, World!\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1, ',': 1, '!': 1}","solution":"def character_frequency(text): Returns the frequency of each character in the given text, ignoring spaces and considering uppercase and lowercase versions of a character as the same character. frequency = {} for char in text: if char != ' ': char = char.lower() if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"import pytest def find_peak_elements(lst): Returns a list of peak elements from the input list. A peak element is an element that is greater than its neighbors. For boundary elements, only one neighbor is considered. >>> find_peak_elements([10, 13, 5, 8, 7, 10, 6, 15, 20]) [13, 8, 10, 20] >>> find_peak_elements([1]) [1] >>> find_peak_elements([5, 3]) [5] >>> find_peak_elements([3, 5]) [5] >>> find_peak_elements([3, 5, 3]) [5] >>> find_peak_elements([1, 2, 3, 1]) [3] >>> find_peak_elements([1, 3, 2, 3, 1]) [3, 3] >>> find_peak_elements([1, 2, 3, 4, 5]) [5] >>> find_peak_elements([]) [] >>> find_peak_elements(\\"not a list\\") Traceback (most recent call last): ... TypeError: Input must be a list. >>> find_peak_elements([1, 2, 'three', 4]) Traceback (most recent call last): ... ValueError: All elements in the list must be integers.","solution":"def find_peak_elements(lst): Returns a list of peak elements from the input list. A peak element is an element that is greater than its neighbors. For boundary elements, only one neighbor is considered. if not isinstance(lst, list): raise TypeError(\\"Input must be a list.\\") if not all(isinstance(x, int) for x in lst): raise ValueError(\\"All elements in the list must be integers.\\") if len(lst) == 0: return [] if len(lst) == 1: return [lst[0]] peak_elements = [] if len(lst) > 1 and lst[0] > lst[1]: peak_elements.append(lst[0]) for i in range(1, len(lst)-1): if lst[i] > lst[i-1] and lst[i] > lst[i+1]: peak_elements.append(lst[i]) if len(lst) > 1 and lst[-1] > lst[-2]: peak_elements.append(lst[-1]) return peak_elements"},{"question":"def evaluate_expression(expression: str, value: float) -> bool: Evaluates the given mathematical expression and checks if it matches the provided numerical value. :param expression: str, the mathematical expression to evaluate :param value: int or float, the numerical value to compare the result against :return: bool or str, True if the evaluated result matches the value, False otherwise, or an error message if the expression is invalid or causes an error during evaluation. >>> evaluate_expression(\\"3 + 2 * 2\\", 7) == True >>> evaluate_expression(\\"3.5 + 2.5\\", 6.0) == True >>> evaluate_expression(\\"(3 + 2) * 2\\", 10) == True >>> evaluate_expression(\\"3 / 0\\", None) == \\"Error: Division by zero\\" >>> evaluate_expression(\\"3 + * 2\\", None) == \\"Error: Invalid expression - invalid syntax (<string>, line 1)\\" >>> evaluate_expression(\\"-3 + 5\\", 2) == True >>> evaluate_expression(\\"6 / 2 * 3\\", 9) == True >>> evaluate_expression(\\"-4 + (-3)\\", -7) == True >>> evaluate_expression(\\"4 * 5\\", 25) == False","solution":"def evaluate_expression(expression, value): Evaluates the given mathematical expression and checks if it matches the provided numerical value. :param expression: str, the mathematical expression to evaluate :param value: int or float, the numerical value to compare the result against :return: bool or str, True if the evaluated result matches the value, False otherwise, or an error message if the expression is invalid or causes an error during evaluation. try: # Evaluate the expression result = eval(expression) # Compare the result with the provided value return result == value except ZeroDivisionError: return \\"Error: Division by zero\\" except Exception as e: return f\\"Error: Invalid expression - {str(e)}\\""},{"question":"def first_non_repeating_char(s: str) -> str: Returns the first non-repeating character in the string s. If all characters repeat, returns None. >>> first_non_repeating_char(\\"teeter\\") 'r' >>> first_non_repeating_char(\\"aabbcc\\") None >>> first_non_repeating_char(\\"Swiss\\") 'S'","solution":"def first_non_repeating_char(s): Returns the first non-repeating character in the string s. If all characters repeat, returns None. char_count = {} # Count the occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find and return the first non-repeating character for char in s: if char_count[char] == 1: return char return None"},{"question":"def filter_even_numbers(input_list): Returns a new list containing only the even integers from the input list. >>> filter_even_numbers([1, 2, 3, 4, 5, 6]) [2, 4, 6] >>> filter_even_numbers([2, 4, 6, 8, 10]) [2, 4, 6, 8, 10] >>> filter_even_numbers([1, 3, 5, 7, 9]) [] >>> filter_even_numbers([]) [] >>> filter_even_numbers([1.5, 3.5, 5.5]) [] >>> filter_even_numbers([-2, -4, -5, -7, -8]) [-2, -4, -8] >>> filter_even_numbers([3, -4, -5, 6, 0]) [-4, 6, 0]","solution":"def filter_even_numbers(input_list): Returns a new list containing only the even integers from the input list. even_numbers = [] for number in input_list: if number % 2 == 0: even_numbers.append(number) return even_numbers # Example usage sample_list = [1, 2, 3, 4, 5, 6] print(filter_even_numbers(sample_list)) # Output should be [2, 4, 6]"},{"question":"from typing import List def find_common_elements(arr1: List[int], arr2: List[int]) -> List[int]: Write a function that takes two sorted arrays as input and returns a new array containing elements that are present in both input arrays. Each input array may have duplicate elements, but the function should return an array consisting of unique elements only. The order of elements in the output array should be in ascending order. Do not use built-in set operations for this task. >>> find_common_elements([1, 2, 2, 3], [2, 2, 3, 4, 5]) [2, 3] >>> find_common_elements([1, 1, 2, 3, 4], [2, 2, 3, 4, 5]) [2, 3, 4] >>> find_common_elements([-3, -2, -1, 0, 1, 2], [-2, -1, 0, 2, 3]) [-2, -1, 0, 2] >>> find_common_elements([], []) [] >>> find_common_elements([], [1, 2, 3]) [] >>> find_common_elements([1, 2, 3], []) []","solution":"def find_common_elements(arr1, arr2): Returns a new array containing unique elements that are present in both sorted input arrays. common_elements = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] == arr2[j]: if not common_elements or common_elements[-1] != arr1[i]: common_elements.append(arr1[i]) i += 1 j += 1 elif arr1[i] < arr2[j]: i += 1 else: j += 1 return common_elements"},{"question":"from typing import List def max_sum_subarray(arr: List[int], k: int) -> int: Finds the maximum sum of any contiguous subarray of length k. If such a subarray is not achievable, returns 0. >>> max_sum_subarray([2, 1, 5, 1, 3, 2], 3) 9 >>> max_sum_subarray([2, 1, 5, 1, 3, 2], 4) 11 >>> max_sum_subarray([2, 1], 3) 0 >>> max_sum_subarray([1, 2, 3, 4, 5], 5) 15 >>> max_sum_subarray([1, 2, 3, 4, 5], 1) 5 >>> max_sum_subarray([1], 2) 0 >>> max_sum_subarray([], 1) 0 >>> max_sum_subarray([5, 5, 5, 5, 5], 3) 15","solution":"def max_sum_subarray(arr, k): Finds the maximum sum of any contiguous subarray of length k. If such a subarray is not achievable, returns 0. n = len(arr) if n < k or k <= 0: return 0 # Compute the sum of the first subarray of size k max_sum = curr_sum = sum(arr[:k]) # Use sliding window to compute sums of remaining subarrays for i in range(k, n): curr_sum += arr[i] - arr[i - k] # Slide the window to the right by 1 max_sum = max(max_sum, curr_sum) return max_sum"},{"question":"import numpy as np from sklearn.metrics import mean_squared_error, mean_absolute_error class MatrixFactorization: def __init__(self, R, K, alpha, beta, iterations): Perform matrix factorization to predict empty entries in a matrix. Arguments - R (ndarray) : user-item rating matrix - K (int) : number of latent features - alpha (float) : learning rate - beta (float) : regularization parameter - iterations (int): number of iterations def train(self): Train the matrix factorization model def sgd(self): Perform stochastic gradient descent def get_prediction(self, i, j): Get the predicted rating of user i and item j def rmse(self): Compute the Root Mean Squared Error (RMSE) def mae(self): Compute the Mean Absolute Error (MAE) def test_matrix_factorization(): R = np.array([ [5, 3, 0, 1, 4, 0], [4, 0, 3, 1, 2, 0], [1, 1, 0, 5, 0, 0], [1, 0, 0, 4, 0, 0], [0, 1, 5, 4, 0, 0] ]) mf = MatrixFactorization(R, K=2, alpha=0.01, beta=0.01, iterations=10) training_process = mf.train() # Check if training_process returns a list assert isinstance(training_process, list) # Check if the training process contains tuples of rmse and mae for process in training_process: assert isinstance(process, tuple) assert len(process) == 2 # Check if RMSE and MAE are computed correctly rmse = mf.rmse() mae = mf.mae() assert isinstance(rmse, float) assert isinstance(mae, float) def test_get_prediction(): R = np.array([ [5, 3, 0, 1, 4, 0], [4, 0, 3, 1, 2, 0], [1, 1, 0, 5, 0, 0], [1, 0, 0, 4, 0, 0], [0, 1, 5, 4, 0, 0] ]) mf = MatrixFactorization(R, K=2, alpha=0.01, beta=0.01, iterations=10) mf.train() prediction = mf.get_prediction(0, 2) assert isinstance(prediction, float) def test_sgd(): R = np.array([ [5, 3, 0, 1, 4, 0], [4, 0, 3, 1, 2, 0], [1, 1, 0, 5, 0, 0], [1, 0, 0, 4, 0, 0], [0, 1, 5, 4, 0, 0] ]) mf = MatrixFactorization(R, K=2, alpha=0.01, beta=0.01, iterations=10) mf.train() assert isinstance(mf.P, np.ndarray) assert isinstance(mf.Q, np.ndarray) assert mf.P.shape == (5, 2) assert mf.Q.shape == (6, 2) def test_rmse(): R = np.array([ [5, 3, 0, 1, 4, 0], [4, 0, 3, 1, 2, 0], [1, 1, 0, 5, 0, 0], [1, 0, 0, 4, 0, 0], [0, 1, 5, 4, 0, 0] ]) mf = MatrixFactorization(R, K=2, alpha=0.01, beta=0.01, iterations=10) mf.train() rmse = mf.rmse() assert isinstance(rmse, float) def test_mae(): R = np.array([ [5, 3, 0, 1, 4, 0], [4, 0, 3, 1, 2, 0], [1, 1, 0, 5, 0, 0], [1, 0, 0, 4, 0, 0], [0, 1, 5, 4, 0, 0] ]) mf = MatrixFactorization(R, K=2, alpha=0.01, beta=0.01, iterations=10) mf.train() mae = mf.mae() assert isinstance(mae, float)","solution":"import numpy as np from sklearn.metrics import mean_squared_error, mean_absolute_error class MatrixFactorization: def __init__(self, R, K, alpha, beta, iterations): Perform matrix factorization to predict empty entries in a matrix. Arguments - R (ndarray) : user-item rating matrix - K (int) : number of latent features - alpha (float) : learning rate - beta (float) : regularization parameter - iterations (int): number of iterations self.R = R self.K = K self.alpha = alpha self.beta = beta self.iterations = iterations def train(self): # Initialize user and item latent feature matrices self.num_users, self.num_items = self.R.shape self.P = np.random.normal(scale=1./self.K, size=(self.num_users, self.K)) self.Q = np.random.normal(scale=1./self.K, size=(self.num_items, self.K)) # Initialize the biases self.b_u = np.zeros(self.num_users) self.b_i = np.zeros(self.num_items) self.b = np.mean(self.R[np.where(self.R != 0)]) # Create a list of training samples self.samples = [ (i, j, self.R[i, j]) for i in range(self.num_users) for j in range(self.num_items) if self.R[i, j] > 0 ] # Perform stochastic gradient descent for given number of iterations training_process = [] for i in range(self.iterations): np.random.shuffle(self.samples) self.sgd() rmse = self.rmse() mae = self.mae() training_process.append((rmse, mae)) print(f\\"Iteration: {i+1}; RMSE = {rmse:.4f}; MAE = {mae:.4f}\\") return training_process def sgd(self): Perform stochastic gradient descent for i, j, r in self.samples: # Compute prediction and error prediction = self.get_prediction(i, j) e = (r - prediction) # Update biases self.b_u[i] += self.alpha * (e - self.beta * self.b_u[i]) self.b_i[j] += self.alpha * (e - self.beta * self.b_i[j]) # Update user and item latent feature matrices self.P[i, :] += self.alpha * (e * self.Q[j, :] - self.beta * self.P[i, :]) self.Q[j, :] += self.alpha * (e * self.P[i, :] - self.beta * self.Q[j, :]) def get_prediction(self, i, j): Get the predicted rating of user i and item j prediction = self.b + self.b_u[i] + self.b_i[j] + self.P[i, :].dot(self.Q[j, :].T) return prediction def rmse(self): A function to compute the Root Mean Squared Error (RMSE) xs, ys = self.R.nonzero() predicted = [] actual = [] for x, y in zip(xs, ys): predicted.append(self.get_prediction(x, y)) actual.append(self.R[x, y]) return np.sqrt(mean_squared_error(predicted, actual)) def mae(self): A function to compute the Mean Absolute Error (MAE) xs, ys = self.R.nonzero() predicted = [] actual = [] for x, y in zip(xs, ys): predicted.append(self.get_prediction(x, y)) actual.append(self.R[x, y]) return mean_absolute_error(predicted, actual)"},{"question":"def pairs_with_target_sum(nums: List[int], target: int) -> List[Tuple[int, int]]: Returns all unique pairs of integers in the list \`nums\` that add up to the specified \`target\` sum. Each pair is listed in ascending order and duplicates are avoided. Arguments: nums -- list of integers target -- the target sum Returns: A list of tuples representing unique pairs that add up to the target sum. >>> pairs_with_target_sum([1, 2, 3, 4, 3, 2, 1], 4) [(1, 3), (2, 2)] >>> pairs_with_target_sum([1, 2, 3, 4], 10) [] >>> pairs_with_target_sum([1, -1, 0, 2, -2, 3, -3], 0) [(-3, 3), (-2, 2), (-1, 1)] >>> pairs_with_target_sum([2, 2, 2, 2], 4) [(2, 2)] >>> pairs_with_target_sum([0, 0, 0, 0], 0) [(0, 0)] >>> pairs_with_target_sum([-10, -8, -5, -1, 0, 2, 5, 8, 10], 0) [(-10, 10), (-8, 8), (-5, 5)]","solution":"def pairs_with_target_sum(nums, target): Returns all unique pairs of integers in the list \`nums\` that add up to the specified \`target\` sum. Each pair is listed in ascending order and duplicates are avoided. Arguments: nums -- list of integers target -- the target sum Returns: A list of tuples representing unique pairs that add up to the target sum. pairs = set() # Using a set to avoid duplicates left, right = 0, len(nums) - 1 nums.sort() while left < right: current_sum = nums[left] + nums[right] if current_sum == target: pairs.add((nums[left], nums[right])) left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return list(pairs)"},{"question":"def invert_dictionary(d): Inverts a dictionary such that each value becomes a key and each key becomes part of a list of values. Parameters: d (dict): The dictionary to invert. Returns: dict: The inverted dictionary. >>> invert_dictionary({'a': 1, 'b': 2, 'c': 1}) {1: ['a', 'c'], 2: ['b']} >>> invert_dictionary({}) {} >>> invert_dictionary({'a': 1}) {1: ['a']} >>> invert_dictionary({'a': 1, 'b': 2, 'c': 3}) {1: ['a'], 2: ['b'], 3: ['c']} >>> invert_dictionary({'a': 1, 'b': 1, 'c': 1}) {1: ['a', 'b', 'c']}","solution":"def invert_dictionary(d): Inverts a dictionary such that each value becomes a key and each key becomes part of a list of values. Parameters: d (dict): The dictionary to invert. Returns: dict: The inverted dictionary. inverted_dict = {} for key, value in d.items(): if value not in inverted_dict: inverted_dict[value] = [] inverted_dict[value].append(key) return inverted_dict"},{"question":"def maxAreaOfIsland(grid: List[List[int]]) -> int: Returns the maximum area of an island in the given grid. An island is a group of 1s (representing land) connected 4-directionally (horizontal or vertical.) Each cell is either land (1) or water (0). Example: >>> maxAreaOfIsland([[0,0,1,0,0,0,0,1,0,0,0,0,0], ... [0,0,0,0,0,0,0,1,1,1,0,0,0], ... [0,1,1,0,1,0,0,0,0,0,0,0,0], ... [0,1,0,0,1,1,0,0,1,0,1,0,0], ... [0,1,0,0,1,1,0,0,1,1,1,0,0], ... [0,0,0,0,0,0,0,0,0,0,1,0,0], ... [0,0,0,0,0,0,0,1,1,1,0,0,0], ... [0,0,0,0,0,0,0,1,1,0,0,0,0]]) 6 >>> maxAreaOfIsland([[0,0,0,0,0,0,0,0]]) 0 >>> maxAreaOfIsland([[1,1,1], ... [1,0,1], ... [1,1,1]]) 8 >>> maxAreaOfIsland([[0,1,0,1,0], ... [1,0,1,0,1], ... [0,1,0,1,0], ... [1,0,1,0,1], ... [0,1,0,1,0]]) 1 >>> maxAreaOfIsland([[1]]) 1 >>> maxAreaOfIsland([[]]) 0 >>> maxAreaOfIsland([[0]]) 0 pass # Test cases from solution import maxAreaOfIsland def test_maxAreaOfIsland_example1(): grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] assert maxAreaOfIsland(grid) == 6 def test_maxAreaOfIsland_example2(): grid = [[0,0,0,0,0,0,0,0]] assert maxAreaOfIsland(grid) == 0 def test_maxAreaOfIsland_example3(): grid = [[1,1,1], [1,0,1], [1,1,1]] assert maxAreaOfIsland(grid) == 8 def test_maxAreaOfIsland_example4(): grid = [[0,1,0,1,0], [1,0,1,0,1], [0,1,0,1,0], [1,0,1,0,1], [0,1,0,1,0]] assert maxAreaOfIsland(grid) == 1 def test_maxAreaOfIsland_example5(): grid = [[1]] assert maxAreaOfIsland(grid) == 1 def test_maxAreaOfIsland_empty(): grid = [[]] assert maxAreaOfIsland(grid) == 0 def test_maxAreaOfIsland_single_zero(): grid = [[0]] assert maxAreaOfIsland(grid) == 0","solution":"def maxAreaOfIsland(grid): Returns the maximum area of an island in the given grid. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) max_area = 0 def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == 0: return 0 grid[x][y] = 0 # Mark the cell as visited by setting it to 0 area = 1 area += dfs(x + 1, y) area += dfs(x - 1, y) area += dfs(x, y + 1) area += dfs(x, y - 1) return area for i in range(m): for j in range(n): if grid[i][j] == 1: max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"def find_longest_palindrome(s: str) -> str: Returns the longest palindromic substring within the given string. If there are multiple palindromic substrings of the same maximum length, returns the first one. >>> find_longest_palindrome(\\"\\") == \\"\\" >>> find_longest_palindrome(\\"a\\") == \\"a\\" >>> find_longest_palindrome(\\"ab\\") == \\"a\\" >>> find_longest_palindrome(\\"abba\\") == \\"abba\\" >>> find_longest_palindrome(\\"racecar\\") == \\"racecar\\" >>> find_longest_palindrome(\\"abacdfgdcaba\\") == \\"aba\\" >>> find_longest_palindrome(\\"babad\\") == \\"bab\\" >>> find_longest_palindrome(\\"cbbd\\") == \\"bb\\" >>> find_longest_palindrome(\\"abc\\") == \\"a\\" >>> find_longest_palindrome(\\"a\\" * 1000 + \\"b\\" * 500 + \\"c\\" * 1000) == \\"a\\" * 1000 >>> find_longest_palindrome(\\"Aba\\") == \\"A\\"","solution":"def find_longest_palindrome(s): Returns the longest palindromic substring within the given string. If there are multiple palindromic substrings of the same maximum length, returns the first one. n = len(s) if n == 0: return \\"\\" start, max_length = 0, 1 for i in range(1, n): # Even length palindrome low, high = i - 1, i while low >= 0 and high < n and s[low] == s[high]: if high - low + 1 > max_length: start = low max_length = high - low + 1 low -= 1 high += 1 # Odd length palindrome low, high = i - 1, i + 1 while low >= 0 and high < n and s[low] == s[high]: if high - low + 1 > max_length: start = low max_length = high - low + 1 low -= 1 high += 1 return s[start:start + max_length]"},{"question":"def knapSack(W, wt, val, n): Returns the maximum value that can be put in a knapsack of capacity W. :param W: Maximum capacity of the knapsack. :param wt: List of weights of the items. :param val: List of values of the items. :param n: Number of items. >>> knapSack(50, [10, 20, 30], [60, 100, 120], 3) == 220 >>> knapSack(0, [10, 20, 30], [60, 100, 120], 3) == 0 >>> knapSack(50, [], [], 0) == 0 >>> knapSack(50, [10], [60], 1) == 60 >>> knapSack(5, [10], [60], 1) == 0 >>> knapSack(5, [10, 20, 30], [60, 100, 120], 3) == 0","solution":"def knapSack(W, wt, val, n): Returns the maximum value that can be put in a knapsack of capacity W. :param W: Maximum capacity of the knapsack. :param wt: List of weights of the items. :param val: List of values of the items. :param n: Number of items. # Create a 2D array to store the maximum value that can be achieved with the given capacity K = [[0 for x in range(W + 1)] for x in range(n + 1)] # Build the DP table K[][] in bottom up manner for i in range(n + 1): for w in range(W + 1): if i == 0 or w == 0: K[i][w] = 0 elif wt[i-1] <= w: K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]], K[i-1][w]) else: K[i][w] = K[i-1][w] return K[n][W]"},{"question":"def trap_water(heights: List[int]) -> int: Given a list of elevations, calculates how much water is trapped after rainfall. >>> trap_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_water([4, 2, 0, 3, 2, 5]) 9","solution":"def trap_water(heights): Given a list of elevations, calculates how much water is trapped after rainfall. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"from typing import List def sort_even_odd(lst: List[int]) -> List[int]: Takes a list of integers and returns a new list containing only the even integers sorted in descending order, followed by the odd integers sorted in ascending order. Example Input/Output: >>> sort_even_odd([3, 1, 4, 7, 2, 8]) [8, 4, 2, 1, 3, 7] >>> sort_even_odd([10, 5, 12, 3, 11, 18, 20]) [20, 18, 12, 10, 3, 5, 11] >>> sort_even_odd([]) [] >>> sort_even_odd([3, 7, 5]) [3, 5, 7] >>> sort_even_odd([4, 2, 10]) [10, 4, 2] >>> sort_even_odd([13, 22, 7, 18, 5, 14]) [22, 18, 14, 5, 7, 13]","solution":"def sort_even_odd(lst): Returns a new list with even integers sorted in descending order, followed by odd integers sorted in ascending order. evens = sorted([x for x in lst if x % 2 == 0], reverse=True) odds = sorted([x for x in lst if x % 2 != 0]) return evens + odds"},{"question":"import os import string from collections import Counter from concurrent.futures import ThreadPoolExecutor def word_frequency(file_path): Reads a file and returns a Counter object with the frequency of each word. def merge_counters(counters): Merges multiple Counter objects into a single Counter. def process_files(file_paths, top_n, thread_pool_size=4): Processes multiple files to calculate word frequency and display the top N frequent words. # Unit Tests: import tempfile import pytest from solution import word_frequency, merge_counters, process_files def create_temp_file(content): Helper function to create a temporary file with the given content and return its path. fd, path = tempfile.mkstemp() with os.fdopen(fd, 'w') as tmp: tmp.write(content) return path def test_word_frequency_single_word(): content = \\"hello\\" path = create_temp_file(content) result = word_frequency(path) os.remove(path) assert result == Counter({\\"hello\\": 1}) def test_word_frequency_multiple_words(): content = \\"hello world hello\\" path = create_temp_file(content) result = word_frequency(path) os.remove(path) assert result == Counter({\\"hello\\": 2, \\"world\\": 1}) def test_word_frequency_with_punctuation(): content = \\"hello, hello! world.\\" path = create_temp_file(content) result = word_frequency(path) os.remove(path) assert result == Counter({\\"hello\\": 2, \\"world\\": 1}) def test_merge_counters(): counters = [Counter({\\"hello\\": 2}), Counter({\\"world\\": 1}), Counter({\\"hello\\": 1})] result = merge_counters(counters) assert result == Counter({\\"hello\\": 3, \\"world\\": 1}) def test_process_files(): content1 = \\"hello world\\" content2 = \\"hello hello world\\" path1 = create_temp_file(content1) path2 = create_temp_file(content2) result = process_files([path1, path2], top_n=2) os.remove(path1) os.remove(path2) assert result == [(\\"hello\\", 3), (\\"world\\", 2)] def test_process_files_edge_case_empty_file(): content1 = \\"\\" content2 = \\"hello hello\\" path1 = create_temp_file(content1) path2 = create_temp_file(content2) result = process_files([path1, path2], top_n=1) os.remove(path1) os.remove(path2) assert result == [(\\"hello\\", 2)] def test_process_files_exception_handling_non_existent_file(): with pytest.raises(FileNotFoundError): process_files([\\"non_existent_file.txt\\"], top_n=1) def test_process_files_invalid_input(): with pytest.raises(ValueError): process_files([], top_n=1) with pytest.raises(ValueError): process_files([\\"dummy_path\\"], top_n=-1)","solution":"import os import string from collections import Counter from concurrent.futures import ThreadPoolExecutor def word_frequency(file_path): Reads a file and returns a Counter object with the frequency of each word. if not os.path.exists(file_path): raise FileNotFoundError(f\\"File not found: {file_path}\\") word_count = Counter() try: with open(file_path, 'r') as file: for line in file: # Normalize case and remove punctuation words = line.lower().translate(str.maketrans('', '', string.punctuation)).split() word_count.update(words) except Exception as e: raise IOError(f\\"Error reading file {file_path}: {str(e)}\\") return word_count def merge_counters(counters): Merges multiple Counter objects into a single Counter. total_count = Counter() for counter in counters: total_count.update(counter) return total_count def process_files(file_paths, top_n, thread_pool_size=4): Processes multiple files to calculate word frequency and display the top N frequent words. if not file_paths or not isinstance(top_n, int) or top_n <= 0: raise ValueError(\\"Invalid input parameters.\\") with ThreadPoolExecutor(max_workers=thread_pool_size) as executor: futures = [executor.submit(word_frequency, file_path) for file_path in file_paths] counters = [future.result() for future in futures] total_count = merge_counters(counters) return total_count.most_common(top_n)"},{"question":"def distance_from_origin(point: tuple) -> float: Computes the Euclidean distance from the origin (0,0) for a given point. pass def sort_points(points: List[tuple]) -> List[tuple]: Sorts a list of points by their distance from the origin (0,0) in ascending order. >>> sort_points([(1, 2), (3, 4), (0, -1)]) [(0, -1), (1, 2), (3, 4)] >>> sort_points([(0, 0), (0, 0), (0, 0)]) [(0, 0), (0, 0), (0, 0)] >>> sort_points([(1, -1), (-2, -2), (-1, 1)]) [(1, -1), (-1, 1), (-2, -2)] >>> sort_points([(1, 1), (-1, -1), (1, -1), (-1, 1)]) [(1, 1), (-1, -1), (1, -1), (-1, 1)] >>> sort_points([]) [] pass def verify_sorting(original_points: List[tuple], sorted_points: List[tuple]) -> bool: Verifies that the sorted points are actually sorted by their distance from the origin and that all original points are present in the sorted list. >>> verify_sorting([(1, 2), (3, 4), (0, -1)], [(0, -1), (1, 2), (3, 4)]) True >>> verify_sorting([(1, 2), (3, 4), (0, -1)], [(1, 2), (0, -1), (3, 4)]) False >>> verify_sorting([(1, 2), (3, 4), (0, -1)], [(0, -1), (1, 2)]) False pass","solution":"import math def distance_from_origin(point): Computes the Euclidean distance from the origin (0,0) for a given point. return math.sqrt(point[0]**2 + point[1]**2) def sort_points(points): Sorts a list of points by their distance from the origin (0,0). Returns a list of sorted points. sorted_points = [] # Copy the original list to avoid mutating the input list points_copy = points.copy() while points_copy: # Find the minimum distance point and remove it from the copy list min_point = min(points_copy, key=distance_from_origin) sorted_points.append(min_point) points_copy.remove(min_point) return sorted_points def verify_sorting(original_points, sorted_points): Verifies that the sorted points are actually sorted by their distance from the origin and that all original points are present in the sorted list. # Check if all original points are present in the sorted list if set(original_points) != set(sorted_points): return False # Check if sorted_points is sorted by distance for i in range(1, len(sorted_points)): if distance_from_origin(sorted_points[i-1]) > distance_from_origin(sorted_points[i]): return False return True"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given an array nums of n integers, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. :param nums: List[int] - The input array of integers :return: List[int] - The array where each element is the product of all the elements except itself >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_except_self([1, 0, 3, 4]) [0, 12, 0, 0] >>> product_except_self([0, 0, 3, 4]) [0, 0, 0, 0] >>> product_except_self([1, 1, 1, 1]) [1, 1, 1, 1] >>> product_except_self([10]) [1] >>> product_except_self([2, 3]) [3, 2] >>> product_except_self([100000, 100000]) [100000, 100000]","solution":"def product_except_self(nums): Given an array nums of n integers, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. :param nums: List[int] - The input array of integers :return: List[int] - The array where each element is the product of all the elements except itself n = len(nums) output = [1] * n # Calculate product of all elements to the left of each element left_product = 1 for i in range(n): output[i] = left_product left_product *= nums[i] # Calculate product of all elements to the right of each element right_product = 1 for i in range(n-1, -1, -1): output[i] *= right_product right_product *= nums[i] return output"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a string representing an arithmetic expression containing addition and subtraction of non-negative integers. Parameters: expression (str): The arithmetic expression string. Returns: int: The result of the evaluated expression. >>> evaluate_expression(\\"1+2+3\\") == 6 >>> evaluate_expression(\\"5-3-1\\") == 1 >>> evaluate_expression(\\"10+5-3+2\\") == 14 >>> evaluate_expression(\\"7\\") == 7 >>> evaluate_expression(\\"5+8-2+3-10+5\\") == 9 >>> evaluate_expression(\\"0-5+2\\") == -3 >>> evaluate_expression(\\"1000+200-150+50\\") == 1100 >>> evaluate_expression(\\"0+0+0\\") == 0 >>> evaluate_expression(\\"10-0-5\\") == 5","solution":"def evaluate_expression(expression: str) -> int: Evaluates a string representing an arithmetic expression containing addition and subtraction of non-negative integers. Parameters: expression (str): The arithmetic expression string. Returns: int: The result of the evaluated expression. i = 0 n = len(expression) current_number = 0 result = 0 sign = 1 # 1 means positive, -1 means negative while i < n: char = expression[i] if char.isdigit(): current_number = 0 while i < n and expression[i].isdigit(): current_number = current_number * 10 + int(expression[i]) i += 1 result += sign * current_number elif char == '+': sign = 1 i += 1 elif char == '-': sign = -1 i += 1 return result"},{"question":"import numpy as np from scipy.sparse import csr_matrix class CollaborativeFiltering: Collaborative Filtering recommends items to users based on historical interaction data. This class includes user-based and item-based collaborative filtering techniques. def __init__(self, user_item_matrix): Initialize the collaborative filtering recommendation system. Parameters: user_item_matrix (np.array): A user-item interaction matrix. self.user_item_matrix = csr_matrix(user_item_matrix) self.user_sim_matrix = None self.item_sim_matrix = None def compute_user_similarity(self): Compute the user-user similarity matrix. pass def compute_item_similarity(self): Compute the item-item similarity matrix. pass def recommend_for_user(self, user_index, top_n=5): Generate item recommendations for a given user based on user-based collaborative filtering. Parameters: user_index (int): Index of the user for whom to generate recommendations. top_n (int): Number of top recommendations to return. Returns: list: A list of recommended item indices. pass def recommend_for_item(self, item_index, top_n=5): Generate item recommendations based on item-based collaborative filtering. Parameters: item_index (int): Index of the item for which to generate recommendations. top_n (int): Number of top recommendations to return. Returns: list: A list of similar item indices. pass def handle_cold_start_user(self, n_items=5): Handle the cold-start problem for new users by recommending the most popular items. Parameters: n_items (int): Number of top items to recommend. Returns: list: A list of recommended item indices for a new user. pass def handle_cold_start_item(self, n_users=5): Handle the cold-start problem for new items by recommending them to the most active users. Parameters: n_users (int): Number of top users to recommend the new item to. Returns: list: A list of user indices to recommend the new item to. pass def evaluate(self, true_items, pred_items): Evaluate the recommendation system using precision, recall, and F1 score. Parameters: true_items (list): A list of ground truth items. pred_items (list): A list of predicted recommended items. Returns: tuple: A tuple containing precision, recall, and F1 score. pass if __name__ == \\"__main__\\": import numpy as np from scipy.sparse import csr_matrix def test_compute_user_similarity(): matrix = np.array([[1, 1, 0, 0], [1, 0, 1, 0], [0, 1, 1, 0], [0, 0, 0, 1]]) cf = CollaborativeFiltering(matrix) cf.compute_user_similarity() assert cf.user_sim_matrix is not None assert cf.user_sim_matrix.shape == (4, 4) def test_compute_item_similarity(): matrix = np.array([[1, 1, 0, 0], [1, 0, 1, 0], [0, 1, 1, 0], [0, 0, 0, 1]]) cf = CollaborativeFiltering(matrix) cf.compute_item_similarity() assert cf.item_sim_matrix is not None assert cf.item_sim_matrix.shape == (4, 4) def test_recommend_for_user(): matrix = np.array([[1, 1, 0, 0], [1, 0, 1, 0], [0, 1, 1, 0], [0, 0, 0, 1]]) cf = CollaborativeFiltering(matrix) recommendations = cf.recommend_for_user(0, top_n=2) assert len(recommendations) == 2 def test_recommend_for_item(): matrix = np.array([[1, 1, 0, 0], [1, 0, 1, 0], [0, 1, 1, 0], [0, 0, 0, 1]]) cf = CollaborativeFiltering(matrix) recommendations = cf.recommend_for_item(0, top_n=2) assert len(recommendations) == 2 def test_handle_cold_start_user(): matrix = np.array([[1, 1, 0, 0], [1, 0, 1, 0], [0, 1, 1, 0], [0, 0, 0, 1]]) cf = CollaborativeFiltering(matrix) recommendations = cf.handle_cold_start_user(n_items=2) assert len(recommendations) == 2 def test_handle_cold_start_item(): matrix = np.array([[1, 1, 0, 0], [1, 0, 1, 0], [0, 1, 1, 0], [0, 0, 0, 1]]) cf = CollaborativeFiltering(matrix) recommendations = cf.handle_cold_start_item(n_users=2) assert len(recommendations) == 2 def test_evaluate(): true_items = [1, 0, 0, 1, 1] pred_items = [1, 0, 1, 0, 1] cf = CollaborativeFiltering(np.array([])) precision, recall, f1 = cf.evaluate(true_items, pred_items) assert 0 <= precision <= 1 assert 0 <= recall <= 1 assert 0 <= f1 <= 1 test_compute_user_similarity() test_compute_item_similarity() test_recommend_for_user() test_recommend_for_item() test_handle_cold_start_user() test_handle_cold_start_item() test_evaluate()","solution":"import numpy as np from sklearn.metrics.pairwise import cosine_similarity from scipy.sparse import csr_matrix from sklearn.metrics import precision_score, recall_score, f1_score class CollaborativeFiltering: def __init__(self, user_item_matrix): Initialize the collaborative filtering recommendation system. Parameters: user_item_matrix (np.array): A user-item interaction matrix. self.user_item_matrix = csr_matrix(user_item_matrix) self.user_sim_matrix = None self.item_sim_matrix = None def compute_user_similarity(self): Compute the user-user similarity matrix using cosine similarity. self.user_sim_matrix = cosine_similarity(self.user_item_matrix) def compute_item_similarity(self): Compute the item-item similarity matrix using cosine similarity. self.item_sim_matrix = cosine_similarity(self.user_item_matrix.T) def recommend_for_user(self, user_index, top_n=5): Generate item recommendations for a given user based on user-based collaborative filtering. Parameters: user_index (int): Index of the user for whom to generate recommendations. top_n (int): Number of top recommendations to return. Returns: list: A list of recommended item indices. if self.user_sim_matrix is None: self.compute_user_similarity() similar_users = self.user_sim_matrix[user_index] item_scores = similar_users.dot(self.user_item_matrix.toarray()) item_scores = item_scores / similar_users.sum() user_items = self.user_item_matrix[user_index].toarray().flatten() item_indices = np.argsort(item_scores - user_items)[::-1] return item_indices[:top_n] def recommend_for_item(self, item_index, top_n=5): Generate item recommendations based on item-based collaborative filtering. Parameters: item_index (int): Index of the item for which to generate recommendations. top_n (int): Number of top recommendations to return. Returns: list: A list of similar item indices. if self.item_sim_matrix is None: self.compute_item_similarity() similar_items = self.item_sim_matrix[item_index] item_indices = np.argsort(similar_items)[::-1] return item_indices[:top_n] def handle_cold_start_user(self, n_items=5): Handle the cold-start problem for new users by recommending the most popular items. Parameters: n_items (int): Number of top items to recommend. Returns: list: A list of recommended item indices for a new user. item_popularity = np.array(self.user_item_matrix.sum(axis=0)).flatten() return np.argsort(item_popularity)[-n_items:] def handle_cold_start_item(self, n_users=5): Handle the cold-start problem for new items by recommending them to the most active users. Parameters: n_users (int): Number of top users to recommend the new item to. Returns: list: A list of user indices to recommend the new item to. user_activity = np.array(self.user_item_matrix.sum(axis=1)).flatten() return np.argsort(user_activity)[-n_users:] def evaluate(self, true_items, pred_items): Evaluate the recommendation system using precision, recall, and F1 score. Parameters: true_items (list): A list of ground truth items. pred_items (list): A list of predicted recommended items. Returns: tuple: A tuple containing precision, recall, and F1 score. precision = precision_score(true_items, pred_items, average='macro') recall = recall_score(true_items, pred_items, average='macro') f1 = f1_score(true_items, pred_items, average='macro') return precision, recall, f1"},{"question":"import json def calculate_grade(score): Calculate the grade based on the score. >>> calculate_grade(95) == \\"A\\" >>> calculate_grade(85) == \\"B\\" >>> calculate_grade(75) == \\"C\\" >>> calculate_grade(65) == \\"D\\" >>> calculate_grade(55) == \\"F\\" pass def process_student_data(file_path): Process student data from the given JSON file. Args: file_path (str): Path to the JSON file containing student data. Returns: Tuple: Contains a list of students with their total score, average score, and grade, and a summary report with highest, lowest, and average scores for each subject. >>> data = [ ... {\\"name\\": \\"Alice\\", \\"scores\\": {\\"math\\": 85, \\"science\\": 90, \\"english\\": 78}}, ... {\\"name\\": \\"Bob\\", \\"scores\\": {\\"math\\": 58, \\"science\\": 62, \\"english\\": 74}}, ... {\\"name\\": \\"Charlie\\", \\"scores\\": {\\"math\\": 92, \\"science\\": 87, \\"english\\": 81}} ... ] ... file_path = \\"students.json\\" ... with open(file_path, 'w') as f: ... json.dump(data, f) >>> result, summary = process_student_data(file_path) >>> expected_result = [ ... {'name': 'Alice', 'total_score': 253, 'average_score': 84.33333333333333, 'grade': 'B'}, ... {'name': 'Bob', 'total_score': 194, 'average_score': 64.66666666666667, 'grade': 'D'}, ... {'name': 'Charlie', 'total_score': 260, 'average_score': 86.66666666666667, 'grade': 'B'} ... ] >>> assert result == expected_result >>> expected_summary = { ... 'math': {'highest': 92, 'lowest': 58, 'total': 235, 'count': 3, 'average': 78.33333333333333}, ... 'science': {'highest': 90, 'lowest': 62, 'total': 239, 'count': 3, 'average': 79.66666666666667}, ... 'english': {'highest': 81, 'lowest': 74, 'total': 233, 'count': 3, 'average': 77.66666666666667} ... } >>> assert summary == expected_summary pass","solution":"import json def calculate_grade(score): if score >= 90: return \\"A\\" elif score >= 80: return \\"B\\" elif score >= 70: return \\"C\\" elif score >= 60: return \\"D\\" else: return \\"F\\" def process_student_data(file_path): with open(file_path, 'r') as f: data = json.load(f) result = [] subject_summary = {} for student in data: name = student['name'] scores = student['scores'] total_score = sum(scores.values()) average_score = total_score / len(scores) grade = calculate_grade(average_score) result.append({ 'name': name, 'total_score': total_score, 'average_score': average_score, 'grade': grade }) for subject, score in scores.items(): if subject not in subject_summary: subject_summary[subject] = { 'highest': score, 'lowest': score, 'total': score, 'count': 1 } else: subject_summary[subject]['highest'] = max(subject_summary[subject]['highest'], score) subject_summary[subject]['lowest'] = min(subject_summary[subject]['lowest'], score) subject_summary[subject]['total'] += score subject_summary[subject]['count'] += 1 for subject in subject_summary: subject_summary[subject]['average'] = subject_summary[subject]['total'] / subject_summary[subject]['count'] return result, subject_summary"},{"question":"import requests import csv import datetime def fetch_bitcoin_price_info(): Fetch the Bitcoin price information from the Coindesk API and store it in a CSV file. Returns: dict: A dictionary containing general information and the filename of the CSV file. Example Usage: >>> fetch_bitcoin_price_info() { 'time_updated': '2023-10-07T09:22:00+00:00', 'disclaimer': 'This data was produced...', 'chart_name': 'Bitcoin', 'currency_info': [ {'Currency': 'USD', 'Description': 'United States Dollar', 'Rate': '50,000.5'}, {'Currency': 'GBP', 'Description': 'British Pound Sterling', 'Rate': '36,000.5'}, {'Currency': 'EUR', 'Description': 'Euro', 'Rate': '41,000.5'} ], 'csv_filename': 'bitcoin_price_20231007_092200.csv' } # Unit Test 1: Check general structure def test_fetch_bitcoin_price_info_structure(): result = fetch_bitcoin_price_info() # Check general structure assert 'time_updated' in result assert 'disclaimer' in result assert 'chart_name' in result assert 'currency_info' in result assert 'csv_filename' in result # Unit Test 2: Check currency info structure def test_fetch_bitcoin_price_info_currency_info(): result = fetch_bitcoin_price_info() # Check currency info structure assert isinstance(result['currency_info'], list) assert len(result['currency_info']) > 0 for currency in result['currency_info']: assert 'Currency' in currency assert 'Description' in currency assert 'Rate' in currency # Unit Test 3: Check if the CSV file was created def test_fetch_bitcoin_price_info_csv_file(): result = fetch_bitcoin_price_info() # Check if the CSV file was created assert result['csv_filename'] with open(result['csv_filename'], 'r') as csvfile: reader = csv.DictReader(csvfile) data = list(reader) # Ensure the CSV has the correct structure assert len(data) > 0 for row in data: assert 'Currency' in row assert 'Description' in row assert 'Rate' in row","solution":"import requests import csv import datetime def fetch_bitcoin_price_info(): url = \\"https://api.coindesk.com/v1/bpi/currentprice.json\\" try: response = requests.get(url) response.raise_for_status() # Will raise HTTPError for bad requests (4xx and 5xx) data = response.json() # Extract general information time_updated = data['time']['updated'] disclaimer = data['disclaimer'] chart_name = data['chartName'] # Extract BPI details bpi_data = data['bpi'] currency_info = [] for currency_code, currency_details in bpi_data.items(): description = currency_details['description'] rate = currency_details['rate'] currency_info.append({ 'Currency': currency_code, 'Description': description, 'Rate': rate }) # Store data in CSV filename = f\\"bitcoin_price_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.csv\\" with open(filename, 'w', newline='') as csvfile: fieldnames = ['Currency', 'Description', 'Rate'] writer = csv.DictWriter(csvfile, fieldnames=fieldnames) writer.writeheader() for row in currency_info: writer.writerow(row) return { 'time_updated': time_updated, 'disclaimer': disclaimer, 'chart_name': chart_name, 'currency_info': currency_info, 'csv_filename': filename } except requests.RequestException as e: print(f\\"Error fetching Bitcoin price information: {e}\\") return None"},{"question":"import pandas as pd import matplotlib.pyplot as plt def load_data(data): Load the data into a Pandas DataFrame. >>> data = [ ... {'user_id': 1, 'activity': 'login', 'timestamp': '2023-01-01 08:00:00'}, ... {'user_id': 2, 'activity': 'purchase', 'timestamp': '2023-01-01 09:00:00'} ... ] >>> df = load_data(data) >>> not df.empty True pass def clean_data(df): Clean the data by normalizing timestamps and handling missing data. >>> data = [ ... {'user_id': 1, 'activity': 'login', 'timestamp': 'corrupted_timestamp'}, ... {'user_id': 2, 'activity': 'purchase', 'timestamp': '2023-01-01 09:00:00'} ... ] >>> df = load_data(data) >>> df = clean_data(df) >>> df.shape[0] 1 pass def transform_data(df): Convert the activities into numerical codes. >>> data = [ ... {'user_id': 1, 'activity': 'login', 'timestamp': '2023-01-01 08:00:00'}, ... {'user_id': 2, 'activity': 'purchase', 'timestamp': '2023-01-01 09:00:00'} ... ] >>> df = load_data(data) >>> df = clean_data(df) >>> df = transform_data(df) >>> 'activity_code' in df.columns True pass def aggregate_data(df): Calculate the number of unique users and number of activities per user. >>> data = [ ... {'user_id': 1, 'activity': 'login', 'timestamp': '2023-01-01 08:00:00'}, ... {'user_id': 2, 'activity': 'purchase', 'timestamp': '2023-01-01 09:00:00'}, ... {'user_id': 1, 'activity': 'logout', 'timestamp': '2023-01-01 10:00:00'} ... ] >>> df = load_data(data) >>> df = clean_data(df) >>> df = transform_data(df) >>> unique_users, activities_per_user = aggregate_data(df) >>> unique_users == 2 True pass def visualize_data(df): Visualize the data with bar charts and time series graphs. >>> data = [ ... {'user_id': 1, 'activity': 'login', 'timestamp': '2023-01-01 08:00:00'}, ... {'user_id': 2, 'activity': 'purchase', 'timestamp': '2023-01-01 09:00:00'}, ... {'user_id': 1, 'activity': 'logout', 'timestamp': '2023-01-01 10:00:00'} ... ] >>> df = load_data(data) >>> df = clean_data(df) >>> df = transform_data(df) >>> visualize_data(df) pass def data_analysis_pipeline(data): Run the full data analysis pipeline. >>> data = [ ... {'user_id': 1, 'activity': 'login', 'timestamp': '2023-01-01 08:00:00'}, ... {'user_id': 2, 'activity': 'purchase', 'timestamp': '2023-01-01 09:00:00'}, ... {'user_id': 1, 'activity': 'logout', 'timestamp': '2023-01-01 10:00:00'} ... ] >>> df, unique_users, activities_per_user = data_analysis_pipeline(data) >>> not df.empty True >>> unique_users == 2 True pass","solution":"import pandas as pd import matplotlib.pyplot as plt def load_data(data): df = pd.DataFrame(data) return df def clean_data(df): df['timestamp'] = pd.to_datetime(df['timestamp'], errors='coerce') df.dropna(subset=['timestamp'], inplace=True) return df def transform_data(df): activity_map = {'login': 1, 'purchase': 2, 'logout': 3} df['activity_code'] = df['activity'].map(activity_map) return df def aggregate_data(df): unique_users = df['user_id'].nunique() activities_per_user = df.groupby('user_id').size() return unique_users, activities_per_user def visualize_data(df): # Bar chart for activity distribution df['activity'].value_counts().plot(kind='bar') plt.title('Distribution of Activities') plt.xlabel('Activity') plt.ylabel('Count') plt.show() # Time series graph of user activity over time df.set_index('timestamp').groupby('activity_code')['activity_code'].resample('H').count().unstack(0).plot() plt.title('User Activity Over Time') plt.xlabel('Time') plt.ylabel('Activity Count') plt.legend(['Login', 'Purchase', 'Logout'], title='Activity') plt.show() def data_analysis_pipeline(data): df = load_data(data) df = clean_data(df) df = transform_data(df) unique_users, activities_per_user = aggregate_data(df) visualize_data(df) return df, unique_users, activities_per_user"},{"question":"import pandas as pd from sklearn.model_selection import train_test_split, GridSearchCV from sklearn.linear_model import LogisticRegression from sklearn.metrics import accuracy_score, roc_auc_score, roc_curve import matplotlib.pyplot as plt from sklearn.preprocessing import StandardScaler def get_results(): Download the 'Heart Disease UCI' dataset from the UCI Machine Learning Repository. Clean the dataset by handling any missing values appropriately. Split the cleaned data into training and testing sets using an 80:20 ratio. Implement a Logistic Regression classifier to predict the presence of heart disease. Tune the hyperparameters of the Logistic Regression model using Grid Search Cross Validation to find the optimal values for 'C' (inverse of regularization strength) and 'solver' (algorithm to use in the optimization problem). Evaluate the performance of the initial and tuned models by calculating their accuracy scores. Generate a Receiver Operating Characteristic (ROC) curve and calculate the Area Under the Curve (AUC) score for each model. Finally, explain the results, highlighting any improvements observed after tuning the model's hyperparameters. Returns: Tuple: containing initial accuracy, best accuracy, initial ROC-AUC score, and best ROC-AUC score (all floats). >>> initial_accuracy, best_accuracy, initial_roc_auc, best_roc_auc = get_results() >>> initial_accuracy > 0.5 True >>> best_accuracy > 0.5 True >>> initial_roc_auc > 0.5 True >>> best_roc_auc > 0.5 True >>> best_accuracy >= initial_accuracy True >>> best_roc_auc >= initial_roc_auc True","solution":"import pandas as pd from sklearn.model_selection import train_test_split, GridSearchCV from sklearn.linear_model import LogisticRegression from sklearn.metrics import accuracy_score, roc_auc_score, roc_curve import matplotlib.pyplot as plt from sklearn.preprocessing import StandardScaler # Load the data url = \\"https://archive.ics.uci.edu/ml/machine-learning-databases/heart-disease/processed.cleveland.data\\" columns = [\\"age\\", \\"sex\\", \\"cp\\", \\"trestbps\\", \\"chol\\", \\"fbs\\", \\"restecg\\", \\"thalach\\", \\"exang\\", \\"oldpeak\\", \\"slope\\", \\"ca\\", \\"thal\\", \\"target\\"] df = pd.read_csv(url, names=columns) # Replace missing values indicated by '?' with NaN df.replace('?', pd.NA, inplace=True) # Convert to numeric type, forcing errors to NaN df = df.apply(pd.to_numeric, errors='coerce') # Drop rows with missing values df.dropna(inplace=True) # Separate features and target X = df.drop(columns='target') y = df['target'].apply(lambda x: 1 if x > 0 else 0) # Binary classification: 1 presence, 0 absence # Split into training and testing sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Standardize the features scaler = StandardScaler() X_train = scaler.fit_transform(X_train) X_test = scaler.transform(X_test) # Initialize the Logistic Regression model initial_model = LogisticRegression(max_iter=1000) # Train the initial model initial_model.fit(X_train, y_train) # Predictions and evaluation of initial model initial_preds = initial_model.predict(X_test) initial_accuracy = accuracy_score(y_test, initial_preds) initial_roc_auc = roc_auc_score(y_test, initial_model.predict_proba(X_test)[:, 1]) # Grid Search for Hyperparameter Tuning param_grid = { 'C': [0.01, 0.1, 1, 10, 100], 'solver': ['liblinear', 'saga'] } grid_search = GridSearchCV(LogisticRegression(max_iter=1000), param_grid, cv=5, scoring='accuracy') grid_search.fit(X_train, y_train) # Best model from Grid Search best_model = grid_search.best_estimator_ # Predictions and evaluation of best model best_preds = best_model.predict(X_test) best_accuracy = accuracy_score(y_test, best_preds) best_roc_auc = roc_auc_score(y_test, best_model.predict_proba(X_test)[:, 1]) # ROC Curve for initial model fpr_initial, tpr_initial, _ = roc_curve(y_test, initial_model.predict_proba(X_test)[:, 1]) plt.plot(fpr_initial, tpr_initial, label=f'Initial Model (AUC = {initial_roc_auc:.2f})', linestyle='--') # ROC Curve for best model fpr_best, tpr_best, _ = roc_curve(y_test, best_model.predict_proba(X_test)[:, 1]) plt.plot(fpr_best, tpr_best, label=f'Best Model (AUC = {best_roc_auc:.2f})') # Plot configuration plt.plot([0, 1], [0, 1], 'k--') plt.xlim([0, 1]) plt.ylim([0, 1]) plt.xlabel('False Positive Rate') plt.ylabel('True Positive Rate') plt.title('ROC Curve') plt.legend(loc='best') plt.show() def get_results(): return initial_accuracy, best_accuracy, initial_roc_auc, best_roc_auc"},{"question":"def filter_and_sort(list_of_dicts, threshold): Filters items with a price lower than the threshold and sorts the remaining items by price in descending order. Each dictionary in the list_of_dicts contains the keys 'name' (string) and 'price' (numeric). :param list_of_dicts: List of dictionaries representing items :param threshold: Numeric threshold to filter items :return: List of filtered and sorted dictionaries >>> list_of_dicts = [ ... {'name': 'item1', 'price': 100}, ... {'name': 'item2', 'price': 200}, ... {'name': 'item3', 'price': 150}, ... {'name': 'item4', 'price': 50} ... ] >>> threshold = 100 >>> filter_and_sort(list_of_dicts, threshold) [{'name': 'item2', 'price': 200}, {'name': 'item3', 'price': 150}, {'name': 'item1', 'price': 100}]","solution":"def filter_and_sort(list_of_dicts, threshold): Filters items with a price lower than the threshold and sorts the remaining items by price in descending order. :param list_of_dicts: List of dictionaries, each having keys 'name' and 'price' :param threshold: Numeric threshold to filter items :return: List of filtered and sorted dictionaries # Filter items based on the threshold filtered_items = [item for item in list_of_dicts if item['price'] >= threshold] # Sort items by price in descending order sorted_items = sorted(filtered_items, key=lambda x: x['price'], reverse=True) return sorted_items"},{"question":"def format_numbers(numbers): Given a list of integers, perform the following operations: 1. Remove duplicates from the list. 2. Sort the list in ascending order. 3. Abbreviate consecutive sequences by using a hyphen to represent the range. Return the formatted string representation of the list. Examples: >>> format_numbers([7, 3, 1, 2, 4, 4, 5, 7, 8, 9]) \\"1-5, 7-9\\" >>> format_numbers([1, 1, 1, 2, 3, 3, 4, 5, 6, 7, 8, 9, 10]) \\"1-10\\" >>> format_numbers([10, 20, 30, 40]) \\"10, 20, 30, 40\\"","solution":"def format_numbers(numbers): Given a list of integers, perform the following operations: 1. Remove duplicates from the list. 2. Sort the list in ascending order. 3. Abbreviate consecutive sequences by using a hyphen to represent the range. Return the formatted string representation of the list. # Step 1: Remove duplicates numbers = list(set(numbers)) # Step 2: Sort the list in ascending order numbers.sort() # Step 3: Abbreviate consecutive sequences result = [] i = 0 while i < len(numbers): start = numbers[i] while i + 1 < len(numbers) and numbers[i + 1] == numbers[i] + 1: i += 1 end = numbers[i] if start == end: result.append(f\\"{start}\\") else: result.append(f\\"{start}-{end}\\") i += 1 return \\", \\".join(result)"},{"question":"def reorder_numbers(nums: List[int], k: int) -> (Tuple[int, int], List[int]): Finds any two distinct numbers in the list that add up to k and returns the pair. Returns the original list of integers reversed. >>> reorder_numbers([10, 15, 3, 7], 17) == ((10, 7), [7, 3, 15, 10]) >>> reorder_numbers([1, 2, 3, 4, 5], 10) == ((), [5, 4, 3, 2, 1]) >>> reorder_numbers([1, 2, 3, 4, 5], 6) == ((2, 4), [5, 4, 3, 2, 1]) >>> reorder_numbers([-1, 3, 2, 4], 1) == ((-1, 2), [4, 2, 3, -1])","solution":"def reorder_numbers(nums, k): Finds any two distinct numbers in the list that add up to k and returns the pair. Returns the original list of integers reversed. seen = set() for num in nums: if (k - num) in seen: return ((k - num), num), nums[::-1] seen.add(num) return (), nums[::-1]"},{"question":"import re def is_palindrome(s: str) -> bool: Check if the given string is a palindrome, ignoring spaces, punctuation, and capitalization. >>> is_palindrome(\\"madam\\") True >>> is_palindrome(\\"A man a plan a canal Panama\\") True >>> is_palindrome(\\"A man, a plan, a canal, Panama!\\") True >>> is_palindrome(\\"No 'x' in Nixon\\") True >>> is_palindrome(\\"Hello, World!\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"12345\\") False","solution":"def is_palindrome(s): Check if the given string is a palindrome, ignoring spaces, punctuation, and capitalization. import re s = re.sub(r'[^A-Za-z0-9]', '', s).lower() for left in range(len(s)//2): right = len(s) - left - 1 if s[left] != s[right]: return False return True input_str = \\"A man, a plan, a canal, Panama\\" print(is_palindrome(input_str))"},{"question":"def evaluate_expression(expr: str): Evaluates a mathematical expression involving basic arithmetic operations, handling order of operations and parentheses. Args: expr (str): The string representing the mathematical expression. Returns: The result of the expression if valid, otherwise an appropriate error message. >>> evaluate_expression(\\"3 + 5\\") 8 >>> evaluate_expression(\\"10 + 2 * 6\\") 22 >>> evaluate_expression(\\"(100 * (2 + 12)) / 14\\") 100 >>> evaluate_expression(\\"3 + 5 / 2\\") 5.5 >>> evaluate_expression(\\"3 / (2 - 2)\\") \\"Error: Division by zero\\" >>> evaluate_expression(\\"3 + * 5\\") \\"Error: Invalid syntax\\" >>> evaluate_expression(\\" 7 - 2 * 3 / 1\\") 1","solution":"def evaluate_expression(expr): Evaluates a mathematical expression involving basic arithmetic operations, handling order of operations and parentheses. Args: expr (str): The string representing the mathematical expression. Returns: the result of the expression if valid, otherwise appropriate error message. try: # Remove whitespace from the expression expr = expr.replace(\\" \\", \\"\\") # Evaluate the expression result = eval(expr) return result except ZeroDivisionError: return \\"Error: Division by zero\\" except (SyntaxError, NameError): return \\"Error: Invalid syntax\\" except Exception as e: return f\\"Error: {str(e)}\\""},{"question":"class QueueUsingStacks: Implement a queue data structure using two stacks. The queue should support the standard enqueue and dequeue operations and ensure that these operations have an amortized time complexity of O(1). def __init__(self): Initialize your data structure here. Example: >>> q = QueueUsingStacks() >>> q.enqueue(1) >>> q.enqueue(2) >>> q.enqueue(3) pass def enqueue(self, x): Push element x to the back of the queue. :type x: int Example: >>> q = QueueUsingStacks() >>> q.enqueue(1) >>> q.enqueue(2) >>> q.enqueue(3) pass def dequeue(self): Removes the element from in front of the queue and returns that element. :rtype: int Example: >>> q = QueueUsingStacks() >>> q.enqueue(1) >>> q.enqueue(2) >>> assert q.dequeue() == 1 pass","solution":"class QueueUsingStacks: def __init__(self): Initialize your data structure here. self.stack1 = [] self.stack2 = [] def enqueue(self, x): Push element x to the back of queue. :type x: int :rtype: void self.stack1.append(x) def dequeue(self): Removes the element from in front of the queue and returns that element. :rtype: int if not self.stack2: # Only transfer from stack1 to stack2 if stack2 is empty while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop() if self.stack2 else None # Sample use case: # q = QueueUsingStacks() # q.enqueue(1) # q.enqueue(2) # print(q.dequeue()) # returns 1 # q.enqueue(3) # print(q.dequeue()) # returns 2"},{"question":"def k_largest_elements(nums: List[int], k: int) -> List[int]: Returns the k largest elements from the list nums in ascending order. >>> k_largest_elements([3, 1, 2, 5, 4], 3) == [3, 4, 5] >>> k_largest_elements([3, 1, 2], 5) == [1, 2, 3] >>> k_largest_elements([3, 1, 2, 5, 4], 0) == [] >>> k_largest_elements([], 3) == [] >>> k_largest_elements([10, 20, 30, 40], 4) == [10, 20, 30, 40] >>> k_largest_elements([42], 1) == [42] >>> k_largest_elements([-5, -1, -3, -2, -4], 2) == [-2, -1] >>> k_largest_elements([2, 1, 2, 3, 3], 3) == [2, 3, 3]","solution":"def k_largest_elements(nums, k): Returns the k largest elements from the list nums in ascending order. :param nums: List of integers :param k: Integer :return: List of k largest integers in ascending order if not nums or k <= 0: return [] # If k is greater than the length of the list, return all elements in ascending order if k >= len(nums): return sorted(nums) # Use heapq to find k largest elements, then sort them in ascending order import heapq largest = heapq.nlargest(k, nums) return sorted(largest)"},{"question":"def custom_sort(dict_list, sort_key): Sort a list of dictionaries by the specified key using a custom sorting algorithm. Each dictionary in the list contains similar keys, and the value associated with the specified key will always be an integer. If two dictionaries have the same value for the specified key, they should maintain their original order (stable sort). Parameters: - dict_list (list): A list of dictionaries to be sorted. - sort_key (str): The key to sort the dictionaries by. Returns: - list: A new list of dictionaries sorted by the sort_key. >>> custom_sort([{\\"name\\": \\"Alice\\", \\"age\\": 32}, {\\"name\\": \\"Bob\\", \\"age\\": 25}, {\\"name\\": \\"Charlie\\", \\"age\\": 30}], \\"age\\") [{\\"name\\": \\"Bob\\", \\"age\\": 25}, {\\"name\\": \\"Charlie\\", \\"age\\": 30}, {\\"name\\": \\"Alice\\", \\"age\\": 32}] >>> custom_sort([{\\"name\\": \\"Alice\\", \\"age\\": 25}, {\\"name\\": \\"Bob\\", \\"age\\": 25}, {\\"name\\": \\"Charlie\\", \\"age\\": 30}], \\"age\\") [{\\"name\\": \\"Alice\\", \\"age\\": 25}, {\\"name\\": \\"Bob\\", \\"age\\": 25}, {\\"name\\": \\"Charlie\\", \\"age\\": 30}]","solution":"def custom_sort(dict_list, sort_key): Sorts a list of dictionaries by the specified key using a custom sorting algorithm (insertion sort in this case) without using built-in sorting functions or methods. Parameters: - dict_list (list): A list of dictionaries to be sorted. - sort_key (str): The key to sort the dictionaries by. Returns: - list: A new list of dictionaries sorted by the sort_key. # Using insertion sort for stable sorting sorted_list = dict_list[:] for i in range(1, len(sorted_list)): key_dict = sorted_list[i] j = i - 1 while j >= 0 and sorted_list[j][sort_key] > key_dict[sort_key]: sorted_list[j + 1] = sorted_list[j] j -= 1 sorted_list[j + 1] = key_dict return sorted_list"},{"question":"from typing import List def is_balanced(s: str) -> bool: Validates that the string s containing only the characters '(', ')', '{', '}', '[' and ']' is a balanced sequence of parentheses, braces, and brackets. >>> is_balanced(\\"()\\") True >>> is_balanced(\\"()[]{}\\") True >>> is_balanced(\\"{[()]}\\") True >>> is_balanced(\\"(]\\") False >>> is_balanced(\\"([)]\\") False >>> is_balanced(\\"{[}\\") False >>> is_balanced(\\"\\") True >>> is_balanced(\\"(((((((\\") False >>> is_balanced(\\"(()))(\\") False >>> is_balanced(\\"()()()\\") True >>> is_balanced(\\"(((())))\\") True >>> is_balanced(\\"{[()()]}[{}]\\") True >>> is_balanced(\\"abc\\") False >>> is_balanced(\\"{[a]()b}\\") False","solution":"def is_balanced(s): Validates that the string s containing only the characters '(', ')', '{', '}', '[' and ']' is a balanced sequence of parentheses, braces, and brackets. stack = [] matching_pairs = {')': '(', '}': '{', ']': '['} for char in s: if char in matching_pairs.values(): # If the character is one of '(', '{', '[' push it to stack stack.append(char) elif char in matching_pairs: # If the character is one of ')', '}', ']' check for matching if stack and stack[-1] == matching_pairs[char]: stack.pop() else: return False else: return False # invalid character return len(stack) == 0"},{"question":"def max_sum_non_adjacent(nums: List[int]) -> int: Given a list of integers, find the maximum sum of non-adjacent numbers. If the list is empty, return 0. >>> max_sum_non_adjacent([2, 4, 6, 2, 5]) 13 >>> max_sum_non_adjacent([5, 1, 1, 5]) 10 >>> max_sum_non_adjacent([]) 0 >>> max_sum_non_adjacent([3, 2, 5, 10, 7]) 15 >>> max_sum_non_adjacent([3, 2, 7, 10]) 13 from solution import max_sum_non_adjacent def test_example_cases(): assert max_sum_non_adjacent([2, 4, 6, 2, 5]) == 13 assert max_sum_non_adjacent([5, 1, 1, 5]) == 10 assert max_sum_non_adjacent([]) == 0 assert max_sum_non_adjacent([3, 2, 5, 10, 7]) == 15 assert max_sum_non_adjacent([3, 2, 7, 10]) == 13 def test_empty_list(): assert max_sum_non_adjacent([]) == 0 def test_single_element(): assert max_sum_non_adjacent([10]) == 10 def test_two_elements(): assert max_sum_non_adjacent([3, 2]) == 3 assert max_sum_non_adjacent([2, 3]) == 3 def test_large_numbers(): assert max_sum_non_adjacent([1000, 2000, 3000, 4000, 5000]) == 9000 assert max_sum_non_adjacent([5000, 10000, 15000, 20000, 25000]) == 45000","solution":"def max_sum_non_adjacent(nums): if not nums: return 0 incl = 0 excl = 0 for num in nums: # Current max excluding i new_excl = max(incl, excl) # Current max including i incl = excl + num excl = new_excl # Return max of incl and excl return max(incl, excl)"},{"question":"def checkout(items, discount_threshold=100, discount_rate=0.1): Simulates a simplified checkout process. Parameters: - items (list of tuples): List of items, where each item is represented by a tuple containing the item name (str) and price (float). - discount_threshold (float): The price threshold above which a discount is applied. - discount_rate (float): The discount rate to be applied if the total price exceeds the discount_threshold. Returns: - total (float): The total price after applying any discounts. Raises: - ValueError: If an item has a negative price or if the items list is empty. pass def test_checkout_no_items(): try: checkout([]) except ValueError as e: assert str(e) == \\"The list of items cannot be empty.\\" def test_checkout_negative_price(): try: checkout([(\\"Apple\\", -2)]) except ValueError as e: assert str(e) == \\"Item 'Apple' has a negative price.\\" def test_checkout_no_discount(): items = [(\\"Apple\\", 2), (\\"Banana\\", 3)] assert checkout(items) == 5 def test_checkout_with_discount(): items = [(\\"Apple\\", 50), (\\"Banana\\", 60)] assert checkout(items) == 99 # 110 with 10% discount def test_checkout_edge_case_threshold(): items = [(\\"Apple\\", 100)] assert checkout(items) == 100 # No discount applied def test_checkout_exact_discount(): items = [(\\"Apple\\", 50), (\\"Banana\\", 50), (\\"Milk\\", 20)] assert checkout(items, discount_threshold=100, discount_rate=0.2) == 96 # 120 with 20% discount","solution":"def checkout(items, discount_threshold=100, discount_rate=0.1): Simulates a simplified checkout process. Parameters: - items (list of tuples): List of items, where each item is represented by a tuple containing the item name (str) and price (float). - discount_threshold (float): The price threshold above which a discount is applied. - discount_rate (float): The discount rate to be applied if the total price exceeds the discount_threshold. Returns: - total (float): The total price after applying any discounts. Raises: - ValueError: If an item has a negative price or if the items list is empty. if not items: raise ValueError(\\"The list of items cannot be empty.\\") total = 0 for item in items: name, price = item if price < 0: raise ValueError(f\\"Item '{name}' has a negative price.\\") total += price if total > discount_threshold: discount = total * discount_rate total -= discount return total"},{"question":"from typing import List class InvalidDivisionError(Exception): Custom exception for invalid division operation. pass def divide_list_elements(lst: List[int], k: int) -> List[int]: Takes a list of integers and an integer k, and returns a list of integers that are k times smaller than the integer at the same position in the original list. If the integer at a position in the original list is not divisible by k, the function raises an InvalidDivisionError. >>> divide_list_elements([10, 20, 30, 40], 2) [5, 10, 15, 20] >>> divide_list_elements([10, 21, 30, 40], 2) InvalidDivisionError: 21 is not divisible by 2 pass","solution":"from typing import List class InvalidDivisionError(Exception): Custom exception for invalid division operation. def __init__(self, value, k): super().__init__(f\\"{value} is not divisible by {k}\\") def divide_list_elements(lst: List[int], k: int) -> List[int]: result = [] for value in lst: if value % k != 0: raise InvalidDivisionError(value, k) result.append(value // k) return result"},{"question":"import requests import csv API_KEY = 'YOUR_API_KEY_HERE' BASE_URL = 'http://api.openweathermap.org/data/2.5/weather' def get_weather_data(cities): Connect to an open weather API and retrieve weather data for a given set of cities. Args: cities (List[str]): List of city names to get weather data for. Returns: List[Dict[str, Any]]: A list of dictionaries, each containing weather details for a city. weather_data = [] return weather_data def save_weather_data_to_csv(weather_data, filename='weather_summary.csv'): Save the summarized weather data to a CSV file. Args: weather_data (List[Dict[str, Any]]): A list of dictionaries containing weather details. filename (str): The name of the CSV file to save the data. Returns: None pass # Unit Tests import pytest def test_get_weather_data(monkeypatch): class MockResponse: @staticmethod def json(): return { 'main': {'temp': 22, 'humidity': 64}, 'weather': [{'description': 'clear sky'}], 'alerts': [{'event': 'Heatwave'}] } status_code = 200 def mock_get(*args, **kwargs): return MockResponse() monkeypatch.setattr('requests.get', mock_get) cities = ['MockCity'] data = get_weather_data(cities) assert len(data) == 1 assert data[0]['city'] == 'MockCity' assert data[0]['temperature'] == 22 assert data[0]['humidity'] == 64 assert data[0]['weather_description'] == 'clear sky' assert data[0]['alerts'] == 'Heatwave' def test_get_weather_data_failure(monkeypatch): class MockResponse: status_code = 404 def mock_get(*args, **kwargs): return MockResponse() monkeypatch.setattr('requests.get', mock_get) cities = ['UnknownCity'] data = get_weather_data(cities) assert len(data) == 0 def test_save_weather_data_to_csv(tmp_path): data = [ {'city': 'City1', 'temperature': 20, 'humidity': 60, 'weather_description': 'clear sky', 'alerts': 'Heatwave'}, {'city': 'City2', 'temperature': 15, 'humidity': 70, 'weather_description': 'rain', 'alerts': ''} ] file_path = tmp_path / 'weather_summary.csv' save_weather_data_to_csv(data, str(file_path)) with open(file_path, mode='r') as file: content = file.read() assert 'city,temperature,humidity,weather_description,alertsn' in content assert 'City1,20,60,clear sky,Heatwaven' in content assert 'City2,15,70,rain,n' in content","solution":"import requests import csv API_KEY = 'YOUR_API_KEY_HERE' BASE_URL = 'http://api.openweathermap.org/data/2.5/weather' def get_weather_data(cities): weather_data = [] for city in cities: response = requests.get(BASE_URL, params={'q': city, 'appid': API_KEY, 'units': 'metric'}) if response.status_code == 200: data = response.json() city_weather = { 'city': city, 'temperature': data['main']['temp'], 'humidity': data['main']['humidity'], 'weather_description': data['weather'][0]['description'], 'alerts': '' } # Check for severe weather alerts in the 'alerts' section if present if 'alerts' in data: city_weather['alerts'] = ', '.join(alert['event'] for alert in data['alerts']) weather_data.append(city_weather) else: print(f\\"Failed to get data for city: {city}\\") return weather_data def save_weather_data_to_csv(weather_data, filename='weather_summary.csv'): keys = weather_data[0].keys() with open(filename, mode='w', newline='') as file: dict_writer = csv.DictWriter(file, fieldnames=keys) dict_writer.writeheader() dict_writer.writerows(weather_data) # Example usage # cities = ['London', 'New York', 'Tokyo', 'Delhi'] # weather_data = get_weather_data(cities) # save_weather_data_to_csv(weather_data)"},{"question":"def rotate_array(arr: List[int], k: int) -> List[int]: Given an array of integers, implement an algorithm to rotate the elements to the right by k steps. Parameters: arr (List[int]): The array of integers k (int): The number of positions to rotate the array Returns: List[int]: The rotated array Examples: >>> rotate_array([1,2,3,4,5,6,7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate_array([-1,-100,3,99], 2) [3, 99, -1, -100] Note: Ensure that your solution has a space complexity of O(1).","solution":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: Given an array of integers, implement an algorithm to rotate the elements to the right by k steps. Parameters: arr (List[int]): The array of integers k (int): The number of positions to rotate the array Returns: List[int]: The rotated array if not arr: return arr n = len(arr) k = k % n # Normalize k to be within the array length # Perform the rotation using slicing rotated_array = arr[-k:] + arr[:-k] return rotated_array"},{"question":"def is_prime(n: int) -> bool: Helper function to check if a number n is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(18) False >>> is_prime(1) False >>> is_prime(0) False >>> is_prime(-5) False def filter_primes(numbers: List[int]) -> Union[List[int], str]: Returns a new list containing only the prime numbers from the provided list. If the list is empty, returns 'Input list is empty'. >>> filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> filter_primes([11, 13, 17, 19, 23, 24, 25]) [11, 13, 17, 19, 23] >>> filter_primes([0, 1, 2, 3, 5, 112, 113]) [2, 3, 5, 113] >>> filter_primes([4, 6, 8, 10]) [] >>> filter_primes([]) \\"Input list is empty\\" >>> filter_primes([-1, -2, -3, -4, -5]) []","solution":"def is_prime(n): Helper function to check if a number n is prime. if n <= 1: return False if n == 2 or n == 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(numbers): Returns a new list containing only the prime numbers from the provided list. If the list is empty, returns 'Input list is empty'. if not numbers: return \\"Input list is empty\\" return [num for num in numbers if is_prime(num)]"},{"question":"from functools import wraps from collections import OrderedDict def lru_cache(max_size=128): A decorator to implement a least-recently-used (LRU) cache. :param max_size: Maximum size of the cache. def decorator(func): cache = OrderedDict() @wraps(func) def wrapped(*args, **kwargs): key = (args, tuple(kwargs.items())) if key in cache: cache.move_to_end(key) # Mark as recently used return cache[key] result = func(*args, **kwargs) if len(cache) >= max_size: cache.popitem(last=False) # Pop the least recently used item cache[key] = result return result return wrapped return decorator Test Cases: @lru_cache(max_size=2) def slow_function(x): Simulates a slow function by returning x squared after a mock delay. return x * x def test_lru_cache_basic(): assert slow_function(2) == 4 assert slow_function(3) == 9 def test_lru_cache_reuse(): # These should hit the cache assert slow_function(2) == 4 assert slow_function(3) == 9 def test_lru_cache_eviction(): # Add more unique calls to evict the oldest one assert slow_function(4) == 16 assert slow_function(5) == 25 # This should recalculate since (2) was the oldest and should be evicted assert slow_function(2) == 4 def test_lru_cache_no_eviction(): # Ensure the cache still holds recent items assert slow_function(4) == 16 assert slow_function(5) == 25 def test_lru_cache_eviction_order(): # Use functions to manipulate the cache order slow_function(1) slow_function(2) slow_function(3) # Should evict (1) slow_function(2) # Refresh the order of (2) slow_function(4) # Should still evict (3) now slow_function(5) # Should evict oldest (2) assert slow_function(1) == 1 assert slow_function(4) == 16 assert slow_function(5) == 25 # Now both 2 and 3 should be evicted, hence 2 should recalculate assert slow_function(2) == 4","solution":"from functools import wraps from collections import OrderedDict def lru_cache(max_size=128): A decorator to implement a least-recently-used (LRU) cache. :param max_size: Maximum size of the cache. def decorator(func): cache = OrderedDict() @wraps(func) def wrapped(*args, **kwargs): key = (args, tuple(kwargs.items())) if key in cache: cache.move_to_end(key) # Mark as recently used return cache[key] result = func(*args, **kwargs) if len(cache) >= max_size: cache.popitem(last=False) # Pop the least recently used item cache[key] = result return result return wrapped return decorator"},{"question":"def cosine_similarity(vector_a, vector_b): Returns the cosine similarity between two vectors. Args: vector_a: List of integers or floats. vector_b: List of integers or floats. Returns: A floating-point number rounded to 4 decimal places.","solution":"def cosine_similarity(vector_a, vector_b): Returns the cosine similarity between two vectors. Args: vector_a: List of integers or floats. vector_b: List of integers or floats. Returns: A floating-point number rounded to 4 decimal places. if not (isinstance(vector_a, list) and isinstance(vector_b, list)): raise TypeError(\\"Both inputs must be lists.\\") if len(vector_a) == 0 or len(vector_b) == 0: raise ValueError(\\"Both lists must be non-empty.\\") if len(vector_a) != len(vector_b): raise ValueError(\\"Both lists must be of equal length.\\") dot_product = sum(a * b for a, b in zip(vector_a, vector_b)) magnitude_a = sum(a * a for a in vector_a) ** 0.5 magnitude_b = sum(b * b for b in vector_b) ** 0.5 if magnitude_a == 0 or magnitude_b == 0: raise ValueError(\\"Neither vector can be the zero vector.\\") similarity = dot_product / (magnitude_a * magnitude_b) return round(similarity, 4)"},{"question":"from typing import List def is_prime(n: int) -> bool: Returns True if the number n is a prime number, otherwise False. pass def filter_primes(numbers: List[int]) -> List[int]: Filters prime numbers from a list of integers and returns a new list containing only primes. >>> filter_primes([]) == [] >>> filter_primes([4, 6, 8, 9, 10, 12]) == [] >>> filter_primes([2, 3, 5, 7, 11, 13]) == [2, 3, 5, 7, 11, 13] >>> filter_primes([2, 4, 6, 11, 13, 15]) == [2, 11, 13] >>> filter_primes([17]) == [17] >>> filter_primes([18]) == [] >>> filter_primes(\\"not a list\\") >>> filter_primes([1, 2, 3, \\"string\\"]) >>> large_list = list(range(1000)) >>> result = filter_primes(large_list) >>> expected_result = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997] >>> result == expected_result pass","solution":"from typing import List def is_prime(n: int) -> bool: Returns True if the number n is a prime number, otherwise False. if n <= 1: return False if n == 2 or n == 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(numbers: List[int]) -> List[int]: Filters prime numbers from a list of integers and returns a new list containing only primes. if not isinstance(numbers, list): raise ValueError(\\"Input must be a list of integers\\") if any(not isinstance(num, int) for num in numbers): raise ValueError(\\"All elements in the input list must be integers\\") prime_numbers = [num for num in numbers if is_prime(num)] return prime_numbers"},{"question":"from typing import List def evaluate_expression(expression: str) -> int: This function takes a string representing a mathematical expression involving addition and subtraction of integers, parses the expression, and evaluates the result without using any built-in evaluation functions. Parameters: - expression (str): The input string containing the mathematical expression. Returns: - int: The result of the evaluated expression. >>> evaluate_expression(\\"12+3-4+5-7\\") 9 >>> evaluate_expression(\\"10\\") 10 >>> evaluate_expression(\\"1+2+3+4+5\\") 15 >>> evaluate_expression(\\"10-1-2-3\\") 4 >>> evaluate_expression(\\"10+2-7+3-1\\") 7 pass def authorize_user(user_id: int) -> bool: Placeholder function for user authorization. Parameters: - user_id (int): The ID of the user requesting authorization. Returns: - bool: True if the user is authorized, False otherwise. >>> authorize_user(1) True >>> authorize_user(6) False pass def authorized_evaluate_expression(user_id: int, expression: str): Wrapper function that first checks if the user is authorized to evaluate the expression and then evaluates if authorized. Parameters: - user_id (int): The ID of the user requesting to evaluate the expression. - expression (str): The input string containing the mathematical expression. Returns: - int or str: The evaluated result if the user is authorized, otherwise a message stating \\"Unauthorized\\". >>> authorized_evaluate_expression(1, \\"12+3-4+5-7\\") 9 >>> authorized_evaluate_expression(6, \\"12+3-4+5-7\\") \\"Unauthorized\\" pass","solution":"def evaluate_expression(expression): This function takes a string representing a mathematical expression involving addition and subtraction of integers. It parses the expression and evaluates the result. Parameters: - expression (str): The input string containing the mathematical expression. Returns: - int: The result of the evaluated expression. total = 0 num = '' sign = 1 for char in expression: if char.isdigit(): num += char else: total += sign * int(num) num = '' sign = 1 if char == '+' else -1 # Add the last number to the total total += sign * int(num) return total def authorize_user(user_id): Placeholder function for user authorization. In a real-world scenario, this could involve checking a database or other methods to verify user identity. authorized_users = {1, 2, 3, 4, 5} # Example set of authorized user ids return user_id in authorized_users def authorized_evaluate_expression(user_id, expression): Wrapper function that first checks if the user is authorized to evaluate the expression and then evaluates if authorized. Parameters: - user_id (int): The ID of the user requesting to evaluate the expression. - expression (str): The input string containing the mathematical expression. Returns: - int or str: The evaluated result if the user is authorized, otherwise a message stating \\"Unauthorized\\". if authorize_user(user_id): return evaluate_expression(expression) else: return \\"Unauthorized\\""},{"question":"class ShoppingCart: Create a Python program that simulates an online shopping cart. Design a ShoppingCart class that includes methods for adding items, removing items, and displaying the current list of items in the cart along with their quantities and prices. Implement functionality to calculate the total cost, apply discounts, and handle sales tax. Ensure that the cart maintains its state between different modifications and includes appropriate error handling for scenarios such as attempting to remove an item that isn't in the cart or applying an invalid discount code. def __init__(self): ... def add_item(self, name, quantity, price): ... def remove_item(self, name, quantity=None): ... def display_cart(self): ... def calculate_total(self): ... def apply_discount(self, discount): ... def set_sales_tax(self, tax): ... def _update_total(self): ... import pytest def test_add_item(): cart = ShoppingCart() cart.add_item(\\"apple\\", 2, 3.0) assert cart.display_cart() == {\\"apple\\": {\\"quantity\\": 2, \\"price\\": 3.0}} cart.add_item(\\"apple\\", 3, 3.0) assert cart.display_cart() == {\\"apple\\": {\\"quantity\\": 5, \\"price\\": 3.0}} def test_remove_item(): cart = ShoppingCart() cart.add_item(\\"orange\\", 3, 2.0) cart.remove_item(\\"orange\\", 1) assert cart.display_cart() == {\\"orange\\": {\\"quantity\\": 2, \\"price\\": 2.0}} cart.remove_item(\\"orange\\", 2) assert cart.display_cart() == {} def test_remove_nonexistent_item(): cart = ShoppingCart() with pytest.raises(ValueError): cart.remove_item(\\"banana\\") def test_display_cart(): cart = ShoppingCart() cart.add_item(\\"apple\\", 2, 3.0) cart.add_item(\\"banana\\", 1, 1.5) assert cart.display_cart() == { \\"apple\\": {\\"quantity\\": 2, \\"price\\": 3.0}, \\"banana\\": {\\"quantity\\": 1, \\"price\\": 1.5}, } def test_calculate_total(): cart = ShoppingCart() cart.add_item(\\"apple\\", 2, 3.0) cart.add_item(\\"banana\\", 1, 1.5) assert cart.calculate_total() == 7.5 def test_apply_discount(): cart = ShoppingCart() cart.add_item(\\"apple\\", 2, 3.0) cart.apply_discount(10) assert cart.calculate_total() == 5.4 def test_invalid_discount(): cart = ShoppingCart() with pytest.raises(ValueError): cart.apply_discount(120) def test_set_sales_tax(): cart = ShoppingCart() cart.add_item(\\"apple\\", 2, 3.0) cart.set_sales_tax(5) assert cart.calculate_total() == 6.3 def test_invalid_sales_tax(): cart = ShoppingCart() with pytest.raises(ValueError): cart.set_sales_tax(120)","solution":"class ShoppingCart: def __init__(self): self.items = {} self.total_cost = 0.0 self.discount = 0.0 self.sales_tax = 0.0 def add_item(self, name, quantity, price): if name in self.items: self.items[name]['quantity'] += quantity self.items[name]['price'] = price else: self.items[name] = {'quantity': quantity, 'price': price} self._update_total() def remove_item(self, name, quantity=None): if name not in self.items: raise ValueError(f\\"Item {name} not found in the cart.\\") if quantity is None or self.items[name]['quantity'] <= quantity: del self.items[name] else: self.items[name]['quantity'] -= quantity self._update_total() def display_cart(self): return self.items def calculate_total(self): total = self.total_cost if self.discount > 0: total -= (total * self.discount / 100) if self.sales_tax > 0: total += (total * self.sales_tax / 100) return total def apply_discount(self, discount): if not 0 <= discount <= 100: raise ValueError(\\"Invalid discount value. Must be between 0 and 100.\\") self.discount = discount def set_sales_tax(self, tax): if not 0 <= tax <= 100: raise ValueError(\\"Invalid tax value. Must be between 0 and 100.\\") self.sales_tax = tax def _update_total(self): self.total_cost = sum(v['quantity'] * v['price'] for v in self.items.values())"},{"question":"import numpy as np from sklearn.cluster import KMeans from sklearn.metrics import silhouette_score def kmeans_clustering(data, n_clusters): Perform K-means clustering on the input data. Parameters: data (np.array): The input data for clustering. n_clusters (int): The number of clusters. Returns: tuple: Tuple containing: - centroids (np.array): Coordinates of cluster centers. - labels (np.array): Labels of each point. pass def evaluate_clustering(data, labels): Evaluate the performance of clustering using the silhouette score. Parameters: data (np.array): The input data for clustering. labels (np.array): Labels of each point. Returns: float: Silhouette score of the clustering. pass # Unit tests def test_kmeans_clustering(): data = np.array([ [1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], [1.0, 0.6], [9.0, 11.0] ]) n_clusters = 2 centroids, labels = kmeans_clustering(data, n_clusters) assert centroids.shape == (n_clusters, data.shape[1]) assert len(labels) == data.shape[0] def test_evaluate_clustering(): data = np.array([ [1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], [1.0, 0.6], [9.0, 11.0] ]) n_clusters = 2 _, labels = kmeans_clustering(data, n_clusters) score = evaluate_clustering(data, labels) assert isinstance(score, float) assert -1 <= score <= 1 def test_kmeans_clustering_with_three_clusters(): data = np.array([ [1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], [1.0, 0.6], [9.0, 11.0], [8.5, 8.5], [1.2, 1.1], [8.1, 7.0], [9.5, 10.5] ]) n_clusters = 3 centroids, labels = kmeans_clustering(data, n_clusters) assert centroids.shape == (n_clusters, data.shape[1]) assert len(labels) == data.shape[0] def test_evaluate_clustering_for_three_clusters(): data = np.array([ [1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], [1.0, 0.6], [9.0, 11.0], [8.5, 8.5], [1.2, 1.1], [8.1, 7.0], [9.5, 10.5] ]) n_clusters = 3 _, labels = kmeans_clustering(data, n_clusters) score = evaluate_clustering(data, labels) assert isinstance(score, float) assert -1 <= score <= 1","solution":"import numpy as np from sklearn.cluster import KMeans from sklearn.metrics import silhouette_score def kmeans_clustering(data, n_clusters): Perform K-means clustering on the input data. Parameters: data (np.array): The input data for clustering. n_clusters (int): The number of clusters. Returns: tuple: Tuple containing: - centroids (np.array): Coordinates of cluster centers. - labels (np.array): Labels of each point. kmeans = KMeans(n_clusters=n_clusters, random_state=42) kmeans.fit(data) centroids = kmeans.cluster_centers_ labels = kmeans.labels_ return centroids, labels def evaluate_clustering(data, labels): Evaluate the performance of clustering using the silhouette score. Parameters: data (np.array): The input data for clustering. labels (np.array): Labels of each point. Returns: float: Silhouette score of the clustering. score = silhouette_score(data, labels) return score # Explanation of silhouette score: # The silhouette score is a measure of how similar an object is to its own cluster (cohesion) # compared to other clusters (separation). It ranges from -1 to +1. A high value close to +1 # indicates that the object is well matched to its own cluster and poorly matched to neighboring clusters. # A value around 0 indicates that the object is on or very close to the decision boundary between # two neighboring clusters. Negative values indicate that those points might have been assigned to # the wrong cluster."},{"question":"def is_balanced(input_str: str) -> bool: Checks whether the input string of parentheses, brackets, and curly braces is balanced. Args: input_str (str): The input string containing '(', ')', '[', ']', '{', '}'. Returns: bool: True if the string is balanced, False otherwise. >>> is_balanced(\\"([{}])()[]\\") True >>> is_balanced(\\"([{})]\\") False","solution":"def is_balanced(input_str): Checks whether the input string of parentheses, brackets, and curly braces is balanced. Args: input_str (str): The input string containing '(', ')', '[', ']', '{', '}'. Returns: bool: True if the string is balanced, False otherwise. stack = [] opening = set('([{') matching = {')': '(', ']': '[', '}': '{'} for char in input_str: if char in opening: stack.append(char) elif char in matching: if not stack or stack.pop() != matching[char]: return False return not stack"},{"question":"from typing import List def get_pentagonal_numbers(n: int) -> List[int]: Returns a list of the first n pentagonal numbers. The pentagonal number for a given positive integer k is calculated using the formula P(k) = k*(3k-1)/2. Parameters: n: int - the count of pentagonal numbers to generate; must be a positive integer Returns: list of n pentagonal numbers, or an empty list if n is not a positive integer. Examples: >>> get_pentagonal_numbers(1) [1] >>> get_pentagonal_numbers(2) [1, 5] >>> get_pentagonal_numbers(0) [] >>> get_pentagonal_numbers(-3) [] >>> get_pentagonal_numbers(\\"three\\") []","solution":"def get_pentagonal_numbers(n): Returns a list of the first n pentagonal numbers. Parameters: n: int - the count of pentagonal numbers to generate; must be a positive integer Returns: list of n pentagonal numbers, or an empty list if n is not a positive integer. if not isinstance(n, int) or n <= 0: return [] pentagonal_numbers = [(k * (3 * k - 1)) // 2 for k in range(1, n + 1)] return pentagonal_numbers"},{"question":"from typing import List from collections import deque def min_distance_to_empty_space(grid: List[List[int]]) -> int: You are given a 2D grid \`grid\` representing a city where \`blockages\` are marked with \`-1\` and empty spaces are marked with \`0\`. Some buildings are placed in the city, each represented by a non-zero positive integer \`b\`, indicating the height of the building. Your task is to determine the distance from the building with the maximum height to the nearest empty space. The distance is defined as the shortest number of moves required to reach an empty space from the building. You can move up, down, left, or right (4 directions). Return the minimum distance to the nearest empty space from the building with the highest height. If there are multiple buildings with the same maximum height, return the minimum distance among them. If there are no empty spaces, return \`-1\`. >>> min_distance_to_empty_space([[0, 2, -1], [3, 0, 1], [2, -1, 4]]) 2 >>> min_distance_to_empty_space([[-1, -1], [-1, -1]]) -1 >>> min_distance_to_empty_space([[0, 3, 0], [2, 4, 1], [0, 0, 4]]) 1 def test_example_1(): grid = [[0, 2, -1], [3, 0, 1], [2, -1, 4]] assert min_distance_to_empty_space(grid) == 2 def test_example_2(): grid = [[-1, -1], [-1, -1]] assert min_distance_to_empty_space(grid) == -1 def test_example_3(): grid = [[0, 3, 0], [2, 4, 1], [0, 0, 4]] assert min_distance_to_empty_space(grid) == 1 def test_edge_case_empty(): grid = [] assert min_distance_to_empty_space(grid) == -1 def test_edge_case_no_buildings(): grid = [[0, 0], [0, 0]] assert min_distance_to_empty_space(grid) == -1 def test_one_building(): grid = [[0, 1000], [0, 0]] assert min_distance_to_empty_space(grid) == 1 def test_multiple_same_height_buildings(): grid = [[4, 3, 2], [0, -1, 4], [2, -1, 3]] assert min_distance_to_empty_space(grid) == 1 def test_no_empty_spaces(): grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] assert min_distance_to_empty_space(grid) == -1 def test_all_blockages(): grid = [[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]] assert min_distance_to_empty_space(grid) == -1","solution":"from collections import deque def bfs(grid, start): m, n = len(grid), len(grid[0]) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] visited = [[False] * n for _ in range(m)] queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited[start[0]][start[1]] = True while queue: x, y, dist = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: if grid[nx][ny] == 0: return dist + 1 visited[nx][ny] = True queue.append((nx, ny, dist + 1)) return float('inf') def min_distance_to_empty_space(grid): if not grid or not grid[0]: return -1 max_height = -1 buildings = [] # Identify the max height and its positions for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] > 0: if grid[i][j] > max_height: max_height = grid[i][j] buildings = [(i, j)] elif grid[i][j] == max_height: buildings.append((i, j)) if max_height == -1: return -1 min_distance = float('inf') for building in buildings: distance = bfs(grid, building) if distance < min_distance: min_distance = distance return min_distance if min_distance != float('inf') else -1"},{"question":"def find_max_concurrent_users(logs): Find the maximum number of concurrent users logged into the system at any point in time. >>> logs = [ ... \\"2023-10-01 08:00:00 user1 LOGIN\\", ... \\"2023-10-01 08:10:00 user2 LOGIN\\", ... \\"2023-10-01 08:15:00 user1 LOGOUT\\", ... \\"2023-10-01 08:20:00 user3 LOGIN\\", ... \\"2023-10-01 08:30:00 user2 LOGOUT\\", ... \\"2023-10-01 08:40:00 user3 LOGOUT\\" ... ] >>> find_max_concurrent_users(logs) 2 pass def test_find_max_concurrent_users_example(): logs = [ \\"2023-10-01 08:00:00 user1 LOGIN\\", \\"2023-10-01 08:10:00 user2 LOGIN\\", \\"2023-10-01 08:15:00 user1 LOGOUT\\", \\"2023-10-01 08:20:00 user3 LOGIN\\", \\"2023-10-01 08:30:00 user2 LOGOUT\\", \\"2023-10-01 08:40:00 user3 LOGOUT\\" ] assert find_max_concurrent_users(logs) == 2 def test_find_max_concurrent_users_single_user(): logs = [ \\"2023-10-01 08:00:00 user1 LOGIN\\", \\"2023-10-01 08:05:00 user1 LOGOUT\\" ] assert find_max_concurrent_users(logs) == 1 def test_find_max_concurrent_users_no_logins(): logs = [] assert find_max_concurrent_users(logs) == 0 def test_find_max_concurrent_users_overlap_logins(): logs = [ \\"2023-10-01 08:00:00 user1 LOGIN\\", \\"2023-10-01 08:05:00 user2 LOGIN\\", \\"2023-10-01 08:10:00 user3 LOGIN\\", \\"2023-10-01 08:15:00 user1 LOGOUT\\", \\"2023-10-01 08:20:00 user2 LOGOUT\\", \\"2023-10-01 08:25:00 user3 LOGOUT\\" ] assert find_max_concurrent_users(logs) == 3 def test_find_max_concurrent_users_empty_intervals(): logs = [ \\"2023-10-01 08:00:00 user1 LOGIN\\", \\"2023-10-01 08:05:00 user1 LOGOUT\\", \\"2023-10-01 08:10:00 user2 LOGIN\\", \\"2023-10-01 08:15:00 user2 LOGOUT\\" ] assert find_max_concurrent_users(logs) == 1","solution":"def find_max_concurrent_users(logs): events = [] for log in logs: parts = log.split() timestamp = parts[0] + \\" \\" + parts[1] user = parts[2] action = parts[3] events.append((timestamp, action)) events.sort() # Sort events by timestamp max_users = 0 current_users = 0 for event in events: if event[1] == \\"LOGIN\\": current_users += 1 if current_users > max_users: max_users = current_users else: current_users -= 1 return max_users"},{"question":"class MedianFinder: A data structure that supports insertion, deletion, and finding the median of a sequence of integers. def __init__(self): Initialize the MedianFinder data structure. pass def insert(self, num: int): Inserts an integer into the data structure. pass def delete(self, num: int) -> bool: Deletes an integer from the data structure if it exists. Returns True if the deletion was successful, otherwise False. pass def find_median(self) -> float: Finds the median of the current sequence. pass import pytest def test_insert_and_find_median(): mf = MedianFinder() mf.insert(1) assert mf.find_median() == 1 mf.insert(2) assert mf.find_median() == 1.5 mf.insert(3) assert mf.find_median() == 2 mf.insert(4) assert mf.find_median() == 2.5 def test_delete_and_find_median(): mf = MedianFinder() mf.insert(1) mf.insert(2) mf.insert(3) mf.insert(4) mf.delete(3) assert mf.find_median() == 2 mf.delete(1) assert mf.find_median() == 3 def test_delete_nonexistent(): mf = MedianFinder() mf.insert(1) mf.insert(2) assert not mf.delete(3) assert mf.find_median() == 1.5 def test_median_of_empty(): mf = MedianFinder() with pytest.raises(ValueError): mf.find_median() def test_mixed_operations(): mf = MedianFinder() mf.insert(1) mf.insert(3) mf.insert(2) assert mf.find_median() == 2 mf.delete(2) assert mf.find_median() == 2 mf.delete(1) assert mf.find_median() == 3","solution":"import bisect class MedianFinder: def __init__(self): Initialize the MedianFinder data structure. self.nums = [] def insert(self, num: int): Inserts an integer into the data structure. bisect.insort(self.nums, num) def delete(self, num: int) -> bool: Deletes an integer from the data structure if it exists. Returns True if the deletion was successful, otherwise False. index = bisect.bisect_left(self.nums, num) if index < len(self.nums) and self.nums[index] == num: self.nums.pop(index) return True return False def find_median(self) -> float: Finds the median of the current sequence. n = len(self.nums) if n == 0: raise ValueError(\\"Median of an empty list is undefined.\\") if n % 2 == 1: return self.nums[n // 2] else: return (self.nums[n // 2 - 1] + self.nums[n // 2]) / 2"},{"question":"def find_duplicates(input_list: List[int]) -> List[int]: Returns a list of integers that appear more than once in the input list while maintaining the original order of their first occurrence. >>> find_duplicates([4, 5, 6, 4, 8, 6, 7, 9]) [4, 6] >>> find_duplicates([1, 2, 3, 4, 5]) [] >>> find_duplicates([]) [] >>> find_duplicates([1]) [] >>> find_duplicates([1, 1, 1, 1]) [1] >>> find_duplicates([1, \\"two\\", 3]) Traceback (most recent call last): ... ValueError: All elements of the input list must be integers >>> find_duplicates([2, 3, 4, 2, 5, 6, 3]) [2, 3]","solution":"def find_duplicates(input_list): Returns a list of integers that appear more than once in the input list while maintaining the original order of their first occurrence. if not all(isinstance(x, int) for x in input_list): raise ValueError(\\"All elements of the input list must be integers\\") seen = set() duplicates = set() result = [] for num in input_list: if num in seen: if num not in duplicates: result.append(num) duplicates.add(num) else: seen.add(num) return result"},{"question":"def find_pairs_with_sum_ten(numbers: List[int]) -> List[Tuple[int, int]]: Returns a list of unique pairs of numbers from the input list whose sum is 10. >>> find_pairs_with_sum_ten([]) == [] >>> find_pairs_with_sum_ten([1, 2, 3, 4]) == [] >>> find_pairs_with_sum_ten([1, 9]) == [(1, 9)] >>> find_pairs_with_sum_ten([1, 9, 2, 8, 3, 7]) == [(1, 9), (2, 8), (3, 7)] >>> find_pairs_with_sum_ten([1, 9, 1, 9, 2, 8, 2, 8]) == [(1, 9), (2, 8)] >>> find_pairs_with_sum_ten([5, 5, 5, 5, 2, 8]) == [(5, 5), (2, 8)]","solution":"def find_pairs_with_sum_ten(numbers): Returns a list of unique pairs of numbers from the input list whose sum is 10. pairs = [] seen = set() added_pairs = set() for num in numbers: target = 10 - num if target in seen: pair = tuple(sorted((num, target))) if pair not in added_pairs: pairs.append(pair) added_pairs.add(pair) seen.add(num) return pairs"},{"question":"from typing import List def F(n: int) -> List[int]: Returns an array where the ith element is the count of positive divisors of i (1-indexed). >>> F(1) == [1] >>> F(2) == [1, 2] >>> F(3) == [1, 2, 2] >>> F(4) == [1, 2, 2, 3] >>> F(6) == [1, 2, 2, 3, 2, 4] def sum_F(m: int) -> int: Returns the sum of the elements in the array returned by F(m). >>> sum_F(1) == 1 >>> sum_F(2) == 3 # 1 + 2 >>> sum_F(3) == 5 # 1 + 2 + 2 >>> sum_F(4) == 8 # 1 + 2 + 2 + 3 >>> sum_F(6) == 14 # 1 + 2 + 2 + 3 + 2 + 4","solution":"def F(n): Returns an array where the ith element is the count of positive divisors of i (1-indexed). divisors_count = [0] * (n + 1) # Count divisors using a modified Sieve of Eratosthenes approach for i in range(1, n + 1): for j in range(i, n + 1, i): divisors_count[j] += 1 # Remove the 0th index to make the list 1-indexed return divisors_count[1:] def sum_F(m): Returns the sum of the elements in the array returned by F(m). return sum(F(m)) # Calculate the sum for m = 1000000 result = sum_F(1000000) result"},{"question":"from typing import List from collections import defaultdict def group_anagrams(words: List[str]) -> List[List[str]]: Groups a list of words into lists of anagrams. >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) == [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] >>> group_anagrams([\\"apple\\", \\"banana\\", \\"cherry\\"]) == [[\\"apple\\"], [\\"banana\\"], [\\"cherry\\"]] >>> group_anagrams([]) == [] >>> group_anagrams([\\"a\\", \\"a\\", \\"b\\", \\"b\\", \\"a\\"]) == [[\\"a\\", \\"a\\", \\"a\\"], [\\"b\\", \\"b\\"]] >>> group_anagrams([\\"a\\", \\"A\\", \\"b\\", \\"B\\"]) == [[\\"a\\"], [\\"A\\"], [\\"b\\"], [\\"B\\"]]","solution":"from collections import defaultdict def group_anagrams(words): Groups a list of words into lists of anagrams. anagrams = defaultdict(list) for word in words: # Sort the word and use the sorted version as the key sorted_word = ''.join(sorted(word)) anagrams[sorted_word].append(word) # Return the values (lists of anagram groups) as a list of lists return list(anagrams.values())"},{"question":"def is_palindrome(s: str) -> bool: Return True if the given string is a valid palindrome, considering only alphanumeric characters and ignoring case. Custom function to check alphanumeric characters should be used. :param s: Input string to check :return: True if the string is a palindrome, False otherwise Examples: >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"race a car\\") False # Erroneous code example: def is_palindrome_incorrect(s: str) -> bool: filtered_string = ''.join(c.lower() for c in s if c.isalnum()) return filtered_string == filtered_string[::-1] # Violates the rule of not using built-in reverse string functions # Unit tests def test_palindrome_valid(): assert is_palindrome(\\"A man, a plan, a canal: Panama\\") == True def test_palindrome_invalid(): assert is_palindrome(\\"race a car\\") == False def test_palindrome_empty_string(): assert is_palindrome(\\"\\") == True def test_palindrome_non_alphanumeric(): assert is_palindrome(\\".,!@#\\") == True def test_palindrome_mixed_cases(): assert is_palindrome(\\"Able was I Ere I saw Elba\\") == True def test_palindrome_numbers(): assert is_palindrome(\\"12321\\") == True assert is_palindrome(\\"12345\\") == False","solution":"def is_palindrome(s: str) -> bool: Return True if the given string is a valid palindrome, considering only alphanumeric characters and ignoring case. :param s: Input string to check :return: True if the string is a palindrome, False otherwise Examples: >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"race a car\\") False def is_alphanumeric(c): return (ord('A') <= ord(c) <= ord('Z') or ord('a') <= ord(c) <= ord('z') or ord('0') <= ord(c) <= ord('9')) filtered_chars = [c.lower() for c in s if is_alphanumeric(c)] length = len(filtered_chars) for i in range(length // 2): if filtered_chars[i] != filtered_chars[length - 1 - i]: return False return True # Erroneous code example: def is_palindrome_incorrect(s: str) -> bool: filtered_string = ''.join(c.lower() for c in s if c.isalnum()) return filtered_string == filtered_string[::-1] # Violates the rule of not using built-in reverse string functions"},{"question":"def longest_palindrome_substring(s: str) -> str: Suppose you have a string 's' comprised of only lowercase alphabets. Your task is to write a function that finds and returns the longest palindromic substring in the given string 's'. A palindromic string reads the same forwards and backwards. For instance: >>> longest_palindrome_substring(\\"babad\\") \\"bab\\" or \\"aba\\" >>> longest_palindrome_substring(\\"cbbd\\") \\"bb\\" >>> longest_palindrome_substring(\\"a\\") \\"a\\" >>> longest_palindrome_substring(\\"ac\\") \\"a\\" or \\"c\\" The function should return just one of the longest palindromic substrings if there are multiple with the same length. from typing import List def test_longest_palindrome_substring(): assert longest_palindrome_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] assert longest_palindrome_substring(\\"cbbd\\") == \\"bb\\" assert longest_palindrome_substring(\\"a\\") == \\"a\\" assert longest_palindrome_substring(\\"ac\\") in [\\"a\\", \\"c\\"] def test_longest_palindrome_substring_edge_cases(): assert longest_palindrome_substring(\\"\\") == \\"\\" assert longest_palindrome_substring(\\"aa\\") == \\"aa\\" assert longest_palindrome_substring(\\"abcda\\") == \\"a\\" assert longest_palindrome_substring(\\"abccba\\") == \\"abccba\\" def test_longest_palindrome_substring_with_repeats(): assert longest_palindrome_substring(\\"aaaa\\") == \\"aaaa\\" assert longest_palindrome_substring(\\"aaaabaaa\\") == \\"aaabaaa\\" assert longest_palindrome_substring(\\"abbaabba\\") == \\"abbaabba\\"","solution":"def longest_palindrome_substring(s): if not s: return \\"\\" n = len(s) start, max_len = 0, 1 for i in range(1, n): odd = s[i - max_len - 1:i + 1] # Palindrome with odd length even = s[i - max_len:i + 1] # Palindrome with even length if i - max_len - 1 >= 0 and odd == odd[::-1]: start = i - max_len - 1 max_len += 2 elif even == even[::-1]: start = i - max_len max_len += 1 return s[start:start + max_len]"},{"question":"def replace_characters(string: str, replacements: dict) -> str: Implement a function that takes two inputs, a string and a dictionary where keys are characters and values are their respective replacement characters shown as strings. The function should replace all occurrences of the specified characters in the input string with their corresponding replacement characters from the dictionary. If a character in the input string is not present in the dictionary, it should remain unchanged. Ensure the input string is processed exactly once in linear time. Example: >>> replace_characters(\\"hello world\\", {'h': 'j', 'e': '3', 'o': '0', 'r': '2'}) == \\"j3ll0 w02ld\\" >>> replace_characters(\\"banana\\", {'b': 'p', 'a': 'u', 'n': 'm'}) == \\"pumumu\\" >>> replace_characters(\\"abracadabra\\", {'a': '@', 'b': '8'}) == \\"@8r@c@d@8r@\\" >>> replace_characters(\\"!abcd?\\", {'a': '1', 'b': '2', 'c': '3', 'd': '4'}) == \\"!1234?\\" :param string: The input string to process. :param replacements: A dictionary where keys are characters to be replaced and values are their replacements. :return: A new string with the replacements applied.","solution":"def replace_characters(string, replacements): Replace all occurrences of specified characters in the input string with their corresponding replacement characters from the dictionary. :param string: The input string to process :param replacements: A dictionary where keys are characters to be replaced and values are their replacements :return: A new string with the replacements applied result = [] for char in string: if char in replacements: result.append(replacements[char]) else: result.append(char) return ''.join(result)"},{"question":"def balancedBrackets(s: str) -> bool: This function checks if the given string s with various types of brackets ('{', '}', '(', ')', '[', ']') is properly balanced. Arguments: s -- input string containing brackets Returns: bool -- True if the string is balanced, False otherwise >>> balancedBrackets(\\"()\\") == True >>> balancedBrackets(\\"[]\\") == True >>> balancedBrackets(\\"{}\\") == True >>> balancedBrackets(\\"()[]{}\\") == True >>> balancedBrackets(\\"{[()]}\\") == True >>> balancedBrackets(\\"([{}])\\") == True >>> balancedBrackets(\\"(]\\") == False >>> balancedBrackets(\\"([)]\\") == False >>> balancedBrackets(\\"{}[\\") == False >>> balancedBrackets(\\"{[}]\\") == False >>> balancedBrackets(\\"(\\") == False >>> balancedBrackets(\\"]\\") == False >>> balancedBrackets(\\"\\") == True","solution":"def balancedBrackets(s: str): This function checks if the given string s with various types of brackets ('{', '}', '(', ')', '[', ']') is properly balanced. stack = [] opening_brackets = {'{', '(', '['} closing_brackets = {'}': '{', ')': '(', ']': '['} for char in s: if char in opening_brackets: stack.append(char) elif char in closing_brackets: if not stack or stack.pop() != closing_brackets[char]: return False return not stack"},{"question":"def string_analysis(input_str: str) -> dict: Analyzes the input string and returns a dictionary with various details: 1. The original string in all uppercase letters. 2. The original string in all lowercase letters. 3. The length of the original string. 4. The count of each vowel (a, e, i, o, u) in the original string. >>> string_analysis(\\"Hello World\\") {'uppercase': 'HELLO WORLD', 'lowercase': 'hello world', 'length': 11, 'vowel_count': {'a': 0, 'e': 1, 'i': 0, 'o': 2, 'u': 0}} >>> string_analysis(\\"\\") {'uppercase': '', 'lowercase': '', 'length': 0, 'vowel_count': {'a': 0, 'e': 0, 'i': 0, 'o': 0, 'u': 0}} >>> string_analysis(\\"bcdfgh\\") {'uppercase': 'BCDFGH', 'lowercase': 'bcdfgh', 'length': 6, 'vowel_count': {'a': 0, 'e': 0, 'i': 0, 'o': 0, 'u': 0}} >>> string_analysis(\\"aeiou\\") {'uppercase': 'AEIOU', 'lowercase': 'aeiou', 'length': 5, 'vowel_count': {'a': 1, 'e': 1, 'i': 1, 'o': 1, 'u': 1}} >>> string_analysis(\\"AeiOu\\") {'uppercase': 'AEIOU', 'lowercase': 'aeiou', 'length': 5, 'vowel_count': {'a': 1, 'e': 1, 'i': 1, 'o': 1, 'u': 1}}","solution":"def string_analysis(input_str): Analyzes the input string and returns a dictionary with various details: 1. The original string in all uppercase letters. 2. The original string in all lowercase letters. 3. The length of the original string. 4. The count of each vowel (a, e, i, o, u) in the original string. Parameters: input_str (str): The input string to analyze. Returns: dict: A dictionary with the analysis details. vowels = 'aeiou' vowel_count = {vowel: input_str.lower().count(vowel) for vowel in vowels} return { \\"uppercase\\": input_str.upper(), \\"lowercase\\": input_str.lower(), \\"length\\": len(input_str), \\"vowel_count\\": vowel_count }"},{"question":"class Server: def __init__(self, id, capacity): self.id = id self.capacity = capacity self.current_load = 0 def is_overloaded(self): Check if the server is overloaded. Returns: bool: True if overloaded, else False. pass def handle_request(self, load): Handle a new request by adding to the current load. Args: load (int): Amount of load to add. pass def release_load(self, load): Release some load from the server. Args: load (int): Amount of load to release. pass class LoadBalancer: def __init__(self, servers): self.servers = servers self.session_map = {} def detect_overload(self): Detect overloaded servers. Returns: list: List of overloaded servers. pass def distribute_request(self, request, session_id): Distribute a new request to the appropriate server. Args: request (Request): The incoming request. session_id (str): The session ID of the request. Returns: Server: The server handling the request. pass def redistribute_load(self): Redistribute the load among servers to prevent overload. pass def ramp_down_servers(self): Ramp down underutilized servers by removing them from the pool. pass class Request: def __init__(self, load): self.load = load # Unit Tests from solution import Server, LoadBalancer, Request def test_server_overload_detection(): server = Server(id=1, capacity=100) server.handle_request(120) assert server.is_overloaded() == True def test_load_balancer_distribute_request(): server1 = Server(id=1, capacity=100) server2 = Server(id=2, capacity=100) lb = LoadBalancer([server1, server2]) request1 = Request(load=20) session_id1 = 'session1' selected_server = lb.distribute_request(request1, session_id1) assert selected_server.id == 1 or selected_server.id == 2 assert selected_server.current_load == 20 def test_load_balancer_redistribute_load(): server1 = Server(id=1, capacity=100) server2 = Server(id=2, capacity=100) lb = LoadBalancer([server1, server2]) server1.handle_request(120) lb.redistribute_load() assert server1.current_load == 100 assert server2.current_load == 20 def test_load_balancer_ramp_down_servers(): server1 = Server(id=1, capacity=100) server2 = Server(id=2, capacity=100) server3 = Server(id=3, capacity=100) lb = LoadBalancer([server1, server2, server3]) server1.handle_request(100) server2.handle_request(50) lb.ramp_down_servers() assert len(lb.servers) == 2 assert lb.servers[0].id in [1, 2] assert lb.servers[1].id in [1, 2]","solution":"class Server: def __init__(self, id, capacity): self.id = id self.capacity = capacity self.current_load = 0 def is_overloaded(self): return self.current_load > self.capacity def handle_request(self, load): self.current_load += load def release_load(self, load): self.current_load -= load if self.current_load < 0: self.current_load = 0 class LoadBalancer: def __init__(self, servers): self.servers = servers self.session_map = {} def detect_overload(self): return [server for server in self.servers if server.is_overloaded()] def distribute_request(self, request, session_id): if session_id in self.session_map: server = self.session_map[session_id] else: server = min(self.servers, key=lambda x: x.current_load) self.session_map[session_id] = server server.handle_request(request.load) return server def redistribute_load(self): overloaded_servers = self.detect_overload() for server in overloaded_servers: extra_load = server.current_load - server.capacity underloaded_servers = sorted(self.servers, key=lambda x: x.current_load) while extra_load > 0 and underloaded_servers: underloaded_server = underloaded_servers.pop(0) if underloaded_server.current_load + extra_load <= underloaded_server.capacity: underloaded_server.handle_request(extra_load) server.release_load(extra_load) extra_load = 0 else: transfer_load = underloaded_server.capacity - underloaded_server.current_load underloaded_server.handle_request(transfer_load) server.release_load(transfer_load) extra_load -= transfer_load def ramp_down_servers(self): underutilized_servers = [server for server in self.servers if server.current_load == 0] for server in underutilized_servers: self.servers.remove(server) class Request: def __init__(self, load): self.load = load"},{"question":"def longest_non_decreasing_subarray_length(arr: List[int]) -> int: Finds the length of the longest contiguous subarray with non-decreasing order and no repeated elements. >>> longest_non_decreasing_subarray_length([1, 3, 5, 4, 2, 3, 4, 5]) 4 >>> longest_non_decreasing_subarray_length([10, 12, 14, 12, 11, 10]) 3","solution":"def longest_non_decreasing_subarray_length(arr): Finds the length of the longest contiguous subarray with non-decreasing order and no repeated elements. n = len(arr) if n == 0: return 0 max_len = 1 current_len = 1 seen = set([arr[0]]) for i in range(1, n): if arr[i] > arr[i - 1] and arr[i] not in seen: current_len += 1 seen.add(arr[i]) else: seen = set([arr[i]]) current_len = 1 max_len = max(max_len, current_len) return max_len"},{"question":"def even_digit_numbers(nums: List[int]) -> List[int]: Returns a list of integers from the input list that have an even number of digits. >>> even_digit_numbers([12, 345, 2, 6, 7896]) [12, 7896] >>> even_digit_numbers([1234, 5678, 90]) [1234, 5678, 90] >>> even_digit_numbers([1, 22, 333, 4444, 55555]) [22, 4444] >>> even_digit_numbers([]) [] >>> even_digit_numbers([111, 1111, 11111, 111111]) [1111, 111111] >>> even_digit_numbers([-12, 345, -2, 6, -7896]) [-12, -7896] >>> even_digit_numbers([-1234, 5678, -90]) [-1234, 5678, -90] >>> even_digit_numbers([-1, -22, 333, -4444, 55555]) [-22, -4444]","solution":"def even_digit_numbers(nums): Returns a list of integers from the input list that have an even number of digits. Args: nums (list of int): A list of integers. Returns: list of int: A list containing integers with an even number of digits. return [num for num in nums if len(str(abs(num))) % 2 == 0]"},{"question":"from typing import List, Tuple, Optional def calculate_average_score(grades: List[Tuple[str, str, int]], student_name: str) -> Optional[float]: Calculate the average score for the given student from the provided list of grades. :param grades: List of tuples with (student_name, subject, score) :param student_name: The name of the student for whom the average score is to be calculated :return: The average score of the student or None if the student is not in the list >>> grades = [ >>> (\\"Alice\\", \\"Math\\", 90), >>> (\\"Alice\\", \\"Science\\", 85), >>> (\\"Bob\\", \\"Math\\", 75), >>> (\\"Bob\\", \\"Science\\", 80) >>> ] >>> calculate_average_score(grades, \\"Alice\\") 87.5 >>> calculate_average_score(grades, \\"Charlie\\") None >>> grades = [(\\"Alice\\", \\"Math\\", 90)] >>> calculate_average_score(grades, \\"Alice\\") 90.0 >>> grades = [] >>> calculate_average_score(grades, \\"Alice\\") None >>> grades = [ >>> (\\"Alice\\", \\"Math\\", 80), >>> (\\"Alice\\", \\"Science\\", 80), >>> (\\"Alice\\", \\"History\\", 80) >>> ] >>> calculate_average_score(grades, \\"Alice\\") 80.0","solution":"from typing import List, Tuple, Optional def calculate_average_score(grades: List[Tuple[str, str, int]], student_name: str) -> Optional[float]: Calculate the average score for the given student from the provided list of grades. :param grades: List of tuples with (student_name, subject, score) :param student_name: The name of the student for whom the average score is to be calculated :return: The average score of the student or None if the student is not in the list total_score = 0 count = 0 for name, subject, score in grades: if name == student_name: total_score += score count += 1 if count == 0: return None return total_score / count"},{"question":"def find_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: Returns a list of unique pairs from nums that add up to the target. Each pair is sorted and appears only once. >>> find_pairs([2, 4, 3, 5, 7], 7) == [(2, 5), (3, 4)] >>> find_pairs([1, 2, 3], 6) == [] >>> find_pairs([1, 2, 3, 4, 5], 9) == [(4, 5)] >>> find_pairs([1, 3, 2, 2, 4, 4], 6) == [(2, 4)] >>> find_pairs([1, 2, 3, 4, 3, 6, 5, 7, 8], 8) == [(1, 7), (2, 6), (3, 5)]","solution":"def find_pairs(nums, target): Returns a list of unique pairs from nums that add up to the target. Each pair is sorted and appears only once. seen = set() pairs = set() for num in nums: complement = target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return list(pairs)"},{"question":"from typing import List, Dict def summary_report(products: List[Dict[str, any]]) -> Dict[str, any]: Takes a list of dictionaries representing products and generates a summary report. :param products: List of dictionaries, each with keys 'name', 'price', and 'quantity'. :return: A dictionary containing the total number of products, total quantity, and total value. >>> summary_report([ ... { \\"name\\": \\"Product1\\", \\"price\\": 2.50, \\"quantity\\": 4 }, ... { \\"name\\": \\"Product2\\", \\"price\\": 5.00, \\"quantity\\": 2 }, ... { \\"name\\": \\"Product3\\", \\"price\\": 1.20, \\"quantity\\": 10 } ... ]) == {'total_products': 3, 'total_quantity': 16, 'total_value': 32.0} >>> summary_report([ ... { \\"name\\": \\"Product1\\", \\"price\\": 2.50, \\"quantity\\": 4 }, ... { \\"name\\": \\"Product2\\", \\"quantity\\": 2 }, # Missing 'price' ... { \\"name\\": \\"Product3\\", \\"price\\": 1.20, \\"quantity\\": 10 }, ... { \\"price\\": 5.00, \\"quantity\\": 3 }, # Missing 'name' ... { \\"name\\": \\"Product4\\", \\"price\\": 3.50 } # Missing 'quantity' ... ]) == {'total_products': 2, 'total_quantity': 14, 'total_value': 16.0} >>> summary_report([]) == {'total_products': 0, 'total_quantity': 0, 'total_value': 0.0} >>> summary_report([ ... { \\"name\\": \\"Product1\\", \\"price\\": 2.50, \\"quantity\\": 4 } ... ]) == {'total_products': 1, 'total_quantity': 4, 'total_value': 10.0}","solution":"def summary_report(products): Takes a list of dictionaries representing products and generates a summary report. :param products: List of dictionaries, each with keys 'name', 'price', and 'quantity'. :return: A dictionary containing the total number of products, total quantity, and total value. import logging logging.basicConfig(level=logging.WARNING) total_products = 0 total_quantity = 0 total_value = 0.0 for product in products: if not all(key in product for key in ['name', 'price', 'quantity']): logging.warning(f\\"Product {product} is missing one or more required keys.\\") continue total_products += 1 total_quantity += product['quantity'] total_value += product['price'] * product['quantity'] return { 'total_products': total_products, 'total_quantity': total_quantity, 'total_value': total_value }"},{"question":"import re from collections import Counter from typing import List def are_anagrams(str1: str, str2: str) -> bool: Given two strings, determine whether they are anagrams of each other or not. An anagram means rearranging the letters of one string to produce the other string, without considering case sensitivity and ignoring non-alphanumeric characters. Returns a boolean value: True if the strings are anagrams; otherwise, False. >>> are_anagrams(\\"Astronomer\\", \\"Moon starer\\") True >>> are_anagrams(\\"Hello, World!\\", \\"Lodger, Wholl!\\") False def test_anagrams(): assert are_anagrams(\\"Astronomer\\", \\"Moon starer\\") == True def test_not_anagrams(): assert are_anagrams(\\"Hello, World!\\", \\"Lodger, Wholl!\\") == False def test_anagrams_with_non_alphanumeric(): assert are_anagrams(\\"A man, a plan, a canal: Panama\\", \\"A plan, a man: a canal, panama\\") == True def test_empty_strings(): assert are_anagrams(\\"\\", \\"\\") == True def test_different_lengths(): assert are_anagrams(\\"abc\\", \\"abcd\\") == False def test_case_insensitivity(): assert are_anagrams(\\"Listen\\", \\"Silent\\") == True def test_identical_strings(): assert are_anagrams(\\"abcdef\\", \\"abcdef\\") == True def test_spaces_in_between(): assert are_anagrams(\\"an agram\\", \\"nagara m\\") == True def test_punctuation(): assert are_anagrams(\\"The eyes!\\", \\"They see.\\") == True","solution":"import re from collections import Counter def are_anagrams(str1, str2): Returns True if str1 and str2 are anagrams of each other, ignoring cases and non-alphanumeric characters. Otherwise, returns False. # Remove non-alphanumeric characters and convert to lower case str1_clean = re.sub(r'[^a-zA-Z0-9]', '', str1).lower() str2_clean = re.sub(r'[^a-zA-Z0-9]', '', str2).lower() # If lengths differ, they cannot be anagrams if len(str1_clean) != len(str2_clean): return False # Count frequencies of characters return Counter(str1_clean) == Counter(str2_clean)"},{"question":"def max_product_of_three(arr): Returns the largest product of any three integers in the array. >>> max_product_of_three([-10, -10, 5, 2]) 500 >>> max_product_of_three([1, 2, 3, 4]) 24 >>> max_product_of_three([-5, -4, -3, -2, -1]) -6 >>> max_product_of_three([1, 2, 3, 4, 5]) 60 >>> max_product_of_three([-10, -10, 1, 3, 2]) 300 >>> max_product_of_three([2, 3, 5]) 30 >>> max_product_of_three([1000, 500, -1000, -500, 1, 2, 3]) 500000000","solution":"def max_product_of_three(arr): Returns the largest product of any three integers in the array. arr.sort() # The maximum product can be achieved either by # - The product of the largest three positive numbers, or # - The product of the two most negative numbers (which can contribute positively because minus times minus is plus) and the largest positive number max1 = arr[-1] * arr[-2] * arr[-3] max2 = arr[0] * arr[1] * arr[-1] return max(max1, max2)"},{"question":"def calculate_trapped_water(heights): Calculate the maximum amount of water that can be trapped between the terrains. :param heights: List of non-negative integers representing the heights of terrain. :return: Maximum amount of water that can be trapped. >>> calculate_trapped_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> calculate_trapped_water([4, 2, 0, 3, 2, 5]) 9 >>> calculate_trapped_water([3, 1, 2]) 1 >>> calculate_trapped_water([1, 2, 3, 4, 5]) 0 >>> calculate_trapped_water([5, 4, 3, 2, 1]) 0","solution":"def calculate_trapped_water(heights): Calculate the maximum amount of water that can be trapped between the terrains. :param heights: List of non-negative integers representing the heights of terrain. :return: Maximum amount of water that can be trapped. if not heights or len(heights) < 3: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) trapped_water = 0 for i in range(1, n - 1): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"def sum_word_numbers(word_list: List[str]) -> Dict[str, int]: Takes a list of strings, each containing a word and a number separated by a space, and returns a dictionary with each unique word as the key and the sum of the associated numbers as the value. >>> sum_word_numbers(['apple 3', 'banana 5', 'apple 10', 'orange -3', 'banana 2', 'peach 6']) {'apple': 13, 'banana': 7, 'orange': -3, 'peach': 6} >>> sum_word_numbers(['apple 3', 'banana 5', 'apple 10', 'orange -3', 'apple xy', 'banana 2', 'peach 6']) {'apple': 13, 'banana': 7, 'orange': -3, 'peach': 6} >>> sum_word_numbers([]) {} >>> sum_word_numbers(['apple 3', 'banana', 'apple 10', 'orange -3', 'banana 2', 'peach 6']) {'apple': 13, 'orange': -3, 'banana': 2, 'peach': 6} >>> sum_word_numbers(['apple 3', 'banana five', 'apple 10', 'orange -3', 'banana 2', 'peach 6']) {'apple': 13, 'orange': -3, 'banana': 2, 'peach': 6}","solution":"def sum_word_numbers(word_list): Takes a list of strings, each containing a word and a number separated by a space, and returns a dictionary with each unique word as the key and the sum of the associated numbers as the value. result = {} for item in word_list: parts = item.split() if len(parts) != 2: continue word, number_str = parts try: number = int(number_str) except ValueError: number = 0 if word in result: result[word] += number else: result[word] = number return result"},{"question":"def reverse_words(input_str: str) -> str: Given a string consisting of lowercase letters and spaces, returns a new string where the order of the words is reversed, but the letters within each word remain in the original order. >>> reverse_words(\\"hello\\") == \\"hello\\" >>> reverse_words(\\"the sky is blue\\") == \\"blue is sky the\\" >>> reverse_words(\\" the sky is blue \\") == \\"blue is sky the\\" >>> reverse_words(\\"\\") == \\"\\" >>> reverse_words(\\" \\") == \\"\\"","solution":"def reverse_words(input_str): Given a string consisting of lowercase letters and spaces, returns a new string where the order of the words is reversed, but the letters within each word remain in the original order. words = [] word = '' # Iterate over each character in the input string for char in input_str: if char == ' ': if word: words.append(word) word = '' else: word += char # Append the last word if there is one if word: words.append(word) # Reverse the order of the words reversed_words = [] for i in range(len(words) - 1, -1, -1): reversed_words.append(words[i]) # Join the reversed words with a single space result = ' '.join(reversed_words) return result"},{"question":"def can_be_palindrome(s: str) -> bool: Return whether the string can be transformed into a palindrome by removing at most one character. The function should account for: - strings containing only lowercase letters. - strings containing a mix of uppercase and lowercase letters. >>> can_be_palindrome(\\"RacecaR\\") == True >>> can_be_palindrome(\\"adbba\\") == True >>> can_be_palindrome(\\"level\\") == True >>> can_be_palindrome(\\"abcdef\\") == False >>> can_be_palindrome(\\"\\") == True >>> can_be_palindrome(\\"a\\") == True >>> can_be_palindrome(\\"abca\\") == True >>> can_be_palindrome(\\"abc\\") == False >>> can_be_palindrome(\\"AbcBa\\") == True >>> can_be_palindrome(\\"AbcB\\") == True >>> can_be_palindrome(\\"Abcd\\") == False","solution":"def can_be_palindrome(s: str) -> bool: Return whether the string can be transformed into a palindrome by removing at most one character. The function should account for: - strings containing only lowercase letters. - strings containing a mix of uppercase and lowercase letters. def is_palindrome_range(i, j): return all(s[k] == s[j - k + i] for k in range(i, j)) s = s.lower() left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: return is_palindrome_range(left + 1, right) or is_palindrome_range(left, right - 1) left += 1 right -= 1 return True"},{"question":"def count_target_word(string: str, target: str) -> int: Counts how many times the target word appears in the given string. Parameters: string (str): The input string containing words separated by single spaces. target (str): The word to count in the input string. Returns: int: The count of target word in the input string. Examples: >>> count_target_word(\\"apple orange apple banana apple\\", \\"apple\\") 3 >>> count_target_word(\\"orange banana apple\\", \\"apple\\") 1 >>> count_target_word(\\"orange banana grape\\", \\"apple\\") 0 >>> count_target_word(\\"apple apple apple apple\\", \\"apple\\") 4 >>> count_target_word(\\"\\", \\"apple\\") 0 >>> count_target_word(\\"apple orange apple banana apple orange banana\\", \\"orange\\") 2 >>> count_target_word(\\"Apple orange apple\\", \\"apple\\") # Assuming case sensitivity 1","solution":"def count_target_word(string, target): Counts how many times the target word appears in the given string. Parameters: string (str): The input string containing words separated by single spaces. target (str): The word to count in the input string. Returns: int: The count of target word in the input string. words = string.split() count = words.count(target) return count"},{"question":"from typing import List, Dict, Any def group_by_key(data: List[Dict[str, Any]], key: str) -> Dict[str, List[Dict[str, Any]]]: Write a function that takes a list of dictionaries and returns a new dictionary. The new dictionary should have keys as unique values of the specified key from each dictionary in the list, and the values should be a list of dictionaries that share that key. Args: data (List[Dict[str, Any]]): A list of dictionaries. key (str): A key that all dictionaries contain. Returns: Dict[str, List[Dict[str, Any]]]: A dictionary grouped by the specified key. Example: >>> data = [ ... {\\"name\\": \\"Alice\\", \\"department\\": \\"Engineering\\", \\"age\\": 25}, ... {\\"name\\": \\"Bob\\", \\"department\\": \\"HR\\", \\"age\\": 30}, ... {\\"name\\": \\"Charlie\\", \\"department\\": \\"Engineering\\", \\"age\\": 29}, ... {\\"name\\": \\"David\\", \\"department\\": \\"Design\\", \\"age\\": 22}, ... {\\"name\\": \\"Eva\\", \\"department\\": \\"Design\\", \\"age\\": 27} ... ] >>> key = \\"department\\" >>> group_by_key(data, key) { \\"Engineering\\": [ {\\"name\\": \\"Alice\\", \\"department\\": \\"Engineering\\", \\"age\\": 25}, {\\"name\\": \\"Charlie\\", \\"department\\": \\"Engineering\\", \\"age\\": 29} ], \\"HR\\": [ {\\"name\\": \\"Bob\\", \\"department\\": \\"HR\\", \\"age\\": 30} ], \\"Design\\": [ {\\"name\\": \\"David\\", \\"department\\": \\"Design\\", \\"age\\": 22}, {\\"name\\": \\"Eva\\", \\"department\\": \\"Design\\", \\"age\\": 27} ] } Test Cases: def test_group_by_key_normal_case(): data = [ {\\"name\\": \\"Alice\\", \\"department\\": \\"Engineering\\", \\"age\\": 25}, {\\"name\\": \\"Bob\\", \\"department\\": \\"HR\\", \\"age\\": 30}, {\\"name\\": \\"Charlie\\", \\"department\\": \\"Engineering\\", \\"age\\": 29}, {\\"name\\": \\"David\\", \\"department\\": \\"Design\\", \\"age\\": 22}, {\\"name\\": \\"Eva\\", \\"department\\": \\"Design\\", \\"age\\": 27} ] key = \\"department\\" expected = { \\"Engineering\\": [ {\\"name\\": \\"Alice\\", \\"department\\": \\"Engineering\\", \\"age\\": 25}, {\\"name\\": \\"Charlie\\", \\"department\\": \\"Engineering\\", \\"age\\": 29} ], \\"HR\\": [ {\\"name\\": \\"Bob\\", \\"department\\": \\"HR\\", \\"age\\": 30} ], \\"Design\\": [ {\\"name\\": \\"David\\", \\"department\\": \\"Design\\", \\"age\\": 22}, {\\"name\\": \\"Eva\\", \\"department\\": \\"Design\\", \\"age\\": 27} ] } assert group_by_key(data, key) == expected def test_group_by_key_empty_list(): data = [] key = \\"department\\" expected = {} assert group_by_key(data, key) == expected def test_group_by_key_single_item(): data = [{\\"name\\": \\"Alice\\", \\"department\\": \\"Engineering\\", \\"age\\": 25}] key = \\"department\\" expected = { \\"Engineering\\": [ {\\"name\\": \\"Alice\\", \\"department\\": \\"Engineering\\", \\"age\\": 25} ] } assert group_by_key(data, key) == expected def test_group_by_key_multiple_keys_same_value(): data = [ {\\"name\\": \\"Alice\\", \\"department\\": \\"Engineering\\", \\"age\\": 25}, {\\"name\\": \\"Charlie\\", \\"department\\": \\"Engineering\\", \\"age\\": 29}, {\\"name\\": \\"David\\", \\"department\\": \\"Engineering\\", \\"age\\": 22} ] key = \\"department\\" expected = { \\"Engineering\\": [ {\\"name\\": \\"Alice\\", \\"department\\": \\"Engineering\\", \\"age\\": 25}, {\\"name\\": \\"Charlie\\", \\"department\\": \\"Engineering\\", \\"age\\": 29}, {\\"name\\": \\"David\\", \\"department\\": \\"Engineering\\", \\"age\\": 22} ] } assert group_by_key(data, key) == expected def test_group_by_key_with_non_string_values(): data = [ {\\"name\\": \\"Alice\\", \\"department\\": 1, \\"age\\": 25}, {\\"name\\": \\"Charlie\\", \\"department\\": 2, \\"age\\": 29}, {\\"name\\": \\"David\\", \\"department\\": 1, \\"age\\": 22} ] key = \\"department\\" expected = { 1: [ {\\"name\\": \\"Alice\\", \\"department\\": 1, \\"age\\": 25}, {\\"name\\": \\"David\\", \\"department\\": 1, \\"age\\": 22} ], 2: [ {\\"name\\": \\"Charlie\\", \\"department\\": 2, \\"age\\": 29} ] } assert group_by_key(data, key) == expected","solution":"from typing import List, Dict, Any def group_by_key(data: List[Dict[str, Any]], key: str) -> Dict[str, List[Dict[str, Any]]]: result = {} for item in data: key_value = item[key] if key_value not in result: result[key_value] = [] result[key_value].append(item) return result"},{"question":"def rearrange_string(s: str) -> str: Write a function that takes a string containing a mix of letters and digits and returns a new string with the letters sorted in ascending order, keeping the digits in their original positions within the string. Examples: >>> rearrange_string(\\"a3c2b1\\") \\"a3b2c1\\" >>> rearrange_string(\\"4d2c3b1a\\") \\"4a2b3c1d\\"","solution":"def rearrange_string(s: str) -> str: Returns a new string with the letters sorted in ascending order, keeping the digits in their original positions within the string. letters = sorted([char for char in s if char.isalpha()]) result = [] letter_index = 0 for char in s: if char.isalpha(): result.append(letters[letter_index]) letter_index += 1 else: result.append(char) return ''.join(result)"},{"question":"def astar_search(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]: Implement a simplified version of the A* search algorithm to find the shortest path in a 2D grid. The grid is represented as a list of lists, where 0 indicates a walkable cell and 1 indicates an obstacle. The function should return the path as a list of coordinates. If no path is found, return an empty list. :param grid: 2D list representing the grid :param start: Tuple representing the starting coordinates :param goal: Tuple representing the goal coordinates :return: List of tuples representing the path from start to goal >>> grid = [ ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ] >>> start = (0, 0) >>> goal = (2, 3) >>> astar_search(grid, start, goal) [(0, 0), (0, 1), (0, 2), (0, 3), (1, 3), (2, 3)] >>> grid = [ ... [0, 1, 1, 0], ... [0, 0, 1, 0], ... [1, 0, 0, 0] ... ] >>> start = (0, 0) >>> goal = (2, 3) >>> astar_search(grid, start, goal) [(0, 0), (1, 0), (1, 1), (2, 1), (2, 2), (2, 3)] >>> grid = [ ... [0, 1, 1, 0], ... [1, 1, 1, 0], ... [1, 0, 0, 0] ... ] >>> start = (0, 0) >>> goal = (2, 3) >>> astar_search(grid, start, goal) [] >>> grid = [ ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ] >>> start = (0, 0) >>> goal = (0, 0) >>> astar_search(grid, start, goal) [(0, 0)] >>> grid = [ ... [0, 0], ... [0, 1] ... ] >>> start = (0, 0) >>> goal = (1, 0) >>> astar_search(grid, start, goal) [(0, 0), (1, 0)]","solution":"import heapq def heuristic(a, b): return abs(a[0] - b[0]) + abs(a[1] - b[1]) def get_neighbors(node, grid): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] neighbors = [] for direction in directions: neighbor = (node[0] + direction[0], node[1] + direction[1]) if 0 <= neighbor[0] < len(grid) and 0 <= neighbor[1] < len(grid[0]) and grid[neighbor[0]][neighbor[1]] == 0: neighbors.append(neighbor) return neighbors def astar_search(grid, start, goal): open_list = [] heapq.heappush(open_list, (0, start)) came_from = {} g_score = {start: 0} f_score = {start: heuristic(start, goal)} while open_list: _, current = heapq.heappop(open_list) if current == goal: path = [] while current in came_from: path.append(current) current = came_from[current] path.append(start) path.reverse() return path for neighbor in get_neighbors(current, grid): tentative_g_score = g_score[current] + 1 if neighbor not in g_score or tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal) heapq.heappush(open_list, (f_score[neighbor], neighbor)) return []"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_palindrome(head: ListNode) -> bool: Determine if a given linked list is a palindrome. >>> is_palindrome(None) == True >>> is_palindrome(ListNode(1)) == True >>> is_palindrome(ListNode(1, ListNode(1))) == True >>> is_palindrome(ListNode(1, ListNode(2))) == False >>> is_palindrome(ListNode(1, ListNode(2, ListNode(1)))) == True >>> is_palindrome(ListNode(1, ListNode(2, ListNode(2, ListNode(1))))) == True >>> is_palindrome(ListNode(1, ListNode(2, ListNode(3)))) == False >>> is_palindrome(ListNode(1, ListNode(2, ListNode(3, ListNode(4))))) == False","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_palindrome(head): Returns True if the linked list is a palindrome, False otherwise. # Convert linked list to list vals = [] current = head while current: vals.append(current.val) current = current.next # Check if list is palindrome return vals == vals[::-1]"},{"question":"def replace_primes_with_ordinal_words(numbers: List[int]) -> List: Replace prime numbers in the list with their ordinal word representation if they are less than 20. For prime numbers 20 or greater, replace them with the word \\"prime\\". >>> replace_primes_with_ordinal_words([3, 4, 5, 10, 23]) ['third', 4, 'fifth', 10, 'prime'] >>> replace_primes_with_ordinal_words([4, 6, 8, 10, 12]) [4, 6, 8, 10, 12] >>> replace_primes_with_ordinal_words([2, 3, 5, 7, 11, 13, 17, 19]) ['second', 'third', 'fifth', 'seventh', 'eleventh', 'thirteenth', 'seventeenth', 'nineteenth'] >>> replace_primes_with_ordinal_words([1, 2, 3, 15, 17, 18, 19, 20, 23]) [1, 'second', 'third', 15, 'seventeenth', 18, 'nineteenth', 20, 'prime'] >>> replace_primes_with_ordinal_words([]) [] >>> replace_primes_with_ordinal_words([2, 3, 5, 30, 50, 60, 70]) ['second', 'third', 'fifth', 30, 50, 60, 70]","solution":"def replace_primes_with_ordinal_words(numbers): Replace prime numbers in the list with their ordinal word representation if they are less than 20. For prime numbers 20 or greater, replace them with the word \\"prime\\". primes_ordinal = { 2: 'second', 3: 'third', 5: 'fifth', 7: 'seventh', 11: 'eleventh', 13: 'thirteenth', 17: 'seventeenth', 19: 'nineteenth' } def is_prime(n): if n < 2: return False for i in range(2, int(n ** 0.5) + 1): if n % i == 0: return False return True result = [] for number in numbers: if is_prime(number): if number in primes_ordinal: result.append(primes_ordinal[number]) else: result.append('prime') else: result.append(number) return result"},{"question":"def evaluate_expression(expr: str): Evaluates a mathematical expression from a string. Args: expr (str): A string representing the mathematical expression. Returns: float or str: The result of the evaluated expression, or an error message if there's a division by zero. # Your code here def compare_expressions(expr1: str, expr2: str) -> bool: Compares two mathematical expressions to check if they are equivalent when fully simplified. Args: expr1 (str): The first expression. expr2 (str): The second expression. Returns: bool: True if the expressions are equivalent, False otherwise. # Your code here # Sample test cases def test_evaluate_expression(): assert evaluate_expression(\\"2 * (3 + 4)\\") == 14 assert evaluate_expression(\\"14 - 2\\") == 12 assert evaluate_expression(\\"5 / 0\\") == \\"Error: Division by zero\\" assert evaluate_expression(\\"5 + 5 / 0\\") == \\"Error: Division by zero\\" def test_compare_expressions(): assert compare_expressions(\\"2 * (3 + 4)\\", \\"14\\") == True assert compare_expressions(\\"2 * (3 + 4)\\", \\"13\\") == False assert compare_expressions(\\"5 / 0\\", \\"10 / 0\\") == True assert compare_expressions(\\"5 / 2\\", \\"2.5\\") == True assert compare_expressions(\\"5 / 2\\", \\"2\\") == False","solution":"def evaluate_expression(expr): Evaluates a mathematical expression from a string. Args: expr (str): A string representing the mathematical expression. Returns: float or str: The result of the evaluated expression, or an error message if there's a division by zero. try: return eval(expr) except ZeroDivisionError: return \\"Error: Division by zero\\" def compare_expressions(expr1, expr2): Compares two mathematical expressions to check if they are equivalent when fully simplified. Args: expr1 (str): The first expression. expr2 (str): The second expression. Returns: bool: True if the expressions are equivalent, False otherwise. result1 = evaluate_expression(expr1) result2 = evaluate_expression(expr2) if isinstance(result1, str) or isinstance(result2, str): # If any of the results is an error message, return False return result1 == result2 return result1 == result2"},{"question":"def is_palindrome_anagram(s: str) -> bool: Determines if a given string can be rearranged to form a palindrome. A palindrome requires that each character appears an even number of times, except for one character which can appear an odd number of times. Args: - s (str): The input string Returns: - bool: True if the string can be rearranged into a palindrome, False otherwise >>> is_palindrome_anagram(\\"civic\\") True >>> is_palindrome_anagram(\\"ivicc\\") True >>> is_palindrome_anagram(\\"hello\\") False >>> is_palindrome_anagram(\\"aabb\\") True >>> is_palindrome_anagram(\\"ab\\") False pass","solution":"def is_palindrome_anagram(s: str) -> bool: Determines if a given string can be rearranged to form a palindrome. A palindrome requires that each character appears an even number of times, except for one character which can appear an odd number of times. Args: - s (str): The input string Returns: - bool: True if the string can be rearranged into a palindrome, False otherwise from collections import Counter # Count frequency of each character in the string char_counts = Counter(s) # Count the number of characters with odd counts odd_count = sum(1 for count in char_counts.values() if count % 2 != 0) # For the string to be a palindrome anagram, at most one character can have an odd count return odd_count <= 1"},{"question":"def has_substring_reversed_order(s: str, length: int) -> bool: Checks if any substring of a given length exists in both the original string and its reverse in the exact reversed order. Args: s: a string, 1 ≤ len(s) ≤ 1000 length: an integer, 1 ≤ length ≤ len(s) Returns: True if such a substring exists, False otherwise. >>> has_substring_reversed_order(\\"abcde\\", 2) # False >>> has_substring_reversed_order(\\"abcdcba\\", 3) # True >>> has_substring_reversed_order(\\"abcdefedcba\\", 5) # True from solution import has_substring_reversed_order def test_no_common_substring(): assert has_substring_reversed_order(\\"abcde\\", 2) == False def test_common_substring_example_1(): assert has_substring_reversed_order(\\"abcdcba\\", 3) == True def test_common_substring_example_2(): assert has_substring_reversed_order(\\"abcdefedcba\\", 5) == True def test_entire_string_as_substring(): assert has_substring_reversed_order(\\"abcdefedcba\\", 11) == True def test_single_character_substring(): assert has_substring_reversed_order(\\"a\\", 1) == True def test_two_characters_no_common_substring(): assert has_substring_reversed_order(\\"ab\\", 2) == False def test_two_characters_with_common_substring(): assert has_substring_reversed_order(\\"aa\\", 2) == True def test_all_characters_different(): assert has_substring_reversed_order(\\"abcdefgh\\", 3) == False def test_palindromic_string(): assert has_substring_reversed_order(\\"racecar\\", 3) == True def test_substring_in_middle(): assert has_substring_reversed_order(\\"xyzracecarzyx\\", 7) == True def test_matching_at_ends(): assert has_substring_reversed_order(\\"abcbadebad\\", 3) == True","solution":"def has_substring_reversed_order(s, length): Checks if any substring of a given length exists in both the original string and its reverse in the exact reversed order. Args: s: a string, 1 ≤ len(s) ≤ 1000 length: an integer, 1 ≤ length ≤ len(s) Returns: True if such a substring exists, False otherwise n = len(s) reversed_s = s[::-1] for i in range(n - length + 1): substring = s[i:i + length] reversed_substring = substring[::-1] if reversed_substring in s: return True return False"},{"question":"def sum_of_binary_digits(lst: List[int]) -> List[int]: Takes a list of integers and returns a new list where each integer is replaced with the sum of its binary digits. >>> sum_of_binary_digits([0, 1]) == [0, 1] >>> sum_of_binary_digits([5, 3, 8]) == [2, 2, 1] >>> sum_of_binary_digits([15, 16, 255]) == [4, 1, 8] >>> sum_of_binary_digits([4, 7, 12, 18]) == [1, 3, 2, 2] >>> sum_of_binary_digits([]) == []","solution":"def sum_of_binary_digits(lst): Takes a list of integers and returns a new list where each integer is replaced with the sum of its binary digits. def sum_binary_digits(n): return sum(int(digit) for digit in bin(n)[2:]) return [sum_binary_digits(num) for num in lst]"},{"question":"import math from typing import List def is_prime(n: int) -> bool: Check if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(10) False pass def filter_primes(numbers: List[int]) -> List[int]: Returns a list of prime numbers from the input list. >>> filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> filter_primes([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]) [11, 13, 17, 19] >>> filter_primes([22, 24, 25, 27, 29, 30]) [29] >>> filter_primes([31, 33, 35, 37, 39, 41]) [31, 37, 41] >>> filter_primes([]) [] pass","solution":"def is_prime(n): Check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(numbers): Returns a list of prime numbers from the input list. return [num for num in numbers if is_prime(num)]"},{"question":"from typing import List, Tuple def euclidean_distance(point1: List[float], point2: List[float]) -> float: Calculate the Euclidean distance between two points in a multidimensional space. >>> euclidean_distance([0, 0], [3, 4]) 5.0 >>> euclidean_distance([1, 1], [4, 5]) 5.0 def calculate_centroids(clusters: List[List[List[float]]]) -> List[List[float]]: Calculate the centroids of clusters by averaging the points in each cluster. >>> calculate_centroids([[[0, 0], [1, 1]]]) [[0.5, 0.5]] >>> calculate_centroids([[[2, 3], [3, 4], [4, 5]]]) [[3.0, 4.0]] def assign_clusters(data: List[List[float]], centroids: List[List[float]]) -> List[int]: Assign each data point to the nearest centroid. >>> assign_clusters([[0, 0], [1, 1], [10, 10], [11, 11]], [[0, 0], [10, 10]]) [0, 0, 1, 1] def k_means_clustering(data: List[List[float]], k: int, max_iter: int) -> Tuple[List[List[float]], List[int]]: Implement the k-means clustering algorithm from scratch. The function should take a dataset, the number of clusters \`k\`, and the maximum number of iterations as input. It returns the final centroids and the cluster assignments for each data point. K-means clustering is an iterative algorithm that aims to partition \`n\` observations into \`k\` clusters in which each observation belongs to the cluster with the nearest mean. The algorithm proceeds as follows: 1. Initialize \`k\` centroids randomly. 2. Assign each data point to the nearest centroid based on Euclidean distance. 3. Recalculate the centroids as the mean of all the points assigned to each cluster. 4. Repeat steps 2 and 3 until the centroids do not change significantly or the algorithm has iterated the maximum number of times specified. Discuss how the choice of \`k\` influences the clustering: - Too small \`k\`: May result in large, heterogeneous clusters that fail to capture the structure in the data. - Too large \`k\`: Can lead to overfitting, where clusters are too small and closely fitted to individual data points. >>> data = [[1, 2], [2, 3], [3, 4], [8, 9], [9, 10], [10, 11]] >>> k_means_clustering(data, k=2, max_iter=100) (final centroids, cluster assignments)","solution":"from typing import List, Tuple import random def euclidean_distance(point1: List[float], point2: List[float]) -> float: return sum((x - y) ** 2 for x, y in zip(point1, point2)) ** 0.5 def calculate_centroids(clusters: List[List[List[float]]]) -> List[List[float]]: centroids = [] for cluster in clusters: centroid = [sum(dim)/len(cluster) for dim in zip(*cluster)] centroids.append(centroid) return centroids def assign_clusters(data: List[List[float]], centroids: List[List[float]]) -> List[int]: assignments = [] for point in data: distances = [euclidean_distance(point, centroid) for centroid in centroids] min_distance_index = distances.index(min(distances)) assignments.append(min_distance_index) return assignments def k_means_clustering(data: List[List[float]], k: int, max_iter: int) -> Tuple[List[List[float]], List[int]]: # Randomly initialize centroids initial_indices = random.sample(range(len(data)), k) centroids = [data[i] for i in initial_indices] for iteration in range(max_iter): # Assign points to the nearest centroid clusters = [[] for _ in range(k)] assignments = assign_clusters(data, centroids) for idx, assignment in enumerate(assignments): clusters[assignment].append(data[idx]) # Calculate new centroids new_centroids = calculate_centroids(clusters) # If centroids do not change, break the loop if new_centroids == centroids: break centroids = new_centroids return centroids, assignments"},{"question":"def find_top_spender(users: dict) -> str: Given a dictionary of users with their purchase histories, finds the user who has spent the most. Parameters: users (dict): a dictionary where keys are usernames and values are lists of dictionaries with 'item' and 'amount' as keys. Returns: str: the username of the top spender. Example: >>> users = { ... \\"Alice\\": [ ... {\\"item\\": \\"Book\\", \\"amount\\": \\"12.49\\"}, ... {\\"item\\": \\"Laptop\\", \\"amount\\": \\"799.99\\"}, ... {\\"item\\": \\"Lunch\\", \\"amount\\": \\"9.25\\"} ... ], ... \\"Bob\\": [ ... {\\"item\\": \\"Chocolate\\", \\"amount\\": \\"5.00\\"}, ... {\\"item\\": \\"Shoes\\", \\"amount\\": \\"59.99\\"} ... ], ... \\"Carol\\": [ ... {\\"item\\": \\"Bag\\", \\"amount\\": \\"45.99\\"}, ... {\\"item\\": \\"Dress\\", \\"amount\\": \\"119.99\\"} ... ] ... } >>> find_top_spender(users) \\"Alice\\"","solution":"def find_top_spender(users): Given a dictionary of users with their purchase histories, finds the user who has spent the most. Parameters: users (dict): a dictionary where keys are usernames and values are lists of dictionaries with 'item' and 'amount' as keys. Returns: str: the username of the top spender. top_spender = None highest_spent = 0 for user, purchases in users.items(): total_spent = sum(float(purchase[\\"amount\\"]) for purchase in purchases) if total_spent > highest_spent: highest_spent = total_spent top_spender = user return top_spender"},{"question":"from threading import Lock, Condition class TrafficIntersection: def __init__(self): self.intersection_busy = False self.intersection_lock = Lock() self.intersection_condition = Condition(self.intersection_lock) def enterIntersection(self, direction): with self.intersection_lock: while self.intersection_busy: self.intersection_condition.wait() self.intersection_busy = True def exitIntersection(self): with self.intersection_lock: self.intersection_busy = False self.intersection_condition.notify() def northbound_vehicle(intersection): intersection.enterIntersection('N') # Simulates time taken to cross the intersection intersection.exitIntersection() def southbound_vehicle(intersection): intersection.enterIntersection('S') # Simulates time taken to cross the intersection intersection.exitIntersection()","solution":"from threading import Lock, Condition class TrafficIntersection: def __init__(self): self.intersection_busy = False self.intersection_lock = Lock() self.intersection_condition = Condition(self.intersection_lock) def enterIntersection(self, direction): with self.intersection_lock: while self.intersection_busy: self.intersection_condition.wait() self.intersection_busy = True def exitIntersection(self): with self.intersection_lock: self.intersection_busy = False self.intersection_condition.notify() def northbound_vehicle(intersection): intersection.enterIntersection('N') print('N entered the intersection') intersection.exitIntersection() print('N exited the intersection') def southbound_vehicle(intersection): intersection.enterIntersection('S') print('S entered the intersection') intersection.exitIntersection() print('S exited the intersection')"},{"question":"def longest_subarray_sum(nums: List[int], k: int) -> int: Returns the length of the longest contiguous subarray whose sum is less than or equal to k. >>> longest_subarray_sum([1, 2, 3, 4, 5], 9) 3 >>> longest_subarray_sum([1, 1, 1, 1, 1], 3) 3 >>> longest_subarray_sum([5, 1, 2, 1, 2, 2, 1], 6) 4 >>> longest_subarray_sum([1, 2, 3], 6) 3 >>> longest_subarray_sum([1, 2, 3], 5) 2 >>> longest_subarray_sum([], 5) 0","solution":"def longest_subarray_sum(nums, k): Returns the length of the longest contiguous subarray whose sum is less than or equal to k. max_length = 0 current_sum = 0 start = 0 for end in range(len(nums)): current_sum += nums[end] while current_sum > k: current_sum -= nums[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def is_valid_hex_color(code: str) -> bool: Returns True if the input string is a valid hexadecimal color code, False otherwise. A valid hexadecimal color code must start with a hashtag (#) followed by exactly six hexadecimal characters (digits 0-9 and/or letters A-F/a-f). >>> is_valid_hex_color(\\"#1A2B3C\\") == True >>> is_valid_hex_color(\\"#ffffff\\") == True >>> is_valid_hex_color(\\"#ABCDEF\\") == True >>> is_valid_hex_color(\\"#123456\\") == True >>> is_valid_hex_color(\\"#ABC\\") == False >>> is_valid_hex_color(\\"#12345G\\") == False >>> is_valid_hex_color(\\"#1234567\\") == False >>> is_valid_hex_color(\\"#12345678\\") == False >>> is_valid_hex_color(\\"123456\\") == False >>> is_valid_hex_color(\\"#abcdfe\\") == True >>> is_valid_hex_color(\\"#ABCDFE\\") == True >>> is_valid_hex_color(\\"\\") == False >>> is_valid_hex_color(\\"123ABC\\") == False","solution":"import re def is_valid_hex_color(code): Returns True if the input string is a valid hexadecimal color code, False otherwise. A valid hexadecimal color code must start with a hashtag (#) followed by exactly six hexadecimal characters (digits 0-9 and/or letters A-F/a-f). Parameters: - code (str): The input string to be checked. Returns: - bool: True if the input string is a valid hexadecimal color code, False otherwise. pattern = r'^#[0-9A-Fa-f]{6}' return bool(re.match(pattern, code))"}]`),N={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:F,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},E={class:"search-container"},I={class:"card-container"},S={key:0,class:"empty-state"},z=["disabled"],D={key:0},j={key:1};function P(i,e,l,m,n,a){const f=h("PoemCard");return s(),r("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",E,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>n.searchQuery=o),placeholder:"Search..."},null,512),[[b,n.searchQuery]]),n.searchQuery?(s(),r("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>n.searchQuery="")}," ✕ ")):u("",!0)]),t("div",I,[(s(!0),r(y,null,v(a.displayedPoems,(o,p)=>(s(),w(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),r("div",S,' No results found for "'+d(n.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(s(),r("button",{key:0,class:"load-more-button",disabled:n.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[n.isLoading?(s(),r("span",j,"Loading...")):(s(),r("span",D,"See more"))],8,z)):u("",!0)])}const B=_(N,[["render",P],["__scopeId","data-v-7015f329"]]),V=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"grok/23.md","filePath":"grok/23.md"}'),M={name:"grok/23.md"},H=Object.assign(M,{setup(i){return(e,l)=>(s(),r("div",null,[x(B)]))}});export{V as __pageData,H as default};
