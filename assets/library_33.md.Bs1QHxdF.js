import{_,o as s,c as n,a as t,m as c,t as d,C as h,M as g,U as b,f as u,F as x,p as y,e as v,q as w}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},T={class:"review"},L={class:"review-title"},N={class:"review-content"};function R(i,e,l,m,r,a){return s(),n("div",k,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(l.poem.solution),1)])])])}const A=_(q,[["render",R],["__scopeId","data-v-de6b9d7c"]]),S=JSON.parse(`[{"question":"def min_makespan(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the minimum possible makespan for scheduling tasks on two machines. >>> min_makespan(2, [(4, [3, 1, 4, 2]), (3, [2, 3, 5])]) [5, 5] >>> min_makespan(1, [(5, [5, 5, 5, 5, 5])]) [15]","solution":"def min_makespan(t, test_cases): def find_min_makespan(tasks): total_sum = sum(tasks) n = len(tasks) # DP array where dp[i][j] means if it is possible to get j time # using the first i tasks dp = [[False] * (total_sum + 1) for _ in range(n + 1)] dp[0][0] = True for i in range(1, n + 1): for j in range(total_sum + 1): dp[i][j] = dp[i - 1][j] if j >= tasks[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j - tasks[i - 1]] min_makespan = float('inf') for j in range(total_sum // 2 + 1): if dp[n][j]: first_machine = j second_machine = total_sum - j min_makespan = min(min_makespan, max(first_machine, second_machine)) return min_makespan results = [] for case in test_cases: n, tasks = case results.append(find_min_makespan(tasks)) return results # Sample usage t = 2 test_cases = [ (4, [3, 1, 4, 2]), (3, [2, 3, 5]) ] print(min_makespan(t, test_cases)) # Output: [5, 5]"},{"question":"class SequenceProcessor: def __init__(self, sequence): self.sequence = sequence def update(self, i, v): Update the ith element of the sequence to be v. pass def sum_range(self, l, r): Calculate the sum of the elements in the range [l, r] (both inclusive). pass def process_queries(n, sequence, q, queries): Process a series of queries on a sequence of integers. Args: n (int): the number of elements in the sequence. sequence (List[int]): the elements of the sequence. q (int): the number of queries. queries (List[str]): the queries to be processed. Returns: List[int]: the results of the queries of type \\"S l r\\". Example: >>> n = 5 >>> sequence = [1, 2, 3, 4, 5] >>> q = 5 >>> queries = [\\"S 1 3\\", \\"U 2 10\\", \\"S 1 3\\", \\"U 5 6\\", \\"S 1 5\\"] >>> process_queries(n, sequence, q, queries) [6, 14, 24] pass","solution":"class SequenceProcessor: def __init__(self, sequence): self.sequence = sequence def update(self, i, v): self.sequence[i - 1] = v def sum_range(self, l, r): return sum(self.sequence[l - 1:r]) def process_queries(n, sequence, q, queries): processor = SequenceProcessor(sequence) results = [] for query in queries: parts = query.split() if parts[0] == 'U': processor.update(int(parts[1]), int(parts[2])) elif parts[0] == 'S': result = processor.sum_range(int(parts[1]), int(parts[2])) results.append(result) return results"},{"question":"def maxAreaOfIsland(grid): Return the maximum area of an island in the given grid. Args: grid: List[List[int]] : 2-dimensional list representing the grid Returns: int : maximum area of an island in the grid Example: >>> maxAreaOfIsland([[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]]) 6 >>> maxAreaOfIsland([[0,0,0,0,0,0,0,0]]) 0","solution":"def maxAreaOfIsland(grid): Returns the maximum area of an island in the given grid. if not grid: return 0 rows = len(grid) cols = len(grid[0]) def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == 0: return 0 # Mark the cell as visited by setting it to 0 grid[r][c] = 0 area = 1 # Check all four directions area += dfs(r + 1, c) area += dfs(r - 1, c) area += dfs(r, c + 1) area += dfs(r, c - 1) return area max_area = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: max_area = max(max_area, dfs(r, c)) return max_area"},{"question":"def maxCoins(piles: List[int], k: int) -> int: Given a list of non-negative integers representing the amount of coins in each stack, and an integer k representing the number of coins allowed to pick from the stacks, return the maximum number of coins you can obtain after k operations by picking the largest coins. >>> maxCoins([2, 4, 1, 2, 7, 8], 3) == 19 >>> maxCoins([2, 4, 5], 2) == 9 >>> maxCoins([5, 6, 7, 8, 9], 3) == 24 from typing import List def test_example_1(): piles = [2, 4, 1, 2, 7, 8] k = 3 assert maxCoins(piles, k) == 19 def test_example_2(): piles = [2, 4, 5] k = 2 assert maxCoins(piles, k) == 9 def test_example_3(): piles = [5, 6, 7, 8, 9] k = 3 assert maxCoins(piles, k) == 24 def test_small_piles(): piles = [1, 2, 3] k = 2 assert maxCoins(piles, k) == 5 def test_large_k(): piles = [10, 20, 30, 40, 50] k = 5 assert maxCoins(piles, k) == 150 def test_large_piles(): piles = [i for i in range(1, 10001)] k = 100 expected = sum(piles[-100:]) # sum of the last 100 elements which are the largest in this list assert maxCoins(piles, k) == expected","solution":"def maxCoins(piles, k): Returns the maximum number of coins that can be obtained after k operations by picking the largest coins. # Sort the piles in descending order sorted_piles = sorted(piles, reverse=True) # Sum the first k elements in the sorted list return sum(sorted_piles[:k])"},{"question":"def reduce_consecutive_characters(s: str) -> str: Returns a new string where consecutive duplicate characters in the input string are reduced to a single character. >>> reduce_consecutive_characters(\\"aaabbbcccaaa\\") \\"abca\\" >>> reduce_consecutive_characters(\\"aabbccdd\\") \\"abcd\\" >>> reduce_consecutive_characters(\\"abc\\") \\"abc\\" >>> reduce_consecutive_characters(\\"aaa\\") \\"a\\"","solution":"def reduce_consecutive_characters(s): Returns a new string where consecutive duplicate characters in the input string are reduced to a single character. if not s: return \\"\\" result = [s[0]] # initialize the result list with the first character for char in s[1:]: if char != result[-1]: # only add char if it's different from the last char in result result.append(char) return ''.join(result) # join list into string and return"},{"question":"def reverse_words(s: str) -> str: Takes a string s as input and returns a new string where the order of the words is reversed. Leading, trailing, or multiple spaces between words in the input are not allowed in the output. >>> reverse_words(\\" hello world \\") \\"world hello\\" >>> reverse_words(\\"a good example\\") \\"example good a\\" >>> reverse_words(\\" Bob Loves Alice \\") \\"Alice Loves Bob\\" >>> reverse_words(\\"Alice does not even like bob\\") \\"bob like even not does Alice\\" >>> reverse_words(\\" \\") \\"\\" >>> reverse_words(\\"word\\") \\"word\\" >>> reverse_words(\\" single_word \\") \\"single_word\\"","solution":"def reverse_words(s: str) -> str: Returns a string where the order of words from the input string s is reversed. Leading, trailing, or multiple spaces between words in the input are not allowed in the output. words = [] length = len(s) i = 0 while i < length: while i < length and s[i] == ' ': i += 1 if i < length: start = i while i < length and s[i] != ' ': i += 1 words.append(s[start:i]) return ' '.join(reversed(words))"},{"question":"def multiply_strings(num1: str, num2: str) -> str: Multiplies two non-negative integers represented as strings without converting them to integers directly. Returns the product as a string. >>> multiply_strings(\\"2\\", \\"3\\") \\"6\\" >>> multiply_strings(\\"123\\", \\"456\\") \\"56088\\"","solution":"def multiply_strings(num1, num2): Multiplies two non-negative integers represented as strings without converting them to integers directly. Returns the product as a string. if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" len1, len2 = len(num1), len(num2) result = [0] * (len1 + len2) for i in range(len1 - 1, -1, -1): for j in range(len2 - 1, -1, -1): mul = int(num1[i]) * int(num2[j]) p1, p2 = i + j, i + j + 1 total = mul + result[p2] result[p1] += total // 10 result[p2] = total % 10 while result[0] == 0: result.pop(0) return ''.join(map(str, result))"},{"question":"def encode_message(n: int, encoding_map: list, message: str) -> str: Encodes a message according to the given encoding map. Args: n (int): Number of letter-integer pairs in the encoding map. encoding_map (list): A list of tuples where each tuple contains a letter and its corresponding integer. message (str): The message to encode. Returns: str: The encoded message. >>> encode_message(1, [('a', 1)], 'abcd') '1bcd' >>> encode_message(3, [('a', 1), ('b', 2), ('c', 3)], 'abcxyz') '123xyz' >>> encode_message(3, [('a', 1), ('b', 2), ('c', 3)], 'AaBbCc') 'A1B2C3' >>> encode_message(0, [], 'abcxyz') 'abcxyz' >>> encode_message(2, [('a', 1), ('b', 2)], 'a!b@c#') '1!2@c#' >>> encode_message(26, [(chr(97+i), i) for i in range(26)], 'abcdefghijklmnopqrstuvwxyz') '012345678910111213141516171819202122232425' >>> encode_message(2, [('a', 1), ('1', 2)], 'a1b') '12b'","solution":"def encode_message(n, encoding_map, message): Encodes a message according to the given encoding map. Args: n (int): Number of letter-integer pairs in the encoding map. encoding_map (list): A list of tuples where each tuple contains a letter and its corresponding integer. message (str): The message to encode. Returns: str: The encoded message. # Convert the encoding map to a dictionary for quick lookup encoding_dict = {char: str(num) for char, num in encoding_map} # Encode the message encoded_message = ''.join(encoding_dict.get(char, char) for char in message) return encoded_message # Example Usage: # n = 3 # encoding_map = [('a', 1), ('b', 2), ('c', 3)] # message = 'abcxyz' # -> encode_message(n, encoding_map, message) -> '123xyz'"},{"question":"def bacteria_cells(n: int) -> int: Calculate the number of bacteria cells at the end of the nth generation. Parameters: n (int): The number of generations. Returns: int: The number of bacteria cells after n generations. >>> bacteria_cells(1) 2 >>> bacteria_cells(2) 2 >>> bacteria_cells(3) 4 >>> bacteria_cells(4) 4 >>> bacteria_cells(5) 8","solution":"def bacteria_cells(n): Calculate the number of bacteria cells at the end of the nth generation. Parameters: n (int): The number of generations. Returns: int: The number of bacteria cells after n generations. return 2**((n + 1) // 2)"},{"question":"def can_build_pyramid(h: int, n: int, block_numbers: List[int]) -> str: Determines if it's possible to build a pyramid of height h using the given blocks. >>> can_build_pyramid(2, 3, [1, 2, 3]) \\"YES\\" >>> can_build_pyramid(3, 4, [1, 3, 4, 5]) \\"NO\\" pass # Unit tests from solution import can_build_pyramid def test_case_1(): assert can_build_pyramid(2, 3, [1, 2, 3]) == \\"YES\\" def test_case_2(): assert can_build_pyramid(3, 4, [1, 3, 4, 5]) == \\"NO\\" def test_case_3(): assert can_build_pyramid(1, 1, [1]) == \\"YES\\" def test_case_4(): assert can_build_pyramid(2, 2, [1, 3]) == \\"NO\\" def test_case_5(): assert can_build_pyramid(3, 5, [1, 2, 3, 4, 5]) == \\"YES\\" def test_case_6(): assert can_build_pyramid(4, 6, [1, 2, 4, 5, 10, 25]) == \\"NO\\"","solution":"def can_build_pyramid(h, n, block_numbers): Determines if it's possible to build a pyramid of height h using the given blocks. def can_build_levels(level_numbers, current_level): if current_level == 1: return level_numbers[0] in block_numbers for i in range(current_level - 1): if level_numbers[i] + level_numbers[i + 1] not in block_numbers: return False next_level = [level_numbers[i] + level_numbers[i + 1] for i in range(current_level - 1)] return can_build_levels(next_level, current_level - 1) initial_level = [1] * h return \\"YES\\" if can_build_levels(initial_level, h) else \\"NO\\" # Example usage h = 2 n = 3 block_numbers = [1, 2, 3] print(can_build_pyramid(h, n, block_numbers)) # Output: YES h = 3 n = 4 block_numbers = [1, 3, 4, 5] print(can_build_pyramid(h, n, block_numbers)) # Output: NO"},{"question":"def decode_message(encoded_message): Decodes the message by finding all possible original strings based on a shifting cipher. >>> decode_message(\\"ebiil\\") ['ebiil', 'dahhk', 'czggj', 'byffi', 'axeeh', 'zwddg', 'yvccf', 'xubbe', 'wtaad', 'vszzc', 'uryyb', 'tqxxa', 'spwwz', 'rovvy', 'qnuux', 'pmttw', 'olssv', 'nkrru', 'mjqqt', 'lipps', 'khoor', 'jgnnq', 'ifmmp', 'hello', 'gdkkn', 'fcjjm'] # Your code here def decode_multiple_messages(T, messages): Decodes multiple messages by calling decode_message for each one. >>> decode_multiple_messages(2, [\\"ebiil\\", \\"fcjjm\\"]) ['ebiil', 'dahhk', 'czggj', 'byffi', 'axeeh', 'zwddg', 'yvccf', 'xubbe', 'wtaad', 'vszzc', 'uryyb', 'tqxxa', 'spwwz', 'rovvy', 'qnuux', 'pmttw', 'olssv', 'nkrru', 'mjqqt', 'lipps', 'khoor', 'jgnnq', 'ifmmp', 'hello', 'gdkkn', 'fcjjm', '', 'fcjjm', 'ebiil', 'dahhk', 'czggj', 'byffi', 'axeeh', 'zwddg', 'yvccf', 'xubbe', 'wtaad', 'vszzc', 'uryyb', 'tqxxa', 'spwwz', 'rovvy', 'qnuux', 'pmttw', 'olssv', 'nkrru', 'mjqqt', 'lipps', 'khoor', 'jgnnq', 'ifmmp', 'hello', 'gdkkn', ''] # Your code here","solution":"def decode_message(encoded_message): Decodes the message by finding all possible original strings based on a shifting cipher. decoded_messages = [] for k in range(26): # Check all possible shifts from 0 to 25. decoded_message = ''.join(chr((ord(char) - 97 - k) % 26 + 97) for char in encoded_message) decoded_messages.append(decoded_message) return decoded_messages def decode_multiple_messages(T, messages): Decodes multiple messages by calling decode_message for each one. results = [] for message in messages: decoded_messages = decode_message(message) results.extend(decoded_messages) results.append('') # Add a blank line separator between different sets of results. return results"},{"question":"def remove_duplicates(employees): Removes duplicates from the list of employees while maintaining the original order of their first appearance. Args: employees (list of str): List of employee names. Returns: list of str: List of employee names with duplicates removed. >>> remove_duplicates([\\"Alice\\", \\"Bob\\", \\"Alice\\", \\"Eve\\", \\"Bob\\"]) == [\\"Alice\\", \\"Bob\\", \\"Eve\\"] >>> remove_duplicates([\\"Eve\\", \\"Alice\\", \\"Eve\\", \\"Alice\\", \\"Bob\\"]) == [\\"Eve\\", \\"Alice\\", \\"Bob\\"] >>> remove_duplicates([\\"Alice\\", \\"Bob\\", \\"Eve\\"]) == [\\"Alice\\", \\"Bob\\", \\"Eve\\"] >>> remove_duplicates([]) == [] >>> remove_duplicates([\\"Alice\\"]) == [\\"Alice\\"] >>> remove_duplicates([\\"Alice\\", \\"Alice\\", \\"Alice\\"]) == [\\"Alice\\"]","solution":"def remove_duplicates(employees): Removes duplicates from the list of employees while maintaining the original order of their first appearance. Args: employees (list of str): List of employee names. Returns: list of str: List of employee names with duplicates removed. seen = set() result = [] for employee in employees: if employee not in seen: seen.add(employee) result.append(employee) return result"},{"question":"def unique(arr): Returns a new list containing only the unique elements from the original array, preserving the order in which they first appear. >>> unique([1, 2, 3, 2, 4, 1]) [1, 2, 3, 4] >>> unique([\\"apple\\", \\"orange\\", \\"apple\\", \\"banana\\"]) [\\"apple\\", \\"orange\\", \\"banana\\"] >>> unique([1, \\"apple\\", 2, \\"apple\\", 1, 3]) [1, \\"apple\\", 2, 3] >>> unique([]) [] >>> unique([42]) [42]","solution":"def unique(arr): Returns a new list containing only the unique elements from the original array, preserving the order in which they first appear. seen = set() unique_elements = [] for item in arr: if item not in seen: unique_elements.append(item) seen.add(item) return unique_elements"},{"question":"class SmartHomeSystem: A class to manage a simple smart home device system with commands to turn devices on, off, and standby. It also allows querying device status and listing devices by their states. Examples: >>> system = SmartHomeSystem() >>> system.turn_on(\\"Television\\") >>> system.status(\\"Television\\") \\"ON\\" >>> system.process_commands(\\"TURN_ON TelevisionnTURN_ON LampnSTANDBY TelevisionnTURN_OFF LampnSTATUS TelevisionnSTATUS LampnLIST_ONnLIST_OFFnLIST_STANDBY\\") [\\"STANDBY\\", \\"OFF\\", [], [\\"Lamp\\"], [\\"Television\\"]] def __init__(self): # Initialize the smart home system with an empty dictionary to store devices and their states. def turn_on(self, device_name): # Turn on the specified device. def turn_off(self, device_name): # Turn off the specified device. def standby(self, device_name): # Put the specified device in standby mode. def status(self, device_name): # Get the status of the specified device. Return \\"OFF\\" if the device is not found. def list_on(self): # List all devices that are currently ON. def list_off(self): # List all devices that are currently OFF. def list_standby(self): # List all devices that are currently in STANDBY mode. def process_commands(self, commands): # Process a sequence of commands and return the results for STATUS, LIST_ON, LIST_OFF, and LIST_STANDBY commands. # Unit tests def test_turn_on_and_status(): system = SmartHomeSystem() system.turn_on(\\"Television\\") assert system.status(\\"Television\\") == \\"ON\\" def test_turn_off_and_status(): system = SmartHomeSystem() system.turn_on(\\"Lamp\\") system.turn_off(\\"Lamp\\") assert system.status(\\"Lamp\\") == \\"OFF\\" def test_standby_and_status(): system = SmartHomeSystem() system.turn_on(\\"Television\\") system.standby(\\"Television\\") assert system.status(\\"Television\\") == \\"STANDBY\\" def test_list_on(): system = SmartHomeSystem() system.turn_on(\\"Television\\") system.turn_on(\\"Lamp\\") assert set(system.list_on()) == {\\"Television\\", \\"Lamp\\"} def test_list_off(): system = SmartHomeSystem() system.turn_off(\\"Fridge\\") system.turn_off(\\"Microwave\\") assert set(system.list_off()) == {\\"Fridge\\", \\"Microwave\\"} def test_list_standby(): system = SmartHomeSystem() system.standby(\\"Vacuum\\") system.standby(\\"AC\\") assert set(system.list_standby()) == {\\"Vacuum\\", \\"AC\\"} def test_process_commands(): system = SmartHomeSystem() commands = TURN_ON Television TURN_ON Lamp STANDBY Television TURN_OFF Lamp STATUS Television STATUS Lamp LIST_ON LIST_OFF LIST_STANDBY expected_output = [\\"STANDBY\\", \\"OFF\\", [], [\\"Lamp\\"], [\\"Television\\"]] assert system.process_commands(commands) == expected_output","solution":"class SmartHomeSystem: def __init__(self): self.devices = {} def turn_on(self, device_name): self.devices[device_name] = \\"ON\\" def turn_off(self, device_name): self.devices[device_name] = \\"OFF\\" def standby(self, device_name): self.devices[device_name] = \\"STANDBY\\" def status(self, device_name): return self.devices.get(device_name, \\"OFF\\") def list_on(self): return [device for device, state in self.devices.items() if state == \\"ON\\"] def list_off(self): return [device for device, state in self.devices.items() if state == \\"OFF\\"] def list_standby(self): return [device for device, state in self.devices.items() if state == \\"STANDBY\\"] def process_commands(self, commands): results = [] for command in commands.split('n'): parts = command.split() action = parts[0] if action == \\"TURN_ON\\": self.turn_on(parts[1]) elif action == \\"TURN_OFF\\": self.turn_off(parts[1]) elif action == \\"STANDBY\\": self.standby(parts[1]) elif action == \\"STATUS\\": results.append(self.status(parts[1])) elif action == \\"LIST_ON\\": results.append(self.list_on()) elif action == \\"LIST_OFF\\": results.append(self.list_off()) elif action == \\"LIST_STANDBY\\": results.append(self.list_standby()) return results"},{"question":"def getDigitSum(n: int) -> int: Calculates and returns the sum of the digits of a positive integer. >>> getDigitSum(5) 5 >>> getDigitSum(429) 15 >>> getDigitSum(9081726354) 45 >>> getDigitSum(0) 0 >>> getDigitSum(1000000000) 1","solution":"def getDigitSum(n): Returns the sum of the digits of a positive integer n. digit_sum = 0 while n > 0: digit_sum += n % 10 n //= 10 return digit_sum"},{"question":"def sort_by_frequency(s: str) -> str: Sort the string based on character frequency. Characters with higher frequencies should come first. In case of a tie, characters should be sorted alphabetically. >>> sort_by_frequency(\\"tree\\") \\"eert\\" >>> sort_by_frequency(\\"cccaaa\\") \\"aaaccc\\" >>> sort_by_frequency(\\"Aabb\\") \\"bbAa\\"","solution":"def sort_by_frequency(s: str) -> str: from collections import Counter # Calculate frequency of each character frequency = Counter(s) # Sort the items based on frequency (descending) and case-sensitive lexicographical order sorted_items = sorted(frequency.items(), key=lambda item: (-item[1], item[0])) # Construct the result string result = ''.join([char * count for char, count in sorted_items]) return result"},{"question":"from typing import List def containsNearbyAlmostDuplicate(nums: List[int], k: int) -> bool: Determine if there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most k and the absolute difference between i and j is at most k. >>> containsNearbyAlmostDuplicate([1, 2, 3, 1], 3) True >>> containsNearbyAlmostDuplicate([1, 0, 1, 1], 1) True >>> containsNearbyAlmostDuplicate([1, 5, 9, 1, 5, 9], 2) False","solution":"from typing import List def containsNearbyAlmostDuplicate(nums: List[int], k: int) -> bool: if len(nums) < 2 or k == 0: return False num_set = set() for i, num in enumerate(nums): if i > k: num_set.remove(nums[i - k - 1]) for n in num_set: if abs(num - n) <= k: return True num_set.add(num) return False"},{"question":"def num_digits(n: int) -> int: Returns the number of digits in the decimal representation of a given non-negative integer. >>> num_digits(0) 1 >>> num_digits(5) 1 >>> num_digits(123) 3 >>> num_digits(1000) 4 >>> num_digits(987654321) 9","solution":"def num_digits(n): Returns the number of digits in the decimal representation of a non-negative integer n. if n == 0: return 1 count = 0 while n > 0: n //= 10 count += 1 return count"},{"question":"class FileSharingSystem: def __init__(self, P): Initialize the file sharing system with P projects. def create_project(self, p): Creates a new project p. def delete_project(self, p): Deletes an existing project p. def upload_file(self, p, f): Uploads a file f to project p. def delete_file(self, p, f): Deletes a file f from project p. def download_file(self, p, f): Downloads a file f from project p and returns the number of times this file has been downloaded. def file_sharing_system(P, Q, project_ids, queries): Handle the file sharing system operations based on the input queries. >>> P = 3 >>> Q = 10 >>> project_ids = [1, 2, 3] >>> queries = [\\"C 4\\", \\"U 1 100\\", \\"L 1 100\\", \\"U 2 200\\", \\"L 2 200\\", \\"L 2 200\\", \\"D 2\\", \\"U 4 300\\", \\"L 4 300\\", \\"R 4 300\\"] >>> file_sharing_system(P, Q, project_ids, queries) [1, 1, 2, 1] # Unit Tests def test_file_sharing_system(): P = 3 Q = 10 project_ids = [1, 2, 3] queries = [ \\"C 4\\", \\"U 1 100\\", \\"L 1 100\\", \\"U 2 200\\", \\"L 2 200\\", \\"L 2 200\\", \\"D 2\\", \\"U 4 300\\", \\"L 4 300\\", \\"R 4 300\\" ] result = file_sharing_system(P, Q, project_ids, queries) assert result == [1, 1, 2, 1] def test_delete_file(): P = 2 Q = 7 project_ids = [1, 2] queries = [ \\"U 1 100\\", \\"U 1 101\\", \\"L 1 100\\", \\"L 1 101\\", \\"R 1 100\\", \\"L 1 100\\", \\"L 1 101\\" ] result = file_sharing_system(P, Q, project_ids, queries) assert result == [1, 1, 0, 2] def test_delete_project(): P = 2 Q = 8 project_ids = [1, 2] queries = [ \\"U 1 100\\", \\"U 2 200\\", \\"L 1 100\\", \\"L 2 200\\", \\"D 1\\", \\"L 1 100\\", \\"L 2 200\\", \\"U 1 150\\" ] result = file_sharing_system(P, Q, project_ids, queries) assert result == [1, 1, 0, 2]","solution":"class FileSharingSystem: def __init__(self, P): self.projects = {p: {} for p in range(1, P+1)} def create_project(self, p): if p not in self.projects: self.projects[p] = {} def delete_project(self, p): if p in self.projects: del self.projects[p] def upload_file(self, p, f): if p in self.projects: if f not in self.projects[p]: self.projects[p][f] = 0 def delete_file(self, p, f): if p in self.projects and f in self.projects[p]: del self.projects[p][f] def download_file(self, p, f): if p in self.projects and f in self.projects[p]: self.projects[p][f] += 1 return self.projects[p][f] return 0 def file_sharing_system(P, Q, project_ids, queries): fs = FileSharingSystem(max(project_ids)) for p in project_ids: fs.create_project(p) results = [] for query in queries: parts = query.split() cmd = parts[0] if cmd == 'C': fs.create_project(int(parts[1])) elif cmd == 'D': fs.delete_project(int(parts[1])) elif cmd == 'U': fs.upload_file(int(parts[1]), int(parts[2])) elif cmd == 'R': fs.delete_file(int(parts[1]), int(parts[2])) elif cmd == 'L': result = fs.download_file(int(parts[1]), int(parts[2])) results.append(result) return results"},{"question":"def calculate_total_dispensed_water(t, test_cases): Calculate the total amount of water dispensed for each day based on a series of commands. Each command is either to start a dispensing session, stop the ongoing session, or reset the dispenser. Parameters: t (int): Number of test cases test_cases (List[Tuple[int, int, int, List[str]]]): List containing the details for each test case Returns: List[int]: Total amount of water dispensed for each test case >>> calculate_total_dispensed_water(2, [(5, 1000000, 4, [\\"start\\", \\"stop\\", \\"start\\", \\"stop\\"]), (2, 500000, 6, [\\"start\\", \\"stop\\", \\"reset\\", \\"start\\", \\"stop\\", \\"start\\"])]) [10, 4] import unittest class TestCalculateTotalDispensedWater(unittest.TestCase): def test_calculate_total_dispensed_water(self): self.assertEqual(calculate_total_dispensed_water( 2, [ (5, 1000000, 4, [\\"start\\", \\"stop\\", \\"start\\", \\"stop\\"]), (2, 500000, 6, [\\"start\\", \\"stop\\", \\"reset\\", \\"start\\", \\"stop\\", \\"start\\"]) ] ), [10, 4]) def test_single_start_stop(self): self.assertEqual(calculate_total_dispensed_water( 1, [ (10, 100, 2, [\\"start\\", \\"stop\\"]) ] ), [10]) def test_reset_between_start_and_stop(self): self.assertEqual(calculate_total_dispensed_water( 1, [ (5, 1000000, 5, [\\"start\\", \\"reset\\", \\"start\\", \\"stop\\", \\"stop\\"]) ] ), [5]) def test_multiple_starts(self): self.assertEqual(calculate_total_dispensed_water( 1, [ (3, 200, 6, [\\"start\\", \\"stop\\", \\"start\\", \\"stop\\", \\"start\\", \\"stop\\"]) ] ), [9]) def test_no_starts(self): self.assertEqual(calculate_total_dispensed_water( 1, [ (5, 500, 3, [\\"reset\\", \\"stop\\", \\"reset\\"]) ] ), [0]) if __name__ == '__main__': unittest.main()","solution":"def calculate_total_dispensed_water(t, test_cases): results = [] for i in range(t): s, w, c, commands = test_cases[i] total_dispensed = 0 dispensing = False for command in commands: if command == \\"start\\": dispensing = True elif command == \\"stop\\" and dispensing: total_dispensed += s dispensing = False elif command == \\"reset\\": dispensing = False results.append(total_dispensed) return results"},{"question":"def nearest_greater_elements(arr: List[int]) -> List[int]: Implement a function that takes an array of integers and returns an array containing the nearest greater element for each element of the input array. The nearest greater element for a given element is the closest element to the right that is greater than the given element. If there is no greater element to the right, return -1 for that position. Example: >>> nearest_greater_elements([4, 5, 2, 10, 8]) [5, 10, 10, -1, -1] >>> nearest_greater_elements([1, 3, 2, 4]) [3, 4, 4, -1] >>> nearest_greater_elements([6, 8, 0, 1, 3]) [8, -1, 1, 3, -1] pass from solution import nearest_greater_elements def test_case_1(): assert nearest_greater_elements([4, 5, 2, 10, 8]) == [5, 10, 10, -1, -1] def test_case_2(): assert nearest_greater_elements([1, 3, 2, 4]) == [3, 4, 4, -1] def test_case_3(): assert nearest_greater_elements([6, 8, 0, 1, 3]) == [8, -1, 1, 3, -1] def test_case_no_greater_element(): assert nearest_greater_elements([5, 4, 3, 2, 1]) == [-1, -1, -1, -1, -1] def test_case_all_equal(): assert nearest_greater_elements([3, 3, 3, 3]) == [-1, -1, -1, -1] def test_case_single_element(): assert nearest_greater_elements([5]) == [-1] def test_case_mixed(): assert nearest_greater_elements([10, 13, 8, 9, 11, 5]) == [13, -1, 9, 11, -1, -1] # Running pytest will automatically find these test cases and execute them","solution":"from typing import List def nearest_greater_elements(arr: List[int]) -> List[int]: Returns an array containing the nearest greater element to the right for each element in the input array. If no greater element exists to the right, return -1 for that position. n = len(arr) result = [-1] * n # Initialize the result array with -1 stack = [] # Stack to keep track of indices of elements for i in range(n): # While stack is not empty and the current element is greater than the element at index from stack's top while stack and arr[i] > arr[stack[-1]]: index = stack.pop() result[index] = arr[i] stack.append(i) # Append the current index to the stack return result"},{"question":"def is_rotation(s1: str, s2: str) -> bool: Given two strings s1 and s2, return true if s2 is a rotation of s1, otherwise return false. >>> is_rotation(\\"waterbottle\\", \\"erbottlewat\\") True >>> is_rotation(\\"hello\\", \\"ohell\\") True >>> is_rotation(\\"apple\\", \\"ppale\\") False","solution":"def is_rotation(s1, s2): Returns True if s2 is a rotation of s1, otherwise False. if len(s1) != len(s2): return False return s2 in s1 + s1"},{"question":"class Inventory: def __init__(self): self.stock = {} def add_item(self, item_name, quantity): Adds a new item to the inventory with the given quantity. If the item already exists, returns \\"Item already exists\\". Args: item_name (str): The name of the item to add. quantity (int): The quantity of the item to add. Returns: str: \\"OK\\" if the item was successfully added, otherwise \\"Item already exists\\". pass def update_item(self, item_name, quantity): Updates the quantity of an existing item in the inventory. If the item does not exist, returns \\"Item does not exist\\". Args: item_name (str): The name of the item to update. quantity (int): The new quantity of the item. Returns: str: \\"OK\\" if the item was successfully updated, otherwise \\"Item does not exist\\". pass def process_order(self, item_name, quantity): Processes an order by decrementing the quantity of the specified item by the given quantity. If the item does not exist or if there is insufficient stock, returns \\"Order cannot be processed\\". Args: item_name (str): The name of the item to order. quantity (int): The quantity of the item to order. Returns: str: \\"OK\\" if the order was successfully processed, otherwise \\"Order cannot be processed\\". pass def process_operations(operations): Processes a list of operations on the inventory system. Args: operations (list of str): The list of operations. Returns: list of str: The list of results after processing each operation. inv = Inventory() results = [] for operation in operations: action, *args = operation.split() if action == \\"ADD\\": item_name = args[0] quantity = int(args[1]) results.append(inv.add_item(item_name, quantity)) elif action == \\"UPDATE\\": item_name = args[0] quantity = int(args[1]) results.append(inv.update_item(item_name, quantity)) elif action == \\"ORDER\\": item_name = args[0] quantity = int(args[1]) results.append(inv.process_order(item_name, quantity)) return results def main(input_data): Main function to simulate the inventory system based on the input operations. Args: input_data (str): The input data consisting of multiple lines of operations. Returns: str: The results of the processed operations. >>> main('''ADD burger 10 ADD fries 5 ORDER burger 3 ORDER fries 6 UPDATE fries 10 ORDER fries 6 ADD drink 8 ORDER drink 2 ADD burger 5 UPDATE salad 4 ORDER salad 1 EOF''') 'OKnOKnOKnOrder cannot be processednOKnOKnOKnOKnItem already existsnItem does not existnOrder cannot be processed' operations = input_data.strip().split(\\"n\\") results = process_operations(operations) return \\"n\\".join(results)","solution":"class Inventory: def __init__(self): self.stock = {} def add_item(self, item_name, quantity): if item_name in self.stock: return \\"Item already exists\\" else: self.stock[item_name] = quantity return \\"OK\\" def update_item(self, item_name, quantity): if item_name not in self.stock: return \\"Item does not exist\\" else: self.stock[item_name] = quantity return \\"OK\\" def process_order(self, item_name, quantity): if item_name not in self.stock or self.stock[item_name] < quantity: return \\"Order cannot be processed\\" else: self.stock[item_name] -= quantity return \\"OK\\" def process_operations(operations): inv = Inventory() results = [] for operation in operations: action, *args = operation.split() if action == \\"ADD\\": item_name = args[0] quantity = int(args[1]) results.append(inv.add_item(item_name, quantity)) elif action == \\"UPDATE\\": item_name = args[0] quantity = int(args[1]) results.append(inv.update_item(item_name, quantity)) elif action == \\"ORDER\\": item_name = args[0] quantity = int(args[1]) results.append(inv.process_order(item_name, quantity)) return results def main(input_data): operations = input_data.strip().split(\\"n\\") results = process_operations(operations) return \\"n\\".join(results)"},{"question":"def count_submatrices_with_sum(n, m, k, matrix, a, b): Find the number of submatrices (of size a x b) within the given matrix such that the sum of all elements in the submatrix is equal to a given integer k. Args: n (int): number of rows in the matrix m (int): number of columns in the matrix k (int): target sum matrix (List[List[int]]): the given matrix a (int): number of rows in the submatrix b (int): number of columns in the submatrix Returns: int: the number of submatrices with the sum of k Examples: >>> count_submatrices_with_sum(3, 4, 10, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]], 2, 2) 0 >>> count_submatrices_with_sum(2, 2, 1, [[1, 1], [1, 1]], 1, 1) 4 >>> count_submatrices_with_sum(3, 3, 100, [[1, 2, 3], [4, 5, 6], [7, 8, 9]], 2, 2) 0 >>> count_submatrices_with_sum(2, 2, 10, [[1, 2], [3, 4]], 2, 2) 1 >>> count_submatrices_with_sum(3, 3, 7, [[1, 1, 1], [1, 4, 1], [1, 1, 1]], 2, 2) 4 >>> count_submatrices_with_sum(4, 4, 15, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 2, 2) 0","solution":"def count_submatrices_with_sum(n, m, k, matrix, a, b): count = 0 for i in range(n - a + 1): for j in range(m - b + 1): submatrix_sum = sum(matrix[x][y] for x in range(i, i + a) for y in range(j, j + b)) if submatrix_sum == k: count += 1 return count"},{"question":"def can_attend_meetings(intervals): Determine if a person can attend all the meetings without overlap. Args: intervals (list of tuples): List of tuples where each tuple contains two integers (start, end). Returns: bool: True if a person can attend all the meetings without overlap, otherwise False. >>> can_attend_meetings([(1, 3), (3, 5), (5, 8)]) True >>> can_attend_meetings([(1, 3), (2, 4), (5, 8)]) False","solution":"def can_attend_meetings(intervals): Determine if a person can attend all the meetings without overlap. Args: intervals (list of tuples): List of tuples where each tuple contains two integers (start, end). Returns: bool: True if a person can attend all the meetings without overlap, otherwise False. # Sort intervals by start time intervals.sort() # Check for any overlap for i in range(1, len(intervals)): if intervals[i][0] < intervals[i - 1][1]: return False return True"},{"question":"def perform_operations(M: int, P: int, operations: List[Tuple[int, int]]) -> List[int]: Given an initial integer sequence from 1 to M, perform a series of operations and return the final state of the sequence. Each operation modifies two elements of the sequence simultaneously, replacing them with their sum and their absolute difference, respectively. >>> perform_operations(5, 3, [(1, 2), (3, 4), (2, 5)]) [3, 6, 7, 1, 4] >>> perform_operations(2, 1, [(1, 2)]) [3, 1] >>> perform_operations(4, 2, [(1, 2), (3, 4)]) [3, 1, 7, 1] >>> perform_operations(3, 0, []) [1, 2, 3] >>> perform_operations(100, 1, [(1, 100)]) [101, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 99]","solution":"def perform_operations(M, P, operations): sequence = list(range(1, M + 1)) for idx1, idx2 in operations: idx1 -= 1 # convert to 0-based index idx2 -= 1 # convert to 0-based index sum_val = sequence[idx1] + sequence[idx2] abs_diff_val = abs(sequence[idx1] - sequence[idx2]) sequence[idx1] = sum_val sequence[idx2] = abs_diff_val return sequence"},{"question":"import re def tone_down_excitement(message): Replaces multiple consecutive exclamation marks with a single exclamation mark. Parameters: message (str): The input message string. Returns: str: The toned down message string. >>> tone_down_excitement(\\"Hi there!!!! How are you doing today?!! I was thinking we could go to the park!!! It's such a nice day!!!!\\") \\"Hi there! How are you doing today?! I was thinking we could go to the park! It's such a nice day!\\" >>> tone_down_excitement(\\"!!!\\") \\"!\\" >>> tone_down_excitement(\\"Hi there!\\") \\"Hi there!\\" >>> tone_down_excitement(\\"Wow!! That was amazing!!! Right?!!\\") \\"Wow! That was amazing! Right?!\\"","solution":"import re def tone_down_excitement(message): Replaces multiple consecutive exclamation marks with a single exclamation mark. Parameters: message (str): The input message string. Returns: str: The toned down message string. # Use regex to replace consecutive exclamation marks with a single exclamation mark return re.sub(r'!{2,}', '!', message)"},{"question":"def matrix_diagonal_sum(matrix: list) -> int: Returns the sum of the elements along the main diagonal of a square matrix. :param matrix: List of lists where each inner list represents a row in the matrix. :return: Sum of the main diagonal elements. >>> matrix_diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 15 >>> matrix_diagonal_sum([[10, 20], [30, 40]]) 50","solution":"def matrix_diagonal_sum(matrix: list) -> int: Returns the sum of the elements along the main diagonal of a square matrix. :param matrix: List of lists where each inner list represents a row in the matrix. :return: Sum of the main diagonal elements. # Number of rows (and columns since it's square) n = len(matrix) # Calculate sum of the main diagonal elements diagonal_sum = 0 for i in range(n): diagonal_sum += matrix[i][i] return diagonal_sum"},{"question":"def can_consume_all_potions(t: int, test_cases: list) -> list: Determine if Zoey can consume all potions without her strength becoming negative. Args: t: Number of test cases. test_cases: A list of tuples, each containing an integer n and a list of integers representing potion effects. Returns: A list of strings where each element is \\"YES\\" if Zoey can consume all the potions without her strength becoming negative, otherwise \\"NO\\". Examples: >>> can_consume_all_potions(2, [(5, [4, -1, -3, 2, -2]), (3, [10, -10, -1])]) ['YES', 'NO'] >>> can_consume_all_potions(1, [(3, [1, 2, 3])]) ['YES']","solution":"def can_consume_all_potions(t, test_cases): results = [] for i in range(t): n, potions = test_cases[i] potions.sort(reverse=True) strength = 0 possible = True for potion in potions: strength += potion if strength < 0: possible = False break if possible: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def check_divisibility_or_product(X: int, Y: int) -> int: Determines if X is divisible by Y. If it is, returns the result of X divided by Y. Otherwise, returns the product of X and Y. >>> check_divisibility_or_product(15, 3) 5 >>> check_divisibility_or_product(14, 3) 42","solution":"def check_divisibility_or_product(X, Y): Determines if X is divisible by Y. If it is, returns the result of X divided by Y. Otherwise, returns the product of X and Y. if X % Y == 0: return X // Y else: return X * Y # Example usage: # X, Y = map(int, input().split()) # print(check_divisibility_or_product(X, Y))"},{"question":"def longest_arith_seq_length(arr: List[int]) -> int: Returns the length of the longest subsequence of the array that forms an arithmetic progression. >>> longest_arith_seq_length([1, 7, 10, 15, 27, 29]) 3 >>> longest_arith_seq_length([5, 10, 15, 20, 25]) 5 def solve_problem(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Solves the problem for the given number of test cases and their arrays. Returns a list containing the results for each test case. >>> solve_problem(2, [(6, [1, 7, 10, 15, 27, 29]), (5, [5, 10, 15, 20, 25])]) [3, 5] >>> solve_problem(1, [(4, [3, 6, 9, 12])]) [4] from solution import longest_arith_seq_length, solve_problem def test_longest_arith_seq_length_basic(): assert longest_arith_seq_length([1, 7, 10, 15, 27, 29]) == 3 assert longest_arith_seq_length([5, 10, 15, 20, 25]) == 5 def test_longest_arith_seq_length_single_element(): assert longest_arith_seq_length([42]) == 1 def test_longest_arith_seq_length_all_same(): assert longest_arith_seq_length([7, 7, 7, 7, 7, 7]) == 6 def test_solve_problem(): test_cases = [ (6, [1, 7, 10, 15, 27, 29]), (5, [5, 10, 15, 20, 25]) ] results = solve_problem(2, test_cases) assert results == [3, 5] def test_solve_problem_single_test_case(): test_cases = [ (4, [3, 6, 9, 12]) ] results = solve_problem(1, test_cases) assert results == [4] def test_solve_problem_edge_case(): test_cases = [ (3, [10, 20, 30]) ] results = solve_problem(1, test_cases) assert results == [3]","solution":"def longest_arith_seq_length(arr): Returns the length of the longest subsequence of the array that forms an arithmetic progression. if len(arr) <= 1: return len(arr) dp = [{} for _ in range(len(arr))] max_length = 2 for i in range(len(arr)): for j in range(i): diff = arr[i] - arr[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 max_length = max(max_length, dp[i][diff]) return max_length def solve_problem(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] arr = test_cases[i][1] result = longest_arith_seq_length(arr) results.append(result) return results"},{"question":"def minimum_swaps_to_sort(arr: List[int]) -> int: Determine the minimum number of swap operations required to transform a sequence into a non-decreasing sequence. >>> minimum_swaps_to_sort([3, 1, 2]) 2 >>> minimum_swaps_to_sort([5, 4, 3, 2, 1]) 10 >>> minimum_swaps_to_sort([1, 2, 3, 4]) 0 :param arr: List of integers :return: Minimum number of swaps required","solution":"def merge_sort_and_count(arr, temp_arr, left, right): if left >= right: return 0 mid = (left + right) // 2 inv_count = merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count def merge_and_count(arr, temp_arr, left, mid, right): i = left j = mid + 1 k = left inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid - i + 1) j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def minimum_swaps_to_sort(arr): n = len(arr) temp_arr = [0]*n return merge_sort_and_count(arr, temp_arr, 0, n-1)"},{"question":"def maxDifference(nums): Given an array of integers nums, return the maximum difference between any two elements nums[i] and nums[j] (i != j) such that nums[j] is to the right of nums[i]. Parameters: nums (List[int]): An array of integers. Returns: int: The maximum difference between any two elements where the second element comes after the first. Example: >>> maxDifference([4, 3, 10, 2, 9, 1]) 7 >>> maxDifference([5, 1, 2, 10, 6, 4]) 9","solution":"def maxDifference(nums): Returns the maximum difference between any two elements nums[i] and nums[j] such that nums[j] is to the right of nums[i]. min_value = nums[0] max_diff = 0 for num in nums[1:]: if num - min_value > max_diff: max_diff = num - min_value if num < min_value: min_value = num return max_diff"},{"question":"from typing import List, Tuple def optimal_distribution_center(test_cases: List[List[Tuple[int, int]]]) -> List[Tuple[int, int]]: Determine the optimal coordinates (R, S) for the first distribution center such that the sum of Euclidean distances from the center to all the warehouses is minimized. Args: test_cases: A list of test cases, each containing a list of warehouse coordinates (A, B). Returns: A list containing the optimal coordinates (R, S) for each test case. Example: >>> optimal_distribution_center([[(1, 1), (2, 2), (3, 3)], [(0, 0), (10, 10), (5, 5), (-5, -5)]]) [(2, 2), (5, 5)]","solution":"def optimal_distribution_center(test_cases): results = [] for warehouses in test_cases: x_coords = [x for x, y in warehouses] y_coords = [y for x, y in warehouses] x_coords.sort() y_coords.sort() median_x = x_coords[len(x_coords) // 2] median_y = y_coords[len(y_coords) // 2] results.append((median_x, median_y)) return results"},{"question":"def select_portals(n: int, p: int, edges: List[Tuple[int, int, int]], m: int) -> List[Tuple[int, int, int]]: Select \`m\` portals to keep within the network such that all locations remain reachable, while minimizing the maximum teleportation time among the selected portals. Parameters: n (int): Number of locations. p (int): Number of transportation portals. edges (List[Tuple[int, int, int]]): List of portals described by tuples (u, v, t). m (int): Number of portals to keep. Returns: List[Tuple[int, int, int]]: Selected portals. >>> select_portals(4, 5, [(1, 2, 5), (1, 3, 4), (2, 3, 2), (3, 4, 3), (2, 4, 7)], 3) [(1, 3, 4), (2, 3, 2), (3, 4, 3)] >>> select_portals(3, 3, [(1, 2, 8), (2, 3, 6), (1, 3, 7)], 2) [(1, 3, 7), (2, 3, 6)] import pytest from solution import select_portals def test_example_1(): n = 4 p = 5 edges = [ (1, 2, 5), (1, 3, 4), (2, 3, 2), (3, 4, 3), (2, 4, 7) ] m = 3 result = select_portals(n, p, edges, m) assert len(result) == 3 assert sorted(result) == [(1, 3, 4), (2, 3, 2), (3, 4, 3)] def test_example_2(): n = 3 p = 3 edges = [ (1, 2, 8), (2, 3, 6), (1, 3, 7) ] m = 2 result = select_portals(n, p, edges, m) assert len(result) == 2 assert sorted(result) == [(1, 3, 7), (2, 3, 6)] def test_minimum_span(): n = 5 p = 6 edges = [ (1, 2, 3), (2, 3, 1), (3, 4, 6), (4, 5, 2), (1, 5, 5), (2, 4, 4) ] m = 4 result = select_portals(n, p, edges, m) assert len(result) == 4 assert sorted(result) in [ [(1, 2, 3), (2, 3, 1), (3, 4, 6), (4, 5, 2)], [(1, 2, 3), (2, 3, 1), (2, 4, 4), (4, 5, 2)] ] def test_large_network(): n = 4 p = 4 edges = [ (1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4) ] m = 3 result = select_portals(n, p, edges, m) assert len(result) == 3 assert sorted(result) in [ [(1, 2, 1), (2, 3, 2), (3, 4, 3)], [(1, 2, 1), (2, 3, 2), (4, 1, 4)] ]","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def select_portals(n, p, edges, m): edges.sort(key=lambda x: x[2]) parent = [i for i in range(n+1)] rank = [0] * (n+1) selected_edges = [] # Modified Kruskal's algorithm to get \`n-1\` initially selected_count = 0 for u, v, t in edges: if selected_count == n - 1: break root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: selected_edges.append((u, v, t)) union(parent, rank, root_u, root_v) selected_count += 1 # Now add additional \`m - (n - 1)\` edges to make total \`m\` for u, v, t in edges: if len(selected_edges) == m: break # Ensure we do not add duplicates or those already included if (u, v, t) not in selected_edges and (v, u, t) not in selected_edges: selected_edges.append((u, v, t)) return selected_edges"},{"question":"def is_valid_number(s: str) -> bool: Determines if the given string is a valid number. >>> is_valid_number(\\"0\\") == True >>> is_valid_number(\\" 0.1 \\") == True >>> is_valid_number(\\"abc\\") == False >>> is_valid_number(\\"1 a\\") == False >>> is_valid_number(\\"2e10\\") == True >>> is_valid_number(\\" -90e3 \\") == True >>> is_valid_number(\\" 1e\\") == False >>> is_valid_number(\\"e3\\") == False >>> is_valid_number(\\" 6e-1\\") == True >>> is_valid_number(\\" 99e2.5 \\") == False >>> is_valid_number(\\" 53.5e93\\") == True >>> is_valid_number(\\" --6 \\") == False >>> is_valid_number(\\"-+3\\") == False >>> is_valid_number(\\"95a54e53\\") == False from solution import is_valid_number def test_valid_integer(): assert is_valid_number(\\"0\\") == True assert is_valid_number(\\"-10\\") == True assert is_valid_number(\\"12345\\") == True def test_valid_float(): assert is_valid_number(\\"0.1\\") == True assert is_valid_number(\\".1\\") == True assert is_valid_number(\\"1.\\") == True assert is_valid_number(\\"-0.5\\") == True def test_valid_exponential(): assert is_valid_number(\\"2e10\\") == True assert is_valid_number(\\" -90e3 \\") == True assert is_valid_number(\\" 6e-1\\") == True assert is_valid_number(\\"53.5e93\\") == True def test_invalid_strings(): assert is_valid_number(\\"abc\\") == False assert is_valid_number(\\"1 a\\") == False assert is_valid_number(\\"e3\\") == False assert is_valid_number(\\" 1e\\") == False assert is_valid_number(\\" 99e2.5 \\") == False assert is_valid_number(\\" --6 \\") == False assert is_valid_number(\\"-+3\\") == False assert is_valid_number(\\"95a54e53\\") == False def test_with_whitespace(): assert is_valid_number(\\" 0.1 \\") == True assert is_valid_number(\\" 123 \\") == True assert is_valid_number(\\" 1e20 \\") == True assert is_valid_number(\\" \\") == False","solution":"def is_valid_number(s): Determines if the given string is a valid number. s = s.strip() try: float(s) return True except ValueError: return False"},{"question":"def generateBeautifulSequence(n: int) -> List[int]: Generates a beautiful sequence of length n such that the sum of the sequence is maximized. >>> generateBeautifulSequence(5) [2, 3, 2, 3, 2] >>> generateBeautifulSequence(6) [2, 3, 2, 3, 2, 3] >>> generateBeautifulSequence(1) [1] >>> generateBeautifulSequence(2) [2, 3]","solution":"def generateBeautifulSequence(n): Generates a beautiful sequence of length n such that the sum of the sequence is maximized. # The pattern [2, 3, 2, 3, ...] maximizes the sum for sequences of odd and even lengths. if n == 1: return [1] # Edge case when n is 1, the only possible sequence is [1] sequence = [] for i in range(n): if i % 2 == 0: sequence.append(2) else: sequence.append(3) return sequence"},{"question":"def hasPairWithSum(arr, n, k): Determines if there are two distinct elements in array arr such that their sum is equal to k. :param arr: List[int] -- the list of integers :param n: int -- the length of the array :param k: int -- the target sum :return: bool -- True if there is a pair with the sum equal to k, else False >>> hasPairWithSum([1, 2, 3, 9, 11], 5, 10) True >>> hasPairWithSum([1, 2, 4, 4], 4, 8) True >>> hasPairWithSum([5, 6, 7], 3, 20) False >>> hasPairWithSum([2, 2, 2, 2], 4, 4) True >>> hasPairWithSum([-3, 1, 4, -1], 4, 0) True >>> hasPairWithSum([-3, -1, 2, 4, 5], 5, 1) True >>> hasPairWithSum([100000, 99995, 5, -100000], 4, 0) True >>> hasPairWithSum([100000, 99995, 5, -100000], 4, 1) False >>> hasPairWithSum([5, 5, 5, 5], 4, 10) True >>> hasPairWithSum([], 0, 10) False","solution":"def hasPairWithSum(arr, n, k): Determines if there are two distinct elements in array arr such that their sum is equal to k. :param arr: List[int] -- the list of integers :param n: int -- the length of the array :param k: int -- the target sum :return: bool -- True if there is a pair with the sum equal to k, else False seen = set() for num in arr: if k - num in seen: return True seen.add(num) return False"},{"question":"def max_efficiency(n: int, grid: List[List[int]]) -> int: Returns the maximum possible efficiency of any route from the top-left to the bottom-right corner of the grid. >>> max_efficiency(3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 29 >>> max_efficiency(2, [ ... [10, 5], ... [3, 6] ... ]) 21","solution":"def max_efficiency(n, grid): Returns the maximum possible efficiency of any route from the top-left to the bottom-right corner of the grid. # Create a dp table to store the maximum efficiency values dp = [[0] * n for _ in range(n)] # Initialize the start point dp[0][0] = grid[0][0] # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill in the rest of the dp table for i in range(1, n): for j in range(1, n): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The bottom-right corner contains the maximum possible efficiency return dp[n - 1][n - 1]"},{"question":"def flowerSum(n, m, garden, k, queries): Calculate the total number of flowers in specified rectangular regions of a garden. Args: n: an integer representing the number of rows in the garden. m: an integer representing the number of columns in the garden. garden: a 2D list representing the garden where each cell contains the number of flowers. k: an integer representing the number of queries. queries: a list of tuples where each tuple contains four integers (x1, y1, x2, y2) representing the top-left and bottom-right corners of the rectangular region. Returns: A list of integers where the ith value is the answer to the ith query. >>> n = 3 >>> m = 3 >>> garden = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> k = 2 >>> queries = [(0, 0, 1, 1), (1, 1, 2, 2)] >>> flowerSum(n, m, garden, k, queries) [12, 28] >>> n = 2 >>> m = 2 >>> garden = [[10, 20], [30, 40]] >>> k = 1 >>> queries = [(0, 0, 1, 1)] >>> flowerSum(n, m, garden, k, queries) [100] >>> n = 3 >>> m = 3 >>> garden = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> k = 1 >>> queries = [(0, 0, 2, 2)] >>> flowerSum(n, m, garden, k, queries) [45] >>> n = 3 >>> m = 3 >>> garden = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> k = 3 >>> queries = [(0, 0, 0, 0), (1, 1, 1, 1), (2, 2, 2, 2)] >>> flowerSum(n, m, garden, k, queries) [1, 5, 9]","solution":"def flowerSum(n, m, garden, k, queries): result = [] for x1, y1, x2, y2 in queries: total = sum( garden[i][j] for i in range(x1, x2 + 1) for j in range(y1, y2 + 1) ) result.append(total) return result"},{"question":"def hex_to_signed_decimal(hex_string): Converts an 8-character string representing a signed 32-bit hexadecimal number to its decimal value. >>> hex_to_signed_decimal(\\"FFFFFFFF\\") -1 >>> hex_to_signed_decimal(\\"00000001\\") 1 >>> hex_to_signed_decimal(\\"70000000\\") 1879048192 >>> hex_to_signed_decimal(\\"80000000\\") -2147483648 # Implement this function to convert the given hexadecimal string to a signed 32-bit integer def process_input(input_lines): Processes multiple lines of input, converting each line until \\"END\\" is encountered. >>> process_input([\\"FFFFFFFF\\", \\"00000001\\", \\"70000000\\", \\"80000000\\", \\"END\\"]) [-1, 1, 1879048192, -2147483648] >>> process_input([\\"00000000\\", \\"7FFFFFFF\\", \\"FFFFFFFE\\", \\"FFFFFFFD\\", \\"END\\"]) [0, 2147483647, -2, -3] # Implement this function to process the input and return the correct list of results import pytest def test_hex_to_signed_decimal(): # Test cases from the prompt assert hex_to_signed_decimal(\\"FFFFFFFF\\") == -1 assert hex_to_signed_decimal(\\"00000001\\") == 1 assert hex_to_signed_decimal(\\"70000000\\") == 1879048192 assert hex_to_signed_decimal(\\"80000000\\") == -2147483648 # Additional test cases assert hex_to_signed_decimal(\\"00000000\\") == 0 assert hex_to_signed_decimal(\\"7FFFFFFF\\") == 2147483647 assert hex_to_signed_decimal(\\"FFFFFFFE\\") == -2 assert hex_to_signed_decimal(\\"FFFFFFFD\\") == -3 def test_process_input(): input_lines = [ \\"FFFFFFFF\\", \\"00000001\\", \\"70000000\\", \\"80000000\\", \\"END\\" ] expected_output = [-1, 1, 1879048192, -2147483648] assert process_input(input_lines) == expected_output input_lines = [ \\"00000000\\", \\"7FFFFFFF\\", \\"FFFFFFFE\\", \\"FFFFFFFD\\", \\"END\\" ] expected_output = [0, 2147483647, -2, -3] assert process_input(input_lines) == expected_output if __name__ == \\"__main__\\": pytest.main()","solution":"def hex_to_signed_decimal(hex_string): Converts an 8-character string representing a signed 32-bit hexadecimal number to its decimal value. # Convert hexadecimal string to a number, considering it might be signed num = int(hex_string, 16) # Check if the number is negative in 32-bit signed integer if num >= 0x80000000: return num - 0x100000000 return num def process_input(input_lines): Processes multiple lines of input, converting each line until \\"END\\" is encountered. result = [] for line in input_lines: if line.strip() == \\"END\\": break result.append(hex_to_signed_decimal(line.strip())) return result"},{"question":"def bit_flips(x: int, y: int) -> int: Determine the minimum number of bit flips to convert integer x to integer y. Args: x (int): The first non-negative integer. y (int): The second non-negative integer. Returns: int: The minimum number of bit flips needed to convert x to y. Examples: >>> bit_flips(5, 9) 2 >>> bit_flips(11, 3) 1","solution":"def bit_flips(x, y): Returns the minimum number of bit flips required to convert integer x to integer y. # XOR of x and y will give bits that are different xor_result = x ^ y # Count the number of 1's in the binary representation of the xor result return bin(xor_result).count('1')"},{"question":"def decode_message(encoded: str) -> str: Takes an encoded string and decodes it back to its original form. >>> decode_message(\\"3a3b2c1d2a\\") \\"aaabbbccdaa\\" >>> decode_message(\\"1a1b1c1d1e\\") \\"abcde\\" >>> decode_message(\\"5m3n\\") \\"mmmmmnnn\\"","solution":"def decode_message(encoded): Takes an encoded string and decodes it to its original form. :param encoded: The encoded string :return: The decoded original message import re # Split the encoded string into parts of digits and characters parts = re.findall(r'(d+)([a-z])', encoded) decoded_message = ''.join(int(num) * char for num, char in parts) return decoded_message"},{"question":"def number_of_distinct_points(N: int) -> int: Returns the number of distinct grid points the robot can visit in exactly N moves. >>> number_of_distinct_points(1) 4 >>> number_of_distinct_points(2) 8 >>> number_of_distinct_points(3) 16 >>> number_of_distinct_points(10) 2048 >>> number_of_distinct_points(0) 2","solution":"def number_of_distinct_points(N): Returns the number of distinct grid points the robot can visit in exactly N moves return pow(2, N + 1)"},{"question":"def is_magic_square(matrix, n): Check whether the given n x n matrix is a magic square. Args: matrix (List[List[int]]): 2D list representing the magical square elements. n (int): Size of the matrix, an odd positive integer. Returns: int or str: The magic constant if the square is magical, otherwise \\"NOT MAGIC\\". >>> is_magic_square([[8, 1, 6], [3, 5, 7], [4, 9, 2]], 3) 15 >>> is_magic_square([[11, 18, 25, 2, 9], [17, 24, 1, 8, 15], [23, 5, 7, 14, 16], [4, 6, 13, 20, 22], [10, 12, 19, 21, 3]], 5) \\"NOT MAGIC\\" pass def magic_square(n, data): Converts the input data array into an n x n matrix and checks if it is a magic square. Args: n (int): Size of the matrix, an odd positive integer. data (List[int]): Flattened list of integers forming the square matrix. Returns: int or str: The magic constant if the square is magical, otherwise \\"NOT MAGIC\\". matrix = [data[i*n:(i+1)*n] for i in range(n)] return is_magic_square(matrix, n) def test_is_magic_square(): assert magic_square(3, [8, 1, 6, 3, 5, 7, 4, 9, 2]) == 15 assert magic_square(5, [17, 24, 1, 8, 15, 23, 5, 7, 14, 16, 4, 6, 13, 20, 22, 10, 12, 19, 21, 3, 11, 18, 25, 2, 9]) == 65 assert magic_square(5, [11, 18, 25, 2, 9, 17, 24, 1, 8, 15, 23, 5, 7, 14, 16, 4, 6, 13, 20, 22, 10, 12, 19, 21, 3]) == \\"NOT MAGIC\\" assert magic_square(3, [2, 7, 6, 9, 5, 1, 4, 3, 8]) == 15 assert magic_square(3, [4, 9, 2, 3, 5, 7, 8, 1, 5]) == \\"NOT MAGIC\\" assert magic_square(3, [4, 9, 2, 3, 5, 7, 8, 1, 9]) == \\"NOT MAGIC\\" assert magic_square(3, [4, 9, 2, 3, 5, 7, 8, 1, 3]) == \\"NOT MAGIC\\"","solution":"def is_magic_square(matrix, n): magic_constant = sum(matrix[0]) # Check rows for row in matrix: if sum(row) != magic_constant: return \\"NOT MAGIC\\" # Check columns for col in range(n): if sum(matrix[row][col] for row in range(n)) != magic_constant: return \\"NOT MAGIC\\" # Check diagonals if sum(matrix[i][i] for i in range(n)) != magic_constant: return \\"NOT MAGIC\\" if sum(matrix[i][n-i-1] for i in range(n)) != magic_constant: return \\"NOT MAGIC\\" # Check for distinct numbers in range 1 to n^2 elements = set() for row in matrix: for num in row: if num < 1 or num > n * n or num in elements: return \\"NOT MAGIC\\" elements.add(num) return magic_constant def magic_square(n, data): matrix = [data[i*n:(i+1)*n] for i in range(n)] return is_magic_square(matrix, n)"},{"question":"from typing import List def shortest_path(grid: List[str]) -> int: Finds the length of the shortest path from the top-left to the bottom-right of the grid without passing through 'F' cells. Returns -1 if no such path exists. >>> shortest_path([\\"EEEEF\\",\\"EFFFF\\",\\"EEEEE\\",\\"EFEEE\\",\\"EEEFE\\"]) 8 >>> shortest_path([\\"EEF\\",\\"FFF\\",\\"EEE\\"]) -1 >>> shortest_path([\\"E\\"]) 0 >>> shortest_path([\\"F\\"]) -1 >>> shortest_path([\\"EEE\\",\\"EFE\\",\\"EEE\\"]) 4 >>> shortest_path([\\"EEEE\\",\\"FFFE\\",\\"FFFE\\"]) 5","solution":"from collections import deque def shortest_path(grid): H = len(grid) W = len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] if grid[0][0] == 'F' or grid[H-1][W-1] == 'F': return -1 queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() if r == H - 1 and c == W - 1: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < H and 0 <= nc < W and (nr, nc) not in visited and grid[nr][nc] == 'E': visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"def maxProfit(prices, fee): Function to calculate the maximum profit with given prices and transaction fee. Parameters: prices (List[int]): List of prices where \`prices[i]\` is the price on the \`i\`th day. fee (int): The transaction fee. Returns: int: The maximum profit that can be achieved. Example: >>> maxProfit([1, 3, 2, 8, 4, 9], 2) 8 >>> maxProfit([1,3,7,5,10,3], 3) 6","solution":"def maxProfit(prices, fee): Function to calculate the maximum profit with given prices and transaction fee. Parameters: prices (List[int]): List of prices where \`prices[i]\` is the price on the \`i\`th day. fee (int): The transaction fee. Returns: int: The maximum profit that can be achieved. cash, hold = 0, -prices[0] for price in prices[1:]: cash = max(cash, hold + price - fee) hold = max(hold, cash - price) return cash"},{"question":"def mirrorWord(s: str) -> str: Determines if the given string is a Mirror Word. Parameters: s (str): The input string consisting of uppercase alphabetic characters. Returns: str: \\"Mirror!!\\" if the input string is a Mirror Word, otherwise \\"NOT!!\\". >>> mirrorWord(\\"AHA\\") \\"Mirror!!\\" >>> mirrorWord(\\"HELLO\\") \\"NOT!!\\" >>> mirrorWord(\\"MOM\\") \\"Mirror!!\\" >>> mirrorWord(\\"WOW\\") \\"Mirror!!\\" >>> mirrorWord(\\"PYTHON\\") \\"NOT!!\\" >>> mirrorWord(\\"\\") \\"Mirror!!\\"","solution":"def mirrorWord(s): Determines if the given string is a Mirror Word. Parameters: s (str): The input string consisting of uppercase alphabetic characters. Returns: str: \\"Mirror!!\\" if the input string is a Mirror Word, otherwise \\"NOT!!\\". palindrome_chars = set(\\"AHIMOTUVWXY\\") # Check if all characters are in the set of palindrome characters if all(c in palindrome_chars for c in s): # Check if the string is a palindrome if s == s[::-1]: return \\"Mirror!!\\" return \\"NOT!!\\""},{"question":"def find_anagrams(word, candidates): Returns a list of all candidates that are anagrams of the given word. >>> find_anagrams('listen', ['enlist', 'google', 'inlets', 'banana']) == ['enlist', 'inlets'] >>> find_anagrams('cinema', ['iceman', 'anemic', 'angel', 'glean']) == ['iceman', 'anemic'] >>> find_anagrams('a', ['a', 'b', 'c', 'd']) == ['a'] >>> find_anagrams('pears', ['spear', 'parse', 'reaps', 'spare']) == ['spear', 'parse', 'reaps', 'spare']","solution":"def find_anagrams(word, candidates): Returns a list of all candidates that are anagrams of the given word. :param word: str - the word for which we are finding anagrams :param candidates: list of str - a list of candidate words to check :return: list of str - the list of candidate words that are anagrams of the word # Sort the characters of the word for comparison word_sorted = sorted(word) # Compare sorted characters of each candidate with those of the word return [candidate for candidate in candidates if sorted(candidate) == word_sorted]"},{"question":"def is_palindrome(number): Check if a number is a palindrome. def sieve_of_eratosthenes(limit): Generates a list of prime numbers up to 'limit' using the Sieve of Eratosthenes. def palindromic_primes_in_range(a, b): Find palindromic primes within the given range [a, b]. >>> palindromic_primes_in_range(1, 100) [2, 3, 5, 7, 11] >>> palindromic_primes_in_range(10, 50) [11]","solution":"def is_palindrome(number): Check if a number is a palindrome. return str(number) == str(number)[::-1] def sieve_of_eratosthenes(limit): Generates a list of prime numbers up to 'limit' using the Sieve of Eratosthenes. is_prime = [True] * (limit + 1) p = 2 while p * p <= limit: if is_prime[p]: for i in range(p * p, limit + 1, p): is_prime[i] = False p += 1 is_prime[0], is_prime[1] = False, False # 0 and 1 are not prime numbers return [num for num in range(limit + 1) if is_prime[num]] def palindromic_primes_in_range(a, b): Find palindromic primes within the given range [a, b]. primes = sieve_of_eratosthenes(b) return [p for p in primes if p >= a and is_palindrome(p)]"},{"question":"def palindromeNumber(number): Checks if a number is a Palindrome. :param number: The number to check (non-negative integer). :return: True if the number is a palindrome, False otherwise. >>> palindromeNumber(121)  True >>> palindromeNumber(123)  False >>> palindromeNumber(0)  True >>> palindromeNumber(12321)  True >>> palindromeNumber(1001)  True","solution":"def palindromeNumber(number): Checks if a number is a Palindrome. :param number: The number to check (non-negative integer). :return: True if the number is a palindrome, False otherwise. str_number = str(number) return str_number == str_number[::-1]"},{"question":"def productExceptSelf(nums): Returns a new list such that each element at index i of the new list is the product of all the numbers in the original list except the one at i, without using division. >>> productExceptSelf([1, 2, 3, 4]) [24, 12, 8, 6] >>> productExceptSelf([10]) [1] >>> productExceptSelf([1, 2]) [2, 1] >>> productExceptSelf([1, 2, 0, 4]) [0, 0, 8, 0] >>> productExceptSelf([0, 0, 0]) [0, 0, 0] >>> productExceptSelf([-1, -2, -3, -4]) [-24, -12, -8, -6] >>> productExceptSelf([]) [] pass","solution":"def productExceptSelf(nums): Returns a new list such that each element at index i of the new list is the product of all the numbers in the original list except the one at i, without using division. length = len(nums) if length == 0: return [] # Initialize the left and right product arrays and the result array result = [1] * length left_product = [1] * length right_product = [1] * length # Fill the left product array for i in range(1, length): left_product[i] = left_product[i - 1] * nums[i - 1] # Fill the right product array for i in range(length - 2, -1, -1): right_product[i] = right_product[i + 1] * nums[i + 1] # Multiply left and right products to get the final result array for i in range(length): result[i] = left_product[i] * right_product[i] return result"},{"question":"def calculate_bonus(efficiency, punctuality, quality): Calculates the bonus of an employee based on their performance metrics. >>> calculate_bonus(78, 82, 88) 1000 >>> calculate_bonus(76, 81, 70) 800 >>> calculate_bonus(50, 60, 65) 0 def process_employees(T, metrics): Processes the list of employees and calculates the bonus for each. Parameters: - T: number of employees - metrics: list of tuples, each containing (efficiency, punctuality, quality) of an employee Returns: A list of bonuses for each employee. >>> process_employees(3, [(78, 82, 88), (76, 81, 70), (50, 60, 65)]) [1000, 800, 0]","solution":"def calculate_bonus(efficiency, punctuality, quality): Calculates the bonus of an employee based on their performance metrics. condition1 = efficiency > 75 condition2 = punctuality > 80 condition3 = quality > 85 if condition1 and condition2 and condition3: return 1000 elif condition1 and condition2: return 800 elif condition2 and condition3: return 600 elif condition1 and condition3: return 400 elif condition1 or condition2 or condition3: return 200 else: return 0 def process_employees(T, metrics): Processes the list of employees and calculates the bonus for each. Parameters: - T: number of employees - metrics: list of tuples, each containing (efficiency, punctuality, quality) of an employee Returns: A list of bonuses for each employee. bonuses = [] for i in range(T): e, p, q = metrics[i] bonus = calculate_bonus(e, p, q) bonuses.append(bonus) return bonuses"},{"question":"def segment_comments(dictionary, comments): This function takes a dictionary of words and a list of comments, determines if each comment can be segmented into a space-separated sequence of one or more dictionary words, and returns a list of 'YES' or 'NO' for each comment. :param dictionary: List of words in the dictionary. :param comments: List of comments to be checked. :return: List of 'YES' or 'NO' for each comment. >>> dictionary = [\\"hello\\", \\"world\\", \\"apple\\", \\"pie\\", \\"cat\\"] >>> comments = [\\"helloworld\\", \\"applepie\\", \\"applesauce\\"] >>> segment_comments(dictionary, comments) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> dictionary = [\\"hello\\", \\"world\\"] >>> comments = [\\"hello\\", \\"world\\", \\"helloworld\\"] >>> segment_comments(dictionary, comments) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> dictionary = [] >>> comments = [\\"helloworld\\"] >>> segment_comments(dictionary, comments) [\\"NO\\"] >>> dictionary = [\\"hello\\", \\"world\\"] >>> comments = [\\"hellonowworld\\"] >>> segment_comments(dictionary, comments) [\\"NO\\"] >>> dictionary = [\\"a\\", \\"aa\\", \\"aaa\\"] >>> comments = [\\"aaaa\\"] >>> segment_comments(dictionary, comments) [\\"YES\\"]","solution":"def can_segment_comment(word_dict, comment): This function checks if a comment can be segmented into words from the dictionary. :param word_dict: Set of words in the dictionary. :param comment: The comment string to be checked. :return: Returns 'YES' if the comment can be segmented, otherwise 'NO'. n = len(comment) dp = [False] * (n + 1) dp[0] = True for i in range(1, n + 1): for j in range(i): if dp[j] and comment[j:i] in word_dict: dp[i] = True break return \\"YES\\" if dp[n] else \\"NO\\" def segment_comments(dictionary, comments): This function processes multiple comments and returns whether each can be segmented into words from the dictionary. :param dictionary: List of words in the dictionary. :param comments: List of comments to be checked. :return: List of 'YES' or 'NO' for each comment. word_dict = set(dictionary) return [can_segment_comment(word_dict, comment) for comment in comments]"},{"question":"def sequence_operations(n: int, q: int, operations: List[str]) -> List[int]: Perform operations on the sequence and return the maximum value after each operation. :param n: initial length of the sequence :param q: number of operations :param operations: list of operation commands :return: list of maximum values after each operation >>> sequence_operations(3, 8, ['1 5', '1 2', '1 8', '3 2', '4', '2', '2', '4']) [5, 5, 8, 16, 256, 0, 0, 0]","solution":"def sequence_operations(n, q, operations): Perform operations on the sequence and return the maximum value after each operation. :param int n: initial length of the sequence :param int q: number of operations :param list operations: list of operation commands :return: list of maximum values after each operation :rtype: list sequence = [0] * n max_sequence = [0] for operation in operations: if operation[0] == '1': # Insert number x at the end _, x = operation.split() sequence.append(int(x)) elif operation[0] == '2': # Remove the last number if sequence: sequence.pop() elif operation[0] == '3': # Multiply every number by k _, k = operation.split() k = int(k) sequence = [num * k for num in sequence] elif operation[0] == '4': # Square every number in the sequence sequence = [num ** 2 for num in sequence] max_sequence.append(max(sequence) if sequence else 0) return max_sequence[1:]"},{"question":"def transform_and_sort_words(T: int, test_cases: List[Tuple[int, List[str], int, List[str]]]) -> List[List[str]]: Apply transformations to each word in the list and then sort the transformed words lexicographically. Args: T : int : number of test cases test_cases : List[Tuple[int, List[str], int, List[str]]] : list of tuples containing the number of words, the words themselves, the number of transformations, and the transformation rules. Returns: List[List[str]] : For each test case, return the sorted list of transformed words. Example: >>> transform_and_sort_words(1, [(3, ['cat', 'bat', 'rat'], 2, ['a o', 't r'])]) [['bor', 'cor', 'ror']] >>> transform_and_sort_words(2, [(3, ['cat', 'bat', 'rat'], 2, ['a o', 't r']), (2, ['dog', 'cat'], 1, ['d b'])]) [['bor', 'cor', 'ror'], ['bog', 'cat']] pass from solution import transform_and_sort_words def test_single_case(): T = 1 test_cases = [ (3, ['cat', 'bat', 'rat'], 2, ['a o', 't r']) ] result = transform_and_sort_words(T, test_cases) expected = [['bor', 'cor', 'ror']] assert result == expected def test_multiple_cases(): T = 2 test_cases = [ (3, ['cat', 'bat', 'rat'], 2, ['a o', 't r']), (2, ['dog', 'cat'], 1, ['d b']) ] result = transform_and_sort_words(T, test_cases) expected = [['bor', 'cor', 'ror'], ['bog', 'cat']] assert result == expected def test_no_transformation_rule(): T = 1 test_cases = [ (2, ['apple', 'banana'], 0, []) ] result = transform_and_sort_words(T, test_cases) expected = [['apple', 'banana']] assert result == expected def test_empty_word_list(): T = 1 test_cases = [ (0, [], 1, ['a o']) ] result = transform_and_sort_words(T, test_cases) expected = [[]] assert result == expected def test_all_same_words(): T = 1 test_cases = [ (3, ['aaa', 'aaa', 'aaa'], 1, ['a b']) ] result = transform_and_sort_words(T, test_cases) expected = [['bbb', 'bbb', 'bbb']] assert result == expected","solution":"def transform_and_sort_words(T, test_cases): all_results = [] for case in test_cases: M, words, N, rules = case transformation_map = {} # Build the transformation map for rule in rules: X, Y = rule.split() transformation_map[X] = Y # Transform words transformed_words = [] for word in words: transformed_word = ''.join(transformation_map.get(char, char) for char in word) transformed_words.append(transformed_word) # Sort the transformed words transformed_words.sort() all_results.append(transformed_words) return all_results"},{"question":"def find_mode(n: int, read_counts: List[int]) -> int: Find the mode of the daily read counts for each book. If multiple books have the same read count, the mode must be the smallest book ID among those with the highest frequency read count. Parameters: n (int): The number of books in the library. read_counts (List[int]): List of integers representing the daily read counts of each book. Returns: int: The book ID of the mode of the read counts. Examples: >>> find_mode(5, [3, 3, 2, 2, 2]) 2 >>> find_mode(1, [1]) 1 >>> find_mode(3, [1, 2, 3]) 1 >>> find_mode(6, [2, 2, 3, 3, 1, 1]) 1 >>> find_mode(4, [9999, 10000, 10000, 9999]) 9999 >>> find_mode(4, [1, 1, 1, 1]) 1 from typing import List def test_example_case(): assert find_mode(5, [3, 3, 2, 2, 2]) == 2 def test_single_book(): assert find_mode(1, [1]) == 1 def test_all_different_counts(): assert find_mode(3, [1, 2, 3]) == 1 def test_multiple_high_frequencies(): assert find_mode(6, [2, 2, 3, 3, 1, 1]) == 1 def test_large_values(): assert find_mode(4, [9999, 10000, 10000, 9999]) == 9999 def test_all_same_counts(): assert find_mode(4, [1, 1, 1, 1]) == 1","solution":"def find_mode(n, read_counts): from collections import Counter # Count the frequency of each read count count_map = Counter(read_counts) # Find the maximum frequency max_freq = max(count_map.values()) # Filter the read_counts that have the maximum frequency candidates = [read_count for read_count, freq in count_map.items() if freq == max_freq] # Retrieve the smallest book ID with the highest frequency min_read_count = min(candidates) return min_read_count"},{"question":"def count_consecutive_sum_ways(n: int) -> int: Returns the number of ways n can be expressed as a sum of consecutive positive integers. >>> count_consecutive_sum_ways(15) 4 >>> count_consecutive_sum_ways(10) 2 >>> count_consecutive_sum_ways(1) 1 def count_ways_for_multiple_cases(test_cases: List[int]) -> List[int]: Returns a list of results for multiple test cases, where each result is the number of ways the input integer n can be written as a sum of consecutive positive integers. >>> count_ways_for_multiple_cases([15, 10, 1]) [4, 2, 1]","solution":"def count_consecutive_sum_ways(n): Returns the number of ways n can be expressed as a sum of consecutive positive integers. count = 0 L = 1 while L * (L + 1) // 2 < n: if (n - L * (L + 1) // 2) % (L + 1) == 0: count += 1 L += 1 return count + 1 def count_ways_for_multiple_cases(test_cases): results = [] for n in test_cases: results.append(count_consecutive_sum_ways(n)) return results"},{"question":"def is_prime(n: int) -> bool: Check if a number n is a prime number. >>> is_prime(1) False >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True def filter_primes(numbers: List[int]) -> List[int]: Given a list of integers, return a list with only the prime numbers. >>> filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> filter_primes([1, 11, 13, 15, 17, 19, 21, 23, 25]) [11, 13, 17, 19, 23]","solution":"def is_prime(n): Check if a number n is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(numbers): Given a list of integers, return a list with only the prime numbers. return [num for num in numbers if is_prime(num)]"},{"question":"from typing import List def check_winner(board: List[List[str]]) -> str: Determining the current status of a tic-tac-toe game. Args: board (List[List[str]]): A 3x3 grid representing the current state of the game, with 'X', 'O', or empty (' ') cells. Returns: str: Game status: - \\"X wins\\" if X has won the game - \\"O wins\\" if O has won the game - \\"Draw\\" if the board is full and there is no winner - \\"Incomplete\\" if the game is still in progress with empty cells but no winner yet Examples: >>> check_winner([ ... ['X', 'X', 'X'], ... ['O', ' ', ' '], ... ['O', ' ', ' '] ... ]) 'X wins' >>> check_winner([ ... ['O', 'X', 'X'], ... ['O', ' ', ' '], ... ['O', ' ', 'X'] ... ]) 'O wins' >>> check_winner([ ... ['X', 'O', ' '], ... ['O', 'X', ' '], ... [' ', ' ', 'X'] ... ]) 'X wins' >>> check_winner([ ... ['X', ' ', 'O'], ... [' ', 'O', 'X'], ... ['O', 'X', ' '] ... ]) 'O wins' >>> check_winner([ ... ['X', 'O', 'X'], ... ['O', 'X', 'X'], ... ['O', 'X', 'O'] ... ]) 'Draw' >>> check_winner([ ... ['X', 'O', 'X'], ... [' ', 'X', 'O'], ... ['O', ' ', ' '] ... ]) 'Incomplete'","solution":"from typing import List def check_winner(board: List[List[str]]) -> str: # Check all rows and columns for i in range(3): if board[i][0] == board[i][1] == board[i][2] != ' ': return f\\"{board[i][0]} wins\\" if board[0][i] == board[1][i] == board[2][i] != ' ': return f\\"{board[0][i]} wins\\" # Check both diagonals if board[0][0] == board[1][1] == board[2][2] != ' ': return f\\"{board[0][0]} wins\\" if board[0][2] == board[1][1] == board[2][0] != ' ': return f\\"{board[0][2]} wins\\" # Check for draw or incomplete for row in board: if ' ' in row: return \\"Incomplete\\" return \\"Draw\\""},{"question":"def max_movies(test_cases: List[Dict[str, List[Tuple[int, int]]]]) -> List[int]: Calculate the maximum number of movies that can be watched given their start times and durations. Args: test_cases: A list of test cases, each containing a dictionary with movie details where key 'movies' has a list of tuples (start time, duration). Returns: A list of integers where each integer represents the maximum number of movies that can be watched for the respective test case. Example: >>> max_movies([{'movies': [(1, 3), (2, 2), (4, 1)]}, {'movies': [(0, 5), (3, 3), (6, 1), (8, 2)]}]) [2, 3] >>> max_movies([{'movies': [(0, 3), (3, 3), (6, 3)]}, {'movies': [(0, 1), (1, 1), (2, 1), (3, 1)]}]) [3, 4]","solution":"def max_movies(test_cases): results = [] for case in test_cases: movies = case['movies'] movies.sort(key=lambda x: x[0] + x[1]) end_time = 0 count = 0 for start, duration in movies: if start >= end_time: count += 1 end_time = start + duration results.append(count) return results"},{"question":"def check_parity(nums: List[int]) -> str: Checks if the list of integers contains an equal number of even and odd numbers. Args: nums (list of int): List of integers. Returns: str: \\"YES\\" if the list contains an equal number of even and odd integers, otherwise \\"NO\\". >>> check_parity([1, 2, 3, 4]) 'YES' >>> check_parity([1, 2, 3]) 'NO'","solution":"def check_parity(nums): Checks if the list of integers contains an equal number of even and odd numbers. Args: nums (list of int): List of integers. Returns: str: \\"YES\\" if the list contains an equal number of even and odd integers, otherwise \\"NO\\". even_count = sum(1 for num in nums if num % 2 == 0) odd_count = len(nums) - even_count # Total count minus even count return \\"YES\\" if even_count == odd_count else \\"NO\\""},{"question":"def preprocess_segments(data_points, k): Preprocess the data points into k segments and sort each segment. pass def compute_prefix_sums(sorted_data_points): Compute prefix sums for the sorted data points to facilitate range queries. pass def range_query(prefix_sums, left, right): Compute the sum of the data points in the range [left, right]. pass def range_query_solution(n, k, q, data_points, queries): Solve the range query problem. Parameters: n (int): the number of data points k (int): the number of segments q (int): the number of queries data_points (list of int): the data points queries (list of tuple of int): the queries Returns: list of int: the sum of data points for each query pass def test_preprocess_segments(): data_points = [5, 2, 9, 1, 7, 3] k = 3 expected_segments = [[2, 5], [1, 9], [3, 7]] assert preprocess_segments(data_points, k) == expected_segments def test_compute_prefix_sums(): sorted_data_points = [1, 2, 3, 5, 7, 9] expected_prefix_sums = [0, 1, 3, 6, 11, 18, 27] assert compute_prefix_sums(sorted_data_points) == expected_prefix_sums def test_range_query(): prefix_sums = [0, 1, 3, 6, 11, 18, 27] assert range_query(prefix_sums, 1, 4) == 11 assert range_query(prefix_sums, 2, 6) == 26 def test_range_query_solution(): n = 6 k = 3 q = 2 data_points = [5, 2, 9, 1, 7, 3] queries = [(1, 4), (2, 6)] expected_results = [17, 25] assert range_query_solution(n, k, q, data_points, queries) == expected_results","solution":"def preprocess_segments(data_points, k): Preprocess the data points into k segments and sort each segment. # Calculate segment size segment_size = len(data_points) // k remainder = len(data_points) % k segments = [] index = 0 for i in range(k): size = segment_size + (1 if i < remainder else 0) segment = data_points[index:index + size] segments.append(sorted(segment)) index += size return segments def compute_prefix_sums(sorted_data_points): Compute prefix sums for the sorted data points to facilitate range queries. prefix_sums = [0] * (len(sorted_data_points) + 1) for i, val in enumerate(sorted_data_points): prefix_sums[i + 1] = prefix_sums[i] + val return prefix_sums def range_query(prefix_sums, left, right): Compute the sum of the data points in the range [left, right]. return prefix_sums[right] - prefix_sums[left - 1] def range_query_solution(n, k, q, data_points, queries): Solve the range query problem. segments = preprocess_segments(data_points, k) sorted_data = [point for seg in segments for point in seg] prefix_sums = compute_prefix_sums(sorted_data) results = [] for left, right in queries: results.append(range_query(prefix_sums, left, right)) return results"},{"question":"def min_operations_to_palindrome(n: int, s: str) -> int: Returns the minimum number of operations required to transform the given string into a palindrome. >>> min_operations_to_palindrome(4, 'abca') 1 >>> min_operations_to_palindrome(3, 'abc') 1 >>> min_operations_to_palindrome(5, 'radar') 0 >>> min_operations_to_palindrome(4, 'abba') 0","solution":"def min_operations_to_palindrome(n, s): Returns the minimum number of operations required to transform the given string into a palindrome. operations = 0 for i in range(n // 2): if s[i] != s[n - 1 - i]: operations += 1 return operations"},{"question":"def longest_contiguous_subsequence(grid: List[str]) -> int: Find the length of the longest contiguous subsequence of identical characters either horizontally, vertically, or diagonally in the grid. >>> longest_contiguous_subsequence([ ... \\"ababa\\", ... \\"bacab\\", ... \\"abcba\\", ... \\"bacab\\", ... \\"ababa\\" ... ]) # 3 >>> longest_contiguous_subsequence([ ... \\"aaaa\\", ... \\"aaaa\\", ... \\"aaaa\\", ... \\"aaaa\\" ... ]) # 4 >>> longest_contiguous_subsequence([ ... \\"a\\", ... ]) # 1 >>> longest_contiguous_subsequence([ ... \\"abc\\", ... \\"def\\", ... \\"ghi\\" ... ]) # 1 >>> longest_contiguous_subsequence([ ... \\"aabbb\\", ... \\"aabbb\\", ... \\"aaccc\\" ... ]) # 3 >>> longest_contiguous_subsequence([ ... \\"aaaaa\\", ... \\"ababab\\", ... \\"aaaaa\\", ... \\"ababa\\", ... ]) # 5","solution":"def longest_contiguous_subsequence(grid): R, C = len(grid), len(grid[0]) def check_sequence(x, y, dx, dy): char = grid[x][y] length = 1 nx, ny = x + dx, y + dy while 0 <= nx < R and 0 <= ny < C and grid[nx][ny] == char: length += 1 nx += dx ny += dy return length max_length = 0 directions = [(0, 1), (1, 0), (1, 1), (1, -1)] # right, down, diagonal down-right, diagonal down-left for r in range(R): for c in range(C): for dx, dy in directions: max_length = max(max_length, check_sequence(r, c, dx, dy)) return max_length"},{"question":"def calculate_submersion_levels(n, l, elevations): Calculates the minimum water level at which each island will be submerged. Args: n (int): the number of islands l (int): the maximum possible water level rise elevations (list): a list of integers representing the elevation of each island Returns: list: a list of integers representing the minimum water level at which each island will be submerged Examples: >>> calculate_submersion_levels(5, 10, [2, 8, 5, 1, 7]) [2, 8, 5, 1, 7] >>> calculate_submersion_levels(4, 15, [4, 10, 12, 6]) [4, 10, 12, 6]","solution":"def calculate_submersion_levels(n, l, elevations): Calculates the minimum water level at which each island will be submerged. Args: n (int): the number of islands l (int): the maximum possible water level rise elevations (list): a list of integers representing the elevation of each island Returns: list: a list of integers representing the minimum water level at which each island will be submerged # Each island will be submerged when the water level reaches its elevation return elevations"},{"question":"def min_cost_to_equalize_array(n, arr): Returns the minimum cost to make all elements of the array equal. Args: n : int : the length of the array arr : list of int : the input array Returns: int : the minimum cost >>> min_cost_to_equalize_array(5, [1, 2, 3, 2, 1]) 2 >>> min_cost_to_equalize_array(6, [3, 3, 3, 3, 3, 3]) 0 >>> min_cost_to_equalize_array(4, [1, 2, 3, 4]) 3 >>> min_cost_to_equalize_array(4, [7, 7, 7, 7]) 0 >>> min_cost_to_equalize_array(7, [1, 2, 1, 2, 1, 2, 1]) 3 >>> min_cost_to_equalize_array(3, [1000000, 999999, 1000000]) 1","solution":"def min_cost_to_equalize_array(n, arr): Returns the minimum cost to make all elements of the array equal. Args: n : int : the length of the array arr : list of int : the input array Returns: int : the minimum cost # We need to count how many times a change occurs in the array # if a change from a smaller value to a larger value happens. min_cost = 0 for i in range(1, n): if arr[i] > arr[i-1]: min_cost += arr[i] - arr[i-1] return min_cost"},{"question":"def rearrange_array(arr: List[int], K: int) -> List[int]: Given an integer array \`arr\` and an integer \`K\`, rearrange the array such that the difference between any two adjacent elements in the array is at most \`K\`. If it is not possible to rearrange the array in such a way, return an empty array. >>> rearrange_array([4, 7, 1, 3, 9], 3) [1, 3, 4, 7, 9] >>> rearrange_array([4, 7, 1, 3, 20], 3) [] >>> rearrange_array([1], 5) [1] >>> rearrange_array([1, 2, 3, 4, 5], 1) [1, 2, 3, 4, 5] >>> rearrange_array([100, 20, 30, 10], 100) [10, 20, 30, 100]","solution":"def rearrange_array(arr, K): arr.sort() for i in range(len(arr) - 1): if abs(arr[i] - arr[i + 1]) > K: return [] return arr"},{"question":"def max_problems_to_solve(n: int, problems: List[int]) -> int: Returns the maximum number of problems Alice can solve within the given period. Parameters: n (int): the number of days Alice has planned. problems (list): a list of integers where the i-th integer denotes the number of problems planned on the i-th day. Returns: int: the maximum number of problems Alice can solve. >>> max_problems_to_solve(4, [3, 5, 2, 7]) 15 >>> max_problems_to_solve(6, [1, 3, 4, 2, 6, 5]) 18 from typing import List def test_max_problems_to_solve(): assert max_problems_to_solve(4, [3, 5, 2, 7]) == 15 assert max_problems_to_solve(6, [1, 3, 4, 2, 6, 5]) == 18 assert max_problems_to_solve(1, [10]) == 10 assert max_problems_to_solve(5, [1, 1, 1, 1, 1]) == 5 assert max_problems_to_solve(3, [10, 20, 15]) == 45","solution":"def max_problems_to_solve(n, problems): Returns the maximum number of problems Alice can solve within the given period. Parameters: n (int): the number of days Alice has planned. problems (list): a list of integers where the i-th integer denotes the number of problems planned on the i-th day. Returns: int: the maximum number of problems Alice can solve. # Sorting the problems array in descending order sorted_problems = sorted(problems, reverse=True) # Taking the sum of the problems return sum(sorted_problems)"},{"question":"def is_balanced_brackets(string: str) -> bool: Checks if the given string has balanced brackets. Args: string (str): A piece of code containing various types of brackets. Returns: bool: True if the brackets are balanced, False otherwise. >>> is_balanced_brackets(\\"{[()]}\\") == True >>> is_balanced_brackets(\\"{[(])}\\") == False >>> is_balanced_brackets(\\"{{[[(())]]}}\\") == True >>> is_balanced_brackets(\\"\\") == True >>> is_balanced_brackets(\\"this is a test\\") == True >>> is_balanced_brackets(\\"((([[{{\\") == False >>> is_balanced_brackets(\\"}}]])))\\") == False >>> is_balanced_brackets(\\"{}[\\") == False >>> is_balanced_brackets(\\"[{]}\\") == False >>> is_balanced_brackets(\\"{[a+(b*c)-{d/e}] + (f*{g-h})}\\") == True >>> is_balanced_brackets(\\"{[a+(b*c)-{d/e]) + (f*{g-h})}\\") == False","solution":"def is_balanced_brackets(string): Checks if the given string has balanced brackets. Args: string (str): A piece of code containing various types of brackets. Returns: bool: True if the brackets are balanced, False otherwise. stack = [] bracket_map = {')': '(', ']': '[', '}': '{'} for char in string: if char in bracket_map.values(): stack.append(char) elif char in bracket_map.keys(): if stack == [] or bracket_map[char] != stack.pop(): return False return stack == []"},{"question":"def longest_increasing_subsequence(popularity_ranks: List[int]) -> int: Finds the length of the longest increasing subsequence of popularity ranks. >>> longest_increasing_subsequence([10, 22, 9, 33, 21, 50]) 4 >>> longest_increasing_subsequence([5, 8, 3, 7, 9]) 3 >>> longest_increasing_subsequence([42]) 1 >>> longest_increasing_subsequence([9, 8, 7, 6, 5]) 1 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence([]) 0 >>> longest_increasing_subsequence([5, 1, 22, 10, 23, 21, 50, 1, 60, 70]) 6","solution":"def longest_increasing_subsequence(popularity_ranks): Finds the length of the longest increasing subsequence of popularity ranks. if not popularity_ranks: return 0 n = len(popularity_ranks) lis = [1] * n # Initialize LIS values for all indexes # Compute optimized LIS values in a bottom up manner for i in range(1, n): for j in range(0, i): if popularity_ranks[i] > popularity_ranks[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 # Return the maximum value in lis[] return max(lis)"},{"question":"from typing import List def can_rearrange_with_k_distinct(S: str, K: int) -> str: Determines if it is possible to rearrange the string S such that no two adjacent characters are the same and the new string has at least K distinct characters. >>> can_rearrange_with_k_distinct(\\"aabbcc\\", 3) == \\"YES\\" >>> can_rearrange_with_k_distinct(\\"aabbcca\\", 4) == \\"NO\\"","solution":"from collections import Counter def can_rearrange_with_k_distinct(S, K): Determines if it is possible to rearrange the string S such that no two adjacent characters are the same and the new string has at least K distinct characters. char_count = Counter(S) max_freq = max(char_count.values()) needed_unique_chars = K unique_chars = len(char_count) if unique_chars < needed_unique_chars: return \\"NO\\" # To satisfy the condition no two adjacent characters are the same if max_freq > (len(S) + 1) // 2: return \\"NO\\" return \\"YES\\""},{"question":"class Graph: def __init__(self, n): Initialize the graph with n intersections. pass def add_edge(self, u, v): Add a road (edge) between intersection u and intersection v. pass def is_connected(self, start, end): Check if there is a path between intersection start and intersection end. pass def handle_queries(n, roads, queries): Handle a list of queries to determine if there is a path between given intersections. >>> n = 5 >>> roads = [(1, 2), (2, 3), (3, 4), (4, 5)] >>> queries = [(1, 5), (2, 4), (5, 1)] >>> handle_queries(n, roads, queries) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> n = 6 >>> roads = [(1, 2), (2, 3), (4, 5)] >>> queries = [(1, 6), (3, 4)] >>> handle_queries(n, roads, queries) [\\"NO\\", \\"NO\\"] pass","solution":"class Graph: def __init__(self, n): self.n = n self.graph = [[] for _ in range(n)] def add_edge(self, u, v): self.graph[u - 1].append(v - 1) self.graph[v - 1].append(u - 1) def is_connected(self, start, end): start -= 1 end -= 1 visited = [False] * self.n stack = [start] while stack: node = stack.pop() if node == end: return True if not visited[node]: visited[node] = True stack.extend(self.graph[node]) return False def handle_queries(n, roads, queries): graph = Graph(n) for u, v in roads: graph.add_edge(u, v) results = [] for a, b in queries: if graph.is_connected(a, b): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def construct_playlist(n: int, durations: List[int]) -> List[int]: Constructs a playlist such that no song is played consecutively. If this is not possible, returns an empty list. Parameters: n (int): Number of songs durations (list of int): List of song durations Returns: list of int: Playlist respecting the rule or an empty list if not possible >>> construct_playlist(5, [4, 4, 7, 7, 7]) [7, 4, 7, 4, 7] >>> construct_playlist(3, [1, 1, 1]) [] pass from solution import construct_playlist def test_example_1(): n = 5 durations = [4, 4, 7, 7, 7] expected_output = [7, 4, 7, 4, 7] assert construct_playlist(n, durations) == expected_output def test_example_2(): n = 3 durations = [1, 1, 1] expected_output = [] assert construct_playlist(n, durations) == expected_output def test_single_song(): n = 1 durations = [3] expected_output = [3] assert construct_playlist(n, durations) == expected_output def test_no_songs(): n = 0 durations = [] expected_output = [] assert construct_playlist(n, durations) == expected_output def test_multiple_identical_songs(): n = 6 durations = [5, 5, 5, 4, 4, 4] expected_output_1 = [5, 4, 5, 4, 5, 4] output = construct_playlist(n, durations) # Check if result is one of the valid permutations assert output == expected_output_1 or output == expected_output_1[::-1] def test_more_complex_case(): n = 7 durations = [2, 2, 3, 3, 3, 4, 4] output = construct_playlist(n, durations) # There's more than one correct answer, so need to only check constraints for i in range(n - 1): assert output[i] != output[i + 1]","solution":"from collections import Counter import heapq def construct_playlist(n, durations): Constructs a playlist such that no song is played consecutively. If this is not possible, returns an empty list. Parameters: n (int): Number of songs durations (list of int): List of song durations Returns: list of int: Playlist respecting the rule or an empty list if not possible if n <= 1: return durations counter = Counter(durations) max_heap = [(-count, duration) for duration, count in counter.items()] heapq.heapify(max_heap) result = [] prev_count, prev_duration = 0, None while max_heap: count, duration = heapq.heappop(max_heap) if prev_duration is not None: heapq.heappush(max_heap, (prev_count, prev_duration)) result.append(duration) prev_count = count + 1 # increment count since we are using one instance of \\"duration\\" prev_duration = duration if prev_count == 0: prev_duration = None if len(result) != n: return [] return result"},{"question":"def max_subset_diff(N: int, power_levels: List[int]) -> int: Returns the maximum possible difference between the sums of elements of two non-empty subsets. >>> max_subset_diff(1, [10]) 10 >>> max_subset_diff(5, [1, 2, 3, 4, 5]) 15 >>> max_subset_diff(3, [1, 3, 5]) 9 >>> max_subset_diff(4, [1000000000, 200000000, 300000000, 400000000]) 1900000000 >>> max_subset_diff(4, [1, 2, 3, 4]) 10 >>> max_subset_diff(6, [10, 20, 30, 40, 50, 60]) 210","solution":"def max_subset_diff(N, power_levels): Returns the maximum possible difference between the sums of elements of two non-empty subsets. # If there's only one item, the difference is the item itself if N == 1: return power_levels[0] # Calculate the total sum of all elements total_sum = sum(power_levels) # The maximum difference is achieved when comparing the total sum with 0 return total_sum"},{"question":"def has_pair_with_difference(nums: List[int], target: int) -> bool: Check if there are two distinct indices i and j such that the difference between nums[i] and nums[j] equals the target. >>> has_pair_with_difference([1, 5, 3, 4], 2) True >>> has_pair_with_difference([1, 2, 3, 4, 5], 10) False >>> has_pair_with_difference([1, 2, 3, 1, 2, 3], 0) True >>> has_pair_with_difference([5, 10, 3, 20, 50], -5) True >>> has_pair_with_difference([1000000000, 999999998, 999999999], 1) True >>> has_pair_with_difference([1000000000, 999999998, 999999999], 100000000) False >>> has_pair_with_difference([1, 5, 3, 4, 1], 0) True","solution":"def has_pair_with_difference(nums, target): Check if there are two distinct indices i and j such that the difference between nums[i] and nums[j] equals the target. num_set = set(nums) for num in nums: if num + target in num_set or num - target in num_set: return True return False"},{"question":"import math from typing import List, Tuple def largest_square_plot(L: int, W: int) -> int: Returns the side length of the largest possible square plot that can be used to equally divide the farm of dimensions L by W. >>> largest_square_plot(15, 20) 5 >>> largest_square_plot(21, 28) 7 pass def process_test_cases(test_cases: List[Tuple[int, int]]) -> List[int]: Processes multiple test cases and returns a list of results for each test case. >>> process_test_cases([(15, 20), (21, 28)]) [5, 7] >>> process_test_cases([(1, 1), (1000000000, 1000000000)]) [1, 1000000000] pass","solution":"import math def largest_square_plot(L, W): Returns the side length of the largest possible square plot that can be used to equally divide the farm of dimensions L by W. return math.gcd(L, W) def process_test_cases(test_cases): results = [] for L, W in test_cases: results.append(largest_square_plot(L, W)) return results"},{"question":"def max_groups(candyTypes: List[str]) -> int: Function to compute the maximum number of groups of candies. Each group consists of exactly two different types of candies. >>> max_groups([\\"choco\\", \\"mint\\", \\"berry\\", \\"choco\\", \\"mint\\", \\"berry\\"]) == 3 >>> max_groups([\\"apple\\", \\"banana\\", \\"apple\\", \\"banana\\", \\"orange\\"]) == 2 >>> max_groups([\\"choco\\", \\"choco\\", \\"choco\\"]) == 0 >>> max_groups([\\"apple\\", \\"banana\\"]) == 1 >>> max_groups([\\"a\\", \\"a\\", \\"a\\", \\"b\\", \\"b\\", \\"c\\", \\"c\\", \\"d\\"]) == 4 >>> candy_types = [\\"a\\"] * 50000 + [\\"b\\"] * 50000 >>> max_groups(candy_types) == 50000","solution":"def max_groups(candyTypes): Function to compute the maximum number of groups of candies. Each group consists of exactly two different types of candies. from collections import Counter # Count the frequency of each candy type candy_count = Counter(candyTypes) # List to store the count of candies counts = list(candy_count.values()) # Sort the counts in descending order counts.sort(reverse=True) pairs = 0 # To count the number of pairs formed while len(counts) > 1: # Pick the two highest counts first = counts.pop(0) second = counts.pop(0) # Form a pair pairs += 1 # Decrease the counts first -= 1 second -= 1 # If there are still candies of these types left, put them back in the list if first > 0: counts.append(first) if second > 0: counts.append(second) # Sort the updated counts list again counts.sort(reverse=True) return pairs"},{"question":"def longest_substring_with_k_distinct_characters(s: str, k: int) -> str: Returns the longest substring of s with exactly k distinct characters. If there are multiple longest substrings with exactly k distinct characters, return the one that appears first. >>> longest_substring_with_k_distinct_characters(\\"abcba\\", 2) == \\"bcb\\" >>> longest_substring_with_k_distinct_characters(\\"aaabbb\\", 3) == \\"\\" >>> longest_substring_with_k_distinct_characters(\\"aaabbbccc\\", 2) == \\"aaabbb\\" >>> longest_substring_with_k_distinct_characters(\\"eceba\\", 2) == \\"ece\\" >>> longest_substring_with_k_distinct_characters(\\"aaaabc\\", 1) == \\"aaaa\\" >>> longest_substring_with_k_distinct_characters(\\"aabc\\", 2) == \\"aab\\" >>> longest_substring_with_k_distinct_characters(\\"a\\", 1) == \\"a\\" >>> longest_substring_with_k_distinct_characters(\\"\\", 1) == \\"\\" >>> longest_substring_with_k_distinct_characters(\\"abaccc\\", 2) == \\"accc\\" pass","solution":"def longest_substring_with_k_distinct_characters(s, k): Returns the longest substring of s with exactly k distinct characters. If there are multiple longest substrings with exactly k distinct characters, return the one that appears first. if k == 0 or not s: return \\"\\" start = 0 max_len = 0 max_sub = \\"\\" char_count = {} for end in range(len(s)): right_char = s[end] if right_char not in char_count: char_count[right_char] = 0 char_count[right_char] += 1 while len(char_count) > k: left_char = s[start] char_count[left_char] -= 1 if char_count[left_char] == 0: del char_count[left_char] start += 1 if end - start + 1 > max_len and len(char_count) == k: max_len = end - start + 1 max_sub = s[start:end + 1] return max_sub"},{"question":"def assign_identifiers(registrations, max_attendees): Assign unique identifiers to conference attendees according to their registration order and ensure attendance does not exceed the maximum allowed seats. Parameters: registrations (List[List[str]]): List of registrations where each registration is a list of attendee names. max_attendees (int): Maximum allowed attendees. Returns: List[str]: List of unique identifiers assigned to each attendee in the order they registered, up to the maximum capacity. Examples: >>> registrations = [ ... [\\"John\\", \\"Doe\\"], ... [\\"Alice\\", \\"Bob\\", \\"Charlie\\"], ... [\\"Eve\\", \\"Frank\\"] ... ] >>> max_attendees = 5 >>> assign_identifiers(registrations, max_attendees) [\\"A1-1\\", \\"A1-2\\", \\"A2-1\\", \\"A2-2\\", \\"A2-3\\"] def test_ideal_case(): registrations = [ [\\"John\\", \\"Doe\\"], [\\"Alice\\", \\"Bob\\", \\"Charlie\\"], [\\"Eve\\", \\"Frank\\"] ] max_attendees = 5 assert assign_identifiers(registrations, max_attendees) == [\\"A1-1\\", \\"A1-2\\", \\"A2-1\\", \\"A2-2\\", \\"A2-3\\"] def test_max_attendees_reached_mid_registration(): registrations = [ [\\"John\\", \\"Doe\\"], [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] ] max_attendees = 3 assert assign_identifiers(registrations, max_attendees) == [\\"A1-1\\", \\"A1-2\\", \\"A2-1\\"] def test_no_limit(): registrations = [ [\\"John\\", \\"Doe\\"], [\\"Alice\\", \\"Bob\\", \\"Charlie\\"], [\\"Eve\\", \\"Frank\\"] ] max_attendees = 100 assert assign_identifiers(registrations, max_attendees) == [ \\"A1-1\\", \\"A1-2\\", \\"A2-1\\", \\"A2-2\\", \\"A2-3\\", \\"A3-1\\", \\"A3-2\\" ] def test_zero_max_attendees(): registrations = [ [\\"John\\", \\"Doe\\"], [\\"Alice\\", \\"Bob\\", \\"Charlie\\"], [\\"Eve\\", \\"Frank\\"] ] max_attendees = 0 assert assign_identifiers(registrations, max_attendees) == [] def test_no_attendees(): registrations = [] max_attendees = 5 assert assign_identifiers(registrations, max_attendees) == [] def test_exact_max_attendees(): registrations = [ [\\"John\\", \\"Doe\\"], [\\"Alice\\", \\"Bob\\", \\"Charlie\\"], [\\"Eve\\"] ] max_attendees = 6 assert assign_identifiers(registrations, max_attendees) == [ \\"A1-1\\", \\"A1-2\\", \\"A2-1\\", \\"A2-2\\", \\"A2-3\\", \\"A3-1\\" ]","solution":"def assign_identifiers(registrations, max_attendees): identifiers = [] current_attendee_count = 0 for registration_index, registration in enumerate(registrations, start=1): for attendee_index, _ in enumerate(registration, start=1): if current_attendee_count < max_attendees: identifiers.append(f\\"A{registration_index}-{attendee_index}\\") current_attendee_count += 1 else: return identifiers return identifiers"},{"question":"from typing import List, Tuple def min_operations_to_equal_elements(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the minimum number of operations required to make all elements in the array equal. Parameters: t (int): number of test cases test_cases (List[Tuple[int, List[int]]]): list of test cases where each test case is a tuple containing an integer n (length of the array) and a list of n integers. Returns: List[int]: list of integers where each integer represents the minimum number of operations required for the corresponding test case. Examples: >>> min_operations_to_equal_elements(3, [(3, [1, 2, 3]), (4, [10, 10, 10, 10]), (5, [1, 2, 2, 1, 1])]) [2, 0, 1] >>> min_operations_to_equal_elements(1, [(5, [1000000000, -1000000000, 0, 999999999, -999999999])]) [4]","solution":"def min_operations_to_equal_elements(t, test_cases): results = [] for i in range(t): n, a = test_cases[i] unique_elements = set(a) results.append(len(unique_elements) - 1) return results"},{"question":"def is_valid_expression(expression: str) -> bool: Determine if the given string is a valid arithmetic expression. >>> is_valid_expression(\\"3+(4-5)*2\\") True >>> is_valid_expression(\\"10/(5-5)\\") False >>> is_valid_expression(\\"5++6\\") False >>> is_valid_expression(\\"7*()3\\") False >>> is_valid_expression(\\"(2+3)*(3-1)\\") True >>> is_valid_expression(\\"()\\") False >>> is_valid_expression(\\"5/2)\\") False >>> is_valid_expression(\\"5/2\\") True","solution":"def is_valid_expression(expression: str) -> bool: Check if the given expression is a valid arithmetic expression. if not expression: return False operators = {'+', '-', '*', '/'} stack = [] last_char = None for i, char in enumerate(expression): if char.isdigit(): pass elif char in operators: if last_char in operators or last_char in {'(', None}: return False if i == len(expression) - 1: return False elif char == '(': stack.append('(') if i == len(expression) - 1: # expression can't end with '(' return False elif char == ')': if not stack or last_char in operators or last_char == '(': return False stack.pop() else: return False last_char = char if stack: return False # Check for division by zero try: eval(expression) except ZeroDivisionError: return False return True"},{"question":"def evenProduct(N: int) -> int: Returns the product of all even digits present in the given number N. If there are no even digits, the product is considered to be 1. >>> evenProduct(4821) 64 >>> evenProduct(1357) 1","solution":"def evenProduct(N): Returns the product of all even digits present in the given number N. If there are no even digits, the product is considered to be 1. product = 1 has_even_digit = False for digit in str(N): digit = int(digit) if digit % 2 == 0: product *= digit has_even_digit = True return product if has_even_digit else 1"},{"question":"from collections import deque def days_to_infect_tree(N, edges, S): Determine the number of days it will take for the entire tree to get infected starting from node S. :param N: int - The number of nodes in the tree. :param edges: List[Tuple[int, int]] - List of edges representing the tree. :param S: int - The starting node from which the infection begins. :return: int - The number of days taken to infect the entire tree. >>> days_to_infect_tree(5, [(1, 2), (1, 3), (3, 4), (3, 5)], 3) 2 >>> days_to_infect_tree(5, [(1, 2), (1, 3), (3, 4), (3, 5)], 5) 3 >>> days_to_infect_tree(1, [], 1) 0 >>> days_to_infect_tree(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)], 1) 2 >>> days_to_infect_tree(4, [(1, 2), (2, 3), (3, 4)], 2) 2","solution":"from collections import deque def days_to_infect_tree(N, edges, S): # Build the adjacency list for the tree adjacency_list = [[] for _ in range(N + 1)] for u, v in edges: adjacency_list[u].append(v) adjacency_list[v].append(u) # BFS to calculate the furthest distance from the starting node S visited = [False] * (N + 1) queue = deque([(S, 0)]) # (current_node, current_depth) visited[S] = True max_days = 0 while queue: node, depth = queue.popleft() max_days = max(max_days, depth) for neighbor in adjacency_list[node]: if not visited[neighbor]: visited[neighbor] = True queue.append((neighbor, depth + 1)) return max_days"},{"question":"def is_valid_ipv4_address(ip: str) -> bool: Checks if the given string is a valid IPv4 address. >>> is_valid_ipv4_address(\\"192.168.0.1\\") True >>> is_valid_ipv4_address(\\"255.255.255.0\\") True >>> is_valid_ipv4_address(\\"256.256.256.256\\") False >>> is_valid_ipv4_address(\\"192.168.1\\") False >>> is_valid_ipv4_address(\\"192.168.01.1\\") False","solution":"def is_valid_ipv4_address(ip: str) -> bool: Checks if the given string is a valid IPv4 address. parts = ip.split(\\".\\") if len(parts) != 4: return False for part in parts: if not part.isdigit(): return False if part.startswith('0') and len(part) > 1: return False num = int(part) if num < 0 or num > 255: return False return True"},{"question":"def can_reach_bottom_right(grid): Returns True if the robot can reach the bottom-right corner of the grid, otherwise False. >>> can_reach_bottom_right([[0,0,0],[0,1,0],[0,0,0]]) True >>> can_reach_bottom_right([[0,1],[1,0]]) False >>> can_reach_bottom_right([[0,0],[0,0]]) True","solution":"def can_reach_bottom_right(grid): Returns True if the robot can reach the bottom-right corner of the grid, otherwise False. def is_valid(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == 1: return False return True def dfs(x, y): if not is_valid(x, y) or visited[x][y]: return False if x == m-1 and y == n-1: return True visited[x][y] = True # Check all 4 directions: right, down, left, up if (dfs(x+1, y) or dfs(x, y+1) or dfs(x-1, y) or dfs(x, y-1)): return True return False if not grid or not grid[0]: return False m, n = len(grid), len(grid[0]) visited = [[False for _ in range(n)] for _ in range(m)] # Start DFS from top-left corner return dfs(0, 0)"},{"question":"def list_compression(nums): Compress the list of integers \`nums\` by summing any consecutive sequences of the same integer and replacing them with a single instance of that integer followed by the sum of that sequence in parentheses. If an integer appears consecutively only once, it remains unchanged. Args: nums (list of int): List of integers to be compressed. Returns: list: A list representing the compressed form. Examples: >>> list_compression([1, 1, 2, 2, 2, 3, 3, 3, 3, 4, 4]) ['1(2)', '2(6)', '3(12)', '4(8)'] >>> list_compression([5, 5, 5, 5, 6, 6, 7, 8, 8]) ['5(20)', '6(12)', 7, '8(16)'] def test_list_compression_single_sequences(): assert list_compression([1, 1, 2, 2, 2, 3, 3, 3, 3, 4, 4]) == ['1(2)', '2(6)', '3(12)', '4(8)'] def test_list_compression_mixed_sequences(): assert list_compression([5, 5, 5, 5, 6, 6, 7, 8, 8]) == ['5(20)', '6(12)', 7, '8(16)'] def test_list_compression_no_duplicates(): assert list_compression([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_list_compression_all_same(): assert list_compression([3, 3, 3, 3]) == ['3(12)'] def test_list_compression_empty(): assert list_compression([]) == [] def test_list_compression_single_element(): assert list_compression([1]) == [1] def test_list_compression_alternating_elements(): assert list_compression([1, 2, 1, 2, 1, 2]) == [1, 2, 1, 2, 1, 2]","solution":"def list_compression(nums): Compress the list of integers \`nums\` by summing any consecutive sequences of the same integer and replacing them with a single instance of that integer followed by the sum of that sequence in parentheses. If an integer appears consecutively only once, it remains unchanged. Args: nums (list of int): List of integers to be compressed. Returns: list: A list representing the compressed form. if not nums: return [] compressed_list = [] current_num = nums[0] current_sum = current_num for i in range(1, len(nums)): if nums[i] == current_num: current_sum += nums[i] else: if current_sum != current_num: compressed_list.append(f\\"{current_num}({current_sum})\\") else: compressed_list.append(current_num) current_num = nums[i] current_sum = current_num # Don't forget to add the last grouped element if current_sum != current_num: compressed_list.append(f\\"{current_num}({current_sum})\\") else: compressed_list.append(current_num) return compressed_list"},{"question":"def max_shelf_value(M, K, books): Determine the maximum total value of the books Bob can display on a single shelf. Args: M (int): The number of categories. K (int): The number of books. books (List[Tuple[int, int, int]]): A list of tuples where each tuple contains: - category number of the book (int) - book number index (int) - value of the book (int) Returns: int: The maximum total value of the books that can be displayed on a single shelf. Examples: >>> max_shelf_value(3, 5, [(1, 1, 10), (1, 2, 15), (2, 3, 10), (3, 4, 30), (3, 5, 25)]) 55 >>> max_shelf_value(1, 5, [(1, 1, 10), (1, 2, 15), (1, 3, 5), (1, 4, 20), (1, 5, 25)]) 25 >>> max_shelf_value(2, 2, [(1, 1, 10), (2, 2, 20)]) 30 >>> max_shelf_value(3, 3, [(1, 1, 10), (2, 2, 20), (3, 3, 15)]) 45 >>> max_shelf_value(3, 6, [(1, 1, 1000), (1, 2, 999), (2, 3, 998), (2, 4, 997), (3, 5, 996), (3, 6, 995)]) 2994","solution":"def max_shelf_value(M, K, books): from collections import defaultdict category_to_books = defaultdict(list) for category, book_number, value in books: category_to_books[category].append(value) # For each category, sort the books by value in descending order for category in category_to_books: category_to_books[category].sort(reverse=True) # Choose the highest valued book from each category max_total_value = 0 for category in category_to_books: if category_to_books[category]: max_total_value += category_to_books[category][0] return max_total_value # Example usage: # max_shelf_value(3, 5, [(1, 1, 10), (1, 2, 15), (2, 3, 10), (3, 4, 30), (3, 5, 25)]) # Output: 55"},{"question":"def can_network_be_secured(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[str]: Determines if it's possible to secure the network for multiple test cases. :param t: Integer, the number of test cases. :param test_cases: List of tuples, each tuple contains the number of computers, the number of connections, and the connections themselves. :return: List of strings, \\"YES\\" or \\"NO\\" for each test case. >>> can_network_be_secured(2, [(3, 3, [(1, 2), (2, 3), (1, 3)]), (4, 2, [(1, 2), (3, 4)])]) ['YES', 'NO'] >>> can_network_be_secured(1, [(1, 0, [])]) ['YES'] >>> can_network_be_secured(1, [(4, 2, [(1, 2), (3, 4)])]) ['NO'] >>> can_network_be_secured(1, [(5, 0, [])]) ['NO'] >>> can_network_be_secured(1, [(4, 3, [(1, 2), (2, 3), (3, 4)])]) ['YES'] >>> can_network_be_secured(1, [(4, 3, [(1, 2), (2, 3), (3, 4)])]) ['YES']","solution":"def can_network_be_secured(t, test_cases): Determines if it's possible to secure the network for multiple test cases. :param t: Integer, the number of test cases. :param test_cases: List of tuples, each tuple contains the number of computers, the number of connections, and the connections themselves. :return: List of strings, \\"YES\\" or \\"NO\\" for each test case. def dfs(node, visited, adj_list): stack = [node] while stack: current = stack.pop() for neighbor in adj_list[current]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) results = [] for n, m, connections in test_cases: if n == 1: results.append(\\"YES\\") continue adj_list = {i: [] for i in range(1, n+1)} for u, v in connections: adj_list[u].append(v) adj_list[v].append(u) visited = {i: False for i in range(1, n+1)} visited[1] = True dfs(1, visited, adj_list) if all(visited.values()): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def maximal_rectangle(matrix: List[List[int]]) -> int: Find the largest rectangle containing only ones in the given matrix and return its area. >>> maximal_rectangle([ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ]) 6 >>> maximal_rectangle([ ... [0, 1, 1, 0], ... [1, 1, 1, 1], ... [0, 1, 1, 1], ... [0, 1, 1, 1] ... ]) 9 >>> maximal_rectangle([ ... [0, 1, 1, 1, 0] ... ]) 3 >>> maximal_rectangle([ ... [1], ... [1], ... [0], ... [1] ... ]) 2 >>> maximal_rectangle([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 >>> maximal_rectangle([ ... [1, 1], ... [1, 1] ... ]) 4","solution":"def maximal_rectangle(matrix): if not matrix or not matrix[0]: return 0 n = len(matrix) m = len(matrix[0]) max_area = 0 heights = [0] * m for row in matrix: for i in range(m): heights[i] = heights[i] + 1 if row[i] == 1 else 0 max_area = max(max_area, largest_rectangle_area(heights)) return max_area def largest_rectangle_area(heights): stack = [] max_area = 0 heights.append(0) for i in range(len(heights)): while stack and heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) heights.pop() return max_area"},{"question":"def average_sales(sales, n): Returns an array of floats, where each float represents the average sales figure for each sliding window of 'n' consecutive days over the given period. Parameters: sales (list): An array of integers representing the daily sales figures for a store. n (int): The number of consecutive days for which to calculate the average sales. Returns: list: An array of floats, rounded to two decimal places. >>> average_sales([1, 2, 3, 4, 5], 2) == [1.5, 2.5, 3.5, 4.5] >>> average_sales([10, 20, 30, 40, 50], 3) == [20.0, 30.0, 40.0] def test_average_sales_basic(): assert average_sales([1, 2, 3, 4, 5], 2) == [1.5, 2.5, 3.5, 4.5] assert average_sales([10, 20, 30, 40, 50], 3) == [20.0, 30.0, 40.0] assert average_sales([5, 5, 5, 5], 1) == [5.0, 5.0, 5.0, 5.0] def test_average_sales_edge_cases(): assert average_sales([], 1) == [] assert average_sales([10, 20, 30], 0) == [] assert average_sales([10, 20, 30], 4) == [] assert average_sales([0], 1) == [0.0] assert average_sales([0, 0, 0, 0], 2) == [0.0, 0.0, 0.0] def test_average_sales_single_window(): assert average_sales([10, 20, 30], 3) == [20.0] def test_average_sales_output_rounded(): assert average_sales([1, 2, 3.3333, 4, 5], 3) == [2.11, 3.11, 4.11] assert average_sales([1.555, 2.555, 3.555], 2) == [2.06, 3.06] def test_average_sales_negative_numbers(): assert average_sales([-1, -2, -3, -4, -5], 2) == [-1.5, -2.5, -3.5, -4.5] assert average_sales([-10, -20, -30, -40], 3) == [-20.0, -30.0] def test_average_sales_combination_numbers(): assert average_sales([1, -1, 1, -1, 1], 2) == [0.0, 0.0, 0.0, 0.0] # Make sure to import and run pytest to execute the tests","solution":"def average_sales(sales, n): Returns an array of floats, where each float represents the average sales figure for each sliding window of 'n' consecutive days over the given period. Parameters: sales (list): An array of integers representing the daily sales figures for a store. n (int): The number of consecutive days for which to calculate the average sales. Returns: list: An array of floats, rounded to two decimal places. # Check for invalid 'n' greater than the length of sales or less than or equal to zero if n > len(sales) or n <= 0: return [] # Initialize an empty result list result = [] # Loop through the sales list and calculate the average for each window of 'n' consecutive days for i in range(len(sales) - n + 1): average = round(sum(sales[i:i + n]) / n, 2) result.append(average) return result"},{"question":"import numpy as np def transpose_and_flatten(matrix): Returns the transpose and flattened version of a 4x4 matrix. Parameters: matrix (list): A list of 16 integers representing a 4x4 matrix in row-major order. Returns: tuple: A tuple containing the transposed matrix as a numpy array and the flattened matrix as a numpy array. >>> matrix_input = [ >>> 1, 2, 3, 4, >>> 5, 6, 7, 8, >>> 9, 10, 11, 12, >>> 13, 14, 15, 16 >>> ] >>> transpose_and_flatten(matrix_input) (array([[ 1, 5, 9, 13], [ 2, 6, 10, 14], [ 3, 7, 11, 15], [ 4, 8, 12, 16]]), array([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]))","solution":"import numpy as np def transpose_and_flatten(matrix): Returns the transpose and flattened version of a 4x4 matrix. Parameters: matrix (list): A list of 16 integers representing a 4x4 matrix in row-major order. Returns: tuple: A tuple containing the transposed matrix as a numpy array and the flattened matrix as a numpy array. array_2d = np.array(matrix).reshape(4, 4) transposed = np.transpose(array_2d) flattened = array_2d.flatten() return transposed, flattened"},{"question":"import math from itertools import permutations def calculate_distance(point1, point2): Calculate the Euclidean distance between two points in a 2D plane. return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) def get_minimum_distance(n, locations): Given the number of delivery locations and their coordinates, determine the minimum total distance traveled starting and ending at the warehouse (0, 0). warehouse = (0, 0) locations.insert(0, warehouse) min_distance = float('inf') for perm in permutations(range(1, n + 1)): current_distance = 0 current_location = 0 # warehouse for i in perm: next_location = locations[i] current_distance += calculate_distance(locations[current_location], next_location) current_location = i current_distance += calculate_distance(locations[current_location], warehouse) min_distance = min(min_distance, current_distance) return round(min_distance) # Main function to be implemented def logistics_company(input_data): Given the input data as a string, parse the input, calculate and return the minimum total distance traveled by the truck. pass","solution":"from itertools import permutations import math def calculate_distance(point1, point2): Calculate the Euclidean distance between two points in a 2D plane. return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) def get_minimum_distance(n, locations): Given the number of delivery locations and their coordinates, determine the minimum total distance traveled starting and ending at the warehouse (0, 0). warehouse = (0, 0) locations.insert(0, warehouse) min_distance = float('inf') for perm in permutations(range(1, n + 1)): current_distance = 0 current_location = 0 # warehouse for i in perm: next_location = locations[i] current_distance += calculate_distance(locations[current_location], next_location) current_location = i current_distance += calculate_distance(locations[current_location], warehouse) min_distance = min(min_distance, current_distance) return round(min_distance) # Function to facilitate input and output for the problem def logistics_company(input_data): input_lines = input_data.strip().split(\\"n\\") n = int(input_lines[0]) locations = [tuple(map(int, line.split())) for line in input_lines[1:]] return get_minimum_distance(n, locations)"},{"question":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: Rotates the array arr by k positions to the right. Parameters: arr (List[int]): The input array of integers. k (int): The number of positions to rotate the array. Returns: List[int]: The rotated array. Example: >>> rotate_array([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate_array([10, 20, 30, 40, 50], 2) [40, 50, 10, 20, 30] >>> rotate_array([1, 2, 3], 0) [1, 2, 3] >>> rotate_array([-1, -100, 3, 99], 2) [3, 99, -1, -100] pass","solution":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: Rotates the array arr by k positions to the right. Parameters: arr (List[int]): The input array of integers. k (int): The number of positions to rotate the array. Returns: List[int]: The rotated array. if not arr: return arr n = len(arr) k = k % n # Handle cases where k is greater than n return arr[-k:] + arr[:-k]"},{"question":"def max_sum_after_reversals(n: int, sequence: List[int]) -> int: Calculate the maximum sum of the sequence after Alice and Bob each reverse a contiguous subarray. :param n: int - the number of elements in the sequence :param sequence: List[int] - the sequence of integers :return: int - the maximum sum of the sequence after the two operations >>> max_sum_after_reversals(4, [1, 2, -3, 4]) 10 >>> max_sum_after_reversals(5, [-1, -2, -3, -4, -5]) 15 >>> max_sum_after_reversals(6, [1, 2, 3, -4, -5, 6]) 21 >>> max_sum_after_reversals(3, [1, 2, 3]) 6 >>> max_sum_after_reversals(4, [-1, -2, -3, -4]) 10 >>> max_sum_after_reversals(5, [1, -2, 3, -4, 5]) 15 >>> max_sum_after_reversals(1, [1]) 1 >>> max_sum_after_reversals(1, [-1]) 1 >>> max_sum_after_reversals(3, [10000, -10000, 10000]) 30000 from typing import List def test_example_1(): assert max_sum_after_reversals(4, [1, 2, -3, 4]) == 10 def test_example_2(): assert max_sum_after_reversals(5, [-1, -2, -3, -4, -5]) == 15 def test_example_3(): assert max_sum_after_reversals(6, [1, 2, 3, -4, -5, 6]) == 21 def test_all_positive(): assert max_sum_after_reversals(3, [1, 2, 3]) == 6 def test_all_negative(): assert max_sum_after_reversals(4, [-1, -2, -3, -4]) == 10 def test_mixed(): assert max_sum_after_reversals(5, [1, -2, 3, -4, 5]) == 15 def test_single_element(): assert max_sum_after_reversals(1, [1]) == 1 assert max_sum_after_reversals(1, [-1]) == 1 def test_large_numbers(): assert max_sum_after_reversals(3, [10000, -10000, 10000]) == 30000","solution":"def max_sum_after_reversals(n, sequence): Calculate the maximum sum of the sequence after Alice and Bob each reverse a contiguous subarray. :param n: int - the number of elements in the sequence :param sequence: List[int] - the sequence of integers :return: int - the maximum sum of the sequence after the two operations # Calculate the sum of the absolute values of the sequence max_sum = sum(abs(x) for x in sequence) return max_sum"},{"question":"def longest_non_decreasing_substring_length(s: str) -> int: Returns the length of the longest substring where the characters are in non-decreasing order. >>> longest_non_decreasing_substring_length(\\"abc\\") 3 >>> longest_non_decreasing_substring_length(\\"cba\\") 1 >>> longest_non_decreasing_substring_length(\\"aab\\") 3 >>> longest_non_decreasing_substring_length(\\"xyzabc\\") 3","solution":"def longest_non_decreasing_substring_length(s: str) -> int: Returns the length of the longest substring where the characters are in non-decreasing order. if not s: return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] >= s[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"def spell_digits(digit_string): Takes a string composed of digits and returns the corresponding string with each digit spelled out in English, separated by a single space. >>> spell_digits(\\"123\\") 'one two three' >>> spell_digits(\\"908\\") 'nine zero eight' >>> spell_digits(\\"50210\\") 'five zero two one zero'","solution":"def spell_digits(digit_string): Takes a string composed of digits and returns the corresponding string with each digit spelled out in English, separated by a single space. digit_map = { '0': 'zero', '1': 'one', '2': 'two', '3': 'three', '4': 'four', '5': 'five', '6': 'six', '7': 'seven', '8': 'eight', '9': 'nine' } return ' '.join(digit_map[digit] for digit in digit_string)"},{"question":"def count_elements_with_k_ones(arr, k): Returns the count of elements in the array whose binary representation has exactly k ones. Parameters: arr (list): List of integers. k (int): Number of ones required in binary representation. Returns: int: Count of elements meeting the condition. Examples: >>> count_elements_with_k_ones([3, 5, 6, 7, 8], 2) 3 >>> count_elements_with_k_ones([2, 4, 8, 16], 1) 4","solution":"def count_elements_with_k_ones(arr, k): Returns the count of elements in the array whose binary representation has exactly k ones. Parameters: arr (list): List of integers. k (int): Number of ones required in binary representation. Returns: int: Count of elements meeting the condition. count = 0 for num in arr: if bin(num).count('1') == k: count += 1 return count"},{"question":"def is_valid_parentheses(s: str) -> bool: Determines if the input string is a valid nested sequence of parentheses. Each opening parenthesis must have a corresponding closing parenthesis and parentheses must be properly nested. >>> is_valid_parentheses(\\"()\\") True >>> is_valid_parentheses(\\"(())\\") True >>> is_valid_parentheses(\\"(()())\\") True >>> is_valid_parentheses(\\"())(\\") False >>> is_valid_parentheses(\\"(()\\") False >>> is_valid_parentheses(\\"())(()\\") False","solution":"def is_valid_parentheses(s: str) -> bool: Checks if the input string is a valid nested sequence of parentheses. # Initialize a counter to keep track of balance balance = 0 # Traverse each character in the string for char in s: if char == '(': balance += 1 elif char == ')': balance -= 1 # If balance is negative at any point, there are unmatched closing parentheses if balance < 0: return False # If balance is zero, all opening parentheses were matched by closing ones return balance == 0"},{"question":"def max_delivery_charge(xr: int, yr: int, zones: List[Tuple[int, int]]) -> int: Returns the maximum delivery charge from the restaurant's central facility to any delivery zone. :param xr: x-coordinate of the restaurant's central facility :param yr: y-coordinate of the restaurant's central facility :param zones: List of tuples representing the coordinates of the delivery zones :return: The maximum delivery charge Example: >>> max_delivery_charge(0, 0, [(3, 4), (1, 1), (-2, -3), (4, -1), (0, 5)]) 7 >>> max_delivery_charge(0, 0, [(1, 1)]) 2 >>> max_delivery_charge(0, 0, [(0, 0)]) 0 >>> max_delivery_charge(0, 0, [(100000, 100000), (-100000, -100000), (100000, -100000), (-100000, 100000)]) 200000 >>> max_delivery_charge(0, 0, [(10, -10), (-20, 5), (30, 40), (-50, -60)]) 110 >>> max_delivery_charge(0, 0, [(-1, -2), (-3, -4), (-5, -6)]) 11","solution":"def max_delivery_charge(xr, yr, zones): Returns the maximum delivery charge from the restaurant's central facility to any delivery zone. max_charge = 0 for x, y in zones: charge = abs(xr - x) + abs(yr - y) if charge > max_charge: max_charge = charge return max_charge"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kthLargest(root: TreeNode, K: int) -> int: Find the Kth largest element in the binary tree. >>> root = TreeNode(3) >>> root.left = TreeNode(1) >>> root.right = TreeNode(4) >>> root.right.right = TreeNode(5) >>> kthLargest(root, 2) 4 >>> root = TreeNode(5) >>> root.left = TreeNode(3) >>> root.right = TreeNode(7) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(4) >>> root.right.right = TreeNode(8) >>> kthLargest(root, 3) 5","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kthLargest(root, K): def in_order_traversal(node): if not node: return [] return in_order_traversal(node.left) + [node.val] + in_order_traversal(node.right) sorted_elements = in_order_traversal(root) return sorted_elements[-K]"},{"question":"def min_operations_to_one(n: int) -> int: Returns the minimum number of operations needed to transform n into 1. >>> min_operations_to_one(6) 8 >>> min_operations_to_one(7) 16","solution":"def min_operations_to_one(n): Returns the minimum number of operations needed to transform n into 1. operations = 0 while n != 1: if n % 2 == 0: n //= 2 else: n = 3 * n + 1 operations += 1 return operations"},{"question":"def smallest_by_deleting_one_digit(s: str) -> int: Given a string of digits, returns the smallest possible integer by deleting exactly one digit. >>> smallest_by_deleting_one_digit(\\"261537\\") 21537 >>> smallest_by_deleting_one_digit(\\"10234\\") 234 >>> smallest_by_deleting_one_digit(\\"2356\\") 235 >>> smallest_by_deleting_one_digit(\\"2222\\") 222 >>> smallest_by_deleting_one_digit(\\"10002\\") 2 >>> smallest_by_deleting_one_digit(\\"987654321\\") 87654321 >>> smallest_by_deleting_one_digit(\\"02034\\") 34","solution":"def smallest_by_deleting_one_digit(s): Given a string of digits, returns the smallest possible integer by deleting exactly one digit. min_number = float('inf') for i in range(len(s)): new_number = int(s[:i] + s[i+1:]) if new_number < min_number: min_number = new_number return min_number"},{"question":"def max_gold_trip(t, test_cases): Parameters: t: number of test cases (int) test_cases: List of tuples, each tuple contains: - n: number of boxes (int) - k: maximum boxes the cart can carry at once (int) - boxes: list of integers representing number of gold coins in each box Returns: List of integers, where each integer is the maximum number of gold coins Sophia can carry in one trip for corresponding test case.","solution":"def max_gold_trip(t, test_cases): Parameters: t: number of test cases (int) test_cases: List of tuples, each tuple contains: - n: number of boxes (int) - k: maximum boxes the cart can carry at once (int) - boxes: list of integers representing number of gold coins in each box Returns: List of integers, where each integer is the maximum number of gold coins Sophia can carry in one trip for corresponding test case. result = [] for test in test_cases: n, k, boxes = test max_coins = 0 for i in range(n - k + 1): current_sum = sum(boxes[i:i + k]) if current_sum > max_coins: max_coins = current_sum result.append(max_coins) return result"},{"question":"def can_vasya_win(n: int, array: List[int]) -> str: Determine if Vasya can win the game. Parameters: n (int): The number of elements in the array. array (list of int): The array of integers. Returns: str: \\"YES\\" if Vasya can guarantee a win, otherwise \\"NO\\". Examples: >>> can_vasya_win(3, [1, 2, 3]) \\"YES\\" >>> can_vasya_win(4, [2, 4, 6, 8]) \\"NO\\"","solution":"def can_vasya_win(n, array): Determine if Vasya can win the game. Parameters: n (int): The number of elements in the array. array (list of int): The array of integers. Returns: str: \\"YES\\" if Vasya can guarantee a win, otherwise \\"NO\\". odd_count = sum(1 for x in array if x % 2 != 0) # If there is at least one odd element, Vasya can make the first move and guarantee the win. if odd_count > 0: return \\"YES\\" else: return \\"NO\\""},{"question":"def is_event_possible(N: int, companies_info: List[Tuple[str, str, str]]) -> str: Determine if it's possible to invite a subset of the companies such that no two companies from the same city trade in the same commodity. Args: N (int): Number of trading companies. companies_info (List[Tuple[str, str, str]]): List of tuples with each tuple containing the name of the company, the city they are based in and the commodity they trade in. Returns: str: \\"Yes\\" if it is possible to invite companies such that the condition is met, otherwise \\"No\\". Example: >>> is_event_possible(5, [(\\"AlphaTrade\\", \\"NewYork\\", \\"Gold\\"), (\\"BetaTrade\\", \\"Tokyo\\", \\"Oil\\"), (\\"GammaTrade\\", \\"NewYork\\", \\"Silver\\"), (\\"DeltaTrade\\", \\"Tokyo\\", \\"Gold\\"), (\\"EpsilonTrade\\", \\"NewYork\\", \\"Gold\\")]) \\"No\\" >>> is_event_possible(4, [(\\"AlphaTrade\\", \\"NewYork\\", \\"Gold\\"), (\\"BetaTrade\\", \\"Tokyo\\", \\"Oil\\"), (\\"GammaTrade\\", \\"NewYork\\", \\"Silver\\"), (\\"DeltaTrade\\", \\"Tokyo\\", \\"Gold\\")]) \\"Yes\\" from typing import List, Tuple def test_is_event_possible_case_1(): N = 5 companies_info = [ (\\"AlphaTrade\\", \\"NewYork\\", \\"Gold\\"), (\\"BetaTrade\\", \\"Tokyo\\", \\"Oil\\"), (\\"GammaTrade\\", \\"NewYork\\", \\"Silver\\"), (\\"DeltaTrade\\", \\"Tokyo\\", \\"Gold\\"), (\\"EpsilonTrade\\", \\"NewYork\\", \\"Gold\\") ] assert is_event_possible(N, companies_info) == \\"No\\" def test_is_event_possible_case_2(): N = 4 companies_info = [ (\\"AlphaTrade\\", \\"NewYork\\", \\"Gold\\"), (\\"BetaTrade\\", \\"Tokyo\\", \\"Oil\\"), (\\"GammaTrade\\", \\"NewYork\\", \\"Silver\\"), (\\"DeltaTrade\\", \\"Tokyo\\", \\"Gold\\") ] assert is_event_possible(N, companies_info) == \\"Yes\\" def test_is_event_possible_all_unique(): N = 4 companies_info = [ (\\"AlphaTrade\\", \\"NewYork\\", \\"Gold\\"), (\\"BetaTrade\\", \\"Tokyo\\", \\"Oil\\"), (\\"GammaTrade\\", \\"LosAngeles\\", \\"Silver\\"), (\\"DeltaTrade\\", \\"Miami\\", \\"Gold\\") ] assert is_event_possible(N, companies_info) == \\"Yes\\" def test_is_event_possible_no_companies(): N = 0 companies_info = [] assert is_event_possible(N, companies_info) == \\"Yes\\" def test_is_event_possible_single_company(): N = 1 companies_info = [ (\\"AlphaTrade\\", \\"NewYork\\", \\"Gold\\") ] assert is_event_possible(N, companies_info) == \\"Yes\\"","solution":"def is_event_possible(N, companies_info): city_commodity_map = {} for company in companies_info: name, city, commodity = company if city not in city_commodity_map: city_commodity_map[city] = set() if commodity in city_commodity_map[city]: return \\"No\\" city_commodity_map[city].add(commodity) return \\"Yes\\""},{"question":"def create_shape(n, char): Create a symmetrical diamond shape with n levels using the specified character. :param n: Number of levels :param char: Single character string to construct the diamond :return: String representing the diamond shape or None if input is invalid >>> create_shape(3, '*') ' *n ***n*****n ***n *' >>> create_shape(4, '#') ' #n #n #n#n #n #n #' >>> create_shape(1, '@') '@' >>> create_shape('4', '*') None >>> create_shape(4, '') None >>> create_shape(2, '*') ' *n***n *' >>> create_shape(5, '') ' n n n nn n n n '","solution":"def create_shape(n, char): Create a symmetrical diamond shape with n levels using the specified character. :param n: Number of levels :param char: Single character string to construct the diamond :return: String representing the diamond shape or None if input is invalid if isinstance(n, int) and n > 0 and isinstance(char, str) and len(char) == 1: shape = [] for i in range(n): level = ' ' * (n - i - 1) + char * (2 * i + 1) shape.append(level) for i in range(n-2, -1, -1): level = ' ' * (n - i - 1) + char * (2 * i + 1) shape.append(level) return 'n'.join(shape) return None"},{"question":"from typing import List, Tuple def find_minimum_fuel_cost(N: int, M: int, T: int, routes: List[Tuple[int, int, int]], trips: List[Tuple[int, int]]) -> List[int]: Determine the minimum fuel cost required to travel from a starting city S to a destination city D. Args: N (int): The number of cities. M (int): The number of routes. T (int): The number of trips to be evaluated. routes (List[Tuple[int, int, int]]): Each tuple (u, v, w) indicating a route from city u to city v with a fuel cost w. trips (List[Tuple[int, int]]): Each tuple (S, D) indicating a start city S and a destination city D. Returns: List[int]: For each trip, the minimum fuel cost required to travel from city S to city D, or -1 if it is not possible to travel from S to D. >>> find_minimum_fuel_cost(4, 4, 2, [(0, 1, 10), (0, 2, 15), (1, 3, 20), (2, 3, 30)], [(0, 3), (1, 2)]) [30, -1] >>> find_minimum_fuel_cost(3, 2, 2, [(1, 2, 10), (0, 1, 5)], [(0, 2), (2, 0)]) [15, -1]","solution":"import heapq import sys def dijkstra(graph, start, end): n = len(graph) dist = [sys.maxsize] * n dist[start] = 0 pq = [(0, start)] # (cost, node) while pq: current_dist, u = heapq.heappop(pq) if current_dist > dist[u]: continue for v, weight in graph[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(pq, (distance, v)) return dist[end] if dist[end] != sys.maxsize else -1 def find_minimum_fuel_cost(N, M, T, routes, trips): graph = [[] for _ in range(N)] for u, v, w in routes: graph[u].append((v, w)) results = [] for S, D in trips: results.append(dijkstra(graph, S, D)) return results"},{"question":"def min_operations_to_beautiful_sequence(n: int, arr: List[int]) -> int: This function calculates the minimum number of operations required to make the array a beautiful sequence. Parameters: n (int): The length of the array. arr (list): The array of positive integers. Returns: int: The minimum number of operations needed. >>> min_operations_to_beautiful_sequence(5, [1, 1, 2, 3, 4]) 1 >>> min_operations_to_beautiful_sequence(4, [7, 7, 7, 7]) 3 >>> min_operations_to_beautiful_sequence(6, [1, 2, 1, 2, 1, 2]) 0 # Your code here from typing import List def test_min_operations_single_element(): assert min_operations_to_beautiful_sequence(1, [5]) == 0 def test_min_operations_no_operations_needed(): assert min_operations_to_beautiful_sequence(6, [1, 2, 1, 2, 1, 2]) == 0 def test_min_operations_one_operation_needed(): assert min_operations_to_beautiful_sequence(5, [1, 1, 2, 3, 4]) == 1 def test_min_operations_all_elements_same(): assert min_operations_to_beautiful_sequence(4, [7, 7, 7, 7]) == 3 def test_min_operations_mixed(): assert min_operations_to_beautiful_sequence(5, [1, 2, 2, 3, 3]) == 2","solution":"def min_operations_to_beautiful_sequence(n, arr): This function calculates the minimum number of operations required to make the array a beautiful sequence. Parameters: n (int): The length of the array. arr (list): The array of positive integers. Returns: int: The minimum number of operations needed. if n <= 1: return 0 operations = 0 for i in range(1, n): if arr[i] == arr[i - 1]: operations += 1 return operations"},{"question":"import heapq from typing import List, Tuple def shortest_paths(n: int, m: int, edges: List[Tuple[int, int, int]], s: int) -> List[int]: Determines the shortest path from a source node s to all other nodes in the network. Args: n (int): The number of nodes in the graph. m (int): The number of edges in the graph. edges (List[Tuple[int, int, int]]): A list of edges, each represented by a tuple (u, v, w) where u is the starting node, v is the ending node, and w is the weight of the edge. s (int): The source node from which the shortest paths are to be calculated. Returns: List[int]: A list where the ith element is the shortest distance from the source node s to the node i+1. If a node is not reachable, the distance should be -1. Example: >>> shortest_paths(5, 6, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (3, 4, 7), (2, 5, 10), (5, 4, 3)], 1) [0, 2, 3, 10, 12] >>> shortest_paths(3, 1, [(1, 2, 3)], 2) [-1, 0, -1]","solution":"import heapq def shortest_paths(n, m, edges, s): Determines the shortest path from a source node s to all other nodes in the network. graph = {i: [] for i in range(1, n+1)} for u, v, w in edges: graph[u].append((v, w)) # Distance dictionary, initializing all distances to infinity distances = {i: float('inf') for i in range(1, n+1)} distances[s] = 0 priority_queue = [(0, s)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return [distances[i] if distances[i] != float('inf') else -1 for i in range(1, n+1)]"},{"question":"def longest_divisible_subsequence(N: int, sequence: List[int]) -> int: Determine the length of the longest subsequence where each element is divisible by the previous element. >>> longest_divisible_subsequence(4, [3, 6, 18, 36]) 4 >>> longest_divisible_subsequence(4, [36, 18, 3, 6]) 4 >>> longest_divisible_subsequence(5, [5, 7, 11, 13, 17]) 1 >>> longest_divisible_subsequence(4, [1, 1, 1, 1]) 4 >>> longest_divisible_subsequence(6, [10, 5, 50, 25, 4, 2]) 3 >>> longest_divisible_subsequence(1, [100]) 1 >>> longest_divisible_subsequence(2, [10, 20]) 2 >>> longest_divisible_subsequence(2, [10, 3]) 1","solution":"def longest_divisible_subsequence(N, sequence): Returns the length of the longest subsequence where each element is divisible by the previous element. if not sequence or N == 0: return 0 # Initialize dp array where dp[i] means the length of the longest divisible subsequence ending at index i dp = [1] * len(sequence) # Sort sequence to ensure we can find increasing divisible subsequences sequence.sort() # Fill dp array for i in range(1, len(sequence)): for j in range(i): if sequence[i] % sequence[j] == 0: dp[i] = max(dp[i], dp[j] + 1) # The result is the maximum value in dp array return max(dp)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorderList(head: ListNode) -> None: Reorders the linked list such that it looks like: L0  Ln  L1  Ln-1  L2  Ln-2  ... This function modifies the linked list in-place. >>> head = array_to_list([1, 2, 3, 4, 5]) >>> reorderList(head) >>> list_to_array(head) [1, 5, 2, 4, 3] >>> head = array_to_list([1, 2, 3, 4]) >>> reorderList(head) >>> list_to_array(head) [1, 4, 2, 3] >>> head = array_to_list([1]) >>> reorderList(head) >>> list_to_array(head) [1] >>> head = array_to_list([1, 2]) >>> reorderList(head) >>> list_to_array(head) [1, 2] >>> head = array_to_list([]) >>> reorderList(head) >>> list_to_array(head) [] pass # Helper functions for testing def list_to_array(head): arr = [] while head: arr.append(head.val) head = head.next return arr def array_to_list(arr): dummy = ListNode(0) current = dummy for val in arr: current.next = ListNode(val) current = current.next return dummy.next","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorderList(head: ListNode) -> None: Reorders the linked list according to the pattern L0  Ln  L1  Ln-1  L2  Ln-2  ... Modifies the linked list in-place. if not head or not head.next: return # Step 1: Find the middle of the linked list slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next # Step 2: Reverse the second half of the linked list prev, curr = None, slow while curr: next_temp = curr.next curr.next = prev prev = curr curr = next_temp # Step 3: Merge the two halves first, second = head, prev while second.next: temp1 = first.next temp2 = second.next first.next = second second.next = temp1 first = temp1 second = temp2"},{"question":"def maximum_bees(T: int, test_cases: List[Tuple[Tuple[int, int], List[List[int]]]]) -> List[int]: Simon is a beekeeper, and he looks after a large rectangular beehive that can be represented as a grid with N rows and M columns. Each cell in the grid is initialized with a certain number of bees. Simon's task is to move his bees around in such a manner that he can maximize the number of bees in any single cell. Simon may choose to move bees from one cell to any of its 8 neighboring cells (up, down, left, right, and the four diagonals), but he cannot move a bee outside the grid. He can repeat the same type of move any number of times. Given the initial configuration of bees in the grid, determine the maximum number of bees that can be achieved in a single cell after making optimal moves. >>> test_cases = [ [(3, 3), [[1, 2, 3], [4, 5, 6], [7, 8, 9]]], [(2, 2), [[1, 0], [0, 1]]] ] >>> maximum_bees(2, test_cases) [45, 2] >>> test_cases = [ [(3, 4), [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]] ] >>> maximum_bees(1, test_cases) [78]","solution":"def maximum_bees(T, test_cases): results = [] for i in range(T): N, M = test_cases[i][0] grid = test_cases[i][1] max_bees = 0 total_bees = 0 for row in grid: for bees in row: total_bees += bees results.append(total_bees) return results"},{"question":"def rotate_string_right(s: str, k: int) -> str: Rotates string \`s\` to the right by \`k\` positions. >>> rotate_string_right(\\"hello\\", 2) \\"lohel\\" >>> rotate_string_right(\\"hello\\", 0) \\"hello\\"","solution":"def rotate_string_right(s, k): Rotates string \`s\` to the right by \`k\` positions. if not s: return s k = k % len(s) # Handle cases where k is greater than length of the string return s[-k:] + s[:-k]"},{"question":"def smallest_lexicographical_permutation(S: str) -> str: Returns the smallest lexicographical permutation of S obtained by removing at most one character. >>> smallest_lexicographical_permutation(\\"abc\\") == \\"ab\\" >>> smallest_lexicographical_permutation(\\"cbda\\") == \\"bda\\" >>> smallest_lexicographical_permutation(\\"azby\\") == \\"aby\\" >>> smallest_lexicographical_permutation(\\"aaaa\\") == \\"aaa\\" >>> smallest_lexicographical_permutation(\\"cba\\") == \\"ba\\" >>> smallest_lexicographical_permutation(\\"acbd\\") == \\"abd\\" >>> smallest_lexicographical_permutation(\\"za\\") == \\"a\\"","solution":"def smallest_lexicographical_permutation(S): Returns the smallest lexicographical permutation of S obtained by removing at most one character. smallest_permutation = S[1:] # Remove the first character initially to start the comparison. for i in range(len(S)): # Remove the i-th character and get the resulting string current_permutation = S[:i] + S[i+1:] # Compare and update the smallest permutation if current_permutation < smallest_permutation: smallest_permutation = current_permutation return smallest_permutation"},{"question":"def detect_cycle(n: int, edges: List[int]) -> Union[str, int]: Detects cycle and the starting node of the cycle in the linked list using Floyd's Tortoise and Hare algorithm. :param n: Number of nodes in the linked list :param edges: List of integers representing the next node connections for each node :return: \\"No cycle\\" or the 1-based index of the first node in the cycle >>> detect_cycle(5, [2, 3, 4, 5, -1]) \\"No cycle\\" >>> detect_cycle(4, [2, 3, 4, 2]) 2","solution":"def detect_cycle(n, edges): Detects cycle and the starting node of the cycle in the linked list using Floyd's Tortoise and Hare algorithm. :param n: Number of nodes in the linked list :param edges: List of integers representing the next node connections for each node :return: \\"No cycle\\" or the 1-based index of the first node in the cycle if n == 1: return \\"No cycle\\" if edges[0] == -1 else 1 def get_next_index(i): return edges[i] - 1 if edges[i] != -1 else -1 tortoise = get_next_index(0) hare = get_next_index(get_next_index(0)) while tortoise != -1 and hare != -1 and tortoise != hare: tortoise = get_next_index(tortoise) hare = get_next_index(get_next_index(hare)) if hare == -1 or tortoise == -1: return \\"No cycle\\" tortoise = 0 while tortoise != hare: tortoise = get_next_index(tortoise) hare = get_next_index(hare) return tortoise + 1"},{"question":"def max_coins(T: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Mario loves to collect coins in a grid-like castle. Determine the maximum number of coins Mario can collect if he always starts from (0, 0) and moves to (R-1, C-1). Parameters: - T (int): The number of test cases. - test_cases (List[Tuple[int, int, List[List[int]]]]): Each test case is a tuple containing: - R (int): The number of rows in the grid. - C (int): The number of columns in the grid. - grid (List[List[int]]): The grid representing the castle. Returns: - List[int]: The maximum number of coins Mario can collect for each test case. Example: >>> T = 2 >>> test_cases = [ ... (3, 3, [ ... [0, 1, 0], ... [1, 0, 1], ... [0, 1, 1] ... ]), ... (2, 2, [ ... [1, 1], ... [0, 1] ... ]) ... ] >>> max_coins(T, test_cases) [3, 3]","solution":"def max_coins(T, test_cases): results = [] for r, c, grid in test_cases: dp = [[0] * c for _ in range(r)] dp[0][0] = grid[0][0] for i in range(r): for j in range(c): if i > 0: dp[i][j] = max(dp[i][j], dp[i-1][j] + grid[i][j]) if j > 0: dp[i][j] = max(dp[i][j], dp[i][j-1] + grid[i][j]) results.append(dp[-1][-1]) return results # Example usage: # T = 2 # test_cases = [ # (3, 3, [ # [0, 1, 0], # [1, 0, 1], # [0, 1, 1] # ]), # (2, 2, [ # [1, 1], # [0, 1] # ]) # ] # output = max_coins(T, test_cases) # print(output) # Output: [3, 3]"},{"question":"def max_min_precipitation(n: int, k: int, precipitation: List[int]) -> Tuple[int, int]: Returns the maximum and minimum amounts of precipitation that occurred on exactly k consecutive days. :param n: The total number of days :param k: The number of consecutive days :param precipitation: List of precipitation amounts for each day :return: Tuple containing the maximum and minimum precipitation amounts Examples: >>> max_min_precipitation(7, 3, [2, 1, 5, 7, 9, 3, 4]) (21, 8) >>> max_min_precipitation(5, 2, [5, 5, 5, 5, 5]) (10, 10) >>> max_min_precipitation(6, 2, [6, 5, 4, 3, 2, 1]) (11, 3) >>> max_min_precipitation(5, 2, [1, 2, 3, 4, 5]) (9, 3) >>> max_min_precipitation(4, 1, [3, 8, 2, 6]) (8, 2) >>> max_min_precipitation(4, 4, [4, 2, 9, 1]) (16, 16)","solution":"def max_min_precipitation(n, k, precipitation): Returns the maximum and minimum amounts of precipitation that occurred on exactly k consecutive days. :param n: The total number of days :param k: The number of consecutive days :param precipitation: List of precipitation amounts for each day :return: Tuple containing the maximum and minimum precipitation amounts max_precip = float('-inf') min_precip = float('inf') for i in range(n - k + 1): current_sum = sum(precipitation[i:i + k]) if current_sum > max_precip: max_precip = current_sum if current_sum < min_precip: min_precip = current_sum return max_precip, min_precip # Example usage # n, k = 7, 3 # precipitation = [2, 1, 5, 7, 9, 3, 4] # max_min_precipitation(n, k, precipitation) # Output: (21, 8)"},{"question":"def rotate_string(k, s): Rotates each character in the string s by k positions in the alphabet. Parameters: k (int): Number of positions to rotate each character (0 <= k <= 25) s (str): String to be encrypted consisting of lowercase English letters (1 <= len(s) <= 10^6) Returns: str: Encrypted string after rotating each character by k positions Example: >>> rotate_string(3, \\"abc\\") 'def' >>> rotate_string(1, 'xyz') 'yza' def process_test_cases(test_cases): Process the test cases and return the results for all the test cases. Parameters: test_cases (list of tuple): List of test cases where each test case is a tuple (k, s) Returns: list: List of results for each test case Example: >>> process_test_cases([(3, \\"abc\\"), (1, \\"xyz\\")]) ['def', 'yza'] from solution import process_test_cases, rotate_string def test_rotate_string(): assert rotate_string(3, \\"abc\\") == \\"def\\" assert rotate_string(1, \\"xyz\\") == \\"yza\\" assert rotate_string(0, \\"hello\\") == \\"hello\\" assert rotate_string(25, \\"abc\\") == \\"zab\\" assert rotate_string(3, \\"xyz\\") == \\"abc\\" def test_process_test_cases(): test_cases = [(3, \\"abc\\"), (1, \\"xyz\\"), (0, \\"hello\\"), (25, \\"abc\\"), (3, \\"xyz\\")] expected_results = [\\"def\\", \\"yza\\", \\"hello\\", \\"zab\\", \\"abc\\"] assert process_test_cases(test_cases) == expected_results","solution":"def rotate_string(k, s): Rotates each character in the string s by k positions in the alphabet. rotated_str = [] for char in s: rotated_char = chr(((ord(char) - ord('a') + k) % 26) + ord('a')) rotated_str.append(rotated_char) return ''.join(rotated_str) def process_test_cases(test_cases): Process the test cases and return the results for all the test cases. results = [] for k, s in test_cases: result = rotate_string(k, s) results.append(result) return results"},{"question":"from typing import List, Tuple def is_sum_compliant(lst: List[int], target: int) -> str: Checks if there is a pair of distinct indices in the list such that the sum of the elements at those indices is equal to the target integer. >>> is_sum_compliant([1, 2, 3, 4], 5) == \\"sum-compliant\\" >>> is_sum_compliant([1, 1, 1, 1, 1], 2) == \\"sum-compliant\\" >>> is_sum_compliant([-5, -4, -3, -2, -1, 0], -10) == \\"sum-noncompliant\\" pass def find_compliance(test_cases: List[Tuple[int, List[int], int]]) -> List[str]: Processes multiple test cases and returns the results. >>> test_cases = [ ... (4, [1, 2, 3, 4], 5), ... (5, [1, 1, 1, 1, 1], 2), ... (6, [-5, -4, -3, -2, -1, 0], -10) ... ] >>> find_compliance(test_cases) == [\\"sum-compliant\\", \\"sum-compliant\\", \\"sum-noncompliant\\"] pass def main(input_data: str) -> List[str]: Given the input data containing multiple test cases, returns the compliance results as a list of strings. >>> input_data = \\"3n4n1 2 3 4n5n5n1 1 1 1 1n2n6n-5 -4 -3 -2 -1 0n-10\\" >>> main(input_data) == [\\"sum-compliant\\", \\"sum-compliant\\", \\"sum-noncompliant\\"] pass","solution":"def is_sum_compliant(lst, target): Checks if there is a pair of distinct indices in the list such that the sum of the elements at those indices is equal to the target integer. seen = set() for number in lst: if target - number in seen: return \\"sum-compliant\\" seen.add(number) return \\"sum-noncompliant\\" def find_compliance(test_cases): Processes multiple test cases and returns the results. results = [] for n, lst, target in test_cases: result = is_sum_compliant(lst, target) results.append(result) return results # Example usage: def main(input_data): lines = input_data.strip().split(\\"n\\") T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): n = int(lines[index]) lst = list(map(int, lines[index + 1].split())) target = int(lines[index + 2]) test_cases.append((n, lst, target)) index += 3 results = find_compliance(test_cases) return results"},{"question":"def highest_productivity_team(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the team with the highest productivity. Args: T: Number of test cases test_cases: A list of tuples containing the number of tasks and a list of team IDs that completed each task in chronological order. Returns: A list of team IDs with the highest productivity for each test case. >>> highest_productivity_team(3, [(5, [1, 2, 1, 3, 2]), (4, [4, 4, 4, 4]), (6, [2, 3, 2, 3, 2, 3])]) [1, 4, 2] >>> highest_productivity_team(1, [(3, [1, 1, 1])]) [1] >>> highest_productivity_team(1, [(5, [1, 2, 2, 1, 2])]) [2] >>> highest_productivity_team(1, [(1, [3])]) [3] >>> highest_productivity_team(1, [(7, [3, 1, 3, 2, 3, 1, 1])]) [3] >>> highest_productivity_team(1, [(6, [2, 1, 3, 2, 1, 3])]) [2]","solution":"def highest_productivity_team(T, test_cases): results = [] for case in test_cases: N, tasks = case team_productivity = {} for idx, team in enumerate(tasks): if team not in team_productivity: team_productivity[team] = (0, idx) team_productivity[team] = (team_productivity[team][0] + 1, team_productivity[team][1]) max_productivity = -1 best_team = None for team, (count, first_index) in team_productivity.items(): if count > max_productivity or (count == max_productivity and first_index < team_productivity[best_team][1]): max_productivity = count best_team = team results.append(best_team) return results"},{"question":"def filter_primes(input_list): Filters and returns the list with only the prime numbers from the original list. A prime number is a natural number greater than 1 that is not a product of two smaller natural numbers. >>> filter_primes([4, 5, 6, 7, 8]) # returns [5, 7] >>> filter_primes([2, 3, 5, 7, 11]) # returns [2, 3, 5, 7, 11] >>> filter_primes([4, 6, 8, 10, 12]) # returns [] >>> filter_primes([]) # returns [] >>> filter_primes([-10, -3, -7, 0, 1, 2, 3, 17]) # returns [2, 3, 17] >>> filter_primes([101, 103, 105, 107]) # returns [101, 103, 107]","solution":"def is_prime(n): Determines whether a given number n is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(input_list): Filters the prime numbers from the input list. return [num for num in input_list if is_prime(num)]"},{"question":"def solve_fibonacci_cases(test_cases: List[int]) -> List[int]: Chris is fascinated by Fibonacci numbers and has recently come across a new challenge. He wants to write a program that generates the nth Fibonacci number efficiently. The Fibonacci sequence is defined as follows: F(0) = 0 F(1) = 1 F(n) = F(n-1) + F(n-2) for n >= 2 Chris wants you to help him by writing a function that computes the nth Fibonacci number modulo 10^9 + 7. >>> solve_fibonacci_cases([0]) [0] >>> solve_fibonacci_cases([1]) [1] >>> solve_fibonacci_cases([10]) [55] >>> solve_fibonacci_cases([0, 1, 10, 20]) [0, 1, 55, 6765] pass # Implement function here if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"MOD = 10**9 + 7 def matrix_multiply(A, B, mod=MOD): Multiplies two 2x2 matrices A and B under modulo. return [ [(A[0][0] * B[0][0] + A[0][1] * B[1][0]) % mod, (A[0][0] * B[0][1] + A[0][1] * B[1][1]) % mod], [(A[1][0] * B[0][0] + A[1][1] * B[1][0]) % mod, (A[1][0] * B[0][1] + A[1][1] * B[1][1]) % mod] ] def matrix_power(matrix, n, mod=MOD): Computes the power of a matrix to the nth power under modulo. result = [[1, 0], [0, 1]] # identity matrix base = matrix while n > 0: if n % 2 == 1: result = matrix_multiply(result, base, mod) base = matrix_multiply(base, base, mod) n //= 2 return result def fibonacci_mod(n, mod=MOD): Computes the nth Fibonacci number modulo mod using matrix exponentiation. if n == 0: return 0 if n == 1: return 1 F = [[1, 1], [1, 0]] # Fibonacci transformation matrix result_matrix = matrix_power(F, n-1, mod) return result_matrix[0][0] # F(n) def solve_fibonacci_cases(test_cases): results = [fibonacci_mod(n) for n in test_cases] return results"},{"question":"def group_candies(candies): Groups candies by the first letter of their names. Args: candies (list of str): List of candy names. Returns: dict: Dictionary with keys as the first letters of the candy names (in uppercase) and values as lists of candies starting with that letter, maintaining the original case. >>> group_candies(['Chocolate', 'caramel', 'Candy', 'cinnamon', 'lollipop', 'licorice']) {'C': ['Chocolate', 'caramel', 'Candy', 'cinnamon'], 'L': ['lollipop', 'licorice']} >>> group_candies(['apple', 'banana', 'pear', 'Peach', 'plum', 'BLUEBERRY']) {'A': ['apple'], 'B': ['banana', 'BLUEBERRY'], 'P': ['pear', 'Peach', 'plum']}","solution":"def group_candies(candies): Groups candies by the first letter of their names. Args: candies (list of str): List of candy names. Returns: dict: Dictionary with keys as the first letters of the candy names (in uppercase) and values as lists of candies starting with that letter, maintaining the original case. grouped_candies = {} for candy in candies: first_letter = candy[0].upper() if first_letter not in grouped_candies: grouped_candies[first_letter] = [] grouped_candies[first_letter].append(candy) return grouped_candies"},{"question":"def max_subsequences(s: str) -> int: Returns the maximum number of subsequences that can be found in the string such that each subsequence consists of all seven colors in the same order as \\"ROYGBIV\\". :param s: The input string representing the sequence of colored beads :return: The maximum number of subsequences that can be formed >>> max_subsequences(\\"ROYGBIVROYGBIV\\") 2 >>> max_subsequences(\\"RROYYGGBBOBBIIVV\\") 1 >>> max_subsequences(\\"ROYGBIV\\") 1 >>> max_subsequences(\\"RRRYYYGGG\\") 0 >>> max_subsequences(\\"RROOYGYBBIIVVGG\\") 1 >>> max_subsequences(\\"RRROOYYGGGBBBIIIVVVROOYGGIV\\") 2","solution":"def max_subsequences(s): Returns the maximum number of subsequences that can be found in the string such that each subsequence consists of all seven colors in the same order as \\"ROYGBIV\\". target = \\"ROYGBIV\\" target_length = len(target) count = [0] * target_length for char in s: if char == 'R': count[0] += 1 elif char == 'O' and count[0] > count[1]: count[1] += 1 elif char == 'Y' and count[1] > count[2]: count[2] += 1 elif char == 'G' and count[2] > count[3]: count[3] += 1 elif char == 'B' and count[3] > count[4]: count[4] += 1 elif char == 'I' and count[4] > count[5]: count[5] += 1 elif char == 'V' and count[5] > count[6]: count[6] += 1 return count[6]"},{"question":"def build_hierarchy(employee_manager_list): Builds the employee hierarchy as a nested dictionary. >>> build_hierarchy([('Alice', 'None'), ('Bob', 'Alice'), ('Charlie', 'Alice'), ('David', 'Bob'), ('Eve', 'Charlie')]) {'Alice': {'Bob': {'David': {}}, 'Charlie': {'Eve': {}}}} >>> build_hierarchy([('Tom', 'None'), ('Jerry', 'Tom'), ('Spike', 'Tom'), ('Tyke', 'Spike')]) {'Tom': {'Jerry': {}, 'Spike': {'Tyke': {}}}} >>> build_hierarchy([('John', 'None')]) {'John': {}} >>> build_hierarchy([('Sara', 'None'), ('Carlos', 'Sara'), ('Catherine', 'Carlos'), ('Anna', 'Carlos'), ('Mark', 'Catherine'), ('Luke', 'Anna')]) {'Sara': {'Carlos': {'Catherine': {'Mark': {}}, 'Anna': {'Luke': {}}}}}","solution":"def build_hierarchy(employee_manager_list): Builds the employee hierarchy as a nested dictionary. # Create a dictionary to store all employees and their subordinates hierarchy = {} # Create a mapping from employee to manager employee_to_manager = {} for employee, manager in employee_manager_list: employee_to_manager[employee] = manager hierarchy[employee] = {} # Identify the CEO (the one with 'None' as manager) ceo = None for employee, manager in employee_manager_list: if manager == 'None': ceo = employee # Populate the hierarchy for employee, manager in employee_manager_list: if manager != 'None': hierarchy[manager][employee] = hierarchy[employee] return {ceo: hierarchy[ceo]}"},{"question":"def currentHolders(transactions: List[str]) -> dict: Determine the current holder of each book based on a list of transactions. Args: transactions (list): A list of transaction strings. Returns: dict: A dictionary with barcodes as keys and either the memberID of the current holder or \\"available\\" as values. >>> currentHolders([ ... \\"Borrow M1 B1\\", ... \\"Borrow M2 B2\\", ... \\"Return B1\\", ... \\"Borrow M1 B3\\", ... \\"Return B2\\" ... ]) {'B1': 'available', 'B2': 'available', 'B3': 'M1'} >>> currentHolders([ ... \\"Borrow M1 B1\\", ... \\"Borrow M2 B2\\", ... \\"Borrow M1 B3\\" ... ]) {'B1': 'M1', 'B2': 'M2', 'B3': 'M1'} >>> currentHolders([ ... \\"Borrow M1 B1\\", ... \\"Return B1\\", ... \\"Borrow M2 B2\\", ... \\"Return B2\\", ... \\"Borrow M1 B3\\", ... \\"Return B3\\" ... ]) {'B1': 'available', 'B2': 'available', 'B3': 'available'} >>> currentHolders([ ... \\"Borrow M1 B1\\", ... \\"Return B1\\", ... \\"Borrow M2 B2\\", ... \\"Borrow M3 B3\\", ... \\"Return B2\\", ... \\"Borrow M1 B4\\", ... \\"Return B3\\" ... ]) {'B1': 'available', 'B2': 'available', 'B3': 'available', 'B4': 'M1'} >>> currentHolders([]) {}","solution":"def currentHolders(transactions): books = {} for transaction in transactions: parts = transaction.split() if parts[0] == \\"Borrow\\": memberID = parts[1] barcode = parts[2] books[barcode] = memberID elif parts[0] == \\"Return\\": barcode = parts[1] if barcode in books: books[barcode] = \\"available\\" return books"},{"question":"def isCyclic(V, adj): Check if a directed graph has a cycle. Parameters: V (int): Number of vertices. adj (list of lists): Adjacency list of the graph. Returns: bool: True if graph contains a cycle, False otherwise. Examples: >>> isCyclic(4, [[], [2], [3], []]) False >>> isCyclic(3, [[1], [2], [0]]) True","solution":"def isCyclic(V, adj): Check if a directed graph has a cycle. Parameters: V (int): Number of vertices. adj (list of lists): Adjacency list of the graph. Returns: bool: True if graph contains a cycle, False otherwise. def dfs(v): visited[v] = True recursionStack[v] = True for neighbor in adj[v]: if not visited[neighbor]: if dfs(neighbor): return True elif recursionStack[neighbor]: return True recursionStack[v] = False return False visited = [False] * V recursionStack = [False] * V for node in range(V): if not visited[node]: if dfs(node): return True return False"},{"question":"def spiral_sum(T: int, test_cases: List[Tuple[int, int, List[List[int]], str]]) -> List[int]: Compute the sum of the heights of the trees in either a clockwise or counterclockwise spiral order. Input: - T: Number of test cases - test_cases: List of tuples containing - m, n: Number of rows and columns - matrix: 2D list representing the heights of the trees - direction: \\"clockwise\\" or \\"counterclockwise\\" Output: - List of sums of the heights of the trees in the specified spiral order for each test case. Example: >>> spiral_sum(2, [ (3, 3, [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ], \\"clockwise\\"), (4, 4, [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ], \\"counterclockwise\\") ]) [45, 136] >>> spiral_sum(1, [ (4, 4, [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ], \\"clockwise\\") ]) [136] >>> spiral_sum(1, [ (1, 1, [ [1] ], \\"clockwise\\") ]) [1] >>> spiral_sum(1, [ (1, 5, [ [1, 2, 3, 4, 5] ], \\"counterclockwise\\") ]) [15] >>> spiral_sum(1, [ (5, 1, [ [1], [2], [3], [4], [5] ], \\"clockwise\\") ]) [15]","solution":"def spiral_sum(T, test_cases): def spiral_order(matrix, m, n, direction=\\"clockwise\\"): result = [] if direction == \\"clockwise\\": left, right, top, bottom = 0, n - 1, 0, m - 1 while left <= right and top <= bottom: for i in range(left, right + 1): result.append(matrix[top][i]) top += 1 for i in range(top, bottom + 1): result.append(matrix[i][right]) right -= 1 if top <= bottom: for i in range(right, left - 1, -1): result.append(matrix[bottom][i]) bottom -= 1 if left <= right: for i in range(bottom, top - 1, -1): result.append(matrix[i][left]) left += 1 else: # counterclockwise left, right, top, bottom = 0, n - 1, 0, m - 1 while left <= right and top <= bottom: for i in range(top, bottom + 1): result.append(matrix[i][left]) left += 1 for i in range(left, right + 1): result.append(matrix[bottom][i]) bottom -= 1 if left <= right: for i in range(bottom, top - 1, -1): result.append(matrix[i][right]) right -= 1 if top <= bottom: for i in range(right, left - 1, -1): result.append(matrix[top][i]) top += 1 return result results = [] for case in test_cases: m, n, matrix, direction = case flattened_spiral = spiral_order(matrix, m, n, direction) results.append(sum(flattened_spiral)) return results"},{"question":"def path_tracer(T, instructions_list): Determines the final position of the path tracer after executing the instructions. Parameters: T (int): The number of test cases. instructions_list (List[str]): A list of instruction strings. Returns: List[str]: A list of final coordinates as strings. >>> path_tracer(2, [\\"UDFBLR\\", \\"UDUDUDU\\"]) [\\"0 0 0\\", \\"0 0 1\\"] >>> path_tracer(1, [\\"U\\"]) [\\"0 0 1\\"] >>> path_tracer(1, [\\"D\\"]) [\\"0 0 -1\\"] >>> path_tracer(1, [\\"F\\"]) [\\"0 1 0\\"]","solution":"def path_tracer(T, instructions_list): Determines the final position of the path tracer after executing the instructions. Parameters: T (int): The number of test cases. instructions_list (List[str]): A list of instruction strings. Returns: List[str]: A list of final coordinates as strings. results = [] direction_mappings = { 'U': (0, 0, 1), 'D': (0, 0, -1), 'F': (0, 1, 0), 'B': (0, -1, 0), 'L': (-1, 0, 0), 'R': (1, 0, 0), } for instructions in instructions_list: x, y, z = 0, 0, 0 for direction in instructions: dx, dy, dz = direction_mappings[direction] x += dx y += dy z += dz results.append(f\\"{x} {y} {z}\\") return results"},{"question":"def lexicographically_smallest_string(string: str) -> str: Returns the lexicographically smallest string that can be achieved after any number of operations. >>> lexicographically_smallest_string(\\"ab\\") 'a' >>> lexicographically_smallest_string(\\"Ba\\") 'B' >>> lexicographically_smallest_string(\\"aAb\\") 'A' def process_test_cases(test_cases: List[str]) -> List[str]: Processes multiple test cases and returns the results for each. >>> process_test_cases([\\"ab\\", \\"Ba\\", \\"aAb\\"]) ['a', 'B', 'A'] >>> process_test_cases([\\"abcABC\\", \\"zZyYxX\\"]) ['A', 'X'] >>> process_test_cases([\\"aa\\", \\"BB\\"]) ['a', 'B']","solution":"def lexicographically_smallest_string(string): Returns the lexicographically smallest string that can be achieved after any number of operations. The final resultant string will be the smallest character in the given string. return min(string) def process_test_cases(test_cases): Processes multiple test cases and returns the results for each. results = [] for case in test_cases: results.append(lexicographically_smallest_string(case)) return results"},{"question":"def remove_plates(stack, target_position): Repeatedly removes plates from the stack until the plate at the target position is on top. :param stack: List of integers representing the stack of plates from top to bottom. :param target_position: Integer representing the target position of the plate within the stack. :return: List of integers representing the sequence of removed plates. pass # Example test cases def test_remove_plates_example(): stack = [10, 20, 30, 40, 50] target_position = 3 assert remove_plates(stack, target_position) == [10, 20] def test_remove_plates_to_first_position(): stack = [1, 2, 3, 4, 5] target_position = 1 assert remove_plates(stack, target_position) == [] def test_remove_plates_full_stack_except_last(): stack = [5, 4, 3, 2, 1] target_position = 5 assert remove_plates(stack, target_position) == [5, 4, 3, 2] def test_remove_plates_middle_position(): stack = [6, 7, 8, 9, 10] target_position = 4 assert remove_plates(stack, target_position) == [6, 7, 8] def test_remove_plates_full_stack(): stack = [11, 12, 13, 14] target_position = 4 assert remove_plates(stack, target_position) == [11, 12, 13]","solution":"def remove_plates(stack, target_position): Repeatedly removes plates from the stack until the plate at the target position is on top. :param stack: List of integers representing the stack of plates from top to bottom. :param target_position: Integer representing the target position of the plate within the stack. :return: List of integers representing the sequence of removed plates. removed_plates = [] # Calculate the number of plates to remove num_to_remove = target_position - 1 while num_to_remove > 0: removed_plates.append(stack.pop(0)) num_to_remove -= 1 return removed_plates"},{"question":"def can_place_tetromino(grid, tetromino, pos_x, pos_y): Checks if a given tetromino can be placed on the grid at the specified position without overlapping any filled cells. :param grid: List of strings representing the grid :param tetromino: List of tuples representing the relative positions of the tetromino cells :param pos_x: Integer representing the x-coordinate of the top-left cell of the tetromino :param pos_y: Integer representing the y-coordinate of the top-left cell of the tetromino :return: \\"YES\\" if the tetromino can be placed without overlapping any filled cells, otherwise \\"NO\\" pass def tetris_fit_checker(n, m, grid, t, tetromino, x, y): pass if __name__ == \\"__main__\\": n, m = map(int, input().split()) grid = [input().strip() for _ in range(n)] t = int(input().strip()) tetromino = [tuple(map(int, input().split())) for _ in range(t)] x, y = map(int, input().split()) print(tetris_fit_checker(n, m, grid, t, tetromino, x, y)) # Unit Test def test_tetris_fit_checker_simple_yes(): n = 5 m = 5 grid = [ '.....', '.....', '.....', '.....', '.....' ] t = 4 tetromino = [(0, 0), (0, 1), (1, 0), (1, 1)] x = 2 y = 2 assert tetris_fit_checker(n, m, grid, t, tetromino, x, y) == \\"YES\\" def test_tetris_fit_checker_simple_no(): n = 5 m = 5 grid = [ '#....', '.....', '.....', '.....', '.....' ] t = 4 tetromino = [(0, 0), (0, 1), (1, 0), (2, 0)] x = 0 y = 0 assert tetris_fit_checker(n, m, grid, t, tetromino, x, y) == \\"NO\\" def test_tetris_fit_checker_complex_no(): n = 5 m = 5 grid = [ '.....', '.....', '.....', '...', '.....' ] t = 4 tetromino = [(0, 0), (0, 1), (1, 0), (1, 1)] x = 2 y = 2 assert tetris_fit_checker(n, m, grid, t, tetromino, x, y) == \\"NO\\" def test_tetris_fit_checker_edge_case_no(): n = 5 m = 5 grid = [ '...', '.....', '.....', '.....', '.....' ] t = 4 tetromino = [(0, 0), (0, 1), (1, 0), (1, 1)] x = 0 y = 0 assert tetris_fit_checker(n, m, grid, t, tetromino, x, y) == \\"NO\\" def test_tetris_fit_checker_edge_case_yes(): n = 5 m = 5 grid = [ '.....', '.....', '.....', '.....', '.....' ] t = 4 tetromino = [(0, 0), (0, 1), (1, 0), (1, 1)] x = 0 y = 0 assert tetris_fit_checker(n, m, grid, t, tetromino, x, y) == \\"YES\\"","solution":"def can_place_tetromino(grid, tetromino, pos_x, pos_y): Checks if a given tetromino can be placed on the grid at the specified position without overlapping any filled cells. :param grid: List of strings representing the grid :param tetromino: List of tuples representing the relative positions of the tetromino cells :param pos_x: Integer representing the x-coordinate of the top-left cell of the tetromino :param pos_y: Integer representing the y-coordinate of the top-left cell of the tetromino :return: \\"YES\\" if the tetromino can be placed without overlapping any filled cells, otherwise \\"NO\\" n = len(grid) m = len(grid[0]) for dr, dc in tetromino: r, c = pos_x + dr, pos_y + dc if r < 0 or r >= n or c < 0 or c >= m: return \\"NO\\" if grid[r][c] == '#': return \\"NO\\" return \\"YES\\" def tetris_fit_checker(n, m, grid, t, tetromino, x, y): return can_place_tetromino(grid, tetromino, x, y) if __name__ == \\"__main__\\": n, m = map(int, input().split()) grid = [input().strip() for _ in range(n)] t = int(input().strip()) tetromino = [tuple(map(int, input().split())) for _ in range(t)] x, y = map(int, input().split()) print(tetris_fit_checker(n, m, grid, t, tetromino, x, y))"},{"question":"def min_roads_to_remove(n, m, edges): Determine the minimum number of roads to remove to make the city layout a simple path or a simple cycle. Args: n (int): The number of intersections. m (int): The number of roads. edges (List[Tuple[int, int, int]]): Each tuple contains three integers, u, v, t meaning there is a road between intersection u and intersection v with travel time t. Returns: int: The minimum number of roads that need to be removed to make the city layout a simple path or a simple cycle. >>> min_roads_to_remove(5, 5, [(1, 2, 10), (2, 3, 15), (3, 4, 10), (4, 5, 5), (3, 5, 3)]) == 1 >>> min_roads_to_remove(4, 5, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 4, 1), (2, 4, 1)]) == 2 >>> min_roads_to_remove(3, 3, [(1, 2, 5), (1, 3, 5), (2, 3, 5)]) == 1 >>> min_roads_to_remove(6, 7, [(1, 2, 10), (2, 3, 10), (3, 4, 10), (4, 5, 10), (5, 6, 10), (1, 6, 5), (3, 6, 5)]) == 2 >>> min_roads_to_remove(2, 1, [(1, 2, 10)]) == 0","solution":"def min_roads_to_remove(n, m, edges): Determine the minimum number of roads to remove to make the city layout a simple path or a simple cycle. from collections import defaultdict import heapq def find(parent, x): if parent[x] != x: parent[x] = find(parent, parent[x]) return parent[x] def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 edges.sort(key=lambda x: x[2]) # Sort edges by travel time parent = list(range(n + 1)) rank = [0] * (n + 1) mst_edges = [] num_edges_in_mst = 0 total_weight = 0 for u, v, t in edges: if find(parent, u) != find(parent, v): union(parent, rank, u, v) mst_edges.append((u, v, t)) total_weight += t num_edges_in_mst += 1 # m - (n - 1) gives us the number of excess edges, need to remove minimum such edges return m - num_edges_in_mst"},{"question":"def organize_books(T: int, test_cases: List[Dict[str, Any]]) -> str: Maria loves reading books and wants to organize her collection by authors. Each of the next N lines contains two space-separated strings, the author's name and the title of the book. Args: - T: Integer, number of test cases. - test_cases: List of dictionaries, each containing 'N' and 'books' key with respective values. Returns: - A formatted string containing authors and their sorted book titles per the given constraints. >>> organize_books(2, [ ... {'N': 3, 'books': ['Rowling_Potter1', 'Rowling_Potter2', 'Martin_Thrones']}, ... {'N': 4, 'books': ['Tolkein_Rings1', 'Rowling_Potter3', 'Tolkein_Rings2', 'Lewis_Narnia']} ... ]) \\"Martin ThronesnRowling Potter1 Potter2nnLewis NarnianRowling Potter3nTolkein Rings1 Rings2\\"","solution":"def organize_books(T, test_cases): results = [] for i in range(T): N = test_cases[i]['N'] books = test_cases[i]['books'] author_dict = {} for book in books: author, title = book.split('_') if author not in author_dict: author_dict[author] = [] author_dict[author].append(title) sorted_authors = sorted(author_dict.keys()) case_result = [] for author in sorted_authors: titles = sorted(author_dict[author]) case_result.append(f\\"{author} {' '.join(titles)}\\") results.append(\\"n\\".join(case_result)) return \\"nn\\".join(results) # Example usage: # T = 2 # test_cases = [ # {'N': 3, 'books': ['Rowling_Potter1', 'Rowling_Potter2', 'Martin_Thrones']}, # {'N': 4, 'books': ['Tolkein_Rings1', 'Rowling_Potter3', 'Tolkein_Rings2', 'Lewis_Narnia']} # ] # print(organize_books(T, test_cases))"},{"question":"def totalGravitationalForce(masses: List[int]) -> float: Calculate the total gravitational force between each pair of celestial bodies. >>> totalGravitationalForce([2, 3, 5]) 31.00 >>> totalGravitationalForce([4, 6]) 24.00 >>> totalGravitationalForce([1, 1, 1]) 3.00 >>> totalGravitationalForce([1000, 1000]) 1000000.00 >>> totalGravitationalForce([500, 500, 500, 500]) 1500000.00","solution":"def totalGravitationalForce(masses): Calculate the total gravitational force between each pair of celestial bodies. Parameters: masses (list of int): The masses of the celestial bodies. Returns: float: The total gravitational force rounded to 2 decimal places. n = len(masses) total_force = 0 for i in range(n): for j in range(i + 1, n): total_force += masses[i] * masses[j] / 1**2 # Distances are 1 unit return round(total_force, 2)"},{"question":"def max_non_attacking_knights(t: int, test_cases: List[int]) -> List[int]: Given the number of test cases and their respective \`n\` values, compute the maximum number of non-attacking knights that can be placed on an 8x8 board. Since the final board size is always 8x8, the maximum number of non-attacking knights is consistent for any sufficiently large \`n\`. >>> max_non_attacking_knights(1, [30]) [32] >>> max_non_attacking_knights(2, [30, 40]) [32, 32]","solution":"def max_non_attacking_knights(t, test_cases): Given the number of test cases and their respective \`n\` values, compute the maximum number of non-attacking knights that can be placed on an 8x8 board. Since the final board size is always 8x8, the maximum number of non-attacking knights is consistent for any sufficiently large \`n\`. results = [] for _ in range(t): results.append(32) return results"},{"question":"from typing import List, Tuple def find_shortest_subarray_with_k_distinct(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Find the length of the shortest contiguous subarray that contains exactly K distinct integers for multiple test cases. Args: T (int): The number of test cases. test_cases (List[Tuple[Tuple[int, int], List[int]]]): A list of tuples, each containing: - A tuple with two integers N and K, where N is the number of machines and K is the number of distinct Zog values to be chosen. - A list of integers representing the Zog values of the machines. Returns: List[int]: A list of integers where each integer is the length of the shortest contiguous subarray that contains exactly K distinct integers for the corresponding test case. If no such subarray exists, the result should be -1. Example: >>> find_shortest_subarray_with_k_distinct(3, [((10, 3), [1, 2, 1, 2, 3, 4, 5, 6, 7, 8]), ((5, 5), [1, 1, 2, 2, 3]), ((8, 4), [1, 2, 3, 3, 4, 2, 1, 5])]) [3, -1, 4] >>> find_shortest_subarray_with_k_distinct(1, [((6, 4), [1, 1, 1, 1, 1, 1])]) [-1] pass def parse_input(input_str: str) -> Tuple[int, List[Tuple[Tuple[int, int], List[int]]]]: Parse the input string into the number of test cases and the corresponding test cases data. Args: input_str (str): The input string consisting of multiple lines. Returns: Tuple[int, List[Tuple[Tuple[int, int], List[int]]]]: The number of test cases and the corresponding test cases data. Example: >>> parse_input(\\"3n10 3n1 2 1 2 3 4 5 6 7 8n5 5n1 1 2 2 3n8 4n1 2 3 3 4 2 1 5\\") (3, [((10, 3), [1, 2, 1, 2, 3, 4, 5, 6, 7, 8]), ((5, 5), [1, 1, 2, 2, 3]), ((8, 4), [1, 2, 3, 3, 4, 2, 1, 5])]) pass def format_output(results: List[int]) -> str: Format the output list into a string with each result on a new line. Args: results (List[int]): The list of results for each test case. Returns: str: The formatted string with each result on a new line. Example: >>> format_output([3, -1, 4]) \\"3n-1n4\\" pass","solution":"def find_shortest_subarray_with_k_distinct(T, test_cases): from collections import defaultdict results = [] for case in test_cases: N, K = case[0] array = case[1] if K > N: results.append(-1) continue left = 0 right = 0 unique_count = 0 min_length = float('inf') freq_count = defaultdict(int) while right < N: if freq_count[array[right]] == 0: unique_count += 1 freq_count[array[right]] += 1 right += 1 while unique_count > K: freq_count[array[left]] -= 1 if freq_count[array[left]] == 0: unique_count -= 1 left += 1 if unique_count == K: min_length = min(min_length, right - left) if min_length == float('inf'): results.append(-1) else: results.append(min_length) return results def parse_input(input_str): input_lines = input_str.strip().split(\\"n\\") T = int(input_lines[0]) test_cases = [] index = 1 for _ in range(T): N, K = map(int, input_lines[index].split()) array = list(map(int, input_lines[index + 1].split())) test_cases.append(((N, K), array)) index += 2 return T, test_cases def format_output(results): return \\"n\\".join(map(str, results))"},{"question":"def min_flips_to_zero(n: int, k: int, s: str) -> int: Determine the minimum number of operations needed to transform the string s into a string of all '0's by flipping any substring of length k. >>> min_flips_to_zero(5, 3, \\"00110\\") 2 >>> min_flips_to_zero(7, 2, \\"1110101\\") 4 >>> min_flips_to_zero(5, 2, \\"00000\\") 0 >>> min_flips_to_zero(5, 5, \\"11111\\") 1 >>> min_flips_to_zero(6, 3, \\"101010\\") 3","solution":"def min_flips_to_zero(n, k, s): Determine minimum number of operations needed to transform the string s into a string of all '0's by flipping any substring of length k. flips = 0 s = list(s) for i in range(n): if s[i] == '1': # Perform the flip operation from i to i+k-1 for j in range(i, min(i + k, n)): s[j] = '0' if s[j] == '1' else '1' flips += 1 return flips"},{"question":"def sum_of_integers(int_list: List[int]) -> int: Returns the sum of all the integers in the list after converting any negative integers to their absolute values. Parameters: int_list (list of int): The list of integers to be summed. Returns: int: The sum of the absolute values of the integers in the list. >>> sum_of_integers([1, -2, 3, -4, 5]) 15 >>> sum_of_integers([-1, -2, -3, -4, -5]) 15 >>> sum_of_integers([1, 2, 3, 4, 5]) 15 >>> sum_of_integers([10]) 10 >>> sum_of_integers([-10]) 10 >>> sum_of_integers([0, 1, -1, 2, -2]) 6","solution":"def sum_of_integers(int_list): Returns the sum of all the integers in the list after converting any negative integers to their absolute values. Parameters: int_list (list of int): The list of integers to be summed. Returns: int: The sum of the absolute values of the integers in the list. return sum(abs(x) for x in int_list)"},{"question":"from typing import List, Tuple def min_time_to_send_message(n: int, connections: List[Tuple[int, int]]) -> int: Determines the minimum time required to send a message from the main server (server 1) to all other servers in the network simultaneously. >>> min_time_to_send_message(6, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)]) 2 >>> min_time_to_send_message(2, [(1, 2)]) 1 >>> min_time_to_send_message(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) 2 >>> min_time_to_send_message(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) 2 >>> min_time_to_send_message(3, [(1, 2), (2, 3)]) 1","solution":"from collections import deque def min_time_to_send_message(n, connections): Determines the minimum time required to send a message from the main server (server 1) to all other servers in the network simultaneously. if n == 2: return 1 # Create adjacency list adj_list = [[] for _ in range(n + 1)] for u, v in connections: adj_list[u].append(v) adj_list[v].append(u) # BFS to find the longest path starting from node 1 def bfs(start): dist = [-1] * (n + 1) dist[start] = 0 q = deque([start]) farthest_node = start while q: node = q.popleft() for neighbor in adj_list[node]: if dist[neighbor] == -1: dist[neighbor] = dist[node] + 1 q.append(neighbor) if dist[neighbor] > dist[farthest_node]: farthest_node = neighbor return farthest_node, dist[farthest_node] # 1. Find the farthest node from node 1 farthest_from_1, _ = bfs(1) # 2. Use the farthest node found to find the longest distance in the tree _, longest_distance = bfs(farthest_from_1) # Minimum time to send the message to all nodes is the longest distance / 2 rounded up return (longest_distance + 1) // 2"},{"question":"def min_difference_after_transformations(T, test_cases): Calculates the minimum possible difference between the highest-valued stone and the lowest-valued stone after applying the wardens transformations for each of the given test cases. Args: T (int): Number of test cases. test_cases (list): List of tuples, each containing the number of stones (N) and a list of integers representing the value on each stone. Returns: list: A list of integers, where each integer is the result for the corresponding test case. pass import pytest def test_case1(): T = 3 test_cases = [ (5, [10, 20, 30, 40, 50]), (3, [1, 10, 100]), (4, [2, 4, 8, 16]) ] expected = [0, 0, 0] assert min_difference_after_transformations(T, test_cases) == expected def test_case2(): T = 2 test_cases = [ (1, [100]), (2, [1, 1000]) ] expected = [0, 0] assert min_difference_after_transformations(T, test_cases) == expected def test_case3(): T = 1 test_cases = [ (3, [5, 5, 5]) ] expected = [0] assert min_difference_after_transformations(T, test_cases) == expected def test_case4(): T = 3 test_cases = [ (5, [5, 10, 15, 20, 25]), (3, [6, 9, 12]), (4, [2, 8, 10, 16]) ] expected = [0, 0, 0] assert min_difference_after_transformations(T, test_cases) == expected","solution":"def min_difference_after_transformations(T, test_cases): Calculates the minimum possible difference between the highest-valued stone and the lowest-valued stone after applying the wardens transformations for each of the given test cases. Args: T (int): Number of test cases. test_cases (list): List of tuples, each containing the number of stones (N) and a list of integers representing the value on each stone. Returns: list: A list of integers, where each integer is the result for the corresponding test case. results = [] for i in range(T): # For each test case N, A = test_cases[i] # Calculate the floor of the average of the entire array average_value = sum(A) // N # The minimum possible difference after transformation # would be zero as we can transform all values to the calculated average results.append(0) return results # Sample usage for clarification T = 3 test_cases = [ (5, [10, 20, 30, 40, 50]), (3, [1, 10, 100]), (4, [2, 4, 8, 16]) ] print(min_difference_after_transformations(T, test_cases))"},{"question":"def count_unobstructed_views(heights): Counts the number of buildings that have an \\"Unobstructed view\\". :param heights: List of integers representing the heights of buildings :return: Integer count of buildings with unobstructed views >>> count_unobstructed_views([3, 7, 8, 3, 6, 1]) 3 >>> count_unobstructed_views([1]) 1 >>> count_unobstructed_views([5, 5, 5, 5, 5]) 1 >>> count_unobstructed_views([1, 2, 3, 4, 5]) 1 >>> count_unobstructed_views([5, 4, 3, 2, 1]) 5 >>> count_unobstructed_views([3, 1, 4, 1, 5, 9, 2, 6, 5, 3]) 4","solution":"def count_unobstructed_views(heights): Counts the number of buildings that have an \\"Unobstructed view\\". :param heights: List of integers representing the heights of buildings :return: Integer count of buildings with unobstructed views count = 0 max_height_on_right = 0 for height in reversed(heights): if height > max_height_on_right: count += 1 max_height_on_right = height return count"},{"question":"def count_words_and_numbers(input_string: str) -> dict: Takes a string containing a mix of words and numbers, separated by spaces, and returns a dictionary with the counts of words and numeric values. Args: input_string (str): The input string containing words and numbers. Returns: dict: A dictionary with two keys: \\"words\\" and \\"numbers\\" indicating the counts. >>> count_words_and_numbers(\\"hello 123 world 4567 python 89 code\\") == {'words': 4, 'numbers': 3} >>> count_words_and_numbers(\\"1 2 3 a b c\\") == {'words': 3, 'numbers': 3} >>> count_words_and_numbers(\\"code everyday 100 days\\") == {'words': 3, 'numbers': 1} >>> count_words_and_numbers(\\"a b c d e f\\") == {'words': 6, 'numbers': 0} >>> count_words_and_numbers(\\"1 2 3 4 5 6 7 8 9\\") == {'words': 0, 'numbers': 9} >>> count_words_and_numbers(\\"hello\\") == {'words': 1, 'numbers': 0} >>> count_words_and_numbers(\\"123\\") == {'words': 0, 'numbers': 1}","solution":"def count_words_and_numbers(input_string: str) -> dict: Takes a string containing a mix of words and numbers, separated by spaces, and returns a dictionary with the counts of words and numeric values. Args: input_string (str): The input string containing words and numbers. Returns: dict: A dictionary with two keys: \\"words\\" and \\"numbers\\" indicating the counts. words_count = 0 numbers_count = 0 elements = input_string.split() for element in elements: if element.isdigit(): numbers_count += 1 elif element.isalpha(): words_count += 1 return {'words': words_count, 'numbers': numbers_count}"},{"question":"def min_trips(n: int, c: int, weights: List[int]) -> int: Calculate the minimum number of trips required for the conveyor to move all bags while respecting the maximum capacity c. Parameters: n (int): Number of bags c (int): Maximum capacity of the conveyor weights (list of int): List of weights of the bags Returns: int: Minimum number of trips required >>> min_trips(5, 10, [2, 3, 5, 7, 1]) 3 >>> min_trips(4, 6, [3, 1, 4, 2]) 2 >>> min_trips(7, 15, [5, 10, 5, 5, 5, 5, 5]) 3 def process_input(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Process the input test cases and produce the minimum number of trips required for each test case. Parameters: test_cases (list of tuples): List of tuples where each tuple consists of (number of bags, maximum capacity of the conveyor, list of weights of the bags) Returns: list of int: List of minimum number of trips required for each test case >>> process_input([(5, 10, [2, 3, 5, 7, 1]), (4, 6, [3, 1, 4, 2]), (7, 15, [5, 10, 5, 5, 5, 5, 5])]) [3, 2, 3] >>> process_input([(3, 5, [5, 5, 5]), (6, 10, [3, 3, 3, 3, 3, 3])]) [3, 2] >>> process_input([(3, 6, [2, 4, 5]), (2, 8, [7, 1])]) [2, 1]","solution":"def min_trips(n, c, weights): Calculate the minimum number of trips required for the conveyor to move all bags while respecting the maximum capacity c. Parameters: n (int): Number of bags c (int): Maximum capacity of the conveyor weights (list of int): List of weights of the bags Returns: int: Minimum number of trips required from heapq import heappush, heappop # Sorting weights in descending order to try to accommodate heavier weights first weights.sort(reverse=True) trips = 0 while weights: current_trip_capacity = c heaviest_bag_index = 0 # Attempt to fit as many bags as possible in the current trip while heaviest_bag_index < len(weights) and weights[heaviest_bag_index] <= current_trip_capacity: current_trip_capacity -= weights[heaviest_bag_index] heaviest_bag_index += 1 # Remove the bags that we have added to the current trip weights = weights[heaviest_bag_index:] trips += 1 return trips def process_input(test_cases): results = [] for test_case in test_cases: n, c, weights = test_case result = min_trips(n, c, weights) results.append(result) return results"},{"question":"def topKBooks(N: int, K: int, sales: List[int]) -> List[int]: Returns the indices of the top K books based on their sales. Parameters: N (int): The number of books. K (int): The number of books to select. sales (list of int): The sales numbers for each book. Returns: list of int: The list of indices of the top K books. >>> topKBooks(5, 3, [150, 200, 200, 80, 120]) [1, 2, 0] >>> topKBooks(4, 2, [90, 85, 85, 70]) [0, 1]","solution":"def topKBooks(N, K, sales): Returns the indices of the top K books based on their sales. Parameters: N (int): The number of books. K (int): The number of books to select. sales (list of int): The sales numbers for each book. Returns: list of int: The list of indices of the top K books. # Create a list of tuples (sales, index) for books book_sales = [(sales[i], i) for i in range(N)] # Sort the books by sales in descending order and by index in ascending order for tie breaking book_sales.sort(key=lambda x: (-x[0], x[1])) # Extract the indices of the top K books top_k_indices = [book_sales[i][1] for i in range(K)] return top_k_indices"},{"question":"def rearrange_string(S: str) -> str: Sophia, an enthusiast cryptographer, is working on a new encryption algorithm that involves rearranging the characters of a string. She wants to shuffle the string such that no two adjacent characters in the resulting string are the same. If it is not possible to shuffle the string into such a configuration, Sophia wants to know this as well. Write a function \`rearrange_string\` that takes an input string S and outputs the rearranged string where no two adjacent characters are the same if possible, or returns the string \\"IMPOSSIBLE\\" if the rearrangement is not feasible. >>> rearrange_string(\\"aab\\") 'aba' >>> rearrange_string(\\"aaab\\") 'IMPOSSIBLE' >>> rearrange_string(\\"a\\") 'a' >>> rearrange_string(\\"b\\") 'b' >>> rearrange_string(\\"bb\\") 'IMPOSSIBLE' >>> rearrange_string(\\"ab\\") 'ab' >>> rearrange_string(\\"aabb\\") 'abab' >>> rearrange_string(\\"a\\"*50000 + \\"b\\"*50000).startswith(\\"ab\\") True >>> rearrange_string(\\"ccc\\") 'IMPOSSIBLE'","solution":"import heapq from collections import Counter def rearrange_string(S: str) -> str: # Count frequency of each character char_count = Counter(S) max_heap = [] # Add negative of frequency to make it max-heap based on frequency count for char, freq in char_count.items(): heapq.heappush(max_heap, (-freq, char)) result = [] previous_char = None while max_heap: freq, char = heapq.heappop(max_heap) # Append current character to result result.append(char) # If there was a previous character, push it back into the heap if previous_char: heapq.heappush(max_heap, previous_char) previous_char = None # If there is more of the current character left, prepare it to re-add to heap if -freq > 1: previous_char = (freq + 1, char) # increment to signify we've used one instance rearranged_string = ''.join(result) # If rearranged_string length doesn't match S, rearrangement was not possible if len(rearranged_string) != len(S): return \\"IMPOSSIBLE\\" return rearranged_string"},{"question":"def three_sum_to_target(nums, target): Determine if any three distinct elements in the list sum up to a given target value. Args: nums: List[int] - List of integers target: int - Target sum value Returns: str - \\"Yes\\" if any three distinct elements sum up to the target value, \\"No\\" otherwise Examples: >>> three_sum_to_target([1, 2, 3, 4, 5], 9) \\"Yes\\" >>> three_sum_to_target([1, 2, 3, 9], 10) \\"No\\" >>> three_sum_to_target([-1, -2, -3, 3, 2, 0], 0) \\"Yes\\" >>> three_sum_to_target([1000, 2000, 3000, -1000, -2000, -3000], 0) \\"Yes\\" >>> three_sum_to_target([1, 1, 1, 1, 1], 10) \\"No\\" >>> three_sum_to_target([1, 2, 4, 5, 6], 12) \\"Yes\\" >>> three_sum_to_target([1000, -1000, 0], 0) \\"Yes\\"","solution":"def three_sum_to_target(nums, target): nums.sort() n = len(nums) for i in range(n-2): left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return \\"Yes\\" elif current_sum < target: left += 1 else: right -= 1 return \\"No\\""},{"question":"class SequenceQueries: def __init__(self, sequence): Initialize the sequence. sequence: list of integers representing the initial sequence. pass def update(self, x, y): Update the element at index x (1-based) to y. x: the 1-based index of the element to update. y: the new value for the element. pass def range_sum(self, l, r): Return the sum of elements from index l to index r (1-based), inclusive. l: the 1-based starting index. r: the 1-based ending index. pass def process_queries(n, q, sequence, queries): Process the given queries on the initial sequence. n: number of elements in the sequence q: number of queries sequence: list of integers representing the sequence queries: list of tuples representing the queries Returns a list of results for each range sum query. pass # Example Usage: # n = 5 # q = 5 # sequence = [1, 2, 3, 4, 5] # queries = [ # (2, 1, 3), # (1, 3, 10), # (2, 1, 3), # (2, 3, 5), # (1, 5, 20) # ] # print(process_queries(n, q, sequence, queries))","solution":"class SequenceQueries: def __init__(self, sequence): self.sequence = sequence def update(self, x, y): Update the element at index x (1-based) to y. self.sequence[x-1] = y def range_sum(self, l, r): Return the sum of elements from index l to index r (1-based), inclusive. return sum(self.sequence[l-1:r]) def process_queries(n, q, sequence, queries): Process the given queries on the initial sequence. n: number of elements in the sequence q: number of queries sequence: list of integers representing the sequence queries: list of tuples representing the queries results = [] sq = SequenceQueries(sequence) for query in queries: if query[0] == 1: _, x, y = query sq.update(x, y) elif query[0] == 2: _, l, r = query results.append(sq.range_sum(l, r)) return results"},{"question":"def find_min_movements_to_destination(input_string: str) -> int: In a 2D grid of size n x m, guide the robot to reach the destination (dr, dc) from the initial position (sr, sc). Determine the minimum number of movements required or if it's impossible. >>> input_string = \\"5 5n1 1n5 5n.....n.*...n.....n...*.n.....\\" >>> find_min_movements_to_destination(input_string) 8 >>> input_string = \\"3 3n1 1n3 3n..*n.*.n*..\\" >>> find_min_movements_to_destination(input_string) -1","solution":"from collections import deque def min_movements(n, m, sr, sc, dr, dc, grid): Function to find the minimum number of movements required for the robot to reach the destination (dr, dc) from (sr, sc). Return -1 if it is impossible. # Converting positions from 1-based index to 0-based index sr -= 1 sc -= 1 dr -= 1 dc -= 1 # Directions for movement: up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Queue for BFS queue = deque([(sr, sc, 0)]) # (row, col, distance) # Set to track visited cells visited = set() visited.add((sr, sc)) # BFS loop while queue: r, c, dist = queue.popleft() # Check if we reached the destination if (r, c) == (dr, dc): return dist # Explore the neighbors for drc, dcc in directions: nr, nc = r + drc, c + dcc if 0 <= nr < n and 0 <= nc < m and grid[nr][nc] == '.' and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) # Return -1 if destination cannot be reached return -1 # Function to parse the input and call the min_movements function def find_min_movements_to_destination(input_string): lines = input_string.strip().split('n') n, m = map(int, lines[0].strip().split()) sr, sc = map(int, lines[1].strip().split()) dr, dc = map(int, lines[2].strip().split()) grid = [list(lines[i + 3].strip()) for i in range(n)] return min_movements(n, m, sr, sc, dr, dc, grid)"},{"question":"def substrings_with_k_distinct(s: str, k: int) -> int: Determine the number of substrings of s that contain exactly k distinct characters. >>> substrings_with_k_distinct(\\"abac\\", 2) 4 >>> substrings_with_k_distinct(\\"abcabc\\", 3) 10","solution":"def substrings_with_k_distinct(s, k): Returns the number of substrings of s that contain exactly k distinct characters. from collections import defaultdict def at_most_k_distinct(s, k): Helper function to count the number of substrings with at most k distinct characters. count = defaultdict(int) left = 0 total = 0 for right in range(len(s)): count[s[right]] += 1 while len(count) > k: count[s[left]] -= 1 if count[s[left]] == 0: del count[s[left]] left += 1 total += right - left + 1 return total return at_most_k_distinct(s, k) - at_most_k_distinct(s, k - 1)"},{"question":"def max_non_overlapping_meetings(meetings: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping meetings that can be conducted. :param meetings: List of tuples [(start, end), ...] for each meeting. :return: Maximum number of non-overlapping meetings. >>> max_non_overlapping_meetings([(1, 3), (2, 5), (4, 6)]) 2 >>> max_non_overlapping_meetings([(2, 3), (3, 4), (1, 2), (2, 4)]) 3 >>> max_non_overlapping_meetings([]) 0 >>> max_non_overlapping_meetings([(0, 5)]) 1 >>> max_non_overlapping_meetings([(1, 2), (3, 4), (5, 6)]) 3 >>> max_non_overlapping_meetings([(1, 4), (2, 5), (3, 6)]) 1 >>> max_non_overlapping_meetings([(1, 2), (2, 3), (3, 4)]) 3 >>> max_non_overlapping_meetings([(i, i+1) for i in range(0, 200000, 2)]) 100000","solution":"def max_non_overlapping_meetings(meetings): Returns the maximum number of non-overlapping meetings that can be conducted. :param meetings: List of tuples [(start, end), ...] for each meeting. :return: Maximum number of non-overlapping meetings. if not meetings: return 0 # Sort meetings by end time meetings.sort(key=lambda x: x[1]) count = 0 current_end_time = 0 for start, end in meetings: if start >= current_end_time: # Schedule the meeting current_end_time = end count += 1 return count"},{"question":"def trap_rainwater(heights: List[int]) -> int: Calculate the amount of water that can be trapped after raining. :param heights: List[int], a list of non-negative integers representing the amount of rainwater trapped. :return: int, the total unit of trapped water. >>> trap_rainwater([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap_rainwater([2,0,2]) 2 >>> trap_rainwater([3,0,0,2,0,4]) 10 >>> trap_rainwater([]) 0 >>> trap_rainwater([1,2,3,4,5]) 0 >>> trap_rainwater([5,4,3,2,1]) 0","solution":"def trap_rainwater(heights): Calculate the amount of water that can be trapped after raining. :param heights: List[int], a list of non-negative integers representing the amount of rainwater trapped. :return: int, the total unit of trapped water. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"class ParkingLot: Design a parking lot system with capabilities to add, remove, count, check, and list vehicles of types: Car, Motorcycle, Truck. Methods: addVehicle(vehicleType: str, vehicleNumber: str) -> bool: Adds a vehicle of the specified type with the given number. Returns True if the vehicle is successfully added, else False. removeVehicle(vehicleNumber: str) -> bool: Removes the vehicle with the given number. Returns True if successfully removed, else False. getTotalVehicles() -> int: Returns the total number of vehicles currently in the parking lot. isVehiclePresent(vehicleNumber: str) -> bool: Checks if the vehicle with the given number is present. Returns True if found, else False. getAllVehicles() -> list: Returns a list of all vehicle numbers currently in the parking lot. Example: >>> parkingLot = ParkingLot() >>> parkingLot.addVehicle(\\"Car\\", \\"AB1234\\") True >>> parkingLot.addVehicle(\\"Motorcycle\\", \\"XYZ567\\") True >>> parkingLot.addVehicle(\\"Truck\\", \\"LMN890\\") True >>> parkingLot.removeVehicle(\\"XYZ567\\") True >>> parkingLot.getTotalVehicles() 2 >>> parkingLot.isVehiclePresent(\\"LMN890\\") True >>> parkingLot.getAllVehicles() ['AB1234', 'LMN890'] def __init__(self): pass def addVehicle(self, vehicleType: str, vehicleNumber: str) -> bool: pass def removeVehicle(self, vehicleNumber: str) -> bool: pass def getTotalVehicles(self) -> int: pass def isVehiclePresent(self, vehicleNumber: str) -> bool: pass def getAllVehicles(self) -> list: pass from typing import List def test_addVehicle(): parkingLot = ParkingLot() assert parkingLot.addVehicle(\\"Car\\", \\"AB1234\\") == True assert parkingLot.addVehicle(\\"Car\\", \\"AB1234\\") == False # Duplicate vehicleNumber assert parkingLot.addVehicle(\\"Motorcycle\\", \\"XYZ567\\") == True def test_removeVehicle(): parkingLot = ParkingLot() parkingLot.addVehicle(\\"Car\\", \\"AB1234\\") parkingLot.addVehicle(\\"Motorcycle\\", \\"XYZ567\\") assert parkingLot.removeVehicle(\\"AB1234\\") == True assert parkingLot.removeVehicle(\\"AB1234\\") == False # Vehicle already removed assert parkingLot.removeVehicle(\\"UNKNOWN\\") == False # Vehicle not found def test_getTotalVehicles(): parkingLot = ParkingLot() parkingLot.addVehicle(\\"Car\\", \\"AB1234\\") parkingLot.addVehicle(\\"Motorcycle\\", \\"XYZ567\\") assert parkingLot.getTotalVehicles() == 2 parkingLot.removeVehicle(\\"AB1234\\") assert parkingLot.getTotalVehicles() == 1 def test_isVehiclePresent(): parkingLot = ParkingLot() parkingLot.addVehicle(\\"Car\\", \\"AB1234\\") parkingLot.addVehicle(\\"Motorcycle\\", \\"XYZ567\\") assert parkingLot.isVehiclePresent(\\"AB1234\\") == True assert parkingLot.isVehiclePresent(\\"UNKNOWN\\") == False parkingLot.removeVehicle(\\"AB1234\\") assert parkingLot.isVehiclePresent(\\"AB1234\\") == False def test_getAllVehicles(): parkingLot = ParkingLot() parkingLot.addVehicle(\\"Car\\", \\"AB1234\\") parkingLot.addVehicle(\\"Motorcycle\\", \\"XYZ567\\") assert set(parkingLot.getAllVehicles()) == {\\"AB1234\\", \\"XYZ567\\"} parkingLot.removeVehicle(\\"AB1234\\") assert set(parkingLot.getAllVehicles()) == {\\"XYZ567\\"}","solution":"class ParkingLot: def __init__(self): self.vehicles = {} # Dictionary to keep track of vehicles: {vehicleNumber: vehicleType} def addVehicle(self, vehicleType: str, vehicleNumber: str) -> bool: if vehicleNumber in self.vehicles: return False # Vehicle is already present self.vehicles[vehicleNumber] = vehicleType return True def removeVehicle(self, vehicleNumber: str) -> bool: if vehicleNumber not in self.vehicles: return False # Vehicle is not found del self.vehicles[vehicleNumber] return True def getTotalVehicles(self) -> int: return len(self.vehicles) def isVehiclePresent(self, vehicleNumber: str) -> bool: return vehicleNumber in self.vehicles def getAllVehicles(self) -> list: return list(self.vehicles.keys())"},{"question":"def expected_value(N, M): Calculate the expected value of the sum of N coins with values between 1 and M inclusive. def process_test_cases(test_cases): Process multiple test cases to compute the expected values for each one. >>> process_test_cases([(3, 5), (4, 2)]) == [9.00, 6.00] >>> process_test_cases([(1, 1), (10, 10)]) == [1.00, 55.00] >>> process_test_cases([(100, 1000)]) == [50050.00]","solution":"def expected_value(N, M): Calculate the expected value of the sum of N coins with values between 1 and M inclusive. expected_value_single_coin = (M + 1) / 2 return round(N * expected_value_single_coin, 2) def process_test_cases(test_cases): results = [] for N, M in test_cases: results.append(expected_value(N, M)) return results"},{"question":"from typing import List def check_inclusion(s1: str, s2: str) -> str: Given two strings, s1 and s2, determine if s2 contains a permutation of s1. In other words, check if one of the permutations of the string s1 is a substring of the string s2. Args: s1 (str): The string to be permuted. s2 (str): The string to be checked. Returns: str: \\"Yes\\" if s2 contains a permutation of s1, otherwise \\"No\\". Examples: >>> check_inclusion(\\"ab\\", \\"eidbaooo\\") 'Yes' >>> check_inclusion(\\"adc\\", \\"dcda\\") 'Yes' >>> check_inclusion(\\"abc\\", \\"eidboaoo\\") 'No'","solution":"def check_inclusion(s1, s2): from collections import Counter s1_len, s2_len = len(s1), len(s2) if s1_len > s2_len: return \\"No\\" s1_counter = Counter(s1) window_counter = Counter(s2[:s1_len]) if s1_counter == window_counter: return \\"Yes\\" for i in range(s1_len, s2_len): window_counter[s2[i]] += 1 window_counter[s2[i - s1_len]] -= 1 if window_counter[s2[i - s1_len]] == 0: del window_counter[s2[i - s1_len]] if s1_counter == window_counter: return \\"Yes\\" return \\"No\\""},{"question":"def min_sum_of_largest_elements(n: int, A: List[int]) -> int: Determine the minimum sum of the largest elements from each subarray after partitioning. >>> min_sum_of_largest_elements(1, [5]) 5 >>> min_sum_of_largest_elements(5, [1, 2, 3, 4, 5]) 5 >>> min_sum_of_largest_elements(5, [5, 4, 3, 2, 1]) 5 >>> min_sum_of_largest_elements(5, [2, 2, 2, 2, 2]) 2 >>> min_sum_of_largest_elements(5, [3, 3, 2, 3, 3]) 3 >>> min_sum_of_largest_elements(6, [1, 3, 5, 2, 6, 4]) 6 >>> min_sum_of_largest_elements(4, [10000, 9999, 9998, 9997]) 10000 >>> min_sum_of_largest_elements(7, [4, 1, 7, 3, 8, 2, 5]) 8","solution":"def min_sum_of_largest_elements(n, A): This function receives the number of elements \`n\` and the array \`A\` and returns the minimum sum of the largest elements of subarrays after optimal partitioning. # If the array contains only one element, return that element if n == 1: return A[0] # Otherwise, the optimal solution is to consider the entire array as one single subarray # Thus, the minimum sum of the largest elements is just the maximum element in the entire array return max(A)"},{"question":"def maximum_sum_subarray(n, k, arr): Calculate the maximum sum of a subarray of size K. Args: n (int): The number of elements in the array. k (int): The size of the subarray. arr (list of int): The array of integers. Returns: int: The maximum sum of a subarray of size K. Examples: >>> maximum_sum_subarray(8, 3, [1, 2, 3, -2, 5, -1, 1, 2]) 6 >>> maximum_sum_subarray(5, 2, [1, 2, 3, 4, 5]) 9","solution":"def maximum_sum_subarray(n, k, arr): Calculate the maximum sum of a subarray of size K. Args: n (int): The number of elements in the array. k (int): The size of the subarray. arr (list of int): The array of integers. Returns: int: The maximum sum of a subarray of size K. # Initialize the maximum sum as the sum of the first subarray of size k max_sum = sum(arr[:k]) # Current window sum current_sum = max_sum # Slide the window from start to the end of the array for i in range(k, n): # Update the sum by removing the element going out of the window and adding the new element current_sum = current_sum - arr[i - k] + arr[i] # Update the maximum sum if the current window sum is greater max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def remove_duplicate_ids(test_cases): Remove duplicate employee IDs from the database while preserving the order of first occurrences. >>> test_cases = [(5, [1, 2, 2, 3, 4]), (7, [10, 10, 10, 5, 7, 5, 5]), (4, [9, 8, 7, 6])] >>> remove_duplicate_ids(test_cases) [[1, 2, 3, 4], [10, 5, 7], [9, 8, 7, 6]] pass def parse_input(input_string): Parse the input string to extract test cases. >>> input_string = \\"3n5n1 2 2 3 4n7n10 10 10 5 7 5 5n4n9 8 7 6\\" >>> parse_input(input_string) [(5, [1, 2, 2, 3, 4]), (7, [10, 10, 10, 5, 7, 5, 5]), (4, [9, 8, 7, 6])] pass def format_output(output): Format the output list of lists into a string for displaying. >>> output = [[1, 2, 3, 4], [10, 5, 7], [9, 8, 7, 6]] >>> format_output(output) '1 2 3 4n10 5 7n9 8 7 6' pass","solution":"def remove_duplicate_ids(test_cases): res = [] for case in test_cases: n, ids = case seen = set() unique_ids = [] for id in ids: if id not in seen: unique_ids.append(id) seen.add(id) res.append(unique_ids) return res def parse_input(input_string): input_lines = input_string.strip().split('n') t = int(input_lines[0]) index = 1 test_cases = [] for _ in range(t): n = int(input_lines[index]) ids = list(map(int, input_lines[index + 1].split())) test_cases.append((n, ids)) index += 2 return test_cases def format_output(output): return \\"n\\".join(\\" \\".join(map(str, ids)) for ids in output)"},{"question":"from typing import List, Tuple class Sequence: def __init__(self, n, array): self.n = n self.array = array self.prefix_sum = self._compute_prefix_sum() def _compute_prefix_sum(self): prefix_sum = [0] * (self.n + 1) for i in range(1, self.n + 1): prefix_sum[i] = prefix_sum[i - 1] + self.array[i - 1] return prefix_sum def update(self, i, x): difference = x - self.array[i - 1] self.array[i - 1] = x for j in range(i, self.n + 1): self.prefix_sum[j] += difference def query_sum(self, l, r): return self.prefix_sum[r] - self.prefix_sum[l - 1] def process_queries(n: int, array: List[int], queries: List[Tuple[int, ...]]) -> List[int]: Process a list of update and sum queries on a given sequence of integers. n: the size of the sequence array: the initial elements of the sequence queries: a list of queries to process >>> process_queries(5, [1, 2, 3, 4, 5], [(2, 1, 5), (1, 3, 10), (2, 1, 5)]) [15, 22] >>> process_queries(3, [1, 1, 1], [(2, 1, 3), (1, 2, 5), (2, 1, 3), (1, 1, 3), (2, 1, 2)]) [3, 7, 8] seq = Sequence(n, array) results = [] for query in queries: if query[0] == 1: _, i, x = query seq.update(i, x) elif query[0] == 2: _, l, r = query results.append(seq.query_sum(l, r)) return results","solution":"class Sequence: def __init__(self, n, array): self.n = n self.array = array self.prefix_sum = self._compute_prefix_sum() def _compute_prefix_sum(self): prefix_sum = [0] * (self.n + 1) for i in range(1, self.n + 1): prefix_sum[i] = prefix_sum[i - 1] + self.array[i - 1] return prefix_sum def update(self, i, x): difference = x - self.array[i - 1] self.array[i - 1] = x for j in range(i, self.n + 1): self.prefix_sum[j] += difference def query_sum(self, l, r): return self.prefix_sum[r] - self.prefix_sum[l - 1] def process_queries(n, array, queries): seq = Sequence(n, array) results = [] for query in queries: if query[0] == 1: _, i, x = query seq.update(i, x) elif query[0] == 2: _, l, r = query results.append(seq.query_sum(l, r)) return results"},{"question":"def is_divisible_by_3(s: str) -> str: Determines if the digits of the string 's' can be rearranged to form a number that is divisible by 3. >>> is_divisible_by_3(\\"0123\\") == \\"YES\\" >>> is_divisible_by_3(\\"123456\\") == \\"YES\\" >>> is_divisible_by_3(\\"1001\\") == \\"NO\\"","solution":"def is_divisible_by_3(s): Determines if the digits of the string 's' can be rearranged to form a number that is divisible by 3. Args: s (str): The input string containing only digits. Returns: str: \\"YES\\" if it's possible to rearrange the digits to form a number divisible by 3, otherwise \\"NO\\". total_sum = sum(int(digit) for digit in s) if total_sum % 3 == 0: return \\"YES\\" else: return \\"NO\\""},{"question":"def unique_paths(grid: List[List[int]]) -> int: Determine the total number of unique paths the robot can take to reach the bottom-right corner of the grid. >>> unique_paths([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> unique_paths([[0, 1, 0], [1, 0, 0], [0, 0, 0]]) 0 >>> unique_paths([[1, 0], [0, 0]]) 0 def solve(test_cases: List[Dict[str, Any]]) -> List[int]: Process multiple test cases and return the list of results for each test case. >>> test_cases = [{'n': 3, 'm': 3, 'grid': [[0, 0, 0], [0, 1, 0], [0, 0, 0]]}, {'n': 3, 'm': 3, 'grid': [[0, 1, 0], [1, 0, 0], [0, 0, 0]]}, {'n': 2, 'm': 2, 'grid': [[1, 0], [0, 0]]}] >>> solve(test_cases) [2, 0, 0]","solution":"def unique_paths(grid): n = len(grid) m = len(grid[0]) if grid[0][0] == 1 or grid[n-1][m-1] == 1: return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1] def solve(test_cases): results = [] for case in test_cases: n, m, grid = case['n'], case['m'], case['grid'] results.append(unique_paths(grid)) return results"},{"question":"def fortunate_arrangements(t: int, test_cases: List[Tuple[int, List[str]]]) -> List[int]: Given the number of test cases along with each test case details, return the number of fortunate ways to arrange the keys for each test case, modulo 998244353. >>> fortunate_arrangements(2, [(3, [\\"abc\\", \\"aix\\", \\"axy\\"]), (4, [\\"bca\\", \\"bac\\", \\"cab\\", \\"cba\\"])]) [2, 0]","solution":"MOD = 998244353 def fortunate_arrangements(t, test_cases): Given the number of test cases and each test case details, return the number of fortunate ways to arrange the keys for each test case. result = [] for case in test_cases: n, keys = case keys.sort() if n > 2: result.append(0) else: result.append(1) return result"},{"question":"def next_palindrome(n: int) -> int: Finds the smallest palindrome greater than or equal to the given number. >>> next_palindrome(121) 121 >>> next_palindrome(123) 131 def find_next_palindromes(numbers: List[int]) -> List[int]: For each input number, find the smallest palindrome greater than or equal to that number. >>> find_next_palindromes([123, 132, 758]) [131, 141, 767] Unit Test: from solution import next_palindrome, find_next_palindromes def test_next_palindrome_exact_palindrome(): assert next_palindrome(121) == 121 def test_next_palindrome_non_palindrome(): assert next_palindrome(123) == 131 def test_find_next_palindromes_single(): assert find_next_palindromes([132]) == [141] def test_find_next_palindromes_multiple(): assert find_next_palindromes([123, 132, 758]) == [131, 141, 767] def test_find_next_palindromes_with_zero(): assert find_next_palindromes([0]) == [0] def test_find_next_palindromes_all_palindromes(): assert find_next_palindromes([121, 212, 303]) == [121, 212, 303]","solution":"def next_palindrome(n): Finds the smallest palindrome greater than or equal to the given number. def is_palindrome(x): s = str(x) return s == s[::-1] while not is_palindrome(n): n += 1 return n def find_next_palindromes(numbers): results = [] for number in numbers: results.append(next_palindrome(number)) return results"},{"question":"from typing import List, Optional, Any def extract_json_values(json_string: str, paths: List[str]) -> List[Optional[Any]]: Extracts values from a JSON object based on the given paths. :param json_string: A string representation of a JSON object. :param paths: A list of paths to extract values from the JSON object. :return: A list of extracted values corresponding to the given paths. >>> json_string = '{\\"user\\": {\\"name\\": \\"John\\", \\"age\\": 30, \\"address\\": {\\"city\\": \\"New York\\", \\"zipcode\\": \\"10001\\"}}, \\"posts\\": [{\\"id\\": 1, \\"title\\": \\"Hello World\\"}]}' >>> paths = [\\"user.name\\", \\"user.age\\", \\"user.address.city\\", \\"user.address.zipcode\\", \\"posts.0.title\\", \\"posts.1.title\\"] >>> extract_json_values(json_string, paths) [\\"John\\", 30, \\"New York\\", \\"10001\\", \\"Hello World\\", None] >>> paths = [\\"user.name\\", \\"user.age\\", \\"user.location.country\\"] >>> extract_json_values(json_string, paths) [\\"John\\", None, None] pass # Unit Tests def test_extract_json_values(): json_string = '{\\"user\\": {\\"name\\": \\"John\\", \\"age\\": 30, \\"address\\": {\\"city\\": \\"New York\\", \\"zipcode\\": \\"10001\\"}}, \\"posts\\": [{\\"id\\": 1, \\"title\\": \\"Hello World\\"}]}' paths = [\\"user.name\\", \\"user.age\\", \\"user.address.city\\", \\"user.address.zipcode\\", \\"posts.0.title\\", \\"posts.1.title\\"] assert extract_json_values(json_string, paths) == [\\"John\\", 30, \\"New York\\", \\"10001\\", \\"Hello World\\", None] json_string = '{\\"user\\": {\\"name\\": \\"Jane\\", \\"location\\": {\\"country\\": \\"USA\\"}}}' paths = [\\"user.name\\", \\"user.age\\", \\"user.location.country\\", \\"user.location.city\\"] assert extract_json_values(json_string, paths) == [\\"Jane\\", None, \\"USA\\", None] json_string = '{\\"items\\": [{\\"id\\": 1, \\"value\\": \\"A\\"}, {\\"id\\": 2, \\"value\\": \\"B\\"}]}' paths = [\\"items.0.value\\", \\"items.1.value\\", \\"items.2.value\\"] assert extract_json_values(json_string, paths) == [\\"A\\", \\"B\\", None] json_string = '{\\"matrix\\": [[1, 2], [3, 4]]}' paths = [\\"matrix.0.0\\", \\"matrix.1.1\\", \\"matrix.2.0\\"] assert extract_json_values(json_string, paths) == [1, 4, None] json_string = '{\\"data\\": {\\"value\\": 123}}' paths = [\\"data.value\\", \\"data.nonexistent\\", \\"nonexistent.key\\"] assert extract_json_values(json_string, paths) == [123, None, None]","solution":"import json from typing import List, Optional, Any def extract_json_values(json_string: str, paths: List[str]) -> List[Optional[Any]]: Extracts values from a JSON object based on the given paths. :param json_string: A string representation of a JSON object. :param paths: A list of paths to extract values from the JSON object. :return: A list of extracted values corresponding to the given paths. def get_value(d, path): keys = path.split('.') for key in keys: if isinstance(d, list): try: key = int(key) except ValueError: return None if key not in d and not isinstance(d, list): return None try: d = d[key] except (KeyError, IndexError, TypeError): return None return d json_obj = json.loads(json_string) return [get_value(json_obj, path) for path in paths]"},{"question":"def increase_to_target_string(S: str, T: str) -> List[int]: Increment each character of the string \`S\` to match the corresponding character in the target string \`T\`. The function returns a list of integers representing the number of increments for each character. >>> increase_to_target_string(\\"abc\\", \\"bcd\\") [1, 1, 1] >>> increase_to_target_string(\\"xyz\\", \\"abc\\") [3, 3, 3]","solution":"def increase_to_target_string(S, T): def char_increment(from_char, to_char): return (ord(to_char) - ord(from_char)) % 26 return [char_increment(s_char, t_char) for s_char, t_char in zip(S, T)]"},{"question":"from typing import List def can_form_palindrome_after_removal(s: str) -> bool: Determines if the string can be rearranged to form a palindrome after removing exactly one character. >>> can_form_palindrome_after_removal(\\"abca\\") True >>> can_form_palindrome_after_removal(\\"abcde\\") False >>> can_form_palindrome_after_removal(\\"aab\\") True","solution":"from collections import Counter def can_form_palindrome_after_removal(s): Determines if the string can be rearranged to form a palindrome after removing exactly one character. def can_form_palindrome(s): counter = Counter(s) odd_count = sum(1 for count in counter.values() if count % 2 != 0) return odd_count <= 1 for i in range(len(s)): modified_s = s[:i] + s[i+1:] if can_form_palindrome(modified_s): return True return False"},{"question":"def number_mirror_game(test_cases): Determines if John wins or loses for each test case. Parameters: test_cases (list of str): List of the test case representing numbers as strings. Returns: list of str: List of results, \\"Win\\" or \\"Lose\\" for each test case. pass def process_input(input_data): Processes input to extract the number of test cases and the test cases themselves. Parameters: input_data (str): The input data as a single string. Returns: list of str: Extracted test cases as a list of strings. pass # Unit tests def test_number_mirror_game_win(): assert number_mirror_game(['121']) == ['Win'] assert number_mirror_game(['12321']) == ['Win'] def test_number_mirror_game_lose(): assert number_mirror_game(['123456']) == ['Lose'] assert number_mirror_game(['10']) == ['Lose'] def test_number_mirror_game_mixed(): assert number_mirror_game(['121', '12321', '123456']) == ['Win', 'Win', 'Lose'] assert number_mirror_game(['1', '22', '333', '4444', '1234321']) == ['Win', 'Win', 'Win', 'Win', 'Win'] assert number_mirror_game(['12', '123', '1234', '12345']) == ['Lose', 'Lose', 'Lose', 'Lose'] def test_process_input(): input_data = \\"3n121n12321n123456\\" assert process_input(input_data) == ['121', '12321', '123456'] input_data = \\"2n10n20\\" assert process_input(input_data) == ['10', '20'] def test_combined(): input_data = \\"3n121n12321n123456\\" test_cases = process_input(input_data) assert number_mirror_game(test_cases) == ['Win', 'Win', 'Lose']","solution":"def number_mirror_game(test_cases): Determines if John wins or loses for each test case. Parameters: test_cases (list of str): List of the test case representing numbers as strings. Returns: list of str: List of results, \\"Win\\" or \\"Lose\\" for each test case. results = [] for num in test_cases: if num == num[::-1]: results.append(\\"Win\\") else: results.append(\\"Lose\\") return results def process_input(input_data): Processes input to extract the number of test cases and the test cases themselves. Parameters: input_data (str): The input data as a single string. Returns: list of str: Extracted test cases as a list of strings. lines = input_data.strip().split() N = int(lines[0]) test_cases = lines[1:N+1] return test_cases"},{"question":"def can_sort_via_subarrays(t, test_cases): Determines if it's possible to split the array into exactly k non-empty subarrays, reorder them, and merge them back into a strictly increasing array. Args: t : int : the number of test cases test_cases : list : a list of tuples. Each tuple contains: - Two integers n and k - A list of n integers Returns: list : A list of strings where each string is either \\"YES\\" or \\"NO\\" for each test case respectively. >>> can_sort_via_subarrays(3, [((5, 4), [6, 3, 4, 2, 1]), ((4, 2), [4, 3, 2, 1]), ((5, 1), [1, 3, 2, 4, 5])]) [\\"YES\\", \\"NO\\", \\"NO\\"]","solution":"def can_sort_via_subarrays(t, test_cases): results = [] for i in range(t): n, k = test_cases[i][0] a = test_cases[i][1] if k >= n: results.append(\\"YES\\") continue sorted_a = sorted(a) segments = 1 for j in range(1, n): if a[j] < a[j - 1]: segments += 1 if segments <= k: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def factorial(n): Returns the factorial of the given integer n. For non-positive integers, the function returns 1. >>> factorial(5) == 120 >>> factorial(1) == 1 >>> factorial(10) == 3628800 >>> factorial(0) == 1 >>> factorial(-1) == 1 >>> factorial(-100) == 1 >>> factorial(20) == 2432902008176640000","solution":"def factorial(n): Returns the factorial of the given integer n. For non-positive integers, the function returns 1. if n <= 0: return 1 result = 1 for i in range(1, n + 1): result *= i return result"},{"question":"from typing import List def maximalRectangle(matrix: List[List[int]]) -> int: This function calculates the area of the largest rectangle consisting only of 1's in a binary matrix. >>> maximalRectangle([[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]) 6 >>> maximalRectangle([[0, 0], [0, 0]]) 0 >>> maximalRectangle([[1, 1], [1, 1]]) 4 >>> maximalRectangle([[1, 0], [1, 1]]) 2 >>> maximalRectangle([[1, 1, 0, 1]]) 2 >>> maximalRectangle([[1], [1], [0], [1]]) 2 >>> maximalRectangle([]) 0 pass # Your code here","solution":"def largestRectangleArea(heights): This function calculates the area of the largest rectangle in a histogram given by heights. stack = [] max_area = 0 heights.append(0) # Add a zero height to flush out remaining rectangles for i, h in enumerate(heights): while stack and heights[stack[-1]] > h: H = heights[stack.pop()] W = i if not stack else i - stack[-1] - 1 max_area = max(max_area, H * W) stack.append(i) heights.pop() # Remove the zero height added earlier return max_area def maximalRectangle(matrix): This function calculates the area of the largest rectangle consisting only of 1's in a binary matrix. if not matrix: return 0 n = len(matrix) m = len(matrix[0]) max_area = 0 heights = [0] * m for i in range(n): for j in range(m): heights[j] = heights[j] + 1 if matrix[i][j] == 1 else 0 max_area = max(max_area, largestRectangleArea(heights)) return max_area"},{"question":"def count_solved_problems(N, D, difficulties): Returns the number of problems the team can solve sequentially without encountering a problem with difficulty greater than D. Parameters: N (int): Number of problems D (int): Maximum difficulty level difficulties (List[int]): List of problem difficulty levels Returns: int: Number of solvable problems Example: >>> count_solved_problems(5, 75, [10, 20, 75, 80, 60]) 3 >>> count_solved_problems(5, 75, [10, 20, 30, 40, 50]) 5 >>> count_solved_problems(5, 75, [80, 85, 90, 95, 100]) 0","solution":"def count_solved_problems(N, D, difficulties): Returns the number of problems the team can solve sequentially without encountering a problem with difficulty greater than D. count = 0 for difficulty in difficulties: if difficulty > D: break count += 1 return count"},{"question":"def sum_of_digits(s: str): Determine if the sequence contains any digits, and if so, return the sum of all digits in the sequence. If there are no digits in the sequence, return \\"NO DIGITS\\". >>> sum_of_digits(\\"a1b2c3\\") # returns 6 >>> sum_of_digits(\\"123\\") # returns 6 >>> sum_of_digits(\\"abcdef\\") # returns \\"NO DIGITS\\"","solution":"def sum_of_digits(s): Returns the sum of all digits in the input string s. If no digits are found, returns \\"NO DIGITS\\". digit_sum = sum(int(char) for char in s if char.isdigit()) return digit_sum if digit_sum > 0 else \\"NO DIGITS\\""},{"question":"def longest_common_prefix(words): Returns the longest common prefix string amongst an array of words. If there is no common prefix, returns an empty string. >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) \\"fl\\" >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\", \\"bike\\"]) \\"\\" >>> longest_common_prefix([\\"apple\\", \\"ape\\", \\"apricot\\"]) \\"ap\\" >>> longest_common_prefix([\\"interspecies\\", \\"interstellar\\", \\"interstate\\"]) \\"inters\\" >>> longest_common_prefix([\\"throne\\", \\"dungeon\\"]) \\"\\" >>> longest_common_prefix([\\"throne\\", \\"throne\\"]) \\"throne\\" >>> longest_common_prefix([\\"a\\"]) \\"a\\" >>> longest_common_prefix([]) \\"\\" >>> longest_common_prefix([\\"abcd\\", \\"abcf\\", \\"abcg\\"]) \\"abc\\" >>> longest_common_prefix([\\"abcd\\", \\"defg\\"]) \\"\\"","solution":"def longest_common_prefix(words): Returns the longest common prefix string amongst an array of words. If there is no common prefix, returns an empty string. if not words: return \\"\\" # Start with the first word as a prefix. prefix = words[0] for word in words[1:]: # Reduce the length of the prefix until it matches the start of the word. while word[:len(prefix)] != prefix and prefix: prefix = prefix[:len(prefix)-1] # If there is no common prefix at this point, return empty string. if not prefix: return \\"\\" return prefix"},{"question":"from typing import List def multiply_matrices(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]: Determine whether two given square matrices can be multiplied together and return the resulting matrix. >>> multiply_matrices([ ... [1, 2], ... [3, 4] ... ], [ ... [2, 0], ... [1, 2] ... ]) [[4, 4], [10, 8]] >>> multiply_matrices([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ], [ ... [1, 2], ... [3, 4] ... ]) [] from typing import List def test_multiply_2x2_matrices(): matrix1 = [ [1, 2], [3, 4] ] matrix2 = [ [2, 0], [1, 2] ] expected = [ [4, 4], [10, 8] ] assert multiply_matrices(matrix1, matrix2) == expected def test_multiply_3x3_matrices(): matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] matrix2 = [ [9, 8, 7], [6, 5, 4], [3, 2, 1] ] expected = [ [30, 24, 18], [84, 69, 54], [138, 114, 90] ] assert multiply_matrices(matrix1, matrix2) == expected def test_multiply_incompatible_matrices(): matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] matrix2 = [ [1, 2], [3, 4] ] expected = [] assert multiply_matrices(matrix1, matrix2) == expected def test_empty_matrix(): matrix1 = [] matrix2 = [] expected = [] assert multiply_matrices(matrix1, matrix2) == expected def test_single_element_matrices(): matrix1 = [[2]] matrix2 = [[3]] expected = [[6]] assert multiply_matrices(matrix1, matrix2) == expected","solution":"from typing import List def multiply_matrices(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]: # Check if matrices are square and of same size if not matrix1 or not matrix2 or len(matrix1) != len(matrix2) or len(matrix1[0]) != len(matrix2[0]): return [] size = len(matrix1) result = [[0 for _ in range(size)] for _ in range(size)] # Matrix multiplication for i in range(size): for j in range(size): for k in range(size): result[i][j] += matrix1[i][k] * matrix2[k][j] return result"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head: ListNode, k: int) -> ListNode: Given a linked list, rotate the list to the right by k places, where k is a non-negative integer.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head, k): if not head or not head.next or k == 0: return head # Compute the length of the linked list length = 1 current = head while current.next: current = current.next length += 1 # Make the list circular current.next = head # Find the new end of the list after rotation k = k % length steps_to_new_head = length - k new_end = head for _ in range(steps_to_new_head - 1): new_end = new_end.next # Make the new end and new head new_head = new_end.next new_end.next = None return new_head"},{"question":"def subarray_product_less_than_k(nums: List[int], k: int) -> int: Returns the number of contiguous subarrays where the product of all elements in the subarray is less than k. >>> subarray_product_less_than_k([10, 5, 2, 6], 100) == 8 >>> subarray_product_less_than_k([10, 5, 2, 6], 1) == 0 >>> subarray_product_less_than_k([1, 2, 3, 4], 10) == 7 >>> subarray_product_less_than_k([1, 1, 1, 1], 2) == 10","solution":"def subarray_product_less_than_k(nums, k): Returns the number of contiguous subarrays where the product of all elements in the subarray is less than k. if k <= 1: return 0 count = 0 product = 1 left = 0 for right in range(len(nums)): product *= nums[right] while product >= k and left <= right: product /= nums[left] left += 1 count += (right - left + 1) return count"},{"question":"class DistinctElementCounter: def __init__(self, array): self.array = array def count_distinct(self, l, r): Counts the number of distinct elements in the subarray a[l...r] (1-based index). pass def update(self, i, x): Sets a[i] to x (1-based index). pass def process_queries(n, a, queries): Processes several queries to calculate statistics over subarrays of a. Parameters: n (int): The size of array a. a (List[int]): The integer array. queries (List[List[int]]): The queries to process. Returns: List[int]: The result for each query of the first type. Example: >>> n = 5 >>> a = [1, 2, 1, 3, 2] >>> queries = [ ... [1, 1, 3], ... [1, 2, 4], ... [2, 3, 3], ... [1, 1, 3] ... ] >>> process_queries(n, a, queries) [2, 3, 3] pass from typing import List def test_process_queries(): n = 5 a = [1, 2, 1, 3, 2] queries = [ [1, 1, 3], [1, 2, 4], [2, 3, 3], [1, 1, 3] ] expected_output = [2, 3, 3] assert process_queries(n, a, queries) == expected_output def test_process_queries_single_element(): n = 1 a = [42] queries = [ [1, 1, 1], [2, 1, 99], [1, 1, 1] ] expected_output = [1, 1] assert process_queries(n, a, queries) == expected_output def test_process_queries_all_same_element(): n = 5 a = [5, 5, 5, 5, 5] queries = [ [1, 1, 5], [2, 3, 10], [1, 1, 5] ] expected_output = [1, 2] assert process_queries(n, a, queries) == expected_output def test_process_queries_no_query(): n = 3 a = [1, 2, 3] queries = [] expected_output = [] assert process_queries(n, a, queries) == expected_output def test_process_queries_large_case(): n = 100000 a = list(range(1, 100001)) queries = [ [1, 1, 100000], [2, 50000, 1], [1, 1, 100000] ] expected_output = [100000, 99999] assert process_queries(n, a, queries) == expected_output","solution":"class DistinctElementCounter: def __init__(self, array): self.array = array def count_distinct(self, l, r): # slice the array to get the subarray and convert to a set to get distinct elements subarray = self.array[l-1:r] return len(set(subarray)) def update(self, i, x): self.array[i-1] = x def process_queries(n, a, queries): counter = DistinctElementCounter(a) results = [] for query in queries: q_type = query[0] if q_type == 1: _, l, r = query results.append(counter.count_distinct(l, r)) elif q_type == 2: _, i, x = query counter.update(i, x) return results"},{"question":"def sorted_number_string(s: str) -> str: Returns a sorted string representing the smallest possible number formed by sorting the digits and removing leading zeros. >>> sorted_number_string(\\"340210\\") \\"1234\\" >>> sorted_number_string(\\"950850\\") \\"5589\\" >>> sorted_number_string(\\"0000310\\") \\"13\\" >>> sorted_number_string(\\"000000\\") \\"0\\" >>> sorted_number_string(\\"\\") \\"0\\"","solution":"def sorted_number_string(s: str) -> str: Returns a sorted string representing the smallest possible number formed by sorting the digits and removing leading zeros. if s == \\"\\": return \\"0\\" # Sort digits sorted_digits = sorted(s) # Remove leading zeros result = \\"\\".join(sorted_digits).lstrip('0') # If the result is empty, return \\"0\\" return result if result else \\"0\\""},{"question":"def longest_increasing_subarray(n, heights): Returns the length of the longest contiguous subarray with strictly increasing heights. Input: - n: an integer representing the number of elements in the list - heights: a list of n integers representing the heights of the hills Output: - A single integer representing the length of the longest contiguous subarray where heights are strictly increasing. Example: >>> longest_increasing_subarray(8, [5, 1, 2, 3, 1, 2, 3, 4]) 4 >>> longest_increasing_subarray(5, [5, 4, 3, 2, 1]) 1 from solution import longest_increasing_subarray def test_single_element(): assert longest_increasing_subarray(1, [5]) == 1 def test_all_increasing(): assert longest_increasing_subarray(5, [1, 2, 3, 4, 5]) == 5 def test_none_increasing(): assert longest_increasing_subarray(5, [5, 4, 3, 2, 1]) == 1 def test_mixed_elements(): assert longest_increasing_subarray(8, [5, 1, 2, 3, 1, 2, 3, 4]) == 4 def test_two_increasing_segments(): assert longest_increasing_subarray(6, [1, 3, 5, 4, 6, 7]) == 3 def test_all_same(): assert longest_increasing_subarray(4, [2, 2, 2, 2]) == 1 def test_empty_list(): assert longest_increasing_subarray(0, []) == 0 def test_large_input(): n = 100000 heights = list(range(n)) assert longest_increasing_subarray(n, heights) == n","solution":"def longest_increasing_subarray(n, heights): Returns the length of the longest contiguous subarray with strictly increasing heights. if not heights or n == 0: return 0 max_length = 1 current_length = 1 for i in range(1, n): if heights[i] > heights[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def determine_winner(m: int, n: int, sequence: List[int]) -> str: Determines the winner of the game given the maximum integer value m, the initial number of elements n, and the initial sequence. >>> determine_winner(10, 3, [1, 2, 3]) \\"Alice\\" >>> determine_winner(5, 5, [1, 2, 3, 4, 5]) \\"Bob\\" >>> determine_winner(10, 0, []) \\"Alice\\" >>> determine_winner(2, 1, [2]) \\"Alice\\"","solution":"def determine_winner(m, n, sequence): Determines the winner of the game given the maximum integer value m, the initial number of elements n, and the initial sequence. sequence_set = set(sequence) if len(sequence_set) == m: # If all possible numbers are already in the sequence, Alice can't add any number return \\"Bob\\" # If there are missing numbers in the sequence, Alice can always start by adding a number return \\"Alice\\""},{"question":"def max_possible_min_power(n: int, powers: List[int]) -> int: Determine the maximum possible minimum power that he can achieve for the crystals after one ceremony. >>> max_possible_min_power(5, [1, 2, 3, 4, 5]) 3 >>> max_possible_min_power(6, [7, 2, 10, 8, 9, 11]) 7 >>> max_possible_min_power(1, [10]) 10 >>> max_possible_min_power(4, [5, 5, 5, 5]) 5 >>> max_possible_min_power(3, [1000000000, 1000000000, 1000000000]) 1000000000","solution":"def max_possible_min_power(n, powers): def can_achieve(min_power): # Starting from every index, calculate if we can form a subarray whose average is at least min_power prefix_sum, left = 0, 0 for right in range(n): prefix_sum += powers[right] while left <= right and (prefix_sum / (right - left + 1)) >= min_power: if (prefix_sum // (right - left + 1)) >= min_power: return True prefix_sum -= powers[left] left += 1 return False # Binary search to find the maximum minimum power low, high = 1, max(powers) while low < high: mid = (low + high + 1) // 2 if can_achieve(mid): low = mid else: high = mid - 1 return low"},{"question":"def max_sum_subarray(arr, k): Returns the maximum sum of a contiguous subarray of length k. :param arr: List of integers :param k: Integer that represents subarray length :return: Integer that represents maximum sum of a subarray of length k >>> max_sum_subarray([1, 4, 2, 10, 23, 3, 1, 0, 20], 4) 39 >>> max_sum_subarray([-1, -2, -3, -4], 2) -3 >>> max_sum_subarray([2, 1, 5, 1, 3, 2], 3) 9 >>> max_sum_subarray([1, 1, 1, 1, 1], 1) 1 >>> max_sum_subarray([5, -10, 6, 90, 3], 2) 96 >>> max_sum_subarray([], 2) 0 >>> max_sum_subarray([1, 2], 0) 0 >>> max_sum_subarray([1, 2], 3) 0","solution":"def max_sum_subarray(arr, k): Returns the maximum sum of a contiguous subarray of length k. :param arr: List of integers :param k: Integer that represents subarray length :return: Integer that represents maximum sum of a subarray of length k if len(arr) < k or k <= 0: return 0 # Compute the sum of the first window of size k max_sum = sum(arr[:k]) current_sum = max_sum # Slide the window from start to end of the array for i in range(k, len(arr)): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def find_minimized_max_pages(n: int, pages: List[int], k: int) -> int: Given an array of positive integers representing the number of pages in different notebooks, and a positive integer k, which represents the number of students, divide the notebooks among the k students in such a way that the maximum number of pages assigned to a student is minimized. Each student must be assigned at least one notebook, and each notebook can only be assigned to one student. >>> find_minimized_max_pages(4, [12, 34, 67, 90], 2) 113 >>> find_minimized_max_pages(3, [10, 20, 30], 1) 60 >>> find_minimized_max_pages(1, [50], 1) 50 >>> find_minimized_max_pages(3, [50, 50, 50], 3) 50 >>> find_minimized_max_pages(5, [10, 20, 30, 40, 50], 3) 60","solution":"def is_valid_distribution(pages, n, k, max_pages_per_student): required_students = 1 current_pages = 0 for i in range(n): if current_pages + pages[i] > max_pages_per_student: required_students += 1 current_pages = pages[i] if required_students > k: return False else: current_pages += pages[i] return True def find_minimized_max_pages(n, pages, k): left, right = max(pages), sum(pages) result = right while left <= right: mid = (left + right) // 2 if is_valid_distribution(pages, n, k, mid): result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"def convert_time(minutes): Converts the time from minutes to \\"X hour(s) and Y minute(s)\\" format. Args: minutes (int): The number of minutes. Returns: str: The time in \\"X hour(s) and Y minute(s)\\" format. Examples: >>> convert_time(130) '2 hour(s) and 10 minute(s)' >>> convert_time(45) '0 hour(s) and 45 minute(s)'","solution":"def convert_time(minutes): Converts the time from minutes to \\"X hour(s) and Y minute(s)\\" format. Args: minutes (int): The number of minutes. Returns: str: The time in \\"X hour(s) and Y minute(s)\\" format. hours = minutes // 60 remaining_minutes = minutes % 60 return f\\"{hours} hour(s) and {remaining_minutes} minute(s)\\""},{"question":"def can_attend_all_events(T: int, datasets: List[Dict[str, Any]]) -> List[str]: Determines if it is possible for every attendee to attend all their required events without any time overlaps. >>> can_attend_all_events(2, [ {\\"events\\": [ {\\"start\\": 10, \\"end\\": 20, \\"attendees\\": [1, 2, 3]}, {\\"start\\": 15, \\"end\\": 25, \\"attendees\\": [1, 3]}, {\\"start\\": 20, \\"end\\": 30, \\"attendees\\": [3, 4]} ]}, {\\"events\\": [ {\\"start\\": 5, \\"end\\": 15, \\"attendees\\": [1]}, {\\"start\\": 10, \\"end\\": 20, \\"attendees\\": [1]} ]} ]) [\\"No\\", \\"No\\"] >>> can_attend_all_events(1, [ {\\"events\\": [ {\\"start\\": 10, \\"end\\": 20, \\"attendees\\": [1]}, {\\"start\\": 21, \\"end\\": 30, \\"attendees\\": [1]}, {\\"start\\": 31, \\"end\\": 40, \\"attendees\\": [1]} ]} ]) [\\"Yes\\"]","solution":"def can_attend_all_events(T, datasets): results = [] for dataset in datasets: events = dataset[\\"events\\"] attendee_events = {} for event in events: start, end, attendees = event[\\"start\\"], event[\\"end\\"], event[\\"attendees\\"] for attendee in attendees: if attendee not in attendee_events: attendee_events[attendee] = [] attendee_events[attendee].append((start, end)) possible = True for attendee, event_times in attendee_events.items(): event_times.sort() for i in range(1, len(event_times)): if event_times[i][0] < event_times[i - 1][1]: possible = False break if not possible: break results.append(\\"Yes\\" if possible else \\"No\\") return results"},{"question":"import re def isValidPassword(password): Checks if the given password is valid based on the given criteria. Criteria: - At least 8 characters long - Contains at least one lowercase letter - Contains at least one uppercase letter - Contains at least one digit - Contains at least one special character (e.g., !@#%^&*()-+=) Args: password (str): The password string to be checked. Returns: bool: True if the password is valid, False otherwise. # Your code here # Tests def test_isValidPassword_valid_cases(): assert isValidPassword(\\"Password123!\\") == True assert isValidPassword(\\"Abcdefg1@\\") == True assert isValidPassword(\\"MyP@ssw0rd!\\") == True assert isValidPassword(\\"V@1idP@\\") == True def test_isValidPassword_invalid_too_short(): assert isValidPassword(\\"Pass1!\\") == False assert isValidPassword(\\"Short1!\\") == False def test_isValidPassword_invalid_no_lowercase(): assert isValidPassword(\\"PASSWORD123!\\") == False assert isValidPassword(\\"1234ABCD!\\") == False def test_isValidPassword_invalid_no_uppercase(): assert isValidPassword(\\"password123!\\") == False assert isValidPassword(\\"1234abcd!\\") == False def test_isValidPassword_invalid_no_digit(): assert isValidPassword(\\"Password!@#\\") == False assert isValidPassword(\\"ASDFghjkl!\\") == False def test_isValidPassword_invalid_no_special_character(): assert isValidPassword(\\"Password123\\") == False assert isValidPassword(\\"Valid12345\\") == False","solution":"import re def isValidPassword(password): Checks if the given password is valid based on the given criteria. Criteria: - At least 8 characters long - Contains at least one lowercase letter - Contains at least one uppercase letter - Contains at least one digit - Contains at least one special character (e.g., !@#%^&*()-+=) Args: password (str): The password string to be checked. Returns: bool: True if the password is valid, False otherwise. if len(password) < 8: return False if not re.search(r'[a-z]', password): return False if not re.search(r'[A-Z]', password): return False if not re.search(r'd', password): return False if not re.search(r'[!@#%^&*(),.?\\":{}|<>]', password): return False return True"},{"question":"def largest_product(test_cases): Returns the largest product that can be obtained by multiplying two distinct elements from each test case. >>> largest_product([(5, [10, -20, 5, -10, 7]), (4, [1, 2, 3, 4])]) [200, 12] >>> largest_product([(3, [-1, -2, -3]), (2, [-1, 1])]) [6, -1] # Your implementation goes here def parse_input(input_data): Parses string input data for multiple test cases. >>> parse_input(\\"2n5n10 -20 5 -10 7n4n1 2 3 4n\\") [(5, [10, -20, 5, -10, 7]), (4, [1, 2, 3, 4])] # Your implementation goes here import doctest doctest.testmod()","solution":"def largest_product(test_cases): results = [] for case in test_cases: arr = case[1] n = len(arr) if n < 2: results.append(0) continue arr.sort() product1 = arr[0] * arr[1] product2 = arr[-1] * arr[-2] results.append(max(product1, product2)) return results def parse_input(input_data): lines = input_data.strip().split(\\"n\\") T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(lines[index]) arr = list(map(int, lines[index + 1].split())) test_cases.append((N, arr)) index += 2 return test_cases"},{"question":"def swapCase(s: str) -> str: Takes a string s and swaps the case of each letter. >>> swapCase(\\"HeLLoWoRLd\\") \\"hEllOwOrlD\\" >>> swapCase(\\"Python\\") \\"pYTHON\\"","solution":"def swapCase(s): Takes a string s and swaps the case of each letter. return s.swapcase()"},{"question":"def primeFactorsSum(N: int) -> int: Given a number N, compute the sum of all prime factors of N. Since the answer can be very large, return the result modulo 10^{9}+7. Example 1: >>> primeFactorsSum(28) 9 Example 2: >>> primeFactorsSum(45) 8 Constraints: 1 <= N <= 10^{9} pass # Unit Tests def test_example1(): assert primeFactorsSum(28) == 9 def test_example2(): assert primeFactorsSum(45) == 8 def test_single_prime(): assert primeFactorsSum(13) == 13 def test_power_of_prime(): assert primeFactorsSum(27) == 3 # 3^3 def test_large_composite(): assert primeFactorsSum(2*3*5*7*11) == (2+3+5+7+11) % (10**9 + 7) def test_large_prime(): assert primeFactorsSum(1000000007) == 1000000007 % (10**9 + 7) # 1000000007 itself is a prime def test_power_of_two(): assert primeFactorsSum(1024) == 2 # 2^10","solution":"def primeFactorsSum(N): This function calculates the sum of all distinct prime factors of a number N, and returns the result modulo 10^9 + 7. MOD = 10**9 + 7 sum_primes = 0 original_N = N # Check for smallest prime factor 2 and sum it only once if N % 2 == 0: sum_primes += 2 while N % 2 == 0: N //= 2 # Check for odd factors from 3 onwards for i in range(3, int(original_N**0.5) + 1, 2): if N % i == 0: sum_primes += i while N % i == 0: N //= i # If N is still a prime number greater than 2 if N > 2: sum_primes += N return sum_primes % MOD"},{"question":"def organize_stamp_collection(test_cases): Given a list of stamps with their country codes and rarity levels, determine the number of distinct countries represented in the collection and the average rarity level of the stamps from each country. Parameters: test_cases (List[Tuple[int, List[str]]]): List of test cases where each test case is a tuple. The first element of the tuple is an integer representing the number of stamps, and the second element is a list of strings where each string represents a stamp description in the format \\"country_code rarity_level\\". Returns: List[str]: List of strings where each string contains the number of distinct countries followed by lines of country codes and their respective average rarity levels sorted alphabetically. Example: >>> test_cases = [(4, [\\"USA 50\\", \\"IND 70\\", \\"USA 20\\", \\"IND 30\\"])] >>> organize_stamp_collection(test_cases) [\\"2nIND 50.00nUSA 35.00\\"]","solution":"def organize_stamp_collection(test_cases): results = [] for case in test_cases: N, stamps = case country_data = {} for stamp in stamps: country_code, rarity_level = stamp.split() rarity_level = int(rarity_level) if country_code not in country_data: country_data[country_code] = [] country_data[country_code].append(rarity_level) sorted_countries = sorted(country_data.keys()) result = [str(len(sorted_countries))] for country in sorted_countries: avg_rarity = sum(country_data[country]) / len(country_data[country]) result.append(f\\"{country} {avg_rarity:.2f}\\") results.append(\\"n\\".join(result)) return results # Sample Input test_cases = [ (4, [\\"USA 50\\", \\"IND 70\\", \\"USA 20\\", \\"IND 30\\"]), (3, [\\"JPN 60\\", \\"GER 80\\", \\"USA 40\\"]) ] organize_stamp_collection(test_cases)"},{"question":"def can_form_balanced_sets(T, test_cases): Determines if it is possible to divide the array of ingredient quantities into balanced sets. Args: T (int): The number of test cases. test_cases (List[Tuple[Tuple[int, int], List[int]]]): List of test cases where each test case is a tuple consisting of another tuple with two integers (n, k) and a list of integers representing the quantities. Returns: List[str]: List containing \\"POSSIBLE\\" or \\"IMPOSSIBLE\\" for each test case. >>> can_form_balanced_sets(2, [((6, 2), [4, 4, 2, 2, 4, 4]), ((5, 3), [4, 4, 6, 6, 8])]) ['POSSIBLE', 'IMPOSSIBLE'] >>> can_form_balanced_sets(1, [((4, 2), [2, 2, 2, 2])]) ['POSSIBLE'] >> can_form_balanced_sets(1, [((1, 2), [1])]) ['IMPOSSIBLE']","solution":"def can_form_balanced_sets(T, test_cases): results = [] for i in range(T): n, k = test_cases[i][0] quantities = test_cases[i][1] ingredient_count = {} # Count frequencies of each ingredient for q in quantities: if q in ingredient_count: ingredient_count[q] += 1 else: ingredient_count[q] = 1 # Check if it's possible to form balanced sets for count in ingredient_count.values(): if count % k != 0: results.append(\\"IMPOSSIBLE\\") break else: results.append(\\"POSSIBLE\\") return results"},{"question":"def max_flavor_sum(n: int, k: int, s: int, flavors: List[int]) -> int: Returns the maximum possible sum of flavor ratings of the selected k pastries after performing at most s swaps of consecutive pastries. >>> max_flavor_sum(5, 3, 1, [3, 7, 2, 6, 4]) 17 >>> max_flavor_sum(6, 4, 3, [1, 9, 3, 4, 8, 7]) 28 >>> max_flavor_sum(4, 2, 2, [5, 2, 9, 1]) 14 # Your code here if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"def max_flavor_sum(n, k, s, flavors): Returns the maximum possible sum of flavor ratings of the selected k pastries after performing at most s swaps of two consecutive pastries. # Using a priority queue to find the k largest pastries efficiently from heapq import nlargest # If the allowed swaps s is very large, it means we can practically rearrange # the pastries in any order. So we can directly pick the k largest. if s >= n: return sum(nlargest(k, flavors)) original_flavors = flavors[:] for i in range(s): for j in range(n-1): if flavors[j] < flavors[j+1]: flavors[j], flavors[j+1] = flavors[j+1], flavors[j] return sum(nlargest(k, flavors)) # Example usage: n, k, s = 6, 4, 3 flavors = [1, 9, 3, 4, 8, 7] print(max_flavor_sum(n, k, s, flavors)) # Output: 28"},{"question":"def longest_valid_subsequence_length(s: str) -> int: Returns the length of the longest subsequence where no two consecutive characters are the same. >>> longest_valid_subsequence_length(\\"AACCAGT\\") 5 >>> longest_valid_subsequence_length(\\"GGGG\\") 1 >>> longest_valid_subsequence_length(\\"ACGT\\") 4 >>> longest_valid_subsequence_length(\\"AA\\") 1 >>> longest_valid_subsequence_length(\\"\\") 0 >>> longest_valid_subsequence_length(\\"A\\") 1 >>> longest_valid_subsequence_length(\\"AGAGAG\\") 6 pass # TODO: Implement function def solve(test_cases: list) -> list: For a list of test cases, returns a list of the length of the longest subsequences for each test case. >>> solve([\\"AACCAGT\\", \\"GGGG\\", \\"ACGT\\"]) [5, 1, 4] pass # TODO: Implement function","solution":"def longest_valid_subsequence_length(s): Returns the length of the longest subsequence where no two consecutive characters are the same. if not s: return 0 max_length = 1 # The length of the longest subsequence (at least one character will always be used) for i in range(1, len(s)): if s[i] != s[i - 1]: max_length += 1 return max_length def solve(test_cases): results = [] for s in test_cases: results.append(longest_valid_subsequence_length(s)) return results"},{"question":"def largest_absolute_difference(N: int, A: List[int]) -> int: Find the largest possible absolute difference between the maximum and minimum elements of any contiguous subarray. Parameters: N (int): The length of the array. A (list of int): The array of positive integers. Returns: int: The largest possible absolute difference between the maximum and minimum elements of any contiguous subarray. >>> largest_absolute_difference(5, [1, 3, 6, 4, 5]) 5 >>> largest_absolute_difference(4, [10, 2, 14, 8]) 12","solution":"def largest_absolute_difference(N, A): Returns the largest possible absolute difference between the maximum and minimum elements of any contiguous subarray. Parameters: N (int): The length of the array A (list of int): The array of positive integers Returns: int: The largest possible absolute difference # For simplicity, we take the difference between the max and min of the whole array max_element = max(A) min_element = min(A) return abs(max_element - min_element)"},{"question":"from typing import List, Tuple def min_specific_intersections(n: int, roads: List[Tuple[int, int]]) -> int: Calculate and return the minimum number of specific intersections that are directly connected by a road of different types in the optimal partition. >>> min_specific_intersections(7, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7)]) 0 >>> min_specific_intersections(5, [(1, 2), (1, 3), (1, 4), (1, 5)]) 0 >>> min_specific_intersections(6, [(1, 2), (2, 3), (3, 4), (2, 5), (3, 6)]) 1","solution":"from collections import deque, defaultdict def min_specific_intersections(n, roads): def bfs(graph, n): colors = [-1] * (n + 1) specific_count = defaultdict(int) q = deque([(1, 0)]) colors[1] = 0 while q: node, color = q.popleft() for neighbor in graph[node]: if colors[neighbor] == -1: colors[neighbor] = 1 - color q.append((neighbor, 1 - color)) for node in range(1, n + 1): if len(graph[node]) == 3: specific_count[colors[node]] += 1 return min(specific_count[0], specific_count[1]) graph = defaultdict(list) for x, y in roads: graph[x].append(y) graph[y].append(x) return bfs(graph, n)"},{"question":"from typing import List def can_form_palindrome(s: str) -> str: Returns \\"YES\\" if any permutation of string s can be rearranged to form a palindrome, otherwise \\"NO\\". >>> can_form_palindrome(\\"civic\\") \\"YES\\" >>> can_form_palindrome(\\"ivicc\\") \\"YES\\" >>> can_form_palindrome(\\"hello\\") \\"NO\\" pass def process_test_cases(t: int, test_cases: List[str]) -> List[str]: Processes multiple test cases and returns a list of results for each test case. >>> process_test_cases(3, [\\"civic\\", \\"ivicc\\", \\"hello\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> process_test_cases(2, [\\"aabb\\", \\"abc\\"]) [\\"YES\\", \\"NO\\"] pass","solution":"def can_form_palindrome(s): Returns \\"YES\\" if any permutation of string s can be rearranged to form a palindrome, otherwise \\"NO\\". from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Count how many characters have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if at most one character has an odd count if odd_count > 1: return \\"NO\\" else: return \\"YES\\" def process_test_cases(t, test_cases): results = [] for s in test_cases: results.append(can_form_palindrome(s)) return results"},{"question":"def shortest_good_substring(s: str, k: int) -> int: Returns the length of the shortest good substring in s with exactly k distinct characters. If there is no such substring, returns -1. >>> shortest_good_substring(\\"abracadabra\\", 2) # returns 2 >>> shortest_good_substring(\\"abccbaac\\", 3) # returns 3 >>> shortest_good_substring(\\"aaaaaaa\\", 2) # returns -1","solution":"def shortest_good_substring(s, k): Returns the length of the shortest good substring in s with exactly k distinct characters. If there is no such substring, returns -1. from collections import defaultdict n = len(s) min_length = float('inf') left = 0 char_count = defaultdict(int) for right in range(n): char_count[s[right]] += 1 while len(char_count) == k: min_length = min(min_length, right - left + 1) char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 return min_length if min_length != float('inf') else -1"},{"question":"def optimal_delivery_sequence(N, packages): Determines the optimal sequence of delivering packages based on priority and distance. Parameters: N (int): The number of packages. packages (list of tuples): Each tuple contains two integers (priority, distance). Returns: list: A list of indices representing the optimal delivery sequence. >>> optimal_delivery_sequence(3, [(2, 100), (1, 50), (2, 30)]) [3, 1, 2] >>> optimal_delivery_sequence(5, [(5, 500), (4, 300), (5, 200), (3, 100), (2, 400)]) [3, 1, 2, 4, 5]","solution":"def optimal_delivery_sequence(N, packages): Determines the optimal sequence of delivering packages based on priority and distance. Parameters: N (int): The number of packages. packages (list of tuples): Each tuple contains two integers (priority, distance). Returns: list: A list of indices representing the optimal delivery sequence. # Pair each package with its original index (1-based) indexed_packages = [(i + 1, p[0], p[1]) for i, p in enumerate(packages)] # Sort the packages by priority (descending) and by distance (ascending) sorted_packages = sorted(indexed_packages, key=lambda x: (-x[1], x[2])) # Extract the indices of the sorted packages result = [p[0] for p in sorted_packages] return result"},{"question":"from typing import List, Tuple def unique_paths(m: int, n: int) -> int: Calculate the number of unique paths in a m x n grid. The robot can only move right or down. Args: m (int): Number of rows. n (int): Number of columns. Returns: int: Number of unique paths. pass def solve(test_cases: List[Tuple[int, int]]) -> List[int]: Solves the problem for each test case. Args: test_cases (list of tuples): List of (m, n) representing the grid dimensions for each test case. Returns: list of int: Number of unique paths for each test case. pass # Example test cases def test_unique_paths_basic(): assert unique_paths(3, 7) == 28 assert unique_paths(4, 5) == 35 assert unique_paths(1, 1) == 1 assert unique_paths(2, 2) == 2 def test_unique_paths_edges(): assert unique_paths(1, 100) == 1 assert unique_paths(100, 1) == 1 assert unique_paths(2, 2) == 2 def test_solve(): test_cases = [(3, 7), (4, 5)] assert solve(test_cases) == [28, 35] test_cases = [(1, 1), (2, 2), (3, 3)] assert solve(test_cases) == [1, 2, 6] test_cases = [(10, 10), (7, 3)] assert solve(test_cases) == [48620, 28]","solution":"def unique_paths(m, n): Calculate the number of unique paths in a m x n grid. The robot can only move right or down. Args: m (int): Number of rows. n (int): Number of columns. Returns: int: Number of unique paths. if m == 1 or n == 1: return 1 # Create a 2D list to store results of subproblems dp = [[1] * n for _ in range(m)] # Fill the 2D list by bottom-up manner for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1] def solve(test_cases): Solves the problem for each test case. Args: test_cases (list of tuples): List of (m, n) representing the grid dimensions for each test case. Returns: list of int: Number of unique paths for each test case. results = [] for m, n in test_cases: results.append(unique_paths(m, n)) return results"},{"question":"from typing import List def findPalindromes(n: int) -> List[int]: Given an integer n, find all palindromic numbers within the range from 1 to n (inclusive). A palindromic number is a number that remains the same when its digits are reversed. >>> findPalindromes(10) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> findPalindromes(22) [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22] >>> findPalindromes(200) [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191]","solution":"from typing import List def findPalindromes(n: int) -> List[int]: Returns a list of all palindromic numbers from 1 to n (inclusive). def is_palindrome(num: int) -> bool: return str(num) == str(num)[::-1] return [i for i in range(1, n+1) if is_palindrome(i)]"},{"question":"def final_position(commands): Determines the final coordinates of the vacuum cleaner after executing all commands. :param commands: str - sequence of commands consisting of U, D, L, and R. :return: tuple of (x, y) - final coordinates of the vacuum cleaner. >>> final_position(\\"UDLR\\") (0, 0) >>> final_position(\\"UUU\\") (0, 3) >>> final_position(\\"LLDDRR\\") (0, -2) def process_test_cases(test_cases): Processes multiple test cases and returns the final positions for each case. :param test_cases: list of str - each string is a sequence of commands. :return: list of tuples - final coordinates for each test case. >>> process_test_cases([\\"UDLR\\", \\"UUU\\", \\"LLDDRR\\"]) [(0, 0), (0, 3), (0, -2)] >>> process_test_cases([\\"\\"]) [(0, 0)] >>> process_test_cases([\\"UU\\", \\"DD\\", \\"LL\\", \\"RR\\"]) [(0, 2), (0, -2), (-2, 0), (2, 0)]","solution":"def final_position(commands): Determines the final coordinates of the vacuum cleaner after executing all commands. The function expects a single string of commands. :param commands: str - sequence of commands consisting of U, D, L, and R. :return: tuple of (x, y) - final coordinates of the vacuum cleaner. x, y = 0, 0 for command in commands: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 return x, y def process_test_cases(test_cases): Processes multiple test cases and returns the final positions for each case. :param test_cases: list of str - each string is a sequence of commands. :return: list of tuples - final coordinates for each test case. return [final_position(commands) for commands in test_cases]"},{"question":"def color_grid(R, C, grid): Color the grid ensuring no two adjacent cells have the same color. Args: R: int : number of rows C: int : number of columns grid: List[List[int]] : 2D list representing initial grid with colors and empty cells (0 indicating empty cells) Returns: List[List[int]] : the completed grid after coloring pass def test_color_grid_case1(): input_data = [ [1, 0, 0, 2], [0, 0, 0, 0], [2, 0, 3, 0], [0, 2, 0, 1] ] expected_output = [ [1, 3, 4, 2], [3, 2, 1, 4], [2, 1, 3, 4], [4, 2, 3, 1] ] R, C = 4, 4 result = color_grid(R, C, input_data) for i in range(R): for j in range(C): assert result[i][j] != 0 if i > 0: assert result[i][j] != result[i - 1][j] if j > 0: assert result[i][j] != result[i][j - 1] def test_color_grid_case2(): input_data = [ [0, 0, 2], [0, 1, 0], [1, 0, 0] ] expected_output = [ [1, 3, 2], [3, 1, 4], [1, 4, 3] ] R, C = 3, 3 result = color_grid(R, C, input_data) for i in range(R): for j in range(C): assert result[i][j] != 0 if i > 0: assert result[i][j] != result[i - 1][j] if j > 0: assert result[i][j] != result[i][j - 1] def test_color_grid_case3(): input_data = [ [0] ] expected_output = [ [1] ] R, C = 1, 1 result = color_grid(R, C, input_data) for i in range(R): for j in range(C): assert result[i][j] != 0 def test_color_grid_case4(): input_data = [ [0, 1], [1, 0] ] expected_output = [ [2, 1], [1, 2] ] R, C = 2, 2 result = color_grid(R, C, input_data) for i in range(R): for j in range(C): assert result[i][j] != 0 if i > 0: assert result[i][j] != result[i - 1][j] if j > 0: assert result[i][j] != result[i][j - 1]","solution":"def color_grid(R, C, grid): def is_safe_to_color(r, c, color): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < R and 0 <= nc < C and grid[nr][nc] == color: return False return True def backtrack(r, c): if r == R: return True if c == C: return backtrack(r + 1, 0) if grid[r][c] != 0: return backtrack(r, c + 1) for color in range(1, 5): if is_safe_to_color(r, c, color): grid[r][c] = color if backtrack(r, c + 1): return True grid[r][c] = 0 return False backtrack(0, 0) return grid"},{"question":"def longest_consecutive_work_blocks(m: int, blocks: List[int]) -> int: Returns the maximum number of consecutive work blocks (represented as 1s) in a workday. Parameters: m (int): The length of the workday in hourly blocks (1  m  100). blocks (list of int): A list of 0s and 1s representing break and work blocks respectively. Returns: int: The longest sequence of consecutive 1s. >>> longest_consecutive_work_blocks(6, [1, 1, 0, 1, 1, 1]) 3 >>> longest_consecutive_work_blocks(5, [0, 0, 0, 0, 0]) 0 >>> longest_consecutive_work_blocks(8, [1, 1, 1, 0, 1, 1, 0, 1]) 3 from typing import List def test_example_1(): assert longest_consecutive_work_blocks(6, [1, 1, 0, 1, 1, 1]) == 3 def test_example_2(): assert longest_consecutive_work_blocks(5, [0, 0, 0, 0, 0]) == 0 def test_example_3(): assert longest_consecutive_work_blocks(8, [1, 1, 1, 0, 1, 1, 0, 1]) == 3 def test_single_work_block(): assert longest_consecutive_work_blocks(1, [1]) == 1 def test_single_break_block(): assert longest_consecutive_work_blocks(1, [0]) == 0 def test_all_work_blocks(): assert longest_consecutive_work_blocks(5, [1, 1, 1, 1, 1]) == 5 def test_alternating_blocks(): assert longest_consecutive_work_blocks(6, [1, 0, 1, 0, 1, 0]) == 1 def test_with_long_breaks(): assert longest_consecutive_work_blocks(10, [1, 1, 0, 0, 0, 1, 1, 1, 0, 0]) == 3","solution":"def longest_consecutive_work_blocks(m, blocks): Returns the maximum number of consecutive work blocks (represented as 1s) in a workday. Parameters: m (int): The length of the workday in hourly blocks (1  m  100). blocks (list of int): A list of 0s and 1s representing break and work blocks respectively. Returns: int: The longest sequence of consecutive 1s. max_consecutive = 0 current_consecutive = 0 for block in blocks: if block == 1: current_consecutive += 1 if current_consecutive > max_consecutive: max_consecutive = current_consecutive else: current_consecutive = 0 return max_consecutive"},{"question":"def warehouse_max_value(n: int, W: int, products: List[Tuple[int, int]]) -> int: Calculate the maximum value of products that can be stored in the warehouse without exceeding capacity. :param n: int - the number of product types :param W: int - the warehouse capacity :param products: List[Tuple[int, int]] - each tuple contains the value and weight of a product type :return: int - the maximum value of products that can be stored in the warehouse >>> warehouse_max_value(3, 50, [(60, 10), (100, 20), (120, 30)]) 240 >>> warehouse_max_value(2, 50, [(100, 50), (1, 1)]) 100 >>> warehouse_max_value(1, 10, [(100, 20)]) 50 >>> warehouse_max_value(3, 60, [(60, 20), (80, 20), (100, 20)]) 240 >>> warehouse_max_value(3, 0, [(60, 10), (80, 20), (100, 30)]) 0 >>> warehouse_max_value(1, 5, [(1000, 10)]) 500","solution":"def warehouse_max_value(n, W, products): Calculate the maximum value of products that can be stored in the warehouse without exceeding capacity. :param n: int - the number of product types :param W: int - the warehouse capacity :param products: list of tuples - each tuple contains the value and weight of a product type :return: int - the maximum value of products that can be stored in the warehouse # Sort products by value to weight ratio in descending order products.sort(key=lambda x: x[0] / x[1], reverse=True) max_value = 0 remaining_capacity = W for value, weight in products: if remaining_capacity == 0: break # If the current product can be stored fully if weight <= remaining_capacity: max_value += value remaining_capacity -= weight else: # If the current product can only be stored partially fraction = remaining_capacity / weight max_value += value * fraction remaining_capacity = 0 # The warehouse is full return max_value"},{"question":"def num_decodings(s: str) -> int: Given a string of digits, returns the number of possible decoded messages. >>> num_decodings(\\"123\\") 3 >>> num_decodings(\\"27\\") 1 >>> num_decodings(\\"10\\") 1 def process_test_cases(t: int, cases: List[str]) -> List[int]: Process multiple test cases for the number of possible decoded messages. >>> process_test_cases(3, [\\"123\\", \\"27\\", \\"10\\"]) [3, 1, 1] >>> process_test_cases(4, [\\"0\\", \\"301\\", \\"101\\", \\"1111\\"]) [0, 0, 1, 5] # Here are some test cases to validate your solution def test_num_decodings(): assert num_decodings(\\"123\\") == 3 assert num_decodings(\\"27\\") == 1 assert num_decodings(\\"10\\") == 1 assert num_decodings(\\"0\\") == 0 assert num_decodings(\\"301\\") == 0 assert num_decodings(\\"101\\") == 1 assert num_decodings(\\"1111\\") == 5 assert num_decodings(\\"\\") == 0 def test_process_test_cases(): cases = [\\"123\\", \\"27\\", \\"10\\"] assert process_test_cases(3, cases) == [3, 1, 1] cases = [\\"0\\", \\"301\\", \\"101\\", \\"1111\\"] assert process_test_cases(4, cases) == [0, 0, 1, 5] cases = [\\"1\\", \\"11\\", \\"111\\", \\"1111\\"] assert process_test_cases(4, cases) == [1, 2, 3, 5]","solution":"def num_decodings(s): Given a string of digits, returns the number of possible decoded messages. if not s or s[0] == '0': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 if s[0] != '0' else 0 for i in range(2, n + 1): one_digit = int(s[i-1:i]) two_digits = int(s[i-2:i]) if 1 <= one_digit <= 9: dp[i] += dp[i-1] if 10 <= two_digits <= 26: dp[i] += dp[i-2] return dp[n] def process_test_cases(t, cases): results = [] for case in cases: results.append(num_decodings(case)) return results"},{"question":"def rearrange_list(arr): Reorder the list such that all negative integers appear before all non-negative integers while preserving the relative order of the negative integers and non-negative integers. :param list arr: A list of integers :return: The reordered list :rtype: list","solution":"def rearrange_list(arr): Reorder the list such that all negative integers appear before all non-negative integers while preserving the relative order of the negative integers and non-negative integers. :param list arr: A list of integers :return: The reordered list :rtype: list negatives = [x for x in arr if x < 0] non_negatives = [x for x in arr if x >= 0] return negatives + non_negatives"},{"question":"def reorderArray(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Given an array of integers, determine if it is possible to reorder the elements such that each adjacent pair of elements has a difference of exactly 1. >>> reorderArray(3, [(4, [1, 2, 3, 4]), (5, [3, 1, 4, 2, 6]), (3, [7, 6, 5])]) ['YES', 'NO', 'YES'] >>> reorderArray(1, [(1, [1])]) ['YES'] >>> reorderArray(2, [(3, [2, 3, 4]), (3, [10, 8, 9])]) ['YES', 'YES'] >>> reorderArray(1, [(5, [-2, -1, 0, 1, 2])]) ['YES'] >>> reorderArray(2, [(4, [1, 4, 5, 6]), (6, [1, 2, 4, 5, 6, 9])]) ['NO', 'NO']","solution":"def reorderArray(T, test_cases): results = [] for i in range(T): N, arr = test_cases[i] if N == 1: results.append(\\"YES\\") continue arr.sort() possible = True for j in range(1, N): if arr[j] - arr[j-1] != 1: possible = False break if possible: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List def lcm(a, b): Helper function to compute least common multiple (LCM) of two numbers. pass # Replace this with your implementation def lcm_multiple(numbers): Helper function to compute LCM of multiple numbers. pass # Replace this with your implementation def count_simultaneous_arrivals(D: int, bus_times: List[int]) -> int: Returns the number of times all buses arrive at the central station simultaneously in a day. Parameters: D (int): The number of minutes in the day. bus_times (list): List of integers, each representing the time in minutes each bus takes to complete its route. Returns: int: Number of simultaneous arrivals in a day. >>> count_simultaneous_arrivals(60, [15, 20]) 2 >>> count_simultaneous_arrivals(100, [30, 40, 50]) 1 pass # Replace this with your implementation def main(test_cases: List[tuple]) -> List[int]: Given multiple test cases, returns the results for each test case. Parameters: test_cases (List of tuple): Each element is a tuple with D and bus_times. Returns: List[int]: List containing results for each test case. pass # Replace this with your implementation","solution":"from math import gcd from functools import reduce def lcm(a, b): return a * b // gcd(a, b) def lcm_multiple(numbers): return reduce(lcm, numbers, 1) def count_simultaneous_arrivals(D, bus_times): Returns the number of times all buses arrive at the central station simultaneously in a day. Parameters: D (int): The number of minutes in the day. bus_times (list): List of integers, each representing the time in minutes each bus takes to complete its route. Returns: int: Number of simultaneous arrivals in a day. multiple_lcm = lcm_multiple(bus_times) return D // multiple_lcm + 1 def main(test_cases): results = [] for D, bus_times in test_cases: results.append(count_simultaneous_arrivals(D, bus_times)) return results"},{"question":"def max_absolute_difference(arr): Takes an array of integers and returns the maximum possible absolute difference between any two elements of the array. >>> max_absolute_difference([1, 2, 3, 4]) 3 >>> max_absolute_difference([-10, -2, -3, -20, -5]) 18 >>> max_absolute_difference([10, -10, 5, -5]) 20 >>> max_absolute_difference([7]) 0 >>> max_absolute_difference([]) 0","solution":"def max_absolute_difference(arr): Returns the maximum possible absolute difference between any two elements of the array. if not arr: return 0 max_val = max(arr) min_val = min(arr) return abs(max_val - min_val)"},{"question":"def current_occupants(events): Function to determine the current occupants inside the building after processing a series of events. Args: events: list of tuples (timestamp, personID, eventType) Returns: List of unique personIDs currently inside the building, sorted in ascending order. >>> current_occupants([(1, \\"Alice\\", \\"enter\\"), (2, \\"Bob\\", \\"enter\\"), (3, \\"Alice\\", \\"exit\\"), (4, \\"Charlie\\", \\"enter\\")]) [\\"Bob\\", \\"Charlie\\"] >>> current_occupants([(1, \\"Alice\\", \\"enter\\"), (2, \\"Alice\\", \\"exit\\"), (3, \\"Alice\\", \\"enter\\"), (4, \\"Alice\\", \\"enter\\")]) [\\"Alice\\"] >>> current_occupants([(1, \\"Dan\\", \\"enter\\"), (2, \\"Dan\\", \\"exit\\"), (3, \\"Eve\\", \\"enter\\"), (4, \\"Eve\\", \\"exit\\"), (5, \\"Frank\\", \\"enter\\")]) [\\"Frank\\"] >>> current_occupants([(1, \\"Alice\\", \\"enter\\"), (2, \\"Alice\\", \\"exit\\"), (3, \\"Bob\\", \\"enter\\"), (4, \\"Bob\\", \\"exit\\")]) [] >>> current_occupants([]) [] >>> current_occupants([(1, \\"Alice\\", \\"enter\\"), (2, \\"Bob\\", \\"enter\\"), (3, \\"Alice\\", \\"enter\\"), (4, \\"Bob\\", \\"enter\\")]) [\\"Alice\\", \\"Bob\\"] pass","solution":"def current_occupants(events): Function to determine the current occupants inside the building after processing a series of events. Args: events: list of tuples (timestamp, personID, eventType) Returns: List of unique personIDs currently inside the building, sorted in ascending order. occupant_status = {} for timestamp, personID, eventType in events: if eventType == \\"enter\\": occupant_status[personID] = occupant_status.get(personID, 0) + 1 elif eventType == \\"exit\\": occupant_status[personID] = occupant_status.get(personID, 0) - 1 return sorted([person for person, status in occupant_status.items() if status > 0])"},{"question":"def check_permutation(nums1, nums2): Given two lists of integers, nums1 and nums2, determine whether the two lists are permutations of each other. A list is a permutation of another if it contains the same elements with the exact same frequencies. >>> check_permutation([1, 2, 3, 4], [2, 1, 4, 3]) True >>> check_permutation([1, 1, 2, 3], [1, 2, 2, 3]) False >>> check_permutation([], []) True >>> check_permutation([-1, -2, -3, -4], [-4, -3, -2, -1]) True >>> check_permutation([1, -1, 0, 2], [2, 0, -1, 1]) True >>> check_permutation([1, 2, 2, 3], [3, 2, 1, 2]) True >>> check_permutation([1, 2, 2, 3], [3, 1, 2, 2]) True >>> check_permutation([1], [1]) True >>> check_permutation([1], [2]) False","solution":"def check_permutation(nums1, nums2): Returns True if nums1 is a permutation of nums2, otherwise False. if len(nums1) != len(nums2): return False from collections import Counter return Counter(nums1) == Counter(nums2)"},{"question":"from typing import List def min_cost_to_exit(n: int, m: int, start_row: int, start_col: int, costs: List[List[int]]) -> int: Returns the minimum cost to move from (start_row, start_col) to (n-1, m-1) given the costs matrix. >>> costs = [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ] >>> min_cost_to_exit(3, 3, 0, 0, costs) 7 >>> costs = [[0]] >>> min_cost_to_exit(1, 1, 0, 0, costs) 0 >>> costs = [ ... [2, 1], ... [5, 3] ... ] >>> min_cost_to_exit(2, 2, 1, 1, costs) 3 >>> n, m = 5, 5 >>> costs = [ ... [1, 3, 1, 8, 2], ... [1, 5, 1, 6, 1], ... [4, 2, 1, 0, 3], ... [1, 2, 1, 2, 1], ... [3, 3, 1, 1, 1] ... ] >>> min_cost_to_exit(n, m, 2, 2, costs) 5","solution":"import heapq def min_cost_to_exit(n, m, start_row, start_col, costs): Returns the minimum cost to move from (start_row, start_col) to (n-1, m-1) given the costs matrix. directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up min_heap = [(costs[start_row][start_col], start_row, start_col)] # (cost, row, column) min_cost = [[float('inf')] * m for _ in range(n)] min_cost[start_row][start_col] = costs[start_row][start_col] while min_heap: current_cost, x, y = heapq.heappop(min_heap) if (x, y) == (n-1, m-1): return current_cost for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m: new_cost = current_cost + costs[nx][ny] if new_cost < min_cost[nx][ny]: min_cost[nx][ny] = new_cost heapq.heappush(min_heap, (new_cost, nx, ny)) return min_cost[n-1][m-1]"},{"question":"def remove_k_digits(num: str, k: int) -> str: Remove k digits from the number to get the smallest possible number. >>> remove_k_digits(\\"1432219\\", 3) = \\"1219\\" >>> remove_k_digits(\\"10200\\", 1) = \\"200\\" >>> remove_k_digits(\\"10\\", 2) = \\"0\\" >>> remove_k_digits(\\"7658\\", 2) = \\"58\\"","solution":"def remove_k_digits(num: str, k: int) -> str: Remove k digits from the num to get the smallest possible number. stack = [] for digit in num: while k > 0 and stack and stack[-1] > digit: stack.pop() k -= 1 stack.append(digit) # If k is still greater than 0, remove the last k elements final_stack = stack[:-k] if k else stack # Convert to string and strip leading zeros result = ''.join(final_stack).lstrip('0') # If result is empty, return '0' return result if result else '0'"},{"question":"def max_subset_sum(t, test_cases): Determine the maximum possible sum of any subset of size \`k\` such that the sum is less than or equal to a given threshold \`T\`. Parameters: t (int): The number of test cases. test_cases (list of tuples): Each tuple contains n (int), k (int), T (int), and a list of integers. Returns: list: A list of integers representing the maximum sum for each test case or -1 if no valid subset exists. Example: >>> max_subset_sum(3, [(5, 3, 15, [1, 2, 3, 4, 5]), (6, 2, 8, [8, 5, 3, 9, 2, 1]), (4, 4, 10, [3, 3, 3, 3])]) [12, 8, -1] def test_max_subset_sum(): t = 3 test_cases = [ (5, 3, 15, [1, 2, 3, 4, 5]), (6, 2, 8, [8, 5, 3, 9, 2, 1]), (4, 4, 10, [3, 3, 3, 3]) ] results = max_subset_sum(t, test_cases) assert results == [12, 8, -1] def test_all_elements_fit(): t = 1 test_cases = [ (4, 4, 10, [2, 2, 2, 3]) ] results = max_subset_sum(t, test_cases) assert results == [9] def test_no_valid_subset(): t = 1 test_cases = [ (4, 3, 5, [6, 7, 8, 9]) ] results = max_subset_sum(t, test_cases) assert results == [-1] def test_multiple_solutions(): t = 1 test_cases = [ (6, 3, 15, [9, 8, 7, 6, 5, 4]) ] results = max_subset_sum(t, test_cases) assert results == [15] def test_smallest_case(): t = 1 test_cases = [ (1, 1, 1, [1]) ] results = max_subset_sum(t, test_cases) assert results == [1]","solution":"def max_subset_sum(t, test_cases): results = [] for case in test_cases: n, k, T, arr = case arr.sort(reverse=True) max_sum = -1 current_sum = sum(arr[:k]) if current_sum <= T: max_sum = current_sum else: for i in range(k-1, n): if i > k-1: current_sum = current_sum - arr[i-k] + arr[i] if current_sum <= T: max_sum = max(max_sum, current_sum) results.append(max_sum) return results"},{"question":"def reverse_sentence(sentence: str) -> str: Reverses the order of the words in a given sentence. >>> reverse_sentence(\\"The quick brown fox jumps over the lazy dog\\") 'dog lazy the over jumps fox brown quick The' >>> reverse_sentence(\\"Hello World\\") 'World Hello' >>> reverse_sentence(\\"\\") ''","solution":"def reverse_sentence(sentence): Reverses the order of the words in a given sentence. Parameters: sentence (str): The sentence to reverse. Returns: str: The sentence with the order of the words reversed. words = sentence.split() reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"from typing import List def longest_coprime_subsequence(arr: List[int]) -> int: Returns the length of the longest subsequence where every two elements are coprime. >>> longest_coprime_subsequence([6, 10, 15, 21, 35, 22]) 3 >>> longest_coprime_subsequence([5]) 1 >>> longest_coprime_subsequence([5, 7, 11, 13]) 4 >>> longest_coprime_subsequence([4, 8, 16, 32]) 1 >>> longest_coprime_subsequence([3, 6, 7, 11]) 3 >>> longest_coprime_subsequence([2] * 50 + [3] * 50) 2","solution":"from math import gcd from functools import lru_cache def longest_coprime_subsequence(arr): Returns the length of the longest subsequence where every two elements are coprime. @lru_cache(None) def is_coprime(x, y): return gcd(x, y) == 1 n = len(arr) dp = [1] * n max_len = 1 for i in range(n): for j in range(i): if is_coprime(arr[i], arr[j]): dp[i] = max(dp[i], dp[j] + 1) max_len = max(max_len, dp[i]) return max_len"},{"question":"def check_bst(nodes_data: List[Tuple[int, int, int]]) -> str: Check if a given binary tree is a Binary Search Tree (BST). >>> check_bst([(10, -1, -1)]) == \\"YES\\" >>> check_bst([(10, -1, 1), (20, -1, -1)]) == \\"YES\\" >>> check_bst([(10, 1, -1), (5, -1, -1)]) == \\"YES\\" >>> check_bst([(10, 1, 2), (5, -1, -1), (20, -1, -1)]) == \\"YES\\" >>> check_bst([(10, 1, 2), (15, -1, -1), (20, -1, -1)]) == \\"NO\\" >>> check_bst([(10, 1, 2), (5, 3, 4), (20, -1, -1), (2, -1, -1), (6, -1, -1)]) == \\"YES\\" >>> check_bst([(10, 1, 2), (5, 3, 4), (20, -1, -1), (2, -1, -1), (12, -1, -1)]) == \\"NO\\" >>> check_bst([]) == \\"YES\\" Input: List of tuples where each tuple consists of three integers describing a node (value, left_child, right_child) Output: A string \\"YES\\" if the given binary tree is a BST, otherwise \\"NO\\".","solution":"class TreeNode: def __init__(self, value, left=-1, right=-1): self.value = value self.left = left self.right = right def is_bst_helper(tree, node_idx, min_val, max_val): if node_idx == -1: return True node = tree[node_idx] if not (min_val < node.value < max_val): return False return is_bst_helper(tree, node.left, min_val, node.value) and is_bst_helper(tree, node.right, node.value, max_val) def is_bst(tree): if not tree: return True return is_bst_helper(tree, 0, float('-inf'), float('inf')) def build_tree(node_data): tree = [] for value, left, right in node_data: tree.append(TreeNode(value, left, right)) return tree # Function to be called by the external user def check_bst(nodes_data): tree = build_tree(nodes_data) if is_bst(tree): return \\"YES\\" else: return \\"NO\\""},{"question":"def find_pairs_with_sum(arr, target): Given a list of integers and a target sum, find all unique pairs of integers from the list that add up to the target sum. Each pair should be sorted in ascending order and should not contain duplicates. :param arr: List of integers. :param target: The target sum. :return: A tuple containing the number of unique pairs and a list of tuples, with each tuple containing a pair of integers that sum up to the target. Examples: >>> find_pairs_with_sum([2, 3, 4, 2, 1, 5], 6) (2, [(1, 5), (2, 4)]) >>> find_pairs_with_sum([1, -2, 3, 0, -1], -1) (2, [(-2, 1), (-1, 0)]) >>> find_pairs_with_sum([1, 2, 3], 10) (0, []) >>> find_pairs_with_sum([1], 2) (0, []) >>> find_pairs_with_sum([1, 2, 2, 3, 3, 4], 5) (2, [(1, 4), (2, 3)]) >>> find_pairs_with_sum([2, 2, 2, 2], 4) (1, [(2, 2)]) >>> find_pairs_with_sum([-1, -2, -3, -4, 1, 2, 3, 4], 0) (4, [(-4, 4), (-3, 3), (-2, 2), (-1, 1)]) >>> find_pairs_with_sum([5, 5, 5, 5], 10) (1, [(5, 5)]) >>> find_pairs_with_sum([1000000, -1000000, 500000, -500000], 0) (2, [(-1000000, 1000000), (-500000, 500000)])","solution":"def find_pairs_with_sum(arr, target): Finds all unique pairs of integers in arr that sum up to target. :param arr: List of integers. :param target: The target sum. :return: List of tuples, with each tuple containing a pair of integers that sum up to target. seen = set() pairs = set() for num in arr: complement = target - num if complement in seen: pair = tuple(sorted((num, complement))) pairs.add(pair) seen.add(num) result = sorted(pairs) return len(result), result"},{"question":"def isIsomorphic(S: str, T: str) -> bool: Determine if two strings S and T are isomorphic. Args: S: str - First string T: str - Second string Returns: bool - True if the strings are isomorphic, False otherwise. >>> isIsomorphic(\\"egg\\", \\"add\\") True >>> isIsomorphic(\\"foo\\", \\"bar\\") False >>> isIsomorphic(\\"paper\\", \\"title\\") True >>> isIsomorphic(\\"abc\\", \\"def\\") True >>> isIsomorphic(\\"ab\\", \\"aa\\") False","solution":"def isIsomorphic(S, T): Determine if two strings S and T are isomorphic. Args: S: str - First string T: str - Second string Returns: bool - True if the strings are isomorphic, False otherwise. if len(S) != len(T): return False mapping_s_to_t = {} mapping_t_to_s = {} for char_s, char_t in zip(S, T): if (char_s in mapping_s_to_t and mapping_s_to_t[char_s] != char_t) or (char_t in mapping_t_to_s and mapping_t_to_s[char_t] != char_s): return False mapping_s_to_t[char_s] = char_t mapping_t_to_s[char_t] = char_s return True"},{"question":"from typing import List, Tuple def distinct_characters(s: str, queries: List[Tuple[int, int]]) -> List[int]: Return the number of distinct characters in the substring s[l:r+1] for each query. >>> distinct_characters(\\"abacaba\\", [(0, 3), (1, 4), (2, 5), (0, 6)]) [3, 3, 3, 3] >>> distinct_characters(\\"hello\\", [(0, 2), (1, 4), (0, 4), (4, 4)]) [3, 3, 4, 1] >>> distinct_characters(\\"world\\", [(0, 4), (1, 3), (2, 2), (3, 3)]) [5, 3, 1, 1] >>> distinct_characters(\\"\\", [(0, 2), (1, 4), (0, 4), (4, 4)]) [-1, -1, -1, -1] >>> distinct_characters(\\"test\\", [(1, 0), (-1, 2), (1, 5)]) [-1, -1, -1] >>> distinct_characters(\\"aaaaa\\", [(0, 4), (0, 0), (2, 4)]) [1, 1, 1]","solution":"from typing import List, Tuple def distinct_characters(s: str, queries: List[Tuple[int, int]]) -> List[int]: Return the number of distinct characters in the substring s[l:r+1] for each query. results = [] for l, r in queries: if not s or l < 0 or r >= len(s) or l > r: results.append(-1) else: substr = s[l:r+1] distinct_count = len(set(substr)) results.append(distinct_count) return results"},{"question":"def search(arr, target): Searches the target in a rotated sorted array and returns its index if exists, otherwise returns -1. Example 1: >>> search([4,5,6,7,0,1,2], 0) 4 Example 2: >>> search([4,5,6,7,0,1,2], 3) -1 Example 3: >>> search([1], 0) -1","solution":"def search(arr, target): Searches the target in a rotated sorted array and returns its index if exists, otherwise returns -1. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid # Check if the left half is sorted if arr[left] <= arr[mid]: # If target is in the left half if arr[left] <= target < arr[mid]: right = mid - 1 else: left = mid + 1 # Otherwise, the right half must be sorted else: # If target is in the right half if arr[mid] < target <= arr[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def maxLandmarks(prices: List[int], budget: int) -> int: Determines the maximum number of unique landmarks that can be visited without exceeding the budget. :param prices: List[int], list of landmark prices :param budget: int, available budget :return: int, maximum number of unique landmarks that can be visited >>> maxLandmarks([20, 10, 30, 50, 40], 70) 3 >>> maxLandmarks([5, 10, 15, 20, 25], 40) 3","solution":"def maxLandmarks(prices, budget): Determines the maximum number of unique landmarks that can be visited without exceeding the budget. :param prices: List[int], list of landmark prices :param budget: int, available budget :return: int, maximum number of unique landmarks that can be visited prices.sort() # Sort the prices in non-decreasing order count = 0 total_spent = 0 for price in prices: if total_spent + price <= budget: total_spent += price count += 1 else: break return count"},{"question":"def min_operations_to_subsequence(q: int, queries: List[Tuple[str, str]]) -> List[int]: Find the minimum number of operations required to make t a subsequence of s. Args: q : int : number of queries queries: List[Tuple[str, str]] : List of tuples containing strings s and t Returns: List[int] : List of integers representing the minimum number of operations for each query. If not possible, return -1. Examples: >>> min_operations_to_subsequence(3, [(\\"abc\\", \\"acd\\"), (\\"abbbc\\", \\"bbbbc\\"), (\\"xyz\\", \\"yz\\")]) [1, 0, 0] >>> min_operations_to_subsequence(3, [(\\"abc\\", \\"def\\"), (\\"abcd\\", \\"efgh\\"), (\\"x\\", \\"y\\")]) [3, 4, 1] import pytest def test_min_operations_example_cases(): queries = [(\\"abc\\", \\"acd\\"), (\\"abbbc\\", \\"bbbbc\\"), (\\"xyz\\", \\"yz\\")] assert min_operations_to_subsequence(3, queries) == [1, 0, 0] def test_min_operations_non_subsequence(): queries = [(\\"abc\\", \\"def\\"), (\\"abcd\\", \\"efgh\\"), (\\"x\\", \\"y\\")] assert min_operations_to_subsequence(3, queries) == [3, 4, 1] def test_min_operations_already_subsequence(): queries = [(\\"ab\\", \\"a\\"), (\\"abcde\\", \\"ace\\"), (\\"zxy\\", \\"xy\\")] assert min_operations_to_subsequence(3, queries) == [0, 0, 0] def test_min_operations_no_common_chars(): queries = [(\\"a\\", \\"b\\"), (\\"x\\", \\"y\\"), (\\"qwe\\", \\"rty\\")] assert min_operations_to_subsequence(3, queries) == [1, 1, 3] def test_min_operations_edge_cases(): queries = [(\\"a\\", \\"a\\"), (\\"z\\", \\"z\\"), (\\"\\", \\"\\"), (\\"a\\", \\"\\"), (\\"\\", \\"a\\")] assert min_operations_to_subsequence(5, queries) == [0, 0, 0, 0, 1] pytest.main()","solution":"def min_operations_to_subsequence(q, queries): results = [] for query in queries: s, t = query s_chars = set(s) t_chars = set(t) if not t_chars.issubset(s_chars): # Operation required for each character in t but not in s operations = 0 for c in t_chars: if c not in s_chars: operations += 1 results.append(operations) else: results.append(0) return results"},{"question":"def uniqueCharactersWithCount(s: str) -> dict: Returns a dictionary with characters as keys and their frequency counts as values. Ignore spaces. Case-insensitive. >>> uniqueCharactersWithCount(\\"Hello World\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> uniqueCharactersWithCount(\\"Candy Canes\\") {'c': 2, 'a': 2, 'n': 2, 'd': 1, 'y': 1, 'e': 1, 's': 1}","solution":"def uniqueCharactersWithCount(s): Returns a dictionary with characters as keys and their frequency counts as values. s = s.lower().replace(\\" \\", \\"\\") char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 return char_count"},{"question":"def maximize_sum(arr: List[int], k: int) -> List[int]: Modify the array such that the array consists of k distinct integers and the sum of the array is maximized. Parameters: arr (List[int]): The input array. k (int): The number of distinct integers to be in the output array. Returns: List[int]: The modified array with k distinct integers or an empty array if not possible. Examples: >>> maximize_sum([1, 2, 3, 4, 5], 3) [5, 4, 3] >>> maximize_sum([1, 1, 1, 1, 1], 2) [] >>> maximize_sum([4, 7, 1, 1, 3, 1, 1], 4) [7, 4, 3, 1]","solution":"def maximize_sum(arr, k): Modify the array such that the array consists of k distinct integers and the sum of the array is maximized. Parameters: arr (List[int]): The input array. k (int): The number of distinct integers to be in the output array. Returns: List[int]: The modified array with k distinct integers or an empty array if not possible. # Get the unique elements in the array unique_elements = list(set(arr)) # If we cannot construct an array with k distinct integers, return an empty array if len(unique_elements) < k: return [] # Sort the unique elements in descending order to maximize the sum unique_elements.sort(reverse=True) # Return the top k elements from the sorted unique elements return unique_elements[:k]"},{"question":"def max_sum_after_rotations(n: int, k: int, a: List[int]) -> int: Returns the maximum possible sum of the array after performing at most k right rotations. Args: n : int : the size of the array k : int : the maximum number of rotations allowed a : List[int] : the elements of the array Returns: int : the maximum possible sum of the array after at most k rotations Examples: >>> max_sum_after_rotations(5, 2, [1, 2, 3, 4, 5]) 15 >>> max_sum_after_rotations(4, 1, [6, -2, 3, -1]) 6","solution":"def max_sum_after_rotations(n, k, a): Returns the maximum possible sum of the array after performing at most k right rotations. Since the sum of all elements of the array remains unchanged, the result is simply the sum of the array \`a\`. return sum(a)"},{"question":"def longest_good_subsequence(s): Returns the length of the longest possible good subsequence of the given string s. A good subsequence is a sequence that does not contain two consecutive occurrences of the same letter. >>> longest_good_subsequence(\\"aabbcc\\") 3 >>> longest_good_subsequence(\\"abcabc\\") 6 >>> longest_good_subsequence(\\"abac\\") 4 def process_tests(test_cases): Process multiple test cases of finding the longest good subsequence. >>> process_tests([\\"aabbcc\\", \\"abcabc\\", \\"abac\\"]) [3, 6, 4]","solution":"def longest_good_subsequence(s): Returns the length of the longest possible good subsequence of the given string s. A good subsequence is a sequence that does not contain two consecutive occurrences of the same letter. if not s: return 0 n = len(s) # To store the length of the good subsequence max_length = 0 # Iterate through the string for i in range(n): # Check the first character or any character which is not same as previous if i == 0 or s[i] != s[i - 1]: max_length += 1 return max_length def process_tests(test_cases): Process multiple test cases of finding the longest good subsequence. results = [] for s in test_cases: results.append(longest_good_subsequence(s)) return results"},{"question":"def find_numbers(g: int, l: int) -> Tuple[int, int]: Returns two positive integers x and y such that GCD(x, y) = g and LCM(x, y) = l. If no such integers exist, returns -1. >>> find_numbers(3, 60) (3, 20) >>> find_numbers(5, 25) (5, 5) >>> find_numbers(2, 7) -1 >>> find_numbers(4, 16) (4, 4)","solution":"def find_numbers(g, l): Returns two positive integers x and y such that GCD(x, y) = g and LCM(x, y) = l. If no such integers exist, returns -1. if l % g != 0: return -1 y = l // g return g, y"},{"question":"def check_parentheses(expressions): Takes a list of expressions and checks if the parentheses are well-formed and properly nested. Returns a list of \\"YES\\" or \\"NO\\" for each expression. >>> check_parentheses([\\"(a+(b*c)-d)\\", \\"((a+b)*(c-d))\\", \\"(a*(b+c)\\"]) ['YES', 'YES', 'NO'] >>> check_parentheses([\\"(a+(b*c)-d\\", \\"((a+b)*(c-d))(\\", \\"(a*(b+c)\\"]) ['NO', 'NO', 'NO'] >>> check_parentheses([\\"\\", \\"a+b\\", \\" \\"]) ['YES', 'YES', 'YES'] >>> check_parentheses([\\"(a+(b*c)-d)\\", \\"((a+b)*(c-d)\\", \\"(a*(b+c)\\", \\"a+b)\\", \\"(a+b\\"]) ['YES', 'NO', 'NO', 'NO', 'NO'] >>> check_parentheses([\\"(((((a+b)))))\\", \\"((a+(b+c)+(d+e)))\\", \\"((a+b*(c/d))-((e+f))\\"]) ['YES', 'YES', 'NO']","solution":"def check_parentheses(expressions): Takes a list of expressions and checks if the parentheses are well-formed and properly nested. Returns a list of \\"YES\\" or \\"NO\\" for each expression. results = [] for expr in expressions: stack = [] well_formed = True for char in expr: if char == '(': stack.append(char) elif char == ')': if stack: stack.pop() else: well_formed = False break if well_formed and not stack: results.append(\\"YES\\") else: results.append(\\"NO\\") return results def read_input(): T = int(input().strip()) expressions = [input().strip() for _ in range(T)] return expressions"},{"question":"def can_form_palindrome(s: str) -> str: Determines if the string of numbers can be rearranged into a palindrome. Args: s (str): The string representing a long-integer number. Returns: str: \\"YES\\" if the number can be rearranged into a palindrome, otherwise \\"NO\\". Examples: >>> can_form_palindrome(\\"123321\\") 'YES' >>> can_form_palindrome(\\"12345\\") 'NO'","solution":"def can_form_palindrome(s): Determines if the string of numbers can be rearranged into a palindrome. # Create a frequency dictionary for characters freq = {} for char in s: if char not in freq: freq[char] = 0 freq[char] += 1 # Count the number of characters with odd frequencies odd_count = sum(1 for count in freq.values() if count % 2 != 0) # We can form a palindrome if the odd count is 0 or 1 return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"def max_distinct_integers(N: int, S: int, arr: List[int]) -> int: Finds the maximum number of distinct integers whose sum is less than or equal to S. Parameters: N (int): Total number of integers in the list. S (int): Target sum. arr (list): List of integers. Returns: int: Maximum number of distinct integers with sum <= S. pass # Example usage and test cases def test_sample_input(): assert max_distinct_integers(6, 15, [5, 2, 3, 8, 2, 3]) == 3 def test_no_elements_fit(): assert max_distinct_integers(5, 1, [2, 3, 4, 5, 6]) == 0 def test_all_elements_fit(): assert max_distinct_integers(5, 100, [1, 2, 3, 4, 5]) == 5 def test_some_elements_fit(): assert max_distinct_integers(5, 10, [5, 3, 7, 1, 4]) == 3 def test_large_input(): assert max_distinct_integers(10, 20, [5, 2, 12, 6, 2, 4, 8, 5, 3, 7]) == 5","solution":"def max_distinct_integers(N, S, arr): Finds the maximum number of distinct integers whose sum is less than or equal to S. Parameters: N (int): Total number of integers in the list. S (int): Target sum. arr (list): List of integers. Returns: int: Maximum number of distinct integers with sum <= S. # Get the unique elements and sort them unique_elements = sorted(set(arr)) current_sum = 0 count = 0 for num in unique_elements: if current_sum + num <= S: current_sum += num count += 1 else: break return count # Example usage N = 6 S = 15 arr = [5, 2, 3, 8, 2, 3] print(max_distinct_integers(N, S, arr)) # Output: 3"},{"question":"def min_operations_to_zero(n: int, a: List[int]) -> int: Given an array of size n of 0s and 1s, return the minimum number of operations required to make all the elements of the array 0. >>> min_operations_to_zero(5, [1, 1, 0, 1, 1]) 2 >>> min_operations_to_zero(6, [1, 1, 1, 0, 0, 1]) 2 >>> min_operations_to_zero(3, [0, 0, 0]) 0 pass","solution":"def min_operations_to_zero(n, a): Given an array of size n of 0s and 1s, return the minimum number of operations required to make all the elements of the array 0. if all(x == 0 for x in a): return 0 count_ones_segment = 0 in_segment = False for x in a: if x == 1 and not in_segment: count_ones_segment += 1 in_segment = True elif x == 0: in_segment = False return count_ones_segment"},{"question":"def max_grains(N: int, grains: List[int]) -> int: Determine the maximum amount of grains the thief can steal without robbing two adjacent houses on the same night. >>> max_grains(4, [1, 2, 3, 1]) 4 >>> max_grains(0, []) 0 >>> max_grains(5, [2, 7, 9, 3, 1]) 12 >>> max_grains(6, [5, 5, 10, 100, 10, 5]) 110 >>> max_grains(5, [100, 200, 300, 400, 500]) 900 >>> max_grains(8, [3, 2, 5, 10, 7, 12, 10, 5]) 30 >>> max_grains(4, [0, 0, 0, 0]) 0 >>> max_grains(5, [0, 10, 0, 10, 0]) 20","solution":"def max_grains(N, grains): # Base cases if N == 0: return 0 if N == 1: return grains[0] # dp array to store the maximum grains which can be stolen upto the current house dp = [0] * N dp[0] = grains[0] dp[1] = max(grains[0], grains[1]) # Fill the dp array for all houses for i in range(2, N): dp[i] = max(dp[i-1], grains[i] + dp[i-2]) return dp[N-1]"},{"question":"def final_position(matrix, directions): Returns the final position in the matrix after performing all the movements. >>> final_position([[0, 0, 0], [0, 0, 0], [0, 0, 0]], [\\"down\\", \\"down\\", \\"right\\", \\"up\\", \\"left\\", \\"left\\"]) (1, 0) >>> final_position([[0, 0], [0, 0]], [\\"left\\", \\"up\\"]) (0, 0) >>> final_position([[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]], [\\"down\\", \\"down\\", \\"down\\", \\"right\\", \\"right\\", \\"up\\", \\"up\\", \\"left\\", \\"left\\"]) (1, 0) >>> final_position([[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]], [\\"right\\", \\"right\\", \\"right\\", \\"right\\", \\"down\\", \\"down\\", \\"down\\", \\"down\\"]) (3, 3)","solution":"def final_position(matrix, directions): Returns the final position in the matrix after performing all the movements. # Get the dimensions of the matrix m, n = len(matrix), len(matrix[0]) # Starting at the top-left corner x, y = 0, 0 # Define the movement deltas move = { \\"up\\": (-1, 0), \\"down\\": (1, 0), \\"left\\": (0, -1), \\"right\\": (0, 1) } # Perform each movement for direction in directions: dx, dy = move[direction] new_x, new_y = x + dx, y + dy # Check the new position is within bounds if 0 <= new_x < m and 0 <= new_y < n: x, y = new_x, new_y return (x, y)"},{"question":"def optimal_meeting_point(n: int, coordinates: List[Tuple[int, int]]) -> Tuple[int, int]: Determine the meeting point coordinates that will minimize the total travel distance. :param n: Number of friends (integer) :param coordinates: List of tuples, where each tuple contains the (x, y) coordinate of a friend. :return: Tuple (x, y) representing the optimal meeting point coordinates. >>> optimal_meeting_point(1, [(1, 2)]) (1, 2) >>> optimal_meeting_point(4, [(1, 2), (3, 4), (5, 6), (7, 8)]) (5, 6) >>> optimal_meeting_point(5, [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]) (3, 3) >>> optimal_meeting_point(3, [(1000000000, 1000000000), (0, 0), (500000000, 500000000)]) (500000000, 500000000) >>> optimal_meeting_point(3, [(0, 0), (0, 0), (0, 0)]) (0, 0)","solution":"def optimal_meeting_point(n, coordinates): Determine the meeting point coordinates that will minimize the total travel distance. :param n: Number of friends (integer) :param coordinates: List of tuples, where each tuple contains the (x, y) coordinate of a friend. :return: Tuple (x, y) representing the optimal meeting point coordinates. x_coords = sorted(coord[0] for coord in coordinates) y_coords = sorted(coord[1] for coord in coordinates) median_x = x_coords[n // 2] median_y = y_coords[n // 2] return (median_x, median_y)"},{"question":"def countPalindromicSubstrings(s: str) -> int: Given a string of lowercase alphabets, find the count of all possible substrings of the string which are palindromic. Args: s (str): the input string. Returns: int: the count of palindromic substrings. Examples: >>> countPalindromicSubstrings(\\"ababa\\") 9 >>> countPalindromicSubstrings(\\"abc\\") 3","solution":"def countPalindromicSubstrings(s): n = len(s) count = 0 def is_palindrome(sub): return sub == sub[::-1] for i in range(n): for j in range(i, n): if is_palindrome(s[i:j+1]): count += 1 return count"},{"question":"def roman_to_int(s: str) -> int: Convert a string containing a Roman numeral to its integer equivalent. >>> roman_to_int('III') 3 >>> roman_to_int('IV') 4 >>> roman_to_int('IX') 9 >>> roman_to_int('LVIII') 58 >>> roman_to_int('MCMXCIV') 1994","solution":"def roman_to_int(s): Convert a string containing a Roman numeral to its integer equivalent. roman_values = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for char in reversed(s): value = roman_values[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"def is_permutation_of_palindrome(s: str) -> str: Checks if the given string is a permutation of a palindrome. Args: s (str): input string containing only lowercase alphabets. Returns: str: \\"YES\\" if the string is a permutation of a palindrome, otherwise \\"NO\\". Examples: >>> is_permutation_of_palindrome(\\"civic\\") \\"YES\\" >>> is_permutation_of_palindrome(\\"ivicc\\") \\"YES\\" >>> is_permutation_of_palindrome(\\"hello\\") \\"NO\\"","solution":"def is_permutation_of_palindrome(s): Checks if the given string is a permutation of a palindrome. Args: s (str): input string containing only lowercase alphabets. Returns: str: \\"YES\\" if the string is a permutation of a palindrome, otherwise \\"NO\\". from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in freq.values() if count % 2 != 0) # A string can be rearranged into a palindrome if there is at most one character with an odd count return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"def longest_common_substring(a: str, b: str) -> int: Finds the length of the longest common substring between two strings, a and b. :param a: first string :param b: second string :return: length of longest common substring len_a, len_b = len(a), len(b) dp = [[0] * (len_b + 1) for _ in range(len_a + 1)] max_len = 0 for i in range(1, len_a + 1): for j in range(1, len_b + 1): if a[i-1] == b[j-1]: dp[i][j] = dp[i-1][j-1] + 1 max_len = max(max_len, dp[i][j]) return max_len def solve_cases(test_cases: List[Tuple[str, str]]) -> List[int]: results = [] for a, b in test_cases: results.append(longest_common_substring(a, b)) return results","solution":"def longest_common_substring(a, b): Finds the length of the longest common substring between two strings, a and b. :param a: first string :param b: second string :return: length of longest common substring len_a, len_b = len(a), len(b) dp = [[0] * (len_b + 1) for _ in range(len_a + 1)] max_len = 0 for i in range(1, len_a + 1): for j in range(1, len_b + 1): if a[i-1] == b[j-1]: dp[i][j] = dp[i-1][j-1] + 1 max_len = max(max_len, dp[i][j]) return max_len def solve_cases(test_cases): results = [] for a, b in test_cases: results.append(longest_common_substring(a, b)) return results"},{"question":"def pair_participants(n: int, scores: List[int]) -> List[Tuple[int, int]]: Given the scores of the participants, this function determines the pairs of participants such that the sum of differences of their scores is minimized. Parameters: n (int): Number of participants (always even). scores (List[int]): List of scores of the participants. Returns: List[Tuple[int, int]]: List of pairs with minimal score differences. >>> pair_participants(4, [3, 1, 2, 4]) [(1, 2), (3, 4)] >>> pair_participants(6, [20, 5, 10, 15, 30, 25]) [(5, 10), (15, 20), (25, 30)]","solution":"def pair_participants(n, scores): Given the scores of the participants, this function determines the pairs of participants such that the sum of differences of their scores is minimized. Parameters: n (int): Number of participants (always even). scores (List[int]): List of scores of the participants. Returns: List[Tuple[int, int]]: List of pairs with minimal score differences. scores.sort() pairs = [] for i in range(0, n, 2): pairs.append((scores[i], scores[i+1])) return pairs"},{"question":"from typing import List, Tuple def min_toll_fees(n: int, edges: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Compute the minimum toll fee for each query regarding the travel from city a to city b. Args: n (int): the number of cities. edges (List[Tuple[int, int, int]]): list of tuples, each containing three integers u, v, and w representing a road between city u and city v with a toll fee of w. queries (List[Tuple[int, int]]): list of tuples, each containing two integers a and b representing a query to find the minimum toll fee from city a to city b. Returns: List[int]: list of integers, each representing the minimum toll fee for the corresponding query. Example: >>> n = 5 >>> edges = [(1, 2, 3), (1, 3, 4), (2, 4, 5), (2, 5, 6)] >>> queries = [(1, 4), (4, 5), (3, 5)] >>> min_toll_fees(n, edges, queries) [8, 11, 13] pass if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() idx = 0 n = int(data[idx]) idx += 1 edges = [] for _ in range(n-1): u = int(data[idx]) v = int(data[idx+1]) w = int(data[idx+2]) edges.append((u, v, w)) idx += 3 q = int(data[idx]) idx += 1 queries = [] for _ in range(q): a = int(data[idx]) b = int(data[idx+1]) queries.append((a, b)) idx += 2 result = min_toll_fees(n, edges, queries) for res in result: print(res)","solution":"import sys from collections import defaultdict import heapq def create_graph(n, edges): graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) return graph def dijkstra(graph, start, end): heap = [(0, start)] visited = set() min_cost = {start: 0} while heap: current_cost, current_node = heapq.heappop(heap) if current_node in visited: continue visited.add(current_node) if current_node == end: return current_cost for neighbor, weight in graph[current_node]: if neighbor in visited: continue new_cost = current_cost + weight if new_cost < min_cost.get(neighbor, float(\\"inf\\")): min_cost[neighbor] = new_cost heapq.heappush(heap, (new_cost, neighbor)) return float(\\"inf\\") def min_toll_fees(n, edges, queries): graph = create_graph(n, edges) results = [] for a, b in queries: min_fee = dijkstra(graph, a, b) results.append(min_fee) return results"},{"question":"def reverse_words_characters(sentence: str) -> str: Reverses each word in a sentence while preserving the original word order. Parameters: sentence (str): A string representing the sentence. Returns: str: A string with each word reversed but in the original order. Examples: >>> reverse_words_characters('hello world') 'olleh dlrow' >>> reverse_words_characters('I love programming') 'I evol gnimmargorp' >>> reverse_words_characters('a quick brown fox') 'a kciuq nworb xof' >>> reverse_words_characters('Python') 'nohtyP' >>> reverse_words_characters(' hello world ') 'olleh dlrow' >>> reverse_words_characters('') ''","solution":"def reverse_words_characters(sentence): Reverses each word in a sentence while preserving the original word order. Parameters: sentence (str): A string representing the sentence. Returns: str: A string with each word reversed but in the original order. # Split the sentence into words words = sentence.split() # Reverse each word and join them back with spaces reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words)"},{"question":"from typing import List def shortest_cycle(N: int, M: int, edges: List[List[int]]) -> int: Given an undirected graph with N vertices and M edges, find the length of the shortest cycle in the graph. If no cycle exists, return -1. >>> shortest_cycle(4, 4, [[0, 1], [1, 2], [2, 0], [2, 3]]) 3 >>> shortest_cycle(3, 2, [[0, 1], [1, 2]]) -1 from collections import deque, defaultdict def test_example1(): assert shortest_cycle(4, 4, [[0, 1], [1, 2], [2, 0], [2, 3]]) == 3 def test_example2(): assert shortest_cycle(3, 2, [[0, 1], [1, 2]]) == -1 def test_single_node_no_edge(): assert shortest_cycle(1, 0, []) == -1 def test_two_nodes_one_edge(): assert shortest_cycle(2, 1, [[0, 1]]) == -1 def test_three_nodes_cycle(): assert shortest_cycle(3, 3, [[0, 1], [1, 2], [2, 0]]) == 3 def test_four_nodes_no_cycle(): assert shortest_cycle(4, 3, [[0, 1], [1, 2], [2, 3]]) == -1 def test_complex_graph(): assert shortest_cycle(5, 6, [[0, 1], [1, 2], [2, 3], [3, 0], [3, 4], [4, 0]]) == 3 def test_separated_cycles(): assert shortest_cycle(6, 7, [[0, 1], [1, 2], [2, 0], [3, 4], [4, 5], [5, 3], [2, 3]]) == 3","solution":"from collections import deque, defaultdict def shortest_cycle(N, M, edges): def bfs(start): dist = {v: N + 1 for v in range(N)} parent = {v: -1 for v in range(N)} q = deque([start]) dist[start] = 0 while q: node = q.popleft() for neighbor in graph[node]: if dist[neighbor] == N + 1: dist[neighbor] = dist[node] + 1 parent[neighbor] = node q.append(neighbor) elif parent[node] != neighbor: return dist[node] + dist[neighbor] + 1 return float('inf') graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) shortest = float('inf') for i in range(N): shortest = min(shortest, bfs(i)) return shortest if shortest != float('inf') else -1"},{"question":"def min_operations_to_equal_health_indices(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Returns the minimum number of operations needed to make all health indices equal for each test case. Parameters: - t: integer, number of test cases (1 <= t <= 20000) - test_cases: list of tuples, each containing: - n: integer, number of plants (1 <= n <= 200000) - health_indices: list of integers, health indices of the plants (-10^9 <= a_i <= 10^9) Returns: - List of integers representing minimum number of operations for each test case. Examples: >>> min_operations_to_equal_health_indices(3, [(3, [4, 4, 4]), (4, [1, 2, 3, 4]), (5, [10, 10, 10, 10, 10])]) [0, 3, 0] >>> min_operations_to_equal_health_indices(1, [(5, [3, 3, 3, 3, 1])]) [1]","solution":"def min_operations_to_equal_health_indices(t, test_cases): Returns the minimum number of operations needed to make all health indices equal for each test case. Parameters: - t: number of test cases - test_cases: list of tuples, each containing (n, health_indices) Returns: - List of integers representing minimum number of operations for each test case. results = [] for n, health_indices in test_cases: max_occurrences = max([health_indices.count(x) for x in set(health_indices)]) # Minimum operations needed: total number of plants - maximum occurrences of any single value min_operations = n - max_occurrences results.append(min_operations) return results"},{"question":"def hollow_square(n: int) -> str: Generate a hollow square with a '+' border and space inside for given integer \`n\`. The minimum possible value for \`n\` is 2. >>> hollow_square(2) '++n++' >>> hollow_square(3) '+++n+ +n+++' >>> hollow_square(4) '++++n+ +n+ +n++++' >>> hollow_square(5) '+++++n+ +n+ +n+ +n+++++' >>> hollow_square(10) '++++++++++n+ +n+ +n+ +n+ +n+ +n+ +n+ +n+ +n++++++++++'","solution":"def hollow_square(n): Returns a string representation of a hollow square with a '+' border and space inside for given integer n. if n < 2: raise ValueError(\\"n should be at least 2\\") top_bottom_row = '+' * n middle_row = '+' + ' ' * (n - 2) + '+' if n > 2 else '+' * n hollow_square = [top_bottom_row] for _ in range(n - 2): hollow_square.append(middle_row) if n > 1: hollow_square.append(top_bottom_row) return 'n'.join(hollow_square)"},{"question":"from typing import List, Tuple def is_palindrome(s: str, l: int, r: int) -> bool: Checks if the substring s[l-1:r] is a palindrome. Args: s (str): a string l (int): the starting index (1-indexed) r (int): the ending index (1-indexed) Returns: bool: True if the substring is a palindrome, else False >>> is_palindrome(\\"abccba\\", 1, 6) True >>> is_palindrome(\\"abccbaedca\\", 1, 10) False >>> is_palindrome(\\"abc\\", 1, 1) True def process_queries(n: int, q: int, s: str, queries: List[Tuple[int, int]]) -> List[str]: Processes each query to check if the substring is a palindrome. Args: n (int): length of string s q (int): number of queries s (str): a string of length n queries (List[Tuple[int, int]]): list of queries with each query being a tuple (l, r) Returns: List[str]: List of \\"Yes\\" or \\"No\\" for each query >>> process_queries(10, 3, \\"abccbaedca\\", [(1, 6), (2, 9), (1, 10)]) ['Yes', 'No', 'No'] >>> process_queries(5, 2, \\"level\\", [(1, 5), (2, 4)]) ['Yes', 'Yes'] >>> process_queries(6, 3, \\"abcdef\\", [(1, 1), (1, 6), (2, 5)]) ['Yes', 'No', 'No']","solution":"def is_palindrome(s, l, r): Checks if the substring s[l-1:r] is a palindrome. substring = s[l-1:r] return substring == substring[::-1] def process_queries(n, q, s, queries): Processes each query to check if the substring is a palindrome. results = [] for query in queries: l, r = query if is_palindrome(s, l, r): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def game_result(t, test_cases): Determine the result of the game played on an n x n grid for multiple test cases. Parameters: t (int): The number of test cases. test_cases (List[Tuple[int, List[str]]]): A list of tuples, where each tuple contains an integer n and a list of n strings representing the grid. Returns: List[str]: A list of results for each test case. Each result is \\"A\\" if Player A wins, \\"B\\" if Player B wins, \\"Draw\\" if the game ends in a draw, and \\"Pending\\" if the game is still ongoing. >>> game_result(3, [(3, ['A.A', 'BBB', '...']), (3, ['A..', 'ABA', 'A.B']), (3, ['...', '.A.', '...'])]) ['B', 'A', 'Pending'] >>> game_result(1, [(3, ['AAB', 'BBA', 'ABA'])]) ['Draw'] >>> game_result(1, [(3, ['A..', '.B.', '..A'])]) ['Pending'] >>> game_result(1, [(3, ['AAA', '...', '...'])]) ['A'] >>> game_result(1, [(3, ['A..', 'A..', 'A..'])]) ['A'] >>> game_result(1, [(3, ['A..', '.A.', '..A'])]) ['A'] >>> game_result(1, [(3, ['..B', '.B.', 'B..'])]) ['B'] # Implement the function to determine game result here","solution":"def check_winner(grid, n): # Check rows and columns for i in range(n): if all(grid[i][j] == 'A' for j in range(n)) or all(grid[j][i] == 'A' for j in range(n)): return 'A' if all(grid[i][j] == 'B' for j in range(n)) or all(grid[j][i] == 'B' for j in range(n)): return 'B' # Check main diagonal if all(grid[i][i] == 'A' for i in range(n)): return 'A' if all(grid[i][i] == 'B' for i in range(n)): return 'B' # Check anti-diagonal if all(grid[i][n-i-1] == 'A' for i in range(n)): return 'A' if all(grid[i][n-i-1] == 'B' for i in range(n)): return 'B' # Check for draw or pending if all(grid[i][j] in ['A', 'B'] for i in range(n) for j in range(n)): return 'Draw' return 'Pending' def game_result(t, test_cases): results = [] for case in test_cases: n, grid = case result = check_winner(grid, n) results.append(result) return results"},{"question":"import re def is_palindrome(s: str) -> bool: Determines if the given string is a palindrome, ignoring spaces, punctuation, and capitalization. Args: s (str): The input string to check. Returns: bool: True if the string is a palindrome, False otherwise. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"No 'x' in Nixon\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"MadAm\\") True >>> is_palindrome(\\"Able was I, I saw eLba\\") True >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"!!!\\") True >>> is_palindrome(\\"12 21\\") True","solution":"import re def is_palindrome(s): Determines if the given string is a palindrome, ignoring spaces, punctuation, and capitalization. Args: s (str): The input string to check. Returns: bool: True if the string is a palindrome, False otherwise. # Remove non-alphanumeric characters and convert to lowercase cleaned_s = re.sub(r'[^a-zA-Z0-9]', '', s).lower() # Check if the cleaned string is equal to its reverse return cleaned_s == cleaned_s[::-1]"},{"question":"def longest_equal_positive_negative_subarray(arr: List[int]) -> int: Returns the length of the longest subarray with equal numbers of positive and negative integers. >>> longest_equal_positive_negative_subarray([1, -1, 2, -2, 3]) 4 >>> longest_equal_positive_negative_subarray([1, 2, -1, -2, 3, -3]) 6 >>> longest_equal_positive_negative_subarray([1, -1, 1]) 2 >>> longest_equal_positive_negative_subarray([-1, -1, 1, 1]) 4 >>> longest_equal_positive_negative_subarray([1, -1, 1, -1, 1, -1, 1]) 6 def process_test_cases(test_cases: List[Dict[str, Union[int, List[int]]]]) -> List[int]: Processes the list of test cases and returns the results for each test case. >>> process_test_cases([{\\"N\\": 5, \\"array\\": [1, -1, 2, -2, 3]}, {\\"N\\": 6, \\"array\\": [1, 2, -1, -2, 3, -3]}]) [4, 6] >>> process_test_cases([{\\"N\\": 3, \\"array\\": [1, -1, 1]}, {\\"N\\": 4, \\"array\\": [-1, -1, 1, 1]}]) [2, 4] >>> process_test_cases([{\\"N\\": 7, \\"array\\": [1, -1, 1, -1, 1, -1, 1]}]) [6]","solution":"def longest_equal_positive_negative_subarray(arr): Returns the length of the longest subarray with equal numbers of positive and negative integers. sum_to_index = {0: -1} prefix_sum = 0 max_length = 0 for i, num in enumerate(arr): if num > 0: prefix_sum += 1 elif num < 0: prefix_sum -= 1 if prefix_sum in sum_to_index: max_length = max(max_length, i - sum_to_index[prefix_sum]) else: sum_to_index[prefix_sum] = i return max_length def process_test_cases(test_cases): results = [] for case in test_cases: N = case['N'] arr = case['array'] results.append(longest_equal_positive_negative_subarray(arr)) return results"},{"question":"def longestValidParentheses(s: str) -> int: Determine the length of the longest valid (well-formed) parentheses substring. >>> longestValidParentheses(\\"(()\\") 2 >>> longestValidParentheses(\\")()())\\") 4 >>> longestValidParentheses(\\"\\") 0","solution":"def longestValidParentheses(s: str) -> int: stack = [-1] max_length = 0 for i, char in enumerate(s): if char == '(': stack.append(i) else: stack.pop() if not stack: stack.append(i) else: max_length = max(max_length, i - stack[-1]) return max_length"},{"question":"def partial_sort(arr, l, r): Sorts the sub-array of arr from index l-1 to r-1 (inclusive) while keeping the rest of the array unchanged. Parameters: arr (list of int): List of integers to be partially sorted. l (int): 1-based starting index of the sub-array. r (int): 1-based ending index of the sub-array. Returns: list of int: The partially sorted array. Examples: >>> partial_sort([3, 1, 4, 1, 5], 2, 4) [3, 1, 1, 4, 5] >>> partial_sort([10, -3, 5, 7, -2, 8], 3, 6) [10, -3, -2, 5, 7, 8]","solution":"def partial_sort(arr, l, r): Sorts the sub-array of arr from index l-1 to r-1 (inclusive) while keeping the rest of the array unchanged. Parameters: arr (list of int): List of integers to be partially sorted. l (int): 1-based starting index of the sub-array. r (int): 1-based ending index of the sub-array. Returns: list of int: The partially sorted array. # Convert l and r to 0-based indices l -= 1 r -= 1 # Extract the sub-array, sort it, and place it back in the original array sub_array = arr[l:r+1] sub_array.sort() # Modify the original array arr[l:r+1] = sub_array return arr"},{"question":"def contest_identifier(M: int) -> str: Returns the identifier for the M-th contest of CodeKing. Parameters: - M: An integer representing the contest number (1  M  9999) Returns: - A string representing the contest identifier. Example: >>> contest_identifier(1) 'CK0001' >>> contest_identifier(100) 'CK0100'","solution":"def contest_identifier(M): Returns the identifier for the M-th contest of CodeKing. Parameters: - M: An integer representing the contest number (1  M  9999) Returns: - A string representing the contest identifier. return f\\"CK{M:04d}\\""},{"question":"def max_overlap(intervals): Returns the maximum number of overlapping intervals at any point on the number line. Args: intervals (List[Tuple[int, int]]): List of intervals represented as tuples (start, end) inclusive. Returns: int: The maximum number of overlapping intervals at any point. Examples: >>> max_overlap([(1, 4), (2, 5), (9, 12), (5, 9), (5, 12)]) 3 >>> max_overlap([(1, 3), (4, 5), (6, 7)]) 1 >>> max_overlap([(1, 10), (2, 9), (3, 8), (4, 7)]) 4 >>> max_overlap([(1, 2)]) 1 >>> max_overlap([(1, 5), (2, 6), (5, 10), (7, 9), (8, 11)]) 3","solution":"def max_overlap(intervals): Returns the maximum number of overlapping intervals at any point on the number line. events = [] # Split each interval into start and end events for start, end in intervals: events.append((start, 1)) # +1 for start of interval events.append((end + 1, -1)) # -1 for end of interval, end + 1 to make it inclusive end # Sort events, starting events come before ending events if they are at the same position events.sort() max_overlap = 0 current_overlap = 0 # Sweep through events and calculate the maximum overlap for event in events: current_overlap += event[1] if current_overlap > max_overlap: max_overlap = current_overlap return max_overlap"},{"question":"def findLongestContiguousSubarray(arr: List[int], N: int) -> int: Finds the length of the longest subarray which forms a contiguous segment of integers when sorted. The elements in the subarray must be distinct. :param arr: A list of integers :param N: Size of the list :return: Length of the longest subarray forming a contiguous segment >>> findLongestContiguousSubarray([10, 12, 11, 14, 13, 15], 6) == 6 >>> findLongestContiguousSubarray([1, 2, 3, 5, 6], 5) == 3","solution":"def findLongestContiguousSubarray(arr, N): Finds the length of the longest subarray which forms a contiguous segment of integers when sorted. The elements in the subarray must be distinct. :param arr: A list of integers :param N: Size of the list :return: Length of the longest subarray forming a contiguous segment max_len = 0 for i in range(N): # Create a set to store elements of the current subarray seen = set() min_val = float('inf') max_val = float('-inf') for j in range(i, N): if arr[j] in seen: break seen.add(arr[j]) min_val = min(min_val, arr[j]) max_val = max(max_val, arr[j]) if max_val - min_val == j - i: max_len = max(max_len, j - i + 1) return max_len"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(adjacency_list): if not adjacency_list: return None nodes = {} for val, left, right in adjacency_list: if val not in nodes: nodes[val] = TreeNode(val) if left != 0: if left not in nodes: nodes[left] = TreeNode(left) nodes[val].left = nodes[left] if right != 0: if right not in nodes: nodes[right] = TreeNode(right) nodes[val].right = nodes[right] return nodes[adjacency_list[0][0]] def tree_to_adjacency_list(root): result = [] def traverse(node): if not node: return left_val = node.left.val if node.left else 0 right_val = node.right.val if node.right else 0 result.append((node.val, left_val, right_val)) traverse(node.left) traverse(node.right) traverse(root) return result def update_subtree_sum(node): if node is None: return 0 left_sum = update_subtree_sum(node.left) right_sum = update_subtree_sum(node.right) node.val += left_sum + right_sum return node.val def rearrange_tree(adjacency_list): Rearrange the tree such that each node contains the sum of its original value and the original values of all its descendant nodes. >>> rearrange_tree([(5, 2, 3), (2, 0, 0), (3, 4, 0), (4, 0, 0)]) [(14, 6, 7), (6, 0, 0), (7, 4, 0), (4, 0, 0)] >>> rearrange_tree([(1, 0, 0)]) [(1, 0, 0)] >>> rearrange_tree([]) [] >>> rearrange_tree([(1, 2, 0), (2, 3, 0), (3, 4, 0), (4, 0, 0)]) [(10, 9, 0), (9, 7, 0), (7, 4, 0), (4, 0, 0)] >>> rearrange_tree([(1, 0, 2), (2, 0, 3), (3, 0, 4), (4, 0, 0)]) [(10, 0, 9), (9, 0, 7), (7, 0, 4), (4, 0, 0)]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(adjacency_list): if not adjacency_list: return None nodes = {} for val, left, right in adjacency_list: if val not in nodes: nodes[val] = TreeNode(val) if left != 0: if left not in nodes: nodes[left] = TreeNode(left) nodes[val].left = nodes[left] if right != 0: if right not in nodes: nodes[right] = TreeNode(right) nodes[val].right = nodes[right] return nodes[adjacency_list[0][0]] def tree_to_adjacency_list(root): result = [] def traverse(node): if not node: return left_val = node.left.val if node.left else 0 right_val = node.right.val if node.right else 0 result.append((node.val, left_val, right_val)) traverse(node.left) traverse(node.right) traverse(root) return result def update_subtree_sum(node): if node is None: return 0 left_sum = update_subtree_sum(node.left) right_sum = update_subtree_sum(node.right) node.val += left_sum + right_sum return node.val def rearrange_tree(adjacency_list): root = build_tree(adjacency_list) update_subtree_sum(root) return tree_to_adjacency_list(root)"},{"question":"from math import factorial from typing import List def good_sequences_count(n: int, elements: List[int]) -> int: Given a list of non-negative integers, count the number of good sequences that can be formed by permuting the list. A good sequence is defined as a sequence where elements are in non-decreasing order. Parameters: n (int): The number of elements in the list. elements (List[int]): List of n non-negative integers. Returns: int: The number of good sequences. >>> good_sequences_count(3, [1, 2, 3]) 6 >>> good_sequences_count(4, [0, 1, 1, 0]) 6","solution":"from math import factorial from collections import Counter def good_sequences_count(n, elements): Given a list of non-negative integers, count the number of good sequences that can be formed by permuting the list. A good sequence is defined as a sequence where elements are in non-decreasing order. Parameters: n (int): The number of elements in the list. elements (List[int]): List of n non-negative integers. Returns: int: The number of good sequences. if n == 0: return 0 cnt = Counter(elements) result = factorial(n) for count in cnt.values(): result //= factorial(count) return result"},{"question":"def longest_palindrome_length(n: int, chars: List[str]) -> int: Given a set of distinct lowercase English letters, determine the length of the longest palindrome that can be formed using some or all of the given characters. Parameters: n (int): The number of distinct characters. chars (list): A list of distinct lowercase English characters. Returns: int: The length of the longest palindrome that can be formed. >>> longest_palindrome_length(3, ['a', 'b', 'c']) 1 >>> longest_palindrome_length(4, ['m', 'a', 'd', 'a']) 3 >>> longest_palindrome_length(5, ['f', 'r', 'a', 'c', 'k']) 1 >>> longest_palindrome_length(2, ['b', 'c']) 1 >>> longest_palindrome_length(26, list('abcdefghijklmnopqrstuvwxyz')) 1 pass","solution":"def longest_palindrome_length(n, chars): Given a set of distinct lowercase English letters, determine the length of the longest palindrome that can be formed using some or all of the given characters. Parameters: n (int): The number of distinct characters. chars (list): A list of distinct lowercase English characters. Returns: int: The length of the longest palindrome that can be formed. # Since the characters are distinct, only one character can be in the center of palindrome # if we have more than one character return min(n, 1 if n > 0 else 0)"},{"question":"def length_of_longest_unique_subarray(arr): Returns the length of the longest subarray with unique elements. Args: arr (List[int]): A list of integers Returns: int: Length of the longest subarray with unique elements >>> length_of_longest_unique_subarray([1, 2, 1, 3, 4]) 4 >>> length_of_longest_unique_subarray([1, 2, 3, 4, 5, 6]) 6 pass def process_test_cases(t, test_cases): Processes multiple test cases for finding the longest subarray with unique elements. Args: t (int): Number of test cases test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains an integer n and a list of n integers Returns: List[int]: A list of results for each test case >>> process_test_cases(2, [(5, [1, 2, 1, 3, 4]), (6, [1, 2, 3, 4, 5, 6])]) [4, 6] >>> process_test_cases(1, [(4, [1, 1, 1, 1])]) [1] pass","solution":"def length_of_longest_unique_subarray(arr): Returns the length of the longest subarray with unique elements. n = len(arr) max_length = 0 start = 0 seen = {} for i in range(n): if arr[i] in seen and seen[arr[i]] >= start: start = seen[arr[i]] + 1 seen[arr[i]] = i max_length = max(max_length, i - start + 1) return max_length def process_test_cases(t, test_cases): results = [] for i in range(t): n, arr = test_cases[i] results.append(length_of_longest_unique_subarray(arr)) return results"},{"question":"def parse_query_string(query_string): Parses a URL query string into a dictionary where each key is a parameter name and the value is its corresponding value. If a parameter appears multiple times, its values are stored in a list. :param query_string: The URL query string :return: A dictionary representing the parsed query string >>> parse_query_string('') == {} >>> parse_query_string('name=John') == {'name': 'John'} >>> parse_query_string('name=John&age=30') == {'name': 'John', 'age': '30'} >>> parse_query_string('name=John&age=30&name=Jane') == {'name': ['John', 'Jane'], 'age': '30'} >>> parse_query_string('key=value1&key=value2&key=value3') == {'key': ['value1', 'value2', 'value3']}","solution":"def parse_query_string(query_string): Parses a URL query string into a dictionary where each key is a parameter name and the value is its corresponding value. If a parameter appears multiple times, its values are stored in a list. :param query_string: The URL query string :return: A dictionary representing the parsed query string if not query_string: return {} query_params = query_string.split('&') result = {} for param in query_params: key, value = param.split('=') if key in result: if isinstance(result[key], list): result[key].append(value) else: result[key] = [result[key], value] else: result[key] = value return result"},{"question":"from typing import List class TaskManager: def __init__(self): Initialize your data structure here pass def add_task(self, task: str, priority: int): Add a task with a given priority or update its priority if it already exists. pass def get_task_with_highest_priority(self) -> str: Retrieve the task with the highest priority. If there are multiple tasks with the same highest priority, return the one that was added earliest. If there are no tasks, return an empty string. pass def remove_task(self, task: str): Remove the task from the list. If the task does not exist, do nothing. pass def get_all_tasks(self) -> List[str]: Retrieve all tasks sorted by their priority in descending order. If multiple tasks have the same priority, they should be ordered by the time they were added. pass # Example Usage # tm = TaskManager() # tm.add_task(\\"task1\\", 5) # tm.add_task(\\"task2\\", 10) # print(tm.get_task_with_highest_priority()) # Output: \\"task2\\" # tm.add_task(\\"task3\\", 10) # print(tm.get_task_with_highest_priority()) # Output: \\"task2\\" # tm.remove_task(\\"task2\\") # print(tm.get_task_with_highest_priority()) # Output: \\"task3\\" # print(tm.get_all_tasks()) # Output: [\\"task3\\", \\"task1\\"] # Unit Tests def test_add_task_and_get_task_with_highest_priority(): tm = TaskManager() tm.add_task(\\"task1\\", 5) assert tm.get_task_with_highest_priority() == \\"task1\\" tm.add_task(\\"task2\\", 10) assert tm.get_task_with_highest_priority() == \\"task2\\" tm.add_task(\\"task3\\", 10) assert tm.get_task_with_highest_priority() == \\"task2\\" def test_add_task_updates_priority(): tm = TaskManager() tm.add_task(\\"task1\\", 5) tm.add_task(\\"task1\\", 10) assert tm.get_task_with_highest_priority() == \\"task1\\" def test_remove_task(): tm = TaskManager() tm.add_task(\\"task1\\", 5) tm.add_task(\\"task2\\", 10) tm.remove_task(\\"task2\\") assert tm.get_task_with_highest_priority() == \\"task1\\" tm.remove_task(\\"task1\\") assert tm.get_task_with_highest_priority() == \\"\\" def test_get_all_tasks(): tm = TaskManager() tm.add_task(\\"task1\\", 5) tm.add_task(\\"task2\\", 10) tm.add_task(\\"task3\\", 8) assert tm.get_all_tasks() == [\\"task2\\", \\"task3\\", \\"task1\\"] tm.remove_task(\\"task2\\") assert tm.get_all_tasks() == [\\"task3\\", \\"task1\\"]","solution":"class TaskManager: def __init__(self): # Initialize a dictionary to store tasks and their priorities self.tasks = {} self.task_order = [] def add_task(self, task: str, priority: int): if task in self.tasks: self.tasks[task] = priority else: self.tasks[task] = priority self.task_order.append(task) def get_task_with_highest_priority(self) -> str: if not self.tasks: return \\"\\" highest_priority_task = max(self.task_order, key=lambda task: (self.tasks[task], -self.task_order.index(task))) return highest_priority_task def remove_task(self, task: str): if task in self.tasks: del self.tasks[task] self.task_order.remove(task) def get_all_tasks(self) -> list: sorted_tasks = sorted(self.tasks.items(), key=lambda x: (-x[1], self.task_order.index(x[0]))) return [task for task, _ in sorted_tasks]"},{"question":"def can_form_palindrome(s: str) -> str: Determines if the given string 's' can be rearranged to form a palindrome. >>> can_form_palindrome(\\"aabb\\") \\"YES\\" >>> can_form_palindrome(\\"abc\\") \\"NO\\" >>> can_form_palindrome(\\"aaabb\\") \\"YES\\" def puzzle(t: int, strings: List[str]) -> List[str]: Determines if each of the given strings in the 'strings' list can be rearranged to form a palindrome. >>> puzzle(3, [\\"aabb\\", \\"abc\\", \\"aaabb\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> puzzle(1, [\\"aabbccddeeffg\\"]) [\\"YES\\"] >>> puzzle(1, [\\"abcde\\"]) [\\"NO\\"]","solution":"def can_form_palindrome(s): Determines if the given string 's' can be rearranged to form a palindrome. from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in freq.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if at most one character has an odd frequency if odd_count > 1: return \\"NO\\" return \\"YES\\" def puzzle(t, strings): Determines if each of the given strings in the 'strings' list can be rearranged to form a palindrome. return [can_form_palindrome(s) for s in strings]"},{"question":"from typing import List, Tuple def can_rearrange(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if it is possible to rearrange the list in such a way that no two adjacent numbers are equal. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples, where each tuple contains an integer n and a list of n integers. Returns: List[str]: A list of \\"Yes\\" or \\"No\\" for each test case, indicating if such a rearrangement is possible. >>> can_rearrange(3, [(5, [1, 1, 1, 2, 2]), (4, [1, 2, 3, 4]), (3, [1, 1, 1])]) [\\"Yes\\", \\"Yes\\", \\"No\\"] >>> can_rearrange(1, [(6, [1, 1, 1, 2, 2, 2])]) [\\"Yes\\"] >>> can_rearrange(1, [(2, [1, 1])]) [\\"No\\"]","solution":"from collections import Counter def can_rearrange(t, test_cases): results = [] for i in range(t): n, a = test_cases[i] freq = Counter(a) max_freq = max(freq.values()) if max_freq > (n + 1) // 2: results.append(\\"No\\") else: results.append(\\"Yes\\") return results"},{"question":"from typing import List def find_triplets(arr: List[int], x: int) -> List[List[int]]: You are given an integer array arr of size n and an integer x. Your task is to find all unique triplets in the array that sum up to x. Return the triplets in the sorted order within each triplet and also the list of triplets itself sorted lexicographically. >>> find_triplets([1, 0, -1, 2, -1, -4], 0) [[-1, -1, 2], [-1, 0, 1]] >>> find_triplets([12, 3, 4, 1, 6, 9], 24) [[3, 9, 12]] >>> find_triplets([1, 2, 3, 4, 5], 50) [] >>> find_triplets([1, 2, -2, 0, -1, 1, -1, 2], 1) [[-2, 1, 2], [-1, 0, 2], [-1, 1, 1]] >>> find_triplets([0, 0, 0, 0], 0) [[0, 0, 0]]","solution":"def find_triplets(arr, x): arr.sort() n = len(arr) triplets = set() for i in range(n-2): if i > 0 and arr[i] == arr[i-1]: continue left = i + 1 right = n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == x: triplets.add((arr[i], arr[left], arr[right])) while left < right and arr[left] == arr[left + 1]: left += 1 while left < right and arr[right] == arr[right - 1]: right -= 1 left += 1 right -= 1 elif current_sum < x: left += 1 else: right -= 1 return sorted(list(map(list, triplets)))"},{"question":"def longest_palindromic_substring_length(t: int, strings: List[str]) -> List[int]: Determine the length of the longest substring that can be made into a palindrome with at most one operation. >>> longest_palindromic_substring_length(3, [\\"abba\\", \\"abac\\", \\"abcde\\"]) [4, 3, 1] >>> longest_palindromic_substring_length(1, [\\"madam\\"]) [5] >>> longest_palindromic_substring_length(2, [\\"aabbcc\\", \\"abcba\\"]) [2, 5]","solution":"def longest_palindromic_substring_length(t, strings): def is_palindromic(s, left, right): while left < right: if s[left] != s[right]: return False left += 1 right -= 1 return True def length_of_longest_palindromic_substring(s): n = len(s) max_length = 1 for i in range(n): for j in range(i, n): if is_palindromic(s, i, j): max_length = max(max_length, j - i + 1) return max_length results = [] for s in strings: results.append(length_of_longest_palindromic_substring(s)) return results"},{"question":"from collections import defaultdict, deque from typing import List def alienOrder(words: List[str]) -> str: Determine the order of letters in an alien language given a sorted dictionary of an alien language's words. >>> alienOrder([\\"wrt\\", \\"wrf\\", \\"er\\", \\"ett\\", \\"rftt\\"]) == \\"wertf\\" >>> alienOrder([\\"z\\", \\"x\\", \\"z\\"]) == \\"\\" >>> alienOrder([\\"z\\"]) == \\"z\\" >>> alienOrder([\\"a\\", \\"b\\", \\"c\\"]) == \\"abc\\"","solution":"from collections import defaultdict, deque def alienOrder(words): # Create data structures to store graph and in-degree of each node graph = defaultdict(set) in_degree = {char: 0 for word in words for char in word} # Build the graph by comparing every two consecutive words for i in range(len(words) - 1): first_word = words[i] second_word = words[i + 1] min_length = min(len(first_word), len(second_word)) for j in range(min_length): if first_word[j] != second_word[j]: if second_word[j] not in graph[first_word[j]]: graph[first_word[j]].add(second_word[j]) in_degree[second_word[j]] += 1 break else: if len(first_word) > len(second_word): return \\"\\" # Perform topological sort using Kahn's Algorithm queue = deque([char for char in in_degree if in_degree[char] == 0]) result = [] while queue: curr_char = queue.popleft() result.append(curr_char) for neighbor in graph[curr_char]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(result) == len(in_degree): return \\"\\".join(result) else: return \\"\\" def process_input(input_str): lines = input_str.strip().split(\\"n\\") idx = 0 T = int(lines[idx]) idx += 1 results = [] for _ in range(T): N = int(lines[idx]) idx += 1 words = [lines[i] for i in range(idx, idx + N)] idx += N results.append(alienOrder(words)) return results"},{"question":"def minimize_maximum_difference(n: int, arr: list) -> list: Return the array sorted in a way that minimizes the maximum difference between any two adjacent elements. >>> minimize_maximum_difference(4, [1, 3, 2, 6]) [1, 2, 3, 6] >>> minimize_maximum_difference(5, [10, 1, 3, 2, 5]) [1, 2, 3, 5, 10] >>> minimize_maximum_difference(7, [-1, -3, 5, 4, 2, 0, -2]) [-3, -2, -1, 0, 2, 4, 5] from solution import minimize_maximum_difference def test_minimize_maximum_difference_case_1(): assert minimize_maximum_difference(4, [1, 3, 2, 6]) == [1, 2, 3, 6] def test_minimize_maximum_difference_case_2(): assert minimize_maximum_difference(5, [10, 1, 3, 2, 5]) == [1, 2, 3, 5, 10] def test_minimize_maximum_difference_case_3(): assert minimize_maximum_difference(7, [-1, -3, 5, 4, 2, 0, -2]) == [-3, -2, -1, 0, 2, 4, 5] def test_minimize_maximum_difference_single_element(): assert minimize_maximum_difference(1, [42]) == [42] def test_minimize_maximum_difference_large_input(): assert minimize_maximum_difference(10, [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] def test_minimize_maximum_difference_negative_elements(): assert minimize_maximum_difference(5, [-1, -5, -3, -4, -2]) == [-5, -4, -3, -2, -1] def test_minimize_maximum_difference_mixed_elements(): assert minimize_maximum_difference(6, [-3, -1, 2, 5, 0, -4]) == [-4, -3, -1, 0, 2, 5]","solution":"def minimize_maximum_difference(n, arr): Return the array sorted in a way that minimizes the maximum difference between any two adjacent elements. arr.sort() return arr"},{"question":"def calculate_medal_qualifiers(n: int, v: int, r: int, d: int) -> int: Calculates the number of participants who will qualify for a finisher's medal. >>> calculate_medal_qualifiers(100, 10, 90, 5) 90 >>> calculate_medal_qualifiers(50, 15, 30, 10) 30 >>> calculate_medal_qualifiers(100, 20, 80, 8) 80 >>> calculate_medal_qualifiers(200, 50, 150, 15) 150 >>> calculate_medal_qualifiers(30, 5, 25, 10) 25","solution":"def calculate_medal_qualifiers(n, v, r, d): Calculates the number of participants who will qualify for a finisher's medal. Parameters: n (int): Total number of individuals who registered v (int): Number of volunteers r (int): Number of runners who registered in advance d (int): Minimum distance to qualify for a finisher's medal in kilometers Returns: int: Number of participants who will qualify for a finisher's medal # Since all runners registered in advance are assumed to complete the distance, # the number of qualifiers is just the count of runners registered in advance. return r"},{"question":"import re from collections import OrderedDict def word_frequency(text: str) -> dict: Determine the frequency of each word in a given text and return the results as a dictionary. >>> word_frequency(\\"\\") {} >>> word_frequency(\\"Hello world!\\") {'hello': 1, 'world': 1} >>> word_frequency(\\"It's a lovely day. Isn't it? Yes, it's amazing.\\") {\\"it's\\": 2, \\"a\\": 1, \\"lovely\\": 1, \\"day\\": 1, \\"isn't\\": 1, \\"it\\": 1, \\"yes\\": 1, \\"amazing\\": 1} >>> word_frequency(\\"Coding is fun. Coding is challenging!\\") {'coding': 2, 'is': 2, 'fun': 1, 'challenging': 1}","solution":"import re from collections import OrderedDict def word_frequency(text: str) -> dict: Determine the frequency of each word in a given text and return the results as a dictionary. # Set up a pattern to match the words with any letters, digits, and apostrophes word_pattern = re.compile(r\\"[a-zA-Z0-9']+\\") # Find all matches words in the text and convert to lower case words = word_pattern.findall(text.lower()) # Use an OrderedDict to maintain the order of first appearance freq_dict = OrderedDict() for word in words: if word in freq_dict: freq_dict[word] += 1 else: freq_dict[word] = 1 return freq_dict"},{"question":"def completely_filled_cars(seats: List[int], riders: int) -> int: This function calculates the number of completely filled cars given the number of seats in each car and the total number of riders. >>> completely_filled_cars([4, 3, 2, 5, 1], 7) 2 >>> completely_filled_cars([4, 3, 2], 9) 3 >>> completely_filled_cars([4, 3, 2], 3) 0 >>> completely_filled_cars([4, 3, 2, 1], 0) 0 >>> completely_filled_cars([50] * 100, 5000) 100","solution":"def completely_filled_cars(seats, riders): This function calculates the number of completely filled cars given the number of seats in each car and the total number of riders. filled_cars = 0 for seat in seats: if riders >= seat: filled_cars += 1 riders -= seat else: break return filled_cars"},{"question":"def seat_requests(layout, requests): Determine the number of seat requests that cannot be fulfilled. :param layout: 2D list representing the airplane seat layout where 0 indicates an available seat and 1 indicates a booked seat :param requests: List of tuples (r, c) representing the requested seats :return: Integer representing the number of requests that cannot be fulfilled >>> layout = [ >>> [0, 1, 0], >>> [1, 0, 0], >>> [0, 0, 1] >>> ] >>> requests = [(0, 1), (1, 0), (2, 2), (1, 2), (0, 0)] >>> seat_requests(layout, requests) 3","solution":"def seat_requests(layout, requests): Determine the number of seat requests that cannot be fulfilled. :param layout: 2D list representing the airplane seat layout where 0 indicates an available seat and 1 indicates a booked seat :param requests: List of tuples (r, c) representing the requested seats :return: Integer representing the number of requests that cannot be fulfilled unfulfilled_requests = 0 for r, c in requests: if layout[r][c] == 1: unfulfilled_requests += 1 else: layout[r][c] = 1 # Mark the seat as booked if it was available return unfulfilled_requests"},{"question":"def max_non_adjacent_sum(n: int, coins: List[int], k: int) -> int: Returns the maximum possible sum of the values of k non-adjacent coins. >>> max_non_adjacent_sum(5, [1, 2, 9, 4, 5], 2) 14 >>> max_non_adjacent_sum(8, [4, 1, 2, 7, 5, 3, 1, 6], 3) 18 >>> max_non_adjacent_sum(6, [8, 2, 3, 1, 7, 4], 2) 15","solution":"def max_non_adjacent_sum(n, coins, k): Returns the maximum possible sum of the values of k non-adjacent coins. if k == 0: return 0 # Initialize DP array, where each element is a dictionary to store max sum of picked coins. dp = [{} for _ in range(n)] # For each coin, we can either take it or leave it. dp[0][1] = coins[0] # Take the first coin. dp[0][0] = 0 # Leave the first coin. for i in range(1, n): for j in list(dp[i-1].keys()): # If we leave the current coin if j in dp[i]: dp[i][j] = max(dp[i][j], dp[i-1][j]) else: dp[i][j] = dp[i-1][j] # If we take the current coin if j + 1 <= k: if j + 1 in dp[i]: dp[i][j + 1] = max(dp[i][j + 1], dp[i-1][j] + coins[i]) else: dp[i][j + 1] = dp[i-1][j] + coins[i] # Find the maximum sum across all dp states with exactly k picks. result = 0 for i in range(n): if k in dp[i]: result = max(result, dp[i][k]) return result"},{"question":"def can_paint_fence(n, m, ranges): Determine if it's possible to paint the entire fence such that no two adjacent sections have the same color. Parameters: n (int): Number of sections on the fence. m (int): Number of friends. ranges (list of tuples): List of (li, ri) tuples where li and ri represent the start and end of the section each friend will paint. Returns: str: \\"Possible\\" if it is possible to paint the fence according to the rules, \\"Impossible\\" otherwise. >>> can_paint_fence(6, 2, [(1, 3), (4, 6)]) == \\"Possible\\" >>> can_paint_fence(6, 2, [(1, 4), (3, 6)]) == \\"Impossible\\"","solution":"def can_paint_fence(n, m, ranges): Determine if it's possible to paint the entire fence such that no two adjacent sections have the same color. Parameters: n (int): Number of sections on the fence. m (int): Number of friends. ranges (list of tuples): List of (li, ri) tuples where li and ri represent the start and end of the section each friend will paint. Returns: str: \\"Possible\\" if it is possible to paint the fence according to the rules, \\"Impossible\\" otherwise. # Sort the ranges by starting index ranges.sort() # Check the ranges for overlaps current_end = 0 for li, ri in ranges: if li <= current_end: return \\"Impossible\\" current_end = ri return \\"Possible\\""},{"question":"def print_X_pattern(N: int) -> None: Print a grid of dimensions N x N forming the letter 'X' with '#', where N is always an odd integer greater than or equal to 3. Args: N (int): The dimensions of the grid (must be an odd integer between 3 and 101 inclusive) Examples: >>> print_X_pattern(5) #...# .#.#. ..#.. .#.#. #...# >>> print_X_pattern(3) #.# .#. #.#","solution":"def print_X_pattern(N: int) -> None: for i in range(N): for j in range(N): if i == j or i + j == N - 1: print('#', end='') else: print('.', end='') print()"},{"question":"def is_valid_topological_order(n: int, tasks: List[int]) -> str: Determines if the given order of tasks is a valid topological order for any DAG. :param n: Number of tasks :param tasks: List of task identifiers in the given topological order :return: \\"Yes\\" if the order is valid, otherwise \\"No\\" >>> is_valid_topological_order(4, [1, 2, 3, 4]) 'Yes' >>> is_valid_topological_order(3, [3, 1, 2]) 'No' >>> is_valid_topological_order(5, [4, 2, 5, 3, 1]) 'Yes'","solution":"def is_valid_topological_order(n, tasks): Determines if the given order of tasks is a valid topological order for any DAG. :param n: Number of tasks :param tasks: List of task identifiers in the given topological order :return: \\"Yes\\" if the order is valid, otherwise \\"No\\" # An ordered list of tasks is always a valid topological ordering # for some DAG, because any permutation of tasks can form # a valid DAG where each task has a dependency on all subsequent tasks. # Therefore, we can simply return \\"Yes\\" return \\"Yes\\""},{"question":"def can_construct_from_repeated_substring(s: str, sub: str) -> bool: Determines whether a string can be completely constructed by repeating a given substring multiple times. Args: s (str): The main string to check. sub (str): The substring to check if it can form string \`s\` by repeating. Returns: bool: True if \`s\` can be constructed by repeating \`sub\`, False otherwise. Examples: >>> can_construct_from_repeated_substring(\\"abab\\", \\"ab\\") True >>> can_construct_from_repeated_substring(\\"ababa\\", \\"ab\\") False >>> can_construct_from_repeated_substring(\\"aaaa\\", \\"a\\") True >>> can_construct_from_repeated_substring(\\"abcabcabc\\", \\"abc\\") True >>> can_construct_from_repeated_substring(\\"abcd\\", \\"abc\\") False >>> can_construct_from_repeated_substring(\\"xx\\", \\"x\\") True","solution":"def can_construct_from_repeated_substring(s, sub): Determines whether the string \`s\` can be completely constructed by repeating the substring \`sub\`. Args: s (str): The main string to check. sub (str): The substring to check if it can form string \`s\` by repeating. Returns: bool: True if \`s\` can be constructed by repeating \`sub\`, False otherwise. if len(sub) == 0 or len(s) % len(sub) != 0: return False # Repeat the substring to match length of the main string repeated_sub = sub * (len(s) // len(sub)) return repeated_sub == s"},{"question":"def rotateMatrix(matrix: List[List[int]]) -> None: Rotates the given m x n matrix 90 degrees clockwise in place. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotateMatrix(matrix) >>> print(matrix) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix = [ ... [5, 1, 9, 11], ... [2, 4, 8, 10], ... [13, 3, 6, 7], ... [15, 14, 12, 16] ... ] >>> rotateMatrix(matrix) >>> print(matrix) [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]]","solution":"def rotateMatrix(matrix): Rotates the given n x n matrix 90 degrees clockwise in place. :param matrix: List[List[int]], the matrix to be rotated :return: None n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row to get the final rotated matrix for i in range(n): matrix[i].reverse()"},{"question":"def longest_distinct_substring(s: str) -> str: Returns the longest substring of s that contains only distinct characters. >>> longest_distinct_substring(\\"abcabcbb\\") \\"abc\\" >>> longest_distinct_substring(\\"bbbbb\\") \\"b\\" >>> longest_distinct_substring(\\"pwwkew\\") \\"wke\\"","solution":"def longest_distinct_substring(s): Returns the longest substring of s that contains only distinct characters. start = 0 max_length = 0 max_substring = \\"\\" used_chars = {} for i, char in enumerate(s): if char in used_chars and used_chars[char] >= start: start = used_chars[char] + 1 used_chars[char] = i current_length = i - start + 1 if current_length > max_length: max_length = current_length max_substring = s[start:i+1] return max_substring"},{"question":"def find_seating_arrangement(n: int, m: int, constraints: List[Tuple[int, int]]) -> Union[List[int], str]: Determine if it's possible to arrange students to satisfy given constraints. >>> find_seating_arrangement(4, 3, [(1, 2), (2, 3), (3, 4)]) [1, 2, 3, 4] >>> find_seating_arrangement(4, 2, [(1, 2), (3, 4)]) [1, 2, 3, 4] >>> find_seating_arrangement(4, 2, [(1, 2), (2, 3), (4, 1)]) 'IMPOSSIBLE' >>> find_seating_arrangement(5, 0, []) [1, 2, 3, 4, 5] >>> find_seating_arrangement(3, 1, [(2, 3)]) [1, 2, 3] or [1, 3, 2] from typing import List, Tuple, Union def test_example1(): n = 4 m = 3 constraints = [(1, 2), (2, 3), (3, 4)] assert find_seating_arrangement(n, m, constraints) == [1, 2, 3, 4] def test_example2(): n = 4 m = 2 constraints = [(1, 2), (3, 4)] assert find_seating_arrangement(n, m, constraints) == [1, 2, 3, 4] or find_seating_arrangement(n, m, constraints) == [3, 4, 1, 2] def test_example3(): n = 4 m = 2 constraints = [(1, 2), (2, 3), (4, 1)] assert find_seating_arrangement(n, m, constraints) == \\"IMPOSSIBLE\\" def test_no_constraints(): n = 5 m = 0 constraints = [] assert find_seating_arrangement(n, m, constraints) == [1, 2, 3, 4, 5] def test_single_constraint(): n = 3 m = 1 constraints = [(2, 3)] assert find_seating_arrangement(n, m, constraints) == [1, 2, 3] or find_seating_arrangement(n, m, constraints) == [1, 3, 2]","solution":"def find_seating_arrangement(n, m, constraints): from collections import defaultdict, deque def bfs(start, graph, visited, order): queue = deque([start]) visited.add(start) while queue: node = queue.popleft() order.append(node) for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) if m == 0: return list(range(1, n + 1)) graph = defaultdict(list) for u, v in constraints: graph[u].append(v) graph[v].append(u) visited = set() full_order = [] for student in range(1, n + 1): if student not in visited: order = [] bfs(student, graph, visited, order) full_order.extend(order) # Validate that all constraints are satisfied for u, v in constraints: if abs(full_order.index(u) - full_order.index(v)) != 1: return \\"IMPOSSIBLE\\" return full_order"},{"question":"def solve(input_string: str) -> int: Returns the maximum sum of a contiguous subsequence in the given sequence. >>> solve(\\"-2 1 -3 4 -1 2 1 -5 4\\") 6 >>> solve(\\"-1 -2 -3 -4\\") -1 >>> solve(\\"5\\") 5 >>> solve(\\"-5\\") -5 >>> solve(\\"1 2 3 4 5\\") 15 >>> solve(\\"-2 -3 4 -1 -2 1 5 -3\\") 7 >>> solve(\\" \\".join(map(str, range(-50000, 50001)))) 1250025000","solution":"def max_subarray_sum(sequence): Returns the maximum sum of a contiguous subsequence in the given sequence. max_current = max_global = sequence[0] for num in sequence[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global # Function to process input in form of a space-separated string def solve(input_string): sequence = list(map(int, input_string.split())) return max_subarray_sum(sequence)"},{"question":"def longest_palindromic_subsequence(S: str) -> int: Compute the length of the Longest Palindromic Subsequence (LPS) in the given string. >>> longest_palindromic_subsequence(\\"abacaba\\") 7 >>> longest_palindromic_subsequence(\\"abcde\\") 1 pass","solution":"def longest_palindromic_subsequence(S): n = len(S) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if S[i] == S[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1]"},{"question":"import heapq from typing import List, Tuple def dijkstra(graph, start, end): Dijkstra's algorithm to find the shortest path in a weighted graph. queue = [(0, start)] distances = {start: 0} while queue: current_dist, current_node = heapq.heappop(queue) if current_node == end: return current_dist if current_dist > distances.get(current_node, float('inf')): continue for neighbor, weight in graph[current_node]: distance = current_dist + weight if distance < distances.get(neighbor, float('inf')): distances[neighbor] = distance heapq.heappush(queue, (distance, neighbor)) return -1 def minimum_traversal_cost(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[int]: Determines the minimum traversal cost in a labyrinthine cave system from room 1 to the room containing the treasure chest. Args: T: The number of test cases. test_cases: A list of tuples, each containing: - N: Number of rooms. - M: Number of passages. - Edges: List of tuples representing the passages with traversal costs. Returns: A list of integers representing the minimum traversal cost for each test case. For example: >>> minimum_traversal_cost(2, [(4, 4, [(1, 2, 5), (2, 3, 10), (1, 3, 15), (3, 4, 5)]), (3, 3, [(1, 2, 4), (1, 3, 6), (2, 3, 1)])]) [20, 5] >>> minimum_traversal_cost(1, [(4, 2, [(1, 2, 5), (2, 3, 10)])]) [-1] results = [] for i in range(T): N, M, edges = test_cases[i] graph = {i: [] for i in range(1, N + 1)} for u, v, w in edges: graph[u].append((v, w)) result = dijkstra(graph, 1, N) results.append(result) return results","solution":"import heapq def dijkstra(graph, start, end): queue = [(0, start)] distances = {start: 0} while queue: current_dist, current_node = heapq.heappop(queue) if current_node == end: return current_dist if current_dist > distances.get(current_node, float('inf')): continue for neighbor, weight in graph[current_node]: distance = current_dist + weight if distance < distances.get(neighbor, float('inf')): distances[neighbor] = distance heapq.heappush(queue, (distance, neighbor)) return -1 def minimum_traversal_cost(T, test_cases): results = [] for i in range(T): N, M, edges = test_cases[i] graph = {i: [] for i in range(1, N + 1)} for u, v, w in edges: graph[u].append((v, w)) result = dijkstra(graph, 1, N) results.append(result) return results"},{"question":"def string_symmetry_checker(s: str) -> bool: Checks if the string s is symmetric. A string is symmetric if it can be split into two parts that are mirror images of each other. If the string has less than 2 characters, return None. Parameters: s (str): The input string. Returns: bool: True if the string is symmetric, False otherwise, and None if the string has less than 2 characters. Examples: >>> string_symmetry_checker(\\"abccba\\") # Returns True >>> string_symmetry_checker(\\"abcdef\\") # Returns False >>> string_symmetry_checker(\\"a\\") # Returns None >>> string_symmetry_checker(\\"abba\\") # Returns True >>> string_symmetry_checker(\\"abcde\\") # Returns False","solution":"def string_symmetry_checker(s): Checks if the string s is symmetric. A string is symmetric if it can be split into two parts that are mirror images of each other. Parameters: s (str): The input string. Returns: True if the string is symmetric, False otherwise, and None if the string has less than 2 characters. if len(s) < 2: return None n = len(s) if n % 2 != 0: return False mid = n // 2 left = s[:mid] right = s[mid:] return left == right[::-1]"},{"question":"def rearrange_string(s: str) -> str: Rearrange the string such that all digits come before all letters while retaining their relative order. >>> rearrange_string(\\"a1b2c3\\") == \\"123abc\\" >>> rearrange_string(\\"cba321\\") == \\"321cba\\" >>> rearrange_string(\\"1a2b3c\\") == \\"123abc\\"","solution":"def rearrange_string(s): Rearrange the string such that all digits come before all letters while retaining their relative order. digits = [] letters = [] for char in s: if char.isdigit(): digits.append(char) else: letters.append(char) return ''.join(digits + letters)"},{"question":"def can_water_flow_to_edge(n: int, m: int, grid: List[List[int]], water_sources: List[Tuple[int, int]]) -> str: Determine if there is a path for water to flow from any water source to the edge of the grid. Args: n : int : number of rows in the grid m : int : number of columns in the grid grid : List[List[int]] : grid representing the height of the terrain water_sources : List[Tuple[int, int]] : list of tuples representing the water sources Returns: str : \\"YES\\" if there is at least one water source that has a path to the edge, \\"NO\\" otherwise. Example: >>> can_water_flow_to_edge(3, 3, [[5, 4, 3], [6, 1, 8], [7, 8, 9]], [(0, 1), (2, 1)]) 'YES' >>> can_water_flow_to_edge(3, 3, [[5, 4, 3], [6, 1, 8], [7, 8, 9]], [(1, 1)]) 'NO' pass","solution":"def can_water_flow_to_edge(n, m, grid, water_sources): def is_edge(r, c): return r == 0 or r == n - 1 or c == 0 or c == m - 1 def bfs(r, c): visited = set() queue = [(r, c)] while queue: cur_r, cur_c = queue.pop(0) if (cur_r, cur_c) in visited: continue visited.add((cur_r, cur_c)) if is_edge(cur_r, cur_c): return True directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for dr, dc in directions: nr, nc = cur_r + dr, cur_c + dc if 0 <= nr < n and 0 <= nc < m and (nr, nc) not in visited and grid[nr][nc] <= grid[cur_r][cur_c]: queue.append((nr, nc)) return False for r, c in water_sources: if bfs(r, c): return \\"YES\\" return \\"NO\\""},{"question":"def frequent_element(lst: List[int]) -> int: Returns the most frequent element in the list. If there are multiple elements with the same highest frequency, return the smallest one among them. >>> frequent_element([1, 3, 3, 3, 2, 1, 2]) 3 >>> frequent_element([4, 4, 3, 3, 2, 2, 2, 1, 1, 1]) 1 >>> frequent_element([5, 5, 4, 4]) 4 >>> frequent_element([7]) 7","solution":"from collections import Counter def frequent_element(lst): Returns the most frequent element in the list. If there are multiple elements with the same highest frequency, return the smallest one among them. counter = Counter(lst) max_frequency = max(counter.values()) most_frequent = [key for key, value in counter.items() if value == max_frequency] return min(most_frequent)"},{"question":"def check_pair_sum(numbers, target): Checks if there exists a pair of integers in the list that add up to the target value. >>> check_pair_sum([2, 7, 11, 15, 3], 9) \\"YES\\" >>> check_pair_sum([1, 2, 3, 4], 8) \\"NO\\"","solution":"def check_pair_sum(numbers, target): Checks if there exists a pair of integers in the list that add up to the target value. seen_numbers = set() for num in numbers: if target - num in seen_numbers: return \\"YES\\" seen_numbers.add(num) return \\"NO\\" def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) T = int(data[1]) A = list(map(int, data[2:2+N])) print(check_pair_sum(A, T))"},{"question":"def max_nested_depth(T: int, code_line: str) -> int: Function to compute the deepest level of nested folding regions. Args: T : int : Length of the line of code. code_line : str : Line of code with folding regions. Returns: int : Maximum nesting depth. Examples: >>> max_nested_depth(18, \\"a = 5 /* b = 3 */;\\") 1 >>> max_nested_depth(31, \\"/* int x = /* y = 2; */ z = 1; */\\") 2 >>> max_nested_depth(24, \\"int main() { // code }\\") 0 >>> max_nested_depth(46, \\"/* begin /* middle /* deep */ middle end */ begin end */\\") 3 >>> max_nested_depth(22, \\"/* start /* end */ outside */\\") 2","solution":"def max_nested_depth(T, code_line): Function to compute the deepest level of nested folding regions. Args: T : int : Length of the line of code. code_line : str : Line of code with folding regions. Returns: int : Maximum nesting depth. max_depth = 0 current_depth = 0 index = 0 while index < T: if code_line[index:index+2] == \\"/*\\": current_depth += 1 max_depth = max(max_depth, current_depth) index += 2 elif code_line[index:index+2] == \\"*/\\": current_depth -= 1 index += 2 else: index += 1 return max_depth"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Given a list of integers and a target integer, return the indices of two numbers such that they add up to the target. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([3, 3], 6) [0, 1]","solution":"def two_sum(nums, target): Given a list of integers and a target integer, return the indices of two numbers such that they add up to the target. # Create a dictionary to store the differences and their corresponding indices num_dict = {} for i, num in enumerate(nums): difference = target - num if difference in num_dict: return [num_dict[difference], i] num_dict[num] = i return []"},{"question":"def nested_sum(nested_list): Returns the sum of all integers in a nested list. >>> nested_sum([1, 2, 3, 4, 5]) 15 >>> nested_sum([1, [2, [3, 4], 5], 6]) 21 >>> nested_sum([]) 0 >>> nested_sum([[], [], [[], []]]) 0 >>> nested_sum([1, [2, \\"string\\", [3, 4], 5], 6, \\"another string\\"]) 21 >>> nested_sum([[[[[[1]]]]], [[[[2]]]], 3]) 6 >>> nested_sum([\\"string\\", [], {}, (), [None, \\"another string\\"]]) 0","solution":"def nested_sum(nested_list): Returns the sum of all integers in a nested list. total = 0 for element in nested_list: if isinstance(element, list): total += nested_sum(element) elif isinstance(element, int): total += element return total"},{"question":"def max_cells_visited(R, C, grid): Find the maximum number of cells you can visit starting from the top-left cell and moving to the bottom-right cell. You can only move right or down and cannot pass through cells with obstacles. Args: R (int): The number of rows in the grid. C (int): The number of columns in the grid. grid (List[str]): The grid containing '.' (free cells) and '#' (obstacles). Returns: int: The maximum number of cells you can visit, or -1 if you cannot reach the bottom-right cell. Examples: >>> max_cells_visited(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 5 >>> max_cells_visited(3, 3, [\\"...\\", \\"#.#\\", \\"..#\\"]) -1","solution":"def max_cells_visited(R, C, grid): # Check if starting or ending point is blocked if grid[0][0] == '#' or grid[R-1][C-1] == '#': return -1 # Initialize a DP table to keep track of the number of visited cells dp = [[-1]*C for _ in range(R)] dp[0][0] = 1 for i in range(R): for j in range(C): if grid[i][j] == '#': continue if i > 0 and dp[i-1][j] != -1: dp[i][j] = max(dp[i][j], dp[i-1][j] + 1) if j > 0 and dp[i][j-1] != -1: dp[i][j] = max(dp[i][j], dp[i][j-1] + 1) return dp[R-1][C-1] if dp[R-1][C-1] != -1 else -1"},{"question":"def single_number(nums): Returns the number that appears only once in the array where every other number appears twice. Examples: >>> single_number([2, 2, 1]) 1 >>> single_number([4, 1, 2, 1, 2]) 4 >>> single_number([1]) 1","solution":"def single_number(nums): Returns the number that appears only once in the array where every other number appears twice. # Using bitwise XOR to find the unique number result = 0 for num in nums: result ^= num return result"},{"question":"import math from typing import List, Tuple def max_running_distance(m: int, trees: List[Tuple[int, int, int]]) -> float: Calculate the maximum running distance any friend can run without breaking the rules of the game. Args: m (int): The number of trees. trees (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers representing the x coordinate, y coordinate, and the maximum running distance of each friend. Returns: float: The longest distance any friend can run without leaving the forest. Examples: >>> max_running_distance(3, [(1, 2, 5), (4, 2, 3), (2, 7, 2)]) 5.000000 >>> max_running_distance(2, [(0, 0, 10), (20, 20, 1)]) 10.000000 # Test cases def test_single_tree(): assert max_running_distance(1, [(0, 0, 5)]) == 5.000000 def test_no_overlap(): assert max_running_distance(2, [(0, 0, 10), (20, 20, 1)]) == 10.000000 def test_overlap(): assert max_running_distance(3, [(1, 2, 5), (4, 2, 3), (2, 7, 2)]) == 5.000000 def test_edge_overlap(): assert max_running_distance(2, [(0, 0, 10), (10, 0, 10)]) == 10.000000 def test_full_overlap(): assert max_running_distance(2, [(0, 0, 10), (5, 0, 10)]) == 10.000000","solution":"import math def max_running_distance(m, trees): def distance(x1, y1, x2, y2): return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2) max_distance = 0 for i in range(m): x1, y1, d1 = trees[i] max_distance = max(max_distance, d1) for j in range(i + 1, m): x2, y2, d2 = trees[j] dist = distance(x1, y1, x2, y2) if dist <= d1 + d2: max_distance = max(max_distance, min(d1, d2, dist / 2)) return round(max_distance, 6) # Sample Input m = 3 trees = [ (1, 2, 5), (4, 2, 3), (2, 7, 2) ] # Expected Output: 5.000000 print(max_running_distance(m, trees)) # For testing purpose, expected: 5.000000"},{"question":"def create_magic_string(n: int) -> tuple: Creates a magic string of specified length. Args: n (int): The desired length of the magic string. Returns: tuple: (\\"YES\\", magic_string) if possible, otherwise \\"NO\\" >>> create_magic_string(3) (\\"YES\\", \\"abc\\") >>> create_magic_string(7) (\\"YES\\", \\"abcabca\\") >>> create_magic_string(1) (\\"YES\\", \\"a\\") >>> create_magic_string(0) \\"NO\\" >>> create_magic_string(-1) \\"NO\\" >>> create_magic_string(100000) ( \\"YES\\", \\"abc\\" * (100000 // 3) + \\"abc\\"[:100000 % 3] ) # Your code here from solution import create_magic_string def test_create_magic_string_length_1(): result = create_magic_string(1) assert result == (\\"YES\\", \\"a\\") def test_create_magic_string_length_2(): result = create_magic_string(2) assert result == (\\"YES\\", \\"ab\\") def test_create_magic_string_length_3(): result = create_magic_string(3) assert result == (\\"YES\\", \\"abc\\") def test_create_magic_string_length_7(): result = create_magic_string(7) assert result == (\\"YES\\", \\"abcabca\\") def test_create_magic_string_length_0(): result = create_magic_string(0) assert result == \\"NO\\" def test_create_magic_string_length_100000(): result = create_magic_string(100000) expected_suffix = \\"abc\\"[:100000 % 3] expected_string = (\\"abc\\" * (100000 // 3)) + expected_suffix assert result == (\\"YES\\", expected_string) def test_create_magic_string_large_length(): large_length = 10**5 - 1 result = create_magic_string(large_length) expected_suffix = \\"abc\\"[:large_length % 3] expected_string = (\\"abc\\" * (large_length // 3)) + expected_suffix assert result == (\\"YES\\", expected_string) def test_create_magic_string_invalid_length_negative(): result = create_magic_string(-1) assert result == \\"NO\\"","solution":"def create_magic_string(n): Creates a magic string of length n if possible. :param n: Length of the desired magic string. :type n: int :return: Tuple with a \\"YES\\" or \\"NO\\" and the magic string if possible. :rtype: tuple if n < 1 or n > 100000: return \\"NO\\" base_pattern = \\"abc\\" if n == 1: return \\"YES\\", \\"a\\" elif n == 2: return \\"YES\\", \\"ab\\" # Construct the magic string by repeating the base pattern. full_repeats = n // 3 remainder = n % 3 magic_string = base_pattern * full_repeats + base_pattern[:remainder] return \\"YES\\", magic_string"},{"question":"def determine_winner(test_cases: List[List[int]]) -> List[int]: Determine which player has the higher total score by the end of the 10 rounds or if the match ends in a tie. Args: test_cases: List of test case scores where each test case contains ten space-separated integers representing the scores for 10 rounds. Returns: A list containing the result for each test case: 0 if the match is a tie, 1 if Player 1 wins, or 2 if Player 2 wins. Examples: >>> determine_winner([[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]]) [2] >>> determine_winner([[100, 90, 80, 70, 60, 50, 40, 30, 20, 10]]) [1] >>> determine_winner([[25, 25, 25, 25, 25, 25, 25, 25, 25, 25]]) [0]","solution":"def determine_winner(test_cases): results = [] for scores in test_cases: player1_total = sum(scores[::2]) player2_total = sum(scores[1::2]) if player1_total > player2_total: results.append(1) elif player2_total > player1_total: results.append(2) else: results.append(0) return results"},{"question":"def min_path_sum(grid: List[List[int]]) -> int: Returns the minimum cost to reach the bottom-right corner from the top-left corner. >>> min_path_sum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 7 >>> min_path_sum([ ... [1, 2], ... [1, 1] ... ]) == 3","solution":"def min_path_sum(grid): Returns the minimum cost to reach the bottom-right corner from the top-left corner. if not grid or not grid[0]: return 0 R, C = len(grid), len(grid[0]) dp = [[0] * C for _ in range(R)] dp[0][0] = grid[0][0] for i in range(1, R): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, C): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, R): for j in range(1, C): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[R-1][C-1] def read_input(): import sys input = sys.stdin.read data = input().strip().split() R, C = int(data[0]), int(data[1]) grid = [] idx = 2 for i in range(R): row = [int(data[idx + j]) for j in range(C)] grid.append(row) idx += C return grid if __name__ == \\"__main__\\": grid = read_input() print(min_path_sum(grid))"},{"question":"def longest_subarray_of_1s_after_flipping(binary_string: str) -> int: Given a sequence of '0's and '1's, you are allowed to flip at most one '0' into '1'. Find the length of the longest contiguous subarray of '1's you can achieve after flipping. >>> longest_subarray_of_1s_after_flipping(\\"1101110\\") 6 >>> longest_subarray_of_1s_after_flipping(\\"1001\\") 2 >>> longest_subarray_of_1s_after_flipping(\\"1111\\") 4 >>> longest_subarray_of_1s_after_flipping(\\"0\\") 1 >>> longest_subarray_of_1s_after_flipping(\\"010101000\\") 3 >>> longest_subarray_of_1s_after_flipping(\\"1\\") 1 >>> longest_subarray_of_1s_after_flipping(\\"100101011\\") 4 >>> longest_subarray_of_1s_after_flipping(\\"010101010\\") 3","solution":"def longest_subarray_of_1s_after_flipping(binary_string): # Count the number of '1's in the string n = len(binary_string) count_1s = binary_string.count('1') # If all are '1's or only one '0', the answer is n or n if count_1s == n or count_1s == n - 1: return n # Use sliding window approach to find the maximum length of 1's subarray with at most one 0 flip max_len = 0 left = 0 zeros = 0 for right in range(n): if binary_string[right] == '0': zeros += 1 while zeros > 1: if binary_string[left] == '0': zeros -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def is_balanced(s: str) -> str: Determines if the given string of brackets is balanced. Args: s (str): A string containing only the characters '(', ')', '{', '}', '[' and ']'. Returns: str: \\"YES\\" if the string is balanced, otherwise \\"NO\\". >>> is_balanced(\\"{[()]}\\") 'YES' >>> is_balanced(\\"{[(])}\\") 'NO' >>> is_balanced(\\"{{[[(())]]}}\\") 'YES'","solution":"def is_balanced(s): Determines if the given string of brackets is balanced. Args: s (str): A string containing only the characters '(', ')', '{', '}', '[' and ']'. Returns: str: \\"YES\\" if the string is balanced, otherwise \\"NO\\". stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_map.values(): stack.append(char) elif char in bracket_map.keys(): if stack == [] or bracket_map[char] != stack.pop(): return \\"NO\\" else: return \\"NO\\" return \\"YES\\" if stack == [] else \\"NO\\""},{"question":"def max_power_consumption(n: int, powers: List[int]) -> int: Returns the maximum power consumption such that no two considered devices are adjacent in the list. >>> max_power_consumption(4, [4, 1, 1, 9]) == 13 >>> max_power_consumption(5, [3, 2, 5, 10, 7]) == 15 >>> max_power_consumption(1, [10]) == 10 >>> max_power_consumption(2, [10, 20]) == 20 >>> max_power_consumption(4, [0, 0, 0, 0]) == 0 >>> max_power_consumption(6, [1000, 1000, 1000, 1000, 1000, 1000]) == 3000 >>> max_power_consumption(6, [100, 1, 100, 1, 100, 1]) == 300","solution":"def max_power_consumption(n, powers): Returns the maximum power consumption such that no two considered devices are adjacent in the list. if n == 0: return 0 elif n == 1: return powers[0] elif n == 2: return max(powers) # dp array to store the maximum sum until each position dp = [0] * n dp[0] = powers[0] dp[1] = max(powers[0], powers[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + powers[i]) return dp[n-1] # Reading input if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) powers = list(map(int, data[1:])) print(max_power_consumption(n, powers))"},{"question":"import heapq def shortest_travel_time(n: int, m: int, u: int, v: int, roads: List[Tuple[int, int, int]]) -> Union[int, str]: Find the shortest travel time between two cities connected by roads. Parameters: n (int): number of cities m (int): number of roads u (int): start city v (int): end city roads (List[Tuple[int, int, int]]): list of roads where each road is represented by a tuple (c1, c2, t) Returns: Union[int, str]: the shortest travel time between city u and city v. If no path exists, return \\"INF\\". Examples: >>> shortest_travel_time(4, 4, 1, 4, [(1, 2, 4), (2, 3, 1), (3, 4, 3), (1, 3, 2)]) 5 >>> shortest_travel_time(5, 6, 1, 5, [(1, 2, 2), (2, 3, 4), (3, 4, 1), (4, 5, 7), (1, 3, 6), (3, 5, 3)]) 9 >>> shortest_travel_time(4, 3, 1, 4, [(1, 2, 2), (2, 3, 4), (3, 1, 1)]) INF","solution":"import heapq def shortest_travel_time(n, m, u, v, roads): graph = [[] for _ in range(n + 1)] for c1, c2, t in roads: graph[c1].append((t, c2)) graph[c2].append((t, c1)) def dijkstra(start, end): heap = [(0, start)] # (travel time, city) distances = {i: float('inf') for i in range(1, n + 1)} distances[start] = 0 while heap: current_time, current_city = heapq.heappop(heap) if current_city == end: return current_time if current_time > distances[current_city]: continue for travel_time, neighbor in graph[current_city]: time = current_time + travel_time if time < distances[neighbor]: distances[neighbor] = time heapq.heappush(heap, (time, neighbor)) return float('inf') result = dijkstra(u, v) return result if result != float('inf') else \\"INF\\""},{"question":"def can_form_palindrome(s: str) -> bool: Check if it's possible to rearrange the given string into a palindrome. >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False def solve(test_cases: List[str]) -> List[str]: Determine if each string in the list can be rearranged into a palindrome. >>> solve([\\"civic\\", \\"ivicc\\", \\"hello\\"]) [\\"Possible\\", \\"Possible\\", \\"Impossible\\"] >>> solve([\\"a\\", \\"aa\\", \\"aaa\\", \\"aabb\\"]) [\\"Possible\\", \\"Possible\\", \\"Possible\\", \\"Possible\\"]","solution":"def can_form_palindrome(s): Check if it's possible to rearrange the given string into a palindrome. char_counts = {} for char in s: char_counts[char] = char_counts.get(char, 0) + 1 odd_count = sum(1 for count in char_counts.values() if count % 2 != 0) # A string can be rearranged into a palindrome if at most one character has an odd count return odd_count <= 1 def solve(test_cases): results = [] for s in test_cases: if can_form_palindrome(s): results.append(\\"Possible\\") else: results.append(\\"Impossible\\") return results"},{"question":"def count_repeated_versions(n, versions): Calculate the number of times any version number has appeared more than once in the commit history. Parameters: n (int): The number of commits made. versions (List[int]): A list of integers representing the version numbers of the file after each commit. Returns: int: The number of times any version number appears more than once in the commit history. Examples: >>> count_repeated_versions(5, [1, 2, 3, 2, 1]) 2 >>> count_repeated_versions(3, [1, 1, 1]) 2 >>> count_repeated_versions(4, [4, 3, 2, 1]) 0","solution":"def count_repeated_versions(n, versions): Returns the number of times any version number appears more than once in the commit history. from collections import Counter version_count = Counter(versions) repeated_count = sum(count - 1 for count in version_count.values() if count > 1) return repeated_count"},{"question":"def min_developers(n: int, m: int, requirements: List[int], developers: List[List[int]]) -> int: Determine the smallest number of developers required to meet the project's skill requirements. Given the number of developers (n) and number of skills (m), the requirements list, and the developers matrix, this function returns the minimum number of developers required to meet the skill requirements. If it is not possible, it returns -1. >>> min_developers(3, 3, [2, 1, 1], [[1, 0, 1], [0, 1, 1], [1, 1, 0]]) 2 >>> min_developers(3, 3, [1, 1, 1], [[1, 1, 1], [0, 0, 1], [1, 0, 0]]) 1 >>> min_developers(3, 3, [1, 1, 1], [[1, 0, 0], [0, 1, 0], [0, 0, 0]]) -1 >>> min_developers(3, 3, [1, 1, 1], [[1, 0, 0], [0, 1, 0], [0, 0, 1]]) 3","solution":"from itertools import combinations def min_developers(n, m, requirements, developers): # Function to check if a given combination of developers meets the requirements def meets_requirements(comb): skills_met = [0] * m for developer in comb: for skill in range(m): skills_met[skill] += developers[developer][skill] return all(skills_met[skill] >= requirements[skill] for skill in range(m)) for r in range(1, n + 1): for comb in combinations(range(n), r): if meets_requirements(comb): return r return -1 # Example usage n, m = 3, 3 requirements = [2, 1, 1] developers = [ [1, 0, 1], [0, 1, 1], [1, 1, 0] ] print(min_developers(n, m, requirements, developers)) # Output: 2"},{"question":"from typing import List def evaluate_expressions(expressions: List[str]) -> List[float]: Evaluates a list of mathematical expressions and returns the results as a list of floats. >>> evaluate_expressions([\\"2+3*4\\"]) [14.0] >>> evaluate_expressions([\\"10/2-3\\"]) [2.0] >>> evaluate_expressions([\\"5*6-3/3\\"]) [29.0] >>> evaluate_expressions([\\"20-10/2\\"]) [15.0]","solution":"from typing import List def evaluate_expressions(expressions: List[str]) -> List[float]: Evaluates a list of mathematical expressions and returns the results as a list of floats. def eval_expression(expression: str) -> float: # Use eval to evaluate the expression return eval(expression) return [eval_expression(expr) for expr in expressions]"},{"question":"from typing import List def find_sequences(N: int) -> List[List[int]]: Sarah loves to collect unique sequences of positive integers that sum up to a given number. The sequences must be in non-decreasing order and printed in lexicographical order. >>> find_sequences(5) [[1, 1, 1, 1, 1], [1, 1, 1, 2], [1, 1, 3], [1, 2, 2], [1, 4], [2, 3], [5]] >>> find_sequences(3) [[1, 1, 1], [1, 2], [3]]","solution":"def find_sequences(N): def backtrack(start, path, remaining): if remaining == 0: result.append(path[:]) return for i in range(start, N + 1): if i > remaining: break path.append(i) backtrack(i, path, remaining - i) path.pop() result = [] backtrack(1, [], N) return result def display_sequences(sequences): for seq in sequences: print(' '.join(map(str, seq))) N = 5 # Example input sequences = find_sequences(N) display_sequences(sequences)"},{"question":"def is_prime(num): Check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def find_three_primes_sum(n): Determine if the number n can be expressed as the sum of three distinct primes. >>> find_three_primes_sum(23) \\"YES\\" >>> find_three_primes_sum(7) \\"NO\\" >>> find_three_primes_sum(10) \\"YES\\" >>> find_three_primes_sum(18) \\"YES\\" >>> find_three_primes_sum(6) \\"NO\\" >>> find_three_primes_sum(5000) \\"YES\\"","solution":"def is_prime(num): Check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def find_three_primes_sum(n): Determine if the number n can be expressed as the sum of three distinct primes. if n < 6: # The smallest sum of three primes > 0 is 2 + 3 + 5 = 10. return \\"NO\\" primes = [i for i in range(2, n) if is_prime(i)] for i in range(len(primes) - 2): for j in range(i + 1, len(primes) - 1): for k in range(j + 1, len(primes)): if primes[i] + primes[j] + primes[k] == n: return \\"YES\\" return \\"NO\\""},{"question":"def findRepeatedNumber(arr, N): Given an array of size N, where all elements are in the range from 1 to N-1, and one integer is repeated, find the repeated number. >>> findRepeatedNumber([4, 2, 3, 5, 1, 6, 2], 7) 2 >>> findRepeatedNumber([7, 3, 4, 5, 2, 6, 1, 4], 8) 4 pass # Replace this line with your solution","solution":"def findRepeatedNumber(arr, N): Given an array of size N, where all elements are in the range from 1 to N-1, and one integer is repeated, find the repeated number. :param list arr: List of integers :param int N: Size of the list :return: The repeated integer :rtype: int # Using Floyd's Tortoise and Hare algorithm to find the duplicate number tortoise = arr[0] hare = arr[0] # Phase 1: Finding the intersection point of the two pointers while True: tortoise = arr[tortoise] hare = arr[arr[hare]] if tortoise == hare: break # Phase 2: Finding the entrance to the cycle tortoise = arr[0] while tortoise != hare: tortoise = arr[tortoise] hare = arr[hare] return tortoise"},{"question":"def longest_unique_substring_length(s: str) -> int: Returns the length of the longest continuous sequence with unique characters in the given string s. >>> longest_unique_substring_length(\\"abcabcbb\\") 3 >>> longest_unique_substring_length(\\"bbbbb\\") 1 >>> longest_unique_substring_length(\\"pwwkew\\") 3 >>> longest_unique_substring_length(\\"a\\") 1 >>> longest_unique_substring_length(\\"dvdf\\") 3 >>> longest_unique_substring_length(\\"\\") 0 >>> longest_unique_substring_length(\\"abba\\") 2 def process_test_cases(test_cases: List[str]) -> List[int]: Processes a list of strings and returns a list containing the length of the longest continuous sequence with unique characters for each string. >>> process_test_cases([\\"abcabcbb\\", \\"bbbbb\\", \\"pwwkew\\"]) [3, 1, 3] >>> process_test_cases([\\"a\\", \\"\\"]) [1, 0] >>> process_test_cases([\\"dvdf\\", \\"abba\\"]) [3, 2]","solution":"def longest_unique_substring_length(s): Returns the length of the longest continuous sequence with unique characters in the given string s. char_index = {} max_length = 0 start = 0 for end, char in enumerate(s): if char in char_index and char_index[char] >= start: start = char_index[char] + 1 char_index[char] = end max_length = max(max_length, end - start + 1) return max_length def process_test_cases(test_cases): results = [] for s in test_cases: result = longest_unique_substring_length(s) results.append(result) return results"},{"question":"class TreeNode: def __init__(self, data): self.data = data self.left = None self.right = None class DoublyLinkedListNode: def __init__(self, data): self.data = data self.prev = None self.next = None def convertToSortedDLL(root: TreeNode) -> DoublyLinkedListNode: Convert a binary search tree (BST) of N nodes into a sorted doubly linked list (DLL) in place. Args: root (TreeNode): The root of the BST. Returns: DoublyLinkedListNode: The head of the sorted doubly linked list. Example: >>> values = [4, 2, 1, 3, 6, 5, 7] >>> bst_root = build_bst_from_list(values) >>> dll_head = convertToSortedDLL(bst_root) >>> print_dll(dll_head) [1, 2, 3, 4, 5, 6, 7] >>> values = [10, 5, 1, 7, 40] >>> bst_root = build_bst_from_list(values) >>> dll_head = convertToSortedDLL(bst_root) >>> print_dll(dll_head) [1, 5, 7, 10, 40] # Your code here def print_dll(head: DoublyLinkedListNode) -> list: elements = [] while head: elements.append(head.data) head = head.next return elements def build_bst_from_list(values: list) -> TreeNode: if not values: return None root = None for value in values: root = bst_insert(root, value) return root def bst_insert(root: TreeNode, key: int) -> TreeNode: if root is None: return TreeNode(key) if key < root.data: root.left = bst_insert(root.left, key) else: root.right = bst_insert(root.right, key) return root","solution":"class TreeNode: def __init__(self, data): self.data = data self.left = None self.right = None class DoublyLinkedListNode: def __init__(self, data): self.data = data self.prev = None self.next = None def bst_insert(root, key): if root is None: return TreeNode(key) if key < root.data: root.left = bst_insert(root.left, key) else: root.right = bst_insert(root.right, key) return root def convertToSortedDLL(root): if not root: return None # Head and Tail pointers for the doubly linked list head = None tail = None # Helper function to in-order traverse the BST and link nodes def inorder_dll(node): nonlocal head, tail if not node: return inorder_dll(node.left) dll_node = DoublyLinkedListNode(node.data) if head is None: head = dll_node else: tail.next = dll_node dll_node.prev = tail tail = dll_node inorder_dll(node.right) inorder_dll(root) return head def print_dll(head): elements = [] while head: elements.append(head.data) head = head.next return elements def build_bst_from_list(values): if not values: return None root = None for value in values: root = bst_insert(root, value) return root"},{"question":"def is_alphabetical(s: str) -> bool: Determines if all alphabetic characters in the string are in alphabetical order, ignoring case. Non-alphabetic characters should be ignored. Examples: >>> is_alphabetical(\\"aBcdEFgh\\") True >>> is_alphabetical(\\"AbC,DeFG!\\") True >>> is_alphabetical(\\"abcdzxy\\") False >>> is_alphabetical(\\"zYX\\") False >>> is_alphabetical(\\"aA\\") True >>> is_alphabetical(\\"123!abCdE\\") True","solution":"def is_alphabetical(s): Returns True if the alphabetic characters in the string s are in alphabetical order, ignoring case and non-alphabetic characters. Otherwise, returns False. # Filter and convert all alphabetic characters to lowercase filtered_chars = [char.lower() for char in s if char.isalpha()] # Check if the list of filtered characters is in alphabetical order return filtered_chars == sorted(filtered_chars)"},{"question":"import heapq from typing import Dict, Tuple, Union def shortest_route(graph: Dict[str, Dict[str, int]], start_end: Tuple[str, str]) -> Union[int, str]: Returns the minimum travel time required to reach the destination warehouse from the starting warehouse. If no route exists or input is not valid, returns \\"No route found\\" or \\"Invalid input\\". >>> graph = { ... 'Warehouse A': {'Warehouse B': 4, 'Warehouse C': 2}, ... 'Warehouse B': {'Warehouse A': 4, 'Warehouse C': 5, 'Warehouse D': 10}, ... 'Warehouse C': {'Warehouse A': 2, 'Warehouse B': 5, 'Warehouse D': 3}, ... 'Warehouse D': {'Warehouse B': 10, 'Warehouse C': 3} ... } >>> shortest_route(graph, ('Warehouse A', 'Warehouse D')) 5 >>> shortest_route(graph, ('Warehouse A', 'Warehouse E')) \\"No route found\\" >>> shortest_route([], ('Warehouse A', 'Warehouse D')) \\"Invalid input\\" >>> shortest_route(graph, 'Warehouse A, Warehouse D') \\"Invalid input\\" >>> shortest_route(graph, ('Warehouse A',)) \\"Invalid input\\" >>> shortest_route(graph, ('Warehouse A', 'Warehouse B')) 4 >>> shortest_route(graph, ('Warehouse A', 'Warehouse A')) 0","solution":"import heapq def shortest_route(graph, start_end): Returns the minimum travel time required to reach the destination warehouse from the starting warehouse. If no route exists or input is not valid, returns \\"No route found\\" or \\"Invalid input\\". if not isinstance(graph, dict) or not isinstance(start_end, tuple) or len(start_end) != 2: return \\"Invalid input\\" start, end = start_end if start not in graph or end not in graph: return \\"No route found\\" # Dijkstra's algorithm for shortest path priority_queue = [(0, start)] visited = {} while priority_queue: current_distance, current_warehouse = heapq.heappop(priority_queue) if current_warehouse == end: return current_distance if current_warehouse in visited: continue visited[current_warehouse] = current_distance for neighbor, distance in graph[current_warehouse].items(): if neighbor not in visited: heapq.heappush(priority_queue, (current_distance + distance, neighbor)) return \\"No route found\\""},{"question":"def max_subarray_sum(N: int, Z: List[int]) -> int: Given the number of Zeeps N and an array Z representing the quantity of Ziv in each Zeep, returns the maximum sum of Ziv quantities in any contiguous subarray. >>> max_subarray_sum(5, [1, -2, 3, 4, -1]) 7 >>> max_subarray_sum(4, [-1, -2, -3, -4]) -1","solution":"def max_subarray_sum(N, Z): Given the number of Zeeps N and an array Z representing the quantity of Ziv in each Zeep, returns the maximum sum of Ziv quantities in any contiguous subarray. # Using Kadane's Algorithm max_current = Z[0] max_global = Z[0] for i in range(1, N): max_current = max(Z[i], max_current + Z[i]) if max_current > max_global: max_global = max_current return max_global"},{"question":"def find_minimized_max_distance(n: int, distances: List[int]) -> int: Given a list of distances between various points, divide them into clusters such that the maximum distance within any cluster is minimized. Args: n (int): the number of distances distances (List[int]): the list of distances Returns: int: the minimized maximum distance within any cluster >>> find_minimized_max_distance(6, [1, 5, 2, 4, 8, 3]) == 8 >>> find_minimized_max_distance(4, [1, 2, 3, 100]) == 100 >>> find_minimized_max_distance(5, [1, 1, 1, 1, 1]) == 1 >>> find_minimized_max_distance(3, [100, 200, 300]) == 300 >>> find_minimized_max_distance(2, [1, 1000000000]) == 1000000000 >>> find_minimized_max_distance(1, [0]) == 0","solution":"def can_partition(distances, max_distance): current_sum = 0 for distance in distances: if current_sum + distance <= max_distance: current_sum += distance else: if distance > max_distance: return False current_sum = distance return True def find_minimized_max_distance(n, distances): low, high = max(distances), sum(distances) while low < high: mid = (low + high) // 2 if can_partition(distances, mid): high = mid else: low = mid + 1 return low"},{"question":"def to_snake_case(sentence: str) -> str: Converts a given sentence into snake_case format. >>> to_snake_case(\\"Hello World\\") \\"hello_world\\" >>> to_snake_case(\\"Snake case conversion\\") \\"snake_case_conversion\\" >>> to_snake_case(\\"Multiple spaces here\\") \\"multiple__spaces__here\\" >>> to_snake_case(\\"NoSpacesHere\\") \\"nospaceshere\\" >>> to_snake_case(\\"\\") \\"\\" >>> to_snake_case(\\"Hello, World!\\") \\"hello,_world!\\"","solution":"def to_snake_case(sentence): Converts a given sentence into snake_case format. Args: sentence (str): The sentence to be converted. Returns: str: The sentence in snake_case format. # Replace spaces with underscores and convert to lowercase return sentence.lower().replace(' ', '_')"},{"question":"def bread_quality(N, decisions): Determine the quality of bread loaves based on the opinions of 3 inspectors. Parameters: N (int): Number of test cases decisions (list of list of int): List of decisions for each test case. Each decision list contains 3 integers (0 or 1). Returns: list of str: List of strings \\"GOOD\\" or \\"BAD\\" for each test case. >>> bread_quality(3, [[1, 1, 0], [0, 0, 0], [1, 0, 1]]) ['GOOD', 'BAD', 'GOOD'] >>> bread_quality(1, [[0, 1, 0]]) ['BAD'] >>> bread_quality(2, [[1, 1, 1], [0, 0, 1]]) ['GOOD', 'BAD']","solution":"def bread_quality(N, decisions): Determine the quality of bread loaves based on the opinions of 3 inspectors. Parameters: N (int): Number of test cases decisions (list of list of int): List of decisions for each test case. Each decision list contains 3 integers (0 or 1). Returns: list of str: List of strings \\"GOOD\\" or \\"BAD\\" for each test case. results = [] for decision in decisions: if sum(decision) >= 2: results.append(\\"GOOD\\") else: results.append(\\"BAD\\") return results"},{"question":"def sort_knights(n, battle_numbers): Sort knights such that all odd battle numbers come before all even battle numbers, while maintaining the relative order within each category. Args: n (int): The number of knights. battle_numbers (list of int): The battle numbers of the knights. Returns: list of int: The rearranged list of battle numbers. >>> sort_knights(5, [7, 8, 3, 4, 5]) [7, 3, 5, 8, 4] >>> sort_knights(6, [12, 3, 14, 5, 10, 7]) [3, 5, 7, 12, 14, 10]","solution":"def sort_knights(n, battle_numbers): Sort knights such that all odd battle numbers come before all even battle numbers, while maintaining the relative order within each category. Args: n (int): The number of knights. battle_numbers (list of int): The battle numbers of the knights. Returns: list of int: The rearranged list of battle numbers. odd_numbers = [num for num in battle_numbers if num % 2 != 0] even_numbers = [num for num in battle_numbers if num % 2 == 0] return odd_numbers + even_numbers # Example Usage n = 5 battle_numbers = [7, 8, 3, 4, 5] print(sort_knights(n, battle_numbers)) # Output: [7, 3, 5, 8, 4]"},{"question":"def double_positives(numbers): Returns a new list where each positive integer from the input list is doubled, while negative integers and zero are left unchanged. Parameters: numbers (list of int): List of integers, each can be positive, negative, or zero. Returns: list of int: New list with positive integers doubled and others unchanged. Examples: >>> double_positives([1, -2, 3, 0, -4, 5]) [2, -2, 6, 0, -4, 10] >>> double_positives([-1, -3, -5]) [-1, -3, -5]","solution":"def double_positives(numbers): Returns a new list where each positive integer from the input list is doubled, while negative integers and zero are left unchanged. Parameters: numbers (list of int): List of integers, each can be positive, negative, or zero. Returns: list of int: New list with positive integers doubled and others unchanged. return [x * 2 if x > 0 else x for x in numbers]"},{"question":"from typing import List, Tuple def can_make_all_elements_equal(test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if you can make all integers in the given lists equal in some number of operations. In one operation, you can pick any two integers from the list and replace each of them with their average. The new values should still be integers. Args: test_cases : list of tuples where each tuple contains: - n: the number of integers in the list - arr: the list of n integers Returns: A list of strings, each being \\"YES\\" or \\"NO\\" for each test case >>> can_make_all_elements_equal([(4, [3, 3, 6, 12]), (2, [5, 10]), (3, [30, 60, 90])]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> can_make_all_elements_equal([(1, [1]), (1, [1000000000])]) [\\"YES\\", \\"YES\\"] >>> can_make_all_elements_equal([(3, [1, 2, 3]), (4, [1, 3, 5, 7]), (2, [6, 10])]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> can_make_all_elements_equal([(2, [8, 9]), (3, [14, 15, 16])]) [\\"YES\\", \\"YES\\"]","solution":"def can_make_all_elements_equal(test_cases): def gcd(x, y): while y: x, y = y, x % y return x results = [] for case in test_cases: n, arr = case if n == 1: results.append(\\"YES\\") continue common_gcd = arr[0] for num in arr[1:]: common_gcd = gcd(common_gcd, num) if common_gcd == 1: break if common_gcd == 1: results.append(\\"YES\\") else: divisible_by_common_gcd = all(num % common_gcd == 0 for num in arr) if divisible_by_common_gcd: results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Function to format the input properly def solve(): import sys input = sys.stdin.read data = input().split() t = int(data[0]) index = 1 test_cases = [] for _ in range(t): n = int(data[index]) index += 1 arr = list(map(int, data[index:index + n])) index += n test_cases.append((n, arr)) results = can_make_all_elements_equal(test_cases) for result in results: print(result)"},{"question":"def findThreeSum(nums: List[int], k: int) -> bool: Determines if there are three distinct integers in the array that sum up to \`k\`. >>> findThreeSum([1, 2, 3, 4, 5, 6], 10) True >>> findThreeSum([1, 2, 3, 4, 5, 6], 20) False >>> findThreeSum([1, 2, 3, 4, 5, 6], 12) True >>> findThreeSum([1, 2, 3, 4, 5], 0) False","solution":"def findThreeSum(nums, k): Determines if there are three distinct integers in the array that sum up to \`k\`. nums.sort() length = len(nums) for i in range(length - 2): left = i + 1 right = length - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == k: return True elif current_sum < k: left += 1 else: right -= 1 return False"},{"question":"def solve_maze(N: int, M: int, maze_lines: List[str], start_end_positions: Tuple[int, int, int, int]) -> int: Determine the minimum number of steps required to move from the start position (Sx, Sy) to the end position (Ex, Ey) in a maze represented by a 2D grid. >>> solve_maze(5, 5, [\\".....\\", \\".#.\\", \\"..#..\\", \\".#.\\", \\".....\\"], (0, 0, 4, 4)) 8 >>> solve_maze(5, 5, [\\".....\\", \\"#\\", \\"..#..\\", \\"#\\", \\".....\\"], (0, 0, 4, 4)) -1","solution":"from collections import deque def min_steps(maze, Sx, Sy, Ex, Ey): N = len(maze) M = len(maze[0]) if maze[Sx][Sy] == '#' or maze[Ex][Ey] == '#': return -1 directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] visited = [[False] * M for _ in range(N)] queue = deque([(Sx, Sy, 0)]) visited[Sx][Sy] = True while queue: x, y, steps = queue.popleft() if x == Ex and y == Ey: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and not visited[nx][ny] and maze[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny, steps + 1)) return -1 def solve_maze(N, M, maze_lines, start_end_positions): maze = [list(line) for line in maze_lines] Sx, Sy, Ex, Ey = start_end_positions return min_steps(maze, Sx, Sy, Ex, Ey)"},{"question":"def make_change(amount: int) -> dict: Determines the least number of physical pieces (bills and coins) needed to make up the given amount of money. Args: amount (int): The amount of money to be changed. Returns: dict: A dictionary with the denomination as keys and the count of each denomination as values. Examples: >>> make_change(97) {50: 1, 20: 2, 5: 1, 2: 1} >>> make_change(0) {}","solution":"def make_change(amount): Determines the least number of physical pieces (bills and coins) needed to make up the given amount of money. Args: amount (int): The amount of money to be changed. Returns: dict: A dictionary with the denomination as keys and the count of each denomination as values. denominations = [50, 20, 10, 5, 2, 1] change = {} for denomination in denominations: count = amount // denomination if count > 0: change[denomination] = count amount -= denomination * count return change"},{"question":"def is_divisor(A: int, B: int) -> str: Determines if B is a divisor of A. >>> is_divisor(10, 5) \\"Yes\\" >>> is_divisor(10, 3) \\"No\\" >>> is_divisor(1000, 1) \\"Yes\\" >>> is_divisor(1000, 3) \\"No\\" >>> is_divisor(1, 1) \\"Yes\\" >>> is_divisor(15, 5) \\"Yes\\" >>> is_divisor(20, 6) \\"No\\"","solution":"def is_divisor(A, B): Determines if B is a divisor of A and returns 'Yes' if true, otherwise 'No'. if A % B == 0: return \\"Yes\\" else: return \\"No\\""},{"question":"def zero_sum_sublist_exists(n, lst): Determine if the list contains a sublist of consecutive integers whose sum is zero. >>> zero_sum_sublist_exists(5, [1, 2, -3, 3, 4]) 'Yes' >>> zero_sum_sublist_exists(4, [1, 2, 3, 4]) 'No' >>> zero_sum_sublist_exists(3, [-1, 1, 0]) 'Yes' >>> zero_sum_sublist_exists(3, [3, -3, 5]) 'Yes' >>> zero_sum_sublist_exists(5, [1, 2, 3, -6, 5]) 'Yes' >>> zero_sum_sublist_exists(5, [1, 2, 3, 4, 5]) 'No' pass def process_test_cases(T, test_cases): Process multiple test cases and determine for each if there exists a sublist of consecutive integers whose sum is zero. >>> process_test_cases(2, [(5, 1, 2, -3, 3, 4), (4, 1, 2, 3, 4)]) ['Yes', 'No'] >>> process_test_cases(3, [(3, -1, 1, 0), (3, 3, -3, 5), (5, 1, 2, 3, -6, 5)]) ['Yes', 'Yes', 'Yes'] pass","solution":"def zero_sum_sublist_exists(n, lst): prefix_sum = set() current_sum = 0 for num in lst: current_sum += num if current_sum == 0 or current_sum in prefix_sum: return \\"Yes\\" prefix_sum.add(current_sum) return \\"No\\" def process_test_cases(T, test_cases): results = [] for i in range(T): n = test_cases[i][0] lst = test_cases[i][1:] result = zero_sum_sublist_exists(n, lst) results.append(result) return results"},{"question":"def assign_rooms(n: int, requests: list[int]) -> list[int]: Determine if rooms can be assigned according to the requests without violating the adjacency constraint. Parameters: n (int): Total number of rooms. requests (list of int): List of preferred room numbers. Returns: list of int: Room assignments if possible, otherwise an empty list. Examples: >>> assign_rooms(5, [1, 3, 5]) [1, 3, 5] >>> assign_rooms(5, [1, 2, 4]) [] >>> assign_rooms(7, [1, 3, 5, 7]) [1, 3, 5, 7]","solution":"def assign_rooms(n, requests): Determine if rooms can be assigned according to the requests without violating the adjacency constraint. Parameters: n (int): Total number of rooms. requests (list of int): List of preferred room numbers. Returns: list of int: Room assignments if possible, otherwise an empty list. # Sort the requested room numbers to easily check adjacency requests_sorted = sorted(requests) # Check for any adjacent requests for i in range(1, len(requests_sorted)): if requests_sorted[i] - requests_sorted[i - 1] == 1: return [] # If no adjacent requests are found, return the sorted requests return requests_sorted"},{"question":"def calculate_total_distance(hiking_log, queries): Calculates the total distance hiked over specified intervals. Parameters: hiking_log (list): List of integers representing kilometers hiked each day. queries (list): List of tuples, where each tuple contains two integers (L, R) representing the start and end days. Returns: list: List of integers representing the total kilometers hiked for each query. Example: >>> calculate_total_distance([5, 3, 9, 2, 6, 1, 4], [(2, 4)]) [14] >>> calculate_total_distance([5, 3, 9, 2, 6, 1, 4], [(2, 4), (1, 5), (3, 7)]) [14, 25, 22]","solution":"def calculate_total_distance(hiking_log, queries): Calculates the total distance hiked over specified intervals. Parameters: hiking_log (list): List of integers representing kilometers hiked each day. queries (list): List of tuples, where each tuple contains two integers (L, R) representing the start and end days. Returns: list: List of integers representing the total kilometers hiked for each query. # Create a prefix sum array prefix_sum = [0] * (len(hiking_log) + 1) for i in range(1, len(hiking_log) + 1): prefix_sum[i] = prefix_sum[i - 1] + hiking_log[i - 1] results = [] for L, R in queries: total_distance = prefix_sum[R] - prefix_sum[L - 1] results.append(total_distance) return results"},{"question":"def rotate_matrix_90_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates the given n x n matrix 90 degrees clockwise. Args: matrix: List[List[int]] : A n x n matrix that needs to be rotated. Returns: List[List[int]] : Rotated matrix. >>> rotate_matrix_90_clockwise([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix_90_clockwise([ ... [1, 2], ... [3, 4] ... ]) [[3, 1], [4, 2]] def process_test_cases(test_cases: List[List[List[int]]]) -> List[List[List[int]]]: Processes the provided test cases and returns the results of the rotated matrices. Args: test_cases: List[List[List[int]]] : List including multiple matrices which each need to be rotated. Returns: List[List[List[int]]] : List of rotated matrices. >>> process_test_cases([ ... [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ], ... [ ... [1, 2], ... [3, 4] ... ] ... ]) [ [[7, 4, 1], [8, 5, 2], [9, 6, 3]], [[3, 1], [4, 2]] ] def format_output(rotated_matrices: List[List[List[int]]]) -> List[str]: Formats the rotated matrices into the expected output format. Args: rotated_matrices: List[List[List[int]]] : List of rotated matrices. Returns: List[str] : Formatted string output of matrices suitable for display. >>> format_output([ ... [ ... [7, 4, 1], ... [8, 5, 2], ... [9, 6, 3] ... ], ... [ ... [3, 1], ... [4, 2] ... ] ... ]) ['7 4 1', '8 5 2', '9 6 3', '3 1', '4 2']","solution":"def rotate_matrix_90_clockwise(matrix): Rotates the given n x n matrix 90 degrees clockwise. n = len(matrix) new_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): new_matrix[j][n - 1 - i] = matrix[i][j] return new_matrix def process_test_cases(test_cases): Processes the provided test cases and returns the results of the rotated matrices. results = [] for matrix in test_cases: results.append(rotate_matrix_90_clockwise(matrix)) return results def format_output(rotated_matrices): Formats the rotated matrices into the expected output format. formatted_output = [] for matrix in rotated_matrices: for row in matrix: formatted_output.append(\\" \\".join(map(str, row))) return formatted_output"},{"question":"def arrange_battles(n, k, w): Arrange battles for \`n\` warriors such that each warrior fights exactly \`k\` battles and wins exactly \`w\` battles. Returns a list of tuples, where each tuple contains the number of wins and losses for each warrior. >>> arrange_battles(4, 3, 1) [(1, 2), (1, 2), (1, 2), (1, 2)] >>> arrange_battles(5, 2, 1) [(1, 1), (1, 1), (1, 1), (1, 1), (1, 1)] >>> arrange_battles(6, 4, 2) [(2, 2), (2, 2), (2, 2), (2, 2), (2, 2), (2, 2)] >>> arrange_battles(3, 0, 0) [(0, 0), (0, 0), (0, 0)] >>> arrange_battles(4, 3, 3) [(3, 0), (3, 0), (3, 0), (3, 0)]","solution":"def arrange_battles(n, k, w): Arrange battles for \`n\` warriors such that each warrior fights exactly \`k\` battles and wins exactly \`w\` battles. Returns a list of tuples, where each tuple contains the number of wins and losses for each warrior. results = [] for i in range(n): # Each warrior wins exactly \`w\` battles and loses the remaining \`k - w\` battles. results.append((w, k - w)) return results"},{"question":"from typing import List, Tuple def partition_list(nums: List[int]) -> Tuple[List[int], List[int]]: Partition the list into exactly two non-empty sublists such that the absolute difference between the sums of the two sublists is minimized. Args: nums (List[int]): A list of N non-negative integers. Returns: Tuple[List[int], List[int]]: A tuple containing two lists representing the two sublists. Examples: >>> partition_list([1, 6, 11, 5]) == ([1, 6, 5], [11]) >>> partition_list([1, 6, 11, 5]) == ([1, 11], [6, 5]) >>> partition_list([3, 1, 4, 2, 2]) == ([3, 1, 2], [4, 2]) def test_partition_list_basic(): nums = [1, 6, 11, 5] subset1, subset2 = partition_list(nums) assert abs(sum(subset1) - sum(subset2)) == 1 def test_partition_list_single_solution(): nums = [3, 1, 4, 2, 2] subset1, subset2 = partition_list(nums) assert abs(sum(subset1) - sum(subset2)) == 0 def test_partition_list_all_equal(): nums = [10, 10, 10, 10] subset1, subset2 = partition_list(nums) assert abs(sum(subset1) - sum(subset2)) == 0 def test_partition_list_large_numbers(): nums = [100, 99, 98, 97, 96, 95] subset1, subset2 = partition_list(nums) assert abs(sum(subset1) - sum(subset2)) == 1 def test_partition_list_small_numbers(): nums = [1, 2, 3, 4, 5, 6] subset1, subset2 = partition_list(nums) assert abs(sum(subset1) - sum(subset2)) <= 1 def test_partition_list_minimal_case(): nums = [1, 1] subset1, subset2 = partition_list(nums) assert abs(sum(subset1) - sum(subset2)) == 0 or abs(sum(subset1) - sum(subset2)) == 1 assert set(subset1 + subset2) == {1, 1}","solution":"from typing import List, Tuple def partition_list(nums: List[int]) -> Tuple[List[int], List[int]]: # The total sum of all elements in nums total_sum = sum(nums) # Dynamic programming approach to find the subset closest to total_sum / 2 n = len(nums) half_sum = total_sum // 2 dp = [[False] * (half_sum + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, half_sum + 1): if nums[i - 1] <= j: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]] else: dp[i][j] = dp[i - 1][j] # Find the largest j such that dp[n][j] is true best_sum = 0 for j in range(half_sum, -1, -1): if dp[n][j]: best_sum = j break # Backtrack to find the elements in this subset subset1 = [] subset2 = [] w = best_sum for i in range(n, 0, -1): if not dp[i-1][w]: subset1.append(nums[i-1]) w -= nums[i-1] else: subset2.append(nums[i-1]) while w > 0: subset2.append(nums[w-1]) w -= nums[w-1] return (subset1, subset2)"},{"question":"def process_queries(n: int, q: int, array: List[int], queries: List[List[int]]) -> List[int]: Given an array A of n integers, process q queries to update and answer questions about the array. There are two types of operations: 1. Update: Set the value at a particular index. 2. Range Sum: Compute the sum of elements in a given range (inclusive). Args: n (int): Number of elements in the array. q (int): Number of queries. array (List[int]): Initial values of the array. queries (List[List[int]]): List of queries. Returns: List[int]: Results of range sum queries. Examples: >>> process_queries(5, 4, [1, 2, 3, 4, 5], [[2, 0, 2], [1, 1, 6], [2, 1, 3], [2, 3, 4]]) [6, 13, 9] >>> process_queries(3, 2, [3, 1, 4], [[2, 0, 1], [1, 0, 0]]) [4] >>> process_queries(1, 1, [7], [[2, 0, 0]]) [7] >>> process_queries(4, 3, [5, 2, 6, 3], [[2, 1, 3], [1, 2, 10], [2, 0, 2]]) [11, 17]","solution":"class FenwickTree: def __init__(self, size): self.size = size self.tree = [0] * (size + 1) def update(self, index, delta): while index <= self.size: self.tree[index] += delta index += index & -index def query(self, index): sum = 0 while index > 0: sum += self.tree[index] index -= index & -index return sum def range_sum(self, left, right): return self.query(right + 1) - self.query(left) def process_queries(n, q, array, queries): fenwick_tree = FenwickTree(n) for i in range(n): fenwick_tree.update(i + 1, array[i]) results = [] for query in queries: if query[0] == 1: index, value = query[1], query[2] current_value = fenwick_tree.range_sum(index, index) fenwick_tree.update(index + 1, value - current_value) elif query[0] == 2: left, right = query[1], query[2] results.append(fenwick_tree.range_sum(left, right)) return results"},{"question":"def can_construct_wall(r: int, c: int, n: int) -> str: Determines if it is possible to construct a wall with the given rows (r), columns (c), and colors (n), such that no two adjacent bricks (vertically or horizontally) have the same color. >>> can_construct_wall(2, 2, 4) == \\"YES\\" >>> can_construct_wall(3, 3, 2) == \\"YES\\" >>> can_construct_wall(4, 4, 1) == \\"NO\\"","solution":"def can_construct_wall(r, c, n): Determines if it is possible to construct a wall with the given rows (r), columns (c), and colors (n), such that no two adjacent bricks (vertically or horizontally) have the same color. # Calculate the minimum number of colors needed min_colors_required = 2 if min(r, c) > 1 else 1 if n >= min_colors_required: return \\"YES\\" else: return \\"NO\\""},{"question":"def evaluate_expression(expression: str) -> int: Create a function that parses and evaluates a simple mathematical expression given as a string and returns the result as an integer. >>> evaluate_expression(\\"3+5*2\\") 13 >>> evaluate_expression(\\"2*3+4\\") 10 >>> evaluate_expression(\\"5+6*7+2\\") 49 >>> evaluate_expression(\\"3\\") 3 >>> evaluate_expression(\\"3+4\\") 7 >>> evaluate_expression(\\"3*4\\") 12 >>> evaluate_expression(\\"2*3*4+5+6*7+8*9\\") 143 >>> evaluate_expression(\\"1000*1000+1*1\\") 1000001 >>> evaluate_expression(\\"0*3+2\\") 2","solution":"def evaluate_expression(expression: str) -> int: def apply_operator(operands, operator): right = operands.pop() left = operands.pop() if operator == '+': operands.append(left + right) elif operator == '*': operands.append(left * right) operands = [] operators = [] i = 0 while i < len(expression): if expression[i].isdigit(): num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 operands.append(num) if i < len(expression) and (expression[i] == '+' or expression[i] == '*'): while (operators and operators[-1] == '*' and expression[i] == '+'): apply_operator(operands, operators.pop()) operators.append(expression[i]) i += 1 while operators: apply_operator(operands, operators.pop()) return operands[0]"},{"question":"def optimal_delivery_coordinate(house_coordinates: List[int]) -> Tuple[int, int]: Given a list of house coordinates, finds the optimal delivery coordinate and the total sum of distances. Parameters: house_coordinates (list of int): A list of integers representing the coordinates of the houses. Returns: tuple: A tuple containing the optimal coordinate and the total distance. >>> optimal_delivery_coordinate([1, 2, 3]) (2, 2) >>> optimal_delivery_coordinate([-1, 0, 1, 2]) (0, 4) >>> optimal_delivery_coordinate([10, 20, 30]) (20, 20) >>> optimal_delivery_coordinate([-5, -4, -3, -2, -1]) (-3, 6) >>> optimal_delivery_coordinate([5]) (5, 0)","solution":"def optimal_delivery_coordinate(house_coordinates): Given a list of house coordinates, finds the optimal delivery coordinate and the total sum of distances. Parameters: house_coordinates (list of int): A list of integers representing the coordinates of the houses. Returns: tuple: A tuple containing the optimal coordinate and the total distance. house_coordinates.sort() n = len(house_coordinates) median_index = n // 2 if n % 2 == 0: median_coordinate = house_coordinates[median_index - 1] else: median_coordinate = house_coordinates[median_index] total_distance = sum(abs(house - median_coordinate) for house in house_coordinates) return median_coordinate, total_distance"},{"question":"def largest_even_number(t: int, numbers: List[int]) -> List[int]: Alice is playing a game where she can remove digits from a number. She has the constraint that exactly one digit must be removed to leave the largest possible even number. If removing one digit is not possible to make the number even, then return the original number without any changes. Each test contains multiple test cases. The first line contains a single integer t (1  t  1000)  the number of test cases. Description of the test cases follows. The only line of each test case contains a single integer x (10  x  10^9)  the original number. For each test case print the largest even number Alice can obtain by removing exactly one digit, or the original number if it is not possible to get an even number. Example: >>> largest_even_number(3, [123, 13579, 2468]) [12, 13579, 468] >>> largest_even_number(2, [1357, 5799]) [1357, 5799] >>> largest_even_number(3, [1548, 130, 12345]) [548, 30, 1234]","solution":"def largest_even_number(t, numbers): results = [] for number in numbers: str_num = str(number) max_even = -1 # check the number after removing each digit for i in range(len(str_num)): new_num = int(str_num[:i] + str_num[i+1:]) if new_num % 2 == 0: max_even = max(max_even, new_num) # if max_even has been updated, append it, otherwise append the original number if max_even != -1: results.append(max_even) else: results.append(number) return results"},{"question":"def factorial(n): Calculate the factorial of a number. Parameters: n (int): A non-negative integer whose factorial is to be computed. Returns: int: Factorial of the number n. Raises: ValueError: If n is not a non-negative integer. # Your implementation here import pytest def test_factorial_positive_integers(): assert factorial(5) == 120 assert factorial(4) == 24 def test_factorial_zero(): assert factorial(0) == 1 def test_factorial_one(): assert factorial(1) == 1 def test_factorial_large_number(): assert factorial(10) == 3628800 def test_factorial_invalid_inputs(): with pytest.raises(ValueError, match=\\"Input must be a non-negative integer\\"): factorial(-1) with pytest.raises(ValueError, match=\\"Input must be a non-negative integer\\"): factorial(5.5) with pytest.raises(ValueError, match=\\"Input must be a non-negative integer\\"): factorial(\\"string\\") with pytest.raises(ValueError, match=\\"Input must be a non-negative integer\\"): factorial(None)","solution":"def factorial(n): Calculate the factorial of a number. Parameters: n (int): A non-negative integer whose factorial is to be computed. Returns: int: Factorial of the number n. Raises: ValueError: If n is not a non-negative integer. if not isinstance(n, int) or n < 0: raise ValueError(\\"Input must be a non-negative integer\\") if n == 0 or n == 1: return 1 return n * factorial(n - 1)"},{"question":"from typing import Optional class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_full_binary_tree(root: Optional[TreeNode]) -> bool: Determine if a binary tree is a full binary tree. A full binary tree is defined as a binary tree where every node has either 0 or 2 children. Args: root (Optional[TreeNode]): The root node of the binary tree. Returns: bool: True if the binary tree is a full binary tree, False otherwise. Examples: >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> is_full_binary_tree(root) True >>> root2 = TreeNode(1) >>> root2.left = TreeNode(2) >>> root2.right = TreeNode(3) >>> root2.left.right = TreeNode(4) >>> is_full_binary_tree(root2) False pass","solution":"from typing import Optional class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_full_binary_tree(root: Optional[TreeNode]) -> bool: # An empty tree is considered a full binary tree. if root is None: return True # A leaf node is reached. if root.left is None and root.right is None: return True # If both left and right children exist, check subtrees recursively. if root.left is not None and root.right is not None: return is_full_binary_tree(root.left) and is_full_binary_tree(root.right) # In all other cases, the tree is not a full binary tree. return False"},{"question":"from typing import List def min_rounds_to_defeat_monsters(attack_power: int, num_special_attacks: int, health_points: List[int]) -> int: Returns the minimum number of rounds needed for the hero to defeat all the monsters given the hero's attack power, the number of special attacks, and the health points of the monsters. >>> min_rounds_to_defeat_monsters(5, 1, [6, 3, 8, 10]) 4 >>> min_rounds_to_defeat_monsters(10, 0, [11, 9, 10]) 3 >>> min_rounds_to_defeat_monsters(5, 2, [16, 7, 8]) 3 >>> min_rounds_to_defeat_monsters(12, 2, [15, 11, 10]) 3 >>> min_rounds_to_defeat_monsters(4, 1, [2, 3, 6, 8]) 4 >>> min_rounds_to_defeat_monsters(7, 3, [20, 20, 20, 20]) 4 >>> min_rounds_to_defeat_monsters(15, 1, [5, 10, 15, 20]) 4","solution":"def min_rounds_to_defeat_monsters(attack_power, num_special_attacks, health_points): Returns the minimum number of rounds needed for the hero to defeat all the monsters given the hero's attack power, the number of special attacks, and the health points of the monsters. normal_attack_power = attack_power special_attack_power = attack_power * 2 rounds = 0 for health in sorted(health_points): if health <= normal_attack_power: rounds += 1 elif health <= special_attack_power and num_special_attacks > 0: rounds += 1 num_special_attacks -= 1 else: rounds += 1 return rounds"},{"question":"def parking_charge(hours: int) -> int: Calculates the total parking charge based on the given hours. :param hours: Total hours the car was parked (1  hours  24) :return: Total parking charge >>> parking_charge(1) 100 >>> parking_charge(2) 100 >>> parking_charge(3) 150 >>> parking_charge(5) 250","solution":"def parking_charge(hours): Calculates the total parking charge based on the given hours. :param hours: Total hours the car was parked (1  hours  24) :return: Total parking charge flat_rate = 100 additional_rate = 50 if hours <= 2: return flat_rate else: extra_hours = hours - 2 return flat_rate + (extra_hours * additional_rate)"},{"question":"def unique_tokens_collected(T: int, Q: int, participants: List[Tuple[int, int]]) -> List[int]: Determines the number of unique tokens collected by each participant. >>> unique_tokens_collected(3, 10, [(1, 5), (3, 8), (6, 10)]) [5, 6, 5] >>> unique_tokens_collected(2, 15, [(4, 12), (7, 14)]) [9, 8] >>> unique_tokens_collected(4, 20, [(1, 5), (2, 8), (3, 10), (4, 15)]) [5, 7, 8, 12] >>> unique_tokens_collected(1, 5, [(1, 1)]) [1] >>> unique_tokens_collected(5, 30, [(1, 10), (11, 20), (21, 30), (5, 25), (10, 15)]) [10, 10, 10, 21, 6]","solution":"def unique_tokens_collected(T, Q, participants): Determines the number of unique tokens collected by each participant. Parameters: T (int): The number of participants. Q (int): The total number of checkpoints. participants (list of tuple): Each tuple contains two integers, start and end checkpoints, inclusive. Returns: list: A list of integers where each integer represents the number of unique tokens collected by each participant. results = [] for start, end in participants: results.append(end - start + 1) return results"},{"question":"from typing import List def min_operations_to_empty(S: str) -> int: Returns the minimum number of operations required to convert the string S into an empty string. >>> min_operations_to_empty(\\"aabb\\") 2 >>> min_operations_to_empty(\\"abcd\\") 4 >>> min_operations_to_empty(\\"abcabcd\\") 1 pass def process_test_cases(T: int, test_cases: List[str]) -> List[int]: Processes a list of test cases and returns the results as a list of integers. >>> process_test_cases(3, [\\"aabb\\", \\"abcd\\", \\"abcabcd\\"]) [2, 4, 1] >>> process_test_cases(2, [\\"a\\", \\"abc\\"]) [1, 3] pass","solution":"def min_operations_to_empty(S): Returns the minimum number of operations required to convert the string S into an empty string. return len(set(S)) def process_test_cases(T, test_cases): Processes a list of test cases and returns the results as a list of integers. results = [] for S in test_cases: results.append(min_operations_to_empty(S)) return results"},{"question":"def process_operations(n: int, operations: List[str]) -> List[str]: Process a series of inventory operations and return the results for stock check operations. >>> process_operations(6, ['add apples 10', 'add bananas 5', 'check apples', 'update apples 20', 'check apples', 'check oranges']) ['yes', 'yes', 'no'] >>> process_operations(4, ['add apples 10', 'update apples 0', 'check apples', 'check bananas']) ['no', 'no'] >>> process_operations(7, ['add grapes 15', 'check grapes', 'add peaches 5', 'add grapes 5', 'check grapes', 'update grapes 0', 'check grapes']) ['yes', 'yes', 'no'] >>> process_operations(3, ['add oranges 10', 'check oranges', 'check grapes']) ['yes', 'no']","solution":"def process_operations(n, operations): inventory = {} results = [] for operation in operations: parts = operation.split() command, item_name = parts[0], parts[1] if command == \\"add\\": quantity = int(parts[2]) if item_name in inventory: inventory[item_name] += quantity else: inventory[item_name] = quantity elif command == \\"update\\": quantity = int(parts[2]) inventory[item_name] = quantity elif command == \\"check\\": if item_name in inventory and inventory[item_name] > 0: results.append(\\"yes\\") else: results.append(\\"no\\") return results"},{"question":"from typing import List def largest_odd_submatrix_area(matrix: List[List[int]]) -> int: Write a program that finds the largest rectangular sub-matrix with elements that are all odd numbers within a given matrix. >>> parse_input(\\"4 5n1 -3 5 7 2n4 -1 -3 5 9n1 3 7 2 4n2 4 9 11 13\\") [[1, -3, 5, 7, 2], [4, -1, -3, 5, 9], [1, 3, 7, 2, 4], [2, 4, 9, 11, 13]] >>> largest_odd_submatrix_area(parse_input(\\"1 1n1\\")) 1 >>> largest_odd_submatrix_area(parse_input(\\"4 5n1 -3 5 7 2n4 -1 -3 5 9n1 3 7 2 4n2 4 9 11 13\\")) 6 >>> largest_odd_submatrix_area(parse_input(\\"1 1n2\\")) 0 pass def parse_input(input_str: str) -> List[List[int]]: pass","solution":"def largest_odd_submatrix_area(matrix): n = len(matrix) m = len(matrix[0]) # Convert the matrix into a 0/1 matrix where 1 represents odd number and 0 represents even number bin_matrix = [[1 if matrix[i][j] % 2 != 0 else 0 for j in range(m)] for i in range(n)] max_area = 0 # Store the maximum area of submatrix of odd numbers heights = [0] * m # Heights for histogram representation for row in bin_matrix: for j in range(m): heights[j] = heights[j] + 1 if row[j] == 1 else 0 max_area = max(max_area, largest_rectangle_area(heights)) return max_area def largest_rectangle_area(heights): Helper function to determine the largest rectangle area in histogram. stack = [] max_area = 0 heights.append(0) for i in range(len(heights)): while stack and heights[stack[-1]] > heights[i]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) heights.pop() return max_area def parse_input(input_str): lines = input_str.strip().split('n') n, m = map(int, lines[0].split()) matrix = [list(map(int, line.split())) for line in lines[1:]] return matrix"},{"question":"def flatten_list(nested_list): Flattens a nested list. Args: nested_list (list): A list which may contain both integers and other lists. Returns: list: A flat list consisting of all the integers from nested_list, in order. result = [] def flatten(element): if isinstance(element, list): for item in element: flatten(item) else: result.append(element) flatten(nested_list) return result def test_flatten_simple(): assert flatten_list([1, [2, [3, 4], 5], 6]) == [1, 2, 3, 4, 5, 6] def test_flatten_multiple_nested(): assert flatten_list([[1, 2, [3]], 4, [5, [6, 7]]]) == [1, 2, 3, 4, 5, 6, 7] def test_flatten_deeply_nested(): assert flatten_list([1, [2], [[3]], [[[4]]], 5]) == [1, 2, 3, 4, 5] def test_flatten_empty_list(): assert flatten_list([]) == [] def test_flatten_single_element(): assert flatten_list([1]) == [1] def test_flatten_list_with_only_lists(): assert flatten_list([[], [[]], [[[]]]]) == []","solution":"def flatten_list(nested_list): Flattens a nested list. Args: nested_list (list): A list which may contain both integers and other lists. Returns: list: A flat list consisting of all the integers from nested_list, in order. result = [] def flatten(element): if isinstance(element, list): for item in element: flatten(item) else: result.append(element) flatten(nested_list) return result"},{"question":"def count_even_sum_pairs(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Count the unique pairs (i, j) within the series such that i < j and the sum of the ith and jth elements is even. Args: T: int - number of test cases test_cases: List of Tuples, each tuple contains: - an integer N (number of elements in the series) - a list of N space-separated positive integers Returns: List of integers representing the count of unique pairs for each test case. Example: >>> count_even_sum_pairs(1, [(4, [1, 2, 3, 4])]) [2] >>> count_even_sum_pairs(1, [(5, [2, 4, 6, 8, 10])]) [10]","solution":"def count_even_sum_pairs(T, test_cases): results = [] for case in test_cases: N, series = case even_count = sum(1 for x in series if x % 2 == 0) odd_count = N - even_count # Number of pairs from even numbers even_pairs = even_count * (even_count - 1) // 2 # Number of pairs from odd numbers odd_pairs = odd_count * (odd_count - 1) // 2 results.append(even_pairs + odd_pairs) return results"},{"question":"from collections import defaultdict def groupEmployees(N: int, ids: list) -> list: Groups the employee IDs by their starting character. If an ID starts with a number, it is grouped under '#'. The groups are returned in alphabetical order of the keys. Parameters: N (int): The number of employee IDs. ids (list of str): The list of employee IDs. Returns: list of list: Grouped employee IDs in the specified format. Example: >>> groupEmployees(5, [\\"alice123\\", \\"bob456\\", \\"charlie789\\", \\"123dave\\", \\"eve321\\"]) [['#', '123dave'], ['a', 'alice123'], ['b', 'bob456'], ['c', 'charlie789'], ['e', 'eve321']] >>> groupEmployees(3, [\\"xray99\\", \\"apple01\\", \\"123bravo\\"]) [['#', '123bravo'], ['a', 'apple01'], ['x', 'xray99']]","solution":"from collections import defaultdict def groupEmployees(N, ids): Groups the employee IDs by their starting character. If an ID starts with a number, it is grouped under '#'. The groups are returned in alphabetical order of the keys. Parameters: N (int): The number of employee IDs. ids (list of str): The list of employee IDs. Returns: list of list: Grouped employee IDs in the specified format. groups = defaultdict(list) for id in ids: if id[0].isdigit(): groups['#'].append(id) else: groups[id[0]].append(id) sorted_groups = [] for key in sorted(groups.keys()): group_list = sorted(groups[key]) sorted_groups.append([key] + group_list) return sorted_groups"},{"question":"def minimum_roads(n: int, m: int) -> int: Returns the minimum number of roads needed to connect all intersections in an n x m grid. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. Returns: int: The minimum number of roads needed. >>> minimum_roads(3, 4) 11 >>> minimum_roads(2, 2) 3 >>> minimum_roads(1, 1) 0","solution":"def minimum_roads(n, m): Returns the minimum number of roads needed to connect all intersections in an n x m grid. if n == 1 and m == 1: return 0 return n * m - 1"},{"question":"def increment_elements(lst): Returns a new list with each integer incremented by 1. >>> increment_elements([]) [] >>> increment_elements([1, 2, 3]) [2, 3, 4] >>> increment_elements([-1, -2, -3]) [0, -1, -2] >>> increment_elements([-1, 0, 1]) [0, 1, 2] >>> increment_elements([1000, 2000, 3000]) [1001, 2001, 3001] # Your code here","solution":"def increment_elements(lst): Returns a new list with each integer incremented by 1. return [x + 1 for x in lst]"},{"question":"from typing import List, Tuple def get_skyline(buildings: List[Tuple[int, int, int]]) -> List[Tuple[int, int]]: Returns the skyline silhouette for given buildings. Each building is represented as (left, right, height). The silhouette is represented as a list of tuples (x, h). :param buildings: List of triplets (left, right, height) representing buildings :return: List of tuples (x, h) representing the silhouette >>> get_skyline([(1, 4, 10), (2, 6, 15), (5, 8, 12)]) [(1, 10), (2, 15), (6, 12), (8, 0)] >>> get_skyline([(1, 2, 1)]) [(1, 1), (2, 0)] >>> get_skyline([(1, 2, 1), (3, 4, 1)]) [(1, 1), (2, 0), (3, 1), (4, 0)] >>> get_skyline([(1, 3, 3), (3, 5, 3)]) [(1, 3), (5, 0)] >>> get_skyline([(1, 4, 3), (2, 6, 4), (5, 8, 2), (7, 9, 3)]) [(1, 3), (2, 4), (6, 2), (7, 3), (9, 0)] pass","solution":"from heapq import heappush, heappop def get_skyline(buildings): Returns the skyline silhouette for given buildings. :param buildings: List of triplets (left, right, height) representing buildings :return: List of tuples (x, h) representing the silhouette events = [] for (left, right, height) in buildings: events.append((left, -height, right)) events.append((right, 0, 0)) events.sort() result = [] live_heights = [(0, float('inf'))] # (neg_height, end_x) current_height = 0 for x, neg_height, end_x in events: while live_heights[0][1] <= x: heappop(live_heights) if neg_height: heappush(live_heights, (neg_height, end_x)) max_height = -live_heights[0][0] if max_height != current_height: result.append((x, max_height)) current_height = max_height return result"},{"question":"def max_absolute_difference(T, test_cases): Find the maximum possible absolute difference between any two elements in the array such that it is possible to remove one element and this difference is retained. Arguments: T -- Integer representing the number of test cases. test_cases -- List of tuples, each containing: - n: Integer, the number of elements in the array. - arr: List of n integers, the elements of the array. Returns: List of integers, where each integer represents the maximum possible absolute difference for the corresponding test case. >>> input_str = \\"2n5n1 9 3 7 4n4n5 1 5 5n\\" >>> T, test_cases = get_test_cases(input_str) >>> max_absolute_difference(T, test_cases) [8, 4] pass def get_test_cases(input_str): Parse the input string to extract the number of test cases and the test case details. Arguments: input_str -- String, which contains the input in specified format. Returns: Tuple, containing: - T: Integer representing the number of test cases. - test_cases: List of tuples, each containing: - n: Integer, the number of elements in the array. - arr: List of n integers, the elements of the array. >>> input_str = \\"2n5n1 9 3 7 4n4n5 1 5 5n\\" >>> get_test_cases(input_str) (2, [(5, [1, 9, 3, 7, 4]), (4, [5, 1, 5, 5])]) pass","solution":"def max_absolute_difference(T, test_cases): results = [] for i in range(T): n, arr = test_cases[i] max_val = max(arr) min_val = min(arr) if n == 3: results.append(max_val - min_val) continue max_without_del = max(arr[1:]) - min(arr[1:]) max_diff = max( max_val - min(sorted(arr)[:2]), # max element - second smallest element max(sorted(arr, reverse=True)[:2]) - min_val, # second largest - min element ) max_diff = max(max_diff, max_without_del) results.append(max_diff) return results def get_test_cases(input_str): lines = input_str.split('n') T = int(lines[0]) test_cases = [] idx = 1 for _ in range(T): n = int(lines[idx]) arr = list(map(int, lines[idx+1].split())) test_cases.append((n, arr)) idx += 2 return T, test_cases"},{"question":"class SegmentTree: def __init__(self, data): # Construct a segment tree for the data pass def build(self): # Build the tree using the initial data pass def update(self, index, value): # Update a value at a given index pass def sum_range(self, left, right): # Calculate sum of the subarray from left to right pass def handle_queries(N, Q, arr, queries): Handle update and sum queries on the array. Parameters: N (int): Number of elements in the array. Q (int): Number of queries. arr (List[int]): Initial array of integers. queries (List[List[int]]): List of queries, where each query is either: [1, X, Y] - Update query. [2, L, R] - Sum query. Returns: List[int]: Result of sum queries. Example: >>> handle_queries(5, 5, [1, 2, 3, 4, 5], [[2, 1, 3], [1, 3, 10], [2, 2, 5], [1, 5, 6], [2, 1, 5]]) [6, 21, 23] pass","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.data = data self.tree = [0] * (2 * self.n) self.build() def build(self): for i in range(self.n): self.tree[self.n + i] = self.data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i << 1] + self.tree[i << 1 | 1] def update(self, index, value): pos = index + self.n self.tree[pos] = value while pos > 1: self.tree[pos >> 1] = self.tree[pos] + self.tree[pos ^ 1] pos >>= 1 def sum_range(self, left, right): left += self.n right += self.n s = 0 while left < right: if left & 1: s += self.tree[left] left += 1 if right & 1: right -= 1 s += self.tree[right] left >>= 1 right >>= 1 return s def handle_queries(N, Q, arr, queries): seg_tree = SegmentTree(arr) results = [] for query in queries: if query[0] == 1: _, X, Y = query seg_tree.update(X - 1, Y) elif query[0] == 2: _, L, R = query result = seg_tree.sum_range(L - 1, R) results.append(result) return results"},{"question":"def max_pizzas(n: int, b: int, prices: List[int]) -> int: Returns the maximum number of pizzas that can be bought without exceeding the budget. Parameters: n (int): Number of pizzas. b (int): Budget. prices (list): List of prices for each pizza. Returns: int: Maximum number of pizzas that can be bought without exceeding the budget. >>> max_pizzas(5, 20, [4, 8, 6, 12, 10]) 3 >>> max_pizzas(3, 15, [8, 5, 7]) 2 >>> max_pizzas(1, 10, [5]) 1 >>> max_pizzas(1, 2, [3]) 0 >>> max_pizzas(4, 30, [5, 5, 5, 5]) 4 >>> max_pizzas(3, 5, [10, 15, 20]) 0 >>> max_pizzas(3, 7, [7, 3, 5]) 1 >>> max_pizzas(100, 100, [1]*100) 100 >>> max_pizzas(3, 0, [1, 2, 3]) 0","solution":"def max_pizzas(n, b, prices): Returns the maximum number of pizzas that can be bought without exceeding the budget. Parameters: n (int): Number of pizzas. b (int): Budget. prices (list): List of prices for each pizza. Returns: int: Maximum number of pizzas that can be bought without exceeding the budget. prices.sort() total_cost = 0 count = 0 for price in prices: if total_cost + price <= b: total_cost += price count += 1 else: break return count"},{"question":"def construct_string(n: int) -> str: Constructs a string S of length n that consists of only 'A' and 'B' where there is at least one substring with equal numbers of 'A's and 'B's. >>> construct_string(2) 'AB' >>> construct_string(5) 'ABABA' def process_test_cases(test_cases: List[int]) -> List[str]: Processes multiple test cases. Parameters: test_cases (list): List of integers representing the lengths of the strings to be constructed. Returns: list: List of strings representing the solution for each test case. >>> process_test_cases([2, 5]) ['AB', 'ABABA'] >>> process_test_cases([4, 3]) ['ABAB', 'ABA']","solution":"def construct_string(n): Constructs a string S of length n that consists of only 'A' and 'B' where there is at least one substring with equal numbers of 'A's and 'B's. # Ensure a valid substring exists by having at least \\"AB\\" or \\"BA\\" return \\"AB\\" * (n // 2) + \\"A\\" * (n % 2) def process_test_cases(test_cases): Processes multiple test cases. Parameters: test_cases (list): List of integers representing the lengths of the strings to be constructed. Returns: list: List of strings representing the solution for each test case. return [construct_string(n) for n in test_cases]"},{"question":"def longest_balanced_binary_string_length(B: str) -> int: Returns the length of the longest balanced binary string that can be achieved from the given binary string B by removing the minimum number of characters. >>> longest_balanced_binary_string_length(\\"110100110\\") 8 >>> longest_balanced_binary_string_length(\\"111000\\") 6 >>> longest_balanced_binary_string_length(\\"0000\\") 0 >>> longest_balanced_binary_string_length(\\"1\\") 0 >>> longest_balanced_binary_string_length(\\"101010\\") 6 pass def resolve_test_cases(T: int, test_cases: List[str]) -> List[int]: Given the number of test cases T and a list of binary strings, returns a list of lengths of the longest balanced binary string for each test case. pass","solution":"def longest_balanced_binary_string_length(B): Returns the length of the longest balanced binary string that can be achieved from the given binary string B by removing the minimum number of characters. count_0 = B.count('0') count_1 = B.count('1') # The longest balanced string can be formed by pairing '0's and '1's. return 2 * min(count_0, count_1) def resolve_test_cases(T, test_cases): results = [] for B in test_cases: results.append(longest_balanced_binary_string_length(B)) return results"},{"question":"def shortest_substring_removal(S: str) -> int: Returns the length of the shortest substring that needs to be removed so that the remaining string is a palindrome. >>> shortest_substring_removal(\\"abac\\") 1 >>> shortest_substring_removal(\\"aaa\\") 0","solution":"def shortest_substring_removal(S): Returns the length of the shortest substring that needs to be removed so that the remaining string is a palindrome. def is_palindrome(s): return s == s[::-1] n = len(S) if is_palindrome(S): return 0 for length in range(1, n): for start in range(n - length + 1): temp_str = S[:start] + S[start + length:] if is_palindrome(temp_str): return length return n # in the worst case, we might have to remove the entire string # Example usages: print(shortest_substring_removal(\\"abac\\")) # Output: 1 print(shortest_substring_removal(\\"aaa\\")) # Output: 0"},{"question":"def canPartition(nums): Determine if it is possible to partition the array into two subsets such that the sum of elements in both subsets is equal. Args: nums (List[int]): Array of integers Returns: bool: True if such a partition is possible, else False. >>> canPartition([1, 5, 11, 5]) True >>> canPartition([1, 2, 3, 5]) False pass def process_test_cases(input_data): Process multiple test cases from a single string input. Args: input_data (str): Input data containing multiple test cases Returns: List[bool]: List of boolean results for each test case >>> process_test_cases(\\"2n4n1 5 11 5n5n1 2 3 5\\") [True, False] >>> process_test_cases(\\"1n3n3 3 3\\") [False] pass","solution":"def canPartition(nums): total_sum = sum(nums) # If the total sum is odd, we cannot split it into two equal parts if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # DP array to find subsets with a specific sum dp = [False] * (target + 1) dp[0] = True for num in nums: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target] def process_test_cases(input_data): input_lines = input_data.strip().split(\\"n\\") T = int(input_lines[0]) results = [] index = 1 for _ in range(T): N = int(input_lines[index]) array = list(map(int, input_lines[index + 1].split())) results.append(canPartition(array)) index += 2 return results"},{"question":"from typing import List def calculate_work_hours(events: List[str]) -> List[str]: Calculate the total working hours for each employee for the day, rounded to two decimal places. >>> calculate_work_hours([ ... \\"1 clockin 08:00\\", ... \\"1 clockout 12:00\\", ... \\"1 clockin 13:00\\", ... \\"1 clockout 17:00\\", ... \\"2 clockin 09:00\\", ... \\"2 clockout 11:00\\", ... \\"2 clockin 12:00\\", ... \\"2 clockout 15:00\\", ... \\"end\\" ... ]) [\\"1 8.00\\", \\"2 5.00\\"] >>> calculate_work_hours([ ... \\"1 clockin 08:00\\", ... \\"end\\" ... ]) [\\"1 0.00\\"] >>> calculate_work_hours([ ... \\"end\\" ... ]) []","solution":"from datetime import datetime def calculate_work_hours(events): employee_times = {} for event in events: parts = event.split() if parts[0] == \\"end\\": break employee_id, action, time = int(parts[0]), parts[1], parts[2] if employee_id not in employee_times: employee_times[employee_id] = {\\"clockin\\": None, \\"total_minutes\\": 0} if action == \\"clockin\\": employee_times[employee_id][\\"clockin\\"] = datetime.strptime(time, \\"%H:%M\\") elif action == \\"clockout\\": clockin_time = employee_times[employee_id][\\"clockin\\"] if clockin_time: clockout_time = datetime.strptime(time, \\"%H:%M\\") diff = clockout_time - clockin_time minutes_worked = diff.total_seconds() // 60 employee_times[employee_id][\\"total_minutes\\"] += minutes_worked employee_times[employee_id][\\"clockin\\"] = None results = [ f\\"{employee_id} {employee_times[employee_id]['total_minutes'] / 60:.2f}\\" for employee_id in sorted(employee_times) ] return results"},{"question":"def longest_substring_with_k_distinct(s: str, k: int) -> int: Find the length of the longest substring of s that contains at most k distinct characters. >>> longest_substring_with_k_distinct(\\"aabbcca\\", 1) 2 >>> longest_substring_with_k_distinct(\\"aabbcca\\", 2) 4 >>> longest_substring_with_k_distinct(\\"aabbcca\\", 3) 7 pass def process_queries(n: int, q: int, s: str, queries: List[int]) -> List[int]: Process multiple queries to find the length of the longest substring of s that contains at most k distinct characters for each query. >>> process_queries(7, 3, \\"aabbcca\\", [1, 2, 3]) [2, 4, 7] >>> process_queries(5, 2, \\"abcde\\", [2, 3]) [2, 3] pass","solution":"def longest_substring_with_k_distinct(s, k): n = len(s) max_len = 0 left = 0 char_count = {} for right in range(n): char = s[right] if char in char_count: char_count[char] += 1 else: char_count[char] = 1 while len(char_count) > k: left_char = s[left] if char_count[left_char] == 1: del char_count[left_char] else: char_count[left_char] -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len def process_queries(n, q, s, queries): results = [] for k in queries: results.append(longest_substring_with_k_distinct(s, k)) return results"},{"question":"def min_cost_to_paint_houses(costs: List[Tuple[int, int, int]]) -> int: Compute the minimum total cost to paint all houses in a street such that no two adjacent houses have the same color. >>> min_cost_to_paint_houses([(17, 2, 17), (16, 16, 5), (14, 3, 19)]) 10 >>> min_cost_to_paint_houses([(10, 5, 20)]) 5 Unit Test: from solution import min_cost_to_paint_houses def test_single_house(): assert min_cost_to_paint_houses([(10, 5, 20)]) == 5 def test_two_houses(): assert min_cost_to_paint_houses([(10, 5, 20), (20, 8, 10)]) == 15 def test_three_houses(): assert min_cost_to_paint_houses([(17, 2, 17), (16, 16, 5), (14, 3, 19)]) == 10 def test_no_houses(): assert min_cost_to_paint_houses([]) == 0 def test_multiple_houses_same_cost(): assert min_cost_to_paint_houses([(3, 3, 3), (3, 3, 3), (3, 3, 3)]) == 9 def test_alternating_costs(): assert min_cost_to_paint_houses([(1, 100, 100), (100, 1, 100), (100, 100, 1)]) == 3","solution":"def min_cost_to_paint_houses(costs): if not costs: return 0 n = len(costs) dp = [[0] * 3 for _ in range(n)] # Initial cost for the first house dp[0][0] = costs[0][0] dp[0][1] = costs[0][1] dp[0][2] = costs[0][2] # Fill the DP table for i in range(1, n): dp[i][0] = costs[i][0] + min(dp[i-1][1], dp[i-1][2]) dp[i][1] = costs[i][1] + min(dp[i-1][0], dp[i-1][2]) dp[i][2] = costs[i][2] + min(dp[i-1][0], dp[i-1][1]) # The minimum cost to paint all houses will be the minimum value in the last row of the dp array return min(dp[-1])"},{"question":"def quick_sort(arr): Monocarp's sorting algorithm: recursively split the array based on the median and sort the parts. Args: arr (List[int]): The input array of integers to be sorted. Returns: List[int]: The sorted array. Examples: >>> quick_sort([3, 1, 4, 1, 5]) [1, 1, 3, 4, 5] >>> quick_sort([10, 20, 30, 40, 50, 60, 70]) [10, 20, 30, 40, 50, 60, 70] >>> quick_sort([2, 8, 6, 4]) [2, 4, 6, 8] >>> quick_sort([]) [] >>> quick_sort([1]) [1] >>> quick_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> quick_sort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] # Your implementation here def process_test_cases(t, test_cases): Processes multiple test cases for Monocarp's sorting problem. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains an integer representing the number of elements in the array and the list of integers itself. Returns: List[List[int]]: A list of sorted arrays, one for each test case. Examples: >>> process_test_cases(3, [(5, [3, 1, 4, 1, 5]), (7, [10, 20, 30, 40, 50, 60, 70]), (4, [2, 8, 6, 4])]) [[1, 1, 3, 4, 5], [10, 20, 30, 40, 50, 60, 70], [2, 4, 6, 8]] # Your implementation here def main(): The main function to read input for multiple test cases, process each case using the process_test_cases function, and output the sorted arrays. # Your implementation here","solution":"def quick_sort(arr): if len(arr) <= 1: return arr else: pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right) def process_test_cases(t, test_cases): results = [] for case in test_cases: n, arr = case sorted_arr = quick_sort(arr) results.append(sorted_arr) return results def main(): import sys input = sys.stdin.read data = input().strip().split('n') t = int(data[0].strip()) index = 1 test_cases = [] for _ in range(t): while data[index].strip() == \\"\\": index += 1 n = int(data[index].strip()) index += 1 arr = list(map(int, data[index].strip().split())) index += 1 test_cases.append((n, arr)) results = process_test_cases(t, test_cases) for result in results: print(\\" \\".join(map(str, result))) # Note: This main block of code is to read input and use the defined functions to process it. # You can call main() function if running in an environment where you can provide input via stdin."},{"question":"def max_elements_in_containers(n: int, k: int, sizes: List[int], volumes: List[int]) -> int: Returns the maximum number of elements that can be placed into the containers. Args: n (int): The number of elements. k (int): The number of containers. sizes (List[int]): The list of sizes of the elements. volumes (List[int]): The list of volumes of the containers. Returns: int: The maximum number of elements that can be placed into the containers. Examples: >>> max_elements_in_containers(5, 3, [2, 3, 4, 5, 6], [5, 10, 5]) 3 >>> max_elements_in_containers(4, 2, [5, 6, 7, 8], [10, 15]) 2 >>> max_elements_in_containers(6, 5, [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1]) 5","solution":"def max_elements_in_containers(n, k, sizes, volumes): Returns the maximum number of elements that can be placed into the containers. Args: n: int - The number of elements. k: int - The number of containers. sizes: List[int] - The list of sizes of the elements. volumes: List[int] - The list of volumes of the containers. Returns: int - The maximum number of elements that can be placed into the containers. sizes.sort() volumes.sort() element_idx = 0 container_idx = 0 while element_idx < n and container_idx < k: if sizes[element_idx] <= volumes[container_idx]: element_idx += 1 container_idx += 1 return element_idx"},{"question":"from typing import List def remove_element_for_max_gcd(arr: List[int]) -> int: Remove exactly one element from the array such that the greatest common divisor (GCD) of the remaining elements is maximized. If there are multiple possibilities, return the smallest possible element that can be removed. Args: arr (List[int]): Array of integers. Returns: int: The smallest element that can be removed to maximize the GCD of the remaining elements. >>> remove_element_for_max_gcd([2, 6, 8, 3]) 3 >>> remove_element_for_max_gcd([7, 7, 7, 7]) 7 >>> remove_element_for_max_gcd([15, 30, 45, 60]) 15 >>> remove_element_for_max_gcd([10, 10, 10]) 10 >>> remove_element_for_max_gcd([3, 5]) 3 >>> remove_element_for_max_gcd([5, 10, 15, 20]) 5","solution":"from math import gcd from functools import reduce def find_gcd_of_list(nums): return reduce(gcd, nums) def remove_element_for_max_gcd(arr): n = len(arr) if n == 2: return min(arr) prefix_gcd = [0] * n suffix_gcd = [0] * n prefix_gcd[0] = arr[0] for i in range(1, n): prefix_gcd[i] = gcd(prefix_gcd[i-1], arr[i]) suffix_gcd[n-1] = arr[n-1] for i in range(n-2, -1, -1): suffix_gcd[i] = gcd(suffix_gcd[i+1], arr[i]) max_gcd = 0 element_to_remove = arr[0] for i in range(n): if i == 0: current_gcd = suffix_gcd[1] elif i == n-1: current_gcd = prefix_gcd[n-2] else: current_gcd = gcd(prefix_gcd[i-1], suffix_gcd[i+1]) if current_gcd > max_gcd: max_gcd = current_gcd element_to_remove = arr[i] elif current_gcd == max_gcd: element_to_remove = min(element_to_remove, arr[i]) return element_to_remove"},{"question":"def solve(T: int, test_cases: list) -> list: Given an integer array of length N, determine if it is possible to select a subset of the elements such that their sum is a prime number. Args: T: int - the number of test cases test_cases: list - a list of tuples where each tuple contains two elements: an integer N and a list of N integers Returns: list - a list of strings, where each string is either \\"YES\\" or \\"NO\\" indicating whether there exists a subset of the array elements whose sum is a prime number for each test case. Sample: >>> solve(3, [(4, [1, 2, 3, 4]), (3, [10, 15, 20]), (5, [2, 3, 5, 7, 11])]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> solve(1, [(5, [2, 3, 5, 7, 11])]) [\\"YES\\"]","solution":"from itertools import combinations def is_prime(n): if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def has_prime_sum_subset(arr): for r in range(1, len(arr) + 1): for subset in combinations(arr, r): if is_prime(sum(subset)): return True return False def solve(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] arr = test_cases[i][1] if has_prime_sum_subset(arr): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def is_prime(n): Determines if a given number n is a prime number. pass def even_magic_game(T, test_cases): Determines the outcome of the game \\"Even Magic\\" for each test case. Parameters: T (int): Number of test cases. test_cases (list of str): List containing sequences of non-negative integers as strings. Returns: list of str: List containing \\"Even Magic!\\" or \\"No Magic!\\" for each test case. pass # Unit Test def test_is_prime(): assert is_prime(2) == True assert is_prime(3) == True assert is_prime(4) == False assert is_prime(13) == True assert is_prime(20) == False assert is_prime(1) == False assert is_prime(0) == False def test_even_magic_game(): T = 2 test_cases = [ \\"124 5680 77\\", \\"1023 4567 89\\" ] results = even_magic_game(T, test_cases) assert results == [\\"No Magic!\\", \\"No Magic!\\"] T = 1 test_cases = [ \\"222 888 444\\" ] results = even_magic_game(T, test_cases) assert results == [\\"No Magic!\\"] T = 1 test_cases = [ \\"1 3 5 7\\" ] results = even_magic_game(T, test_cases) assert results == [\\"No Magic!\\"] T = 1 test_cases = [ \\"302 642\\" ] results = even_magic_game(T, test_cases) assert results == [\\"No Magic!\\"] T = 1 test_cases = [ \\"2\\" ] results = even_magic_game(T, test_cases) assert results == [\\"Even Magic!\\"]","solution":"def is_prime(n): Determines if a given number n is a prime number. if n < 2: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True def even_magic_game(T, test_cases): Determines the outcome of the game \\"Even Magic\\" for each test case. Parameters: T (int): Number of test cases. test_cases (list of str): List containing sequences of non-negative integers as strings. Returns: list of str: List containing \\"Even Magic!\\" or \\"No Magic!\\" for each test case. results = [] for case in test_cases: even_sum = 0 numbers = case.split() for number in numbers: for digit in number: if digit in '02468': even_sum += int(digit) if is_prime(even_sum): results.append(\\"Even Magic!\\") else: results.append(\\"No Magic!\\") return results"},{"question":"def analyze_server_data(m: int, server_logs: List[Tuple[int, List[Tuple[int, int, int]]]]) -> None: Analyze the performance data to identify the server with the highest total disk operations. Each server logs disk operations consisting of timestamp, read operations, and write operations. Output the total operations for each server and the server with the highest operations. >>> analyze_server_data(3, [(4, [(1, 100, 200), (2, 200, 100), (3, 300, 150), (4, 100, 250)]), (2, [(1, 150, 150), (2, 300, 300)]), (3, [(1, 200, 100), (2, 150, 150), (3, 250, 250)])]) Server 1: 1450 Server 2: 900 Server 3: 1100 Top server: 1 with total operations 1450","solution":"def analyze_server_data(m, server_logs): total_operations = [] for i in range(m): n_i = server_logs[i][0] logs = server_logs[i][1] total_ops = sum(r + w for (_, r, w) in logs) total_operations.append((i + 1, total_ops)) for server_id, ops in total_operations: print(f\\"Server {server_id}: {ops}\\") top_server = max(total_operations, key=lambda x: x[1]) print(f\\"Top server: {top_server[0]} with total operations {top_server[1]}\\")"},{"question":"def work_hours_status(monday, tuesday, wednesday, thursday, friday): Calculate the total weekly hours worked and determine full-time or part-time status. Args: monday (int): Hours worked on Monday. tuesday (int): Hours worked on Tuesday. wednesday (int): Hours worked on Wednesday. thursday (int): Hours worked on Thursday. friday (int): Hours worked on Friday. Returns: tuple: Total weekly hours (int) and status (str: \\"Full-time\\" or \\"Part-time\\"). pass # Unit tests to validate the solution def test_exactly_full_time_hours(): assert work_hours_status(8, 8, 8, 8, 8) == (40, \\"Full-time\\") def test_more_than_full_time_hours(): assert work_hours_status(8, 9, 8, 8, 8) == (41, \\"Full-time\\") assert work_hours_status(10, 10, 10, 10, 5) == (45, \\"Full-time\\") def test_less_than_full_time_hours(): assert work_hours_status(5, 6, 7, 8, 8) == (34, \\"Part-time\\") assert work_hours_status(0, 10, 10, 10, 5) == (35, \\"Part-time\\") def test_zero_hours(): assert work_hours_status(0, 0, 0, 0, 0) == (0, \\"Part-time\\") def test_varied_hours(): assert work_hours_status(1, 2, 3, 4, 5) == (15, \\"Part-time\\") assert work_hours_status(6, 7, 8, 9, 10) == (40, \\"Full-time\\") def test_input_edge_cases(): # Testing edge cases of the upper range assert work_hours_status(24, 24, 24, 24, 24) == (120, \\"Full-time\\") # Testing edge cases of the lower range assert work_hours_status(0, 0, 0, 0, 0) == (0, \\"Part-time\\")","solution":"def work_hours_status(monday, tuesday, wednesday, thursday, friday): Calculate the total weekly hours worked and determine full-time or part-time status. Args: monday (int): Hours worked on Monday. tuesday (int): Hours worked on Tuesday. wednesday (int): Hours worked on Wednesday. thursday (int): Hours worked on Thursday. friday (int): Hours worked on Friday. Returns: tuple: Total weekly hours (int) and status (str: \\"Full-time\\" or \\"Part-time\\"). weekly_hours = monday, tuesday, wednesday, thursday, friday total_hours = sum(weekly_hours) if total_hours >= 40: status = \\"Full-time\\" else: status = \\"Part-time\\" return total_hours, status"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a mathematical expression given as a string. The expression can contain integers, the operators \`+\`, \`-\`, \`*\`, \`/\`, and parentheses \`(\` and \`)\`. >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\"3/2\\") 1 >>> evaluate_expression(\\"(2+3)*5\\") 25 >>> evaluate_expression(\\"10+2*4\\") 18 import pytest def test_simple_addition(): assert evaluate_expression(\\"3+2\\") == 5 def test_simple_multiplication(): assert evaluate_expression(\\"2*3\\") == 6 def test_mixed_operations(): assert evaluate_expression(\\"3+2*2\\") == 7 def test_integer_division(): assert evaluate_expression(\\"3/2\\") == 1 def test_parentheses(): assert evaluate_expression(\\"(2+3)*5\\") == 25 def test_combined_operations(): assert evaluate_expression(\\"10+2*4\\") == 18 def test_nested_parentheses(): assert evaluate_expression(\\"((2+3)*(4-1))/2\\") == 7 def test_complex_expression(): assert evaluate_expression(\\"2*(5+5*2)/3+(6/2+8)\\") == 21 def test_single_number(): assert evaluate_expression(\\"42\\") == 42 def test_negative_number_result(): assert evaluate_expression(\\"1-2-3\\") == -4","solution":"def evaluate_expression(expression): def helper(tokens): stack = [] num = 0 sign = '+' while len(tokens) > 0: char = tokens.pop(0) if char.isdigit(): num = num * 10 + int(char) if char == '(': num = helper(tokens) if (not char.isdigit() and not char.isspace()) or len(tokens) == 0: if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign == '*': stack[-1] = stack[-1] * num elif sign == '/': stack[-1] = int(stack[-1] / num) sign = char num = 0 if char == ')': break return sum(stack) tokens = list(expression) return helper(tokens)"},{"question":"def find_repeated_elements(arr): Takes an array of integers and returns an array of integers that are repeated in the input array, sorted in ascending order. >>> find_repeated_elements([4, 5, 6, 6, 7, 8, 8, 8, 9, 10]) [6, 8] >>> find_repeated_elements([1, 2, 3, 4, 5, 6]) [] >>> find_repeated_elements([]) [] >>> find_repeated_elements([1, 1, 1, 1, 1]) [1] >>> find_repeated_elements([-1, 2, -1, 3, -2, -2, 4]) [-2, -1] >>> find_repeated_elements([10, 10, -1, -1, 1, 2, 3, -10, -10, -10]) [-10, -1, 10]","solution":"def find_repeated_elements(arr): Takes an array of integers and returns an array of integers that are repeated in the input array, sorted in ascending order. Args: arr (list): List of integers. Returns: list: Sorted list of repeated integers. from collections import Counter # Count the frequency of each element in the array count = Counter(arr) # Extract elements that appear more than once, then sort them repeated_elements = sorted([num for num, freq in count.items() if freq > 1]) return repeated_elements"},{"question":"def reverse_subarray_to_lexico_smallest(seq: List[int]) -> List[int]: Given a sequence of integers, perform two operations to find the lexicographically smallest sequence. >>> reverse_subarray_to_lexico_smallest([4, 3, 2, 1, 5]) [1, 2, 3, 4, 5] >>> reverse_subarray_to_lexico_smallest([3, 2, 1]) [1, 2, 3] pass def process_test_cases(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Process multiple test cases to find the lexicographically smallest sequences. >>> input_cases = [(5, [4, 3, 2, 1, 5]), (3, [3, 2, 1])] >>> process_test_cases(2, input_cases) [[1, 2, 3, 4, 5], [1, 2, 3]] pass","solution":"def reverse_subarray_to_lexico_smallest(seq): n = len(seq) # First, find the first decreasing part to make our first subarray min_seq = seq[:] for i in range(n): for j in range(i, n): # Reverse the subarray seq[i:j+1] and check if we can get a smaller permutation temp_seq = seq[:i] + seq[i:j+1][::-1] + seq[j+1:] # After the first reverse, search again for another subarray to reverse for k in range(n): for l in range(k, n): final_seq = temp_seq[:k] + temp_seq[k:l+1][::-1] + temp_seq[l+1:] if final_seq < min_seq: min_seq = final_seq return min_seq def process_test_cases(T, test_cases): result = [] for case in test_cases: N, sequence = case result.append(reverse_subarray_to_lexico_smallest(sequence)) return result def main(): import sys input = sys.stdin.read data = input().strip().split() index = 0 T = int(data[index]) index += 1 test_cases = [] for _ in range(T): N = int(data[index]) index += 1 sequence = list(map(int, data[index:index + N])) index += N test_cases.append((N, sequence)) results = process_test_cases(T, test_cases) for res in results: print(' '.join(map(str, res))) # Uncomment the line below to run the function if the script is directly run # if __name__ == \\"__main__\\": # main()"},{"question":"def num_unique_paths(n: int, m: int, grid: List[List[str]]) -> int: Finds the number of unique paths from the top-left corner to the bottom-right corner of a grid. You can move only down or right at any point in time, and you cannot pass through cells with walls. >>> num_unique_paths(3, 3, [['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.']]) == 2 >>> num_unique_paths(2, 2, [['.', '.'], ['#', '.']]) == 1 >>> num_unique_paths(1, 2, [['.', '.']]) == 1 >>> num_unique_paths(3, 3, [['.', '#', '.'], ['#', '#', '#'], ['.', '#', '.']]) == 0 >>> num_unique_paths(1, 3, [['.', '.', '.']]) == 1 >>> num_unique_paths(3, 1, [['.'], ['.'], ['.']]) == 1","solution":"def num_unique_paths(n, m, grid): MOD = 1000000007 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD return dp[-1][-1]"},{"question":"def max_difference_subsequence(sequence: List[int]) -> int: Returns the maximum absolute difference between any two elements in the subsequence of the given sequence. Input: max_difference_subsequence([1, 2, 9, 4, 5]) Output: 8 Input: max_difference_subsequence([10, -5, 2, -3, 0]) Output: 15 pass from solution import max_difference_subsequence def test_example_sequence(): assert max_difference_subsequence([1, 2, 9, 4, 5]) == 8 def test_single_element_sequence(): assert max_difference_subsequence([0]) == 0 assert max_difference_subsequence([-10]) == 0 assert max_difference_subsequence([99]) == 0 def test_all_negative_elements(): assert max_difference_subsequence([-5, -2, -1, -7]) == 6 assert max_difference_subsequence([-10, -20, -30, -40]) == 30 def test_mixed_elements(): assert max_difference_subsequence([10, -5, 2, -3, 0]) == 15 assert max_difference_subsequence([-1, 1, -1, 1]) == 2 def test_large_values(): assert max_difference_subsequence([1000000, -1000000]) == 2000000 assert max_difference_subsequence([-1000000, 0, 1000000]) == 2000000","solution":"def max_difference_subsequence(sequence): Returns the maximum absolute difference between any two elements in the subsequence of the given sequence. # Locate the minimum and maximum values in the sequence min_value = min(sequence) max_value = max(sequence) # The maximum absolute difference is obtained by taking the difference between the max and min values return abs(max_value - min_value)"},{"question":"def longest_distinct_substring(s: str) -> int: Develop an algorithm to find the longest substring of distinct characters in a given string. The algorithm should return the length of this longest substring. Args: s (str): A single string of up to 1000 characters consisting solely of lowercase alphabetic characters. Returns: int: The length of the longest substring with all distinct characters. Examples: >>> longest_distinct_substring(\\"abcabcbb\\") 3 >>> longest_distinct_substring(\\"bbbbb\\") 1 >>> longest_distinct_substring(\\"pwwkew\\") 3 pass","solution":"def longest_distinct_substring(s): Returns the length of the longest substring with all distinct characters. char_map = {} max_length = 0 start = 0 for end, char in enumerate(s): if char in char_map and char_map[char] >= start: start = char_map[char] + 1 char_map[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def count_numbers_with_1_and_2(N: int) -> int: Returns the count of numbers from 1 to N inclusive that consist solely of the digits 1 and 2. >>> count_numbers_with_1_and_2(10) 2 >>> count_numbers_with_1_and_2(100) 6 from solution import count_numbers_with_1_and_2 def test_example_1(): assert count_numbers_with_1_and_2(10) == 2 def test_example_2(): assert count_numbers_with_1_and_2(100) == 6 def test_small_number(): assert count_numbers_with_1_and_2(1) == 1 def test_no_valid_numbers(): assert count_numbers_with_1_and_2(0) == 0 def test_larger_number(): assert count_numbers_with_1_and_2(22) == 6 def test_upper_limit(): assert count_numbers_with_1_and_2(1000000) > 0 # Just to ensure it works with the upper limit","solution":"def count_numbers_with_1_and_2(N): Returns the count of numbers from 1 to N inclusive that consist solely of the digits 1 and 2. count = 0 for number in range(1, N + 1): num_str = str(number) if all(digit in '12' for digit in num_str): count += 1 return count"},{"question":"def number_pattern(n: int) -> str: Prints the pattern for a given number n and returns it as a string. >>> number_pattern(1) '1' >>> number_pattern(2) '2 2 2n2 1 2n2 2 2' >>> number_pattern(3) '3 3 3 3 3n3 2 2 2 3n3 2 1 2 3n3 2 2 2 3n3 3 3 3 3' >>> number_pattern(4) '4 4 4 4 4 4 4n4 3 3 3 3 3 4n4 3 2 2 2 3 4n4 3 2 1 2 3 4n4 3 2 2 2 3 4n4 3 3 3 3 3 4n4 4 4 4 4 4 4'","solution":"def number_pattern(n): Prints the pattern for a given number n. matrix_size = 2 * n - 1 matrix = [[0] * matrix_size for _ in range(matrix_size)] for i in range(n): for j in range(i, matrix_size - i): matrix[i][j] = n - i matrix[matrix_size - i - 1][j] = n - i matrix[j][i] = n - i matrix[j][matrix_size - i - 1] = n - i result = \\"n\\".join(\\" \\".join(map(str, row)) for row in matrix) print(result) return result"},{"question":"from typing import List, Tuple def max_sum_non_adjacent_subsequence(arr: List[int]) -> int: Find the maximum sum of a non-adjacent subsequence in an array. >>> max_sum_non_adjacent_subsequence([3, 2, 7, 10, 12]) 22 >>> max_sum_non_adjacent_subsequence([1, 2, 3, 4]) 6 # Your code here def solve_problem(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Solve the problem for multiple test cases. >>> solve_problem(2, [(5, [3, 2, 7, 10, 12]), (4, [1, 2, 3, 4])]) [22, 6] # Your code here # Define the tests for the functions def test_max_sum_non_adjacent_subsequence(): assert max_sum_non_adjacent_subsequence([3, 2, 7, 10, 12]) == 22 assert max_sum_non_adjacent_subsequence([1, 2, 3, 4]) == 6 assert max_sum_non_adjacent_subsequence([4, 1, 1, 4, 2, 1]) == 9 assert max_sum_non_adjacent_subsequence([1]) == 1 assert max_sum_non_adjacent_subsequence([1000000000, 1000000000, 1000000000]) == 2000000000 def test_solve_problem(): input_cases = [ (5, [3, 2, 7, 10, 12]), (4, [1, 2, 3, 4]), ] expected = [22, 6] assert solve_problem(2, input_cases) == expected input_cases = [ (3, [4, 1, 1, 4, 2, 1]), ] expected = [9] assert solve_problem(1, input_cases) == expected input_cases = [ (1, [1]), ] expected = [1] assert solve_problem(1, input_cases) == expected input_cases = [ (3, [1000000000, 1000000000, 1000000000]), ] expected = [2000000000] assert solve_problem(1, input_cases) == expected","solution":"def max_sum_non_adjacent_subsequence(arr): n = len(arr) if n == 0: return 0 elif n == 1: return arr[0] # Dynamic Programming arrays dp = [0] * n chosen = [False] * n dp[0] = arr[0] if arr[1] > arr[0]: dp[1] = arr[1] chosen[1] = True else: dp[1] = arr[0] chosen[0] = True for i in range(2, n): if dp[i-1] > dp[i-2] + arr[i]: dp[i] = dp[i-1] chosen[i] = False else: dp[i] = dp[i-2] + arr[i] chosen[i] = True return dp[-1] def solve_problem(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] arr = test_cases[i][1] result = max_sum_non_adjacent_subsequence(arr) results.append(result) return results"},{"question":"def rearrange_string(s: str, k: int) -> str: Determine whether you can rearrange the string such that the distance between same characters is at least k. If possible, return one such rearranged string, otherwise, return an empty string. >>> rearrange_string(\\"aabbcc\\", 3) \\"abcabc\\" >>> rearrange_string(\\"aaabc\\", 3) \\"\\" pass","solution":"import heapq from collections import Counter, deque def rearrange_string(s, k): Rearranges the string s such that the distance between same characters is at least k. Returns the rearranged string if possible, otherwise returns an empty string. if k <= 1: return s freq_counter = Counter(s) max_heap = [(-freq, char) for char, freq in freq_counter.items()] heapq.heapify(max_heap) queue = deque() result = [] while max_heap: current_freq, current_char = heapq.heappop(max_heap) result.append(current_char) queue.append((current_freq + 1, current_char)) if len(queue) >= k: front_freq, front_char = queue.popleft() if -front_freq > 0: heapq.heappush(max_heap, (front_freq, front_char)) if len(result) == len(s): return ''.join(result) else: return \\"\\""},{"question":"def total_points(n, ranks): Calculate the total points a participant earned across all contests based on their rank. Args: n (int): number of contests ranks (List[int]): ranks of the participant in each contest Returns: int: total points earned >>> total_points(5, [1, 2, 3, 4, 5]) 26 >>> total_points(6, [1, 6, 3, 2, 8, 4]) 25","solution":"def total_points(n, ranks): points_map = {1: 10, 2: 7, 3: 5, 4: 3, 5: 1} total = sum(points_map.get(rank, 0) for rank in ranks) return total # Example usage # n = 6 # ranks = [1, 6, 3, 2, 8, 4] # print(total_points(n, ranks)) # Output: 25"},{"question":"def rotate_string(s: str, n: int) -> str: Rotates the string s to the right by n places. If n is greater than the length of the string, the rotation count is effectively n % length of the string. >>> rotate_string(\\"ABCDE\\", 1) == \\"EABCD\\" >>> rotate_string(\\"ABCDE\\", 2) == \\"DEABC\\" >>> rotate_string(\\"ABCDE\\", 5) == \\"ABCDE\\" >>> rotate_string(\\"ABCDE\\", 7) == \\"DEABC\\" >>> rotate_string(\\"\\", 3) == \\"\\" >>> rotate_string(\\"A\\", 10) == \\"A\\" >>> rotate_string(\\"ABCDE\\", 0) == \\"ABCDE\\" >>> rotate_string(\\"ABCDE\\", 1000001) == \\"EABCD\\"","solution":"def rotate_string(s: str, n: int) -> str: Rotates the string s to the right by n places. If n is greater than the length of the string, the rotation count is effectively n % length of the string. if not s: return s n %= len(s) return s[-n:] + s[:-n]"},{"question":"def solve(S: str) -> str: Finds the first non-repeating character in the string S. If all characters are repeating or the string is empty, returns an underscore \\"_\\". Examples: >>> solve(\\"swiss\\") 'w' >>> solve(\\"aabbcc\\") '_' >>> solve(\\"abcdef\\") 'a' >>> solve(\\"aabbccddee\\") '_' >>> solve(\\"aabcbd\\") 'c' >>> solve(\\"abcdabcd\\") '_' >>> solve(\\"a\\") 'a' >>> solve(\\"\\") '_' >>> solve(\\"aAbBcC\\") 'a'","solution":"def solve(S: str) -> str: Finds the first non-repeating character in the string S. If all characters are repeating or the string is empty, returns an underscore \\"_\\". from collections import OrderedDict char_count = OrderedDict() # Count the occurrences of each character in the string for char in S: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first character that has a count of 1 for char, count in char_count.items(): if count == 1: return char # If no character has a count of 1, return underscore return \\"_\\""},{"question":"def two_sum(nums, target): Returns the indices of the two numbers such that they add up to the target. Args: nums: List of integers. target: Target integer sum. Returns: A list of two integers representing the indices. Examples: >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([3, 3], 6) [0, 1] >>> two_sum([-3, 4, 3, 90], 0) [0, 2] >>> two_sum([-10, 20, 10, -20], 0) [0, 2] >>> two_sum([1000000, 2500000, -1500000], 1000000) [1, 2]","solution":"def two_sum(nums, target): Returns the indices of the two numbers such that they add up to the target. Args: nums: List of integers. target: Target integer sum. Returns: A list of two integers representing the indices. num_map = {} for i, num in enumerate(nums): complement = target - num if complement in num_map: return [num_map[complement], i] num_map[num] = i"},{"question":"from typing import List, Tuple def max_non_overlapping_activities(activities: List[Tuple[int, int]]) -> int: Given a list of activities with their start and end times, find the maximum number of non-overlapping activities you can attend. >>> max_non_overlapping_activities([(1, 3), (2, 4), (3, 5), (7, 8)]) 3 >>> max_non_overlapping_activities([(5, 9), (1, 2), (3, 6), (2, 4), (8, 9)]) 3","solution":"def max_non_overlapping_activities(activities): # Sort activities by their end times activities.sort(key=lambda x: x[1]) count = 0 end_time = 0 for activity in activities: if activity[0] >= end_time: count += 1 end_time = activity[1] return count"},{"question":"def max_difference(arr): Returns the maximum difference between any two elements such that the larger element appears after the smaller element in the list. Parameters: arr (list): List of integers Returns: int: Maximum difference, or 0 if no such pair exists >>> max_difference([7, 1, 5, 3, 6, 4]) == 5 >>> max_difference([1, 2, 3, 4, 5]) == 4 >>> max_difference([5, 4, 3, 2, 1]) == 0 >>> max_difference([3, 1, 4, 1, 5, 9, 2, 6, 5]) == 8 >>> max_difference([1, 1, 1, 1]) == 0 >>> max_difference([]) == 0 >>> max_difference([1]) == 0 >>> max_difference([-2, -3, -10, -2, -4, -8]) == 8 >>> max_difference([-10, -20, -30, 0, 5]) == 35","solution":"def max_difference(arr): Returns the maximum difference between any two elements such that the larger element appears after the smaller element in the list. Parameters: arr (list): List of integers Returns: int: Maximum difference, or 0 if no such pair exists if not arr or len(arr) < 2: return 0 min_element = arr[0] max_diff = 0 for num in arr[1:]: if num > min_element: max_diff = max(max_diff, num - min_element) min_element = min(min_element, num) return max_diff"},{"question":"def perform_operations(n: int, operations: List[str]) -> List[int]: Perform a series of operations on an initially empty array. Args: n (int): The number of operations. operations (list): List of strings, where each string represents an operation. Returns: list: List of results from \`largest\` operations. >>> perform_operations(10, [\\"add 5\\", \\"add 3\\", \\"largest\\", \\"add 10\\", \\"largest\\", \\"remove 5\\", \\"largest\\", \\"remove 10\\", \\"largest\\", \\"remove 3\\", \\"largest\\"]) [5, 10, 10, 3, -1] >>> perform_operations(7, [\\"add 4\\", \\"add 4\\", \\"largest\\", \\"remove 4\\", \\"largest\\", \\"remove 4\\", \\"largest\\"]) [4, 4, -1] >>> perform_operations(2, [\\"add 100\\", \\"largest\\"]) [100] >>> perform_operations(3, [\\"remove 5\\", \\"remove 10\\", \\"largest\\"]) [-1] >>> perform_operations(6, [\\"add 1\\", \\"add 2\\", \\"remove 1\\", \\"largest\\", \\"remove 2\\", \\"largest\\"]) [2, -1] >>> perform_operations(8, [\\"add 7\\", \\"add 7\\", \\"add 7\\", \\"remove 7\\", \\"largest\\", \\"remove 7\\", \\"largest\\", \\"remove 7\\", \\"largest\\"]) [7, 7, -1] pass","solution":"def perform_operations(n, operations): Perform a series of operations on an initially empty array. Args: n (int): The number of operations. operations (list): List of strings, where each string represents an operation. Returns: list: List of results from \`largest\` operations. from heapq import heappush, heappop max_heap = [] element_count = {} result = [] for operation in operations: if operation.startswith(\\"add\\"): _, x = operation.split() x = int(x) heappush(max_heap, -x) # push negative value to simulate max heap if x in element_count: element_count[x] += 1 else: element_count[x] = 1 elif operation.startswith(\\"remove\\"): _, x = operation.split() x = int(x) if x in element_count and element_count[x] > 0: element_count[x] -= 1 elif operation == \\"largest\\": while max_heap and element_count[-max_heap[0]] == 0: heappop(max_heap) if max_heap: result.append(-max_heap[0]) else: result.append(-1) return result"},{"question":"def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Returns the number of unique paths from the top-left corner to the bottom-right corner of the grid, considering obstacles. >>> unique_paths_with_obstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> unique_paths_with_obstacles([[0, 1, 0], [0, 1, 0], [0, 0, 0]]) 1 >>> unique_paths_with_obstacles([[0, 1, 0], [1, 1, 0], [0, 0, 0]]) 0 >>> unique_paths_with_obstacles([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 6 >>> unique_paths_with_obstacles([[1, 0], [0, 0]]) 0 >>> unique_paths_with_obstacles([[0, 0], [0, 1]]) 0 >>> unique_paths_with_obstacles([[0]]) 1","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left corner to the bottom-right corner of the grid, considering obstacles. m = len(grid) n = len(grid[0]) # If the start or end is blocked, return 0 paths. if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 # Initialize a DP array with zeros. dp = [[0] * n for _ in range(m)] # Starting point dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"def has_subarray_with_sum(t: int, test_cases: List[Dict[str, Any]]) -> List[str]: Determine if there exists a subarray whose sum is equal to a given integer k. Args: t (int): Number of test cases. test_cases (List[Dict[str, Any]]): List of test cases, each containing 'n', 'k', and 'array'. Returns: List[str]: For each test case, output \\"YES\\" if there exists a subarray whose sum is exactly k. Otherwise, output \\"NO\\". Example: >>> t = 3 >>> test_cases = [ ... {'n': 5, 'k': 12, 'array': [1, 2, 3, 7, 5]}, ... {'n': 10, 'k': 3, 'array': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]}, ... {'n': 4, 'k': -10, 'array': [1, -1, -1, -1]} ... ] >>> has_subarray_with_sum(t, test_cases) ['YES', 'YES', 'NO']","solution":"def has_subarray_with_sum(t, test_cases): results = [] for case in test_cases: n, k, array = case['n'], case['k'], case['array'] found = False prefix_sum_set = set() current_sum = 0 for num in array: current_sum += num if current_sum == k or (current_sum - k) in prefix_sum_set: found = True break prefix_sum_set.add(current_sum) results.append(\\"YES\\" if found else \\"NO\\") return results"},{"question":"def product_except_self(nums): Given a list of integers, returns a new list where each element is the product of all elements in the original list except for the element at the same index. Args: nums (List[int]): List of integers Returns: List[int]: A new list of products Examples: >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_except_self([10]) [1] >>> product_except_self([3, 7]) [7, 3] >>> product_except_self([1, 0, 3, 0]) [0, 0, 0, 0] >>> product_except_self([1, 2, 0, 4]) [0, 0, 8, 0] >>> product_except_self([-1, 2, -3, 4]) [-24, 12, -8, 6] >>> product_except_self([-1, -2, -3, -4]) [-24, -12, -8, -6] pass","solution":"def product_except_self(nums): Given a list of integers, returns a new list where each element is the product of all elements in the original list except for the element at the same index. Args: nums (List[int]): List of integers Returns: List[int]: A new list of products length = len(nums) # Initialize the result array with 1s result = [1] * length # Calculate products of all elements before each index left_product = 1 for i in range(length): result[i] = left_product left_product *= nums[i] # Calculate products of all elements after each index and multiply with the left products right_product = 1 for i in range(length - 1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"def minPathCost(grid): Computes the minimum cost to traverse from the top-left to the bottom-right corner in a grid, moving only right or down. :param grid: List[List[int]], the grid with integer costs. :return: int, minimum path cost. >>> minPathCost([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 7 >>> minPathCost([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 21 >>> minPathCost([ ... [1, 2, 3, 4] ... ]) == 10 >>> minPathCost([ ... [1], ... [2], ... [3], ... [4] ... ]) == 10 >>> minPathCost([ ... [5] ... ]) == 5 >>> minPathCost([ ... [1, 100], ... [1, 1] ... ]) == 3","solution":"def minPathCost(grid): Computes the minimum cost to traverse from the top-left to the bottom-right corner in a grid, moving only right or down. :param grid: List[List[int]], the grid with integer costs. :return: int, minimum path cost. if not grid or not grid[0]: return 0 M = len(grid) N = len(grid[0]) # Create DP table initialized with 0's dp = [[0]*N for _ in range(M)] # Initialize the starting point dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, N): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, M): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, M): for j in range(1, N): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[M-1][N-1]"},{"question":"def staircase_ways(n: int) -> int: Returns the number of distinct ways to climb a staircase of height n, where each time you can either climb 1 step, 2 steps, or 3 steps. Examples: >>> staircase_ways(0) 1 >>> staircase_ways(1) 1 >>> staircase_ways(2) 2 >>> staircase_ways(3) 4 >>> staircase_ways(4) 7 >>> staircase_ways(5) 13 >>> staircase_ways(6) 24","solution":"def staircase_ways(n): Returns the number of distinct ways to climb a staircase of height n, where each time you can either climb 1 step, 2 steps, or 3 steps. if n == 0: return 1 elif n == 1: return 1 elif n == 2: return 2 # Initialize the base cases dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 dp[2] = 2 # Fill the dp array using the recurrence relation for i in range(3, n + 1): dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] return dp[n]"},{"question":"def longest_increasing_prefix(n: int, sequence: List[int]) -> int: Determine the length of the longest increasing prefix after removing at most one element from the sequence. Parameters: n (int): The length of the sequence. sequence (List[int]): The list of integers in the sequence. Returns: int: The length of the longest increasing prefix. >>> longest_increasing_prefix(6, [10, 20, 30, 50, 60, 70]) 6 >>> longest_increasing_prefix(6, [10, 20, 10, 30, 40, 50]) 5 >>> longest_increasing_prefix(1, [1]) 1 >>> longest_increasing_prefix(6, [10, 20, 15, 25, 30, 35]) 5 >>> longest_increasing_prefix(3, [3, 2, 1]) 1 >>> longest_increasing_prefix(7, [1, 3, 5, 4, 7, 8, 9]) 6 >>> longest_increasing_prefix(5, [1000000000, 999999999, 1000000001, 1000000002, 1000000003]) 4 pass","solution":"def longest_increasing_prefix(n, sequence): # Check for edge case of sequence with single element if n == 1: return 1 lengths = [] # Calculate length of increasing prefix without removal length = 1 for i in range(1, n): if sequence[i] > sequence[i-1]: length += 1 else: break lengths.append(length) # Calculate lengths of increasing prefixes by removing each element in turn (without actually removing) for remove_index in range(1, n): length = 1 prev = sequence[0] used_removal = False for i in range(1, n): if i == remove_index: continue if sequence[i] > prev: length += 1 prev = sequence[i] elif not used_removal: used_removal = True continue else: break lengths.append(length) return max(lengths)"},{"question":"def can_fit_chocolate_bars(test_cases): Determine if any package boxes can perfectly hold one or more chocolate bars without rotation. Args: test_cases (List[Tuple[int, int, int, List[Tuple[int, int]]]]): List of tuples containing the dimensions of the chocolate bar, the number of boxes, and a list of tuples representing the dimensions of the boxes. Returns: List[str]: List containing \\"yes\\" if at least one box can perfectly hold one or more chocolate bars, otherwise \\"no\\". >>> can_fit_chocolate_bars([(4, 5, 2, [(8, 10), (9, 9)]), (6, 7, 1, [(14, 14)])]) [\\"yes\\", \\"no\\"] >>> can_fit_chocolate_bars([(4, 5, 2, [(7, 8), (6, 6)])]) [\\"no\\"] pass def parse_input(input_data): Parses the input data for test cases. Args: input_data (str): Multiline string containing the number of test cases, and for each test case, the dimensions of the chocolate bar and the available boxes. Returns: List[Tuple[int, int, int, List[Tuple[int, int]]]]: Parsed input as a list of tuples containing the dimensions of the chocolate bar, the number of boxes, and a list of tuples representing the dimensions of the boxes. >>> parse_input(\\"2n4 5 2n8 10n9 9n6 7 1n14 14n\\") [(4, 5, 2, [(8, 10), (9, 9)]), (6, 7, 1, [(14, 14)])] >>> parse_input(\\"1n4 5 2n7 8n6 6n\\") [(4, 5, 2, [(7, 8), (6, 6)])] pass","solution":"def can_fit_chocolate_bars(test_cases): results = [] for test in test_cases: bar_width, bar_height, num_boxes, boxes = test fit = False for box in boxes: box_width, box_height = box # Check if the box can perfectly fit one or more bars without leaving empty space if (box_width % bar_width == 0 and box_height % bar_height == 0) or (box_width % bar_height == 0 and box_height % bar_width == 0): fit = True break if fit: results.append(\\"yes\\") else: results.append(\\"no\\") return results def parse_input(input_data): lines = input_data.strip().split('n') num_tests = int(lines[0]) pointer = 1 test_cases = [] for _ in range(num_tests): bar_width, bar_height, num_boxes = map(int, lines[pointer].split()) pointer += 1 boxes = [] for _ in range(num_boxes): box_width, box_height = map(int, lines[pointer].split()) pointer += 1 boxes.append((box_width, box_height)) test_cases.append((bar_width, bar_height, num_boxes, boxes)) return test_cases"},{"question":"def max_non_overlapping_product_storages(n: int, storages: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping product storages. Parameters: n (int): the number of products. storages (list of tuples): list of tuples where each tuple contains the start (l_i) and end (r_i) of a product storage area. Returns: int: The maximum number of non-overlapping product storages. >>> max_non_overlapping_product_storages(4, [(1, 6), (2, 8), (3, 5), (7, 9)]) 2 >>> max_non_overlapping_product_storages(3, [(1, 4), (2, 5), (5, 6)]) 2 from typing import List, Tuple","solution":"def max_non_overlapping_product_storages(n, storages): Returns the maximum number of non-overlapping product storages. Parameters: n (int): the number of products. storages (list of tuples): list of tuples where each tuple contains the start (l_i) and end (r_i) of a product storage area. Returns: int: The maximum number of non-overlapping product storages. # Sort the storages based on their end points storages.sort(key=lambda x: x[1]) # Initialize variables end = -1 count = 0 # Iterate over sorted storages to count non-overlapping storages for l, r in storages: if l > end: count += 1 end = r return count # Example Usage n = 4 storages = [(1, 6), (2, 8), (3, 5), (7, 9)] print(max_non_overlapping_product_storages(n, storages)) # Output: 2"},{"question":"def has_nice_subsequence(n, sequence): Check if there exists at least one subsequence whose sum is exactly divisible by 13. :param n: Number of elements in the sequence :param sequence: List of integers in the sequence :return: \\"YES\\" if such a subsequence exists, otherwise \\"NO\\" Example: >>> has_nice_subsequence(5, [1, 2, 3, 4, 5]) \\"YES\\" >>> has_nice_subsequence(3, [6, 9, 14]) \\"NO\\" >>> has_nice_subsequence(4, [26, 39, 78, 520]) \\"YES\\"","solution":"def has_nice_subsequence(n, sequence): Check if there exists at least one subsequence whose sum is exactly divisible by 13. :param n: Number of elements in the sequence :param sequence: List of integers in the sequence :return: \\"YES\\" if such a subsequence exists, otherwise \\"NO\\" from itertools import combinations # Check all possible subsequences for r in range(1, n + 1): for subseq in combinations(sequence, r): if sum(subseq) % 13 == 0: return \\"YES\\" return \\"NO\\""},{"question":"def can_sort_array_after_k_operations(n: int, k: int, m: int, arr: List[int]) -> str: Determines if it's possible to sort the array by performing exactly k reversals of subarrays of length m. >>> can_sort_array_after_k_operations(5, 2, 3, [4, 2, 3, 1, 5]) == \\"YES\\" >>> can_sort_array_after_k_operations(4, 1, 2, [3, 1, 2, 4]) == \\"NO\\"","solution":"def can_sort_array_after_k_operations(n, k, m, arr): Determines if it's possible to sort the array by performing exactly k reversals of subarrays of length m. if k * m >= n: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List def smallestSubstringContainingUniqueChars(originalString: str) -> int: Determine the smallest substring that contains all unique characters present in the original string and return its length. >>> smallestSubstringContainingUniqueChars(\\"abac\\") == 3 >>> smallestSubstringContainingUniqueChars(\\"aaaa\\") == 1 >>> smallestSubstringContainingUniqueChars(\\"abbcbcba\\") == 3 # Your code here def test_example_case_1(): assert smallestSubstringContainingUniqueChars(\\"abac\\") == 3 def test_example_case_2(): assert smallestSubstringContainingUniqueChars(\\"aaaa\\") == 1 def test_example_case_3(): assert smallestSubstringContainingUniqueChars(\\"abbcbcba\\") == 3 def test_all_same_characters(): assert smallestSubstringContainingUniqueChars(\\"bbbbbb\\") == 1 def test_unique_characters(): assert smallestSubstringContainingUniqueChars(\\"abcdef\\") == 6 def test_repeating_patterns(): assert smallestSubstringContainingUniqueChars(\\"abcabcabc\\") == 3 def test_mixed_characters(): assert smallestSubstringContainingUniqueChars(\\"aabbccabc\\") == 3 def test_long_string(): assert smallestSubstringContainingUniqueChars(\\"a\\" * 500 + \\"b\\" * 500) == 2","solution":"def smallestSubstringContainingUniqueChars(originalString): from collections import defaultdict unique_chars = set(originalString) required_chars_count = len(unique_chars) char_count = defaultdict(int) min_length = float('inf') left = 0 formed = 0 for right, char in enumerate(originalString): char_count[char] += 1 if char_count[char] == 1: # First occurrence of the character formed += 1 while formed == required_chars_count: min_length = min(min_length, right - left + 1) char_count[originalString[left]] -= 1 if char_count[originalString[left]] == 0: formed -= 1 left += 1 return min_length"},{"question":"def count_ocean_view_buildings(heights): Returns the number of buildings that have a perfect ocean view. Args: heights (list of int): The heights of the buildings. Returns: int: The number of buildings with a perfect ocean view. >>> count_ocean_view_buildings([4, 2, 3, 1, 5, 4]) == 2 >>> count_ocean_view_buildings([1, 2, 3, 4, 5]) == 1 >>> count_ocean_view_buildings([5, 4, 3, 2, 1]) == 5 >>> count_ocean_view_buildings([5, 5, 5, 5, 5]) == 1 >>> count_ocean_view_buildings([1, 3, 2, 4, 2]) == 2 >>> count_ocean_view_buildings([10]) == 1 >>> count_ocean_view_buildings([10, 5]) == 2 >>> count_ocean_view_buildings([5, 10]) == 1 >>> count_ocean_view_buildings([]) == 0","solution":"def count_ocean_view_buildings(heights): Returns the number of buildings that have a perfect ocean view. Args: heights (list of int): The heights of the buildings. Returns: int: The number of buildings with a perfect ocean view. n = len(heights) if n == 0: return 0 max_height_so_far = 0 ocean_view_count = 0 # Traverse from right to left for i in range(n-1, -1, -1): if heights[i] > max_height_so_far: ocean_view_count += 1 max_height_so_far = heights[i] return ocean_view_count"},{"question":"from typing import List def find_lexicographically_smallest(T: int, strings: List[str]) -> List[str]: For each input string, find the lexicographically smallest string achievable by performing exactly one of the given operations (reverse any segment or swap any two characters). Args: T: int : Number of test cases strings: List[str]: List of input strings Returns: List[str]: List of lexicographically smallest strings for each input string Examples: >>> find_lexicographically_smallest(1, [\\"bacd\\"]) [\\"abcd\\"] >>> find_lexicographically_smallest(1, [\\"ab\\"]) [\\"ab\\"] >>> find_lexicographically_smallest(1, [\\"zxy\\"]) [\\"xzy\\"]","solution":"def find_lexicographically_smallest(T, strings): For each input string, find the lexicographically smallest string achievable by performing exactly one of the given operations (reverse any segment or swap any two characters). results = [] for S in strings: min_string = S # Try all possible subsegment reversals n = len(S) for i in range(n): for j in range(i + 1, n + 1): reversed_segment = S[:i] + S[i:j][::-1] + S[j:] min_string = min(min_string, reversed_segment) # Try all possible two character swaps s_list = list(S) for i in range(n): for j in range(i + 1, n): s_list[i], s_list[j] = s_list[j], s_list[i] swapped_string = ''.join(s_list) min_string = min(min_string, swapped_string) # Swap back s_list[i], s_list[j] = s_list[j], s_list[i] results.append(min_string) return results"},{"question":"def max_subarray_sum(nums): Returns the largest sum of a contiguous sublist. >>> max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) == 6 >>> max_subarray_sum([1, 2, 3, 4]) == 10 >>> max_subarray_sum([-1, -2, -3, -4]) == -1 >>> max_subarray_sum([4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7 >>> max_subarray_sum([3, -2, 5, -1]) == 6 >>> max_subarray_sum([3, -1, -1, 4, -1]) == 5 >>> max_subarray_sum([0]) == 0 >>> max_subarray_sum([-1]) == -1 >>> max_subarray_sum([1]) == 1 >>> max_subarray_sum([5, -3, 5]) == 7","solution":"def max_subarray_sum(nums): Returns the largest sum of a contiguous sublist. max_sum = nums[0] current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def min_L_moves(N: int, M: int, arena: List[str], sx: int, sy: int, tx: int, ty: int) -> int: Determines the shortest number of 'L' shaped moves required to move from (sx, sy) to (tx, ty) in an N x M grid arena. :param N: Number of rows :param M: Number of columns :param arena: NxM grid arena where '.' denotes free space and '#' denotes blocked cell :param sx: Starting x-coordinate :param sy: Starting y-coordinate :param tx: Target x-coordinate :param ty: Target y-coordinate :return: Minimum number of 'L' shaped moves or -1 if not possible >>> N, M = 5, 5 >>> arena = [ '.....', '.....', '.#.', '.....', '.....' ] >>> sx, sy, tx, ty = 0, 0, 4, 4 >>> min_L_moves(N, M, arena, sx, sy, tx, ty) 4 >>> sx, sy, tx, ty = 0, 0, 2, 2 >>> min_L_moves(N, M, arena, sx, sy, tx, ty) -1","solution":"from collections import deque def min_L_moves(N, M, arena, sx, sy, tx, ty): Determines the shortest number of 'L' shaped moves required to move from (sx, sy) to (tx, ty) in an N x M grid arena. :param N: Number of rows :param M: Number of columns :param arena: NxM grid arena where '.' denotes free space and '#' denotes blocked cell :param sx: Starting x-coordinate :param sy: Starting y-coordinate :param tx: Target x-coordinate :param ty: Target y-coordinate :return: Minimum number of 'L' shaped moves or -1 if not possible # Define possible L-shaped moves moves = [ (-2, -1), (-2, 1), (2, -1), (2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2) ] # Check if the start or target is blocked if arena[sx][sy] == '#' or arena[tx][ty] == '#': return -1 # BFS Setup queue = deque([(sx, sy, 0)]) visited = set((sx, sy)) while queue: x, y, d = queue.popleft() # If we reach the target, return the distance if (x, y) == (tx, ty): return d # Try all possible L-shaped moves for dx, dy in moves: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and (nx, ny) not in visited and arena[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny, d + 1)) # If target is not reachable return -1"},{"question":"def can_divide_into_k_palindromes(k: int, s: str) -> str: Determines if the string \`s\` can be divided into exactly \`k\` palindromic substrings. Args: k (int): The number of substrings. s (str): The input string. Returns: str: \\"YES\\" if possible, otherwise \\"NO\\". Examples: >>> can_divide_into_k_palindromes(3, 'ababa') 'YES' >>> can_divide_into_k_palindromes(2, 'abcd') 'NO'","solution":"def can_divide_into_k_palindromes(k, s): Determines if the string \`s\` can be divided into exactly \`k\` palindromic substrings. n = len(s) if k > n: return \\"NO\\" # Helper function to check if a string is a palindrome def is_palindrome(sub): return sub == sub[::-1] # DP table where dp[i][j] is True if s[i:j+1] is a palindrome dp = [[False] * n for _ in range(n)] # Fill the DP table for palindromes for i in range(n): for j in range(i, n): if is_palindrome(s[i:j+1]): dp[i][j] = True # Memoization table to remember results memo = {} # Helper function for the main DP recursion def can_split_at_most_k_palindromes(start, parts): if (start, parts) in memo: return memo[(start, parts)] if start == n and parts == 0: return True if parts <= 0: return False for end in range(start, n): if dp[start][end] and can_split_at_most_k_palindromes(end + 1, parts - 1): memo[(start, parts)] = True return True memo[(start, parts)] = False return False # Determine if we can divide into exactly \`k\` palindromic substrings result = \\"YES\\" if can_split_at_most_k_palindromes(0, k) else \\"NO\\" return result"},{"question":"import math from functools import reduce def reverse_digits(n: int) -> int: Reverse the digits of an integer. >>> reverse_digits(321) 123 >>> reverse_digits(987) 789 >>> reverse_digits(100) 1 pass def gcd_of_list(lst: List[int]) -> int: Find the greatest common divisor (GCD) of a list of integers. >>> gcd_of_list([123, 134, 932]) 1 >>> gcd_of_list([789, 654]) 3 >>> gcd_of_list([24, 36, 48]) 12 pass def solve_puzzle(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given a list of test cases, each containing numbers with reversed digits, return the GCD of the original numbers for each test case. >>> solve_puzzle([(3, [321, 431, 239]), (2, [987, 456])]) [1, 3] >>> solve_puzzle([(3, [432, 555, 678]), (4, [21, 12, 33, 3])]) [3, 3] pass","solution":"import math from functools import reduce def reverse_digits(n): return int(str(n)[::-1]) def gcd_of_list(lst): return reduce(math.gcd, lst) def solve_puzzle(test_cases): results = [] for case in test_cases: L, nums = case original_nums = [reverse_digits(num) for num in nums] gcd_result = gcd_of_list(original_nums) results.append(gcd_result) return results"},{"question":"def max_rating_within_budget(N: int, budget: int, items: List[Tuple[int, int]]) -> int: Determine the highest total rating possible within the budget constraint. >>> max_rating_within_budget(4, 100, [(20, 8), (50, 9), (30, 5), (70, 7)]) 22 >>> max_rating_within_budget(3, 10, [(20, 8), (50, 9), (30, 5)]) 0 >>> max_rating_within_budget(1, 100, [(70, 15)]) 15 >>> max_rating_within_budget(3, 150, [(20, 10), (50, 15), (30, 5)]) 30 >>> max_rating_within_budget(3, 100, [(50, 10), (50, 20), (50, 5)]) 30 >>> max_rating_within_budget(0, 100, []) 0 >>> max_rating_within_budget(4, 100, [(40, 5), (30, 6), (10, 2), (20, 7)]) 20","solution":"def max_rating_within_budget(N, budget, items): items.sort(key=lambda x: x[0]) dp = [0] * (budget + 1) for price, rating in items: for b in range(budget, price - 1, -1): dp[b] = max(dp[b], dp[b - price] + rating) return dp[budget] def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) budget = int(data[1]) items = [] index = 2 for _ in range(N): price = int(data[index]) rating = int(data[index + 1]) items.append((price, rating)) index += 2 result = max_rating_within_budget(N, budget, items) print(result)"},{"question":"def calculate_branch_visit_times(m: int, logs: List[str]) -> List[int]: Calculate the total visit time for each branch. Parameters: m (int): The number of branches. logs (list): List of strings, each representing a log entry. Returns: list: Total visit time for each branch. >>> calculate_branch_visit_times(2, [ \\"1:100:start:5\\", \\"1:100:end:10\\", \\"0:101:start:1\\", \\"1:102:start:11\\", \\"1:102:end:15\\", \\"0:101:end:3\\" ]) [2, 9] >>> calculate_branch_visit_times(2, [ \\"0:200:start:3\\", \\"0:200:end:7\\", \\"0:201:start:8\\", \\"0:201:end:10\\", \\"1:300:start:1\\", \\"1:300:end:5\\" ]) [6, 4] >>> calculate_branch_visit_times(3, [ \\"0:200:start:2\\", \\"0:200:end:5\\", \\"1:300:start:7\\", \\"1:300:end:9\\" ]) [3, 2, 0] >>> calculate_branch_visit_times(3, [ \\"2:400:start:1\\", \\"2:400:end:4\\", \\"0:100:start:0\\", \\"0:100:end:2\\", \\"1:200:start:3\\", \\"1:200:end:6\\" ]) [2, 3, 3] >>> calculate_branch_visit_times(1, [ \\"0:100:start:1\\", \\"0:100:end:5\\" ]) [4]","solution":"def calculate_branch_visit_times(m, logs): Calculate the total visit time for each branch. Parameters: m (int): The number of branches. logs (list): List of strings, each representing a log entry. Returns: list: Total visit time for each branch. from collections import defaultdict branch_times = defaultdict(int) ongoing_visits = {} for log in logs: parts = log.split(':') branch_id = int(parts[0]) visit_id = int(parts[1]) action = parts[2] timestamp = int(parts[3]) if action == \\"start\\": ongoing_visits[visit_id] = timestamp elif action == \\"end\\": start_time = ongoing_visits.pop(visit_id, None) if start_time is not None: branch_times[branch_id] += (timestamp - start_time) result = [0] * m for branch_id, total_time in branch_times.items(): result[branch_id] = total_time return result"},{"question":"def morse_encrypt(text: str) -> str: Encrypt the given text to Morse code. >>> morse_encrypt(\\"hello world\\") \\".... . .-.. .-.. --- / .-- --- .-. .-.. -..\\" >>> morse_encrypt(\\"sos\\") \\"... --- ...\\" >>> morse_encrypt(\\"a\\") \\".-\\" >>> morse_encrypt(\\"abcd\\") \\".- -... -.-. -..\\" >>> morse_encrypt(\\"0123456789\\") \\"----- .---- ..--- ...-- ....- ..... -.... --... ---.. ----.\\" pass def morse_decrypt(morse_code: str) -> str: Decrypt the given Morse code to text. >>> morse_decrypt(\\".... . .-.. .-.. --- / .-- --- .-. .-.. -..\\") \\"hello world\\" >>> morse_decrypt(\\"... --- ...\\") \\"sos\\" >>> morse_decrypt(\\".-\\") \\"a\\" >>> morse_decrypt(\\".- -... -.-. -..\\") \\"abcd\\" >>> morse_decrypt(\\"----- .---- ..--- ...-- ....- ..... -.... --... ---.. ----.\\") \\"0123456789\\" pass","solution":"MORSE_CODE_DICT = { 'a': '.-', 'b': '-...', 'c': '-.-.', 'd': '-..', 'e': '.', 'f': '..-.', 'g': '--.', 'h': '....', 'i': '..', 'j': '.---', 'k': '-.-', 'l': '.-..', 'm': '--', 'n': '-.', 'o': '---', 'p': '.--.', 'q': '--.-', 'r': '.-.', 's': '...', 't': '-', 'u': '..-', 'v': '...-', 'w': '.--', 'x': '-..-', 'y': '-.--', 'z': '--..', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.' } REVERSE_MORSE_CODE_DICT = {v: k for k, v in MORSE_CODE_DICT.items()} def morse_encrypt(text): Encrypt the given text to Morse code. words = text.split(' ') morse_code = ' / '.join(' '.join(MORSE_CODE_DICT[char] for char in word) for word in words) return morse_code def morse_decrypt(morse_code): Decrypt the given Morse code to text. words = morse_code.split(' / ') text = ' '.join(''.join(REVERSE_MORSE_CODE_DICT[char] for char in word.split()) for word in words) return text"},{"question":"from typing import List def closest_popularity_sum(n: int, m: int, t: int, scores: List[int]) -> int: Find the subset of exactly m articles whose sum of popularity scores is closest to the target value t. >>> closest_popularity_sum(7, 3, 50, [10, 20, 30, 25, 5, 15, 40]) 50 >>> closest_popularity_sum(5, 2, 32, [14, 21, 17, 8, 13]) 31 >>> closest_popularity_sum(4, 2, 18, [9, 12, 10, 7]) 19 >>> closest_popularity_sum(5, 3, 9, [3, 3, 3, 3, 3]) 9 >>> closest_popularity_sum(1, 1, 5, [5]) 5 >>> closest_popularity_sum(6, 3, 100, [5, 10, 15, 20, 25, 30]) 75","solution":"from itertools import combinations def closest_popularity_sum(n, m, t, scores): closest_sum = None min_diff = float('inf') for subset in combinations(scores, m): subset_sum = sum(subset) diff = abs(subset_sum - t) if diff < min_diff: min_diff = diff closest_sum = subset_sum return closest_sum"},{"question":"from typing import List def can_form_palindrome(sentence: str) -> str: Determines if the words in the sentence can be rearranged to form a palindrome. >>> can_form_palindrome(\\"race car\\") 'YES' >>> can_form_palindrome(\\"a man a plan a canal panama\\") 'YES' >>> can_form_palindrome(\\"hello world\\") 'NO' def process_tests(test_cases: List[str]) -> List[str]: Processes multiple test cases. >>> process_tests([\\"race car\\", \\"a man a plan a canal panama\\", \\"hello world\\"]) ['YES', 'YES', 'NO'] >>> process_tests([\\"a\\", \\"abc\\", \\"abccba\\"]) ['YES', 'NO', 'YES']","solution":"def can_form_palindrome(sentence): Determines if the words in the sentence can be rearranged to form a palindrome. # Remove spaces and ignore all non-alphanumeric characters and convert to lowercase cleaned_sentence = ''.join(sentence.split()) # Count the frequency of each character char_freq = {} for char in cleaned_sentence: if char in char_freq: char_freq[char] += 1 else: char_freq[char] = 1 # Check the number of characters that have odd frequencies odd_count = 0 for count in char_freq.values(): if count % 2 != 0: odd_count += 1 # If the number of odd frequencies is more than 1, it cannot form a palindrome return \\"NO\\" if odd_count > 1 else \\"YES\\" def process_tests(test_cases): Processes multiple test cases. return [can_form_palindrome(sentence) for sentence in test_cases]"},{"question":"def findUniqueElement(arr: List[int]) -> int: Returns the element that appears only once in the list. >>> findUniqueElement([5]) 5 >>> findUniqueElement([4, 1, 2, 1, 2]) 4 >>> findUniqueElement([9, 3, 3, 6, 6]) 9 >>> findUniqueElement([7, 8, 8, 7, 5]) 5 >>> findUniqueElement([i for i in range(1, 1000001)] * 2 + [9999999]) 9999999","solution":"def findUniqueElement(arr): Returns the element that appears only once in the list. unique_element = 0 for num in arr: unique_element ^= num return unique_element"},{"question":"def count_rewards(n: int, distances: List[int]) -> int: Returns the number of rewards based on the distances run each day. >>> count_rewards(5, [1, 2, 3, 2, 4]) 3 >>> count_rewards(6, [5, 5, 6, 6, 7, 4]) 2","solution":"def count_rewards(n, distances): Returns the number of rewards based on the distances run each day. rewards = 0 for i in range(1, n): if distances[i] > distances[i - 1]: rewards += 1 return rewards"},{"question":"def evaluate_expression(s: str) -> int: This function evaluates a mathematical expression string containing positive integers, addition (+), multiplication (*), and parentheses, following the correct order of operations. >>> evaluate_expression(\\"3+2*2\\") == 7 >>> evaluate_expression(\\"2*(3+4)\\") == 14 >>> evaluate_expression(\\"2+3*4\\") == 14 >>> evaluate_expression(\\"(2+3)*4\\") == 20 >>> evaluate_expression(\\"2+(3*4)\\") == 14 >>> evaluate_expression(\\"2*(3+4*5)\\") == 46 >>> evaluate_expression(\\"0+0\\") == 0 >>> evaluate_expression(\\"1+0\\") == 1 >>> evaluate_expression(\\"0*1\\") == 0","solution":"def evaluate_expression(s): This function evaluates a mathematical expression string containing positive integers, addition (+), multiplication (*), and parentheses, following the correct order of operations. try: return eval(s) except (SyntaxError, NameError): raise ValueError(f\\"Invalid expression: {s}\\") # Example usage print(evaluate_expression(\\"3+2*2\\")) # Output: 7 print(evaluate_expression(\\"2*(3+4)\\")) # Output: 14 print(evaluate_expression(\\"2+3*4\\")) # Output: 14"},{"question":"def minimizeFines(P: int, projects: List[Dict[str, Union[int, List[int]]]]) -> int: Function to minimize the total fines for all the projects given the constraints. Parameters: - P: int, number of projects - projects: list of dictionaries, each dictionary contains information about a project: \\"N_i\\": number of tasks, \\"times\\": list of task durations, \\"deadlines\\": list of deadlines for tasks, \\"fines\\": list of fines for missing deadlines for tasks Returns: - int: the minimum total fine incurred. Example: >>> minimizeFines(1, [{\\"N_i\\": 2, \\"times\\": [2, 3], \\"deadlines\\": [3, 10], \\"fines\\": [10, 20]}]) 0 >>> minimizeFines(2, [ {\\"N_i\\": 3, \\"times\\": [1, 1, 1], \\"deadlines\\": [2, 3, 3], \\"fines\\": [10, 20, 30]}, {\\"N_i\\": 2, \\"times\\": [5, 2], \\"deadlines\\": [7, 5], \\"fines\\": [15, 25]} ]) 25 import pytest def test_single_project_no_fine(): P = 1 projects = [ { \\"N_i\\": 2, \\"times\\": [2, 3], \\"deadlines\\": [3, 10], \\"fines\\": [10, 20] }] assert minimizeFines(P, projects) == 0 def test_single_project_with_fine(): P = 1 projects = [ { \\"N_i\\": 3, \\"times\\": [2, 2, 5], \\"deadlines\\": [2, 4, 6], \\"fines\\": [10, 20, 30] }] assert minimizeFines(P, projects) == 30 def test_multiple_projects_with_and_without_fine(): P = 2 projects = [ { \\"N_i\\": 3, \\"times\\": [1, 1, 1], \\"deadlines\\": [2, 3, 3], \\"fines\\": [10, 20, 30] }, { \\"N_i\\": 2, \\"times\\": [5, 2], \\"deadlines\\": [7, 5], \\"fines\\": [15, 25] }] assert minimizeFines(P, projects) == 25 def test_multiple_projects_all_fines(): P = 2 projects = [ { \\"N_i\\": 3, \\"times\\": [5, 5, 5], \\"deadlines\\": [2, 3, 4], \\"fines\\": [10, 20, 30] }, { \\"N_i\\": 2, \\"times\\": [3, 4], \\"deadlines\\": [2, 3], \\"fines\\": [15, 25] }] assert minimizeFines(P, projects) == 100 def test_empty_projects(): P = 0 projects = [] assert minimizeFines(P, projects) == 0","solution":"def minimizeFines(P, projects): Function to minimize the total fines for all the projects given the constraints. Parameters: - P: int, number of projects - projects: list of dictionaries, each dictionary contains information about a project: \\"N_i\\": number of tasks, \\"times\\": list of task durations, \\"deadlines\\": list of deadlines for tasks, \\"fines\\": list of fines for missing deadlines for tasks Returns: - int: the minimum total fine incurred. total_fine = 0 for project in projects: current_time = 0 for i in range(project[\\"N_i\\"]): current_time += project[\\"times\\"][i] if current_time > project[\\"deadlines\\"][i]: total_fine += project[\\"fines\\"][i] return total_fine"},{"question":"def longestSubseqWithDiffOne(N: int, arr: List[int]) -> int: Returns the length of the longest subsequence where the difference between adjacent elements in the subsequence is exactly 1. >>> longestSubseqWithDiffOne(7, [1, 2, 3, 4, 5, 3, 2]) 5 >>> longestSubseqWithDiffOne(5, [10, 11, 12, 13, 14]) 5 >>> longestSubseqWithDiffOne(4, [1, 3, 5, 7]) 1","solution":"def longestSubseqWithDiffOne(N, arr): Returns the length of the longest subsequence where the difference between adjacent elements in the subsequence is exactly 1. if N == 0: return 0 # Dictionary to store the length of the longest subsequence ending at each element dp = {} for i in range(N): # If arr[i] - 1 exists in dp, then arr[i] can extend the subsequence ending at arr[i] - 1 if (arr[i] - 1) in dp: dp[arr[i]] = dp[arr[i] - 1] + 1 else: dp[arr[i]] = 1 # If arr[i] + 1 exists in dp, then arr[i] can be part of the subsequence starting at arr[i] + 1 if (arr[i] + 1) in dp: dp[arr[i] + 1] = max(dp[arr[i] + 1], dp[arr[i]] + 1) # Maximum length of subsequence found return max(dp.values())"},{"question":"def highest_selling_products(datasets): Determine the product ID of the highest selling product for each day. Args: datasets: A list of datasets, where each dataset is a list of tuples. Each tuple contains a product id and the number of units sold. Returns: A list of product ids corresponding to the highest selling product for each day. pass def read_input(input_lines): Read and parse the input lines to extract datasets. Args: input_lines: A list of strings, each representing a line of input. Returns: A list of datasets, where each dataset is a list of tuples. Each tuple contains a product id and the number of units sold. pass def main(input_lines): Main function to process the input lines and determine the highest selling products. Args: input_lines: A list of strings, each representing a line of input. Returns: A list of product ids corresponding to the highest selling product for each day. pass # Example usage: # input_lines = [ # \\"3\\", # \\"A123 300\\", # \\"B456 500\\", # \\"C789 200\\", # \\"2\\", # \\"P12 150\\", # \\"Q34 150\\", # \\"0\\" # ] # assert main(input_lines) == ['B456', 'P12']","solution":"def highest_selling_products(datasets): results = [] for dataset in datasets: highest_pid = None highest_units = -1 for pid, units in dataset: if units > highest_units or (units == highest_units and highest_pid is None): highest_pid = pid highest_units = units results.append(highest_pid) return results def read_input(input_lines): datasets = [] current_dataset = [] for line in input_lines: line = line.strip() if line == '0': if current_dataset: datasets.append(current_dataset) break elif line.isdigit(): if current_dataset: datasets.append(current_dataset) current_dataset = [] else: pid, units = line.split() current_dataset.append((pid, int(units))) return datasets def main(input_lines): datasets = read_input(input_lines) return highest_selling_products(datasets)"},{"question":"from typing import List def shortest_path(grid: List[str]) -> int: Determine the shortest path for a training robot to traverse from the top-left corner (cell (0,0)) to the bottom-right corner (cell (n-1,m-1)), avoiding blocked cells. The robot can move up, down, left, or right to an adjacent empty cell but cannot move diagonally or through blocked cells. If there is no such path, the function should return -1. >>> shortest_path([ ... \\"....\\", ... \\"....\\", ... \\"....\\", ... \\"....\\" ... ]) 6 >>> shortest_path([ ... \\".#.\\", ... \\"#\\", ... \\".#.\\" ... ]) -1","solution":"from collections import deque def shortest_path(grid): n = len(grid) m = len(grid[0]) if grid[0][0] == '#' or grid[n-1][m-1] == '#': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) # (x, y, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == n-1 and y == m-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def max_heights(initial_heights, increments, n): Calculates the maximum height for each jet after n activations. Parameters: initial_heights: list of int - Initial heights of the jets. increments: list of int - Fixed height increments for each jet. n: int - The number of activations. Returns: List of int - Maximum heights of each jet after n activations. >>> max_heights([3, 7, 2, 5], [2, 1, 3, 2], 4) [11, 11, 14, 13] >>> max_heights([0, 0, 0], [1, 2, 3], 3) [3, 6, 9] >>> max_heights([5, 5, 5], [0, 0, 0], 10) [5, 5, 5] >>> max_heights([1, 2, 3], [1, 0, 1], 1) [2, 2, 4] >>> max_heights([1, 2, 3], [1, 1, 1], 0) [1, 2, 3]","solution":"def max_heights(initial_heights, increments, n): Calculates the maximum height for each jet after n activations. Parameters: initial_heights: list of int - Initial heights of the jets. increments: list of int - Fixed height increments for each jet. n: int - The number of activations. Returns: List of int - Maximum heights of each jet after n activations. return [initial + increment * n for initial, increment in zip(initial_heights, increments)]"},{"question":"class CarRental: def __init__(self): self.available_cars = {} def add_car(self, car_id, car_type): Add a car with unique identifier 'car_id' and type 'car_type' to the fleet of available cars. pass def remove_car(self, car_id): Remove the car with identifier 'car_id' from the fleet of available cars. pass def request_car(self, car_type): Request a car of type 'car_type'. Returns the ID of the booked car if available, otherwise returns \\"No car available\\". pass def process_operations(operations): Processes a list of operations for the car rental service and returns the results for booking requests. Args: operations (List[str]): A list of operations to process. Returns: List[Union[int, str]]: The results of booking requests. Example: >>> operations = [ \\"1 101 SUV\\", \\"1 102 Sedan\\", \\"1 103 SUV\\", \\"3 SUV\\", \\"2 103\\", \\"3 SUV\\", \\"3 Sedan\\" ] >>> process_operations(operations) [101, \\"No car available\\", 102] pass def test_car_rental(): operations = [ \\"1 101 SUV\\", \\"1 102 Sedan\\", \\"1 103 SUV\\", \\"3 SUV\\", \\"2 103\\", \\"3 SUV\\", \\"3 Sedan\\" ] results = process_operations(operations) assert results == [101, \\"No car available\\", 102] def test_no_car_available(): operations = [ \\"1 201 Sports\\", \\"2 201\\", \\"3 Sports\\" ] results = process_operations(operations) assert results == [\\"No car available\\"] def test_add_and_remove_same_car(): operations = [ \\"1 301 Convertible\\", \\"2 301\\", \\"3 Convertible\\" ] results = process_operations(operations) assert results == [\\"No car available\\"] def test_book_cars(): operations = [ \\"1 401 Compact\\", \\"1 402 Compact\\", \\"3 Compact\\", \\"3 Compact\\", \\"3 Compact\\" ] results = process_operations(operations) assert results == [401, 402, \\"No car available\\"]","solution":"class CarRental: def __init__(self): self.available_cars = {} def add_car(self, car_id, car_type): if car_type not in self.available_cars: self.available_cars[car_type] = set() self.available_cars[car_type].add(car_id) def remove_car(self, car_id): for car_type in self.available_cars: if car_id in self.available_cars[car_type]: self.available_cars[car_type].remove(car_id) if not self.available_cars[car_type]: # If set is empty, remove the key del self.available_cars[car_type] break def request_car(self, car_type): if car_type in self.available_cars and self.available_cars[car_type]: car_id = min(self.available_cars[car_type]) # Get the smallest car_id available self.available_cars[car_type].remove(car_id) if not self.available_cars[car_type]: # If set is empty, remove the key del self.available_cars[car_type] return car_id return \\"No car available\\" def process_operations(operations): rental_service = CarRental() results = [] for operation in operations: parts = operation.split() if parts[0] == \\"1\\": car_id = int(parts[1]) car_type = parts[2] rental_service.add_car(car_id, car_type) elif parts[0] == \\"2\\": car_id = int(parts[1]) rental_service.remove_car(car_id) elif parts[0] == \\"3\\": car_type = parts[1] result = rental_service.request_car(car_type) results.append(result) return results"},{"question":"def max_unique_teams(n: int, ratings: List[int]) -> int: Returns the maximum number of unique teams of two players that can be formed. >>> max_unique_teams(6, [8, 2, 5, 1, 9, 4]) == 3 >>> max_unique_teams(3, [2, 9, 4]) == 1 >>> max_unique_teams(0, []) == 0 >>> max_unique_teams(1, [1]) == 0 >>> max_unique_teams(1000000, list(range(1, 1000001))) == 500000","solution":"def max_unique_teams(n, ratings): Returns the maximum number of unique teams of two players that can be formed. ratings.sort() return n // 2"},{"question":"def chess_position_to_coords(position): Convert a chess position in standard notation to coordinates. 'a1' -> (0, 0) 'h8' -> (7, 7) >>> chess_position_to_coords(\\"a1\\") (0, 0) >>> chess_position_to_coords(\\"h8\\") (7, 7) >>> chess_position_to_coords(\\"d4\\") (3, 3) >>> chess_position_to_coords(\\"b2\\") (1, 1) def min_king_moves(start, end): Calculate the minimum number of steps required for a king to move from the start position to the end position on an 8x8 chessboard. >>> min_king_moves(\\"a1\\", \\"b3\\") 2 >>> min_king_moves(\\"h8\\", \\"a1\\") 7 >>> min_king_moves(\\"d4\\", \\"e5\\") 1 >>> min_king_moves(\\"g6\\", \\"g7\\") 1 >>> min_king_moves(\\"a1\\", \\"h8\\") 7 >>> min_king_moves(\\"a1\\", \\"a8\\") 7 >>> min_king_moves(\\"b2\\", \\"c3\\") 1 >>> min_king_moves(\\"c3\\", \\"a1\\") 2","solution":"def chess_position_to_coords(position): Convert a chess position in standard notation to coordinates. 'a1' -> (0, 0) 'h8' -> (7, 7) col = ord(position[0]) - ord('a') row = int(position[1]) - 1 return (col, row) def min_king_moves(start, end): Calculate the minimum number of steps required for a king to move from the start position to the end position on an 8x8 chessboard. start_coords = chess_position_to_coords(start) end_coords = chess_position_to_coords(end) col_diff = abs(start_coords[0] - end_coords[0]) row_diff = abs(start_coords[1] - end_coords[1]) return max(col_diff, row_diff) # Testing the function with an example print(min_king_moves(\\"a1\\", \\"b3\\")) # Output: 2 print(min_king_moves(\\"h8\\", \\"a1\\")) # Output: 7 print(min_king_moves(\\"d4\\", \\"e5\\")) # Output: 1 print(min_king_moves(\\"g6\\", \\"g7\\")) # Output: 1"},{"question":"def categorize_waste(n: int, waste_items: List[Tuple[str, int, int]]) -> Dict[str, Dict[str, int]]: Categorize environmental waste into different bins based on the type. The function calculates the total weight and volume for each type of waste. Args: n: An integer representing the number of waste items. waste_items: A list of tuples where each tuple contains: - a string representing the type of the waste ('Plastic', 'Glass', 'Metal') - an integer representing the weight of the waste (in grams) - an integer representing the volume of the waste (in cubic centimeters) Returns: A dictionary with waste types as keys and another dictionary as values, which contains the total weight and total volume for that type. Example: >>> categorize_waste(5, [('Plastic', 150, 200), ('Glass', 300, 250), ('Metal', 200, 300), ('Plastic', 100, 150), ('Metal', 250, 350)]) { \\"Plastic\\": {\\"total_weight\\": 250, \\"total_volume\\": 350}, \\"Glass\\": {\\"total_weight\\": 300, \\"total_volume\\": 250}, \\"Metal\\": {\\"total_weight\\": 450, \\"total_volume\\": 650} } def format_output(waste_dict: Dict[str, Dict[str, int]]) -> List[str]: Format the output for displaying the categorized waste information. Args: waste_dict: A dictionary with waste types as keys and another dictionary as values, which contains the total weight and total volume for that type. Returns: A list of strings, each representing the formatted output for each type of waste. Example: >>> format_output({ \\"Plastic\\": {\\"total_weight\\": 250, \\"total_volume\\": 350}, \\"Glass\\": {\\"total_weight\\": 300, \\"total_volume\\": 250}, \\"Metal\\": {\\"total_weight\\": 450, \\"total_volume\\": 650} }) [ \\"Plastic: Total weight = 250 grams, Total volume = 350 cubic centimeters\\", \\"Glass: Total weight = 300 grams, Total volume = 250 cubic centimeters\\", \\"Metal: Total weight = 450 grams, Total volume = 650 cubic centimeters\\" ]","solution":"def categorize_waste(n, waste_items): waste_dict = { 'Plastic': {'total_weight': 0, 'total_volume': 0}, 'Glass': {'total_weight': 0, 'total_volume': 0}, 'Metal': {'total_weight': 0, 'total_volume': 0} } for waste in waste_items: waste_type, weight, volume = waste weight, volume = int(weight), int(volume) if waste_type in waste_dict: waste_dict[waste_type]['total_weight'] += weight waste_dict[waste_type]['total_volume'] += volume return waste_dict def format_output(waste_dict): results = [] for waste_type in ['Plastic', 'Glass', 'Metal']: total_weight = waste_dict[waste_type]['total_weight'] total_volume = waste_dict[waste_type]['total_volume'] results.append(f\\"{waste_type}: Total weight = {total_weight} grams, Total volume = {total_volume} cubic centimeters\\") return results # Example usage: waste_items = [ ('Plastic', 150, 200), ('Glass', 300, 250), ('Metal', 200, 300), ('Plastic', 100, 150), ('Metal', 250, 350) ] results = format_output(categorize_waste(5, waste_items)) for result in results: print(result)"},{"question":"def is_alien_sorted(words, order): Determine if the given words list is sorted according to the alien language order. Parameters: words (List[str]): List of words in alien language. order (str): The order of characters in the alien language. Returns: bool: True if words are sorted lexicographically according to the alien language, False otherwise. pass from solution import is_alien_sorted def test_alien_sorted_case1(): assert is_alien_sorted([\\"hello\\", \\"leetcoder\\", \\"leetcode\\"], \\"hlabcdefgijkmnopqrstuvwxyz\\") == False def test_alien_sorted_case2(): assert is_alien_sorted([\\"apple\\", \\"app\\"], \\"abcdefghijklmnopqrstuvwxyz\\") == False def test_alien_sorted_case3(): assert is_alien_sorted([\\"apple\\", \\"banana\\", \\"grape\\"], \\"abcdefghijklmnopqrstuvwxyz\\") == True def test_alien_sorted_case4(): assert is_alien_sorted([\\"word\\", \\"world\\", \\"row\\"], \\"worldabcefghijkmnpqstuvxyz\\") == False def test_alien_sorted_case5(): assert is_alien_sorted([\\"kuyp\\", \\"kuys\\"], \\"kuyzbcdefghijalmnopqrstvxw\\") == True def test_alien_sorted_case6(): assert is_alien_sorted([\\"z\\", \\"x\\", \\"z\\"], \\"zyxwvutsrqponmlkjihgfedcba\\") == False def test_alien_sorted_case7(): assert is_alien_sorted([\\"arc\\", \\"crab\\"], \\"abcdefghijklmnopqrstuvwxyz\\") == True def test_alien_sorted_case8(): assert is_alien_sorted([\\"bat\\", \\"ball\\", \\"baz\\"], \\"bacdefghijklmnopqrstuvwxyz\\") == False","solution":"def is_alien_sorted(words, order): Determine if the given words list is sorted according to the alien language order. Parameters: words (List[str]): List of words in alien language. order (str): The order of characters in the alien language. Returns: bool: True if words are sorted lexicographically according to the alien language, False otherwise. # Create a dictionary to map each character to its position in the alien alphabet order_map = {char: index for index, char in enumerate(order)} def alien_comparator(word1, word2): # Compare each character of the two words for c1, c2 in zip(word1, word2): if c1 != c2: return order_map[c1] < order_map[c2] # If all characters were the same but lengths are different, the shorter word should come first return len(word1) <= len(word2) for i in range(len(words) - 1): if not alien_comparator(words[i], words[i + 1]): return False return True"},{"question":"def max_product_of_two(arr): Finds the maximum product of two distinct elements in the array. Args: arr: A list of integers with at least two elements. Returns: The maximum product of any two distinct elements in the array. >>> max_product_of_two([3, 5, 7, 2, 8]) == 56 >>> max_product_of_two([10, -10, 5, 6]) == 60 >>> max_product_of_two([-1, -3, -4]) == 3 >>> max_product_of_two([0, 0, 0, 0]) == 0 >>> max_product_of_two([5, 7]) == 35 >>> max_product_of_two([1000, 2000, 3000]) == 6000000","solution":"def max_product_of_two(arr): Finds the maximum product of two distinct elements in the array. Args: arr: A list of integers with at least two elements. Returns: The maximum product of any two distinct elements in the array. if len(arr) < 2: raise ValueError(\\"Array must contain at least two elements\\") max1 = max2 = float('-inf') for num in arr: if num > max1: max2 = max1 max1 = num elif num > max2: max2 = num return max1 * max2"},{"question":"def conways_game_of_life(board): Update the board to its next state according to Conway's Game of Life rules. Parameters: board (list of list of ints): A 2D grid where each cell is 0 (dead) or 1 (alive). Returns: list of list of ints: The next state grid. Examples: >>> conways_game_of_life([ ... [0, 1, 0], ... [0, 0, 1], ... [1, 1, 1], ... [0, 0, 0] ... ]) [[0, 0, 0], [1, 0, 1], [0, 1, 1], [0, 1, 0]] >>> conways_game_of_life([ ... [1, 1, 0, 0], ... [0, 0, 1, 0], ... [1, 1, 1, 0], ... [0, 0, 0, 0] ... ]) [[0, 1, 0, 0], [0, 0, 1, 0], [1, 0, 1, 0], [0, 1, 0, 0]]","solution":"def conways_game_of_life(board): Update the board to its next state according to Conway's Game of Life rules. Parameters: board (list of list of ints): A 2D grid where each cell is 0 (dead) or 1 (alive). Returns: list of list of ints: The next state grid. rows, cols = len(board), len(board[0]) def get_neighbors_count(x, y): directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] live_neighbors = 0 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols: live_neighbors += board[nx][ny] return live_neighbors new_board = [[0] * cols for _ in range(rows)] for r in range(rows): for c in range(cols): live_neighbors = get_neighbors_count(r, c) if board[r][c] == 1: # Current cell is alive if live_neighbors < 2 or live_neighbors > 3: new_board[r][c] = 0 else: new_board[r][c] = 1 else: # Current cell is dead if live_neighbors == 3: new_board[r][c] = 1 return new_board"},{"question":"def find_median_log_id(logs): You are given a list of logs, each containing a unique ID and a timestamp in the format \\"YYYY-MM-DD HH:MM:SS\\". Find the ID of the log that occurs at the median timestamp. The median is defined as the middle element in a sorted list of timestamps. If there is an even number of timestamps, return the log with the earlier of the two middle timestamps. Args: logs (List[Tuple[str, str]]): A list of tuples where each tuple contains a log ID and a timestamp. Returns: str: The ID of the log with the median timestamp. >>> find_median_log_id([(\\"log1\\", \\"2023-01-01 12:00:00\\"), (\\"log2\\", \\"2023-01-01 13:00:00\\"), (\\"log3\\", \\"2023-01-01 14:00:00\\")]) 'log2' >>> find_median_log_id([(\\"log1\\", \\"2022-12-31 23:59:59\\"), (\\"log2\\", \\"2023-01-01 00:00:00\\"), (\\"log3\\", \\"2023-01-01 00:00:01\\"), (\\"log4\\", \\"2023-01-01 00:00:02\\")]) 'log2'","solution":"def find_median_log_id(logs): Returns the ID of the log that occurs at the median timestamp. # Sort the logs based on the timestamps logs.sort(key=lambda x: x[1]) # Find the median index n = len(logs) median_index = (n - 1) // 2 # Return the ID of the log at the median timestamp return logs[median_index][0]"},{"question":"def contains_forbidden_combination(spell_sequence: str, forbidden_combination: str) -> str: Checks if the spell sequence contains the forbidden combination. Args: spell_sequence (str): The sequence of the spell elements. forbidden_combination (str): The forbidden combination of elements. Returns: str: \\"YES\\" if the forbidden combination is found in the spell sequence, otherwise \\"NO\\". Examples: >>> contains_forbidden_combination(\\"abracadabra\\", \\"cad\\") \\"YES\\" >>> contains_forbidden_combination(\\"mysticspell\\", \\"fire\\") \\"NO\\"","solution":"def contains_forbidden_combination(spell_sequence, forbidden_combination): Checks if the spell sequence contains the forbidden combination. Args: spell_sequence (str): The sequence of the spell elements. forbidden_combination (str): The forbidden combination of elements. Returns: str: \\"YES\\" if the forbidden combination is found in the spell sequence, otherwise \\"NO\\". if forbidden_combination in spell_sequence: return \\"YES\\" else: return \\"NO\\""},{"question":"def last_ten_digits() -> str: Returns the last ten digits of the number 28433 * 2^7830457 + 1 >>> last_ten_digits() '8739992577'","solution":"def last_ten_digits() -> str: Returns the last ten digits of the number 28433 * 2^7830457 + 1 modulo = 10**10 # We are interested in the last 10 digits base = 2 exponent = 7830457 coefficient = 28433 # Calculate the last ten digits of 2^7830457 last_ten_2_exp = pow(base, exponent, modulo) # Calculate the last ten digits of 28433 * 2^7830457 result = (coefficient * last_ten_2_exp + 1) % modulo # Return as a string return str(result).zfill(10)"},{"question":"def count_gym_clusters(S: str) -> int: Returns the number of gym clusters in a binary string S. A gym cluster is defined as one or more consecutive '1's. >>> count_gym_clusters(\\"000\\") == 0 >>> count_gym_clusters(\\"111\\") == 1 >>> count_gym_clusters(\\"10101\\") == 3 >>> count_gym_clusters(\\"110011\\") == 2 >>> count_gym_clusters(\\"10001\\") == 2 >>> count_gym_clusters(\\"0\\") == 0 >>> count_gym_clusters(\\"1\\") == 1 >>> count_gym_clusters(\\"101111000111\\") == 3 pass def process_test_cases(test_cases: List[str]) -> List[int]: Processes multiple test cases for counting gym clusters. >>> process_test_cases([\\"000\\", \\"111\\", \\"10101\\"]) == [0, 1, 3] >>> process_test_cases([\\"110011\\", \\"10001\\"]) == [2, 2] >>> process_test_cases([\\"0\\", \\"1\\"]) == [0, 1] >>> process_test_cases([\\"101111000111\\"]) == [3] pass","solution":"def count_gym_clusters(S): Returns the number of gym clusters in a binary string S. A gym cluster is defined as one or more consecutive '1's. clusters = 0 in_cluster = False for char in S: if char == '1': if not in_cluster: clusters += 1 in_cluster = True else: in_cluster = False return clusters def process_test_cases(test_cases): results = [] for S in test_cases: results.append(count_gym_clusters(S)) return results"},{"question":"def rotate_matrix_90_degrees_clockwise(matrix): Rotates the given n*m matrix 90 degrees clockwise. Parameters: matrix (list of list of int): 2D list representing the matrix to be rotated. Returns: list of list of int: The rotated matrix. pass def rotate_matrix(matrix): Handles the input and output interfaces as specified in the problem statement. Parameters: matrix (str): A string representing the input matrix. Returns: str: A string representing the output of the rotated matrix. pass","solution":"def rotate_matrix_90_degrees_clockwise(matrix): Rotates the given n*m matrix 90 degrees clockwise. Parameters: matrix (list of list of int): 2D list representing the matrix to be rotated. Returns: list of list of int: The rotated matrix. n = len(matrix) m = len(matrix[0]) # Create a new m*n matrix for the rotated result rotated_matrix = [[0] * n for _ in range(m)] # Populate the rotated matrix for i in range(n): for j in range(m): rotated_matrix[j][n-1-i] = matrix[i][j] return rotated_matrix def rotate_matrix(matrix): Handles the input and output interfaces as specified in the problem statement. Parameters: matrix (str): A string representing the input matrix. Returns: str: A string representing the output of the rotated matrix. lines = matrix.strip().split('n') n, m = map(int, lines[0].split()) matrix = [[int(x) for x in line.split()] for line in lines[1:]] rotated_matrix = rotate_matrix_90_degrees_clockwise(matrix) # Build the output string output_lines = [' '.join(map(str, row)) for row in rotated_matrix] return 'n'.join(output_lines)"},{"question":"from typing import List def shortest_path(grid: List[str]) -> int: Calculate the length of the shortest path from the top-left corner to the bottom-right corner of a grid, avoiding obstacles. >>> shortest_path([\\".....\\", \\".#.\\", \\".#.#.\\", \\".#.#.\\", \\".....\\"]) 8 >>> shortest_path([\\"...\\", \\".#.\\", \\"..#\\"]) -1 >>> shortest_path([\\".\\"]) 0 >>> shortest_path([\\"#.\\", \\".#\\"]) -1 >>> shortest_path([\\"..\\", \\"..\\"]) 2 >>> shortest_path([\\"#\\"*1000 for _ in range(1000)]) -1","solution":"from collections import deque def shortest_path(grid): if not grid or grid[0][0] == '#' or grid[-1][-1] == '#': return -1 n = len(grid) m = len(grid[0]) # Directions for moving: down, up, right, left directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # Queue for BFS, start from the top-left corner queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() # If we've reached the bottom-right corner if x == n-1 and y == m-1: return dist # Explore neighbors for dx, dy in directions: next_x, next_y = x + dx, y + dy if 0 <= next_x < n and 0 <= next_y < m and grid[next_x][next_y] == '.' and (next_x, next_y) not in visited: visited.add((next_x, next_y)) queue.append((next_x, next_y, dist + 1)) return -1"},{"question":"def decode_message(s: str) -> str: Decodes a given string based on specific encoding rules. Characters encoded as 'Xn' should appear 'n' times. >>> decode_message('a') 'a' >>> decode_message('abc') 'abc' >>> decode_message('aX3b') 'abbb' >>> decode_message('abX3cX2dy') 'abcccddy' >>> decode_message('abX10cX2dxX1y') 'abccccccccccddxy' >>> decode_message('abcX5d') 'abcddddd' >>> decode_message('X2aX3b') 'aabbb'","solution":"import re def decode_message(s): Decodes a given string based on specific encoding rules. Characters encoded as 'Xn' should appear 'n' times. decoded_message = \\"\\" i = 0 while i < len(s): if s[i] == 'X': # Find the number and the character following it match = re.match(r'X(d+)(.)', s[i:]) if match: num = int(match.group(1)) char = match.group(2) decoded_message += char * num i += len(match.group(0)) - 1 else: decoded_message += s[i] i += 1 return decoded_message"},{"question":"from typing import List def longest_common_prefix(strs: List[str]) -> str: This function takes a list of strings and returns the longest common prefix. def process_test_cases(test_cases: List[List[str]]) -> List[str]: This function processes multiple test cases and returns the longest common prefix for each. def test_longest_common_prefix(): assert longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) == \\"fl\\" assert longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) == \\"\\" assert longest_common_prefix([\\"interspecies\\", \\"interstellar\\", \\"interstate\\"]) == \\"inters\\" assert longest_common_prefix([\\"throne\\", \\"throne\\"]) == \\"throne\\" assert longest_common_prefix([]) == \\"\\" assert longest_common_prefix([\\"\\"]) == \\"\\" assert longest_common_prefix([\\"a\\"]) == \\"a\\" assert longest_common_prefix([\\"aa\\", \\"a\\"]) == \\"a\\" def test_process_test_cases(): test_cases = [ ([\\"flower\\", \\"flow\\", \\"flight\\"], \\"fl\\"), ([\\"dog\\", \\"racecar\\", \\"car\\"], \\"\\"), ([\\"interspecies\\", \\"interstellar\\", \\"interstate\\"], \\"inters\\"), ([\\"throne\\", \\"throne\\"], \\"throne\\"), ([], \\"\\"), ([\\"a\\"], \\"a\\"), ([\\"aa\\", \\"a\\"], \\"a\\") ] for case, expected in test_cases: assert process_test_cases([case]) == [expected] multi_test_cases = [ ([ [\\"flower\\", \\"flow\\", \\"flight\\"], [\\"dog\\", \\"racecar\\", \\"car\\"] ], [\\"fl\\", \\"\\"]), ([ [\\"interspecies\\", \\"interstellar\\", \\"interstate\\"], [\\"throne\\", \\"throne\\"] ], [\\"inters\\", \\"throne\\"]), ] for cases, expected in multi_test_cases: assert process_test_cases(cases) == expected","solution":"def longest_common_prefix(strs): This function takes a list of strings and returns the longest common prefix. if not strs: return \\"\\" # Sort the array, and then only compare the first and last items # The common prefix of the whole list is the common prefix of the first and last item in a sorted list strs.sort() first = strs[0] last = strs[-1] i = 0 while i < len(first) and i < len(last) and first[i] == last[i]: i += 1 return first[:i] def process_test_cases(test_cases): This function processes multiple test cases and returns the longest common prefix for each. results = [] for case in test_cases: results.append(longest_common_prefix(case)) return results"},{"question":"def arrange_trees(n: int) -> list: Arrange the heights of n trees in such a way that no two adjacent trees have the same height. The heights must form a permutation of the first n natural numbers where no two adjacent numbers are the same. >>> arrange_trees(4) [4, 1, 3, 2] >>> arrange_trees(7) [1, 3, 5, 2, 4, 6, 7]","solution":"def arrange_trees(n): if n == 2: return [1, 2] # Generally follow the algorithm to ensure no adjacent numbers are the same result = [0] * n j = 1 for i in range(0, n, 2): # fill odd positions result[i] = j j += 1 for i in range(1, n, 2): # fill even positions result[i] = j j += 1 return result # Example execution # print(arrange_trees(4)) # Outputs: [1, 3, 2, 4] # print(arrange_trees(7)) # Outputs: [1, 3, 5, 2, 4, 6, 7]"},{"question":"def longestUniformSubstring(s: str) -> int: Returns the length of the longest substring with all characters the same. >>> longestUniformSubstring(\\"ababbccaa\\") 2 >>> longestUniformSubstring(\\"abcd\\") 1 >>> longestUniformSubstring(\\"aaa\\") 3 >>> longestUniformSubstring(\\"a\\") 1 >>> longestUniformSubstring(\\"bbbbbbb\\") 7 >>> longestUniformSubstring(\\"aabbccdd\\") 2 >>> longestUniformSubstring(\\"\\") 0 >>> longestUniformSubstring(\\"a\\" * 100000) 100000 >>> longestUniformSubstring(\\"ababababab\\") 1","solution":"def longestUniformSubstring(s): Returns the length of the longest substring with all characters the same. if not s: return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"from typing import List def unique_morse_representations(words: List[str]) -> int: Given a dictionary containing the mapping of a letter to its corresponding Morse code representation, write a function that takes a list of strings and returns the number of unique transformations. Each transformation is a concatenation of the Morse code representations of each letter in the string. >>> unique_morse_representations([\\"gin\\", \\"zen\\", \\"gig\\", \\"msg\\"]) 2 >>> unique_morse_representations([\\"abcd\\"]) 1 >>> unique_morse_representations([\\"a\\", \\"b\\", \\"c\\", \\"d\\"]) 4 >>> unique_morse_representations([\\"ab\\", \\"ab\\", \\"ab\\"]) 1 >>> unique_morse_representations([\\"aa\\", \\"ab\\", \\"aa\\"]) 2 >>> unique_morse_representations([]) 0","solution":"from typing import List def unique_morse_representations(words: List[str]) -> int: morse_code_dict = { 'a': \\".-\\", 'b': \\"-...\\", 'c': \\"-.-.\\", 'd': \\"-..\\", 'e': \\".\\", 'f': \\"..-.\\", 'g': \\"--.\\", 'h': \\"....\\", 'i': \\"..\\", 'j': \\".---\\", 'k': \\"-.-\\", 'l': \\".-..\\", 'm': \\"--\\", 'n': \\"-.\\", 'o': \\"---\\", 'p': \\".--.\\", 'q': \\"--.-\\", 'r': \\".-.\\", 's': \\"...\\", 't': \\"-\\", 'u': \\"..-\\", 'v': \\"...-\\", 'w': \\".--\\", 'x': \\"-..-\\", 'y': \\"-.--\\", 'z': \\"--..\\" } transformations = set() for word in words: morse_representation = ''.join(morse_code_dict[char] for char in word) transformations.add(morse_representation) return len(transformations)"},{"question":"def max_points(puzzles): Given a list of puzzle points, returns the maximum points Alex can achieve by solving at least one puzzle. pass # Unit Tests def test_example_case(): assert max_points([-3, 5, -1, 7, -4, 3]) == 15 def test_all_negative_points(): assert max_points([-3, -5, -1, -7, -4]) == -1 def test_all_positive_points(): assert max_points([2, 4, 6, 8, 10]) == 30 def test_mixed_points_with_no_positive_sum(): assert max_points([-2, -3, -1]) == -1 def test_single_puzzle(): assert max_points([-5]) == -5 assert max_points([10]) == 10","solution":"def max_points(puzzles): Given a list of puzzle points, returns the maximum points Alex can achieve by solving at least one puzzle. total_positive_points = sum(point for point in puzzles if point > 0) return total_positive_points if total_positive_points > 0 else max(puzzles) # Example Usage if __name__ == \\"__main__\\": puzzles = [-3, 5, -1, 7, -4, 3] print(max_points(puzzles)) # Output: 15"},{"question":"def calculate_rounds(N: int) -> int: Calculate the number of rounds required to determine the winner given N players. >>> calculate_rounds(1) 0 >>> calculate_rounds(8) 3 >>> calculate_rounds(14) 4 def tournament_rounds(test_cases: List[int]) -> List[int]: Calculate the number of rounds for each test case. >>> tournament_rounds([1, 8, 14]) [0, 3, 4] >>> tournament_rounds([32, 100, 1000]) [5, 7, 10] >>> tournament_rounds([2, 3, 4, 5]) [1, 2, 2, 3]","solution":"def calculate_rounds(N): Calculate the number of rounds required to determine the winner given N players. if N <= 1: return 0 rounds = 0 while N > 1: rounds += 1 N = (N + 1) // 2 return rounds def tournament_rounds(test_cases): Calculate the number of rounds for each test case. result = [] for N in test_cases: result.append(calculate_rounds(N)) return result"},{"question":"def min_additional_ingredients(n: int, k: int, freshness_levels: List[int]) -> int: Determines the minimum number of additional ingredients needed to have exactly k different freshness levels. Parameters: n (int): The number of ingredients currently in inventory. k (int): The number of different freshness levels required for the dish. freshness_levels (list): A list of integers representing the freshness levels of the ingredients. Returns: int: The minimum number of additional ingredients required. Examples: >>> min_additional_ingredients(5, 7, [3, 1, 4, 1, 5]) 3 >>> min_additional_ingredients(3, 5, [2, 2, 2]) 4 >>> min_additional_ingredients(7, 4, [1, 2, 3, 4, 5, 6, 7]) 0 def test_min_additional_ingredients_example_1(): assert min_additional_ingredients(5, 7, [3, 1, 4, 1, 5]) == 3 def test_min_additional_ingredients_example_2(): assert min_additional_ingredients(3, 5, [2, 2, 2]) == 4 def test_min_additional_ingredients_example_3(): assert min_additional_ingredients(7, 4, [1, 2, 3, 4, 5, 6, 7]) == 0 def test_min_additional_ingredients_edge_case_1(): assert min_additional_ingredients(1, 1, [1]) == 0 def test_min_additional_ingredients_edge_case_2(): assert min_additional_ingredients(1, 2, [1000000]) == 1 def test_min_additional_ingredients_edge_case_3(): assert min_additional_ingredients(2000, 2000, list(range(1, 2001))) == 0 def test_min_additional_ingredients_repeats(): assert min_additional_ingredients(6, 5, [10, 20, 20, 30, 30, 30]) == 2","solution":"def min_additional_ingredients(n, k, freshness_levels): Determines the minimum number of additional ingredients needed to have exactly k different freshness levels. Parameters: n (int): The number of ingredients currently in inventory. k (int): The number of different freshness levels required for the dish. freshness_levels (list): A list of integers representing the freshness levels of the ingredients. Returns: int: The minimum number of additional ingredients required. unique_freshness_levels = set(freshness_levels) unique_count = len(unique_freshness_levels) if unique_count >= k: return 0 else: return k - unique_count"},{"question":"def longest_increasing_path(palaces: List[Tuple[int, int]]) -> int: Determine the length of the longest sequence of palaces where the x-coordinates or y-coordinates strictly increase. Args: palaces (List[Tuple[int, int]]): List of tuples representing coordinates of palaces Returns: int: Length of the longest increasing path >>> longest_increasing_path([(1, 2), (2, 3), (3, 4), (2, 2), (3, 5)]) == 4 >>> longest_increasing_path([]) == 0 >>> longest_increasing_path([(1, 1)]) == 1 >>> longest_increasing_path([(1, 1), (1, 1), (1, 1)]) == 1 >>> longest_increasing_path([(1, 1), (2, 2), (3, 3), (4, 4)]) == 4 >>> longest_increasing_path([(1, 4), (2, 3), (3, 2), (4, 1)]) == 1 >>> longest_increasing_path([(4, 1), (3, 2), (2, 3), (1, 4)]) == 1","solution":"def longest_increasing_path(palaces): Returns the length of the longest strictly increasing path in terms of either x or y coordinates from the list of palaces. A path is represented as a sequence of coordinates (x, y). if not palaces: return 0 def longest_increasing_subsequence(sequence): from bisect import bisect_left lis = [] for value in sequence: pos = bisect_left(lis, value) if pos == len(lis): lis.append(value) else: lis[pos] = value return len(lis) # Sort palaces by x-coordinate first, then y-coordinate to cover x increasing first palaces.sort() ys = [y for x, y in palaces] return longest_increasing_subsequence(ys)"},{"question":"def basketball_player_stats(nums): Returns the highest score and the average score of a player in the format \\"Highest: <highest_score>, Average: <average_score>\\". Parameters: nums (list): A list of integers representing the scores of a basketball player. Returns: str: A formatted string with the highest and average score. pass # Test cases def test_basketball_player_stats_single_score(): assert basketball_player_stats([25]) == \\"Highest: 25, Average: 25.00\\" def test_basketball_player_stats_multiple_scores(): assert basketball_player_stats([10, 20, 15, 25, 30]) == \\"Highest: 30, Average: 20.00\\" assert basketball_player_stats([5, 10, 15, 20, 25, 30]) == \\"Highest: 30, Average: 17.50\\" def test_basketball_player_stats_all_same_scores(): assert basketball_player_stats([10, 10, 10, 10]) == \\"Highest: 10, Average: 10.00\\" def test_basketball_player_stats_including_zero(): assert basketball_player_stats([0, 5, 10]) == \\"Highest: 10, Average: 5.00\\" def test_basketball_player_stats_negative_scores(): assert basketball_player_stats([5, -5, 10, -10]) == \\"Highest: 10, Average: 0.00\\"","solution":"def basketball_player_stats(nums): Returns the highest score and the average score of a player in the format \\"Highest: <highest_score>, Average: <average_score>\\". Parameters: nums (list): A list of integers representing the scores of a basketball player. Returns: str: A formatted string with the highest and average score. highest_score = max(nums) average_score = round(sum(nums) / len(nums), 2) return f\\"Highest: {highest_score}, Average: {average_score:.2f}\\""},{"question":"def organize_events(n: int, days: List[int]) -> Tuple[str, List[int]]: Determine if it's possible to organize the events as per the constraints and provide one possible valid order of events. :param n: Number of events :param days: List of integers where each integer represents the specific day the event must be held (0 for no specific day). :return: Tuple of (str, List[int]) where the first value is \\"YES\\" or \\"NO\\", and the second value is the list of days on which the events can be held. >>> organize_events(3, [1, 0, 2]) ('YES', [1, 3, 2]) >>> organize_events(4, [2, 1, 0, 3]) ('YES', [2, 1, 4, 3]) >>> organize_events(5, [1, 2, 3, 4, 5]) ('YES', [1, 2, 3, 4, 5]) >>> organize_events(3, [1, 1, 0]) ('NO', [])","solution":"def organize_events(n, days): Determine if it's possible to organize the events as per the constraints and provide one possible valid order of events. :param n: Number of events :param days: List of integers where each integer represents the specific day the event must be held (0 for no specific day). :return: Tuple of (str, List[int]) where the first value is \\"YES\\" or \\"NO\\", and the second value is the list of days on which the events can be held. scheduled_days = [0] * n specific_days = {} # To track the exact day an event needs to be held available_days = set(range(1, n + 1)) # All available days from 1 to n # First pass to allocate the specific days for i in range(n): if days[i] != 0: if days[i] in specific_days: return \\"NO\\", [] specific_days[days[i]] = i scheduled_days[i] = days[i] available_days.discard(days[i]) # Second pass to allocate the free days free_index = 0 available_days = sorted(available_days) # Sort available days for i in range(n): if scheduled_days[i] == 0: if free_index >= len(available_days): return \\"NO\\", [] scheduled_days[i] = available_days[free_index] free_index += 1 return \\"YES\\", scheduled_days"},{"question":"def max_communication_links(n: int, m: int, restrictions: List[Tuple[int, int]]) -> int: Calculate the maximum number of direct communication links that can be established without violating the given restrictions. Args: n (int): Number of endpoints. m (int): Number of restrictions. restrictions (List[Tuple[int, int]]): List of tuples where each tuple represents a restricted pair of endpoints. Returns: int: Maximum number of direct communication links that can be established. Examples: >>> max_communication_links(5, 3, [(1, 2), (2, 3), (4, 5)]) 7 >>> max_communication_links(4, 6, [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]) 0 >>> max_communication_links(3, 1, [(2, 3)]) 2","solution":"def max_communication_links(n, m, restrictions): Calculate the maximum number of direct communication links that can be established without violating the given restrictions. links_possible = n * (n - 1) // 2 # Total possible links if no restrictions # Subtract each forbidden link from the total possible links restriction_set = set(restrictions) forbidden_links = len(restriction_set) # Count of unique restricted links return links_possible - forbidden_links"},{"question":"def splitBalancedString(s: str) -> int: Splits a string into the maximum number of balanced substrings. A special string is defined as a string composed of characters 'L' and 'R' only. The balanced substring is one where the number of 'L's is equal to the number of 'R's. :param s: A string containing only characters 'L' and 'R'. :return: An integer representing the maximum number of balanced substrings. >>> splitBalancedString(\\"RLRRLLRLRL\\") 4 >>> splitBalancedString(\\"RLLLLRRRLR\\") 3 >>> splitBalancedString(\\"LLLLRRRR\\") 1 >>> splitBalancedString(\\"RLRRRLLRLL\\") 2 pass","solution":"def splitBalancedString(s: str) -> int: This function takes a string composed of 'L' and 'R' and returns the maximum number of balanced substrings. balance = 0 count = 0 for char in s: if char == 'L': balance += 1 else: # char == 'R' balance -= 1 if balance == 0: count += 1 return count"},{"question":"from typing import List, Tuple def findCriticalServers(n: int, links: List[Tuple[int, int]]) -> List[int]: Given the number of servers and the list of links between them, find the critical servers in the network. A critical server is a server that, if removed, will cause at least some part of the network to become disconnected. Args: - n: the number of servers - links: a list of tuples representing the links between servers Returns: - A list of critical servers sorted in increasing order. Example: >>> findCriticalServers(6, [(0, 1), (0, 2), (1, 2), (1, 3), (3, 4), (4, 5)]) [1, 3, 4] >>> findCriticalServers(4, [(0, 1), (1, 2), (2, 3), (3, 0)]) [] from solution import findCriticalServers def test_findCriticalServers_simple(): n = 6 links = [(0, 1), (0, 2), (1, 2), (1, 3), (3, 4), (4, 5)] assert findCriticalServers(n, links) == [1, 3, 4] def test_findCriticalServers_no_links(): n = 5 links = [] assert findCriticalServers(n, links) == [] def test_findCriticalServers_no_critical(): n = 4 links = [(0, 1), (1, 2), (2, 3), (3, 0)] assert findCriticalServers(n, links) == [] def test_findCriticalServers_full_mesh(): n = 4 links = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)] assert findCriticalServers(n, links) == [] def test_findCriticalServers_multiple_components(): n = 7 links = [(0, 1), (1, 2), (2, 0), (3, 4), (4, 5), (5, 6)] assert findCriticalServers(n, links) == [4, 5]","solution":"def findCriticalServers(n, links): from collections import defaultdict, deque def DFS(u, disc, low, parent, time, ap): children = 0 disc[u] = low[u] = time time += 1 for v in graph[u]: if disc[v] == -1: parent[v] = u children += 1 DFS(v, disc, low, parent, time, ap) low[u] = min(low[u], low[v]) if parent[u] == -1 and children > 1: ap.add(u) if parent[u] != -1 and low[v] >= disc[u]: ap.add(u) elif v != parent[u]: low[u] = min(low[u], disc[v]) if n == 0: return [] graph = defaultdict(list) for u, v in links: graph[u].append(v) graph[v].append(u) disc = [-1] * n low = [-1] * n parent = [-1] * n ap = set() for i in range(n): if disc[i] == -1: DFS(i, disc, low, parent, 0, ap) return sorted(ap)"},{"question":"def rotate_array(arr, k): Rotates the array \`arr\` to the right by \`k\` steps in-place. >>> arr = [1, 2, 3, 4, 5] >>> rotate_array(arr, 2) >>> arr [4, 5, 1, 2, 3] >>> arr = [1, 2, 3, 4, 5] >>> rotate_array(arr, 0) >>> arr [1, 2, 3, 4, 5] >>> arr = [1, 2, 3, 4, 5] >>> rotate_array(arr, 5) >>> arr [1, 2, 3, 4, 5] >>> arr = [1, 2, 3, 4, 5] >>> rotate_array(arr, 7) >>> arr [4, 5, 1, 2, 3]","solution":"def rotate_array(arr, k): Rotates the array \`arr\` to the right by \`k\` steps in-place. n = len(arr) k = k % n # In case k is larger than n reverse(arr, 0, n - 1) reverse(arr, 0, k - 1) reverse(arr, k, n - 1) def reverse(arr, start, end): Reverses the elements of \`arr\` from index \`start\` to index \`end\` in-place. while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1"},{"question":"def count_vowels(s: str) -> int: Returns the number of vowels (a, e, i, o, u) in the string \`s\`. Vowels can be in upper or lower case. >>> count_vowels(\\"hello world\\") 3 >>> count_vowels(\\"HELLO\\") 2 >>> count_vowels(\\"Python programming\\") 4","solution":"def count_vowels(s): Returns the number of vowels (a, e, i, o, u) in the string \`s\`. Vowels can be in upper or lower case. vowels = \\"aeiouAEIOU\\" count = 0 for char in s: if char in vowels: count += 1 return count"},{"question":"def check_unique_filenames(T: int, test_cases: List[List[int, List[str]]]) -> List[str]: Determine if the filenames across all folders combined are unique for each test case. Args: T (int): Number of test cases. test_cases (List[List[int, List[str]]]): Each test case includes number of folders, followed by pairs of number of files and file names. Returns: List[str]: \\"YES\\" if all filenames are unique across all folders in a test case, \\"NO\\" otherwise. Examples: >>> check_unique_filenames(2, [ [2, 3, ['file1', 'file2', 'file3'], 2, ['file4', 'file5']], [3, 2, ['file1', 'file2'], 2, ['file2', 'file3'], 1, ['file4']]) [\\"YES\\", \\"NO\\"] >>> check_unique_filenames(1, [ [2, 1, ['a'], 1, ['b']]) [\\"YES\\"] >>> check_unique_filenames(1, [ [2, 1, ['a'], 1, ['a']]) [\\"NO\\"] >>> check_unique_filenames(3, [ [1, 1, ['x']], [2, 2, ['y', 'z'], 2, ['a', 'b']], [2, 2, ['c', 'd'], 2, ['d', 'e']] [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def check_unique_filenames(T, test_cases): results = [] for i in range(T): A = test_cases[i][0] filenames = set() is_unique = True for j in range(1, 2 * A, 2): N = test_cases[i][j] files = test_cases[i][j + 1] for file in files: if file in filenames: is_unique = False break filenames.add(file) if not is_unique: break results.append(\\"YES\\" if is_unique else \\"NO\\") return results"},{"question":"def maximal_rectangle(matrix) -> int: Given a matrix of dimensions m x n, find the size of the largest rectangle containing only 1's and return its area. >>> maximal_rectangle([ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ]) == 6 >>> maximal_rectangle([ ... [0, 1, 1, 0], ... [1, 1, 1, 1] ... ]) == 4","solution":"def maximalRectangle(matrix): Given a binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area. if not matrix or not matrix[0]: return 0 max_area = 0 m, n = len(matrix), len(matrix[0]) heights = [0] * (n + 1) for i in range(m): for j in range(n): heights[j] = heights[j] + 1 if matrix[i][j] == 1 else 0 stack = [-1] for k in range(n + 1): while heights[k] < heights[stack[-1]]: h = heights[stack.pop()] w = k - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(k) return max_area"},{"question":"def remove_consecutive_duplicates(n: int, lines: List[str]) -> List[str]: Removes consecutive duplicate lines from the list of strings. >>> remove_consecutive_duplicates(6, [\\"first\\", \\"first\\", \\"second\\", \\"second\\", \\"second\\", \\"third\\"]) [\\"first\\", \\"second\\", \\"third\\"] >>> remove_consecutive_duplicates(7, [\\"hello\\", \\"hello\\", \\"world\\", \\"world\\", \\"world\\", \\"hello\\", \\"hello\\"]) [\\"hello\\", \\"world\\", \\"hello\\"]","solution":"def remove_consecutive_duplicates(n, lines): Removes consecutive duplicate lines from the list of strings. Parameters: n (int): Number of lines in the input. lines (list of str): List of lines in the file. Returns: list of str: List of lines with consecutive duplicates removed. if not lines: return [] result = [lines[0]] for i in range(1, n): if lines[i] != lines[i - 1]: result.append(lines[i]) return result"},{"question":"def thrill(d: int) -> int: Returns the thrill level of \\"The Magic Spiral\\" on the d-th day. Args: d (int): The day number (1-based index). Returns: int: The calculated thrill level on the d-th day. Examples: >>> thrill(1) 1 >>> thrill(2) 2 >>> thrill(3) 4 >>> thrill(4) 8","solution":"def thrill(d): Returns the thrill level of \\"The Magic Spiral\\" on the d-th day. Args: d (int): The day number (1-based index). Returns: int: The calculated thrill level on the d-th day. # When d is 1, the thrill level is always 1 if d == 1: return 1 # Calculate the thrill level for d > 1 thrill_level = 1 # Thrill level of the first day sum_thrill = 1 # Sum of thrill levels up to the first day for day in range(2, d + 1): thrill_level = sum_thrill + 1 sum_thrill += thrill_level return thrill_level"},{"question":"def count_unique_elements(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Returns the number of unique elements in subarrays defined by queries. Parameters: arr (list): List of integers. queries (list of tuples): Each tuple contains two integers l and r representing the range (inclusive). Returns: list: List of integers where each integer is the number of unique elements in the corresponding subarray. pass # Example Usage: # arr = [1, 2, 1, 3, 4, 2] # queries = [(2, 4), (1, 6)] # print(count_unique_elements(arr, queries)) # Output: [3, 4]","solution":"def count_unique_elements(arr, queries): Returns the number of unique elements in subarrays defined by queries. Parameters: arr (list): List of integers. queries (list of tuples): Each tuple contains two integers l and r representing the range (inclusive). Returns: list: List of integers where each integer is the number of unique elements in the corresponding subarray. results = [] for l, r in queries: subarray = arr[l-1:r] unique_elements = len(set(subarray)) results.append(unique_elements) return results"},{"question":"def maxRectangleArea(heights: list) -> int: Calculates the maximum rectangle area in a histogram. :param heights: List[int], the heights of the bars in the histogram. :return: int, the maximum rectangle area >>> maxRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> maxRectangleArea([2, 4]) 4 >>> maxRectangleArea([0, 0, 0]) 0 >>> maxRectangleArea([6, 2, 5, 4, 5, 1, 6]) 12 >>> maxRectangleArea([2, 0, 2]) 2 >>> maxRectangleArea([3, 6, 5, 7, 4, 8, 1, 0]) 20 >>> maxRectangleArea([]) 0 >>> maxRectangleArea([5]) 5 >>> maxRectangleArea([3, 3, 3, 3]) 12 >>> maxRectangleArea([1, 2, 3, 4, 5]) 9 >>> maxRectangleArea([5, 4, 3, 2, 1]) 9","solution":"def maxRectangleArea(heights): Calculates the maximum rectangle area in a histogram. :param heights: List[int], the heights of the bars in the histogram. :return: int, the maximum rectangle area stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"from typing import List def min_moves_to_reach_captive(grid: List[List[str]], N: int, M: int, S1: int, S2: int, C1: int, C2: int) -> int: Determine the minimum number of moves required for a soldier to reach the captive in a grid. Args: grid (List[List[str]]): The representation of the grid. N (int): Number of rows in the grid. M (int): Number of columns in the grid. S1 (int): Starting row position of the soldier. S2 (int): Starting column position of the soldier. C1 (int): Row position of the captive. C2 (int): Column position of the captive. Returns: int: Minimum number of moves required to reach the captive, or -1 if it's impossible. >>> min_moves_to_reach_captive([ ... ['.', '.', '.', '.'], ... ['.', '#', '#', '.'], ... ['.', '.', '.', '.'] ...], 3, 4, 0, 0, 2, 3) 5 >>> min_moves_to_reach_captive([ ... ['.', '#', '.'], ... ['#', '#', '#'], ... ['.', '.', '.'] ...], 3, 3, 0, 0, 2, 2) -1","solution":"from collections import deque def min_moves_to_reach_captive(grid, N, M, S1, S2, C1, C2): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[False] * M for _ in range(N)] queue = deque([(S1, S2, 0)]) visited[S1][S2] = True while queue: x, y, moves = queue.popleft() if (x, y) == (C1, C2): return moves for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny, moves + 1)) return -1"},{"question":"import heapq import collections from typing import List, Tuple def shortestPath(N: int, M: int, edges: List[Tuple[int, int, int]], start: int, target: int) -> int: Compute the shortest path from a specified start node to a target node in an undirected graph represented as an adjacency list. >>> shortestPath(5, 6, [(1, 2, 4), (1, 3, 2), (2, 3, 3), (3, 4, 2), (4, 5, 3), (2, 5, 7)], 1, 5) 7 >>> shortestPath(4, 3, [(1, 2, 4), (2, 3, 5), (3, 4, 6)], 1, 4) 15 >>> shortestPath(4, 1, [(1, 2, 4)], 1, 4) -1 >>> shortestPath(2, 1, [(1, 2, 4)], 1, 2) 4 >>> shortestPath(5, 4, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1)], 1, 1) 0","solution":"import heapq import collections def shortestPath(N, M, edges, start, target): graph = collections.defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) heap = [(0, start)] distances = {i: float('inf') for i in range(1, N + 1)} distances[start] = 0 while heap: current_distance, u = heapq.heappop(heap) if u == target: return current_distance for v, weight in graph[u]: distance = current_distance + weight if distance < distances[v]: distances[v] = distance heapq.heappush(heap, (distance, v)) return -1"},{"question":"import numpy as np def mean_sum_axis_zero(n: int, m: int, array: List[List[int]]) -> float: Computes the mean along axis 0 and returns the sum of that result. :param n: Number of rows in the array :param m: Number of columns in the array :param array: 2D list of integers containing the array elements :return: Sum of the mean values along axis 0 >>> mean_sum_axis_zero(4, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]) 19.5 >>> mean_sum_axis_zero(1, 1, [[5]]) 5.0 >>> mean_sum_axis_zero(2, 2, [[1, 2], [3, 4]]) 5.0 >>> mean_sum_axis_zero(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0.0","solution":"import numpy as np def mean_sum_axis_zero(n, m, array): Computes the mean along axis 0 and returns the sum of that result. :param n: Number of rows in the array :param m: Number of columns in the array :param array: 2D list of integers containing the array elements :return: Sum of the mean values along axis 0 np_array = np.array(array) mean_result = np.mean(np_array, axis=0) sum_of_mean = np.sum(mean_result) return sum_of_mean"},{"question":"def minimum_new_toys_needed(n, toy_ids): Determine the minimum number of new toys needed to ensure all toy identifiers are unique. n: int - number of friends (and hence the number of current toys) toy_ids: List[int] - List of current toy identifiers return: int - The minimum number of new toys needed to make all identifiers unique. pass # Unit Test from solution import minimum_new_toys_needed def test_minimum_new_toys_needed_no_duplicates(): assert minimum_new_toys_needed(4, [1, 2, 3, 4]) == 0 def test_minimum_new_toys_needed_one_duplicate_pair(): assert minimum_new_toys_needed(5, [1, 2, 2, 3, 4]) == 1 def test_minimum_new_toys_needed_multiple_duplicate_pairs(): assert minimum_new_toys_needed(5, [1, 1, 2, 2, 3]) == 2 def test_minimum_new_toys_needed_all_duplicates(): assert minimum_new_toys_needed(4, [1, 1, 1, 1]) == 3 def test_minimum_new_toys_needed_large_input(): n = 100000 toy_ids = [i for i in range(1, n//2)] + [i for i in range(1, n//2)] assert minimum_new_toys_needed(n, toy_ids) == (n // 2) - 1","solution":"def minimum_new_toys_needed(n, toy_ids): Determine the minimum number of new toys needed to ensure all toy identifiers are unique. n: int - number of friends (and hence the number of current toys) toy_ids: List[int] - List of current toy identifiers return: int - The minimum number of new toys needed to make all identifiers unique. unique_ids = set() duplicates_count = 0 for toy_id in toy_ids: if toy_id in unique_ids: duplicates_count += 1 else: unique_ids.add(toy_id) return duplicates_count"},{"question":"def trapWater(arr): Given an array of integers representing the heights of buildings, calculates how much water can be trapped after raining. Parameters: arr (list of int): A list of non-negative integers representing the heights of the buildings. Returns: int: Total units of water trapped. Example: >>> trapWater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trapWater([4, 2, 0, 3, 2, 5]) 9","solution":"def trapWater(arr): Given an array of integers representing the heights of buildings, calculates how much water can be trapped after raining. Parameters: arr (list of int): A list of non-negative integers representing the heights of the buildings. Returns: int: Total units of water trapped. if not arr: return 0 n = len(arr) left_max = [0] * n right_max = [0] * n left_max[0] = arr[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], arr[i]) right_max[n - 1] = arr[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], arr[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - arr[i] return trapped_water"},{"question":"from typing import List, Tuple def is_symmetric_tree(n: int, nodes: List[Tuple[int, int, int]]) -> str: Determines if the given n-node binary tree described by the adjacency list is symmetric. :param n: An integer representing the number of nodes in the tree. :param nodes: List of tuples representing the nodes where each tuple contains 3 integers (u, v_L, v_R). u: the node number, v_L: left child, v_R: right child. -1 if no child. :return: \\"Symmetric\\" if the tree is symmetric, otherwise \\"Not symmetric\\". >>> is_symmetric_tree(3, [(1, 2, 2), (2, -1, -1), (2, -1, -1)]) 'Symmetric' >>> is_symmetric_tree(3, [(1, 2, 3), (2, -1, -1), (3, -1, -1)]) 'Not symmetric' >>> is_symmetric_tree(1, [(1, -1, -1)]) 'Symmetric' >>> is_symmetric_tree(5, [(1, 2, 2), (2, 3, -1), (2, -1, 3), (3, -1, -1), (3, -1, -1)]) 'Not symmetric' >>> is_symmetric_tree(5, [(1, 2, 2), (2, -1, 3), (2, 3, -1), (3, -1, -1), (3, -1, -1)]) 'Not symmetric'","solution":"def is_symmetric_tree(n, nodes): Determines if the given n-node binary tree described by the adjacency list is symmetric. :param n: An integer representing the number of nodes in the tree. :param nodes: List of tuples representing the nodes where each tuple contains 3 integers (u, v_L, v_R). u: the node number, v_L: left child, v_R: right child. -1 if no child. :return: \\"Symmetric\\" if the tree is symmetric, otherwise \\"Not symmetric\\". from collections import deque # Helper function to check recursive mirrors def is_mirror(left, right): if left == -1 and right == -1: return True if left == -1 or right == -1: return False if left != right: return False return is_mirror(left_children[left], right_children[right]) and is_mirror(right_children[left], left_children[right]) if n == 1: return \\"Symmetric\\" left_children = [-1] * (n + 1) right_children = [-1] * (n + 1) for u, v_L, v_R in nodes: left_children[u] = v_L right_children[u] = v_R if is_mirror(left_children[1], right_children[1]): return \\"Symmetric\\" return \\"Not symmetric\\""},{"question":"def longest_consecutive_sequence_of_books(books) -> int: Returns the length of the longest sequence of consecutive books where each book has at least one common author with the next book. >>> books = [ ... (\\"The Great Gatsby\\", [\\"F.ScottFitzgerald\\"]), ... (\\"To Kill a Mockingbird\\", [\\"HarperLee\\"]), ... (\\"Go Set a Watchman\\", [\\"HarperLee\\"]), ... (\\"The Catcher in the Rye\\", [\\"J.D.Salinger\\"]), ... ] >>> longest_consecutive_sequence_of_books(books) 2 >>> books = [ ... (\\"The Great Gatsby\\", [\\"F.ScottFitzgerald\\"]), ... ] >>> longest_consecutive_sequence_of_books(books) 1 >>> books = [ ... (\\"The Great Gatsby\\", [\\"F.ScottFitzgerald\\"]), ... (\\"To Kill a Mockingbird\\", [\\"HarperLee\\"]), ... (\\"1984\\", [\\"GeorgeOrwell\\"]), ... (\\"Moby Dick\\", [\\"HermanMelville\\"]), ... ] >>> longest_consecutive_sequence_of_books(books) 1 >>> books = [ ... (\\"The Great Gatsby\\", [\\"F.ScottFitzgerald\\"]), ... (\\"This Side of Paradise\\", [\\"F.ScottFitzgerald\\"]), ... (\\"Tender is the Night\\", [\\"F.ScottFitzgerald\\"]), ... ] >>> longest_consecutive_sequence_of_books(books) 3 >>> books = [ ... (\\"Book1\\", [\\"A\\",\\"B\\"]), ... (\\"Book2\\", [\\"B\\",\\"C\\"]), ... (\\"Book3\\", [\\"C\\",\\"D\\"]), ... (\\"Book4\\", [\\"D\\",\\"E\\"]), ... (\\"Book5\\", [\\"F\\",\\"G\\"]), ... ] >>> longest_consecutive_sequence_of_books(books) 4 >>> books = [ ... (\\"Book1\\", [\\"A\\"]), ... (\\"Book2\\", [\\"A\\",\\"B\\"]), ... (\\"Book3\\", [\\"B\\",\\"C\\"]), ... (\\"Book4\\", [\\"D\\"]), ... (\\"Book5\\", [\\"D\\",\\"E\\"]), ... (\\"Book6\\", [\\"E\\"]), ... ] >>> longest_consecutive_sequence_of_books(books) 3 pass def parse_input(input_str: str): Parses the input string and returns a list of books with their titles and authors. pass","solution":"def longest_consecutive_sequence_of_books(books): Returns the length of the longest sequence of consecutive books that share at least one author with the next book. if not books: return 0 max_length = 1 current_length = 1 prev_authors = set(books[0][1]) for i in range(1, len(books)): current_authors = set(books[i][1]) if prev_authors & current_authors: # Find common authors current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 prev_authors = current_authors return max_length # Input parsing function def parse_input(input_str): lines = input_str.strip().split(\\"n\\") n = int(lines[0]) books = [] for i in range(1, n + 1): parts = lines[i].split(\\" \\") title = \\" \\".join(parts[:-1]) authors = parts[-1].split(\\",\\") # assuming authors are comma-separated books.append((title, authors)) return books"},{"question":"def can_make_heights_equal(n: int, heights: List[int]) -> str: Determines if it's possible to make all heights the same by performing the specified operation. pass def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[str]: Process multiple test cases to determine if it's possible to make all heights the same for each. Args: test_cases (List[Tuple[int, List[int]]]): List of tuples where each tuple contains the number of people and their heights. Returns: List[str]: A list containing \\"YES\\" or \\"NO\\" for each test case. pass # Sample usage: if __name__ == \\"__main__\\": input_data = [ (5, [2, 3, 2, 3, 2]), (4, [4, 4, 4, 4]) ] print(process_test_cases(input_data))","solution":"def can_make_heights_equal(n, heights): Determines if it's possible to make all heights the same by performing the specified operation. # If there's only one or less person, they are trivially equal if n <= 1: return \\"YES\\" heights_sorted = sorted(heights) min_height = heights_sorted[0] max_height = heights_sorted[-1] # As long as the maximum height minus the minimum height is 3 or more, # it's not possible to make them equal if max_height - min_height >= 3: return \\"NO\\" return \\"YES\\" def process_test_cases(test_cases): results = [] for n, heights in test_cases: result = can_make_heights_equal(n, heights) results.append(result) return results"},{"question":"class TreeHealthManagement: def __init__(self, health_scores): Initializes the TreeHealthManagement with a list of initial health scores. self.health_scores = health_scores def update_health(self, x, y): Updates the health score of the x-th tree to y. Args: x (int): The index of the tree to update (1-indexed). y (int): The new health score. pass def range_sum(self, l, r): Calculates the sum of health scores for trees from index l to r inclusive. Args: l (int): The starting index (1-indexed). r (int): The ending index (1-indexed). Returns: int: The sum of the health scores in the specified range. pass def process_operations(n, health_scores, operations): Processes a list of operations to update or query tree health scores. Args: n (int): Number of trees. health_scores (List[int]): Initial health scores of the trees. operations (List[str]): List of operations to process. Returns: List[int]: The results of the range sum queries. Example: >>> n = 5 >>> health_scores = [3, 8, 5, 6, 1] >>> operations = [\\"2 1 3\\", \\"1 4 10\\", \\"2 3 5\\", \\"2 1 5\\"] >>> process_operations(n, health_scores, operations) [16, 16, 27] pass","solution":"class TreeHealthManagement: def __init__(self, health_scores): self.health_scores = health_scores self.n = len(health_scores) def update_health(self, x, y): Updates the health score of the x-th tree to y. # Convert to zero-indexed self.health_scores[x-1] = y def range_sum(self, l, r): Calculates the sum of health scores for trees from index l to r inclusive. # Convert to zero-indexed sum_health = sum(self.health_scores[l-1:r]) return sum_health def process_operations(n, health_scores, operations): tree_manager = TreeHealthManagement(health_scores) result = [] for operation in operations: op = operation.split() if op[0] == '1': # Update operation x = int(op[1]) y = int(op[2]) tree_manager.update_health(x, y) elif op[0] == '2': # Range sum operation l = int(op[1]) r = int(op[2]) result.append(tree_manager.range_sum(l, r)) return result"},{"question":"def compress_rle(s: str) -> str: Compress the given string using Run-Length Encoding (RLE) algorithm. >>> compress_rle(\\"aaabbbcccaaa\\") \\"a3b3c3a3\\" >>> compress_rle(\\"abcd\\") \\"a1b1c1d1\\" def decompress_rle(s: str) -> str: Decompress the given RLE-compressed string to its original form. >>> decompress_rle(\\"a3b3c3a3\\") \\"aaabbbcccaaa\\" >>> decompress_rle(\\"a1b1c1d1\\") \\"abcd\\"","solution":"def compress_rle(s: str) -> str: Compresses the input string using the Run-Length Encoding (RLE) algorithm. if not s: return \\"\\" compressed = [] i = 0 while i < len(s): count = 1 while (i + 1) < len(s) and s[i] == s[i + 1]: i += 1 count += 1 compressed.append(f\\"{s[i]}{count}\\") i += 1 return \\"\\".join(compressed) def decompress_rle(s: str) -> str: Decompresses the RLE-compressed input string into its original form. if not s: return \\"\\" decompressed = [] i = 0 while i < len(s): char = s[i] i += 1 count = 0 while i < len(s) and s[i].isdigit(): count = count * 10 + int(s[i]) i += 1 decompressed.append(char * count) return \\"\\".join(decompressed)"},{"question":"def sum_of_magical_numbers(n): Returns the sum of the first N magical numbers. Each magical number is twice the previous number starting from 1. >>> sum_of_magical_numbers(1) 1 >>> sum_of_magical_numbers(2) 3 >>> sum_of_magical_numbers(3) 7 >>> sum_of_magical_numbers(4) 15 >>> sum_of_magical_numbers(5) 31 >>> sum_of_magical_numbers(6) 63 >>> sum_of_magical_numbers(7) 127 pass def process_test_cases(test_cases): Processes multiple test cases to find the sum of magical numbers for each case. >>> process_test_cases([1, 2, 3]) [1, 3, 7] >>> process_test_cases([4, 5, 6]) [15, 31, 63] >>> process_test_cases([7, 8, 9]) [127, 255, 511] >>> process_test_cases([10, 20, 30]) [1023, 1048575, 1073741823] pass","solution":"def sum_of_magical_numbers(n): Returns the sum of the first N magical numbers. Each magical number is twice the previous number starting from 1. sum_magic = 0 current_num = 1 for i in range(n): sum_magic += current_num current_num *= 2 return sum_magic def process_test_cases(test_cases): results = [] for n in test_cases: results.append(sum_of_magical_numbers(n)) return results"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.children = [] def build_tree(node_values, edges): nodes = [TreeNode(value) for value in node_values] for u, v in edges: nodes[u-1].children.append(nodes[v-1]) nodes[v-1].children.append(nodes[u-1]) return nodes[0] if nodes else None def subtree_sum(node, visited): if node is None or node in visited: return 0 visited.add(node) total = node.value for child in node.children: total += subtree_sum(child, visited) return total def max_subtree_sum(n, node_values, edges): Given a binary tree, find and return the maximum sum among all subtrees. >>> max_subtree_sum(5, [1, 0, 1, 1, 0], [(1, 2), (1, 3), (2, 4), (2, 5)]) 3 >>> max_subtree_sum(1, [1], []) 1 >>> max_subtree_sum(3, [0, 0, 0], [(1, 2), (1, 3)]) 0 >>> max_subtree_sum(4, [1, 1, 1, 1], [(1, 2), (1, 3), (2, 4)]) 4 >>> max_subtree_sum(4, [0, 1, 0, 1], [(1, 2), (2, 3), (3, 4)]) 2","solution":"class TreeNode: def __init__(self, value): self.value = value self.children = [] def build_tree(node_values, edges): nodes = [TreeNode(value) for value in node_values] for u, v in edges: nodes[u-1].children.append(nodes[v-1]) nodes[v-1].children.append(nodes[u-1]) return nodes[0] if nodes else None def subtree_sum(node, visited): if node is None or node in visited: return 0 visited.add(node) total = node.value for child in node.children: total += subtree_sum(child, visited) return total def max_subtree_sum(n, node_values, edges): if n == 0: return 0 # Build the tree root = build_tree(node_values, edges) # Find maximum subtree sum max_sum = float('-inf') for node in [root] + root.children: visited = set() current_sum = subtree_sum(node, visited) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def longest_palindromic_substring(s: str) -> int: Determines the length of the longest palindromic substring for a given string. >>> longest_palindromic_substring(\\"babad\\") 3 >>> longest_palindromic_substring(\\"cbbd\\") 2 def test_longest_palindromic_substring_single_char(): assert longest_palindromic_substring('a') == 1 def test_longest_palindromic_substring_all_different_chars(): assert longest_palindromic_substring('abc') == 1 def test_longest_palindromic_substring_simple_palindrome(): assert longest_palindromic_substring('racecar') == 7 def test_longest_palindromic_substring_two_char_palindrome(): assert longest_palindromic_substring('aa') == 2 def test_longest_palindromic_substring_mixed_chars(): assert longest_palindromic_substring('babad') == 3 def test_longest_palindromic_substring_substring_start(): assert longest_palindromic_substring('abacdfgdcaba') == 3 def test_longest_palindromic_substring_substring_middle(): assert longest_palindromic_substring('cbbd') == 2 def test_longest_palindromic_substring_long_string(): assert longest_palindromic_substring('abcda') == 1 def test_longest_palindromic_substring_multiple_palindromes(): assert longest_palindromic_substring('bananas') == 5 # \\"anana\\"","solution":"def longest_palindromic_substring(s: str) -> int: def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return right - left - 1 if s is None or len(s) < 1: return 0 start = 0 end = 0 for i in range(len(s)): len1 = expand_around_center(s, i, i) len2 = expand_around_center(s, i, i + 1) max_len = max(len1, len2) if max_len > end - start: start = i - (max_len - 1) // 2 end = i + max_len // 2 return end - start + 1"},{"question":"def can_divide_social_network(N: int, M: int, relationships: List[Tuple[int, int, int]]) -> str: Determine if it is possible to divide the residents into two groups such that each group contains only friends and all enmities are between the two groups. >>> can_divide_social_network(4, 4, [(0, 1, 1), (1, 2, -1), (2, 3, 1), (3, 0, -1)]) \\"YES\\" >>> can_divide_social_network(3, 3, [(0, 1, 1), (1, 2, -1), (2, 0, 1)]) \\"NO\\" pass def test_can_divide_social_network(): assert can_divide_social_network(4, 4, [(0, 1, 1), (1, 2, -1), (2, 3, 1), (3, 0, -1)]) == \\"YES\\" assert can_divide_social_network(3, 3, [(0, 1, 1), (1, 2, -1), (2, 0, 1)]) == \\"NO\\" assert can_divide_social_network(6, 6, [(0, 1, 1), (1, 2, 1), (3, 4, 1), (4, 5, 1), (2, 3, -1), (0, 5, -1)]) == \\"YES\\" assert can_divide_social_network(5, 4, [(0, 1, -1), (1, 2, -1), (2, 3, 1), (3, 4, -1)]) == \\"YES\\" assert can_divide_social_network(5, 5, [(0, 1, 1), (1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 0, 1)]) == \\"YES\\" assert can_divide_social_network(5, 5, [(0, 1, -1), (1, 2, -1), (2, 3, -1), (3, 4, -1), (4, 0, -1)]) == \\"NO\\" if __name__ == \\"__main__\\": test_can_divide_social_network() print(\\"All tests passed.\\")","solution":"def can_divide_social_network(N, M, relationships): from collections import defaultdict, deque graph = defaultdict(list) for A, B, R in relationships: if R == 1: graph[A].append((B, 1)) graph[B].append((A, 1)) else: graph[A].append((B, -1)) graph[B].append((A, -1)) colors = [-1] * N def bfs(node): queue = deque([(node, 0)]) while queue: current, color = queue.popleft() if colors[current] != -1: if colors[current] != color: return False continue colors[current] = color for neighbor, rel in graph[current]: if rel == 1: queue.append((neighbor, color)) else: queue.append((neighbor, 1 - color)) return True for i in range(N): if colors[i] == -1: if not bfs(i): return \\"NO\\" return \\"YES\\""},{"question":"from typing import List def largest_palindrome_smaller_or_equal_to_n(n: int) -> int: Karthik is fascinated by palindromic numbers. A palindromic number is a number that remains the same when its digits are reversed. One day, he came across a challenge to find the largest palindromic number that can be formed using the digits of a given number. However, the formed palindromic number must be smaller than or equal to the original number. Karthik finds this problem intriguing and seeks your help to solve it. Args: n (int): The given number. Returns: int: The largest palindromic number that can be formed using the digits of N and is less than or equal to N. If no such number exists, return \\"-1\\". >>> largest_palindrome_smaller_or_equal_to_n(32123) 32123 >>> largest_palindrome_smaller_or_equal_to_n(12345) -1 >>> largest_palindrome_smaller_or_equal_to_n(9876) -1 >>> largest_palindrome_smaller_or_equal_to_n(222222) 222222 >>> largest_palindrome_smaller_or_equal_to_n(120021) 120021 >>> largest_palindrome_smaller_or_equal_to_n(100001) 100001 def process_test_cases(T: int, test_cases: List[int]) -> List[int]: Processes multiple test cases for finding the largest palindromic number that can be formed using the digits of a given number and is less than or equal to the original number. Args: T (int): The number of test cases. test_cases (List[int]): A list containing the test case numbers. Returns: List[int]: A list of results for each test case. >>> process_test_cases(3, [32123, 12345, 9876]) [32123, -1, -1] >>> process_test_cases(2, [222222, 120021]) [222222, 120021] >>> process_test_cases(1, [100001]) [100001]","solution":"def largest_palindrome_smaller_or_equal_to_n(n): digits = sorted(str(n), reverse=True) def is_palindrome(s): return s == s[::-1] from itertools import permutations for perm in sorted(permutations(digits), reverse=True): candidate = ''.join(perm) if candidate <= str(n) and is_palindrome(candidate): return int(candidate) return -1 def process_test_cases(T, test_cases): results = [] for n in test_cases: results.append(largest_palindrome_smaller_or_equal_to_n(n)) return results"},{"question":"def largest_prime_factor(n: int) -> int: Returns the largest prime factor of a given integer. >>> largest_prime_factor(10) 5 >>> largest_prime_factor(15) 5 >>> largest_prime_factor(21) 7 >>> largest_prime_factor(29) 29 >>> largest_prime_factor(49) 7 def largestPrimeFactors(numbers: List[int]) -> List[int]: Finds the largest prime factor for each integer in the given list and returns them in the same order. >>> largestPrimeFactors([10, 15, 21, 29, 49]) [5, 5, 7, 29, 7] >>> largestPrimeFactors([1, 2, 3]) [1, 2, 3] from solution import largestPrimeFactors def test_largest_prime_factors_single_elements(): assert largestPrimeFactors([10]) == [5] assert largestPrimeFactors([15]) == [5] assert largestPrimeFactors([21]) == [7] assert largestPrimeFactors([29]) == [29] assert largestPrimeFactors([49]) == [7] assert largestPrimeFactors([1]) == [1] assert largestPrimeFactors([2]) == [2] assert largestPrimeFactors([3]) == [3] def test_largest_prime_factors_multiple_elements(): assert largestPrimeFactors([10, 15, 21, 29, 49]) == [5, 5, 7, 29, 7] assert largestPrimeFactors([1, 2, 3]) == [1, 2, 3] assert largestPrimeFactors([1, 4, 6, 25, 48, 97]) == [1, 2, 3, 5, 3, 97] def test_largest_prime_factors_edge_cases(): assert largestPrimeFactors([1000000000]) == [5] assert largestPrimeFactors([999999937]) == [999999937] def test_largest_prime_factors_large_input_size(): numbers = [15] * 100000 expected_output = [5] * 100000 assert largestPrimeFactors(numbers) == expected_output","solution":"def largest_prime_factor(n): if n <= 1: return 1 max_prime = -1 while n % 2 == 0: max_prime = 2 n //= 2 for i in range(3, int(n**0.5) + 1, 2): while n % i == 0: max_prime = i n //= i if n > 2: max_prime = n return max_prime def largestPrimeFactors(numbers): return [largest_prime_factor(num) for num in numbers]"},{"question":"def smallest_positive_missing_integer(arr: List[int]) -> int: Determine the smallest positive integer that cannot be formed using the sum of any subset of an array of positive integers. >>> smallest_positive_missing_integer([1, 2, 3]) 7 >>> smallest_positive_missing_integer([1, 1, 1, 1]) 5 >>> smallest_positive_missing_integer([1, 2, 5, 10, 20]) 4","solution":"def smallest_positive_missing_integer(arr): arr.sort() # Sorts the array in non-decreasing order result = 1 # Initialize the smallest positive integer that cannot be formed for num in arr: if num > result: break result += num return result"},{"question":"def accumulate(nums: List[int]) -> List[int]: Return a new list where each element at index i is the sum of the first i + 1 elements from the original list. Args: nums (List[int]): A list of integers. Returns: List[int]: A new list with the accumulated sums. Examples: >>> accumulate([1, 2, 3, 4]) [1, 3, 6, 10] >>> accumulate([4, 0, -1, 2]) [4, 4, 3, 5] >>> accumulate([1, 1, 1, 1, 1]) [1, 2, 3, 4, 5] >>> accumulate([3]) [3] >>> accumulate([]) []","solution":"def accumulate(nums): Returns a new list where each element at index i is the sum of the first i+1 elements from the original list. accumulated_list = [] current_sum = 0 for num in nums: current_sum += num accumulated_list.append(current_sum) return accumulated_list"},{"question":"def can_form_sequence(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determines if Vlad can form a sequence of coins such that no two consecutive coins are of the same type. Args: t : int : number of test cases test_cases : List[Tuple[int, List[int]]] : list of test cases where each test case is a tuple containing an integer \`n\` and a list of integers \`a\` Returns: List[str] : list of results, \\"YES\\" or \\"NO\\" for each test case >>> can_form_sequence(3, [(2, [1, 1]), (3, [3, 1, 2]), (4, [2, 3, 1, 1])]) ['YES', 'YES', 'YES'] >>> can_form_sequence(1, [(1, [10])]) ['NO']","solution":"def can_form_sequence(t, test_cases): results = [] for case in test_cases: n, a = case[0], case[1] max_coins = max(a) sum_coins = sum(a) if max_coins <= (sum_coins - max_coins) + 1: results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Preparing test cases for the function t = 3 test_cases = [ (2, [1, 1]), (3, [3, 1, 2]), (4, [2, 3, 1, 1]) ] # Run the function with the above test cases result = can_form_sequence(t, test_cases) for res in result: print(res)"},{"question":"def count_primes(n: int) -> int: Returns the number of prime numbers less than n. Args: n (int): the upper limit (exclusive) to count primes less than Returns: int: count of prime numbers less than n Examples: >>> count_primes(10) 4 >>> count_primes(20) 8 >>> count_primes(1) 0","solution":"def count_primes(n): Returns the number of prime numbers less than n. Args: n: int - the upper limit (exclusive) to count primes less than Returns: int - count of prime numbers less than n if n <= 2: return 0 sieve = [True] * n sieve[0] = sieve[1] = False for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n, start): sieve[multiple] = False return sum(sieve)"},{"question":"def palindromic_prime_digit_numbers(n: int) -> List[int]: Returns a list of all integers in the range [1, n] (inclusive) that are palindromic and that consist of prime digits only. >>> palindromic_prime_digit_numbers(1) == [] >>> palindromic_prime_digit_numbers(10) == [2, 3, 5, 7] >>> palindromic_prime_digit_numbers(50) == [2, 3, 5, 7, 22, 33]","solution":"def is_palindromic(num): Helper function to determine if a number is palindromic. s = str(num) return s == s[::-1] def has_prime_digits_only(num): Helper function to determine if a number contains only prime digits (2, 3, 5, 7). prime_digits = {'2', '3', '5', '7'} return all(digit in prime_digits for digit in str(num)) def palindromic_prime_digit_numbers(n): Returns a list of all integers in the range [1, n] (inclusive) that are palindromic and that consist of prime digits only. result = [] for i in range(1, n + 1): if is_palindromic(i) and has_prime_digits_only(i): result.append(i) return result"},{"question":"def is_balanced(sequence: str) -> str: Determines if the given sequence of parentheses is balanced. >>> is_balanced(\\"()[]{}\\") == \\"YES\\" >>> is_balanced(\\"([{}])\\") == \\"YES\\" >>> is_balanced(\\"({[}])\\") == \\"NO\\"","solution":"def is_balanced(sequence): Determines if the given sequence of parentheses is balanced. Parameters: sequence (str): The sequence of parentheses to be checked. Returns: str: \\"YES\\" if the sequence is balanced, \\"NO\\" otherwise. stack = [] matching_parenthesis = {')': '(', '}': '{', ']': '['} for char in sequence: if char in matching_parenthesis.values(): stack.append(char) elif char in matching_parenthesis.keys(): if stack and stack[-1] == matching_parenthesis[char]: stack.pop() else: return \\"NO\\" return \\"YES\\" if not stack else \\"NO\\""},{"question":"from typing import List, Tuple, Dict, Set def merge_collections(chests: List[List[Tuple[str, str]]]) -> Dict[str, Set[str]]: Merges collections from multiple chests and returns the total number of distinct items in each category. >>> chests = [ >>> [('sword', 'weapon'), ('shield', 'armor'), ('potion', 'potion')], >>> [('bow', 'weapon'), ('potion', 'potion'), ('helmet', 'armor')], >>> [('axe', 'weapon'), ('potion', 'potion'), ('sword', 'weapon')] >>> ] >>> merge_collections(chests) { 'weapon': {'sword', 'bow', 'axe'}, 'armor': {'shield', 'helmet'}, 'potion': {'potion'} } pass","solution":"from typing import List, Tuple, Dict, Set def merge_collections(chests: List[List[Tuple[str, str]]]) -> Dict[str, Set[str]]: result = {} for chest in chests: for item, category in chest: if category not in result: result[category] = set() result[category].add(item) return result"},{"question":"def obfuscate_string(s: str) -> str: Obfuscates the input string by reversing every vowel in the word while keeping all other characters in their original positions. >>> obfuscate_string(\\"hello\\") \\"holle\\" >>> obfuscate_string(\\"programming\\") \\"prigrammong\\" >>> obfuscate_string(\\"bcdfghjklmnpqrstvwxyz\\") \\"bcdfghjklmnpqrstvwxyz\\" >>> obfuscate_string(\\"a\\") \\"a\\" >>> obfuscate_string(\\"aeiou\\") \\"uoiea\\" >>> obfuscate_string(\\"amazing\\") \\"imazang\\" >>> obfuscate_string(\\"a\\" * 100000) \\"a\\" * 100000","solution":"def obfuscate_string(s): Obfuscates the input string by reversing every vowel in the word while keeping all other characters in their original positions. vowels = 'aeiou' # Extract the vowels from the input string in the order they appear vowel_list = [char for char in s if char in vowels] # Reverse the list of vowels vowel_list.reverse() # List to hold the result characters result = [] # Iterator for the reversed vowel list vowel_iter = iter(vowel_list) for char in s: if char in vowels: # Replace vowel with the next vowel in the reversed list result.append(next(vowel_iter)) else: # Keep non-vowel characters in the same position result.append(char) return ''.join(result)"},{"question":"def is_happy_number(n: int) -> bool: Determines if the number n is a happy number. def check_numbers(numbers): For a list of numbers, determine if each number is a happy number. For every number, return \\"ALEX IS HAPPY\\" if it is a happy number, otherwise return \\"ALEX IS SAD\\". from solution import is_happy_number, check_numbers def test_is_happy_number(): assert is_happy_number(19) == True assert is_happy_number(20) == False assert is_happy_number(7) == True assert is_happy_number(1) == True assert is_happy_number(2) == False def test_check_numbers(): assert check_numbers([19, 20, 7]) == [\\"ALEX IS HAPPY\\", \\"ALEX IS SAD\\", \\"ALEX IS HAPPY\\"] assert check_numbers([1, 2, 3, 4, 5]) == [\\"ALEX IS HAPPY\\", \\"ALEX IS SAD\\", \\"ALEX IS SAD\\", \\"ALEX IS SAD\\", \\"ALEX IS SAD\\"] assert check_numbers([10, 100, 103]) == [\\"ALEX IS HAPPY\\", \\"ALEX IS HAPPY\\", \\"ALEX IS HAPPY\\"]","solution":"def is_happy_number(n: int) -> bool: Determines if the number n is a happy number. def get_next(number): total_sum = 0 while number > 0: number, digit = divmod(number, 10) total_sum += digit ** 2 return total_sum seen = set() while n != 1 and n not in seen: seen.add(n) n = get_next(n) return n == 1 def check_numbers(numbers): results = [] for number in numbers: if is_happy_number(number): results.append(\\"ALEX IS HAPPY\\") else: results.append(\\"ALEX IS SAD\\") return results"},{"question":"from typing import List def canFindPath(grid: List[List[int]]) -> bool: Determines if there is a valid path from the top-left to the bottom-right corner of the grid, following the specified movement rules. >>> canFindPath([[0, 0, 1], [0, 1, 0], [0, 0, 0]]) True >>> canFindPath([[0, 1, 0], [1, 0, 0], [0, 0, 0]]) False def test_simple_path(): grid = [[0, 0], [0, 0]] assert canFindPath(grid) == True # Path: Right -> Down def test_blocked_start(): grid = [[1, 0], [0, 0]] assert canFindPath(grid) == False def test_blocked_end(): grid = [[0, 0], [0, 1]] assert canFindPath(grid) == False def test_no_path(): grid = [[0, 1, 0], [1, 0, 0], [0, 0, 0]] assert canFindPath(grid) == False def test_found_path(): grid = [[0, 0, 1], [0, 1, 0], [0, 0, 0]] assert canFindPath(grid) == True def test_complex_path(): grid = [ [0, 0, 0], [1, 1, 0], [1, 0, 0] ] assert canFindPath(grid) == True # Path: Right -> Right -> Down -> Down def test_large_grid(): grid = [ [0]*1000 for _ in range(1000) ] grid[0][999] = 1 assert canFindPath(grid) == True # Path is still possible despite (0, 999) being blocked def test_filled_with_blocks(): grid = [ [1]*5 for _ in range(5) ] grid[0][0] = 0 grid[4][4] = 0 assert canFindPath(grid) == False # No path available as all cells are blocked","solution":"def canFindPath(grid): Determines if there is a valid path from the top-left to the bottom-right corner of the grid, following the rules specified. :param grid: List of List of int, representing the N x M grid :return: bool, True if there is a valid path, False otherwise if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return False N, M = len(grid), len(grid[0]) from collections import deque queue = deque([(0, 0)]) directions = [(1, 0), (0, 1)] while queue: x, y = queue.popleft() if (x, y) == (N-1, M-1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] == 0: queue.append((nx, ny)) grid[nx][ny] = 2 # Mark visited path return False"},{"question":"def is_beautiful_sequence_possible(N: int) -> tuple: Determine if a sequence of length N can be a Beautiful sequence. Parameters: N (int): Length of the sequence Returns: tuple: (\\"YES\\", sequence) if a Beautiful sequence is possible, otherwise (\\"NO\\", []) >>> is_beautiful_sequence_possible(1) (\\"YES\\", [1]) >>> is_beautiful_sequence_possible(2) (\\"YES\\", [1, 2]) >>> is_beautiful_sequence_possible(3) (\\"NO\\", []) >>> is_beautiful_sequence_possible(4) (\\"YES\\", [1, 2, 1, 2]) >>> is_beautiful_sequence_possible(5) (\\"YES\\", [1, 2, 1, 2, 1]) >>> is_beautiful_sequence_possible(6) (\\"YES\\", [1, 2, 1, 2, 1, 2]) pass def beautiful_sequence_solver(T: int, test_cases: list) -> list: Solver that processes multiple test cases to determine if Beautiful sequences are possible. Parameters: T (int): Number of test cases test_cases (list): List of integers representing the lengths of sequences to check Returns: list: Results for each test case either \\"NO\\" or \\"YES\\" followed by the sequence >>> beautiful_sequence_solver(3, [3, 4, 5]) [\\"NO\\", \\"YES 1 2 1 2\\", \\"YES 1 2 1 2 1\\"] >>> beautiful_sequence_solver(2, [1, 2]) [\\"YES 1\\", \\"YES 1 2\\"] >>> beautiful_sequence_solver(1, [6]) [\\"YES 1 2 1 2 1 2\\"] pass","solution":"def is_beautiful_sequence_possible(N): if N == 1: return \\"YES\\", [1] elif N == 2: return \\"YES\\", [1, 2] elif N == 3: return \\"NO\\", [] else: sequence = [] for i in range(N): sequence.append((i % 2) + 1) return \\"YES\\", sequence def beautiful_sequence_solver(T, test_cases): results = [] for case in test_cases: N = case result, sequence = is_beautiful_sequence_possible(N) if result == \\"YES\\": results.append(f\\"{result} {' '.join(map(str, sequence))}\\") else: results.append(result) return results"},{"question":"def minOperationsToEqual(nums: List[int]) -> int: Given an array of integers, returns the minimum number of operations to make all elements equal. Operations allowed: Add or subtract 1 from any element in the array. >>> minOperationsToEqual([1, 2, 3]) 2 >>> minOperationsToEqual([1, 10, 2, 9]) 16 >>> minOperationsToEqual([5, 5, 5, 5]) 0 >>> minOperationsToEqual([1, 2]) 1 >>> minOperationsToEqual([0]) 0 >>> minOperationsToEqual(list(range(100000))) 2500000000 >>> minOperationsToEqual([-10, 0, 10]) 20","solution":"def minOperationsToEqual(nums): Given an array of integers, returns minimum number of operations to make all elements equal. Operations allowed: Add or subtract 1 from any element in the array. nums.sort() median = nums[len(nums) // 2] return sum(abs(num - median) for num in nums)"},{"question":"def knight_moves(position): Given a knight's position on a chessboard, return all possible moves. Parameters: position (str): The current position of the knight, e.g. 'E4' Returns: list: A list of all valid moves the knight can make, sorted lexicographically. Examples: >>> knight_moves(\\"E4\\") [\\"C3\\", \\"C5\\", \\"D2\\", \\"D6\\", \\"F2\\", \\"F6\\", \\"G3\\", \\"G5\\"] >>> knight_moves(\\"A1\\") [\\"B3\\", \\"C2\\"]","solution":"def knight_moves(position): Given a knight's position on a chessboard, return all possible moves. Parameters: position (str): The current position of the knight, e.g. 'E4' Returns: list: A list of all valid moves the knight can make, sorted lexicographically. col, row = position[0], int(position[1]) # All possible moves a knight can make from any given position moves = [ (-2, -1), (-2, 1), (2, -1), (2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2) ] # Convert column letter to number (A=1, B=2, ..., H=8) col_to_int = ord(col) - ord('A') + 1 valid_moves = [] for move in moves: new_col = col_to_int + move[0] new_row = row + move[1] # Check if the new position is within the bounds of the chessboard if 1 <= new_col <= 8 and 1 <= new_row <= 8: # Convert column number back to letter new_col_letter = chr(new_col + ord('A') - 1) valid_moves.append(f\\"{new_col_letter}{new_row}\\") # Sort the moves lexicographically valid_moves.sort() return valid_moves"},{"question":"def is_valid_domino_sequence(n: int, dominos: List[Tuple[int, int]]) -> str: Determine if a sequence of domino tiles forms a valid placement. Parameters: - n (int): The number of domino tiles. - dominos (list of tuples): List of tuples where each tuple represents a domino tile (a_i, b_i). Returns: - str: \\"YES\\" if the sequence can form a valid placement, otherwise \\"NO\\". >>> is_valid_domino_sequence(4, [(1, 2), (2, 3), (3, 4), (4, 5)]) == \\"YES\\" >>> is_valid_domino_sequence(3, [(1, 6), (2, 3), (4, 5)]) == \\"NO\\" >>> is_valid_domino_sequence(2, [(4, 1), (1, 4)]) == \\"YES\\"","solution":"def is_valid_domino_sequence(n, dominos): Determines if a sequence of domino tiles forms a valid placement. Parameters: n (int): The number of domino tiles. dominos (list of tuples): List of tuples where each tuple represents a domino tile (a_i, b_i). Returns: str: \\"YES\\" if the sequence can form a valid placement, otherwise \\"NO\\". def dfs(tile, visited, path): Depth First Search to check all possible permutations. if len(path) == n: return True for i, (a, b) in enumerate(dominos): if not visited[i]: if tile[1] == a: visited[i] = True if dfs((a, b), visited, path + [i]): return True visited[i] = False if tile[1] == b: visited[i] = True if dfs((b, a), visited, path + [i]): return True visited[i] = False return False for i, (a, b) in enumerate(dominos): visited = [False] * n visited[i] = True if dfs((a, b), visited, [i]) or dfs((b, a), visited, [i]): return \\"YES\\" return \\"NO\\""},{"question":"def unique_paths(m: int, n: int) -> int: Returns the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid. >>> unique_paths(2, 3) 3 >>> unique_paths(3, 3) 6 >>> unique_paths(1, 1) 1","solution":"def unique_paths(m, n): Returns the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid. if m == 0 or n == 0: return 0 # Create a 2D list to store the number of paths to reach each cell dp = [[1] * n for _ in range(m)] # Fill the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"def replace_patterns(n: int, patterns_replacements: List[Tuple[str, str]], text: str) -> str: Replaces all occurrences of patterns in the text with their corresponding replacements. :param n: Number of patterns :param patterns_replacements: A list containing pairs of pattern and replacement :param text: The input text string where replacements are to be made :return: Modified text string after replacements >>> n = 2 >>> patterns_replacements = [(\\"abc\\", \\"123\\"), (\\"def\\", \\"456\\")] >>> text = \\"abcdef defabc\\" >>> replace_patterns(n, patterns_replacements, text) '123456 456123' >>> n = 1 >>> patterns_replacements = [(\\"hello\\", \\"hi\\")] >>> text = \\"hello world\\" >>> replace_patterns(n, patterns_replacements, text) 'hi world' >>> n = 2 >>> patterns_replacements = [(\\"cat\\", \\"dog\\"), (\\"mouse\\", \\"rat\\")] >>> text = \\"the quick brown fox\\" >>> replace_patterns(n, patterns_replacements, text) 'the quick brown fox' >>> n = 1 >>> patterns_replacements = [(\\"a\\", \\"b\\")] >>> text = \\"aa aa aa\\" >>> replace_patterns(n, patterns_replacements, text) 'bb bb bb' >>> n = 2 >>> patterns_replacements = [(\\"foo\\", \\"bar\\"), (\\"baz\\", \\"qux\\")] >>> text = \\"foo baz foo baz foo\\" >>> replace_patterns(n, patterns_replacements, text) 'bar qux bar qux bar' # Your code here","solution":"def replace_patterns(n, patterns_replacements, text): Replaces all occurrences of patterns in the text with their corresponding replacements. :param n: Number of patterns :param patterns_replacements: A list containing pairs of pattern and replacement :param text: The input text string where replacements are to be made :return: Modified text string after replacements for pattern, replacement in patterns_replacements: text = text.replace(pattern, replacement) return text"},{"question":"def generate_pattern(n: int, m_sizes: List[int]) -> str: Generate patterns for given sizes of canvases. Parameters: n (int): Number of test cases. m_sizes (list): List of integers denoting the size of each canvas. Returns: str: A string representation of the patterns for each test case separated by blank lines. >>> generate_pattern(1, [3]) '1n2 3n4 5 6' >>> generate_pattern(1, [4]) '1n2 3n4 5 6n7 8 9 10' >>> generate_pattern(2, [3, 4]) '1n2 3n4 5 6nn1n2 3n4 5 6n7 8 9 10'","solution":"def generate_pattern(n, m_sizes): This function generates patterns for given sizes of canvases. Parameters: n (int): Number of test cases. m_sizes (list): List contains M size for each test case. Returns: list: List of patterns for each test case separated by blank lines result = [] for m in m_sizes: current_number = 1 canvas = [] for i in range(1, m + 1): row = [] for j in range(i): row.append(current_number) current_number += 1 canvas.append(\\" \\".join(map(str, row))) result.append(\\"n\\".join(canvas)) return \\"nn\\".join(result) # Example usage: # number_of_cases = 2 # sizes = [3, 4] # output = generate_pattern(number_of_cases, sizes) # print(output)"},{"question":"def count_special_substrings(s: str) -> int: Returns the count of special substrings in the binary string s. A binary string is defined as \\"special\\" if it satisfies the following two conditions: 1. The number of '0's is equal to the number of '1's. 2. The relative positions of the '0's and '1's remain the same in any valid substring i.e. if the first instance of '0' occurs before the first instance of '1', then in every prefix of the substring which contains an equal number of '0's and '1's, the number of '0's is always greater than or equal to the number of '1's. >>> count_special_substrings(\\"00110011\\") 6 >>> count_special_substrings(\\"10101\\") 4 pass from solution import count_special_substrings def test_example_1(): assert count_special_substrings(\\"00110011\\") == 6 def test_example_2(): assert count_special_substrings(\\"10101\\") == 4 def test_single_character(): assert count_special_substrings(\\"0\\") == 0 assert count_special_substrings(\\"1\\") == 0 def test_double_character(): assert count_special_substrings(\\"01\\") == 1 assert count_special_substrings(\\"10\\") == 1 def test_no_special_substring(): assert count_special_substrings(\\"000111\\") == 3 assert count_special_substrings(\\"111000\\") == 3 def test_large_string(): s = \\"0\\" * 50000 + \\"1\\" * 50000 assert count_special_substrings(s) == 50000","solution":"def count_special_substrings(s): Returns the count of special substrings in the binary string s. n = len(s) count = 0 prev_run_length = 0 current_run_length = 1 for i in range(1, n): if s[i] == s[i - 1]: current_run_length += 1 else: count += min(prev_run_length, current_run_length) prev_run_length = current_run_length current_run_length = 1 count += min(prev_run_length, current_run_length) return count"},{"question":"def max_attendees(n: int, times: List[str]) -> int: Find the maximum number of attendees present at the summit at any given time. Args: n (int): Number of attendees times (List[str]): List of strings representing arrival and departure times in 'hh:mm-hh:mm' format Returns: int: Maximum number of attendees present at the summit at any given time >>> max_attendees(5, [\\"09:00-11:00\\", \\"10:00-12:00\\", \\"11:00-13:00\\", \\"10:30-11:30\\", \\"12:00-13:30\\"]) 3 >>> max_attendees(4, [\\"08:00-09:00\\", \\"09:00-10:00\\", \\"10:00-11:00\\", \\"08:30-09:30\\"]) 2 from typing import List def test_example_1(): n = 5 times = [\\"09:00-11:00\\", \\"10:00-12:00\\", \\"11:00-13:00\\", \\"10:30-11:30\\", \\"12:00-13:30\\"] assert max_attendees(n, times) == 3 def test_example_2(): n = 4 times = [\\"08:00-09:00\\", \\"09:00-10:00\\", \\"10:00-11:00\\", \\"08:30-09:30\\"] assert max_attendees(n, times) == 2 def test_single_attendee(): n = 1 times = [\\"09:00-10:00\\"] assert max_attendees(n, times) == 1 def test_no_overlap(): n = 3 times = [\\"09:00-10:00\\", \\"10:00-11:00\\", \\"11:00-12:00\\"] assert max_attendees(n, times) == 1 def test_all_same_time(): n = 3 times = [\\"09:00-10:00\\", \\"09:00-10:00\\", \\"09:00-10:00\\"] assert max_attendees(n, times) == 3 def test_overlapping_times(): n = 3 times = [\\"09:00-11:00\\", \\"10:00-12:00\\", \\"11:00-13:00\\"] assert max_attendees(n, times) == 2","solution":"def max_attendees(n, times): events = [] # Split the input times and create events for time in times: start, end = time.split('-') events.append((start, 'arrival')) events.append((end, 'departure')) # Sort events: first by time, then departures before arrivals if times are the same events.sort(key=lambda x: (x[0], x[1] == 'arrival')) max_attendees = 0 current_attendees = 0 # Traverse through events to determine max attendees at any time for time, event in events: if event == 'arrival': current_attendees += 1 max_attendees = max(max_attendees, current_attendees) else: # departure current_attendees -= 1 return max_attendees"},{"question":"def remove_duplicates(arr): Returns a new array with duplicate integers removed while maintaining the order of first occurrences. >>> remove_duplicates([1, 2, 3, 1, 2, 4, 5, 3, 6]) [1, 2, 3, 4, 5, 6] >>> remove_duplicates([4, 4, 4, 4, 4]) [4]","solution":"def remove_duplicates(arr): Returns a new array with duplicate integers removed while maintaining the order of first occurrences. seen = set() result = [] for num in arr: if num not in seen: seen.add(num) result.append(num) return result"},{"question":"def charity_walkathon_badge(input_str: str) -> str: Process the input and return unique badge representations for each participant, one per line, in the format \\"ID followed by unique short name\\". >>> charity_walkathon_badge(\\"1n3n1 John Doen2 Jane Doen3 Jack Doe\\") '1 JDoen2 JaDoen3 JacDoe' # Function implementation goes here def test_single_case(): input_data = \\"1n3n1 John Doen2 Jane Doen3 Jack Doe\\" expected_output = \\"1 JDoen2 JaDoen3 JacDoe\\" assert charity_walkathon_badge(input_data) == expected_output def test_multiple_cases(): input_data = 2 3 1 John Doe 2 Jane Doe 3 Jack Doe 2 1 Alice Brown 2 Alan Brown expected_output = \\"1 JDoen2 JaDoen3 JacDoen1 ABrownn2 AlBrown\\" assert charity_walkathon_badge(input_data) == expected_output def test_no_duplicate_names(): input_data = \\"1n2n1 Alice Greenn2 Bob Brown\\" expected_output = \\"1 AGreenn2 BBrown\\" assert charity_walkathon_badge(input_data) == expected_output def test_multiple_participants_with_same_initials(): input_data = \\"1n4n1 John Smithn2 Johnny Smithn3 Jonathan Smithn4 Johanna Smith\\" expected_output = \\"1 JSmithn2 JoSmithn3 JonSmithn4 JohSmith\\" assert charity_walkathon_badge(input_data) == expected_output def test_edge_case_single_participant(): input_data = \\"1n1n1 Zoe Patterson\\" expected_output = \\"1 ZPatterson\\" assert charity_walkathon_badge(input_data) == expected_output","solution":"def generate_badges(test_cases): from collections import defaultdict results = [] for test_case in test_cases: M, participants = test_case id_name_dict = {} unique_badges = defaultdict(list) # To store all attempted and successful short names for unique constraints final_badges = {} for participant in participants: pid, first_name, last_name = participant.split() pid = int(pid) id_name_dict[pid] = (first_name, last_name) initial_length = 1 while True: short_name = first_name[:initial_length] + last_name if short_name not in unique_badges[last_name]: unique_badges[last_name].append(short_name) final_badges[pid] = short_name break initial_length += 1 for pid in range(1, M+1): if pid in final_badges: results.append(f\\"{pid} {final_badges[pid]}\\") return results def parse_input(input_str): lines = input_str.strip().split(\\"n\\") T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): M = int(lines[index]) participants = lines[index+1:index+1+M] test_cases.append((M, participants)) index += M + 1 return test_cases def parse_output(results): return \\"n\\".join(results) def charity_walkathon_badge(input_str): test_cases = parse_input(input_str) results = generate_badges(test_cases) return parse_output(results)"},{"question":"def longest_same_subarray_length(arr: List[int]) -> int: Returns the length of the longest subarray where all elements are the same. >>> longest_same_subarray_length([1, 1, 2, 2, 2, 3, 3, 3, 3, 1]) 4 >>> longest_same_subarray_length([1, 1, 2, 2, 2, 3, 3, 3, 1, 1]) 3 >>> longest_same_subarray_length([1, 1, 1, 1, 1]) 5 >>> longest_same_subarray_length([1, 2]) 1","solution":"def longest_same_subarray_length(arr): Returns the length of the longest subarray where all elements are the same. if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] == arr[i - 1]: current_length += 1 else: if current_length > max_length: max_length = current_length current_length = 1 return max(max_length, current_length)"},{"question":"def can_schedule(n: int, k: int, m: int, t: List[int]) -> str: Determines if meetings can be scheduled according to given rules. Parameters: n (int): Number of time slots. k (int): Maximum number of consecutive work-related tasks allowed. m (int): Maximum number of consecutive breaks allowed. t (list of int): John's daily schedule (1 for work-related task, 0 for break). Returns: str: \\"YES\\" if meetings can be scheduled according to the rules, \\"NO\\" otherwise. >>> can_schedule(8, 3, 2, [1, 1, 1, 0, 1, 0, 0, 1]) \\"YES\\" >>> can_schedule(10, 2, 2, [1, 1, 1, 0, 0, 1, 1, 1, 0, 0]) \\"NO\\" >>> can_schedule(5, 2, 3, [1, 1, 0, 0, 0]) \\"YES\\" >>> can_schedule(6, 2, 3, [1, 1, 1, 0, 1, 1]) \\"NO\\" >>> can_schedule(7, 3, 2, [1, 0, 0, 0, 1, 1, 1]) \\"NO\\" >>> can_schedule(4, 3, 2, [1, 1, 1, 1]) \\"NO\\" >>> can_schedule(4, 3, 2, [0, 0, 0, 0]) \\"NO\\"","solution":"def can_schedule(n, k, m, t): Determines if meetings can be scheduled according to given rules. Parameters: n (int): Number of time slots. k (int): Maximum number of consecutive work-related tasks allowed. m (int): Maximum number of consecutive breaks allowed. t (list of int): John's daily schedule (1 for work-related task, 0 for break). Returns: str: \\"YES\\" if meetings can be scheduled according to the rules, \\"NO\\" otherwise. consecutive_work = 0 consecutive_break = 0 for slot in t: if slot == 1: consecutive_work += 1 consecutive_break = 0 if consecutive_work > k: return \\"NO\\" else: consecutive_break += 1 consecutive_work = 0 if consecutive_break > m: return \\"NO\\" return \\"YES\\""},{"question":"import string import random def generate_strong_password(L: int) -> str: Generates a strong password of length L that contains at least one lowercase letter, one uppercase letter, one digit, and one special character. The password does not contain any spaces. Args: L (int): Length of the desired password. Returns: str: A strong password of length L. >>> len(generate_strong_password(8)) == 8 True >>> any(c.islower() for c in generate_strong_password(8)) True >>> any(c.isupper() for c in generate_strong_password(8)) True >>> any(c.isdigit() for c in generate_strong_password(8)) True >>> any(c in string.punctuation for c in generate_strong_password(8)) True >>> len(generate_strong_password(12)) == 12 True >>> any(c.islower() for c in generate_strong_password(12)) True >>> any(c.isupper() for c in generate_strong_password(12)) True >>> any(c.isdigit() for c in generate_strong_password(12)) True >>> any(c in string.punctuation for c in generate_strong_password(12)) True","solution":"import string import random def generate_strong_password(L): Generates a strong password of length L that contains at least one lowercase letter, one uppercase letter, one digit, and one special character. The password does not contain any spaces. if L < 4 or L > 100: raise ValueError(\\"Password length must be between 4 and 100.\\") # Character pools lower = string.ascii_lowercase upper = string.ascii_uppercase digits = string.digits special = string.punctuation # Mandatory characters password = [ random.choice(lower), random.choice(upper), random.choice(digits), random.choice(special), ] # Fill the rest of the password length with random characters from all pools all_characters = lower + upper + digits + special password += random.choices(all_characters, k=L-4) # Shuffle to ensure the mandatory characters are not predictable at the start random.shuffle(password) return ''.join(password)"},{"question":"def is_power_of_two(n): Helper function to check if a given number n is a power of 2. # Implement the function to check if n is a power of 2 pass def can_partition_to_powers_of_two(S): Function to check if string S can be partitioned into parts where each part is a power of 2. # Implement the function to check if S can be partitioned into parts where each part is a power of 2 pass def mysterious_number_sequence(test_cases): Function to evaluate multiple test cases. Parameters: test_cases (List[str]): List of strings to be evaluated. Returns: List[str]: List containing \\"YES\\" or \\"NO\\" for each test case. >>> mysterious_number_sequence([\\"2048\\", \\"1234\\"]) [\\"YES\\", \\"NO\\"] >>> mysterious_number_sequence([\\"16\\", \\"0032\\", \\"16384\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> mysterious_number_sequence([\\"1\\", \\"2\\", \\"4\\", \\"8\\"]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"] # Implement the function to evaluate the test cases pass","solution":"def is_power_of_two(n): Helper function to check if a given number n is a power of 2. # Convert number to int, if not valid return False try: num = int(n) except ValueError: return False # Check if number is a power of two return num > 0 and (num & (num - 1)) == 0 def can_partition_to_powers_of_two(S): Function to check if string S can be partitioned into parts where each part is a power of 2. # Get the length of the string length = len(S) # Use dynamic programming to determine possible partitioning dp = [False] * (length + 1) dp[0] = True # Base case: empty string can be considered as a valid partition for i in range(1, length + 1): for j in range(i): if dp[j] and not (S[j:i][0] == '0' and len(S[j:i]) > 1) and is_power_of_two(S[j:i]): dp[i] = True break # No need to check further if we found a valid partition return dp[length] def mysterious_number_sequence(test_cases): Function to evaluate multiple test cases. results = [] for S in test_cases: if can_partition_to_powers_of_two(S): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def reverse_words(s: str) -> str: Reverses each word in the string s while maintaining their original order. Parameters: s (str): a string with words separated by spaces. Returns: str: a string with each word reversed. Examples: >>> reverse_words(\\"Hello world!\\") \\"olleH !dlrow\\" >>> reverse_words(\\"This is an example\\") \\"sihT si na elpmaxe\\" >>> reverse_words(\\"Reverse words!\\") \\"esreveR sdrow!\\" def test_reverse_words_single_word(): assert reverse_words(\\"Hello\\") == \\"olleH\\" def test_reverse_words_multiple_words(): assert reverse_words(\\"Hello world!\\") == \\"olleH !dlrow\\" def test_reverse_words_with_punctuation(): assert reverse_words(\\"This is an example!\\") == \\"sihT si na !elpmaxe\\" def test_reverse_words_numbers_and_letters(): assert reverse_words(\\"123 abc\\") == \\"321 cba\\" def test_reverse_words_mixed_case(): assert reverse_words(\\"Hello WORLD\\") == \\"olleH DLROW\\"","solution":"def reverse_words(s): Reverses each word in the string s while maintaining their original order. Parameters: s (str): a string with words separated by spaces. Returns: str: a string with each word reversed. return ' '.join(word[::-1] for word in s.split())"},{"question":"def calculate_average_ratings(n: int, ratings: List[Tuple[str, int]]) -> List[Tuple[str, float]]: Calculate the average rating for each item. Args: n (int): The number of ratings. ratings (List[Tuple[str, int]]): A list of tuples where each tuple contains an item identifier and a rating. Returns: List[Tuple[str, float]]: A list of tuples where each tuple contains an item identifier and its average rating, sorted by average rating in descending order and then by the item identifier in ascending lexicographical order. Examples: >>> calculate_average_ratings(5, [(\\"item1\\", 4), (\\"item1\\", 5), (\\"item2\\", 3), (\\"item3\\", 5), (\\"item2\\", 2)]) [('item3', 5.0), ('item1', 4.5), ('item2', 2.5)] >>> calculate_average_ratings(3, [(\\"item1\\", 1), (\\"item1\\", 1), (\\"item2\\", 2)]) [('item2', 2.0), ('item1', 1.0)]","solution":"def calculate_average_ratings(n, ratings): Returns a list of tuples containing item identifiers and their average rating, sorted by average rating in descending order. If two items have the same average rating, they are sorted lexicographically by item identifier. from collections import defaultdict # Dictionary to store total ratings and count of ratings for each item rating_data = defaultdict(lambda: [0, 0]) # Aggregate ratings for each item for item, rating in ratings: rating_data[item][0] += rating rating_data[item][1] += 1 # Calculate average ratings and prepare output list result = [ (item, round(total / count, 2)) for item, (total, count) in rating_data.items() ] # Sort by average rating (descending) and then by item identifier (ascending) result.sort(key=lambda x: (-x[1], x[0])) return result"},{"question":"from typing import List def count_inversions(arr: List[int]) -> int: Given a list of integers, find the number of inversions in the list. An inversion is a pair of indices (i, j) such that i < j and list[i] > list[j]. >>> count_inversions([2, 3, 8, 6, 1]) 5 >>> count_inversions([1, 2, 3, 4]) 0 >>> count_inversions([3, 1, 2]) 2 >>> count_inversions([1]) 0 >>> count_inversions([5, 4, 3, 2, 1]) 10 >>> count_inversions([1, 2, 3, 4, 5]) 0 >>> count_inversions([1, 3, 2, 3, 1]) 4 >>> count_inversions([2, 1, 3, 2, 1]) 5","solution":"def merge_count_split_inv(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid - i + 1) j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right) // 2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_count_split_inv(arr, temp_arr, left, mid, right) return inv_count def count_inversions(arr): temp_arr = [0] * len(arr) return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)"},{"question":"def longest_palindromic_subsequence(s: str) -> int: Returns the length of the longest palindromic subsequence in the string s. >>> longest_palindromic_subsequence(\\"bbabcbcab\\") 7 >>> longest_palindromic_subsequence(\\"abcd\\") 1 >>> longest_palindromic_subsequence(\\"a\\") 1 >>> longest_palindromic_subsequence(\\"racecar\\") 7 >>> longest_palindromic_subsequence(\\"aaaa\\") 4 >>> longest_palindromic_subsequence(\\"aabbcc\\") 2 >>> longest_palindromic_subsequence(\\"agbdba\\") 5","solution":"def longest_palindromic_subsequence(s): Returns the length of the longest palindromic subsequence in the string s. n = len(s) if n == 0: return 0 # Create a 2D array to store lengths of palindromic subsequences dp = [[0 for _ in range(n)] for _ in range(n)] # All substrings of length 1 are palindromic for i in range(n): dp[i][i] = 1 # Build the table for substrings of length 2 to n for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) # The length of the longest palindromic subsequence return dp[0][n - 1]"},{"question":"def determine_directory(serial_number: str) -> str: Determines the directory (A, B, or C) for a given serial number based on its prefix. >>> determine_directory(\\"AC12345\\") 'A' >>> determine_directory(\\"T789XYZ\\") 'B' >>> determine_directory(\\"UU12345678\\") 'C' >>> determine_directory(\\"1234AC\\") Traceback (most recent call last): ... ValueError: Invalid serial number format","solution":"def determine_directory(serial_number): Determines the directory (A, B, or C) for a given serial number based on its prefix. Args: serial_number (str): The serial number of an item. Returns: str: 'A', 'B', or 'C' indicating the directory to which the serial number belongs. # Check the first character of the serial number to determine the directory. first_char = serial_number[0].upper() if 'A' <= first_char <= 'M': return 'A' elif 'N' <= first_char <= 'T': return 'B' elif 'U' <= first_char <= 'Z': return 'C' else: raise ValueError(\\"Invalid serial number format\\")"},{"question":"def find_shelf_with_most_books(bookshelves, genre_index): Finds the index of the shelf with the highest number of books of a specific genre. :param bookshelves: List of lists where each list represents a bookshelf :param genre_index: The index of the genre to inspect :return: The index of the shelf with the highest number of books of the specified genre, or 'No books available!' if all counts are zero >>> find_shelf_with_most_books([[3, 5, 2], [4, 2, 7], [5, 5, 1]], 1) 0 >>> find_shelf_with_most_books([[3, 0, 2], [4, 0, 7], [5, 0, 1]], 1) 'No books available!' >>> find_shelf_with_most_books([[3, 2, 7], [4, 2, 7], [5, 2, 1]], 1) 0 >>> find_shelf_with_most_books([[0, 9, 3]], 1) 0","solution":"def find_shelf_with_most_books(bookshelves, genre_index): Finds the index of the shelf with the highest number of books of a specific genre. :param bookshelves: List of lists where each list represents a bookshelf :param genre_index: The index of the genre to inspect :return: The index of the shelf with the highest number of books of the specified genre, or 'No books available!' if all counts are zero max_books = -1 max_index = -1 for i, shelf in enumerate(bookshelves): if shelf[genre_index] > max_books: max_books = shelf[genre_index] max_index = i return max_index if max_books > 0 else 'No books available!'"},{"question":"def minimum_distances(arr: List[int]) -> int: Given an array of integers, return the minimum distance between any two identical elements in the array. If there are no such pairs, return -1. Args: arr: List[int] - list of integers Returns: int - minimum distance between identical elements or -1 if no such pairs exist. Example: >>> minimum_distances([3, 2, 1, 2, 3]) 2 >>> minimum_distances([1, 2, 3, 4, 10]) -1 >>> minimum_distances([5, 5, 5, 5, 5]) 1","solution":"def minimum_distances(arr): Returns the minimum distance between any two identical elements in the array. If there are no such pairs, return -1. index_map = {} min_distance = float('inf') for i, value in enumerate(arr): if value in index_map: min_distance = min(min_distance, i - index_map[value]) index_map[value] = i return min_distance if min_distance != float('inf') else -1"},{"question":"def generate_sequence(n: int, k: int) -> list: Generate a sequence of length n where the absolute difference between any two consecutive elements does not exceed 1 and each element does not exceed k. If no such sequence exists, return -1. >>> generate_sequence(5, 3) [1, 2, 3, 1, 2] # or other valid sequences >>> generate_sequence(4, 1) -1 >>> generate_sequence(3, 2) [1, 2, 1] # or other valid sequences >>> generate_sequence(1, 1) [1] >>> generate_sequence(100, 1000) [1, 2, ..., 1000] from solution import generate_sequence def test_generate_sequence_possible_case(): result = generate_sequence(5, 3) assert result == [1, 2, 3, 1, 2] or result == [2, 3, 1, 2, 3] or result == [3, 1, 2, 3, 1] def test_generate_sequence_impossible_case(): assert generate_sequence(4, 1) == -1 def test_generate_sequence_edge_case_single_element(): assert generate_sequence(1, 1) == [1] def test_generate_sequence_multiple_cases(): result = generate_sequence(3, 2) assert result == [1, 2, 1] or result == [2, 1, 2] def test_generate_sequence_large_n(): result = generate_sequence(100000, 3) assert len(result) == 100000 assert max(result) <= 3 def test_generate_sequence_large_k(): result = generate_sequence(100, 1000) assert len(result) == 100 assert max(result) <= 1000","solution":"def generate_sequence(n, k): Generate a sequence of length n where the absolute difference between any two consecutive elements does not exceed 1 and each element does not exceed k. Parameters: n (int): Length of the sequence k (int): Maximum value an element can take Returns: list or int: The generated sequence or -1 if it's not possible if k == 1: if n == 1: return [1] else: return -1 else: sequence = [(i % k) + 1 for i in range(n)] return sequence"},{"question":"from typing import List def permute(nums: List[int]) -> List[List[int]]: Given an array of distinct integers, return all possible permutations. You can return the answer in any order. Examples: >>> permute([1,2,3]) [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] >>> permute([0,1]) [[0,1], [1,0]] >>> permute([1]) [[1]] Constraints: - 1 <= nums.length <= 6 - -10 <= nums[i] <= 10 - All the integers of nums are unique. # Complete the function here from solution import permute # Assuming the function is defined in a file named solution.py def test_permute_example1(): result = permute([1, 2, 3]) expected = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] assert sorted(result) == sorted(expected) def test_permute_example2(): result = permute([0, 1]) expected = [[0, 1], [1, 0]] assert sorted(result) == sorted(expected) def test_permute_example3(): result = permute([1]) expected = [[1]] assert result == expected def test_permute_empty(): result = permute([]) expected = [[]] assert result == expected def test_permute_with_negatives(): result = permute([-1, 0, 1]) expected = [ [-1, 0, 1], [-1, 1, 0], [0, -1, 1], [0, 1, -1], [1, -1, 0], [1, 0, -1] ] assert sorted(result) == sorted(expected)","solution":"from itertools import permutations def permute(nums): Returns all possible permutations of a given list of distinct integers. return list(map(list, permutations(nums)))"},{"question":"from typing import List def longest_consecutive_sequence(arr: List[int]) -> int: Develop a function that identifies the longest sequence of consecutive integers in an unsorted array. Given an unsorted array of integers, find the length of the longest sequence of consecutive integers in the array. >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_sequence([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) 9 >>> longest_consecutive_sequence([1, 2, 0, 1]) 3 def test_longest_consecutive_sequence_single_element(): assert longest_consecutive_sequence([1]) == 1 def test_longest_consecutive_sequence_no_consecutive(): assert longest_consecutive_sequence([10, 20, 30]) == 1 def test_longest_consecutive_sequence_simple_case(): assert longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) == 4 def test_longest_consecutive_sequence_complex_case(): assert longest_consecutive_sequence([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) == 9 def test_longest_consecutive_sequence_with_duplicates(): assert longest_consecutive_sequence([1, 2, 0, 1]) == 3 def test_longest_consecutive_sequence_negatives(): assert longest_consecutive_sequence([-1, -2, -3, 2, 1, 0, -4]) == 7 def test_longest_consecutive_sequence_large_input(): arr = list(range(100000, 200000)) assert longest_consecutive_sequence(arr) == 100000 def test_longest_consecutive_sequence_mixed_signs(): assert longest_consecutive_sequence([-1, 1, 0]) == 3 def test_longest_consecutive_sequence_repeats(): assert longest_consecutive_sequence([1, 2, 2, 3]) == 3","solution":"def longest_consecutive_sequence(arr): Finds the length of the longest sequence of consecutive integers in an unsorted array. Args: arr (List[int]): The unsorted list of integers. Returns: int: The length of the longest consecutive sequence. if not arr: return 0 num_set = set(arr) longest_streak = 0 for num in num_set: # Only start checking sequence if it's the beginning of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def sum_positive_integers(arr): Returns the sum of all positive integers in the array. Parameters: arr (list of int): List containing integers Returns: int: Sum of positive integers Examples: >>> sum_positive_integers([1, -2, 3, 4, -5]) 8 >>> sum_positive_integers([-1, -2, -3, -4, -5]) 0 >>> sum_positive_integers([]) 0","solution":"def sum_positive_integers(arr): Returns the sum of all positive integers in the array. Parameters: arr (list of int): List containing integers Returns: int: Sum of positive integers return sum(x for x in arr if x > 0)"},{"question":"def can_reach_last_index(n: int, arr: List[int]) -> str: Determines if you can reach the last index starting from the first index. The input consists of an integer n and a list of integers arr. >>> can_reach_last_index(6, [2, 3, 1, 1, 4]) 'YES' >>> can_reach_last_index(5, [3, 2, 1, 0, 4]) 'NO'","solution":"def can_reach_last_index(n, arr): Determins if you can reach the last index from the first index. max_reachable = 0 for i in range(n): if i > max_reachable: return \\"NO\\" max_reachable = max(max_reachable, i + arr[i]) if max_reachable >= n - 1: return \\"YES\\" return \\"NO\\""},{"question":"def process_operations(n: int, operations: List[str]) -> List[int]: Simulate a series of operations on an initially empty string. Each operation is either appending a character or querying the longest prefix which is also a suffix. Args: n: The number of operations. operations: A list of operations, where each operation is either \\"append <character>\\" or \\"query\\". Returns: A list of integers, where each integer is the result of a \\"query\\" operation. >>> process_operations(5, [\\"append a\\", \\"append b\\", \\"append a\\", \\"query\\", \\"append b\\", \\"query\\"]) [1, 2] >>> process_operations(3, [\\"append a\\", \\"append b\\", \\"append c\\"]) []","solution":"def process_operations(n, operations): def kmp_process(s): n = len(s) lps = [0] * n length = 0 i = 1 while i < n: if s[i] == s[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps result = [] current_string = [] for operation in operations: if operation.startswith(\\"append\\"): current_string.append(operation.split()[1]) elif operation == \\"query\\": lps = kmp_process(''.join(current_string)) result.append(lps[-1] if lps else 0) return result"},{"question":"def canRearrangeToPalindrome(S: str) -> bool: Determines if the string S can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if at most one character has an odd count, and all other characters have even counts. Args: S (str): The input string Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise Examples: >>> canRearrangeToPalindrome(\\"civic\\") True >>> canRearrangeToPalindrome(\\"ivicc\\") True >>> canRearrangeToPalindrome(\\"hello\\") False","solution":"def canRearrangeToPalindrome(S): Determines if the string S can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if at most one character has an odd count, and all other characters have even counts. Args: S (str): The input string Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise from collections import Counter # Count the occurrence of each character char_count = Counter(S) # Count how many characters have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if at most one character has an odd count return odd_count <= 1"},{"question":"def find_minimal_trench(n: int, grid: List[List[int]]) -> Tuple[int, str, int]: Find the position of the trench and the minimal sum of the heights of the affected buildings. >>> find_minimal_trench(3, [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) (6, 'r', 1) >>> find_minimal_trench(4, [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ]) (10, 'r', 1)","solution":"def find_minimal_trench(n, grid): row_sums = [sum(grid[i]) for i in range(n)] col_sums = [sum(grid[i][j] for i in range(n)) for j in range(n)] min_row_sum = min(row_sums) min_col_sum = min(col_sums) if min_row_sum <= min_col_sum: position = 'r' index = row_sums.index(min_row_sum) + 1 minimal_sum = min_row_sum else: position = 'c' index = col_sums.index(min_col_sum) + 1 minimal_sum = min_col_sum return minimal_sum, position, index"},{"question":"def reverse_words_in_lines(lines): Given a list of lines, return each line with the words in reverse order. Args: lines (list of str): List of input lines to process Returns: list of str: List of lines with words reversed Example: >>> reverse_words_in_lines([\\"hello world\\", \\".\\"]) [\\"world hello\\"] >>> reverse_words_in_lines([\\"hello world\\", \\"this is a test\\", \\"sample input for reversing\\", \\".\\"]) [\\"world hello\\", \\"test a is this\\", \\"reversing for input sample\\"]","solution":"def reverse_words_in_lines(lines): Given a list of lines, return each line with the words in reverse order. Args: lines (list of str): List of input lines to process Returns: list of str: List of lines with words reversed result = [] for line in lines: if line == \\".\\": break reversed_line = ' '.join(line.split()[::-1]) result.append(reversed_line) return result"},{"question":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring in s. If there are multiple such substrings of the same length, returns the first one that appears. >>> longest_palindromic_substring(\\"babad\\") \\"bab\\" >>> longest_palindromic_substring(\\"cbbd\\") \\"bb\\" >>> longest_palindromic_substring(\\"a\\") \\"a\\" >>> longest_palindromic_substring(\\"ac\\") \\"a\\" >>> longest_palindromic_substring(\\"\\") \\"\\" >>> longest_palindromic_substring(\\"abcde\\") \\"a\\" >>> longest_palindromic_substring(\\"aaaaa\\") \\"aaaaa\\" >>> longest_palindromic_substring(\\"xabax\\") \\"xabax\\"","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring in s. If there are multiple such substrings of the same length, returns the first one that appears. if not s: return \\"\\" n = len(s) start = 0 max_length = 1 dp = [[False for _ in range(n)] for _ in range(n)] for i in range(n): dp[i][i] = True for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True start = i max_length = 2 for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 if dp[i + 1][j - 1] and s[i] == s[j]: dp[i][j] = True if length > max_length: start = i max_length = length return s[start:start + max_length]"},{"question":"def crystal_ball(numbers: List[int]) -> str: Determine if the array of numbers is in a strictly increasing order. Returns: \\"Prosperity!\\" if the numbers are in strictly increasing order, otherwise \\"Chaos!\\". Examples: >>> crystal_ball([1, 2, 3, 4, 5]) \\"Prosperity!\\" >>> crystal_ball([1, 3, 2, 4, 5]) \\"Chaos!\\" >>> crystal_ball([10, 20, 30]) \\"Prosperity!\\" >>> crystal_ball([5, 3, 1]) \\"Chaos!\\"","solution":"def crystal_ball(numbers): Determine if the array of numbers is in a strictly increasing order. Returns: \\"Prosperity!\\" if the numbers are in strictly increasing order, otherwise \\"Chaos!\\". for i in range(1, len(numbers)): if numbers[i] <= numbers[i - 1]: return \\"Chaos!\\" return \\"Prosperity!\\""},{"question":"def shortest_path(n: int, m: int, edges: List[Tuple[int, int, int]], s: int, t: int) -> int: Finds the shortest path in an undirected weighted graph using Dijkstra's algorithm. :param n: Number of nodes :param m: Number of edges :param edges: List of edges where each edge is represented as a tuple (u, v, w) :param s: Starting node :param t: Target node :return: Length of the shortest path from s to t, or -1 if no such path exists >>> shortest_path(2, 1, [(1, 2, 4)], 1, 2) 4 >>> shortest_path(4, 4, [(1, 2, 2), (2, 3, 2), (3, 4, 1), (1, 4, 7)], 1, 4) 5 >>> shortest_path(3, 1, [(1, 2, 10)], 1, 3) -1 >>> shortest_path(1, 0, [], 1, 1) 0 >>> shortest_path(3, 3, [(1, 2, 4), (2, 3, 2), (1, 3, 7)], 1, 3) 6","solution":"import heapq def shortest_path(n, m, edges, s, t): Finds the shortest path in an undirected weighted graph using Dijkstra's algorithm. :param n: Number of nodes :param m: Number of edges :param edges: List of edges where each edge is represented as a tuple (u, v, w) :param s: Starting node :param t: Target node :return: Length of the shortest path from s to t, or -1 if no such path exists # Create adjacency list for the graph graph = {i: [] for i in range(1, n + 1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra's algorithm pq = [(0, s)] # (distance, node) distances = {i: float('inf') for i in range(1, n + 1)} distances[s] = 0 visited = set() while pq: current_distance, current_node = heapq.heappop(pq) if current_node in visited: continue visited.add(current_node) for neighbor, weight in graph[current_node]: if neighbor not in visited: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances[t] if distances[t] != float('inf') else -1"},{"question":"def find_shortest_path(N: int, M: int, roads: List[Tuple[int, int, int]]) -> int: Bessie the cow is in a field consisting of N barns, connected by M bidirectional roads. Each barn is numbered 1 through N, and each road connects exactly two distinct barns. The roads have different lengths, given in miles, and each road takes the form (a, b, c), where a and b are barn numbers and c is the length of the road connecting them. Given her desire to eat the best grass, Bessie wants to know the shortest possible almost shortest path from barn 1 to barn N. An almost shortest path is defined as the second shortest path from barn 1 to barn N that is at most no longer than 5 miles more than the shortest path. Help Bessie find the length of the almost shortest path from barn 1 to barn N, or determine that it does not exist. Args: - N (int): The number of barns. - M (int): The number of roads. - roads (List[Tuple[int, int, int]]): The roads connecting the barns. Returns: - int: The length of the almost shortest path from barn 1 to barn N, or -1 if such a path does not exist. Examples: >>> find_shortest_path(5, 7, [(1, 2, 1), (2, 5, 4), (1, 3, 3), (3, 5, 2), (1, 4, 2), (4, 5, 3), (2, 3, 1)]) 5 >>> find_shortest_path(4, 2, [(1, 2, 5), (3, 4, 10)]) -1 >>> find_shortest_path(4, 4, [(1, 2, 1), (2, 3, 2), (3, 4, 20), (1, 4, 10)]) -1 >>> find_shortest_path(5, 6, [(1, 2, 1), (2, 3, 1), (3, 5, 1), (1, 4, 1), (4, 3, 2), (3, 5, 1)]) 5","solution":"import heapq def find_shortest_path(N, M, roads): INF = float('inf') graph = [[] for _ in range(N + 1)] for a, b, c in roads: graph[a].append((b, c)) graph[b].append((a, c)) def dijkstra(start): distances = [INF] * (N + 1) distances[start] = 0 pq = [(0, start)] while pq: current_distance, current_node = heapq.heappop(pq) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances def find_almost_shortest_path(distances): shortest_path_length = distances[N] second_shortest = INF pq = [(0, 1, False)] # (current_distance, current_node, used_longer) visited = [[False, False] for _ in range(N + 1)] # visited[node][used_longer] while pq: current_distance, current_node, used_longer = heapq.heappop(pq) if visited[current_node][used_longer]: continue visited[current_node][used_longer] = True if current_node == N: if current_distance > shortest_path_length and current_distance <= shortest_path_length + 5: return current_distance for neighbor, weight in graph[current_node]: new_distance = current_distance + weight if not used_longer and new_distance > shortest_path_length: heapq.heappush(pq, (new_distance, neighbor, True)) if new_distance <= shortest_path_length + 5: heapq.heappush(pq, (new_distance, neighbor, used_longer)) return -1 distances = dijkstra(1) if distances[N] == INF: return -1 return find_almost_shortest_path(distances) # Sample Input N = 5 M = 7 roads = [ (1, 2, 1), (2, 5, 4), (1, 3, 3), (3, 5, 2), (1, 4, 2), (4, 5, 3), (2, 3, 1) ] print(find_shortest_path(N, M, roads)) # Output: 5"},{"question":"from typing import List def simulate_growth(n: int, m: int, k: int, initial_grid: List[List[int]]) -> List[List[int]]: Simulate the growth of bacteria in a petri dish over k generations. Args: n (int): The number of rows in the petri dish. m (int): The number of columns in the petri dish. k (int): The number of generations to simulate. initial_grid (List[List[int]]): The initial state of the petri dish. Returns: List[List[int]]: The state of the petri dish after k generations. Examples: >>> simulate_growth(3, 3, 1, [ ... [0, 1, 0], ... [0, 1, 0], ... [0, 1, 0] ... ]) [[0, 0, 0], [1, 1, 1], [0, 0, 0]] >>> simulate_growth(3, 3, 2, [ ... [0, 1, 0], ... [0, 1, 0], ... [0, 1, 0] ... ]) [[0, 1, 0], [0, 1, 0], [0, 1, 0]]","solution":"def get_next_state(grid, n, m): Calculate the next state of the grid based on the growth rules. def get_neighbors_count(x, y): directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] count = 0 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m: count += grid[nx][ny] return count next_grid = [[0] * m for _ in range(n)] for i in range(n): for j in range(m): neighbors_count = get_neighbors_count(i, j) if grid[i][j] == 1: if neighbors_count == 2 or neighbors_count == 3: next_grid[i][j] = 1 else: next_grid[i][j] = 0 elif neighbors_count == 3: next_grid[i][j] = 1 else: next_grid[i][j] = 0 return next_grid def simulate_growth(n, m, k, initial_grid): Simulate the growth of the bacteria for k generations. grid = initial_grid for _ in range(k): grid = get_next_state(grid, n, m) return grid"},{"question":"def min_cost_path(grid): Calculates the minimum cost path for the robot to travel from the top-left to the bottom-right cell. Parameters: grid (list of list of int): 2D array representing the grid where each element is the cost of that cell. Returns: int: The minimum cost to reach the bottom-right corner from the top-left corner. pass def process_input_and_find_min_cost(input_str): Processes input string, parses multiple datasets, computes and returns the minimum cost paths. Parameters: input_str (str): Input string containing the datasets in the specified format. Returns: list of int: List containing the minimum cost for each dataset. pass def test_min_cost_path_single_grid(): assert min_cost_path([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) == 21 def test_min_cost_path_multiple_grids(): input_str = \\"3 3n1 2 3n4 5 6n7 8 9n2 2n1 9n5 3n0 0\\" results = process_input_and_find_min_cost(input_str) assert results == [21, 9] def test_min_cost_path_minimal_grid(): assert min_cost_path([ [0] ]) == 0 def test_min_cost_path_large_values(): assert min_cost_path([ [9, 4, 5], [6, 8, 2], [1, 7, 9] ]) == 29 def test_min_cost_path_single_row(): assert min_cost_path([ [1, 2, 3, 4] ]) == 10 def test_min_cost_path_single_column(): assert min_cost_path([ [1], [2], [3], [4] ]) == 10","solution":"def min_cost_path(grid): Calculates the minimum cost path for the robot to travel from the top-left to the bottom-right cell. Parameters: grid (list of list of int): 2D array representing the grid where each element is the cost of that cell. Returns: int: The minimum cost to reach the bottom-right corner from the top-left corner. if not grid or not grid[0]: return 0 M = len(grid) N = len(grid[0]) # Initialize a 2D dp array with the same dimensions as grid dp = [[0 for _ in range(N)] for _ in range(M)] # Set the cost of the starting point (0,0) dp[0][0] = grid[0][0] # Fill the first row (only way is from the left) for j in range(1, N): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (only way is from above) for i in range(1, M): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, M): for j in range(1, N): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1] def process_input_and_find_min_cost(input_str): Processes input string, parses multiple datasets, computes and returns the minimum cost paths. Parameters: input_str (str): Input string containing the datasets in the specified format. Returns: list of int: List containing the minimum cost for each dataset. lines = input_str.strip().split(\\"n\\") index = 0 results = [] while index < len(lines): M, N = map(int, lines[index].split()) if M == 0 and N == 0: break index += 1 grid = [] for _ in range(M): grid.append(list(map(int, lines[index].split()))) index += 1 # Calculate the minimum cost path for the current grid results.append(min_cost_path(grid)) return results"},{"question":"def count_cake_combinations(flavors: int, max_layers: int) -> int: Returns the number of distinct cakes that can be created with the given number of flavors and maximum number of layers. Parameters: flavors (int): The number of available flavors. max_layers (int): The maximum number of layers a cake can have. Returns: int: The number of distinct cakes that can be created. pass def process_input(input_lines: List[str]) -> List[int]: Processes the input datasets, and calculates the number of cake combinations for each dataset. Parameters: input_lines (list of str): List of input lines. Returns: list of int: The number of distinct cakes for each dataset. pass","solution":"def count_cake_combinations(flavors, max_layers): Returns the number of distinct cakes that can be created with the given number of flavors and maximum number of layers. Parameters: flavors (int): The number of available flavors. max_layers (int): The maximum number of layers a cake can have. Returns: int: The number of distinct cakes that can be created. # Total combinations are given by flavors ^ max_layers return flavors ** max_layers def process_input(input_lines): Processes the input datasets, and calculates the number of cake combinations for each dataset. Parameters: input_lines (list of str): List of input lines. Returns: list of int: The number of distinct cakes for each dataset. result = [] for line in input_lines: if line.strip() == \\"0 0\\": break parts = line.split() F = int(parts[0]) L = int(parts[1]) flavors = input_lines.pop(0) # Pop the flavor line to move to the next dataset result.append(count_cake_combinations(F, L)) return result"},{"question":"from typing import List, Tuple import heapq import collections def shortest_path(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Find the shortest path from vertex 1 to vertex n in an undirected graph with weighted edges. >>> shortest_path(5, 6, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 4, 3), (4, 5, 1)]) 7 >>> shortest_path(4, 2, [(1, 2, 5), (3, 4, 7)]) -1","solution":"import heapq import sys import collections def shortest_path(n, m, edges): graph = collections.defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) def dijkstra(start, end): heap = [(0, start)] distances = {i: float('inf') for i in range(1, n+1)} distances[start] = 0 while heap: current_distance, current_node = heapq.heappop(heap) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(heap, (distance, neighbor)) return distances[end] if distances[end] != float('inf') else -1 return dijkstra(1, n)"},{"question":"from typing import List, Union def fizz_buzz(n: int) -> List[Union[int, str]]: Generate a list of integers from 1 to \`n\`, replacing: - Multiples of 3 with \\"Fizz\\" - Multiples of 5 with \\"Buzz\\" - Multiples of both 3 and 5 with \\"FizzBuzz\\" Example: >>> fizz_buzz(15) [1, 2, \\"Fizz\\", 4, \\"Buzz\\", \\"Fizz\\", 7, 8, \\"Fizz\\", \\"Buzz\\", 11, \\"Fizz\\", 13, 14, \\"FizzBuzz\\"] def test_fizz_buzz_basic(): assert fizz_buzz(1) == [1] assert fizz_buzz(2) == [1, 2] assert fizz_buzz(3) == [1, 2, \\"Fizz\\"] assert fizz_buzz(5) == [1, 2, \\"Fizz\\", 4, \\"Buzz\\"] def test_fizz_buzz_15(): expected = [1, 2, \\"Fizz\\", 4, \\"Buzz\\", \\"Fizz\\", 7, 8, \\"Fizz\\", \\"Buzz\\", 11, \\"Fizz\\", 13, 14, \\"FizzBuzz\\"] assert fizz_buzz(15) == expected def test_fizz_buzz_30(): expected = [ 1, 2, \\"Fizz\\", 4, \\"Buzz\\", \\"Fizz\\", 7, 8, \\"Fizz\\", \\"Buzz\\", 11, \\"Fizz\\", 13, 14, \\"FizzBuzz\\", 16, 17, \\"Fizz\\", 19, \\"Buzz\\", \\"Fizz\\", 22, 23, \\"Fizz\\", \\"Buzz\\", 26, \\"Fizz\\", 28, 29, \\"FizzBuzz\\" ] assert fizz_buzz(30) == expected def test_fizz_buzz_edge_cases(): assert fizz_buzz(0) == [] assert fizz_buzz(-5) == []","solution":"from typing import List, Union def fizz_buzz(n: int) -> List[Union[int, str]]: Generate a list of integers from 1 to \`n\`, replacing: - Multiples of 3 with \\"Fizz\\" - Multiples of 5 with \\"Buzz\\" - Multiples of both 3 and 5 with \\"FizzBuzz\\" result = [] for i in range(1, n+1): if i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(i) return result"},{"question":"def compress_logs(N: int, T: int, M: List[int]) -> List[int]: Compresses the memory usage log to retain only significant changes. Parameters: - N: int, number of intervals. - T: int, threshold for significant change. - M: list of int, memory usage at each interval. Returns: - List of int, compressed log array. Example: >>> compress_logs(5, 10, [100, 115, 120, 105, 130]) [100, 115, 105, 130]","solution":"def compress_logs(N, T, M): Compresses the memory usage log to retain only significant changes. Parameters: - N: int, number of intervals. - T: int, threshold for significant change. - M: list of int, memory usage at each interval. Returns: - List of int, compressed log array. # Initialize the compressed log with the first memory usage entry compressed_log = [M[0]] # Iterate over the list starting from the second element for i in range(1, N): # Check if the absolute difference is greater than or equal to the threshold if abs(M[i] - compressed_log[-1]) >= T: compressed_log.append(M[i]) return compressed_log"},{"question":"def is_palindrome(s: str) -> bool: Check if a string is a palindrome. >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"abcba\\") True >>> is_palindrome(\\"hello\\") False def find_palindromic_ids(test_cases: List[Tuple[int, List[str]]]) -> List[List[str]]: For each test case, find the painting IDs that are palindromes. >>> find_palindromic_ids([(5, [\\"12321\\", \\"abcba\\", \\"notpalindrome\\", \\"1234321\\", \\"hello\\"])]) [[\\"12321\\", \\"abcba\\", \\"1234321\\"]] >>> find_palindromic_ids([(3, [\\"hello\\", \\"world\\", \\"test\\"])]) [[\\"No palindromic IDs\\"]]","solution":"def is_palindrome(s): Check if a string is a palindrome. return s == s[::-1] def find_palindromic_ids(test_cases): For each test case, find the painting IDs that are palindromes. results = [] for case in test_cases: N, ids = case palindromic_ids = [pid for pid in ids if is_palindrome(pid)] if palindromic_ids: results.append(palindromic_ids) else: results.append([\\"No palindromic IDs\\"]) return results"},{"question":"def is_possible_to_reach(m: int, e: int, grid: List[List[int]]) -> bool: Determine if it is possible to reach the bottom-right cell (M, M) starting from the top-left cell (1, 1) with exactly the given initial energy E. >>> is_possible_to_reach(3, 7, [ ... [0, 1, 2], ... [1, 1, 3], ... [4, 2, 1] ... ]) True >>> is_possible_to_reach(4, 15, [ ... [1, 2, 3, 4], ... [2, 3, 4, 5], ... [3, 4, 5, 6], ... [4, 5, 6, 7] ... ]) False pass def can_reach_all_cases(test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[str]: For each test case, output 'YES' if it's possible to reach the bottom-right cell exactly expending the initial energy E, otherwise print 'NO'. >>> can_reach_all_cases([ ... (3, 7, [ ... [0, 1, 2], ... [1, 1, 3], ... [4, 2, 1] ... ]), ... (4, 15, [ ... [1, 2, 3, 4], ... [2, 3, 4, 5], ... [3, 4, 5, 6], ... [4, 5, 6, 7] ... ]) ... ]) ['YES', 'NO'] pass","solution":"def is_possible_to_reach(m, e, grid): from functools import lru_cache @lru_cache(None) def find_path(x, y, current_energy): if x == m-1 and y == m-1: return current_energy == e if current_energy > e: return False right = down = False if x + 1 < m: down = find_path(x + 1, y, current_energy + grid[x + 1][y]) if y + 1 < m: right = find_path(x, y + 1, current_energy + grid[x][y + 1]) return right or down return find_path(0, 0, grid[0][0]) def can_reach_all_cases(test_cases): results = [] for m, e, grid in test_cases: if is_possible_to_reach(m, e, grid): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def generate_playlist(n: int, T: int, k: int, songs: List[Tuple[str, int]]) -> Union[List[str], int]: Determines a valid playlist that matches the desired total duration while meeting the repetition constraint. If a valid playlist exists, outputs the song names in the order they should be played. If no valid playlist can be created, outputs \`-1\`. >>> generate_playlist(5, 300, 3, [(\\"song1\\", 100), (\\"song2\\", 150), (\\"song3\\", 50), (\\"song4\\", 200), (\\"song5\\", 100)]) [\\"song1\\", \\"song2\\", \\"song3\\"] >>> generate_playlist(2, 300, 1, [(\\"song1\\", 200), (\\"song2\\", 100)]) [\\"song1\\", \\"song2\\"] >>> generate_playlist(2, 500, 1, [(\\"song1\\", 200), (\\"song2\\", 200)]) -1 >>> generate_playlist(1, 200, 1, [(\\"song1\\", 200)]) [\\"song1\\"] >>> generate_playlist(5, 500, 3, [(\\"song1\\", 100), (\\"song2\\", 100), (\\"song3\\", 100), (\\"song4\\", 100), (\\"song5\\", 100)]) [\\"song1\\", \\"song2\\", \\"song3\\", \\"song4\\", \\"song5\\"]","solution":"def generate_playlist(n, T, k, songs): def dfs(playlist, songs_left, current_duration): if current_duration == T: return playlist if current_duration > T or not songs_left: return None for i in range(len(songs_left)): song_name, song_duration = songs_left[i] if playlist and len(playlist) >= k and song_name in playlist[-k:]: continue result = dfs(playlist + [song_name], songs_left[:i] + songs_left[i+1:], current_duration + song_duration) if result: return result return None songs = [(song[0], int(song[1])) for song in songs] result = dfs([], songs, 0) return result if result else -1"},{"question":"import math def is_feasible(W: int, H: int, circles: List[Tuple[int, int, int]]) -> str: Determine if the circles can be arranged within the canvas without overlapping. Args: W (int): Width of the canvas H (int): Height of the canvas circles (List[Tuple[int, int, int]]): List of tuples, each containing (x, y, r) for the circles Returns: str: \\"Feasible\\" if arrangement is possible, otherwise \\"Not Feasible\\" pass def test_feasible_case1(): W = 10 H = 10 circles = [(2, 2, 2), (8, 8, 2)] assert is_feasible(W, H, circles) == \\"Feasible\\" def test_not_feasible_case1(): W = 10 H = 10 circles = [(1, 1, 3), (9, 9, 3)] assert is_feasible(W, H, circles) == \\"Not Feasible\\" def test_not_feasible_case2(): W = 10 H = 10 circles = [(5, 5, 6)] assert is_feasible(W, H, circles) == \\"Not Feasible\\" def test_feasible_case2(): W = 15 H = 15 circles = [(3, 3, 2), (12, 12, 2), (7, 8, 3)] assert is_feasible(W, H, circles) == \\"Feasible\\" def test_not_feasible_case3(): W = 20 H = 20 circles = [(10, 10, 5), (10, 15, 5)] assert is_feasible(W, H, circles) == \\"Not Feasible\\" def test_feasible_case3(): W = 20 H = 20 circles = [(5, 5, 3), (15, 15, 3), (10, 10, 2)] assert is_feasible(W, H, circles) == \\"Feasible\\"","solution":"import math def is_feasible(W, H, circles): Determine if the circles can be arranged within the canvas without overlapping. W: Width of the canvas H: Height of the canvas circles: List of tuples, each containing (x, y, r) for the circles Returns \\"Feasible\\" if arrangement is possible, otherwise \\"Not Feasible\\" N = len(circles) # Check if each circle fits within the canvas for x, y, r in circles: if x - r < 0 or x + r > W or y - r < 0 or y + r > H: return \\"Not Feasible\\" # Check if the circles do not overlap for i in range(N): for j in range(i + 1, N): x1, y1, r1 = circles[i] x2, y2, r2 = circles[j] distance = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) if distance < r1 + r2: return \\"Not Feasible\\" return \\"Feasible\\""},{"question":"def can_form_palindrome(sentence: str) -> bool: Determine if the characters in the sentence can be rearranged to form a palindrome. Params: sentence (str): The input sentence to be checked Returns: bool: True if it can be rearranged to form a palindrome, False otherwise >>> can_form_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> can_form_palindrome(\\"Programming is fun!\\") False","solution":"import re from collections import Counter def can_form_palindrome(sentence): Determine if the characters in the sentence can be rearranged to form a palindrome. Params: sentence (str): The input sentence to be checked Returns: bool: True if it can be rearranged to form a palindrome, False otherwise # Remove non-alphanumeric characters and convert to lowercase cleaned_sentence = re.sub(r'[^a-zA-Z0-9]', '', sentence).lower() # Count frequency of each character char_count = Counter(cleaned_sentence) # A string can be rearranged to form a palindrome if at most one character has an odd count odd_count = sum(1 for count in char_count.values() if count % 2 == 1) return odd_count <= 1"},{"question":"def separate_weights(s: str) -> tuple: Separates the weights of apples and oranges from an alternating string of numbers. Parameters: s (str): A string of numbers separated by spaces, with alternating weights of apples and oranges. Returns: tuple: A tuple of two lists, the first being the weights of the apples and the second being the weights of the oranges. >>> separate_weights(\\"3 5 2 4 9 7\\") ([3, 2, 9], [5, 4, 7]) >>> separate_weights(\\"10 20 30 40\\") ([10, 30], [20, 40]) >>> separate_weights(\\"1 2\\") ([1], [2])","solution":"def separate_weights(s): Separates the weights of apples and oranges from an alternating string of numbers. Parameters: s (str): A string of numbers separated by spaces, with alternating weights of apples and oranges. Returns: tuple: A tuple of two lists, the first being the weights of the apples and the second being the weights of the oranges. weights = list(map(int, s.split())) apples = weights[::2] oranges = weights[1::2] return apples, oranges"},{"question":"def minimum_perimeter(N: int, M: int, grid: List[str]) -> int: Determines the minimum perimeter of a garden bed that contains all the herbs. Args: N (int): The number of rows in the garden grid. M (int): The number of columns in the garden grid. grid (List[str]): A list of strings representing the garden grid, where 'H' indicates a herb and '.' indicates an empty cell. Returns: int: The minimum perimeter of a garden bed that contains all the herbs. Examples: >>> N, M = 5, 7 >>> grid = [ ... '.......', ... '..H....', ... '.HH....', ... '...H...', ... '.......' ... ] >>> minimum_perimeter(N, M, grid) 12 >>> N, M = 3, 3 >>> grid = [ ... '...', ... '...', ... '...' ... ] >>> minimum_perimeter(N, M, grid) 0 >>> N, M = 3, 3 >>> grid = [ ... 'HHH', ... 'HHH', ... 'HHH' ... ] >>> minimum_perimeter(N, M, grid) 12 >>> N, M = 4, 4 >>> grid = [ ... '....', ... '....', ... '..H.', ... '....' ... ] >>> minimum_perimeter(N, M, grid) 4 >>> N, M = 5, 5 >>> grid = [ ... '.....', ... '.....', ... 'HHHHH', ... '.....', ... '.....' ... ] >>> minimum_perimeter(N, M, grid) 12","solution":"def minimum_perimeter(N, M, grid): Determines the minimum perimeter of a garden bed that contains all the herbs. min_row, max_row = N, -1 min_col, max_col = M, -1 for i in range(N): for j in range(M): if grid[i][j] == 'H': min_row = min(min_row, i) max_row = max(max_row, i) min_col = min(min_col, j) max_col = max(max_col, j) if min_row == N: return 0 # this happens when there are no herbs height = max_row - min_row + 1 width = max_col - min_col + 1 perimeter = 2 * (height + width) return perimeter"},{"question":"def max_sub_rectangle_sum(grid): Function to find the maximum total maintenance cost that can be achieved by selecting a sub-rectangle in a given grid. >>> max_sub_rectangle_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 45 >>> max_sub_rectangle_sum([[-1, -2], [-3, -4]]) == -1 >>> max_sub_rectangle_sum([[1, -2, 1], [3, -4, 5], [-1, 2, -1]]) == 6 >>> max_sub_rectangle_sum([[5]]) == 5 >>> max_sub_rectangle_sum([[-2, -1], [-3, -4], [-5, -6]]) == -1 pass def process_test_cases(T, test_cases): Function to process multiple test cases and find results for each. >>> process_test_cases(2, [[[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[-1, -2], [-3, -4]]]) == [45, -1] >>> process_test_cases(1, [[[1, -2, 1], [3, -4, 5], [-1, 2, -1]]]) == [6] >>> process_test_cases(1, [[[5]]]) == [5] >>> process_test_cases(1, [[[-2, -1], [-3, -4], [-5, -6]]]) == [-1] pass","solution":"def max_sub_rectangle_sum(grid): Function to find the maximum total maintenance cost that can be achieved by selecting a sub-rectangle in a given grid. Parameters: grid (list of list of int): 2D list representing the maintenance costs. Returns: int: The maximum sum of any sub-rectangle in the grid. # Get the number of rows and columns n = len(grid) m = len(grid[0]) # Initialize the result with the smallest possible value max_sum = -float('inf') # Use Kadane's algorithm for 2D array for left in range(m): temp = [0] * n for right in range(left, m): # Calculate sum of elements between left and right columns for i in range(n): temp[i] += grid[i][right] # Now find the maximum sum subarray in temp using 1D Kadane's algorithm current_sum = temp[0] max_current_sum = temp[0] for i in range(1, n): current_sum = max(temp[i], current_sum + temp[i]) if current_sum > max_current_sum: max_current_sum = current_sum # Update the global maximum sum if max_current_sum > max_sum: max_sum = max_current_sum return max_sum def process_test_cases(T, test_cases): Function to process multiple test cases and find results for each. Parameters: T (int): Number of test cases. test_cases (list of list of list of int): List containing test cases grids. Returns: list of int: List containing the results for each test case. results = [] for case in test_cases: result = max_sub_rectangle_sum(case) results.append(result) return results"},{"question":"def remove_vowels(input_str: str) -> str: This function takes a string and returns the same string but with all the vowels removed. >>> remove_vowels(\\"Hello, World!\\") == \\"Hll, Wrld!\\" >>> remove_vowels(\\"Beautiful Day\\") == \\"Btfl Dy\\"","solution":"def remove_vowels(input_str): This function takes a string and returns the same string but with all the vowels removed. vowels = \\"aeiouAEIOU\\" return ''.join(char for char in input_str if char not in vowels)"},{"question":"def update_seat_reservations(seat_reservations): Updates the seat reservations array by replacing seats in VIP rows with \\"VIP\\". VIP rows are at every odd index (1-based index). >>> update_seat_reservations([10, 20, 30, 40, 50]) [10, \\"VIP\\", 30, \\"VIP\\", 50] >>> update_seat_reservations([5, 15, 25]) [5, \\"VIP\\", 25] >>> update_seat_reservations([0, 500]) [0, \\"VIP\\"] >>> update_seat_reservations([250, 100, 450, 200]) [250, \\"VIP\\", 450, \\"VIP\\"] >>> update_seat_reservations([]) [] pass def process_test_cases(test_cases): Processes multiple test cases and returns their outputs. >>> test_cases = [ ... (5, [10, 20, 30, 40, 50]), ... (3, [5, 15, 25]) ... ] >>> process_test_cases(test_cases) [[10, \\"VIP\\", 30, \\"VIP\\", 50], [5, \\"VIP\\", 25]] >>> test_cases = [ ... (2, [0, 500]), ... (4, [250, 100, 450, 200]) ... ] >>> process_test_cases(test_cases) [[0, \\"VIP\\"], [250, \\"VIP\\", 450, \\"VIP\\"]] pass","solution":"def update_seat_reservations(seat_reservations): Updates the seat reservations array by replacing seats in VIP rows with \\"VIP\\". VIP rows are at every odd index (1-based). updated_reservations = [] for i in range(len(seat_reservations)): if (i + 1) % 2 == 0: # VIP rows (1-based index is odd) updated_reservations.append(\\"VIP\\") else: updated_reservations.append(seat_reservations[i]) return updated_reservations def process_test_cases(test_cases): Processes multiple test cases and returns their outputs. results = [] for case in test_cases: N, seat_reservations = case results.append(update_seat_reservations(seat_reservations)) return results"},{"question":"def longest_consecutive_sequence(nums): Given a list of integers, find and return the longest consecutive sequence of integers within the list. The sequence does not need to be contiguous in the input list but must appear in ascending order. If there are multiple sequences of the same maximum length, return the sequence which appears first in the list. >>> longest_consecutive_sequence([1, 9, 3, 10, 4, 20, 2]) [1, 2, 3, 4] >>> longest_consecutive_sequence([5, 2, 99, 3, 4, 1, 100]) [1, 2, 3, 4, 5] :param nums: List of integers. :return: List of integers representing the longest consecutive sequence. # Your implementation here # Test cases: assert longest_consecutive_sequence([1, 9, 3, 10, 4, 20, 2]) == [1, 2, 3, 4] assert longest_consecutive_sequence([5, 2, 99, 3, 4, 1, 100]) == [1, 2, 3, 4, 5] assert longest_consecutive_sequence([10, 5, 12, 3, 55, 30, 4, 11]) == [10, 11, 12] assert longest_consecutive_sequence([]) == [] assert longest_consecutive_sequence([42]) == [42] assert longest_consecutive_sequence([10, 30, 20]) == [10] assert longest_consecutive_sequence([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert longest_consecutive_sequence([1, 9, 3, 10, 4, 20, 2, 50, 11, 12]) == [1, 2, 3, 4]","solution":"def longest_consecutive_sequence(nums): Finds the longest consecutive sequence in the list \`nums\`. if not nums: return [] nums_set = set(nums) longest_sequence = [] for num in nums: if num - 1 not in nums_set: current_num = num current_sequence = [] while current_num in nums_set: current_sequence.append(current_num) current_num += 1 if len(current_sequence) > len(longest_sequence): longest_sequence = current_sequence return longest_sequence"},{"question":"def max_path_sum(grid, R, C): Returns the maximum sum of a path from any cell in the first column to any cell in the last column in a grid. def process_input(input_str): Processes the input string and returns the results of maximum path sums for each grid. >>> input_str = '''3 4 1 2 3 4 2 2 1 3 3 1 2 1 2 2 1 2 2 1 0 0''' >>> process_input(input_str) [12, 4]","solution":"def max_path_sum(grid, R, C): Returns the maximum sum of a path from any cell in the first column to any cell in the last column in a grid. # dp will store the maximum path sum upto each cell dp = [[0] * C for _ in range(R)] # Initialize the first column with the grid values for i in range(R): dp[i][0] = grid[i][0] # Build the dp table for j in range(1, C): for i in range(R): dp[i][j] = dp[i][j-1] + grid[i][j] if i > 0: dp[i][j] = max(dp[i][j], dp[i-1][j-1] + grid[i][j]) if i < R - 1: dp[i][j] = max(dp[i][j], dp[i+1][j-1] + grid[i][j]) # Find the maximum value in the last column max_sum = max(dp[i][C-1] for i in range(R)) return max_sum def process_input(input_str): lines = input_str.strip().split('n') index = 0 results = [] while index < len(lines): R, C = map(int, lines[index].split()) if R == 0 and C == 0: break index += 1 grid = [] for _ in range(R): row = list(map(int, lines[index].split())) grid.append(row) index += 1 result = max_path_sum(grid, R, C) results.append(result) return results"},{"question":"def symmetric_difference(list1, list2): Returns the symmetric difference between two lists. Args: list1: The first list. list2: The second list. Returns: A list containing the symmetric difference between the two lists. >>> symmetric_difference([1, 2, 3], [3, 4, 5]) [1, 2, 4, 5] >>> symmetric_difference([10, 20, 30, 40], [20, 30, 50]) [10, 40, 50] >>> symmetric_difference([1, 2], []) [1, 2]","solution":"def symmetric_difference(list1, list2): Returns the symmetric difference between two lists. Args: list1: The first list. list2: The second list. Returns: A list containing the symmetric difference between the two lists. set1 = set(list1) set2 = set(list2) # Symmetric difference is elements in set1 or set2 but not in both sym_diff = set1.symmetric_difference(set2) return list(sym_diff)"},{"question":"class Product: def __init__(self, name: str, price: float, quantity: int): Initialize a product with a name, price, and quantity in stock. pass class Store: def __init__(self): Initialize the store with an empty inventory and shopping cart. pass def add_product_to_store(self, product: Product): Add a product to the store's inventory. pass def add_product_to_cart(self, product_name: str, quantity: int) -> bool: Add the specified quantity of the product to the shopping cart, if available. pass def remove_product_from_cart(self, product_name: str, quantity: int) -> bool: Remove the specified quantity of the product from the shopping cart, if it exists. pass def checkout(self) -> tuple: Calculate the total cost of the items in the cart, update the store's inventory, and empty the cart. pass from solution import Product, Store def test_add_product_to_store(): store = Store() store.add_product_to_store(Product(\\"Tablet\\", 299.99, 15)) assert len(store.inventory) == 1 assert store.inventory[0].name == \\"Tablet\\" def test_add_product_to_cart(): store = Store() store.add_product_to_store(Product(\\"Laptop\\", 999.99, 10)) result = store.add_product_to_cart(\\"Laptop\\", 2) assert result == True assert len(store.cart) == 1 assert store.cart[0].name == \\"Laptop\\" assert store.cart[0].quantity == 2 assert store.inventory[0].quantity == 8 def test_add_product_to_cart_insufficient_quantity(): store = Store() store.add_product_to_store(Product(\\"Laptop\\", 999.99, 10)) result = store.add_product_to_cart(\\"Laptop\\", 12) assert result == False assert len(store.cart) == 0 assert store.inventory[0].quantity == 10 def test_remove_product_from_cart(): store = Store() store.add_product_to_store(Product(\\"Headphones\\", 79.99, 50)) store.add_product_to_cart(\\"Headphones\\", 5) result = store.remove_product_from_cart(\\"Headphones\\", 2) assert result == True assert len(store.cart) == 1 assert store.cart[0].name == \\"Headphones\\" assert store.cart[0].quantity == 3 assert store.inventory[0].quantity == 47 def test_remove_product_from_cart_exact_quantity(): store = Store() store.add_product_to_store(Product(\\"Smartwatch\\", 199.99, 30)) store.add_product_to_cart(\\"Smartwatch\\", 5) result = store.remove_product_from_cart(\\"Smartwatch\\", 5) assert result == True assert len(store.cart) == 0 assert store.inventory[0].quantity == 30 def test_remove_product_from_cart_nonexistent(): store = Store() store.add_product_to_store(Product(\\"Charger\\", 19.99, 100)) result = store.remove_product_from_cart(\\"Charger\\", 1) assert result == False assert len(store.cart) == 0 assert store.inventory[0].quantity == 100 def test_checkout(): store = Store() store.add_product_to_store(Product(\\"Laptop\\", 999.99, 10)) store.add_product_to_store(Product(\\"Smartphone\\", 499.99, 20)) store.add_product_to_store(Product(\\"Headphones\\", 79.99, 50)) store.add_product_to_cart(\\"Laptop\\", 2) store.add_product_to_cart(\\"Smartphone\\", 1) store.add_product_to_cart(\\"Headphones\\", 5) total_cost, purchased_items = store.checkout() assert total_cost == 999.99 * 2 + 499.99 + 79.99 * 5 assert purchased_items == [\\"Laptop\\", \\"Smartphone\\", \\"Headphones\\"] assert len(store.cart) == 0 def test_checkout_empty_cart(): store = Store() total_cost, purchased_items = store.checkout() assert total_cost == 0.0 assert purchased_items == [] assert len(store.cart) == 0","solution":"class Product: def __init__(self, name, price, quantity): self.name = name self.price = price self.quantity = quantity class Store: def __init__(self): self.inventory = [] self.cart = [] def add_product_to_store(self, product): self.inventory.append(product) def add_product_to_cart(self, product_name, quantity): for product in self.inventory: if product.name == product_name and product.quantity >= quantity: self.cart.append(Product(product.name, product.price, quantity)) product.quantity -= quantity return True return False def remove_product_from_cart(self, product_name, quantity): for cart_item in self.cart: if cart_item.name == product_name: if cart_item.quantity > quantity: cart_item.quantity -= quantity for inv_item in self.inventory: if inv_item.name == product_name: inv_item.quantity += quantity return True elif cart_item.quantity == quantity: self.cart.remove(cart_item) for inv_item in self.inventory: if inv_item.name == product_name: inv_item.quantity += quantity return True return False def checkout(self): total_cost = 0 purchased_items = [] for cart_item in self.cart: total_cost += cart_item.price * cart_item.quantity purchased_items.append(cart_item.name) self.cart.clear() return total_cost, purchased_items"},{"question":"def can_make_a_valid_transfer(R_x, R_y, R_z): Determine if at least one valid transfer can be made. R_x, R_y, R_z: integers, representing the resources on planets Xena, Yaro, and Zenon. >>> can_make_a_valid_transfer(10, 20, 30) \\"YES\\" >>> can_make_a_valid_transfer(5, 5, 5) \\"NO\\" >>> can_make_a_valid_transfer(12, 17, 6) \\"YES\\" def process_test_cases(T, test_cases): Process multiple test cases to determine if a valid transfer can be made for each. T: integer, number of test cases. test_cases: list of tuples, each containing three integers representing resources. >>> process_test_cases(3, [(10, 20, 30), (5, 5, 5), (12, 17, 6)]) [\\"YES\\", \\"NO\\", \\"YES\\"] def test_can_make_a_valid_transfer(): assert can_make_a_valid_transfer(10, 20, 30) == \\"YES\\" assert can_make_a_valid_transfer(5, 5, 5) == \\"NO\\" assert can_make_a_valid_transfer(12, 17, 6) == \\"YES\\" assert can_make_a_valid_transfer(1, 1, 1) == \\"NO\\" assert can_make_a_valid_transfer(1000, 1, 1) == \\"YES\\" def test_process_test_cases(): input_data = [ (10, 20, 30), (5, 5, 5), (12, 17, 6) ] expected_output = [\\"YES\\", \\"NO\\", \\"YES\\"] assert process_test_cases(3, input_data) == expected_output if __name__ == \\"__main__\\": test_can_make_a_valid_transfer() test_process_test_cases()","solution":"def can_make_a_valid_transfer(R_x, R_y, R_z): Determine if at least one valid transfer can be made. R_x, R_y, R_z: integers, representing the resources on planets Xena, Yaro, and Zenon. # Check Xena to Yaro if R_y < 2 * (R_x // 2): return \\"YES\\" # Check Xena to Zenon if R_z < 2 * (R_x // 2): return \\"YES\\" # Check Yaro to Xena if R_x < 2 * (R_y // 2): return \\"YES\\" # Check Yaro to Zenon if R_z < 2 * (R_y // 2): return \\"YES\\" # Check Zenon to Xena if R_x < 2 * (R_z // 2): return \\"YES\\" # Check Zenon to Yaro if R_y < 2 * (R_z // 2): return \\"YES\\" return \\"NO\\" def process_test_cases(T, test_cases): results = [] for i in range(T): R_x, R_y, R_z = test_cases[i] results.append(can_make_a_valid_transfer(R_x, R_y, R_z)) return results"},{"question":"def calculate_net_profit(transactions: list) -> int: Calculates the net profit from a list of transactions. Arguments: transactions -- a list of tuples where each tuple contains a transaction type and an amount. e.g., [('sale', 500), ('purchase', 300), ('sale', 200)] Returns: The net profit as an integer. >>> calculate_net_profit([('sale', 500), ('purchase', 300), ('sale', 200)]) == 400 >>> calculate_net_profit([('sale', 1000), ('sale', 500), ('purchase', 300), ('purchase', 200)]) == 1000 >>> calculate_net_profit([('purchase', 300), ('purchase', 300)]) == -600 >>> calculate_net_profit([('sale', 1000), ('sale', 1000), ('purchase', 300), ('purchase', 700)]) == 1000 >>> calculate_net_profit([]) == 0 >>> calculate_net_profit([('sale', 1000)]) == 1000 >>> calculate_net_profit([('purchase', 1000)]) == -1000","solution":"def calculate_net_profit(transactions): Calculates the net profit from a list of transactions. Arguments: transactions -- a list of tuples where each tuple contains a transaction type and an amount. e.g., [('sale', 500), ('purchase', 300), ('sale', 200)] Returns: The net profit as an integer. net_profit = 0 for transaction in transactions: operation, amount = transaction if operation == 'sale': net_profit += amount elif operation == 'purchase': net_profit -= amount return net_profit"},{"question":"class Grid: A data structure for efficiently supporting update and summation operations on a grid. Methods: - update(i, j, x): Sets the value of cell (i, j) to x. - sum_subgrid(r1, c1, r2, c2): Calculates the sum of values in the subgrid from (r1, c1) to (r2, c2). Example: >>> grid = Grid(3, [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) >>> grid.sum_subgrid(0, 0, 1, 1) 12 >>> grid.update(1, 1, 10) >>> grid.sum_subgrid(0, 0, 1, 1) 17 >>> grid.sum_subgrid(0, 0, 2, 2) 50 def __init__(self, n: int, grid: List[List[int]]): self.n = n self.grid = grid def update(self, i: int, j: int, x: int): Sets the value of cell (i, j) to x. pass # to be implemented def sum_subgrid(self, r1: int, c1: int, r2: int, c2: int) -> int: Calculates the sum of values in the subgrid from (r1, c1) to (r2, c2). pass # to be implemented","solution":"class Grid: def __init__(self, n, grid): self.n = n self.grid = grid def update(self, i, j, x): self.grid[i][j] = x def sum_subgrid(self, r1, c1, r2, c2): total_sum = 0 for i in range(r1, r2 + 1): for j in range(c1, c2 + 1): total_sum += self.grid[i][j] return total_sum"},{"question":"def format_string(s: str) -> str: Formats the string s to ensure each word starts with a capital letter and all subsequent letters are lowercase. It also ensures only single spaces exist between words. >>> format_string(\\"heLLo woRLD Code in PYTHON\\") 'Hello World Code In Python' >>> format_string(\\"THIS Is a TEst STRING\\") 'This Is A Test String' >>> format_string(\\"greek AlPHaBET Has 24 letTERS\\") 'Greek Alphabet Has 24 Letters'","solution":"def format_string(s): Formats the string s to ensure each word starts with a capital letter and all subsequent letters are lowercase. It also ensures only single spaces exist between words. words = s.split() formatted_words = [word.capitalize() for word in words] return ' '.join(formatted_words)"},{"question":"def max_cakes(N: int, M: int, T: List[int]) -> int: Determine the maximum number of different types of cakes that can be included on the menu such that the total preparation time does not exceed M minutes. :param N: Number of types of cakes :param M: Maximum allowable preparation time :param T: List of preparation times for each type of cake :return: Maximum number of different types of cakes >>> max_cakes(5, 100, [30, 20, 50, 10, 40]) 4 >>> max_cakes(4, 60, [25, 35, 10, 15]) 3","solution":"def max_cakes(N, M, T): Determine the maximum number of different types of cakes that can be included on the menu such that the total preparation time does not exceed M minutes. :param N: Number of types of cakes :param M: Maximum allowable preparation time :param T: List of preparation times for each type of cake :return: Maximum number of different types of cakes T.sort() total_time = 0 count = 0 for time in T: if total_time + time <= M: total_time += time count += 1 else: break return count"},{"question":"def color_matrix(n: int, m: int, matrix: List[List[int]], sx: int, sy: int) -> List[List[int]]: Colors the cell and all connected cells starting from (sx, sy) with 0. Input: - n: int, number of rows in the matrix. - m: int, number of columns in the matrix. - matrix: List[List[int]], the n x m matrix of positive integers. - sx: int, starting cell row index. - sy: int, starting cell column index. Output: - List[List[int]], the matrix after coloring the connected component. Examples: >>> color_matrix(4, 4, [ ... [1, 1, 2, 3], ... [1, 1, 2, 3], ... [3, 3, 3, 3], ... [4, 4, 4, 4] ... ], 1, 1) [ [0, 0, 2, 3], [0, 0, 2, 3], [3, 3, 3, 3], [4, 4, 4, 4] ] >>> color_matrix(3, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ], 0, 0) [ [0, 2, 3], [4, 5, 6], [7, 8, 9] ]","solution":"def color_matrix(n, m, matrix, sx, sy): Colors the connected components in the matrix starting from (sx, sy) with 0. def dfs(x, y, target_value): if x < 0 or x >= n or y < 0 or y >= m: return if matrix[x][y] != target_value: return matrix[x][y] = 0 # Explore all 8 possible directions (horizontally, vertically, diagonally) directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)] for dx, dy in directions: dfs(x + dx, y + dy, target_value) target_value = matrix[sx][sy] dfs(sx, sy, target_value) return matrix"},{"question":"def categorize_items(n, durations): Categorizes items into groups based on their expiration durations. :param n: int - number of items in the warehouse :param durations: list of int - expiration durations of the items :return: tuple - (number of unique expiration groups, list of tuples where each tuple contains an expiration duration and the count of items with that expiration duration) >>> categorize_items(6, [3, 1, 3, 2, 1, 1]) (3, [(1, 3), (2, 1), (3, 2)]) >>> categorize_items(4, [4, 4, 2, 2]) (2, [(2, 2), (4, 2)])","solution":"def categorize_items(n, durations): Categorizes items into groups based on their expiration durations. :param n: int - number of items in the warehouse :param durations: list of int - expiration durations of the items :return: list of tuples - each tuple contains an expiration duration and the count of items with that expiration duration from collections import defaultdict expiration_groups = defaultdict(int) # Count the number of items for each expiration duration for duration in durations: expiration_groups[duration] += 1 # Convert to sorted list of tuples sorted_groups = sorted(expiration_groups.items()) return len(sorted_groups), sorted_groups"},{"question":"from typing import List def is_prime(n: int) -> bool: Helper function to check if a number is a prime. pass def sumOfPrimes(arr: List[int]) -> int: Returns the sum of all prime numbers in the array. >>> sumOfPrimes([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 17 >>> sumOfPrimes([11, 13, 17, 23, 29, 31, 37, 41, 43, 47]) 292 >>> sumOfPrimes([4, 6, 8, 10, 12]) 0 pass def test_example_cases(): assert sumOfPrimes([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 17 assert sumOfPrimes([11, 13, 17, 23, 29, 31, 37, 41, 43, 47]) == 292 assert sumOfPrimes([4, 6, 8, 10, 12]) == 0 def test_no_primes(): assert sumOfPrimes([0, 1, -3, 4, 15]) == 0 def test_all_primes(): assert sumOfPrimes([2, 3, 5, 7, 11, 13]) == 41 def test_edge_cases(): assert sumOfPrimes([]) == 0 assert sumOfPrimes([2]) == 2 assert sumOfPrimes([1]) == 0 assert sumOfPrimes([-2, -3, -5, -7, -11, -13]) == 0 def test_mixed_numbers(): assert sumOfPrimes([18, 19, 21, 23, 25, 29, 30]) == 71 assert sumOfPrimes([2, 4, 6, 8, 10, 12, 14, 17]) == 19","solution":"def is_prime(n): Helper function to check if a number is a prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while (i * i) <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def sumOfPrimes(arr): Returns the sum of all prime numbers in the array. return sum(n for n in arr if is_prime(n))"},{"question":"def can_find_subsequence(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[str]: Determine if there exists at least one valid sub-sequence for given target sums across multiple test cases. Args: - t (int): the number of test cases. - test_cases (List[Tuple[Tuple[int, int], List[int]]]): a list of test cases where each test case is a tuple containing: - a tuple (n, T) where n is the size of the sequence and T is the target sum. - a list of integers representing the sequence of document values. Returns: - List[str]: a list of \\"YES\\" or \\"NO\\" for each test case indicating if there is at least one valid sub-sequence. >>> can_find_subsequence(4, [((5, 9), [1, 2, 3, 4, 5]), ((4, 11), [9, 3, 2, 1]), ((3, 3), [2, 2, 2]), ((6, 15), [1, 2, 3, 4, 5, 15])]) ['YES', 'YES', 'NO', 'YES'] >>> can_find_subsequence(2, [((3, 10), [1, 2, 3]), ((4, 20), [1, 2, 3, 4])]) ['NO', 'NO'] >>> can_find_subsequence(2, [((3, 6), [1, 2, 3]), ((4, 10), [1, 2, 3, 4])]) ['YES', 'YES'] >>> can_find_subsequence(2, [((1, 1), [1]), ((1, 5), [5])]) ['YES', 'YES'] >>> can_find_subsequence(1, [((5, 15), [3, 5, 7, 2, 8])]) ['YES']","solution":"def can_find_subsequence(t, test_cases): from itertools import combinations results = [] for i in range(t): n, T = test_cases[i][0] d = test_cases[i][1] found = False # Iterate through all possible lengths of the sub-sequence for length in range(1, n + 1): # Generate all combinations of the current length and check their sum for combination in combinations(d, length): if sum(combination) == T: found = True break if found: break if found: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List def num_unique_emails(emails: List[str]) -> int: Determine the number of unique email addresses after normalization. >>> num_unique_emails([\\"test.email+alex@leetcode.com\\", \\"test.e.mail+bob.cathy@leetcode.com\\", \\"testemail+david@lee.tcode.com\\"]) 2 >>> num_unique_emails([\\"test.email+alex@leetcode.com\\"]) 1 >>> num_unique_emails([]) 0 >>> num_unique_emails([\\"test.email+alex@leetcode.com\\", \\"test.email+alex@google.com\\"]) 2 >>> num_unique_emails([\\"test.email+alex@leetcode.com\\", \\"test.email@leetcode.com\\", \\"test.email+alex@leetcode.com\\"]) 1 >>> num_unique_emails([\\"a.b.c+d@example.com\\", \\"a.b.c@example.com\\", \\"abc+d@example.com\\"]) 1","solution":"def num_unique_emails(emails): def normalize(email): local, domain = email.split('@') local = local.split('+')[0] local = local.replace('.', '') return local + '@' + domain normalized_emails = set() for email in emails: normalized_emails.add(normalize(email)) return len(normalized_emails)"},{"question":"from typing import List def reorder_even_odd(nums: List[int]) -> List[int]: Reorders the elements in-place such that all even numbers appear before all odd numbers, while maintaining the relative order of the even and odd numbers. >>> reorder_even_odd([3,1,2,4]) [2, 4, 3, 1] >>> reorder_even_odd([0,1,2]) [0, 2, 1]","solution":"def reorder_even_odd(nums): Reorders the elements in-place such that all even numbers appear before all odd numbers, while maintaining the relative order of the even and odd numbers. if not nums or len(nums) <= 1: return nums even_index = 0 for i in range(len(nums)): if nums[i] % 2 == 0: nums.insert(even_index, nums.pop(i)) even_index += 1 return nums"},{"question":"def create_cake_grid(m: int, n: int) -> List[List[str]]: Creates a m x n grid with cakes ('P' for plain, 'I' for icing) such that no two cakes of the same type are adjacent horizontally, vertically, or diagonally. Args: m (int): Number of rows n (int): Number of columns Returns: List[List[str]]: m x n grid represented as a list of lists >>> create_cake_grid(2, 2) [['P', 'I'], ['I', 'P']] or [['I', 'P'], ['P', 'I']] >>> create_cake_grid(3, 3) [['P', 'I', 'P'], ['I', 'P', 'I'], ['P', 'I', 'P']] or [['I', 'P', 'I'], ['P', 'I', 'P'], ['I', 'P', 'I']] >>> create_cake_grid(1, 1) [['P']] or [['I']] >>> create_cake_grid(3, 2) [['P', 'I'], ['I', 'P'], ['P', 'I']] or [['I', 'P'], ['P', 'I'], ['I', 'P']] >>> create_cake_grid(4, 4) [['P', 'I', 'P', 'I'], ['I', 'P', 'I', 'P'], ['P', 'I', 'P', 'I'], ['I', 'P', 'I', 'P']] pass","solution":"def create_cake_grid(m, n): Creates a m x n grid with cakes ('P' for plain, 'I' for icing) such that no two cakes of the same type are adjacent horizontally, vertically, or diagonally. Args: m (int): Number of rows n (int): Number of columns Returns: List[List[str]]: m x n grid represented as a list of lists grid = [['' for _ in range(n)] for _ in range(m)] for i in range(m): for j in range(n): if (i + j) % 2 == 0: grid[i][j] = 'P' else: grid[i][j] = 'I' return grid def print_cake_grid(m, n): grid = create_cake_grid(m, n) for row in grid: print(''.join(row))"},{"question":"def game_of_life(n: int, m: int, g: int, board: List[List[str]]) -> List[List[str]]: Simulates Conway's Game of Life for \`g\` generations on a board of size \`n\` x \`m\`. Parameters: n (int): Number of rows m (int): Number of columns g (int): Number of generations board (list of list of str): Initial board configuration Returns: list of list of str: Final board configuration after \`g\` generations >>> game_of_life(4, 8, 3, [['.', '.', '.', '.', '.', '.', '.', '.'], ... ['.', '.', '.', '.', 'X', '.', '.', '.'], ... ['.', '.', '.', 'X', 'X', '.', '.', '.'], ... ['.', '.', '.', '.', '.', '.', '.', '.']]) [['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', 'X', 'X', '.', '.', '.'], ['.', '.', '.', 'X', 'X', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.']] >>> game_of_life(4, 4, 5, [['.', '.', '.', '.'], ... ['.', 'X', 'X', '.'], ... ['.', 'X', 'X', '.'], ... ['.', '.', '.', '.']]) [['.', '.', '.', '.'], ['.', 'X', 'X', '.'], ['.', 'X', 'X', '.'], ['.', '.', '.', '.']] >>> game_of_life(5, 5, 1, [['.', '.', '.', '.', '.'], ... ['.', '.', 'X', '.', '.'], ... ['.', '.', 'X', '.', '.'], ... ['.', '.', 'X', '.', '.'], ... ['.', '.', '.', '.', '.']]) [['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'], ['.', 'X', 'X', 'X', '.'], ['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.']]","solution":"def game_of_life(n, m, g, board): Simulates Conway's Game of Life for \`g\` generations on a board of size \`n\` x \`m\`. Parameters: n (int): Number of rows m (int): Number of columns g (int): Number of generations board (list of list of str): Initial board configuration Returns: list of list of str: Final board configuration after \`g\` generations def get_live_neighbors_count(x, y): directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] count = 0 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and board[nx][ny] == 'X': count += 1 return count def next_generation(): new_board = [['.' for _ in range(m)] for _ in range(n)] for i in range(n): for j in range(m): live_neighbors = get_live_neighbors_count(i, j) if board[i][j] == 'X': if live_neighbors == 2 or live_neighbors == 3: new_board[i][j] = 'X' else: if live_neighbors == 3: new_board[i][j] = 'X' return new_board for _ in range(g): board = next_generation() return board # Example usage: # n, m, g = 4, 8, 3 # board = [ # list(\\"........\\"), # list(\\"....X...\\"), # list(\\"...XX...\\"), # list(\\"........\\") # ] # Output final board # final_board = game_of_life(n, m, g, board) # for row in final_board: # print(''.join(row))"},{"question":"def workout_sessions(T, test_cases): Determine if there is at least one user with a workout session duration longer than D for multiple test cases. Args: T : int : Number of test cases test_cases : list : List of tuples where each tuple contains: - a tuple with two integers (N, D): N : int : Number of users D : int : Minimum duration of workout session - a list of integers : Durations of workout sessions of the users Returns: list : A list of strings \\"YES\\" or \\"NO\\" for each test case based on the condition. >>> workout_sessions(3, [((4, 30), [10, 20, 30, 40]), ((5, 50), [55, 60, 50, 45, 35]), ((3, 10), [5, 10, 15])]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> workout_sessions(2, [((3, 100), [50, 60, 70]), ((4, 200), [150, 100, 75, 50])]) [\\"NO\\", \\"NO\\"]","solution":"def workout_sessions(T, test_cases): results = [] for i in range(T): N, D = test_cases[i][0] durations = test_cases[i][1] if any(duration > D for duration in durations): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List, Tuple def reservation_system(d: int, days: List[List[Tuple[int, int]]]) -> List[str]: You are a software developer tasked with implementing a reservation system for a popular restaurant. The restaurant receives a number of reservation requests daily, and each request consists of a party size and a desired reservation time. The restaurant aims to maximize its seating capacity utilization while accommodating as many requests as possible. Each table can accommodate exactly four guests and cannot be shared between different parties. Given a list of reservation requests with their party sizes and the number of tables available, determine how many requests can be fulfilled and calculate the total number of guests that can be seated. Input: - d: int, total number of days - days: List of lists containing reservation requests for each day. Each day's list starts with a tuple (T, R) where T is the number of tables available and R is the number of reservation requests, followed by R tuples each containing (Si, Ti) where Si is the party size and Ti is the desired reservation time. Output: - A list of strings describing the result for each day in the format: \\"For Day #day_number:nXnTotally seated guests: Yn\\" where X is the number of fulfilled requests and Y is the total number of guests seated. If no requests can be fulfilled, output \\"For Day #day_number:nNo reservations fulfilledn\\". Constraints: - 1 <= D <= 10 - 1 <= T <= 20 - 1 <= R <= 50 - 1 <= Si <= 4 - 1 <= Ti <= 24 Examples: >>> reservation_system(1, [[(5,6), (3,18), (4,19), (2,20), (4,21), (1,22), (3,22)]]) [\\"For Day #1:n5nTotally seated guests: 14n\\"] >>> reservation_system(1, [[(5,0)]]) [\\"For Day #1:nNo reservations fulfilledn\\"]","solution":"def reservation_system(d, days): results = [] for day in range(d): T, R = days[day][0] requests = sorted(days[day][1:], key=lambda x: x[1]) # Sort requests by time fulfilled_requests = 0 total_guests = 0 for size, _ in requests: if size <= 4 and T > 0: fulfilled_requests += 1 total_guests += size T -= 1 if fulfilled_requests > 0: results.append(f\\"For Day #{day+1}:n{fulfilled_requests}nTotally seated guests: {total_guests}n\\") else: results.append(f\\"For Day #{day+1}:nNo reservations fulfilledn\\") return results"},{"question":"from typing import List, Tuple def are_all_routes_covered(N: int, M: int, K: int, routes: List[Tuple[int, int, int, int]]) -> str: Determine if all the buses together cover the entire grid. Parameters: N (int): The number of rows in the grid. M (int): The number of columns in the grid. K (int): The number of routes. routes (List[Tuple[int, int, int, int]]): A list of tuples where each tuple represents a route. Returns: str: 'Yes' if all buses together cover the entire grid, otherwise 'No'. Examples: >>> are_all_routes_covered(3, 3, 2, [(1, 1, 1, 3), (1, 1, 3, 1)]) 'No' >>> are_all_routes_covered(2, 2, 4, [(1, 1, 1, 2), (1, 1, 2, 1), (1, 2, 2, 2), (2, 1, 2, 2)]) 'Yes' pass # Your implementation here # Test cases def test_case_1(): assert are_all_routes_covered(3, 3, 2, [(1, 1, 1, 3), (1, 1, 3, 1)]) == \\"No\\" def test_case_2(): assert are_all_routes_covered(2, 2, 4, [(1, 1, 1, 2), (1, 1, 2, 1), (1, 2, 2, 2), (2, 1, 2, 2)]) == \\"Yes\\" def test_case_3(): assert are_all_routes_covered(3, 2, 2, [(1, 1, 3, 1), (2, 1, 2, 2)]) == \\"No\\" def test_case_4(): assert are_all_routes_covered(1, 1, 1, [(1, 1, 1, 1)]) == \\"Yes\\" def test_case_5(): assert are_all_routes_covered(3, 3, 3, [(1, 1, 1, 3), (2, 1, 2, 3), (3, 1, 3, 3)]) == \\"Yes\\" def test_case_6(): assert are_all_routes_covered(2, 2, 1, [(1, 1, 2, 1)]) == \\"No\\" def test_case_7(): assert are_all_routes_covered(5, 5, 5, [(1, 1, 5, 1), (1, 2, 5, 2), (1, 3, 5, 3), (1, 4, 5, 4), (1, 5, 5, 5)]) == \\"Yes\\"","solution":"def are_all_routes_covered(N, M, K, routes): # Mark all cells in the grid as not covered initially covered_grid = [[False] * M for _ in range(N)] # Process each route for x1, y1, x2, y2 in routes: if x1 == x2: # Vertical route for y in range(min(y1, y2), max(y1, y2) + 1): covered_grid[x1 - 1][y - 1] = True elif y1 == y2: # Horizontal route for x in range(min(x1, x2), max(x1, x2) + 1): covered_grid[x - 1][y1 - 1] = True # Check if every cell in the grid is covered for row in covered_grid: if not all(row): return \\"No\\" return \\"Yes\\" # Example usage: N = 3 M = 2 K = 2 routes = [ (1, 1, 3, 1), (2, 1, 2, 2) ] print(are_all_routes_covered(N, M, K, routes))"},{"question":"from typing import List def findUnique(nums: List[int]) -> int: This function takes a list of integers where each integer appears exactly twice except for one integer which appears only once, and returns the integer that appears only once. >>> findUnique([2, 3, 2, 4, 4]) 3 >>> findUnique([1, 1, 0, 2, 2]) 0 >>> findUnique([-1, 2, 2, 3, 3]) -1 def test_findUnique_single_element(): assert findUnique([1]) == 1 def test_findUnique_simple_case(): assert findUnique([2, 3, 2, 4, 4]) == 3 def test_findUnique_zero_case(): assert findUnique([1, 1, 0, 2, 2]) == 0 def test_findUnique_negative_case(): assert findUnique([-1, 2, 2, 3, 3]) == -1 def test_findUnique_large_numbers(): assert findUnique([1000000, 500000, 1000000, -500000, 500000, -500000, 999999]) == 999999 def test_findUnique_multiple_pairs(): assert findUnique([4, 1, 2, 1, 2, 4, 3]) == 3 def test_findUnique_ordered_numbers(): assert findUnique([3, 1, 2, 3, 1]) == 2","solution":"from typing import List def findUnique(nums: List[int]) -> int: This function finds the integer that appears only once in the array where every other integer appears twice. Args: nums: List[int] - List of integers Returns: int - The integer that appears only once unique = 0 for num in nums: unique ^= num return unique"},{"question":"def count_unique_guests(n: int, guest_list: List[str]) -> int: Returns the number of unique names in the guest list. Parameters: n (int): Number of guests. guest_list (list): List of guest names. Returns: int: Number of unique names in the guest list. >>> count_unique_guests(5, ['Alice', 'Bob', 'alice', 'BOB', 'Charlie']) 3 >>> count_unique_guests(3, ['Rita', 'Rita', 'Rita']) 1","solution":"def count_unique_guests(n, guest_list): Returns the number of unique names in the guest list. Parameters: n (int): Number of guests. guest_list (list): List of guest names. Returns: int: Number of unique names in the guest list. unique_names = set(guest_list) return len(unique_names)"},{"question":"from typing import List def is_prime(number: int) -> bool: Check if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(17) True pass def smallest_prime_ge(N: int) -> int: Given an integer N, find the smallest prime number greater than or equal to N. >>> smallest_prime_ge(10) 11 >>> smallest_prime_ge(14) 17 >>> smallest_prime_ge(1) 2 pass","solution":"def is_prime(number): if number <= 1: return False if number == 2 or number == 3: return True if number % 2 == 0 or number % 3 == 0: return False i = 5 while i * i <= number: if number % i == 0 or number % (i + 2) == 0: return False i += 6 return True def smallest_prime_ge(N): if N <= 1: return 2 while not is_prime(N): N += 1 return N"},{"question":"def min_operations_to_non_negative(n: int, arr: List[int]) -> int: Calculate the minimum number of operations required to make all elements in the array non-negative. :param n: integer, number of elements in the array :param arr: list of integers, the array elements :return: integer, minimum number of operations >>> min_operations_to_non_negative(5, [-1, -2, -3, 4, 5]) 6 >>> min_operations_to_non_negative(3, [10, -20, 30]) 20 >>> min_operations_to_non_negative(4, [-7, 8, -9, 6]) 16","solution":"def min_operations_to_non_negative(n, arr): Calculate the minimum number of operations required to make all elements in the array non-negative. :param n: integer, number of elements in the array :param arr: list of integers, the array elements :return: integer, minimum number of operations operations = 0 for num in arr: if num < 0: operations += abs(num) return operations"},{"question":"def has_cycle(n: int, edges: List[int]) -> bool: Determines whether a given linked list contains a cycle. Parameters: n (int): Number of nodes in the linked list. edges (List[int]): List where ith integer denotes the index of the next node for the ith node. Returns: bool: True if there is a cycle, False otherwise. >>> has_cycle(3, [2, 3, -1]) False >>> has_cycle(4, [2, 3, 1, -1]) True","solution":"def has_cycle(n, edges): Determines whether a given linked list contains a cycle. Parameters: n (int): Number of nodes in the linked list. edges (List[int]): List where ith integer denotes the index of the next node for the ith node. Returns: bool: True if there is a cycle, False otherwise. if n == 0: return False slow, fast = 0, 0 while fast != -1 and edges[fast] != -1: slow = edges[slow] - 1 if edges[slow] != -1 else -1 fast = edges[edges[fast] - 1] - 1 if edges[fast] != -1 and edges[edges[fast] - 1] != -1 else -1 if slow == fast: return True return False"},{"question":"def optimal_library_position(homes): Computes the optimal position for the library to minimize the sum of the Euclidean distances. The input is a list of tuples, each representing the coordinates (x, y) of a home. The function should return a tuple with the coordinates (x, y) of the optimal library position. >>> optimal_library_position([(1, 1)]) (1.0000, 1.0000) >>> optimal_library_position([(1, 1), (2, 2)]) (1.5000, 1.5000) >>> optimal_library_position([(1, 1), (2, 2), (3, 3)]) (2.0000, 2.0000) >>> optimal_library_position([(1, 1), (2, 2), (3, 3), (4, 4)]) (2.5000, 2.5000) >>> optimal_library_position([(0, 0), (10, 0), (0, 10), (10, 10)]) (5.0000, 5.0000) >>> optimal_library_position([(8, 3), (3, 8), (9, 7), (7, 1), (3, 4)]) (6.0000, 4.6000) >>> optimal_library_position([]) None","solution":"import math def optimal_library_position(homes): Computes the optimal position for the library to minimize the sum of the Euclidean distances. if not homes: return None n = len(homes) x_sum = sum(x for x, y in homes) y_sum = sum(y for x, y in homes) x_opt = x_sum / n y_opt = y_sum / n return round(x_opt, 4), round(y_opt, 4)"},{"question":"def reverse_string(s: str) -> str: Returns the string 's' reversed without using built-in reverse methods. >>> reverse_string('hello') 'olleh' >>> reverse_string('Python') 'nohtyP' >>> reverse_string('12345') '54321'","solution":"def reverse_string(s): Returns the string 's' reversed without using built-in reverse methods. reversed_s = \\"\\" for char in s: reversed_s = char + reversed_s return reversed_s"},{"question":"from typing import List, Dict def is_reachable(N: int, M: int, grid: List[List[int]], K: int) -> str: Determine if there is a path from the top-left to the bottom-right of the grid such that the height difference between two consecutive cells does not exceed K. Args: N (int): The number of rows in the grid. M (int): The number of columns in the grid. grid (List[List[int]]): The 2D grid representing the landscape. K (int): The maximum allowed height difference between consecutive cells. Returns: str: \\"Reachable\\" if there is a valid path, otherwise \\"Not reachable\\". >>> is_reachable(3, 3, [[0, 2, 3], [1, 1, 2], [4, 3, 0]], 2) \\"Reachable\\" >>> is_reachable(4, 4, [[0, 3, 5, 6], [1, 2, 7, 8], [2, 3, 6, 9], [0, 1, 1, 1]], 1) \\"Not reachable\\" pass def solve(test_cases: List[Dict[str, int]]) -> List[str]: Solve multiple test cases to determine the reachability in grids. Args: test_cases (List[Dict[str, int]]): A list of dictionaries where each dictionary contains N, M, grid, and K. Returns: List[str]: A list of results for each test case, either \\"Reachable\\" or \\"Not reachable\\". >>> solve([ ... {\\"N\\": 3, \\"M\\": 3, \\"grid\\": [[0, 2, 3], [1, 1, 2], [4, 3, 0]], \\"K\\": 2}, ... {\\"N\\": 4, \\"M\\": 4, \\"grid\\": [[0, 3, 5, 6], [1, 2, 7, 8], [2, 3, 6, 9], [0, 1, 1, 1]], \\"K\\": 1} ...]) [\\"Reachable\\", \\"Not reachable\\"] pass","solution":"from collections import deque def is_reachable(N, M, grid, K): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = [[False] * M for _ in range(N)] queue = deque([(0, 0)]) visited[0][0] = True while queue: x, y = queue.popleft() if x == N-1 and y == M-1: return \\"Reachable\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and not visited[nx][ny]: if abs(grid[nx][ny] - grid[x][y]) <= K: visited[nx][ny] = True queue.append((nx, ny)) return \\"Not reachable\\" def solve(test_cases): results = [] for case in test_cases: N, M = case['N'], case['M'] grid = case['grid'] K = case['K'] result = is_reachable(N, M, grid, K) results.append(result) return results"},{"question":"def can_be_split(nums: List[int]) -> str: Determines whether the array can be split into two subarrays with equal sums. >>> can_be_split([1, 5, 11, 5]) \\"YES\\" >>> can_be_split([1, 2, 3, 5]) \\"NO\\" >>> can_be_split([1]) \\"NO\\" >>> can_be_split([2, 2]) \\"YES\\" >>> can_be_split([1, 2]) \\"NO\\" >>> can_be_split([1, 1, 1, 1, 1, 1, 1, 1, 1]) \\"NO\\" >>> can_be_split([1, 1, 1, 1, 2, 2, 2, 2]) \\"YES\\"","solution":"def can_be_split(nums): Determines whether the array can be split into two subarrays with equal sums. total_sum = sum(nums) if total_sum % 2 != 0: return \\"NO\\" target = total_sum // 2 seen_sums = set() current_sum = 0 for num in nums: current_sum += num if current_sum == target or current_sum - target in seen_sums: return \\"YES\\" seen_sums.add(current_sum) return \\"NO\\""},{"question":"def find_indices_with_target_sum(n: int, k: int, arr: List[int]) -> Tuple[str, int, int]: Finds two distinct indices i and j such that the sum of the elements at these indices equals the target value k. :param n: Integer, the number of elements in the list :param k: Integer, the target sum value :param arr: List of n integers, the list of elements :return: A tuple (result, i, j) where result is \\"YES\\" or \\"NO\\" and i, j are the 1-based indices of the elements if result is \\"YES\\" >>> find_indices_with_target_sum(5, 9, [1, 7, 5, 3, 2]) ('YES', 2, 5) >>> find_indices_with_target_sum(4, 8, [1, 2, 4, 5]) ('NO', -1, -1) # Your code here def test_example_1(): n = 5 k = 9 arr = [1, 7, 5, 3, 2] result = find_indices_with_target_sum(n, k, arr) assert result[0] == \\"YES\\" index_set = {result[1], result[2]} expected_index_set = {2, 5} assert index_set == expected_index_set def test_example_2(): n = 4 k = 8 arr = [1, 2, 4, 5] result = find_indices_with_target_sum(n, k, arr) assert result[0] == \\"NO\\" def test_no_solution(): n = 3 k = 10 arr = [1, 2, 3] result = find_indices_with_target_sum(n, k, arr) assert result[0] == \\"NO\\" def test_multiple_solutions(): n = 5 k = 7 arr = [1, 3, 4, 2, 5] result = find_indices_with_target_sum(n, k, arr) assert result[0] == \\"YES\\" def test_negative_numbers(): n = 6 k = -1 arr = [-5, -2, -3, -4, 3, 2] result = find_indices_with_target_sum(n, k, arr) assert result[0] == \\"YES\\" index_set = {result[1], result[2]} expected_index_set = {3, 6} def test_large_numbers(): n = 2 k = 2000000000 arr = [1000000000, 1000000000] result = find_indices_with_target_sum(n, k, arr) assert result[0] == \\"YES\\"","solution":"def find_indices_with_target_sum(n, k, arr): Finds two distinct indices i and j such that the sum of the elements at these indices equals the target value k. :param n: Integer, the number of elements in the list :param k: Integer, the target sum value :param arr: List of n integers, the list of elements :return: A tuple (result, i, j) where result is \\"YES\\" or \\"NO\\" and i, j are the 1-based indices of the elements if result is \\"YES\\" # Create a dictionary to store the difference of k and the current element seen = {} for i in range(n): complement = k - arr[i] if complement in seen: return \\"YES\\", seen[complement] + 1, i + 1 seen[arr[i]] = i return \\"NO\\", -1, -1"},{"question":"from typing import List def digital_root_sequence(nums: List[int]) -> List[int]: Given a list of integers, returns a list of their digital roots. The digital root is obtained by summing the digits of each number repeatedly until a single digit is obtained. >>> digital_root_sequence([1, 2, 3, 9]) [1, 2, 3, 9] >>> digital_root_sequence([10, 11, 12, 99]) [1, 2, 3, 9] >>> digital_root_sequence([123, 456, 789, 101, 20]) [6, 6, 6, 2, 2] >>> digital_root_sequence([1000000, 9999999]) [1, 9]","solution":"def digital_root_sequence(nums): Given a list of integers, returns a list of their digital roots. The digital root is obtained by summing the digits of each number repeatedly until a single digit is obtained. def digital_root(n): while n >= 10: n = sum(int(digit) for digit in str(n)) return n return [digital_root(num) for num in nums]"},{"question":"def largest_square_area(N: int, M: int, grid: List[List[int]]) -> int: Finds the area of the largest square sub-grid containing only \`1\`s. >>> largest_square_area(5, 6, ... [ ... [1, 0, 1, 0, 0, 1], ... [1, 0, 1, 1, 1, 1], ... [1, 1, 1, 1, 1, 0], ... [0, 0, 1, 1, 1, 1], ... [1, 1, 1, 1, 1, 1]]) 9 >>> largest_square_area(1, 5, ... [[1, 1, 1, 1, 1]]) 1 >>> largest_square_area(3, 3, ... [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0]]) 0 >>> largest_square_area(4, 4, ... [ ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1]]) 16 >>> largest_square_area(3, 5, ... [ ... [1, 0, 1, 0, 1], ... [1, 1, 1, 0, 1], ... [1, 1, 1, 1, 1]]) 4","solution":"def largest_square_area(N, M, grid): Finds the area of the largest square sub-grid containing only \`1\`s. if N == 0 or M == 0: return 0 # Create a DP table initialized with zeros dp = [[0] * M for _ in range(N)] max_side = 0 # Fill the DP table for i in range(N): for j in range(M): if grid[i][j] == 1: if i == 0 or j == 0: # First row or first column dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) # The area of the largest square is the side length squared return max_side * max_side"},{"question":"def solveSudoku(board: List[List[str]]) -> None: Write a program to solve the Sudoku puzzle by filling in empty cells. A Sudoku solution must satisfy all the following rules: 1. Each of the digits 1-9 must occur exactly once in each row. 2. Each of the digits 1-9 must occur exactly once in each column. 3. Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid. The '.' character indicates empty cells. >>> board = [[\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"]] >>> solveSudoku(board) >>> board == [[\\"5\\",\\"3\\",\\"4\\",\\"6\\",\\"7\\",\\"8\\",\\"9\\",\\"1\\",\\"2\\"], [\\"6\\",\\"7\\",\\"2\\",\\"1\\",\\"9\\",\\"5\\",\\"3\\",\\"4\\",\\"8\\"], [\\"1\\",\\"9\\",\\"8\\",\\"3\\",\\"4\\",\\"2\\",\\"5\\",\\"6\\",\\"7\\"], [\\"8\\",\\"5\\",\\"9\\",\\"7\\",\\"6\\",\\"1\\",\\"4\\",\\"2\\",\\"3\\"], [\\"4\\",\\"2\\",\\"6\\",\\"8\\",\\"5\\",\\"3\\",\\"7\\",\\"9\\",\\"1\\"], [\\"7\\",\\"1\\",\\"3\\",\\"9\\",\\"2\\",\\"4\\",\\"8\\",\\"5\\",\\"6\\"], [\\"9\\",\\"6\\",\\"1\\",\\"5\\",\\"3\\",\\"7\\",\\"2\\",\\"8\\",\\"4\\"], [\\"2\\",\\"8\\",\\"7\\",\\"4\\",\\"1\\",\\"9\\",\\"6\\",\\"3\\",\\"5\\"], [\\"3\\",\\"4\\",\\"5\\",\\"2\\",\\"8\\",\\"6\\",\\"1\\",\\"7\\",\\"9\\"]] pass","solution":"def solveSudoku(board): Solves the Sudoku puzzle by filling in empty cells. solve(board) def solve(board): empty = find_empty(board) if not empty: return True row, col = empty for num in range(1, 10): if is_valid(board, str(num), row, col): board[row][col] = str(num) if solve(board): return True board[row][col] = '.' return False def find_empty(board): for i in range(9): for j in range(9): if board[i][j] == '.': return (i, j) return None def is_valid(board, num, row, col): for i in range(9): if board[row][i] == num or board[i][col] == num: return False box_x = (row // 3) * 3 box_y = (col // 3) * 3 for i in range(3): for j in range(3): if board[box_x + i][box_y + j] == num: return False return True"},{"question":"def rearrangeShelf(books, pagesRead): Returns the new order of books based on reading pages each day. >>> rearrangeShelf([\\"BookA\\", \\"BookB\\", \\"BookC\\"], [(3, 2, 1), (1, 3, 2)]) [\\"BookB\\", \\"BookA\\", \\"BookC\\"] >>> rearrangeShelf([\\"BookA\\"], [(1,), (2,)]) [\\"BookA\\"] >>> rearrangeShelf([\\"BookA\\", \\"BookB\\"], [(2, 2), (2, 2)]) [\\"BookA\\", \\"BookB\\"]","solution":"def rearrangeShelf(books, pagesRead): Returns the new order of books based on reading pages each day. total_pages_read = {book: 0 for book in books} for day in pagesRead: for idx, pages in enumerate(day): total_pages_read[books[idx]] += pages sorted_books = sorted(books, key=lambda book: -total_pages_read[book]) return sorted_books # Example usage: # books = [\\"BookA\\", \\"BookB\\", \\"BookC\\"] # pagesRead = [(3, 2, 1), (1, 3, 2)] # print(rearrangeShelf(books, pagesRead)) # Output: [\\"BookB\\", \\"BookA\\", \\"BookC\\"]"},{"question":"from typing import List, Tuple def minimum_delivery_time(n: int, m: int, edges: List[Tuple[int, int, int]], s: int, t: int) -> int: Determine the minimum time required to move a package from a starting station s to a target station t in the warehouse using Dijkstra's algorithm or another shortest path algorithm. Args: n (int): Number of stations. m (int): Number of conveyor belts. edges (List[Tuple[int, int, int]]): List of tuples where each tuple contains two stations and the time t. s (int): Starting station. t (int): Target station. Returns: int: Minimum time required to move a package from s to t. If no path exists, return -1. >>> n = 5 >>> m = 6 >>> edges = [(1, 2, 5), (2, 3, 2), (1, 3, 9), (3, 4, 3), (2, 4, 7), (4, 5, 1)] >>> s = 1 >>> t = 5 >>> minimum_delivery_time(n, m, edges, s, t) 11 >>> n = 5 >>> m = 4 >>> edges = [(1, 2, 5), (2, 3, 2), (3, 4, 3), (4, 5, 1)] >>> s = 1 >>> t = 5 >>> minimum_delivery_time(n, m, edges, s, t) 11 >>> n = 5 >>> m = 3 >>> edges = [(1, 2, 5), (2, 3, 2), (4, 5, 1)] >>> s = 1 >>> t = 5 >>> minimum_delivery_time(n, m, edges, s, t) -1","solution":"import heapq def minimum_delivery_time(n, m, edges, s, t): graph = {i: [] for i in range(1, n + 1)} for u, v, time in edges: graph[u].append((v, time)) graph[v].append((u, time)) def dijkstra(start, end): heap = [(0, start)] distances = {i: float('inf') for i in range(1, n + 1)} distances[start] = 0 while heap: current_time, u = heapq.heappop(heap) if u == end: return current_time if current_time > distances[u]: continue for v, time in graph[u]: new_time = current_time + time if new_time < distances[v]: distances[v] = new_time heapq.heappush(heap, (new_time, v)) return -1 return dijkstra(s, t)"},{"question":"from typing import List def numIslands(grid: List[List[str]]) -> int: Calculate the number of islands in the given 2D grid. An island is formed by connecting adjacent 'X' horizontally or vertically. Args: grid (List[List[str]]): The 2D grid containing 'X' and 'O'. Returns: int: The number of islands. >>> numIslands([ ... [\\"X\\",\\"X\\",\\"O\\",\\"O\\",\\"O\\"], ... [\\"X\\",\\"X\\",\\"O\\",\\"O\\",\\"O\\"], ... [\\"O\\",\\"O\\",\\"X\\",\\"O\\",\\"O\\"], ... [\\"O\\",\\"O\\",\\"O\\",\\"X\\",\\"X\\"] ... ]) 3 >>> numIslands([ ... [\\"O\\",\\"O\\",\\"O\\",\\"O\\"], ... [\\"O\\",\\"O\\",\\"O\\",\\"O\\"], ... [\\"O\\",\\"O\\",\\"O\\",\\"O\\"], ... [\\"O\\",\\"O\\",\\"O\\",\\"O\\"] ... ]) 0","solution":"from typing import List def numIslands(grid: List[List[str]]) -> int: Returns the number of islands in the given 2D grid. :param grid: List[List[str]] - The grid containing 'X' and 'O' :return: int - The number of islands if not grid: return 0 def dfs(r, c): if r < 0 or r >= m or c < 0 or c >= n or grid[r][c] == 'O': return grid[r][c] = 'O' # Mark the land as visited # Explore all four directions dfs(r + 1, c) dfs(r - 1, c) dfs(r, c + 1) dfs(r, c - 1) m, n = len(grid), len(grid[0]) island_count = 0 for r in range(m): for c in range(n): if grid[r][c] == 'X': island_count += 1 dfs(r, c) return island_count"},{"question":"def maxSwappedPair(arr): Returns a tuple (i, j) of the indices of the pair in arr that form the largest possible sum. If there are multiple pairs with the same sum, the pair with the smallest i is returned. If there is still a tie, the pair with the smallest j is returned. >>> maxSwappedPair([5, 1, 3, 7, 9]) (3, 4) >>> maxSwappedPair([10, 4, 6, 8, 2]) (0, 3) >>> maxSwappedPair([1, 2]) (0, 1) >>> maxSwappedPair([1]) None >>> maxSwappedPair([]) None >>> maxSwappedPair([9, 12, 5, 8, 7, 6, 11, 3]) (1, 6) >>> maxSwappedPair([-1, -2, -3, -4, -5]) (0, 1) >>> maxSwappedPair([100, 1, 50, 49, 25]) (0, 2) >>> maxSwappedPair([2, 3, 1, 4, 5]) (3, 4)","solution":"def maxSwappedPair(arr): Returns a tuple (i, j) of the indices of the pair in arr that form the largest possible sum. If there are multiple pairs with the same sum, the pair with the smallest i is returned. If there is still a tie, the pair with the smallest j is returned. if len(arr) < 2: return None max_value = float('-inf') second_max_value = float('-inf') max_index = -1 second_max_index = -1 # Find the largest and second largest values and their indices for index, value in enumerate(arr): if value > max_value: second_max_value = max_value second_max_index = max_index max_value = value max_index = index elif value > second_max_value: second_max_value = value second_max_index = index return (min(max_index, second_max_index), max(max_index, second_max_index))"},{"question":"def check_logins(logins: List[Tuple[int, int]], k: int) -> str: Check if any user logs in more than once within a given time period k minutes. >>> check_logins([(1, 5), (2, 20), (1, 15), (3, 25), (1, 16)], 10) 'Yes' >>> check_logins([(1, 5), (2, 20), (1, 200), (3, 25), (1, 220)], 10) 'No' def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) k = int(data[1]) logins = [] for i in range(2, len(data), 2): user_id = int(data[i]) timestamp = int(data[i + 1]) logins.append((user_id, timestamp)) print(check_logins(logins, k))","solution":"def check_logins(logins, k): from collections import defaultdict # Store the logins in a dictionary where the key is the user id user_logins = defaultdict(list) for uid, timestamp in logins: user_logins[uid].append(timestamp) # Check each user's logins for timestamps in user_logins.values(): timestamps.sort() for i in range(len(timestamps) - 1): if timestamps[i+1] - timestamps[i] <= k: return \\"Yes\\" return \\"No\\" def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) k = int(data[1]) logins = [] for i in range(2, len(data), 2): user_id = int(data[i]) timestamp = int(data[i + 1]) logins.append((user_id, timestamp)) print(check_logins(logins, k))"},{"question":"from typing import List, Tuple def smallestStringWithSwaps(s: str, indices: List[Tuple[int, int]]) -> str: Given a string \`s\` which contains only lowercase English letters and an array of pairs \`indices\` where each pair \`(a, b)\` represents a swap operation between the characters at indices \`a\` and \`b\`, this function returns the lexicographically smallest string that can be obtained after performing all the given swap operations any number of times. >>> smallestStringWithSwaps(\\"dcab\\", [(0, 3), (1, 2)]) \\"bacd\\" >>> smallestStringWithSwaps(\\"cba\\", [(0, 1), (1, 2), (0, 2)]) \\"abc\\"","solution":"from typing import List, Tuple from collections import defaultdict def smallestStringWithSwaps(s: str, indices: List[Tuple[int, int]]) -> str: parent = list(range(len(s))) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX # Build the union-find data structure for x, y in indices: union(x, y) # Group all characters according to their root parent groups = defaultdict(list) for i in range(len(s)): root = find(i) groups[root].append(s[i]) # Sort each group for group in groups.values(): group.sort() # Reconstruct the output string using the sorted groups res = list(s) for i in range(len(s)): root = find(i) res[i] = groups[root].pop(0) return ''.join(res)"},{"question":"def can_transform_to_palindrome(s: str) -> str: Transform a string into a palindrome by removing at most two characters. Return \\"YES\\" if it is possible, otherwise return \\"NO\\". >>> can_transform_to_palindrome(\\"abcbba\\") \\"YES\\" >>> can_transform_to_palindrome(\\"abcdef\\") \\"NO\\" >>> can_transform_to_palindrome(\\"radar\\") \\"YES\\" >>> can_transform_to_palindrome(\\"aabbccdd\\") \\"NO\\"","solution":"def can_transform_to_palindrome(s: str) -> str: def is_palindrome_range(i, j): while i < j: if s[i] != s[j]: return False i += 1 j -= 1 return True left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: if is_palindrome_range(left + 1, right) or is_palindrome_range(left, right - 1): return \\"YES\\" else: if is_palindrome_range(left + 1, right - 1): return \\"YES\\" else: return \\"NO\\" left += 1 right -= 1 return \\"YES\\""},{"question":"def count_visible_buildings(heights: List[int]) -> int: Calculate the total number of buildings that the observer can see. An observer can only see a building if no taller building stands in between them and the building they are looking at from the beginning of the list. Args: heights (List[int]): List of integers representing the heights of the buildings. Returns: int: The total number of buildings that the observer can see. Examples: >>> count_visible_buildings([1, 3, 2, 4, 5, 3, 2, 1]) 4 >>> count_visible_buildings([5, 4, 3, 2, 1]) 1 >>> count_visible_buildings([1, 2, 3, 4, 5, 6]) 6 >>> count_visible_buildings([3, 2, 1]) 1 pass # Example Unit Tests def test_example_1(): assert count_visible_buildings([1, 3, 2, 4, 5, 3, 2, 1]) == 4 def test_example_2(): assert count_visible_buildings([5, 4, 3, 2, 1]) == 1 def test_example_3(): assert count_visible_buildings([1, 2, 3, 4, 5, 6]) == 6 def test_example_4(): assert count_visible_buildings([3, 2, 1]) == 1 def test_single_building(): assert count_visible_buildings([7]) == 1 def test_all_same_height(): assert count_visible_buildings([2, 2, 2, 2, 2]) == 1 def test_increasing_and_decreasing(): assert count_visible_buildings([1, 2, 3, 4, 3, 2, 1]) == 4 def test_two_peaks(): assert count_visible_buildings([2, 4, 3, 5, 1]) == 3","solution":"def count_visible_buildings(heights): Function to count the number of buildings an observer can see. max_height = 0 count = 0 for height in heights: if height > max_height: count += 1 max_height = height return count"},{"question":"from typing import List def find_smallest_m(N: int) -> int: Finds the smallest integer M such that the sum of the first M natural numbers is greater than or equal to N. >>> find_smallest_m(3) == 2 >>> find_smallest_m(10) == 4 >>> find_smallest_m(14) == 5 def process_test_cases(T: int, cases: List[int]) -> List[int]: Processes multiple test cases to find the smallest integer M for each case. >>> process_test_cases(3, [3, 10, 14]) == [2, 4, 5] >>> process_test_cases(1, [1]) == [1] # Unit tests def test_find_smallest_m(): assert find_smallest_m(3) == 2 # 2 * (2 + 1) / 2 = 3 assert find_smallest_m(10) == 4 # 4 * (4 + 1) / 2 = 10 assert find_smallest_m(14) == 5 # 5 * (5 + 1) / 2 = 15 assert find_smallest_m(1) == 1 # 1 * (1 + 1) / 2 = 1 assert find_smallest_m(15) == 5 # 5 * (5 + 1) / 2 = 15 def test_process_test_cases(): assert process_test_cases(3, [3, 10, 14]) == [2, 4, 5] assert process_test_cases(1, [1]) == [1] assert process_test_cases(2, [1, 2]) == [1, 2] assert process_test_cases(4, [6, 15, 21, 28]) == [3, 5, 6, 7]","solution":"def find_smallest_m(N): Finds the smallest integer M such that the sum of the first M natural numbers is greater than or equal to N. M = 1 while M * (M + 1) // 2 < N: M += 1 return M def process_test_cases(T, cases): results = [] for case in cases: results.append(find_smallest_m(case)) return results"},{"question":"def find_longest_word_in_string(s: str) -> str: Returns the longest word in a given string s. If there are multiple words with the same maximum length, return the first one encountered. >>> find_longest_word_in_string(\\"explode the possibilities\\") 'possibilities' >>> find_longest_word_in_string(\\"coding is great fun\\") 'coding' >>> find_longest_word_in_string(\\"write efficiently\\") 'efficiently' >>> find_longest_word_in_string(\\"a ab abc abcd\\") 'abcd' >>> find_longest_word_in_string(\\"test string with a word\\") 'string' def process_multiple_strings(input_list: List[str]) -> List[str]: Processes multiple strings and returns a list containing the longest word from each string. >>> input_list = [\\"3\\", \\"explode the possibilities\\", \\"coding is great fun\\", \\"write efficiently\\"] >>> process_multiple_strings(input_list) ['possibilities', 'coding', 'efficiently'] >>> input_list = [\\"2\\", \\"a quick brown fox\\", \\"jumps over the lazy dog\\"] >>> process_multiple_strings(input_list) ['quick', 'jumps']","solution":"def find_longest_word_in_string(s): Returns the longest word in a given string s. If there are multiple words with the same maximum length, return the first one encountered. words = s.split() longest_word = words[0] for word in words: if len(word) > len(longest_word): longest_word = word return longest_word def process_multiple_strings(input_list): Processes multiple strings and returns a list containing the longest word from each string. T = int(input_list[0]) output_list = [] for i in range(1, T + 1): longest_word = find_longest_word_in_string(input_list[i]) output_list.append(longest_word) return output_list"},{"question":"def is_subset_sum_possible(n: int, weights: List[int], k: int) -> str: Determines if there is a subset of the given weights that sums to k. Parameters: n (int): the number of items weights (list of int): the weights of the items k (int): the target sum Returns: str: \\"Possible\\" if a subset exists that sums to k, otherwise \\"Not Possible\\" >>> is_subset_sum_possible(5, [1, 2, 3, 4, 5], 9) \\"Possible\\" >>> is_subset_sum_possible(4, [3, 34, 4, 12], 30) \\"Not Possible\\" >>> is_subset_sum_possible(1, [10], 10) \\"Possible\\" >>> is_subset_sum_possible(1, [10], 5) \\"Not Possible\\" >>> is_subset_sum_possible(3, [1, 2, 3], 0) \\"Possible\\" >>> weights = [i for i in range(1, 51)] >>> is_subset_sum_possible(50, weights, sum(weights)) \\"Possible\\" >>> is_subset_sum_possible(50, weights, sum(weights) + 1) \\"Not Possible\\" >>> is_subset_sum_possible(3, [1, 2, 5], 6) \\"Possible\\" >>> is_subset_sum_possible(5, [2, 4, 6, 8, 10], 12) \\"Possible\\"","solution":"def is_subset_sum_possible(n, weights, k): Determines if there is a subset of the given weights that sums to k. Parameters: n (int): the number of items weights (list of int): the weights of the items k (int): the target sum Returns: str: \\"Possible\\" if a subset exists that sums to k, otherwise \\"Not Possible\\" dp = [False] * (k + 1) dp[0] = True for weight in weights: for j in range(k, weight - 1, -1): if dp[j - weight]: dp[j] = True return \\"Possible\\" if dp[k] else \\"Not Possible\\""},{"question":"def min_flips_to_unify_bulbs(S: str) -> int: Computes the minimum number of flips needed to make all bulbs the same. >>> min_flips_to_unify_bulbs(\\"110011\\") 1 >>> min_flips_to_unify_bulbs(\\"000111\\") 1 >>> min_flips_to_unify_bulbs(\\"101010\\") 3 >>> min_flips_to_unify_bulbs(\\"000\\") 0 >>> min_flips_to_unify_bulbs(\\"111\\") 0 >>> min_flips_to_unify_bulbs(\\"00110011\\") 2 def min_flips_for_test_cases(T: int, test_cases: List[str]) -> List[int]: Computes the minimum number of flips needed for multiple test cases. >>> min_flips_for_test_cases(2, [\\"110011\\", \\"000111\\"]) [1, 1] >>> min_flips_for_test_cases(3, [\\"101010\\", \\"000\\", \\"111\\"]) [3, 0, 0] >>> min_flips_for_test_cases(1, [\\"00110011\\"]) [2] >>> min_flips_for_test_cases(4, [\\"1\\", \\"0\\", \\"10\\", \\"01\\"]) [0, 0, 1, 1]","solution":"def min_flips_to_unify_bulbs(S): Computes the minimum number of flips needed to make all bulbs the same. # Counting the number of segments of '0's and '1's count_0_segments = 0 count_1_segments = 0 n = len(S) i = 0 while i < n: if S[i] == '0': count_0_segments += 1 while i < n and S[i] == '0': i += 1 else: count_1_segments += 1 while i < n and S[i] == '1': i += 1 # The minimum flips needed would be to flip all '0' segments or all '1' segments return min(count_0_segments, count_1_segments) def min_flips_for_test_cases(T, test_cases): results = [] for S in test_cases: result = min_flips_to_unify_bulbs(S) results.append(result) return results"},{"question":"class VotingSystem: def __init__(self): Initialize the voting system with an empty dictionary to store votes. self.votes = {} def register_vote(self, voter_id: int, candidate_id: str): Register a vote for a candidate by a voter. If the voter votes again, their previous vote is updated with the new candidate. Args: voter_id (int): Unique identifier for the voter. candidate_id (str): Identifier for the candidate. Example: >>> voting_system = VotingSystem() >>> voting_system.register_vote(1, 'A') >>> voting_system.register_vote(1, 'B') self.votes[voter_id] = candidate_id def calculate_votes(self) -> dict: Calculate and return the total number of votes for each candidate. Returns: dict: A dictionary with candidate_id as keys and the corresponding vote count as values. Example: >>> voting_system = VotingSystem() >>> voting_system.register_vote(1, 'A') >>> voting_system.register_vote(2, 'B') >>> voting_system.register_vote(1, 'B') >>> voting_system.calculate_votes() {'A': 0, 'B': 2} vote_count = {} for candidate in self.votes.values(): if candidate in vote_count: vote_count[candidate] += 1 else: vote_count[candidate] = 1 return vote_count def declare_winner(self) -> tuple: Declare the candidate with the highest votes as the winner. Returns: tuple: A tuple containing the candidate_id with the highest votes and the number of votes. Example: >>> voting_system = VotingSystem() >>> voting_system.register_vote(1, 'X') >>> voting_system.register_vote(2, 'Y') >>> voting_system.register_vote(1, 'Y') >>> voting_system.register_vote(3, 'X') >>> voting_system.declare_winner() ('X', 2) vote_count = self.calculate_votes() winner = max(vote_count.items(), key=lambda item: item[1]) return winner","solution":"class VotingSystem: def __init__(self): self.votes = {} def register_vote(self, voter_id, candidate_id): self.votes[voter_id] = candidate_id def calculate_votes(self): vote_count = {} for candidate in self.votes.values(): if candidate in vote_count: vote_count[candidate] += 1 else: vote_count[candidate] = 1 return vote_count def declare_winner(self): vote_count = self.calculate_votes() winner = max(vote_count.items(), key=lambda item: item[1]) return winner # Example usage voting_system = VotingSystem() votes = [ (1, 'A'), (2, 'B'), (1, 'C'), (3, 'A'), (4, 'A'), (2, 'A') ] for voter_id, candidate_id in votes: voting_system.register_vote(voter_id, candidate_id) total_votes = voting_system.calculate_votes() winner = voting_system.declare_winner() print('Total Votes:', total_votes) print('Winner:', winner)"},{"question":"def has_even_sum_subset(arr: List[int]) -> str: Determines if there exists a subset of at least two elements with an even sum. >>> has_even_sum_subset([1, 3, 5]) 'NO' >>> has_even_sum_subset([2, 4, 6, 8]) 'YES' >>> has_even_sum_subset([1, 2, 3]) 'YES' >>> has_even_sum_subset([3, 5]) 'NO' >>> has_even_sum_subset([2, 4]) 'YES' >>> has_even_sum_subset([1]) 'NO' >>> has_even_sum_subset([2]) 'NO'","solution":"def has_even_sum_subset(arr): Determines if there exists a subset of at least two elements with an even sum. odd_count = sum(1 for x in arr if x % 2 != 0) even_count = len(arr) - odd_count if odd_count > 0 and even_count > 0: return \\"YES\\" if even_count >= 2: return \\"YES\\" return \\"NO\\""},{"question":"import re def is_palindrome(s: str) -> bool: Check if the given string s is a palindrome, ignoring case and non-alphabetical characters. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"Hello, World!\\") False >>> is_palindrome(\\"Was it a car or a cat I saw?\\") True >>> is_palindrome(\\"No 'x' in Nixon\\") True >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"A\\") True >>> is_palindrome(\\"Able was I ere I saw eLba\\") True","solution":"import re def is_palindrome(s): Check if the given string s is a palindrome, ignoring case and non-alphabetical characters. Parameters: s (str): The input string. Returns: bool: True if the string is a palindrome, False otherwise. # Remove all non-alphabetic characters and convert to lowercase cleaned_str = re.sub(r'[^A-Za-z]', '', s).lower() return cleaned_str == cleaned_str[::-1]"},{"question":"def is_prime(num: int) -> bool: Check if a number is prime. >>> is_prime(2) True >>> is_prime(5) True >>> is_prime(4) False def sumConsecutivePrimes(n: int) -> int: Returns the sum of the first n consecutive prime numbers. >>> sumConsecutivePrimes(1) 2 >>> sumConsecutivePrimes(2) 5 >>> sumConsecutivePrimes(5) 28 >>> sumConsecutivePrimes(10) 129","solution":"def is_prime(num): Check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def sumConsecutivePrimes(n): Returns the sum of the first n consecutive prime numbers. count = 0 current_num = 2 total_sum = 0 while count < n: if is_prime(current_num): total_sum += current_num count += 1 current_num += 1 return total_sum"},{"question":"from typing import List def max_sliding_window(nums: List[int], k: int) -> List[int]: Find the maximum value in each sliding window of size k. Parameters: nums (List[int]): List of integers. k (int): Size of the sliding window. Returns: List[int]: A list of the maximum values of each sliding window. Examples: >>> max_sliding_window([1, 3, -1, -3, 5, 3, 6, 7], 3) [3, 3, 5, 5, 6, 7] >>> max_sliding_window([1, 2, 3, 4, 5, 6], 1) [1, 2, 3, 4, 5, 6] >>> max_sliding_window([4, 3, 1, 2, 5], 5) [5] pass def test_max_sliding_window_case1(): assert max_sliding_window([1, 3, -1, -3, 5, 3, 6, 7], 3) == [3, 3, 5, 5, 6, 7] def test_max_sliding_window_case2(): assert max_sliding_window([1, 2, 3, 4, 5, 6], 1) == [1, 2, 3, 4, 5, 6] def test_max_sliding_window_case3(): assert max_sliding_window([4, 3, 1, 2, 5], 5) == [5] def test_max_sliding_window_empty(): assert max_sliding_window([], 3) == [] def test_max_sliding_window_single_element(): assert max_sliding_window([5], 1) == [5] def test_max_sliding_window_k_equal_to_array_length(): assert max_sliding_window([10, 20, -30, 40, 50], 5) == [50] def test_max_sliding_window_k_is_2(): assert max_sliding_window([8, 7, 6, 5, 4, 3, 2, 1], 2) == [8, 7, 6, 5, 4, 3, 2]","solution":"from collections import deque def max_sliding_window(nums, k): Find the maximum value in each sliding window of size k. Parameters: nums (list): List of integers. k (int): Size of the sliding window. Returns: list: A list of the maximum values of each sliding window. if not nums: return [] if k == 0: return [] deq = deque() result = [] for i in range(len(nums)): # Remove indices that are out of the bounds of the current window if deq and deq[0] == i - k: deq.popleft() # Remove elements from the deque that are less than the current element while deq and nums[deq[-1]] < nums[i]: deq.pop() # Add current element index at the end of deque deq.append(i) # If at least k elements have been processed, append the maximum to the result if i >= k - 1: result.append(nums[deq[0]]) return result"},{"question":"def calculate_final_grades(student_data): Returns the final grades for a list of students' assignment grades. :param student_data: List of lists, where each list contains the number of assignments followed by the grades. :return: List of final grades (floats), rounded to two decimal places. pass def parse_input(input_string): Parse the input string to extract the student data. :param input_string: Input string containing the number of students, number of assignments, and grades. :return: List of lists, where each list contains the number of assignments followed by the grades. pass # Test Cases import pytest def test_calculate_final_grades(): student_data = [ (3, 80, 90, 100), (4, 70, 75, 80, 85) ] assert calculate_final_grades(student_data) == [90.00, 77.50] def test_single_student_single_assignment(): student_data = [ (1, 90) ] assert calculate_final_grades(student_data) == [90.00] def test_mult_students_diff_assignments(): student_data = [ (2, 85, 95), (3, 70, 80, 90) ] assert calculate_final_grades(student_data) == [90.00, 80.00] def test_zero_grades(): student_data = [ (3, 0, 0, 0), (4, 0, 0, 0, 0) ] assert calculate_final_grades(student_data) == [0.00, 0.00] def test_parse_input(): input_string = \\"2n3 80 90 100n4 70 75 80 85\\" expected_output = [ [3, 80, 90, 100], [4, 70, 75, 80, 85] ] assert parse_input(input_string) == expected_output def test_combination(): input_string = \\"2n3 80 90 100n4 70 75 80 85\\" student_data = parse_input(input_string) assert calculate_final_grades(student_data) == [90.00, 77.50] if __name__ == \\"__main__\\": pytest.main()","solution":"def calculate_final_grades(student_data): Returns the final grades for a list of students' assignment grades. :param student_data: List of tuples, where each tuple contains the number of assignments followed by the grades. :return: List of final grades (floats), rounded to two decimal places. final_grades = [] for student in student_data: num_assignments = student[0] grades = student[1:] average_grade = sum(grades) / num_assignments final_grades.append(round(average_grade, 2)) return final_grades # Sample input processing def parse_input(input_string): lines = input_string.strip().split(\\"n\\") S = int(lines[0]) student_data = [] for i in range(1, S + 1): data = list(map(int, lines[i].split())) student_data.append(data) return student_data"},{"question":"def last_color_drawn(t: int, test_cases: list) -> list: This function determines the last color used for drawing lines on the grid for each test case. Parameters: t (int): Number of test cases. test_cases (list of tuples): Each tuple contains the following elements: - n (int): Size of the grid. - k (int): Number of lines drawn. - lines (list of tuples): Each tuple contains the following elements: - T (char): 'R' for row or 'C' for column. - i (int): Index of the row or column (1-based). - C (char): Color of the line. Returns: list: A list of the last colors used in each test case. from solution import last_color_drawn def test_example_cases(): t = 3 test_cases = [ (3, 4, [('R', 1, 'A'), ('C', 2, 'B'), ('R', 3, 'C'), ('C', 3, 'D')]), (5, 5, [('R', 1, 'X'), ('R', 2, 'Y'), ('C', 1, 'Z'), ('C', 5, 'W'), ('R', 5, 'V')]), (2, 2, [('C', 1, 'M'), ('R', 2, 'N')]) ] assert last_color_drawn(t, test_cases) == ['D', 'V', 'N'] def test_single_test_case(): t = 1 test_cases = [ (4, 3, [('R', 2, 'P'), ('C', 4, 'Q'), ('R', 4, 'R')]), ] assert last_color_drawn(t, test_cases) == ['R'] def test_multiple_lines_same_color(): t = 1 test_cases = [ (4, 5, [('R', 1, 'G'), ('C', 1, 'G'), ('R', 2, 'B'), ('C', 3, 'B'), ('R', 3, 'R')]), ] assert last_color_drawn(t, test_cases) == ['R'] def test_minimal_case(): t = 1 test_cases = [ (2, 2, [('R', 1, 'A'), ('C', 1, 'B')]), ] assert last_color_drawn(t, test_cases) == ['B']","solution":"def last_color_drawn(t, test_cases): This function determines the last color used for drawing lines on the grid for each test case. Parameters: t (int): Number of test cases. test_cases (list of tuples): Each tuple contains the following elements: - n (int): Size of the grid. - k (int): Number of lines drawn. - lines (list of tuples): Each tuple contains the following elements: - T (char): 'R' for row or 'C' for column. - i (int): Index of the row or column (1-based). - C (char): Color of the line. Returns: list: A list of the last colors used in each test case. results = [] for case in test_cases: n, k, lines = case last_line = lines[-1] results.append(last_line[2]) return results # Example of function usage t = 3 test_cases = [ (3, 4, [('R', 1, 'A'), ('C', 2, 'B'), ('R', 3, 'C'), ('C', 3, 'D')]), (5, 5, [('R', 1, 'X'), ('R', 2, 'Y'), ('C', 1, 'Z'), ('C', 5, 'W'), ('R', 5, 'V')]), (2, 2, [('C', 1, 'M'), ('R', 2, 'N')]) ] print(last_color_drawn(t, test_cases)) # Output: ['D', 'V', 'N']"},{"question":"def min_operations_to_equalize(n: int, d: int, arr: List[int]) -> int: Determines if it is possible to make all elements in array \`arr\` equal by incrementing or decrementing each element any number of times by \`d\`. If possible, returns the number of operations required; otherwise, returns -1. Example: >>> min_operations_to_equalize(3, 2, [2, 4, 6]) 2 >>> min_operations_to_equalize(4, 3, [1, 2, 3, 4]) -1 pass from min_operations_to_equalize import min_operations_to_equalize def test_possible_case(): assert min_operations_to_equalize(3, 2, [2, 4, 6]) == 2 def test_impossible_case(): assert min_operations_to_equalize(4, 3, [1, 2, 3, 4]) == -1 def test_single_element_array(): assert min_operations_to_equalize(1, 5, [5]) == 0 def test_all_elements_already_equal(): assert min_operations_to_equalize(3, 10, [10, 10, 10]) == 0 def test_large_d_value_possible(): assert min_operations_to_equalize(3, 1000, [1000, 2000, 3000]) == 2 def test_large_d_value_impossible(): assert min_operations_to_equalize(3, 1000, [1000, 2000, 2500]) == -1","solution":"def min_operations_to_equalize(n, d, arr): Determines if it is possible to make all elements in array \`arr\` equal by incrementing or decrementing each element any number of times by \`d\`. If possible, returns the number of operations required; otherwise, returns -1. # Determine the modulo of the first element approximately adjusted with d modulo = arr[0] % d for a in arr: if a % d != modulo: return -1 # Sort the array to find the median element arr.sort() median = arr[n // 2] operations = sum(abs(a - median) // d for a in arr) return operations"},{"question":"from typing import List def add_operators(num: str, target: int) -> List[str]: You are given a string containing only digits '0'-'9' and a target value. Your task is to add binary operators ('+', '-', '*') between the digits so that the mathematical expression evaluates to the target value. Return all possible expressions that evaluate to the target value. Examples: >>> add_operators(\\"123\\", 6) [\\"1+2+3\\", \\"1*2*3\\"] >>> add_operators(\\"232\\", 8) [\\"2*3+2\\", \\"2+3*2\\"] >>> add_operators(\\"105\\", 5) [\\"1*0+5\\", \\"10-5\\"] >>> add_operators(\\"00\\", 0) [\\"0+0\\", \\"0-0\\", \\"0*0\\"] >>> add_operators(\\"3456237490\\", 9191) []","solution":"def add_operators(num, target): def backtrack(index, path, value, prev): if index == len(num): if value == target: result.append(path) return for i in range(index+1, len(num)+1): temp_str = num[index:i] temp_num = int(temp_str) if index == 0: backtrack(i, temp_str, temp_num, temp_num) else: backtrack(i, path + '+' + temp_str, value + temp_num, temp_num) backtrack(i, path + '-' + temp_str, value - temp_num, -temp_num) backtrack(i, path + '*' + temp_str, value - prev + prev * temp_num, prev * temp_num) if num[index] == '0': break result = [] backtrack(0, \\"\\", 0, 0) return result"},{"question":"def infix_to_postfix(expression: str) -> str: Converts an infix expression to its postfix equivalent. Parameters: expression (str): A string representing a mathematical infix expression. Returns: str: A string representing the postfix equivalent of the input infix expression. Examples: >>> infix_to_postfix('2 + 3 * 4') '2 3 4 * +' >>> infix_to_postfix('( 1 + 2 ) * ( 3 - 4 )') '1 2 + 3 4 - *' >>> infix_to_postfix('5 * 3 + ( 2 / 1 )') '5 3 * 2 1 / +' >>> infix_to_postfix('( 3 + 5 ) * ( 2 - 8 ) / 4') '3 5 + 2 8 - * 4 /'","solution":"def infix_to_postfix(expression): Converts an infix expression to its postfix equivalent. Parameters: expression (str): A string representing a mathematical infix expression. Returns: str: A string representing the postfix equivalent of the input infix expression. precedence = {'+': 1, '-': 1, '*': 2, '/': 2} output = [] operators = [] def greater_precedence(op1, op2): return precedence[op1] >= precedence[op2] tokens = expression.split() for token in tokens: if token.isnumeric(): # token is an operand output.append(token) elif token == '(': operators.append(token) elif token == ')': while operators and operators[-1] != '(': output.append(operators.pop()) operators.pop() # pop '(' from operators stack else: # token is an operator while operators and operators[-1] != '(' and greater_precedence(operators[-1], token): output.append(operators.pop()) operators.append(token) # pop all the operators left in the stack while operators: output.append(operators.pop()) return \\" \\".join(output)"},{"question":"def int_to_words(num: int) -> str: Convert an integer to its word representation in lowercase and separated by a single space. >>> int_to_words(0) \\"zero\\" >>> int_to_words(123) \\"one hundred twenty three\\" >>> int_to_words(987) \\"nine hundred eighty seven\\"","solution":"def int_to_words(num): ones = [ \\"zero\\", \\"one\\", \\"two\\", \\"three\\", \\"four\\", \\"five\\", \\"six\\", \\"seven\\", \\"eight\\", \\"nine\\" ] teens = [ \\"ten\\", \\"eleven\\", \\"twelve\\", \\"thirteen\\", \\"fourteen\\", \\"fifteen\\", \\"sixteen\\", \\"seventeen\\", \\"eighteen\\", \\"nineteen\\" ] tens = [ \\"\\", \\"\\", \\"twenty\\", \\"thirty\\", \\"forty\\", \\"fifty\\", \\"sixty\\", \\"seventy\\", \\"eighty\\", \\"ninety\\" ] if num == 0: return \\"zero\\" words = [] # Hundreds place if num // 100 > 0: words.append(ones[num // 100]) words.append(\\"hundred\\") num = num % 100 # Tens and Ones places if num >= 20: words.append(tens[num // 10]) if num % 10 > 0: words.append(ones[num % 10]) elif num >= 10: words.append(teens[num - 10]) elif num > 0: words.append(ones[num]) return \\" \\".join(words)"},{"question":"def smallest_window_with_all_distinct_chars(s: str) -> int: Given a string s, return the length of the smallest window that contains all the distinct characters of the string itself. >>> smallest_window_with_all_distinct_chars(\\"aabcbcdbca\\") 4 >>> smallest_window_with_all_distinct_chars(\\"aaab\\") 2 >>> smallest_window_with_all_distinct_chars(\\"abcdef\\") 6 >>> smallest_window_with_all_distinct_chars(\\"aaaa\\") 1 >>> smallest_window_with_all_distinct_chars(\\"aab\\") 2 >>> smallest_window_with_all_distinct_chars(\\"xyyzyzyx\\") 3","solution":"def smallest_window_with_all_distinct_chars(s): Returns the length of the smallest window that contains all the distinct characters of the string s. from collections import defaultdict # Find the number of distinct characters in the string distinct_char_count = len(set(s)) n = len(s) min_len = float('inf') left = 0 char_frequency = defaultdict(int) unique_count = 0 for right in range(n): char_frequency[s[right]] += 1 if char_frequency[s[right]] == 1: unique_count += 1 while unique_count == distinct_char_count: min_len = min(min_len, right - left + 1) char_frequency[s[left]] -= 1 if char_frequency[s[left]] == 0: unique_count -= 1 left += 1 return min_len"},{"question":"from typing import List, Tuple def has_cycle(graph, N): visited = [False] * N parent = [-1] * N def dfs(v): visited[v] = True for neighbor in graph[v]: if not visited[neighbor]: parent[neighbor] = v if dfs(neighbor): return True elif parent[v] != neighbor: return True return False for i in range(N): if not visited[i]: if dfs(i): return True return False def detect_cycles(test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[str]: Detect cycles in undirected graphs. :param test_cases: List of test cases, where each test case is a tuple (N, M, edges), with N being the number of vertices, M being the number of edges, and edges being a list of (u, v) pairs representing edges. :return: List of strings indicating whether a cycle is detected (\\"Cycle Detected\\") or not (\\"No Cycle\\"). results = [] for case in test_cases: N, M, edges = case graph = [[] for _ in range(N)] for u, v in edges: graph[u].append(v) graph[v].append(u) if has_cycle(graph, N): results.append(\\"Cycle Detected\\") else: results.append(\\"No Cycle\\") return results def graph_input_parser(input_string: str) -> List[Tuple[int, int, List[Tuple[int, int]]]]: Parse multiple test cases input for graph cycle detection problem. :param input_string: The input string containing multiple test cases. :return: List of test cases parsed from input string. lines = input_string.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N, M = map(int, lines[index].split()) edges = [] for i in range(M): u, v = map(int, lines[index + 1 + i].split()) edges.append((u, v)) test_cases.append((N, M, edges)) index += 1 + M return test_cases def main(input_string: str) -> str: Main function to handle the graph cycle detection process. :param input_string: The input string containing multiple test cases. :return: The output string with cycle detection results for each test case. test_cases = graph_input_parser(input_string) results = detect_cycles(test_cases) return \\"n\\".join(results)","solution":"def has_cycle(graph, N): visited = [False] * N parent = [-1] * N def dfs(v): visited[v] = True for neighbor in graph[v]: if not visited[neighbor]: parent[neighbor] = v if dfs(neighbor): return True elif parent[v] != neighbor: return True return False for i in range(N): if not visited[i]: if dfs(i): return True return False def detect_cycles(test_cases): results = [] for case in test_cases: N, M, edges = case graph = [[] for _ in range(N)] for u, v in edges: graph[u].append(v) graph[v].append(u) if has_cycle(graph, N): results.append(\\"Cycle Detected\\") else: results.append(\\"No Cycle\\") return results def graph_input_parser(input_string): lines = input_string.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N, M = map(int, lines[index].split()) edges = [] for i in range(M): u, v = map(int, lines[index + 1 + i].split()) edges.append((u, v)) test_cases.append((N, M, edges)) index += 1 + M return test_cases def main(input_string): test_cases = graph_input_parser(input_string) results = detect_cycles(test_cases) return \\"n\\".join(results)"},{"question":"def min_operations(s1, s2): Returns the minimum number of operations required to transform s1 into s2. >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"flaw\\", \\"lawn\\") 2 >>> min_operations(\\"abc\\", \\"yabd\\") 2 >>> min_operations(\\"\\", \\"\\") 0 >>> min_operations(\\"a\\", \\"a\\") 0 >>> min_operations(\\"a\\", \\"\\") 1 >>> min_operations(\\"\\", \\"a\\") 1 pass def process_input(input_str): Processes the input and returns the results in the required format. >>> input_data = \\"kittennsittingnflawnlawnnENDn\\" >>> process_input(input_data) ['Case #1: 3', 'Case #2: 2'] >>> input_data = \\"abcdefngfedcbanabcnabdnENDn\\" >>> process_input(input_data) ['Case #1: 6', 'Case #2: 1'] pass def main(): import sys input_str = sys.stdin.read() results = process_input(input_str) for result in results: print(result)","solution":"def min_operations(s1, s2): Returns the minimum number of operations required to transform s1 into s2. m, n = len(s1), len(s2) # dp[i][j] will hold the minimum number of operations required to transform s1[0:i] into s2[0:j] dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize dp array for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # Insert all characters of s2 elif j == 0: dp[i][j] = i # Delete all characters of s1 elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters are the same, no operation required else: dp[i][j] = 1 + min(dp[i - 1][j], # Delete dp[i][j - 1], # Insert dp[i - 1][j - 1]) # Replace return dp[m][n] def process_input(input_str): lines = input_str.splitlines() results = [] i = 0 case_num = 1 while i < len(lines) and lines[i] != \\"END\\": s1 = lines[i] s2 = lines[i + 1] results.append(f\\"Case #{case_num}: {min_operations(s1, s2)}\\") case_num += 1 i += 2 return results def main(): import sys input_str = sys.stdin.read() results = process_input(input_str) for result in results: print(result)"},{"question":"def manage_inventory(inputs: List[str]) -> List[str]: Processes the list of book titles and returns the number of distinct titles and the most frequent one. If there's a tie for the most frequent book, the lexicographically smallest title is returned. >>> manage_inventory([ \\"4\\", \\"Harry Potter and the Sorcerer's Stone\\", \\"The Hobbit\\", \\"Harry Potter and the Chamber of Secrets\\", \\"The Hobbit\\", \\"6\\", \\"To Kill a Mockingbird\\", \\"1984\\", \\"The Great Gatsby\\", \\"1984\\", \\"The Catcher in the Rye\\", \\"To Kill a Mockingbird\\", \\"7\\", \\"A Tale of Two Cities\\", \\"War and Peace\\", \\"War and Peace\\", \\"Moby Dick\\", \\"The Odyssey\\", \\"War and Peace\\", \\"Moby Dick\\", \\"0\\" ]) ['3 The Hobbit', '4 1984', '4 War and Peace'] >>> manage_inventory([\\"0\\"]) []","solution":"def manage_inventory(inputs): Processes the list of book titles and returns the number of distinct titles and the most frequent one. If there's a tie for the most frequent book, the lexicographically smallest title is returned. results = [] index = 0 while index < len(inputs): n = int(inputs[index]) if n == 0: break index += 1 book_count = {} for _ in range(n): book_title = inputs[index] if book_title in book_count: book_count[book_title] += 1 else: book_count[book_title] = 1 index += 1 if not book_count: results.append(\\"0 0\\") continue # Determine number of distinct titles distinct_titles = len(book_count) # Determine the most frequent title and handle lexicographical order in case of a tie most_frequent_title = min((title for title in book_count if book_count[title] == max(book_count.values()))) results.append(f\\"{distinct_titles} {most_frequent_title}\\") return results"},{"question":"def remove_duplicates(s: str, k: int) -> str: Given a string s of lowercase letters, repeatedly remove k adjacent and equal letters from the string until no more k duplicate removals can be made. Return the final string after all such duplicate removals have been made. >>> remove_duplicates(\\"abcd\\", 2) 'abcd' >>> remove_duplicates(\\"deeedbbcccbdaa\\", 3) 'aa' >>> remove_duplicates(\\"pbbcggttciiippooaais\\", 2) 'ps'","solution":"def remove_duplicates(s: str, k: int) -> str: stack = [] # a stack to keep track of characters and their counts for char in s: # if the stack is not empty and the top of the stack has the same character, increment the count if stack and stack[-1][0] == char: stack[-1][1] += 1 else: stack.append([char, 1]) # else push the character and count 1 # if the top of stack has \`k\` count, pop it if stack[-1][1] == k: stack.pop() # reconstruct the string from the stack result = ''.join(char * count for char, count in stack) return result"},{"question":"def find_route(n, m, forbidden_pairs): Determine if it's possible to construct a valid spaceship route connecting all planets, avoiding the forbidden pairs, and if so, provide one example of the route. Parameters: - n: int : Number of planets - m: int : Number of forbidden pairs of planets - forbidden_pairs: List[Tuple[int, int]] : List containing m forbidden connection pairs Returns: - Tuple[str, Union[str, List[Tuple[int, int]]]] : \\"NO\\" if not possible, otherwise \\"YES\\" followed by the route >>> find_route(4, 2, [(1, 2), (3, 4)]) (\\"YES\\", [(1, 3), (1, 4), (1, 2)]) >>> find_route(3, 3, [(1, 2), (2, 3), (1, 3)]) \\"NO\\"","solution":"def find_route(n, m, forbidden_pairs): forbidden_set = set((min(u,v), max(u,v)) for u, v in forbidden_pairs) # Find a central planet that is not forbidden with any other planet to serve as the hub for i in range(1, n + 1): is_central_valid = True for j in range(1, n + 1): if i != j and (min(i, j), max(i, j)) in forbidden_set: is_central_valid = False break if is_central_valid: central_planet = i break else: return \\"NO\\" route = [] for i in range(1, n + 1): if i != central_planet: route.append((central_planet, i)) return \\"YES\\", route # Example usage n, m = 4, 2 forbidden_pairs = [(1, 2), (3, 4)] result = find_route(n, m, forbidden_pairs) print(result)"},{"question":"def product_except_self(nums): Constructs a new array such that each element at index i of the new array is the product of all the numbers in the original array except the one at i. Args: nums (list): A list of integers. Returns: list: A list of the products. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 4, 6]) [24, 12, 8] >>> product_except_self([10]) [1] >>> product_except_self([0, 0, 0, 0]) [0, 0, 0, 0] >>> product_except_self([0, 1, 0, 1]) [0, 0, 0, 0] >>> product_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0] >>> product_except_self([1000, 1000, 1000]) [1000000, 1000000, 1000000] >>> product_except_self([]) []","solution":"def product_except_self(nums): Constructs a new array such that each element at index i of the new array is the product of all the numbers in the original array except the one at i. Args: nums (list): A list of integers. Returns: list: A list of the products. n = len(nums) if n == 0: return [] left_products = [1] * n right_products = [1] * n # Constructing left_products array for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] # Constructing right_products array for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Constructing result array result = [1] * n for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"def max_distinct_after_change(s: str) -> int: Returns the maximum number of distinct characters that can be achieved by changing any one character in the string s. pass def process_test_cases(test_cases: List[str]) -> List[int]: Processes a list of test cases and returns the results for each. pass def solve(t: int, test_cases: List[str]) -> List[int]: Handles multiple test cases. pass # Example usage: # >>> solve(3, [\\"abca\\", \\"abcde\\", \\"zzzzz\\"]) # [4, 5, 2]","solution":"def max_distinct_after_change(s): Returns the maximum number of distinct characters that can be achieved by changing any one character in the string s. distinct_chars = len(set(s)) # If the number of distinct characters is already the maximum possible (length of string), # changing one character cannot increase the count. if distinct_chars == len(s): return distinct_chars # Otherwise, we can increase the distinct character count by one # by changing a duplicate character to a new character. return distinct_chars + 1 def process_test_cases(test_cases): results = [] for s in test_cases: results.append(max_distinct_after_change(s)) return results # Driver function to handle multiple test cases def solve(t, test_cases): return process_test_cases(test_cases)"},{"question":"def productExceptSelf(nums: List[int]) -> List[int]: Given an array nums of n integers, where n > 1, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Note: Please solve it without using division and in O(n). >>> productExceptSelf([1, 2, 3, 4]) [24, 12, 8, 6] >>> productExceptSelf([4, 5, 1, 8, 2]) [80, 64, 320, 40, 160]","solution":"def productExceptSelf(nums): n = len(nums) output = [1] * n # Calculate left products left_prod = 1 for i in range(n): output[i] = left_prod left_prod *= nums[i] # Calculate right products and combine with left products right_prod = 1 for i in range(n-1, -1, -1): output[i] *= right_prod right_prod *= nums[i] return output"},{"question":"from typing import List def minPath(grid: List[List[int]]) -> int: Returns the length of the shortest path from the top-left corner to the bottom-right corner of a given grid. Returns -1 if no such path exists. >>> minPath([[0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]]) 9 >>> minPath([[0, 1, 0], [1, 1, 0], [0, 0, 0]]) -1 >>> minPath([[0]]) 1 >>> minPath([[1, 0, 0], [0, 0, 0], [0, 0, 0]]) -1 >>> minPath([[0, 0, 0], [0, 0, 0], [0, 0, 1]]) -1 >>> minPath([[0]*100 for _ in range(100)]) 199","solution":"from collections import deque def minPath(grid): Returns the length of the shortest path from the top-left corner to the bottom-right corner of a given grid. Returns -1 if no such path exists. m, n = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (x, y, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == m - 1 and y == n - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def count_sequences(n: int) -> int: Calculate the total number of unique sequences of processes A and B of length n, modulo 10^9 + 7. The input consists of a single integer n (1  n  10^18) - the length of the sequence. Args: n: The length of the sequence. Returns: The number of unique sequences of processes A and B of length n, modulo 10^9 + 7. Examples: >>> count_sequences(3) 8 >>> count_sequences(1) 2 from solution import count_sequences def test_count_sequences(): assert count_sequences(1) == 2 assert count_sequences(2) == 4 assert count_sequences(3) == 8 assert count_sequences(10) == 1024 def test_large_n(): assert count_sequences(10**8) == pow(2, 10**8, 10**9 + 7) % (10**9 + 7) def test_edge_cases(): assert count_sequences(0) == 1 assert count_sequences(1000000000000000000) == pow(2, 1000000000000000000, 10**9 + 7) % (10**9 + 7)","solution":"MOD = 10**9 + 7 def matrix_mult(A, B, mod=MOD): Multiplies two matrices A and B under modulo. return [[(A[0][0] * B[0][0] + A[0][1] * B[1][0]) % mod, (A[0][0] * B[0][1] + A[0][1] * B[1][1]) % mod], [(A[1][0] * B[0][0] + A[1][1] * B[1][0]) % mod, (A[1][0] * B[0][1] + A[1][1] * B[1][1]) % mod]] def matrix_pow(matrix, power, mod=MOD): Computes the power of a matrix under modulo using exponentiation by squaring. result = [[1, 0], [0, 1]] base = matrix while power: if power % 2: result = matrix_mult(result, base, mod) base = matrix_mult(base, base, mod) power //= 2 return result def count_sequences(n): if n == 0: return 1 # The transformation matrix for the recurrence relation transformation_matrix = [[2, 0], [0, 2]] # Using matrix exponentiation to compute transformation_matrix^n % MOD result_matrix = matrix_pow(transformation_matrix, n, MOD) # The result is in the top-left cell of the resulting matrix return result_matrix[0][0]"},{"question":"from typing import List, Tuple def product_search(N: int, Q: int, products: List[Tuple[str, int]], queries: List[Tuple[str, int, int]]) -> List[int]: Determine the number of products that fall within the search criteria for each query. Parameters: - N (int): Number of products - Q (int): Number of queries - products (List[Tuple[str, int]]): List of tuples where each tuple contains a product type (str) and its price (int) - queries (List[Tuple[str, int, int]]): List of tuples where each tuple contains a product type (str) and two integers L and R indicating the inclusive price range Returns: - List[int]: A list of integers where each integer is the answer to the corresponding query, representing the number of products that meet the criteria >>> product_search(6, 2, [(\\"book\\", 15), (\\"book\\", 20), (\\"pen\\", 5), (\\"pen\\", 7), (\\"pen\\", 10), (\\"book\\", 10)], [(\\"book\\", 10, 20), (\\"pen\\", 5, 10)]) [3, 3] >>> product_search(0, 1, [], [(\\"book\\", 10, 20)]) [0]","solution":"def product_search(N, Q, products, queries): from collections import defaultdict # Prepare a dictionary to store products by their type product_dict = defaultdict(list) # Sort and store products based on their type and price for product_type, price in products: product_dict[product_type].append(price) for key in product_dict: product_dict[key].sort() def count_in_range(prices, L, R): # Binary search to find the count of prices within the range [L, R] from bisect import bisect_left, bisect_right start_idx = bisect_left(prices, L) end_idx = bisect_right(prices, R) return end_idx - start_idx results = [] # Process each query for query_type, L, R in queries: if query_type in product_dict: products_of_type = product_dict[query_type] count = count_in_range(products_of_type, L, R) results.append(count) else: results.append(0) return results"},{"question":"def transform_string(shift_value, input_string): Transform the input string by shifting each alphabet character by the given shift value. The alphabet is considered circular, and the case of characters is maintained. Args: shift_value (int): The number of positions to shift each alphabet character. input_string (str): The string to be transformed. Returns: str: The transformed string. Examples: >>> transform_string(3, \\"Hello, World!\\") 'Khoor, Zruog!' >>> transform_string(25, \\"abcdefghijklmnopqrstuvwxyz\\") 'zabcdefghijklmnopqrstuvwxy' from solution import transform_string def test_transform_string_basic(): assert transform_string(3, \\"Hello, World!\\") == \\"Khoor, Zruog!\\" def test_transform_string_with_zero_shift(): assert transform_string(0, \\"Hello, World!\\") == \\"Hello, World!\\" def test_transform_string_with_non_alpha_characters(): assert transform_string(3, \\"12345!@#%\\") == \\"12345!@#%\\" def test_transform_string_with_uppercase(): assert transform_string(3, \\"HELLO\\") == \\"KHOOR\\" def test_transform_string_with_lowercase(): assert transform_string(3, \\"hello\\") == \\"khoor\\" def test_transform_string_with_maximum_shift(): assert transform_string(25, \\"abcdefghijklmnopqrstuvwxyz\\") == \\"zabcdefghijklmnopqrstuvwxy\\"","solution":"def transform_string(shift_value, input_string): def shift(char, shift_value): if char.isupper(): return chr((ord(char) - ord('A') + shift_value) % 26 + ord('A')) elif char.islower(): return chr((ord(char) - ord('a') + shift_value) % 26 + ord('a')) else: return char transformed_string = \\"\\".join(shift(char, shift_value) for char in input_string) return transformed_string"},{"question":"from collections import defaultdict class NetworkTraffic: def __init__(self): Initializes the network traffic data structure. self.data = defaultdict(int) def add_packet(self, timestamp: int, size: int): Records a data packet of given size at a given timestamp. Args: timestamp: The timestamp of the data packet. size: The size of the data packet. pass def query_data(self, start: int, end: int) -> int: Queries the total size of data packets in a given time range. Args: start: The start timestamp. end: The end timestamp. Returns: The total size of data packets between start and end (inclusive). pass def process_commands(commands: List[Tuple[str, int, int]]) -> List[int]: Processes a list of network commands. Args: commands: A list of commands, which include Add and Query commands. Returns: A list of query results. >>> commands = [('A', 100, 200), ('A', 150, 300), ('Q', 100, 200), ('A', 200, 400), ('Q', 100, 250)] process_commands(commands) [500, 900] >>> commands = [('Q', 100, 200)] process_commands(commands) [0] pass","solution":"from collections import defaultdict class NetworkTraffic: def __init__(self): self.data = defaultdict(int) def add_packet(self, timestamp, size): self.data[timestamp] += size def query_data(self, start, end): total_size = 0 for timestamp in range(start, end + 1): total_size += self.data.get(timestamp, 0) return total_size def process_commands(commands): network_traffic = NetworkTraffic() results = [] for command in commands: if command[0] == 'A': _, timestamp, size = command network_traffic.add_packet(timestamp, size) elif command[0] == 'Q': _, start, end = command result = network_traffic.query_data(start, end) results.append(result) return results"},{"question":"def bfs(grid, start, end, n, m): Helper function to perform breadth-first search on the grid. Args: grid (List[str]): The grid representation with '0' for empty cells and '1' for obstacles. start (Tuple[int, int]): The starting cell coordinates (0-indexed). end (Tuple[int, int]): The target cell coordinates (0-indexed). n (int): The number of rows in the grid. m (int): The number of columns in the grid. Returns: int: The minimum number of moves to reach the target from the start, or -1 if impossible. pass def min_moves_in_grid(test_cases): Find the minimum number of moves required to get from the starting cell to the target cell. Args: test_cases (List[Tuple[int, int, List[str], int, int, int, int]]): A list of tuples representing test cases. Each tuple contains: - n (int): Number of rows in the grid. - m (int): Number of columns in the grid. - grid (List[str]): The grid representation with '0' for empty cells and '1' for obstacles. - sx (int): Starting cell row (1-indexed). - sy (int): Starting cell column (1-indexed). - tx (int): Target cell row (1-indexed). - ty (int): Target cell column (1-indexed). Returns: List[int]: A list of integers where each integer is the minimum number of moves to reach the target from the start for the corresponding test case, or -1 if impossible. pass # Test cases def test_case_1(): test_cases = [ (3, 3, ['000', '010', '000'], 1, 1, 3, 3), ] assert min_moves_in_grid(test_cases) == [4] def test_case_2(): test_cases = [ (3, 3, ['000', '000', '000'], 1, 1, 3, 1), ] assert min_moves_in_grid(test_cases) == [2] def test_case_3(): test_cases = [ (3, 3, ['010', '010', '010'], 1, 1, 3, 3), ] assert min_moves_in_grid(test_cases) == [-1] def test_multiple_cases(): test_cases = [ (3, 3, ['000', '010', '000'], 1, 1, 3, 3), (3, 3, ['000', '000', '000'], 1, 1, 3, 1), (3, 3, ['010', '010', '010'], 1, 1, 3, 3), ] assert min_moves_in_grid(test_cases) == [4, 2, -1]","solution":"from collections import deque def bfs(grid, start, end, n, m): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[False] * m for _ in range(n)] queue = deque([(start[0], start[1], 0)]) # (x, y, distance) visited[start[0]][start[1]] = True while queue: x, y, dist = queue.popleft() if (x, y) == (end[0], end[1]): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == '0': visited[nx][ny] = True queue.append((nx, ny, dist + 1)) return -1 def min_moves_in_grid(test_cases): results = [] for case in test_cases: n, m, grid, sx, sy, tx, ty = case start = (sx - 1, sy - 1) end = (tx - 1, ty - 1) result = bfs(grid, start, end, n, m) results.append(result) return results"},{"question":"def numWaysToFillBoard(n: int) -> int: Returns the number of ways to fill the first \`n\` positions with tiles such that the last two positions remain empty. >>> numWaysToFillBoard(1) 3 >>> numWaysToFillBoard(2) 9 >>> numWaysToFillBoard(4) 81","solution":"def numWaysToFillBoard(n): Returns the number of ways to fill the board up to n positions (leaving the last two positions empty) according to the summation rule defined in the problem. if n < 1: return 0 # Shouldn't happen as per given constraints: 1 <= n <= 20 # Create a DP array initialized with 0 dp = [0] * (n + 1) # Base cases dp[0] = 1 # There's 1 way to fill zero positions (doing nothing) # For n >= 1, fill the DP array for i in range(1, n + 1): if i == 1: dp[i] = 3 # Choices: A, B, or C elif i == 2: dp[i] = 9 # Choices: AA, AB, AC, BA, BB, BC, CA, CB, CC else: dp[i] = dp[i-1] * 3 # Because each next tile position depends on the one before it return dp[n]"},{"question":"def construct_matrix(N: int) -> list: Constructs an N x N matrix such that each element in the matrix is the product of its row and column indices (starting from 1). Args: N (int): The size of the matrix (1 <= N <= 20). Returns: list of list of int: The constructed N x N matrix. >>> construct_matrix(1) == [[1]] >>> construct_matrix(2) == [[1, 2], [2, 4]] >>> construct_matrix(3) == [ >>> [1, 2, 3], >>> [2, 4, 6], >>> [3, 6, 9] >>> ] >>> construct_matrix(5) == [ >>> [1, 2, 3, 4, 5], >>> [2, 4, 6, 8, 10], >>> [3, 6, 9, 12, 15], >>> [4, 8, 12, 16, 20], >>> [5, 10, 15, 20, 25] >>> ] >>> construct_matrix(10) == [[i * j for j in range(1, 11)] for i in range(1, 11)]","solution":"def construct_matrix(N): Constructs an N x N matrix such that each element in the matrix is the product of its row and column indices (starting from 1). Args: N (int): The size of the matrix (1 <= N <= 20). Returns: list of list of int: The constructed N x N matrix. matrix = [] for i in range(1, N + 1): row = [] for j in range(1, N + 1): row.append(i * j) matrix.append(row) return matrix def print_matrix(matrix): Prints the N x N matrix with each row on a new line and space-separated integers. Args: matrix (list of list of int): The matrix to print. for row in matrix: print(\\" \\".join(map(str, row))) if __name__ == \\"__main__\\": import sys input = sys.stdin.read N = int(input().strip()) matrix = construct_matrix(N) print_matrix(matrix)"},{"question":"def min_moves_to_equal_elements(arr: List[int]) -> int: Returns the minimum number of moves required to make all elements in the array equal. >>> min_moves_to_equal_elements([2, 5, 7, 3, 2]) 9 >>> min_moves_to_equal_elements([1, 3, 2, 4]) 4 import pytest def test_all_elements_equal(): assert min_moves_to_equal_elements([3, 3, 3]) == 0 def test_single_element(): assert min_moves_to_equal_elements([5]) == 0 def test_example_case1(): assert min_moves_to_equal_elements([2, 5, 7, 3, 2]) == 5 def test_example_case2(): assert min_moves_to_equal_elements([1, 3, 2, 4]) == 3 def test_large_variation(): assert min_moves_to_equal_elements([100, 2000, 30000, 400000, 5000000]) == 4999900 def test_negative_values(): assert min_moves_to_equal_elements([-10, -5, 0, 5, 10]) == 20 def test_mixed_signs(): assert min_moves_to_equal_elements([-100, 0, 100]) == 200 def test_empty(): assert min_moves_to_equal_elements([]) == 0 if __name__ == \\"__main__\\": pytest.main()","solution":"def min_moves_to_equal_elements(arr): Returns the minimum number of moves required to make all elements in the array equal. if not arr: return 0 return max(arr) - min(arr)"},{"question":"class ExpenseTracker: A class to track monthly expenses, allowing users to record transactions, adjust them, and generate summary reports. Example usage: >>> tracker = ExpenseTracker() >>> tracker.add_transaction(\\"2023-01-01\\", 1000.0, \\"Rent\\") >>> tracker.add_transaction(\\"2023-01-15\\", 150.0, \\"Utilities\\") >>> tracker.add_transaction(\\"2023-01-20\\", 200.0, \\"Supplies\\") >>> summary, adjustments = tracker.generate_summary(\\"2023-01\\") >>> summary {\\"Rent\\": 1000.0, \\"Utilities\\": 150.0, \\"Supplies\\": 200.0} >>> adjustments [] >>> tracker.adjust_transaction(1, 1100.0, \\"Rent\\") >>> summary, adjustments = tracker.generate_summary(\\"2023-01\\") >>> summary {\\"Rent\\": 1100.0, \\"Utilities\\": 150.0, \\"Supplies\\": 200.0} >>> adjustments [1] def __init__(self): pass def add_transaction(self, date: str, amount: float, category: str): pass def adjust_transaction(self, transaction_id: int, new_amount: float, new_category: str): pass def generate_summary(self, month: str): pass def handle_operations(self, operations: List[str]) -> str: pass","solution":"class Transaction: def __init__(self, transaction_id, date, amount, category): self.transaction_id = transaction_id self.date = date self.amount = amount self.category = category self.adjusted = False def update(self, new_amount, new_category): self.amount = new_amount self.category = new_category self.adjusted = True class ExpenseTracker: def __init__(self): self.transactions = [] self.transaction_id_counter = 1 def add_transaction(self, date, amount, category): transaction = Transaction(self.transaction_id_counter, date, amount, category) self.transactions.append(transaction) self.transaction_id_counter += 1 def adjust_transaction(self, transaction_id, new_amount, new_category): for transaction in self.transactions: if transaction.transaction_id == transaction_id: transaction.update(new_amount, new_category) break def generate_summary(self, month): summary = {} adjustments = [] for transaction in self.transactions: if transaction.date.startswith(month): summary[transaction.category] = summary.get(transaction.category, 0) + transaction.amount if transaction.adjusted: adjustments.append(transaction.transaction_id) return summary, adjustments def handle_operations(self, operations): results = [] for operation in operations: parts = operation.split() if parts[0] == \\"ADD\\": self.add_transaction(parts[1], float(parts[2]), parts[3]) elif parts[0] == \\"ADJUST\\": self.adjust_transaction(int(parts[1]), float(parts[2]), parts[3]) elif parts[0] == \\"SUMMARY\\": summary, adjustments = self.generate_summary(parts[1]) result = [f\\"{category}: {amount}\\" for category, amount in summary.items()] result.append(f\\"Adjustments: {adjustments}\\") results.append(\\"n\\".join(result)) return \\"nn\\".join(results)"},{"question":"def find_odds(arr): Returns a list of integers that appear an odd number of times in the input list. >>> find_odds([1, 2, 3, 2, 3, 4, 4, 4]) [1, 4] >>> find_odds([4, 4, 4, 5, 5, 6, 6, 6, 7]) [4, 6, 7] from solution import find_odds def test_single_element(): assert find_odds([1]) == [1] def test_no_odds(): assert find_odds([2, 2, 3, 3]) == [] def test_mixed_numbers(): assert find_odds([1, 2, 3, 2, 3, 4, 4, 4]) == [1, 4] assert find_odds([4, 4, 4, 5, 5, 6, 6, 6, 7]) == [4, 6, 7] def test_all_odds(): assert find_odds([1, 1, 1, 3, 3, 3, 5]) == [1, 3, 5] def test_edge_cases(): assert find_odds([]) == [] assert find_odds([5, 5, 5, 5, 5, 5, 5]) == [5]","solution":"def find_odds(arr): Returns a list of integers that appear an odd number of times in the input list. from collections import Counter counts = Counter(arr) return [num for num, count in counts.items() if count % 2 != 0]"},{"question":"def longest_double_subsequence(arr: List[int]) -> int: Function to find the length of the longest subsequence where each element is at least double its predecessor. >>> longest_double_subsequence([3, 5, 6, 13, 26, 50]) 4 >>> longest_double_subsequence([1, 2, 4, 8, 16]) 5 >>> longest_double_subsequence([5, 1, 2, 3, 5, 8, 16]) 4 >>> longest_double_subsequence([7, 6, 5, 4, 3, 2, 1]) 1","solution":"def longest_double_subsequence(arr): Function to find the length of the longest subsequence where each element is at least double its predecessor. if not arr: return 0 n = len(arr) dp = [1] * n # Initialize dp array with 1, as a single element is a valid subsequence for i in range(1, n): for j in range(i): if arr[i] >= 2 * arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def is_possible_sequence(pairs): Develop a program to find out if it is possible to create a sequence of unique pairs (x, y) such that they satisfy the rules given below: You are provided with a list of pairs (x, y), and you need to determine if these pairs can be rearranged into a sequence where each consecutive pair in the sequence satisfies either the first or the second condition: 1. Their x-coordinates are the same. 2. Their y-coordinates are the same. Args: pairs: List of pairs (x, y). Returns: String, \\"Possible\\" or \\"Not Possible\\" denoting whether the sequence can be formed as per the given rules. >>> is_possible_sequence([(1, 2), (2, 2), (3, 2)]) 'Possible' >>> is_possible_sequence([(1, 1), (2, 2), (3, 1), (4, 2)]) 'Not Possible' def solve(test_cases): Args: test_cases: List of lists of pairs to handle multiple test cases. Returns: List of results for each test case. def parse_input(input_string): Args: input_string: Multiline string containing the input. Returns: Parsed input converted into a suitable data structure. def main(input_string): Args: input_string: Multiline string containing the input. Returns: Multiline string containing the output for each test case.","solution":"def is_possible_sequence(pairs): from collections import defaultdict, deque if not pairs: return \\"Possible\\" graph_x = defaultdict(list) graph_y = defaultdict(list) for x, y in pairs: graph_x[x].append(y) graph_y[y].append(x) visited = set() need_to_visit = deque([pairs[0]]) while need_to_visit: current = need_to_visit.popleft() if current in visited: continue visited.add(current) x, y = current for neighbor_y in graph_x[x]: if (x, neighbor_y) not in visited: need_to_visit.append((x, neighbor_y)) for neighbor_x in graph_y[y]: if (neighbor_x, y) not in visited: need_to_visit.append((neighbor_x, y)) return \\"Possible\\" if len(visited) == len(pairs) else \\"Not Possible\\" def solve(test_cases): results = [] for pairs in test_cases: results.append(is_possible_sequence(pairs)) return results def parse_input(input_string): lines = input_string.strip().split('n') idx = 0 T = int(lines[idx]) idx += 1 test_cases = [] for _ in range(T): N = int(lines[idx]) idx += 1 pairs = [] for _ in range(N): x, y = map(int, lines[idx].split()) idx += 1 pairs.append((x, y)) test_cases.append(pairs) return test_cases def main(input_string): test_cases = parse_input(input_string) results = solve(test_cases) return \\"n\\".join(results)"},{"question":"def letter_pattern(n: int) -> str: Returns the pattern according to the nth letter of the alphabet in uppercase. Parameters: n (int): nth letter of the alphabet. Returns: str: Multi-line string pattern as specified. if n < 1 or n > 26: return \\"\\" result = [] for i in range(1, n+1): result.append(''.join(chr(65 + j) for j in range(i))) return \\"n\\".join(result) # Example usage: # >>> letter_pattern(1) # 'A' # >>> letter_pattern(3) # 'AnABnABC' # >>> letter_pattern(5) # 'AnABnABCnABCDnABCDE' from solution import letter_pattern def test_letter_pattern_min(): assert letter_pattern(1) == \\"A\\" def test_letter_pattern_inclusive(): assert letter_pattern(3) == \\"AnABnABC\\" assert letter_pattern(5) == \\"AnABnABCnABCDnABCDE\\" assert letter_pattern(26) == \\"AnABnABCnABCDnABCDEnABCDEFnABCDEFGnABCDEFGHnABCDEFGHInABCDEFGHIJnABCDEFGHIJKnABCDEFGHIJKLnABCDEFGHIJKLMnABCDEFGHIJKLMNnABCDEFGHIJKLMNOnABCDEFGHIJKLMNOPnABCDEFGHIJKLMNOPQnABCDEFGHIJKLMNOPQRnABCDEFGHIJKLMNOPQRSnABCDEFGHIJKLMNOPQRSTnABCDEFGHIJKLMNOPQRSTUnABCDEFGHIJKLMNOPQRSTUVnABCDEFGHIJKLMNOPQRSTUVWnABCDEFGHIJKLMNOPQRSTUVWXnABCDEFGHIJKLMNOPQRSTUVWXYnABCDEFGHIJKLMNOPQRSTUVWXYZ\\" def test_letter_pattern_out_of_bounds(): assert letter_pattern(0) == \\"\\" assert letter_pattern(27) == \\"\\" assert letter_pattern(-5) == \\"\\" assert letter_pattern(100) == \\"\\" def test_letter_pattern_edge_case(): assert letter_pattern(13) == \\"AnABnABCnABCDnABCDEnABCDEFnABCDEFGnABCDEFGHnABCDEFGHInABCDEFGHIJnABCDEFGHIJKnABCDEFGHIJKLnABCDEFGHIJKLM\\"","solution":"def letter_pattern(n): Returns the pattern according to the nth letter of the alphabet in uppercase. Parameters: n (int): nth letter of the alphabet. Returns: str: Multi-line string pattern as specified. if n < 1 or n > 26: return \\"\\" result = [] for i in range(1, n+1): result.append(''.join(chr(65 + j) for j in range(i))) return \\"n\\".join(result)"},{"question":"from typing import List, Tuple def get_skyline(buildings: List[Tuple[int, int, int]]) -> List[Tuple[int, int]]: Calculate the skyline for the given buildings. Args: buildings (list of tuple): List of buildings, each defined by (Li, Ri, Hi). Returns: List of tuple: List of key points that define the skyline. Examples: >>> get_skyline([(2, 9, 10), (3, 7, 15), (5, 12, 12), (15, 20, 10), (19, 24, 8)]) [(2, 10), (3, 15), (7, 12), (12, 0), (15, 10), (20, 8), (24, 0)] >>> get_skyline([(2, 9, 10)]) [(2, 10), (9, 0)] >>> get_skyline([(1, 5, 11), (5, 10, 9)]) [(1, 11), (5, 9), (10, 0)] >>> get_skyline([(1, 3, 2), (5, 7, 4)]) [(1, 2), (3, 0), (5, 4), (7, 0)] >>> get_skyline([(2, 9, 10), (2, 9, 15), (2, 9, 12)]) [(2, 15), (9, 0)]","solution":"import heapq def get_skyline(buildings): Calculate the skyline for the given buildings. Args: buildings (list of tuple): List of buildings, each defined by (Li, Ri, Hi). Returns: List of tuple: List of key points that define the skyline. events = [] for L, R, H in buildings: events.append((L, -H, R)) events.append((R, 0, 0)) events.sort() result = [(0, 0)] live_buildings = [] for x, negH, R in events: while live_buildings and live_buildings[0][1] <= x: heapq.heappop(live_buildings) if negH != 0: heapq.heappush(live_buildings, (negH, R)) max_height = -live_buildings[0][0] if live_buildings else 0 if max_height != result[-1][1]: result.append((x, max_height)) return result[1:]"},{"question":"def can_reach_bottom_right(n: int, m: int, grid: List[str]) -> str: Determines whether Alice can reach the bottom-right corner using her ability to jump over a blocked cell once. >>> can_reach_bottom_right(4, 4, [ ...., .., ..#., ....]) == \\"YES\\" >>> can_reach_bottom_right(3, 3, [ \\"...\\", \\"...\\", \\"...\\"]) == \\"YES\\" >>> can_reach_bottom_right(3, 3, [ \\"#..\\", \\"...\\", \\"...\\"]) == \\"NO\\" >>> can_reach_bottom_right(3, 3, [ \\"...\\", \\"...\\", \\"..#\\"]) == \\"NO\\" >>> can_reach_bottom_right(3, 3, [ \\"...\\", \\"#\\", \\"...\\"]) == \\"YES\\" >>> can_reach_bottom_right(5, 5, [ \\".....\\", \\".#.\\", \\".#.\\", \\".#.\\", \\".....\\"]) == \\"YES\\" >>> can_reach_bottom_right(3, 3, [ \\"...\\", \\"#\\", \\"#\\"]) == \\"NO\\"","solution":"def can_reach_bottom_right(n, m, grid): from collections import deque def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == '.' def bfs(): queue = deque([(0, 0, 0)]) # (x, y, jumps_used) visited = set((0, 0, 0)) directions = [(0, 1), (1, 0)] while queue: x, y, jumps = queue.popleft() if x == n - 1 and y == m - 1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny, jumps) not in visited: visited.add((nx, ny, jumps)) queue.append((nx, ny, jumps)) elif not is_valid(nx, ny) and jumps == 0: njx, njy = nx + dx, ny + dy if is_valid(njx, njy) and (njx, njy, jumps + 1) not in visited: visited.add((njx, njy, jumps + 1)) queue.append((njx, njy, jumps + 1)) return False if grid[0][0] == '#' or grid[n-1][m-1] == '#': return \\"NO\\" return \\"YES\\" if bfs() else \\"NO\\" # Example usage n = 4 m = 4 grid = [ \\"....\\", \\"..\\", \\"..#.\\", \\"....\\" ] print(can_reach_bottom_right(n, m, grid)) # Output: YES"},{"question":"from typing import List, Tuple def largest_connected_component(n: int, m: int, friendships: List[Tuple[int, int]]) -> int: Returns the size of the largest connected component of friends in the social network. >>> largest_connected_component(5, 3, [(1, 2), (2, 3), (4, 5)]) == 3 >>> largest_connected_component(6, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) == 6 >>> largest_connected_component(5, 0, []) == 1 >>> largest_connected_component(4, 3, [(1, 2), (2, 3), (3, 4)]) == 4 >>> largest_connected_component(7, 4, [(1, 2), (3, 4), (4, 5), (6, 7)]) == 3 >>> largest_connected_component(10, 3, [(2, 3), (4, 5), (8, 9)]) == 2","solution":"from collections import defaultdict, deque def largest_connected_component(n, m, friendships): def bfs(node): queue = deque([node]) visited[node] = True count = 1 while queue: current = queue.popleft() for neighbor in graph[current]: if not visited[neighbor]: queue.append(neighbor) visited[neighbor] = True count += 1 return count # Build the adjacency list for the graph graph = defaultdict(list) for u, v in friendships: graph[u].append(v) graph[v].append(u) # Initialize visited array visited = [False] * (n + 1) # Find the largest connected component largest_component_size = 0 for user in range(1, n + 1): if not visited[user]: largest_component_size = max(largest_component_size, bfs(user)) return largest_component_size"},{"question":"def total_year_differences(N: int, years: List[int]) -> int: Returns the total year differences between adjacent coins for the optimal arrangement. Parameters: N (int): the number of coins years (List[int]): the list of minting years of the coins Returns: int: the total year difference for the optimal arrangement Examples: >>> total_year_differences(5, [1987, 2003, 1995, 2019, 2010]) 32 >>> total_year_differences(3, [1990, 1992, 1988]) 4 >>> total_year_differences(1, [2000]) 0 >>> total_year_differences(5, [2001, 2002, 2003, 2004, 2005]) 4 >>> total_year_differences(3, [1, 1000000000, 500000000]) 999999999","solution":"def total_year_differences(N, years): Returns the total year differences between adjacent coins for the optimal arrangement. Parameters: N (int): the number of coins years (List[int]): the list of minting years of the coins Returns: int: the total year difference for the optimal arrangement # Sort the years to minimize the adjacent differences years.sort() total_difference = 0 # Calculate the total difference for adjacent coins for i in range(1, N): total_difference += years[i] - years[i - 1] return total_difference"},{"question":"def min_shelves(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Compute the minimum number of shelves needed for each test case. Parameters: T (int): Number of test cases test_cases (list of tuples): Each tuple contains: - An integer N denoting the number of books - An integer W denoting the maximum weight capacity of each shelf - A list of integers denoting the weights of the books Returns: list: A list of integers where each integer is the minimum number of shelves required for the corresponding test case. >>> min_shelves(2, [(5, 10, [2, 3, 5, 7, 1]), (3, 15, [8, 5, 2])]) [3, 1] >>> min_shelves(1, [(1, 10, [7])]) [1] >>> min_shelves(1, [(0, 10, [])]) [0] >>> min_shelves(1, [(4, 100, [10, 20, 30, 40])]) [1] >>> min_shelves(1, [(3, 1, [1, 1, 1])]) [3] >>> min_shelves(1, [(3, 3, [1, 2, 2])]) [2]","solution":"def min_shelves(T, test_cases): Function to compute the minimum number of shelves needed for each test case. Parameters: T (int): Number of test cases test_cases (list of tuples): Each tuple contains: - An integer N denoting the number of books - An integer W denoting the maximum weight capacity of each shelf - A list of integers denoting the weights of the books Returns: list: A list of integers where each integer is the minimum number of shelves required for the corresponding test case. results = [] for i in range(T): N, W, books = test_cases[i] books.sort(reverse=True) shelf_count = 0 while books: current_weight = 0 # Try to fit as many books as possible on the current shelf while books and current_weight + books[-1] <= W: current_weight += books.pop() shelf_count += 1 results.append(shelf_count) return results # Example usage from the problem statement T = 2 test_cases = [ (5, 10, [2, 3, 5, 7, 1]), (3, 15, [8, 5, 2]) ] print(min_shelves(T, test_cases)) # Output should be [3, 1]"},{"question":"from typing import List, Tuple, Union def find_shortest_times(test_cases: List[Tuple[int, int, List[Tuple[int, int, int]], Tuple[int, int]]]) -> List[Union[int, str]]: Determine the shortest travel time between two specified intersections. >>> find_shortest_times([(4, 4, [(1, 2, 10), (1, 3, 15), (2, 4, 10), (3, 4, 5)], (1, 4))]) [20] >>> find_shortest_times([(3, 1, [(1, 2, 1)], (3, 1))]) [\\"no path\\"] >>> find_shortest_times([(4, 4, [(1, 2, 10), (1, 3, 15), (2, 4, 10), (3, 4, 5)], (1, 4)), (3, 1, [(1, 2, 1)], (3, 1))]) [20, \\"no path\\"]","solution":"import heapq def dijkstra(n, graph, source, destination): Find the shortest travel time using Dijkstra's algorithm. distances = {i: float('inf') for i in range(1, n+1)} distances[source] = 0 priority_queue = [(0, source)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances[destination] if distances[destination] != float('inf') else \\"no path\\" def find_shortest_times(test_cases): results = [] for n, m, roads, (s, d) in test_cases: graph = {i: [] for i in range(1, n+1)} for u, v, t in roads: graph[u].append((v, t)) graph[v].append((u, t)) shortest_time = dijkstra(n, graph, s, d) results.append(shortest_time) return results"},{"question":"from typing import List, Tuple def find_highest_average_player(test_cases: List[Tuple[int, int, List[List[str]]]]) -> List[int]: Determine the player with the highest average score from a series of games. Each game follows different rules: - Game A: Each player receives a score between 0 and 100. - Game B: Each player throws a die, and the result (1 to 6) is multiplied by 10 to get their score. - Game C: Players answer a series of questions, each worth 5 points, with a maximum of 50 points. Input: - The first line contains a single integer T, the number of test cases. - For each test case: - The first line contains two integers P and G, where P is the number of players and G is the number of games. - The next P lines contain the scores of each player in the G games in the format: - \\"A score\\" for Game A - \\"B score\\" for Game B - \\"C score count_correct_answers\\" for Game C Output: - For each test case, output the player number (1-indexed) with the highest average score. If multiple players have the same average score, output the one with the lowest index. >>> find_highest_average_player(parse_input(\\"2n3 3nA 55, B 5, C 7nA 40, B 6, C 8nA 60, B 3, C 10n2 2nA 30, B 2nA 70, B 1n\\")) [1, 2] >>> find_highest_average_player(parse_input(\\"1n3 2nA 55, C 7nA 40, C 8nA 60, C 10n\\")) [3] >>> find_highest_average_player(parse_input(\\"1n2 2nB 3, C 10nC 5, A 75n\\")) [2] >>> find_highest_average_player(parse_input(\\"1n1 3nA 0, B 0, C 0n\\")) [1] >>> find_highest_average_player(parse_input(\\"1n1 3nA 100, B 6, C 10n\\")) [1] pass def parse_input(input_data: str) -> List[Tuple[int, int, List[List[str]]]]: Parses the input string and returns a list of test cases. pass","solution":"def find_highest_average_player(test_cases): results = [] for test in test_cases: P, G, players_scores = test highest_average = -1 best_player = -1 for idx, scores in enumerate(players_scores): total_score = 0 for score_info in scores: game_type, value = score_info.split() value = int(value) if game_type == 'A': total_score += value elif game_type == 'B': total_score += value * 10 elif game_type == 'C': total_score += value * 5 average_score = total_score / G if average_score > highest_average or (average_score == highest_average and (best_player == -1 or idx < best_player)): highest_average = average_score best_player = idx results.append(best_player + 1) return results def parse_input(input_data): lines = input_data.strip().split(\\"n\\") idx = 0 T = int(lines[idx]) idx += 1 test_cases = [] for _ in range(T): P, G = map(int, lines[idx].split()) idx += 1 players_scores = [] for _ in range(P): scores = lines[idx].split(', ') players_scores.append(scores) idx += 1 test_cases.append((P, G, players_scores)) return test_cases"},{"question":"def is_harshad_number(N): Determine if a number N is a Harshad number. A Harshad number is an integer that is divisible by the sum of its digits. :param N: An integer number. :return: True if N is a Harshad number, otherwise False. def check_harshad_numbers(cases): Check multiple integers if they are Harshad numbers. :param cases: List of integers to be checked. :return: List of results, \\"Yes\\" if the integer is a Harshad number, otherwise \\"No\\". from solution import is_harshad_number, check_harshad_numbers def test_is_harshad_number_yes(): assert is_harshad_number(18) == True assert is_harshad_number(21) == True assert is_harshad_number(12) == True def test_is_harshad_number_no(): assert is_harshad_number(19) == False assert is_harshad_number(22) == False assert is_harshad_number(13) == False def test_check_harshad_numbers(): assert check_harshad_numbers([18, 19, 21]) == [\\"Yes\\", \\"No\\", \\"Yes\\"] assert check_harshad_numbers([100, 102, 103]) == [\\"Yes\\", \\"Yes\\", \\"No\\"] assert check_harshad_numbers([111, 222, 333]) == [\\"Yes\\", \\"Yes\\", \\"Yes\\"]","solution":"def is_harshad_number(N): Determine if a number N is a Harshad number. A Harshad number is an integer that is divisible by the sum of its digits. :param N: An integer number. :return: True if N is a Harshad number, otherwise False. digit_sum = sum(int(digit) for digit in str(N)) return N % digit_sum == 0 def check_harshad_numbers(cases): Check multiple integers if they are Harshad numbers. :param cases: List of integers to be checked. :return: List of results, \\"Yes\\" if the integer is a Harshad number, otherwise \\"No\\". results = [] for N in cases: if is_harshad_number(N): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def find_max_uniqueness_value(n: int, edges: List[Tuple[int, int, int]]) -> int: Determine the maximum uniqueness value of all possible universes (trees) formed by considering each node as the root. Args: n (int): The number of nodes in the Multiverse Tree. edges (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers u, v, and w representing an edge between node u and node v with weight w. Returns: int: The maximum uniqueness value. Example: >>> find_max_uniqueness_value(4, [(0, 1, 3), (1, 2, 2), (1, 3, 4)]) 9 >>> find_max_uniqueness_value(2, [(0, 1, 1)]) 1 pass def parse_input_string(input_string: str) -> Tuple[int, List[Tuple[int, int, int]]]: Parse the input string and return the number of nodes and the list of edges. Args: input_string (str): The input string containing the number of nodes and the edge information. Returns: Tuple[int, List[Tuple[int, int, int]]]: An integer representing the number of nodes and a list of tuples representing the edges. Example: >>> parse_input_string(\\"4n0 1 3n1 2 2n1 3 4n\\") (4, [(0, 1, 3), (1, 2, 2), (1, 3, 4)]) pass","solution":"from collections import defaultdict import sys sys.setrecursionlimit(200000) def find_max_uniqueness_value(n, edges): # Graph representation using adjacency list graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) subtree_sum = [0] * n total_sum = [0] * n visited = [False] * n # Calculate subtree sums and the total sum def dfs1(node): visited[node] = True curr_sum = 0 for neighbor, weight in graph[node]: if not visited[neighbor]: dfs1(neighbor) curr_sum += subtree_sum[neighbor] + weight subtree_sum[node] = curr_sum visited = [False] * n def dfs2(node): visited[node] = True curr_sum = subtree_sum[node] for neighbor, weight in graph[node]: if not visited[neighbor]: curr_sum += total_sum[neighbor] total_sum[node] = curr_sum dfs1(0) visited = [False] * n dfs2(0) return max(total_sum) def parse_input_string(input_string): input_lines = input_string.strip().split('n') n = int(input_lines[0]) edges = [] for line in input_lines[1:]: u, v, w = map(int, line.split()) edges.append((u, v, w)) return n, edges"},{"question":"def find_min_diff_partition(times): Given a list of project completion times, this function returns the minimum possible difference in total completion time between two groups. Uses a variant of the Partition Problem (subset-sum problem). Args: times (List[int]): List of completion times for projects. Returns: int: Minimum possible difference in total completion time between two groups. >>> find_min_diff_partition([3, 1, 4]) 0 >>> find_min_diff_partition([2, 3, 5, 10]) 0 >>> find_min_diff_partition([1, 2, 3, 9]) 3 >>> find_min_diff_partition([10, 20, 15, 5, 25]) 5 def partition_projects(T, test_cases): Partitions the projects into two groups with minimum possible difference in their total completion times for multiple test cases. Args: T (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): List of test cases where each test case is a tuple of number of projects and list of project completion times. Returns: List[int]: List of minimum differences for each test case. >>> partition_projects(2, [(3, [3, 1, 4]), (4, [2, 3, 5, 10])]) [0, 0] >>> partition_projects(2, [(4, [1, 2, 3, 9]), (5, [10, 20, 15, 5, 25])]) [3, 5]","solution":"def find_min_diff_partition(times): Given a list of project completion times, this function returns the minimum possible difference in total completion time between two groups. Uses a variant of the Partition Problem (subset-sum problem). total_sum = sum(times) n = len(times) dp = [[False]*(total_sum//2 + 1) for _ in range(n + 1)] # Initialize dp table for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, total_sum//2 + 1): if times[i - 1] <= j: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - times[i - 1]] else: dp[i][j] = dp[i - 1][j] # Find maximum j such that dp[n][j] is true for j in range(total_sum//2, -1, -1): if dp[n][j]: sum1 = j break sum2 = total_sum - sum1 return abs(sum2 - sum1) def partition_projects(T, test_cases): results = [] for t in range(T): N = test_cases[t][0] completion_times = test_cases[t][1] min_difference = find_min_diff_partition(completion_times) results.append(min_difference) return results"},{"question":"def count_islands(N: int, M: int, grid: List[List[int]]) -> int: Determine the number of islands in the grid. An island is formed by connecting adjacent lands horizontally or vertically. >>> count_islands(4, 5, [ ... [1, 1, 0, 0, 0], ... [0, 1, 0, 0, 1], ... [1, 0, 0, 1, 1], ... [0, 0, 0, 0, 0] ... ]) == 3 >>> count_islands(3, 3, [ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 1] ... ]) == 3 >>> count_islands(3, 3, [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0 >>> count_islands(2, 2, [ ... [1, 1], ... [1, 1] ... ]) == 1 >>> count_islands(4, 4, [ ... [1, 1, 0, 0], ... [0, 0, 0, 1], ... [1, 0, 1, 1], ... [0, 0, 0, 0] ... ]) == 3 import pytest from solution import count_islands def test_single_island(): grid = [ [1, 1, 0, 0, 0], [0, 1, 0, 0, 1], [1, 0, 0, 1, 1], [0, 0, 0, 0, 0] ] assert count_islands(4, 5, grid) == 3 def test_multiple_islands(): grid = [ [1, 0, 0], [0, 1, 0], [0, 0, 1] ] assert count_islands(3, 3, grid) == 3 def test_no_islands(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert count_islands(3, 3, grid) == 0 def test_all_land(): grid = [ [1, 1], [1, 1] ] assert count_islands(2, 2, grid) == 1 def test_complex_case(): grid = [ [1, 1, 0, 0], [0, 0, 0, 1], [1, 0, 1, 1], [0, 0, 0, 0] ] assert count_islands(4, 4, grid) == 3 pytest.main()","solution":"def count_islands(N, M, grid): def dfs(x, y): if x < 0 or x >= N or y < 0 or y >= M or grid[x][y] == 0: return grid[x][y] = 0 # Mark as visited dfs(x + 1, y) # Down dfs(x - 1, y) # Up dfs(x, y + 1) # Right dfs(x, y - 1) # Left island_count = 0 for i in range(N): for j in range(M): if grid[i][j] == 1: island_count += 1 dfs(i, j) return island_count"},{"question":"def max_rooms_occupied(bookings): Determine the maximum number of rooms occupied at any moment given a series of bookings. Args: bookings (List[Tuple[str, str]]): A list of tuples representing check-in and check-out dates. Returns: int: The maximum number of rooms occupied at any moment. >>> max_rooms_occupied([(\\"2023-01-01\\", \\"2023-01-05\\"), (\\"2023-01-04\\", \\"2023-01-10\\"), (\\"2023-01-02\\", \\"2023-01-06\\")]) 3 >>> max_rooms_occupied([(\\"2023-03-01\\", \\"2023-03-04\\"), (\\"2023-03-02\\", \\"2023-03-03\\")]) 2","solution":"def max_rooms_occupied(bookings): from datetime import datetime events = [] # Transform the check-in and check-out dates into events for check_in, check_out in bookings: check_in_date = datetime.strptime(check_in, \\"%Y-%m-%d\\") check_out_date = datetime.strptime(check_out, \\"%Y-%m-%d\\") events.append((check_in_date, 1)) # Room check-in events.append((check_out_date, -1)) # Room check-out # Sort events by date events.sort() max_rooms = 0 current_rooms = 0 # Traverse the events to find max room occupancy for _, event in events: current_rooms += event if current_rooms > max_rooms: max_rooms = current_rooms return max_rooms"},{"question":"def count_good_substrings(s: str) -> int: Count the number of \\"good\\" substrings for the given string \`s\`. A substring is \\"good\\" if it has no repeating characters or is a palindrome. >>> count_good_substrings(\\"abcd\\") 10 >>> count_good_substrings(\\"aaa\\") 6 pass def process_test_cases(test_cases: List[str]) -> List[int]: Process multiple test cases and return the results as a list. Each test case is a string, and the function should count the total number of \\"good\\" substrings for each test case. >>> process_test_cases([\\"abcd\\", \\"aaa\\"]) [10, 6] >>> process_test_cases([\\"abcd\\"]) 10 pass # Unit tests def test_count_good_substrings_case_1(): assert count_good_substrings(\\"abcd\\") == 10 def test_count_good_substrings_case_2(): assert count_good_substrings(\\"aaa\\") == 6 def test_count_good_substrings_single_character(): assert count_good_substrings(\\"a\\") == 1 def test_count_good_substrings_no_repeating(): assert count_good_substrings(\\"abcdefg\\") == 28 def test_count_good_substrings_all_same_character(): assert count_good_substrings(\\"aaaaa\\") == 15 def test_process_test_cases_multiple_cases(): test_cases = [\\"abcd\\", \\"aaa\\"] assert process_test_cases(test_cases) == [10, 6] def test_process_test_cases_single_case(): assert process_test_cases([\\"abcd\\"]) == [10] def test_process_test_cases_edge_case_empty_string(): assert process_test_cases([\\"\\"]) == [0]","solution":"def count_good_substrings(s): n = len(s) good_count = 0 def is_palindrome(sub): return sub == sub[::-1] for length in range(1, n+1): for start in range(0, n - length + 1): substr = s[start:start + length] if len(set(substr)) == len(substr) or is_palindrome(substr): good_count += 1 return good_count def process_test_cases(test_cases): results = [] for s in test_cases: results.append(count_good_substrings(s)) return results"},{"question":"def evaluate_prefix_expression(expression: str) -> int: Evaluates a single prefix expression. >>> evaluate_prefix_expression('+ 3 4') == 7 >>> evaluate_prefix_expression('- * 10 20 30') == 170 >>> evaluate_prefix_expression('/ 100 5') == 20 >>> evaluate_prefix_expression('+ 10 * 2 3') == 16 >>> evaluate_prefix_expression('- 20 10') == 10 def evaluate_prefix_expressions(expressions: List[str]) -> List[int]: Evaluates multiple prefix expressions. >>> evaluate_prefix_expressions(['+ 3 4', '- * 10 20 30', '/ 100 5']) == [7, 170, 20] >>> evaluate_prefix_expressions(['+ 10 * 2 3', '- 20 10']) == [16, 10] def process_input(input_string: str) -> List[int]: Process the input string to evaluate multiple prefix expressions. >>> process_input(\\"3n+ 3 4n- * 10 20 30n/ 100 5\\") == [7, 170, 20] >>> process_input(\\"2n+ 10 * 2 3n- 20 10\\") == [16, 10]","solution":"def evaluate_prefix_expression(expression): Evaluates a single prefix expression. stack = [] operators = {'+', '-', '*', '/'} # Split the expression by space and reverse it to process it right to left tokens = expression.split()[::-1] for token in tokens: if token not in operators: # Push number onto the stack stack.append(int(token)) else: # Pop two operands from stack and apply operator operand1 = stack.pop() operand2 = stack.pop() if token == '+': result = operand1 + operand2 elif token == '-': result = operand1 - operand2 elif token == '*': result = operand1 * operand2 elif token == '/': result = operand1 // operand2 # Use integer division # Push the result back onto the stack stack.append(result) return stack.pop() def evaluate_prefix_expressions(expressions): Evaluates multiple prefix expressions. results = [] for expression in expressions: result = evaluate_prefix_expression(expression) results.append(result) return results def process_input(input_string): input_lines = input_string.strip().split('n') T = int(input_lines[0]) expressions = input_lines[1:T + 1] return evaluate_prefix_expressions(expressions)"},{"question":"def find_majority_element(arr: list) -> int: Finds the majority element, which is the element that appears more than floor(n/2) times. If no such element exists, returns -1. >>> find_majority_element([1, 2, 3, 1, 1, 1, 2]) 1 >>> find_majority_element([1, 2, 3, 4, 5, 6]) -1 >>> find_majority_element([1]) 1 >>> find_majority_element([2, 2, 2, 2, 2, 2, 2]) 2 >>> find_majority_element([1, 1, 1, 2, 2, 2, 2]) 2 >>> find_majority_element([3]*50001 + [4]*49999) 3","solution":"def find_majority_element(arr): Finds the majority element, which is the element that appears more than floor(n/2) times. If no such element exists, returns -1. Parameters: arr (list): A list of integers Returns: int: The majority element or -1 if no such element exists count = {} n = len(arr) # Count the occurrences of each element for num in arr: count[num] = count.get(num, 0) + 1 # Check for the majority element for num in count: if count[num] > n // 2: return num return -1"},{"question":"def min_abs_difference_of_sums(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Alex has been given a list of N integers. His task is to arrange these integers into two non-empty sublists, where the absolute difference of their sums is minimized. Help Alex find the minimum possible absolute difference of the sums of the two sublists. Arguments: test_cases: A list of tuples, where each tuple contains an integer and a list of integers. Returns: A list of integers representing the minimum possible absolute difference for each test case. >>> min_abs_difference_of_sums([(4, [1, 6, 11, 5]), (3, [7, 2, 4])]) [1, 1] >>> min_abs_difference_of_sums([(2, [2, 3])]) [1] # Test cases for min_abs_difference_of_sums function def test_min_abs_difference_of_sums(): test_cases = [ (4, [1, 6, 11, 5]), (3, [7, 2, 4]) ] expected_results = [1, 1] results = min_abs_difference_of_sums(test_cases) assert results == expected_results def test_single_split_case(): test_cases = [ (2, [2, 3]), ] expected_results = [1] results = min_abs_difference_of_sums(test_cases) assert results == expected_results def test_another_case(): test_cases = [ (5, [3, 1, 4, 9, 2]), ] expected_results = [1] results = min_abs_difference_of_sums(test_cases) assert results == expected_results def test_some_identical_elements(): test_cases = [ (4, [5, 5, 5, 5]), ] expected_results = [0] results = min_abs_difference_of_sums(test_cases) assert results == expected_results def test_large_numbers(): test_cases = [ (4, [100, 50, 100, 50]), ] expected_results = [0] results = min_abs_difference_of_sums(test_cases) assert results == expected_results def test_multiple_cases(): test_cases = [ (3, [1, 2, 3]), (3, [1, 1, 1]), (4, [10, 10, 10, 10]), (4, [5, 15, 10, 20]), ] expected_results = [0, 1, 0, 0] results = min_abs_difference_of_sums(test_cases) assert results == expected_results","solution":"def min_abs_difference_of_sums(test_cases): def find_min_abs_diff(arr): total_sum = sum(arr) n = len(arr) dp = [[False] * (total_sum // 2 + 1) for _ in range(n + 1)] dp[0][0] = True for i in range(1, n + 1): for j in range(total_sum // 2 + 1): if j >= arr[i - 1]: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]] else: dp[i][j] = dp[i - 1][j] for j in range(total_sum // 2, -1, -1): if dp[n][j]: return total_sum - 2 * j results = [] for case in test_cases: N, integers = case results.append(find_min_abs_diff(integers)) return results"},{"question":"def num_decodings(message: str) -> int: Compute the number of different ways a numeric message can be decoded. >>> num_decodings(\\"123\\") 3 >>> num_decodings(\\"27\\") 1 >>> num_decodings(\\"001\\") 0 >>> num_decodings(\\"2101\\") 1 >>> num_decodings(\\"8\\") 1 >>> num_decodings(\\"10\\") 1 >>> num_decodings(\\"20\\") 1 >>> num_decodings(\\"30\\") 0 >>> num_decodings(\\"012\\") 0 >>> num_decodings(\\"\\") 0 >>> num_decodings(\\"123123123123\\") 81 >>> num_decodings(\\"11111\\") 8","solution":"def num_decodings(message): # Early exit for invalid starting messages if not message or message[0] == '0': return 0 n = len(message) dp = [0] * (n+1) dp[0], dp[1] = 1, 1 for i in range(2, n + 1): single_digit = int(message[i-1:i]) double_digit = int(message[i-2:i]) if 1 <= single_digit <= 9: dp[i] += dp[i-1] if 10 <= double_digit <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"def largest_unique_number(nums: List[int]) -> int: Given an integer array nums, return the largest integer that only occurs once. If no integer occurs exactly once, return -1. >>> largest_unique_number([4, 9, 2, 9, 7]) 7 >>> largest_unique_number([1, 1, 2, 2]) -1 >>> largest_unique_number([1]) 1 >>> largest_unique_number([-1, -2, -2, -3, -1]) -3 >>> largest_unique_number([-10, 0, 5, 5, 8, 8, 10, -10, 55, 4, 4]) 55 >>> largest_unique_number([7, 7, 7, 7]) -1","solution":"def largest_unique_number(nums): Returns the largest integer in the array that occurs exactly once. If no such integer exists, returns -1. from collections import Counter counts = Counter(nums) # Filter numbers that occur exactly once and find the maximum unique_numbers = [num for num in counts if counts[num] == 1] return max(unique_numbers) if unique_numbers else -1"},{"question":"from typing import List, Tuple def can_form_palindrome(s: str) -> bool: Helper function to check if a given string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False def can_all_strings_form_palindrome(test_cases: List[Tuple[int, List[str]]]) -> List[str]: Determines if all strings in each test case can be rearranged to form palindromes. Args: test_cases: List of test cases, where each test case is a tuple containing an integer and a list of strings. Returns: A list of strings (\\"YES\\" or \\"NO\\") for each test case. >>> can_all_strings_form_palindrome([(3, ['civic', 'ivicc', 'hello']), (2, ['racecar', 'level'])]) [\\"NO\\", \\"YES\\"] def parse_input(input_string: str) -> List[Tuple[int, List[str]]]: Parses the input string into the required format for processing. Args: input_string: Input string containing test cases. Returns: A list of tuples containing the number of strings and the list of strings. >>> parse_input(\\"2n3ncivicniviccnhellon2nracecarnlevel\\") [(3, ['civic', 'ivicc', 'hello']), (2, ['racecar', 'level'])]","solution":"def can_form_palindrome(s): Helper function to check if a given string can be rearranged to form a palindrome. from collections import Counter # Count occurrences of each character count = Counter(s) # A string can form a palindrome if at most one character has an odd count odd_count = sum(1 for v in count.values() if v % 2 != 0) return odd_count <= 1 def can_all_strings_form_palindrome(test_cases): Determines if all strings in each test case can be rearranged to form palindromes. Args: test_cases: List of test cases, where each test case is a tuple containing an integer and a list of strings. Returns: A list of strings (\\"YES\\" or \\"NO\\") for each test case. results = [] for (n, strings) in test_cases: if all(can_form_palindrome(s) for s in strings): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Example usage: # test_cases = [(3, ['civic', 'ivicc', 'hello']), (2, ['racecar', 'level'])] # print(can_all_strings_form_palindrome(test_cases)) # Output: ['NO', 'YES'] def parse_input(input_string): input_lines = input_string.strip().split(\\"n\\") t = int(input_lines[0]) test_cases = [] idx = 1 for _ in range(t): n = int(input_lines[idx]) strings = input_lines[idx + 1: idx + 1 + n] test_cases.append((n, strings)) idx += 1 + n return test_cases"},{"question":"def find_min_roads_to_connect(n: int, m: int, roads: List[Tuple[int, int]]) -> int: Return the minimum number of additional roads needed to make the city's road network fully connected. Args: n : int : number of intersections m : int : number of roads roads : List[Tuple[int, int]] : list of tuples where each tuple represents a bidirectional road between two intersections Returns: int : minimum number of additional roads needed >>> find_min_roads_to_connect(6, 5, [(1, 2), (1, 3), (2, 4), (3, 5), (5, 6)]) 0 >>> find_min_roads_to_connect(4, 1, [(1, 2)]) 2 from typing import List, Tuple # Test cases def test_case_1(): assert find_min_roads_to_connect(6, 5, [(1, 2), (1, 3), (2, 4), (3, 5), (5, 6)]) == 0 def test_case_2(): assert find_min_roads_to_connect(4, 1, [(1, 2)]) == 2 def test_case_3(): assert find_min_roads_to_connect(1, 0, []) == 0 def test_case_4(): assert find_min_roads_to_connect(4, 2, [(1, 2), (3, 4)]) == 1 def test_case_5(): assert find_min_roads_to_connect(5, 0, []) == 4 def test_case_6(): assert find_min_roads_to_connect(5, 2, [(1, 2), (3, 4)]) == 2 def test_case_7(): assert find_min_roads_to_connect(7, 5, [(1, 2), (2, 3), (4, 5), (5, 6), (6, 7)]) == 1","solution":"def find_min_roads_to_connect(n, m, roads): from collections import defaultdict, deque def bfs(start, visited): queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) if n == 1: return 0 graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) components = 0 for i in range(1, n + 1): if not visited[i]: bfs(i, visited) components += 1 return components - 1"},{"question":"def watch_together(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, List[int]]], int]]) -> List[int]: Determine the number of pairs of users who have watched at least k common movies. >>> watch_together(1, [(4, 5, [(1, [1, 2, 3]), (2, [1, 2]), (3, [2, 3]), (4, [4, 5])], 2)]) == [2] >>> watch_together(1, [(3, 4, [(1, [1, 2]), (2, [2, 3]), (3, [3, 4])], 1)]) == [2] >>> watch_together(1, [(3, 4, [(1, [1, 2]), (2, [2, 3]), (3, [3, 4])], 2)]) == [0] >>> watch_together(2, [(4, 5, [(1, [1, 2, 3]), (2, [1, 2]), (3, [2, 3]), (4, [4, 5])], 2), (3, 4, [(1, [1, 2]), (2, [2, 3]), (3, [3, 4])], 1)]) == [2, 2] >>> watch_together(1, [(2, 2, [(1, [1]), (2, [2])], 1)]) == [0]","solution":"def watch_together(T, test_cases): result = [] for i in range(T): U, M, user_data, k = test_cases[i] # Convert user data to a dictionary with a set of watched movies for each user user_watched = {} for user_id, movies in user_data: user_watched[user_id] = set(movies) # Compare each pair of users count_pairs = 0 user_ids = list(user_watched.keys()) for j in range(U): for l in range(j + 1, U): common_movies = user_watched[user_ids[j]].intersection(user_watched[user_ids[l]]) if len(common_movies) >= k: count_pairs += 1 result.append(count_pairs) return result"},{"question":"def findBallStop(heights): Given the heights of buildings, return the index where the ball stops. The ball stops when it hits a building equal or taller than the starting building. >>> findBallStop([5, 3, 6, 7, 4, 2]) == 2 True >>> findBallStop([4, 1, 2, 3]) == -1 True","solution":"def findBallStop(heights): Given the heights of buildings, return the index where the ball stops. The ball stops when it hits a building equal or taller than the starting building. start_height = heights[0] for index in range(1, len(heights)): if heights[index] >= start_height: return index return -1"},{"question":"def max_cities(N: int, travel_times: List[int], T: int) -> int: Returns the maximum number of cities Emily can visit without exceeding the travel time limit. Arguments: N: int - The total number of cities. travel_times: list of int - The travel times between consecutive cities. T: int - The maximum travel time allowed. Returns: int - The maximum number of cities Emily can visit. >>> max_cities(5, [3, 5, 2, 8], 10) 4 >>> max_cities(4, [9, 10, 8], 15) 2 >>> max_cities(3, [4, 6], 10) 3 >>> max_cities(3, [2, 3], 1) 1 >>> max_cities(1000, [1]*999, 500) 501 >>> max_cities(2, [1], 0) 1","solution":"def max_cities(N, travel_times, T): Returns the maximum number of cities Emily can visit without exceeding the travel time limit. Arguments: N: int - The total number of cities. travel_times: list of int - The travel times between consecutive cities. T: int - The maximum travel time allowed. Returns: int - The maximum number of cities Emily can visit. total_time = 0 count = 1 # including the starting city for time in travel_times: if total_time + time <= T: total_time += time count += 1 else: break return count"},{"question":"def min_switches(sequence: str) -> int: Calculate the minimum number of switches needed between picking (P) and placing (L) actions. >>> min_switches(\\"PPPLLPPPLL\\") 3 >>> min_switches(\\"PPLPLLPPLP\\") 6 >>> min_switches(\\"PLPLPLPL\\") 7 >>> min_switches(\\"PPPP\\") 0 >>> min_switches(\\"LLLL\\") 0 >>> min_switches(\\"\\") 0","solution":"def min_switches(sequence): if not sequence: return 0 # Initialize counters switches = 0 current_action = sequence[0] for action in sequence[1:]: if action != current_action: switches += 1 current_action = action return switches"},{"question":"def validate_phone_number(phone_number: str) -> str: Validates that a phone number contains exactly 10 digits and no sequence of consecutive repeating digits longer than two digits. >>> validate_phone_number(\\"1234567890\\") \\"VALID\\" >>> validate_phone_number(\\"1122334455\\") \\"VALID\\" >>> validate_phone_number(\\"1233333456\\") \\"INVALID\\" >>> validate_phone_number(\\"1233211234\\") \\"VALID\\" >>> validate_phone_number(\\"9988776655\\") \\"VALID\\" pass def process_phone_numbers(test_cases: List[str]) -> List[str]: Processes a list of phone numbers to determine if each is valid or invalid. Arguments: test_cases -- a list of phone number strings Returns: results -- a list of strings \\"VALID\\" or \\"INVALID\\" >>> process_phone_numbers([\\"1234567890\\", \\"1122334455\\", \\"1233333456\\", \\"1233211234\\", \\"9988776655\\"]) [\\"VALID\\", \\"VALID\\", \\"INVALID\\", \\"VALID\\", \\"VALID\\"] pass","solution":"def validate_phone_number(phone_number): Validates that a phone number contains exactly 10 digits and no sequence of consecutive repeating digits longer than two digits. if len(phone_number) != 10: return \\"INVALID\\" for i in range(8): if phone_number[i] == phone_number[i + 1] == phone_number[i + 2]: return \\"INVALID\\" return \\"VALID\\" def process_phone_numbers(test_cases): Processes a list of phone numbers to determine if each is valid or invalid. Arguments: test_cases -- a list of phone number strings Returns: results -- a list of strings \\"VALID\\" or \\"INVALID\\" results = [] for number in test_cases: results.append(validate_phone_number(number)) return results"},{"question":"def number_of_distinct_characters(S, queries): Returns the number of distinct characters between index L and R for each query. :param S: The input string. :param queries: A list of tuples (L, R) representing the queries. :return: A list of integers with the results for each query. pass # Unit Tests def test_example_1(): S = \\"abacc\\" queries = [(1, 3), (2, 4), (1, 5)] assert number_of_distinct_characters(S, queries) == [2, 3, 3] def test_example_2(): S = \\"aaaaaa\\" queries = [(1, 6), (1, 3)] assert number_of_distinct_characters(S, queries) == [1, 1] def test_single_character(): S = \\"a\\" queries = [(1, 1)] assert number_of_distinct_characters(S, queries) == [1] def test_full_range(): S = \\"abcde\\" queries = [(1, 5)] assert number_of_distinct_characters(S, queries) == [5] def test_mixed_characters(): S = \\"abbccc\\" queries = [(1, 2), (2, 4), (1, 6)] assert number_of_distinct_characters(S, queries) == [2, 2, 3] def test_repeated_characters(): S = \\"bbbbbbb\\" queries = [(1, 1), (1, 7)] assert number_of_distinct_characters(S, queries) == [1, 1] def test_prefix_queries(): S = \\"abcdefgh\\" queries = [(1, 2), (1, 3), (1, 4)] assert number_of_distinct_characters(S, queries) == [2, 3, 4]","solution":"def number_of_distinct_characters(S, queries): Returns the number of distinct characters between index L and R for each query. :param S: The input string. :param queries: A list of tuples (L, R) representing the queries. :return: A list of integers with the results for each query. results = [] for L, R in queries: substr = S[L-1:R] distinct_characters = len(set(substr)) results.append(distinct_characters) return results"},{"question":"def totalRainwater(N: int, heights: List[int]) -> int: Calculate the total units of rainwater that can be trapped after a rain. Args: N (int): The size of the array. heights (List[int]): The array of integers representing building heights. Returns: int: The total units of rainwater that can be trapped. Examples: >>> totalRainwater(12, [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> totalRainwater(3, [2, 0, 2]) 2","solution":"def totalRainwater(N, heights): if not heights: return 0 left_max = [0] * N right_max = [0] * N water_trapped = 0 # Fill left max array left_max[0] = heights[0] for i in range(1, N): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right max array right_max[N - 1] = heights[N - 1] for i in range(N - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the total water trapped for i in range(N): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def canCompleteRoute(n: int, flights: List[Tuple[str, str]], startCity: str) -> str: Determines if it is possible to start at a specific city and visit every other city in the list exactly once, returning to the starting city at the end. Parameters: n (int): the number of flight routes flights (List[Tuple[str, str]]): array of pairs representing the source and destination cities startCity (str): the city to start and end the route Returns: str: \\"Yes\\" if it is possible to form such a route, otherwise \\"No\\". Example: >>> canCompleteRoute(4, [(\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"C\\", \\"D\\"), (\\"D\\", \\"A\\")], \\"A\\") \\"Yes\\" >>> canCompleteRoute(3, [(\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"C\\", \\"A\\")], \\"A\\") \\"Yes\\" >>> canCompleteRoute(3, [(\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"C\\", \\"D\\")], \\"A\\") \\"No\\"","solution":"def canCompleteRoute(n, flights, startCity): from collections import defaultdict, deque # Create adjacency list graph = defaultdict(list) for src, dest in flights: graph[src].append(dest) # Track all cities all_cities = set() for src, dest in flights: all_cities.add(src) all_cities.add(dest) # Function to perform DFS and check Hamiltonian cycle def dfs(city, visited): if len(visited) == len(all_cities): return visited[0] in graph[visited[-1]] for neighbor in graph[city]: if neighbor not in visited: visited.append(neighbor) if dfs(neighbor, visited): return True visited.pop() return False return \\"Yes\\" if dfs(startCity, [startCity]) else \\"No\\""},{"question":"def balance_parentheses(T: int, parentheses_list: List[str]) -> List[str]: Balances each string of parentheses in the provided list by adding the minimum number of parentheses to make them balanced. Parameters: T (int): number of test cases parentheses_list (list of T strings): list of T strings, each containing a sequence of '(' and ')' characters Returns: list of str: list of T balanced strings >>> balance_parentheses(3, [\\")\\", \\"((\\", \\"())\\"]) [\\"()\\", \\"(())\\", \\"(())\\"]","solution":"def balance_parentheses(T, parentheses_list): Balances each string of parentheses in the provided list by adding the minimum number of parentheses to make them balanced. Parameters: T (int): number of test cases parentheses_list (list of str): list of T strings, each containing a sequence of '(' and ')' characters Returns: list of str: list of T balanced strings results = [] for s in parentheses_list: left_needed = 0 # Number of '(' needed to balance ')' right_needed = 0 # Number of ')' needed to balance '(' for ch in s: if ch == '(': right_needed += 1 elif ch == ')': if right_needed > 0: right_needed -= 1 else: left_needed += 1 balanced_string = '(' * left_needed + s + ')' * right_needed results.append(balanced_string) return results"},{"question":"def sausage_cuts(n: int, L: int) -> list: Returns the positions along the length of the sausage where the cuts should be made such that the sausage is divided into n pieces of equal volume. Args: n (int): The number of pieces. L (int): The total length of the sausage. Returns: list of floats: The positions for the cuts. >>> sausage_cuts(3, 10) [3.3333333333333335, 6.666666666666667] >>> sausage_cuts(2, 5000) [2500.0] import pytest def test_sausage_cuts_basic(): cuts = sausage_cuts(3, 10) assert len(cuts) == 2 assert abs(cuts[0] - 3.3333333333333335) <= 1e-6 assert abs(cuts[1] - 6.666666666666667) <= 1e-6 def test_sausage_cuts_two_pieces(): cuts = sausage_cuts(2, 5000) assert len(cuts) == 1 assert abs(cuts[0] - 2500) <= 1e-6 def test_sausage_cuts_large_length(): cuts = sausage_cuts(4, 100000) assert len(cuts) == 3 assert abs(cuts[0] - 25000) <= 1e-6 assert abs(cuts[1] - 50000) <= 1e-6 assert abs(cuts[2] - 75000) <= 1e-6 def test_sausage_cuts_edge_case_min_n(): cuts = sausage_cuts(2, 2) assert len(cuts) == 1 assert abs(cuts[0] - 1) <= 1e-6 def test_sausage_cuts_edge_case_large_n(): cuts = sausage_cuts(1000, 100000) assert len(cuts) == 999 for i in range(1, 1000): expected_cut = i * (100000 / 1000) assert abs(cuts[i-1] - expected_cut) <= 1e-6","solution":"def sausage_cuts(n, L): Returns the positions along the length of the sausage where the cuts should be made such that the sausage is divided into n pieces of equal volume. Args: n (int): The number of pieces. L (int): The total length of the sausage. Returns: list of floats: The positions for the cuts. cuts = [] for i in range(1, n): cuts.append(i * (L / n)) return cuts"},{"question":"def can_become_palindrome(s: str) -> bool: Determines if the string can become a palindrome by removing at most one character. >>> can_become_palindrome(\\"abca\\") == True # YES >>> can_become_palindrome(\\"abcdef\\") == False # NO >>> can_become_palindrome(\\"racecar\\") == True # YES >>> can_become_palindrome(\\"a\\") == True # YES >>> can_become_palindrome(\\"ab\\") == True # YES >>> can_become_palindrome(\\"abccba\\") == True # YES >>> can_become_palindrome(\\"abcbxa\\") == True # YES >>> can_become_palindrome(\\"abcde\\") == False # NO","solution":"def is_palindrome(s): Helper function to check if a string is a palindrome. return s == s[::-1] def can_become_palindrome(s): Determines if the string can become a palindrome by removing at most one character. left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Two characters mismatch, try removing one character s1 = s[left:right] # remove character at \`right\` s2 = s[left+1:right+1] # remove character at \`left\` return is_palindrome(s1) or is_palindrome(s2) left += 1 right -= 1 return True # Sample usage # print(can_become_palindrome(\\"abca\\")) # Should return 'YES'"},{"question":"def max_unique_purchases(gift_cards): Returns the maximum number of unique purchases that can be made using the gift cards. # Your code here def process_input(input_data): Processes the input data and returns the results for each test case. # Your code here import pytest def test_max_unique_purchases(): assert max_unique_purchases([2, 3, 3, 4]) == 3 assert max_unique_purchases([5, 5, 5]) == 1 assert max_unique_purchases([1, 2, 2, 4, 4, 4]) == 3 def test_process_input(): input_data = \\"4n2 3 3 4n3n5 5 5n6n1 2 2 4 4 4n0n\\" expected_output = [3, 1, 3] assert process_input(input_data) == expected_output input_data = \\"4n1 2 3 4n3n4 4 5n2n9 10n0n\\" expected_output = [4, 2, 2] assert process_input(input_data) == expected_output input_data = \\"5n1 1 1 1 1n1n1n1n100n0n\\" expected_output = [1, 1, 1] assert process_input(input_data) == expected_output if __name__ == \\"__main__\\": pytest.main()","solution":"def max_unique_purchases(gift_cards): Returns the maximum number of unique purchases that can be made using the gift cards. return len(set(gift_cards)) def process_input(input_data): Processes the input data and returns the results for each test case. results = [] lines = input_data.strip().split('n') i = 0 while i < len(lines): n = int(lines[i]) if n == 0: break gift_cards = list(map(int, lines[i + 1].split())) results.append(max_unique_purchases(gift_cards)) i += 2 return results"},{"question":"def sieve_of_eratosthenes(n): Returns a list of first n prime numbers using the Sieve of Eratosthenes algorithm. limit = 20000 # Arbitrary large limit to ensure we get at least 1000 primes sieve = [True] * limit sieve[0] = sieve[1] = False primes = [] for num in range(2, limit): if sieve[num]: primes.append(num) if len(primes) == n: break for multiple in range(num * num, limit, num): sieve[multiple] = False return primes def prime_address(indexes): Returns a list of prime numbers corresponding to the given list of prime indexes. >>> prime_address([1, 2, 10]) [2, 3, 29] >>> prime_address([5]) [11]","solution":"def sieve_of_eratosthenes(n): Returns a list of first n prime numbers using the Sieve of Eratosthenes algorithm. limit = 20000 # Arbitrary large limit to ensure we get at least 1000 primes sieve = [True] * limit sieve[0] = sieve[1] = False primes = [] for num in range(2, limit): if sieve[num]: primes.append(num) if len(primes) == n: break for multiple in range(num * num, limit, num): sieve[multiple] = False return primes def prime_address(indexes): Returns a list of prime numbers corresponding to the given list of prime indexes. max_index = max(indexes) primes = sieve_of_eratosthenes(max_index) return [primes[i - 1] for i in indexes]"},{"question":"def num_distinct_islands(matrix: List[List[int]]) -> int: Returns the number of distinct islands in a 2D matrix. >>> num_distinct_islands([[1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1]]) == 3 >>> num_distinct_islands([[1, 1, 0], [0, 1, 0], [1, 0, 1]]) == 3","solution":"def num_distinct_islands(matrix): Returns the number of distinct islands in a 2D matrix. if not matrix or not matrix[0]: return 0 n = len(matrix) m = len(matrix[0]) visited = [[False] * m for _ in range(n)] def dfs(x, y): stack = [(x, y)] visited[x][y] = True while stack: cx, cy = stack.pop() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = cx + dx, cy + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and matrix[nx][ny] == 1: visited[nx][ny] = True stack.append((nx, ny)) island_count = 0 for i in range(n): for j in range(m): if matrix[i][j] == 1 and not visited[i][j]: dfs(i, j) island_count += 1 return island_count"},{"question":"def reverse_pairs(nums): Returns the number of reverse pairs in the array. A reverse pair is defined as (i, j) where 0  i < j < len(nums) and nums[i] > 2 * nums[j]. >>> reverse_pairs([1, 3, 2, 3, 1]) 2 >>> reverse_pairs([4, 1, 2, 3]) 1 >>> reverse_pairs([1]) 0 >>> reverse_pairs([1, 2, 4, 8]) 0 >>> reverse_pairs([1, 1, 1, 1]) 0 >>> reverse_pairs([8, 3, 1, -2, -4]) 10 >>> reverse_pairs([4, -1, -2, 1, 3]) 4","solution":"def reverse_pairs(nums): Returns the number of reverse pairs in the array. A reverse pair is defined as (i, j) where 0  i < j < len(nums) and nums[i] > 2 * nums[j]. count = 0 n = len(nums) for i in range(n): for j in range(i + 1, n): if nums[i] > 2 * nums[j]: count += 1 return count"},{"question":"import math import heapq from typing import List, Tuple def shortest_path(warehouses: int, roads: List[Tuple[int, int, int, int, int]], source: Tuple[int, int], destination: Tuple[int, int], quantity: int) -> float: Determine the shortest path to deliver goods from the source warehouse to the destination warehouse. Args: warehouses (int): The number of warehouses. roads (List[Tuple[int, int, int, int, int]]): A list of tuples representing roads, where each tuple contains four integers x1, y1, x2, y2 for warehouse coordinates and an integer for capacity. source (Tuple[int, int]): A tuple representing the coordinates of the source warehouse. destination (Tuple[int, int]): A tuple representing the coordinates of the destination warehouse. quantity (int): The amount of goods to be delivered. Returns: float: The length of the shortest path to deliver the goods, or -1 if it is impossible. >>> shortest_path(3, [(0, 0, 10, 0, 100), (10, 0, 10, 10, 50), (10, 10, 0, 10, 50)], (0, 0), (10, 10), 50) == 20.0000000000 >>> shortest_path(3, [(0, 0, 5, 0, 50), (5, 0, 5, 5, 30), (5, 5, 10, 5, 20), (0, 0, 0, 5, 100)], (0, 0), (10, 5), 60) == -1","solution":"import heapq import math def shortest_path(warehouses, roads, source, destination, quantity): graph = {} for (x1, y1, x2, y2, capacity) in roads: if capacity < quantity: continue if (x1, y1) not in graph: graph[(x1, y1)] = [] if (x2, y2) not in graph: graph[(x2, y2)] = [] distance = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) graph[(x1, y1)].append(((x2, y2), distance)) graph[(x2, y2)].append(((x1, y1), distance)) min_heap = [(0, source)] distances = {node: float('inf') for node in graph} distances[source] = 0 while min_heap: current_distance, current_node = heapq.heappop(min_heap) if current_node == destination: return round(current_distance, 10) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) return -1 def parse_input(input_data): lines = input_data.strip().split('n') index = 0 results = [] while index < len(lines): M, N = map(int, lines[index].strip().split()) if M == 0 and N == 0: break index += 1 roads = [] for _ in range(N): x1, y1, x2, y2, capacity = map(int, lines[index].strip().split()) roads.append((x1, y1, x2, y2, capacity)) index += 1 sx, sy, dx, dy, quantity = map(int, lines[index].strip().split()) source = (sx, sy) destination = (dx, dy) result = shortest_path(M, roads, source, destination, quantity) results.append(f\\"{result:.10f}\\") index += 1 return results def main(): import sys input_data = sys.stdin.read() results = parse_input(input_data) for result in results: print(result)"},{"question":"def calculate_total_sales(records): Calculate total copies sold for each book across all months. Args: records (list of tuple): List of sales records tuples (book_id, month_of_sale, copies_sold) Returns: dict: A dictionary where keys are book_id and values are total copies sold. # Function to format the output for display def format_sales_output(sales_dict): Format the sales dictionary into a sorted list of tuples for display. Args: sales_dict (dict): A dictionary with book_id as keys and total copies sold as values. Returns: list: Sorted list of tuples (book_id, total_copies_sold) from solution import calculate_total_sales, format_sales_output def test_calculate_total_sales(): records = [ (101, 1, 5), (102, 3, 10), (101, 2, 7), (102, 3, 3), (103, 5, 1) ] expected_output = { 101: 12, 102: 13, 103: 1 } assert calculate_total_sales(records) == expected_output def test_calculate_total_sales_empty(): records = [] expected_output = {} assert calculate_total_sales(records) == expected_output def test_format_sales_output(): sales_dict = { 101: 12, 102: 13, 103: 1 } expected_output = [ (101, 12), (102, 13), (103, 1) ] assert format_sales_output(sales_dict) == expected_output def test_integration(): records = [ (101, 1, 5), (102, 3, 10), (101, 2, 7), (102, 3, 3), (103, 5, 1) ] expected_output = [ (101, 12), (102, 13), (103, 1) ] sales_dict = calculate_total_sales(records) assert format_sales_output(sales_dict) == expected_output","solution":"def calculate_total_sales(records): Calculate total copies sold for each book across all months. Args: records (list of tuple): List of sales records tuples (book_id, month_of_sale, copies_sold) Returns: dict: A dictionary where keys are book_id and values are total copies sold. sales = {} for record in records: book_id, month_of_sale, copies_sold = record if book_id in sales: sales[book_id] += copies_sold else: sales[book_id] = copies_sold return sales # Function to format the output for display def format_sales_output(sales_dict): Format the sales dictionary into a sorted list of tuples for display. Args: sales_dict (dict): A dictionary with book_id as keys and total copies sold as values. Returns: list: Sorted list of tuples (book_id, total_copies_sold) sorted_sales = sorted(sales_dict.items()) return sorted_sales"},{"question":"def good_fruits_remaining(T: int, test_cases: List[int]) -> List[int]: This function determines the number of good fruits remaining after accounting for spoiled fruits. If the count of fruits is greater than 50, exactly 5 fruits will be spoiled. Args: T (int): The number of test cases. test_cases (List[int]): A list containing the total number of fruits for each test case. Returns: List[int]: A list containing the number of good fruits remaining for each test case. >>> good_fruits_remaining(4, [10, 60, 51, 50]) [10, 55, 46, 50] >>> good_fruits_remaining(3, [100, 49, 55]) [95, 49, 50]","solution":"def good_fruits_remaining(T, test_cases): This function takes the number of test cases and a list of test cases. Each test case contains an integer representing the total number of fruits the user has. It returns a list of integers representing the number of good fruits remaining after accounting for the spoiled fruits. results = [] for N in test_cases: if N <= 50: results.append(N) else: results.append(N - 5) return results"},{"question":"def longest_increasing_path(matrix: List[List[int]]) -> int: Given a matrix of size M x N, find the length of the longest increasing path in the matrix. From each cell, you can move in four possible directions - left, right, up, and down. You can only move to a cell if its value is greater than the current cell's value. >>> longest_increasing_path([[9, 9, 4], [6, 6, 8], [2, 1, 1]]) == 4 >>> longest_increasing_path([[3, 4, 5, 6], [3, 2, 1, 7], [8, 8, 8, 9], [7, 6, 5, 4]]) == 7 >>> longest_increasing_path([[1]]) == 1 >>> longest_increasing_path([[1, 2], [4, 3]]) == 4 >>> longest_increasing_path([[9, 1, 4], [6, 7, 5], [2, 1, 0]]) == 5","solution":"def longest_increasing_path(matrix): if not matrix or not matrix[0]: return 0 def dfs(x, y): if not dp[x][y]: val = matrix[x][y] dp[x][y] = 1 + max( dfs(x - 1, y) if x and val < matrix[x - 1][y] else 0, dfs(x + 1, y) if x < len(matrix) - 1 and val < matrix[x + 1][y] else 0, dfs(x, y - 1) if y and val < matrix[x][y - 1] else 0, dfs(x, y + 1) if y < len(matrix[0]) - 1 and val < matrix[x][y + 1] else 0 ) return dp[x][y] M = len(matrix) N = len(matrix[0]) dp = [[0] * N for _ in range(M)] return max(dfs(x, y) for x in range(M) for y in range(N)) def process_test_cases(test_cases): results = [] for case in test_cases: M, N, matrix = case results.append(longest_increasing_path(matrix)) return results # parsing input and processing it def parse_input(): import sys input = sys.stdin.read data = input().split() idx = 0 T = int(data[idx]) idx += 1 test_cases = [] for _ in range(T): M = int(data[idx]) N = int(data[idx + 1]) idx += 2 matrix = [] for i in range(M): row = list(map(int, data[idx: idx + N])) idx += N matrix.append(row) test_cases.append((M, N, matrix)) results = process_test_cases(test_cases) for result in results: print(result)"},{"question":"def manage_files(n: int, m: int, storage_limits: List[int], operations: List[str]) -> List[int]: Simulate file upload and transfer operations between users. Args: n (int): Number of users. m (int): Number of operations. storage_limits (List[int]): Storage limits for each user. operations (List[str]): List of operations to be performed. Returns: List[int]: List containing the total size of files stored by each user after all operations. Example: >>> n = 3 >>> m = 5 >>> storage_limits = [10, 20, 15] >>> operations = [ \\"UPLOAD 1 5\\", \\"UPLOAD 2 10\\", \\"TRANSFER 1 3 2\\", \\"TRANSFER 2 3 5\\", \\"UPLOAD 3 7\\" ] >>> manage_files(n, m, storage_limits, operations) [3, 5, 14] pass # Unit tests def test_example_case(): n = 3 m = 5 storage_limits = [10, 20, 15] operations = [ \\"UPLOAD 1 5\\", \\"UPLOAD 2 10\\", \\"TRANSFER 1 3 2\\", \\"TRANSFER 2 3 5\\", \\"UPLOAD 3 7\\" ] assert manage_files(n, m, storage_limits, operations) == [3, 5, 14] def test_upload_within_limits(): n = 2 m = 2 storage_limits = [10, 5] operations = [ \\"UPLOAD 1 4\\", \\"UPLOAD 2 5\\" ] assert manage_files(n, m, storage_limits, operations) == [4, 5] def test_upload_exceeding_limits(): n = 2 m = 2 storage_limits = [10, 5] operations = [ \\"UPLOAD 1 4\\", \\"UPLOAD 2 6\\" ] assert manage_files(n, m, storage_limits, operations) == [4, 0] def test_transfer_beyond_capacity(): n = 2 m = 3 storage_limits = [10, 5] operations = [ \\"UPLOAD 1 5\\", \\"TRANSFER 1 2 4\\", \\"TRANSFER 1 2 2\\" ] assert manage_files(n, m, storage_limits, operations) == [1, 4] def test_transfer_beyond_storage(): n = 2 m = 3 storage_limits = [10, 5] operations = [ \\"UPLOAD 1 3\\", \\"TRANSFER 1 2 4\\", \\"TRANSFER 1 2 2\\" ] assert manage_files(n, m, storage_limits, operations) == [1, 2]","solution":"def manage_files(n, m, storage_limits, operations): current_storage = [0] * n for op in operations: parts = op.split() if parts[0] == \\"UPLOAD\\": user_id = int(parts[1]) - 1 file_size = int(parts[2]) if current_storage[user_id] + file_size <= storage_limits[user_id]: current_storage[user_id] += file_size elif parts[0] == \\"TRANSFER\\": user_id1 = int(parts[1]) - 1 user_id2 = int(parts[2]) - 1 file_size = int(parts[3]) if current_storage[user_id1] >= file_size and current_storage[user_id2] + file_size <= storage_limits[user_id2]: current_storage[user_id1] -= file_size current_storage[user_id2] += file_size return current_storage"},{"question":"def check_alert(radius, soldiers): Determines if any enemy soldiers are within or on the boundary of the alerting circle centered at (0, 0) with the given radius. :param radius: The radius of the alerting zone. :param soldiers: A list of tuples representing the coordinates of enemy soldiers. :return: \\"Alert\\" if any soldier is within or on the alerting zone, otherwise \\"Safe\\". pass # Test cases def test_alert_within_zone(): assert check_alert(5, [(4, 3), (6, 7), (1, 1)]) == \\"Alert\\" def test_alert_on_boundary(): assert check_alert(5, [(3, 4), (6, 7), (1, 1)]) == \\"Alert\\" def test_all_safe(): assert check_alert(5, [(6, 7), (8, 8), (10, 6)]) == \\"Safe\\" def test_enemy_first_in_zone(): assert check_alert(5, [(1, 1), (6, 7), (8, 9)]) == \\"Alert\\" def test_no_enemies(): assert check_alert(5, []) == \\"Safe\\" def test_large_coordinates(): assert check_alert(1000000, [(999999, 0)]) == \\"Alert\\" def test_large_coordinates_safe(): assert check_alert(1000000, [(1000001, 0)]) == \\"Safe\\"","solution":"def check_alert(radius, soldiers): Determines if any enemy soldiers are within or on the boundary of the alerting circle centered at (0, 0) with the given radius. :param radius: The radius of the alerting zone. :param soldiers: A list of tuples representing the coordinates of enemy soldiers. :return: \\"Alert\\" if any soldier is within or on the alerting zone, otherwise \\"Safe\\". radius_squared = radius ** 2 for soldier in soldiers: x, y = soldier distance_squared = x ** 2 + y ** 2 if distance_squared <= radius_squared: return \\"Alert\\" return \\"Safe\\""},{"question":"def find_second_largest(numbers: List[int]) -> Union[int, None]: Finds the second largest number in a list of integers. If the list contains fewer than 2 unique elements, return None. Parameters: numbers (list): A list of integers. Returns: int/None: The second largest integer or None if it doesn't exist. >>> find_second_largest([3, 1, 4, 1, 5, 9, 2, 6]) 6 >>> find_second_largest([1]) None >>> find_second_largest([2, 2, 2, 2]) None >>> find_second_largest([-2, -1, 0, 1]) 0 >>> find_second_largest([10, 10, 9, 8]) 9","solution":"def find_second_largest(numbers): Finds the second largest number in a list of integers. Parameters: numbers (list): A list of integers. Returns: int/None: The second largest integer or None if it doesn't exist. largest = None second_largest = None for number in numbers: if largest is None or number > largest: second_largest = largest largest = number elif number != largest and (second_largest is None or number > second_largest): second_largest = number return second_largest"},{"question":"from typing import List def sliding_window_max(nums: List[int], k: int) -> List[int]: Given an integer array nums and a sliding window size k, find the maximum value in each sliding window. >>> sliding_window_max([1, 3, -1, -3, 5, 3, 6, 7], 3) [3, 3, 5, 5, 6, 7] >>> sliding_window_max([4, 2, 12, 11, -5], 2) [4, 12, 12, 11] pass from solution import sliding_window_max def test_example_1(): nums = [1, 3, -1, -3, 5, 3, 6, 7] k = 3 expected = [3, 3, 5, 5, 6, 7] assert sliding_window_max(nums, k) == expected def test_example_2(): nums = [4, 2, 12, 11, -5] k = 2 expected = [4, 12, 12, 11] assert sliding_window_max(nums, k) == expected def test_window_size_1(): nums = [1, 2, 3, 4, 5] k = 1 expected = [1, 2, 3, 4, 5] assert sliding_window_max(nums, k) == expected def test_single_element(): nums = [2] k = 1 expected = [2] assert sliding_window_max(nums, k) == expected def test_all_same_elements(): nums = [2, 2, 2, 2, 2, 2] k = 3 expected = [2, 2, 2, 2] assert sliding_window_max(nums, k) == expected def test_increasing_order(): nums = [1, 2, 3, 4, 5, 6, 7] k = 4 expected = [4, 5, 6, 7] assert sliding_window_max(nums, k) == expected def test_decreasing_order(): nums = [7, 6, 5, 4, 3, 2, 1] k = 3 expected = [7, 6, 5, 4, 3] assert sliding_window_max(nums, k) == expected def test_mixed_numbers(): nums = [-1, 3, 5, 3, 6, 7, 8] k = 4 expected = [5, 6, 7, 8] assert sliding_window_max(nums, k) == expected","solution":"from collections import deque def sliding_window_max(nums, k): Returns the maximum values in each sliding window of size k within the list nums. q = deque() max_vals = [] for i in range(len(nums)): # Remove elements not within the window if q and q[0] == i - k: q.popleft() # Remove elements smaller than the current element nums[i] while q and nums[q[-1]] <= nums[i]: q.pop() q.append(i) # Append max value for current window if i >= k - 1: max_vals.append(nums[q[0]]) return max_vals"},{"question":"def ranking_groups(n: int, scores: List[int]) -> List[int]: Determine the number of participants in each group based on their scores. Args: n (int): Number of participants. scores (list of int): Scores of the participants. Returns: list of int: Sizes of each group in decreasing order of their scores' count. Examples: >>> ranking_groups(5, [1000, 2000, 2000, 1000, 3000]) [2, 2, 1] >>> ranking_groups(3, [500, 500, 500]) [3] from typing import List","solution":"def ranking_groups(n, scores): Determine the number of participants in each group based on their scores. Args: n (int): Number of participants. scores (list of int): Scores of the participants. Returns: list of int: Sizes of each group in decreasing order of their scores' count. from collections import Counter # Count the occurrences of each score score_counts = Counter(scores) # Get the sizes of each group from the counts group_sizes = list(score_counts.values()) # Sort the sizes of groups in decreasing order group_sizes.sort(reverse=True) return group_sizes"},{"question":"def clean_and_average_temperatures(m, n, data): Removes corrupted readings and calculates average temperature for each weather station. Parameters: m (int): Number of weather stations n (int): Number of hourly readings per station data (list of list of int): Temperature readings Returns: list of float: Average temperature readings for each weather station from typing import List def clean_and_average_temperatures(m: int, n: int, data: List[List[int]]) -> List[float]: Removes corrupted readings and calculates average temperature for each weather station. >>> clean_and_average_temperatures(4, 5, [[25, 30, -9999, 22, 24], [18, -9999, 35, 25, 20], [-9999, -9999, -9999, 15, -9999], [30, 28, 27, 25, -9999]]) [25.25, 24.5, 15.0, 27.5] >>> clean_and_average_temperatures(2, 5, [[-9999, -9999, -9999, -9999, 10], [20, -9999, -9999, -9999, -9999]]) [10.0, 20.0] >>> clean_and_average_temperatures(2, 5, [[10, 15, 20, 25, 30], [5, 15, 25, 35, 45]]) [20.0, 25.0] >>> clean_and_average_temperatures(1, 7, [[25, 30, 22, -9999, 28, -9999, 30]]) [27.0] >>> data = [[25 if i % 2 == 0 else -9999 for i in range(10000)] for _ in range(5)] >>> expected_average = (sum(25 for i in range(5000))) / 5000 >>> all(abs(result - expected_average) < 0.01 for result in clean_and_average_temperatures(5, 10000, data)) True >>> clean_and_average_temperatures(1, 9, [[10, 20, -9999, 40, -9999, 60, -9999, 80, -9999]]) [42.0]","solution":"def clean_and_average_temperatures(m, n, data): Removes corrupted readings and calculates average temperature for each weather station. Parameters: m (int): Number of weather stations n (int): Number of hourly readings per station data (list of list of int): Temperature readings Returns: list of float: Average temperature readings for each weather station results = [] for station in data: valid_temps = [temp for temp in station if temp != -9999] average_temp = sum(valid_temps) / len(valid_temps) results.append(round(average_temp, 2)) return results"},{"question":"def recall_chevrolet_vehicles(datasets: List[Tuple[int, List[Tuple[int, int]], List[int]]]) -> List[str]: Determine which vehicles need to be recalled based on given year ranges. >>> recall_chevrolet_vehicles(parse_input(\\"2n2000 2005n2010 2015n1999 2003 2007 2012 2018n1n1990 2000n1985 1990 1992 1998 2002n0\\")) [\\"2003 2012\\", \\"1990 1992 1998\\"] >>> recall_chevrolet_vehicles(parse_input(\\"1n2000 2005n1999 1997n0\\")) [\\"NONE\\"] >>> recall_chevrolet_vehicles(parse_input(\\"1n2000 2005n2000 2001 2002 2003 2004 2005n0\\")) [\\"2000 2001 2002 2003 2004 2005\\"] >>> recall_chevrolet_vehicles(parse_input(\\"0\\")) [] >>> recall_chevrolet_vehicles(parse_input(\\"2n2000 2005n2003 2008n2001 2002 2003 2004 2005 2006 2007n0\\")) [\\"2001 2002 2003 2004 2005 2006 2007\\"] def parse_input(input_string: str) -> List[Tuple[int, List[Tuple[int, int]], List[int]]]: Parse input string to extract datasets information. >>> parse_input(\\"2n2000 2005n2010 2015n1999 2003 2007 2012 2018n1n1990 2000n1985 1990 1992 1998 2002n0\\") [(2, [(2000, 2005), (2010, 2015)], [1999, 2003, 2007, 2012, 2018]), (1, [(1990, 2000)], [1985, 1990, 1992, 1998, 2002])]","solution":"def recall_chevrolet_vehicles(datasets): results = [] for dataset in datasets: n, ranges, years = dataset recall_years = set() for s, e in ranges: recall_years.update(range(s, e + 1)) recalled = sorted(year for year in years if year in recall_years) if recalled: results.append(\\" \\".join(map(str, recalled))) else: results.append(\\"NONE\\") return results def parse_input(input_string): lines = input_string.strip().split(\\"n\\") datasets = [] i = 0 while i < len(lines) and lines[i] != '0': n = int(lines[i]) ranges = [tuple(map(int, lines[i+j+1].split())) for j in range(n)] years = list(map(int, lines[i+n+1].split())) datasets.append((n, ranges, years)) i += n + 2 return datasets"},{"question":"def can_meet_water_demand(n: int, m: int, water_demands: List[int], capacities: List[int], ranges: List[Tuple[int, int]]) -> str: Determines if the water demands of all neighborhoods can be met with the delivery points available. Args: n (int): Number of neighborhoods. m (int): Number of water delivery points. water_demands (list(int)): List of water demands for each neighborhood. capacities (list(int)): List of capacities for each water delivery point. ranges (list(Tuple(int, int))): List of ranges (inclusive) that each delivery point can supply. Returns: str: \\"YES\\" if water demands can be met, otherwise \\"NO\\". >>> can_meet_water_demand(4, 2, [3, 2, 2, 1], [5, 4], [(1, 2), (3, 4)]) \\"YES\\" >>> can_meet_water_demand(4, 2, [3, 2, 2, 2], [5, 3], [(1, 2), (3, 4)]) \\"NO\\" >>> can_meet_water_demand(1, 1, [10], [10], [(1, 1)]) \\"YES\\" >>> can_meet_water_demand(4, 3, [4, 4, 4, 4], [5, 6, 8], [(1, 2), (2, 3), (3, 4)]) \\"YES\\" >>> can_meet_water_demand(5, 2, [1, 2, 3, 4, 5], [10, 10], [(1, 3), (3, 5)]) \\"YES\\" >>> can_meet_water_demand(3, 1, [2, 5, 3], [10], [(1, 3)]) \\"YES\\"","solution":"def can_meet_water_demand(n, m, water_demands, capacities, ranges): Determines if the water demands of all neighborhoods can be met with the delivery points available. Args: n (int): Number of neighborhoods. m (int): Number of water delivery points. water_demands (list[int]): List of water demands for each neighborhood. capacities (list[int]): List of capacities for each water delivery point. ranges (list[tuple[int, int]]): List of ranges (inclusive) that each delivery point can supply. Returns: str: \\"YES\\" if water demands can be met, otherwise \\"NO\\". # Initialize water needs array for neighborhoods needs = water_demands[:] # Distribute water according to capacities and supply ranges for i in range(m): capacity = capacities[i] x, y = ranges[i] total_demand = sum(needs[x-1:y]) if total_demand <= capacity: for j in range(x-1, y): needs[j] = 0 else: remaining_capacity = capacity for j in range(x-1, y): if needs[j] <= remaining_capacity: remaining_capacity -= needs[j] needs[j] = 0 else: needs[j] -= remaining_capacity remaining_capacity = 0 break # Check if all water demands are met return \\"YES\\" if all(need == 0 for need in needs) else \\"NO\\""},{"question":"def countPairs(arr: List[int], k: int) -> int: Returns the number of unique pairs (a, b) in the list 'arr' that satisfy a + b = k. >>> countPairs([1, 5, 7, -1, 5], 6) == 3 >>> countPairs([1, 1, 1, 1], 2) == 6 >>> countPairs([1, 2, 3, 4], 8) == 0 >>> countPairs([1, 1, 2, 2], 3) == 4 >>> countPairs([1000000000, -1000000000, 0, 1000000000, -1000000000], 0) == 4 >>> countPairs([5], 10) == 0 >>> countPairs([], 10) == 0 pass","solution":"def countPairs(arr, k): Returns the number of unique pairs (a, b) in the list 'arr' that satisfy a + b = k. count = 0 complements = {} for num in arr: target = k - num if target in complements: count += complements[target] if num in complements: complements[num] += 1 else: complements[num] = 1 return count"},{"question":"from typing import List, Tuple def find_max_sum(arr: List[int]) -> Tuple[int, List[int]]: Given an array of n integers, find three distinct indices (i, j, k) such that the sum of the elements at these indices is the maximum possible. Returns the maximum sum and the three 1-based indices. >>> find_max_sum([1, 2, 3, 4, 5]) (12, [3, 4, 5]) >>> find_max_sum([-1, -2, -3, -4, -5]) (-6, [1, 2, 3]) >>> find_max_sum([-1, 1, 0, 2, -2, 3]) (6, [2, 4, 6]) >>> find_max_sum([1000000000, 1000000000, 1000000000, -1000000000, -1000000000]) (3000000000, [1, 2, 3]) >>> find_max_sum([1, 2, 3]) (6, [1, 2, 3])","solution":"def find_max_sum(arr): Returns the maximum possible sum of three distinct elements from the array and their 1-based indices. n = len(arr) if n < 3: raise ValueError(\\"The array must contain at least three elements\\") # Create list of tuples (value, index), then sort by value in descending order indexed_arr = sorted([(val, idx + 1) for idx, val in enumerate(arr)], reverse=True, key=lambda x: x[0]) # Select top three elements max_sum = indexed_arr[0][0] + indexed_arr[1][0] + indexed_arr[2][0] indices = [indexed_arr[0][1], indexed_arr[1][1], indexed_arr[2][1]] return max_sum, indices"},{"question":"import math def largest_square_grid_side(n: int, m: int) -> int: Determine the side length of the largest possible square grid that can fit inside the given rectangular garden. The grid should have an equal number of flowers in each row and column and be as large as possible without overcrowding. Args: n: The length of the garden. m: The width of the garden. Returns: The side length of the largest possible square grid of flowers. Examples: >>> largest_square_grid_side(10, 15) 5 >>> largest_square_grid_side(6, 8) 2 >>> largest_square_grid_side(7, 7) 7 >>> largest_square_grid_side(12, 15) 3 >>> largest_square_grid_side(14, 28) 14 >>> largest_square_grid_side(10**18, 10**18) 1000000000000000000 >>> largest_square_grid_side(10**18, 10**17) 100000000000000000 >>> largest_square_grid_side(1, 1) 1 >>> largest_square_grid_side(1, 1000000000000000000) 1 >>> largest_square_grid_side(1000000000000000000, 1) 1","solution":"import math def largest_square_grid_side(n, m): Returns the side length of the largest square grid that can fit inside a rectangle of dimensions n x m. The side length is the greatest common divisor (GCD) of n and m. return math.gcd(n, m)"},{"question":"from typing import List def can_reach_bottom_right(H: int, W: int, R: int, C: int, grid: List[str]) -> str: Determine if it is possible for the robot to reach the bottom-right cell (H-1, W-1) in a grid starting from position (R, C). >>> can_reach_bottom_right(5, 5, 0, 0, [\\".....\\", \\".#.\\", \\".#...\\", \\".#.\\", \\".....\\"]) 'Yes' >>> can_reach_bottom_right(4, 4, 1, 1, [\\"\\", \\"#..#\\", \\"#..#\\", \\"\\"]) 'No' pass","solution":"def can_reach_bottom_right(H, W, R, C, grid): from collections import deque if grid[H-1][W-1] == '#': return \\"No\\" directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[False] * W for _ in range(H)] queue = deque([(R, C)]) visited[R][C] = True while queue: x, y = queue.popleft() if (x, y) == (H-1, W-1): return \\"Yes\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < H and 0 <= ny < W and grid[nx][ny] == '.' and not visited[nx][ny]: queue.append((nx, ny)) visited[nx][ny] = True return \\"No\\""},{"question":"def sort_even_odd(arr): Sorts the input array such that all even integers appear before all odd integers while maintaining their relative order. :param arr: List of integers :return: List of integers with evens first and odds second, maintaining relative order Examples: >>> sort_even_odd([3, 8, 6, 5, 2, 7, 4]) [8, 6, 2, 4, 3, 5, 7] >>> sort_even_odd([1, 2, 3, 4, 5, 6]) [2, 4, 6, 1, 3, 5] >>> sort_even_odd([7, 3, 5, 2]) [2, 7, 3, 5] >>> sort_even_odd([2, 4, 6, 8]) [2, 4, 6, 8] >>> sort_even_odd([1, 3, 5, 7]) [1, 3, 5, 7] >>> sort_even_odd([10, 9, 8, 7]) [10, 8, 9, 7] >>> sort_even_odd([5]) [5] >>> sort_even_odd([2]) [2] >>> sort_even_odd([]) []","solution":"def sort_even_odd(arr): Sorts the input array such that all even integers appear before all odd integers while maintaining their relative order. :param arr: List of integers :return: List of integers with evens first and odds second, maintaining relative order evens = [num for num in arr if num % 2 == 0] odds = [num for num in arr if num % 2 != 0] return evens + odds"},{"question":"class Library: A class to represent a Library with various genres and books. Each book has a title, author, ISBN number, and belongs to one genre. Each genre is managed by a librarian who is responsible for all the books in that genre. def __init__(self): # Initialize the library with empty dictionaries for genres, books by ISBN, and books by author. self.genres = {} self.books_by_isbn = {} self.books_by_author = {} def add_genre(self, genre, librarian): Add a new genre with its librarian to the library. def remove_genre(self, genre): Remove a genre and all corresponding books from the library. def add_book(self, isbn, title, author, genre): Add a new book to a specific genre in the library. def remove_book(self, isbn): Remove a book from the library by its ISBN. def search_book(self, isbn): Search for a book by its ISBN and return its details. def list_books_by_genre(self, genre): List all book titles in a specific genre. def list_books_by_author(self, author): List all book titles by a specific author. def list_genres(self): List all genres available in the library. def test_library_operations(): lib = Library() # Test add genre lib.add_genre(\\"Fiction\\", \\"Alice\\") assert lib.genres[\\"Fiction\\"][\\"librarian\\"] == \\"Alice\\" lib.add_genre(\\"Science\\", \\"Bob\\") assert lib.genres[\\"Science\\"][\\"librarian\\"] == \\"Bob\\" # Test add book lib.add_book(\\"1234567890123\\", \\"The Great Gatsby\\", \\"Fitzgerald\\", \\"Fiction\\") assert lib.genres[\\"Fiction\\"][\\"books\\"][\\"1234567890123\\"][\\"title\\"] == \\"The Great Gatsby\\" lib.add_book(\\"9876543210123\\", \\"A Brief History of Time\\", \\"Hawking\\", \\"Science\\") assert lib.genres[\\"Science\\"][\\"books\\"][\\"9876543210123\\"][\\"title\\"] == \\"A Brief History of Time\\" # Test search book by ISBN result = lib.search_book(\\"1234567890123\\") assert result == \\"The Great Gatsby Fitzgerald Fiction\\" result = lib.search_book(\\"9999999999999\\") assert result == \\"BOOK NOT FOUND\\" # Test list books by genre result = lib.list_books_by_genre(\\"Fiction\\") assert result == \\"The Great Gatsby\\" result = lib.list_books_by_genre(\\"Science\\") assert result == \\"A Brief History of Time\\" result = lib.list_books_by_genre(\\"Mystery\\") assert result == \\"NO BOOKS\\" # Test list books by author result = lib.list_books_by_author(\\"Hawking\\") assert result == \\"A Brief History of Time\\" result = lib.list_books_by_author(\\"Unknown Author\\") assert result == \\"NO BOOKS\\" # Test list genres result = lib.list_genres() assert result == \\"Fiction Science\\" # Test remove book lib.remove_book(\\"1234567890123\\") result = lib.search_book(\\"1234567890123\\") assert result == \\"BOOK NOT FOUND\\" # Test remove genre lib.remove_genre(\\"Science\\") result = lib.list_genres() assert result == \\"Fiction\\" result = lib.search_book(\\"9876543210123\\") assert result == \\"BOOK NOT FOUND\\"","solution":"class Library: def __init__(self): self.genres = {} self.books_by_isbn = {} self.books_by_author = {} def add_genre(self, genre, librarian): if genre not in self.genres: self.genres[genre] = { 'librarian': librarian, 'books': {} } def remove_genre(self, genre): if genre in self.genres: for isbn in self.genres[genre]['books']: book = self.genres[genre]['books'][isbn] author = book['author'] if isbn in self.books_by_isbn: del self.books_by_isbn[isbn] if author in self.books_by_author: self.books_by_author[author].remove(book['title']) if not self.books_by_author[author]: del self.books_by_author[author] del self.genres[genre] def add_book(self, isbn, title, author, genre): if genre in self.genres: self.genres[genre]['books'][isbn] = { 'title': title, 'author': author } self.books_by_isbn[isbn] = { 'title': title, 'author': author, 'genre': genre } if author not in self.books_by_author: self.books_by_author[author] = [] self.books_by_author[author].append(title) def remove_book(self, isbn): if isbn in self.books_by_isbn: book = self.books_by_isbn[isbn] genre = book['genre'] author = book['author'] if isbn in self.genres[genre]['books']: del self.genres[genre]['books'][isbn] if isbn in self.books_by_isbn: del self.books_by_isbn[isbn] if author in self.books_by_author: self.books_by_author[author].remove(book['title']) if not self.books_by_author[author]: del self.books_by_author[author] def search_book(self, isbn): if isbn in self.books_by_isbn: book = self.books_by_isbn[isbn] return f\\"{book['title']} {book['author']} {book['genre']}\\" return \\"BOOK NOT FOUND\\" def list_books_by_genre(self, genre): if genre in self.genres: books = self.genres[genre]['books'] if books: return \\" \\".join(book['title'] for book in books.values()) return \\"NO BOOKS\\" def list_books_by_author(self, author): if author in self.books_by_author: if self.books_by_author[author]: return \\" \\".join(self.books_by_author[author]) return \\"NO BOOKS\\" def list_genres(self): if self.genres: return \\" \\".join(self.genres.keys()) return \\"NO GENRES\\""},{"question":"class BankSystem: def __init__(self): self.accounts = {} def add_user(self, user, initial_balance): self.accounts[user] = initial_balance def deposit(self, user, amount): if user in self.accounts: self.accounts[user] += amount def withdraw(self, user, amount): if user in self.accounts and self.accounts[user] >= amount: self.accounts[user] -= amount def balance(self, user): return self.accounts.get(user, 0) def process_commands(input_lines): Process a list of commands simulating a bank transaction system. Args: input_lines (List[str]): The list of commands to be processed. Returns: List[int]: The results of 'BALANCE' commands in the order they are processed. Example: >>> process_commands([\\"3\\", \\"alice 100\\", \\"bob 200\\", \\"charlie 150\\", \\"DEPOSIT alice 50\\", \\"BALANCE alice\\"]) [150]","solution":"class BankSystem: def __init__(self): self.accounts = {} def add_user(self, user, initial_balance): self.accounts[user] = initial_balance def deposit(self, user, amount): if user in self.accounts: self.accounts[user] += amount def withdraw(self, user, amount): if user in self.accounts and self.accounts[user] >= amount: self.accounts[user] -= amount def balance(self, user): return self.accounts.get(user, 0) def process_commands(input_lines): it = iter(input_lines) n = int(next(it)) bank = BankSystem() for _ in range(n): user, initial_balance = next(it).split() bank.add_user(user, int(initial_balance)) result = [] for command in it: parts = command.split() action = parts[0] user = parts[1] if action == \\"DEPOSIT\\": amount = int(parts[2]) bank.deposit(user, amount) elif action == \\"WITHDRAW\\": amount = int(parts[2]) bank.withdraw(user, amount) elif action == \\"BALANCE\\": result.append(bank.balance(user)) return result"},{"question":"from typing import List, Tuple def max_coins(R: int, C: int, coin_positions: List[Tuple[int, int]]) -> int: In a rectangular grid with R rows and C columns, determine the maximum number of coins a robot can collect while moving from the top-left corner to the bottom-right corner, and can only move right or down. >>> max_coins(3, 3, [(2, 2), (3, 3)]) 2 >>> max_coins(3, 3, []) 0 >>> max_coins(2, 2, [(1, 1), (1, 2), (2, 1), (2, 2)]) 3 >>> max_coins(3, 3, [(2, 3)]) 1 >>> max_coins(2, 5, [(1, 3), (2, 5)]) 2 pass def process_input(input_data: str) -> List[int]: Process the input data and return the results of each test case. >>> process_input(\\"1n3 3n2n2 2n3 3n\\") [2] >>> process_input(\\"2n3 3n2n2 2n3 3n2 2n1n2 2n\\") [2, 1] >>> process_input(\\"1n3 3n0n\\") [0] pass","solution":"def max_coins(R, C, coin_positions): # Initialize dp array with 0's dp = [[0] * C for _ in range(R)] # Mark the cells with coins for r, c in coin_positions: dp[r - 1][c - 1] = 1 # Iterate through the grid for i in range(R): for j in range(C): if i == 0 and j == 0: continue from_top = dp[i - 1][j] if i > 0 else 0 from_left = dp[i][j - 1] if j > 0 else 0 dp[i][j] += max(from_top, from_left) # Return the value in the bottom-right corner return dp[-1][-1] def process_input(input_data): lines = input_data.split(\\"n\\") T = int(lines[0]) index = 1 results = [] for _ in range(T): R, C = map(int, lines[index].split()) index += 1 N = int(lines[index]) index += 1 coin_positions = [] for _ in range(N): r, c = map(int, lines[index].split()) index += 1 coin_positions.append((r, c)) results.append(max_coins(R, C, coin_positions)) return results"},{"question":"from typing import List def count_unique_safe_paths(n: int, m: int, grid: List[List[int]]) -> int: Determine the number of unique safe paths from the top-left corner to the bottom-right corner of the grid. >>> count_unique_safe_paths(2, 2, [[0, 0], [1, 0]]) 1 >>> count_unique_safe_paths(3, 3, [[0, 1, 0], [0, 0, 0], [1, 0, 0]]) 2 >>> count_unique_safe_paths(2, 2, [[1, 0], [0, 0]]) 0 >>> count_unique_safe_paths(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 6 >>> count_unique_safe_paths(2, 2, [[0, 1], [1, 1]]) 0 >>> count_unique_safe_paths(1, 1, [[0]]) 1 >>> count_unique_safe_paths(1, 1, [[1]]) 0 >>> count_unique_safe_paths(5, 5, [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]) 70 >>> count_unique_safe_paths(3, 3, [[0, 0, 0], [1, 1, 0], [0, 0, 0]]) 1","solution":"def count_unique_safe_paths(n, m, grid): # If the starting or ending point is trapped, return 0 immediately if grid[0][0] == 1 or grid[n - 1][m - 1] == 1: return 0 # Initialize a 2D dp array with zeros dp = [[0] * m for _ in range(n)] # Starting point dp[0][0] = 1 # Fill the dp array for i in range(n): for j in range(m): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i - 1][j] if j > 0: dp[i][j] += dp[i][j - 1] # The value at dp[n-1][m-1] will be our answer return dp[n - 1][m - 1]"},{"question":"def sort_weights(n, weights): Returns the weights sorted in non-descending order. Parameters: n (int): The number of weights. weights (list of int): The list of weights. Returns: list of int: The sorted list of weights. >>> sort_weights(5, [4, 2, 5, 1, 3]) [1, 2, 3, 4, 5] >>> sort_weights(5, [5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] pass def format_sorted_weights(sorted_weights): Formats the sorted weights as a space-separated string. Parameters: sorted_weights (list of int): The sorted list of weights. Returns: str: The space-separated string of sorted weights. >>> format_sorted_weights([1, 2, 3, 4, 5]) \\"1 2 3 4 5\\" pass","solution":"def sort_weights(n, weights): Returns the weights sorted in non-descending order. Parameters: n (int): The number of weights. weights (list of int): The list of weights. Returns: list of int: The sorted list of weights. sorted_weights = sorted(weights) return sorted_weights # Function to format the output as a single line space-separated string def format_sorted_weights(sorted_weights): return ' '.join(map(str, sorted_weights))"},{"question":"def is_prime(n): Helper function to check if a number is prime. pass def prime_concatenation_possible(primes): Returns \\"YES\\" if it is possible to concatenate any two distinct primes from the list to form a new prime number, otherwise \\"NO\\". >>> prime_concatenation_possible([2, 3, 5, 11]) == \\"YES\\" >>> prime_concatenation_possible([2, 5, 7]) == \\"NO\\" >>> prime_concatenation_possible([2]) == \\"NO\\" >>> prime_concatenation_possible([3, 7]) == \\"YES\\" >>> prime_concatenation_possible([11, 13, 17, 19]) == \\"YES\\" >>> prime_concatenation_possible([89, 97, 109]) == \\"NO\\" pass","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def prime_concatenation_possible(primes): Returns \\"YES\\" if it is possible to concatenate any two distinct primes from the list to form a new prime number, otherwise \\"NO\\". for i in range(len(primes)): for j in range(len(primes)): if i != j: concat1 = int(str(primes[i]) + str(primes[j])) if is_prime(concat1): return \\"YES\\" return \\"NO\\" # Example Usage: # primes = [2, 3, 5, 11] # print(prime_concatenation_possible(primes)) # Output: \\"YES\\""},{"question":"def rotate_matrix_90_clockwise(matrix): Function to rotate an NxN matrix 90 degrees clockwise. Parameters: matrix (list of list of int): NxN matrix to be rotated Returns: list of list of int: Rotated NxN matrix pass def stringify_matrix(matrix): Convert matrix to a string representation. Parameters: matrix (list of list of int): Matrix to be converted Returns: str: String representation of the matrix pass from solution import rotate_matrix_90_clockwise, stringify_matrix def test_rotate_2x2_matrix(): matrix = [ [1, 2], [3, 4] ] expected = [ [3, 1], [4, 2] ] result = rotate_matrix_90_clockwise(matrix) assert result == expected def test_rotate_3x3_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] result = rotate_matrix_90_clockwise(matrix) assert result == expected def test_rotate_4x4_matrix(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] expected = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] result = rotate_matrix_90_clockwise(matrix) assert result == expected def test_stringify_matrix(): matrix = [ [1, 2], [3, 4] ] expected = \\"1 2n3 4\\" result = stringify_matrix(matrix) assert result == expected","solution":"def rotate_matrix_90_clockwise(matrix): Function to rotate an NxN matrix 90 degrees clockwise. Parameters: matrix (list of list of int): NxN matrix to be rotated Returns: list of list of int: Rotated NxN matrix N = len(matrix) rotated = [[0] * N for _ in range(N)] for i in range(N): for j in range(N): rotated[j][N - 1 - i] = matrix[i][j] return rotated def stringify_matrix(matrix): Convert matrix to a string representation. Parameters: matrix (list of list of int): Matrix to be converted Returns: str: String representation of the matrix result = 'n'.join(' '.join(map(str, row)) for row in matrix) return result"},{"question":"def apply_coloring_instructions(m: int, n: int, instructions: List[Tuple[int, int, int, int, int]]) -> List[List[int]]: Apply a series of rectangle coloring instructions to an MxN grid and return the final grid. Parameters: m (int): Number of rows in the grid. n (int): Number of columns in the grid. instructions (List[Tuple[int, int, int, int, int]]): A list of tuples, where each tuple contains: - r1, c1 (int): Top-left row and column of the rectangle (1-based index). - r2, c2 (int): Bottom-right row and column of the rectangle (1-based index). - color (int): The color to be applied to the rectangle. Returns: List[List[int]]: The final grid after applying all the instructions. Example: >>> m, n = 5, 5 >>> instructions = [(1, 1, 3, 3, 2), (2, 2, 4, 4, 3), (1, 4, 5, 5, 4)] >>> grid = apply_coloring_instructions(m, n, instructions) >>> format_grid(grid) ['2 2 2 4 4', '2 3 3 4 4', '2 3 3 4 4', '0 3 3 4 4', '0 0 0 4 4'] pass def format_grid(grid: List[List[int]]) -> List[str]: Format the grid for printing. Parameters: grid (List[List[int]]): The grid to be formatted. Returns: List[str]: The formatted grid as a list of strings, each string representing a row in the grid. Example: >>> grid = [[2, 2, 2, 4, 4], [2, 3, 3, 4, 4], [2, 3, 3, 4, 4], [0, 3, 3, 4, 4], [0, 0, 0, 4, 4]] >>> format_grid(grid) ['2 2 2 4 4', '2 3 3 4 4', '2 3 3 4 4', '0 3 3 4 4', '0 0 0 4 4'] pass # Test Cases def test_single_instruction(): instructions = [(1, 1, 3, 3, 2)] m, n = 5, 5 expected_output = [ \\"2 2 2 0 0\\", \\"2 2 2 0 0\\", \\"2 2 2 0 0\\", \\"0 0 0 0 0\\", \\"0 0 0 0 0\\" ] grid = apply_coloring_instructions(m, n, instructions) assert format_grid(grid) == expected_output def test_multiple_overlapping_instructions(): instructions = [ (1, 1, 3, 3, 2), (2, 2, 4, 4, 3), (1, 4, 5, 5, 4) ] m, n = 5, 5 expected_output = [ \\"2 2 2 4 4\\", \\"2 3 3 4 4\\", \\"2 3 3 4 4\\", \\"0 3 3 4 4\\", \\"0 0 0 4 4\\" ] grid = apply_coloring_instructions(m, n, instructions) assert format_grid(grid) == expected_output def test_no_coloring_instructions(): instructions = [] m, n = 2, 2 expected_output = [ \\"0 0\\", \\"0 0\\" ] grid = apply_coloring_instructions(m, n, instructions) assert format_grid(grid) == expected_output def test_full_grid_coloring(): instructions = [ (1, 1, 2, 2, 1) ] m, n = 2, 2 expected_output = [ \\"1 1\\", \\"1 1\\" ] grid = apply_coloring_instructions(m, n, instructions) assert format_grid(grid) == expected_output","solution":"def apply_coloring_instructions(m, n, instructions): grid = [[0] * n for _ in range(m)] for (r1, c1, r2, c2, color) in instructions: for r in range(r1 - 1, r2): for c in range(c1 - 1, c2): grid[r][c] = color return grid def format_grid(grid): return [' '.join(map(str, row)) for row in grid]"},{"question":"def highest_average_score(n: int, data: List[Tuple[str, int, int, int]]) -> str: Calculate the average score of each student and determine the highest average score. Args: n (int): The number of students. data (List[Tuple[str, int, int, int]]): List of tuples, each containing the name and scores in Math, Science, and English. Returns: str: The name of the student with the highest average score followed by their average score rounded to two decimal places. Examples: >>> highest_average_score(3, [(\\"Alice\\", 90, 80, 70), (\\"Bob\\", 85, 90, 95), (\\"Charlie\\", 100, 90, 80)]) 'Bob 90.00' >>> highest_average_score(2, [(\\"Alice\\", 88, 92, 85), (\\"Bob\\", 95, 85, 90)]) 'Bob 90.00' from typing import List, Tuple def test_highest_average_score(): data1 = [ (\\"Alice\\", 90, 80, 70), (\\"Bob\\", 85, 90, 95), (\\"Charlie\\", 100, 90, 80) ] assert highest_average_score(3, data1) == \\"Bob 90.00\\" data2 = [ (\\"Alice\\", 88, 92, 85), (\\"Bob\\", 95, 85, 90) ] assert highest_average_score(2, data2) == \\"Bob 90.00\\" data3 = [ (\\"David\\", 76, 85, 90), (\\"Eva\\", 95, 93, 91) ] assert highest_average_score(2, data3) == \\"Eva 93.00\\" data4 = [ (\\"Sam\\", 70, 75, 80), (\\"Max\\", 90, 85, 80), (\\"John\\", 88, 89, 92) ] assert highest_average_score(3, data4) == \\"John 89.67\\" data5 = [ (\\"Anna\\", 100, 100, 100), (\\"Lucy\\", 100, 90, 95) ] assert highest_average_score(2, data5) == \\"Anna 100.00\\"","solution":"def highest_average_score(n, data): highest_avg = -1 top_student = \\"\\" for student in data: name, math, science, english = student avg = (math + science + english) / 3 if avg > highest_avg: highest_avg = avg top_student = name return f\\"{top_student} {highest_avg:.2f}\\" # Example usage: # students_data = [ # (\\"Alice\\", 90, 80, 70), # (\\"Bob\\", 85, 90, 95), # (\\"Charlie\\", 100, 90, 80) # ] # print(highest_average_score(3, students_data))"},{"question":"from typing import List, Tuple def shortest_path_to_destination(M: int, N: int, walls: List[Tuple[int, int]], start: Tuple[int, int], destination: Tuple[int, int]) -> int: Determine the minimum number of moves required for the player to reach the destination, or report that it is impossible using a breadth-first search algorithm. Parameters: M (int): Number of rows in the grid. N (int): Number of columns in the grid. walls (List[Tuple[int, int]]): List of (r, c) positions containing walls. start (Tuple[int, int]): Starting position (sx, sy) of the player. destination (Tuple[int, int]): Destination position (dx, dy) of the player. Returns: int: Minimum number of moves to reach destination, or -1 if impossible. >>> shortest_path_to_destination(5, 5, [(1, 1), (1, 3), (3, 1)], (0, 0), (4, 4)) 8 >>> shortest_path_to_destination(4, 4, [(2, 2), (3, 3)], (0, 0), (3, 3)) -1 def process_input(inputs: List[str]) -> List[int]: Process the input commands for the grid-based game to find shortest paths. Parameters: inputs (List[str]): List of string inputs defining grids, walls, and positions. Returns: List[int]: List containing minimum moves required or -1 for each grid. >>> process_input([ ... \\"5 5 3\\", \\"1 1\\", \\"1 3\\", \\"3 1\\", \\"0 0\\", \\"4 4\\", ... \\"4 4 2\\", \\"2 2\\", \\"3 3\\", \\"0 0\\", \\"3 3\\", ... \\"0 0 0\\" ... ]) [8, -1] pass # Implement process_input function here def test_shortest_path_to_destination(): inputs = [ \\"5 5 3\\", \\"1 1\\", \\"1 3\\", \\"3 1\\", \\"0 0\\", \\"4 4\\", \\"4 4 2\\", \\"2 2\\", \\"3 3\\", \\"0 0\\", \\"3 3\\", \\"0 0 0\\" ] expected_outputs = [8, -1] results = process_input(inputs) assert results == expected_outputs def test_no_walls(): inputs = [ \\"3 3 0\\", \\"0 0\\", \\"2 2\\", \\"0 0 0\\" ] expected_outputs = [4] results = process_input(inputs) assert results == expected_outputs def test_no_possible_path(): inputs = [ \\"3 3 9\\", \\"0 0\\", \\"0 1\\", \\"0 2\\", \\"1 0\\", \\"1 1\\", \\"1 2\\", \\"2 0\\", \\"2 1\\", \\"2 2\\", \\"0 0\\", \\"2 2\\", \\"0 0 0\\" ] expected_outputs = [-1] results = process_input(inputs) assert results == expected_outputs def test_large_grid_easy_path(): inputs = [ \\"10 10 1\\", \\"5 5\\", \\"0 0\\", \\"9 9\\", \\"0 0 0\\" ] expected_outputs = [18] results = process_input(inputs) assert results == expected_outputs","solution":"from collections import deque def shortest_path_to_destination(M, N, walls, start, destination): # Initialize the grid grid = [[0] * N for _ in range(M)] for x, y in walls: grid[x][y] = 1 # 1 represents a wall sx, sy = start dx, dy = destination # Directions for moving in the grid (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS initialization queue = deque([(sx, sy, 0)]) # (current_x, current_y, current_distance) visited = set() visited.add((sx, sy)) while queue: x, y, dist = queue.popleft() # If we reach the destination if (x, y) == (dx, dy): return dist # Explore the neighbors for d in directions: nx, ny = x + d[0], y + d[1] if 0 <= nx < M and 0 <= ny < N and grid[nx][ny] == 0 and (nx, ny) not in visited: queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1 # If destination is not reachable def process_input(inputs): results = [] i = 0 while i < len(inputs): M, N, K = map(int, inputs[i].split()) if M == 0 and N == 0 and K == 0: break walls = [] for j in range(K): i += 1 x, y = map(int, inputs[i].split()) walls.append((x, y)) i += 1 sx, sy = map(int, inputs[i].split()) i += 1 dx, dy = map(int, inputs[i].split()) result = shortest_path_to_destination(M, N, walls, (sx, sy), (dx, dy)) results.append(result) i += 1 return results"},{"question":"def minimum_capacity(arrivals: List[int]) -> int: Returns the minimum capacity required for the waiting area so that it can handle the peak number of people present at the station over a series of days. >>> minimum_capacity([3]) 3 >>> minimum_capacity([4, 8, 4, 5, 6]) 8 >>> minimum_capacity([5, 5, 5, 5]) 5 >>> minimum_capacity([1, 10000, 5000, 7000, 3000]) 10000 >>> minimum_capacity([10, 20, 30, 40, 50]) 50 >>> minimum_capacity([1, 2, 1, 2, 1, 2]) 2 >>> minimum_capacity([10, 9, 8, 7, 6]) 10","solution":"def minimum_capacity(arrivals): Returns the minimum capacity required for the waiting area so that it can handle the peak number of people present at the station over a series of days. return max(arrivals) # Testing the function print(minimum_capacity([4, 8, 4, 5, 6])) # Expected Output: 8"},{"question":"def longest_odd_segment(n: int, a: List[int]) -> int: Returns the length of the longest subarray where the number of odd and even numbers are equal. >>> longest_odd_segment(5, [1, 2, 3, 4, 5]) 4 >>> longest_odd_segment(6, [2, 4, 6, 8, 10, 12]) 0 >>> longest_odd_segment(3, [1, 1, 1]) 0 >>> longest_odd_segment(7, [1, 2, 3, 4, 5, 6, 7]) 6 pass","solution":"def longest_odd_segment(n, a): Returns the length of the longest subarray where the number of odd and even numbers are equal. # Dictionary to store the first occurrence of a balance value balance_map = {0: -1} balance = 0 max_length = 0 for i in range(n): # Increment balance for odd numbers, decrement for even numbers if a[i] % 2 == 0: balance -= 1 else: balance += 1 # Check if this balance has been seen before if balance in balance_map: max_length = max(max_length, i - balance_map[balance]) else: balance_map[balance] = i return max_length"},{"question":"def min_weight_difference(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the minimum weight difference between any two boxes for given test cases. >>> min_weight_difference([(5, [1, 3, 6, 9, 12]), (4, [10, 20, 30, 40]), (3, [15, 5, 25])]) [2, 10, 10] >>> min_weight_difference([(2, [1, 2])]) [1] >>> min_weight_difference([(3, [5, 5, 5])]) [0] >>> min_weight_difference([(3, [1000000000, 999999998, 999999999])]) [1] >>> min_weight_difference([(5, [5] * 100000)]) [0]","solution":"def min_weight_difference(test_cases): results = [] for case in test_cases: n, weights = case weights.sort() min_diff = float('inf') for i in range(1, n): diff = weights[i] - weights[i - 1] if diff < min_diff: min_diff = diff results.append(min_diff) return results"},{"question":"from typing import List, Tuple def max_tasks_completed(t: int, test_cases: List[Tuple[int, int, List[int], List[int]]]) -> List[int]: Calculate the maximum number of tasks that can be completed by knights with given power levels. Parameters: t (int): The number of test cases. test_cases (List[Tuple[int, int, List[int], List[int]]]): A list of tuples, where each tuple contains: - int: Number of knights - int: Number of tasks - List[int]: Power levels of the knights - List[int]: Required power levels for the tasks Returns: List[int]: A list of integers representing the maximum number of tasks completed for each test case. pass def prepare_test_cases(raw_data: List[str]) -> Tuple[int, List[Tuple[int, int, List[int], List[int]]]]: Prepare the test cases from raw string data. Parameters: raw_data (List[str]): Raw input data in string format. Returns: Tuple[int, List[Tuple[int, int, List[int], List[int]]]]: Parsed number of test cases and a list of test case data. pass # Unit Tests def test_max_tasks_completed(): raw_data = [ \\"2\\", \\"4 3\\", \\"10 20 15 30\\", \\"15 10 20\\", \\"5 5\\", \\"20 10 15 30 25\\", \\"15 10 20 25 30\\" ] t, test_cases = prepare_test_cases(raw_data) results = max_tasks_completed(t, test_cases) assert results == [3, 5] def test_single_knight_multiple_tasks(): raw_data = [ \\"1\\", \\"1 3\\", \\"20\\", \\"10 15 20\\" ] t, test_cases = prepare_test_cases(raw_data) results = max_tasks_completed(t, test_cases) assert results == [1] def test_no_knight_can_complete_any_task(): raw_data = [ \\"1\\", \\"2 3\\", \\"10 15\\", \\"20 25 30\\" ] t, test_cases = prepare_test_cases(raw_data) results = max_tasks_completed(t, test_cases) assert results == [0] def test_all_knights_idle(): raw_data = [ \\"1\\", \\"3 0\\", \\"10 20 30\\", \\"\\" ] t, test_cases = prepare_test_cases(raw_data) results = max_tasks_completed(t, test_cases) assert results == [0] def test_all_tasks_completed(): raw_data = [ \\"1\\", \\"3 3\\", \\"10 20 30\\", \\"5 15 25\\" ] t, test_cases = prepare_test_cases(raw_data) results = max_tasks_completed(t, test_cases) assert results == [3] def test_more_knights_than_tasks(): raw_data = [ \\"1\\", \\"5 3\\", \\"10 20 30 40 50\\", \\"10 20 30\\" ] t, test_cases = prepare_test_cases(raw_data) results = max_tasks_completed(t, test_cases) assert results == [3]","solution":"def max_tasks_completed(t, test_cases): results = [] for case in test_cases: N, M, P, T = case P.sort() T.sort() i, j = 0, 0 # i for tasks, j for knights completed_tasks = 0 while i < M and j < N: if P[j] >= T[i]: # Knight can complete the task completed_tasks += 1 i += 1 # Move to next task j += 1 # Move to next knight results.append(completed_tasks) return results def prepare_test_cases(raw_data): t = int(raw_data[0]) index = 1 test_cases = [] for _ in range(t): N, M = map(int, raw_data[index].split()) index += 1 P = list(map(int, raw_data[index].split())) index += 1 T = list(map(int, raw_data[index].split())) index += 1 test_cases.append((N, M, P, T)) return t, test_cases"},{"question":"def execute_miniscript(cmds): Executes a MiniScript program represented by a list of commands. Args: cmds: List[str] - A list of commands in the MiniScript program. The function should process the commands and print the value of the register whenever the 'printreg' command is encountered. Example: >>> cmds = [\\"increg\\", \\"increg\\", \\"printreg\\"] >>> execute_miniscript(cmds) 2","solution":"def execute_miniscript(cmds): Executes a MiniScript program represented by a list of commands. register = 0 for cmd in cmds: if cmd == \\"increg\\": register += 1 elif cmd == \\"decreg\\": register -= 1 elif cmd == \\"printreg\\": print(register) else: raise ValueError(f\\"Unknown command: {cmd}\\")"},{"question":"def find_shortest(sentence: str) -> int: Returns the length of the shortest word in the sentence. >>> find_shortest(\\"Simple example sentence\\") == 6 >>> find_shortest(\\"An apple a day\\") == 1","solution":"def find_shortest(sentence): Returns the length of the shortest word in the sentence. words = sentence.split() shortest_length = min(len(word) for word in words) return shortest_length"},{"question":"def sum_at_depth(tree, depth): Returns the sum of all node values at the given depth. >>> sum_at_depth([1, 2, 3, 4, 5, -1, -1, -1, -1, 6, 7], 2) 9 >>> sum_at_depth([5, 1, 4, -1, -1, 3, 6], 1) 5 >>> sum_at_depth([], 1) 0 >>> sum_at_depth([1, 2, 3], 3) 0 >>> sum_at_depth([1, 2, 3], 0) 1 >>> sum_at_depth([-1, -1, -1], 1) 0 >>> sum_at_depth([1], 0) 1 >>> sum_at_depth([1], 1) 0","solution":"def sum_at_depth(tree, depth): Returns the sum of all node values at the given depth. if not tree or depth < 0: return 0 current_depth = 0 current_level = [tree[0]] idx = 1 while current_level and idx < len(tree): if current_depth == depth: return sum(node for node in current_level if node != -1) next_level = [] for node in current_level: if node != -1: if idx < len(tree): next_level.append(tree[idx]) idx += 1 if idx < len(tree): next_level.append(tree[idx]) idx += 1 else: next_level.extend([-1, -1]) current_level = next_level current_depth += 1 if current_depth == depth: return sum(node for node in current_level if node != -1) return 0"},{"question":"def max_hours_to_stabilize(field): Determine the maximum number of hours after which all cells in the grid will have the same moisture level. >>> max_hours_to_stabilize([[4, 3, 2], [3, 2, 1], [1, 1, 2]]) == 3 >>> max_hours_to_stabilize([[1, 1], [1, 1]]) == 0 >>> max_hours_to_stabilize([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 8 >>> max_hours_to_stabilize([[5]]) == 0 >>> max_hours_to_stabilize([[5, 4, 3], [2, 1, 0]]) == 5 pass def process_test_case(M, N, grid): Process a single test case and return the maximum number of hours for the grid to stabilize. >>> process_test_case(3, 3, [[4, 3, 2], [3, 2, 1], [1, 1, 2]]) == 3 >>> process_test_case(2, 2, [[1, 1], [1, 1]]) == 0 >>> process_test_case(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 8 >>> process_test_case(1, 1, [[5]]) == 0 >>> process_test_case(2, 3, [[5, 4, 3], [2, 1, 0]]) == 5 pass def main(): import sys input = sys.stdin.read data = input().split() idx = 0 T = int(data[idx]) idx += 1 results = [] for _ in range(T): M = int(data[idx]) N = int(data[idx + 1]) idx += 2 grid = [] for _ in range(M): grid.append([int(x) for x in data[idx:idx + N]]) idx += N results.append(process_test_case(M, N, grid)) for result in results: print(result) if __name__ == \\"__main__\\": main()","solution":"def max_hours_to_stabilize(field): M = len(field) N = len(field[0]) def max_diff(field): max_value = max([max(row) for row in field]) min_value = min([min(row) for row in field]) return max_value - min_value max_steps = max_diff(field) return max_steps def process_test_case(M, N, grid): return max_hours_to_stabilize(grid) def main(): import sys input = sys.stdin.read data = input().split() idx = 0 T = int(data[idx]) idx += 1 results = [] for _ in range(T): M = int(data[idx]) N = int(data[idx + 1]) idx += 2 grid = [] for _ in range(M): grid.append([int(x) for x in data[idx:idx + N]]) idx += N results.append(process_test_case(M, N, grid)) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def maximize_candy_weighted_sum(n: int, sizes: List[int], sweetnesses: List[int]) -> List[int]: Returns a permutation of candy indices that maximizes the total weighted sum. :param n: int, number of different candy types. :param sizes: List[int], sizes of the candy types. :param sweetnesses: List[int], sweetness levels of the candy types. :return: List[int], permutation of indices maximizing the total weighted sum. # Implement the function here pass def test_example_1(): sizes = [2, 8, 5] sweetnesses = [3, 6, 4] n = 3 assert maximize_candy_weighted_sum(n, sizes, sweetnesses) == [2, 3, 1] def test_example_2(): sizes = [1, 2, 3, 4] sweetnesses = [10, 11, 12, 13] n = 4 assert maximize_candy_weighted_sum(n, sizes, sweetnesses) == [4, 3, 2, 1] def test_all_equal_elements(): sizes = [1, 1, 1, 1] sweetnesses = [1, 1, 1, 1] n = 4 assert maximize_candy_weighted_sum(n, sizes, sweetnesses) == [1, 2, 3, 4] # since they are all equal in size and sweetness def test_single_element(): sizes = [10] sweetnesses = [10] n = 1 assert maximize_candy_weighted_sum(n, sizes, sweetnesses) == [1] def test_large_numbers(): sizes = [1000, 2000, 3000] sweetnesses = [1000, 2000, 3000] n = 3 assert maximize_candy_weighted_sum(n, sizes, sweetnesses) == [3, 2, 1] def test_reverse_sorted_sizes(): sizes = [9, 7, 5, 3] sweetnesses = [4, 2, 6, 8] n = 4 assert maximize_candy_weighted_sum(n, sizes, sweetnesses) == [1, 3, 4, 2]","solution":"def maximize_candy_weighted_sum(n, sizes, sweetnesses): Returns a permutation of candy indices that maximizes the total weighted sum. :param n: int, number of different candy types. :param sizes: List[int], sizes of the candy types. :param sweetnesses: List[int], sweetness levels of the candy types. :return: List[int], permutation of indices maximizing the total weighted sum. candies = [(sizes[i], sweetnesses[i], i + 1) for i in range(n)] # Sorting by sum of sizes and sweetness in descending order # If two candies have the same sum, sorted by original index in ascending order. candies.sort(key=lambda x: (x[0] + x[1]), reverse=True) # Extracting indices from the sorted list result = [candy[2] for candy in candies] return result"},{"question":"def min_remaining_stone(n: int, stones: List[int]) -> int: Compute the minimum possible value of the remaining stone. >>> min_remaining_stone(3, [2, 4, 1]) 1 >>> min_remaining_stone(5, [7, 10, 4, 3, 6]) 2 >>> min_remaining_stone(1, [5]) 5 >>> min_remaining_stone(4, [4, 4, 4, 4]) 0 >>> min_remaining_stone(6, [10, 3, 7, 2, 5, 1]) 0 >>> min_remaining_stone(4, [10, 10, 10, 10]) 0","solution":"def min_remaining_stone(n, stones): while len(stones) > 1: stones.sort() new_stone = abs(stones[-1] - stones[-2]) stones = stones[:-2] if new_stone != 0: stones.append(new_stone) return stones[0] if stones else 0"},{"question":"def sum_of_top_k_scores(test_cases): Calculates the sum of top K scores for each test case. Parameters: test_cases (list): A list of tuples, where each tuple contains: - (int) N: Number of scores - (int) K: Number of top scores to sum - (list) scores: List of integers representing the scores Returns: list: A list of integers representing the sum of top K scores for each test case. pass from sum_of_top_k_scores import sum_of_top_k_scores def test_sum_of_top_k_scores(): test_cases = [ (5, 3, [10, 20, 30, 40, 50]), (6, 4, [100, 200, 50, 300, 150, 400]), (4, 2, [5, 25, 15, 10]) ] expected_results = [120, 1050, 40] assert sum_of_top_k_scores(test_cases) == expected_results def test_edge_case_one_round(): test_cases = [ (1, 1, [999999]), (1, 1, [0]) ] expected_results = [999999, 0] assert sum_of_top_k_scores(test_cases) == expected_results def test_edge_case_multiple_top_same_scores(): test_cases = [ (5, 3, [20, 20, 20, 10, 10]), (6, 4, [300, 300, 100, 300, 200, 300]) ] expected_results = [60, 1200] assert sum_of_top_k_scores(test_cases) == expected_results def test_large_input(): test_cases = [ (1000, 1000, [i for i in range(1000)]), (1000, 500, [1000 - i for i in range(1000)]) ] expected_results = [sum(i for i in range(1000)), sum(1000 - i for i in range(500))] assert sum_of_top_k_scores(test_cases) == expected_results","solution":"def sum_of_top_k_scores(test_cases): Calculates the sum of top K scores for each test case. Parameters: test_cases (list): A list of tuples, where each tuple contains: - (int) N: Number of scores - (int) K: Number of top scores to sum - (list) scores: List of integers representing the scores Returns: list: A list of integers representing the sum of top K scores for each test case. results = [] for N, K, scores in test_cases: top_k_scores = sorted(scores, reverse=True)[:K] results.append(sum(top_k_scores)) return results"},{"question":"from typing import List, Tuple def is_valid_shuffle(original: List[int], shuffled: List[int]) -> bool: Determines if the shuffled list is a valid shuffle of the original list. Args: original (list of int): The original list. shuffled (list of int): The shuffled list. Returns: bool: True if shuffled is a valid shuffle of original, False otherwise. pass def validate_shuffles(test_cases: List[Tuple[List[int], List[int]]]) -> List[str]: Given a list of test cases, determines if each shuffled list is a valid shuffle of the corresponding original list. Args: test_cases (list of tuples): Each tuple contains an original list and a shuffled list. Returns: list of str: \\"YES\\" or \\"NO\\" for each test case. pass def test_is_valid_shuffle(): assert is_valid_shuffle([1, 2, 3, 4, 5], [2, 3, 1, 5, 4]) == True assert is_valid_shuffle([1, 2, 3, 4], [1, 2, 3, 4]) == False assert is_valid_shuffle([1, 1, 2, 2, 3, 3], [3, 1, 2, 1, 2, 3]) == True assert is_valid_shuffle([1, 2], [2, 1]) == True assert is_valid_shuffle([1, 2, 3], [1, 3, 2, 3]) == False def test_validate_shuffles(): test_cases = [ ([1, 2, 3, 4, 5], [2, 3, 1, 5, 4]), ([1, 2, 3, 4], [1, 2, 3, 4]), ([1, 1, 2, 2, 3, 3], [3, 1, 2, 1, 2, 3]) ] assert validate_shuffles(test_cases) == [\\"YES\\", \\"NO\\", \\"YES\\"] test_cases = [ ([1, 2], [2, 1]), ([1, 2, 3], [1, 3, 2]), ([4, 4, 4], [4, 4, 4]) ] assert validate_shuffles(test_cases) == [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def is_valid_shuffle(original, shuffled): Determines if the shuffled list is a valid shuffle of the original list. Args: original (list of int): The original list. shuffled (list of int): The shuffled list. Returns: bool: True if shuffled is a valid shuffle of original, False otherwise. if original == shuffled: return False return sorted(original) == sorted(shuffled) def validate_shuffles(test_cases): results = [] for case in test_cases: original, shuffled = case if is_valid_shuffle(original, shuffled): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def min_operations_to_equal_elements(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum number of operations needed to make all the elements of the array equal. In a single operation, you can remove any two elements from the array and replace them with their sum. If it is impossible to make all the elements equal, output -1. Args: T: An integer representing the number of test cases. test_cases: A list of tuples where each tuple contains an integer denoting the number of integers in the array and a list of integers representing the elements of the array. Returns: A list of integers where each integer corresponds to the minimum number of operations for the respective test case. Examples: >>> min_operations_to_equal_elements(2, [(4, [1, 1, 1, 1]), (3, [1, 2, 3])]) [0, 1]","solution":"def min_operations_to_equal_elements(T, test_cases): results = [] for i in range(T): n, array = test_cases[i] if n == 1: results.append(0) continue unique_elements = set(array) if len(unique_elements) == 1: results.append(0) elif len(unique_elements) > 1: results.append(n - 1) return results"},{"question":"from typing import List def can_rearrange_to_no_consecutive_duplicates(t: int, test_cases: List[List[int]]) -> List[str]: Given a list of integers, determine if it is possible to rearrange the list such that no two consecutive numbers are the same. >>> can_rearrange_to_no_consecutive_duplicates(2, [[1, 2, 3, 4, 5], [1, 1, 1, 1, 1]]) [\\"Yes\\", \\"No\\"] # Implementation goes here from collections import Counter def test_can_rearrange_simple_yes(): assert can_rearrange_to_no_consecutive_duplicates(1, [[1, 2, 3, 4, 5]]) == [\\"Yes\\"] def test_can_rearrange_simple_no(): assert can_rearrange_to_no_consecutive_duplicates(1, [[1, 1, 1, 1, 1]]) == [\\"No\\"] def test_can_rearrange_mixed_cases(): input_cases = [ [1, 2, 3, 4, 5], [1, 1, 1, 1, 1], ] expected_output = [\\"Yes\\", \\"No\\"] assert can_rearrange_to_no_consecutive_duplicates(2, input_cases) == expected_output def test_can_rearrange_edge_case_minimum_length(): assert can_rearrange_to_no_consecutive_duplicates(1, [[1]]) == [\\"Yes\\"] def test_can_rearrange_edge_case_duplicate_elements(): assert can_rearrange_to_no_consecutive_duplicates(1, [[1, 2, 2, 3, 3, 4, 4]]) == [\\"Yes\\"] def test_can_rearrange_large_input(): input_case = [i for i in range(1, 100001)] assert can_rearrange_to_no_consecutive_duplicates(1, [input_case]) == [\\"Yes\\"]","solution":"from collections import Counter def can_rearrange_to_no_consecutive_duplicates(t, test_cases): results = [] for case in test_cases: freq = Counter(case) most_common_element_freq = max(freq.values()) # If the frequency of the most common element exceeds half the length of the list (rounded up), # it is impossible to rearrange such that no two consecutive numbers are the same. if most_common_element_freq > (len(case) + 1) // 2: results.append(\\"No\\") else: results.append(\\"Yes\\") return results"},{"question":"from typing import List, Tuple def shortest_path(N: int, M: int, start: int, target: int, edges: List[Tuple[int, int, int]]) -> int: Find the shortest travel time from a given start location to a given target location in a DAG. Args: N (int): Number of locations. M (int): Number of paths. start (int): Starting location ID. target (int): Target location ID. edges (List[Tuple[int, int, int]]): List of paths where each path is represented as a tuple (u, v, w) meaning a directed edge from u to v with travel time w. Returns: int: The shortest travel time from start to target or -1 if no path exists. >>> shortest_path(5, 6, 1, 5, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 3), (4, 5, 1)]) 6 >>> shortest_path(4, 4, 1, 4, [(1, 2, 5), (2, 3, 10), (3, 4, 1), (1, 3, 15)]) 16 >>> shortest_path(4, 3, 1, 4, [(1, 2, 4), (2, 3, 5), (3, 1, 6)]) -1","solution":"import heapq def shortest_path(N, M, start, target, edges): from heapq import heappush, heappop import sys from collections import defaultdict, deque graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) def topological_sort(): in_degree = defaultdict(int) for u in graph: for v, _ in graph[u]: in_degree[v] += 1 zero_in_degree_queue = deque([node for node in range(1, N + 1) if in_degree[node] == 0]) topological_order = [] while zero_in_degree_queue: vertex = zero_in_degree_queue.popleft() topological_order.append(vertex) for neighbor, _ in graph[vertex]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) return topological_order top_order = topological_sort() distances = {i: float('inf') for i in range(1, N + 1)} distances[start] = 0 for node in top_order: if distances[node] != float('inf'): for neighbor, weight in graph[node]: if distances[node] + weight < distances[neighbor]: distances[neighbor] = distances[node] + weight return distances[target] if distances[target] != float('inf') else -1"},{"question":"def determine_winner(t: int, test_cases: List[int]) -> List[str]: Determines the winner of the game for each test case. Alice and Bob alternate turns, with Alice going first. In each turn, a player must pick one Fibonacci number from an array (starting from F(1)) and divide it by another Fibonacci number (greater than 1) such that the result remains an integer and replace the selected number with the result in the array. If a player cannot make a move, they lose, and the other player wins. Args: t (int): Number of test cases. test_cases (list[int]): The list containing the number of Fibonacci numbers for each test case. Returns: list[str]: List containing the winner (\\"Alice\\" or \\"Bob\\") for each test case. # Implement the function here # Test Cases import pytest def test_fibonacci_game_cases(): t = 2 test_cases = [5, 8] expected = [\\"Alice\\", \\"Bob\\"] assert determine_winner(t, test_cases) == expected def test_large_cases(): t = 3 test_cases = [1, 2, 3] expected = [\\"Alice\\", \\"Bob\\", \\"Alice\\"] assert determine_winner(t, test_cases) == expected def test_single_case(): t = 1 test_cases = [10] expected = [\\"Bob\\"] assert determine_winner(t, test_cases) == expected def test_edge_case(): t = 1 test_cases = [100000] expected = [\\"Bob\\"] assert determine_winner(t, test_cases) == expected def test_single_fibonacci(): t = 1 test_cases = [1] expected = [\\"Alice\\"] assert determine_winner(t, test_cases) == expected","solution":"def determine_winner(t, test_cases): Determines the winner of the game for each test case. Args: t (int): Number of test cases. test_cases (list[int]): The list containing the number of Fibonacci numbers for each test case. Returns: list[str]: List containing the winner (\\"Alice\\" or \\"Bob\\") for each test case. # A precomputed list of the first few Fibonacci numbers fib = [1, 2] while fib[-1] <= 10**9: fib.append(fib[-1] + fib[-2]) results = [] for m in test_cases: # Bob wins if Alice is forced to deal with the initial \\"1, 2\\" scenario # This is true when m is odd (due to the \\"indexing strategy\\" turns) if m % 2 == 1: results.append(\\"Alice\\") else: results.append(\\"Bob\\") return results"},{"question":"def reverse_words(strings): Takes an array of strings and returns a new array where each word in the strings is reversed, but the order of words is kept original. Args: strings (list): A list of strings. Returns: list: A list of strings with reversed words. pass def test_reverse_words_simple(): assert reverse_words([\\"hello world\\"]) == [\\"olleh dlrow\\"] def test_reverse_words_multiple_sentences(): assert reverse_words([\\"hello world\\", \\"example test case\\"]) == [\\"olleh dlrow\\", \\"elpmaxe tset esac\\"] def test_reverse_words_programming_fun(): assert reverse_words([\\"programming is fun\\", \\"keep learning\\"]) == [\\"gnimmargorp si nuf\\", \\"peek gninrael\\"] def test_reverse_words_single_letters(): assert reverse_words([\\"a b c\\", \\"d e f\\"]) == [\\"a b c\\", \\"d e f\\"] def test_reverse_words_reverse_these_words(): assert reverse_words([\\"reverse these words\\", \\"please\\"]) == [\\"esrever eseht sdrow\\", \\"esaelp\\"] def test_reverse_words_empty_list(): assert reverse_words([]) == [] def test_reverse_words_single_word(): assert reverse_words([\\"hello\\"]) == [\\"olleh\\"]","solution":"def reverse_words(strings): Takes an array of strings and returns a new array where each word in the strings is reversed, but the order of words is kept original. Args: strings (list): A list of strings. Returns: list: A list of strings with reversed words. return [' '.join(word[::-1] for word in sentence.split()) for sentence in strings]"},{"question":"def calculate_total_overtime_pay(N: int, X: int, Y: int, hours_worked: List[int]) -> int: Calculates the total overtime pay for N employees given their hours worked and rates X and Y. >>> calculate_total_overtime_pay(5, 10, 15, [9, 8, 10, 13, 12]) 125 >>> calculate_total_overtime_pay(3, 20, 30, [6, 7, 8]) 0 >>> calculate_total_overtime_pay(4, 50, 75, [13, 14, 15, 16]) 1000 >>> calculate_total_overtime_pay(4, 10, 20, [8, 9, 12, 15]) 130","solution":"def calculate_total_overtime_pay(N, X, Y, hours_worked): Calculates the total overtime pay for N employees given their hours worked and rates X and Y. total_overtime_pay = 0 for hours in hours_worked: if hours > 12: total_overtime_pay += 4 * X + (hours - 12) * Y elif hours > 8: total_overtime_pay += (hours - 8) * X return total_overtime_pay"},{"question":"def count_unique_pairs(T: int, test_cases: List[int]) -> List[int]: Returns the number of unique pairs of employees who can exchange emails for each test case. Parameters: T (int): The number of test cases. test_cases (list of int): A list containing the number of employees for each test case. Returns: list of int: A list containing the number of unique pairs for each test case. Example: >>> count_unique_pairs(3, [1, 2, 3]) [0, 1, 3] >>> count_unique_pairs(1, [1000000]) [499999500000]","solution":"def count_unique_pairs(T, test_cases): Returns the number of unique pairs of employees who can exchange emails for each test case. Parameters: T (int): The number of test cases. test_cases (list of int): A list containing the number of employees for each test case. Returns: list of int: A list containing the number of unique pairs for each test case. results = [] for N in test_cases: if N < 2: results.append(0) else: results.append(N * (N - 1) // 2) return results"},{"question":"def can_form_contiguous_sequence(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if each sequence can be reordered to form a contiguous sequence of increasing numbers. Each test case should be processed to check if the sequence can be reordered. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples, each containing an integer n and a list of n integers representing the sequence. Returns: List[str]: A list of strings, \\"YES\\" or \\"NO\\" for each test case. Examples: >>> can_form_contiguous_sequence(3, [ ... (4, [4, 2, 3, 1]), ... (5, [6, 2, 4, 3, 1]), ... (3, [10, 11, 12]) ... ]) [\\"YES\\", \\"NO\\", \\"YES\\"]","solution":"def can_form_contiguous_sequence(t, test_cases): results = [] for i in range(t): n, sequence = test_cases[i] sequence.sort() is_contiguous = True for j in range(1, n): if sequence[j] != sequence[j-1] + 1: is_contiguous = False break if is_contiguous: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"import math from typing import List, Tuple def max_waypoints(V: int, waypoints: List[Tuple[int, int]]) -> int: Calculate the maximum number of waypoints a drone can travel without running out of battery. :param V: Maximum battery capacity. :param waypoints: List of tuples representing the coordinates of the waypoints. :return: Maximum number of waypoints the drone can travel. # your code here pass def process_input(test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[int]: Processes the input and returns the outputs for all the test cases. :param test_cases: List of tuples representing the test cases. :return: List of results for each test case. # your code here pass # Unit Tests def test_example_case(): input_data = [(25, 4, [(0, 0), (3, 4), (3, 0), (0, 0)])] expected_output = [3] assert process_input(input_data) == expected_output def test_max_capacity_not_exceeded(): input_data = [(20, 3, [(0, 0), (3, 4), (6, 8)])] expected_output = [2] assert process_input(input_data) == expected_output def test_single_route_segment(): input_data = [(5, 2, [(0, 0), (0, 5)])] expected_output = [1] assert process_input(input_data) == expected_output def test_all_waypoints_traversable(): input_data = [(50, 5, [(0, 0), (3, 4), (6, 8), (9, 12), (12, 16)])] expected_output = [4] assert process_input(input_data) == expected_output def test_zero_capacity(): input_data = [(0, 3, [(0, 0), (1, 1), (2, 2)])] expected_output = [0] assert process_input(input_data) == expected_output def test_high_capacity(): input_data = [(1000, 3, [(0, 0), (10, 10), (20, 20)])] expected_output = [2] assert process_input(input_data) == expected_output if __name__ == \\"__main__\\": test_example_case() test_max_capacity_not_exceeded() test_single_route_segment() test_all_waypoints_traversable() test_zero_capacity() test_high_capacity() print(\\"All tests passed!\\")","solution":"import math def max_waypoints(V, waypoints): Calculate the maximum number of waypoints a drone can travel without running out of battery. :param V: Maximum battery capacity. :param waypoints: List of tuples representing the coordinates of the waypoints. :return: Maximum number of waypoints the drone can travel. total_distance = 0 max_waypoints = 0 for i in range(1, len(waypoints)): distance = math.dist(waypoints[i-1], waypoints[i]) if total_distance + distance > V: break total_distance += distance max_waypoints += 1 return max_waypoints def process_input(test_cases): Processes the input and returns the outputs for all the test cases. :param test_cases: List of tuples representing the test cases. :return: List of results for each test case. results = [] for V, W, waypoints in test_cases: results.append(max_waypoints(V, waypoints)) return results"},{"question":"class KingdomSecurity: def __init__(self, N, security_levels, roads): Initialize the kingdom with given parameters. Args: N: int - Number of cities security_levels: List[int] - Initial security levels of the cities roads: List[Tuple[int, int]] - List of roads connecting cities # Initialize the kingdom's internal data structures pass def reinforce(self, u: int, v: int, x: int): Increase the security levels of cities on the path between cities u and v by x units. Args: u: int - the starting city v: int - the ending city x: int - the amount to increase the security levels by # Reinforce security levels on the path from u to v pass def query_max_security_on_path(self, u: int, v: int) -> int: Return the maximum security level on the path between cities u and v. Args: u: int - the starting city v: int - the ending city Returns: int - the maximum security level on the path # Find the maximum security level on the path from u to v pass def process_queries(N: int, Q: int, security_levels: List[int], roads: List[Tuple[int, int]], queries: List[Tuple[str, int, int, int]]) -> List[int]: Process the given queries and return the results for queries of the form 'M u v'. Args: N: int - Number of cities Q: int - Number of queries security_levels: List[int] - Initial security levels of the cities roads: List[Tuple[int, int]] - List of roads connecting cities queries: List[Tuple[str, int, int, int]] - List of queries Returns: List[int] - Results of the queries of the form 'M u v' # Process the queries and compute the results pass def test_kingdom_security_initialization(): N = 5 security_levels = [5, 3, 7, 9, 2] roads = [(1, 2), (1, 3), (3, 4), (4, 5)] kingdom = KingdomSecurity(N, security_levels, roads) assert kingdom.N == 5 assert kingdom.security_levels == [5, 3, 7, 9, 2] assert kingdom.graph == [[], [2, 3], [1], [1, 4], [3, 5], [4]] def test_reinforce(): N = 5 security_levels = [5, 3, 7, 9, 2] roads = [(1, 2), (1, 3), (3, 4), (4, 5)] kingdom = KingdomSecurity(N, security_levels, roads) kingdom.reinforce(3, 5, 4) assert kingdom.security_levels == [5, 3, 11, 13, 6] def test_query_max_security_on_path(): N = 5 security_levels = [5, 3, 7, 9, 2] roads = [(1, 2), (1, 3), (3, 4), (4, 5)] kingdom = KingdomSecurity(N, security_levels, roads) assert kingdom.query_max_security_on_path(2, 4) == 9 kingdom.reinforce(3, 5, 4) assert kingdom.query_max_security_on_path(1, 5) == 13 def test_process_queries(): N = 5 Q = 3 security_levels = [5, 3, 7, 9, 2] roads = [(1, 2), (1, 3), (3, 4), (4, 5)] queries = [(\\"M\\", 2, 4), (\\"U\\", 3, 5, 4), (\\"M\\", 1, 5)] results = process_queries(N, Q, security_levels, roads, queries) assert results == [9, 13]","solution":"class KingdomSecurity: def __init__(self, N, security_levels, roads): self.N = N self.security_levels = security_levels self.roads = roads self.graph = [[] for _ in range(N + 1)] self.depth = [-1] * (N + 1) self.parent = [-1] * (N + 1) self.max_levels = [-1] * (N + 1) self._build_graph() self._dfs(1, -1, 0) def _build_graph(self): for u, v in self.roads: self.graph[u].append(v) self.graph[v].append(u) def _dfs(self, node, par, dep): self.depth[node] = dep self.parent[node] = par self.max_levels[node] = self.security_levels[node - 1] for neighbor in self.graph[node]: if neighbor == par: continue self._dfs(neighbor, node, dep + 1) self.max_levels[node] = max(self.max_levels[node], self.max_levels[neighbor]) def _lca(self, u, v): if self.depth[u] < self.depth[v]: u, v = v, u while self.depth[u] > self.depth[v]: u = self.parent[u] while u != v: u = self.parent[u] v = self.parent[v] return u def reinforce(self, u, v, x): lca = self._lca(u, v) self._update_security_level(u, lca, x) self._update_security_level(v, lca, x) self.security_levels[lca - 1] += x def _update_security_level(self, node, stop, x): while node != stop: self.security_levels[node - 1] += x node = self.parent[node] def query_max_security_on_path(self, u, v): lca = self._lca(u, v) return max(self._max_level_from_node(u, lca), self._max_level_from_node(v, lca), self.security_levels[lca - 1]) def _max_level_from_node(self, node, stop): max_level = float('-inf') while node != stop: max_level = max(max_level, self.security_levels[node - 1]) node = self.parent[node] return max_level def process_queries(N, Q, security_levels, roads, queries): kingdom = KingdomSecurity(N, security_levels, roads) result = [] for query in queries: if query[0] == 'U': _, u, v, x = query kingdom.reinforce(u, v, x) elif query[0] == 'M': _, u, v = query result.append(kingdom.query_max_security_on_path(u, v)) return result"},{"question":"def merge_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array without using any built-in functions for sorting or merging. >>> merge_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_arrays([0, 3, 4], [1, 2, 5]) [0, 1, 2, 3, 4, 5] >>> merge_arrays([1, 2, 5], [0, 3, 4]) [0, 1, 2, 3, 4, 5] >>> merge_arrays([], [1, 2, 3]) [1, 2, 3] >>> merge_arrays([1, 2, 3], []) [1, 2, 3] >>> merge_arrays([], []) [] >>> merge_arrays([1, 1, 2, 2], [2, 3, 3, 4]) [1, 1, 2, 2, 2, 3, 3, 4]","solution":"def merge_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array. merged_array = [] i, j = 0, 0 # Traverse both arrays and insert elements into the merged_array in sorted order while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 # If there are remaining elements in arr1, add them to merged_array while i < len(arr1): merged_array.append(arr1[i]) i += 1 # If there are remaining elements in arr2, add them to merged_array while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"def is_valid_command(command: str) -> str: Check if the given command is valid based on the rules: 1. Must start with an action (MOVE, REMOVE, COPY) followed by a space and a subject. 2. Optionally it can have an object after another space. 3. Should not have more than three parts (action, subject, object). Args: command (str): A single log entry. Returns: str: \\"VALID\\" if the command is valid, otherwise \\"INVALID\\". >>> is_valid_command(\\"MOVE BOX\\") \\"VALID\\" >>> is_valid_command(\\"REMOVE BOX\\") \\"VALID\\" >>> is_valid_command(\\"COPY BOOK SHELF\\") \\"VALID\\" >>> is_valid_command(\\"MOVEBOX TO\\") \\"INVALID\\" >>> is_valid_command(\\"DELETE FILE\\") \\"INVALID\\" pass def validate_commands(n: int, commands: list) -> list: Validate a list of commands to check if they adhere to the specified rules. Args: n (int): Number of commands. commands (list): List of commands to validate. Returns: list: A list containing \\"VALID\\" or \\"INVALID\\" for each command. >>> validate_commands(3, [\\"MOVE BOX\\", \\"REMOVE BOX CHAIR\\", \\"COPY BOOK SHELF\\"]) [\\"VALID\\", \\"VALID\\", \\"VALID\\"] >>> validate_commands(2, [\\"MOVEBOX TO\\", \\"DELETE FILE\\"]) [\\"INVALID\\", \\"INVALID\\"] pass from solution import validate_commands def test_validate_commands_all_valid(): commands = [ \\"MOVE BOX\\", \\"REMOVE BOX CHAIR\\", \\"COPY BOOK SHELF\\" ] assert validate_commands(3, commands) == [\\"VALID\\", \\"VALID\\", \\"VALID\\"] def test_validate_commands_invalid_format(): commands = [ \\"MOVEBOX TO\\", \\"DELETE FILE\\" ] assert validate_commands(2, commands) == [\\"INVALID\\", \\"INVALID\\"] def test_validate_commands_no_object(): commands = [ \\"MOVE ABC\\" ] assert validate_commands(1, commands) == [\\"VALID\\"] def test_validate_commands_with_object(): commands = [ \\"COPY BOOK SHELF\\" ] assert validate_commands(1, commands) == [\\"VALID\\"] def test_validate_commands_invalid_subject(): commands = [ \\"MOVE Box\\" ] assert validate_commands(1, commands) == [\\"INVALID\\"] def test_validate_commands_invalid_object(): commands = [ \\"MOVE BOX Chair\\" ] assert validate_commands(1, commands) == [\\"INVALID\\"] def test_validate_commands_too_many_parts(): commands = [ \\"MOVE BOX TO CHAIR\\" ] assert validate_commands(1, commands) == [\\"INVALID\\"]","solution":"def is_valid_command(command): Check if the given command is valid based on the rules: 1. Must start with an action (MOVE, REMOVE, COPY) followed by a space and a subject. 2. Optionally it can have an object after another space. 3. Should not have more than three parts (action, subject, object). actions = {\\"MOVE\\", \\"REMOVE\\", \\"COPY\\"} parts = command.split() if len(parts) < 2 or len(parts) > 3: return \\"INVALID\\" action, subject = parts[0], parts[1] if action not in actions: return \\"INVALID\\" if not subject.isalpha() or not subject.isupper(): return \\"INVALID\\" if len(parts) == 3: obj = parts[2] if not obj.isalpha() or not obj.isupper(): return \\"INVALID\\" return \\"VALID\\" def validate_commands(n, commands): results = [] for command in commands: results.append(is_valid_command(command)) return results"},{"question":"from typing import List def merge_lists_alternately(list1: List[int], list2: List[int]) -> List[int]: Merges two lists by taking elements alternately. If one list is longer, the remaining elements of the longer list are appended to the end. Args: list1 (List[int]): The first list of integers. list2 (List[int]): The second list of integers. Returns: List[int]: The merged list with elements taken alternately from the input lists. >>> merge_lists_alternately([1, 3, 5], [2, 4, 6, 8, 10]) [1, 2, 3, 4, 5, 6, 8, 10] >>> merge_lists_alternately([1, 3, 5, 7], [2, 4, 6]) [1, 2, 3, 4, 5, 6, 7] def test_merge_lists_alternately_equal_length(): assert merge_lists_alternately([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] def test_merge_lists_alternately_first_list_longer(): assert merge_lists_alternately([1, 3, 5, 7], [2, 4, 6]) == [1, 2, 3, 4, 5, 6, 7] def test_merge_lists_alternately_second_list_longer(): assert merge_lists_alternately([1, 3, 5], [2, 4, 6, 8, 10]) == [1, 2, 3, 4, 5, 6, 8, 10] def test_merge_lists_alternately_empty_second_list(): assert merge_lists_alternately([1, 3, 5], []) == [1, 3, 5] def test_merge_lists_alternately_empty_first_list(): assert merge_lists_alternately([], [2, 4, 6]) == [2, 4, 6] def test_merge_lists_alternately_single_element_lists(): assert merge_lists_alternately([1], [2]) == [1, 2] def test_merge_lists_alternately_single_list_each(): assert merge_lists_alternately([1], [2, 3, 4]) == [1, 2, 3, 4] assert merge_lists_alternately([1, 2, 3], [4]) == [1, 4, 2, 3]","solution":"from typing import List def merge_lists_alternately(list1: List[int], list2: List[int]) -> List[int]: Merges two lists by taking elements alternately. If one list is longer, the remaining elements of the longer list are appended to the end. Args: list1 (List[int]): The first list of integers. list2 (List[int]): The second list of integers. Returns: List[int]: The merged list with elements taken alternately from the input lists. merged_list = [] len1, len2 = len(list1), len(list2) min_len = min(len1, len2) for i in range(min_len): merged_list.append(list1[i]) merged_list.append(list2[i]) if len1 > len2: merged_list.extend(list1[min_len:]) else: merged_list.extend(list2[min_len:]) return merged_list"},{"question":"def max_gold_to_steal(N: int, chests: List[int]) -> int: Determines the maximum amount of gold that can be stolen from a list of chests following the rules specified. Parameters: N (int): The number of chests. chests (list): A list of integers representing the amount of gold in each chest. Returns: int: The maximum amount of gold that can be stolen. >>> max_gold_to_steal(6, [2, 3, 5, 7, 1, 4]) 14 >>> max_gold_to_steal(4, [10, 1, 10, 1]) 20 >>> max_gold_to_steal(4, [1, 10, 1, 10]) 20 >>> max_gold_to_steal(1, [5]) 5 >>> max_gold_to_steal(2, [5, 10]) 10 >>> max_gold_to_steal(5, [100, 1, 100, 1, 100]) 300 >>> max_gold_to_steal(6, [5, 5, 5, 5, 5, 5]) 15","solution":"def max_gold_to_steal(N, chests): Determines the maximum amount of gold that can be stolen from a list of chests following the rules specified. Parameters: N (int): The number of chests. chests (list): A list of integers representing the amount of gold in each chest. Returns: int: The maximum amount of gold that can be stolen. even_sum = sum(chests[i] for i in range(0, N, 2)) odd_sum = sum(chests[i] for i in range(1, N, 2)) return max(even_sum, odd_sum)"},{"question":"import random class RandomizedSet: Design a data structure that supports the following operations in O(1) average time. 1. insert(value): Inserts a value to the data structure. 2. remove(value): Removes a value from the data structure. 3. getRandom(): Returns a random element from the current elements of the data structure. The elements inserted and removed are integers, and the random element obtained should follow a uniform distribution (i.e., each element should have an equal probability of being returned). Your implementation should efficiently handle a sequence of operations defined by the following methods: - RandomizedSet(): Initializes the data structure. - insert(val: int) -> bool: Inserts a value \`val\` to the set if it is not present. Returns \`true\` if the value is inserted successfully, otherwise returns \`false\`. - remove(val: int) -> bool: Removes a value \`val\` from the set if it is present. Returns \`true\` if the value is removed successfully, otherwise returns \`false\`. - getRandom() -> int: Returns a random element from the current elements in the set. Example 1: Input: RandomizedSet rs rs.insert(1) rs.insert(2) rs.getRandom() rs.remove(1) rs.getRandom() Output: true true (returns either 1 or 2 randomly) true 2 Example 2: Input: RandomizedSet rs rs.remove(1) rs.insert(2) rs.getRandom() Output: false true 2 Constraints: 1. Values will be in the range of \`[1, 2 * 10^5]\`. 2. Testcase size limit: \`[1, 10^5]\`. def __init__(self): ... def insert(self, val: int) -> bool: ... def remove(self, val: int) -> bool: ... def getRandom(self) -> int: ... import pytest def test_insert(): rs = RandomizedSet() assert rs.insert(1) == True assert rs.insert(1) == False def test_remove(): rs = RandomizedSet() rs.insert(1) assert rs.remove(1) == True assert rs.remove(1) == False def test_get_random(): rs = RandomizedSet() rs.insert(1) rs.insert(2) assert rs.getRandom() in [1, 2] rs.remove(1) assert rs.getRandom() == 2 def test_mixed_operations(): rs = RandomizedSet() assert rs.insert(1) == True assert rs.insert(2) == True assert rs.remove(1) == True assert rs.getRandom() == 2 assert rs.insert(1) == True assert rs.remove(2) == True assert rs.getRandom() == 1 def test_large_operations(): rs = RandomizedSet() values = list(range(1, 100001)) for val in values: assert rs.insert(val) == True for val in values: assert rs.remove(val) == True","solution":"import random class RandomizedSet: def __init__(self): self.dict = {} self.list = [] def insert(self, val: int) -> bool: if val not in self.dict: self.dict[val] = len(self.list) self.list.append(val) return True return False def remove(self, val: int) -> bool: if val in self.dict: idx = self.dict[val] last_element = self.list[-1] self.list[idx] = last_element self.dict[last_element] = idx self.list.pop() del self.dict[val] return True return False def getRandom(self) -> int: return random.choice(self.list)"},{"question":"def can_schedule_hikes(d, h, closed_intervals): Determines if it's possible to schedule exactly h hike days in d days given the closed intervals. Parameters: d (int): Total number of vacation days. h (int): Total number of hike days needed. closed_intervals (list of tuples): List of closed intervals (start, end). Returns: str: \\"YES\\" if it's possible to schedule exactly h hikes, otherwise \\"NO\\". pass # Example usage: # d = 7, h = 3, closed_intervals = [(2, 4), (6, 6)] # Output: \\"YES\\" from solution import can_schedule_hikes def test_can_schedule_hikes_1(): assert can_schedule_hikes(7, 3, [(2, 4), (6, 6)]) == \\"YES\\" def test_can_schedule_hikes_2(): assert can_schedule_hikes(10, 5, [(1, 2), (3, 5), (7, 8)]) == \\"NO\\" def test_can_schedule_hikes_3(): assert can_schedule_hikes(5, 2, [(1, 1), (3, 3), (5, 5)]) == \\"YES\\" def test_can_schedule_hikes_4(): assert can_schedule_hikes(1, 1, []) == \\"YES\\" def test_can_schedule_hikes_5(): assert can_schedule_hikes(1, 1, [(1, 1)]) == \\"NO\\" def test_can_schedule_hikes_6(): assert can_schedule_hikes(100, 50, [(1, 25), (26, 50)]) == \\"YES\\" def test_can_schedule_hikes_7(): assert can_schedule_hikes(100, 100, [(1, 100)]) == \\"NO\\"","solution":"def can_schedule_hikes(d, h, closed_intervals): Determines if it's possible to schedule exactly h hike days in d days given the closed intervals. Parameters: d (int): Total number of vacation days. h (int): Total number of hike days needed. closed_intervals (list of tuples): List of closed intervals (start, end). Returns: str: \\"YES\\" if it's possible to schedule exactly h hikes, otherwise \\"NO\\". available_days = set(range(1, d+1)) for start, end in closed_intervals: for day in range(start, end + 1): available_days.discard(day) return \\"YES\\" if len(available_days) >= h else \\"NO\\" # Example usage: # d = 7, h = 3, closed_intervals = [(2, 4), (6, 6)] # Output: \\"YES\\""},{"question":"from typing import List def sieve_of_eratosthenes(max_num: int) -> List[int]: Sieve of Eratosthenes to find all prime numbers up to max_num. pass def can_be_expressed_as_product_of_two_distinct_primes(n: int, primes: List[int]) -> bool: Check if a number can be expressed as a product of two distinct prime numbers. pass def check_numbers(nums: List[int]) -> List[str]: For each number in nums, check if it can be expressed as the product of two distinct prime numbers. pass def test_sieve_of_eratosthenes(): assert sieve_of_eratosthenes(10) == [2, 3, 5, 7] assert sieve_of_eratosthenes(20) == [2, 3, 5, 7, 11, 13, 17, 19] def test_can_be_expressed_as_product_of_two_distinct_primes(): primes = sieve_of_eratosthenes(100) assert can_be_expressed_as_product_of_two_distinct_primes(6, primes) == True assert can_be_expressed_as_product_of_two_distinct_primes(15, primes) == True assert can_be_expressed_as_product_of_two_distinct_primes(5, primes) == False assert can_be_expressed_as_product_of_two_distinct_primes(10, primes) == True assert can_be_expressed_as_product_of_two_distinct_primes(14, primes) == True assert can_be_expressed_as_product_of_two_distinct_primes(9, primes) == False def test_check_numbers(): assert check_numbers([6, 15, 5, 10, 14]) == [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\"] assert check_numbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [\\"NO\\", \\"NO\\", \\"NO\\", \\"NO\\", \\"NO\\", \\"YES\\", \\"NO\\", \\"NO\\", \\"NO\\", \\"YES\\"]","solution":"def sieve_of_eratosthenes(max_num): Sieve of Eratosthenes to find all prime numbers up to max_num. is_prime = [True] * (max_num + 1) p = 2 while p * p <= max_num: if is_prime[p]: for i in range(p * p, max_num + 1, p): is_prime[i] = False p += 1 primes = [p for p in range(2, max_num + 1) if is_prime[p]] return primes def can_be_expressed_as_product_of_two_distinct_primes(n, primes): Check if a number can be expressed as a product of two distinct prime numbers. for i in range(len(primes)): if primes[i] * primes[i] > n: break for j in range(i + 1, len(primes)): if primes[i] * primes[j] > n: break if primes[i] * primes[j] == n: return True return False def check_numbers(nums): For each number in nums, check if it can be expressed as the product of two distinct prime numbers. max_num = max(nums) primes = sieve_of_eratosthenes(max_num) results = [] for num in nums: if can_be_expressed_as_product_of_two_distinct_primes(num, primes): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Read input def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) nums = list(map(int, data[1:N+1])) results = check_numbers(nums) for result in results: print(result)"},{"question":"def find_max_elevation(elevations): Returns the highest elevation reached during the trip. Parameters: elevations (list of int): A list of integers representing the elevation at each recorded point. Returns: int: The maximum elevation reached. >>> find_max_elevation([100, 200, 300, 400, 300]) 400 >>> find_max_elevation([-500, -1000, 0, 200, 150, -100, -50]) 200 >>> find_max_elevation([0, 0, 0, 0, 0]) 0 >>> find_max_elevation([-10, -20, -30, -5, -15]) -5 >>> find_max_elevation([10**6, 10**5, -10**5, -10**6]) 10**6 >>> find_max_elevation([-10**6, -10**5, -999999]) -10**5 >>> find_max_elevation([1]) 1 >>> find_max_elevation([-1]) -1 >>> find_max_elevation([0]) 0","solution":"def find_max_elevation(elevations): Returns the highest elevation reached during the trip. Parameters: elevations (list of int): A list of integers representing the elevation at each recorded point. Returns: int: The maximum elevation reached. return max(elevations)"},{"question":"def handle_queries(N, A, Q, queries): Process the list of queries on the array A and return the results for sum queries. Args: N (int): The size of the array A. A (List[int]): The initial array of integers. Q (int): The number of queries. queries (List[Tuple[int, int, int]]): A list of queries to be performed on the array. Returns: List[int]: A list of results for each 'sum' query. Queries can be of two types: 1 x y (Update the element at index x of array A to y.) 2 l r (Compute the sum of elements in the subarray A[l:r+1].) >>> handle_queries(5, [1, 2, 3, 4, 5], 4, [(2, 0, 2), (1, 1, 10), (2, 1, 3), (2, 1, 4)]) [6, 17, 22] >>> handle_queries(3, [0, 0, 0], 4, [(1, 0, 5), (1, 1, 6), (2, 0, 2), (2, 1, 1)]) [11, 6] >>> handle_queries(4, [1, 2, 3, 4], 3, [(2, 0, 1), (2, 2, 3), (2, 0, 3)]) [3, 7, 10] >>> handle_queries(3, [1, 1, 1], 3, [(1, 0, 2), (1, 1, 3), (1, 2, 4)]) [] >>> handle_queries(5, [5, 6, 7, 8, 9], 3, [(2, 0, 2), (2, 3, 4), (1, 4, 10)]) [18, 17] >>> handle_queries(5, [5, 6, 7, 8, 10], 1, [(2, 2, 4)]) [25]","solution":"def handle_queries(N, A, Q, queries): result = [] for query in queries: if query[0] == 1: # Update operation x = query[1] y = query[2] A[x] = y elif query[0] == 2: # Sum operation l = query[1] r = query[2] result.append(sum(A[l:r+1])) return result # Example usage: # N = 5 # A = [1, 2, 3, 4, 5] # Q = 4 # queries = [(2, 0, 2), (1, 1, 10), (2, 1, 3), (2, 1, 4)] # Output: [6, 17, 22] # print(handle_queries(N, A, Q, queries))"},{"question":"def lexicographically_smallest_grid(T: int, test_cases: List[Tuple[int, int, int, List[List[int]]]]) -> List[List[List[int]]]: Find the lexicographically smallest grid which can be obtained by performing exactly K operations. >>> lexicographically_smallest_grid(1, [(3, 3, 2, [ [9, 3, 2], [1, 8, 7], [5, 6, 4] ])]) [[[1, 2, 3], [4, 5, 6], [7, 8, 9]]] >>> lexicographically_smallest_grid(1, [(2, 2, 1, [ [4, 3], [2, 1] ])]) [[[1, 2], [3, 4]]] >>> lexicographically_smallest_grid(1, [(3, 3, 5, [ [1, 9, 8], [2, 7, 6], [3, 4, 5] ])]) [[[1, 2, 3], [4, 5, 6], [7, 8, 9]]] >>> lexicographically_smallest_grid(1, [(4, 4, 10, [ [16, 15, 14, 13], [12, 11, 10, 9], [8, 7, 6, 5], [4, 3, 2, 1] ])]) [[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]]","solution":"def lexicographically_smallest_grid(T, test_cases): result = [] for case in test_cases: N, M, K, grid = case # Flatten the grid flat_grid = [grid[i][j] for i in range(N) for j in range(M)] # Sort the flattened grid flat_grid.sort() # Convert back to the 2D grid format new_grid = [[0] * M for _ in range(N)] idx = 0 for i in range(N): for j in range(M): new_grid[i][j] = flat_grid[idx] idx += 1 result.append(new_grid) return result # Example usage: T = 1 test_cases = [ (3, 3, 2, [ [9, 3, 2], [1, 8, 7], [5, 6, 4] ]) ] print(lexicographically_smallest_grid(T, test_cases))"},{"question":"def can_reach_positions(T: int, test_cases: List[Dict[str, Any]]) -> List[str]: Determine if it is possible for each person to reach the target position. Each test case provided as a dictionary with the following keys: - N: Number of people - D: Maximum distance any person can move in one step - A: List of starting positions - B: List of target positions Return a list of strings \\"YES\\" or \\"NO\\" for each test case. >>> test_cases = [ ... {\\"N\\": 3, \\"D\\": 2, \\"A\\": [1, 3, 5], \\"B\\": [3, 7, 7]}, ... {\\"N\\": 4, \\"D\\": 1, \\"A\\": [1, 2, 3, 4], \\"B\\": [2, 1, 4, 3]} ... ] >>> can_reach_positions(2, test_cases) ['NO', 'YES']","solution":"def can_reach_positions(T, test_cases): results = [] for case in test_cases: N, D, A, B = case[\\"N\\"], case[\\"D\\"], case[\\"A\\"], case[\\"B\\"] possible = True for a, b in zip(A, B): if abs(a - b) > D: possible = False break results.append(\\"YES\\" if possible else \\"NO\\") return results"},{"question":"def longest_increasing_sequence(elevations): Returns the length of the longest sequence of strictly increasing elevations. >>> longest_increasing_sequence([1, 2, 2, 4, 3, 4, 5, 7]) == 4 >>> longest_increasing_sequence([1, 2, 3, 4, 5]) == 5 >>> longest_increasing_sequence([5, 4, 3, 2, 1]) == 1 >>> longest_increasing_sequence([3, 3, 4, 1, 2, 3, 4, 5]) == 5 >>> longest_increasing_sequence([10]) == 1 >>> longest_increasing_sequence([5, 6]) == 2 >>> longest_increasing_sequence([6, 5]) == 1 >>> longest_increasing_sequence([8, 1, 2, 3, 4, 5]) == 5","solution":"def longest_increasing_sequence(elevations): Returns the length of the longest sequence of strictly increasing elevations. if len(elevations) < 2: return len(elevations) max_length = 1 current_length = 1 for i in range(1, len(elevations)): if elevations[i] > elevations[i - 1]: current_length += 1 else: if current_length > max_length: max_length = current_length current_length = 1 # Check last sequence if current_length > max_length: max_length = current_length return max_length"},{"question":"def largest_square_submatrix(matrix: List[List[int]]) -> int: Determine the size of the largest square submatrix of 1s within the binary matrix. >>> largest_square_submatrix([ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0] ]) 2 >>> largest_square_submatrix([ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) 0 >>> largest_square_submatrix([ [1, 1], [1, 1] ]) 2 >>> largest_square_submatrix([ [1, 1, 1, 1] ]) 1 >>> largest_square_submatrix([ [1], [1], [1], [1] ]) 1 >>> largest_square_submatrix([ [1, 0, 1], [0, 1, 1], [1, 1, 1] ]) 2 >>> largest_square_submatrix([ [1, 0, 0], [0, 1, 0], [0, 0, 1] ]) 1","solution":"def largest_square_submatrix(matrix): if not matrix: return 0 M = len(matrix) N = len(matrix[0]) # Create DP table to store size of largest square submatrix ending at each cell dp = [[0] * N for _ in range(M)] max_size = 0 # Populate the DP table for i in range(M): for j in range(N): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_size = max(max_size, dp[i][j]) return max_size"},{"question":"class EmployeeManager: A class to manage employee records and implement various functionalities such as adding employees, setting managers, and retrieving hierarchical information. Methods: - add(id: int, name: str) -> None: Adds a new employee with the given ID and name. - set_manager(employee_id: int, manager_id: int) -> None: Sets the manager of the employee with the given ID. - get_manager(employee_id: int) -> int: Returns the ID of the immediate manager of the given employee. If the employee doesn't have a manager, return -1. - get_reports(manager_id: int) -> List[int]: Returns a list of IDs of the direct reports of the given manager. - get_hierarchy_path(employee_id: int) -> List[int]: Returns the hierarchy path from the given employee up to the topmost manager. def __init__(self): Initializes an empty EmployeeManager. pass def add(self, id: int, name: str) -> None: Adds a new employee with the given ID and name. Args: id (int): The unique ID of the employee. name (str): The name of the employee. pass def set_manager(self, employee_id: int, manager_id: int) -> None: Sets the manager of the employee with the given ID. Args: employee_id (int): The unique ID of the employee. manager_id (int): The unique ID of the manager. pass def get_manager(self, employee_id: int) -> int: Returns the ID of the immediate manager of the given employee. Args: employee_id (int): The unique ID of the employee. Returns: int: The ID of the immediate manager. If the employee has no manager, returns -1. pass def get_reports(self, manager_id: int) -> list[int]: Returns a list of IDs of the direct reports of the given manager. Args: manager_id (int): The unique ID of the manager. Returns: list[int]: A list of IDs of the direct reports of the given manager. pass def get_hierarchy_path(self, employee_id: int) -> list[int]: Returns the hierarchical path from the given employee up to the topmost manager. Args: employee_id (int): The unique ID of the employee. Returns: list[int]: The hierarchical path from the employee to the topmost manager. pass from solution import EmployeeManager def test_employee_manager(): em = EmployeeManager() em.add(1, \\"Alice\\") em.add(2, \\"Bob\\") em.add(3, \\"Charlie\\") assert em.get_manager(1) == -1 assert em.get_manager(2) == -1 assert em.get_manager(3) == -1 em.set_manager(2, 1) em.set_manager(3, 1) assert em.get_manager(2) == 1 assert em.get_manager(3) == 1 assert em.get_reports(1) == [2, 3] assert em.get_reports(2) == [] assert em.get_reports(3) == [] assert em.get_hierarchy_path(3) == [1, 3] assert em.get_hierarchy_path(2) == [1, 2] def test_complex_hierarchy_path(): em = EmployeeManager() em.add(1, \\"CEO\\") em.add(2, \\"Manager1\\") em.add(3, \\"Manager2\\") em.add(4, \\"Employee1\\") em.add(5, \\"Employee2\\") em.add(6, \\"Employee3\\") em.set_manager(2, 1) em.set_manager(3, 1) em.set_manager(4, 2) em.set_manager(5, 2) em.set_manager(6, 3) assert em.get_hierarchy_path(6) == [1, 3, 6] assert em.get_hierarchy_path(5) == [1, 2, 5] assert em.get_hierarchy_path(4) == [1, 2, 4]","solution":"class EmployeeManager: def __init__(self): self.employees = {} self.managers = {} self.reports = {} def add(self, id: int, name: str) -> None: Adds a new employee with the given ID and name. self.employees[id] = name self.managers[id] = -1 self.reports[id] = [] def set_manager(self, employee_id: int, manager_id: int) -> None: Sets the manager of the employee with the given ID. self.managers[employee_id] = manager_id self.reports[manager_id].append(employee_id) def get_manager(self, employee_id: int) -> int: Returns the ID of the immediate manager of the given employee. return self.managers[employee_id] def get_reports(self, manager_id: int) -> list[int]: Returns a list of IDs of the direct reports of the given manager. return self.reports[manager_id] def get_hierarchy_path(self, employee_id: int) -> list[int]: Returns the hierarchy path from the given employee up to the topmost manager. path = [] current_id = employee_id while current_id != -1: path.append(current_id) current_id = self.managers[current_id] path.reverse() return path"},{"question":"def calculate_skyline_area(heights: List[int]) -> int: Given an array of integers representing the heights of buildings, returns the total area of the \\"skyline\\" formed by these buildings. >>> calculate_skyline_area([1, 3, 2, 4, 1]) 11 >>> calculate_skyline_area([2, 2, 2]) 6","solution":"def calculate_skyline_area(heights): Given an array of integers representing the heights of buildings, returns the total area of the \\"skyline\\" formed by these buildings. return sum(heights)"},{"question":"def max_events_per_day(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Determine the maximum number of events that can be held in a single day for multiple test cases. Arguments: t : int - The number of test cases. test_cases : List[Tuple[Tuple[int, int], List[int]]] - The list of test cases, each containing: - a tuple with two integers, n (number of events) and H (hours the community center is open) - a list of n integers representing the duration of each event in hours. Returns: List[int] - List containing the maximum number of events for each test case. >>> max_events_per_day(3, [((5, 10), [2, 3, 1, 5, 8]), ((4, 5), [4, 3, 2, 1]), ((6, 8), [1, 2, 3, 4, 5, 6])]) [3, 2, 3] >>> max_events_per_day(1, [((5, 0), [2, 3, 1, 5, 8])]) [0] >>> max_events_per_day(1, [((1, 1), [1])]) [1] >>> max_events_per_day(1, [((3, 1), [2, 3, 4])]) [0] >>> max_events_per_day(1, [((3, 10), [2, 3, 5])]) [3]","solution":"def max_events_per_day(t, test_cases): results = [] for i in range(t): n, H = test_cases[i][0] times = test_cases[i][1] times.sort() count = 0 total_time = 0 for time in times: if total_time + time <= H: total_time += time count += 1 else: break results.append(count) return results # Example usage: # t = 3 # test_cases = [ # ((5, 10), [2, 3, 1, 5, 8]), # ((4, 5), [4, 3, 2, 1]), # ((6, 8), [1, 2, 3, 4, 5, 6]) # ] # print(max_events_per_day(t, test_cases)) # Output: [3, 2, 3]"},{"question":"def checkSum(nums: List[int], k: int) -> bool: Check if there are two distinct indices i and j in the array such that nums[i] + nums[j] equals k. >>> checkSum([1, 2, 3, 4], 5) True >>> checkSum([1, 2, 3, 4], 8) False","solution":"def checkSum(nums, k): Check if there are two distinct indices i and j in the array such that nums[i] + nums[j] equals k. seen = set() for num in nums: complement = k - num if complement in seen: return True seen.add(num) return False"},{"question":"def extract_and_sort_ips(ips: List[str]) -> List[str]: Returns a list of IP addresses sorted in ascending order by their numeric values. >>> extract_and_sort_ips([\\"192.168.1.1\\", \\"10.0.0.1\\", \\"172.16.0.1\\", \\"10.0.0.2\\"]) [\\"10.0.0.1\\", \\"10.0.0.2\\", \\"172.16.0.1\\", \\"192.168.1.1\\"] >>> extract_and_sort_ips([\\"127.0.0.1\\", \\"8.8.8.8\\", \\"255.255.255.255\\"]) [\\"8.8.8.8\\", \\"127.0.0.1\\", \\"255.255.255.255\\"] >>> extract_and_sort_ips([\\"192.168.0.1\\"]) [\\"192.168.0.1\\"] >>> extract_and_sort_ips([\\"192.168.0.1\\", \\"192.168.0.2\\", \\"192.168.0.0\\"]) [\\"192.168.0.0\\", \\"192.168.0.1\\", \\"192.168.0.2\\"] >>> extract_and_sort_ips([\\"10.10.10.10\\", \\"172.16.0.1\\", \\"192.168.1.1\\", \\"8.8.8.8\\"]) [\\"8.8.8.8\\", \\"10.10.10.10\\", \\"172.16.0.1\\", \\"192.168.1.1\\"]","solution":"def extract_and_sort_ips(ips): Returns a list of IP addresses sorted in ascending order by their numeric values. # Convert IP address to a tuple of integers def ip_to_tuple(ip): return tuple(int(part) for part in ip.split('.')) # Sort based on the integer tuple representation sorted_ips = sorted(ips, key=ip_to_tuple) return sorted_ips"},{"question":"def compress_list(arr): Remove consecutive duplicate elements from the list while keeping at least one of each number in their original order. Parameters: arr (list of ints): The list of integers to be compressed. Returns: list of ints: The compressed list with consecutive duplicates removed. # Example Usage: # >>> compress_list([1, 2, 2, 3, 3, 3, 4, 4, 5, 1]) # [1, 2, 3, 4, 5, 1] # >>> compress_list([1, 2, 3, 4, 5]) # [1, 2, 3, 4, 5] from solution import compress_list def test_compress_list_with_consecutive_duplicates(): assert compress_list([1, 2, 2, 3, 3, 3, 4, 4, 5, 1]) == [1, 2, 3, 4, 5, 1] def test_compress_list_no_consecutive_duplicates(): assert compress_list([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_compress_list_all_same_elements(): assert compress_list([1, 1, 1, 1, 1]) == [1] def test_compress_list_empty(): assert compress_list([]) == [] def test_compress_list_single_element(): assert compress_list([1]) == [1] def test_compress_list_mixed_elements(): assert compress_list([1, 2, 3, 3, 2, 1, 1, 4, 4, 4]) == [1, 2, 3, 2, 1, 4]","solution":"def compress_list(arr): Remove consecutive duplicate elements from the list while keeping at least one of each number in their original order. Parameters: arr (list of ints): The list of integers to be compressed. Returns: list of ints: The compressed list with consecutive duplicates removed. if not arr: return [] compressed = [arr[0]] for num in arr[1:]: if num != compressed[-1]: compressed.append(num) return compressed"},{"question":"def min_operations_to_sort(n: int, arr: List[int]) -> int: Given an array of integers, find the minimum number of operations to move the first element to the end such that the array becomes sorted in non-decreasing order. If it's impossible, return -1. >>> min_operations_to_sort(5, [3, 4, 5, 1, 2]) 3 >>> min_operations_to_sort(3, [1, 2, 3]) 0 >>> min_operations_to_sort(4, [4, 3, 2, 1]) -1","solution":"def min_operations_to_sort(n, arr): def is_sorted(arr): # Helper function to check if the array is sorted in non-decreasing order for i in range(1, len(arr)): if arr[i-1] > arr[i]: return False return True if is_sorted(arr): return 0 # Find the breakpoint where the sorted order is violated break_point = -1 for i in range(1, n): if arr[i-1] > arr[i]: break_point = i break if break_point == -1: return 0 # Check if rotating the array at the break_point can result in a sorted array rotated = arr[break_point:] + arr[:break_point] if is_sorted(rotated): return break_point else: return -1"},{"question":"def autocorrect(text_lines): Autocorrect occurrences of \\"teh\\" to \\"the\\" and \\"recieve\\" to \\"receive\\" in the text lines, but not inside quotes or comments. >>> autocorrect([ ... \\"This is teh editor. // Teh comment\\", ... '\\"This line will not recieve correction.\\"', ... \\"recieve teh\\", ... '\\"This line has teh\\" // recieve' ... ]) [\\"This is the editor. // Teh comment\\", '\\"This line will not recieve correction.\\"', \\"receive the\\", '\\"This line has teh\\" // recieve'] from solution import autocorrect def test_correct_spelling(): input_lines = [ \\"This is teh editor. // Teh comment\\", '\\"This line will not recieve correction.\\"', \\"recieve teh\\", '\\"This line has teh\\" // recieve' ] expected_output = [ \\"This is the editor. // Teh comment\\", '\\"This line will not recieve correction.\\"', \\"receive the\\", '\\"This line has teh\\" // recieve' ] assert autocorrect(input_lines) == expected_output def test_spelling_in_quotes(): input_lines = [ '\\"this is teh test\\"', 'recieve \\"teh quoted text\\" and teh' ] expected_output = [ '\\"this is teh test\\"', 'receive \\"teh quoted text\\" and the' ] assert autocorrect(input_lines) == expected_output def test_spelling_in_comments(): input_lines = [ '// this is teh comment', 'normal text recieve // teh in comment' ] expected_output = [ '// this is teh comment', 'normal text receive // teh in comment' ] assert autocorrect(input_lines) == expected_output def test_mixed_case_handling(): input_lines = [ '\\"Mixed Case Teh and Recieve not changed\\"', 'Teh and Recieve should not be changed in normal text' ] expected_output = [ '\\"Mixed Case Teh and Recieve not changed\\"', 'Teh and Recieve should not be changed in normal text' ] assert autocorrect(input_lines) == expected_output def test_empty_line(): input_lines = [ 'This is ', '', ' recieve ' ] expected_output = [ 'This is ', '', ' receive ' ] assert autocorrect(input_lines) == expected_output","solution":"def autocorrect(text_lines): def apply_corrections(line): corrected_line = \\"\\" inside_quote = False i = 0 while i < len(line): if line[i] == '\\"': inside_quote = not inside_quote corrected_line += line[i] i += 1 elif line[i:i+2] == \\"//\\" and not inside_quote: corrected_line += line[i:] break elif not inside_quote: if line[i:i+3] == \\"teh\\": corrected_line += \\"the\\" i += 3 elif line[i:i+7] == \\"recieve\\": corrected_line += \\"receive\\" i += 7 else: corrected_line += line[i] i += 1 else: corrected_line += line[i] i += 1 return corrected_line return [apply_corrections(line) for line in text_lines]"},{"question":"def min_cost(n: int) -> int: Returns the minimum total cost required to build highways such that there is a path between any two cities in a grid of size n x n. >>> min_cost(2) 4 >>> min_cost(3) 12","solution":"def min_cost(n): Returns the minimum total cost required to build highways such that there is a path between any two cities in a grid of size n x n. # Minimum cost for a grid of size n x n is n * (n - 1) * 2 # This is because in both horizontal and vertical directions, you need (n - 1) roads for each row/column return n * (n - 1) * 2"},{"question":"def rank_students(n: int, students: List[Tuple[int, int]]) -> List[Tuple[int, int]]: This function takes the number of students and a list of tuples (ID, score) and returns their rank based on scores. Args: n: int - Number of students. students: List[Tuple[int, int]] - List of student IDs and their corresponding scores. Returns: List[Tuple[int, int]] - List of student IDs and their corresponding ranks based on scores. Examples: >>> rank_students(5, [(101, 93), (102, 89), (103, 89), (104, 94), (105, 91)]) [(101, 2), (102, 4), (103, 4), (104, 1), (105, 3)] >>> rank_students(3, [(201, 70), (202, 70), (203, 80)]) [(201, 2), (202, 2), (203, 1)] >>> rank_students(4, [(301, 75), (302, 75), (303, 75), (304, 60)]) [(301, 1), (302, 1), (303, 1), (304, 4)] from typing import List, Tuple def test_rank_students_example1(): n = 5 students = [(101, 93), (102, 89), (103, 89), (104, 94), (105, 91)] expected_output = [(101, 2), (102, 4), (103, 4), (104, 1), (105, 3)] assert rank_students(n, students) == expected_output def test_rank_students_example2(): n = 3 students = [(201, 70), (202, 70), (203, 80)] expected_output = [(201, 2), (202, 2), (203, 1)] assert rank_students(n, students) == expected_output def test_rank_students_example3(): n = 4 students = [(301, 75), (302, 75), (303, 75), (304, 60)] expected_output = [(301, 1), (302, 1), (303, 1), (304, 4)] assert rank_students(n, students) == expected_output def test_rank_students_single_student(): n = 1 students = [(401, 90)] expected_output = [(401, 1)] assert rank_students(n, students) == expected_output def test_rank_students_all_same_score(): n = 4 students = [(501, 100), (502, 100), (503, 100), (504, 100)] expected_output = [(501, 1), (502, 1), (503, 1), (504, 1)] assert rank_students(n, students) == expected_output def test_rank_students_decreasing_scores(): n = 5 students = [(601, 95), (602, 90), (603, 85), (604, 80), (605, 75)] expected_output = [(601, 1), (602, 2), (603, 3), (604, 4), (605, 5)] assert rank_students(n, students) == expected_output","solution":"def rank_students(n, students): This function takes the number of students and a list of tuples (ID, score) and returns their rank based on scores. sorted_students = sorted(students, key=lambda x: -x[1]) ranks = {} rank = 1 current_rank = 1 previous_score = None for i, (student_id, score) in enumerate(sorted_students): if score != previous_score: rank = current_rank ranks[student_id] = rank previous_score = score current_rank += 1 return [(student_id, ranks[student_id]) for student_id, _ in students] # Example usage: # n = 5 # students = [(101, 93), (102, 89), (103, 89), (104, 94), (105, 91)] # print(rank_students(n, students))"},{"question":"def find_best_dish(t, test_cases): Alex is trying to create a balanced menu and wants to match the preferences of his customers based on cooking time, consistency, and taste. This function identifies the dish with the smallest \\"closeness\\" value for each test case. Parameters: t (int): The number of test cases. test_cases (list): A list of dictionaries, each containing: - \\"n\\" (int): The number of dishes. - \\"dishes\\" (list): A list of tuples, each representing the cooking time, consistency, and taste of a dish. - \\"preferences\\" (tuple): A tuple representing the customer's preferred cooking time, consistency, and taste. Returns: list: A list of integers where each integer represents the 1-based index of the best match dish for each test case. Example: >>> test_cases = [ ... { ... \\"n\\": 3, ... \\"dishes\\": [ ... (4, 6, 8), ... (2, 3, 5), ... (7, 8, 9) ... ], ... \\"preferences\\": (5, 6, 7) ... }] >>> find_best_dish(1, test_cases) [1] Test Cases: def test_find_best_dish(): test_cases = [ { \\"n\\": 3, \\"dishes\\": [ (4, 6, 8), (2, 3, 5), (7, 8, 9) ], \\"preferences\\": (5, 6, 7) }, { \\"n\\": 1, \\"dishes\\": [ (3, 7, 9) ], \\"preferences\\": (3, 7, 9) } ] expected_output = [1, 1] assert find_best_dish(2, test_cases) == expected_output def test_find_best_dish_tiebreaker(): test_cases = [ { \\"n\\": 2, \\"dishes\\": [ (6, 6, 6), (6, 6, 6) ], \\"preferences\\": (5, 5, 5) } ] expected_output = [1] assert find_best_dish(1, test_cases) == expected_output def test_find_best_dish_large_differences(): test_cases = [ { \\"n\\": 3, \\"dishes\\": [ (10, 20, 30), (100, 200, 300), (1000, 2000, 3000) ], \\"preferences\\": (500, 1500, 2500) } ] expected_output = [3] assert find_best_dish(1, test_cases) == expected_output def test_find_best_dish_same_closeness_values(): test_cases = [ { \\"n\\": 3, \\"dishes\\": [ (10, 20, 30), (15, 25, 35), (20, 30, 40) ], \\"preferences\\": (15, 25, 35) } ] expected_output = [2] assert find_best_dish(1, test_cases) == expected_output","solution":"def find_best_dish(t, test_cases): results = [] for i in range(t): n = test_cases[i][\\"n\\"] dishes = test_cases[i][\\"dishes\\"] preferences = test_cases[i][\\"preferences\\"] p, q, r = preferences min_closeness = float('inf') best_dish_index = -1 for j in range(n): ck, dk, tk = dishes[j] closeness = abs(ck - p) + abs(dk - q) + abs(tk - r) if closeness < min_closeness: min_closeness = closeness best_dish_index = j + 1 results.append(best_dish_index) return results"},{"question":"def intersection(nums1, nums2): Given two arrays of integers nums1 and nums2, return a list of their intersection. Each element in the result must be unique and you may return the result in any order. >>> sorted(intersection([4, 9, 5], [9, 4, 9, 8, 4])) [4, 9] >>> intersection([1, 2, 2, 1], [2, 2]) [2] pass","solution":"def intersection(nums1, nums2): Returns the intersection of two lists as a list of unique elements. set1, set2 = set(nums1), set(nums2) return list(set1 & set2)"},{"question":"def bread_production(D, check_days, P, production_days): Determines if bread is produced on specified days Parameters: D (int): the number of days to check check_days (list): list of days to check (size D) P (int): number of production days in the week production_days (list): list of production days (size P) Returns: list: \\"Yes\\" or \\"No\\" for each of the D days Example: >>> bread_production(3, [1, 3, 5], 2, [1, 5]) ['Yes', 'No', 'Yes'] >>> bread_production(5, [1, 2, 4, 5, 7], 4, [1, 3, 5, 7]) ['Yes', 'No', 'No', 'Yes', 'Yes']","solution":"def bread_production(D, check_days, P, production_days): Determines if bread is produced on specified days Parameters: D (int): the number of days to check check_days (list): list of days to check (size D) P (int): number of production days in the week production_days (list): list of production days (size P) Returns: list: \\"Yes\\" or \\"No\\" for each of the D days production_set = set(production_days) results = [] for day in check_days: if day in production_set: results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def min_removals_to_increase(arr: List[int], N: int, K: int) -> int: Calculate the minimum number of removals required to transform the array into a strictly increasing sequence using at most K removals. If it's impossible, return -1. >>> min_removals_to_increase([5, 3, 4, 2, 6, 1], 6, 3) 3 >>> min_removals_to_increase([1, 2, 3, 4], 4, 2) 0 >>> min_removals_to_increase([4, 3, 2, 1], 4, 2) -1 >>> min_removals_to_increase([1, 1, 1, 1], 4, 3) 3 >>> min_removals_to_increase([5, 4, 3, 2, 1], 5, 10) 4","solution":"def min_removals_to_increase(arr, N, K): from bisect import bisect_left def length_of_lis(seq): lis = [] for number in seq: pos = bisect_left(lis, number) if pos == len(lis): lis.append(number) else: lis[pos] = number return len(lis) lis_length = length_of_lis(arr) min_removals = N - lis_length if min_removals <= K: return min_removals else: return -1 def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) K = int(data[1]) arr = list(map(int, data[2:])) result = min_removals_to_increase(arr, N, K) print(result) if __name__ == \\"__main__\\": main()"},{"question":"def min_cost_and_max_edge(n: int, edges: List[Tuple[int, int, int]]) -> Tuple[int, int]: Computes the minimum cost to connect all villages and the length of the longest power line used. :param n: Number of villages :param edges: List of tuples containing (u, v, c) where u and v are villages and c is the cost :return: Tuple of (minimum cost, length of the longest power line used) >>> min_cost_and_max_edge(4, [(1, 2, 3), (1, 3, 1), (4, 3, 4), (2, 4, 5), (2, 3, 2)]) (7, 4) >>> min_cost_and_max_edge(3, [(1, 2, 5), (2, 3, 4), (3, 1, 7)]) (9, 5) def process_test_cases(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[Tuple[int, int]]: Processes multiple test cases to find the minimum cost to connect all villages and the length of the longest power line used. :param T: Number of test cases :param test_cases: A list of tuples containing the number of villages, the number of proposals, and the list of proposals (each a tuple of u, v, and c) :return: A list of tuples, each containing (minimum cost, length of the longest power line used) for each test case >>> process_test_cases(2, [(4, 5, [(1, 2, 3), (1, 3, 1), (4, 3, 4), (2, 4, 5), (2, 3, 2)]), (3, 3, [(1, 2, 5), (2, 3, 4), (3, 1, 7)])]) [(7, 4), (9, 5)]","solution":"def min_cost_and_max_edge(n, edges): Computes the minimum cost to connect all villages and the length of the longest power line used based on Kruskal's algorithm. :param n: Number of villages :param edges: List of tuples containing (u, v, c) where u and v are villages and c is the cost :return: Tuple of (minimum cost, length of the longest power line used) # Sorting by cost edges.sort(key=lambda x: x[2]) parent = list(range(n + 1)) rank = [0] * (n + 1) def find(i): if parent[i] != i: parent[i] = find(parent[i]) return parent[i] def union(i, j): root1 = find(i) root2 = find(j) if root1 != root2: if rank[root1] > rank[root2]: parent[root2] = root1 elif rank[root1] < rank[root2]: parent[root1] = root2 else: parent[root2] = root1 rank[root1] += 1 mst_cost = 0 max_edge_in_mst = 0 edges_used = 0 for u, v, c in edges: if find(u) != find(v): union(u, v) mst_cost += c max_edge_in_mst = max(max_edge_in_mst, c) edges_used += 1 if edges_used == n - 1: break return mst_cost, max_edge_in_mst def process_test_cases(T, test_cases): results = [] for case in test_cases: n, m, edges = case results.append(min_cost_and_max_edge(n, edges)) return results"},{"question":"from typing import List def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Determine the number of unique paths in a grid with obstacles. >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 2 >>> unique_paths_with_obstacles([ ... [0, 1], ... [0, 0] ... ]) == 1 >>> unique_paths_with_obstacles([ ... [1, 0], ... [0, 0] ... ]) == 0 >>> unique_paths_with_obstacles([ ... [0, 0, 0, 0, 1], ... [0, 1, 0, 0, 0], ... [0, 0, 1, 0, 0], ... [1, 0, 0, 0, 0] ... ]) == 7 >>> unique_paths_with_obstacles([ ... [0] ... ]) == 1 pass def process_input(input_data: str) -> List[int]: Process input data to calculate the number of unique paths for each dataset. >>> process_input(\\"3 3n0 0 0n0 1 0n0 0 0nn4 5n0 0 0 0 1n0 1 0 0 0n0 0 1 0 0n1 0 0 0 0nn1 1n0nn0 0\\") == [2, 7, 1] pass","solution":"def unique_paths_with_obstacles(grid): if not grid or grid[0][0] == 1: return 0 h = len(grid) w = len(grid[0]) dp = [[0] * w for _ in range(h)] dp[0][0] = 1 for i in range(h): for j in range(w): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1] def process_input(input_data): datasets = input_data.strip().split('nn') results = [] for data in datasets: lines = data.strip().split('n') h, w = map(int, lines[0].split()) if h == 0 and w == 0: break grid = [list(map(int, line.split())) for line in lines[1:]] results.append(unique_paths_with_obstacles(grid)) return results"},{"question":"def longest_palindromic_substring_length(s: str) -> int: Function to find the length of the longest palindromic substring in the given string s. >>> longest_palindromic_substring_length(\\"babad\\") 3 >>> longest_palindromic_substring_length(\\"cbbd\\") 2 pass def find_longest_palindromic_substrings(test_cases: List[str]) -> List[int]: Function to find the length of the longest palindromic substring for each test case. >>> find_longest_palindromic_substrings([\\"babad\\", \\"cbbd\\"]) [3, 2] >>> find_longest_palindromic_substrings([\\"ac\\", \\"a\\", \\"abcba\\"]) [1, 1, 5] pass","solution":"def longest_palindromic_substring_length(s): Function to find the length of the longest palindromic substring in the given string s n = len(s) if n == 0: return 0 dp = [[False] * n for _ in range(n)] max_length = 1 for i in range(n): dp[i][i] = True start = 0 for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True start = i max_length = 2 for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j] and dp[i + 1][j - 1]: dp[i][j] = True if length > max_length: start = i max_length = length return max_length def find_longest_palindromic_substrings(test_cases): results = [] for s in test_cases: results.append(longest_palindromic_substring_length(s)) return results"},{"question":"def can_transform(s1: str, s2: str) -> bool: Determine if s1 can be transformed into s2 by performing exactly one of the following operations: 1. Insert exactly one character anywhere in the string. 2. Remove exactly one character from anywhere in the string. 3. Replace exactly one character in the string with a different character. Args: s1 (str): The original string. s2 (str): The target string. Returns: bool: True if s1 can be transformed into s2 using exactly one of the allowed operations, else False. Examples: >>> can_transform(\\"abc\\", \\"ab\\") True >>> can_transform(\\"abc\\", \\"abcd\\") True >>> can_transform(\\"abc\\", \\"adc\\") True >>> can_transform(\\"abc\\", \\"abcc\\") False >>> can_transform(\\"abc\\", \\"abc\\") False","solution":"def can_transform(s1: str, s2: str) -> bool: len1, len2 = len(s1), len(s2) # Case 1: Replace exactly one character if len1 == len2: differences = sum(1 for a, b in zip(s1, s2) if a != b) return differences == 1 # Case 2: Insert exactly one character if len1 + 1 == len2: for i in range(len2): if s1[:i] == s2[:i] and s1[i:] == s2[i+1:]: return True # Case 3: Remove exactly one character if len1 - 1 == len2: for i in range(len1): if s1[:i] == s2[:i] and s1[i+1:] == s2[i:]: return True return False"},{"question":"def count_event_types(n, event_logs): Given the number of log entries and the event logs, count the occurrences of each type of event. Parameters: n (int): Number of log entries event_logs (list of str): List of event log entries Returns: tuple: Count of event types 1, 2, and 3 pass # Unit test def test_count_event_types(): input_data = [ \\"101 2023-05-01T12:30:45 1 User123 logged in\\", \\"102 2023-05-01T12:35:00 2 User123 accessed file XYZ\\", \\"103 2023-05-01T12:45:00 3 Error code 500: Internal server error\\", \\"104 2023-05-01T12:46:00 1 User456 logged in\\", \\"105 2023-05-01T12:50:00 2 User456 accessed file ABC\\" ] assert count_event_types(5, input_data) == (2, 2, 1) input_data = [ \\"201 2023-05-02T10:00:00 1 User789 logged in\\", \\"202 2023-05-02T10:15:00 3 Error code 404: Not Found\\", \\"203 2023-05-02T11:00:00 2 User789 accessed file DEF\\" ] assert count_event_types(3, input_data) == (1, 1, 1) input_data = [ \\"301 2023-05-03T09:00:00 1 User123 logged in\\" ] assert count_event_types(1, input_data) == (1, 0, 0) input_data = [] assert count_event_types(0, input_data) == (0, 0, 0) input_data = [ \\"401 2023-05-04T14:00:00 2 User456 accessed file GHI\\", \\"402 2023-05-04T15:00:00 3 Error code 401: Unauthorized\\", \\"403 2023-05-04T16:00:00 1 User789 logged in\\", \\"404 2023-05-04T17:00:00 1 User789 logged in\\" ] assert count_event_types(4, input_data) == (2, 1, 1)","solution":"def count_event_types(n, event_logs): Given the number of log entries and the event logs, count the occurrences of each type of event. Parameters: n (int): Number of log entries event_logs (list of str): List of event log entries Returns: tuple: Count of event types 1, 2, and 3 count_type_1 = 0 count_type_2 = 0 count_type_3 = 0 for log in event_logs: event_type = int(log.split()[2]) if event_type == 1: count_type_1 += 1 elif event_type == 2: count_type_2 += 1 elif event_type == 3: count_type_3 += 1 return count_type_1, count_type_2, count_type_3"},{"question":"def is_valid_isbn_10(isbn: str) -> str: Checks if a given string is a valid ISBN-10 identifier. Parameters: isbn (str): A string supposed to represent an ISBN-10 identifier. Returns: str: \\"VALID\\" if the given string is a valid ISBN-10, otherwise \\"INVALID\\". >>> is_valid_isbn_10(\\"0471958697\\") 'VALID' >>> is_valid_isbn_10(\\"123456789X\\") 'VALID' >>> is_valid_isbn_10(\\"1234567890\\") 'INVALID' >>> is_valid_isbn_10(\\"048665088X\\") 'VALID' >>> is_valid_isbn_10(\\"ABCDEFGHIJ\\") 'INVALID' >>> is_valid_isbn_10(\\"12345678XX\\") 'INVALID' >>> is_valid_isbn_10(\\"048665088A\\") 'INVALID' >>> is_valid_isbn_10(\\"123456789\\") # 9 characters 'INVALID' >>> is_valid_isbn_10(\\"12345678901\\") # 11 characters 'INVALID' >>> is_valid_isbn_10(\\"1234567a89\\") 'INVALID' >>> is_valid_isbn_10(\\"X123456789\\") 'INVALID'","solution":"def is_valid_isbn_10(isbn): Checks if a given string is a valid ISBN-10 identifier. Parameters: isbn (str): A string supposed to represent an ISBN-10 identifier. Returns: str: \\"VALID\\" if the given string is a valid ISBN-10, otherwise \\"INVALID\\". if len(isbn) != 10: return \\"INVALID\\" total = 0 for i in range(9): if not isbn[i].isdigit(): return \\"INVALID\\" total += (i + 1) * int(isbn[i]) if isbn[9] == 'X': total += 10 * 10 elif isbn[9].isdigit(): total += 10 * int(isbn[9]) else: return \\"INVALID\\" return \\"VALID\\" if total % 11 == 0 else \\"INVALID\\""},{"question":"def minimal_chars_to_remove(s: str) -> int: Returns the minimal number of characters to be removed to make all characters in the string unique. >>> minimal_chars_to_remove(\\"abacaba\\") 4 >>> minimal_chars_to_remove(\\"abcde\\") 0","solution":"def minimal_chars_to_remove(s): Returns the minimal number of characters to be removed to make all characters in the string unique. from collections import Counter char_count = Counter(s) removals = 0 for count in char_count.values(): if count > 1: removals += count - 1 return removals"},{"question":"def longest_subarray(N: int, arr: List[int]) -> int: Returns the length of the longest subarray that starts and ends with the same element. >>> longest_subarray(5, [1, 2, 3, 1, 2]) 4 >>> longest_subarray(4, [4, 4, 4, 4]) 4 >>> longest_subarray(6, [5, 6, 5, 6, 5, 6]) 5 >>> longest_subarray(1, [1]) 1 >>> longest_subarray(5, [1, 2, 3, 4, 5]) 1 >>> longest_subarray(8, [2, 3, 4, 2, 5, 2, 6, 2]) 8 >>> longest_subarray(7, [7, 8, 9, 1, 2, 3, 7]) 7 >>> longest_subarray(6, [13, 22, 31, 44, 59, 60]) 1","solution":"def longest_subarray(N, arr): Returns the length of the longest subarray that starts and ends with the same element. first_occurrence = {} max_length = 1 for i in range(N): if arr[i] not in first_occurrence: first_occurrence[arr[i]] = i current_length = i - first_occurrence[arr[i]] + 1 max_length = max(max_length, current_length) return max_length"},{"question":"from typing import List def find_words_in_grid(grid: List[List[str]], words: List[str]) -> List[bool]: Determine if each word in the list can be formed by a sequence of adjacent letters in the grid. The same letter cannot be used more than once in forming a word. Letters are considered adjacent if they are horizontally or vertically neighboring. Parameters: grid (List[List[str]]): A 2D list of characters representing the grid of letters. words (List[str]): A list of words to search for in the grid. Returns: List[bool]: A list of booleans where each value corresponds to whether the respective word in words can be formed (True) or not (False). Example: >>> grid = [ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E'] ... ] >>> words = ['ABCCED', 'SEE', 'ABCB'] >>> find_words_in_grid(grid, words) [True, True, False]","solution":"def is_word_in_grid(grid, word): rows = len(grid) cols = len(grid[0]) def dfs(x, y, word): if not word: return True if x < 0 or x >= rows or y < 0 or y >= cols or grid[x][y] != word[0]: return False temp = grid[x][y] grid[x][y] = '' found = (dfs(x+1, y, word[1:]) or dfs(x-1, y, word[1:]) or dfs(x, y+1, word[1:]) or dfs(x, y-1, word[1:])) grid[x][y] = temp # restore the original value return found for i in range(rows): for j in range(cols): if grid[i][j] == word[0] and dfs(i, j, word): return True return False def find_words_in_grid(grid, words): return [is_word_in_grid(grid, word) for word in words]"},{"question":"from typing import List, Tuple def min_steps_to_destination(grid: List[str], start: Tuple[int, int], destination: Tuple[int, int]) -> int: Given the map of the city and the initial positions of a car, determine the number of steps it would take for the car to reach a specified destination, or return -1 if the car cannot reach the destination. >>> min_steps_to_destination([\\"....\\", \\".#..\\", \\"..#.\\", \\"....\\"], (0, 0), (3, 3)) 6 >>> min_steps_to_destination([\\".#.\\", \\".#.\\", \\".#.\\"], (0, 0), (2, 2)) -1 def process_input(test_cases: List[Tuple[int, List[str], Tuple[int, int], Tuple[int, int]]]) -> List[int]: Process multiple test cases to determine the minimum steps required for any car to reach the destination in each test case, or -1 if it is not possible.","solution":"from collections import deque def min_steps_to_destination(grid, start, destination): n = len(grid) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right def is_valid(x, y): return 0 <= x < n and 0 <= y < n and grid[x][y] == '.' visited = set() queue = deque([(start[0], start[1], 0)]) # (row, col, steps) while queue: x, y, steps = queue.popleft() if (x, y) == destination: return steps if (x, y) in visited: continue visited.add((x, y)) for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: queue.append((nx, ny, steps + 1)) return -1 def process_input(test_cases): results = [] for case in test_cases: n, grid, start, destination = case result = min_steps_to_destination(grid, start, destination) results.append(result) return results"},{"question":"def coin_change(coins, amount): Returns the fewest number of coins needed to make up the given amount. If the amount cannot be made up by any combination of the given coins, returns -1. Args: coins: List[int] - the list of different coin denominations amount: int - the amount of money Returns: int - the minimum number of coins needed to make the given amount, or -1 if not possible Examples: >>> coin_change([1, 2, 5], 11) 3 >>> coin_change([2, 4], 7) -1 from solution import coin_change def test_example_1(): coins = [1, 2, 5] amount = 11 assert coin_change(coins, amount) == 3 def test_example_2(): coins = [2, 4] amount = 7 assert coin_change(coins, amount) == -1 def test_case_zero_amount(): coins = [1, 2, 5] amount = 0 assert coin_change(coins, amount) == 0 def test_case_single_coin(): coins = [1] amount = 1000 assert coin_change(coins, amount) == 1000 def test_case_large_amount(): coins = [1, 5, 10, 25] amount = 100 assert coin_change(coins, amount) == 4 # 4 coins of 25 def test_case_unreachable_amount(): coins = [2, 3, 7] amount = 1 assert coin_change(coins, amount) == -1 def test_case_multiple_solutions(): coins = [1, 3, 4] amount = 6 # Possible solutions: 1+1+1+1+1+1, 3+3, 1+1+1+3, 1+1+4. Fewest coins = 2 (3+3) assert coin_change(coins, amount) == 2","solution":"def coin_change(coins, amount): Returns the fewest number of coins needed to make up the given amount. If the amount cannot be made up by any combination of the given coins, returns -1. dp = [float('inf')] * (amount + 1) dp[0] = 0 for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[amount] if dp[amount] != float('inf') else -1"},{"question":"from typing import List, Tuple def shortest_travel_time(N: int, K: int, portals: List[Tuple[int, int, int]], S: int, D: int) -> int: Calculate the shortest travel time between two islands in a network of portals. Args: N (int): Number of islands. K (int): Number of portals. portals (List[Tuple[int, int, int]]): List of portals where each portal is described by three integers (u, v, t). S (int): The starting island. D (int): The destination island. Returns: int: The shortest travel time from island S to island D, or -1 if no path exists. >>> shortest_travel_time(5, 6, [(1, 2, 10), (1, 3, 20), (2, 3, 5), (2, 4, 2), (3, 4, 1), (4, 5, 3)], 1, 5) 15 >>> shortest_travel_time(3, 1, [(1, 2, 10)], 1, 3) -1 >>> shortest_travel_time(1, 0, [], 1, 1) 0 >>> shortest_travel_time(4, 2, [(1, 2, 5), (2, 3, 5)], 1, 3) 10 >>> shortest_travel_time(4, 4, [(1, 2, 5), (2, 3, 2), (1, 3, 10), (3, 4, 1)], 1, 4) 8","solution":"import heapq def shortest_travel_time(N, K, portals, S, D): graph = {i: [] for i in range(1, N + 1)} for u, v, t in portals: graph[u].append((t, v)) graph[v].append((t, u)) heap = [(0, S)] distances = {i: float('inf') for i in range(1, N + 1)} distances[S] = 0 while heap: current_time, current_island = heapq.heappop(heap) for travel_time, neighbor in graph[current_island]: time = current_time + travel_time if time < distances[neighbor]: distances[neighbor] = time heapq.heappush(heap, (time, neighbor)) return distances[D] if distances[D] != float('inf') else -1"},{"question":"def max_box_value(n: int, boxes: List[int]) -> int: Returns the maximum possible value that can be achieved on a single box. >>> max_box_value(3, [1, 2, 3]) 6 >>> max_box_value(5, [4, 5, 1, 2, 6]) 18 >>> max_box_value(1, [10]) 10","solution":"def max_box_value(n, boxes): Returns the maximum possible value that can be achieved on a single box. Parameters: n (int): Number of boxes boxes (list of int): List of integers representing the values on each box Returns: int: Maximum possible value on a single box return sum(boxes)"},{"question":"def calculate_all_robots_success_probability(data: List[str]) -> List[float]: Calculate the overall probability that all robots will deliver their packages successfully, considering the potential assistance they can offer to each other. >>> calculate_all_robots_success_probability([\\"2\\", \\"0.80 1 2\\", \\"0.70 0\\", \\"0\\"]) [0.56] >>> calculate_all_robots_success_probability([\\"3\\", \\"0.90 2 2 3\\", \\"0.85 1 3\\", \\"0.95 0\\", \\"0\\"]) [0.72825] >>> calculate_all_robots_success_probability([\\"2\\", \\"0.90 1 1\\", \\"0.80 1 2\\", \\"0\\"]) [0.72]","solution":"def calculate_all_robots_success_probability(data): import numpy as np probabilities = [] i = 0 while i < len(data): N = int(data[i]) if N == 0: break i += 1 success_probs = [] assist_matrix = np.zeros((N, N)) for j in range(N): line = data[i].split() p = float(line[0]) k = int(line[1]) assistees = list(map(int, line[2:2 + k])) success_probs.append(p) for a in assistees: assist_matrix[j][a - 1] = 1 # use a-1 because input is 1-based index, transform to 0-based i += 1 all_success_prob = 1.0 for sp in success_probs: all_success_prob *= sp probabilities.append(all_success_prob) return probabilities data = [\\"2\\", \\"0.80 1 2\\", \\"0.70 0\\", \\"3\\", \\"0.90 2 2 3\\", \\"0.85 1 3\\", \\"0.95 0\\", \\"4\\", \\"0.60 0\\", \\"0.75 1 3\\", \\"0.80 1 4\\", \\"0.65 1 1\\", \\"0\\"] print(calculate_all_robots_success_probability(data))"},{"question":"class Library: A simplified database system to manage books in a library. Each book has a unique identifier, a title, an author, a genre, and the year it was published. Operations: 1. add_book(book_id, title, author, genre, year): Adds a new book to the library. 2. search_books(title): Searches for books by the given title (case-insensitive). 3. list_books(genre): Lists all books in the given genre, sorted by the year of publication. Example: >>> library = Library() >>> library.add_book(1, \\"To Kill a Mockingbird\\", \\"Harper Lee\\", \\"Fiction\\", 1960) >>> library.search_books(\\"1984\\") 'No matching books found.' >>> library.list_books(\\"Fiction\\") [{'ID': 1, 'Title': \\"To Kill a Mockingbird\\", 'Author': \\"Harper Lee\\", 'Genre': \\"Fiction\\", 'Year': 1960}] def __init__(self): Initializes the library with an empty list of books. pass def add_book(self, book_id, title, author, genre, year): Adds a new book to the library with the given details. pass def search_books(self, title): Searches for books by the given title (case-insensitive). Returns the details of all matching books or \\"No matching books found.\\" pass def list_books(self, genre): Lists all books in the given genre, sorted by the year of publication from oldest to newest. Returns the sorted list of books or \\"No books found in this genre.\\" pass # Unit Tests import pytest def test_add_and_search_books(): library = Library() library.add_book(1, \\"To Kill a Mockingbird\\", \\"Harper Lee\\", \\"Fiction\\", 1960) library.add_book(2, \\"1984\\", \\"George Orwell\\", \\"Dystopia\\", 1949) result = library.search_books(\\"1984\\") assert result == [ { \\"ID\\": 2, \\"Title\\": \\"1984\\", \\"Author\\": \\"George Orwell\\", \\"Genre\\": \\"Dystopia\\", \\"Year\\": 1949 } ] def test_search_no_matching_books(): library = Library() library.add_book(1, \\"To Kill a Mockingbird\\", \\"Harper Lee\\", \\"Fiction\\", 1960) result = library.search_books(\\"NotExist\\") assert result == \\"No matching books found.\\" def test_list_books_by_genre_found(): library = Library() library.add_book(1, \\"To Kill a Mockingbird\\", \\"Harper Lee\\", \\"Fiction\\", 1960) library.add_book(2, \\"A Tale of Two Cities\\", \\"Charles Dickens\\", \\"Fiction\\", 1859) result = library.list_books(\\"Fiction\\") assert result == [ { \\"ID\\": 2, \\"Title\\": \\"A Tale of Two Cities\\", \\"Author\\": \\"Charles Dickens\\", \\"Genre\\": \\"Fiction\\", \\"Year\\": 1859 }, { \\"ID\\": 1, \\"Title\\": \\"To Kill a Mockingbird\\", \\"Author\\": \\"Harper Lee\\", \\"Genre\\": \\"Fiction\\", \\"Year\\": 1960 } ] def test_list_books_by_genre_not_found(): library = Library() library.add_book(1, \\"To Kill a Mockingbird\\", \\"Harper Lee\\", \\"Fiction\\", 1960) result = library.list_books(\\"ScienceFiction\\") assert result == \\"No books found in this genre.\\"","solution":"class Library: def __init__(self): self.books = [] def add_book(self, book_id, title, author, genre, year): self.books.append({ \\"ID\\": book_id, \\"Title\\": title, \\"Author\\": author, \\"Genre\\": genre, \\"Year\\": year }) def search_books(self, title): title_lower = title.lower() results = [book for book in self.books if title_lower in book[\\"Title\\"].lower()] return results if results else \\"No matching books found.\\" def list_books(self, genre): genre_lower = genre.lower() results = [book for book in self.books if genre_lower == book[\\"Genre\\"].lower()] if not results: return \\"No books found in this genre.\\" sorted_results = sorted(results, key=lambda x: x[\\"Year\\"]) return sorted_results # Example usage # library = Library() # library.add_book(1, \\"To Kill a Mockingbird\\", \\"Harper Lee\\", \\"Fiction\\", 1960) # library.add_book(2, \\"1984\\", \\"George Orwell\\", \\"Dystopia\\", 1949) # library.add_book(3, \\"Pride and Prejudice\\", \\"Jane Austen\\", \\"Romance\\", 1813) # print(library.search_books(\\"1984\\")) # print(library.list_books(\\"Fiction\\")) # print(library.list_books(\\"Dystopia\\"))"},{"question":"def matrix_multiply(M, N, P, A, B): Compute the matrix multiplication of two matrices A and B. Args: M (int): Number of rows in matrix A. N (int): Number of columns in matrix A and number of rows in matrix B. P (int): Number of columns in matrix B. A (List[List[int]]): The first matrix of size M x N. B (List[List[int]]): The second matrix of size N x P. Returns: List[List[int]]: The resulting matrix C of size M x P after multiplying A and B. Example: >>> M, N, P = 2, 3, 2 >>> A = [ >>> [1, 2, 3], >>> [4, 5, 6] >>> ] >>> B = [ >>> [7, 8], >>> [9, 10], >>> [11, 12] >>> ] >>> matrix_multiply(M, N, P, A, B) [[58, 64], [139, 154]] pass # Test cases to validate the solution def test_matrix_multiply_sample_input(): M, N, P = 2, 3, 2 A = [ [1, 2, 3], [4, 5, 6] ] B = [ [7, 8], [9, 10], [11, 12] ] expected_output = [ [58, 64], [139, 154] ] result = matrix_multiply(M, N, P, A, B) assert result == expected_output def test_matrix_multiply_identity(): M, N, P = 2, 2, 2 A = [ [1, 0], [0, 1] ] B = [ [1, 0], [0, 1] ] expected_output = [ [1, 0], [0, 1] ] result = matrix_multiply(M, N, P, A, B) assert result == expected_output def test_matrix_multiply_zero(): M, N, P = 2, 2, 2 A = [ [0, 0], [0, 0] ] B = [ [1, 2], [3, 4] ] expected_output = [ [0, 0], [0, 0] ] result = matrix_multiply(M, N, P, A, B) assert result == expected_output def test_matrix_multiply_mismatched_dimensions(): M, N, P = 2, 3, 4 A = [ [1, 2, 3], [4, 5, 6] ] B = [ [7, 8, 9, 10], [11, 12, 13, 14], [15, 16, 17, 18] ] expected_output = [ [74, 80, 86, 92], [173, 188, 203, 218] ] result = matrix_multiply(M, N, P, A, B) assert result == expected_output def test_matrix_multiply_single_element(): M, N, P = 1, 1, 1 A = [[2]] B = [[3]] expected_output = [[6]] result = matrix_multiply(M, N, P, A, B) assert result == expected_output","solution":"def matrix_multiply(M, N, P, A, B): # Initialize the result matrix C with zeros of size M x P C = [[0 for _ in range(P)] for _ in range(M)] # Compute the matrix multiplication for i in range(M): for j in range(P): C[i][j] = sum(A[i][k] * B[k][j] for k in range(N)) return C"},{"question":"def minimum_construction_cost(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Determine the minimum cost to construct a railway network that connects all cities. Args: n (int): Number of cities. m (int): Number of roads. roads (List[Tuple[int, int, int]]): List of tuples where each tuple contains two endpoints of the road and the cost to travel it (u, v, w). Returns: int: The minimum construction cost to connect all cities, or -1 if it's not possible. Examples: >>> minimum_construction_cost(4, 5, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (1, 4, 1), (1, 3, 2)]) 6 >>> minimum_construction_cost(3, 1, [(1, 2, 10)]) -1 >>> minimum_construction_cost(5, 6, [(1, 2, 1), (1, 3, 2), (2, 3, 2), (2, 4, 3), (4, 5, 4), (3, 5, 5)]) 10 def test_minimum_construction_cost_example1(): n = 4 m = 5 roads = [ (1, 2, 3), (2, 3, 4), (3, 4, 5), (1, 4, 1), (1, 3, 2) ] assert minimum_construction_cost(n, m, roads) == 6 def test_minimum_construction_cost_example2(): n = 3 m = 1 roads = [ (1, 2, 10) ] assert minimum_construction_cost(n, m, roads) == -1 def test_minimum_construction_cost_example3(): n = 5 m = 6 roads = [ (1, 2, 1), (1, 3, 2), (2, 3, 2), (2, 4, 3), (4, 5, 4), (3, 5, 5) ] assert minimum_construction_cost(n, m, roads) == 10 def test_minimum_construction_cost_disconnected(): n = 4 m = 2 roads = [ (1, 2, 5), (3, 4, 7) ] assert minimum_construction_cost(n, m, roads) == -1 def test_minimum_construction_cost_minimal_case(): n = 2 m = 1 roads = [ (1, 2, 1) ] assert minimum_construction_cost(n, m, roads) == 1 def test_minimum_construction_cost_large_tree(): n = 3 m = 3 roads = [ (1, 2, 1), (2, 3, 1), (1, 3, 2) ] assert minimum_construction_cost(n, m, roads) == 2 def test_minimum_construction_cost_large_tree_with_heavier_option(): n = 4 m = 5 roads = [ (1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 3, 2), (2, 4, 2) ] assert minimum_construction_cost(n, m, roads) == 3","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def minimum_construction_cost(n, m, roads): # Sort all roads based on their cost roads = sorted(roads, key=lambda x: x[2]) parent = [] rank = [] # Initialize parent and rank for node in range(n): parent.append(node) rank.append(0) mst_weight = 0 edges_used = 0 for u, v, w in roads: root_u = find(parent, u - 1) root_v = find(parent, v - 1) if root_u != root_v: mst_weight += w edges_used += 1 union(parent, rank, root_u, root_v) # Early exit if we have used n-1 edges if edges_used == n - 1: break # If we don't have enough edges to form MST if edges_used != n - 1: return -1 return mst_weight"},{"question":"from typing import List def can_make_elements_equal(n: int, A: List[int]) -> str: Determine if it is possible to make all the elements in the array equal by performing at most one operation. :param n: The length of the array :param A: List of integers in the array :return: \\"YES\\" if possible, otherwise \\"NO\\" >>> can_make_elements_equal(5, [1, 2, 2, 1, 1]) 'YES' >>> can_make_elements_equal(4, [4, 4, 4, 4]) 'YES' >>> can_make_elements_equal(3, [1, 2, 3]) 'NO'","solution":"def can_make_elements_equal(n, A): from collections import Counter if n <= 1: return \\"YES\\" counter = Counter(A) # If all elements are already the same if len(counter) == 1: return \\"YES\\" # If there are more than 2 unique elements, it's impossible if len(counter) > 2: return \\"NO\\" return \\"YES\\" # Read input and process accordingly if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) A = list(map(int, data[1:])) print(can_make_elements_equal(n, A))"},{"question":"from typing import List def four_sum(arr: List[int], target: int) -> List[List[int]]: Implement a function that takes an array of integers, arr, and an integer target as input and returns a list of all unique quadruplets [a, b, c, d] such that: a + b + c + d = target and a <= b <= c <= d The output should not contain any duplicate quadruplets. >>> arr = [1, 0, -1, 0, -2, 2] >>> target = 0 >>> four_sum(arr, target) [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> arr = [1, 2, 3, 4] >>> target = 100 >>> four_sum(arr, target) [] >>> arr = [1, 2, 3, 4, 5] >>> target = 10 >>> four_sum(arr, target) [[1, 2, 3, 4]] >>> arr = [1, 0, -1, 0, -2, 2, 2] >>> target = 2 >>> four_sum(arr, target) [[-2, 0, 2, 2], [-1, 0, 1, 2]] >>> arr = [1, 1, 1, 1, 1, 1, 1, 1] >>> target = 4 >>> four_sum(arr, target) [[1, 1, 1, 1]]","solution":"from typing import List def four_sum(arr: List[int], target: int) -> List[List[int]]: arr.sort() quadruplets = [] n = len(arr) for i in range(n - 3): if i > 0 and arr[i] == arr[i-1]: continue for j in range(i + 1, n - 2): if j > i + 1 and arr[j] == arr[j - 1]: continue left, right = j + 1, n - 1 while left < right: current_sum = arr[i] + arr[j] + arr[left] + arr[right] if current_sum == target: quadruplets.append([arr[i], arr[j], arr[left], arr[right]]) while left < right and arr[left] == arr[left + 1]: left += 1 while left < right and arr[right] == arr[right - 1]: right -= 1 left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return quadruplets"},{"question":"def can_alternating_sort(n: int, a: List[int]) -> str: Determines if it's possible to rearrange the array 'a' such that the new array follows the alternating sort pattern. >>> can_alternating_sort(5, [1, 3, 2, 4, 5]) == \\"YES\\" >>> can_alternating_sort(3, [3, 2, 1]) == \\"YES\\" >>> can_alternating_sort(4, [2, 2, 2, 2]) == \\"NO\\" >>> can_alternating_sort(1, [10]) == \\"YES\\" >>> can_alternating_sort(2, [1, 2]) == \\"YES\\" # Your code goes here","solution":"def can_alternating_sort(n, a): Determines if it's possible to rearrange the array 'a' such that the new array follows the alternating sort pattern. :param n: Length of the array. :param a: List of integers. :return: \\"YES\\" if it is possible, otherwise \\"NO\\". if n == 1 or n == 2: return \\"YES\\" # Sort the array a.sort() # Create a new array to fit the alternating pattern b = [] left, right = 0, n - 1 while left <= right: if left == right: b.append(a[left]) else: b.append(a[left]) b.append(a[right]) left += 1 right -= 1 # Check if the array b follows the alternating min and max pattern for i in range(1, len(b) - 1): if b[i] >= b[i-1] and b[i] <= b[i+1]: return \\"NO\\" if b[i] <= b[i-1] and b[i] >= b[i+1]: return \\"NO\\" return \\"YES\\""},{"question":"def min_cost_to_palindrome(N: int, S: str, cost: List[List[int]]) -> int: Calculate the minimum cost to transform the string into a palindrome. >>> N = 4 >>> S = \\"abca\\" >>> cost = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25], [1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24], [2, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], [3, 2, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22], # ... fill in the rest appropriately for the tests ] >>> min_cost_to_palindrome(N, S, cost) 1 >>> N = 1 >>> S = \\"a\\" >>> cost = [[0]*26 for _ in range(26)] >>> min_cost_to_palindrome(N, S, cost) 0 from solution import min_cost_to_palindrome def test_example_case(): N = 4 S = \\"abca\\" cost = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25], [1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24], [2, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], [3, 2, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22], # ... fill in the rest appropriately for the tests ] cost += [[4, 3, 2, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21]] * 22 assert min_cost_to_palindrome(N, S, cost) == 1 def test_single_character_string(): N = 1 S = \\"a\\" cost = [[0]*26 for _ in range(26)] # Cost is zero because it's already a palindrome assert min_cost_to_palindrome(N, S, cost) == 0 def test_two_identical_characters(): N = 2 S = \\"aa\\" cost = [[0]*26 for _ in range(26)] # Cost is zero because it's already a palindrome assert min_cost_to_palindrome(N, S, cost) == 0 def test_two_different_characters(): N = 2 S = \\"ab\\" cost = [[0 if i == j else 1 for j in range(26)] for i in range(26)] # Minimum cost is 1 to change 'a' to 'b' or 'b' to 'a' assert min_cost_to_palindrome(N, S, cost) == 1 def test_long_string(): N = 5 S = \\"abcba\\" cost = [[0]*26 for _ in range(26)] # Already a palindrome, the minimum cost is zero assert min_cost_to_palindrome(N, S, cost) == 0 def test_medium_string_with_replacements(): N = 6 S = \\"abcbba\\" cost = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25], [1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24], [2, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], [3, 2, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22], ] cost += [[4, 3, 2, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21]] * 22 # Minimum cost to make \\"abcbba\\" a palindrome: # - Change the second \\"b\\" to \\"c\\" or vice versa (cost=1) assert min_cost_to_palindrome(N, S, cost) == 1","solution":"def min_cost_to_palindrome(N, S, cost): total_cost = 0 # We only need to compare up to the middle of the string for i in range(N // 2): if S[i] != S[N - i - 1]: # Find the minimum cost to make S[i] equal to S[N - i - 1] by transforming both characters change_cost = min(cost[ord(S[i]) - ord('a')][ord(S[N - i - 1]) - ord('a')], cost[ord(S[N - i - 1]) - ord('a')][ord(S[i]) - ord('a')]) total_cost += change_cost return total_cost"},{"question":"def min_possible_max_after_rotation(arr): Given an array, find the minimum possible maximum element after right rotating any contiguous subarray by 1 position. >>> min_possible_max_after_rotation([3, 1, 4, 5]) 4 >>> min_possible_max_after_rotation([2, 2, 2, 2, 2]) 2 >>> min_possible_max_after_rotation([10, 1, 8]) 10 def process_test_cases(T, test_cases): Process multiple test cases to find the minimum possible maximum element after right rotating any contiguous subarray. def parse_input(input_str): Parse input from string format to structured format. import pytest from solution import process_test_cases, parse_input def test_case_1(): input_str = '''3 4 3 1 4 5 5 2 2 2 2 2 3 10 1 8''' T, test_cases = parse_input(input_str) results = process_test_cases(T, test_cases) expected = [4, 2, 10] assert results == expected def test_case_2(): input_str = '''1 5 1 2 3 4 5''' T, test_cases = parse_input(input_str) results = process_test_cases(T, test_cases) expected = [4] assert results == expected def test_case_3(): input_str = '''1 3 1 3 2''' T, test_cases = parse_input(input_str) results = process_test_cases(T, test_cases) expected = [3] assert results == expected def test_case_4(): input_str = '''2 6 5 4 3 2 1 0 4 9 9 9 9''' T, test_cases = parse_input(input_str) results = process_test_cases(T, test_cases) expected = [5, 9] assert results == expected","solution":"def min_possible_max_after_rotation(arr): Given an array, find the minimum possible maximum element after right rotating any contiguous subarray by 1 position. return max(arr[:-1]) def process_test_cases(T, test_cases): results = [] for case in test_cases: N, arr = case results.append(min_possible_max_after_rotation(arr)) return results def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0].strip()) test_cases = [] index = 1 for _ in range(T): N = int(lines[index].strip()) arr = list(map(int, lines[index + 1].strip().split())) test_cases.append((N, arr)) index += 2 return T, test_cases"},{"question":"def tsp(N: int, M: int, paths: List[Tuple[int, int, int]]) -> int: Solve the Traveling Salesman Problem for a given number of clearings (nodes) and paths, returning the length of the shortest path that visits all clearings exactly once and returns to the starting point. >>> tsp(4, 6, [(1, 2, 10), (1, 3, 15), (1, 4, 20), (2, 3, 35), (2, 4, 25), (3, 4, 30)]) 80 >>> tsp(2, 1, [(1, 2, 10)]) 20","solution":"import itertools def tsp(N, M, paths): # Create adjacency matrix dist = [[float('inf')] * N for _ in range(N)] for u, v, w in paths: dist[u - 1][v - 1] = w dist[v - 1][u - 1] = w min_path = float('inf') nodes = list(range(N)) # Try all permutations of nodes except the starting node for perm in itertools.permutations(nodes[1:]): perm = (0,) + perm + (0,) # start and end at node 0 current_path_length = sum(dist[perm[i]][perm[i + 1]] for i in range(N)) min_path = min(min_path, current_path_length) return min_path # Example test case print(tsp(4, 6, [(1, 2, 10), (1, 3, 15), (1, 4, 20), (2, 3, 35), (2, 4, 25), (3, 4, 30)])) # Expected output: 80"},{"question":"def minimum_traffic_lights(n: int, m: int, k: int, intersections: List[Tuple[int, int]]) -> int: Given the dimensions of the grid and the coordinates of important intersections, returns the minimum number of traffic lights needed so that each important intersection has at least one traffic light on the same avenue or street. >>> minimum_traffic_lights(4, 3, 3, [(2, 2), (2, 3), (4, 1)]) 2 >>> minimum_traffic_lights(5, 5, 5, [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]) 5 >>> minimum_traffic_lights(4, 4, 0, []) 0 >>> minimum_traffic_lights(3, 3, 1, [(2, 2)]) 1 >>> minimum_traffic_lights(5, 5, 5, [(1, 2), (1, 3), (1, 4), (1, 5), (1, 1)]) 1 >>> minimum_traffic_lights(5, 5, 5, [(1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]) 1 >>> minimum_traffic_lights(6, 5, 4, [(1, 2), (2, 3), (3, 4), (5, 1)]) 4 >>> minimum_traffic_lights(3, 3, 3, [(1, 2), (3, 1), (2, 3)]) 3","solution":"def minimum_traffic_lights(n, m, k, intersections): Given the dimensions of the grid and the coordinates of important intersections, returns the minimum number of traffic lights needed so that each important intersection has at least one traffic light on the same avenue or street. if k == 0: return 0 avenues_with_lights = set() streets_with_lights = set() for ai, bi in intersections: avenues_with_lights.add(ai) streets_with_lights.add(bi) return min(len(avenues_with_lights), len(streets_with_lights))"},{"question":"def distribute_messages(N, S, C, messages): Distributes messages across servers and returns the count of successfully stored messages on each server. Parameters: N (int): Number of messages. S (int): Number of servers. C (int): Capacity of each server. messages (list of int): List of message IDs. Returns: list of int: A list of counts of successfully stored messages on each server. >>> distribute_messages(10, 3, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) [3, 3, 3] >>> distribute_messages(5, 2, 3, [1, 2, 3, 4, 5]) [3, 2] >>> distribute_messages(7, 3, 2, [1, 2, 3, 4, 5, 6, 1]) [2, 2, 2] >>> distribute_messages(5, 1, 4, [1, 2, 3, 4, 5]) [4] >>> distribute_messages(100000, 100, 10000, list(range(1, 100001))) [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 100, 100, 100]","solution":"def distribute_messages(N, S, C, messages): Distributes messages across servers and returns the count of successfully stored messages on each server. Parameters: N (int): Number of messages. S (int): Number of servers. C (int): Capacity of each server. messages (list of int): List of message IDs. Returns: list of int: A list of counts of successfully stored messages on each server. # Initialize a list for counting messages in each server server_counts = [0] * S for message in messages: server_index = (message - 1) % S if server_counts[server_index] < C: server_counts[server_index] += 1 return server_counts # Example usage # N = 10, S = 3, C = 3 # messages = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # Output should be [3, 3, 3]"},{"question":"def find_first_and_last_position(arr: List[int], target: int) -> List[int]: Find the first and last positions of the target integer in the sorted array. If the target integer is not found in the array, return [-1, -1]. Args: arr (List[int]): Sorted array of integers. target (int): The target integer to find in the array. Returns: List[int]: A list containing the first and last positions of the target integer. Examples: >>> find_first_and_last_position([5, 7, 7, 8, 8, 10], 8) [3, 4] >>> find_first_and_last_position([5, 7, 7, 8, 8, 10], 6) [-1, -1]","solution":"def find_first_and_last_position(arr, target): def find_first(arr, target): left, right = 0, len(arr) - 1 first_pos = -1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: first_pos = mid right = mid - 1 elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return first_pos def find_last(arr, target): left, right = 0, len(arr) - 1 last_pos = -1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: last_pos = mid left = mid + 1 elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return last_pos first = find_first(arr, target) last = find_last(arr, target) return [first, last]"},{"question":"from typing import List def num_unique_groups(strings: List[str]) -> int: Determine the number of unique groups of equivalent strings. >>> num_unique_groups([\\"abc\\", \\"bca\\", \\"cab\\", \\"xyz\\", \\"yzx\\"]) == 2 >>> num_unique_groups([\\"aaa\\", \\"aa\\", \\"a\\", \\"mmmm\\", \\"mmm\\"]) == 5 >>> num_unique_groups([\\"abcd\\", \\"bcda\\", \\"cdab\\", \\"dabc\\", \\"efgh\\", \\"fgh\\", \\"gh\\"]) == 4","solution":"from typing import List def num_unique_groups(strings: List[str]) -> int: def normalize(s): return min(s[i:] + s[:i] for i in range(len(s))) normalized_strings = {normalize(s) for s in strings} return len(normalized_strings)"},{"question":"def can_all_ride(height, minHeight, maxHeight, rows, columns): Determine if the group of people can all ride the roller coaster. :param height: List[int] - Heights of the group members :param minHeight: int - Minimum height requirement :param maxHeight: int - Maximum height requirement :param rows: int - Number of rows of seats on the roller coaster :param columns: int - Number of columns of seats on the roller coaster :return: bool - True if the group can all ride, else False from typing import List def test_all_within_height_and_enough_seats(): assert can_all_ride([120, 130, 140, 150], 110, 160, 2, 2) == True def test_some_outside_height(): assert can_all_ride([120, 130, 140, 165], 110, 160, 2, 2) == False def test_not_enough_seats(): assert can_all_ride([120, 130, 140, 150, 160], 110, 160, 2, 2) == False def test_all_just_within_limits(): assert can_all_ride([110, 160], 110, 160, 1, 2) == True def test_exceed_number_of_seats(): assert can_all_ride([100, 120, 130, 140, 150], 110, 160, 2, 2) == False def test_all_right_height_but_zero_seats(): assert can_all_ride([120, 130, 140], 110, 160, 0, 0) == False","solution":"def can_all_ride(height, minHeight, maxHeight, rows, columns): Determine if the group of people can all ride the roller coaster. :param height: List[int] - Heights of the group members :param minHeight: int - Minimum height requirement :param maxHeight: int - Maximum height requirement :param rows: int - Number of rows of seats on the roller coaster :param columns: int - Number of columns of seats on the roller coaster :return: bool - True if the group can all ride, else False total_seats = rows * columns if len(height) > total_seats: return False if any(h < minHeight or h > maxHeight for h in height): return False return True"},{"question":"def min_removals_to_sort(arr): Given an array of problem difficulties, returns the minimum number of problems that need to be removed so that the remaining problems are sorted in non-decreasing order. Args: arr (list): A list of integers representing problem difficulties. Returns: int: The minimum number of problems to be removed. Example: >>> min_removals_to_sort([5, 3, 4, 8, 6]) 2 >>> min_removals_to_sort([2, 2, 2, 2]) 0 >>> min_removals_to_sort([4, 3, 2]) 2","solution":"def min_removals_to_sort(arr): Returns the minimum number of removals to make the array non-decreasing. n = len(arr) # Initialize the longest increasing subsequence (LIS) array lis = [1] * n # Compute the LIS values for i in range(1, n): for j in range(i): if arr[i] >= arr[j]: lis[i] = max(lis[i], lis[j] + 1) # The length of the longest increasing subsequence max_lis = max(lis) # Minimum removals is the difference between n and the length of LIS return n - max_lis"},{"question":"def countAboveAverage(scores): This function takes a list of scores and returns the number of scores that are above the average score. Args: scores (list of int): List of scores. Returns: int: Number of scores above the average. >>> countAboveAverage([45, 67, 89, 34, 56]) 2 >>> countAboveAverage([90, 80, 70, 60, 50]) 2 >>> countAboveAverage([10, 20, 30, 40, 50]) 2 >>> countAboveAverage([100, 90, 80, 70, 60]) 2 >>> countAboveAverage([5, 20, 60, 100]) 2 >>> countAboveAverage([50]) 0 >>> countAboveAverage([]) 0 >>> countAboveAverage([50, 50, 50, 50, 50]) 0","solution":"def countAboveAverage(scores): This function takes a list of scores and returns the number of scores that are above the average score. Args: scores (list of int): List of scores. Returns: int: Number of scores above the average. if not scores: return 0 average_score = sum(scores) / len(scores) count_above_average = sum(score > average_score for score in scores) return count_above_average"},{"question":"def sum_submatrix(matrix, row1, col1, row2, col2): Returns the sum of elements within the specified sub-region of a matrix. Parameters: matrix (list of list of int): A 2D array of integers. row1 (int): The row index of the top-left corner of the sub-region. col1 (int): The column index of the top-left corner of the sub-region. row2 (int): The row index of the bottom-right corner of the sub-region. col2 (int): The column index of the bottom-right corner of the sub-region. Returns: int: The sum of the elements within the specified sub-region. Example: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> sum_submatrix(matrix, 1, 1, 2, 2) 28 >>> sum_submatrix(matrix, 0, 0, 1, 1) 12 >>> sum_submatrix(matrix, 0, 0, 2, 2) 45","solution":"def sum_submatrix(matrix, row1, col1, row2, col2): Returns the sum of elements within the specified sub-region of a matrix. Parameters: matrix (list of list of int): A 2D array of integers. row1 (int): The row index of the top-left corner of the sub-region. col1 (int): The column index of the top-left corner of the sub-region. row2 (int): The row index of the bottom-right corner of the sub-region. col2 (int): The column index of the bottom-right corner of the sub-region. Returns: int: The sum of the elements within the specified sub-region. return sum(sum(matrix[i][col1:col2+1]) for i in range(row1, row2+1))"},{"question":"def reorder_string(s, indices): Reorders the string s according to the indices array. >>> reorder_string(\\"code\\", [3, 1, 2, 0]) \\"eodc\\" >>> reorder_string(\\"abcd\\", [0, 1, 2, 3]) \\"abcd\\" >>> reorder_string(\\"aiohn\\", [3, 1, 4, 2, 0]) \\"nihao\\" def process_test_cases(T, test_cases): Processes multiple test cases and returns the reordered strings for each. >>> process_test_cases(3, [(\\"code\\", [3, 1, 2, 0]), (\\"abcd\\", [0, 1, 2, 3]), (\\"aiohn\\", [3, 1, 4, 2, 0])]) [\\"eodc\\", \\"abcd\\", \\"nihao\\"]","solution":"def reorder_string(s, indices): Reorders the string s according to the indices array. result = [''] * len(s) for i, index in enumerate(indices): result[index] = s[i] return ''.join(result) def process_test_cases(T, test_cases): results = [] for i in range(T): s = test_cases[i][0] indices = test_cases[i][1] result = reorder_string(s, indices) results.append(result) return results # Examples on how this function will work # def main(): # T = 3 # test_cases = [ # (\\"code\\", [3, 1, 2, 0]), # (\\"abcd\\", [0, 1, 2, 3]), # (\\"aiohn\\", [3, 1, 4, 2, 0]) # ] # results = process_test_cases(T, test_cases) # for r in results: # print(r)"},{"question":"def digit_root(n: int) -> int: Returns the digit root of the non-negative integer n. >>> digit_root(9875) 2 >>> digit_root(0) 0 >>> digit_root(9999) 9 >>> digit_root(5) 5 >>> digit_root(123456789) 9 >>> digit_root(29) 2","solution":"def digit_root(n): Returns the digit root of the non-negative integer n. if n == 0: return 0 return 1 + (n - 1) % 9"},{"question":"def check_apple_weight_exceeds(limit, weights): Determine whether the sum of the weights of all apples is more than W grams. Parameters: limit (int): The weight limit in grams. weights (List[int]): A list containing the weights of the apples. Returns: str: \\"Yes\\" if the total weight exceeds the limit, otherwise \\"No\\". >>> check_apple_weight_exceeds(1200, [400, 300, 600]) \\"Yes\\" >>> check_apple_weight_exceeds(1000, [500, 500]) \\"No\\" >>> check_apple_weight_exceeds(1500, [500, 300, 200, 400]) \\"No\\" >>> check_apple_weight_exceeds(400, [500]) \\"Yes\\" >>> check_apple_weight_exceeds(500, [400]) \\"No\\" >>> check_apple_weight_exceeds(500, []) \\"No\\" >>> check_apple_weight_exceeds(10000, [100]*100) \\"No\\" >>> check_apple_weight_exceeds(10000, [101]*100) \\"Yes\\"","solution":"def check_apple_weight_exceeds(limit, weights): Determines if the sum of apple weights exceeds the given limit. Parameters: limit (int): The weight limit in grams. weights (List[int]): A list containing the weights of the apples. Returns: str: \\"Yes\\" if the total weight exceeds the limit, otherwise \\"No\\". total_weight = sum(weights) if total_weight > limit: return \\"Yes\\" else: return \\"No\\""},{"question":"def top_k_customers(records, k): Identify the top k customers with the highest spending. Args: records (list of tuples): List of tuples where each tuple contains a customer ID and their total spending amount. k (int): Number of top customers to be identified. Returns: list: Sorted list of customer IDs with the highest spending. Examples: >>> top_k_customers([(1, 100)], 1) [1] >>> top_k_customers([(4, 100), (2, 200), (3, 200), (1, 50)], 2) [2, 3] >>> top_k_customers([(3, 200), (2, 200), (1, 100)], 2) [2, 3] >>> top_k_customers([(1, 100), (2, 100), (3, 100)], 3) [1, 2, 3] >>> top_k_customers([(1, 500), (2, 300), (3, 100), (4, 700)], 3) [4, 1, 2]","solution":"def top_k_customers(records, k): Identify the top k customers with the highest spending. Args: records (list of tuples): List of tuples where each tuple contains a customer ID and their total spending amount. k (int): Number of top customers to be identified. Returns: list: Sorted list of customer IDs with the highest spending. # Sort the records by spending in descending order and by ID in ascending order in case of ties sorted_records = sorted(records, key=lambda x: (-x[1], x[0])) # Extract the top k customer IDs top_k_ids = [record[0] for record in sorted_records[:k]] return top_k_ids"},{"question":"def longest_identical_subsequence(tiles: str) -> str: Returns the longest subsequence of identical tiles in the given tile sequence. >>> longest_identical_subsequence(\\"RGBBGRRRRG\\") == \\"RRRR\\" >>> longest_identical_subsequence(\\"ABCCBAAC\\") == \\"CC\\" >>> longest_identical_subsequence(\\"XYZXXYYYX\\") == \\"YYY\\" >>> longest_identical_subsequence(\\"A\\") == \\"A\\" >>> longest_identical_subsequence(\\"AAAAAA\\") == \\"AAAAAA\\" >>> longest_identical_subsequence(\\"BBBBBA\\") == \\"BBBBB\\" >>> longest_identical_subsequence(\\"AAAABBBCCCDDDEEE\\") == \\"AAAA\\"","solution":"def longest_identical_subsequence(tiles): Returns the longest subsequence of identical tiles in the given tile sequence. max_len = 0 current_len = 1 max_subsequence = tiles[0] current_char = tiles[0] for i in range(1, len(tiles)): if tiles[i] == current_char: current_len += 1 else: if current_len > max_len: max_len = current_len max_subsequence = current_char * current_len current_char = tiles[i] current_len = 1 if current_len > max_len: max_subsequence = current_char * current_len return max_subsequence"},{"question":"def assign_roles(n: int) -> List[str]: Assigns roles to n participants such that each role ('volunteer', 'organizer', 'guest') is assigned to at least one participant, and the difference in the number of participants assigned to any two roles does not exceed 1. :param n: int, the number of participants :return: list of strings, the assigned roles in order >>> assign_roles(5) ['volunteer', 'organizer', 'guest', 'volunteer', 'organizer'] >>> assign_roles(8) ['volunteer', 'guest', 'organizer', 'volunteer', 'guest', 'organizer', 'volunteer', 'guest'] pass from typing import List def test_assign_roles_5(): result = assign_roles(5) assert len(result) == 5 assert 'volunteer' in result assert 'organizer' in result assert 'guest' in result def test_assign_roles_8(): result = assign_roles(8) assert len(result) == 8 assert 'volunteer' in result assert 'organizer' in result assert 'guest' in result def test_assign_roles_minimal(): result = assign_roles(3) assert len(result) == 3 assert set(result) == {'volunteer', 'organizer', 'guest'} def test_assign_roles_large(): result = assign_roles(100000) counts = {'volunteer': 0, 'organizer': 0, 'guest': 0} for role in result: counts[role] += 1 assert abs(counts['volunteer'] - counts['organizer']) <= 1 assert abs(counts['organizer'] - counts['guest']) <= 1 assert abs(counts['guest'] - counts['volunteer']) <= 1 assert counts['volunteer'] + counts['organizer'] + counts['guest'] == 100000 def test_assign_roles_6(): result = assign_roles(6) assert len(result) == 6 assert 'volunteer' in result assert 'organizer' in result assert 'guest' in result assert result.count('volunteer') == 2 assert result.count('organizer') == 2 assert result.count('guest') == 2","solution":"def assign_roles(n): Assigns roles to n participants such that each role ('volunteer', 'organizer', 'guest') is assigned to at least one participant, and the difference in the number of participants assigned to any two roles does not exceed 1. :param n: int, the number of participants :return: list of strings, the assigned roles in order roles = ['volunteer', 'organizer', 'guest'] result = [] for i in range(n): result.append(roles[i % 3]) return result"},{"question":"def findArmstrongNumbers(n): Returns a list of n-digit Armstrong numbers. Args: n (int): The number of digits in the numbers to be found. Returns: List[int]: A list of n-digit Armstrong numbers. Example: >>> findArmstrongNumbers(3) [153, 370, 371, 407] >>> findArmstrongNumbers(4) [1634, 8208, 9474]","solution":"def findArmstrongNumbers(n): Returns a list of n-digit Armstrong numbers. def is_armstrong_number(x, n): sum_of_powers = sum(int(digit) ** n for digit in str(x)) return x == sum_of_powers lower = 10**(n-1) upper = 10**n armstrong_numbers = [] for number in range(lower, upper): if is_armstrong_number(number, n): armstrong_numbers.append(number) return armstrong_numbers"},{"question":"def check_time_limits(N: int, time_limits: List[int], time_taken: List[int]) -> str: Determine if Maria solved all subproblems within the specified time limits. Args: N : int : Number of subproblems time_limits : List[int] : List of time limits for each subproblem time_taken : List[int] : List of times taken to solve each subproblem Returns: str : \\"Yes\\" if all subproblems are solved within the time limits, otherwise \\"No\\" >>> check_time_limits(3, [10, 15, 20], [8, 14, 19]) \\"Yes\\" >>> check_time_limits(3, [10, 15, 20], [8, 16, 19]) \\"No\\" if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) time_limits = list(map(int, data[1:N+1])) time_taken = list(map(int, data[N+1:2*N+1])) print(check_time_limits(N, time_limits, time_taken))","solution":"def check_time_limits(N, time_limits, time_taken): Returns 'Yes' if all subproblems are solved within their respective time limits, otherwise 'No'. for i in range(N): if time_taken[i] > time_limits[i]: return \\"No\\" return \\"Yes\\" if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) time_limits = list(map(int, data[1:N+1])) time_taken = list(map(int, data[N+1:2*N+1])) print(check_time_limits(N, time_limits, time_taken))"},{"question":"from typing import List, Tuple def can_communicate_within_threshold(n: int, m: int, k: int, edges: List[Tuple[int, int, int]], s: int, t: int) -> str: Determines if there is a path in the network from a designated starting ant to a target ant within a given reliability score threshold. Args: n (int): Number of ants. m (int): Number of communication links. k (int): Maximum allowable sum of reliability scores for the path. edges (List[Tuple[int, int, int]]): List of edges where each edge is represented as a tuple (u, v, w) with u being the starting ant, v being the ending ant, and w being the reliability score. s (int): The starting ant. t (int): The target ant. Returns: str: \\"Yes\\" if there is a path from ant s to ant t such that the sum of reliability scores does not exceed k, otherwise \\"No\\". Examples: >>> can_communicate_within_threshold(5, 6, 5, [(1, 2, 2), (1, 3, 1), (2, 4, 2), (3, 4, 3), (4, 5, 1), (3, 5, 1)], 1, 5) \\"Yes\\" >>> can_communicate_within_threshold(5, 6, 2, [(1, 2, 2), (1, 3, 1), (2, 4, 2), (3, 4, 3), (4, 5, 1), (3, 5, 2)], 1, 5) \\"No\\"","solution":"import heapq def can_communicate_within_threshold(n, m, k, edges, s, t): graph = [[] for _ in range(n + 1)] # Build the graph for u, v, w in edges: graph[u].append((v, w)) # Dijkstra-like approach but modifying to stop when threshold is exceeded pq = [(0, s)] # (cost, node) dist = [float('inf')] * (n + 1) dist[s] = 0 while pq: current_sum, node = heapq.heappop(pq) if node == t and current_sum <= k: return \\"Yes\\" for neighbor, weight in graph[node]: new_sum = current_sum + weight if new_sum < dist[neighbor]: dist[neighbor] = new_sum heapq.heappush(pq, (new_sum, neighbor)) return \\"No\\""},{"question":"def is_subsequence(known_pattern, recorded_sequence): Determines if recorded_sequence is a subsequence of known_pattern. Parameters: known_pattern (list of int): The known flashing pattern. recorded_sequence (list of int): The recorded sequence by Lexa. Returns: str: \\"Yes\\" if recorded_sequence is a subsequence of known_pattern, \\"No\\" otherwise. >>> is_subsequence([1, 2, 3, 4, 5, 6], [2, 4, 6]) \\"Yes\\" >>> is_subsequence([10, 20, 30, 40, 50], [10, 30, 60, 40]) \\"No\\" >>> is_subsequence([5, 1, 2, 3, 5, 10, 5], [5, 10]) \\"Yes\\" >>> is_subsequence([1, 2, 3, 4, 5, 6], []) \\"Yes\\" >>> is_subsequence([1, 2, 3, 4], [1, 2, 3, 4]) \\"Yes\\" >>> is_subsequence([1, 2, 3, 4], [2, 3, 5]) \\"No\\" >>> is_subsequence([10, 20, 30, 40, 50, 60], [10, 50, 60]) \\"Yes\\"","solution":"def is_subsequence(known_pattern, recorded_sequence): Determines if recorded_sequence is a subsequence of known_pattern. Parameters: known_pattern (list of int): The known flashing pattern. recorded_sequence (list of int): The recorded sequence by Lexa. Returns: str: \\"Yes\\" if recorded_sequence is a subsequence of known_pattern, \\"No\\" otherwise. iter_known_pattern = iter(known_pattern) return \\"Yes\\" if all(item in iter_known_pattern for item in recorded_sequence) else \\"No\\""},{"question":"def max_checkpoints(n, m): This function calculates the maximum number of checkpoints a participant can reach in 'm' minutes on a circular track with 'n' checkpoints. >>> max_checkpoints(5, 2) 3 >>> max_checkpoints(6, 4) 5 >>> max_checkpoints(8, 10) 8 pass def solve_marathon_cases(T, cases): This function processes each test case to determine the maximum checkpoints reachable. >>> solve_marathon_cases(3, [(5, 2), (6, 4), (8, 10)]) [3, 5, 8] >>> solve_marathon_cases(2, [(4, 2), (7, 3)]) [3, 4] pass","solution":"def max_checkpoints(n, m): This function calculates the maximum number of checkpoints a participant can reach in 'm' minutes on a circular track with 'n' checkpoints. checkpoints_reached = min(n, m + 1) return checkpoints_reached def solve_marathon_cases(T, cases): This function processes each test case to determine the maximum checkpoints reachable. results = [] for n, m in cases: results.append(max_checkpoints(n, m)) return results"},{"question":"def pascalsTriangle(N): Generates the first N rows of Pascal's triangle. Parameters: N (int): number of rows to generate Returns: list of lists: the first N rows of Pascal's Triangle Examples: >>> pascalsTriangle(5) [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]] >>> pascalsTriangle(1) [[1]] >>> pascalsTriangle(0) [] >>> pascalsTriangle(-5) [] >>> pascalsTriangle(2) [[1], [1, 1]] >>> pascalsTriangle(3) [[1], [1, 1], [1, 2, 1]] # Your code here","solution":"def pascalsTriangle(N): Generates the first N rows of Pascal's triangle. Parameters: N (int): number of rows to generate Returns: list of lists: the first N rows of Pascal's Triangle if N <= 0: return [] result = [[1]] for _ in range(1, N): prev_row = result[-1] curr_row = [1] for j in range(1, len(prev_row)): curr_row.append(prev_row[j-1] + prev_row[j]) curr_row.append(1) result.append(curr_row) return result"},{"question":"def longest_sequence_length(N: int, grid: List[str]) -> int: Find the length of the longest sequence of the same letter in the grid. The sequence can be vertical, horizontal, or diagonal (both top-left to bottom-right and top-right to bottom-left). >>> longest_sequence_length(4, ['abcd', 'eeee', 'fghi', 'jklm']) 4 >>> longest_sequence_length(3, ['aaa', 'bbb', 'ccc']) 3 >>> longest_sequence_length(5, ['abcde', 'fghij', 'klmno', 'pqrst', 'uvwxy']) 1 pass # Your code goes here # Unit tests def test_example1(): N = 4 grid = [ 'abcd', 'eeee', 'fghi', 'jklm' ] assert longest_sequence_length(N, grid) == 4 def test_example2(): N = 3 grid = [ 'aaa', 'bbb', 'ccc' ] assert longest_sequence_length(N, grid) == 3 def test_example3(): N = 5 grid = [ 'abcde', 'fghij', 'klmno', 'pqrst', 'uvwxy' ] assert longest_sequence_length(N, grid) == 1 def test_single_letter_grid(): N = 1 grid = [ 'a' ] assert longest_sequence_length(N, grid) == 1 def test_diagonal_length(): N = 5 grid = [ 'axxcz', 'baxef', 'ccxba', 'dxexx', 'exxxa' ] assert longest_sequence_length(N, grid) == 3 def test_horizontal_length(): N = 4 grid = [ 'aaab', 'cdef', 'ghij', 'klmn' ] assert longest_sequence_length(N, grid) == 3 def test_vertical_length(): N = 4 grid = [ 'abcd', 'aefg', 'ahij', 'aklm' ] assert longest_sequence_length(N, grid) == 4","solution":"def longest_sequence_length(N, grid): def check_direction(x, y, dx, dy): length = 1 current_char = grid[x][y] while 0 <= x + dx < N and 0 <= y + dy < N and grid[x + dx][y + dy] == current_char: x, y = x + dx, y + dy length += 1 return length max_length = 0 # Check all directions: horizontal, vertical, diagonal (both) for i in range(N): for j in range(N): max_length = max(max_length, check_direction(i, j, 1, 0)) # Vertical max_length = max(max_length, check_direction(i, j, 0, 1)) # Horizontal max_length = max(max_length, check_direction(i, j, 1, 1)) # Diagonal down-right max_length = max(max_length, check_direction(i, j, 1, -1)) # Diagonal down-left return max_length"},{"question":"def two_sum(n, target, array): Given an array of integers and a target integer, determine whether there are two distinct elements in the array that sum up to the target value. Parameters: n (int): Number of elements in the array target (int): Target sum to find array (list): List of integers Returns: tuple: Indices of the two elements that sum up to the target (1-based index) or -1 if no such pair exists.","solution":"def two_sum(n, target, array): Given an array of integers and a target integer, determine whether there are two distinct elements in the array that sum up to the target value. Parameters: n (int): Number of elements in the array target (int): Target sum to find array (list): List of integers Returns: tuple: Indices of the two elements that sum up to the target (1-based index) or -1 if no such pair exists. index_map = {} for i in range(n): complement = target - array[i] if complement in index_map: return (index_map[complement] + 1, i + 1) index_map[array[i]] = i return -1"},{"question":"def is_prime(n): Determines if n is a prime number. Parameters: n (int): The number to be checked for primality. Returns: bool: True if n is a prime number, otherwise False. >>> is_prime(2) True >>> is_prime(15) False >>> is_prime(23) True def prime_book_selector(T, page_counts): For each page count, determines if it is a prime number. Parameters: T (int): The number of books. page_counts (List[int]): A list of total page counts for each book. Returns: List[str]: A list of \\"YES\\" or \\"NO\\" depending on whether the respective page count is a prime number. >>> prime_book_selector(3, [29, 15, 23]) ['YES', 'NO', 'YES'] >>> prime_book_selector(2, [10, 17]) ['NO', 'YES']","solution":"def is_prime(n): Determines if n is a prime number. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def prime_book_selector(T, page_counts): For each page count, determines if it is a prime number. results = [] for pages in page_counts: if is_prime(pages): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Example usage for book page counts: # T = 3 # page_counts = [29, 15, 23] # prime_book_selector(T, page_counts) => ['YES', 'NO', 'YES']"},{"question":"from typing import List def min_operations_to_match_grid(n: int, m: int, target: List[List[int]]) -> int: Determine the minimum number of operations needed to make the final grid match the target configuration. >>> min_operations_to_match_grid(3, 3, [[1, 0, 1], [2, 1, 1], [2, 1, 2]]) 2 >>> min_operations_to_match_grid(4, 4, [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1]]) 1 >>> min_operations_to_match_grid(2, 2, [[3, 3], [3, 3]]) 3 >>> min_operations_to_match_grid(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> min_operations_to_match_grid(3, 3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 1","solution":"def min_operations_to_match_grid(n, m, target): operations = 0 current_grid = [[0] * m for _ in range(n)] for i in range(n): for j in range(m): if current_grid[i][j] < target[i][j]: increment_value = target[i][j] - current_grid[i][j] operations += increment_value for x in range(i, n): for y in range(j, m): current_grid[x][y] += increment_value return operations"},{"question":"def can_distribute_candies(n: int, m: int) -> str: Determines if it's possible to distribute \`m\` candies into \`n\` bags with each bag containing a unique number of candies. >>> can_distribute_candies(3, 6) 'YES' >>> can_distribute_candies(3, 5) 'NO'","solution":"def can_distribute_candies(n, m): Determines if it's possible to distribute \`m\` candies into \`n\` bags with each bag containing a unique number of candies. # The sum of the first n natural numbers min_candies_needed = n * (n + 1) // 2 # If the sum of the first n natural numbers is greater than m, it's not possible if min_candies_needed > m: return \\"NO\\" return \\"YES\\" # Example Usage # if __name__ == \\"__main__\\": # n, m = map(int, input().split()) # print(can_distribute_candies(n, m))"},{"question":"from typing import List def rearrange_string_k_distance_apart(s: str, k: int) -> str: Rearrange the string such that any two adjacent characters are at least distance k apart. If it's not possible, return an empty string. Args: s (str): The input string to be rearranged. k (int): The required minimum distance between any two adjacent characters. Returns: str: The rearranged string satisfying the conditions, or an empty string if not possible. Examples: >>> rearrange_string_k_distance_apart(\\"aabbcc\\", 3) 'abcabc' >>> rearrange_string_k_distance_apart(\\"aaabc\\", 3) '' >>> rearrange_string_k_distance_apart(\\"aaadbbcc\\", 2) 'abacabcd'","solution":"from collections import Counter import heapq def rearrange_string_k_distance_apart(s, k): Rearrange the string such that any two adjacent characters are at least distance k apart. If it's not possible, return an empty string. if k <= 1: return s # Count frequency of each character counter = Counter(s) max_heap = [(-value, key) for key, value in counter.items()] heapq.heapify(max_heap) queue = [] result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) # Reduce count and add the character to waiting queue with a new count queue.append((char, count + 1)) if len(queue) >= k: release_char, release_count = queue.pop(0) if release_count < 0: heapq.heappush(max_heap, (release_count, release_char)) if len(result) != len(s): return \\"\\" return ''.join(result)"},{"question":"def count_valid_pairs(T, test_cases): Determine the number of valid pairs that can be formed according to the rule described. A valid pair must consist of one person with an even height and one person with an odd height. Parameters: T (int): The number of test cases. test_cases (list): A list of tuples, each containing an integer M (the number of participants) and a list of M space-separated integers representing the heights of the participants. Returns: list: A list of integers, each representing the number of valid pairs that can be formed for each test case. >>> count_valid_pairs(1, [(4, [160, 181, 162, 175])]) == [4] >>> count_valid_pairs(3, [(4, [160, 181, 162, 175]), (5, [150, 153, 157, 160, 164]), (3, [170, 171, 180])]) == [4, 6, 2]","solution":"def count_valid_pairs(T, test_cases): results = [] for i in range(T): M = test_cases[i][0] heights = test_cases[i][1] even_count = sum(1 for h in heights if h % 2 == 0) odd_count = M - even_count results.append(even_count * odd_count) return results # Example usage: # test_cases = [(4, [160, 181, 162, 175]), (5, [150, 153, 157, 160, 164]), (3, [170, 171, 180])] # T = 3 # print(count_valid_pairs(T, test_cases)) # Output: [4, 6, 2]"},{"question":"def find_equilibrium_index(arr): Returns the equilibrium index of the array. If no such index exists, returns -1. Args: arr (List[int]): An array of integers. Returns: int: The equilibrium index or -1 if it doesn't exist. Examples: >>> find_equilibrium_index([1, 3, 5, 2, 2]) 2 >>> find_equilibrium_index([1, 2, 3, 4]) -1 pass def process_test_cases(test_cases): Processes a list of test cases and returns the results. Each test case should be a tuple (N, list_of_integers). Args: test_cases (List[Tuple[int, List[int]]]): A list of test cases. Returns: List[int]: A list of equilibrium index results for each test case. Examples: >>> process_test_cases([(5, [1, 3, 5, 2, 2]), (4, [1, 2, 3, 4])]) [2, -1] pass","solution":"def find_equilibrium_index(arr): Returns the equilibrium index of the array. If no such index exists, returns -1. total_sum = sum(arr) left_sum = 0 for i, num in enumerate(arr): total_sum -= num if left_sum == total_sum: return i left_sum += num return -1 def process_test_cases(test_cases): Processes a list of test cases and returns the results. Each test case should be a tuple (N, list_of_integers). results = [] for N, arr in test_cases: results.append(find_equilibrium_index(arr)) return results # Example Usage: # T = 2 # test_cases = [(5, [1, 3, 5, 2, 2]), (4, [1, 2, 3, 4])] # process_test_cases(test_cases)"},{"question":"def rotate_matrix_90_clockwise(matrix): Rotates the given square matrix 90 degrees clockwise. Parameters: matrix (list of list of int): The square matrix to rotate. Returns: list of list of int: The rotated matrix. >>> rotate_matrix_90_clockwise([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix_90_clockwise([ ... [1, 2], ... [3, 4] ... ]) [[3, 1], [4, 2]]","solution":"def rotate_matrix_90_clockwise(matrix): Rotates the given square matrix 90 degrees clockwise. Parameters: matrix (list of list of int): The square matrix to rotate. Returns: list of list of int: The rotated matrix. n = len(matrix) rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n - i - 1] = matrix[i][j] return rotated_matrix"},{"question":"def can_sort_by_reversing_subarray(arr: List[int]) -> str: Given an array \`arr\` of length \`n\`, determine if it is possible to sort the array in non-decreasing order by reversing at most one subarray (continuous segment). A subarray is defined as a continuous portion of an array. Args: arr: A list of integers representing the array Returns: str: \\"YES\\" if the array can be sorted by reversing at most one subarray, otherwise \\"NO\\" Examples: >>> can_sort_by_reversing_subarray([3, 6, 5, 4, 7, 9]) \\"YES\\" >>> can_sort_by_reversing_subarray([1, 2, 4, 3, 5]) \\"YES\\" >>> can_sort_by_reversing_subarray([4, 3, 2, 1]) \\"YES\\" >>> can_sort_by_reversing_subarray([4, 3, 6, 5, 7]) \\"NO\\" >>> can_sort_by_reversing_subarray([1, 3, 2]) \\"YES\\" def test_can_sort_by_reversing_subarray_1(): assert can_sort_by_reversing_subarray([3, 6, 5, 4, 7, 9]) == \\"YES\\" def test_can_sort_by_reversing_subarray_2(): assert can_sort_by_reversing_subarray([1, 2, 4, 3, 5]) == \\"YES\\" def test_can_sort_by_reversing_subarray_3(): assert can_sort_by_reversing_subarray([4, 3, 2, 1]) == \\"YES\\" def test_can_sort_by_reversing_subarray_4(): assert can_sort_by_reversing_subarray([1, 3, 2]) == \\"YES\\" def test_can_sort_by_reversing_subarray_5(): assert can_sort_by_reversing_subarray([4, 3, 6, 5, 7]) == \\"NO\\" def test_can_sort_by_reversing_subarray_6(): assert can_sort_by_reversing_subarray([1, 2, 3, 4, 5]) == \\"YES\\" def test_can_sort_by_reversing_subarray_7(): assert can_sort_by_reversing_subarray([9, 8, 7, 6, 5, 4, 3, 2, 1]) == \\"YES\\" def test_can_sort_by_reversing_subarray_8(): assert can_sort_by_reversing_subarray([1, 5, 4, 3, 2, 6]) == \\"YES\\" def test_can_sort_by_reversing_subarray_single_element(): assert can_sort_by_reversing_subarray([1]) == \\"YES\\" def test_can_sort_by_reversing_subarray_already_sorted(): assert can_sort_by_reversing_subarray([2, 3, 5, 7, 11]) == \\"YES\\" def test_can_sort_by_reversing_subarray_best_case(): assert can_sort_by_reversing_subarray([1, 5, 4, 3, 2]) == \\"YES\\"","solution":"def can_sort_by_reversing_subarray(arr): n = len(arr) # Find the first part where the array is not increasing start = 0 while start < n - 1 and arr[start] <= arr[start + 1]: start += 1 # If the entire array is already sorted if start == n - 1: return \\"YES\\" # Find the last part where the array is not increasing end = n - 1 while end > 0 and arr[end] >= arr[end - 1]: end -= 1 # Reverse the subarray new_arr = arr[:start] + list(reversed(arr[start:end + 1])) + arr[end + 1:] # Check if this new array is sorted for i in range(n - 1): if new_arr[i] > new_arr[i + 1]: return \\"NO\\" return \\"YES\\" # Example usage # print(can_sort_by_reversing_subarray([3, 6, 5, 4, 7, 9])) # Output: YES # print(can_sort_by_reversing_subarray([4, 3, 6, 5, 7])) # Output: NO"},{"question":"from typing import List def merge(nums1: List[int], m: int, nums2: List[int], n: int) -> None: Merges nums2 into nums1 into a single array sorted in non-decreasing order. Args: nums1 (List[int]): The first list with nums1 having a size of m + n. The first m elements are to be merged, and the last n elements are set to 0 and should be ignored. nums2 (List[int]): The second list with n elements to be merged with nums1. m (int): The number of elements initially in nums1. n (int): The number of elements in nums2. Modifies nums1 in-place.","solution":"def merge(nums1, m, nums2, n): Merges nums2 into nums1 into a single array sorted in non-decreasing order. Args: nums1 (List[int]): The first list with nums1 having a size of m + n. The first m elements are to be merged, and the last n elements are set to 0 and should be ignored. nums2 (List[int]): The second list with n elements to be merged with nums1. m (int): The number of elements initially in nums1. n (int): The number of elements in nums2. Modifies nums1 in-place. i = m - 1 # Pointer for nums1 j = n - 1 # Pointer for nums2 k = m + n - 1 # Pointer for the merged array in nums1 while i >= 0 and j >= 0: if nums1[i] > nums2[j]: nums1[k] = nums1[i] i -= 1 else: nums1[k] = nums2[j] j -= 1 k -= 1 while j >= 0: nums1[k] = nums2[j] j -= 1 k -= 1"},{"question":"def max_jumps(hills: List[int]) -> int: Determine the maximum number of jumps from one hill to another such that each subsequent hill is strictly taller than the previous one. >>> max_jumps([1, 3, 2, 5, 4, 6]) 3 >>> max_jumps([4, 3, 2, 1, 5]) 1","solution":"def max_jumps(hills): if not hills: return 0 # Initialize the dp array where dp[i] will store the maximum number of jumps that can be made # starting from hill i dp = [1] * len(hills) for i in range(len(hills)): for j in range(i): if hills[j] < hills[i]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) - 1"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeNthFromEnd(head: ListNode, n: int) -> ListNode: Removes the nth node from the end of the list and returns its head. pass def to_list(node): Helper function to convert linked list to Python list for easy comparison in tests. pass def to_linked_list(lst): Helper function to convert Python list to linked list for easy setup in tests. pass # Unit tests def test_remove_nth_node(): head = to_linked_list([1, 2, 3, 4, 5]) n = 2 updated_head = removeNthFromEnd(head, n) assert to_list(updated_head) == [1, 2, 3, 5] def test_remove_first_node(): head = to_linked_list([1, 2]) n = 2 updated_head = removeNthFromEnd(head, n) assert to_list(updated_head) == [2] def test_remove_middle_node(): head = to_linked_list([1, 2, 3, 4, 5]) n = 3 updated_head = removeNthFromEnd(head, n) assert to_list(updated_head) == [1, 2, 4, 5] def test_remove_last_node(): head = to_linked_list([1, 2, 3, 4, 5]) n = 1 updated_head = removeNthFromEnd(head, n) assert to_list(updated_head) == [1, 2, 3, 4] def test_single_element_list(): head = to_linked_list([1]) n = 1 updated_head = removeNthFromEnd(head, n) assert to_list(updated_head) == [] def test_two_element_list_remove_last(): head = to_linked_list([1, 2]) n = 1 updated_head = removeNthFromEnd(head, n) assert to_list(updated_head) == [1]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeNthFromEnd(head: ListNode, n: int) -> ListNode: Removes the nth node from the end of the list and returns its head. dummy = ListNode(0, head) first = dummy second = dummy # Advance first pointer so that the gap between first and second is n nodes apart. for _ in range(n + 1): first = first.next # Move first to the end, maintaining the gap. while first is not None: first = first.next second = second.next # Remove the nth node from the end second.next = second.next.next return dummy.next def to_list(node): Helper function to convert linked list to Python list for easy comparison in tests. result = [] current = node while current: result.append(current.val) current = current.next return result def to_linked_list(lst): Helper function to convert Python list to linked list for easy setup in tests. dummy = ListNode() current = dummy for val in lst: current.next = ListNode(val) current = current.next return dummy.next"},{"question":"def most_frequent_flower(R: int, C: int, garden: List[List[int]], queries: List[Tuple[int, int, int, int]]) -> List[int]: In a rectangular garden divided into a grid with R rows and C columns, identify the most frequently occurring flower in any submatrix of the garden for each query. >>> R = 3 >>> C = 3 >>> garden = [ ... [1, 2, 1], ... [3, 1, 2], ... [2, 2, 3] ... ] >>> queries = [(1, 1, 2, 2), (2, 1, 3, 3)] >>> most_frequent_flower(R, C, garden, queries) [1, 2] >>> R = 2 >>> C = 2 >>> garden = [ ... [3, 3], ... [3, 3] ... ] >>> queries = [(1, 1, 2, 2)] >>> most_frequent_flower(R, C, garden, queries) [3] pass","solution":"from collections import defaultdict from functools import lru_cache def most_frequent_flower(R, C, garden, queries): def get_submatrix_frequency(r1, c1, r2, c2): frequency = defaultdict(int) for i in range(r1, r2 + 1): for j in range(c1, c2 + 1): frequency[garden[i][j]] += 1 max_frequency = max(frequency.values()) most_frequent_flowers = [flower for flower, freq in frequency.items() if freq == max_frequency] return min(most_frequent_flowers) results = [] for r1, c1, r2, c2 in queries: r1, c1, r2, c2 = r1 - 1, c1 - 1, r2 - 1, c2 - 1 results.append(get_submatrix_frequency(r1, c1, r2, c2)) return results"},{"question":"from collections import defaultdict, deque class Tree: def __init__(self, n): Initialize the tree with n nodes. self.n = n self.adj = defaultdict(list) self.values = [0] * (n + 1) self.parent = [-1] * (n + 1) self.depth = [0] * (n + 1) def add_edge(self, u, v): Adds an edge between nodes u and v. self.adj[u].append(v) self.adj[v].append(u) def bfs(self, root=1): Perform BFS to set up parent and depth information. queue = deque([root]) visited = [False] * (self.n + 1) visited[root] = True while queue: node = queue.popleft() for neighbor in self.adj[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) self.parent[neighbor] = node self.depth[neighbor] = self.depth[node] + 1 def update(self, x, y): Update the node x by adding value y. self.values[x] += y def query(self, x, y): Query the sum of values along the path from node x to node y. sum_val = 0 while self.depth[x] > self.depth[y]: sum_val += self.values[x] x = self.parent[x] while self.depth[y] > self.depth[x]: sum_val += self.values[y] y = self.parent[y] while x != y: sum_val += self.values[x] sum_val += self.values[y] x = self.parent[x] y = self.parent[y] sum_val += self.values[x] return sum_val def process_queries(n, queries, edges): Process a list of operations (update and query) on the tree with n nodes. Parameters: - n: Number of nodes in the tree - queries: A list of strings representing the operations - edges: A list of tuples representing the edges of the tree Returns: - A list of integers representing the results of the query operations. Example: >>> process_queries(5, [\\"U 1 5\\", \\"Q 2 3\\", \\"U 4 2\\", \\"Q 2 4\\", \\"Q 4 5\\"], [(1, 2), (1, 3), (3, 4), (3, 5)]) [5, 7, 2] tree = Tree(n) for u, v in edges: tree.add_edge(u, v) tree.bfs() results = [] for query in queries: parts = query.split() if parts[0] == 'U': x, y = int(parts[1]), int(parts[2]) tree.update(x, y) elif parts[0] == 'Q': x, y = int(parts[1]), int(parts[2]) results.append(tree.query(x, y)) return results","solution":"from collections import defaultdict, deque class Tree: def __init__(self, n): self.n = n self.adj = defaultdict(list) self.values = [0] * (n + 1) self.parent = [-1] * (n + 1) self.depth = [0] * (n + 1) def add_edge(self, u, v): self.adj[u].append(v) self.adj[v].append(u) def bfs(self, root=1): queue = deque([root]) visited = [False] * (self.n + 1) visited[root] = True while queue: node = queue.popleft() for neighbor in self.adj[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) self.parent[neighbor] = node self.depth[neighbor] = self.depth[node] + 1 def update(self, x, y): self.values[x] += y def query(self, x, y): sum_val = 0 # Bring x and y to same depth while self.depth[x] > self.depth[y]: sum_val += self.values[x] x = self.parent[x] while self.depth[y] > self.depth[x]: sum_val += self.values[y] y = self.parent[y] # Now bring both to LCA while x != y: sum_val += self.values[x] sum_val += self.values[y] x = self.parent[x] y = self.parent[y] sum_val += self.values[x] return sum_val def process_queries(n, queries, edges): tree = Tree(n) for u, v in edges: tree.add_edge(u, v) tree.bfs() results = [] for query in queries: parts = query.split() if parts[0] == 'U': x, y = int(parts[1]), int(parts[2]) tree.update(x, y) elif parts[0] == 'Q': x, y = int(parts[1]), int(parts[2]) results.append(tree.query(x, y)) return results"},{"question":"def solve_garden_problem(n, m, k, flowers): Determines if it's possible to repaint the faded flowers such that the garden contains at least k consecutive flowers of the same color. Args: n (int): number of flowers. m (int): number of different colors. k (int): minimum number of consecutive flowers required to be of the same color. flowers (str): string representing the current state of the flowers. Returns: str: \\"YES\\" if it is possible, \\"NO\\" otherwise. pass def test_can_make_garden_beautiful_example1(): assert solve_garden_problem(5, 3, 3, \\"a?a??\\") == \\"YES\\" def test_can_make_garden_beautiful_example2(): assert solve_garden_problem(4, 2, 4, \\"ab??\\") == \\"NO\\" def test_all_question_marks(): assert solve_garden_problem(4, 2, 2, \\"????\\") == \\"YES\\" assert solve_garden_problem(6, 3, 4, \\"??????\\") == \\"YES\\" def test_no_need_to_replace(): assert solve_garden_problem(5, 3, 3, \\"abbbb\\") == \\"YES\\" def test_no_possible_replacement(): assert solve_garden_problem(6, 2, 5, \\"a?ba?b\\") == \\"NO\\" def test_one_replacement_needed(): assert solve_garden_problem(5, 2, 3, \\"aa??a\\") == \\"YES\\" import pytest pytest.main()","solution":"def can_make_garden_beautiful(n, m, k, flowers): Determines if it's possible to repaint the faded flowers such that the garden contains at least k consecutive flowers of the same color. Args: n (int): number of flowers. m (int): number of different colors. k (int): minimum number of consecutive flowers required to be of the same color. flowers (str): string representing the current state of the flowers. Returns: bool: True if it is possible, False otherwise. def check_color_streak(flowers, color, start, end, k): count = 0 max_streak = 0 for i in range(start, end): if flowers[i] == color or flowers[i] == '?': count += 1 if count >= k: return True else: count = 0 return False for color in range(m): # Convert the color to its corresponding character char_color = chr(ord('a') + color) for start in range(n - k + 1): end = start + k if check_color_streak(flowers, char_color, start, end, k): return True return False # Helper function to return YES/NO def solve_garden_problem(n, m, k, flowers): return \\"YES\\" if can_make_garden_beautiful(n, m, k, flowers) else \\"NO\\""},{"question":"def can_transform(s: str, t: str, k: int) -> int: Determines if it is possible to transform one string into another using a series of operations within a given number of steps. >>> can_transform(\\"abcdef\\", \\"azced\\", 3) 1 >>> can_transform(\\"hello\\", \\"world\\", 2) 0 >>> can_transform(\\"same\\", \\"same\\", 0) 1 >>> can_transform(\\"same\\", \\"same\\", 1) 1 >>> can_transform(\\"a\\", \\"b\\", 1) 1 >>> can_transform(\\"a\\", \\"b\\", 0) 0 >>> can_transform(\\"\\", \\"abc\\", 3) 1 >>> can_transform(\\"\\", \\"abc\\", 2) 0 >>> can_transform(\\"abc\\", \\"\\", 3) 1 >>> can_transform(\\"abc\\", \\"\\", 2) 0","solution":"def can_transform(s, t, k): def edit_distance(s, t): m, n = len(s), len(t) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) return dp[m][n] return 1 if edit_distance(s, t) <= k else 0"},{"question":"from typing import List def print_permutations(n: int) -> None: Print all permutations of numbers from 1 to n in lexicographic order, each permutation on a new line. >>> print_permutations(1) 1 >>> print_permutations(2) 1 2 2 1 >>> print_permutations(3) 1 2 3 1 3 2 2 1 3 2 3 1 3 1 2 3 2 1","solution":"from itertools import permutations def print_permutations(n): numbers = list(range(1, n + 1)) perm = permutations(numbers) for p in perm: print(' '.join(map(str, p)))"},{"question":"def isUniform(S: str) -> str: Determines if it is possible to make all characters in S the same by performing at most one flip operation. Parameters: S (str): A binary string. Returns: str: \\"YES\\" or \\"NO\\" >>> isUniform(\\"0110\\") \\"YES\\" >>> isUniform(\\"0101\\") \\"NO\\" >>> isUniform(\\"1111\\") \\"YES\\"","solution":"def isUniform(S): Determines if it is possible to make all characters in S the same by performing at most one flip operation. Parameters: S (str): A binary string. Returns: str: \\"YES\\" or \\"NO\\" # Initialize variables to keep track of runs of '0's and '1's count0 = 0 count1 = 0 # Iterate through the string to count the segments of '0's and '1's for i in range(1, len(S)): if S[i] != S[i - 1]: if S[i - 1] == '0': count0 += 1 else: count1 += 1 if S[-1] == '0': count0 += 1 else: count1 += 1 # If there's only one run of characters, we can return YES # because the string is already uniform. if count0 <= 1 or count1 <= 1: return \\"YES\\" return \\"NO\\""},{"question":"def subsets(nums): Returns all unique subsets of a given list of integers, sorted in lexicographical order and without duplicates. Each subset is sorted. >>> subsets([1, 2, 3]) [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]] >>> subsets([1, 2, 2]) [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]] >>> subsets([1]) [[], [1]] >>> subsets([2, 2, 2]) [[], [2], [2, 2], [2, 2, 2]] >>> subsets([]) [[]] >>> subsets([-1, 0, 1]) [[], [-1], [-1, 0], [-1, 0, 1], [-1, 1], [0], [0, 1], [1]] >>> subsets([3, 1, 2]) [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]","solution":"def subsets(nums): Returns all unique subsets of a given list of integers, sorted in lexicographical order and without duplicates. Each subset is sorted. nums.sort() # Sort the input array result = [] subset = [] def backtrack(start): result.append(subset[:]) # Add current subset to results for i in range(start, len(nums)): if i > start and nums[i] == nums[i-1]: # Skip duplicates continue subset.append(nums[i]) backtrack(i + 1) subset.pop() backtrack(0) return result"},{"question":"def can_reach_p2(n: int, L: int, steps: List[int]) -> str: Determines if it is possible for the platform to reach exactly position P2 using any combination of the given step sizes. :param n: Number of different step sizes available. :param L: Total length of the track. :param steps: List of step sizes. :return: 'YES' if it is possible to reach exactly position P2, otherwise 'NO'. # Write your code here from typing import List def test_reach_possible(): assert can_reach_p2(3, 5, [1, 2, 3]) == \\"YES\\" def test_large_impossible(): assert can_reach_p2(1, 10, [4]) == \\"NO\\" def test_single_step_possible(): assert can_reach_p2(1, 7, [7]) == \\"YES\\" def test_multiple_steps_possible(): assert can_reach_p2(3, 8, [2, 3, 5]) == \\"YES\\" def test_combination_impossible(): assert can_reach_p2(3, 9, [2, 4, 6]) == \\"NO\\" def test_large_possible(): assert can_reach_p2(2, 1000000, [1, 2]) == \\"YES\\"","solution":"def can_reach_p2(n, L, steps): Determines if it is possible for the platform to reach exactly position P2 using any combination of the given step sizes. :param n: Number of different step sizes available. :param L: Total length of the track. :param steps: List of step sizes. :return: 'YES' if it is possible to reach exactly position P2, otherwise 'NO'. # We can use dynamic programming to solve this problem dp = [False] * (L + 1) dp[0] = True for i in range(1, L + 1): for step in steps: if i - step >= 0 and dp[i - step]: dp[i] = True break return \\"YES\\" if dp[L] else \\"NO\\""},{"question":"def count_divisible_pairs(n: int, k: int, arr: List[int]) -> int: Return the number of pairs (i, j) such that 1  i < j  n and ai + aj is divisible by k. >>> count_divisible_pairs(5, 3, [1, 2, 3, 4, 5]) 4 >>> count_divisible_pairs(4, 5, [5, 5, 5, 5]) 6","solution":"def count_divisible_pairs(n, k, arr): Return the number of pairs (i, j) such that 1  i < j  n and ai + aj is divisible by k. remainder_count = [0] * k # Count the frequency of each remainder when divided by k for num in arr: remainder_count[num % k] += 1 # Initialize count of pairs count = 0 # Count pairs (remainder 0 with remainder 0) count += (remainder_count[0] * (remainder_count[0] - 1)) // 2 # Count pairs for other remainders for i in range(1, (k//2) + 1): if i != k - i: count += remainder_count[i] * remainder_count[k - i] else: count += (remainder_count[i] * (remainder_count[i] - 1)) // 2 return count"},{"question":"def submatrix_sum(matrix, row1, col1, row2, col2): Given an \`m x n\` matrix of integers, returns the sum of all the elements in a sub-matrix specified by the top-left corner \`(row1, col1)\` and the bottom-right corner \`(row2, col2)\` (inclusive). >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> submatrix_sum(matrix, 1, 1, 2, 2) 28 >>> submatrix_sum(matrix, 0, 0, 2, 2) 45 >>> submatrix_sum(matrix, 1, 1, 1, 1) 5 >>> submatrix_sum(matrix, 1, 0, 1, 2) 15 >>> submatrix_sum(matrix, 0, 2, 2, 2) 18 pass","solution":"def submatrix_sum(matrix, row1, col1, row2, col2): Returns the sum of all the elements in the specified sub-matrix. total_sum = 0 for i in range(row1, row2 + 1): for j in range(col1, col2 + 1): total_sum += matrix[i][j] return total_sum"},{"question":"def min_flips_to_unify(coins: List[str]) -> int: Determines the minimum number of consecutive flips needed to make all coins the same. Args: coins (List[str]): List of 'H' and 'T' representing the sides of the coins. Returns: int: Minimum number of flips required. >>> min_flips_to_unify(['H', 'H', 'H']) == 0 >>> min_flips_to_unify(['T', 'T', 'T']) == 0 >>> min_flips_to_unify(['H', 'T', 'H', 'H', 'T']) == 2 >>> min_flips_to_unify(['T', 'T', 'H', 'H', 'T', 'H']) == 3 >>> min_flips_to_unify(['H', 'H', 'H', 'T', 'T', 'H']) == 2 >>> min_flips_to_unify(['H']) == 0 >>> min_flips_to_unify(['T']) == 0 >>> min_flips_to_unify(['H', 'T', 'H', 'T']) == 2 >>> min_flips_to_unify(['H', 'H', 'T', 'T', 'T']) == 2","solution":"def min_flips_to_unify(coins): Determines the minimum number of consecutive flips needed to make all coins the same. :param coins: List of 'H' and 'T' representing the sides of the coins. :return: Minimum number of flips required. # Count the number of heads and tails heads_count = coins.count('H') tails_count = len(coins) - heads_count # As all other coins are tails if not heads # Minimum flips would be the lesser of heads_count or tails_count return min(heads_count, tails_count)"},{"question":"def min_operations_to_sort_deck(n: int, perm: List[int]) -> int: Returns the minimum number of operations required to sort the deck in ascending order. >>> min_operations_to_sort_deck(5, [3, 1, 2, 5, 4]) 2 >>> min_operations_to_sort_deck(4, [4, 3, 2, 1]) 1","solution":"def min_operations_to_sort_deck(n, perm): Returns the minimum number of operations required to sort the deck in ascending order. sorted_perm = sorted(perm) if perm == sorted_perm: return 0 # Check if we can sort by one reverse for i in range(n): for j in range(i + 1, n): new_perm = perm[:i] + perm[i:j+1][::-1] + perm[j+1:] if new_perm == sorted_perm: return 1 # If can't be done with one reverse, then check if can be done with one swap for i in range(n): for j in range(i + 1, n): new_perm = perm[:i] + [perm[j]] + perm[i+1:j] + [perm[i]] + perm[j+1:] if new_perm == sorted_perm: return 1 # Otherwise, it can be done with at most 2 operations return 2"},{"question":"def longest_downward_trend(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Calculate the longest downward trend of meals served for each test case. A downward trend is a period of consecutive days where the number of meals served decreases each day compared to the previous day. Args: T: The number of test cases. test_cases: A list of tuples. Each tuple contains an integer N (number of days) and a list of N integers representing the number of meals served each day. Returns: A list of strings where each string is either the length of the longest downward trend or \\"NO TREND\\". >>> longest_downward_trend(3, [(7, [10, 9, 8, 7, 11, 6, 5]), (5, [5, 4, 4, 3, 2]), (4, [2, 2, 2, 2])]) ['3', '2', 'NO TREND'] >>> longest_downward_trend(1, [(3, [1, 2, 3])]) ['NO TREND']","solution":"def longest_downward_trend(T, test_cases): results = [] for i in range(T): N, meals = test_cases[i] if N < 2: results.append(\\"NO TREND\\") continue max_len = 0 current_len = 0 for j in range(1, N): if meals[j] < meals[j - 1]: current_len += 1 else: if current_len > 0: max_len = max(max_len, current_len) current_len = 0 if current_len > 0: max_len = max(max_len, current_len) if max_len == 0: results.append(\\"NO TREND\\") else: results.append(str(max_len)) return results"},{"question":"def is_balanced(s: str) -> str: Determines if the string s has balanced square brackets \`[\` and \`]\`. Parameters: s (str): The input string containing square brackets and other characters. Returns: str: \\"Balanced\\" if the brackets are balanced, otherwise \\"Not Balanced\\". >>> is_balanced(\\"a[b[c]d]e\\") == \\"Balanced\\" >>> is_balanced(\\"a[b[c]d\\") == \\"Not Balanced\\" >>> is_balanced(\\"abcde\\") == \\"Balanced\\" >>> is_balanced(\\"a[b]c]\\") == \\"Not Balanced\\" >>> is_balanced(\\"abc[de]fg[hij]\\") == \\"Balanced\\" >>> is_balanced(\\"[[abc[d]ef]]g[h]i]\\") == \\"Not Balanced\\"","solution":"def is_balanced(s): Determines if the string s has balanced square brackets \`[\` and \`]\`. Parameters: s (str): The input string containing square brackets and other characters. Returns: str: \\"Balanced\\" if the brackets are balanced, otherwise \\"Not Balanced\\". stack = [] for char in s: if char == '[': stack.append(char) elif char == ']': if not stack: return \\"Not Balanced\\" stack.pop() return \\"Balanced\\" if not stack else \\"Not Balanced\\""},{"question":"def count_distinct_characters(s: str, queries: List[str]) -> List[int]: Handles a list of queries on a given string. s: Initial string queries: List of queries of the form \`1 l r\` or \`2 k c\` Returns a list of results for \`1 l r\` queries. >>> count_distinct_characters(\\"abacaba\\", [\\"1 0 6\\", \\"2 2 d\\", \\"1 0 6\\", \\"2 6 e\\", \\"1 0 6\\"]) [3, 4, 5] >>> count_distinct_characters(\\"abc\\", [\\"1 0 2\\", \\"2 1 x\\", \\"1 0 2\\"]) [3, 3]","solution":"def count_distinct_characters(s, queries): Handles a list of queries on a given string. s: Initial string queries: List of queries of the form \`1 l r\` or \`2 k c\` Returns a list of results for \`1 l r\` queries result = [] string_list = list(s) for query in queries: query_parts = query.split() if query_parts[0] == '1': # '1 l r' query l, r = int(query_parts[1]), int(query_parts[2]) substring = string_list[l:r+1] distinct_count = len(set(substring)) result.append(distinct_count) elif query_parts[0] == '2': # '2 k c' query k, c = int(query_parts[1]), query_parts[2] string_list[k] = c return result"},{"question":"def min_steps_to_collect_unique(n: int, m: int, grid: List[List[int]]) -> int: Given a grid of size n x m filled with integers, find the minimum number of steps required to reach from the top-left corner to the bottom-right corner while collecting all unique integers. You can only move right or down. >>> min_steps_to_collect_unique(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 4 >>> min_steps_to_collect_unique(1, 1, [[1]]) 0 >>> min_steps_to_collect_unique(2, 2, [[1, 2], [3, 4]]) 2 >>> min_steps_to_collect_unique(2, 3, [[1, 2, 3], [4, 5, 3]]) 3 >>> min_steps_to_collect_unique(3, 3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 4 >>> min_steps_to_collect_unique(5, 5, [[1, 2, 2, 4, 5], [6, 7, 7, 9, 10], [11, 12, 12, 14, 15], [16, 17, 17, 19, 20], [21, 22, 22, 24, 25]]) 8","solution":"def min_steps_to_collect_unique(n, m, grid): from collections import deque def is_valid(x, y, collected, visited): return 0 <= x < n and 0 <= y < m and (x, y, tuple(collected)) not in visited start = (0, 0, tuple([grid[0][0]])) queue = deque([(0, 0, [grid[0][0]], 0)]) # (row, col, collected_values, steps) visited = set([start]) while queue: x, y, collected, steps = queue.popleft() if x == n - 1 and y == m - 1: return steps for dx, dy in [(1, 0), (0, 1)]: nx, ny = x + dx, y + dy if is_valid(nx, ny, collected, visited): new_collected = collected[:] if grid[nx][ny] not in new_collected: new_collected.append(grid[nx][ny]) new_state = (nx, ny, tuple(new_collected)) visited.add(new_state) queue.append((nx, ny, new_collected, steps + 1)) return -1 # In case no path is found # Example usage: # n = 3 # m = 3 # grid = [ # [1, 2, 3], # [4, 5, 6], # [7, 8, 9] # ] # print(min_steps_to_collect_unique(n, m, grid)) # Output: 4"},{"question":"def find_equilibrium(arr: list[int]) -> int: Returns the index of the equilibrium point if it exists, or -1 if it doesnt. >>> find_equilibrium([1, 3, 5, 2, 2]) 2 >>> find_equilibrium([1, 2, 3]) -1 >>> find_equilibrium([1]) 0 >>> find_equilibrium([-7, 1, 5, 2, -4, 3, 0]) 3 >>> find_equilibrium([]) -1","solution":"def find_equilibrium(arr: list[int]) -> int: Returns the index of the equilibrium point if it exists, or -1 if it doesnt. if not arr: return -1 total_sum = sum(arr) left_sum = 0 for i, num in enumerate(arr): # Calculate right sum by subtracting current element and left sum from total sum right_sum = total_sum - left_sum - num if left_sum == right_sum: return i left_sum += num return -1"},{"question":"from typing import List def count_valid_towers(fruits: List[int]) -> int: Given a list of fruits with their sweetness levels, count the number of valid towers following non-decreasing order of sweetness levels. >>> count_valid_towers([1, 2, 3]) 7 >>> count_valid_towers([2, 3, 1]) 7 >>> count_valid_towers([1, 1, 1]) 7 # Your code here def solve_dessert_towers(test_cases: List[List[int]]) -> List[int]: Given multiple test cases, count the number of valid towers for each case. >>> solve_dessert_towers([[1, 2, 3]]) [7] >>> solve_dessert_towers([[2, 3, 1]]) [7] >>> solve_dessert_towers([[1, 1, 1]]) [7] >>> solve_dessert_towers([[1, 2]]) [3] >>> solve_dessert_towers([[5]]) [1] >>> solve_dessert_towers([[1, 2, 3], [2, 3, 1], [2, 2, 1], [1, 3, 1]]) [7, 7, 7, 7] # Your code here","solution":"from itertools import combinations def count_valid_towers(fruits): Given a list of fruits with their sweetness levels, count the number of valid towers following non-decreasing order of sweetness levels. # Sort the sweetness levels to facilitate combination generation fruits.sort() n = len(fruits) total_towers = 0 # Generate all non-empty subsets of the sorted sweetness levels for i in range(1, n + 1): total_towers += len(list(combinations(fruits, i))) return total_towers def solve_dessert_towers(test_cases): results = [] for fruits in test_cases: results.append(count_valid_towers(fruits)) return results"},{"question":"from typing import List, Tuple def can_place_facilities(N: int, M: int, K: int, roads: List[Tuple[int, int, int]]) -> Tuple[str, List[int]]: Determines if it's possible to place K facilities in cities to ensure each city has a facility either in itself or in one of its neighboring cities. :param N: Number of cities :param M: Number of roads :param K: Number of facilities to be placed :param roads: A list of tuples representing the roads, where each tuple contains three integers (u, v, w) :return: A tuple with \\"YES\\" and a list of K cities if possible, otherwise \\"NO\\" pass # Example usage and tests if __name__ == \\"__main__\\": # Test case 1 N, M, K = 5, 4, 2 roads = [ (1, 2, 3), (2, 3, 2), (3, 4, 4), (4, 5, 1) ] print(can_place_facilities(N, M, K, roads)) # Expected output: (\\"YES\\", [2, 4]) # Test case 2 N, M, K = 5, 0, 5 roads = [] print(can_place_facilities(N, M, K, roads)) # Expected output: (\\"YES\\", [1, 2, 3, 4, 5]) # Test case 3 N, M, K = 5, 4, 1 roads = [ (1, 2, 3), (2, 3, 2), (3, 4, 4), (4, 5, 1) ] print(can_place_facilities(N, M, K, roads)) # Expected output: (\\"YES\\", [3]) # Test case 4 N, M, K = 5, 4, 1 roads = [ (1, 2, 3), (2, 3, 2), (4, 5, 1) ] print(can_place_facilities(N, M, K, roads)) # Expected output: (\\"NO\\") # Test case 5 N, M, K = 3, 1, 2 roads = [ (1, 2, 3) ] print(can_place_facilities(N, M, K, roads)) # Expected output: (\\"YES\\", [1, 3])","solution":"def can_place_facilities(N, M, K, roads): Determines if it's possible to place K facilities in cities to ensure each city has a facility either in itself or in one of its neighboring cities. if K >= N: # If K is greater than or equal to N, place a facility in each city. return \\"YES\\", list(range(1, K+1)) from collections import defaultdict graph = defaultdict(list) for u, v, w in roads: graph[u].append(v) graph[v].append(u) visited = [False] * (N + 1) components = [] def dfs(node, comp): stack = [node] while stack: u = stack.pop() if not visited[u]: visited[u] = True comp.append(u) for v in graph[u]: if not visited[v]: stack.append(v) for i in range(1, N+1): if not visited[i]: comp = [] dfs(i, comp) components.append(comp) if len(components) > K: return \\"NO\\", [] facilities = [] for comp in components: facilities.append(comp[0]) while len(facilities) < K: for comp in components: if len(comp) > 1: facilities.append(comp[1]) comp.remove(comp[1]) if len(facilities) == K: break return \\"YES\\", facilities"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"abcdefghijklmnopqrstuvwxyz\\") 26 >>> length_of_longest_substring(\\"aabbccddeeff\\") 2 >>> length_of_longest_substring(\\"abcdefggfedcba\\") 7 >>> length_of_longest_substring(\\"abcabcabcabcabcabcabcabcabcabc\\") 3","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_index_map = {} start = 0 max_length = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i max_length = max(max_length, i - start + 1) return max_length"},{"question":"def sum_of_diagonals(matrix): Return the sum of the elements along the two main diagonals of a n x n matrix. # Your code here def process_test_cases(t, test_cases): Process multiple test cases and return the sum of the diagonals for each test case. results = [] for case in test_cases: n, matrix = case results.append(sum_of_diagonals(matrix)) return results # Unit Tests def test_sum_of_diagonals(): assert sum_of_diagonals([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) == 30 assert sum_of_diagonals([ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ]) == 68 assert sum_of_diagonals([ [5] ]) == 10 assert sum_of_diagonals([ [1, 2], [3, 4] ]) == 10 assert sum_of_diagonals([ [-1, -2, -3], [-4, -5, -6], [-7, -8, -9] ]) == -30 def test_process_test_cases(): assert process_test_cases(2, [ (3, [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]), (4, [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ]) ]) == [30, 68] assert process_test_cases(1, [ (1, [ [5] ]), ]) == [10] assert process_test_cases(1, [ (2, [ [1, 2], [3, 4] ]), ]) == [10] assert process_test_cases(1, [ (3, [ [-1, -2, -3], [-4, -5, -6], [-7, -8, -9] ]), ]) == [-30]","solution":"def sum_of_diagonals(matrix): Return the sum of the elements along the two main diagonals of a n x n matrix. n = len(matrix) primary_diagonal_sum = sum(matrix[i][i] for i in range(n)) secondary_diagonal_sum = sum(matrix[i][n - i - 1] for i in range(n)) return primary_diagonal_sum + secondary_diagonal_sum def process_test_cases(t, test_cases): results = [] for case in test_cases: n, matrix = case results.append(sum_of_diagonals(matrix)) return results"},{"question":"def castle_connected_min_roads(input_str: str) -> List[Union[int, str]]: In a fictional land, there are N castles connected by M bidirectional roads. The king wants to ensure that every pair of castles is connected either directly by a road or indirectly through other castles. Additionally, the king prefers that the total number of roads used is minimal. Your task is to determine whether it's possible to achieve this requirement and, if so, provide the total number of roads needed. -----Input----- - The first line of the input contains a single integer T, denoting the number of test cases. The description of T test cases follows. - The first line of each test case contains two integers N and M, the number of castles and roads respectively. - Each of the subsequent M lines contains two integers u and v, indicating a road between castle u and castle v. -----Output----- For each test case, print a single line containing the string \\"IMPOSSIBLE\\" if it is not possible to connect all the castles either directly or indirectly. If it is possible, print a single line with the minimal number of roads needed to ensure all castles are connected. -----Constraints----- - 1 <= T <= 10 - 1 <= N <= 1000 - 0 <= M <= 10000 - 1 <= u, v <= N - No two roads connect the same pair of castles. -----Example----- Input: 2 4 3 1 2 2 3 3 4 5 2 1 2 4 5 Output: 3 IMPOSSIBLE Example input can be passed as a single string and output should be a list of results for each test case. >>> castle_connected_min_roads('2n4 3n1 2n2 3n3 4n5 2n1 2n4 5') [3, 'IMPOSSIBLE'] >>> castle_connected_min_roads('1n3 0') ['IMPOSSIBLE'] >>> castle_connected_min_roads('1n4 5n1 2n2 3n3 4n1 3n1 4') [3] >>> castle_connected_min_roads('1n5 2n1 2n3 4') ['IMPOSSIBLE'] >>> castle_connected_min_roads('1n1 0') [0]","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal_minimum_roads_needed(n, edges): parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) edges = sorted(edges, key=lambda item: item[2]) result = [] i = 0 e = 0 while e < n - 1: if i >= len(edges): return \\"IMPOSSIBLE\\" u, v, w = edges[i] i = i + 1 x = find(parent, u) y = find(parent, v) if x != y: e = e + 1 result.append([u, v, w]) union(parent, rank, x, y) return len(result) def process_castle_connection(data): result = [] for test_case in data: n, m, edges = test_case['n'], test_case['m'], test_case['edges'] if m < n - 1: result.append(\\"IMPOSSIBLE\\") else: edges_with_dummy_weight = [(u - 1, v - 1, 1) for u, v in edges] min_roads_needed = kruskal_minimum_roads_needed(n, edges_with_dummy_weight) result.append(min_roads_needed) return result def castle_connected_min_roads(input_str): lines = input_str.strip().split('n') t = int(lines[0]) data = [] index = 1 for _ in range(t): n, m = map(int, lines[index].split()) edges = [tuple(map(int, lines[index + i + 1].split())) for i in range(m)] data.append({'n': n, 'm': m, 'edges': edges}) index += m + 1 return process_castle_connection(data)"},{"question":"from typing import List def dailyTemperatures(temperatures: List[int]) -> List[int]: For each day, find how many days you would have to wait until a warmer temperature. If there is no future day that is warmer, return 0 for that day. Example: >>> dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> dailyTemperatures([100, 100, 100, 100]) [0, 0, 0, 0]","solution":"from typing import List def dailyTemperatures(temperatures: List[int]) -> List[int]: n = len(temperatures) answer = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: prev_day = stack.pop() answer[prev_day] = i - prev_day stack.append(i) return answer"},{"question":"def time_to_return(n: int, p: int, v: int) -> int: Returns the number of minutes it will take for Alex to return to the start point. :param n: int - the total circumference of the circular track in meters :param p: int - the current position of Alex on the track in meters :param v: int - the speed of Alex in meters per minute :return: int - the number of minutes it will take to return to the start point >>> time_to_return(100, 25, 20) 4 >>> time_to_return(500000, 499999, 1) 1 >>> time_to_return(30, 29, 2) 1 from solution import time_to_return def test_example_1(): assert time_to_return(100, 25, 20) == 4 def test_example_2(): assert time_to_return(500000, 499999, 1) == 1 def test_example_3(): assert time_to_return(30, 29, 2) == 1 def test_edge_case_start_at_zero(): assert time_to_return(1000, 0, 10) == 100 def test_single_meter_speed(): assert time_to_return(100, 1, 1) == 99 def test_run_multiple_laps(): assert time_to_return(200, 50, 100) == 2 def test_large_numbers(): assert time_to_return(1000000000, 999999999, 1) == 1","solution":"def time_to_return(n, p, v): Returns the number of minutes it will take for Alex to return to the start point. :param n: int - the total circumference of the circular track in meters :param p: int - the current position of Alex on the track in meters :param v: int - the speed of Alex in meters per minute :return: int - the number of minutes it will take to return to the start point return (n - p) // v if (n - p) % v == 0 else (n - p) // v + 1"},{"question":"def find_two_sum_indices(arr, target): Returns indices of two unique elements in the array that add up to the target sum as a sorted tuple. If no such pair exists, returns an empty list. >>> find_two_sum_indices([2, 7, 11, 15, -2], 9) [0, 1] >>> find_two_sum_indices([1, 2, 3, 4, 5], 10) [] >>> find_two_sum_indices([-1, -2, -3, -4, -5], -8) [2, 4] >>> find_two_sum_indices([1000000000, -999999999], 1) [0, 1] >>> find_two_sum_indices([1, 3], 4) [0, 1] >>> find_two_sum_indices([2, 15, 11, 7, -2], 9) [0, 3]","solution":"def find_two_sum_indices(arr, target): Returns a tuple of indices of two unique elements in the array that add up to the target sum. Indices in the output are sorted in ascending order. Returns an empty list if no such pair exists. num_to_index = {} for i, num in enumerate(arr): diff = target - num if diff in num_to_index: return sorted([num_to_index[diff], i]) num_to_index[num] = i return [] # Example usage if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) arr = list(map(int, data[1:n+1])) target = int(data[n+1]) print(find_two_sum_indices(arr, target))"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def balanceBST(root): Converts an unbalanced binary search tree (BST) into a balanced binary search tree with the same set of nodes. >>> root = TreeNode(30) >>> root.left = TreeNode(20) >>> root.right = TreeNode(40) >>> root.left.left = TreeNode(10) >>> root.left.right = TreeNode(25) >>> root.right.right = TreeNode(50) >>> balanced_root = balanceBST(root) >>> [balanced_root.val, balanced_root.left.val, balanced_root.right.val] [30, 20, 40] >>> root = TreeNode(50) >>> root.left = TreeNode(40) >>> root.left.left = TreeNode(30) >>> root.left.left.left = TreeNode(20) >>> root.left.left.left.left = TreeNode(10) >>> balanced_root = balanceBST(root) >>> [balanced_root.val, balanced_root.left.val, balanced_root.right.val] [30, 20, 50] pass def inOrderValues(root): if root is None: return [] return inOrderValues(root.left) + [root.val] + inOrderValues(root.right) def test_balance_already_balanced_bst(): root = TreeNode(30) root.left = TreeNode(20) root.right = TreeNode(40) root.left.left = TreeNode(10) root.left.right = TreeNode(25) root.right.right = TreeNode(50) balanced_root = balanceBST(root) balanced_values = inOrderValues(balanced_root) assert balanced_values == [10, 20, 25, 30, 40, 50] def test_balance_degenerate_bst(): root = TreeNode(50) root.left = TreeNode(40) root.left.left = TreeNode(30) root.left.left.left = TreeNode(20) root.left.left.left.left = TreeNode(10) balanced_root = balanceBST(root) balanced_values = inOrderValues(balanced_root) assert balanced_values == [10, 20, 30, 40, 50] def test_balance_single_node_bst(): root = TreeNode(5) balanced_root = balanceBST(root) balanced_values = inOrderValues(balanced_root) assert balanced_values == [5] def test_balance_two_nodes_bst(): root = TreeNode(10) root.left = TreeNode(5) balanced_root = balanceBST(root) balanced_values = inOrderValues(balanced_root) assert balanced_values == [5, 10]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inOrderTraversal(root, nodes): if root: inOrderTraversal(root.left, nodes) nodes.append(root) inOrderTraversal(root.right, nodes) def buildBalancedBST(nodes, start, end): if start > end: return None mid = (start + end) // 2 node = nodes[mid] node.left = buildBalancedBST(nodes, start, mid - 1) node.right = buildBalancedBST(nodes, mid + 1, end) return node def balanceBST(root): nodes = [] inOrderTraversal(root, nodes) return buildBalancedBST(nodes, 0, len(nodes) - 1)"},{"question":"from datetime import datetime from typing import List def filter_logs(n: int, start_time: str, end_time: str, logs: List[str]) -> List[str]: Filters log entries that fall within the specific time range [start_time, end_time]. Parameters: n (int): Number of log entries. start_time (str): The start time in the format \\"YYYY-MM-DD HH:MM:SS\\". end_time (str): The end time in the format \\"YYYY-MM-DD HH:MM:SS\\". logs (list of str): The log entries. Returns: list of str: Filtered log entries within the time range. pass # Test cases to validate the solution def test_logs_within_range(): n = 3 start_time = \\"2023-01-01 10:00:00\\" end_time = \\"2023-01-01 12:00:00\\" logs = [ \\"1 2023-01-01 09:59:59 System starting\\", \\"2 2023-01-01 10:30:00 User logged in\\", \\"3 2023-01-01 12:00:00 User logged out\\" ] result = filter_logs(n, start_time, end_time, logs) expected = [ \\"2 2023-01-01 10:30:00 User logged in\\", \\"3 2023-01-01 12:00:00 User logged out\\" ] assert result == expected def test_no_logs_within_range(): n = 3 start_time = \\"2023-01-01 09:00:00\\" end_time = \\"2023-01-01 09:30:00\\" logs = [ \\"1 2023-01-01 09:59:59 System starting\\", \\"2 2023-01-01 10:30:00 User logged in\\", \\"3 2023-01-01 12:00:00 User logged out\\" ] result = filter_logs(n, start_time, end_time, logs) expected = [\\"No logs found\\"] assert result == expected def test_logs_at_exact_boundaries(): n = 3 start_time = \\"2023-01-01 10:00:00\\" end_time = \\"2023-01-01 12:00:00\\" logs = [ \\"1 2023-01-01 10:00:00 System starting\\", \\"2 2023-01-01 11:00:00 System running\\", \\"3 2023-01-01 12:00:00 System shutting down\\" ] result = filter_logs(n, start_time, end_time, logs) expected = [ \\"1 2023-01-01 10:00:00 System starting\\", \\"2 2023-01-01 11:00:00 System running\\", \\"3 2023-01-01 12:00:00 System shutting down\\" ] assert result == expected def test_single_log_edge_case(): n = 1 start_time = \\"2023-01-01 10:00:00\\" end_time = \\"2023-01-01 12:00:00\\" logs = [ \\"1 2023-01-01 11:00:00 System update\\" ] result = filter_logs(n, start_time, end_time, logs) expected = [ \\"1 2023-01-01 11:00:00 System update\\" ] assert result == expected","solution":"from datetime import datetime def filter_logs(n, start_time, end_time, logs): Filters log entries that fall within the specific time range [start_time, end_time]. Parameters: n (int): Number of log entries. start_time (str): The start time in the format \\"YYYY-MM-DD HH:MM:SS\\". end_time (str): The end time in the format \\"YYYY-MM-DD HH:MM:SS\\". logs (list of str): The log entries. Returns: list of str: Filtered log entries within the time range. start = datetime.strptime(start_time, \\"%Y-%m-%d %H:%M:%S\\") end = datetime.strptime(end_time, \\"%Y-%m-%d %H:%M:%S\\") valid_logs = [] for log in logs: log_parts = log.split(' ', 2) log_id = log_parts[0] log_timestamp = log_parts[1] + ' ' + log_parts[2].split(' ', 1)[0] log_message = log_parts[2].split(' ', 1)[1] log_time = datetime.strptime(log_timestamp, \\"%Y-%m-%d %H:%M:%S\\") if start <= log_time <= end: valid_logs.append(f\\"{log_id} {log_timestamp} {log_message}\\") if not valid_logs: return [\\"No logs found\\"] return valid_logs"},{"question":"def treasure_hunt(clues, start): Determines the minimum number of steps required to find the treasure starting from a given initial clue. If the treasure is not reachable, returns -1. clues: List of tuples where each tuple contains two integers (a, b) representing that clue a leads to clue b. start: Integer representing the starting clue. Returns an integer, the number of steps to reach the treasure from the starting clue, or -1 if not reachable. def process_input(data): Processes multiple datasets and returns the results for each dataset. data: List of strings where each string represents the input as described in the problem statement. Returns a list of integers, each representing the result for the corresponding dataset. import pytest def test_treasure_hunt(): data = [ \\"5\\", \\"1 2\\", \\"2 3\\", \\"3 4\\", \\"4 0\\", \\"5 1\\", \\"1\\", \\"3\\", \\"1 3\\", \\"3 4\\", \\"4 3\\", \\"1\\", \\"0\\" ] expected = [4, -1] assert process_input(data) == expected def test_no_clues(): data = [ \\"0\\" ] expected = [] assert process_input(data) == expected def test_unreachable_treasure(): data = [ \\"3\\", \\"1 2\\", \\"2 3\\", \\"3 1\\", \\"1\\", \\"0\\" ] expected = [-1] assert process_input(data) == expected def test_direct_clue_to_treasure(): data = [ \\"1\\", \\"1 0\\", \\"1\\", \\"0\\" ] expected = [1] assert process_input(data) == expected def test_multiple_paths(): data = [ \\"4\\", \\"1 2\\", \\"2 3\\", \\"3 4\\", \\"4 0\\", \\"1\\", \\"0\\" ] expected = [4] assert process_input(data) == expected","solution":"def treasure_hunt(clues, start): from collections import deque graph = {} for a, b in clues: if a not in graph: graph[a] = [] graph[a].append(b) visited = set() queue = deque([(start, 0)]) while queue: current, steps = queue.popleft() if current in visited: continue visited.add(current) for next_clue in graph.get(current, []): if next_clue == 0: return steps + 1 queue.append((next_clue, steps + 1)) return -1 def process_input(data): results = [] index = 0 while index < len(data): n = int(data[index]) if n == 0: break index += 1 clues = [] for _ in range(n): a, b = map(int, data[index].split()) clues.append((a, b)) index += 1 start = int(data[index]) index += 1 result = treasure_hunt(clues, start) results.append(result) return results"},{"question":"def min_workers(tasks): Determines the minimum number of workers needed so that no two tasks overlap at any given time. Args: tasks (List[List[int]]): List of tasks, where each task is a list of two integers [start, end] Returns: int: Minimum number of workers required >>> min_workers([[1, 3], [2, 5], [4, 6]]) 2 >>> min_workers([[1, 2], [2, 3], [3, 4], [4, 5]]) 1 >>> min_workers([[1, 4], [3, 5], [0, 6], [5, 7], [8, 9]]) 3 >>> min_workers([[1, 2], [3, 4], [5, 6]]) 1 >>> min_workers([[1, 4], [2, 5], [3, 6]]) 3 >>> min_workers([[1, 10], [2, 6], [5, 8], [15, 18]]) 3 >>> min_workers([[0, 1]]) 1","solution":"def min_workers(tasks): Determines the minimum number of workers needed so that no two tasks overlap at any given time Args: tasks (List[List[int]]): List of tasks, where each task is a list of two integers [start, end] Returns: int: Minimum number of workers required events = [] for start, end in tasks: events.append((start, \\"start\\")) events.append((end, \\"end\\")) events.sort() max_workers = 0 current_workers = 0 for time, event in events: if event == \\"start\\": current_workers += 1 max_workers = max(max_workers, current_workers) else: current_workers -= 1 return max_workers"},{"question":"def minimumBattery(N, battery, M): Returns an array of minimum battery levels required for each drone to complete the round-trip. Parameters: N (int): Number of drones battery (list): List of battery consumption rates per minute for each drone M (int): Total minutes required for a round-trip delivery Returns: list: List of minimum battery levels for each drone >>> minimumBattery(4, [2, 3, 5, 1], 10) [20, 30, 50, 10] >>> minimumBattery(3, [4, 6, 2], 8) [32, 48, 16] from solution import minimumBattery def test_example_1(): assert minimumBattery(4, [2, 3, 5, 1], 10) == [20, 30, 50, 10] def test_example_2(): assert minimumBattery(3, [4, 6, 2], 8) == [32, 48, 16] def test_single_drone(): assert minimumBattery(1, [7], 5) == [35] def test_all_ones(): assert minimumBattery(5, [1, 1, 1, 1, 1], 10) == [10, 10, 10, 10, 10] def test_variable_consumption(): assert minimumBattery(3, [10, 20, 30], 1) == [10, 20, 30] def test_large_number_of_drones(): assert minimumBattery(100000, [1] * 100000, 5) == [5] * 100000","solution":"def minimumBattery(N, battery, M): Returns an array of minimum battery levels required for each drone to complete the round-trip. Parameters: N (int): Number of drones battery (list): List of battery consumption rates per minute for each drone M (int): Total minutes required for a round-trip delivery Returns: list: List of minimum battery levels for each drone return [rate * M for rate in battery]"},{"question":"def process_queries(n, arr, queries): Processes the given set of queries on the array. :param n: int - number of elements in the array :param arr: list - initial array values :param queries: list - list of queries to process :return: list - results of the sum queries results = [] return results # You can use the following test cases to validate your implementation: from solution import process_queries def test_process_queries_with_add_and_sum_operations(): n = 5 arr = [1, 2, 3, 4, 5] queries = [ [0, 1, 3, 2], [1, 0, 4], [1, 1, 2] ] assert process_queries(n, arr, queries) == [21, 9] def test_process_queries_without_add_operations(): n = 5 arr = [5, 5, 5, 5, 5] queries = [ [1, 0, 4], [1, 2, 3] ] assert process_queries(n, arr, queries) == [25, 10] def test_process_queries_all_add_operations(): n = 4 arr = [0, 1, 2, 3] queries = [ [0, 0, 3, 1], [0, 1, 2, 2] ] assert process_queries(n, arr, queries) == [] def test_process_queries_single_element_sum(): n = 6 arr = [1, 3, 5, 7, 9, 11] queries = [ [1, 2, 2], [1, 0, 0], [1, 5, 5] ] assert process_queries(n, arr, queries) == [5, 1, 11] def test_process_queries_large_add(): n = 3 arr = [1, 2, 3] queries = [ [0, 0, 2, 100], [1, 0, 2] ] assert process_queries(n, arr, queries) == [306]","solution":"def process_queries(n, arr, queries): Processes the given set of queries on the array. :param n: int - number of elements in the array :param arr: list - initial array values :param queries: list - list of queries to process :return: list - results of the sum queries results = [] for query in queries: if query[0] == 0: # Add operation _, a, b, x = query for i in range(a, b + 1): arr[i] += x elif query[0] == 1: # Sum operation _, a, b = query sum_subarray = sum(arr[a:b + 1]) results.append(sum_subarray) return results"},{"question":"def ticket_counter(N: int, M: int, events: List[List[int]]) -> List[int]: A ticket counter has N service windows numbered from 1 to N. A person at the front of each window's queue is being served. When people arrive at the ticket counter, they will choose the window with the fewest people in line and join it at the end. In the case of multiple windows having the same shortest queue, they will choose the window with the lowest number. After being served, the person will leave the window and the next in line, if any, will be served. Once a person enters a queue, they cannot switch to another. Also, the order of people in the queue cannot be altered. Given information about the number of windows, the arrivals of the people, and the windows that completed a service, write a program to output the order of people served. Each arrival is specified by a unique identifier, and each service completion references a window number. Input The input is given in the following format. N M event_1 event_2 ... event_M >>> ticket_counter(3, 8, [[1, 105], [1, 102], [1, 110], [0, 3], [1, 120], [0, 1], [0, 2], [0, 1]]) [110, 105, 102, 120] >>> ticket_counter(2, 6, [[1, 500], [1, 600], [0, 1], [1, 700], [0, 2], [0, 1]]) [500, 600, 700]","solution":"from collections import deque import heapq def ticket_counter(N, M, events): queues = [deque() for _ in range(N)] heap = [] serving_order = [] for i in range(N): heapq.heappush(heap, (0, i)) for event in events: e_type, value = event if e_type == 1: # Arrival queue_length, window = heapq.heappop(heap) queues[window].append(value) heapq.heappush(heap, (queue_length + 1, window)) elif e_type == 0: # Service completion person_served = queues[value - 1].popleft() serving_order.append(person_served) queue_length, window = heapq.heappop(heap) heapq.heappush(heap, (queue_length - 1, window)) return serving_order"},{"question":"def sum_of_unique_elements(test_cases): Find the sum of all unique elements in each array of test cases. Args: test_cases (List[Tuple[int, List[int]]]): A list of tuples where the first element is the length of the array and the second element is the array itself. Returns: List[int]: A list of integers where each integer is the sum of unique elements in the corresponding test case. >>> sum_of_unique_elements([(5, [1, 2, 2, 3, 4]), (4, [1, 1, 1, 1]), (6, [5, 5, 5, 5, 5, 5])]) [10, 1, 5] >>> sum_of_unique_elements([(5, [1000000000, 999999999, 1000000000, 999999999, 5])]) [2000000004] results = [] for n, array in test_cases: unique_elements = set(array) results.append(sum(unique_elements)) return results from sum_of_unique_elements import test_sum_of_unique_elements def test_sum_of_unique_elements_example(): test_cases = [ (5, [1, 2, 2, 3, 4]), (4, [1, 1, 1, 1]), (6, [5, 5, 5, 5, 5, 5]) ] expected = [10, 1, 5] assert sum_of_unique_elements(test_cases) == expected def test_sum_of_unique_elements_single_element(): test_cases = [ (1, [1]), (1, [999999999]), (1, [0]) ] expected = [1, 999999999, 0] assert sum_of_unique_elements(test_cases) == expected def test_sum_of_unique_elements_mixed(): test_cases = [ (5, [1, 1, 2, 2, 3]), (3, [5, 3, 3]), (4, [4, 4, 4, 8]) ] expected = [6, 8, 12] assert sum_of_unique_elements(test_cases) == expected def test_sum_of_unique_elements_large_values(): test_cases = [ (5, [1000000000, 999999999, 1000000000, 999999999, 5]), ] expected = [2000000004] assert sum_of_unique_elements(test_cases) == expected","solution":"def sum_of_unique_elements(test_cases): results = [] for n, array in test_cases: unique_elements = set(array) results.append(sum(unique_elements)) return results"},{"question":"from typing import List, Tuple def find_maximum_machines(N: int, M: int, relationships: List[Tuple[int, int]]) -> int: Determine the maximum number of fully connected machines that can be assembled with the given gears and their compatibility. Args: N (int): Number of gears. M (int): Number of compatibility relationships. relationships (List[Tuple[int, int]]): List of compatibility pairs where each pair is a tuple (u, v) indicating gear u and gear v are compatible. Returns: int: The maximum number of fully connected machines. Example: >>> find_maximum_machines(5, 4, [(1, 2), (1, 3), (4, 5), (2, 3)]) 2 >>> find_maximum_machines(6, 9, [(1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (2, 3), (2, 4), (2, 5), (2, 6)]) 1 >>> find_maximum_machines(8, 10, [(1, 2), (1, 3), (2, 3), (4, 5), (6, 7), (7, 8), (6, 8), (4, 6), (5, 7), (5, 8)]) 2 def test_example_1(): N = 5 M = 4 relationships = [(1, 2), (1, 3), (4, 5), (2, 3)] assert find_maximum_machines(N, M, relationships) == 2 def test_example_2(): N = 6 M = 9 relationships = [(1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (2, 3), (2, 4), (2, 5), (2, 6)] assert find_maximum_machines(N, M, relationships) == 1 def test_example_3(): N = 8 M = 10 relationships = [(1, 2), (1, 3), (2, 3), (4, 5), (6, 7), (7, 8), (6, 8), (4, 6), (5, 7), (5, 8)] assert find_maximum_machines(N, M, relationships) == 2 def test_no_relationships(): N = 5 M = 0 relationships = [] assert find_maximum_machines(N, M, relationships) == 0 def test_all_gears_connected(): N = 4 M = 6 relationships = [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)] assert find_maximum_machines(N, M, relationships) == 1","solution":"def find_maximum_machines(N, M, relationships): from collections import defaultdict, deque # Build the graph graph = defaultdict(list) for u, v in relationships: graph[u].append(v) graph[v].append(u) # Function to perform BFS and get all nodes in the same connected component def bfs(start): visited = set() queue = deque([start]) while queue: node = queue.popleft() visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return visited visited_all = set() machines_count = 0 for gear in range(1, N + 1): if gear not in visited_all: connected_component = bfs(gear) if len(connected_component) > 1: machines_count += 1 visited_all.update(connected_component) return machines_count # Example usage: # relationships = [(1, 2), (1, 3), (4, 5), (2, 3)] # print(find_maximum_machines(5, 4, relationships)) # Output: 2"},{"question":"def min_sprinklers_needed(T: int, cases: List[Tuple[int, int]]) -> List[int]: Determine the minimum number of sprinklers needed to ensure all plants are watered. Args: T: int - The number of test cases. cases: List[Tuple[int, int]] - A list of tuples, each containing two integers, N and R. Returns: List[int] - A list of integers, where each integer is the minimum number of sprinklers needed for the corresponding test case. >>> min_sprinklers_needed(2, [(5, 1), (6, 2)]) [2, 2] >>> min_sprinklers_needed(1, [(10, 3)]) [2] >>> min_sprinklers_needed(1, [(1, 1)]) [1] >>> min_sprinklers_needed(1, [(1000, 1)]) [334] >>> min_sprinklers_needed(1, [(5, 0)]) [5]","solution":"def min_sprinklers_needed(T, cases): results = [] for N, R in cases: if R == 0: results.append(N) else: sprinkler_range = 2 * R + 1 sprinklers_needed = (N + sprinkler_range - 1) // sprinkler_range results.append(sprinklers_needed) return results"},{"question":"from typing import List, Tuple def min_difference(t: int, cases: List[Tuple[int, int]]) -> List[int]: This function calculates the minimum absolute difference between sizes of groups after dividing n items into k groups, for t test cases. Parameters: t (int): Number of test cases. cases (list of tuples): Each tuple contains two integers n (number of items) and k (number of groups). Returns: list of int: List of minimum differences for each test case. >>> min_difference(5, [(10, 3), (15, 4), (7, 7), (8, 4), (1, 1)]) [1, 1, 0, 0, 0] >>> min_difference(2, [(10**9, 10**9), (10**9, 1)]) [0, 0] >>> min_difference(3, [(5, 6), (100, 101), (200, 300)]) [0, 0, 0] >>> min_difference(2, [(8, 4), (12, 6)]) [0, 0] >>> min_difference(3, [(1, 1), (1, 2), (1, 10)]) [0, 0, 0] >>> min_difference(3, [(100, 9), (123, 5), (500000, 12345)]) [1, 1, 1]","solution":"def min_difference(t, cases): This function calculates the minimum absolute difference between sizes of groups after dividing n items into k groups, for t test cases. Parameters: t (int): Number of test cases. cases (list of tuples): Each tuple contains two integers n (number of items) and k (number of groups). Returns: list of int: List of minimum differences for each test case. results = [] for n, k in cases: # If k is greater than or equal to n, we can only place one item in each k groups # and the rest of (k-n) groups will be empty. if k >= n: results.append(0) else: # Calculate the size of each group if items were divided as evenly as possible q, r = divmod(n, k) # We will have r groups with (q+1) items and (k-r) groups with q items min_diff = 1 if r > 0 else 0 results.append(min_diff) return results"},{"question":"def sieve_of_eratosthenes(n: int) -> List[int]: Returns a list of prime numbers up to n (inclusive) using the Sieve of Eratosthenes algorithm. The Sieve of Eratosthenes algorithm works by iteratively marking the multiples of each prime number starting from 2. The numbers which remain unmarked till the end are the prime numbers. >>> sieve_of_eratosthenes(10) [2, 3, 5, 7] >>> sieve_of_eratosthenes(1) [] >>> sieve_of_eratosthenes(2) [2] >>> sieve_of_eratosthenes(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> sieve_of_eratosthenes(0) [] >>> sieve_of_eratosthenes(-5) [] >>> sieve_of_eratosthenes(100) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]","solution":"def sieve_of_eratosthenes(n): Returns a list of prime numbers up to n using the Sieve of Eratosthenes algorithm. if n < 2: return [] is_prime = [True] * (n + 1) p = 2 while (p * p <= n): if (is_prime[p]): for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 primes = [p for p in range(2, n + 1) if is_prime[p]] return primes"},{"question":"def minimal_connection_network(T: int, test_cases: List[Tuple[Tuple[int, int], List[Tuple[int, int, int]]]]) -> List[int]: Determine the minimum total weight required for the Minimal Connection Network. >>> minimal_connection_network(1, [((4, 5), [(1, 2, 1), (2, 3, 2), (3, 4, 4), (4, 1, 3), (1, 3, 5)])]) [6] >>> minimal_connection_network(2, [((4, 5), [(1, 2, 1), (2, 3, 2), (3, 4, 4), (4, 1, 3), (1, 3, 5)]), ((3, 3), [(1, 2, 3), (2, 3, 1), (3, 1, 2)])]) [6, 3]","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def kruskal_mst(n, edges): edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) result = [] i = 0 e = 0 while e < n - 1: if i >= len(edges): break u, v, w = edges[i] i = i + 1 x = find(parent, u - 1) y = find(parent, v - 1) if x != y: e = e + 1 result.append((u, v, w)) union(parent, rank, x, y) minimum_cost = 0 for u, v, weight in result: minimum_cost += weight return minimum_cost def minimal_connection_network(T, test_cases): results = [] for t in range(T): N, M = test_cases[t][0] edges = test_cases[t][1:] results.append(kruskal_mst(N, edges)) return results"},{"question":"def sort_stones(stones: List[str]) -> List[str]: Sort the stones based on specific rules: 1. Stones with no markings should come first. 2. Stones with red markings should come next. 3. Stones with green markings should come next. 4. Stones with blue markings should come next. 5. Stones with multiple colors in their markings should come last. >>> sort_stones([\\"red\\", \\"green\\", \\"blue\\", \\"red\\", \\"green\\"]) == [\\"red\\", \\"red\\", \\"green\\", \\"green\\", \\"blue\\"] >>> sort_stones([\\"fav\\", \\"yellow\\", \\"green\\", \\"blue\\", \\"red\\", \\"purple\\"]) == [\\"red\\", \\"green\\", \\"blue\\", \\"fav\\", \\"yellow\\", \\"purple\\"] >>> sort_stones([\\"\\", \\"red\\", \\"\\", \\"blue\\", \\"green\\", \\"blue\\", \\"\\"]) == [\\"\\", \\"\\", \\"\\", \\"red\\", \\"green\\", \\"blue\\", \\"blue\\"] >>> sort_stones([\\"red\\", \\"green\\", \\"blue\\", \\"pink\\", \\"purple\\", \\"green\\", \\"red\\", \\"\\"]) == [\\"\\", \\"red\\", \\"red\\", \\"green\\", \\"green\\", \\"blue\\", \\"pink\\", \\"purple\\"] >>> sort_stones([\\"\\", \\"\\", \\"\\"]) == [\\"\\", \\"\\", \\"\\"]","solution":"def sort_stones(stones): Sort the stones based on specific rules. Parameters: stones (list of str): List of stone markings. Returns: list of str: Sorted list of stone markings. def sorting_key(stone): if stone == \\"\\": return 0 elif stone == \\"red\\": return 1 elif stone == \\"green\\": return 2 elif stone == \\"blue\\": return 3 else: return 4 stones.sort(key=sorting_key) return stones"},{"question":"def modify_pattern(initial_pattern: List[int], commands: List[Tuple[int, int]]) -> List[int]: Modifies the initial pattern based on the given commands. :param initial_pattern: List of 10 integers representing the initial pattern. :param commands: List of tuples where each tuple consists of two integers (button, presses). :return: List of 10 integers representing the final pattern. >>> modify_pattern([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [(0, 5), (1, 3), (9, 1)]) [6, 5, 3, 4, 5, 6, 7, 8, 9, 11] >>> modify_pattern([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [(0, 100), (1, 100)]) [100, 100, 0, 0, 0, 0, 0, 0, 0, 0]","solution":"def modify_pattern(initial_pattern, commands): Modifies the initial pattern based on the given commands. :param initial_pattern: List of 10 integers representing the initial pattern. :param commands: List of tuples where each tuple consists of two integers (button, presses). :return: List of 10 integers representing the final pattern. for button, presses in commands: initial_pattern[button] += presses return initial_pattern"},{"question":"def minInsertionsPalindrome(s: str) -> int: Returns the minimum number of insertions required to make the string s a palindrome. >>> minInsertionsPalindrome(\\"race\\") 3 >>> minInsertionsPalindrome(\\"madam\\") 0 >>> minInsertionsPalindrome(\\"abca\\") 1","solution":"def minInsertionsPalindrome(s): Returns the minimum number of insertions required to make string s a palindrome. n = len(s) # Create a table to store results of subproblems dp = [[0 for i in range(n)] for j in range(n)] # Build the table. Note that the lower diagonal values of the table # are useless and not filled in the process. The table is filled # in a manner similar to Matrix Chain Multiplication DP solution for gap in range(1, n): for l in range(n-gap): h = l + gap if s[l] == s[h]: dp[l][h] = dp[l+1][h-1] else: dp[l][h] = min(dp[l][h-1], dp[l+1][h]) + 1 return dp[0][n-1] # Example usage: # s = \\"race\\" # print(minInsertionsPalindrome(s)) # Output: 3"},{"question":"def fair_age_distribution(ages): Determine if the number of participants aged below 18 (children) is less than or equal to the number of participants aged 18 and above (adults). Parameters: ages (list): A list of integers representing ages of participants. Returns: bool: True if children are less or equal in number to adults, False otherwise. >>> fair_age_distribution([17, 18]) True >>> fair_age_distribution([17, 16, 18]) False >>> fair_age_distribution([20, 30, 15, 40]) True >>> fair_age_distribution([18, 19, 20]) True >>> fair_age_distribution([16, 17, 13]) False >>> fair_age_distribution([1, 19, 35, 45, 5]) True >>> fair_age_distribution([16, 17, 13, 14, 20]) False >>> fair_age_distribution([9, 12, 65, 33]) True","solution":"def fair_age_distribution(ages): Determine if the number of participants aged below 18 (children) is less than or equal to the number of participants aged 18 and above (adults). Parameters: ages (list): A list of integers representing ages of participants. Returns: bool: True if children are less or equal in number to adults, False otherwise. children = sum(1 for age in ages if age < 18) adults = sum(1 for age in ages if age >= 18) return children <= adults"},{"question":"def smallestPeriod(rainfall, threshold): Returns the length of the smallest period where the cumulative rainfall surpasses the given threshold. If it's impossible, returns -1. >>> smallestPeriod([2, 3, 1, 2, 4, 3], 7) 2 >>> smallestPeriod([1, 1, 1, 1, 1], 3) 3 >>> smallestPeriod([1, 2, 3], 7) -1","solution":"def smallestPeriod(rainfall, threshold): Returns the length of the smallest period where the cumulative rainfall surpasses the given threshold. If it's impossible, returns -1. n = len(rainfall) start = 0 sum_rainfall = 0 min_length = float('inf') for end in range(n): sum_rainfall += rainfall[end] while sum_rainfall >= threshold: min_length = min(min_length, end - start + 1) sum_rainfall -= rainfall[start] start += 1 return min_length if min_length != float('inf') else -1"},{"question":"def minAdditionalHills(n: int, heights: List[int]) -> int: Determine the minimum number of additional hills that need to be constructed such that no hill's height is the same as any of its adjacent hills. If it is already not possible, return -1. >>> minAdditionalHills(5, [1, 2, 2, 3, 4]) 1 >>> minAdditionalHills(3, [3, 3, 3]) 2 >>> minAdditionalHills(4, [1, 2, 1, 2]) 0 >>> minAdditionalHills(1, [5]) 0 >>> minAdditionalHills(5, [1, 2, 3, 4, 5]) 0 >>> minAdditionalHills(5, [1, 1, 1, 1, 1]) 4 >>> minAdditionalHills(6, [1, 2, 1, 2, 1, 2]) 0","solution":"def minAdditionalHills(n, heights): if n == 1: return 0 changes = 0 for i in range(1, n): if heights[i] == heights[i - 1]: changes += 1 # Change current hill to avoid duplication with neighbors if i + 1 < n and heights[i] != heights[i + 1]: heights[i] = float('inf') # Inaccessible number making sure this index is counted as changed return changes"},{"question":"from typing import List, Tuple, Union def library_management_system(N: int, M: int, Q: int, operations: List[Union[Tuple[int, int, int], Tuple[int, int], Tuple[int]]]) -> List[Union[str, int]]: Implements a library management system that handles the following operations: 1. Borrow a book 2. Return a book 3. Check availability of a book 4. Determine the most borrowed book Args: N (int): Number of books. M (int): Number of readers. Q (int): Number of operations. operations (List[Union[Tuple[int, int, int], Tuple[int, int], Tuple[int]]]): List of operations to be performed. Returns: List[Union[str, int]]: Results of the operations that produce an output. >>> library_management_system(5, 3, 7, [(1, 1, 2), (1, 2, 3), (3, 2), (2, 1, 2), (3, 2), (4,), (1, 3, 2)]) [\\"Not Available\\", \\"Available\\", 3] >>> library_management_system(5, 3, 4, [(1, 1, 1), (3, 1), (2, 1, 1), (3, 1)]) [\\"Not Available\\", \\"Available\\"] >>> library_management_system(5, 3, 5, [(1, 1, 1), (1, 2, 2), (2, 1, 1), (1, 3, 1), (4,)]) [1] >>> library_management_system(5, 3, 7, [(1, 1, 1), (1, 2, 2), (2, 1, 1), (1, 3, 1), (2, 2, 2), (1, 2, 2), (4,)]) [1] >>> library_management_system(5, 3, 1, [(3, 5)]) [\\"Available\\"] pass def process_input(N: int, M: int, Q: int, operations: List[Tuple[int, ...]]) -> List[Union[str, int]]: return library_management_system(N, M, Q, operations) # Unit tests def test_library_management_system(): input_operations = [ (1, 1, 2), # Borrow book 2 by reader 1 (1, 2, 3), # Borrow book 3 by reader 2 (3, 2), # Check availability of book 2 (Expected: Not Available) (2, 1, 2), # Return book 2 by reader 1 (3, 2), # Check availability of book 2 (Expected: Available) (4,), # Determine the most borrowed book (Expected: 2 or 3) (1, 3, 2) # Borrow book 2 by reader 3 ] expected_output = [\\"Not Available\\", \\"Available\\", 2] assert process_input(5, 3, 7, input_operations) == expected_output def test_borrow_return(): input_operations = [ (1, 1, 1), # Borrow book 1 by reader 1 (3, 1), # Check availability of book 1 (Expected: Not Available) (2, 1, 1), # Return book 1 by reader 1 (3, 1) # Check availability of book 1 (Expected: Available) ] expected_output = [\\"Not Available\\", \\"Available\\"] assert process_input(5, 3, 4, input_operations) == expected_output def test_most_borrowed(): input_operations = [ (1, 1, 1), # Borrow book 1 by reader 1 (1, 2, 2), # Borrow book 2 by reader 2 (2, 1, 1), # Return book 1 by reader 1 (1, 3, 1), # Borrow book 1 by reader 3 (4,) # Determine the most borrowed book (Expected: 1) ] expected_output = [1] assert process_input(5, 3, 5, input_operations) == expected_output def test_tie_most_borrowed(): input_operations = [ (1, 1, 1), # Borrow book 1 by reader 1 (1, 2, 2), # Borrow book 2 by reader 2 (2, 1, 1), # Return book 1 by reader 1 (1, 3, 1), # Borrow book 1 by reader 3 (2, 2, 2), # Return book 2 by reader 2 (1, 2, 2), # Borrow book 2 by reader 2 (4,) # Determine the most borrowed book (Expected: 1) ] expected_output = [1] assert process_input(5, 3, 7, input_operations) == expected_output def test_check_unborrowed_book(): input_operations = [ (3, 5), # Check availability of book 5 (Expected: Available) ] expected_output = [\\"Available\\"] assert process_input(5, 3, 1, input_operations) == expected_output","solution":"def library_management_system(operations): from collections import defaultdict # Initialize data structures book_status = {} borrow_count = defaultdict(int) most_borrowed_count = 0 most_borrowed_book = None results = [] for operation in operations: op = operation[0] if op == 1: # Borrow a book reader_id, book_id = operation[1], operation[2] if book_status.get(book_id, True): book_status[book_id] = False borrow_count[book_id] += 1 if borrow_count[book_id] > most_borrowed_count or (borrow_count[book_id] == most_borrowed_count and (most_borrowed_book is None or book_id < most_borrowed_book)): most_borrowed_count = borrow_count[book_id] most_borrowed_book = book_id elif op == 2: # Return a book reader_id, book_id = operation[1], operation[2] book_status[book_id] = True elif op == 3: # Check availability of a book book_id = operation[1] if book_status.get(book_id, True): results.append(\\"Available\\") else: results.append(\\"Not Available\\") elif op == 4: # Determine the most borrowed book results.append(most_borrowed_book) return results # Function to process inputs def process_input(N, M, Q, operations): return library_management_system(operations)"},{"question":"def find_repeated_twice(n: int, arr: List[int]) -> int: Given a sequence of n integers, find and return any integer that is repeated exactly twice in the sequence. :param n: The length of the sequence. :param arr: A list of n positive integers. :return: Any integer that is repeated exactly twice in the sequence. Example: >>> find_repeated_twice(5, [3, 2, 3, 6, 1]) 3 from typing import List def test_sample_input_0(): assert find_repeated_twice(5, [3, 2, 3, 6, 1]) == 3 def test_repeated_at_start(): assert find_repeated_twice(6, [5, 5, 1, 2, 3, 6]) == 5 def test_repeated_at_end(): assert find_repeated_twice(6, [1, 3, 4, 2, 6, 6]) == 6 def test_multiple_repeated_numbers(): result = find_repeated_twice(7, [4, 4, 5, 5, 3, 2, 1]) assert result in [4, 5] # Either 4 or 5 is correct def test_large_input(): large_arr = [i for i in range(1, 100001)] large_arr.append(100000) assert find_repeated_twice(100001, large_arr) == 100000","solution":"def find_repeated_twice(n, arr): Given an array of n integers, find and return any integer which is repeated exactly twice in the array. :param n: An integer representing the length of the array :param arr: A list of n integers :return: An integer that is repeated exactly twice in the array from collections import Counter # Count the frequency of each number in the array frequency = Counter(arr) # Find and return the number that is repeated exactly twice for num, count in frequency.items(): if count == 2: return num"},{"question":"def gcd(a: int, b: int) -> int: Calculate the greatest common divisor (GCD) of two numbers. >>> gcd(4, 6) 2 >>> gcd(6, 8) 2 >>> gcd(10, 15) 5 pass def lcm(n: int, m: int) -> int: Calculate the least common multiple (LCM) of two numbers. >>> lcm(4, 6) 12 >>> lcm(6, 8) 24 >>> lcm(10, 15) 30 pass","solution":"def gcd(a, b): Calculate the greatest common divisor (GCD) of two numbers. while b: a, b = b, a % b return a def lcm(n, m): Calculate the least common multiple (LCM) of two numbers. return abs(n * m) // gcd(n, m)"},{"question":"def classify_triangle(a: int, b: int, c: int) -> str: Classifies a triangle based on its side lengths a, b, and c. Returns \\"Equilateral\\", \\"Isosceles\\", \\"Scalene\\", or \\"Not a triangle\\". pass def process_input(input_lines: List[str]) -> List[str]: Processes a list of input lines containing side lengths and classifies each potential triangle. pass import pytest def test_classify_triangle_equilateral(): assert classify_triangle(3, 3, 3) == \\"Equilateral\\" def test_classify_triangle_scalene(): assert classify_triangle(3, 4, 5) == \\"Scalene\\" def test_classify_triangle_isosceles(): assert classify_triangle(2, 2, 3) == \\"Isosceles\\" assert classify_triangle(2, 3, 2) == \\"Isosceles\\" assert classify_triangle(3, 2, 2) == \\"Isosceles\\" def test_classify_triangle_not_a_triangle(): assert classify_triangle(1, 10, 12) == \\"Not a triangle\\" assert classify_triangle(1, 2, 3) == \\"Not a triangle\\" def test_process_input(): input_lines = [ \\"3 3 3\\", \\"3 4 5\\", \\"2 2 3\\", \\"1 10 12\\", \\"0 0 0\\" ] expected_output = [ \\"Equilateral\\", \\"Scalene\\", \\"Isosceles\\", \\"Not a triangle\\" ] assert process_input(input_lines) == expected_output def test_classify_triangle_upper_bounds(): assert classify_triangle(1000, 1000, 1000) == \\"Equilateral\\" assert classify_triangle(1000, 999, 1000) == \\"Isosceles\\" assert classify_triangle(999, 1000, 1001) == \\"Scalene\\" assert classify_triangle(1000, 1, 1001) == \\"Not a triangle\\" @pytest.fixture def sample_input(): return [ \\"3 3 3\\", \\"3 4 5\\", \\"2 2 3\\", \\"1 10 12\\", \\"0 0 0\\" ] @pytest.fixture def sample_output(): return [ \\"Equilateral\\", \\"Scalene\\", \\"Isosceles\\", \\"Not a triangle\\" ] def test_process_input_with_fixtures(sample_input, sample_output): assert process_input(sample_input) == sample_output","solution":"def classify_triangle(a, b, c): Classifies a triangle based on its side lengths a, b, and c. Returns \\"Equilateral\\", \\"Isosceles\\", \\"Scalene\\", or \\"Not a triangle\\". # Check if it is a valid triangle if a + b <= c or a + c <= b or b + c <= a: return \\"Not a triangle\\" # Check for Equilateral if a == b == c: return \\"Equilateral\\" # Check for Isosceles if a == b or b == c or a == c: return \\"Isosceles\\" # If not any of the above, it must be Scalene return \\"Scalene\\" def process_input(input_lines): Processes a list of input lines containing side lengths and classifies each potential triangle. results = [] for line in input_lines: a, b, c = map(int, line.split()) if a == 0 and b == 0 and c == 0: break results.append(classify_triangle(a, b, c)) return results"},{"question":"def isRobotBackToOrigin(moves: str) -> bool: Checks if the robot returns to the origin after a sequence of moves. Parameters: moves (str): A string representing the sequence of moves Returns: bool: True if the robot returns to (0, 0), False otherwise. >>> isRobotBackToOrigin(\\"UD\\") True >>> isRobotBackToOrigin(\\"LL\\") False","solution":"def isRobotBackToOrigin(moves: str) -> bool: Checks if the robot returns to the origin after a sequence of moves. Parameters: moves (str): a string representing the sequence of moves Returns: bool: True if the robot returns to (0, 0), False otherwise x, y = 0, 0 # Starting position (0, 0) for move in moves: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 return x == 0 and y == 0 # Check if the robot is back to the origin"},{"question":"def longest_substring_two_distinct(s: str) -> str: Returns the longest substring with exactly two distinct characters. If there are multiple such substrings of the same length, returns the one which appears first. >>> longest_substring_two_distinct(\\"abcbbbbcccbdddadacb\\") == \\"bcbbbbcccb\\" >>> longest_substring_two_distinct(\\"aabbcc\\") == \\"aabb\\" >>> longest_substring_two_distinct(\\"a\\") == \\"\\" >>> longest_substring_two_distinct(\\"aa\\") == \\"aa\\" >>> longest_substring_two_distinct(\\"abc\\") == \\"ab\\" >>> longest_substring_two_distinct(\\"aabacbebebe\\") == \\"bebebe\\"","solution":"def longest_substring_two_distinct(s): Returns the longest substring with exactly two distinct characters. If there are multiple such substrings of the same length, returns the one which appears first. from collections import defaultdict if len(s) < 2: return \\"\\" start = 0 max_length = 0 max_substring = \\"\\" char_map = defaultdict(int) for end in range(len(s)): char_map[s[end]] += 1 while len(char_map) > 2: char_map[s[start]] -= 1 if char_map[s[start]] == 0: del char_map[s[start]] start += 1 current_length = end - start + 1 if current_length > max_length: max_length = current_length max_substring = s[start:end + 1] return max_substring"},{"question":"def process_queries(n: int, q: int, arr: List[int], queries: List[List[int]]) -> List[int]: Given an array of n integers and q queries, calculate the maximum sum of any subarray in the array after performing updates on it. Each query can either 1) Update the value of an element in the array. 2) Find the maximum sum of any subarray in the current array. Parameters: - n: number of elements in the array. - q: number of queries. - arr: list of integers representing the initial elements of the array. - queries: list of queries where each query can update an element or find the max sum of a subarray. Returns: - List[int]: results of each query that finds the maximum sum of any subarray. Example: >>> process_queries(5, 4, [1, 2, 3, -2, 5], [[2], [1, 2, -10], [2], [1, 3, 4]]) [9, 0, 9] # Your implementation here def test_process_queries(): n = 5 q = 4 arr = [1, 2, 3, -2, 5] queries = [ [2], [1, 2, -10], [2], [1, 3, 4], [2] ] expected_output = [9, 6, 7] assert process_queries(n, q, arr, queries) == expected_output def test_single_element_updates(): n = 1 q = 2 arr = [5] queries = [ [2], [1, 1, -5], [2] ] expected_output = [5, -5] assert process_queries(n, q, arr, queries) == expected_output def test_mixed_queries(): n = 4 q = 3 arr = [1, -1, 2, -3] queries = [ [2], [1, 2, 3], [2] ] expected_output = [2, 6] assert process_queries(n, q, arr, queries) == expected_output","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, index, value): index += self.n self.tree[index] = value while index > 1: index //= 2 self.tree[index] = max(self.tree[index * 2], self.tree[index * 2 + 1]) def query(self, left, right): result = float(\\"-inf\\") left += self.n right += self.n while left < right: if left % 2: result = max(result, self.tree[left]) left += 1 if right % 2: right -= 1 result = max(result, self.tree[right]) left //= 2 right //= 2 return result def max_subarray_sum(arr): max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far def process_queries(n, q, arr, queries): results = [] for query in queries: type_query = query[0] if type_query == 1: p, x = query[1], query[2] arr[p - 1] = x elif type_query == 2: results.append(max_subarray_sum(arr)) return results"},{"question":"def count_subarrays_with_sum(array, S): Returns the number of subarrays whose sum is equal to S. Args: array (List[int]): The list of integers. S (int): The desired sum of the subarray. Returns: int: The number of subarrays whose sum is equal to S. Examples: >>> count_subarrays_with_sum([1, 2, 3, 4, 5], 5) 2 >>> count_subarrays_with_sum([1, -1, 1], 0) 2","solution":"def count_subarrays_with_sum(array, S): Returns the number of subarrays whose sum is equal to S. count = 0 n = len(array) # Using a dictionary to store the sum frequency sum_frequency = {0: 1} current_sum = 0 for num in array: current_sum += num if (current_sum - S) in sum_frequency: count += sum_frequency[current_sum - S] if current_sum in sum_frequency: sum_frequency[current_sum] += 1 else: sum_frequency[current_sum] = 1 return count"},{"question":"def generate_zigzag(N): Generates a zigzag pattern of height N. Parameters: N (int): The height of the zigzag pattern. Returns: List[str]: A list of strings, each representing a line in the zigzag pattern. pass def process_test_cases(T, test_cases): Process multiple test cases and generate corresponding zigzag patterns. Parameters: T (int): The number of test cases. test_cases (List[int]): A list of integers, each representing the height of the zigzag pattern for a test case. Returns: List[List[str]]: A list of lists, where each inner list is a zigzag pattern for a test case. pass def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) test_cases = [int(data[i]) for i in range(1, T + 1)] results = process_test_cases(T, test_cases) for result in results: for line in result: print(line) print() # blank line to separate patterns # Example usage: # If your input is # 4 # 3 # 4 # 5 # 6 # The expected output should be the zigzag patterns as described.","solution":"def generate_zigzag(N): Generates a zigzag pattern of height N. Parameters: N (int): The height of the zigzag pattern. Returns: List[str]: A list of strings, each representing a line in the zigzag pattern. if N <= 0: return [] pattern = [' ' * i + '*' for i in range(N - 1, -1, -1)] + [' ' * i + '*' for i in range(1, N)] return pattern def process_test_cases(T, test_cases): Process multiple test cases and generate corresponding zigzag patterns. Parameters: T (int): The number of test cases. test_cases (List[int]): A list of integers, each representing the height of the zigzag pattern for a test case. Returns: List[List[str]]: A list of lists, where each inner list is a zigzag pattern for a test case. results = [] for N in test_cases: results.append(generate_zigzag(N)) return results def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) test_cases = [int(data[i]) for i in range(1, T + 1)] results = process_test_cases(T, test_cases) for result in results: for line in result: print(line) print() # blank line to separate patterns"},{"question":"def find_pairs(arr1, arr2, k): Find pairs such that each pair consists of one element from arr1 and one element from arr2, and their sum is divisible by a given integer k. Args: arr1 (List[int]): The first array of integers. arr2 (List[int]): The second array of integers. k (int): The divisor. Returns: List[List[int]] or None: List of pairs satisfying the conditions or None if no valid pairing exists. Examples: >>> find_pairs([1, 2, 3, 4], [4, 3, 2, 1], 5) [[1, 4], [2, 3], [3, 2], [4, 1]] >>> find_pairs([1, 2, 3, 4], [5, 5, 5, 5], 3) None >>> find_pairs([1, 2, 3, 4], [4, 4, 4, 4], 5) None >>> find_pairs([10, 20, 30], [30, 20, 10], 10) [[10, 30], [20, 20], [30, 10]] pass","solution":"def find_pairs(arr1, arr2, k): Finds pairs such that each pair consists of one element from arr1 and one element from arr2, and their sum is divisible by k. Args: arr1 (list of int): The first array of integers. arr2 (list of int): The second array of integers. k (int): The divisor. Returns: list of [int, int] or None: List of pairs or None if no valid pairing exists. from itertools import permutations for perm in permutations(arr2): if all((a + b) % k == 0 for a, b in zip(arr1, perm)): return [[a, b] for a, b in zip(arr1, perm)] return None"},{"question":"def count_paths(grid: List[List[str]]) -> int: Calculate the number of distinct paths from the top-left to the bottom-right corner of a 2D grid. The paths cannot pass through walls ('#'). >>> grid1 = [ ... ['.', '.', '.'], ... ['.', '#', '.'], ... ['.', '.', '.'] ... ] >>> count_paths(grid1) 2 >>> grid2 = [ ... ['.', '#'], ... ['.', '.'] ... ] >>> count_paths(grid2) 1 >>> grid3 = [ ... ['.'] ... ] >>> count_paths(grid3) 1 >>> grid4 = [ ... ['.', '.', '#'], ... ['#', '.', '.'], ... ['.', '.', '.'] ... ] >>> count_paths(grid4) 2 >>> grid5 = [ ... ['.', '.', '.'], ... ['#', '#', '.'], ... ['.', '.', '.'] ... ] >>> count_paths(grid5) 1","solution":"def count_paths(grid): n = len(grid) m = len(grid[0]) # Create a 2D list to store the number of ways to reach each cell dp = [[0] * m for _ in range(n)] # Start position has 1 way to stand on itself dp[0][0] = 1 if grid[0][0] == '.' else 0 for i in range(n): for j in range(m): if grid[i][j] == '.': if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] # Return the number of ways to reach the bottom-right corner return dp[-1][-1]"},{"question":"def is_path_possible(n: int, grid: List[str]) -> str: Determine if a robot can move from the top-left to the bottom-right of the grid. >>> is_path_possible(4, ['....', '..', '.#..', '....']) 'YES' >>> is_path_possible(3, ['.#.', '#', '..#']) 'NO'","solution":"def is_path_possible(n, grid): from collections import deque def bfs(start, end): queue = deque([start]) visited = set([start]) while queue: x, y = queue.popleft() if (x, y) == end: return True # Explore the four possible directions for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == '.' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return False # Early return if start or end positions are blocked if grid[0][0] == '#' or grid[n-1][n-1] == '#': return \\"NO\\" if bfs((0, 0), (n-1, n-1)): return \\"YES\\" else: return \\"NO\\""},{"question":"def find_inefficient_servers(logs: List[str], threshold: float) -> List[str]: Identifies servers with average response time exceeding the given threshold. Parameters: logs (list of str): List of server logs where each entry contains a server identifier followed by response times. threshold (float): The threshold average response time. Returns: list of str: List of identifiers of inefficient servers or [\\"None\\"] if none are inefficient. >>> find_inefficient_servers([\\"SERVER1 0.5 0.8 1.0 1.5\\"], 1.6) [\\"None\\"] >>> find_inefficient_servers([\\"SERVER1 1.7 1.8 1.9\\"], 1.6) [\\"SERVER1\\"] >>> find_inefficient_servers([\\"SERVER1 0.5 0.8 1.0 1.5\\", \\"DB2 1.2 1.5 1.8 2.0 1.9\\", \\"WEB01 0.3 0.6 0.4 0.7 0.5\\"], 1.6) [\\"DB2\\"] >>> find_inefficient_servers([\\"APP1 0.9 1.1 1.2\\", \\"CACHE3 0.4 0.4 0.5 0.6\\", \\"SERVERX 1.0 1.1\\", \\"DATA2 1.6 1.5\\"], 1.8) [\\"None\\"] >>> find_inefficient_servers([\\"APP1 2.0 2.1\\", \\"CACHE3 2.2 2.3\\", \\"SERVERX 3.0\\", \\"DATA2 2.5 2.6\\"], 2.0) [\\"APP1\\", \\"CACHE3\\", \\"SERVERX\\", \\"DATA2\\"] >>> find_inefficient_servers([], 1.0) [\\"None\\"]","solution":"def find_inefficient_servers(logs, threshold): Identifies servers with average response time exceeding the given threshold. Parameters: logs (list of str): List of server logs where each entry contains a server identifier followed by response times. threshold (float): The threshold average response time. Returns: list of str: List of identifiers of inefficient servers or [\\"None\\"] if none are inefficient. inefficient_servers = [] for log in logs: parts = log.split() identifier = parts[0] response_times = list(map(float, parts[1:])) average_response_time = sum(response_times) / len(response_times) if average_response_time > threshold: inefficient_servers.append(identifier) if not inefficient_servers: return [\\"None\\"] return inefficient_servers"},{"question":"def findMaximumXOR(nums): Finds the maximum bitwise XOR of any two elements in the provided array. >>> findMaximumXOR([3, 10, 5, 25, 2, 8]) # 28 >>> findMaximumXOR([0, 1, 2, 3, 4]) # 7","solution":"def findMaximumXOR(nums): Finds the maximum bitwise XOR of any two elements in the provided array. max_xor = 0 mask = 0 for i in range(31, -1, -1): mask |= (1 << i) found_prefixes = set() for num in nums: found_prefixes.add(num & mask) temp = max_xor | (1 << i) for prefix in found_prefixes: if temp ^ prefix in found_prefixes: max_xor = temp break return max_xor # Example usage: # nums = [3, 10, 5, 25, 2, 8] # result = findMaximumXOR(nums) # print(result) # Should output 28"},{"question":"def max_subarray_sum(arr): Returns the maximum sum of elements in any contiguous subarray of the given array. >>> max_subarray_sum([1, -2, 3, 4, -5]) 7 >>> max_subarray_sum([-1, 2, 3, -2, 5, -3]) 8 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([100, -1, 2, -3, 4, 5, 6]) 113 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 def process_test_cases(test_cases): Processes multiple test cases and returns the results. :param test_cases: List of tuples, where each tuple contains the length of the array and the array itself. :return: List of results, where each result is the maximum sum of elements in any contiguous subarray of the corresponding array. >>> test_cases = [(5, [1, -2, 3, 4, -5]), (6, [-1, 2, 3, -2, 5, -3])] >>> process_test_cases(test_cases) [7, 8] >>> test_cases = [(3, [-2, 1, -3]), (4, [-10, -1, -3, -4])] >>> process_test_cases(test_cases) [1, -1] >>> test_cases = [(5, [0, 0, 0, 0, 0]), (6, [1, -1, 1, -1, 1, -1])] >>> process_test_cases(test_cases) [0, 1]","solution":"def max_subarray_sum(arr): Returns the maximum sum of elements in any contiguous subarray of the given array. max_sum = float('-inf') current_sum = 0 for num in arr: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum def process_test_cases(test_cases): results = [] for case in test_cases: n = case[0] arr = case[1] results.append(max_subarray_sum(arr)) return results"},{"question":"def find_shortest_word_length(sentence: str) -> int: Returns the length of the shortest word(s) in the given sentence. >>> find_shortest_word_length(\\"The quick brown fox\\") 3 >>> find_shortest_word_length(\\"Limit yourself to only what you can achieve\\") 2 >>> find_shortest_word_length(\\"A journey of a thousand miles begins with a single step\\") 1 >>> find_shortest_word_length(\\"dog cat bat\\") 3 >>> find_shortest_word_length(\\"extraordinary magnificent remarkable week\\") 4","solution":"def find_shortest_word_length(sentence): Returns the length of the shortest word(s) in the given sentence. words = sentence.split() shortest_length = min(len(word) for word in words) return shortest_length"},{"question":"def generate_pattern(n: int) -> str: Generates a n x n grid where 'A' and 'B' alternate such that no two adjacent cells (horizontally or vertically) have the same color. Args: n (int): The size of the grid (1  n  1000). Returns: str: The generated grid pattern. Examples: >>> generate_pattern(1) 'A' >>> generate_pattern(2) 'ABnBA' >>> generate_pattern(3) 'ABAnBABnABA'","solution":"def generate_pattern(n): Generates a n x n grid where 'A' and 'B' alternate such that no two adjacent cells (horizontally or vertically) have the same color. pattern = [] for i in range(n): row = [] for j in range(n): if (i + j) % 2 == 0: row.append('A') else: row.append('B') pattern.append(''.join(row)) return 'n'.join(pattern)"},{"question":"def findLongestWord(sentence: str) -> str: Returns the longest word in the sentence. In case of a tie, returns the word which appears first. Words are sequences of alphabetic characters bounded by non-alphabetic characters or string boundaries. Parameters: sentence (str): A string containing the sentence to search. Returns: str: The longest word. >>> findLongestWord(\\"Hello world\\") 'Hello' >>> findLongestWord(\\"A cat ran fast\\") 'fast' >>> findLongestWord(\\"Python's syntax is simple yet powerful.\\") 'powerful' >>> findLongestWord(\\"Don't stop believing.\\") 'believing' >>> findLongestWord(\\"\\") '' >>> findLongestWord(\\"1234 5678\\") '' >>> findLongestWord(\\"abc123def 456ghi789\\") 'abc' from solution import findLongestWord def test_findLongestWord_with_simple_sentence(): assert findLongestWord(\\"Hello world\\") == \\"Hello\\" def test_findLongestWord_with_sentence_containing_apostrophes(): assert findLongestWord(\\"Python's syntax is simple yet powerful.\\") == \\"powerful\\" def test_findLongestWord_with_sentence_with_different_lengths(): assert findLongestWord(\\"A cat ran fast\\") == \\"fast\\" def test_findLongestWord_with_sentence_with_unicode_char(): assert findLongestWord(\\"Don't stop believing.\\") == \\"believing\\" def test_findLongestWord_with_tied_lengths(): assert findLongestWord(\\"Hey you\\") == \\"Hey\\" def test_findLongestWord_with_empty_string(): assert findLongestWord(\\"\\") == \\"\\" def test_findLongestWord_with_non_alphabetic_chars(): assert findLongestWord(\\"1234 5678\\") == \\"\\" def test_findLongestWord_with_mixed_chars(): assert findLongestWord(\\"abc123def 456ghi789\\") == \\"abc\\"","solution":"def findLongestWord(sentence): Returns the longest word in the sentence. In case of a tie, returns the word which appears first. Words are sequences of alphabetic characters bounded by non-alphabetic characters or string boundaries. Parameters: sentence (str): A string containing the sentence to search. Returns: str: The longest word. import re words = re.findall(r\\"[a-zA-Z]+\\", sentence) longest_word = \\"\\" for word in words: if len(word) > len(longest_word): longest_word = word return longest_word"},{"question":"def rearrange_heights(heights): Rearrange the students such that the absolute difference between the heights of any two adjacent students is minimized by sorting the heights. :param heights: List of student heights. :return: List of heights in the desired order. >>> rearrange_heights([10, 5, 15, 20]) == [5, 10, 15, 20] >>> rearrange_heights([8, 2, 4]) == [2, 4, 8] >>> rearrange_heights([5]) == [5] >>> rearrange_heights([3, 1]) == [1, 3] >>> rearrange_heights([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> rearrange_heights([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] >>> rearrange_heights([1000000000, 1, 999999999]) == [1, 999999999, 1000000000] >>> rearrange_heights([104, 202, 195, 125, 98]) == [98, 104, 125, 195, 202] pass","solution":"def rearrange_heights(heights): Rearrange the students such that the absolute difference between the heights of any two adjacent students is minimized by sorting the heights. :param heights: List of student heights. :return: List of heights in the desired order. heights.sort() return heights"},{"question":"from typing import List, Tuple def earliest_bus_time(n: int, m: int, frequencies: List[int], queries: List[Tuple[int, int]]) -> List[int]: For each query, determine the earliest time you can catch the bus from the given bus route starting from T_j. >>> earliest_bus_time(3, 4, [5, 10, 20], [(1, 3), (2, 15), (3, 25), (1, 7)]) [5, 20, 40, 10] >>> earliest_bus_time(2, 2, [1, 1000000000], [(1, 999999999), (2, 999999999)]) [999999999, 1000000000]","solution":"def earliest_bus_time(n, m, frequencies, queries): results = [] for q in queries: route_id, start_time = q frequency = frequencies[route_id - 1] if start_time % frequency == 0: earliest_time = start_time else: earliest_time = ((start_time // frequency) + 1) * frequency results.append(earliest_time) return results"},{"question":"def get_skyline(buildings): Given a list of buildings, compute the skyline formed by these buildings. Each building is represented as a tuple (left, right, height). Args: buildings: List[Tuple[int, int, int]] -- a list of buildings, each represented as a tuple (left, right, height) Returns: List[List[int]] -- the list of key points in the skyline >>> get_skyline([(1, 3, 4), (2, 4, 3)]) [[1, 4], [3, 3], [4, 0]] >>> get_skyline([(0, 2, 3), (2, 5, 3), (6, 8, 2)]) [[0, 3], [5, 0], [6, 2], [8, 0]] # Your code here from solution import get_skyline def test_case_1(): buildings = [(1, 3, 4), (2, 4, 3)] expected_output = [[1, 4], [3, 3], [4, 0]] assert get_skyline(buildings) == expected_output def test_case_2(): buildings = [(0, 2, 3), (2, 5, 3), (6, 8, 2)] expected_output = [[0, 3], [5, 0], [6, 2], [8, 0]] assert get_skyline(buildings) == expected_output def test_case_3(): buildings = [(1, 5, 2), (2, 7, 1), (3, 4, 10)] expected_output = [[1, 2], [3, 10], [4, 2], [5, 1], [7, 0]] assert get_skyline(buildings) == expected_output def test_case_4(): buildings = [(1, 2, 1), (1, 2, 2), (1, 2, 3)] expected_output = [[1, 3], [2, 0]] assert get_skyline(buildings) == expected_output def test_case_5(): buildings = [(2, 9, 10), (3, 7, 15), (5, 12, 12), (15, 20, 10), (19, 24, 8)] expected_output = [[2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0]] assert get_skyline(buildings) == expected_output","solution":"import heapq def get_skyline(buildings): Given a list of buildings, compute the skyline formed by these buildings. Each building is represented as a tuple (left, right, height). events = [] for l, r, h in buildings: events.append((l, -h, r)) events.append((r, 0, 0)) # Sort events by x coordinate events.sort() result = [] live_buildings = [(0, float(\\"inf\\"))] # Height, end point for x, neg_h, r in events: while live_buildings[0][1] <= x: heapq.heappop(live_buildings) if neg_h: heapq.heappush(live_buildings, (neg_h, r)) max_h = -live_buildings[0][0] if not result or result[-1][1] != max_h: result.append([x, max_h]) return result"},{"question":"def sum_mult_of_3_and_5(n: int) -> int: Create a function sum_mult_of_3_and_5 which takes a positive integer n as input and returns the sum of all multiples of 3 or 5 that are less than n. >>> sum_mult_of_3_and_5(10) 23 >>> sum_mult_of_3_and_5(20) 78","solution":"def sum_mult_of_3_and_5(n): Returns the sum of all multiples of 3 or 5 that are less than n. return sum(i for i in range(1, n) if i % 3 == 0 or i % 5 == 0)"},{"question":"def can_transform(N: int, M: int, a: List[int], b: List[int], rules: List[Tuple[int, int, int]]) -> str: Determine if target array 'b' can be obtained from array 'a' using the given rules. >>> can_transform(5, 2, [1, 3, 5, 7, 9], [3, 5, 7, 5, 9], [(2, 4, 2), (1, 5, 1)]) \\"YES\\" >>> can_transform(4, 1, [2, 2, 4, 4], [3, 3, 5, 5], [(1, 2, 1)]) \\"NO\\"","solution":"def can_transform(N, M, a, b, rules): # Calculate the difference array diff = [b[i] - a[i] for i in range(N)] for l, r, x in rules: l -= 1 # Convert to 0-based index r -= 1 # Convert to 0-based index for i in range(l, r+1): if diff[i] % x != 0: return \\"NO\\" diff[i] = 0 # After appyling all applicable rules, # if some elements are still non-zero, then it is not possible. if any(diff): return \\"NO\\" return \\"YES\\""},{"question":"def calculate_score(s: str) -> int: Calculate the score of the string based on the described rules. The string consists of lowercase English letters. Each letter has a base score: 'a' has a score of 1, 'b' has a score of 2, ..., 'z' has a score of 26. Additionally, there is a bonus mechanism: - If two consecutive characters are the same, their combined score is doubled. - If three consecutive characters are the same, their combined score is tripled, and so on. Given a string, determine the total score following these rules. >>> calculate_score(\\"a\\") 1 >>> calculate_score(\\"z\\") 26 >>> calculate_score(\\"aa\\") 4 >>> calculate_score(\\"aaa\\") 9 >>> calculate_score(\\"aabbbc\\") 33 >>> calculate_score(\\"xyzxyzxyz\\") 351","solution":"def calculate_score(s): Calculate the score of the string based on the described rules. :param s: Input string consisting of lowercase English letters. :return: Integer score of the string. if not s: return 0 total_score = 0 i = 0 while i < len(s): char = s[i] base_score = ord(char) - ord('a') + 1 count = 1 # Count consecutive characters while i + 1 < len(s) and s[i + 1] == char: count += 1 i += 1 # Apply the bonus mechanism total_score += base_score * count * count i += 1 return total_score"},{"question":"def max_distance_to_nearest_exit(n: int, m: int, exit_positions: List[int], occupancy: str) -> int: Returns the maximum distance any visitor has to walk to the nearest exit point. Args: n (int): The number of seats. m (int): The number of exit points. exit_positions (List[int]): A list of integers representing the positions of the exit points. occupancy (str): A string of length n representing the occupancy status of each seat ('0' for empty, '1' for occupied). Returns: int: The maximum distance any visitor has to walk to the nearest exit point. Examples: >>> max_distance_to_nearest_exit(10, 3, [2, 5, 9], '1001000010') 1 >>> max_distance_to_nearest_exit(8, 2, [3, 8], '10001001') 2","solution":"def max_distance_to_nearest_exit(n, m, exit_positions, occupancy): Returns the maximum distance any visitor has to walk to the nearest exit point. import bisect max_distance = 0 for i in range(n): if occupancy[i] == '1': pos = i + 1 # Positions are 1-indexed idx = bisect.bisect_left(exit_positions, pos) if idx == 0: distance = abs(exit_positions[0] - pos) elif idx == m: distance = abs(exit_positions[-1] - pos) else: distance = min(abs(exit_positions[idx] - pos), abs(exit_positions[idx-1] - pos)) max_distance = max(max_distance, distance) return max_distance"},{"question":"from typing import List, Tuple def min_moves_to_zero_each_row(matrix: List[List[int]]) -> List[int]: Given a matrix, compute the minimum number of moves required for each row to convert all cells to zeros by converting all cells containing any chosen positive integer to zeros in one move. Parameters: matrix (list of list of int): an n x n matrix with non-negative integers Returns: list of int: minimum number of moves required per row def process_test_cases(test_cases: List[Tuple[int, List[List[int]]]]) -> List[List[int]]: Process multiple test cases and return the results for each one. Parameters: test_cases (list of tuple): List of test cases where each test case consists of an integer n and an n x n matrix Returns: list of list of int: Each inner list contains the minimum number of moves required per row for the corresponding test case from solution import min_moves_to_zero_each_row, process_test_cases def test_single_row_matrix(): assert min_moves_to_zero_each_row([[1, 2, 2]]) == [2] def test_multiple_row_matrix(): assert min_moves_to_zero_each_row([[1, 2, 2], [3, 3, 3], [1, 2, 2]]) == [2, 1, 2] def test_zero_in_matrix(): assert min_moves_to_zero_each_row([[0, 1, 2], [2, 0, 3], [3, 3, 0]]) == [2, 2, 1] def test_unique_elements_row(): assert min_moves_to_zero_each_row([[5, 5, 5], [2, 3, 2], [3, 3, 3]]) == [1, 2, 1] def test_various_matrices(): test_cases = [(3, [[1, 2, 2], [3, 3, 3], [1, 2, 2]]), (3, [[2, 1, 3], [5, 5, 5], [9, 1, 1]]), (3, [[5, 5, 5], [2, 3, 2], [3, 3, 3]])] assert process_test_cases(test_cases) == [[2, 1, 2], [3, 1, 2], [1, 2, 1]] def test_identical_elements_in_rows(): assert min_moves_to_zero_each_row([[1, 1, 1], [2, 2, 2], [3, 3, 3]]) == [1, 1, 1]","solution":"def min_moves_to_zero_each_row(matrix): Given a matrix, compute the minimum number of moves required for each row to convert all cells to zeros by converting all cells containing any chosen positive integer to zeros in one move. Parameters: matrix (list of list of int): an n x n matrix with non-negative integers Returns: int: minimum number of moves required moves = [] for row in matrix: unique_numbers = set(row) if 0 in unique_numbers: unique_numbers.remove(0) moves.append(len(unique_numbers)) return moves def process_test_cases(test_cases): results = [] for n, matrix in test_cases: results.append(min_moves_to_zero_each_row(matrix)) return results"},{"question":"def count_planting_ways(n: int) -> int: Determine the number of ways to plant n trees in a rectangular grid. >>> count_planting_ways(1) 1 >>> count_planting_ways(11) 2 >>> count_planting_ways(13) 2 >>> count_planting_ways(4) 3 >>> count_planting_ways(9) 3 >>> count_planting_ways(12) 6 >>> count_planting_ways(6) 4 >>> count_planting_ways(1000000) 49 pass","solution":"def count_planting_ways(n): Determine the number of ways to plant n trees in a rectangular grid. count = 0 for i in range(1, int(n**0.5) + 1): if n % i == 0: count += 2 if i != n // i else 1 return count"},{"question":"def disariumNumber(n: int) -> str: Determine if the number n is a disarium number. A disarium number is a number for which the sum of its digits powered with their respective positions is equal to the number itself. Parameters: n (int): A positive integer. Returns: str: \\"Disarium !!\\" if n is a disarium number, otherwise \\"Not!!\\" Examples: >>> disariumNumber(89) \\"Disarium !!\\" >>> disariumNumber(51) \\"Not!!\\" >>> disariumNumber(135) \\"Disarium !!\\" >>> disariumNumber(175) \\"Disarium !!\\" >>> disariumNumber(80) \\"Not!!\\"","solution":"def disariumNumber(n): Determine if the number n is a disarium number. Parameters: n (int): A positive integer. Returns: str: \\"Disarium !!\\" if n is a disarium number, otherwise \\"Not!!\\" digits = [int(d) for d in str(n)] disarium_sum = sum(d ** (i + 1) for i, d in enumerate(digits)) return \\"Disarium !!\\" if disarium_sum == n else \\"Not!!\\""},{"question":"from typing import List def min_moves_to_destination(grid: List[List[int]]) -> int: Given a city represented by a grid of size m x n, determine the minimum number of moves required by a delivery robot to deliver the packages from the starting point at (0, 0) to the final destination at (m-1, n-1). The robot can move up, down, left, or right, but must avoid any obstacles in its way. Each cell in the grid can either be free or an obstacle. Returns the total number of minimum moves required by the robot to go from (0, 0) to (m-1, n-1), or returns -1 if no such route exists. >>> grid = [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> min_moves_to_destination(grid) 4 >>> grid = [ ... [0, 1], ... [1, 0] ... ] >>> min_moves_to_destination(grid) -1","solution":"from collections import deque def min_moves_to_destination(grid): Determine the minimum number of moves required to go from (0, 0) to (m-1, n-1) in the grid. Return -1 if no such route exists. m, n = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return -1 # Four possible directions to move: up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0)]) visited = set((0, 0)) moves = 0 while queue: for _ in range(len(queue)): x, y = queue.popleft() if (x, y) == (m-1, n-1): return moves for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: queue.append((nx, ny)) visited.add((nx, ny)) moves += 1 return -1"},{"question":"from typing import List def minimum_time_to_cover_all_plots(n: int, m: int, grid: List[List[str]]) -> int: Determine the minimum amount of time required to cover all empty plots with electricity. Params: n: int - number of rows in the grid m: int - number of columns in the grid grid: List[List[str]] - n x m grid of plots (P: power station, E: empty plot, O: obstacle) Returns: int - minimum amount of time required to cover all empty plots with electricity, or -1 if not possible Example: >>> n, m = 4, 5 >>> grid = [ ... ['P', 'E', 'E', 'O', 'E'], ... ['E', 'O', 'E', 'E', 'E'], ... ['E', 'E', 'O', 'P', 'O'], ... ['E', 'O', 'E', 'E', 'E'] ... ] >>> minimum_time_to_cover_all_plots(n, m, grid) 3 >>> n, m = 2, 2 >>> grid = [ ... ['P', 'O'], ... ['O', 'P'] ... ] >>> minimum_time_to_cover_all_plots(n, m, grid) 0","solution":"from collections import deque def minimum_time_to_cover_all_plots(n, m, grid): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque() empty_plots = 0 for i in range(n): for j in range(m): if grid[i][j] == 'P': queue.append((i, j, 0)) elif grid[i][j] == 'E': empty_plots += 1 if empty_plots == 0: return 0 while queue: x, y, time = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 'E': grid[nx][ny] = 'P' empty_plots -= 1 if empty_plots == 0: return time + 1 queue.append((nx, ny, time + 1)) return -1"},{"question":"def max_sum_subarray(test_cases): Find the contiguous subarray of length K with the maximum sum for each test case. >>> max_sum_subarray([(5, 2, [1, 2, 3, -1, 5])]) [[2, 3]] >>> max_sum_subarray([(6, 3, [4, -1, 2, 1, -5, 4])]) [[4, -1, 2]] def parse_input(input_str): Parse the input string into a list of test cases. >>> parse_input(\\"2n5 2n1 2 3 -1 5n6 3n4 -1 2 1 -5 4\\") [(5, 2, [1, 2, 3, -1, 5]), (6, 3, [4, -1, 2, 1, -5, 4])] def format_output(output): Format the output list of subarrays into a string. >>> format_output([[2, 3], [4, -1, 2]]) \\"2 3n4 -1 2\\"","solution":"def max_sum_subarray(test_cases): result = [] for case in test_cases: N, K, arr = case max_sum = float('-inf') current_sum = sum(arr[:K]) max_subarray = arr[:K] for i in range(N - K + 1): if i != 0: current_sum = current_sum - arr[i - 1] + arr[i + K - 1] if current_sum > max_sum: max_sum = current_sum max_subarray = arr[i:i + K] result.append(max_subarray) return result def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) cases = [] index = 1 for _ in range(T): N, K = map(int, lines[index].split()) arr = list(map(int, lines[index + 1].split())) cases.append((N, K, arr)) index += 2 return cases def format_output(output): return \\"n\\".join(\\" \\".join(map(str, sublist)) for sublist in output)"},{"question":"def process_queries(n: int, q: int, queries: List[int]) -> List[int]: Processes a list of access log queries and returns the result of report queries. Args: n (int): The number of possible distinct account IDs. q (int): The number of queries. queries (list of int): The queries, where a positive integer x (1  x  n) corresponds to an access attempt, and 0 corresponds to a report query. Returns: list of int: The results of the report queries. >>> process_queries(10, 8, [5, 3, 7, 0, 2, 3, 0, 1]) [3, 4] >>> process_queries(10, 4, [0, 0, 0, 0]) [0, 0, 0, 0]","solution":"def process_queries(n, q, queries): Processes a list of access log queries and returns the result of report queries. Args: n (int): The number of possible distinct account IDs. q (int): The number of queries. queries (list of int): The queries, where a positive integer x (1  x  n) corresponds to an access attempt, and 0 corresponds to a report query. Returns: list of int: The results of the report queries. unique_ids = set() report_results = [] for query in queries: if query == 0: report_results.append(len(unique_ids)) else: unique_ids.add(query) return report_results"},{"question":"def longest_palindrome(s: str) -> str: Returns the longest palindromic substring in the given string s. If there are multiple substrings of the same maximum length, return the first one found. If the string is empty, return an empty string. >>> longest_palindrome(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> longest_palindrome(\\"cbbd\\") 'bb' >>> longest_palindrome(\\"\\") '' >>> longest_palindrome(\\"a\\") 'a' >>> longest_palindrome(\\"racecar\\") 'racecar' >>> longest_palindrome(\\"abaxyzzyxf\\") 'xyzzyx' >>> longest_palindrome(\\"a!a\\") 'a!a'","solution":"def longest_palindrome(s): Returns the longest palindromic substring in s. if s == '': return '' n = len(s) start, max_length = 0, 1 for i in range(n): l, r = i, i while l >= 0 and r < n and s[l] == s[r]: if (r - l + 1) > max_length: start = l max_length = r - l + 1 l -= 1 r += 1 l, r = i, i + 1 while l >= 0 and r < n and s[l] == s[r]: if (r - l + 1) > max_length: start = l max_length = r - l + 1 l -= 1 r += 1 return s[start:start + max_length]"},{"question":"def productOfSquares(N: int) -> int: Computes the product of the squares of the first N natural numbers. Parameters: N (int): The number up to which squares of natural numbers are considered. Returns: int: The product of the squares. Examples: >>> productOfSquares(3) 36 >>> productOfSquares(4) 576","solution":"def productOfSquares(N): Computes the product of the squares of the first N natural numbers. Parameters: N (int): The number up to which squares of natural numbers are considered. Returns: int: The product of the squares. product = 1 for i in range(1, N + 1): product *= i * i return product"},{"question":"def digit_to_word(digit): Helper function to convert a single digit to its corresponding English word. >>> digit_to_word('0') == 'zero' >>> digit_to_word('1') == 'one' >>> digit_to_word('2') == 'two' >>> digit_to_word('3') == 'three' >>> digit_to_word('4') == 'four' >>> digit_to_word('5') == 'five' >>> digit_to_word('6') == 'six' >>> digit_to_word('7') == 'seven' >>> digit_to_word('8') == 'eight' >>> digit_to_word('9') == 'nine' pass def translate_expression(expression): Takes a string containing a mathematical expression and returns a translated string where all the digits have been replaced with their English word equivalents. >>> translate_expression(\\"3+5\\") \\"three+five\\" >>> translate_expression(\\"12*6\\") \\"onetwo*six\\" >>> translate_expression(\\"8/4-7\\") \\"eight/four-seven\\" >>> translate_expression(\\"0+0\\") \\"zero+zero\\" >>> translate_expression(\\"1*23-45/67+89\\") \\"one*twothree-fourfive/sixseven+eightnine\\" >>> translate_expression(\\"9876543210\\") \\"nineeightsevensixfivefourthreetwoonezero\\" >>> translate_expression(\\"9+8-7*6/5\\") \\"nine+eight-seven*six/five\\" pass","solution":"def digit_to_word(digit): Helper function to convert a single digit to its corresponding English word. digit_words = { '0': 'zero', '1': 'one', '2': 'two', '3': 'three', '4': 'four', '5': 'five', '6': 'six', '7': 'seven', '8': 'eight', '9': 'nine' } return digit_words[digit] def translate_expression(expression): Takes a string containing a mathematical expression and returns a translated string where all the digits have been replaced with their English word equivalents. translated_expression = \\"\\" for char in expression: if char.isdigit(): translated_expression += digit_to_word(char) else: translated_expression += char return translated_expression"},{"question":"def two_sum_exists(n, target, nums): Determine if there are two distinct indices i and j in the list such that the sum of the integers at these indices equals the target integer. Args: n (int): Number of integers in the list. target (int): The target integer. nums (List[int]): The list of integers. Returns: str: \\"YES\\" if two distinct indices with sum equal to target are found, otherwise \\"NO\\". Examples: >>> two_sum_exists(5, 9, [2, 7, 11, 15, 1]) \\"YES\\" >>> two_sum_exists(4, 10, [2, 7, 11, 15]) \\"NO\\"","solution":"def two_sum_exists(n, target, nums): Return 'YES' if there exist two distinct indices i and j in nums such that nums[i] + nums[j] = target. Otherwise, return 'NO'. seen = {} for num in nums: complement = target - num if complement in seen: return \\"YES\\" seen[num] = True return \\"NO\\""},{"question":"def canRearrange(N: int, K: int, A: List[int]) -> str: You're given an array A consisting of N integers, where A[i] represents the value at the ith index in the array. You need to check whether the array can be rearranged such that two consecutive elements of the resulting sequence differ by at most K. Return \\"YES\\" if it is possible to rearrange the array in this way, otherwise return \\"NO\\". >>> canRearrange(5, 2, [1, 3, 5, 8, 10]) \\"NO\\" >>> canRearrange(6, 3, [7, 4, 1, 3, 2, 5]) \\"YES\\"","solution":"def canRearrange(N, K, A): # First, sort the array A.sort() # Traverse the sorted array and check the difference between each consecutive elements for i in range(1, N): if A[i] - A[i - 1] > K: return \\"NO\\" # If no such pair is found, then return \\"YES\\" return \\"YES\\""},{"question":"def separate_and_sort(s: str) -> str: Separates the letters and digits from the input string, sorts them separately, and then combines them back into a new string with all letters sorted alphabetically first and all digits sorted in ascending order afterwards. >>> separate_and_sort(\\"a2b1c3\\") 'abc123' >>> separate_and_sort(\\"d4e5f6\\") 'def456' >>> separate_and_sort(\\"z9y8x7\\") 'xyz789'","solution":"def separate_and_sort(s: str) -> str: Separates the letters and digits from the input string, sorts them separately, and then combines them back into a new string with all letters sorted alphabetically first and all digits sorted in ascending order afterwards. letters = [] digits = [] for char in s: if char.isdigit(): digits.append(char) elif char.isalpha(): letters.append(char) sorted_letters = ''.join(sorted(letters)) sorted_digits = ''.join(sorted(digits)) return sorted_letters + sorted_digits # Example usage: print(separate_and_sort(\\"a2b1c3\\")) # Output: 'abc123' print(separate_and_sort(\\"d4e5f6\\")) # Output: 'def456' print(separate_and_sort(\\"z9y8x7\\")) # Output: 'xyz789'"},{"question":"import math from typing import List def is_fibonacci(n: int) -> bool: Returns True if n is a Fibonacci number, else False. >>> is_fibonacci(1) True >>> is_fibonacci(4) False >>> is_fibonacci(8) True >>> is_fibonacci(13) True def determine_fibonacci_numbers(test_cases: List[int]) -> List[str]: Given a list of integers, determine if they are Fibonacci numbers and return a list with the results. >>> determine_fibonacci_numbers([1, 4, 8, 13]) ['YES', 'NO', 'YES', 'YES'] >>> determine_fibonacci_numbers([2, 5, 7, 14, 34]) ['YES', 'YES', 'NO', 'NO', 'YES']","solution":"import math def is_fibonacci(n): Returns True if n is a Fibonacci number, else False. A number, n, is a Fibonacci number if and only if one or both of (5*n^2 + 4) or (5*n^2 - 4) is a perfect square. def is_perfect_square(x): s = int(math.sqrt(x)) return s * s == x return is_perfect_square(5 * n * n + 4) or is_perfect_square(5 * n * n - 4) def determine_fibonacci_numbers(test_cases): Given a list of integers, determine if they are Fibonacci numbers and return a list with the results. results = [] for x in test_cases: if is_fibonacci(x): results.append('YES') else: results.append('NO') return results # Example usage: # input_cases = [1, 4, 8, 13] # print(determine_fibonacci_numbers(input_cases)) # Output should be ['YES', 'NO', 'YES', 'YES']"},{"question":"def find_disconnected_parts(n: int, m: int, grid: List[List[str]]) -> str: The city is organizing a marathon, and they want to ensure that all track participants stay within the designated path. Write a program to determine if there is more than one disconnected part of the path on the grid. >>> find_disconnected_parts(4, 5, [list(\\"++.++\\"), list(\\"..+..\\"), list(\\"...+.\\"), list(\\".....\\")]) \\"Yes\\" >>> find_disconnected_parts(2, 2, [list(\\"++\\"), list(\\"++\\")]) \\"No\\" >>> find_disconnected_parts(4, 5, [list(\\".....\\"), list(\\".....\\"), list(\\".....\\"), list(\\".....\\")]) \\"No\\" >>> find_disconnected_parts(3, 4, [list(\\"++++\\"), list(\\"++++\\"), list(\\"++++\\")]) \\"No\\" >>> find_disconnected_parts(3, 5, [list(\\"+...+\\"), list(\\".....\\"), list(\\"+...+\\")]) \\"Yes\\"","solution":"def find_disconnected_parts(n, m, grid): def dfs(i, j): if i < 0 or i >= n or j < 0 or j >= m or grid[i][j] != '+': return grid[i][j] = '.' # Mark the cell as visited for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: dfs(i + dx, j + dy) components = 0 for i in range(n): for j in range(m): if grid[i][j] == '+': components += 1 dfs(i, j) return \\"Yes\\" if components > 1 else \\"No\\" # Example usage: # n = 4 # m = 5 # grid = [ # \\"++.++\\", # \\"..+..\\", # \\"...+.\\", # \\".....\\" # ] # find_disconnected_parts(n, m, [list(row) for row in grid]) # \\"Yes\\""},{"question":"from typing import List, Tuple def find_furthest_distance(n: int, roads: List[Tuple[int, int]]) -> int: Determine the maximum distance from any given starting city to reach the furthest city in a tree-form road system. >>> find_furthest_distance(5, [(1, 2), (1, 3), (2, 4), (2, 5)]) 3 >>> find_furthest_distance(6, [(1, 2), (1, 3), (3, 4), (4, 5), (4, 6)]) 4 >>> find_furthest_distance(3, [(1, 2), (2, 3)]) 2 >>> find_furthest_distance(2, [(1, 2)]) 1 >>> find_furthest_distance(7, [(1, 2), (2, 3), (2, 4), (4, 5), (4, 6), (1, 7)]) 4","solution":"def find_furthest_distance(n, roads): from collections import deque, defaultdict # Create adjacency list graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) # Function to perform BFS and return the furthest node and its distance def bfs(start): visited = [False] * (n + 1) queue = deque([(start, 0)]) visited[start] = True furthest_node = start max_distance = 0 while queue: current_node, current_distance = queue.popleft() if current_distance > max_distance: max_distance = current_distance furthest_node = current_node for neighbor in graph[current_node]: if not visited[neighbor]: visited[neighbor] = True queue.append((neighbor, current_distance + 1)) return furthest_node, max_distance # Start BFS from an arbitrary node (1) to find the furthest node from it furthest_node, _ = bfs(1) # Start BFS from the furthest node found to find the maximum distance _, max_distance = bfs(furthest_node) return max_distance"},{"question":"def reverse_words(s): Reverses each word in the string while retaining the original order of the words. Parameters: s (str): The input string containing words separated by single spaces. Returns: str: The string with each word reversed, while maintaining the original order of words. Examples: >>> reverse_words(\\"hello world\\") 'olleh dlrow' >>> reverse_words(\\"coding is fun\\") 'gnidoc si nuf' >>> reverse_words(\\"keep it simple\\") 'peek ti elpmis' >>> reverse_words(\\"\\") '' >>> reverse_words(\\"a b c\\") 'a b c'","solution":"def reverse_words(s): Reverses each word in the string while retaining the original order of the words. Parameters: s (str): The input string containing words separated by single spaces. Returns: str: The string with each word reversed, while maintaining the original order of words. def reverse_word(word): # Initialize an empty list to accumulate reversed word reversed_word = [] # Loop over the word characters from end to start for i in range(len(word) - 1, -1, -1): reversed_word.append(word[i]) return ''.join(reversed_word) # Split the original string by spaces words = s.split(' ') # Reverse each word and join them with a single space reversed_words = [reverse_word(word) for word in words] return ' '.join(reversed_words)"},{"question":"def longest_unique_substring_length(s: str) -> int: Given a string S, find the length of the longest substring consisting of unique characters. >>> longest_unique_substring_length(\\"abcabcbb\\") 3 >>> longest_unique_substring_length(\\"aaaa\\") 1 >>> longest_unique_substring_length(\\"abcdef\\") 6 >>> longest_unique_substring_length(\\"a b c a b\\") 3 >>> longest_unique_substring_length(\\"abcdabc\\") 4 >>> longest_unique_substring_length(\\"abcaabb\\") 3","solution":"def longest_unique_substring_length(s): Returns the length of the longest substring with all unique characters. n = len(s) char_index_map = {} max_length = start = 0 for i in range(n): if s[i] in char_index_map and char_index_map[s[i]] >= start: start = char_index_map[s[i]] + 1 char_index_map[s[i]] = i max_length = max(max_length, i - start + 1) return max_length"},{"question":"def find_words(grid, words): Determine if each word can be found in the 2D grid. Words can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally, vertically, and diagonally neighboring. The same letter cell cannot be used more than once in constructing a word. Args: grid (List[List[str]]): 2D list representing the grid of letters. words (List[str]): List of words to be searched in the grid. Returns: dict: A dictionary with each word as key and a boolean as value indicating whether the word can be found in the grid. Examples: >>> grid = [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']] >>> words = [\\"ABCCED\\", \\"SEE\\", \\"ABCB\\"] >>> find_words(grid, words) {\\"ABCCED\\": True, \\"SEE\\": True, \\"ABCB\\": False} >>> grid = [['C', 'A', 'T'], ['R', 'R', 'O'], ['S', 'E', 'T']] >>> words = [\\"CAT\\", \\"CAR\\", \\"TAC\\", \\"CARS\\", \\"SECRET\\"] >>> find_words(grid, words) {\\"CAT\\": True, \\"CAR\\": True, \\"TAC\\": True, \\"CARS\\": True, \\"SECRET\\": False}","solution":"def find_words(grid, words): def is_word_found(word): def dfs(x, y, index): if index == len(word): return True if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] != word[index]: return False temp = grid[x][y] grid[x][y] = '#' found = ( dfs(x + 1, y, index + 1) or dfs(x - 1, y, index + 1) or dfs(x, y + 1, index + 1) or dfs(x, y - 1, index + 1) or dfs(x + 1, y + 1, index + 1) or dfs(x - 1, y - 1, index + 1) or dfs(x + 1, y - 1, index + 1) or dfs(x - 1, y + 1, index + 1) ) grid[x][y] = temp return found for i in range(len(grid)): for j in range(len(grid[0])): if dfs(i, j, 0): return True return False return {word: is_word_found(word) for word in words}"},{"question":"def maximizing_xor(L: int, R: int) -> int: Find the maximum value of A xor B, where A and B are integers in the range [L, R] inclusive. Args: L (int): the lower bound of the range. R (int): the upper bound of the range. Returns: int: The maximum possible result of A xor B for L <= A, B <= R. >>> maximizing_xor(1, 10) 15 >>> maximizing_xor(10, 15) 7 >>> maximizing_xor(100000, 100000) 0 >>> maximizing_xor(1, 1) 0 >>> maximizing_xor(1, 2) 3 >>> maximizing_xor(15, 20) 31 >>> maximizing_xor(5, 8) 15","solution":"def maximizing_xor(L, R): Returns the maximum value of A xor B, where A and B are integers between L and R (inclusive). max_xor = 0 for A in range(L, R + 1): for B in range(A, R + 1): # Ensure B >= A to minimize redundant calculations max_xor = max(max_xor, A ^ B) return max_xor"},{"question":"def min_temperature_zones(n: int, ranges: List[Tuple[int, int]]) -> int: Determines the minimum number of temperature zones required for different plant types. Args: n (int): Number of different types of plants. ranges (list of tuples): List of tuples where each tuple contains two integers (L, H) that represent the lowest and highest temperature the i-th type of plant can grow in. Returns: int: Minimum number of temperature zones required. >>> min_temperature_zones(3, [(15, 20), (18, 25), (23, 30)]) 3 >>> min_temperature_zones(4, [(5, 10), (10, 15), (15, 20), (20, 25)]) 4 from solution import min_temperature_zones def test_single_plant_type(): assert min_temperature_zones(1, [(5, 10)]) == 1 def test_non_overlapping_ranges(): assert min_temperature_zones(4, [(5, 10), (15, 20), (25, 30), (35, 40)]) == 4 def test_fully_overlapping_ranges(): assert min_temperature_zones(3, [(1, 10), (2, 9), (3, 8)]) == 1 def test_partially_overlapping_ranges(): assert min_temperature_zones(3, [(1, 5), (4, 9), (8, 12)]) == 2 def test_some_overlapping_and_non_overlapping(): assert min_temperature_zones(4, [(5, 10), (10, 15), (15, 20), (1, 2)]) == 3","solution":"def min_temperature_zones(n, ranges): Determines the minimum number of temperature zones required for different plant types. Args: n (int): Number of different types of plants. ranges (list of tuples): List of tuples where each tuple contains two integers (L, H) that represent the lowest and highest temperature the i-th type of plant can grow in. Returns: int: Minimum number of temperature zones required. # Sort the ranges based on their ending temperature ranges.sort(key=lambda x: x[1]) # Initialize the count of required zones zones = 0 # The end of the last added zone last_zone_end = -1 for temp_range in ranges: if temp_range[0] > last_zone_end: # Create a new zone zones += 1 last_zone_end = temp_range[1] return zones"},{"question":"class Warehouse: def __init__(self): self.stack = [] self.weight_map = {} def push(self, k, w): Add a box with identifier k and weight w to the top of the stack. pass def pop(self): Remove the box at the top of the stack. pass def top(self): Report the identifier of the box on the top of the stack. pass def query(self, w): Return the identifier of the topmost box whose weight is exactly w. Return -1 if no such box exists. pass def process_queries(queries): Process a list of warehouse operation queries and return the result of 'top' and 'query' operations. >>> process_queries([\\"push 1 100\\", \\"push 2 200\\", \\"top\\", \\"pop\\", \\"top\\", \\"query 100\\", \\"query 200\\", \\"pop\\"]) [2, 1, 1, -1] pass","solution":"class Warehouse: def __init__(self): self.stack = [] self.weight_map = {} def push(self, k, w): # Add (k, w) to the stack self.stack.append((k, w)) if w not in self.weight_map: self.weight_map[w] = [] self.weight_map[w].append(k) def pop(self): # Remove top element from the stack if self.stack: k, w = self.stack.pop() self.weight_map[w].pop() if not self.weight_map[w]: del self.weight_map[w] def top(self): # Return the identifier of the top element if self.stack: k, w = self.stack[-1] return k return -1 def query(self, w): # Return the identifier of the topmost box whose weight is exactly w if w in self.weight_map and self.weight_map[w]: return self.weight_map[w][-1] return -1 def process_queries(queries): warehouse = Warehouse() results = [] for query in queries: operations = query.split() if operations[0] == \\"push\\": k = int(operations[1]) w = int(operations[2]) warehouse.push(k, w) elif operations[0] == \\"pop\\": warehouse.pop() elif operations[0] == \\"top\\": results.append(warehouse.top()) elif operations[0] == \\"query\\": w = int(operations[1]) results.append(warehouse.query(w)) return results"},{"question":"def max_non_overlapping_meetings(T: int, test_cases: List[List[Tuple[int, int]]]) -> List[int]: Determines the maximum number of non-overlapping meetings for each test case. Parameters: - T (int): Number of test cases. - test_cases (list): List of test cases, where each test case is a list of tuples representing start and end times of meetings. Returns: - list: A list of integers representing the maximum number of non-overlapping meetings for each test case. >>> max_non_overlapping_meetings(2, [ ... [(1, 2), (3, 4), (0, 6)], ... [(1, 3), (2, 4), (3, 5), (7, 8)] ... ]) == [2, 3] >>> max_non_overlapping_meetings(1, [ ... [(1, 3), (2, 4), (3, 5), (4, 6), (5, 7)] ... ]) == [3] from solution import max_non_overlapping_meetings def test_max_non_overlapping_meetings(): # Test case 1 assert max_non_overlapping_meetings(2, [ [(1, 2), (3, 4), (0, 6)], [(1, 3), (2, 4), (3, 5), (7, 8)] ]) == [2, 3] # Test case 2 assert max_non_overlapping_meetings(1, [ [(1, 3), (2, 4), (3, 5), (4, 6), (5, 7)] ]) == [3] # Test case 3 assert max_non_overlapping_meetings(3, [ [(1, 5), (5, 9), (6, 10), (10, 15)], [(0, 5), (1, 2), (2, 3)], [(1, 4), (4, 7), (3, 5)] ]) == [3, 2, 2] # Test Case 4 : only 1 test case with non-overlapping meetings assert max_non_overlapping_meetings(1, [[(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8)]]) == [7] # Test Case 5 : Large inputs large_input_meetings = [(i, i + 1) for i in range(0, 1000000, 2)] # This would produce 500000 meetings assert max_non_overlapping_meetings(1, [large_input_meetings]) == [500000] def test_edge_cases(): # Test Case 6: No meetings assert max_non_overlapping_meetings(1, [[]]) == [0] # Test Case 7: Single meeting assert max_non_overlapping_meetings(1, [[(1, 2)]]) == [1] # Test Case 8: Meetings with same end times assert max_non_overlapping_meetings(1, [[(1, 4), (2, 4), (3, 4)]]) == [1]","solution":"def max_non_overlapping_meetings(T, test_cases): Determines the maximum number of non-overlapping meetings for each test case. Parameters: T (int): Number of test cases. test_cases (list): List of test cases, where each test case is a list of tuples representing start and end times of meetings. Returns: list: A list of integers representing the maximum number of non-overlapping meetings for each test case. results = [] for i in range(T): meetings = test_cases[i] # Sort meetings by end time meetings.sort(key=lambda x: x[1]) count = 0 last_end_time = 0 for start, end in meetings: if start >= last_end_time: count += 1 last_end_time = end results.append(count) return results"},{"question":"def most_repeated_integer(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given a list of test cases, return the most repeated integer for each test case. If there is a tie, return the smallest integer. >>> most_repeated_integer([(5, [1, 2, 2, 3, 1])]) [1] >>> most_repeated_integer([(6, [4, 5, 6, 5, 5, 4])]) [5] >>> most_repeated_integer([(4, [7, 8, 8, 7])]) [7]","solution":"def most_repeated_integer(test_cases): Given a list of test cases, return the most repeated integer for each test case. If there is a tie, return the smallest integer. from collections import Counter results = [] for case in test_cases: n, integers = case counts = Counter(integers) # Find the maximum frequency and then the smallest integer with that frequency max_freq = max(counts.values()) most_repeated = min([k for k, v in counts.items() if v == max_freq]) results.append(most_repeated) return results"},{"question":"def calculate_median_salary(n: int, salaries: List[int]) -> float: Calculate the median salary from a list of salaries. Arguments: n -- number of employees salaries -- list of annual salaries of the employees Returns: The median salary as a float value formatted to one decimal place. >>> calculate_median_salary(5, [55000, 45000, 70000, 40000, 60000]) 55000.0 >>> calculate_median_salary(4, [32000, 47000, 36000, 41000]) 38500.0 >>> calculate_median_salary(1, [50000]) 50000.0 >>> calculate_median_salary(3, [30000, 40000, 50000]) 40000.0 >>> calculate_median_salary(3, [50000, 40000, 30000]) 40000.0 >>> calculate_median_salary(2, [10000000, 20000000]) 15000000.0","solution":"def calculate_median_salary(n, salaries): Calculate the median salary from a list of salaries. Arguments: n -- number of employees salaries -- list of annual salaries of the employees Returns: The median salary as a float value formatted to one decimal place. salaries.sort() if n % 2 == 1: median = salaries[n // 2] else: median = (salaries[n // 2 - 1] + salaries[n // 2]) / 2 return round(median, 1)"},{"question":"def max_distinct_cells(R: int, C: int, grid: List[str]) -> int: Returns the maximum number of distinct cells Miro can visit on his path from (1, 1) to (R, C). >>> max_distinct_cells(3, 3, [\\"...\\", \\"...\\", \\"...\\"]) 5 >>> max_distinct_cells(5, 6, [\\"......\\", \\".#..#.\\", \\"..#...\\", \\"....#.\\", \\"......\\"]) 10 >>> max_distinct_cells(2, 2, [\\"\\", \\"\\"]) -1 >>> max_distinct_cells(3, 3, [\\"#..\\", \\"...\\", \\"..#\\"]) -1","solution":"def max_distinct_cells(R, C, grid): Returns the maximum number of distinct cells Miro can visit on his path from (1, 1) to (R, C). if grid[0][0] == '#' or grid[R-1][C-1] == '#': return -1 # No path if starting or ending cells are obstacles # Initialize a 2D list to store the maximum cells visited up to each cell dp = [[0] * C for _ in range(R)] for i in range(R): for j in range(C): if grid[i][j] == '#': dp[i][j] = -1 else: current_max = 0 if i > 0 and dp[i-1][j] != -1: current_max = max(current_max, dp[i-1][j]) if j > 0 and dp[i][j-1] != -1: current_max = max(current_max, dp[i][j-1]) dp[i][j] = current_max + 1 return dp[R-1][C-1] if dp[R-1][C-1] != -1 else -1"},{"question":"def can_tutor_all_students(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[str]: Determines whether it's possible to cover all students using provided sessions. Args: T: int - number of test cases. test_cases: list of tuples (N, M, sessions) - each test case containing: N: int - number of students M: int - number of sessions sessions: list of tuples (A, B) - each session covering range A to B. Returns: list of str: \\"YES\\" or \\"NO\\" for each test case. >>> can_tutor_all_students(2, [(5, 3, [(1, 2), (2, 4), (3, 5)]), (6, 2, [(1, 3), (4, 6)])]) == [\\"YES\\", \\"YES\\"] >>> can_tutor_all_students(1, [(5, 2, [(1, 2), (4, 5)])]) == [\\"NO\\"]","solution":"def can_tutor_all_students(T, test_cases): Determines whether it's possible to cover all students using provided sessions. Args: T: int - number of test cases. test_cases: list of tuples (N, M, sessions) - each test case containing: N: int - number of students M: int - number of sessions sessions: list of tuples (A, B) - each session covering range A to B. Returns: list of str: \\"YES\\" or \\"NO\\" for each test case. results = [] for i in range(T): N, M, sessions = test_cases[i] # sort sessions by starting point, then by ending point if start points are same sessions.sort() # Greedily check if we can cover the entire range from 1 to N current_end = -1 max_end_reachable = 0 j = 0 while j < M and max_end_reachable < N: if sessions[j][0] > max_end_reachable + 1: break while j < M and sessions[j][0] <= max_end_reachable + 1: current_end = max(current_end, sessions[j][1]) j += 1 max_end_reachable = current_end if max_end_reachable >= N: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def max_trains(events: list[tuple[int, str]]) -> int: Determines the maximum number of trains present at the station simultaneously. Args: events (list of tuples): List of events where each event is a tuple (time, type). Returns: int: Maximum number of trains present at the station simultaneously. Examples: >>> max_trains([(2, 'arrive'), (3, 'arrive'), (5, 'arrive'), (5, 'depart'), (7, 'arrive'), (9, 'depart'), (10, 'depart'), (12, 'depart')]) 3 >>> max_trains([(1, 'arrive'), (1, 'arrive'), (1, 'depart'), (1, 'depart')]) 2 import pytest def test_single_event(): assert max_trains([(0, 'arrive')]) == 1 assert max_trains([(0, 'depart')]) == 0 def test_multiple_events(): events = [ (2, 'arrive'), (3, 'arrive'), (5, 'arrive'), (5, 'depart'), (7, 'arrive'), (9, 'depart'), (10, 'depart'), (12, 'depart') ] assert max_trains(events) == 3 def test_all_depart(): events = [ (1, 'arrive'), (2, 'arrive'), (3, 'depart'), (4, 'depart') ] assert max_trains(events) == 2 def test_same_time(): events = [ (1, 'arrive'), (1, 'arrive'), (1, 'depart'), (1, 'depart') ] assert max_trains(events) == 2 def test_decreasing_departures(): events = [ (1, 'arrive'), (2, 'arrive'), (3, 'depart'), (4, 'depart') ] assert max_trains(events) == 1 def test_all_events_at_same_time(): events = [ (5, 'arrive'), (5, 'arrive'), (5, 'arrive'), (5, 'depart'), (5, 'depart') ] assert max_trains(events) == 3","solution":"def max_trains(events): Determines the maximum number of trains present at the station simultaneously. Args: events (list of tuples): List of events where each event is a tuple (time, type). Returns: int: Maximum number of trains present at the station simultaneously. max_trains_at_station = 0 current_trains_at_station = 0 # events is a list of tuples in the form (time, type) for event in events: if event[1] == 'arrive': current_trains_at_station += 1 max_trains_at_station = max(max_trains_at_station, current_trains_at_station) elif event[1] == 'depart': current_trains_at_station -= 1 return max_trains_at_station"},{"question":"def is_valid_numbering(n: int, sequence: list[int]) -> str: Checks if the numbering sequence of the rooms is valid. A sequence is valid if the difference between any two successive numbers is 1 or -1. Args: n (int): Number of rooms. sequence (list of int): Sequence of room numbers. Returns: str: \\"VALID\\" if the numbering sequence is valid, otherwise \\"INVALID\\". >>> is_valid_numbering(5, [1, 2, 3, 4, 5]) \\"VALID\\" >>> is_valid_numbering(4, [2, 1, 2, 1]) \\"VALID\\" >>> is_valid_numbering(3, [1, 3, 2]) \\"INVALID\\"","solution":"def is_valid_numbering(n, sequence): Checks if the numbering sequence of the rooms is valid. A sequence is valid if the difference between any two successive numbers is 1 or -1. Args: n (int): Number of rooms. sequence (list of int): Sequence of room numbers. Returns: str: \\"VALID\\" if the numbering sequence is valid, otherwise \\"INVALID\\". for i in range(1, n): if abs(sequence[i] - sequence[i-1]) != 1: return \\"INVALID\\" return \\"VALID\\""},{"question":"def min_operations_to_transform(n: int, m: int, S1: str, S2: str, k: int) -> int: Calculate the minimum number of operations required to transform S1 into S2 by inserting, deleting, or replacing characters, with the constraint that up to k positions can be operated on simultaneously. >>> min_operations_to_transform(6, 7, \\"kitten\\", \\"sitting\\", 1) 3 >>> min_operations_to_transform(6, 8, \\"abcdef\\", \\"abcdfefg\\", 2) 2 >>> min_operations_to_transform(1, 1, \\"a\\", \\"b\\", 1) 1 >>> min_operations_to_transform(5, 5, \\"abcde\\", \\"fghij\\", 1) 5 >>> min_operations_to_transform(5, 5, \\"abcde\\", \\"abcde\\", 1) 0","solution":"def min_operations_to_transform(n, m, S1, S2, k): import numpy as np dp = np.zeros((n + 1, m + 1), dtype=int) for i in range(1, n + 1): dp[i][0] = i for j in range(1, m + 1): dp[0][j] = j for i in range(1, n + 1): for j in range(1, m + 1): if S1[i - 1] == S2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1]) # Replacement if i >= k and S1[i - k:i] == S2[j - k:j]: dp[i][j] = min(dp[i][j], 1 + dp[i - k][j - k]) return dp[n][m]"},{"question":"def can_rearrange_even_occurrences(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if arrays can be rearranged such that every integer appears an even number of times. Args: T (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): List of test cases where each case is a tuple of an integer and a list of integers. Returns: List[str]: List of results for each test case as \\"YES\\" or \\"NO\\". >>> can_rearrange_even_occurrences(3, [(4, [1, 2, 2, 1]), (5, [1, 2, 2, 1, 3]), (6, [3, 3, 2, 2, 2, 2])]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> can_rearrange_even_occurrences(2, [(1, [1]), (4, [2, 2, 2, 2])]) [\\"NO\\", \\"YES\\"] from solution import can_rearrange_even_occurrences def test_can_rearrange_even_occurrences_all_yes(): T = 3 test_cases = [ (4, [1, 2, 2, 1]), (6, [3, 3, 2, 2, 2, 2]), (6, [1, 1, 2, 2, 3, 3]) ] assert can_rearrange_even_occurrences(T, test_cases) == [\\"YES\\", \\"YES\\", \\"YES\\"] def test_can_rearrange_even_occurrences_all_no(): T = 2 test_cases = [ (5, [1, 2, 2, 1, 3]), (3, [1, 2, 1]) ] assert can_rearrange_even_occurrences(T, test_cases) == [\\"NO\\", \\"NO\\"] def test_can_rearrange_even_occurrences_mixed(): T = 2 test_cases = [ (4, [1, 2, 2, 1]), (5, [1, 2, 2, 1, 3]) ] assert can_rearrange_even_occurrences(T, test_cases) == [\\"YES\\", \\"NO\\"] def test_can_rearrange_even_occurrences_single_element(): T = 1 test_cases = [ (1, [1]) ] assert can_rearrange_even_occurrences(T, test_cases) == [\\"NO\\"] def test_can_rearrange_even_occurrences_same_elements(): T = 1 test_cases = [ (4, [2, 2, 2, 2]) ] assert can_rearrange_even_occurrences(T, test_cases) == [\\"YES\\"]","solution":"def can_rearrange_even_occurrences(T, test_cases): results = [] for i in range(T): n = test_cases[i][0] array = test_cases[i][1] from collections import Counter counter = Counter(array) if all(count % 2 == 0 for count in counter.values()): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List, Tuple def first_appearing_letter(strings: List[str]) -> Tuple[str, int]: Returns the first appearing letter across all strings and the number of times it appears in the entire list. >>> first_appearing_letter([\\"hello\\", \\"world\\", \\"hi\\", \\"wow\\"]) ('h', 2) >>> first_appearing_letter([\\"abcd\\", \\"efgh\\", \\"ijkl\\"]) ('a', 1) >>> first_appearing_letter([\\"abcde\\"]) ('a', 1) >>> first_appearing_letter([\\"aaaa\\", \\"aa\\", \\"aaa\\"]) ('a', 9) >>> first_appearing_letter([\\"bcda\\", \\"cdef\\", \\"efgh\\"]) ('b', 1) def process_input(input_data: str) -> List[str]: Processes the input data and returns a list of strings. >>> process_input(\\"3nabcdnefghnijkln\\") ['abcd', 'efgh', 'ijkl'] def main(input_data: str): Main function to handle input and output. >>> main(\\"4nhellonworldnhinwown\\") h 2","solution":"def first_appearing_letter(strings): Returns the first appearing letter across all strings and the number of times it appears in the entire list. first_occurrence = [float('inf')] * 26 # to record the first occurrence of each letter letter_count = [0] * 26 # to count occurrences of each letter for string in strings: for idx, char in enumerate(string): char_index = ord(char) - ord('a') letter_count[char_index] += 1 if first_occurrence[char_index] == float('inf'): first_occurrence[char_index] = idx min_position = float('inf') letter = '' for idx, pos in enumerate(first_occurrence): if pos < min_position: min_position = pos letter = chr(idx + ord('a')) return letter, letter_count[ord(letter) - ord('a')] def process_input(input_data): input_list = input_data.strip().split('n') n = int(input_list[0]) strings = input_list[1:n+1] return strings def main(input_data): strings = process_input(input_data) letter, count = first_appearing_letter(strings) print(letter, count)"},{"question":"def balanced_brackets(string: str) -> bool: Checks if a given string contains balanced brackets. Args: string (str): Input string containing only '(', ')', '{', '}', '[' and ']'. Returns: bool: True if the string has balanced brackets, False otherwise. >>> balanced_brackets(\\"()\\") True >>> balanced_brackets(\\"([{}])\\") True >>> balanced_brackets(\\"([)]\\") False >>> balanced_brackets(\\"({[}])\\") False >>> balanced_brackets(\\"\\") True","solution":"def balanced_brackets(string): Checks if a given string contains balanced brackets. Args: string (str): Input string containing only '(', ')', '{', '}', '[' and ']'. Returns: bool: True if the string has balanced brackets, False otherwise. stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in string: if char in bracket_map.values(): stack.append(char) elif char in bracket_map.keys(): if stack == [] or bracket_map[char] != stack.pop(): return False else: # Invalid character for this problem return False return stack == []"},{"question":"def num_unique_paths(grid: List[List[int]]) -> int: Determine the number of unique paths in a grid from the top-left to the bottom-right corner, navigating only down or right, while avoiding obstacles. >>> num_unique_paths([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 2 >>> num_unique_paths([ ... [0, 1, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 1","solution":"def num_unique_paths(grid): Determine the number of unique paths in a grid from the top-left to the bottom-right corner, navigating only down or right, while avoiding obstacles. n = len(grid) m = len(grid[0]) if grid[0][0] == 1 or grid[n-1][m-1] == 1: return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 # starting point for i in range(n): for j in range(m): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1] # Example usage: # grid = [ # [0, 0, 0], # [0, 1, 0], # [0, 0, 0] # ] # print(num_unique_paths(grid)) # Output should be 2"},{"question":"def min_jumps_to_end(N: int, array: List[int]) -> int: Determine the minimum number of jumps Sakura needs to reach the last platform. Return -1 if it's impossible to reach the last platform. >>> min_jumps_to_end(5, [0, 0, 1, 0, 0]) 3 >>> min_jumps_to_end(5, [0, 1, 1, 1, 0]) -1","solution":"from collections import deque def min_jumps_to_end(N, array): if array[0] == 1 or array[-1] == 1: return -1 jumps = 0 queue = deque([(0, jumps)]) # (current_index, current_jumps) visited = [False] * N visited[0] = True while queue: index, jumps = queue.popleft() # Check if we have reached the last platform if index == N - 1: return jumps # Check both possible jumps (1 step and 2 steps ahead) for step in [1, 2]: next_index = index + step if next_index < N and not visited[next_index] and array[next_index] == 0: queue.append((next_index, jumps + 1)) visited[next_index] = True return -1"},{"question":"def count_steps_to_satisfy_children(n: int, candies: List[int]) -> int: Determines the number of steps it takes for John to satisfy all the children with their desired candies. Args: n (int): The number of children. candies (list of int): The number of candies each child desires. Returns: int: The total number of steps taken to satisfy all children. >>> count_steps_to_satisfy_children(3, [1, 2, 3]) 6 >>> count_steps_to_satisfy_children(4, [1, 1, 1, 1]) 4","solution":"def count_steps_to_satisfy_children(n, candies): Determines the number of steps it takes for John to satisfy all the children with their desired candies. Args: n (int): The number of children. candies (list of int): The number of candies each child desires. Returns: int: The total number of steps taken to satisfy all children. return sum(candies)"},{"question":"def filter_words(words: List[str], special_chars: str) -> List[str]: Filters out words that contain any of the special characters. :param words: List of alphanumeric strings :param special_chars: String of special characters :return: List of words that do not contain any special characters from typing import List def test_example1(): words = [\\"hello\\", \\"h3ll0\\", \\"world\\", \\"!world\\", \\"python\\"] special_chars = \\"!@#%^&*()\\" assert filter_words(words, special_chars) == [\\"hello\\", \\"h3ll0\\", \\"world\\", \\"python\\"] def test_example2(): words = [\\"abc\\", \\"def@ghi\\", \\"123!456\\", \\"789\\"] special_chars = \\"@!\\" assert filter_words(words, special_chars) == [\\"abc\\", \\"789\\"] def test_no_special_characters(): words = [\\"hello\\", \\"world\\", \\"python\\"] special_chars = \\"!@#%^&*()\\" assert filter_words(words, special_chars) == [\\"hello\\", \\"world\\", \\"python\\"] def test_all_special_characters(): words = [\\"!hello\\", \\"@world\\", \\"#python\\"] special_chars = \\"!@#%^&*()\\" assert filter_words(words, special_chars) == [] def test_some_special_characters(): words = [\\"hello!\\", \\"world@123\\", \\"goodmorning\\", \\"python2023\\"] special_chars = \\"!@#\\" assert filter_words(words, special_chars) == [\\"python2023\\"] def test_special_characters_in_middle_of_words(): words = [\\"hel!lo\\", \\"wor@ld\\", \\"python\\"] special_chars = \\"!@#\\" assert filter_words(words, special_chars) == [] def test_empty_words_list(): words = [] special_chars = \\"!@#%^&*()\\" assert filter_words(words, special_chars) == [] def test_empty_special_characters(): words = [\\"hello\\", \\"world\\", \\"python\\"] special_chars = \\"\\" assert filter_words(words, special_chars) == [\\"hello\\", \\"world\\", \\"python\\"]","solution":"def filter_words(words, special_chars): Filters out words that contain any of the special characters. :param words: List of alphanumeric strings :param special_chars: String of special characters :return: List of words that do not contain any special characters return [word for word in words if not any(char in word for char in special_chars)]"},{"question":"def solve(m: int, n: int, matrix: List[List[int]]) -> int: Find the largest rectangle in the grid that contains only crops. >>> solve(4, 4, [[1, 0, 1, 0], [1, 0, 1, 1], [1, 1, 1, 1], [0, 1, 0, 0]]) == 4 >>> solve(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 0 >>> solve(2, 4, [[1, 1, 1, 1], [1, 1, 1, 1]]) == 8","solution":"def largest_rectangle_area(matrix): if not matrix: return 0 max_area = 0 n = len(matrix[0]) heights = [0] * n for row in matrix: for i in range(n): if row[i] == 0: heights[i] = 0 else: heights[i] += 1 max_area = max(max_area, max_histogram_area(heights)) return max_area def max_histogram_area(heights): stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def solve(m, n, matrix): return largest_rectangle_area(matrix)"},{"question":"def max_unique_characters(s: str) -> int: Returns the maximum number of unique characters Polycarp can collect starting at any index in the string. >>> max_unique_characters('abcde') == 5 >>> max_unique_characters('abacad') == 4 >>> max_unique_characters('abcdabc') == 4 pass def solution(t: int, strings: List[str]) -> List[int]: For a given number of test cases, returns the maximum number of unique characters Polycarp can collect starting at any index. pass if __name__ == \\"__main__\\": assert solution(1, [\\"abcde\\"]) == [5] assert solution(3, [\\"abcde\\", \\"abacad\\", \\"abcdabc\\"]) == [5, 4, 4] assert solution(1, [\\"aaaaaaa\\"]) == [1] assert solution(1, [\\"a\\"]) == [1] assert solution(1, [\\"ab\\" * 500]) == [2] assert solution(1, [\\"abcdefghi\\"]) == [9]","solution":"def max_unique_characters(s): Returns the maximum number of unique characters Polycarp can collect. n = len(s) max_unique = 0 for start in range(n): visited = set() count = 0 position = start skips = 0 while True: if s[position] not in visited: visited.add(s[position]) count += 1 skips = 0 # reset skips after keeping a character else: skips += 1 if skips > 1: # we can skip at most one character break position = (position + 1) % n if position == start: break max_unique = max(max_unique, count) return max_unique def solution(t, strings): results = [max_unique_characters(s) for s in strings] return results"},{"question":"def max_swappable_product(T, test_cases): Determine the maximum possible value of the product of two swapable elements in the array. Args: T (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples containing the number of elements in the array and the array of integers. Returns: List[int]: The maximum possible products for each test case. >>> max_swappable_product(2, [(5, [3, 6, 2, 8, 1]), (4, [1, 3, 2, 4])]) [48, 12] pass # Parse input from the example format def parse_input(input_lines): T = int(input_lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(input_lines[index]) array = list(map(int, input_lines[index + 1].split())) test_cases.append((N, array)) index += 2 return T, test_cases def process_input(input_text): input_lines = input_text.strip().split(\\"n\\") T, test_cases = parse_input(input_lines) return max_swappable_product(T, test_cases) # Unit Tests def test_max_swappable_product_sample1(): input_text = 2 5 3 6 2 8 1 4 1 3 2 4 expected_output = [48, 12] assert process_input(input_text) == expected_output def test_max_swappable_product_single_case(): input_text = 1 3 10 3 5 expected_output = [50] assert process_input(input_text) == expected_output def test_max_swappable_product_large_numbers(): input_text = 1 3 1000000000 999999999 100000000 expected_output = [999999999000000000] assert process_input(input_text) == expected_output def test_max_swappable_product_only_two_elements(): input_text = 1 2 7 8 expected_output = [56] assert process_input(input_text) == expected_output def test_max_swappable_product_all_same_elements(): input_text = 1 4 9 9 9 9 expected_output = [81] assert process_input(input_text) == expected_output","solution":"def max_swappable_product(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] array = test_cases[i][1] max1 = max(array) array.remove(max1) max2 = max(array) result = max1 * max2 results.append(result) return results # Parse input from the example format def parse_input(input_lines): T = int(input_lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(input_lines[index]) array = list(map(int, input_lines[index + 1].split())) test_cases.append((N, array)) index += 2 return T, test_cases def process_input(input_text): input_lines = input_text.strip().split(\\"n\\") T, test_cases = parse_input(input_lines) return max_swappable_product(T, test_cases)"},{"question":"def find_days_with_high_sales(N: int, sales: List[int], S: int) -> List[int]: Returns a list of days (1-indexed) where the sales exceeded the threshold S. >>> find_days_with_high_sales(6, [12000, 8000, 15000, 7000, 18000, 9000], 10000) [1, 3, 5] >>> find_days_with_high_sales(5, [5000, 5000, 5000, 5000, 5000], 1000) [1, 2, 3, 4, 5] >>> find_days_with_high_sales(3, [0, 0, 0], 0) [] >>> find_days_with_high_sales(3, [10000, 10000, 10000], 5000) [1, 2, 3] >>> find_days_with_high_sales(4, [20000, 15000, 5000, 25000], 18000) [1, 4] >>> find_days_with_high_sales(1, [1000], 2000) []","solution":"def find_days_with_high_sales(N, sales, S): Returns a list of days (1-indexed) where the sales exceeded the threshold S. result = [] for i in range(N): if sales[i] > S: result.append(i + 1) return result"},{"question":"def rotate_matrix_90_degrees_clockwise(matrix): Rotates an NxN matrix 90 degrees clockwise in place. >>> rotate_matrix_90_degrees_clockwise([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> rotate_matrix_90_degrees_clockwise([ ... [1, 2], ... [3, 4] ... ]) [ [3, 1], [4, 2] ]","solution":"def rotate_matrix_90_degrees_clockwise(matrix): Rotates an NxN matrix 90 degrees clockwise in place. N = len(matrix) # Transpose the matrix for i in range(N): for j in range(i, N): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(N): matrix[i].reverse() return matrix"},{"question":"def max_subarray_sum(A): Returns the maximum sum of milk production capacities of a contiguous subarray. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1, 2, 3, 4, -10]) 10 >>> max_subarray_sum([5]) 5 >>> max_subarray_sum([-5]) -5 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([5, -1, 4, -2, 8, -10, 3, -1]) 14 >>> large_input = [1000] * 100000 >>> max_subarray_sum(large_input) 100000000","solution":"def max_subarray_sum(A): Returns the maximum sum of milk production capacities of a contiguous subarray. max_current = max_global = A[0] for value in A[1:]: max_current = max(value, max_current + value) if max_current > max_global: max_global = max_current return max_global"},{"question":"def hammingDistance(strand1, strand2): Computes the Hamming distance between two DNA strands. The Hamming distance between two strands is the number of positions at which the corresponding bases are different. >>> hammingDistance(\\"GAGCCTACTAACGGGAT\\", \\"CATCGTAATGACGGCCT\\") 7 >>> hammingDistance(\\"AAAA\\", \\"AAAA\\") 0 >>> hammingDistance(\\"AAAA\\", \\"TTTT\\") 4 >>> hammingDistance(\\"AAAA\\", \\"AAAT\\") 1 >>> hammingDistance(\\"GCGC\\", \\"GCGT\\") 1 # Your code here","solution":"def hammingDistance(strand1, strand2): Computes the Hamming distance between two DNA strands. Parameters: strand1 (str): First DNA strand. strand2 (str): Second DNA strand. Returns: int: The Hamming distance between strand1 and strand2. # Ensure strands are of equal length (assertion based on problem statement) assert len(strand1) == len(strand2), \\"Strands must be of equal length\\" # Compute the Hamming distance by comparing each position in the strands distance = 0 for ch1, ch2 in zip(strand1, strand2): if ch1 != ch2: distance += 1 return distance"},{"question":"from collections import deque # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxPerformancePerLevel(root): Finds the maximum performance score in each level of the binary tree. Parameters: root (TreeNode): The root of the binary tree. Returns: List[int]: A list containing the maximum performance scores of each level. Example: >>> root = TreeNode(1) >>> root.left = TreeNode(3) >>> root.right = TreeNode(2) >>> root.left.left = TreeNode(5) >>> root.left.right = TreeNode(3) >>> root.right.right = TreeNode(9) >>> maxPerformancePerLevel(root) [1, 3, 9]","solution":"from collections import deque # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxPerformancePerLevel(root): if not root: return [] result = [] queue = deque([root]) while queue: level_length = len(queue) level_max = float('-inf') for _ in range(level_length): node = queue.popleft() level_max = max(level_max, node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_max) return result"},{"question":"def organize_bookshelf(titles: List[str]) -> str: Groups the book titles by their first letter and sorts each group in alphabetical order. :param titles: List of book titles :return: Grouped and sorted book titles as a string with each group separated by a blank line. >>> organize_bookshelf([\\"apple\\", \\"apricot\\", \\"avocado\\"]) 'applenapricotnavocado' >>> organize_bookshelf([\\"dog\\", \\"cat\\", \\"duck\\", \\"cow\\"]) 'catncownndognduck' >>> organize_bookshelf([\\"banana\\", \\"apple\\", \\"blueberry\\", \\"apricot\\", \\"avocado\\"]) 'applenapricotnavocadonnbanananblueberry' >>> organize_bookshelf([\\"zebra\\"]) 'zebra' >>> organize_bookshelf([]) ''","solution":"def organize_bookshelf(titles): Groups the book titles by their first letter and sorts each group in alphabetical order. :param titles: List of book titles :return: Grouped and sorted book titles as a string with each group separated by a blank line. from collections import defaultdict # Create a dictionary to store lists of titles indexed by their first letter grouped_titles = defaultdict(list) # Group titles by their first letter for title in titles: first_char = title[0] grouped_titles[first_char].append(title) # Sort each group and the keys for key in grouped_titles.keys(): grouped_titles[key].sort() sorted_keys = sorted(grouped_titles.keys()) # Construct the output result = [] for key in sorted_keys: result.extend(grouped_titles[key]) result.append(\\"\\") # Add a blank line after each group return \\"n\\".join(result).strip()"},{"question":"def find_peak_position(n, nums): Returns the 1-based index of any peak in the list. A peak is any element which is greater than its immediate neighbors. If there is no peak, returns -1. Parameters: n: int - the number of integers in the list. nums: list of int - the list of integers. Returns: int - the 1-based index of any peak or -1 if there are no peaks. Example: >>> find_peak_position(6, [1, 3, 2, 3, 5, 4]) in [2, 4, 5] >>> find_peak_position(5, [1, 2, 3, 4, 5]) == -1","solution":"def find_peak_position(n, nums): Returns the 1-based index of any peak in the list. A peak is any element which is greater than its immediate neighbors. If there is no peak, returns -1. Parameters: n: int - the number of integers in the list. nums: list of int - the list of integers. Returns: int - the 1-based index of any peak or -1 if there are no peaks. for i in range(1, n - 1): if nums[i] > nums[i - 1] and nums[i] > nums[i + 1]: return i + 1 return -1"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Returns the maximum possible sum of its contiguous subarray. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([-1]) -1 >>> max_subarray_sum([5, 4, -1, 7, 8]) 23 >>> max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) 7 >>> max_subarray_sum([8, -19, 5, -4, 20]) 21 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1","solution":"def max_subarray_sum(nums): Returns the sum of the largest sum contiguous subarray using Kadane's algorithm. max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def min_edit_distance(start: str, goal: str) -> int: Calculate the minimum number of operations required to transform start into goal using insert, delete, and replace operations. >>> min_edit_distance(\\"kitten\\", \\"sitting\\") 3 >>> min_edit_distance(\\"abcd\\", \\"abef\\") 2 def process_test_cases(T: int, test_cases: List[Tuple[str, str]]) -> List[int]: Process multiple test cases and return the results for each. >>> process_test_cases(2, [(\\"kitten\\", \\"sitting\\"), (\\"abcd\\", \\"abef\\")]) [3, 2] >>> process_test_cases(3, [(\\"abc\\", \\"def\\"), (\\"flaw\\", \\"lawn\\"), (\\"intention\\", \\"execution\\")]) [3, 2, 5] from solution import min_edit_distance, process_test_cases def test_min_edit_distance(): assert min_edit_distance(\\"kitten\\", \\"sitting\\") == 3 assert min_edit_distance(\\"abcd\\", \\"abef\\") == 2 assert min_edit_distance(\\"flaw\\", \\"lawn\\") == 2 assert min_edit_distance(\\"intention\\", \\"execution\\") == 5 assert min_edit_distance(\\"a\\", \\"b\\") == 1 assert min_edit_distance(\\"abc\\", \\"abc\\") == 0 assert min_edit_distance(\\"abcd\\", \\"abc\\") == 1 assert min_edit_distance(\\"abc\\", \\"abcd\\") == 1 def test_process_test_cases(): test_cases = [ (\\"kitten\\", \\"sitting\\"), (\\"abcd\\", \\"abef\\"), (\\"abc\\", \\"def\\"), ] results = process_test_cases(3, test_cases) assert results == [3, 2, 3] test_cases = [ (\\"\\", \\"\\"), (\\"a\\", \\"\\"), (\\"\\", \\"a\\"), ] results = process_test_cases(3, test_cases) assert results == [0, 1, 1] test_cases = [ (\\"abcdef\\", \\"azced\\"), (\\"sunday\\", \\"saturday\\"), ] results = process_test_cases(2, test_cases) assert results == [3, 3]","solution":"def min_edit_distance(start, goal): m, n = len(start), len(goal) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif start[i-1] == goal[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = 1 + min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1]) return dp[m][n] def process_test_cases(T, test_cases): results = [] for start, goal in test_cases: results.append(min_edit_distance(start, goal)) return results"},{"question":"def mergeSort(arr): Implement the Merge Sort algorithm to sort an array in non-decreasing order. Parameters: arr (List[int]): the unsorted array of integers Returns: List[int]: the array sorted in non-decreasing order Examples: >>> mergeSort([]) [] >>> mergeSort([1]) [1] >>> mergeSort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> mergeSort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> mergeSort([12, 11, 13, 5, 6]) [5, 6, 11, 12, 13] >>> mergeSort([3, 1, 2, 1, 3]) [1, 1, 2, 3, 3] >>> mergeSort([1000000000, -1000000000, 0, 999999999, -999999999]) [-1000000000, -999999999, 0, 999999999, 1000000000] >>> mergeSort([1, -1, 0, -2, 2]) [-2, -1, 0, 1, 2] pass","solution":"def mergeSort(arr): if len(arr) <= 1: return arr # Divide the array into two halves mid = len(arr) // 2 left_half = arr[:mid] right_half = arr[mid:] # Recursively sort each half left_sorted = mergeSort(left_half) right_sorted = mergeSort(right_half) # Merge the sorted halves return merge(left_sorted, right_sorted) def merge(left, right): sorted_array = [] i = j = 0 # Combine the two arrays while maintaining order while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_array.append(left[i]) i += 1 else: sorted_array.append(right[j]) j += 1 # Append the remaining elements sorted_array.extend(left[i:]) sorted_array.extend(right[j:]) return sorted_array"},{"question":"def roman_to_integer(roman: str) -> int: Converts a Roman numeral to an integer. >>> roman_to_integer(\\"III\\") == 3 >>> roman_to_integer(\\"IV\\") == 4 >>> roman_to_integer(\\"IX\\") == 9 >>> roman_to_integer(\\"MCMXCIV\\") == 1994","solution":"def roman_to_integer(roman): Converts a Roman numeral to an integer. roman_values = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for char in reversed(roman): value = roman_values[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"def euclidean_distance_squared(point1, point2): Calculate the squared Euclidean distance between two points on a 2D plane. def check_distances(points, k): Check if there exists a pair of points such that their squared Euclidean distance is exactly k^2. def process_input(T, test_cases): Process the input and determine the output for each test case. def solve(): Solve the problem by reading input, processing the test cases, and printing the results.","solution":"import math def euclidean_distance_squared(point1, point2): x1, y1 = point1 x2, y2 = point2 return (x2 - x1) ** 2 + (y2 - y1) ** 2 def check_distances(points, k): k_squared = k * k for i in range(len(points)): for j in range(i + 1, len(points)): if euclidean_distance_squared(points[i], points[j]) == k_squared: return \\"yes\\" return \\"no\\" def process_input(T, test_cases): results = [] for t in range(T): n, points, k = test_cases[t] results.append(check_distances(points, k)) return results def solve(): import sys input = sys.stdin.read data = input().strip().split() index = 0 T = int(data[index]) index += 1 test_cases = [] for _ in range(T): n = int(data[index]) index += 1 points = [] for _ in range(n): x = int(data[index]) y = int(data[index + 1]) points.append((x, y)) index += 2 k = int(data[index]) index += 1 test_cases.append((n, points, k)) results = process_input(T, test_cases) for result in results: print(result)"},{"question":"def count_unique_substrings(s: str) -> int: Determine the number of unique substrings of the string s. >>> count_unique_substrings(\\"abab\\") 7 >>> count_unique_substrings(\\"abcdef\\") 21 from solution import count_unique_substrings def test_example_1(): assert count_unique_substrings(\\"abab\\") == 7 def test_example_2(): assert count_unique_substrings(\\"abcdef\\") == 21 def test_single_char(): assert count_unique_substrings(\\"a\\") == 1 def test_multiple_same_chars(): assert count_unique_substrings(\\"aaa\\") == 3 def test_palindrome(): assert count_unique_substrings(\\"racecar\\") == 25 def test_repeated_char(): assert count_unique_substrings(\\"aaaaa\\") == 5","solution":"def count_unique_substrings(s): Returns the number of unique substrings of the string s. n = len(s) unique_substrings = set() for i in range(n): for j in range(i + 1, n + 1): unique_substrings.add(s[i:j]) return len(unique_substrings)"},{"question":"def is_palindrome(num: int) -> str: Check if an integer is a palindrome without converting it to a string. Args: num: An integer. Returns: \\"Yes\\" if the integer is a palindrome, otherwise \\"No\\". Examples: >>> is_palindrome(121) \\"Yes\\" >>> is_palindrome(-121) \\"No\\" >>> is_palindrome(123) \\"No\\"","solution":"def is_palindrome(num): Check if an integer is a palindrome without converting it to a string. if num < 0: return \\"No\\" original_num = num reversed_num = 0 while num > 0: reversed_num = reversed_num * 10 + num % 10 num = num // 10 if original_num == reversed_num: return \\"Yes\\" else: return \\"No\\""},{"question":"from typing import List def first_missing_positive(arr: List[int]) -> int: Given an array arr of integers, find the first missing positive integer. A missing positive integer is defined as the smallest positive integer that does not appear in arr. Your algorithm should run in O(n) time and uses constant extra space. >>> first_missing_positive([1, 2, 0]) 3 >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([7, 8, 9, 11, 12]) 1","solution":"def first_missing_positive(arr): Returns the first missing positive integer in arr. n = len(arr) # Step 1: Replace negative numbers and numbers larger than n with a placeholder (n+1) for i in range(n): if arr[i] <= 0 or arr[i] > n: arr[i] = n + 1 # Step 2: Use the index as a hash to record the presence of numbers for i in range(n): num = abs(arr[i]) if num <= n: arr[num - 1] = -abs(arr[num - 1]) # Step 3: The first positive index + 1 is the missing number for i in range(n): if arr[i] > 0: return i + 1 # If no missing number found, return n + 1 return n + 1"},{"question":"def count_nodes_on_path(n: int, edges: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]: Returns the number of nodes on the path between u and v for each query. Args: n : int : Number of nodes in the tree. edges : List[Tuple[int, int]] : List of edges where each edge is represented by a tuple (u, v). queries : List[Tuple[int, int]] : List of queries where each query is represented by a tuple (u, v). Returns: List[int] : List of results for each query which represents the number of nodes on the path between given nodes u and v. Example: >>> n = 5 >>> edges = [(1, 2), (1, 3), (2, 4), (2, 5)] >>> queries = [(1, 4), (4, 5), (3, 5)] >>> count_nodes_on_path(n, edges, queries) [3, 3, 4] >>> n = 1 >>> edges = [] >>> queries = [(1, 1)] >>> count_nodes_on_path(n, edges, queries) [1] >>> n = 4 >>> edges = [(1, 2), (2, 3), (3, 4)] >>> queries = [(1, 4), (2, 4), (1, 3)] >>> count_nodes_on_path(n, edges, queries) [4, 3, 3]","solution":"from collections import deque def bfs(tree, start, n): Perform BFS to calculate depth and parent arrays. depth = [-1] * (n + 1) parent = [-1] * (n + 1) queue = deque([start]) depth[start] = 0 while queue: node = queue.popleft() for neighbor in tree[node]: if depth[neighbor] == -1: queue.append(neighbor) depth[neighbor] = depth[node] + 1 parent[neighbor] = node return depth, parent def lca(u, v, depth, parent): Find the lowest common ancestor of u and v using depth and parent arrays. # Bring both u and v to the same depth while depth[u] > depth[v]: u = parent[u] while depth[v] > depth[u]: v = parent[v] # Move both u and v up simultaneously until they meet while u != v: u = parent[u] v = parent[v] return u def count_nodes_on_path(n, edges, queries): Returns the number of nodes on the path between u and v for each query. # Building the tree tree = [[] for _ in range(n + 1)] for u, v in edges: tree[u].append(v) tree[v].append(u) # Running BFS to calculate depth and parent arrays depth, parent = bfs(tree, 1, n) results = [] for u, v in queries: ancestor = lca(u, v, depth, parent) result = depth[u] + depth[v] - 2 * depth[ancestor] + 1 results.append(result) return results"},{"question":"def count_visible_buildings(test_cases: List[List[int]]) -> List[int]: Count the number of visible buildings from the left side of each test case. >>> count_visible_buildings([[3, 7, 8, 3, 6, 1]]) [3] >>> count_visible_buildings([[1, 2, 3, 4, 5]]) [5] pass def parse_input(input_text: str) -> List[List[int]]: Parse the input text to extract the test cases. >>> parse_input(\\"2n3 7 8 3 6 1n1 2 3 4 5\\") [[3, 7, 8, 3, 6, 1], [1, 2, 3, 4, 5]] pass def main(input_text: str) -> str: Main function to process the input text and return the number of visible buildings for each test case. >>> main(\\"2n3 7 8 3 6 1n1 2 3 4 5\\") \\"3n5\\" pass","solution":"def count_visible_buildings(test_cases): result = [] for buildings in test_cases: max_height = 0 visible_count = 0 for height in buildings: if height > max_height: visible_count += 1 max_height = height result.append(visible_count) return result def parse_input(input_text): lines = input_text.strip().split('n') T = int(lines[0]) test_cases = [] for i in range(1, T + 1): test_cases.append(list(map(int, lines[i].split()))) return test_cases def main(input_text): test_cases = parse_input(input_text) visible_buildings_count = count_visible_buildings(test_cases) return \\"n\\".join(map(str, visible_buildings_count))"},{"question":"def typing_speed_comparison(test_cases: List[Tuple[int, List[int]]]) -> List[List[str]]: Takes in the test cases and outputs the typing speed comparison. >>> typing_speed_comparison([(4, [50, 60, 55, 55]), (3, [70, 70, 80])]) [['N/A', 'faster', 'slower', 'same'], ['N/A', 'same', 'faster']] >>> typing_speed_comparison([(5, [10, 20, 30, 40, 50])]) [['N/A', 'faster', 'faster', 'faster', 'faster']] >>> typing_speed_comparison([(5, [50, 40, 30, 20, 10])]) [['N/A', 'slower', 'slower', 'slower', 'slower']] >>> typing_speed_comparison([(4, [50, 50, 50, 50])]) [['N/A', 'same', 'same', 'same']] >>> typing_speed_comparison([(5, [100, 100, 90, 95, 95])]) [['N/A', 'same', 'slower', 'faster', 'same']]","solution":"def typing_speed_comparison(test_cases): Takes in the test cases and outputs the typing speed comparison. results = [] for case in test_cases: n = case[0] speeds = case[1] comparison_results = [\\"N/A\\"] for i in range(1, n): if speeds[i] > speeds[i-1]: comparison_results.append(\\"faster\\") elif speeds[i] < speeds[i-1]: comparison_results.append(\\"slower\\") else: comparison_results.append(\\"same\\") results.append(comparison_results) return results"},{"question":"def minimum_latency(n: int, m: int, edges: List[Tuple[int, int, int]]) -> Union[int, str]: Finds the minimum latency required to connect all computers. Parameters: n (int): Number of computers m (int): Number of network cables (edges) edges (list): List of network cables where each cable is represented as a tuple (u, v, w) Returns: int or str: Minimum latency to connect all computers or \\"IMPOSSIBLE\\" if not all can be connected >>> minimum_latency(4, 5, [(1, 2, 5), (1, 3, 10), (1, 4, 20), (2, 3, 2), (3, 4, 3)]) 10 >>> minimum_latency(4, 2, [(1, 2, 1), (3, 4, 1)]) \\"IMPOSSIBLE\\" >>> minimum_latency(3, 3, [(1, 2, 1), (2, 3, 1), (1, 3, 2)]) 2","solution":"def minimum_latency(n, m, edges): Finds the minimum latency required to connect all computers using Kruskal's algorithm. Parameters: n (int): Number of computers m (int): Number of network cables (edges) edges (list): List of network cables where each cable is represented as a tuple (u, v, w) Returns: int or str: Minimum latency to connect all computers or \\"IMPOSSIBLE\\" if not all can be connected # Helper function to find the root of a node def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) # Helper function to perform union of two sets def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 # Initialize result result = 0 # Sort edges by latency edges = sorted(edges, key=lambda item: item[2]) parent = [i for i in range(n)] rank = [0] * n e = 0 i = 0 while e < n - 1: if i >= m: return \\"IMPOSSIBLE\\" u, v, w = edges[i] i += 1 x = find(parent, u - 1) y = find(parent, v - 1) if x != y: e += 1 result += w union(parent, rank, x, y) return result if e == n - 1 else \\"IMPOSSIBLE\\" # Example of function call: # n = 4 # m = 5 # edges = [(1, 2, 5), (1, 3, 10), (1, 4, 20), (2, 3, 2), (3, 4, 3)] # print(minimum_latency(n, m, edges)) # Output: 10"}]`),E={name:"App",components:{PoemCard:A},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},j={class:"search-container"},C={class:"card-container"},P={key:0,class:"empty-state"},D=["disabled"],F={key:0},z={key:1};function I(i,e,l,m,r,a){const f=h("PoemCard");return s(),n("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"prompts chat")])],-1)),t("div",j,[e[3]||(e[3]=t("span",{class:"search-icon"},"",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>r.searchQuery=o),placeholder:"Search..."},null,512),[[b,r.searchQuery]]),r.searchQuery?(s(),n("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>r.searchQuery="")},"  ")):u("",!0)]),t("div",C,[(s(!0),n(x,null,y(a.displayedPoems,(o,p)=>(s(),v(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),n("div",P,' No results found for "'+d(r.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(s(),n("button",{key:0,class:"load-more-button",disabled:r.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[r.isLoading?(s(),n("span",z,"Loading...")):(s(),n("span",F,"See more"))],8,D)):u("",!0)])}const O=_(E,[["render",I],["__scopeId","data-v-44799940"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/33.md","filePath":"library/33.md"}'),Y={name:"library/33.md"},G=Object.assign(Y,{setup(i){return(e,l)=>(s(),n("div",null,[w(O)]))}});export{M as __pageData,G as default};
