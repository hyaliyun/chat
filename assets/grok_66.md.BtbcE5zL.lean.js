import{_ as m,o as s,c as n,a as t,m as d,t as c,C as h,M as g,U as b,f as l,F as y,p as x,e as v,q as w}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},T={class:"review"},L={class:"review-title"},N={class:"review-content"};function A(i,e,u,_,r,a){return s(),n("div",k,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),d(c(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),d(c(u.poem.solution),1)])])])}const S=m(q,[["render",A],["__scopeId","data-v-b06adf04"]]),R=JSON.parse(`[{"question":"def maximal_positions_match(n: int, s: str, t: str) -> int: You are given two strings s and t. Vasya can rearrange (permute) the characters of string s. He wants to do it in such a way that the number of positions in the rearranged string s where the characters match the characters in string t is maximized. Help Vasya find the maximal number of matches possible. Args: n: the length of strings s and t. s: the string s consisting of lowercase English letters. t: the string t consisting of lowercase English letters. Returns: The maximal number of positions in the rearranged string s that can match the characters in string t. Example: >>> maximal_positions_match(4, 'aabc', 'cbda') 3 >>> maximal_positions_match(3, 'abc', 'xyz') 0","solution":"from collections import Counter def maximal_positions_match(n, s, t): Returns the maximum number of positions where characters of rearranged string s match string t. s_count = Counter(s) t_count = Counter(t) matches = 0 for char in t_count: if char in s_count: matches += min(s_count[char], t_count[char]) return matches"},{"question":"def robHouses(nums): Given an array of n integers representing the amount of money at each house, determine the maximum amount of money the thief can rob without triggering the alarm. The houses are arranged in a circle, and the thief cannot rob consecutive houses. Examples: >>> robHouses([2, 3, 2]) 3 >>> robHouses([1, 2, 3, 1]) 4 >>> robHouses([1, 2, 3]) 3","solution":"def robHouses(nums): if len(nums) == 1: return nums[0] return max(rob_linear(nums[:-1]), rob_linear(nums[1:])) def rob_linear(nums): prev, curr = 0, 0 for num in nums: prev, curr = curr, max(curr, prev + num) return curr"},{"question":"from typing import List import string def most_common_words(text: str) -> List[str]: Returns the list of most common words in alphabetical order after removing punctuation and converting to lowercase. >>> text1 = \\"Hello, hello? HELLO! How are you you you?\\" >>> most_common_words(text1) [\\"hello\\", \\"you\\"] >>> text2 = \\"It was the best of times, it was the worst of times.\\" >>> most_common_words(text2) [\\"it\\", \\"of\\", \\"the\\", \\"times\\", \\"was\\"] pass","solution":"from typing import List import string from collections import Counter def most_common_words(text: str) -> List[str]: Returns the list of most common words in alphabetical order after removing punctuation and converting to lowercase. # Remove punctuation translator = str.maketrans('', '', string.punctuation) cleaned_text = text.translate(translator) # Convert to lowercase and split into words words = cleaned_text.lower().split() # Count word frequencies word_counts = Counter(words) # Find the highest frequency max_count = max(word_counts.values()) # Extract words with the highest frequency most_common = [word for word, count in word_counts.items() if count == max_count] # Return the words sorted alphabetically return sorted(most_common)"},{"question":"def min_coins(t: int, cases: List[int]) -> List[int]: Determine the minimum number of coins needed to make any given amount of change using denominations of 1, 3, and 4 cents. Input: t (int): number of test cases cases (List[int]): the list of amounts of change to be made Output: List[int]: a list of integers representing the minimum number of coins needed for each amount Examples: >>> min_coins(3, [6, 11, 15]) [2, 3, 4] >>> min_coins(1, [1]) [1] >>> min_coins(1, [4]) [1] >>> min_coins(1, [3]) [1] >>> min_coins(1, [10]) [3] >>> min_coins(1, [0]) [0] >>> min_coins(1, [10000]) [2500] >>> min_coins(5, [1, 2, 3, 4, 5]) [1, 2, 1, 1, 2] >>> min_coins(3, [7, 9, 12]) [2, 3, 3] >>> min_coins(1, [9999]) [2500]","solution":"def min_coins(t, cases): Returns the minimum number of coins needed to make the given amounts of change for each case. :param t: Number of test cases :param cases: A list of integers where each integer represents an amount of change to be made :return: A list of integers where each integer represents the minimum number of coins needed for the corresponding amount in cases max_amount = max(cases) # Initialize a list to store the minimum number of coins for each amount up to the maximum amount in the cases min_coins_required = [float('inf')] * (max_amount + 1) # Base case: 0 coins needed to make 0 cents min_coins_required[0] = 0 denominations = [1, 3, 4] for i in range(1, max_amount + 1): for coin in denominations: if i >= coin: min_coins_required[i] = min(min_coins_required[i], min_coins_required[i - coin] + 1) result = [min_coins_required[amount] for amount in cases] return result"},{"question":"def max_sum_of_min_values(N: int, A: List[int]) -> int: Returns the maximum possible sum of the minimum values of all subsequences. Each integer in the array must belong to exactly one subsequence. >>> max_sum_of_min_values(6, [1, 3, 2, 4, 6, 5]) 21 >>> max_sum_of_min_values(5, [1, 1, 1, 1, 1]) 5 >>> max_sum_of_min_values(4, [1, 2, 3, 4]) 10 >>> max_sum_of_min_values(4, [4, 3, 2, 1]) 10 >>> max_sum_of_min_values(5, [4, 2, 9, 7, 3]) 25 >>> max_sum_of_min_values(1, [7]) 7","solution":"def max_sum_of_min_values(N, A): Returns the maximum possible sum of the minimum values of all subsequences. In this case, each element should be treated as its own subsequence. return sum(A)"},{"question":"def game_winner(num_cases: int, cases: List[Tuple[int, List[int], List[Tuple[int, int]]]]) -> List[str]: Determine the winner between Alice and Bob in a game played on a tree with N nodes. Args: - num_cases: The number of test cases. - cases: A list of test cases. Each test case contains: - N: The number of nodes in the tree. - node_values: A list of integers representing the magical value of each node. - edges: A list of tuples representing bidirectional edges between the nodes. Returns: - A list containing \\"Alice\\" or \\"Bob\\" for each test case depending on who wins the game. >>> game_winner(1, [(3, [1, 2, 3], [(1, 2), (1, 3)])]) [\\"Alice\\"] >>> game_winner(1, [(1, [1], [])]) [\\"Alice\\"] >>> game_winner(1, [(4, [4, 2, 3, 1], [(1, 2), (1, 3), (2, 4)])]) [\\"Alice\\"]","solution":"def game_winner(num_cases, cases): import sys input = sys.stdin.read from collections import deque results = [] for case_idx in range(num_cases): # Unpack the current case N, node_values, edges = cases[case_idx] if N == 1: results.append(\\"Alice\\") continue adj = [[] for _ in range(N + 1)] for u, v in edges: adj[u].append(v) adj[v].append(u) # We will perform a BFS to determine the level of each node from the root levels = [-1] * (N + 1) q = deque([1]) levels[1] = 0 while q: node = q.popleft() for neighbor in adj[node]: if levels[neighbor] == -1: # Not visited levels[neighbor] = levels[node] + 1 q.append(neighbor) max_level = max(levels) # If the tree has only one level, Alice wins by picking the root node if max_level == 1: results.append(\\"Alice\\") else: leaf_level_count = sum(1 for level in levels if level == max_level) if leaf_level_count % 2 == 1: results.append(\\"Alice\\") else: results.append(\\"Bob\\") return results def process_input(): import sys input = sys.stdin.read data = input().split() index = 0 T = int(data[index]) index += 1 cases = [] for _ in range(T): N = int(data[index]) index += 1 node_values = list(map(int, data[index:index + N])) index += N edges = [] for _ in range(N - 1): u = int(data[index]) v = int(data[index + 1]) edges.append((u, v)) index += 2 cases.append((N, node_values, edges)) return T, cases def main(): T, cases = process_input() results = game_winner(T, cases) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def min_moves_to_identical(n, seq1, seq2): You are given two sequences of n integers each such that the sequences are permutations of each other. You can perform the following operations any number of times to make these sequences identical: 1. Choose any element from the first sequence and move it to the end, shifting all subsequent elements one position to the left. 2. Choose any element from the second sequence and move it to the end, shifting all subsequent elements one position to the left. You want to perform the minimum number of moves to make the two sequences identical. Parameters: n (int): The length of the sequences seq1 (list): The first sequence of integers seq2 (list): The second sequence of integers Returns: int: The minimum number of moves required to make the sequences identical. >>> min_moves_to_identical(3, [1, 2, 3], [3, 2, 1]) 4 >>> min_moves_to_identical(5, [5, 4, 3, 2, 1], [1, 2, 3, 4, 5]) 8 >>> min_moves_to_identical(3, [1, 2, 3], [1, 2, 3]) 0 >>> min_moves_to_identical(4, [1, 2, 3, 4], [1, 2, 3, 4]) 0 >>> min_moves_to_identical(1, [1], [1]) 0 >>> min_moves_to_identical(4, [4, 3, 2, 1], [1, 2, 3, 4]) 6","solution":"def min_moves_to_identical(n, seq1, seq2): Parameters: n (int): The length of the sequences. seq1 (list): The first sequence of integers. seq2 (list): The second sequence of integers. Returns: int: The minimum number of moves required to make the sequences identical. # create a dictionary to store the index of each element in the second sequence index_map = {value: idx for idx, value in enumerate(seq2)} # create a list to store the mapped indices of seq1's elements mapped_seq = [index_map[value] for value in seq1] # Find the longest increasing subsequence (LIS) in mapped_seq lis = [] for idx in mapped_seq: pos = binary_search(lis, idx) if pos == len(lis): lis.append(idx) else: lis[pos] = idx # The number of moves required is twice the number of elements not in the LIS return 2 * (n - len(lis)) def binary_search(seq, value): Helper function to perform binary search and return the position to replace or append. low, high = 0, len(seq) while low < high: mid = (low + high) // 2 if seq[mid] < value: low = mid + 1 else: high = mid return low"},{"question":"from typing import List, Tuple def find_minimum_costs(N: int, roads: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Given the number of locations N, a list of roads where each road is represented by a tuple (u, v, C) signifying a road between locations u and v with cost C, and a list of queries where each query is a tuple (u, v), find the minimum travel cost between the locations given in each query. Args: N: An integer representing the number of locations. roads: A list of tuples, where each tuple contains three integers u, v, and C representing a road between locations u and v with cost C. queries: A list of tuples, where each tuple contains two integers u and v representing a query for finding the minimum travel cost between locations u and v. Returns: A list of integers where each integer is the minimum travel cost between the locations given in the corresponding query. Examples: >>> find_minimum_costs(5, [(1, 2, 3), (1, 3, 1), (3, 4, 5), (3, 5, 4)], [(2, 4), (1, 5), (3, 2)]) [9, 5, 4] >>> find_minimum_costs(4, [(1, 2, 2), (2, 3, 3), (3, 4, 4)], [(1, 4), (2, 4)]) [9, 7] pass from solution import find_minimum_costs def test_example_case(): N = 5 Q = 3 roads = [ (1, 2, 3), (1, 3, 1), (3, 4, 5), (3, 5, 4) ] queries = [ (2, 4), (1, 5), (3, 2) ] expected_output = [9, 5, 4] assert find_minimum_costs(N, roads, queries) == expected_output def test_single_path_tree(): N = 4 Q = 2 roads = [ (1, 2, 2), (2, 3, 3), (3, 4, 4) ] queries = [ (1, 4), (2, 4) ] expected_output = [9, 7] assert find_minimum_costs(N, roads, queries) == expected_output def test_same_node(): N = 3 Q = 1 roads = [ (1, 2, 5), (2, 3, 6) ] queries = [ (1, 1) ] expected_output = [0] assert find_minimum_costs(N, roads, queries) == expected_output def test_direct_connections(): N = 3 Q = 1 roads = [ (1, 2, 7), (1, 3, 8) ] queries = [ (2, 3) ] expected_output = [15] assert find_minimum_costs(N, roads, queries) == expected_output","solution":"import heapq from collections import defaultdict import sys def find_minimum_costs(N, roads, queries): graph = defaultdict(list) for u, v, c in roads: graph[u].append((v, c)) graph[v].append((u, c)) def dijkstra(start, end): heap = [(0, start)] visited = set() min_cost = {i: sys.maxsize for i in range(1, N+1)} min_cost[start] = 0 while heap: current_cost, current = heapq.heappop(heap) if current in visited: continue visited.add(current) for neighbor, cost in graph[current]: if neighbor not in visited: new_cost = current_cost + cost if new_cost < min_cost[neighbor]: min_cost[neighbor] = new_cost heapq.heappush(heap, (new_cost, neighbor)) return min_cost[end] results = [] for u, v in queries: results.append(dijkstra(u, v)) return results"},{"question":"def max_subarray_sum_circular(arr: List[int]) -> int: Find the maximum sum of any contiguous subarray, possibly wrapping around. >>> max_subarray_sum_circular([10, -3, -4, 7, 6, 5, -4, -1]) 23 >>> max_subarray_sum_circular([5, -3, 5]) 10","solution":"def max_subarray_sum_circular(arr): def kadane(arr): max_ending_here = max_so_far = arr[0] for i in range(1, len(arr)): max_ending_here = max(arr[i], max_ending_here + arr[i]) max_so_far = max(max_so_far, max_ending_here) return max_so_far max_kadane = kadane(arr) max_wrap = sum(arr) for i in range(len(arr)): arr[i] = -arr[i] max_wrap = max_wrap + kadane(arr) if max_wrap == 0: return max_kadane return max(max_kadane, max_wrap)"},{"question":"def sum_of_digits(numbers): Returns the sum of the digits of the given list of positive integers. The list is terminated by -1, which should not be included in the sum. >>> sum_of_digits([123, 45, 67, 8, -1]) == 36 >>> sum_of_digits([1, 2, 3, 4, -1]) == 10 >>> sum_of_digits([34, 5, 67, -1]) == 25 >>> sum_of_digits([7, 8, 9, -1]) == 24 >>> sum_of_digits([-1]) == 0 >>> sum_of_digits([102, 305, -1]) == 11","solution":"def sum_of_digits(numbers): Returns the sum of the digits of the given list of positive integers. The list is terminated by -1, which should not be included in the sum. total_sum = 0 for number in numbers: if number == -1: break total_sum += sum(int(digit) for digit in str(number)) return total_sum"},{"question":"def count_pairs_with_difference_k(arr, k): Returns the number of distinct pairs (i, j) where i < j and the absolute difference between arr[i] and arr[j] is exactly k. pass # Function to read input data def main(): import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) k = int(data[1]) arr = list(map(int, data[2:])) result = count_pairs_with_difference_k(arr, k) print(result)","solution":"def count_pairs_with_difference_k(arr, k): Returns the number of distinct pairs (i, j) where i < j and the absolute difference between arr[i] and arr[j] is exactly k. count = 0 seen = set() for num in arr: if num + k in seen: count += 1 if num - k in seen: count += 1 seen.add(num) return count # Function to read input data def main(): import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) k = int(data[1]) arr = list(map(int, data[2:])) result = count_pairs_with_difference_k(arr, k) print(result)"},{"question":"def max_water_between_trees(n: int, heights: List[int]) -> int: Find the maximum amount of water that can be trapped between any two trees when it rains. >>> max_water_between_trees(4, [1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> max_water_between_trees(2, [1, 1]) 1","solution":"def max_water_between_trees(n, heights): left, right = 0, n - 1 max_water = 0 while left < right: width = right - left height = min(heights[left], heights[right]) current_water = width * height max_water = max(max_water, current_water) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isCousins(root: TreeNode, x: int, y: int) -> bool: Determine if two nodes in a binary tree are cousins (i.e., at the same level with different parents). :param root: The root node of the binary tree. :param x: The value of the first node. :param y: The value of the second node. :return: True if the nodes are cousins, otherwise False. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.right.right = TreeNode(5) >>> isCousins(root, 4, 5) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> isCousins(root, 4, 5) False >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.left.left = TreeNode(5) >>> isCousins(root, 4, 5) False >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.right.left = TreeNode(5) >>> isCousins(root, 4, 5) True >>> root = TreeNode(1) >>> current = root >>> for i in range(2, 11): ... new_node = TreeNode(i) ... current.right = new_node ... current = new_node >>> root.right.right.right.left = TreeNode(11) >>> root.right.right.right.right = TreeNode(12) >>> isCousins(root, 11, 12) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_depth_and_parent(node, val, depth=0, parent=None): if node is None: return None, None if node.val == val: return depth, parent left_result = find_depth_and_parent(node.left, val, depth + 1, node) if left_result[0] is not None: return left_result right_result = find_depth_and_parent(node.right, val, depth + 1, node) return right_result def isCousins(root: TreeNode, x: int, y: int) -> bool: x_depth, x_parent = find_depth_and_parent(root, x) y_depth, y_parent = find_depth_and_parent(root, y) return (x_depth == y_depth) and (x_parent != y_parent)"},{"question":"def total_leaves_shed(n: int, d: int, tree_data: List[Tuple[int, int]]) -> List[int]: Calculate the total number of leaves shed by each kind of tree over given days. >>> total_leaves_shed(3, 10, [(5, 2), (3, 4), (7, 1)]) [100, 120, 70] >>> total_leaves_shed(1, 5, [(10, 2)]) [100] >>> total_leaves_shed(2, 1, [(2, 3), (5, 4)]) [6, 20] >>> total_leaves_shed(2, 10, [(1, 1), (1, 2)]) [10, 20] >>> total_leaves_shed(2, 1000, [(1000, 1000), (500, 2)]) [1000000000, 1000000]","solution":"def total_leaves_shed(n, d, tree_data): total_leaves = [] for t, l in tree_data: total_leaves.append(t * l * d) return total_leaves"},{"question":"def count_divisibles(n: int, q: int, A: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Returns the count of elements in subarray A[l...r] divisible by x for each query. n: int - length of array A q: int - number of queries A: list[int] - array of integers queries: list[tuple(int, int, int)] - list of queries with (l, r, x) returns list[int] - list of results for each query >>> count_divisibles(5, 3, [2, 3, 4, 9, 6], [(1, 3, 2), (2, 5, 3), (1, 4, 2)]) [2, 3, 2] >>> count_divisibles(4, 1, [5, 10, 15, 20], [(1, 4, 5)]) [4] >>> count_divisibles(4, 1, [1, 2, 3, 4], [(1, 4, 10)]) [0] >>> count_divisibles(1, 1, [100], [(1, 1, 10)]) [1] >>> count_divisibles(1, 1, [100], [(1, 1, 3)]) [0]","solution":"def count_divisibles(n, q, A, queries): Returns the count of elements in subarray A[l...r] divisible by x for each query. n: int - length of array A q: int - number of queries A: list[int] - array of integers queries: list[tuple(int, int, int)] - list of queries with (l, r, x) returns list[int] - list of results for each query results = [] for query in queries: l, r, x = query # Adjusting l and r for 0-based indexing l -= 1 r -= 1 count = 0 for i in range(l, r + 1): if A[i] % x == 0: count += 1 results.append(count) return results"},{"question":"def longestOddSubarray(nums): Returns the length of the longest subarray that contains only odd numbers. Examples: >>> longestOddSubarray([1, 2, 3, 5, 9, 10, 11, 13]) 3 >>> longestOddSubarray([2, 4, 6, 8, 1, 3, 5, 7, 9, 11]) 6 >>> longestOddSubarray([2, 4, 6, 8]) 0","solution":"def longestOddSubarray(nums): Returns the length of the longest subarray that contains only odd numbers. max_length = 0 current_length = 0 for num in nums: if num % 2 != 0: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"def find_kth_smallest(n: int, m: int, list1: List[int], list2: List[int], k: int) -> int: Finds the k-th smallest number in the union of two sorted lists list1 and list2. >>> find_kth_smallest(3, 4, [1, 4, 7], [2, 5, 6, 8], 5) 6 >>> find_kth_smallest(2, 3, [1, 3], [2, 4, 7], 4) 4","solution":"def find_kth_smallest(n, m, list1, list2, k): Finds the k-th smallest number in the union of two sorted lists list1 and list2. combined = [] i = j = 0 # Merge the lists until we reach k elements while len(combined) < k: if i < n and (j >= m or list1[i] <= list2[j]): combined.append(list1[i]) i += 1 else: combined.append(list2[j]) j += 1 return combined[k - 1]"},{"question":"def calculate_silhouette(buildings: List[int]) -> List[int]: Given a list of integers representing the heights of different buildings, returns a list representing the silhouette of the city. >>> calculate_silhouette([3, 0, 2, 4, 3, 0, 1]) == [3, 3, 3, 4, 4, 4, 4] >>> calculate_silhouette([2, 2, 2, 2, 2]) == [2, 2, 2, 2, 2] >>> calculate_silhouette([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] pass # Example test cases assert calculate_silhouette([3, 0, 2, 4, 3, 0, 1]) == [3, 3, 3, 4, 4, 4, 4] assert calculate_silhouette([2, 2, 2, 2, 2]) == [2, 2, 2, 2, 2] assert calculate_silhouette([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert calculate_silhouette([5, 4, 3, 2, 1]) == [5, 5, 5, 5, 5] assert calculate_silhouette([1, 3, 2, 5, 4, 3, 0, 2]) == [1, 3, 3, 5, 5, 5, 5, 5] assert calculate_silhouette([0, 0, 0, 0, 3, 0]) == [0, 0, 0, 0, 3, 3] assert calculate_silhouette([7]) == [7] assert calculate_silhouette([]) == []","solution":"def calculate_silhouette(buildings): Given a list of integers representing the heights of different buildings, returns a list representing the silhouette of the city. if not buildings: return [] silhouette = [0] * len(buildings) max_height = 0 for i in range(len(buildings)): if buildings[i] > max_height: max_height = buildings[i] silhouette[i] = max_height return silhouette"},{"question":"def reverse_string_preserve_spaces(s: str) -> str: Return a new string with characters reversed but spaces in their original positions. >>> reverse_string_preserve_spaces(\\"a b c d e\\") == \\"e d c b a\\" >>> reverse_string_preserve_spaces(\\"ab c d ef\\") == \\"fe d c ba\\" >>> reverse_string_preserve_spaces(\\"abc def\\") == \\"fed cba\\"","solution":"def reverse_string_preserve_spaces(s): Returns the string with characters reversed but spaces in their original positions. # Extract the non-space characters and reverse them chars = [c for c in s if c != ' '] chars.reverse() # Rebuild the string with spaces in their original positions result = [] char_index = 0 for c in s: if c == ' ': result.append(' ') else: result.append(chars[char_index]) char_index += 1 return ''.join(result)"},{"question":"def generate_peak_array(M: int) -> list: Given an integer M, generates an integer array B of length M that satisfies the following conditions: 1. The array B has exactly one peak. 2. Every element of B is an integer from 1 to M (both inclusive). Args: M: int - Length of the array. Returns: list - The array satisfying the above conditions. >>> generate_peak_array(3) [1, 3, 2] >>> generate_peak_array(5) [1, 2, 4, 3, 5] def process_test_cases(test_cases: list) -> list: Processes a list of test cases to generate arrays for each test case. Args: test_cases: list of int - List containing lengths of arrays to be generated. Returns: list of list - List containing arrays for each test case.","solution":"def generate_peak_array(M): Generate an array of length M with exactly one peak. if M == 2: return [1, 2] # Construct a peak in the middle peak_position = M // 2 array = list(range(1, M + 1)) # Swap the peak element to be strictly greater than its neighbors array[peak_position], array[M - 1] = array[M - 1], array[peak_position] return array def process_test_cases(test_cases): results = [] for M in test_cases: results.append(generate_peak_array(M)) return results"},{"question":"def longestGroup(shelves): Determine the length of the longest consecutive group of identical characters in the shelves. >>> longestGroup([\\"aaabb\\", \\"bbaaaacc\\", \\"ccbaa\\"]) 4 >>> longestGroup([\\"ab\\", \\"bc\\", \\"ca\\"]) 1 def test_longestGroup(): assert longestGroup([\\"aaabb\\", \\"bbaaaacc\\", \\"ccbaa\\"]) == 4 assert longestGroup([\\"ab\\", \\"bc\\", \\"ca\\"]) == 1 assert longestGroup([\\"a\\", \\"b\\", \\"c\\"]) == 1 assert longestGroup([\\"aaaa\\", \\"bbbb\\", \\"cccc\\"]) == 4 assert longestGroup([\\"ababab\\", \\"bbb\\", \\"cccccc\\"]) == 6 assert longestGroup([\\"aabbcc\\", \\"ddeeff\\", \\"gghhiijj\\"]) == 2 assert longestGroup([\\"\\"]) == 0 assert longestGroup([\\"aa\\", \\"aaa\\", \\"aaaa\\"]) == 4 assert longestGroup([\\"xyz\\", \\"yyz\\", \\"zzzzzz\\"]) == 6 test_longestGroup()","solution":"def longestGroup(shelves): Determines the length of the longest consecutive group of identical characters in the shelves. max_length = 0 for shelf in shelves: current_char = '' current_length = 0 for char in shelf: if char == current_char: current_length += 1 else: current_char = char current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"from typing import List def solve_longest_palindromic_subsequences(t: int, strings: List[str]) -> List[int]: Given the number of test cases t and a list of strings, return a list with the length of the longest palindromic subsequence for each string. >>> solve_longest_palindromic_subsequences(3, [\\"bbbab\\", \\"cbbd\\", \\"aabcdcb\\"]) [4, 2, 5] >>> solve_longest_palindromic_subsequences(3, [\\"a\\", \\"b\\", \\"c\\"]) [1, 1, 1] >>> solve_longest_palindromic_subsequences(2, [\\"aaaaaa\\", \\"bbbbbbb\\"]) [6, 7] >>> solve_longest_palindromic_subsequences(2, [\\"abcd\\", \\"efgh\\"]) [1, 1] >>> solve_longest_palindromic_subsequences(1, [\\"character\\"]) [5] >>> solve_longest_palindromic_subsequences(1, [\\"a\\" * 1000]) [1000]","solution":"def longest_palindromic_subsequence(s): Returns the length of the longest palindromic subsequence in a given string s. n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1] def solve_longest_palindromic_subsequences(t, strings): Returns a list of lengths of the longest palindromic subsequences for each of the t strings. results = [] for s in strings: results.append(longest_palindromic_subsequence(s)) return results"},{"question":"def tower_of_hanoi(n: int, start_rod: int = 1, end_rod: int = 3, aux_rod: int = 2, moves: list = None) -> list: Solves the Tower of Hanoi puzzle and returns the sequence of moves. :param n: Number of disks :param start_rod: The starting rod number :param end_rod: The target rod number :param aux_rod: The auxiliary rod number :param moves: List to store moves :return: List of moves (each move is a tuple (start_rod, end_rod)) >>> tower_of_hanoi(1) [(1, 3)] >>> tower_of_hanoi(2) [(1, 2), (1, 3), (2, 3)] >>> tower_of_hanoi(3) [(1, 3), (1, 2), (3, 2), (1, 3), (2, 1), (2, 3), (1, 3)]","solution":"def tower_of_hanoi(n, start_rod=1, end_rod=3, aux_rod=2, moves=None): Solves the Tower of Hanoi puzzle and returns the sequence of moves. :param n: Number of disks :param start_rod: The starting rod number :param end_rod: The target rod number :param aux_rod: The auxiliary rod number :param moves: List to store moves :return: List of moves (each move is a tuple (start_rod, end_rod)) if moves is None: moves = [] if n == 1: moves.append((start_rod, end_rod)) else: tower_of_hanoi(n-1, start_rod, aux_rod, end_rod, moves) moves.append((start_rod, end_rod)) tower_of_hanoi(n-1, aux_rod, end_rod, start_rod, moves) return moves"},{"question":"def palindromeIndex(s: str) -> int: Given a string of lowercase letters, determine the index of a character that can be removed to make the string a palindrome. If the string is already a palindrome, return \`-1\`. If there is more than one valid answer, return the smallest index. Args: s (str): a string to analyze Returns: int: the index of the character to remove or \`-1\` if the string is already a palindrome >>> palindromeIndex(\\"aaab\\") 3 >>> palindromeIndex(\\"baa\\") 0 >>> palindromeIndex(\\"aaa\\") -1","solution":"def is_palindrome(s): return s == s[::-1] def palindromeIndex(s): if is_palindrome(s): return -1 start, end = 0, len(s) - 1 while start < end: if s[start] != s[end]: if is_palindrome(s[start+1:end+1]): return start elif is_palindrome(s[start:end]): return end else: return -1 start += 1 end -= 1 return -1"},{"question":"from math import factorial from typing import List, Tuple def unique_string_permutations(S: str) -> int: Calculate the number of unique permutations of the string S with all distinct characters. pass def number_of_unique_strings(T: int, strings: List[str]) -> List[int]: Given a number of test cases and a list of strings, calculate the number of unique strings that can be formed by rearranging the characters of each string. Args: T (int): Number of test cases strings (List[str]): List of input strings Returns: List[int]: List of integers representing the number of unique strings that can be formed for each input string >>> number_of_unique_strings(2, [\\"abc\\", \\"aabb\\"]) [6, 2] >>> number_of_unique_strings(1, [\\"abcdefg\\"]) [5040] pass # Unit tests def test_single_unique_string(): assert number_of_unique_strings(1, [\\"abc\\"]) == [6] def test_repeated_characters_string(): assert number_of_unique_strings(1, [\\"aabb\\"]) == [2] def test_mix_cases(): assert number_of_unique_strings(2, [\\"abc\\", \\"aabb\\"]) == [6, 2] def test_minimum_length_string(): assert number_of_unique_strings(1, [\\"a\\"]) == [1] def test_all_unique(): assert number_of_unique_strings(1, [\\"abcdefg\\"]) == [5040] def test_same_character(): assert number_of_unique_strings(1, [\\"aaaa\\"]) == [1] def test_combined(): assert number_of_unique_strings(3, [\\"abcd\\", \\"aabb\\", \\"aaaa\\"]) == [24, 2, 1]","solution":"from math import factorial def unique_string_permutations(S): Calculate the number of unique permutations of the string S with all distinct characters. unique_chars = set(S) n = len(unique_chars) return factorial(n) def number_of_unique_strings(T, strings): results = [] for S in strings: results.append(unique_string_permutations(S)) return results"},{"question":"def count_ways(N: int, K: int) -> int: Returns the number of ways to plant K saplings of N different types such that no two consecutive saplings are of the same type. >>> count_ways(2, 3) 2 >>> count_ways(3, 2) 6 >>> count_ways(4, 1) 4 def process_input(test_cases: list) -> list: Process multiple test cases and return the result for each case. >>> process_input([(2, 3), (3, 2), (4, 1)]) [2, 6, 4]","solution":"def count_ways(N, K): Returns the number of ways to plant K saplings of N different types such that no two consecutive saplings are of the same type. if K == 1: return N # dp[i][j] will store the number of ways to plant i saplings ending with sapling type j dp = [[0] * N for _ in range(K)] # Initialize for the first sapling for j in range(N): dp[0][j] = 1 for i in range(1, K): for j in range(N): dp[i][j] = sum(dp[i-1][k] for k in range(N) if k != j) return sum(dp[K-1]) def process_input(test_cases): results = [] for N, K in test_cases: results.append(count_ways(N, K)) return results"},{"question":"from typing import List def find_pairs(numbers: List[int], target: int) -> List[List[int]]: Finds all unique pairs of elements (a, b) such that their sum is equal to a given target number. The pairs (a, b) and (b, a) are considered the same and should only be counted once. The output list of pairs should be sorted in non-decreasing order based on the first element of each pair. If no such pairs exist, return an empty list. >>> find_pairs([1, 5, 3, 2, 4, 5, -1, 0], 4) [[-1, 5], [0, 4], [1, 3]] >>> find_pairs([1, 2, 3], 10) [] >>> find_pairs([1, 2, 2, 3, 4], 6) [[2, 4]] >>> find_pairs([-2, -1, 0, 1, 2, 3, 4], 2) [[-2, 4], [-1, 3], [0, 2]] >>> find_pairs([0, 0, 0, 0], 0) [[0, 0]] >>> find_pairs([], 5) [] pass","solution":"from typing import List def find_pairs(numbers: List[int], target: int) -> List[List[int]]: Finds all unique pairs of elements (a, b) such that their sum is equal to a given target number. found_pairs = set() seen = set() for number in numbers: complement = target - number if complement in seen: found_pairs.add(tuple(sorted((number, complement)))) seen.add(number) unique_pairs = [list(pair) for pair in sorted(found_pairs)] return unique_pairs"},{"question":"from typing import List, Tuple def max_sunlight_per_building(building_heights: List[int]) -> int: Given a list of building heights, return the maximum amount of sunlight received by any building. >>> max_sunlight_per_building([10, 4, 8, 3, 6]) 10 >>> max_sunlight_per_building([7, 6, 5, 8]) 8 def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Process each test case and return an array of results. >>> process_test_cases([(5, [10, 4, 8, 3, 6]), (4, [7, 6, 5, 8])]) [10, 8] >>> process_test_cases([(3, [1, 2, 3]), (3, [3, 2, 1])]) [3, 3]","solution":"def max_sunlight_per_building(building_heights): Given a list of building heights, return the maximum amount of sunlight received by any building. max_sunlight = 0 max_height_so_far = 0 for height in building_heights: sunlight = height if height > max_height_so_far else 0 max_sunlight = max(max_sunlight, sunlight) max_height_so_far = max(max_height_so_far, height) return max_sunlight def process_test_cases(test_cases): Process each test case and return an array of results. results = [] for case in test_cases: N, buildings = case result = max_sunlight_per_building(buildings) results.append(result) return results"},{"question":"def array_queries(n: int, array: List[int], q: int, queries: List[int]) -> List[str]: Answers queries to determine whether each query element is present in the array. n : int - Size of the array array: List[int] - The array of integers q : int - The number of queries queries: List[int] - The queried integers Returns a list of strings, either \\"Yes\\" or \\"No\\" for each query. >>> array_queries(5, [1, 2, 3, 4, 5], 3, [3, 6, 1]) ['Yes', 'No', 'Yes'] >>> array_queries(1, [10], 1, [10]) ['Yes'] >>> array_queries(1, [10], 1, [5]) ['No'] >>> array_queries(1, [10], 3, [10, 10, 10]) ['Yes', 'Yes', 'Yes'] >>> array_queries(3, [1, 2, 3], 0, []) [] >>> array_queries(0, [], 3, [1, 2, 3]) ['No', 'No', 'No'] >>> array_queries(5, [1, 1, 2, 2, 3], 3, [1, 2, 3]) ['Yes', 'Yes', 'Yes'] >>> array_queries(5, [1, 1, 2, 2, 3], 2, [4, 5]) ['No', 'No']","solution":"def array_queries(n, array, q, queries): Answers queries to determine whether each query element is present in the array. n: int - Size of the array array: list of int - The array of integers q: int - The number of queries queries: list of int - The queried integers Returns a list of strings, either \\"Yes\\" or \\"No\\" for each query. array_set = set(array) results = [] for query in queries: if query in array_set: results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def min_subarray_len(A, K): Finds the length of the shortest subarray whose sum is greater than or equal to K. Parameters: A (list of int): The array of integers. K (int): The target sum. Returns: int: The length of the shortest subarray with sum >= K, or -1 if no such subarray exists. >>> min_subarray_len([1, 2, 3, 4, 5], 11) 3 >>> min_subarray_len([1, 1, 1, 1, 1], 10) -1 >>> min_subarray_len([10, 5, 2], 10) 1 >>> min_subarray_len([1, 2, 3, 10], 10) 1 >>> min_subarray_len([2, 1, 3, 2, 4], 12) 5 >>> min_subarray_len([5, 1, 3, 5, 10, 7, 4, 9, 2, 8], 15) 2 >>> min_subarray_len([1, 100000, 100000], 100000) 1 >>> min_subarray_len([1, 2, 100000, 1, 1], 100001) 2 >>> min_subarray_len([-1, -2, -3, -4, -5], 1) -1 >>> min_subarray_len([-1, 2, 4, -1, 5, 6], 10) 2 >>> min_subarray_len([-1, 2, 4, -1, 5, -6, 20], 10) 1","solution":"def min_subarray_len(A, K): Finds the length of the shortest subarray whose sum is greater than or equal to K. Parameters: A (list of int): The array of integers. K (int): The target sum. Returns: int: The length of the shortest subarray with sum >= K, or -1 if no such subarray exists. N = len(A) min_length = N + 1 current_sum = 0 start = 0 for end in range(N): current_sum += A[end] while current_sum >= K: min_length = min(min_length, end - start + 1) current_sum -= A[start] start += 1 return min_length if min_length <= N else -1"},{"question":"def is_arithmetic_mean_integer(N: int, A: List[int]) -> str: Determine if the arithmetic mean of the list of integers is an integer. >>> is_arithmetic_mean_integer(4, [2, 8, 4, 6]) \\"yes\\" >>> is_arithmetic_mean_integer(3, [1, 2, 4]) \\"no\\"","solution":"def is_arithmetic_mean_integer(N, A): Determine if the arithmetic mean of the list of integers is an integer. Parameters: N (int): The number of integers in the list A (list): The list of integers Returns: str: \\"yes\\" if the arithmetic mean is an integer, otherwise \\"no\\" total_sum = sum(A) mean = total_sum / N return \\"yes\\" if mean.is_integer() else \\"no\\""},{"question":"def detect_repetitive_trips(t: int, test_cases: List[Tuple[int, List[Tuple[str, List[str]]]]]) -> List[List[str]]: Identify spacecraft that have made repetitive trips to the same set of planets. Parameters: t (int): Number of test cases. test_cases (list): List of test cases. Each test case is a tuple with the number of travel logs and a list of travel log entries (each entry is a tuple of spacecraft name and list of visited planets). Returns: list: List of results for each test case. Each result is a list of spacecraft with repetitive trips, sorted lexicographically, or [\\"No repetitive trips\\"] if there are no repetitive trips. pass # Unit Test import pytest def test_single_case_no_repeat(): assert detect_repetitive_trips(1, [(3, [(\\"Apollo\\", [\\"Moon\\", \\"Mars\\"]), (\\"Challenger\\", [\\"Venus\\"]), (\\"Hubble\\", [\\"Jupiter\\", \\"Saturn\\"])])]) == [[\\"No repetitive trips\\"]] def test_single_case_with_repeats(): assert detect_repetitive_trips(1, [(5, [(\\"Explorer1\\", [\\"Mars\\", \\"Venus\\"]), (\\"Voyager1\\", [\\"Jupiter\\", \\"Saturn\\"]), (\\"Explorer1\\", [\\"Venus\\", \\"Mars\\"]), (\\"Endeavor1\\", [\\"Earth\\", \\"Mars\\"]), (\\"Explorer1\\", [\\"Mars\\", \\"Mars\\"])])]) == [[\\"Explorer1\\"]] def test_multiple_cases(): assert detect_repetitive_trips(2, [(5, [(\\"Explorer1\\", [\\"Mars\\", \\"Venus\\"]), (\\"Voyager1\\", [\\"Jupiter\\", \\"Saturn\\"]), (\\"Explorer1\\", [\\"Venus\\", \\"Mars\\"]), (\\"Endeavor1\\", [\\"Earth\\", \\"Mars\\"]), (\\"Explorer1\\", [\\"Mars\\", \\"Mars\\"])]), (4, [(\\"Falcon1\\", [\\"Mercury\\", \\"Venus\\"]), (\\"Voyager2\\", [\\"Pluto\\", \\"Neptune\\"]), (\\"Falcon2\\", [\\"Jupiter\\", \\"Venus\\"]), (\\"Voyager2\\", [\\"Neptune\\", \\"Pluto\\"])])]) == [[\\"Explorer1\\"], [\\"Voyager2\\"]] def test_no_repeat(): assert detect_repetitive_trips(2, [(3, [(\\"SpacecraftA\\", [\\"Earth\\", \\"Mars\\"]), (\\"SpacecraftB\\", [\\"Mars\\", \\"Jupiter\\"]), (\\"SpacecraftC\\", [\\"Venus\\", \\"Mercury\\"])]), (4, [(\\"Delta\\", [\\"Earth\\", \\"Venus\\"]), (\\"Gamma\\", [\\"Neptune\\", \\"Uranus\\"]), (\\"Beta\\", [\\"Mars\\", \\"Jupiter\\"]), (\\"Alpha\\", [\\"Saturn\\"])] )]) == [[\\"No repetitive trips\\"], [\\"No repetitive trips\\"]] def test_with_empty_logs(): assert detect_repetitive_trips(1, [(0, [])]) == [[\\"No repetitive trips\\"]] pytest.main()","solution":"def detect_repetitive_trips(t, test_cases): Identify spacecraft that have made repetitive trips to the same set of planets. Parameters: t (int): Number of test cases. test_cases (list): List of test cases. Each test case is a tuple with the number of travel logs and a list of travel log entries (each entry is a tuple of spacecraft name and list of visited planets). Returns: list: List of results for each test case. Each result is a list of spacecraft with repetitive trips, sorted lexicographically, or [\\"No repetitive trips\\"] if there are no repetitive trips. results = [] for n, logs in test_cases: trip_dict = {} for spacecraft, planets in logs: planet_set = frozenset(planets) # Create an immutable set of planets for comparison if spacecraft not in trip_dict: trip_dict[spacecraft] = set() if planet_set in trip_dict[spacecraft]: trip_dict[spacecraft].add(\\"REPEATED\\") else: trip_dict[spacecraft].add(planet_set) repeated_spacecraft = sorted([sp for sp in trip_dict if \\"REPEATED\\" in trip_dict[sp]]) if repeated_spacecraft: results.append(repeated_spacecraft) else: results.append([\\"No repetitive trips\\"]) return results"},{"question":"import math def lcm(a, b): return abs(a * b) // math.gcd(a, b) def smallest_common_multiple(a: int, b: int, c: int, x: int) -> int: Determine the smallest common multiple of three given numbers greater than a specified number x. The common multiple must be divisible by all three numbers. >>> smallest_common_multiple(4, 5, 6, 10) 60 >>> smallest_common_multiple(3, 7, 9, 20) 63 >>> smallest_common_multiple(2, 3, 5, 50) 60 >>> smallest_common_multiple(6, 8, 12, 100) 120","solution":"import math def lcm(a, b): return abs(a * b) // math.gcd(a, b) def smallest_common_multiple(a, b, c, x): multiple = lcm(lcm(a, b), c) if x % multiple == 0: return x + multiple else: return ((x // multiple) + 1) * multiple"},{"question":"def unique_union(arr1, arr2): Write a function that takes two arrays as inputs and returns a new array containing the unique elements that exist in either of the input arrays. The returned array should not contain any duplicate values and should be sorted in ascending order. Args: arr1: List of elements (integers, floats, strings). arr2: List of elements (integers, floats, strings). Returns: A sorted list of unique elements. Examples: >>> unique_union([1, 3, 2, 4], [3, 5, 6, 4]) [1, 2, 3, 4, 5, 6] >>> unique_union([8, 9, 7], [7, 6, 5]) [5, 6, 7, 8, 9]","solution":"def unique_union(arr1, arr2): Returns a sorted list of unique elements present in either arr1 or arr2. # Use a set to automatically handle uniqueness unique_elements = set(arr1).union(set(arr2)) # Convert the set back to a list and sort it return sorted(list(unique_elements))"},{"question":"def reverse_words(s: str) -> str: Reverses each word in the string s but maintains the order of the words. Parameters: s (str): Input string Returns: str: New string with each word reversed Examples: >>> reverse_words(\\"hello world\\") 'olleh dlrow' >>> reverse_words(\\"this is a test\\") 'siht si a tset'","solution":"def reverse_words(s: str) -> str: Reverses each word in the string s but maintains the order of the words. Parameters: s (str): Input string Returns: str: New string with each word reversed return ' '.join(word[::-1] for word in s.split())"},{"question":"def has_improving_subsequence(run_durations): Returns True if there exists a subsequence of four consecutive runs where each subsequent run is faster than the previous one, otherwise returns False. >>> has_improving_subsequence([45, 42, 39, 37, 36, 30, 29, 28]) == True >>> has_improving_subsequence([45, 48, 50, 41, 46, 50, 38, 37]) == False","solution":"def has_improving_subsequence(run_durations): Returns True if there exists a subsequence of four consecutive runs where each subsequent run is faster than the previous one, otherwise returns False. if len(run_durations) < 4: return False for i in range(len(run_durations) - 3): if (run_durations[i] > run_durations[i + 1] > run_durations[i + 2] > run_durations[i + 3]): return True return False"},{"question":"def longestDistinctSubstring(S: str) -> int: Returns the length of the longest substring with all distinct characters. >>> longestDistinctSubstring(\\"abcabcbb\\") 3 >>> longestDistinctSubstring(\\"bbbbb\\") 1 >>> longestDistinctSubstring(\\"pwwkew\\") 3","solution":"def longestDistinctSubstring(S): Returns the length of the longest substring with all distinct characters. n = len(S) max_len = 0 start = 0 char_index = {} for i in range(n): if S[i] in char_index and char_index[S[i]] >= start: start = char_index[S[i]] + 1 char_index[S[i]] = i max_len = max(max_len, i - start + 1) return max_len"},{"question":"def final_coordinates(n, x, y, moves): Returns the final coordinates of the robot after performing a series of moves. Args: n (int): Size of the grid (n x n) x (int): Initial x-coordinate of the robot y (int): Initial y-coordinate of the robot moves (str): String representing the sequence of moves Returns: tuple: Final coordinates of the robot (x, y) Example: >>> final_coordinates(5, 2, 2, \\"RRUULLDD\\") (2, 2) >>> final_coordinates(3, 1, 1, \\"RRDDD\\") (2, 2)","solution":"def final_coordinates(n, x, y, moves): Returns the final coordinates of the robot after performing a series of moves. Args: n (int): Size of the grid (n x n) x (int): Initial x-coordinate of the robot y (int): Initial y-coordinate of the robot moves (str): String representing the sequence of moves Returns: tuple: Final coordinates of the robot (x, y) for move in moves: if move == 'R' and y < n - 1: y += 1 elif move == 'L' and y > 0: y -= 1 elif move == 'U' and x > 0: x -= 1 elif move == 'D' and x < n - 1: x += 1 return (x, y)"},{"question":"def min_difference(n: int, sizes: List[int]) -> int: Determine the minimum possible absolute difference between the sum of sizes in the two groups. >>> min_difference(3, [2, 3, 5]) 0 >>> min_difference(5, [1, 2, 3, 4, 5]) 1","solution":"def min_difference(n, sizes): total_sum = sum(sizes) half_sum = total_sum // 2 dp = [[False] * (half_sum + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, half_sum + 1): dp[i][j] = dp[i-1][j] if sizes[i-1] <= j: dp[i][j] = dp[i][j] or dp[i-1][j-sizes[i-1]] for j in range(half_sum, -1, -1): if dp[n][j]: return abs(total_sum - 2 * j)"},{"question":"def min_operations_to_balance(t: int, test_cases: List[str]) -> List[int]: Returns a list of integers where each integer represents the minimum number of operations required to make the binary string contain an equal number of '0's and '1's for each test case. >>> min_operations_to_balance(4, [\\"1101\\", \\"101010\\", \\"111000\\", \\"0000\\"]) [1, 0, 0, 2] >>> min_operations_to_balance(3, [\\"0\\", \\"1\\", \\"01\\"]) [0, 0, 0] >>> min_operations_to_balance(2, [\\"1111\\", \\"000\\"]) [2, 1] >>> min_operations_to_balance(1, [\\"010101010101\\"]) [0] >>> min_operations_to_balance(1, [\\"111000111000111\\"]) [1]","solution":"def min_operations_to_balance(t, test_cases): Returns a list of integers where each integer represents the minimum number of operations required to make the binary string contain an equal number of '0's and '1's for each test case. results = [] for s in test_cases: count_0 = s.count('0') count_1 = s.count('1') min_operations = abs(count_0 - count_1) // 2 results.append(min_operations) return results"},{"question":"def isLucasNumber(n) -> str: Checks if a given number n is a Lucas number. >>> isLucasNumber(3) == \\"True\\" >>> isLucasNumber(5) == \\"False\\" >>> isLucasNumber(7) == \\"True\\" >>> isLucasNumber(10) == \\"False\\"","solution":"def isLucasNumber(n): Checks if a given number n is a Lucas number. if n == 2 or n == 1: return \\"True\\" a, b = 2, 1 while b < n: a, b = b, a + b return \\"True\\" if b == n else \\"False\\""},{"question":"def length_of_lis(nums: List[int]) -> int: Finds the length of the longest increasing subsequence in the given list of integers. >>> length_of_lis([10, 22, 9, 33, 21, 50]) 4 >>> length_of_lis([3, 10, 2, 1, 20]) 3 >>> length_of_lis([10]) 1 >>> length_of_lis([2, 2, 2, 2, 2]) 1 >>> length_of_lis([1, 2, 3, 4, 5]) 5 >>> length_of_lis([5, 4, 3, 2, 1]) 1 >>> length_of_lis([]) 0 >>> length_of_lis([10, 11, 12, 7, 8, 9, 10, 11, 12]) 6","solution":"def length_of_lis(nums): Returns the length of the longest increasing subsequence in the list nums. if not nums: return 0 n = len(nums) dp = [1] * n for i in range(1, n): for j in range(0, i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def min_removals_to_palindrome(s: str) -> int: Determine the minimum number of operations required to convert the string into a palindrome. >>> min_removals_to_palindrome(\\"abca\\") 1 >>> min_removals_to_palindrome(\\"racecar\\") 0 >>> min_removals_to_palindrome(\\"abcdef\\") 5 pass","solution":"def min_removals_to_palindrome(s: str) -> int: Determine the minimum number of operations required to convert the string into a palindrome. n = len(s) # Function to find the length of the longest palindromic subsequence def longest_palindromic_subsequence(seq): # Create a table to store results of subproblems dp = [[0 for x in range(n)] for y in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n+1): for i in range(n - cl + 1): j = i + cl - 1 if seq[i] == seq[j] and cl == 2: dp[i][j] = 2 elif seq[i] == seq[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1] # Length of string len_of_s = len(s) # Length of longest palindromic subsequence in s length_of_lps = longest_palindromic_subsequence(s) # Minimum number of removals is difference of length of string and length of LPS return len_of_s - length_of_lps"},{"question":"import math def isPerfectSquare(N): Determines if N is a perfect square. Args: N (int): A positive integer. Returns: int: 1 if N is a perfect square, 0 otherwise. Examples: >>> isPerfectSquare(16) 1 >>> isPerfectSquare(20) 0","solution":"import math def isPerfectSquare(N): Determines if N is a perfect square. Args: N (int): A positive integer. Returns: int: 1 if N is a perfect square, 0 otherwise. if N < 1: return 0 sqrt_N = int(math.isqrt(N)) return 1 if sqrt_N * sqrt_N == N else 0"},{"question":"def max_tasks(N, K, M, durations): Determines the maximum number of tasks that can be processed simultaneously without exceeding the time limit M. Parameters: N : int : the number of tasks K : int : the maximum number of tasks that can be processed simultaneously M : int : the maximum total duration of tasks that can be processed simultaneously durations : List[int] : the duration of each task Returns: int : the maximum number of tasks that can be processed simultaneously without exceeding the time limit Example: >>> max_tasks(5, 3, 50, [10, 20, 30, 40, 50]) 2 >>> max_tasks(5, 3, 5, [10, 20, 30, 40, 50]) 0 >>> max_tasks(1, 1, 1, [1]) 1","solution":"def max_tasks(N, K, M, durations): Determines the maximum number of tasks that can be processed simultaneously without exceeding the time limit M. durations.sort() max_count = 0 for i in range(min(K, N)): if sum(durations[:i + 1]) <= M: max_count = i + 1 else: break return max_count"},{"question":"def max_consecutive_train_duration(durations: List[int]) -> int: Returns the maximum sum of consecutive train durations. >>> max_consecutive_train_duration([2, 1, 3, 5, 2, 2]) 15 >>> max_consecutive_train_duration([7, 3, 9, 2]) 21","solution":"def max_consecutive_train_duration(durations): Returns the maximum sum of consecutive train durations. # Since there is no gap, the entire array is the longest consecutive train duration return sum(durations)"},{"question":"from typing import List, Tuple def find_max_step_size(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the maximum step size that can divide all soldiers' heights perfectly. >>> find_max_step_size(2, [(3, [15, 25, 35]), (4, [2, 4, 6, 8])]) [5, 2]","solution":"from math import gcd from functools import reduce def find_max_step_size(T, test_cases): def find_gcd_of_list(lst): Helper function to find the GCD of a list of numbers return reduce(gcd, lst) results = [] for i in range(T): N = test_cases[i][0] heights = test_cases[i][1] step_size = find_gcd_of_list(heights) results.append(step_size) return results # Example usage: T = 2 test_cases = [ (3, [15, 25, 35]), (4, [2, 4, 6, 8]) ] print(find_max_step_size(T, test_cases)) # Output: [5, 2]"},{"question":"def MaxDepth(root): Returns the maximum depth of a binary tree. >>> test_max_depth_empty_tree() >>> test_max_depth_single_node() >>> test_max_depth_balanced_tree() >>> test_max_depth_unbalanced_left() >>> test_max_depth_unbalanced_right() >>> test_max_depth_full_tree() >>> test_max_depth_complex_tree() pass # Your code here","solution":"def MaxDepth(root): Returns the maximum depth of a binary tree. if not root: return 0 left_depth = MaxDepth(root.left) right_depth = MaxDepth(root.right) return max(left_depth, right_depth) + 1"},{"question":"def determine_winner(n: int, array: List[int]) -> str: Determine the winner of the game based on the sum of the array's elements. Args: n (int): Number of elements in the array. array (list of int): The initial array of integers. Returns: str: \\"Alice\\" if the sum is odd, otherwise \\"Bob\\". Examples: >>> determine_winner(3, [3, 6, 2]) 'Alice' >>> determine_winner(4, [1, 1, 1, 1]) 'Bob' >>> determine_winner(5, [2, 2, 3, 1, 5]) 'Alice'","solution":"def determine_winner(n, array): Determines the winner of the game based on the sum of the array's elements. Args: n (int): Number of elements in the array. array (list of int): The initial array of integers. Returns: str: \\"Alice\\" if the sum is odd, otherwise \\"Bob\\". total_sum = sum(array) if total_sum % 2 == 1: return \\"Alice\\" else: return \\"Bob\\""},{"question":"def reverse_words_in_string(s: str) -> str: Reverse characters in each word of the string while maintaining word order and spaces. Args: s (str): Input string containing words separated by spaces. Returns: str: String with each word's characters reversed. >>> reverse_words_in_string(\\"The quick brown fox jumps over the lazy dog\\") == \\"ehT kciuq nworb xof spmuj revo eht yzal god\\" >>> reverse_words_in_string(\\"Hello World\\") == \\"olleH dlroW\\"","solution":"def reverse_words_in_string(s): Reverse characters in each word of the string while maintaining word order and spaces. Args: s (str): Input string containing words separated by spaces. Returns: str: String with each word's characters reversed. return ' '.join(word[::-1] for word in s.split())"},{"question":"def count_ways_to_divide_candies(n: int, candies: List[int]) -> int: Calculate and return the number of ways to divide the candies into one or more contiguous segments, such that the concatenation of the types across all segments results in the original array. :param n: int - number of unique types of candies :param candies: list of int - unique integers representing types of candies :return: int - number of valid ways to divide candies into contiguous segments >>> count_ways_to_divide_candies(4, [1, 2, 3, 4]) 8 >>> count_ways_to_divide_candies(3, [2, 1, 3]) 4 >>> count_ways_to_divide_candies(1, [1]) 1 >>> count_ways_to_divide_candies(5, [5, 3, 2, 4, 1]) 16 >>> count_ways_to_divide_candies(2, [2, 1]) 2 >>> count_ways_to_divide_candies(4, [4, 3, 2, 1]) 8","solution":"def count_ways_to_divide_candies(n, candies): Returns the number of ways to divide candies into contiguous segments. :param n: int - number of unique types of candies :param candies: list of int - unique integers representing types of candies :return: int - number of ways to divide candies into contiguous segments # Inspired by the number of subsequences problem. def is_contiguous_segment(arr): Checks if an array is a contiguous segment. return all(arr[i] + 1 == arr[i + 1] for i in range(len(arr) - 1)) # Subtracting 1 because a single segment covering the whole array is not allowed, # which is essentially \`2**(n-1)\` combinations representing each possible segment. return 2**(n-1)"},{"question":"def reverse_number(n: int) -> int: Returns the reverse of the given number n. >>> reverse_number(123) == 321 >>> reverse_number(1200) == 21 >>> reverse_number(1) == 1 def is_palindrome(n: int) -> bool: Checks if the given number n is a palindrome. >>> is_palindrome(121) == True >>> is_palindrome(123) == False >>> is_palindrome(1) == True >>> is_palindrome(0) == True def steps_to_palindrome(n: int) -> int: Determines the number of steps required to reach a palindrome. >>> steps_to_palindrome(56) == 1 >>> steps_to_palindrome(87) == 4 >>> steps_to_palindrome(1) == 0 >>> steps_to_palindrome(11) == 0 >>> steps_to_palindrome(123) == 1 # 123 + 321 = 444 (palindrome) >>> steps_to_palindrome(1000) == 1 # 1000 + 1 = 1001 (palindrome)","solution":"def reverse_number(n): Returns the reverse of the given number n. return int(str(n)[::-1]) def is_palindrome(n): Checks if the given number n is a palindrome. s = str(n) return s == s[::-1] def steps_to_palindrome(n): Determines the number of steps required to reach a palindrome. steps = 0 while not is_palindrome(n): reverse_n = reverse_number(n) n = n + reverse_n steps += 1 return steps"},{"question":"def is_reachable(n: int, m: int, roads: List[Tuple[int, int]], q: int, queries: List[Tuple[int, int]]) -> List[str]: Determine if it is possible to travel between pairs of cities using the given roads. Parameters: n (int): The number of cities. m (int): The number of roads. roads (List[Tuple[int, int]]): A list of tuples, each containing two integers representing a road between city u and city v. q (int): The number of queries. queries (List[Tuple[int, int]]): A list of tuples, each containing two integers representing the cities to check for possible travel. Returns: List[str]: A list of \\"YES\\" or \\"NO\\" corresponding to each query. Examples: >>> is_reachable(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)], 3, [(1, 5), (2, 4), (1, 3)]) ['YES', 'YES', 'YES'] >>> is_reachable(6, 4, [(1, 2), (2, 3), (4, 5), (5, 6)], 2, [(1, 4), (3, 6)]) ['NO', 'NO'] import pytest def test_is_reachable(): assert is_reachable(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)], 3, [(1, 5), (2, 4), (1, 3)]) == [\\"YES\\", \\"YES\\", \\"YES\\"] assert is_reachable(6, 4, [(1, 2), (2, 3), (4, 5), (5, 6)], 2, [(1, 4), (3, 6)]) == [\\"NO\\", \\"NO\\"] assert is_reachable(1, 0, [], 1, [(1, 1)]) == [\\"YES\\"] assert is_reachable(4, 2, [(1, 2), (3, 4)], 2, [(1, 3), (2, 4)]) == [\\"NO\\", \\"NO\\"] assert is_reachable(3, 2, [(1, 2), (2, 3)], 2, [(1, 3), (3, 1)]) == [\\"YES\\", \\"YES\\"] assert is_reachable(4, 3, [(1, 2), (2, 3), (3, 4)], 0, []) == []","solution":"def is_reachable(n, m, roads, q, queries): from collections import defaultdict, deque # Build the graph graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) results = [] def bfs(start, goal): # Breadth First Search (BFS) to find if there is a path from start to goal visited = set() queue = deque([start]) while queue: node = queue.popleft() if node == goal: return True if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return False for a, b in queries: if bfs(a, b): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def CheckAscendingOrder(arr: List[int]) -> bool: Returns True if every integer in the array is strictly greater than the previous integer. >>> CheckAscendingOrder([1, 2, 3, 4, 5]) True >>> CheckAscendingOrder([1, 2, 2, 4, 5]) False >>> CheckAscendingOrder([5, 4, 3, 2, 1]) False","solution":"def CheckAscendingOrder(arr): Returns True if every integer in the array is strictly greater than the previous integer. :param arr: List of integers :return: Boolean for i in range(len(arr) - 1): if arr[i] >= arr[i+1]: return False return True"},{"question":"def process_queries(N: int, values: List[int], edges: List[Tuple[int, int]], queries: List[Tuple[int, int, Optional[int]]]) -> List[int]: Process the updates and queries on a binary tree. :param N: Number of nodes in the tree. :param values: Initial values of the nodes. :param edges: Edges denoting the connections between nodes. :param queries: List of queries where each query is either an update or a maximum value request. :return: List of results for the maximum value queries. pass # Below are sample test cases to validate the function import pytest def test_sample_input_1(): N = 5 values = [1, 2, 3, 4, 5] edges = [(1, 2), (1, 3), (3, 4), (3, 5)] queries = [(2, 3), (1, 3, 10), (2, 3)] assert process_queries(N, values, edges, queries) == [5, 10] def test_all_nodes_single_query(): N = 3 values = [5, 6, 1] edges = [(1, 2), (1, 3)] queries = [(2, 1)] assert process_queries(N, values, edges, queries) == [6] def test_all_updates(): N = 4 values = [3, 6, 2, 8] edges = [(1, 2), (2, 3), (3, 4)] queries = [(1, 2, 10), (1, 3, 7), (2, 3)] assert process_queries(N, values, edges, queries) == [8] def test_mixed_queries(): N = 6 values = [3, 8, 6, 5, 9, 7] edges = [(1, 2), (1, 3), (2, 4), (2, 5), (2, 6)] queries = [(2, 3), (1, 2, 11), (2, 2)] assert process_queries(N, values, edges, queries) == [6, 11] def test_single_node(): N = 1 values = [5] edges = [] queries = [(2, 1)] assert process_queries(N, values, edges, queries) == [5] if __name__ == \\"__main__\\": pytest.main()","solution":"class BinaryTree: def __init__(self, n, values): self.n = n self.values = values self.edges = [[] for _ in range(n + 1)] self.subtree_max = [0] * (n + 1) self.visited = [False] * (n + 1) self.parent = [-1] * (n + 1) def add_edge(self, u, v): self.edges[u].append(v) self.edges[v].append(u) def update_value(self, u, value): self.values[u - 1] = value self.dfs(1) def find_subtree_max(self, u): return self.subtree_max[u] def dfs(self, node): self.visited[node] = True max_val = self.values[node - 1] for neighbor in self.edges[node]: if not self.visited[neighbor]: self.parent[neighbor] = node self.dfs(neighbor) max_val = max(max_val, self.subtree_max[neighbor]) self.subtree_max[node] = max_val self.visited[node] = False def process_queries(N, values, edges, queries): bt = BinaryTree(N, values) for u, v in edges: bt.add_edge(u, v) bt.dfs(1) result = [] for query in queries: if query[0] == 1: u, value = query[1], query[2] bt.update_value(u, value) elif query[0] == 2: u = query[1] result.append(bt.find_subtree_max(u)) return result"},{"question":"def reorder_tasks(test_cases): Reorders tasks based on their priority levels in descending order. Args: test_cases (List[Tuple[int, List[Tuple[str, int]]]]): A list containing multiple test cases. Each test case is represented as a tuple containing the number of tasks and a list of tasks. Each task is represented as a tuple containing the task identifier and its priority level. Returns: List[str]: A list containing the reordered task identifiers for each test case. def parse_input(input_text): Parses the input text into a list of test cases. Args: input_text (str): The input text containing the number of test cases and task details. Returns: List[Tuple[int, List[Tuple[str, int]]]]: A list of test cases. Each test case is represented as a tuple containing the number of tasks and a list of tasks. Each task is represented as a tuple containing the task identifier and its priority level. import pytest from solution import reorder_tasks, parse_input def test_parse_input(): input_data = \\"2n3ntask1 10ntask2 50ntask3 20n4ntaskA 99ntaskB 88ntaskC 77ntaskD 66\\" expected_output = [ (3, [(\\"task1\\", 10), (\\"task2\\", 50), (\\"task3\\", 20)]), (4, [(\\"taskA\\", 99), (\\"taskB\\", 88), (\\"taskC\\", 77), (\\"taskD\\", 66)]) ] assert parse_input(input_data) == expected_output def test_reorder_tasks(): test_cases = [ (3, [(\\"task1\\", 10), (\\"task2\\", 50), (\\"task3\\", 20)]), (4, [(\\"taskA\\", 99), (\\"taskB\\", 88), (\\"taskC\\", 77), (\\"taskD\\", 66)]) ] expected_output = [\\"task2 task3 task1\\", \\"taskA taskB taskC taskD\\"] assert reorder_tasks(test_cases) == expected_output def test_reorder_tasks_with_same_priority(): test_cases = [ (3, [(\\"task1\\", 10), (\\"task3\\", 10), (\\"task2\\", 10)]) ] expected_output = [\\"task1 task3 task2\\"] assert reorder_tasks(test_cases) == expected_output","solution":"def reorder_tasks(test_cases): results = [] for case in test_cases: n, tasks = case sorted_tasks = sorted(tasks, key=lambda x: x[1], reverse=True) results.append(' '.join([task[0] for task in sorted_tasks])) return results def parse_input(input_text): lines = input_text.strip().split('n') index = 0 t = int(lines[index]) index += 1 cases = [] for _ in range(t): n = int(lines[index]) index += 1 tasks = [] for _ in range(n): task_data = lines[index].split() tasks.append((task_data[0], int(task_data[1]))) index += 1 cases.append((n, tasks)) return cases"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if the input string can be rearranged to form a palindrome. Parameters: s (str): The input string containing only lowercase alphabetical characters. Returns: bool: True if the string can be rearranged into a palindrome, otherwise False. Examples: >>> can_form_palindrome(\\"aabb\\") True >>> can_form_palindrome(\\"abc\\") False >>> can_form_palindrome(\\"racecar\\") True >>> can_form_palindrome(\\"abcd\\") False","solution":"def can_form_palindrome(s: str) -> bool: Determines if the input string can be rearranged to form a palindrome. Parameters: s (str): The input string containing only lowercase alphabetical characters. Returns: bool: True if the string can be rearranged into a palindrome, otherwise False. from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"def shortest_word_length(sentence: str) -> int: Write a function that takes a string representing a sentence and returns the length of the shortest word in the sentence. The sentence will contain only letters and spaces, and there will be no leading or trailing spaces. Words are separated by a single space. >>> shortest_word_length(\\"Hello there my friend\\") == 2 >>> shortest_word_length(\\"The quick brown fox\\") == 3 >>> shortest_word_length(\\"coding is fun\\") == 2 >>> shortest_word_length(\\"shortest\\") == 8 # Your code here","solution":"def shortest_word_length(sentence): Returns the length of the shortest word in the given sentence. words = sentence.split() if not words: return 0 return min(len(word) for word in words)"},{"question":"def check_grid_safety(n: int, m: int, grid: List[str]) -> str: Check if no two adjacent cells (horizontally, vertically, or diagonally) in the grid have the same character. >>> check_grid_safety(2, 2, [\\"AB\\", \\"CD\\"]) 'SAFE' >>> check_grid_safety(3, 3, [\\"ABC\\", \\"DEF\\", \\"GHI\\"]) 'SAFE' >>> check_grid_safety(3, 3, [\\"AAB\\", \\"CDE\\", \\"FGH\\"]) 'ALERT'","solution":"def check_grid_safety(n, m, grid): def is_adjacent_same(i, j): # Check adjacent cells for similarities directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == grid[i][j]: return True return False for i in range(n): for j in range(m): if is_adjacent_same(i, j): return \\"ALERT\\" return \\"SAFE\\""},{"question":"def max_cookies(F: int, X: int) -> Tuple[int, int]: Given the total amount of flour (F) and the amount of flour required per cookie (X), returns the maximum number of whole cookies that can be baked and the remaining flour. >>> max_cookies(500, 100) (5, 0) >>> max_cookies(600, 120) (5, 0) >>> max_cookies(550, 120) (4, 70)","solution":"def max_cookies(F, X): Given the total amount of flour and the amount of flour required per cookie, returns the maximum number of whole cookies that can be baked and the remaining flour. max_complete_cookies = F // X remaining_flour = F % X return max_complete_cookies, remaining_flour"},{"question":"def merge_sorted_arrays(arr1, arr2): Write a function \`merge_sorted_arrays\` that takes two sorted arrays of integers as inputs and returns a single sorted array containing all the elements from both input arrays. The function should maintain the sorted order. You cannot use built-in methods like \`sort\` to sort the final array. You must implement the merging process manually. Examples: >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([1, 2, 3], [4, 5, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([-1, 0, 2], [-2, 1, 3]) [-2, -1, 0, 1, 2, 3] >>> merge_sorted_arrays([], [7, 8, 9]) [7, 8, 9] >>> merge_sorted_arrays([10, 20, 30], []) [10, 20, 30]","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array. merged = [] i, j = 0, 0 # Merge the arrays by comparing elements while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged.append(arr1[i]) i += 1 else: merged.append(arr2[j]) j += 1 # Add the remaining elements from arr1 while i < len(arr1): merged.append(arr1[i]) i += 1 # Add the remaining elements from arr2 while j < len(arr2): merged.append(arr2[j]) j += 1 return merged"},{"question":"def shortest_string_extension(s: str, t: str) -> str: Returns the shortest string u such that s is a prefix of u and t is a suffix of u. >>> shortest_string_extension(\\"prefix\\", \\"suffix\\") 'prefixsuffix' >>> shortest_string_extension(\\"abcd\\", \\"cdef\\") 'abcdef' >>> shortest_string_extension(\\"hello\\", \\"world\\") 'helloworld' def solve(q: int, test_cases: List[Tuple[str, str]]) -> List[str]: Processes multiple test cases and returns their respective results. >>> solve(3, [(\\"prefix\\", \\"suffix\\"), (\\"abcd\\", \\"cdef\\"), (\\"hello\\", \\"world\\")]) ['prefixsuffix', 'abcdef', 'helloworld'] >>> solve(2, [(\\"a\\", \\"a\\"), (\\"x\\", \\"x\\")]) ['a', 'x']","solution":"def shortest_string_extension(s, t): Returns the shortest string u such that s is a prefix of u and t is a suffix of u. # Try to find the largest suffix of s which is a prefix of t max_overlap = 0 for i in range(1, min(len(s), len(t)) + 1): if s[-i:] == t[:i]: max_overlap = i # Form the result by combining s and the suffix of t that isn't overlapping result = s + t[max_overlap:] return result def solve(q, test_cases): Processes multiple test cases and returns their respective results. results = [] for s, t in test_cases: results.append(shortest_string_extension(s, t)) return results"},{"question":"def second_smallest(lst: List[int]) -> int: Returns the second smallest number in a list of integers. Assumes the list contains at least two different integers. >>> second_smallest([3, 1, 5, 7, 2]) 2 >>> second_smallest([12, 45, 3, 7, 19]) 7 >>> second_smallest([-10, -20, -5, -25, -15]) -20 >>> second_smallest([4, 4, 3, 2, 2, 1, 1, 0]) 1 >>> second_smallest([2, 1]) 2","solution":"def second_smallest(lst): Returns the second smallest number in a list of integers. Assumes the list contains at least two different integers. # Remove duplicates by converting list to set and back to list unique_lst = list(set(lst)) if len(unique_lst) < 2: raise ValueError(\\"List must contain at least two different integers\\") first, second = float('inf'), float('inf') for num in unique_lst: if num < first: second = first first = num elif num < second: second = num return second"},{"question":"def reorderString(s): Reorders the input string such that all digits are at the end. Preserves the order of the non-digits and the digits. >>> reorderString(\\"a1b2c3\\") == \\"abc123\\" >>> reorderString(\\"h3e2l1lo4\\") == \\"hello3214\\" >>> reorderString(\\"abcdef\\") == \\"abcdef\\" >>> reorderString(\\"123456\\") == \\"123456\\" >>> reorderString(\\"a!b@c#12%3^\\") == \\"a!b@c#%^123\\" >>> reorderString(\\"\\") == \\"\\" >>> reorderString(\\"1\\") == \\"1\\" >>> reorderString(\\"a\\") == \\"a\\" >>> reorderString(\\"ab12cd34ef56\\") == \\"abcdef123456\\"","solution":"def reorderString(s): Reorders the input string such that all digits are at the end. Preserves the order of the non-digits and the digits. non_digits = [] digits = [] for char in s: if char.isdigit(): digits.append(char) else: non_digits.append(char) return \\"\\".join(non_digits) + \\"\\".join(digits)"},{"question":"def twoSum(nums: List[int], k: int) -> bool: Determines if there are two distinct indices i and j in the array such that nums[i] + nums[j] is equal to k. >>> twoSum([1, 2, 3, 9], 8) False >>> twoSum([1, 2, 4, 4], 8) True","solution":"def twoSum(nums, k): Determines if there are two distinct indices i and j in the array such that nums[i] + nums[j] is equal to k. :param nums: List of integers :param k: Integer sum value to check for :return: Boolean indicating if such pair exists seen = set() for num in nums: if k - num in seen: return True seen.add(num) return False"},{"question":"def longest_continuous_increase(n: int, views: List[int]) -> int: Determine the length of the longest period of continuous increase in user activity. >>> longest_continuous_increase(6, [1, 2, 3, 2, 4, 5]) 3 >>> longest_continuous_increase(5, [5, 4, 3, 2, 1]) 1 >>> longest_continuous_increase(8, [10, 20, 30, 40, 50, 60, 70, 80]) 8","solution":"def longest_continuous_increase(n, views): if n == 0: return 0 if n == 1: return 1 longest_increase = 1 current_increase = 1 for i in range(1, n): if views[i] > views[i - 1]: current_increase += 1 if current_increase > longest_increase: longest_increase = current_increase else: current_increase = 1 return longest_increase"},{"question":"def reorganize_string(s: str) -> str: Write a function to determine if a given string can be rearranged such that no two adjacent characters are the same. If possible, return one such rearrangement. If not possible, return an empty string. >>> reorganize_string('aabb') in ['abab', 'baba'] True >>> reorganize_string('aaab') '' >>> reorganize_string('aaabb') in ['ababa', 'babab'] True >>> reorganize_string('aaaaa') '' >>> reorganize_string('a') 'a' >>> reorganize_string('ab') in ['ab', 'ba'] True >>> reorganize_string('aa') '' >>> result = reorganize_string('aabbcc') >>> len(result) == 6 and all(result[i] != result[i + 1] for i in range(len(result) - 1)) True >>> reorganize_string('abbabbaaab') in ['ababababab', 'bababababa'] True >>> s = 'abcdefghijklmnopqrstuvwxyz' * 200 >>> result = reorganize_string(s) >>> len(result) == len(s) and all(result[i] != result[i + 1] for i in range(len(result) - 1)) True","solution":"import heapq from collections import Counter def reorganize_string(s): Rearranges the given string \`s\` such that no two adjacent characters are the same. If it's not possible, returns an empty string. if not s: return \\"\\" # Count the frequency of each character count = Counter(s) max_heap = [(-freq, char) for char, freq in count.items()] heapq.heapify(max_heap) prev_freq, prev_char = 0, \\"\\" result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_freq, prev_char = freq + 1, char result_str = ''.join(result) if len(result_str) != len(s): return \\"\\" return result_str"},{"question":"def count_islands(grid): Counts the number of islands in a grid. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. :param grid: List of strings representing the grid :return: Integer count of islands Examples: >>> count_islands([\\"11000\\", \\"11000\\", \\"00100\\", \\"00011\\"]) == 3 >>> count_islands([\\"1\\"]) == 1 >>> count_islands([\\"0\\"]) == 0 >>> count_islands([\\"111\\", \\"111\\", \\"111\\"]) == 1 >>> count_islands([\\"110\\", \\"110\\", \\"001\\"]) == 2","solution":"def count_islands(grid): Counts the number of islands in a grid. :param grid: List of strings representing the grid :return: Integer count of islands if not grid: return 0 N = len(grid) visited = [[False] * N for _ in range(N)] count = 0 def dfs(x, y): if x < 0 or y < 0 or x >= N or y >= N or visited[x][y] or grid[x][y] == '0': return visited[x][y] = True # explore all adjacent cells dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) for i in range(N): for j in range(N): if grid[i][j] == '1' and not visited[i][j]: dfs(i, j) count += 1 return count"},{"question":"def is_palindrome(s: str) -> str: Determine if the given string s is a palindrome, considering only alphanumeric characters and ignoring cases. Args: s (str): The input string Returns: str: \\"YES\\" if the string is a palindrome, \\"NO\\" otherwise. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") \\"YES\\" >>> is_palindrome(\\"race a car\\") \\"NO\\" >>> is_palindrome(\\"0P\\") \\"NO\\"","solution":"def is_palindrome(s): Returns 'YES' if the given string s is a palindrome, ignoring non-alphanumeric characters and case differences. Otherwise returns 'NO'. # Filter out non-alphanumeric characters and convert to lowercase filtered_chars = ''.join(char.lower() for char in s if char.isalnum()) # Check if the filtered string is equal to its reverse if filtered_chars == filtered_chars[::-1]: return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List def transform_to_non_decreasing(a: List[int]) -> List[int]: Transforms the array \`a\` into a non-decreasing sequence with the minimum possible sum by allowed operations. Conditions: * You need to ensure that the resulting array is in non-decreasing order. * Minimize the sum of the resulting array. Constraints: * 2 ≤ N ≤ 50 * -10^6 ≤ a_i ≤ 10^6 * All input values are integers. Args: a : List[int] : Array of integers Returns: List[int] : Transformed array Examples: >>> transform_to_non_decreasing([3, 1, 4, 2]) [3, 3, 4, 4] >>> transform_to_non_decreasing([-1, -2, -3]) [-1, -1, -1] >>> transform_to_non_decreasing([6, 6, 6, 6, 6]) [6, 6, 6, 6, 6] pass # Unit tests def test_example1(): assert transform_to_non_decreasing([3, 1, 4, 2]) == [3, 3, 4, 4] def test_example2(): assert transform_to_non_decreasing([-1, -2, -3]) == [-1, -1, -1] def test_example3(): assert transform_to_non_decreasing([6, 6, 6, 6, 6]) == [6, 6, 6, 6, 6] def test_random_order(): assert transform_to_non_decreasing([5, 3, 8, 1, 2]) == [5, 5, 8, 8, 8] def test_single_element(): assert transform_to_non_decreasing([7]) == [7] def test_all_equal(): assert transform_to_non_decreasing([4, 4, 4, 4]) == [4, 4, 4, 4] def test_all_negative_and_decreasing(): assert transform_to_non_decreasing([-5, -6, -7, -8, -9]) == [-5, -5, -5, -5, -5]","solution":"from typing import List def transform_to_non_decreasing(a: List[int]) -> List[int]: Transforms the array \`a\` into a non-decreasing sequence with the minimum possible sum by allowed operations. # Initialize the resulting array with the input array result = a[:] N = len(a) # Iterate through the array from the second element to the end for i in range(1, N): # If the current element is less than the previous element, set it equals to the previous element if result[i] < result[i - 1]: result[i] = result[i - 1] return result"},{"question":"def longest_arithmetic_subarray(arr): Returns the length of the longest subarray that can form an arithmetic progression. >>> longest_arithmetic_subarray([3, 6, 9, 12, 15]) == 5 >>> longest_arithmetic_subarray([1, 3, 5, 7]) == 4 >>> longest_arithmetic_subarray([10, 7, 4, 1]) == 4 >>> longest_arithmetic_subarray([5, 5, 5, 5]) == 4 >>> longest_arithmetic_subarray([1, 2]) == 2 >>> longest_arithmetic_subarray([1, 2, 4]) == 2 pass def process_inputs(T, cases): Process multiple test cases to find the longest arithmetic subarray for each case. >>> T = 2 >>> cases = [(5, [3, 6, 9, 12, 15]), (4, [1, 3, 5, 7])] >>> process_inputs(T, cases) == [5, 4] >>> T = 2 >>> cases = [(3, [1, 1, 1]), (6, [1, 2, 3, 4, 6, 8])] >>> process_inputs(T, cases) == [3, 4] pass","solution":"def longest_arithmetic_subarray(arr): Returns the length of the longest subarray that can form an arithmetic progression. n = len(arr) if n < 2: return n longest_length = 2 current_length = 2 common_diff = arr[1] - arr[0] for i in range(2, n): if arr[i] - arr[i - 1] == common_diff: current_length += 1 else: common_diff = arr[i] - arr[i - 1] current_length = 2 longest_length = max(longest_length, current_length) return longest_length def process_inputs(T, cases): results = [] for i in range(T): n, arr = cases[i] results.append(longest_arithmetic_subarray(arr)) return results"},{"question":"def are_permutations(s1: str, s2: str) -> bool: Determine if one string is a permutation of another. Parameters: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if one string is a permutation of the other, False otherwise. >>> are_permutations(\\"abcd\\", \\"dcba\\") True >>> are_permutations(\\"abcd\\", \\"abdc\\") True >>> are_permutations(\\"abcd\\", \\"abcc\\") False >>> are_permutations(\\"abcd\\", \\"abcdx\\") False","solution":"def are_permutations(s1, s2): Determine if one string is a permutation of another. Parameters: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if one string is a permutation of the other, False otherwise. return sorted(s1) == sorted(s2)"},{"question":"def count_friend_pairs(users: List[List[int]], queries: List[int]) -> List[int]: Count the number of user pairs that can be considered friends for each query. Each pair is a friend if they share at least K common interests. >>> count_friend_pairs([[1, 2, 3], [2, 3, 4], [1, 4]], [2, 1]) [1, 3] >>> count_friend_pairs([[1, 2, 3], [4, 5, 6], [7, 8, 9]], [1, 2]) [0, 0] >>> count_friend_pairs([[1, 2], [1, 2], [1, 2]], [1, 2]) [3, 3] >>> count_friend_pairs([[1, 3, 5], [3, 5, 7], [5, 7, 9], [1, 9, 3]], [1, 2, 3]) [6, 3, 0] >>> count_friend_pairs([list(range(1, 101)) for _ in range(1000)], [50, 100]) [499500, 499500]","solution":"def count_friend_pairs(users, queries): # Convert list of interests to sets for each user user_sets = [set(user) for user in users] results = [] for K in queries: count = 0 for i in range(len(user_sets)): for j in range(i + 1, len(user_sets)): if len(user_sets[i] & user_sets[j]) >= K: count += 1 results.append(count) return results"},{"question":"def largest_rectangular_block(matrix: List[str]) -> int: Given a matrix of characters, find the largest rectangular block of the same character. >>> largest_rectangular_block([ ... \\"aaaab\\", ... \\"aaabb\\", ... \\"aaacb\\", ... \\"bcccb\\" ... ]) 9 >>> largest_rectangular_block([ ... \\"a\\", ... \\"a\\", ... \\"b\\", ... \\"b\\", ... \\"b\\" ... ]) 3 >>> largest_rectangular_block([ ... \\"abc\\", ... \\"def\\", ... \\"ghi\\" ... ]) 1","solution":"def largest_rectangular_block(matrix): if not matrix: return 0 n = len(matrix) m = len(matrix[0]) max_area = 0 for c in range(26): char = chr(ord('a') + c) height = [0] * (m + 1) for i in range(n): for j in range(m): if matrix[i][j] == char: height[j] += 1 else: height[j] = 0 stack = [-1] for k in range(m + 1): while height[k] < height[stack[-1]]: h = height[stack.pop()] w = k - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(k) return max_area"},{"question":"def min_knights_to_capture(n: int, x: int, y: int) -> int: Calculate the minimum number of knights needed to ensure the enemy piece is under attack on an n x n board. Args: n : int : size of the board (n x n) x : int : x-coordinate (or row) of the enemy piece (1-indexed) y : int : y-coordinate (or column) of the enemy piece (1-indexed) Returns: int : minimum number of knights needed Example: >>> min_knights_to_capture(5, 3, 3) 1 >>> min_knights_to_capture(1, 1, 1) 1","solution":"def min_knights_to_capture(n, x, y): Calculate the minimum number of knights needed to ensure the enemy piece is under attack. Args: n : int : size of the board (n x n) x : int : x-coordinate (or row) of the enemy piece (1-indexed) y : int : y-coordinate (or column) of the enemy piece (1-indexed) Returns: int : minimum number of knights needed # Knights moves offsets knight_moves = [ (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2), (-1, 2), (-2, 1) ] def is_attacking(enemy_pos, knight_pos): ex, ey = enemy_pos kx, ky = knight_pos return any(kx + dx == ex and ky + dy == ey for dx, dy in knight_moves) # Checking all positions on the board to find minimum knights needed min_knights = 1 for move in knight_moves: nx, ny = x + move[0], y + move[1] if 1 <= nx <= n and 1 <= ny <= n: return 1 return min_knights # Example usage: # print(min_knights_to_capture(5, 3, 3)) # Output: 1"},{"question":"def longest_divisor_sequence_length(L, R): Returns the length of the longest sequence where each number is a divisor of the next within the range [L, R]. >>> longest_divisor_sequence_length(1, 1) == 1 >>> longest_divisor_sequence_length(10, 20) == 2 >>> longest_divisor_sequence_length(15, 30) == 2 >>> longest_divisor_sequence_length(5, 15) == 2 >>> longest_divisor_sequence_length(1, 32) == 6 def solve(test_cases): Given multiple test cases, returns a list of results for the longest divisor sequence length for each test case. >>> test_cases = [(1, 1), (10, 20), (15, 30)] >>> solve(test_cases) == [1, 2, 2] >>> test_cases = [(1, 32), (5, 15), (7, 22)] >>> solve(test_cases) == [6, 2, 2]","solution":"def longest_divisor_sequence_length(L, R): Returns the length of the longest sequence where each number is a divisor of the next. if L == R: return 1 max_length = 1 # The minimum possible sequence length is 1, since a number is a divisor of itself. for i in range(L, R + 1): count = 1 num = i while num <= R: num *= 2 if num <= R: count += 1 max_length = max(max_length, count) return max_length def solve(test_cases): results = [] for case in test_cases: L, R = case results.append(longest_divisor_sequence_length(L, R)) return results"},{"question":"def can_alice_reach_goal(h: int, w: int, grid: List[str]) -> str: Determine if Alice can reach the goal in the provided 2D grid despite Bob placing obstacles. >>> can_alice_reach_goal(3, 3, [ \\"A..\\", \\".#.\\", \\"..G\\" ]) \\"YES\\" >>> can_alice_reach_goal(3, 3, [ \\"A..\\", \\"#\\", \\"..G\\" ]) \\"NO\\" >>> can_alice_reach_goal(4, 4, [ \\"A#.#\\", \\"..\\", \\"#..#\\", \\"G..#\\" ]) \\"NO\\"","solution":"def can_alice_reach_goal(h, w, grid): from collections import deque # Find Alice and Goal position for i in range(h): for j in range(w): if grid[i][j] == 'A': alice_start = (i, j) elif grid[i][j] == 'G': goal = (i, j) # Directions for movement (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS to find if there's a path from Alice to the Goal def bfs(start, end): queue = deque([start]) visited = set([start]) while queue: x, y = queue.popleft() if (x, y) == end: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < h and 0 <= ny < w and (nx, ny) not in visited and grid[nx][ny] != '#': visited.add((nx, ny)) queue.append((nx, ny)) return False return \\"YES\\" if bfs(alice_start, goal) else \\"NO\\""},{"question":"def min_operations_to_palindrome(s: str) -> int: Given a string of lowercase alphabets, returns the minimum number of replace operations needed to make it a palindrome. Args: s (str): A string consisting of lowercase alphabets. Returns: int: The minimum number of replace operations needed to make the string a palindrome. Examples: >>> min_operations_to_palindrome('abca') 1 >>> min_operations_to_palindrome('racecar') 0 >>> min_operations_to_palindrome('abcdef') 3","solution":"def min_operations_to_palindrome(s): Returns the minimum number of replace operations needed to make the string a palindrome. n = len(s) operations = 0 # Check pairs of characters from the start and end for i in range(n // 2): if s[i] != s[n - i - 1]: operations += 1 return operations"},{"question":"def calculate_final_prices(items): Calculate the final price of each item after applying the appropriate discount. Args: items: A list of tuples, where each tuple contains the item name, original price, and sales frequency. Returns: A list of tuples, where each tuple contains the item name and its final price after the discount, rounded to 2 decimal places. Examples: >>> calculate_final_prices([(\\"Laptop\\", \\"1000\\", \\"3\\")]) [(\\"Laptop\\", 600.00)] >>> calculate_final_prices([(\\"Smartphone\\", \\"500\\", \\"15\\")]) [(\\"Smartphone\\", 400.00)] >>> calculate_final_prices([ (\\"Laptop\\", \\"1000\\", \\"3\\"), (\\"Smartphone\\", \\"500\\", \\"15\\"), (\\"Tablet\\", \\"300\\", \\"25\\"), (\\"Headphones\\", \\"150\\", \\"7\\") ]) [ (\\"Laptop\\", 600.00), (\\"Smartphone\\", 400.00), (\\"Tablet\\", 270.00), (\\"Headphones\\", 105.00) ]","solution":"def calculate_final_prices(items): final_prices = [] for item in items: name, original_price, frequency = item original_price = float(original_price) frequency = int(frequency) if 1 <= frequency <= 5: discount_rate = 0.40 elif 6 <= frequency <= 10: discount_rate = 0.30 elif 11 <= frequency <= 20: discount_rate = 0.20 else: discount_rate = 0.10 final_price = original_price * (1 - discount_rate) final_prices.append((name, round(final_price, 2))) return final_prices"},{"question":"def longest_palindromic_substring_length(s: str) -> int: Returns the length of the longest contiguous palindromic substring in s. >>> longest_palindromic_substring_length(\\"abacded\\") 3 >>> longest_palindromic_substring_length(\\"forgeeksskeegfor\\") 10 >>> longest_palindromic_substring_length(\\"a\\") 1 >>> longest_palindromic_substring_length(\\"aa\\") 2 >>> longest_palindromic_substring_length(\\"ab\\") 1 >>> longest_palindromic_substring_length(\\"aaaa\\") 4 >>> longest_palindromic_substring_length(\\"abcdefgh\\") 1 >>> longest_palindromic_substring_length(\\"abccbaabcd\\") 6","solution":"def longest_palindromic_substring_length(s: str) -> int: Returns the length of the longest contiguous palindromic substring in s. n = len(s) if n == 0: return 0 # Create a 2D DP array to store the results of subproblems dp = [[False for _ in range(n)] for _ in range(n)] max_length = 1 # All substrings of length 1 are palindromic for i in range(n): dp[i][i] = True start = 0 # Check for substrings of length 2 for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True start = i max_length = 2 # Check for lengths greater than 2 for k in range(3, n + 1): for i in range(n - k + 1): j = i + k - 1 # Ending index of the substring from starting index i and length k # Check for palindrome if dp[i + 1][j - 1] and s[i] == s[j]: dp[i][j] = True if k > max_length: start = i max_length = k return max_length"},{"question":"def recommend_songs(n: int, play_counts: List[int]) -> List[int]: Recommends a list of song indices sorted by their play counts in descending order. If two songs have the same number of play counts, the song with the smaller index appears first. Parameters: n (int): The number of songs. play_counts (List[int]): A list of integers representing the play counts of songs. Returns: List[int]: A list of song indices sorted by their play counts in descending order. >>> recommend_songs(5, [30, 10, 20, 30, 15]) [0, 3, 2, 4, 1] >>> recommend_songs(4, [10, 10, 10, 10]) [0, 1, 2, 3]","solution":"def recommend_songs(n, play_counts): Recommends a list of song indices sorted by their play counts in descending order. If two songs have the same number of play counts, the song with the smaller index appears first. # Create a list of (index, play_count) tuples indexed_play_counts = [(i, play_counts[i]) for i in range(n)] # Sort the list based on play_count in descending order, and index in ascending order for ties sorted_songs = sorted(indexed_play_counts, key=lambda x: (-x[1], x[0])) # Extract the indices of the sorted songs recommended_indices = [song[0] for song in sorted_songs] return recommended_indices # Example usage: # n = 5 # play_counts = [30, 10, 20, 30, 15] # print(recommend_songs(n, play_counts)) # Output: [0, 3, 2, 4, 1]"},{"question":"from typing import List, Tuple def fibonacci_sum_modulo(n: int, m: int) -> int: Calculate the sum of the first n Fibonacci numbers modulo m. >>> fibonacci_sum_modulo(4, 100) 7 >>> fibonacci_sum_modulo(7, 10) 3 >>> fibonacci_sum_modulo(0, 10) 0 >>> fibonacci_sum_modulo(1, 10**9) 1 >>> fibonacci_sum_modulo(5, 5) 2 pass def process_test_cases(test_cases: List[Tuple[int, int]]) -> List[int]: Process multiple test cases of fibonacci_sum_modulo function. >>> process_test_cases([(4, 100), (7, 10), (0, 10), (1, 10**9), (5, 5)]) [7, 3, 0, 1, 2] pass","solution":"def fibonacci_sum_modulo(n, m): if n == 0: return 0 % m fib_numbers = [0, 1] while len(fib_numbers) <= n: fib_numbers.append((fib_numbers[-1] + fib_numbers[-2]) % m) return sum(fib_numbers) % m def process_test_cases(test_cases): results = [] for n, m in test_cases: results.append(fibonacci_sum_modulo(n, m)) return results"},{"question":"def maxUniqueSubstrings(s: str) -> int: Determines the maximum number of substrings that can be created from string s such that each substring does not contain any repeated character. >>> maxUniqueSubstrings(\\"abac\\") 4 >>> maxUniqueSubstrings(\\"aaaa\\") 4","solution":"def maxUniqueSubstrings(s): Determines the maximum number of substrings that can be created from string s such that each substring does not contain any repeated character. if not s: return 0 last_seen = {} start = -1 max_substrings = 0 for index, char in enumerate(s): # When we encounter a previously seen character, we start a new substring if char in last_seen and last_seen[char] > start: start = last_seen[char] last_seen[char] = index max_substrings += 1 return max_substrings"},{"question":"def minimum_possible_height_difference(n: int, heights: List[int]) -> int: Determines the minimum possible height difference that Banjo can achieve by starting at any segment and completing one lap around the circular racetrack. >>> minimum_possible_height_difference(6, [2, 5, 3, 7, 1, 4]) 4 >>> minimum_possible_height_difference(5, [10, 15, 20, 25, 30]) 20 >>> minimum_possible_height_difference(1, [100]) 0 >>> minimum_possible_height_difference(2, [5, 10]) 5 >>> minimum_possible_height_difference(4, [4, 4, 4, 4]) 0 >>> minimum_possible_height_difference(3, [1000, 800, 900]) 200","solution":"def minimum_possible_height_difference(n, heights): Determines the minimum possible height difference that Banjo can achieve by starting at any segment and completing one lap around the circular racetrack. # Initialize the minimum difference with a large value min_diff = float('inf') # Consider each segment as a starting point for i in range(n): # Rotate the heights to consider the current starting point rotated_heights = heights[i:] + heights[:i] # Determine the max and min heights in the rotated list max_height = max(rotated_heights) min_height = min(rotated_heights) # Update the minimum difference min_diff = min(min_diff, max_height - min_height) return min_diff"},{"question":"def minimum_time_to_complete_courses(N: int, course_info: List[List[int]]) -> int: Find the shortest possible time to complete all courses, considering prerequisites and course durations. >>> minimum_time_to_complete_courses(3, [[3, 0], [2, 1, 1], [5, 1, 2]]) 10 >>> minimum_time_to_complete_courses(4, [[4, 0], [3, 1, 1], [2, 1, 2], [1, 2, 2, 3]]) 10","solution":"def minimum_time_to_complete_courses(N, course_info): from collections import deque, defaultdict duration = [0] * (N + 1) prerequisites = defaultdict(list) in_degree = [0] * (N + 1) for i in range(N): data = course_info[i] D_i, P_i = data[0], data[1] duration[i + 1] = D_i for idx in data[2:]: prerequisites[idx].append(i + 1) in_degree[i + 1] += 1 queue = deque() time_to_complete = [0] * (N + 1) for i in range(1, N + 1): if in_degree[i] == 0: queue.append(i) time_to_complete[i] = duration[i] while queue: curr = queue.popleft() for dependent in prerequisites[curr]: in_degree[dependent] -= 1 time_to_complete[dependent] = max(time_to_complete[dependent], time_to_complete[curr] + duration[dependent]) if in_degree[dependent] == 0: queue.append(dependent) return max(time_to_complete)"},{"question":"def can_ride(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Determine if all people can take the ride given the heights of N people and the number of available safety belts K. >>> can_ride(3, [(120, 3, [110, 130, 145]), (140, 4, [150, 160, 155, 145]), (100, 2, [95, 105])]) [\\"NO\\", \\"YES\\", \\"NO\\"]","solution":"def can_ride(T, test_cases): results = [] for i in range(T): H, K = test_cases[i][:2] heights = test_cases[i][2:] if all(height >= H for height in heights) and len(heights) <= K: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def get_initials(full_name: str) -> str: Returns the initials of a person's full name in uppercase. :param full_name: A string representing a person's full name in the format \\"First Last\\" :return: A string with the initials in uppercase followed by dots. >>> get_initials('John') == 'J.' >>> get_initials('John Doe') == 'J.D.' >>> get_initials('Jane Mary Smith') == 'J.M.S.' >>> get_initials(' Mario Rossi ') == 'M.R.' >>> get_initials('John-Doe') == 'J.' >>> get_initials(\\"O'Reilly McDonald\\") == 'O.M.' >>> get_initials('A B C D') == 'A.B.C.D.'","solution":"def get_initials(full_name: str) -> str: Returns the initials of a person's full name in uppercase. :param full_name: A string representing a person's full name in the format \\"First Last\\" :return: A string with the initials in uppercase followed by dots. # Split by spaces and filter out any empty strings parts = list(filter(None, full_name.split(' '))) # Extract the first letter of each part, convert to uppercase, and join with dots initials = '.'.join([part[0].upper() for part in parts]) # Add a trailing dot return f'{initials}.'"},{"question":"def count_titles_by_starting_letter(titles: List[str]) -> Dict[str, int]: Returns a dictionary with the count of titles that start with each letter of the alphabet. The count is case-insensitive. >>> count_titles_by_starting_letter(['A Tale of Two Cities', 'a brief history of time', 'Alice's Adventures in Wonderland']) {'A': 3, 'B': 0, 'C': 0, 'D': 0, 'E': 0, 'F': 0, 'G': 0, 'H': 0, 'I': 0, 'J': 0, 'K': 0, 'L': 0, 'M': 0, 'N': 0, 'O': 0, 'P': 0, 'Q': 0, 'R': 0, 'S': 0, 'T': 0, 'U': 0, 'V': 0, 'W': 0, 'X': 0, 'Y': 0, 'Z': 0} >>> count_titles_by_starting_letter(['Gone with the Wind', 'good omens', 'The Hobbit']) {'A': 0, 'B': 0, 'C': 0, 'D': 0, 'E': 0, 'F': 0, 'G': 2, 'H': 0, 'I': 0, 'J': 0, 'K': 0, 'L': 0, 'M': 0, 'N': 0, 'O': 0, 'P': 0, 'Q': 0, 'R': 0, 'S': 0, 'T': 1, 'U': 0, 'V': 0, 'W': 0, 'X': 0, 'Y': 0, 'Z': 0}","solution":"def count_titles_by_starting_letter(titles): Returns a dictionary with the count of titles that start with each letter of the alphabet. The count is case-insensitive. # Initialize dictionary with all letters set to 0 count_dict = {chr(i): 0 for i in range(ord('A'), ord('Z') + 1)} for title in titles: first_letter = title[0].upper() if first_letter in count_dict: count_dict[first_letter] += 1 return count_dict"},{"question":"def sum_of_primes(n: int) -> int: Returns the sum of the first n prime numbers. >>> sum_of_primes(1) == 2 >>> sum_of_primes(3) == 10 >>> sum_of_primes(5) == 28 >>> sum_of_primes(10) == 129 >>> sum_of_primes(20) == 639","solution":"def sum_of_primes(n): Returns the sum of the first n prime numbers. def is_prime(num): Check if a number is prime. if num <= 1: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True primes = [] num = 2 while len(primes) < n: if is_prime(num): primes.append(num) num += 1 return sum(primes)"},{"question":"from typing import List def largestCommonSum(arr1: List[int], arr2: List[int]) -> int: Returns the largest sum of common elements in two integer arrays. If there are no common elements, returns 0. >>> largestCommonSum([1, 2, 3, 4], [3, 4, 5, 6]) == 7 >>> largestCommonSum([-1, -2, 3, 4], [3, 4, -2, 0]) == 5 >>> largestCommonSum([1, 2, 2, 2], [2, 2]) == 2 >>> largestCommonSum([1, 2, 3], [4, 5, 6]) == 0","solution":"from typing import List def largestCommonSum(arr1: List[int], arr2: List[int]) -> int: Returns the largest sum of common elements in two integer arrays. If there are no common elements, returns 0. common_elements = set(arr1).intersection(set(arr2)) return sum(common_elements) if common_elements else 0"},{"question":"def min_moves_to_balance(s: str) -> int: Find the minimum number of moves that need to be removed to make the robot end up at the starting position with an even-length sequence. >>> min_moves_to_balance(\\"LRLRDUUD\\") 0 >>> min_moves_to_balance(\\"LRLRD\\") 1 >>> min_moves_to_balance(\\"LLLLRRUUUDDDDDD\\") 5 >>> min_moves_to_balance(\\"LLLLL\\") 5 >>> min_moves_to_balance(\\"LRUDLRUD\\") 0 >>> min_moves_to_balance(\\"LRLRUDLR\\") 0 >>> min_moves_to_balance(\\"LR\\"*50000 + \\"UD\\"*50000) 0 >>> min_moves_to_balance(\\"LR\\"*50000 + \\"UD\\"*49999 + \\"L\\") 1","solution":"def min_moves_to_balance(s): Returns the minimum number of moves to be removed to make the robot end up at the starting position with an even-length sequence. from collections import Counter counts = Counter(s) # count of moves in each direction L_count = counts['L'] R_count = counts['R'] U_count = counts['U'] D_count = counts['D'] # imbalance in horizontal and vertical movements horizontal_imbalance = abs(L_count - R_count) vertical_imbalance = abs(U_count - D_count) # total imbalance is the sum of both total_imbalance = horizontal_imbalance + vertical_imbalance # ensure sequence length is even, removing additional one move if odd length if (len(s) - total_imbalance) % 2 != 0: total_imbalance += 1 return total_imbalance"},{"question":"def reverse_first_k_elements(arr, k): Given an integer array \`arr\` and an integer \`k\`, reverse the order of the first \`k\` elements of the array. Parameters: arr (list of int): The array to be modified. k (int): The number of elements to reverse. Returns: list of int: The array with the first k elements reversed. Examples: >>> reverse_first_k_elements([1, 2, 3, 4, 5], 3) [3, 2, 1, 4, 5] >>> reverse_first_k_elements([10, 20, 30, 40], 4) [40, 30, 20, 10]","solution":"def reverse_first_k_elements(arr, k): Reverses the first k elements of the array arr. Parameters: arr (list of int): The array to be modified. k (int): The number of elements to reverse. Returns: list of int: The array with the first k elements reversed. return arr[:k][::-1] + arr[k:]"},{"question":"from typing import List def unique_sort(lst: List[int]) -> List[int]: Sorts the array such that numbers with higher frequency come first. Numbers with the same frequency should appear in ascending order. >>> unique_sort([1, 2, 3, 1, 2, 1, 2, 3]) == [1, 1, 1, 2, 2, 2, 3, 3] >>> unique_sort([4, 4, 4, 1, 2, 3, 4, 5, 5, 5, 5]) == [4, 4, 4, 4, 5, 5, 5, 5, 1, 2, 3]","solution":"from collections import Counter def unique_sort(lst): Sorts the array such that numbers with higher frequency come first. Numbers with the same frequency should appear in ascending order. # Count the frequency of each number in the list freq = Counter(lst) # Sort the list by (-frequency, number) sorted_lst = sorted(lst, key=lambda x: (-freq[x], x)) return sorted_lst"},{"question":"def reverse_string(s: str) -> str: Write a function that takes a string input and returns the string in reverse order. The function should preserve the original case of each character and reverse all punctuation. >>> reverse_string(\\"Hello, World!\\") == \\"!dlroW ,olleH\\" >>> reverse_string(\\"Python 3.8\\") == \\"8.3 nohtyP\\" >>> reverse_string(\\"\\") == \\"\\" >>> reverse_string(\\"a\\") == \\"a\\" >>> reverse_string(\\"1\\") == \\"1\\" >>> reverse_string(\\"!\\") == \\"!\\" >>> reverse_string(\\"madam\\") == \\"madam\\" >>> reverse_string(\\"A man a plan a canal Panama\\") == \\"amanaP lanac a nalp a nam A\\"","solution":"def reverse_string(s): Returns the input string in reverse order, preserving the original case of each character and reversing all punctuation. return s[::-1]"},{"question":"def index_of(nums, target): Returns the index of the target number within the given sorted list of numbers. If the target number is not found, returns -1. >>> index_of([10, 20, 30, 40, 50, 60], 40) 3 >>> index_of([10, 20, 30, 40, 50, 60], 25) -1","solution":"def index_of(nums, target): Returns the index of the target number within the given sorted list of numbers. If the target number is not found, returns -1. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def longest_increasing_subarray_length(trips): Find the length of the longest contiguous subarray with strictly increasing temperatures for each trip. Args: trips (List[Tuple[int, List[int]]]): A list where each element is a tuple containing an integer N and a list of N recorded temperatures. Returns: List[int]: A list of integers representing the length of the longest contiguous subarray with strictly increasing temperatures for each trip. def process_input_and_find_lengths(input_data: str) -> List[int]: Process the input data and return the lengths of the longest increasing subarrays for each trip. Args: input_data (str): The input data as a string in the specified format. Returns: List[int]: The lengths of the longest increasing subarrays for each trip. >>> input_data = \\"3n7n23 24 25 25 26 27 28n6n10 12 15 14 16 17n5n1 2 3 4 5\\" >>> process_input_and_find_lengths(input_data) [4, 3, 5] >>> input_data = \\"1n5n1 2 3 4 5\\" >>> process_input_and_find_lengths(input_data) [5] >>> input_data = \\"1n4n2 2 2 2\\" >>> process_input_and_find_lengths(input_data) [1] >>> input_data = \\"2n5n1 3 5 2 8n4n1 2 3 1\\" >>> process_input_and_find_lengths(input_data) [3, 3] >>> input_data = \\"1n1n10\\" >>> process_input_and_find_lengths(input_data) [1]","solution":"def longest_increasing_subarray_length(trips): results = [] for i in range(len(trips)): n, temperatures = trips[i] max_length = current_length = 1 for j in range(1, n): if temperatures[j] > temperatures[j - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) results.append(max_length) return results def process_input_and_find_lengths(input_data): lines = input_data.strip().split('n') index = 0 T = int(lines[index]) index += 1 trips = [] for _ in range(T): N = int(lines[index]) index += 1 temperatures = list(map(int, lines[index].split())) index += 1 trips.append((N, temperatures)) return longest_increasing_subarray_length(trips)"},{"question":"def longest_valid_subsequence(n: int, sequence: List[int]) -> int: Given a sequence of integers, find the length of the longest subsequence such that the absolute difference between any two consecutive elements is either 1 or 2. >>> longest_valid_subsequence(6, [1, 2, 3, 4, 5, 6]) 6 >>> longest_valid_subsequence(8, [1, 2, 5, 8, 9, 10, 11, 12]) 5 >>> longest_valid_subsequence(5, [1, 4, 7, 10, 13]) 1 >>> longest_valid_subsequence(7, [1, 3, 2, 4, 7, 9, 8]) 4 >>> longest_valid_subsequence(1, [1]) 1 >>> longest_valid_subsequence(2, [1, 3]) 2 >>> longest_valid_subsequence(2, [1, 5]) 1","solution":"def longest_valid_subsequence(n, sequence): if n == 0: return 0 longest = 1 current_length = 1 for i in range(1, n): if abs(sequence[i] - sequence[i-1]) <= 2: current_length += 1 if current_length > longest: longest = current_length else: current_length = 1 return longest"},{"question":"from typing import List def min_travel_cost(N: int, M: int, costs: List[int]) -> int: Determine the minimum cost required to travel to any contiguous sub-sequence of up to M cities from the list of city travel costs. Parameters: - N (int): Number of cities. - M (int): Maximum number of cities Alice can afford to visit in one trip. - costs (List[int]): List containing the travel costs of the cities. Returns: - int: Minimum travel cost for any contiguous sub-sequence of up to M cities. Examples: >>> min_travel_cost(8, 3, [4, 2, 6, 3, 1, 7, 5, 8]) 1 >>> min_travel_cost(5, 2, [10, 5, 3, 8, 12]) 3","solution":"def min_travel_cost(N, M, costs): Determine the minimum cost required to travel to any contiguous sub-sequence of up to M cities from the list of city travel costs. min_cost = float('inf') # Iterate over all possible starting points for the sub-sequence for start in range(N): current_sum = 0 # Find the minimum sum for a sub-sequence starting at 'start' with length up to M for length in range(M): if start + length >= N: break current_sum += costs[start + length] if current_sum < min_cost: min_cost = current_sum return min_cost"},{"question":"def longest_subarray_to_sort(arr: List[int]) -> int: Find the length of the longest contiguous subarray which, when sorted, results in the subarray being in non-decreasing order. >>> longest_subarray_to_sort([1, 3, 5, 2, 4, 6, 8, 7]) 4 >>> longest_subarray_to_sort([1, 2, 3, 4, 5]) 5 >>> longest_subarray_to_sort([5, 4, 3, 2, 1]) 1 >>> longest_subarray_to_sort([1, 3, 2, 1, 4, 2, 2, 3, 5]) 4 >>> longest_subarray_to_sort([1]) 1 >>> longest_subarray_to_sort([2, 2, 2, 2]) 4","solution":"def longest_subarray_to_sort(arr): n = len(arr) max_len = 1 # At least one element sequence is sorted current_len = 1 for i in range(1, n): if arr[i-1] <= arr[i]: current_len += 1 else: max_len = max(max_len, current_len) current_len = 1 max_len = max(max_len, current_len) return max_len"},{"question":"def students_who_can_see_teacher(heights): Given the heights of students, this function will return the heights of students who can see the teacher. A student can see if there is no taller student in front. >>> students_who_can_see_teacher([130, 135, 145, 150, 160]) [130, 135, 145, 150, 160] >>> students_who_can_see_teacher([130, 135, 145, 137, 150, 160]) [130, 135, 145, 150, 160] >>> students_who_can_see_teacher([130, 125, 140, 135, 150, 145]) [130, 140, 150] >>> students_who_can_see_teacher([130, 130, 130, 130]) [130] >>> students_who_can_see_teacher([130]) [130] >>> students_who_can_see_teacher([120, 130, 140, 150, 140, 130]) [120, 130, 140, 150]","solution":"def students_who_can_see_teacher(heights): Given the heights of students, this function will return the heights of students who can see the teacher. A student can see if there is no taller student in front. max_height = 0 result = [] for height in heights: if height > max_height: result.append(height) max_height = height return result"},{"question":"def zeta_series_length(x): Returns the length of the Zeta Series for a given integer x. >>> zeta_series_length(6) == 9 >>> zeta_series_length(19) == 21 >>> zeta_series_length(1) == 1 >>> zeta_series_length(16) == 5 # Implement the function here pass def process_zeta_series(test_cases): Processes multiple test cases to find the Zeta Series length for each. >>> process_zeta_series([6, 19]) == [9, 21] >>> process_zeta_series([1, 16]) == [1, 5] >>> process_zeta_series([7]) == [17] # Implement the function here pass","solution":"def zeta_series_length(x): Returns the length of the Zeta Series for a given integer x. length = 1 while x != 1: if x % 2 == 0: x = x // 2 else: x = 3 * x + 1 length += 1 return length def process_zeta_series(test_cases): Processes multiple test cases to find the Zeta Series length for each. results = [] for x in test_cases: results.append(zeta_series_length(x)) return results"},{"question":"def check_overlapping_shifts(n, shifts): Determines if there are any overlapping shifts in the given list of shifts. Parameters: n (int): The number of shifts. shifts (list of tuple): List of tuples where each tuple contains start and end time of a shift. Returns: str: \\"Yes\\" if there are overlapping shifts, otherwise \\"No\\". Examples: >>> check_overlapping_shifts(3, [(0, 60), (70, 130), (60, 120)]) 'No' >>> check_overlapping_shifts(3, [(0, 60), (50, 110), (120, 180)]) 'Yes'","solution":"def check_overlapping_shifts(n, shifts): Determines if there are any overlapping shifts in the given list of shifts. Parameters: n (int): The number of shifts. shifts (list of tuple): List of tuples where each tuple contains start and end time of a shift. Returns: str: \\"Yes\\" if there are overlapping shifts, otherwise \\"No\\". # Sort shifts by start time shifts.sort() # Check for overlaps for i in range(1, n): # Compare the end time of the previous shift with the start time of the current shift if shifts[i][0] < shifts[i-1][1]: return \\"Yes\\" return \\"No\\""},{"question":"def length_of_longest_increasing_subsequence(prices): Given a list of stock prices, returns the length of the longest subsequence where each consecutive element is greater than the previous one. def process_test_cases(test_cases): Processes multiple test cases. def main(input_lines): Main function to process the input and produce the output. # Example usage: # input_lines = [ # \\"2\\", # \\"6\\", # \\"1 2 1 5 2 3\\", # \\"5\\", # \\"5 1 1 2 3\\" # ] # main(input_lines)","solution":"def length_of_longest_increasing_subsequence(prices): Given a list of stock prices, returns the length of the longest subsequence where each consecutive element is greater than the previous one. if not prices: return 0 n = len(prices) dp = [1] * n for i in range(1, n): for j in range(i): if prices[i] > prices[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) def process_test_cases(test_cases): Processes multiple test cases. results = [] for n, prices in test_cases: results.append(length_of_longest_increasing_subsequence(prices)) return results def main(input_lines): Main function to process the input and produce the output. t = int(input_lines[0]) index = 1 test_cases = [] for _ in range(t): n = int(input_lines[index]) prices = list(map(int, input_lines[index + 1].split())) test_cases.append((n, prices)) index += 2 results = process_test_cases(test_cases) for result in results: print(result) # Example usage: # input_lines = [ # \\"2\\", # \\"6\\", # \\"1 2 1 5 2 3\\", # \\"5\\", # \\"5 1 1 2 3\\" # ] # main(input_lines)"},{"question":"def can_form_arithmetic_progression(n: int, arr: List[int]) -> str: Checks if it is possible to reorder the list to form an arithmetic progression. Args: n (int): The number of elements in the list. arr (list of int): The list of integers. Returns: str: \\"YES\\" if the list can be reordered to form an arithmetic progression, otherwise \\"NO\\". >>> can_form_arithmetic_progression(4, [3, 1, 2, 4]) 'YES' >>> can_form_arithmetic_progression(5, [1, 2, 4, 8, 16]) 'NO'","solution":"def can_form_arithmetic_progression(n, arr): Checks if it is possible to reorder the list to form an arithmetic progression. Args: n (int): The number of elements in the list. arr (list of int): The list of integers. Returns: str: \\"YES\\" if the list can be reordered to form an arithmetic progression, otherwise \\"NO\\". arr.sort() common_diff = arr[1] - arr[0] for i in range(1, n): if arr[i] - arr[i-1] != common_diff: return \\"NO\\" return \\"YES\\""},{"question":"def expand_string(s: str) -> str: Expands the compressed string using the format k[encoded_string]. >>> expand_string(\\"3[a]2[bc]\\") 'aaabcbc' >>> expand_string(\\"3[a2[c]]\\") 'accaccacc' >>> expand_string(\\"2[abc]3[cd]ef\\") 'abcabccdcdcdef' >>> expand_string(\\"10[a]\\") 'aaaaaaaaaa' >>> expand_string(\\"3[ab2[c]]\\") 'abccabccabcc' pass","solution":"def expand_string(s: str) -> str: Expands the compressed string using the format k[encoded_string]. stack = [] # Stack to hold current string segments and counts current_string = \\"\\" k = 0 # Current count that we are building for char in s: if char.isdigit(): k = k * 10 + int(char) elif char == '[': # Push the current segment and count to stack stack.append((current_string, k)) # Reset current string and count for the new segment current_string = \\"\\" k = 0 elif char == ']': # Pop from stack prev_string, repeat_count = stack.pop() # Expand the current_string current_string = prev_string + current_string * repeat_count else: current_string += char return current_string"},{"question":"class EmployeeSystem: def __init__(self): self.employees = {} def add_employee(self, emp_id: int, rating: int): Add an employee with a given ID and rating. pass def update_rating(self, emp_id: int, new_rating: int): Update the rating of an existing employee. pass def find_top_rated_employee(self) -> int: Find the ID of the top-rated employee. If there is a tie, return the smallest ID. If there are no employees, return None. pass def process_queries(queries: List[str]) -> List[int]: Process the given list of queries and return the results for 'T' queries. Example: >>> queries = [ 'A 101 200', 'A 202 350', 'T', 'U 202 150', 'T' ] >>> process_queries(queries) [202, 101] pass","solution":"class EmployeeSystem: def __init__(self): self.employees = {} def add_employee(self, emp_id, rating): self.employees[emp_id] = rating def update_rating(self, emp_id, new_rating): if emp_id in self.employees: self.employees[emp_id] = new_rating def find_top_rated_employee(self): if not self.employees: return None top_rating = max(self.employees.values()) top_employees = [emp_id for emp_id, rating in self.employees.items() if rating == top_rating] return min(top_employees) def process_queries(queries): system = EmployeeSystem() results = [] for query in queries: parts = query.split() if parts[0] == 'A': emp_id, rating = int(parts[1]), int(parts[2]) system.add_employee(emp_id, rating) elif parts[0] == 'U': emp_id, new_rating = int(parts[1]), int(parts[2]) system.update_rating(emp_id, new_rating) elif parts[0] == 'T': top_emp_id = system.find_top_rated_employee() results.append(top_emp_id) return results"},{"question":"def min_prizes(N: int, problems: List[int]) -> int: Calculate the minimum number of prizes needed to distribute according to the conditions. Every student must receive at least one prize. Any student who has solved more problems than an adjacent student receives more prizes than the adjacent student. Args: N (int): The number of students. problems (List[int]): List of integers representing the number of problems solved by each student. Returns: int: The minimum number of prizes required. >>> min_prizes(4, [1, 2, 2, 3]) 6 >>> min_prizes(3, [3, 2, 1]) 6 # Example usage # N = 4 # problems = [1, 2, 2, 3] # print(min_prizes(N, problems)) # Output: 6 from solution import min_prizes def test_sample_input(): N = 4 problems = [1, 2, 2, 3] assert min_prizes(N, problems) == 6 def test_all_same(): N = 5 problems = [2, 2, 2, 2, 2] assert min_prizes(N, problems) == 5 def test_strictly_increasing(): N = 3 problems = [1, 2, 3] assert min_prizes(N, problems) == 6 def test_strictly_decreasing(): N = 3 problems = [3, 2, 1] assert min_prizes(N, problems) == 6 def test_increasing_then_decreasing(): N = 5 problems = [1, 2, 3, 2, 1] assert min_prizes(N, problems) == 9 def test_single_student(): N = 1 problems = [5] assert min_prizes(N, problems) == 1","solution":"def min_prizes(N, problems): if N == 0: return 0 prizes = [1] * N # Left to right pass for i in range(1, N): if problems[i] > problems[i-1]: prizes[i] = prizes[i-1] + 1 # Right to left pass for i in range(N-2, -1, -1): if problems[i] > problems[i+1] and prizes[i] <= prizes[i+1]: prizes[i] = prizes[i+1] + 1 return sum(prizes) # Example usage # N = 4 # problems = [1, 2, 2, 3] # print(min_prizes(N, problems)) # Output: 6"},{"question":"def min_total_time(N, times): Returns the minimum total time for a single team to complete the relay race. :param N: Integer, number of participants :param times: List of lists, each containing four integers representing the time a participant takes for segments S1, S2, S3, and S4 respectively. :return: Integer, minimum possible total time for a team to complete the relay >>> min_total_time(6, [ ... [5, 9, 3, 8], ... [3, 7, 6, 12], ... [8, 5, 4, 9], ... [6, 2, 8, 10], ... [7, 4, 10, 11], ... [4, 6, 7, 5] ... ]) == 13 >>> min_total_time(4, [ ... [10, 20, 30, 40], ... [15, 25, 35, 45], ... [20, 30, 40, 50], ... [25, 35, 45, 55] ... ]) == 100 >>> min_total_time(4, [ ... [1, 2, 3, 4], ... [2, 3, 4, 1], ... [3, 4, 1, 2], ... [4, 1, 2, 3] ... ]) == 4 >>> min_total_time(5, [ ... [10, 15, 20, 25], ... [11, 14, 19, 24], ... [12, 13, 18, 23], ... [13, 12, 17, 22], ... [14, 11, 16, 21] ... ]) == 58","solution":"def min_total_time(N, times): Returns the minimum total time for a single team to complete the relay race. # Sort each segment's times individually S1_times = sorted([times[i][0] for i in range(N)]) S2_times = sorted([times[i][1] for i in range(N)]) S3_times = sorted([times[i][2] for i in range(N)]) S4_times = sorted([times[i][3] for i in range(N)]) # Sum the smallest times from each segment return S1_times[0] + S2_times[0] + S3_times[0] + S4_times[0] # Function to handle input directly def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) times = [] for i in range(N): times.append([int(data[4 * i + 1]), int(data[4 * i + 2]), int(data[4 * i + 3]), int(data[4 * i + 4])]) print(min_total_time(N, times)) # Example usage # if __name__ == \\"__main__\\": # main()"},{"question":"def product_except_self(nums): Given an array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([4, 3, 2, 1]) [6, 8, 12, 24] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_except_self([1, 1, 1, 1]) [1, 1, 1, 1] >>> product_except_self([2, 0, 2]) [0, 4, 0]","solution":"def product_except_self(nums): Given an array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. n = len(nums) if n < 2 or n > 1000: return [] # Create two auxiliary arrays left_products = [1] * n right_products = [1] * n answer = [1] * n # Fill the left_products array for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] # Fill the right_products array for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Construct the answer array for i in range(n): answer[i] = left_products[i] * right_products[i] return answer def parse_input(input_str): lines = input_str.splitlines() n = int(lines[0]) nums = list(map(int, lines[1].split())) return n, nums def format_output(result): return ' '.join(map(str, result))"},{"question":"from collections import defaultdict, deque def find_course_order(N: int, M: int, prerequisites: List[Tuple[int, int]]) -> Union[List[int], str]: Given a number of courses and a list of prerequisite pairs, determine the order in which you can complete the courses. If it is impossible to complete all the courses, return IMPOSSIBLE. >>> find_course_order(4, 3, [(1, 0), (2, 0), (3, 1)]) [3, 1, 2, 0] >>> find_course_order(4, 2, [(1, 0), (0, 1)]) 'IMPOSSIBLE' def test_sample_input_1(): N, M = 4, 3 prerequisites = [(1, 0), (2, 0), (3, 1)] result = find_course_order(N, M, prerequisites) assert result == [3, 1, 2, 0] or result == [2, 3, 1, 0] def test_sample_input_2(): N, M = 4, 2 prerequisites = [(1, 0), (0, 1)] result = find_course_order(N, M, prerequisites) assert result == \\"IMPOSSIBLE\\" def test_no_prerequisites(): N, M = 3, 0 prerequisites = [] result = find_course_order(N, M, prerequisites) assert result == [0, 1, 2] or result == [0, 2, 1] or result == [1, 0, 2] or result == [1, 2, 0] or result == [2, 0, 1] or result == [2, 1, 0] def test_all_courses_independent(): N, M = 5, 0 prerequisites = [] result = find_course_order(N, M, prerequisites) assert set(result) == set(range(N)) def test_complex_case(): N, M = 5, 4 prerequisites = [(0, 1), (1, 2), (2, 3), (3, 4)] result = find_course_order(N, M, prerequisites) assert result == [0, 1, 2, 3, 4] def test_cycle_detected(): N, M = 3, 3 prerequisites = [(0, 1), (1, 2), (2, 0)] result = find_course_order(N, M, prerequisites) assert result == \\"IMPOSSIBLE\\" def test_large_case(): N, M = 1000, 0 prerequisites = [] result = find_course_order(N, M, prerequisites) assert set(result) == set(range(N))","solution":"from collections import defaultdict, deque def find_course_order(N, M, prerequisites): # Create a graph and a list to keep track of in-degrees graph = defaultdict(list) in_degree = [0] * N # Build the graph and in-degree list for a, b in prerequisites: graph[a].append(b) in_degree[b] += 1 # Use a queue to perform topological sort queue = deque([i for i in range(N) if in_degree[i] == 0]) order = [] while queue: current = queue.popleft() order.append(current) for neighbor in graph[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # Check if we were able to order all courses if len(order) == N: return order else: return \\"IMPOSSIBLE\\""},{"question":"class RangeSearch: A class to support range search operations. Methods: 1. add(int num): Adds a number to the data structure. 2. rangeQuery(int start, int end): Returns the count of numbers that fall within the inclusive range [start, end]. Examples: >>> rs = RangeSearch() >>> rs.add(10) >>> rs.add(20) >>> rs.add(15) >>> rs.rangeQuery(10, 20) 3 >>> rs.rangeQuery(15, 25) 2 >>> rs.add(25) >>> rs.rangeQuery(15, 25) 3 def __init__(self): pass def add(self, num): pass def rangeQuery(self, start, end): pass from solution import RangeSearch def test_add_and_range_query(): rs = RangeSearch() rs.add(10) rs.add(20) rs.add(15) assert rs.rangeQuery(10, 20) == 3 assert rs.rangeQuery(15, 25) == 2 rs.add(25) assert rs.rangeQuery(15, 25) == 3 def test_empty_range_search(): rs = RangeSearch() assert rs.rangeQuery(0, 10) == 0 def test_add_duplicate_numbers(): rs = RangeSearch() rs.add(10) rs.add(10) rs.add(10) assert rs.rangeQuery(5, 15) == 3 assert rs.rangeQuery(10, 10) == 3 def test_range_query_outside_bounds(): rs = RangeSearch() rs.add(5) rs.add(15) rs.add(-5) assert rs.rangeQuery(20, 30) == 0 assert rs.rangeQuery(-10, -6) == 0 def test_range_query_with_all_negative_numbers(): rs = RangeSearch() rs.add(-10) rs.add(-20) rs.add(-30) assert rs.rangeQuery(-25, -15) == 1 assert rs.rangeQuery(-35, -15) == 2 assert rs.rangeQuery(-40, -5) == 3","solution":"import bisect class RangeSearch: def __init__(self): self.data = [] def add(self, num): bisect.insort(self.data, num) def rangeQuery(self, start, end): left_index = bisect.bisect_left(self.data, start) right_index = bisect.bisect_right(self.data, end) return right_index - left_index"},{"question":"class CustomQueue: def __init__(self): self.queue = [] def enqueue(self, x): Add element x to the end of the queue. self.queue.append(x) def dequeue(self): Remove the front element from the queue. If the queue is empty, print -1. if len(self.queue) == 0: print(-1) else: self.queue.pop(0) def front(self): Print the front element of the queue. If the queue is empty, print -1. if len(self.queue) == 0: print(-1) else: print(self.queue[0]) def size(self): Print the size of the queue. print(len(self.queue)) def process_commands(n, commands): :param n: Integer representing the number of commands. :param commands: List of commands as strings. >>> commands = [\\"enqueue 5\\", \\"enqueue 3\\", \\"front\\", \\"dequeue\\", \\"front\\", \\"size\\"] >>> process_commands(6, commands) 5 3 1 que = CustomQueue() for command in commands: if command.startswith('enqueue'): _, x = command.split() que.enqueue(int(x)) elif command == 'dequeue': que.dequeue() elif command == 'front': que.front() elif command == 'size': que.size()","solution":"class CustomQueue: def __init__(self): self.queue = [] def enqueue(self, x): self.queue.append(x) def dequeue(self): if len(self.queue) == 0: print(-1) else: self.queue.pop(0) def front(self): if len(self.queue) == 0: print(-1) else: print(self.queue[0]) def size(self): print(len(self.queue)) def process_commands(n, commands): que = CustomQueue() for command in commands: if command.startswith('enqueue'): _, x = command.split() que.enqueue(int(x)) elif command == 'dequeue': que.dequeue() elif command == 'front': que.front() elif command == 'size': que.size()"},{"question":"import math from typing import List def calculate_distance(commands: List[str]) -> float: Calculate the Euclidean distance of a robot from the initial position (0, 0) after executing a sequence of commands. :param commands: List of string commands which can be \\"UP\\", \\"DOWN\\", \\"LEFT\\", \\"RIGHT\\" :return: Euclidean distance from the initial position rounded to 2 decimal places >>> calculate_distance([\\"UP\\", \\"RIGHT\\", \\"DOWN\\", \\"LEFT\\"]) 0.00 >>> calculate_distance([\\"UP\\", \\"UP\\", \\"UP\\", \\"RIGHT\\"]) 3.16 pass def main(test_cases: List[str]) -> List[str]: Given multiple test cases with sequences of commands, determine the Euclidean distance for each sequence from the initial position. :param test_cases: List of strings, where each string is a sequence of commands :return: List of strings representing the Euclidean distances rounded to 2 decimal places >>> test_cases = [\\"UP RIGHT DOWN LEFT\\", \\"UP UP UP RIGHT\\"] >>> main(test_cases) [\\"0.00\\", \\"3.16\\"] pass","solution":"import math def calculate_distance(commands): Calculate the Euclidean distance of a robot from the initial position (0, 0) after executing a sequence of commands. :param commands: List of string commands which can be \\"UP\\", \\"DOWN\\", \\"LEFT\\", \\"RIGHT\\" :return: Euclidean distance from the initial position rounded to 2 decimal places x, y = 0, 0 for command in commands: if command == \\"UP\\": y += 1 elif command == \\"DOWN\\": y -= 1 elif command == \\"LEFT\\": x -= 1 elif command == \\"RIGHT\\": x += 1 distance = math.sqrt(x**2 + y**2) return round(distance, 2) def main(test_cases): results = [] for commands in test_cases: command_list = commands.split() distance = calculate_distance(command_list) results.append(\\"{:.2f}\\".format(distance)) return results"},{"question":"from typing import List def multiply_next(lst: List[int]) -> List[int]: Write a function that takes a list of integers and returns a new list where each element in the original list is multiplied by the next element in the list. The last element should be multiplied by the first element. Args: lst (list): A list of integers. Returns: list: A new list with the multiplied values. >>> multiply_next([1, 2, 3, 4]) [2, 6, 12, 4] >>> multiply_next([0, 5, 10]) [0, 50, 0] >>> multiply_next([7]) [49] >>> multiply_next([]) [] >>> multiply_next([-1, 2, -3, 4]) [-2, -6, -12, -4] >>> multiply_next([0, 0, 0, 0]) [0, 0, 0, 0]","solution":"def multiply_next(lst): Returns a new list where each element in the original list is multiplied by the next element in the list. The last element is multiplied by the first element. Args: lst (list): A list of integers. Returns: list: A new list with the multiplied values. if not lst: return [] if len(lst) == 1: return [lst[0] * lst[0]] return [lst[i] * lst[(i + 1) % len(lst)] for i in range(len(lst))]"},{"question":"def largest_non_adjacent_sum(nums: List[int]) -> int: Given an array of integers, compute the largest sum of non-adjacent numbers. >>> largest_non_adjacent_sum([2, 4, 6, 2, 5]) 13 >>> largest_non_adjacent_sum([5, 1, 1, 5]) 10 >>> largest_non_adjacent_sum([2, 1, 2, 7, 3]) 9 >>> largest_non_adjacent_sum([4, 1, 1, 4]) 8 >>> largest_non_adjacent_sum([5, 5, 10, 100, 10, 5]) 110 >>> largest_non_adjacent_sum([]) 0","solution":"def largest_non_adjacent_sum(nums): if not nums: return 0 if len(nums) == 1: return nums[0] if len(nums) == 2: return max(nums) prev_one = max(nums[0], nums[1]) prev_two = nums[0] for i in range(2, len(nums)): current = max(prev_one, prev_two + nums[i]) prev_two = prev_one prev_one = current return prev_one"},{"question":"def subarray_contains_all(N, M, arr): Determines if there exists a subarray of length M that contains all integers from 1 to M exactly once. :param N: The length of the array. :param M: The length of the desired subarray. :param arr: The list of integers. :return: \\"Yes\\" if such a subarray exists, otherwise \\"No\\". from solution import subarray_contains_all def test_subarray_exists(): assert subarray_contains_all(6, 3, [3, 1, 2, 3, 2, 1]) == \\"Yes\\" def test_subarray_with_full_length(): assert subarray_contains_all(5, 4, [4, 3, 2, 1, 3]) == \\"Yes\\" def test_subarray_does_not_exist(): assert subarray_contains_all(5, 3, [1, 3, 1, 2, 2]) == \\"No\\" def test_minimum_length(): assert subarray_contains_all(1, 1, [1]) == \\"Yes\\" def test_large_array_no_subarray(): N = 100000 M = 2 arr = [1] * N assert subarray_contains_all(N, M, arr) == \\"No\\" def test_large_array_with_subarray(): N = 100000 M = 2 arr = [1 if i % 2 == 0 else 2 for i in range(N)] assert subarray_contains_all(N, M, arr) == \\"Yes\\"","solution":"def subarray_contains_all(N, M, arr): Determines if there exists a subarray of length M that contains all integers from 1 to M exactly once. :param N: The length of the array. :param M: The length of the desired subarray. :param arr: The list of integers. :return: \\"Yes\\" if such a subarray exists, otherwise \\"No\\". if M > N: return \\"No\\" required_set = set(range(1, M+1)) current_set = set(arr[:M]) if current_set == required_set: return \\"Yes\\" for i in range(M, N): current_set.discard(arr[i - M]) # Remove the element that is sliding out current_set.add(arr[i]) # Add the new element that is sliding in if current_set == required_set: return \\"Yes\\" return \\"No\\""},{"question":"def minimum_operations_to_sort(a): Determines the minimum number of operations needed to sort the array in non-decreasing order. :param a: List[int] - input array of integers :return: int - minimum number of operations needed to sort the array >>> minimum_operations_to_sort([4, 3, 2, 5, 1]) 3 >>> minimum_operations_to_sort([1, 2, 3, 4, 5]) 0 >>> minimum_operations_to_sort([5, 4, 3, 2, 1]) 4","solution":"def minimum_operations_to_sort(a): Determines the minimum number of operations needed to sort the array in non-decreasing order. n = len(a) sorted_a = sorted(a) if a == sorted_a: return 0 longest_sorted_subarray_length = 0 current_sorted_subarray_length = 1 for i in range(1, n): if a[i] >= a[i - 1]: current_sorted_subarray_length += 1 else: longest_sorted_subarray_length = max(longest_sorted_subarray_length, current_sorted_subarray_length) current_sorted_subarray_length = 1 longest_sorted_subarray_length = max(longest_sorted_subarray_length, current_sorted_subarray_length) return n - longest_sorted_subarray_length"},{"question":"def largestString(s: str, k: int) -> str: Find the largest lexicographical string by changing at most k characters in the string. Parameters: s (str): Input string consisting of lowercase English alphabets. k (int): Maximum number of characters that can be changed. Returns: str: The largest lexicographical string that can be obtained. Examples: >>> largestString(\\"abcde\\", 2) 'zzcde' >>> largestString(\\"abcd\\", 1) 'zbcd' >>> largestString(\\"abcde\\", 0) 'abcde' >>> largestString(\\"abcdef\\", 6) 'zzzzzz' >>> largestString(\\"abcdef\\", 3) 'zzzdef' >>> largestString(\\"a\\" * 100000, 50000) 'z' * 50000 + 'a' * 50000 >>> largestString(\\"a\\", 1) 'z' >>> largestString(\\"a\\", 0) 'a'","solution":"def largestString(s, k): Find the largest lexicographical string by changing at most k characters in the string. Parameters: s (str): Input string consisting of lowercase English alphabets. k (int): Maximum number of characters that can be changed. Returns: str: The largest lexicographical string that can be obtained. s_list = list(s) changes = 0 # Iterate over the string for i in range(len(s_list)): if changes < k: # Determine the highest possible character to replace current one with highest_possible = 'z' # If changing the current character helps (i.e., it is not 'z') if s_list[i] != highest_possible: s_list[i] = highest_possible changes += 1 return ''.join(s_list)"},{"question":"morse_code = { 'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.', ' ': ' ' } def morse_encrypt(text: str) -> str: Encrypts the given string text into Morse code. >>> morse_encrypt('HELLO') '.... . .-.. .-.. ---' >>> morse_encrypt('HELLO WORLD') '.... . .-.. .-.. --- .-- --- .-. .-.. -..' >>> morse_encrypt('HELLO 123') '.... . .-.. .-.. --- .---- ..--- ...--' pass def morse_decrypt(morse: str) -> str: Decrypts the given Morse code string back into a readable string. >>> morse_decrypt('.... . .-.. .-.. ---') 'HELLO' >>> morse_decrypt('.... . .-.. .-.. --- .-- --- .-. .-.. -..') 'HELLO WORLD' >>> morse_decrypt('.... . .-.. .-.. --- .---- ..--- ...--') 'HELLO 123' pass","solution":"morse_code = { 'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.', ' ': ' ' } def morse_encrypt(text: str) -> str: Encrypts the given string text into Morse code. return ' '.join(morse_code[char] for char in text) def morse_decrypt(morse: str) -> str: Decrypts the given Morse code string back into a readable string. reverse_morse_code = {v: k for k, v in morse_code.items()} words = morse.split(' ') decoded_words = [] for word in words: decoded_chars = ''.join(reverse_morse_code[char] for char in word.split()) decoded_words.append(decoded_chars) return ' '.join(decoded_words)"},{"question":"def remove_duplicates(nums): Modifies the array nums in place to remove duplicates such that each unique element appears at most twice and returns the new length of the array. >>> nums1 = [1,1,1,2,2,3] >>> remove_duplicates(nums1) 5 >>> nums1[:5] [1, 1, 2, 2, 3] >>> nums2 = [0,0,1,1,1,1,2,3,3] >>> remove_duplicates(nums2) 7 >>> nums2[:7] [0, 0, 1, 1, 2, 3, 3] >>> nums3 = [1, 1, 1, 1] >>> remove_duplicates(nums3) 2 >>> nums3[:2] [1, 1] >>> nums4 = [1, 2, 3, 4, 5] >>> remove_duplicates(nums4) 5 >>> nums4[:5] [1, 2, 3, 4, 5] >>> nums5 = [1] >>> remove_duplicates(nums5) 1 >>> nums5[:1] [1] >>> nums6 = [] >>> remove_duplicates(nums6) 0 >>> nums6 [] >>> nums7 = [1,1,2,2,2,3,3,3,4,4,4,4,5,5,5,5,5] >>> remove_duplicates(nums7) 10 >>> nums7[:10] [1, 1, 2, 2, 3, 3, 4, 4, 5, 5]","solution":"def remove_duplicates(nums): Modifies the array nums in place to remove duplicates such that each unique element appears at most twice and returns the new length of the array. if not nums: return 0 # Initialize the write pointer write_ptr = 1 # Count occurrences of the current number count = 1 for i in range(1, len(nums)): if nums[i] == nums[i - 1]: count += 1 else: count = 1 if count <= 2: nums[write_ptr] = nums[i] write_ptr += 1 return write_ptr"},{"question":"def group_students_by_score(input_list): Receives a list of tuples, each containing a student's name and their score. Returns a dictionary where keys are unique scores, and values are lists of names of students who achieved each score. The names in the lists are sorted alphabetically. >>> group_students_by_score([(\\"Alice\\", 85), (\\"Bob\\", 75), (\\"Cathy\\", 85), (\\"David\\", 60)]) {85: [\\"Alice\\", \\"Cathy\\"], 75: [\\"Bob\\"], 60: [\\"David\\"]} >>> group_students_by_score([]) {} >>> group_students_by_score([(\\"Alice\\", 85)]) {85: [\\"Alice\\"]} >>> group_students_by_score([(\\"Alice\\", 85), (\\"Bob\\", 85), (\\"Cathy\\", 85)]) {85: [\\"Alice\\", \\"Bob\\", \\"Cathy\\"]} >>> group_students_by_score([(\\"Alice\\", 85), (\\"Bob\\", 90), (\\"Cathy\\", 85), (\\"David\\", 90), (\\"Eva\\", 60)]) {85: [\\"Alice\\", \\"Cathy\\"], 90: [\\"Bob\\", \\"David\\"], 60: [\\"Eva\\"]}","solution":"def group_students_by_score(input_list): Receives a list of tuples, each containing a student's name and their score. Returns a dictionary where keys are unique scores, and values are lists of names of students who achieved each score. The names in the lists are sorted alphabetically. score_dict = {} for name, score in input_list: if score not in score_dict: score_dict[score] = [] score_dict[score].append(name) # Sort the names in each list alphabetically for score in score_dict: score_dict[score].sort() return score_dict"},{"question":"def battleship_game(hidden_x, hidden_y, guesses): Simulates a Battleship game on a 5x5 grid with a single hidden battleship. :param hidden_x: int - The x-coordinate of the hidden battleship. :param hidden_y: int - The y-coordinate of the hidden battleship. :param guesses: List of tuples - Each tuple contains the x and y coordinates of a guess. :return: A list of strings containing the result of each guess and the game outcome. >>> battleship_game(2, 3, [(1, 1), (2, 3)]) [\\"Guess 1 1:\\", \\"Miss\\", \\"Guess 2 3:\\", \\"Hit!\\", \\"You sank my battleship!\\"] >>> battleship_game(3, 0, [(0, 0), (1, 4), (2, 2), (3, 3), (0, 1), (2, 3), (1, 1)]) [\\"Guess 0 0:\\", \\"Miss\\", \\"Guess 1 4:\\", \\"Miss\\", \\"Guess 2 2:\\", \\"Miss\\", \\"Guess 3 3:\\", \\"Miss\\", \\"Guess 0 1:\\", \\"Miss\\", \\"Guess 2 3:\\", \\"Miss\\", \\"Guess 1 1:\\", \\"Miss\\", \\"Game Over!\\"]","solution":"def battleship_game(hidden_x, hidden_y, guesses): Simulates a Battleship game on a 5x5 grid with a single hidden battleship. :param hidden_x: int - The x-coordinate of the hidden battleship. :param hidden_y: int - The y-coordinate of the hidden battleship. :param guesses: List of tuples - Each tuple contains the x and y coordinates of a guess. :return: A list of strings containing the result of each guess and the game outcome. # Maximum number of attempts max_attempts = 8 # List to store the output output = [] for attempt in range(min(len(guesses), max_attempts)): guess_x, guess_y = guesses[attempt] output.append(f\\"Guess {guess_x} {guess_y}:\\") if guess_x == hidden_x and guess_y == hidden_y: output.append(\\"Hit!\\") output.append(\\"You sank my battleship!\\") return output else: output.append(\\"Miss\\") output.append(\\"Game Over!\\") return output"},{"question":"def is_almost_palindrome(string: str) -> bool: Determines if the given string is an almost palindrome. >>> is_almost_palindrome(\\"abca\\") \\"YES\\" >>> is_almost_palindrome(\\"abcd\\") \\"NO\\" >>> is_almost_palindrome(\\"racecar\\") \\"YES\\" >>> is_almost_palindrome(\\"a\\") \\"YES\\" >>> is_almost_palindrome(\\"ab\\") \\"YES\\" pass def solution_case(input_strings: List[str]) -> List[str]: Given a list of strings consisting of lowercase English letters only, returns a list of strings \\"YES\\" if the string is an almost palindrome or \\"NO\\" if it is not. >>> solution_case([\\"abca\\", \\"abcd\\", \\"racecar\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> solution_case([\\"a\\", \\"b\\"]) [\\"YES\\", \\"YES\\"] >>> solution_case([\\"acbca\\", \\"abcdba\\", \\"abcdeba\\", \\"aa\\", \\"ab\\"]) [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\"] >>> solution_case([\\"aaaaaaa\\"]) [\\"YES\\"] >>> solution_case([\\"aabbccddccbaa\\", \\"abcdefghij\\", \\"xyyx\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] pass","solution":"def is_almost_palindrome(string): Determines if the given string is an almost palindrome. def is_palindrome_modified(s, left, right, modified): # Return True if this snippet is a palindrome or can be made into one with at most one modification while left < right: if s[left] != s[right]: if modified: return False return is_palindrome_modified(s, left + 1, right, True) or is_palindrome_modified(s, left, right - 1, True) left += 1 right -= 1 return True return is_palindrome_modified(string, 0, len(string) - 1, False) def solution_case(input_strings): results = [] for string in input_strings: if is_almost_palindrome(string): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def count_elements_greater_than_x(arr, queries): For each query, return the number of elements in arr greater than the given number in the query. >>> count_elements_greater_than_x([1, 2, 3, 4, 5, 6], [2, 4, 5]) [4, 2, 1] >>> count_elements_greater_than_x([10, 20, 30, 40, 50], [25, 35, 45]) [3, 2, 1] >>> count_elements_greater_than_x([7, 12, 5, 18, 25], [10, 15, 20]) [3, 2, 1] >>> count_elements_greater_than_x([8, 8, 8, 8, 8], [7, 8, 9]) [5, 0, 0] >>> count_elements_greater_than_x([1], [0, 1, 2]) [1, 0, 0]","solution":"def count_elements_greater_than_x(arr, queries): For each query, return the number of elements in arr greater than the given number in the query. arr.sort() results = [] for x in queries: left = 0 right = len(arr) while left < right: mid = (left + right) // 2 if arr[mid] <= x: left = mid + 1 else: right = mid results.append(len(arr) - left) return results"},{"question":"def max_treasures(M: int, N: int, sx: int, sy: int, grid: List[List[str]]) -> int: Given the dimensions of the grid MxN, the starting position (sx, sy) of the hunter, and the layout of the map, determine the maximum number of treasures the hunter can collect. >>> max_treasures(4, 4, 0, 0, [['E', 'T', 'E', 'O'], ['T', 'E', 'E', 'T'], ['E', 'E', 'O', 'E'], ['O', 'T', 'E', 'E']]) 4 >>> max_treasures(3, 3, 1, 1, [['E', 'O', 'E'], ['O', 'E', 'O'], ['E', 'O', 'E']]) 0 >>> max_treasures(3, 3, 0, 0, [['E', 'E', 'E'], ['E', 'T', 'E'], ['E', 'E', 'E']]) 1","solution":"def max_treasures(M, N, sx, sy, grid): from collections import deque # Directions array for moving in the grid directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS initialization queue = deque([(sx, sy)]) visited = set([(sx, sy)]) treasures_collected = 0 while queue: x, y = queue.popleft() if grid[x][y] == 'T': treasures_collected += 1 grid[x][y] = 'E' # Mark the treasure as collected for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < M and 0 <= ny < N and (nx, ny) not in visited and grid[nx][ny] != 'O': visited.add((nx, ny)) queue.append((nx, ny)) return treasures_collected # Example input: # M, N = 4, 4 # sx, sy = 0, 0 # grid = [ # ['E', 'T', 'E', 'O'], # ['T', 'E', 'E', 'T'], # ['E', 'E', 'O', 'E'], # ['O', 'T', 'E', 'E'], # ] # print(max_treasures(M, N, sx, sy, grid)) # Expected output: 4"},{"question":"def update_inventory(inventory: dict, transactions: list) -> dict: Update inventory based on transactions. Raise an Exception if any transaction results in negative inventory. Parameters: inventory (dict): Dictionary with product IDs as keys and stock levels as values. transactions (list): List of tuples where each tuple contains a product ID and a quantity change. Returns: dict: Updated inventory after applying all transactions. Raises: Exception: If any transaction results in a negative stock level for any product. Example: >>> inventory = {101: 50, 102: 75, 103: 20} >>> transactions = [(101, -30), (102, 50), (103, -10)] >>> update_inventory(inventory, transactions) {101: 20, 102: 125, 103: 10} # your code here","solution":"def update_inventory(inventory: dict, transactions: list) -> dict: Update inventory based on transactions. Raise an Exception if any transaction results in negative inventory. Parameters: inventory (dict): Dictionary with product IDs as keys and stock levels as values. transactions (list): List of tuples where each tuple contains a product ID and a quantity change. Returns: dict: Updated inventory after applying all transactions. Raises: Exception: If any transaction results in a negative stock level for any product. for product_id, quantity_change in transactions: if product_id in inventory: inventory[product_id] += quantity_change if inventory[product_id] < 0: raise Exception(product_id) else: if quantity_change < 0: raise Exception(product_id) inventory[product_id] = quantity_change return inventory"},{"question":"def find_max_difference(n: int, candies: List[int]) -> int: Find the maximum difference between the number of candies in two boxes such that the box with lesser candies comes before the box with more candies. >>> find_max_difference(5, [1, 9, 2, 4, 6]) 8 >>> find_max_difference(4, [4, 3, 2, 1]) -1","solution":"def find_max_difference(n, candies): Finds the maximum difference between the number of candies in two boxes such that the box with lesser candies comes before the box with more candies. if n < 2: return -1 min_candies = candies[0] max_difference = -1 for i in range(1, n): if candies[i] > min_candies: max_difference = max(max_difference, candies[i] - min_candies) min_candies = min(min_candies, candies[i]) return max_difference"},{"question":"def contains_all_vowels(s: str) -> bool: Determine if a given string contains all the vowels (a, e, i, o, u) at least once. >>> contains_all_vowels(\\"education\\") True >>> contains_all_vowels(\\"sequoia\\") True >>> contains_all_vowels(\\"hello world\\") False >>> contains_all_vowels(\\"sky\\") False >>> contains_all_vowels(\\"\\") False >>> contains_all_vowels(\\"reeducation\\") True >>> contains_all_vowels(\\"aeeeiosuuuu\\") True >>> contains_all_vowels(\\"a\\") False >>> contains_all_vowels(\\"e\\") False >>> contains_all_vowels(\\"i\\") False >>> contains_all_vowels(\\"o\\") False >>> contains_all_vowels(\\"u\\") False >>> contains_all_vowels(\\"aieou\\") True >>> contains_all_vowels(\\"aaeeiioo\\") False","solution":"def contains_all_vowels(s): Returns True if the input string contains all the vowels (a, e, i, o, u) at least once. Otherwise, returns False. vowels = set('aeiou') return vowels.issubset(set(s))"},{"question":"def min_risk_traps(n: int, m: int, tunnels: List[Tuple[int, int, int]], start: int, end: int) -> int: Returns the minimum total risk level of deactivating traps necessary to make a path from the start room to the end room. If there is no path from the start room to the end room, returns -1. >>> min_risk_traps(3, 3, [(1, 2, 4), (1, 3, 2), (2, 3, 1)], 1, 3) 2 >>> min_risk_traps(4, 4, [(1, 2, 3), (2, 3, 1), (3, 4, 5), (1, 4, 10)], 1, 4) 9 >>> min_risk_traps(2, 1, [(1, 2, 0)], 1, 2) 0 >>> min_risk_traps(4, 2, [(1, 2, 5), (3, 4, 7)], 1, 4) -1","solution":"import heapq from collections import defaultdict def min_risk_traps(n, m, tunnels, start, end): Returns the minimum total risk level of deactivating traps necessary to make a path from the start room to the end room. If there is no path from the start room to the end room, returns -1. graph = defaultdict(list) # Build the graph for u, v, w in tunnels: graph[u].append((w, v)) graph[v].append((w, u)) # Use Dijkstra's algorithm to find the shortest path from start to end based on risk levels min_risk = {i: float('inf') for i in range(1, n+1)} min_risk[start] = 0 priority_queue = [(0, start)] while priority_queue: current_risk, u = heapq.heappop(priority_queue) if current_risk > min_risk[u]: continue for risk, v in graph[u]: new_risk = current_risk + risk if new_risk < min_risk[v]: min_risk[v] = new_risk heapq.heappush(priority_queue, (new_risk, v)) return min_risk[end] if min_risk[end] != float('inf') else -1"},{"question":"def max_total_power(n: int, power_levels: List[int]) -> int: Given n participants with their respective power levels, determine the maximum possible total power of the winning participants by optimally pairing them up. >>> max_total_power(4, [10, 20, 30, 40]) == 70 >>> max_total_power(6, [1, 3, 2, 6, 5, 4]) == 15 >>> max_total_power(4, [10, 10, 10, 10]) == 20 >>> max_total_power(2, [1, 2]) == 2 >>> max_total_power(6, [1000, 1000, 1000, 1000, 1000, 1000]) == 3000 >>> max_total_power(8, [1, 8, 7, 6, 5, 4, 3, 2]) == 26 >>> max_total_power(2, [99, 100]) == 100","solution":"def max_total_power(n, power_levels): Given n participants with their respective power levels, determine the maximum possible total power of the winning participants by optimally pairing them up. Parameters: n: int - the number of participants (always even) power_levels: list of int - power levels of the participants Returns: int - the maximum possible total power of the winning participants. power_levels.sort() total_power = 0 for i in range(n // 2): total_power += power_levels[n - 1 - i] return total_power"},{"question":"def partition_cards(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: You are given a list of integers representing cards with different values. Your task is to find out whether it is possible to partition the list into two subsets such that the sum of the elements in both subsets is the same. Input: The first line contains an integer T, the number of test cases. Each test case begins with a blank line. The first line of each test case contains an integer N which represents the number of cards. The second line contains N integers, representing the card values. Output: For each test case, output a single line with a single word \\"POSSIBLE\\" if the cards can be partitioned into two subsets with equal sums, or \\"IMPOSSIBLE\\" otherwise. SAMPLE INPUT 2 4 1 5 11 5 3 1 2 5 SAMPLE OUTPUT POSSIBLE IMPOSSIBLE >>> partition_cards(2, [(4, [1, 5, 11, 5]), (3, [1, 2, 5])]) [\\"POSSIBLE\\", \\"IMPOSSIBLE\\"]","solution":"def can_partition_equal_subset(nums): total_sum = sum(nums) # If the total sum is odd, we cannot split it into two equal sum subsets if total_sum % 2 != 0: return False subset_sum = total_sum // 2 n = len(nums) dp = [[False] * (subset_sum + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, subset_sum + 1): if nums[i-1] > j: dp[i][j] = dp[i-1][j] else: dp[i][j] = dp[i-1][j] or dp[i-1][j - nums[i-1]] return dp[n][subset_sum] def partition_cards(T, test_cases): results = [] for case_index in range(T): N, nums = test_cases[case_index] if can_partition_equal_subset(nums): results.append(\\"POSSIBLE\\") else: results.append(\\"IMPOSSIBLE\\") return results"},{"question":"def mostFrequentSubstring(s: str, k: int) -> str: Implement a function which will receive a string and an integer k for input, and return the most frequently occurring substring of length k. If there are multiple substrings with the same frequency, return the lexicographically smallest one. >>> mostFrequentSubstring(\\"ababc\\", 2) 'ab' >>> mostFrequentSubstring(\\"abacabadabacaba\\", 3) 'aba' >>> mostFrequentSubstring(\\"xyzxyyz\\", 2) 'xy'","solution":"def mostFrequentSubstring(s, k): from collections import defaultdict substring_count = defaultdict(int) for i in range(len(s) - k + 1): substring = s[i:i+k] substring_count[substring] += 1 max_count = max(substring_count.values()) most_frequent_substrings = [sub for sub, count in substring_count.items() if count == max_count] return min(most_frequent_substrings)"},{"question":"def is_armstrong_number(n: int) -> bool: Returns True if n is an Armstrong number, otherwise False. >>> is_armstrong_number(153) True >>> is_armstrong_number(123) False","solution":"def is_armstrong_number(n): Returns True if n is an Armstrong number, otherwise False. # Convert n to a string to easily iterate over digits num_str = str(n) # Calculate the number of digits num_digits = len(num_str) # Calculate the Armstrong sum armstrong_sum = sum(int(digit) ** num_digits for digit in num_str) return armstrong_sum == n"},{"question":"def calculate_stamp_area(T: int, cases: List[Tuple[int, int]]) -> List[int]: Calculate the total area of stamp collections. T: int - Number of test cases. cases: list of tuples - Each tuple contains two integers (A, B) representing the number of small and large stamps respectively. Returns: list of int - List of total areas for each test case. >>> calculate_stamp_area(2, [(3, 2), (1, 4)]) == [16, 22] >>> calculate_stamp_area(1, [(0, 0)]) == [0]","solution":"def calculate_stamp_area(T, cases): Calculate the total area of stamp collections. T: int - Number of test cases. cases: list of tuples - Each tuple contains two integers (A, B). Returns: list of int - List of total areas for each test case. areas = [] for A, B in cases: total_area = A * 2 + B * 5 areas.append(total_area) return areas"},{"question":"def findMaxAverage(nums: List[int], k: int) -> float: Find a contiguous subarray of length \`k\` that has the maximum average value and return the maximum average. >>> findMaxAverage([1, 12, -5, -6, 50, 3], 4) 12.75 >>> findMaxAverage([1, 2, 3, 4, 5], 2) 4.5 >>> findMaxAverage([-1, -2, -3, -4, -5], 1) -1.0 >>> findMaxAverage([5, 1, 3, 2, 4], 5) 3.0 >>> findMaxAverage([3, 3, 3, 3], 1) 3.0 >>> findMaxAverage([], 1) 0.0 >>> findMaxAverage([7, 8, 9, 1, 2, 3], 6) 5.0","solution":"def findMaxAverage(nums, k): Returns the maximum average of a contiguous subarray of length \`k\` in the given array \`nums\`. n = len(nums) if n == 0: return 0.0 # edge case when nums is empty # Compute the sum of the first \`k\` elements current_sum = sum(nums[:k]) max_sum = current_sum # Use sliding window to compute sums of subarrays of length \`k\` for i in range(k, n): current_sum += nums[i] - nums[i - k] max_sum = max(max_sum, current_sum) return max_sum / k"},{"question":"from typing import List, Tuple def are_three_points_collinear(x1: int, y1: int, x2: int, y2: int, x3: int, y3: int) -> bool: Determine if three points are collinear. >>> are_three_points_collinear(0, 0, 1, 1, 2, 2) True >>> are_three_points_collinear(1, 5, 3, 5, 5, 5) True >>> are_three_points_collinear(-1, -1, 0, 1, 1, 1) False def check_connectivity(test_cases: List[Tuple[int, int, int, int, int, int]]) -> List[str]: For a list of test cases, determine if the factories are connectable by a straight road. >>> check_connectivity([(0, 0, 1, 1, 2, 2), (1, 5, 3, 5, 5, 5), (-1, -1, 0, 1, 1, 1)]) ['CONNECTED', 'CONNECTED', 'DISCONNECTED']","solution":"def are_three_points_collinear(x1, y1, x2, y2, x3, y3): Returns True if the points (x1, y1), (x2, y2), and (x3, y3) are collinear, otherwise False. # Calculate the area of the triangle formed by the three points # If the area is 0, then the points are collinear area = x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) return area == 0 def check_connectivity(test_cases): results = [] for case in test_cases: x1, y1, x2, y2, x3, y3 = case if are_three_points_collinear(x1, y1, x2, y2, x3, y3): results.append(\\"CONNECTED\\") else: results.append(\\"DISCONNECTED\\") return results"},{"question":"def min_operations_to_make_elements_equal(n: int, arr: List[int]) -> int: Returns the minimum number of operations required to make all elements in the array equal. >>> min_operations_to_make_elements_equal(4, [4, 6, 3, 1]) 3 >>> min_operations_to_make_elements_equal(1, [5]) 0 >>> min_operations_to_make_elements_equal(5, [2, 2, 2, 2, 2]) 0 >>> min_operations_to_make_elements_equal(2, [1, 2]) 1 >>> min_operations_to_make_elements_equal(100000, [1] * 100000) 0 >>> min_operations_to_make_elements_equal(100000, list(range(1, 100001))) 99999","solution":"from collections import Counter def min_operations_to_make_elements_equal(n, arr): Returns the minimum number of operations required to make all elements in the array equal. # Frequency of each element in the array frequency = Counter(arr) # Maximum frequency of any single element max_frequency = max(frequency.values()) # Minimum operations are the total elements minus the maximum frequency return n - max_frequency"},{"question":"def is_valid_seating(n: int, m: int, seating: List[str]) -> str: Determines if the seating arrangement is valid based on the given rules. Args: n (int): number of rows. m (int): number of columns. seating (list of str): seating layout where each string represents a row. Returns: str: 'YES' if the arrangement is valid, 'NO' otherwise. Examples: >>> is_valid_seating(3, 3, ['.X.', '...', '.X.']) == 'YES' >>> is_valid_seating(3, 3, ['.XX', 'X..', '..X']) == 'NO' >>> is_valid_seating(3, 3, ['.X.', '.X.', '.X.']) == 'NO'","solution":"def is_valid_seating(n, m, seating): Determines if the seating arrangement is valid based on the given rules. Args: n (int): number of rows. m (int): number of columns. seating (list of str): seating layout where each string represents a row. Returns: str: 'YES' if the arrangement is valid, 'NO' otherwise. for i in range(n): for j in range(m): if seating[i][j] == 'X': # Check horizontally if j + 1 < m and seating[i][j + 1] == 'X': return 'NO' # Check vertically if i + 1 < n and seating[i + 1][j] == 'X': return 'NO' return 'YES'"},{"question":"def min_palindrome_partition(s: str) -> int: Given a string consisting of lowercase Latin letters, find the minimum number of palindromic substrings into which it can be split. >>> min_palindrome_partition(\\"aab\\") 2 >>> min_palindrome_partition(\\"racecarannakayak\\") 3 >>> min_palindrome_partition(\\"banana\\") 2 >>> min_palindrome_partition(\\"aba\\") 1 >>> min_palindrome_partition(\\"abcd\\") 4 def generate_partitions(s: str): Given a string consisting of lowercase Latin letters, output all possible ways to split this string into the minimum number of palindromic substrings. >>> count, partitions = generate_partitions(\\"aab\\") >>> count 2 >>> partitions [['aa', 'b']] >>> count, partitions = generate_partitions(\\"racecarannakayak\\") >>> count 3 >>> partitions [['racecar', 'anna', 'kayak']] >>> count, partitions = generate_partitions(\\"banana\\") >>> count 2 >>> partitions [['b', 'anana']] >>> count, partitions = generate_partitions(\\"aba\\") >>> count 1 >>> partitions [['aba']] >>> count, partitions = generate_partitions(\\"abcd\\") >>> count 4 >>> partitions [['a', 'b', 'c', 'd']]","solution":"def is_palindrome(s): return s == s[::-1] def min_palindrome_partition(s): n = len(s) dp = [[0 for _ in range(n)] for _ in range(n)] cut = [0 for _ in range(n)] for i in range(n): min_cut = i for j in range(i + 1): if s[j:i + 1] == s[j:i + 1][::-1]: min_cut = 0 if j == 0 else min(min_cut, cut[j - 1] + 1) cut[i] = min_cut return cut[-1] + 1 def generate_partitions(s): def dfs(start, current_partition, result): if start >= len(s): result.append(current_partition[:]) return for end in range(start, len(s)): if is_palindrome(s[start:end + 1]): current_partition.append(s[start:end + 1]) dfs(end + 1, current_partition, result) current_partition.pop() result = [] dfs(0, [], result) min_cut = min_palindrome_partition(s) partitions = [partition for partition in result if len(partition) == min_cut] return min_cut, partitions # Example Usage: # print(min_palindrome_partition(\\"aab\\")) # print(generate_partitions(\\"aab\\"))"},{"question":"def can_segment_passwords(n: int, passwords: List[str], hacker_string: str) -> str: Determines if the hacker_string can be segmented into the given passwords in sequence. >>> can_segment_passwords(3, [\\"hack\\", \\"code\\", \\"secure\\"], \\"hackcodesecure\\") \\"YES\\" >>> can_segment_passwords(2, [\\"hack\\", \\"code\\"], \\"haackcode\\") \\"NO\\"","solution":"def can_segment_passwords(n, passwords, hacker_string): Determines if the hacker_string can be segmented into the given passwords in sequence. Args: n (int): Number of passwords. passwords (list of str): List of passwords. hacker_string (str): The character string the hacker is attempting to use. Returns: str: \\"YES\\" if the string can be segmented into the passwords in the given order, otherwise \\"NO\\". index = 0 for password in passwords: if hacker_string.startswith(password, index): index += len(password) else: return \\"NO\\" return \\"YES\\" if index == len(hacker_string) else \\"NO\\""},{"question":"def count_ways(n: int) -> int: Returns the number of different ways to produce exactly n milliliters using pipette sizes 1, 3, and 4. >>> count_ways(4) 4 >>> count_ways(5) 6 >>> count_ways(1) 1 >>> count_ways(0) 1 >>> count_ways(10) 64 pass def number_of_ways_to_dispense(T: int, test_cases: List[int]) -> List[int]: For each test case, outputs the number of ways to produce exactly N milliliters using pipettes of sizes 1, 3, and 4. >>> number_of_ways_to_dispense(2, [4, 5]) [4, 6] >>> number_of_ways_to_dispense(3, [1, 2, 3]) [1, 1, 2] >>> number_of_ways_to_dispense(1, [0]) [1] >>> number_of_ways_to_dispense(1, [10]) [64] pass","solution":"def count_ways(n): Returns the number of different ways to produce exactly n milliliters using pipette sizes 1, 3, and 4. if n == 0: return 1 # Initialize dp array dp = [0] * (n + 1) dp[0] = 1 # There's one way to make 0 milliliters: do nothing for i in range(1, n + 1): dp[i] = dp[i-1] if i >= 3: dp[i] += dp[i-3] if i >= 4: dp[i] += dp[i-4] return dp[n] def number_of_ways_to_dispense(T, test_cases): results = [] for N in test_cases: results.append(count_ways(N)) return results"},{"question":"def sort_employees_by_score(n: int, employees: List[Tuple[int, str]]) -> List[Tuple[int, str]]: Sorts employees based on their performance scores in a stable manner. :param n: int - the number of employees :param employees: list - list of tuples (score, name) :return: list - sorted list of tuples (score, name) >>> sort_employees_by_score(4, [(60, 'alice'), (75, 'steve'), (60, 'bob'), (95, 'john')]) [(60, 'alice'), (60, 'bob'), (75, 'steve'), (95, 'john')] >>> sort_employees_by_score(1, [(50, 'alice')]) [(50, 'alice')] >>> sort_employees_by_score(3, [(50, 'alice'), (50, 'bob'), (50, 'charlie')]) [(50, 'alice'), (50, 'bob'), (50, 'charlie')] >>> sort_employees_by_score(4, [(20, 'dave'), (50, 'alice'), (75, 'bob'), (90, 'charlie')]) [(20, 'dave'), (50, 'alice'), (75, 'bob'), (90, 'charlie')] >>> sort_employees_by_score(4, [(90, 'charlie'), (75, 'bob'), (50, 'alice'), (20, 'dave')]) [(20, 'dave'), (50, 'alice'), (75, 'bob'), (90, 'charlie')]","solution":"def sort_employees_by_score(n, employees): Sorts employees based on their performance scores in a stable manner. :param n: int - the number of employees :param employees: list - list of tuples (score, name) :return: list - sorted list of tuples (score, name) return sorted(employees, key=lambda x: x[0])"},{"question":"def consolidate_logs(n: int, logs: List[Tuple[int, str]]) -> List[Tuple[int, str]]: Process the list of logs and remove consecutive duplicates. Parameters: n (int): Number of log entries. logs (list of tuple): List of log entries where each log entry is represented by a timestamp and a message. Returns: list of tuple: Processed list of log entries with consecutive duplicates removed. >>> consolidate_logs(5, [(1, \\"Error: Disk not found\\"), (2, \\"Error: Disk not found\\"), (3, \\"Info: Disk check starting\\"), (4, \\"Info: Disk check starting\\"), (5, \\"Error: Disk not found\\")]) [(1, \\"Error: Disk not found\\"), (3, \\"Info: Disk check starting\\"), (5, \\"Error: Disk not found\\")] >>> consolidate_logs(4, [(1, \\"Warning: Low memory\\"), (2, \\"Warning: Low memory\\"), (3, \\"Warning: Low memory\\"), (4, \\"Error: Out of memory\\")]) [(1, \\"Warning: Low memory\\"), (4, \\"Error: Out of memory\\")]","solution":"def consolidate_logs(n, logs): Process the list of logs and remove consecutive duplicates. Parameters: n (int): Number of log entries. logs (list of tuple): List of log entries where each log entry is represented by a timestamp and a message. Returns: list of tuple: Processed list of log entries with consecutive duplicates removed. if n == 0: return [] unique_logs = [logs[0]] for i in range(1, n): if logs[i][1] != logs[i - 1][1]: unique_logs.append(logs[i]) return unique_logs"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bstInsert(root, data): Given a binary tree and a node value called data, insert the data into the tree maintaining the properties of a Binary Search Tree (BST). Example 1: >>> tree = TreeNode(40) >>> tree.left = TreeNode(20) >>> tree.right = TreeNode(60) >>> tree.left.left = TreeNode(10) >>> tree.left.right = TreeNode(30) >>> tree.right.left = TreeNode(50) >>> tree.right.right = TreeNode(70) >>> result = bstInsert(tree, 25) >>> tree_to_list(result) [40, 20, 60, 10, 30, 50, 70, None, None, 25] Example 2: >>> tree = TreeNode(15) >>> tree.left = TreeNode(10) >>> tree.right = TreeNode(20) >>> result = bstInsert(tree, 13) >>> tree_to_list(result) [15, 10, 20, None, 13]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bstInsert(root, data): if root is None: return TreeNode(data) if data < root.val: root.left = bstInsert(root.left, data) else: root.right = bstInsert(root.right, data) return root"},{"question":"def min_cost_hamiltonian_cycle(n: int, cost: List[List[int]]) -> int: Calculates the minimum travel cost to visit all cities once and return to the starting city. >>> min_cost_hamiltonian_cycle(4, [ ... [0, 10, 15, 20], ... [10, 0, 35, 25], ... [15, 35, 0, 30], ... [20, 25, 30, 0]]) 80 >>> min_cost_hamiltonian_cycle(2, [ ... [0, 3], ... [3, 0]]) 6 pass def solve_itineraries(datasets: List[Tuple[int, List[List[int]]]]) -> List[int]: Solves multiple datasets to find the minimum travel cost for a complete tour. >>> solve_itineraries([ ... (4, [ ... [0, 10, 15, 20], ... [10, 0, 35, 25], ... [15, 35, 0, 30], ... [20, 25, 30, 0] ... ]), ... (2, [ ... [0, 3], ... [3, 0] ... ]), ... (0, []) ... ]) [80, 6] pass","solution":"from itertools import permutations def min_cost_hamiltonian_cycle(n, cost): Calculates the minimum travel cost to visit all cities once and return to the starting city. min_cost = float('inf') # Generate all possible permutations of city indices, starting from city 0 cities = list(range(n)) for perm in permutations(cities[1:]): current_cost = 0 current_perm = [0] + list(perm) + [0] # Calculate the travel cost for this permutation for i in range(len(current_perm) - 1): current_cost += cost[current_perm[i]][current_perm[i+1]] # Update the minimum cost min_cost = min(min_cost, current_cost) return min_cost def solve_itineraries(datasets): results = [] for dataset in datasets: n, costs = dataset if n == 0: break results.append(min_cost_hamiltonian_cycle(n, costs)) return results"},{"question":"def has_subarray_with_sum(N: int, S: int, sequence: List[int]) -> str: Determines if there exists a contiguous subarray whose sum equals S. >>> has_subarray_with_sum(5, 10, [1, 2, 3, 4, 5]) \\"YES\\" >>> has_subarray_with_sum(5, 20, [1, 2, 3, 4, 5]) \\"NO\\"","solution":"def has_subarray_with_sum(N, S, sequence): Determines if there exists a contiguous subarray whose sum equals S. :param N: Integer, length of the sequence. :param S: Integer, the given sum to check. :param sequence: List of integers, the sequence of numbers. :return: str, \\"YES\\" if such a subarray exists, otherwise \\"NO\\". # Initialize pointers and the current sum start = 0 current_sum = 0 for end in range(N): current_sum += sequence[end] # Check if current_sum exceeds S while current_sum > S and start <= end: current_sum -= sequence[start] start += 1 # Check if we found a subarray with the required sum if current_sum == S: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List, Tuple def count_connected_components(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Calculates the number of connected components in an undirected graph. :param n: Number of vertices :param m: Number of edges :param edges: List of edges :return: Number of connected components >>> count_connected_components(6, 3, [(1, 2), (2, 3), (4, 5)]) == 3 >>> count_connected_components(4, 0, []) == 4 >>> count_connected_components(1, 0, []) == 1 >>> count_connected_components(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) == 1 >>> count_connected_components(6, 2, [(1, 2), (3, 4)]) == 4","solution":"def count_connected_components(n, m, edges): Calculates the number of connected components in an undirected graph. :param n: Number of vertices :param m: Number of edges :param edges: List of edges :return: Number of connected components from collections import defaultdict, deque def bfs(start, visited, graph): queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False]*(n+1) # Index 0 is unused since vertices are 1-based count = 0 for vertex in range(1, n+1): if not visited[vertex]: bfs(vertex, visited, graph) count += 1 return count"},{"question":"from typing import List def count_unique_alphabetical_characters(S: str) -> int: Returns the number of unique alphabetical characters in string S (case insensitive). >>> count_unique_alphabetical_characters(\\"Hello, World!\\") == 7 >>> count_unique_alphabetical_characters(\\"1234 easy as ABC\\") == 6","solution":"def count_unique_alphabetical_characters(S): Returns the number of unique alphabetical characters in string S (case insensitive). unique_chars = set() for char in S: if char.isalpha(): unique_chars.add(char.lower()) return len(unique_chars)"},{"question":"def find_rewarded_students(num_students: int, students_grades: list) -> list: Returns the names of students who will receive a reward based on their grades. Parameters: - num_students (int): The number of students. - students_grades (list of tuples): A list of (student_name, grade) tuples. Returns: - list of strings: Names of students who will receive a reward, sorted alphabetically. >>> find_rewarded_students(5, [(\\"Alice\\", 50), (\\"Bob\\", 40), (\\"Charlie\\", 60), (\\"David\\", 70), (\\"Eve\\", 30)]) [\\"Alice\\", \\"Charlie\\", \\"David\\"] >>> find_rewarded_students(3, [(\\"Alice\\", 60), (\\"Bob\\", 60), (\\"Charlie\\", 60)]) [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] >>> find_rewarded_students(4, [(\\"Alice\\", 10), (\\"Bob\\", 20), (\\"Charlie\\", 30), (\\"David\\", 40)]) [\\"Charlie\\", \\"David\\"] >>> find_rewarded_students(1, [(\\"Alice\\", 80)]) [\\"Alice\\"] >>> find_rewarded_students(3, [(\\"alice\\", 50), (\\"Bob\\", 50), (\\"charlie\\", 50)]) [\\"alice\\", \\"Bob\\", \\"charlie\\"]","solution":"def find_rewarded_students(num_students, students_grades): Returns the names of students who will receive a reward based on their grades. Parameters: - num_students (int): The number of students. - students_grades (list of tuples): A list of (student_name, grade) tuples. Returns: - list of strings: Names of students who will receive a reward, sorted alphabetically. total_grades = sum(grade for _, grade in students_grades) average_grade = total_grades / num_students rewarded_students = [name for name, grade in students_grades if grade >= average_grade] rewarded_students.sort(key=lambda x: x.lower()) return rewarded_students"},{"question":"def can_find_equal_subset_sums(n: int, measurements: List[int]) -> str: Determine whether there's any subset of the measurements that sum to the same value. excluding the empty subset. >>> can_find_equal_subset_sums(4, [1, 2, 3, 6]) 'YES' >>> can_find_equal_subset_sums(3, [1, 1, 1]) 'YES' >>> can_find_equal_subset_sums(3, [1, 5, 7]) 'NO' from solution import can_find_equal_subset_sums def test_example_1(): assert can_find_equal_subset_sums(4, [1, 2, 3, 6]) == \\"YES\\" def test_example_2(): assert can_find_equal_subset_sums(3, [1, 1, 1]) == \\"YES\\" def test_example_3(): assert can_find_equal_subset_sums(3, [1, 5, 7]) == \\"NO\\" def test_single_measurement(): assert can_find_equal_subset_sums(1, [10]) == \\"NO\\" def test_no_duplicate_subsets(): assert can_find_equal_subset_sums(5, [1, 2, 4, 8, 16]) == \\"NO\\" def test_multiple_equal_subsets(): assert can_find_equal_subset_sums(4, [2, 4, 2, 6]) == \\"YES\\" def test_large_numbers(): assert can_find_equal_subset_sums(4, [100, 200, 300, 600]) == \\"YES\\"","solution":"def can_find_equal_subset_sums(n, measurements): from itertools import combinations subset_sums = {} # Generate all subsets except the empty subset for i in range(1, n + 1): for subset in combinations(measurements, i): subset_sum = sum(subset) if subset_sum in subset_sums: return \\"YES\\" subset_sums[subset_sum] = subset return \\"NO\\""},{"question":"def can_form_palindrome(s: str) -> bool: Given a string consisting of lowercase English letters, determine if it can be permuted to form a palindrome. A string is said to be a palindrome if it reads the same backward as forward. >>> can_form_palindrome(\\"carrace\\") True >>> can_form_palindrome(\\"daily\\") False","solution":"from collections import Counter def can_form_palindrome(s: str) -> bool: Returns True if the string s can be permuted to form a palindrome, else False. char_count = Counter(s) # A string can form a palindrome if at most one character has an odd count. odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"def shortest_char_sequence(s: str) -> str: Returns the shortest sequence that contains all distinct characters in the input string s. Examples: >>> sorted(shortest_char_sequence('abbacad')) == sorted('bacd') True >>> sorted(shortest_char_sequence('abcdabababcd')) == sorted('abcd') True >>> sorted(shortest_char_sequence('aabbcc')) == sorted('abc') True >>> sorted(shortest_char_sequence('abacb')) == sorted('acb') True >>> sorted(shortest_char_sequence('aaaa')) == sorted('a') True >>> sorted(shortest_char_sequence('b')) == sorted('b') True >>> sorted(shortest_char_sequence('abracadabra')) == sorted('abrcd') True >>> sorted(shortest_char_sequence('xyzxyz')) == sorted('xyz') True >>> shortest_char_sequence('') == '' True >>> sorted(shortest_char_sequence('a!@#a!@#')) == sorted('a!@#') True","solution":"def shortest_char_sequence(s): Returns the shortest sequence that contains all distinct characters in the input string s. return ''.join(set(s))"},{"question":"def simplify_path(path: str) -> str: Simplify a given Unix-style file path. Args: path (str): The given path to be simplified. Returns: str: The simplified absolute path. Examples: >>> simplify_path(\\"/home/\\") \\"/home\\" >>> simplify_path(\\"/../\\") \\"/\\" >>> simplify_path(\\"/home//foo/\\") \\"/home/foo\\" >>> simplify_path(\\"/a/./b/../../c/\\") \\"/c\\"","solution":"def simplify_path(path): Simplify a given Unix-style file path. Args: path (str): The given path to be simplified. Returns: str: The simplified absolute path. parts = path.split(\\"/\\") stack = [] for part in parts: if part == \\"..\\": if stack: stack.pop() elif part == \\".\\" or part == \\"\\": continue else: stack.append(part) return \\"/\\" + \\"/\\".join(stack)"},{"question":"def minimal_total_length(test_cases): Determine the minimal total length of hallways needed to connect all exhibits. Args: test_cases (List[Tuple[int, int, List[Tuple[int, int, int]]]]): A list of test cases. Each test case is represented as a tuple containing the number of exhibits \`n\`, the number of hallways \`m\`, and a list of \`m\` tuples each representing a hallway with two exhibits and a length. Returns: List[int]: A list of integers where each integer represents the minimal total length of hallways needed to connect all exhibits for the corresponding test case. Example: >>> minimal_total_length([ ... (4, 5, [ ... (1, 2, 1), ... (1, 3, 4), ... (2, 3, 2), ... (2, 4, 3), ... (3, 4, 5) ... ]), ... (5, 7, [ ... (1, 2, 2), ... (1, 3, 3), ... (1, 4, 4), ... (4, 5, 5), ... (2, 3, 2), ... (3, 4, 1), ... (2, 5, 8) ... ]), ... (3, 3, [ ... (1, 2, 2), ... (2, 3, 3), ... (1, 3, 1) ... ]) ... ]) [6, 10, 3]","solution":"import heapq def minimal_total_length(test_cases): def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 results = [] for n, m, edges in test_cases: edges.sort(key=lambda x: x[2]) parent = list(range(n)) rank = [0] * n total_cost = 0 edges_included = 0 for u, v, w in edges: u -= 1 v -= 1 root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: union(parent, rank, root_u, root_v) total_cost += w edges_included += 1 if edges_included == n - 1: break results.append(total_cost) return results def parse_input(input_lines): t = int(input_lines[0]) current_line = 1 test_cases = [] for _ in range(t): n, m = map(int, input_lines[current_line].split()) current_line += 1 edges = [] for _ in range(m): u, v, w = map(int, input_lines[current_line].split()) edges.append((u, v, w)) current_line += 1 test_cases.append((n, m, edges)) return test_cases if __name__ == \\"__main__\\": import sys input_data = sys.stdin.read().strip().split(\\"n\\") test_cases = parse_input(input_data) result = minimal_total_length(test_cases) for r in result: print(r)"},{"question":"def min_operations_to_equalize(nums: List[int]) -> int: Calculate the minimum number of operations required to make all the numbers in the list equal. Args: nums (list of int): A list of integers. Returns: int: The minimum number of operations required to make all numbers equal. >>> min_operations_to_equalize([1, 2, 3]) 2 >>> min_operations_to_equalize([10, 10, 10]) 0 >>> min_operations_to_equalize([1, 10, 2, 9]) 16","solution":"def min_operations_to_equalize(nums): Calculate the minimum number of operations required to make all the numbers in the list equal. Args: nums (list of int): A list of integers. Returns: int: The minimum number of operations required to make all numbers equal. nums.sort() median = nums[len(nums) // 2] return sum(abs(num - median) for num in nums)"},{"question":"def min_intersections(n: int, logbook: List[int]) -> int: Returns the minimum number of intersections in the city that can accommodate Anna's logbook entries without any repeated visits to intersections. :param n: The number of logbook entries :param logbook: A list of integers representing the intersections visited in order :return: The minimum number of intersections >>> min_intersections(5, [1, 2, 3, 4, 2]) 4 >>> min_intersections(6, [1, 3, 1, 2, 4, 3]) 4 pass","solution":"def min_intersections(n, logbook): Returns the minimum number of intersections in the city that can accommodate Anna's logbook entries without any repeated visits to intersections. :param n: The number of logbook entries :param logbook: A list of integers representing the intersections visited in order :return: The minimum number of intersections unique_intersections = set(logbook) return len(unique_intersections)"},{"question":"def least_frequent_char(s: str) -> str: Write a function that takes a string as input and returns the character that appears least frequently in the string. If there are multiple characters with the same frequency, return the character that appears first in the string. The input string will contain only lowercase alphabets. Examples: >>> least_frequent_char(\\"abacabad\\") \\"c\\" >>> least_frequent_char(\\"hello\\") \\"h\\" >>> least_frequent_char(\\"aabbccdd\\") \\"a\\"","solution":"def least_frequent_char(s): from collections import Counter # Count the frequency of each character frequency = Counter(s) # Find the minimum frequency min_freq = min(frequency.values()) # Find the first character with the minimum frequency for char in s: if frequency[char] == min_freq: return char"},{"question":"def count_unique_paths(n: int, edges: List[Tuple[int, int]]) -> int: Given a tree with \`n\` nodes and a list of \`edges\` representing the edges between nodes, returns the total number of unique paths between any two distinct nodes in the tree. Args: n : int : number of nodes in the tree edges : list of tuple : list of edges, where each edge is represented by a tuple (ai, bi) Returns: int : the total number of unique paths >>> count_unique_paths(4, [(1, 2), (1, 3), (3, 4)]) 6 >>> count_unique_paths(5, [(1, 2), (2, 3), (2, 4), (4, 5)]) 10 >>> count_unique_paths(2, [(1, 2)]) 1 >>> count_unique_paths(3, [(1, 2), (1, 3)]) 3 >>> count_unique_paths(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) 10 >>> count_unique_paths(6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) 15 >>> n = 1000 >>> edges = [(i, i + 1) for i in range(1, n)] >>> count_unique_paths(n, edges) 499500","solution":"def count_unique_paths(n, edges): Given a tree with \`n\` nodes and a list of \`edges\` representing the edges between nodes, returns the total number of unique paths between any two distinct nodes in the tree. Args: n : int : number of nodes in the tree edges : list of tuple : list of edges, where each edge is represented by a tuple (ai, bi) Returns: int : the total number of unique paths # In a tree with n nodes, the number of unique paths between any two distinct nodes is n * (n - 1) / 2. return n * (n - 1) // 2"},{"question":"def min_distance_from_building(n, m, grid): Find the minimum distance from any building to any empty land in the grid. >>> min_distance_from_building(3, 3, [ ... [1, 0, 1], ... [0, 0, 0], ... [1, 0, 1] ... ]) 1 >>> min_distance_from_building(3, 3, [ ... [1, 1, 1], ... [1, 0, 1], ... [1, 1, 1] ... ]) 1 >>> min_distance_from_building(3, 3, [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) -1 >>> min_distance_from_building(3, 3, [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 1 >>> min_distance_from_building(4, 4, [ ... [1, 0, 0, 1], ... [0, 0, 1, 0], ... [0, 1, 0, 0], ... [1, 0, 0, 1] ... ]) 1 pass","solution":"from collections import deque def min_distance_from_building(n, m, grid): Find the minimum distance from any building to any empty land in the grid. if not grid or n == 0 or m == 0: return -1 def bfs(start_x, start_y): visited = [[False for _ in range(m)] for _ in range(n)] queue = deque([(start_x, start_y, 0)]) visited[start_x][start_y] = True min_distance = float('inf') while queue: x, y, dist = queue.popleft() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]: visited[nx][ny] = True if grid[nx][ny] == 0: min_distance = min(min_distance, dist + 1) elif grid[nx][ny] == 1: queue.append((nx, ny, dist + 1)) return min_distance min_dist = float('inf') for i in range(n): for j in range(m): if grid[i][j] == 1: min_dist = min(min_dist, bfs(i, j)) return min_dist if min_dist != float('inf') else -1"},{"question":"def is_self_dividing(number: int) -> bool: Determines whether a given number is a self-dividing number. A self-dividing number is a number that is divisible by every digit it contains. Args: number (int): The number to check. Returns: bool: True if the number is self-dividing, False otherwise. >>> is_self_dividing(128) True >>> is_self_dividing(26) False >>> is_self_dividing(0) False from solution import is_self_dividing def test_is_self_dividing_true_case(): assert is_self_dividing(128) == True def test_is_self_dividing_false_case(): assert is_self_dividing(26) == False def test_is_self_dividing_contains_zero(): assert is_self_dividing(102) == False def test_is_self_dividing_single_digit(): assert is_self_dividing(5) == True def test_is_self_dividing_larger_number_untrue(): assert is_self_dividing(130) == False def test_is_self_dividing_larger_number_true(): assert is_self_dividing(36) == True","solution":"def is_self_dividing(number): Determines whether a given number is a self-dividing number. A self-dividing number is a number that is divisible by every digit it contains. Args: number (int): The number to check. Returns: bool: True if the number is self-dividing, False otherwise. original_number = number while number > 0: digit = number % 10 if digit == 0 or original_number % digit != 0: return False number //= 10 return True"},{"question":"def largest_rectangle_of_H(grid: List[str]) -> int: Find the area of the largest rectangle consisting entirely of 'H's within the given grid. >>> largest_rectangle_of_H([ \\"TTTTT\\", \\"THHHH\\", \\"THHTT\\", \\"THHHH\\" ]) 6 >>> largest_rectangle_of_H([ \\"HHH\\", \\"HTH\\", \\"HHH\\" ]) 3","solution":"def calculate_max_histogram_area(heights): stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def largest_rectangle_of_H(grid): if not grid or not grid[0]: return 0 n = len(grid) m = len(grid[0]) hist = [0] * m max_rectangle_area = 0 for i in range(n): for j in range(m): hist[j] = hist[j] + 1 if grid[i][j] == 'H' else 0 max_rectangle_area = max(max_rectangle_area, calculate_max_histogram_area(hist)) return max_rectangle_area"},{"question":"def compute_repair_time(n: int, grid: List[str]) -> int: Computes the total time required to restore the damaged tracks in the grid. Parameters: n (int): The size of the grid (n x n) grid (list of str): The grid representation with '.' as undamaged and '#' as damaged Returns: int: Total time required to restore all damaged tracks Examples: >>> compute_repair_time(3, [\\".#.\\", \\"#\\", \\".#.\\"]) 5 >>> compute_repair_time(4, [\\"....\\", \\"....\\", \\"....\\", \\"....\\"]) 0 >>> compute_repair_time(5, [\\"#\\", \\".....\\", \\".....\\", \\".....\\", \\"#\\"]) 10 from typing import List def test_sample_input_1(): assert compute_repair_time(3, [ \\".#.\\", \\"#\\", \\".#.\\" ]) == 5 def test_sample_input_2(): assert compute_repair_time(4, [ \\"....\\", \\"....\\", \\"....\\", \\"....\\" ]) == 0 def test_sample_input_3(): assert compute_repair_time(5, [ \\"#\\", \\".....\\", \\".....\\", \\".....\\", \\"#\\" ]) == 10 def test_all_damaged(): assert compute_repair_time(3, [ \\"#\\", \\"#\\", \\"#\\" ]) == 9 def test_no_damaged(): assert compute_repair_time(3, [ \\"...\\", \\"...\\", \\"...\\" ]) == 0 def test_mixed_grid(): assert compute_repair_time(4, [ \\"#.#.\\", \\".#.#\\", \\"#.#.\\", \\".#.#\\" ]) == 8","solution":"def compute_repair_time(n, grid): Computes the total time required to restore the damaged tracks in the grid. Parameters: n (int): The size of the grid (n x n) grid (list of str): The grid representation with '.' as undamaged and '#' as damaged Returns: int: Total time required to restore all damaged tracks repair_time = 0 for row in grid: repair_time += row.count('#') return repair_time"},{"question":"def is_palindrome(number): Checks if the given number is a palindrome. return str(number) == str(number)[::-1] def smallest_palindrome(n): Finds the smallest palindrome number which is greater than or equal to n. >>> smallest_palindrome(120) 121 >>> smallest_palindrome(321) 323 >>> smallest_palindrome(99) 99 >>> smallest_palindrome(12321) 12321 >>> smallest_palindrome(123) 131 >>> smallest_palindrome(1) 1 >>> smallest_palindrome(10) 11 >>> smallest_palindrome(111) 111 >>> smallest_palindrome(1001) 1001 >>> smallest_palindrome(999) 999","solution":"def is_palindrome(number): Checks if the given number is a palindrome. return str(number) == str(number)[::-1] def smallest_palindrome(n): Finds the smallest palindrome number which is greater than or equal to n. while not is_palindrome(n): n += 1 return n"},{"question":"class StackWithMin: def __init__(self): self.stack = [] self.min_stack = [] def push(self, x): Push the integer x onto the stack. pass def pop(self): Remove the top element from the stack. If the stack is empty, ignore this operation. pass def min(self): Return the minimum value in the stack. If the stack is empty, return 'EMPTY'. pass def print_stack(self): Print the elements in the stack from top to bottom. If the stack is empty, return 'EMPTY'. pass def process_operations(operations): Process a list of operations on a stack with an added min operation. Args: operations (List[str]): A list of operations to be performed on the stack. Returns: str: The results of the operations 'min' and 'print' as a newline-separated string. Example: >>> process_operations([ \\"push 5\\", \\"push 2\\", \\"push 8\\", \\"min\\", \\"pop\\", \\"min\\", \\"push 1\\", \\"min\\", \\"print\\", \\"pop\\", \\"pop\\", \\"print\\" ]) \\"2n2n1n1 2 5n5\\" pass import sys if __name__ == '__main__': input = sys.stdin.read data = input().splitlines() n = int(data[0]) operations = data[1:] assert len(operations) == n result = process_operations(operations) if result: print(result)","solution":"class StackWithMin: def __init__(self): self.stack = [] self.min_stack = [] def push(self, x): self.stack.append(x) if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self): if not self.stack: return x = self.stack.pop() if x == self.min_stack[-1]: self.min_stack.pop() def min(self): if not self.min_stack: return \\"EMPTY\\" return self.min_stack[-1] def print_stack(self): if not self.stack: return \\"EMPTY\\" return \\" \\".join(map(str, reversed(self.stack))) def process_operations(operations): stack = StackWithMin() output = [] for op in operations: if op.startswith(\\"push\\"): _, x = op.split() stack.push(int(x)) elif op == \\"pop\\": stack.pop() elif op == \\"min\\": output.append(str(stack.min())) elif op == \\"print\\": output.append(stack.print_stack()) return \\"n\\".join(output) def main(): import sys input = sys.stdin.read data = input().splitlines() n = int(data[0]) operations = data[1:] assert len(operations) == n result = process_operations(operations) if result: print(result)"},{"question":"def is_prime(n: int) -> str: Determines if a given number n is a prime number. Returns \\"Prime\\" if the number is prime, and \\"Not Prime\\" otherwise. >>> is_prime(29) \\"Prime\\" >>> is_prime(14) \\"Not Prime\\" >>> is_prime(1) \\"Not Prime\\" >>> is_prime(2) \\"Prime\\" >>> is_prime(17) \\"Prime\\" >>> is_prime(18) \\"Not Prime\\" >>> is_prime(19) \\"Prime\\" def check_prime_numbers(numbers: List[int]) -> List[str]: Given a list of numbers, returns a list of results stating if the number is \\"Prime\\" or \\"Not Prime\\". >>> check_prime_numbers([29, 14, 0]) [\\"Prime\\", \\"Not Prime\\"] >>> check_prime_numbers([3, 5, 7, 11, 13, 0]) [\\"Prime\\", \\"Prime\\", \\"Prime\\", \\"Prime\\", \\"Prime\\"] >>> check_prime_numbers([4, 6, 8, 9, 10, 0]) [\\"Not Prime\\", \\"Not Prime\\", \\"Not Prime\\", \\"Not Prime\\", \\"Not Prime\\"] >>> check_prime_numbers([1, 2, 3, 4, 5, 6, 0]) [\\"Not Prime\\", \\"Prime\\", \\"Prime\\", \\"Not Prime\\", \\"Prime\\", \\"Not Prime\\"]","solution":"def is_prime(n): Determines if a given number n is a prime number. Returns \\"Prime\\" if the number is prime, and \\"Not Prime\\" otherwise. if n <= 1: return \\"Not Prime\\" if n == 2: return \\"Prime\\" if n % 2 == 0: return \\"Not Prime\\" limit = int(n ** 0.5) + 1 for i in range(3, limit, 2): if n % i == 0: return \\"Not Prime\\" return \\"Prime\\" def check_prime_numbers(numbers): Given a list of numbers, returns a list of results stating if the number is \\"Prime\\" or \\"Not Prime\\". results = [] for number in numbers: if number == 0: break results.append(is_prime(number)) return results"},{"question":"def final_sequence_length(N: int, sequence: List[int]) -> int: Determines the length of the final sequence after performing the operation where adjacent elements with different parity are removed. Parameters: N (int): The length of the sequence. sequence (list of int): The elements of the sequence. Returns: int: The length of the final sequence after performing operations. Examples: >>> final_sequence_length(5, [1, 2, 3, 4, 5]) 1 >>> final_sequence_length(4, [4, 5, 6, 7]) 0 from solution import final_sequence_length def test_sequence_example_1(): assert final_sequence_length(5, [1, 2, 3, 4, 5]) == 1 def test_sequence_example_2(): assert final_sequence_length(4, [4, 5, 6, 7]) == 0 def test_single_element(): assert final_sequence_length(1, [1]) == 1 assert final_sequence_length(1, [2]) == 1 def test_all_even_numbers(): assert final_sequence_length(5, [2, 4, 6, 8, 10]) == 5 def test_all_odd_numbers(): assert final_sequence_length(5, [1, 3, 5, 7, 9]) == 5 def test_alternating_even_odd(): assert final_sequence_length(6, [1, 2, 3, 4, 5, 6]) == 0 def test_alternating_odd_even(): assert final_sequence_length(6, [2, 1, 4, 3, 6, 5]) == 0","solution":"def final_sequence_length(N, sequence): Determines the length of the final sequence after performing the operation. Parameters: N (int): The length of the sequence. sequence (list of int): The elements of the sequence. Returns: int: The length of the final sequence after performing operations. stack = [] for num in sequence: if stack and (stack[-1] % 2 != num % 2): stack.pop() else: stack.append(num) return len(stack)"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring('abcabcbb') 3 >>> length_of_longest_substring('bbbbb') 1 >>> length_of_longest_substring('pwwkew') 3","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. if not s: return 0 n = len(s) char_map = {} left = 0 max_length = 0 for right in range(n): if s[right] in char_map: left = max(char_map[s[right]] + 1, left) char_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"def max_even_sum(n: int, alice_seq: List[int], bob_seq: List[int]) -> int: Determine the maximum possible even sum that can be achieved by the end of the game. >>> max_even_sum(3, [1, 2, 3], [4, 5, 6]) 20 >>> max_even_sum(2, [1, 1], [1, 1]) 4 >>> max_even_sum(4, [1, 3, 5, 7], [2, 4, 6, 8]) 36","solution":"def max_even_sum(n, alice_seq, bob_seq): # Sort both sequences in descending order alice_seq.sort(reverse=True) bob_seq.sort(reverse=True) total_sum = 0 # Iterate over the sequences and add the highest valued elements to total_sum for i in range(n): total_sum += alice_seq[i] total_sum += bob_seq[i] # If total_sum is even, return it, else find the best way to make it even if total_sum % 2 == 0: return total_sum else: # If total_sum is odd, we need to make it even by removing the smallest odd element or adding the smallest even # Min odd element from each of the sequences min_odd_alice = float('inf') min_odd_bob = float('inf') for num in alice_seq: if num % 2 != 0 and num < min_odd_alice: min_odd_alice = num for num in bob_seq: if num % 2 != 0 and num < min_odd_bob: min_odd_bob = num min_odd = min(min_odd_alice, min_odd_bob) # Try to switch the smallest odd element with the smallest from the other sequence min_diff_even = float('inf') for num in alice_seq: if num % 2 == 0: min_diff_even = min(min_diff_even, num) for num in bob_seq: if num % 2 == 0: min_diff_even = min(min_diff_even, num) if min_odd == float('inf'): return total_sum - min_diff_even return total_sum - min_odd"},{"question":"def is_palindrome(s: str) -> bool: Determines if a string is a palindrome, ignoring spaces, punctuation, and case. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"Able was I, ere I saw Elba\\") True","solution":"import re def is_palindrome(s: str) -> bool: Determines if a string is a palindrome, ignoring spaces, punctuation, and case. cleaned = re.sub(r'[^A-Za-z0-9]', '', s).lower() return cleaned == cleaned[::-1]"},{"question":"def find_diameter(n, edges): Calculate the diameter of a tree (the longest path between any two nodes). >>> find_diameter(4, [(1, 2), (2, 3), (3, 4)]) 3 >>> find_diameter(3, [(1, 2), (2, 3)]) 2 pass def min_possible_diameter(t, test_cases): Determine the minimum possible diameter after adding one road. >>> min_possible_diameter(2, [(4, [(1, 2), (2, 3), (3, 4)]), (3, [(1, 2), (2, 3)])]) [2, 2] def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) index = 1 test_cases = [] for _ in range(T): n = int(data[index]) edges = [] index += 1 for _ in range(n - 1): u = int(data[index]) v = int(data[index + 1]) edges.append((u, v)) index += 2 test_cases.append((n, edges)) results = min_possible_diameter(T, test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()","solution":"from collections import deque def find_diameter(n, edges): def bfs(start): visited = [-1] * n queue = deque([(start, 0)]) visited[start] = 0 farthest_node, max_distance = start, 0 while queue: node, dist = queue.popleft() for neighbor in graph[node]: if visited[neighbor] == -1: new_dist = dist + 1 visited[neighbor] = new_dist queue.append((neighbor, new_dist)) if new_dist > max_distance: max_distance = new_dist farthest_node = neighbor return farthest_node, max_distance graph = [[] for _ in range(n)] for u, v in edges: graph[u - 1].append(v - 1) graph[v - 1].append(u - 1) # Step 1: Find the farthest node from any node (we use node 0). farthest_node, _ = bfs(0) # Step 2: Find the farthest node from the farthest node found in step 1 (this gives diameter). farthest_node, diameter = bfs(farthest_node) return diameter def min_possible_diameter(t, test_cases): results = [] for test_case in test_cases: n = test_case[0] edges = test_case[1] current_diameter = find_diameter(n, edges) min_diameter = current_diameter // 2 + 1 results.append(min_diameter) return results def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) index = 1 test_cases = [] for _ in range(T): n = int(data[index]) edges = [] index += 1 for _ in range(n - 1): u = int(data[index]) v = int(data[index + 1]) edges.append((u, v)) index += 2 test_cases.append((n, edges)) results = min_possible_diameter(T, test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def isPalindrome(S: str) -> str: Returns \\"Yes\\" if the string S is a palindrome ignoring spaces, otherwise returns \\"No\\". >>> isPalindrome(\\"nurses run\\") \\"Yes\\" >>> isPalindrome(\\"hello there\\") \\"No\\" >>> isPalindrome(\\"a\\") \\"Yes\\" >>> isPalindrome(\\"a man a plan a canal panama\\") \\"Yes\\" >>> isPalindrome(\\"never odd or even\\") \\"Yes\\" >>> isPalindrome(\\"no lemon no melon\\") \\"Yes\\" >>> isPalindrome(\\"abc cba\\") \\"Yes\\" >>> isPalindrome(\\"abc bca\\") \\"No\\" >>> isPalindrome(\\"race car\\") \\"Yes\\" >>> isPalindrome(\\"not a palindrome\\") \\"No\\"","solution":"def isPalindrome(S: str) -> str: Returns \\"Yes\\" if the string S is a palindrome ignoring spaces, otherwise returns \\"No\\". # Remove spaces from the string cleaned_str = S.replace(\\" \\", \\"\\") # Compare the cleaned string with its reverse if cleaned_str == cleaned_str[::-1]: return \\"Yes\\" else: return \\"No\\""},{"question":"def max_books(n, widths, L): Determines the maximum number of books that can fit into the bookshelf without exceeding the width capacity. Args: n (int): Number of books. widths (list of int): List of widths of the books. L (int): Maximum width capacity of the bookshelf. Returns: int: Maximum number of books that can fit into the bookshelf. >>> max_books(5, [4, 2, 5, 6, 3], 10) 3 >>> max_books(4, [5, 1, 3, 2], 5) 2 >>> max_books(1, [5], 10) 1 >>> max_books(1, [10], 5) 0 >>> max_books(5, [1, 2, 2, 1, 1], 10) 5 >>> max_books(5, [5, 8, 3, 7, 2], 15) 3 >>> max_books(3, [15, 20, 25], 10) 0 >>> max_books(4, [2, 3, 4, 1], 10) 4 >>> max_books(6, [1, 1, 1, 1, 1, 1], 5) 5","solution":"def max_books(n, widths, L): Determines the maximum number of books that can fit into the bookshelf without exceeding the width capacity. Args: n (int): Number of books. widths (list of int): List of widths of the books. L (int): Maximum width capacity of the bookshelf. Returns: int: Maximum number of books that can fit into the bookshelf. widths.sort() total_width = 0 count = 0 for width in widths: if total_width + width <= L: total_width += width count += 1 else: break return count"},{"question":"def min_cost_path(N: int, M: int, cost: List[List[int]]) -> int: Compute the minimum cost path from the top-left corner to the bottom-right corner of a grid. The robot can only move either down or right at any point in time. >>> N, M = 3, 3 >>> cost = [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ] >>> min_cost_path(N, M, cost) 7 >>> N, M = 1, 1 >>> cost = [ ... [1] ... ] >>> min_cost_path(N, M, cost) 1 >>> N, M = 1, 3 >>> cost = [ ... [1, 2, 3] ... ] >>> min_cost_path(N, M, cost) 6 >>> N, M = 3, 1 >>> cost = [ ... [1], ... [2], ... [3] ... ] >>> min_cost_path(N, M, cost) 6 >>> N, M = 2, 2 >>> cost = [ ... [1000, 1000], ... [1000, 1000] ... ] >>> min_cost_path(N, M, cost) 3000","solution":"def min_cost_path(N, M, cost): # Initialize a DP table with the same dimensions as the cost matrix dp = [[0 for _ in range(M)] for _ in range(N)] # Set the cost of the starting position dp[0][0] = cost[0][0] # Fill the first row (can only come from the left) for j in range(1, M): dp[0][j] = dp[0][j-1] + cost[0][j] # Fill the first column (can only come from above) for i in range(1, N): dp[i][0] = dp[i-1][0] + cost[i][0] # Fill the rest of the table for i in range(1, N): for j in range(1, M): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + cost[i][j] # The value in the bottom-right corner is the minimal cost path return dp[N-1][M-1]"},{"question":"def calculate_total_points(M: str) -> int: Calculates the total points based on the match outcomes provided in M. >>> calculate_total_points('WDLW') 7 >>> calculate_total_points('WWWW') 12 >>> calculate_total_points('DDDD') 4 >>> calculate_total_points('LLLL') 0 >>> calculate_total_points('W') 3 >>> calculate_total_points('D') 1 >>> calculate_total_points('L') 0 >>> calculate_total_points('') 0 >>> calculate_total_points('WDLX') 4 # Ignore 'X' and calculate with 'WDL'","solution":"def calculate_total_points(M): Calculates the total points based on the match outcomes provided in M. Parameters: M (str): A string consisting of 'W', 'L', 'D' characters. Returns: int: The total points based on the match outcomes. points_map = {'W': 3, 'D': 1, 'L': 0} total_points = 0 for match in M: total_points += points_map.get(match, 0) return total_points # Example usage M = 'WDLW' print(calculate_total_points(M)) # Output should be 7"},{"question":"def minimum_teams(n: int, d: int, skills: List[int]) -> int: Determines the minimum number of teams required to group all ninjas such that the difference between the highest and the lowest skill levels in each team does not exceed a specified value d. :param n: Number of ninjas :param d: Maximum allowed difference in skill levels in each team :param skills: List of skill levels of the ninjas :return: Minimum number of teams required >>> minimum_teams(6, 3, [1, 5, 3, 2, 4, 6]) == 2 >>> minimum_teams(5, 1, [1, 1, 1, 1, 1]) == 1 >>> minimum_teams(6, 0, [1, 2, 3, 4, 5, 6]) == 6 >>> minimum_teams(6, 5, [1, 2, 3, 4, 5, 6]) == 1 >>> minimum_teams(8, 2, [6, 2, 5, 10, 12, 14, 1, 3]) == 4 >>> minimum_teams(1, 2, [5]) == 1 >>> minimum_teams(7, 3, [3, 3, 2, 2, 4, 4, 4]) == 1 >>> minimum_teams(4, 10, [1, 20, 30, 40]) == 3 pass","solution":"def minimum_teams(n, d, skills): Determines the minimum number of teams required to group all ninjas such that the difference between the highest and the lowest skill levels in each team does not exceed a specified value d. :param n: Number of ninjas :param d: Maximum allowed difference in skill levels in each team :param skills: List of skill levels of the ninjas :return: Minimum number of teams required # Sort the skill levels skills.sort() # Initialize count of teams teams = 0 # Start with the first ninja i = 0 while i < n: # Form a new team starting with the current ninja teams += 1 # While the next ninja can be added to the current team, move to the next ninja j = i while j < n and skills[j] - skills[i] <= d: j += 1 # Move i to the next ninja that can't be added to the current team i = j return teams"},{"question":"def rotate_matrix_clockwise(matrix): Rotates a square matrix 90 degrees clockwise. Args: matrix: List of List of integers representing the NxN matrix Returns: A new List of List of integers representing the rotated matrix >>> rotate_matrix_clockwise([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == [ ... [7, 4, 1], ... [8, 5, 2], ... [9, 6, 3] ... ] >>> rotate_matrix_clockwise([ ... [10, 20, 30, 40], ... [50, 60, 70, 80], ... [90, 100, 110, 120], ... [130, 140, 150, 160] ... ]) == [ ... [130, 90, 50, 10], ... [140, 100, 60, 20], ... [150, 110, 70, 30], ... [160, 120, 80, 40] ... ]","solution":"def rotate_matrix_clockwise(matrix): Rotates a square matrix 90 degrees clockwise. Args: matrix: List of List of integers representing the NxN matrix Returns: A new List of List of integers representing the rotated matrix N = len(matrix) rotated_matrix = [[0] * N for _ in range(N)] for i in range(N): for j in range(N): rotated_matrix[j][N - 1 - i] = matrix[i][j] return rotated_matrix"},{"question":"def count_cycles(n: int, k: int, roads: List[Tuple[int, int]]) -> int: Given a number of cities connected by bidirectional roads, find the number of possible travel cycles such that: - Each city is visited exactly once. - The absolute difference in the number of cities visited on any two consecutive days does not exceed k. The result should be presented modulo 10^9 + 7. Args: n : int : The number of cities. k : int : The threshold for the difference constraint. roads : List[Tuple[int, int]] : The list of bidirectional roads connecting cities. Returns: int : The number of possible travel cycles modulo 10^9 + 7. >>> count_cycles(4, 2, [(1, 2), (2, 3), (3, 4)]) 8 >>> count_cycles(1, 1, []) 1 >>> count_cycles(2, 1, [(1, 2)]) 2 >>> count_cycles(3, 2, [(1, 2), (2, 3)]) 6 >>> count_cycles(5, 3, [(1, 2), (1, 3), (1, 4), (1, 5)]) 120 >>> count_cycles(3, 1, [(1, 2), (2, 3)]) 0","solution":"def count_cycles(n, k, roads): MOD = 10**9 + 7 from itertools import permutations def is_valid_cycle(permutation, k): for i in range(len(permutation)): if abs(permutation[i] - permutation[(i+1) % len(permutation)]) > k: return False return True cities = [i + 1 for i in range(n)] valid_cycles = 0 for perm in permutations(cities): if is_valid_cycle(perm, k): valid_cycles += 1 return valid_cycles % MOD"},{"question":"def diagonal_sum(grids): Args: grids: List of tuples where each tuple contains an integer n (dimension of grid) followed by a list of n lists (each having n integers) representing the grid. Returns: List of sums of diagonal elements for each grid. pass # Test cases grids = [ (3, [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]), (5, [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25] ]), (1, [ [42] ]) ] print(diagonal_sum(grids)) # Expected Output: [25, 117, 42] grids = [(1, [ [1] ])] print(diagonal_sum(grids)) # Expected Output: [1] grids = [(99, [ [i for i in range(1, 100)] for _ in range(99) ])] print(diagonal_sum(grids)) # Expected Output: (Check if it handles the large grid correctly) grids = [(3, [ [1, -2, 3], [-4, 5, -6], [7, -8, 9] ])] print(diagonal_sum(grids)) # Expected Output: [25]","solution":"def diagonal_sum(grids): Args: grids: List of tuples where each tuple contains an integer n (dimension of grid) followed by a list of n lists (each having n integers) representing the grid. Returns: List of sums of diagonal elements for each grid. results = [] for grid_info in grids: n = grid_info[0] grid = grid_info[1] primary_diagonal = sum(grid[i][i] for i in range(n)) secondary_diagonal = sum(grid[i][n - 1 - i] for i in range(n)) # Subtract the middle element, since it is counted twice middle_element = grid[n // 2][n // 2] total_sum = primary_diagonal + secondary_diagonal - middle_element results.append(total_sum) return results"},{"question":"def minimum_bracket_reversals(n: int, s: str) -> int: Determine the minimum number of bracket reversals required to make the given bracket sequence valid. If it is impossible to make the sequence valid by reversing the brackets, return -1. >>> minimum_bracket_reversals(4, \\"())(\\") 2 >>> minimum_bracket_reversals(6, \\"((())\\") 1 >>> minimum_bracket_reversals(5, \\"())((\\") -1 >>> minimum_bracket_reversals(10, \\"()()()()()\\") 0","solution":"def minimum_bracket_reversals(n, s): if n % 2 != 0: return -1 open_count = 0 close_count = 0 for ch in s: if ch == '(': open_count += 1 else: if open_count > 0: open_count -= 1 else: close_count += 1 return (open_count + 1) // 2 + (close_count + 1) // 2"},{"question":"def can_be_palindrome(s: str) -> bool: Determines if the string can be transformed into a palindrome by checking the frequency of each character in the string. >>> can_be_palindrome(\\"aabb\\") == True >>> can_be_palindrome(\\"abc\\") == False >>> can_be_palindrome(\\"abab\\") == True >>> can_be_palindrome(\\"a\\") == True >>> can_be_palindrome(\\"ab\\") == False >>> can_be_palindrome(\\"aab\\") == True def process_test_cases(t: int, test_cases: List[str]) -> List[str]: Processes multiple test cases to determine if each string can be rearranged into a palindrome. >>> process_test_cases(3, [\\"aabb\\", \\"abc\\", \\"abab\\"]) == [\\"YES\\", \\"NO\\", \\"YES\\"] >>> process_test_cases(2, [\\"aa\\", \\"bb\\"]) == [\\"YES\\", \\"YES\\"] >>> process_test_cases(3, [\\"abc\\", \\"cde\\", \\"a\\"]) == [\\"NO\\", \\"NO\\", \\"YES\\"]","solution":"def can_be_palindrome(s): Determines if the string can be transformed into a palindrome by checking the frequency of each character in the string. from collections import Counter count = Counter(s) # Count the number of characters with odd frequencies odd_count = sum(1 for freq in count.values() if freq % 2 != 0) # If there's more than one character with an odd frequency, it can't be rearranged into a palindrome return odd_count <= 1 def process_test_cases(t, test_cases): results = [] for s in test_cases: if can_be_palindrome(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List, Tuple def process_queries(N: int, A: List[int], queries: List[Tuple]) -> List[int]: Processes the given queries on array A of size N. Args: N: int: Number of elements in array A A: List[int]: List of integers representing the array A queries: List[Tuple]: List of queries to process Returns: List[int]: A list containing the results of type 2 queries >>> process_queries(6, [1, 2, 3, 4, 5, 6], [(1, 2, 5, 10, 2), (2, 1, 6), (2, 2, 5)]) [59, 52] >>> process_queries(5, [1, 1, 1, 1, 1], [(1, 1, 5, 1, 1), (2, 1, 3)]) [6] >>> process_queries(4, [0, 0, 0, 0], [(2, 1, 4), (1, 2, 4, 5, -1), (2, 1, 4)]) [0, 12] >>> process_queries(3, [10, -10, 20], [(1, 1, 2, -5, 5), (2, 1, 3), (2, 2, 3)]) [15, 20]","solution":"def process_queries(N, A, queries): Processes the given queries on array A of size N. Args: N : int : Number of elements in array A A : List[int] : List of integers representing the array A queries : List[Tuple] : List of queries to process Returns: List[int] : A list containing the results of type 2 queries result = [] for query in queries: if query[0] == 1: # Update type query _, l, r, x, d = query for i in range(l - 1, r): A[i] = x + (i - (l - 1)) * d elif query[0] == 2: # Sum type query _, l, r = query result.append(sum(A[l - 1:r])) return result"},{"question":"def min_deletions_to_make_anagrams(a: str, b: str) -> int: Given two strings a and b, determine the minimum number of character deletions required to make a and b anagrams of each other. >>> min_deletions_to_make_anagrams('abc', 'cba') 0 >>> min_deletions_to_make_anagrams('hello', 'billion') 6 >>> min_deletions_to_make_anagrams('abcdef', 'ghijkl') 12 pass def process_test_cases(test_cases: List[Tuple[str, str]]) -> List[int]: Given a list of tuples where each tuple contains two strings, return a list of integers representing the minimum number of character deletions required to make the strings in each tuple anagrams. >>> process_test_cases([('abc', 'cba'), ('hello', 'billion'), ('abcdef', 'ghijkl')]) [0, 6, 12] >>> process_test_cases([('abc', 'def'), ('a', 'b'), ('racecar', 'carrace')]) [6, 2, 0] >>> process_test_cases([('aabbcc', 'abc'), ('abc', 'aabbcc')]) [3, 3] pass","solution":"def min_deletions_to_make_anagrams(a, b): Given two strings a and b, determine the minimum number of character deletions required to make a and b anagrams of each other. from collections import Counter counter_a = Counter(a) counter_b = Counter(b) deletions = 0 # Characters present in a but not in b, or in different amounts for char in counter_a: if char in counter_b: deletions += abs(counter_a[char] - counter_b[char]) else: deletions += counter_a[char] # Characters present in b but not in a for char in counter_b: if char not in counter_a: deletions += counter_b[char] return deletions def process_test_cases(test_cases): results = [] for a, b in test_cases: result = min_deletions_to_make_anagrams(a, b) results.append(result) return results"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if the characters of the string can be rearranged to form a palindrome. pass def palindrome_tester(test_cases: List[str]) -> List[str]: Determines for each test case if the characters of the string can be rearranged to form a palindrome. >>> palindrome_tester([\\"aabb\\", \\"racecar\\", \\"abc\\"]) == [\\"YES\\", \\"YES\\", \\"NO\\"] >>> palindrome_tester([\\"a\\", \\"b\\", \\"c\\", \\"d\\"]) == [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"] >>> palindrome_tester([\\"aab\\", \\"ccc\\", \\"abcd\\"]) == [\\"YES\\", \\"YES\\", \\"NO\\"] pass","solution":"def can_form_palindrome(s): Determines if the characters of the string can be rearranged to form a palindrome. from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1 def palindrome_tester(test_cases): Determines for each test case if the characters of the string can be rearranged to form a palindrome. results = [] for s in test_cases: if can_form_palindrome(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def largest_full_binary_rectangle(matrix: List[List[int]]) -> Tuple[int, int]: Find the largest full binary rectangle within the given binary matrix. Each rectangle consists only of 1s and is surrounded by 0s or matrix boundaries. Args: matrix (List[List[int]]): A binary matrix with dimensions m x n. Returns: Tuple[int, int]: The dimensions (number of rows, number of columns) of the largest full binary rectangle. >>> largest_full_binary_rectangle([ ... [0, 0, 1, 0, 0], ... [0, 1, 1, 1, 0], ... [0, 1, 1, 1, 0], ... [0, 0, 0, 0, 0] ... ]) (2, 2) >>> largest_full_binary_rectangle([ ... [0, 1, 1, 1, 0, 0], ... [0, 1, 1, 1, 0, 0], ... [0, 1, 1, 1, 0, 0], ... [0, 0, 0, 0, 0, 0], ... [1, 1, 1, 0, 0, 0] ... ]) (3, 3) >>> largest_full_binary_rectangle([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 1, 0] ... ]) (1, 1)","solution":"def largest_full_binary_rectangle(matrix): m = len(matrix) n = len(matrix[0]) if m == 0 or n == 0: return (0, 0) max_area = 0 max_row_length = 0 max_col_length = 0 dp = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = (1, 1) else: row_len = dp[i-1][j][0] + 1 if matrix[i-1][j] == 1 else 1 col_len = dp[i][j-1][1] + 1 if matrix[i][j-1] == 1 else 1 dp[i][j] = (row_len, col_len) area = min(row_len, col_len) ** 2 if area > max_area: max_area = area max_row_length = min(row_len, col_len) max_col_length = min(row_len, col_len) return (max_row_length, max_col_length)"},{"question":"def common_problem(n: int, participants: List[List[int]]) -> str: Determines if there is a common problem that every participant plans to solve. :param n: int - The number of participants :param participants: list of lists - Each inner list contains the problems one participant plans to solve :return: str - \\"YES\\" if there is at least one common problem, otherwise \\"NO\\" >>> common_problem(3, [[1, 2, 3], [2, 3], [1, 2, 3, 4]]) == \\"YES\\" >>> common_problem(2, [[5, 6], [7, 8, 9]]) == \\"NO\\" >>> common_problem(1, [[1, 2, 3]]) == \\"YES\\" >>> common_problem(2, [[1, 2, 3], [3, 4, 5]]) == \\"YES\\" >>> common_problem(2, [[1, 2], [3, 4]]) == \\"NO\\" >>> common_problem(3, [[1, 2], [3, 4], [5, 6]]) == \\"NO\\" pass","solution":"def common_problem(n, participants): Determines if there is a common problem that every participant plans to solve. :param n: int - The number of participants :param participants: list of lists - Each inner list contains the problems one participant plans to solve :return: str - \\"YES\\" if there is at least one common problem, otherwise \\"NO\\" # Initialize the common set to the problems of the first participant common_problems = set(participants[0]) # Intersect with problems of each participant for i in range(1, n): common_problems.intersection_update(participants[i]) # If there is any common problem left, return \\"YES\\", otherwise \\"NO\\" if common_problems: return \\"YES\\" else: return \\"NO\\""},{"question":"def find_peak_element(grid): Find a peak element in the 2D grid and return its position as a tuple (i, j). If the grid contains multiple peaks, return the position of any one of them. >>> find_peak_element([ ... [10, 20, 15], ... [21, 30, 14], ... [ 7, 16, 13] ... ]) in [(1, 1)] >>> find_peak_element([ ... [1, 4], ... [3, 2] ... ]) in [(0, 1)] >>> find_peak_element([ ... [10] ... ]) == (0, 0) >>> find_peak_element([ ... [10, 20, 30], ... [40, 50, 60], ... [70, 80, 100] ... ]) == (2, 2) >>> find_peak_element([ ... [1, 4, 1], ... [3, 2, 6], ... [1, 5, 1] ... ]) in [(0, 1), (1, 2), (2, 1)]","solution":"def find_peak_element(grid): def is_peak(i, j): curr_val = grid[i][j] # Check up if i > 0 and grid[i-1][j] >= curr_val: return False # Check down if i < len(grid) - 1 and grid[i+1][j] >= curr_val: return False # Check left if j > 0 and grid[i][j-1] >= curr_val: return False # Check right if j < len(grid[0]) - 1 and grid[i][j+1] >= curr_val: return False return True m = len(grid) n = len(grid[0]) if m else 0 for i in range(m): for j in range(n): if is_peak(i, j): return (i, j) return None"},{"question":"def min_coins(X: int) -> int: Given an integer X representing an amount of money, returns the minimum number of coins needed to make that amount using denominations of 1, 2, and 5 units. >>> min_coins(1) == 1 >>> min_coins(2) == 1 >>> min_coins(13) == 3 from typing import List def test_small_amounts(): assert min_coins(1) == 1 assert min_coins(2) == 1 assert min_coins(3) == 2 assert min_coins(4) == 2 assert min_coins(5) == 1 def test_multiple_of_5(): assert min_coins(10) == 2 assert min_coins(25) == 5 assert min_coins(50) == 10 def test_mixed_denominations(): assert min_coins(6) == 2 # 5 + 1 assert min_coins(7) == 2 # 5 + 2 assert min_coins(8) == 3 # 5 + 2 + 1 assert min_coins(9) == 3 # 5 + 2 + 2 assert min_coins(11) == 3 # 5 + 5 + 1 def test_large_amount(): assert min_coins(100000) == 20000","solution":"def min_coins(X): Given an integer X representing an amount of money, returns the minimum number of coins needed to make that amount using denominations of 1, 2, and 5 units. # Start with the largest denomination to minimize the number of coins count = 0 # Use as many 5-unit coins as possible count += X // 5 X %= 5 # Use as many 2-unit coins as possible with the remainder count += X // 2 X %= 2 # Use any remaining 1-unit coins count += X return count"},{"question":"def merge_intervals(intervals): Merges overlapping intervals. Given a list of intervals, merges all overlapping intervals and returns the merged intervals. Each interval is represented as a list of two integers [start, end]. >>> merge_intervals([[1,3],[2,6],[8,10],[15,18]]) [[1,6], [8,10], [15,18]] >>> merge_intervals([[1,4],[4,5]]) [[1,5]] # Unit tests: # from solution import merge_intervals # # def test_merge_intervals_example1(): # assert merge_intervals([[1,3],[2,6],[8,10],[15,18]]) == [[1,6],[8,10],[15,18]] # # def test_merge_intervals_example2(): # assert merge_intervals([[1,4],[4,5]]) == [[1,5]] # # def test_merge_intervals_no_overlap(): # assert merge_intervals([[1,2],[3,4],[5,6]]) == [[1,2],[3,4],[5,6]] # # def test_merge_intervals_all_overlap(): # assert merge_intervals([[1,5],[2,6],[3,7]]) == [[1,7]] # # def test_merge_intervals_single_interval(): # assert merge_intervals([[1,5]]) == [[1,5]] # # def test_merge_intervals_empty(): # assert merge_intervals([]) == [] # # def test_merge_intervals_complex_case(): # assert merge_intervals([[1,4],[2,5],[7,9],[8,10],[12,15]]) == [[1,5],[7,10],[12,15]]","solution":"def merge_intervals(intervals): Merges overlapping intervals. :param intervals: List of intervals where each interval is represented as [start, end] :return: List of merged intervals if not intervals: return [] # First, sort the intervals by the starting time intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] # Initialize with the first interval for current in intervals[1:]: last = merged[-1] # If the current interval overlaps with the last merged interval if current[0] <= last[1]: # Merge the current interval with the last merged interval merged[-1] = [last[0], max(last[1], current[1])] else: merged.append(current) return merged"},{"question":"def is_point_in_hexagon(hexagon: List[List[int]], point: List[int]) -> bool: Checks if a given point is inside a hexagon. The hexagon's vertices and the point's coordinates are given. Assume the hexagon vertices are provided in a clockwise or counter-clockwise order. >>> is_point_in_hexagon([[1, 1], [3, 1], [4, 2], [3, 3], [1, 3], [0, 2]], [2, 2]) True >>> is_point_in_hexagon([[1, 1], [3, 1], [4, 2], [3, 3], [1, 3], [0, 2]], [5, 5]) False","solution":"def is_point_in_hexagon(hexagon, point): def sign(o, a, b): return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]) inside = True for i in range(len(hexagon)): j = (i + 1) % len(hexagon) if sign(hexagon[i], hexagon[j], point) < 0: inside = False break return inside"},{"question":"def min_max_diff(arr): This function returns the minimized maximum difference between the maximum and minimum elements in any subsequence of the array containing at least two elements. # Implement the function logic here def process_test_cases(T, test_cases): results = [] for i in range(T): N, arr = test_cases[i] result = min_max_diff(arr) results.append(result) return results # Example test cases if __name__ == \\"__main__\\": T = 3 test_cases = [ (5, [1, 3, 2, 2, 4]), (4, [7, 5, 3, 1]), (5, [3, 8, 6, 2, 7]) ] print(process_test_cases(T, test_cases)) # Output should be [1, 2, 1]","solution":"def min_max_diff(arr): This function returns the minimized maximum difference between the maximum and minimum elements in any subsequence of the array containing at least two elements. arr.sort() min_diff = float('inf') for i in range(1, len(arr)): diff = arr[i] - arr[i - 1] if diff < min_diff: min_diff = diff return min_diff def process_test_cases(T, test_cases): results = [] for i in range(T): N, arr = test_cases[i] result = min_max_diff(arr) results.append(result) return results"},{"question":"from typing import List, Tuple def can_reorganize_books(N: int, B: str) -> str: Determine if it is possible to reorganize books so no two adjacent books have the same ID. >>> can_reorganize_books(5, \\"aabbc\\") \\"YES\\" >>> can_reorganize_books(4, \\"aaab\\") \\"NO\\" >>> can_reorganize_books(6, \\"abcabc\\") \\"YES\\" pass def process_test_cases(T: int, test_cases: List[Tuple[int, str]]) -> List[str]: Process multiple test cases and determine if it's possible to reorganize books for each one. >>> T = 3 >>> test_cases = [ ... (5, \\"aabbc\\"), ... (4, \\"aaab\\"), ... (6, \\"abcabc\\") ... ] >>> process_test_cases(T, test_cases) [\\"YES\\", \\"NO\\", \\"YES\\"] pass","solution":"def can_reorganize_books(N, B): from collections import Counter import heapq counter = Counter(B) max_count = max(counter.values()) if max_count > (N + 1) // 2: return \\"NO\\" return \\"YES\\" def process_test_cases(T, test_cases): results = [] for i in range(T): N, B = test_cases[i] results.append(can_reorganize_books(N, B)) return results"},{"question":"def traffic_light(current_state: str, seconds: int) -> str: Returns the state of the traffic light after the given seconds have elapsed from the provided state. Args: current_state (str): Current state of the traffic light, either \\"green\\", \\"yellow\\" or \\"red\\". seconds (int): Number of seconds elapsed since the current state. Returns: str: State of the traffic light after the given seconds. >>> traffic_light(\\"green\\", 7) \\"green\\" >>> traffic_light(\\"green\\", 10) \\"yellow\\" >>> traffic_light(\\"yellow\\", 4) \\"red\\" >>> traffic_light(\\"red\\", 15) \\"green\\" >>> traffic_light(\\"red\\", 20) \\"yellow\\" >>> traffic_light(\\"yellow\\", 1) \\"yellow\\" # Unit Tests def test_traffic_light_initial_state(): assert traffic_light(\\"green\\", 0) == \\"green\\" assert traffic_light(\\"yellow\\", 0) == \\"yellow\\" assert traffic_light(\\"red\\", 0) == \\"red\\" def test_traffic_light_simple_transitions(): assert traffic_light(\\"green\\", 10) == \\"yellow\\" assert traffic_light(\\"yellow\\", 3) == \\"red\\" assert traffic_light(\\"red\\", 12) == \\"green\\" def test_traffic_light_within_cycle(): assert traffic_light(\\"green\\", 7) == \\"green\\" assert traffic_light(\\"green\\", 12) == \\"yellow\\" assert traffic_light(\\"yellow\\", 4) == \\"red\\" assert traffic_light(\\"red\\", 15) == \\"green\\" def test_traffic_light_multiple_full_cycles(): assert traffic_light(\\"green\\", 100) == \\"green\\" assert traffic_light(\\"yellow\\", 300) == \\"yellow\\" assert traffic_light(\\"red\\", 400) == \\"red\\" def test_traffic_light_edge_cases(): assert traffic_light(\\"green\\", 15) == \\"red\\" # 15 seconds from green assert traffic_light(\\"yellow\\", 5) == \\"red\\" # 2 seconds in yellow, then 3 in yellow again","solution":"def traffic_light(current_state, seconds): Returns the state of the traffic light after the given seconds have elapsed from the provided state. Args: current_state (str): Current state of the traffic light, either \\"green\\", \\"yellow\\" or \\"red\\". seconds (int): Number of seconds elapsed since the current state. Returns: str: State of the traffic light after the given seconds. cycle_times = { \\"green\\": 10, \\"yellow\\": 3, \\"red\\": 12 } # Calculate the total cycle length cycle_length = sum(cycle_times.values()) # Determine the effective seconds within the current cycle seconds %= cycle_length # Determine which segment of the cycle we fall into if current_state == \\"green\\": initial_offset = 0 elif current_state == \\"yellow\\": initial_offset = cycle_times[\\"green\\"] else: # current_state == \\"red\\" initial_offset = cycle_times[\\"green\\"] + cycle_times[\\"yellow\\"] # Adjust the seconds according to the initial offset seconds += initial_offset seconds %= cycle_length if seconds < cycle_times[\\"green\\"]: return \\"green\\" elif seconds < cycle_times[\\"green\\"] + cycle_times[\\"yellow\\"]: return \\"yellow\\" else: return \\"red\\""},{"question":"from typing import List def check_prime_numbers(nums: List[int]) -> List[bool]: Given a list of integers, return a list of booleans indicating whether each integer in the list is a prime number or not. >>> check_prime_numbers([2, 3, 4, 5, 10, 17]) == [True, True, False, True, False, True] >>> check_prime_numbers([1, 2, 3, 4, 5, 15, 18, 19]) == [False, True, True, False, True, False, False, True] >>> check_prime_numbers([0, 1]) == [False, False] >>> check_prime_numbers([101, 103, 104, 100003]) == [True, True, False, True] >>> check_prime_numbers([-1, -3, 2, 17]) == [False, False, True, True]","solution":"from typing import List import math def is_prime(n: int) -> bool: Helper function to check if a number is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def check_prime_numbers(nums: List[int]) -> List[bool]: Returns a list of booleans indicating whether each integer in the input list \`nums\` is a prime number. return [is_prime(num) for num in nums]"},{"question":"def find_popular_products(n: int, k: int, ratings: List[Tuple[int, int]]) -> List[int]: Find the IDs of popular products which have received at least k ratings of 4 or 5. Args: n : int : Number of ratings k : int : Minimum number of high ratings (4 or 5) needed for a product to be popular ratings : List[Tuple[int, int]] : List of tuples containing product ID and rating Returns: List[int] : List of IDs of popular products in ascending order Example: >>> find_popular_products(7, 2, [(1, 5), (1, 4), (2, 5), (2, 3), (3, 5), (3, 4), (3, 5)]) [1, 3] >>> find_popular_products(5, 1, [(100, 5), (100, 2), (200, 4), (200, 3), (300, 5)]) [100, 200, 300] pass","solution":"def find_popular_products(n, k, ratings): from collections import defaultdict product_ratings = defaultdict(int) for product_id, rating in ratings: if rating >= 4: # Consider only ratings that are 4 or 5 product_ratings[product_id] += 1 popular_products = [product_id for product_id, count in product_ratings.items() if count >= k] return sorted(popular_products) # Sample input parsing for understanding def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) k = int(data[1]) ratings = [(int(data[i]), int(data[i + 1])) for i in range(2, len(data), 2)] result = find_popular_products(n, k, ratings) for product_id in result: print(product_id)"},{"question":"from typing import List def shortest_subarray_length(arr: List[int]) -> int: Returns the length of the shortest subarray which, when sorted, results in the entire array being sorted. >>> shortest_subarray_length([1, 2, 3, 4, 5]) 0 >>> shortest_subarray_length([1, 3, 2, 4, 5]) 2 >>> shortest_subarray_length([1, 2, 5, 3, 4, 6, 7]) 3 # Unit tests import pytest def test_already_sorted(): assert shortest_subarray_length([1, 2, 3, 4, 5]) == 0 def test_simple_case(): assert shortest_subarray_length([1, 3, 2, 4, 5]) == 2 def test_entire_array_unsorted(): assert shortest_subarray_length([5, 4, 3, 2, 1]) == 5 def test_subarray_in_middle(): assert shortest_subarray_length([1, 2, 5, 3, 4, 6, 7]) == 3 def test_partial_sorted(): assert shortest_subarray_length([1, 2, 4, 7, 9, 3, 5, 6, 8, 10]) == 7 def test_edge_case_single_element(): assert shortest_subarray_length([1]) == 0 def test_edge_case_two_elements_sorted(): assert shortest_subarray_length([1, 2]) == 0 def test_edge_case_two_elements_unsorted(): assert shortest_subarray_length([2, 1]) == 2","solution":"from typing import List def shortest_subarray_length(arr: List[int]) -> int: Returns the length of the shortest subarray which, when sorted, results in the entire array being sorted. n = len(arr) if n <= 1: return 0 # Find the first element which is not in sorted order from the left left = 0 while left < n - 1 and arr[left] <= arr[left + 1]: left += 1 # If the array is already sorted if left == n - 1: return 0 # Find the first element which is not in sorted order from the right right = n - 1 while right > 0 and arr[right] >= arr[right - 1]: right -= 1 # Find min and max in the subarray arr[left:right+1] subarray_min = min(arr[left:right + 1]) subarray_max = max(arr[left:right + 1]) # Extend the left boundary to the left as needed while left > 0 and arr[left - 1] > subarray_min: left -= 1 # Extend the right boundary to the right as needed while right < n - 1 and arr[right + 1] < subarray_max: right += 1 return right - left + 1"},{"question":"def count_unique_identifiers(n: int, m: int, k: int, titles: List[str]) -> int: Determine the total number of unique identifiers that can be created for Peter's book collection. Parameters: n (int): the number of books. m (int): the length of each book title. k (int): the maximum reference number. titles (list of str): the titles of the books. Returns: int: the total number of unique identifiers. Examples: >>> count_unique_identifiers(3, 4, 10, [\\"book\\", \\"read\\", \\"note\\"]) 30 >>> count_unique_identifiers(2, 3, 5, [\\"abc\\", \\"xyz\\"]) 10 >>> count_unique_identifiers(4, 5, 1, [\\"apple\\", \\"berry\\", \\"cherry\\", \\"date\\"]) 4","solution":"def count_unique_identifiers(n, m, k, titles): Returns the total number of unique identifiers that can be formed by concatenating book titles with reference numbers ranging from 1 to k. Parameters: n (int): the number of books. m (int): the length of each book title. k (int): the maximum reference number. titles (list of str): the titles of the books. Returns: int: the total number of unique identifiers. return n * k"},{"question":"def min_operations_to_non_decreasing(arr): Returns the minimum number of operations required to make the array non-decreasing by setting elements to 0. >>> min_operations_to_non_decreasing([5, 1, 3, 2, 4, 6]) 2 >>> min_operations_to_non_decreasing([8, 7, 6, 5]) 3 >>> min_operations_to_non_decreasing([1, 2, 3, 4, 5]) 0 N = len(arr) operations = 0 for i in range(1, N): if arr[i] < arr[i - 1]: operations += 1 return operations def test_example_1(): assert min_operations_to_non_decreasing([5, 1, 3, 2, 4, 6]) == 2 def test_example_2(): assert min_operations_to_non_decreasing([8, 7, 6, 5]) == 3 def test_example_3(): assert min_operations_to_non_decreasing([1, 2, 3, 4, 5]) == 0 def test_all_elements_decreasing(): assert min_operations_to_non_decreasing([10, 8, 6, 4, 2]) == 4 def test_alternating_highs_and_lows(): assert min_operations_to_non_decreasing([1, 3, 2, 4, 3, 5]) == 2 def test_single_element(): assert min_operations_to_non_decreasing([1]) == 0","solution":"def min_operations_to_non_decreasing(arr): Returns the minimum number of operations required to make the array non-decreasing by setting elements to 0. N = len(arr) operations = 0 for i in range(1, N): if arr[i] < arr[i - 1]: operations += 1 return operations if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) arr = list(map(int, data[1:])) print(min_operations_to_non_decreasing(arr))"},{"question":"def maxNumber(S: str) -> str: Returns the highest possible number by deleting exactly one digit from the input string S. >>> maxNumber(\\"1234\\") \\"234\\" >>> maxNumber(\\"54321\\") \\"5432\\" >>> maxNumber(\\"10001\\") \\"1001\\"","solution":"def maxNumber(S): Returns the highest possible number by deleting exactly one digit from the input string S. max_num = \\"\\" for i in range(len(S)): current_num = S[:i] + S[i+1:] if current_num > max_num: max_num = current_num return max_num"},{"question":"def longestCommonPrefix(strs): Returns the longest common prefix string amongst an array of strings. If there is no common prefix, returns an empty string. Examples: >>> longestCommonPrefix([\\"flower\\", \\"flow\\", \\"flight\\"]) 'fl' >>> longestCommonPrefix([\\"dog\\", \\"racecar\\", \\"car\\"]) ''","solution":"def longestCommonPrefix(strs): Returns the longest common prefix string amongst an array of strings. If there is no common prefix, returns an empty string. if not strs: return \\"\\" # Sort the array, the common prefix of the first and last elements will be the common prefix for the whole array strs.sort() first = strs[0] last = strs[-1] i = 0 while i < len(first) and i < len(last) and first[i] == last[i]: i += 1 return first[:i]"},{"question":"def find_two_sum_indices(n: int, elements: List[int], target: int) -> Union[Tuple[int, int], str]: Determine if there are two distinct elements in the list whose sum is equal to the target value. Returns the 1-based indices of these elements or \\"NO\\" if no such elements exist. :param n: Number of elements in the list :param elements: List of n space-separated integers :param target: The target integer value :return: A tuple with 1-based indices of the elements whose sum is equal to the target value, or \\"NO\\". >>> find_two_sum_indices(6, [1, 2, 3, 4, 5, 6], 9) [3, 5] >>> find_two_sum_indices(4, [4, 5, 1, 3], 8) [2, 4] >>> find_two_sum_indices(5, [1, 2, 3, 4, 5], 10) \\"NO\\"","solution":"def find_two_sum_indices(n, elements, target): Finds two distinct elements in the list whose sum is equal to the target value. Returns the 1-based indices of these elements or \\"NO\\" if no such elements exist. # Dictionary to store the value and its 0-based index index_map = {} for i in range(n): current_value = elements[i] complement = target - current_value if complement in index_map: # Returning the indices as 1-based return index_map[complement] + 1, i + 1 index_map[current_value] = i return \\"NO\\""},{"question":"def rearrange_string(s: str) -> str: Rearranges characters in the string such that no two adjacent characters are the same. Args: s (str): Input string. Returns: str: Rearranged string or an empty string if not possible. Examples: >>> rearrange_string(\\"aab\\") 'aba' >>> rearrange_string(\\"aaab\\") ''","solution":"import heapq from collections import Counter def rearrange_string(s): Rearranges characters in the string such that no two adjacent characters are the same. Args: s (str): Input string. Returns: str: Rearranged string or an empty string if not possible. # Count the frequency of each character char_count = Counter(s) # Create a max heap with negative counts (for highest frequency character first) max_heap = [(-count, char) for char, count in char_count.items()] heapq.heapify(max_heap) prev_char = None prev_count = 0 result = [] while max_heap or prev_count: if not max_heap and prev_count: return \\"\\" count, char = heapq.heappop(max_heap) result.append(char) if prev_count: # Append the previous character back to the heap if its count is not zero heapq.heappush(max_heap, (prev_count, prev_char)) # Update prev_count and prev_char prev_char = char prev_count = count + 1 # Moving towards zero, as count was initially negative return \\"\\".join(result)"},{"question":"from typing import List def max_attractions(matrix: List[List[int]], start: int) -> int: Given an adjacency matrix of attractions and a starting attraction, determine the maximum number of attractions a visitor can visit without visiting an attraction more than once. Args: matrix : List[List[int]] : The adjacency matrix representing direct paths between attractions. start : int : The starting attraction. Returns: int : The maximum number of attractions visited. Example: >>> max_attractions([[0, 1, 0, 0], ... [1, 0, 1, 1], ... [0, 1, 0, 0], ... [0, 1, 0, 0]], 1) 4 >>> max_attractions([[0, 1], ... [1, 0]], 2) 2 def solve_theme_park(input_text: str) -> str: Parses the input text, processes each test case and returns the results as described. Args: input_text : str : The input text containing multiple test cases. Returns: str : The formatted string with the results of each test case. Example: >>> input_text = '''2 ...0 1 0 0 ...1 0 1 1 ...0 1 0 0 ...0 1 0 0 ...1 ...0 1 ...1 0 ...2''' >>> solve_theme_park(input_text) 'Case 1: 4nCase 2: 2'","solution":"def max_attractions(matrix, start): Uses Depth First Search to find the maximum number of attractions one can visit starting from the given attraction. n = len(matrix) visited = [False] * n def dfs(attraction): visited[attraction] = True count = 1 for neighbor in range(n): if matrix[attraction][neighbor] == 1 and not visited[neighbor]: count += dfs(neighbor) return count # Adjust for zero-based index start -= 1 return dfs(start) def solve_theme_park(input_text): Parses the input text, processes each test case and returns the results as described. lines = input_text.strip().split('n') t = int(lines[0]) index = 1 case_results = [] for case_num in range(1, t + 1): # Skip the blank line while lines[index].strip() == '': index += 1 # Read matrix matrix = [] while index < len(lines) and not lines[index].strip().isdigit(): row = list(map(int, lines[index].split())) matrix.append(row) index += 1 # Read start attraction start = int(lines[index].strip()) index += 1 # Calculate maximum attractions visited for this case result = max_attractions(matrix, start) case_results.append(f'Case {case_num}: {result}') return 'n'.join(case_results)"},{"question":"def max_non_adjacent_sum(nums): Returns the maximum sum of non-adjacent elements in the array. Args: nums (list): A list of positive integers. Returns: int: Maximum sum of non-adjacent elements. >>> max_non_adjacent_sum([3, 2, 5, 10]) 13 >>> max_non_adjacent_sum([1, 2, 3, 4, 5]) 9 >>> max_non_adjacent_sum([5]) 5 >>> max_non_adjacent_sum([5, 1]) 5 >>> max_non_adjacent_sum([5, 10, 10, 100, 5]) 110 def process_test_cases(T, test_cases): Process multiple test cases to get the maximum sum of non-adjacent elements for each case. Args: T (int): Number of test cases. test_cases (list): A list of tuples where each tuple contains the size of the array and the array itself. Returns: list: A list of integers where each integer is the result of max_non_adjacent_sum for the corresponding test case. >>> process_test_cases(4, [(4, [3, 2, 5, 10]), (5, [1, 2, 3, 4, 5]), (3, [3, 2, 7]), (6, [5, 5, 10, 100, 10, 5])]) [13, 9, 10, 110]","solution":"def max_non_adjacent_sum(nums): Returns the maximum sum of non-adjacent elements in the array. Args: nums (list): A list of positive integers. Returns: int: Maximum sum of non-adjacent elements. if not nums: return 0 if len(nums) == 1: return nums[0] inclusive = nums[0] exclusive = 0 for i in range(1, len(nums)): new_exclusive = max(inclusive, exclusive) inclusive = exclusive + nums[i] exclusive = new_exclusive return max(inclusive, exclusive) def process_test_cases(T, test_cases): results = [] for case in test_cases: N, nums = case results.append(max_non_adjacent_sum(nums)) return results"},{"question":"from typing import List def maximum_difference_with_constraint(a: List[int]) -> int: Returns the maximum difference between any two elements such that the larger element comes after the smaller element in the array. >>> maximum_difference_with_constraint([7, 1, 5, 3, 6, 4]) 5 >>> maximum_difference_with_constraint([7, 6, 4, 3, 1]) 0 >>> maximum_difference_with_constraint([1, 2, 90, 10, 110]) 109 >>> maximum_difference_with_constraint([2, 3, 10, 2, 4, 8, 1]) 8 >>> maximum_difference_with_constraint([]) 0 >>> maximum_difference_with_constraint([1]) 0 >>> maximum_difference_with_constraint([5, 5, 5, 5]) 0 >>> maximum_difference_with_constraint([5, 1, 5, 10]) 9","solution":"def maximum_difference_with_constraint(a): Returns the maximum difference between any two elements such that the larger element comes after the smaller element in the array. if not a or len(a) < 2: return 0 min_element = a[0] max_difference = 0 for i in range(1, len(a)): max_difference = max(max_difference, a[i] - min_element) min_element = min(min_element, a[i]) return max_difference"},{"question":"def count_arrangements(B: int, W: int) -> int: Returns the number of valid arrangements such that no two white marbles are consecutive. >>> count_arrangements(3, 2) # Output: 6 >>> count_arrangements(1, 4) # Output: 0 >>> count_arrangements(0, 3) # Output: 0 >>> count_arrangements(5, 0) # Output: 1","solution":"import math def count_arrangements(B, W): Returns the number of valid arrangements such that no two white marbles are consecutive. # If there are no black marbles or more white marbles than black + 1, return 0 if B == 0 or W > B + 1: return 0 # Using combinatorics to calculate valid arrangements. return math.comb(B + 1, W)"},{"question":"from typing import List def sort_by_absolute_values(arr: List[int]) -> List[int]: Sorts the list of integers based on the absolute values in ascending order. Retains the original relative order of elements with identical absolute values. pass def process_test_cases(test_cases: List[List[int]]) -> List[List[int]]: Processes multiple test cases and returns results for each. pass def test_sort_by_absolute_values(): assert sort_by_absolute_values([3, -1, 2, -7, 5]) == [-1, 2, 3, 5, -7] assert sort_by_absolute_values([-10, 5, 3, 9, -4]) == [3, -4, 5, 9, -10] assert sort_by_absolute_values([0, -1, -2, 1, 2]) == [0, -1, 1, -2, 2] assert sort_by_absolute_values([-3, -2, -1, 0, 1, 2, 3]) == [0, -1, 1, -2, 2, -3, 3] assert sort_by_absolute_values([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_process_test_cases(): test_cases = [ [3, -1, 2, -7, 5], [-10, 5, 3, 9, -4] ] expected_output = [ [-1, 2, 3, 5, -7], [3, -4, 5, 9, -10] ] assert process_test_cases(test_cases) == expected_output test_cases = [ [0, -1, -2, 1, 2], [-3, -2, 0, 1, 3, 2], ] expected_output = [ [0, -1, 1, -2, 2], [0, 1, -2, 2, -3, 3] ] assert process_test_cases(test_cases) == expected_output","solution":"from typing import List def sort_by_absolute_values(arr: List[int]) -> List[int]: Sorts the list of integers based on the absolute values in ascending order. return sorted(arr, key=abs) def process_test_cases(test_cases: List[List[int]]) -> List[List[int]]: Processes multiple test cases and returns results for each. return [sort_by_absolute_values(case) for case in test_cases]"},{"question":"def compress_string(s: str) -> str: Compress a string using the following algorithm: 1. Count the consecutive occurrences of each character in the string. 2. If a character repeats consecutively, append the character followed by the count of its occurrences to the compressed string. If a character does not repeat consecutively, simply append the character. 3. The compressed string should only be returned if it is shorter than the original string; otherwise, return the original string. >>> compress_string(\\"aabcccccaaa\\") \\"a2b1c5a3\\" >>> compress_string(\\"abcd\\") \\"abcd\\" >>> compress_string(\\"\\") \\"\\" >>> compress_string(\\"aaabbbcccdddeee\\") \\"a3b3c3d3e3\\" >>> compress_string(\\"a\\") \\"a\\" pass","solution":"def compress_string(s: str) -> str: if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(f\\"{s[i - 1]}{count}\\") count = 1 compressed.append(f\\"{s[-1]}{count}\\") compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"class Inventory: def __init__(self): self.stock = {} def add_stock(self, ID, units): Add stock for a specific item type given its ID and units. pass def remove_stock(self, ID, units): Remove stock for a specific item type given its ID and units. Assumes there is always enough stock to remove. pass def query_stock(self, ID): Query the stock for a specific item type given its ID. pass def process_operations(operations): Process a list of operations for the inventory system. Args: operations (List[str]): List of operation strings to be executed. Returns: List[int]: List of results from 'query' commands. Example: >>> process_operations([\\"add 100 50\\", \\"add 200 30\\", \\"query 100\\", \\"remove 100 20\\", \\"query 100\\", \\"query 200\\"]) [50, 30, 30] pass","solution":"class Inventory: def __init__(self): self.stock = {} def add_stock(self, ID, units): if ID in self.stock: self.stock[ID] += units else: self.stock[ID] = units def remove_stock(self, ID, units): if ID in self.stock: self.stock[ID] -= units def query_stock(self, ID): return self.stock.get(ID, 0) def process_operations(operations): inventory = Inventory() results = [] for operation in operations: op = operation.split() if op[0] == \\"add\\": inventory.add_stock(int(op[1]), int(op[2])) elif op[0] == \\"remove\\": inventory.remove_stock(int(op[1]), int(op[2])) elif op[0] == \\"query\\": results.append(inventory.query_stock(int(op[1]))) return results"},{"question":"def smallest_missing_positive(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the smallest positive integer missing from each list in the test cases. >>> smallest_missing_positive(3, [(5, [1, 2, 0, -1, 3]), (3, [3, 4, 5]), (4, [-1, -2, -3, -4])]) [4, 1, 1] >>> smallest_missing_positive(1, [(5, [1, 2, 3, 4, 5])]) [6] >>> smallest_missing_positive(1, [(5, [-1, -2, 1, 2, 3])]) [4] >>> smallest_missing_positive(1, [(3, [-1, -2, -3])]) [1] >>> smallest_missing_positive(1, [(5, [1000000, 999999, 500000, 1, 2])]) [3] >>> smallest_missing_positive(1, [(6, [7, 8, 9, 11, 12, 1])]) [2]","solution":"def smallest_missing_positive(t, test_cases): results = [] for case in test_cases: n, array = case present = set(array) i = 1 while i in present: i += 1 results.append(i) return results"},{"question":"def air_quality_alert(n, m, k, aqi_readings): Determines whether an air quality alert will be issued based on the given parameters. Parameters: n (int): Number of days m (int): Required consecutive days for an alert k (int): AQI threshold aqi_readings (list of int): AQI values for each day Returns: str: 'Yes' if an air quality alert is issued, otherwise 'No' pass from solution import air_quality_alert def test_air_quality_alert_issued(): assert air_quality_alert(7, 3, 100, [80, 120, 130, 150, 90, 160, 170]) == \\"Yes\\" assert air_quality_alert(5, 2, 50, [60, 55, 45, 65, 70]) == \\"Yes\\" def test_air_quality_alert_not_issued(): assert air_quality_alert(7, 3, 100, [80, 120, 90, 150, 90, 160, 170]) == \\"No\\" assert air_quality_alert(5, 3, 200, [180, 190, 210, 205, 190]) == \\"No\\" def test_air_quality_alert_edge_cases(): assert air_quality_alert(1, 1, 100, [90]) == \\"No\\" assert air_quality_alert(1, 1, 100, [150]) == \\"Yes\\" assert air_quality_alert(2, 2, 200, [250, 300]) == \\"Yes\\" assert air_quality_alert(10, 5, 100, [101, 102, 103, 104, 105, 80, 120, 130, 150, 90]) == \\"Yes\\"","solution":"def air_quality_alert(n, m, k, aqi_readings): Determines whether an air quality alert will be issued based on the given parameters. Parameters: n (int): Number of days m (int): Required consecutive days for an alert k (int): AQI threshold aqi_readings (list of int): AQI values for each day Returns: str: 'Yes' if an air quality alert is issued, otherwise 'No' consecutive_days = 0 for reading in aqi_readings: if reading > k: consecutive_days += 1 if consecutive_days == m: return \\"Yes\\" else: consecutive_days = 0 return \\"No\\""},{"question":"def longest_increasing_subsequence(arr): Returns the length of the longest strictly increasing subsequence in the given array. >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence([5, 8, 3, 7, 9, 1]) 3 >>> longest_increasing_subsequence([]) 0","solution":"def longest_increasing_subsequence(arr): Returns the length of the longest strictly increasing subsequence in the given array. if not arr: return 0 n = len(arr) lis = [1] * n # Initialize LIS values for all indexes to 1 # Compute optimized LIS values in a bottom up manner for i in range(1, n): for j in range(0, i): if arr[i] > arr[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 # Return maximum value in lis[] return max(lis)"},{"question":"def min_operations_to_single_char(s: str) -> int: Given a string, determines the minimum number of operations required to reduce the string to a single character by replacing palindromic substrings with '*'. >>> min_operations_to_single_char(\\"abba\\") 1 >>> min_operations_to_single_char(\\"abab\\") 2 >>> min_operations_to_single_char(\\"aaa\\") 1 >>> min_operations_to_single_char(\\"abcba\\") 1 >>> min_operations_to_single_char(\\"abcd\\") 2 pass def min_operations_for_test_cases(t: int, test_cases: List[str]) -> List[int]: Given multiple test cases, determines the minimum number of operations required to reduce each string to a single character. >>> min_operations_for_test_cases(3, [\\"abba\\", \\"abab\\", \\"aaa\\"]) [1, 2, 1] >>> min_operations_for_test_cases(2, [\\"racecar\\", \\"abccba\\"]) [1, 1] >>> min_operations_for_test_cases(4, [\\"palindrome\\", \\"noon\\", \\"madam\\", \\"abcba\\"]) [2, 1, 1, 1] >>> min_operations_for_test_cases(1, [\\"a\\"]) [1] >>> min_operations_for_test_cases(1, [\\"a\\" * 1000]) [1] >>> min_operations_for_test_cases(1, [\\"a\\" * 999 + \\"b\\"]) [2] pass","solution":"def min_operations_to_single_char(s): Given a string, determines the minimum number of operations required to reduce the string to a single character by replacing palindromic substrings with '*'. # Check if the entire string is a palindrome if s == s[::-1]: return 1 # If the entire string is not a palindrome, return 2 # because we can always reduce it to one character in two steps: # 1. Replace any single character with '*'. # 2. Each remaining half can be reduced to '*' in further steps. return 2 def min_operations_for_test_cases(t, test_cases): results = [] for s in test_cases: results.append(min_operations_to_single_char(s)) return results"},{"question":"def contributor_of_the_week(m, posts): Determine the Contributor of the Week based on unique user likes. Each post is represented by a pair: the user ID of the post author and a list of user IDs who liked the post. Args: m (int): The number of posts. posts (List[Tuple[int, List[int]]]): A list where each element is a tuple containing two elements: - an integer representing the user ID who made the post - a list of integers representing the user IDs who liked the post Returns: int: The user ID of the Contributor of the Week. Examples: >>> contributor_of_the_week(3, [(1, [2, 3, 4]), (2, [3, 1, 5]), (1, [2, 5])]) 1 >>> contributor_of_the_week(2, [(1, [2, 3]), (2, [2, 4, 3])]) 2 >>> contributor_of_the_week(1, [(100, [101, 102, 103, 104])]) 100 pass","solution":"def contributor_of_the_week(m, posts): from collections import defaultdict user_likes = defaultdict(set) for post in posts: user_id, likes = post[0], post[1] user_likes[user_id].update(likes) max_unique_likes = 0 contributor_of_the_week = None for user_id, likes in user_likes.items(): unique_likes_count = len(likes) if (unique_likes_count > max_unique_likes) or (unique_likes_count == max_unique_likes and (contributor_of_the_week is None or user_id < contributor_of_the_week)): max_unique_likes = unique_likes_count contributor_of_the_week = user_id return contributor_of_the_week"},{"question":"def evaluate_expression(expression): Evaluates a mathematical expression string containing positive integers and the operators + and -. Parameters: expression (str): A string representing the mathematical expression. Returns: int: The result of evaluating the expression. Examples: >>> evaluate_expression(\\"3+5-2\\") 6 >>> evaluate_expression(\\"10+20-30+40\\") 40 >>> evaluate_expression(\\"1+2+3+4-5\\") 5 >>> evaluate_expression(\\"100\\") 100","solution":"def evaluate_expression(expression): Evaluates a mathematical expression string containing positive integers and the operators + and -. Parameters: expression (str): A string representing the mathematical expression. Returns: int: The result of evaluating the expression. tokens = expression.split() result = 0 num = \\"\\" sign = 1 for char in expression: if char.isdigit(): num += char else: if num: result += sign * int(num) if char == '+': sign = 1 elif char == '-': sign = -1 num = \\"\\" if num: result += sign * int(num) return result"},{"question":"def maxEnvelopes(n: int, envelopes: List[Tuple[int, int]]) -> int: Find the maximum number of envelopes one can \\"Russian doll\\". >>> maxEnvelopes(4, [(5, 4), (6, 4), (6, 7), (2, 3)]) 3 >>> maxEnvelopes(3, [(2, 3), (3, 4), (4, 5)]) 3 >>> maxEnvelopes(3, [(5, 4), (6, 7), (6, 8)]) 2 >>> maxEnvelopes(5, [(1, 1), (1, 1), (1, 1), (1, 1), (1, 1)]) 1 >>> maxEnvelopes(1, [(10, 20)]) 1 >>> maxEnvelopes(6, [(8, 9), (7, 9), (2, 3), (14, 15), (10, 11), (2, 4)]) 4 # Write your solution here","solution":"def maxEnvelopes(n, envelopes): envelopes.sort(key=lambda x: (x[0], -x[1])) dp = [] import bisect for _, h in envelopes: idx = bisect.bisect_left(dp, h) if idx == len(dp): dp.append(h) else: dp[idx] = h return len(dp) def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) envelopes = [] for i in range(n): width = int(data[2 * i + 1]) height = int(data[2 * i + 2]) envelopes.append((width, height)) print(maxEnvelopes(n, envelopes))"},{"question":"def maximum_value(T: int, test_cases: list) -> list: Determine the maximum possible value Diane can obtain by visiting a subset of locations such that no two visits overlap in time. >>> maximum_value(1, [(4, 4, [(0, 1, 300), (1, 2, 200), (2, 3, 400), (3, 4, 500)])]) [1400] >>> maximum_value(1, [(1, 4, [(0, 4, 1000)])]) [1000] >>> maximum_value(1, [(3, 4, [(0, 1, 500), (1, 2, 300), (2, 3, 200)])]) [1000] >>> maximum_value(1, [(3, 4, [(0, 2, 700), (1, 3, 800), (2, 4, 900)])]) [1600] >>> maximum_value(2, [ (4, 4, [(0, 1, 300), (1, 2, 200), (2, 3, 400), (3, 4, 500)]), (3, 4, [(0, 2, 700), (1, 3, 800), (2, 4, 900)]) ]) [1400, 1600]","solution":"def maximum_value(T, test_cases): results = [] for i in range(T): n, m, locations = test_cases[i] locations.sort(key=lambda x: x[1]) dp = [0] * (m + 1) for s, e, v in locations: for t in range(m, s - 1, -1): if t >= e: dp[t] = max(dp[t], dp[t - (e - s)] + v) results.append(max(dp)) return results"},{"question":"def canPartition(nums): Determine if it is possible to partition the list into two subsets such that the sum of elements in both subsets is equal. >>> canPartition([1, 5, 11, 5]) True >>> canPartition([1, 2, 3, 5]) False","solution":"def canPartition(nums): total_sum = sum(nums) # If total sum is odd, it's not possible to divide it into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 # To check whether a subset with sum 'target' exists n = len(nums) dp = [False] * (target + 1) dp[0] = True # There is always a subset with sum 0 (empty subset) for num in nums: # Traverse dp array from back to avoid using the same item more than once for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"def digit_sum_sequence(N: int) -> list: Returns the sequence of numbers generated by repeatedly summing the digits of N until a single-digit number is obtained. >>> digit_sum_sequence(9875) [9875, 29, 11, 2] >>> digit_sum_sequence(12345) [12345, 15, 6]","solution":"def digit_sum_sequence(N): Returns the sequence of numbers generated by repeatedly summing the digits of N until a single-digit number is obtained. sequence = [] while N >= 10: sequence.append(N) N = sum(int(digit) for digit in str(N)) sequence.append(N) return sequence"},{"question":"def totalElevationGain(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate total elevation gain for multiple test cases. Parameters: t (int): The number of test cases. test_cases (list of tuples): List containing tuples, each representing a test case. Each tuple contains an integer n (number of heights) and a list of n integers representing the heights. Returns: List of integers: Total elevation gain for each test case. >>> totalElevationGain(2, [(9, [2, 3, 4, 3, 2, 1, 5, 6, 3]), (5, [1, 2, 1, 2, 1])]) [7, 2]","solution":"def totalElevationGain(t, test_cases): Returns the total elevation gain for multiple test cases. Parameters: t (int): The number of test cases. test_cases (list of tuples): List containing tuples, each representing a test case. Each tuple contains an integer n and a list of n integers representing the heights. Returns: List of integers: Total elevation gain for each test case. results = [] for case in test_cases: n, heights = case total_gain = 0 for i in range(1, n): if heights[i] > heights[i - 1]: total_gain += heights[i] - heights[i - 1] results.append(total_gain) return results # Single function to handle all test cases instead of processing one at a time"},{"question":"def find_pair(nums: List[int], target: int) -> Optional[Tuple[int, int]]: Returns a tuple (a, b) such that a + b = target and a and b are distinct elements in the list. If no such pair exists, returns None. >>> find_pair([2, 7, 11, 15], 9) in [(2, 7), (7, 2)] True >>> find_pair([3, 2, 4], 6) in [(2, 4), (4, 2)] True >>> find_pair([1, 2, 3, 4, 5], 10) None >>> find_pair([], 5) None >>> find_pair([5], 5) None >>> find_pair([1000000000, -999999999], 1) in [(1000000000, -999999999), (-999999999, 1000000000)] True >>> find_pair([0, 0, 3, 4], 0) in [(0, 0)] True >>> find_pair([0, 3, 4], 3) in [(0, 3), (3, 0)] True","solution":"def find_pair(nums, target): Returns a tuple (a, b) such that a + b = target and a and b are distinct elements in the list. If no such pair exists, returns None. seen = {} for num in nums: complement = target - num if complement in seen: return (complement, num) seen[num] = True return None"},{"question":"def count_distinct_characters(grid, queries): You are given a grid of size n x m filled with lowercase English letters. Your task is to answer several queries about the grid. Each query describes a rectangle defined by its top-left and bottom-right corners, and you need to determine how many distinct characters are present in that rectangle. Args: grid (List[str]): List of strings representing the grid. queries (List[Tuple[int, int, int, int]]): List of queries where each query is a tuple (r1, c1, r2, c2). Returns: List[int]: List of counts of distinct characters for each query. >>> grid = [\\"abcd\\", \\"efgh\\", \\"ijkl\\"] >>> queries = [(1, 1, 2, 2), (2, 2, 3, 3)] >>> count_distinct_characters(grid, queries) [4, 4] >>> grid = [\\"a\\"] >>> queries = [(1, 1, 1, 1)] >>> count_distinct_characters(grid, queries) [1] >>> grid = [\\"abcd\\", \\"efgh\\", \\"ijkl\\"] >>> queries = [(1, 1, 3, 4)] >>> count_distinct_characters(grid, queries) [12] >>> grid = [\\"abcd\\", \\"abcd\\", \\"abcd\\"] >>> queries = [(1, 1, 2, 2), (1, 2, 2, 3), (2, 2, 3, 3)] >>> count_distinct_characters(grid, queries) [2, 2, 2]","solution":"def count_distinct_characters(grid, queries): results = [] for r1, c1, r2, c2 in queries: chars = set() for i in range(r1-1, r2): for j in range(c1-1, c2): chars.add(grid[i][j]) results.append(len(chars)) return results"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"\\") == 0 >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"bbbbb\\") == 1 >>> length_of_longest_substring(\\"pwwkew\\") == 3 >>> length_of_longest_substring(\\"au\\") == 2 >>> length_of_longest_substring(\\"dvdf\\") == 3","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_index_map = {} start = 0 max_length = 0 for index, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = index max_length = max(max_length, index - start + 1) return max_length"},{"question":"def determine_winner(m: int, n: int) -> str: Determine the winner of the game given the dimensions m (rows) and n (columns). Alice and Bob are playing a game on a 2D grid with dimensions m x n. The players take turns removing all pieces from a sub-grid defined by the rectangle with corners at (1,1) and (x,y). A player loses if they cannot make a move. Alice always plays first. Determine the winner of the game if both players play optimally. Parameters: m (int): Number of rows in the grid. n (int): Number of columns in the grid. Returns: str: \\"Alice\\" if Alice wins, \\"Bob\\" if Bob wins. Examples: >>> determine_winner(2, 2) 'Bob' >>> determine_winner(3, 2) 'Alice' >>> determine_winner(4, 3) 'Alice' # Your implementation here def solve_game(test_cases: List[Tuple[int, int]]) -> List[str]: Solve the game for multiple test cases. Parameters: test_cases (List[Tuple[int, int]]): List of test cases where each test case is a tuple (m, n). Returns: List[str]: List of results for each test case, with \\"Alice\\" or \\"Bob\\" as winners. Examples: >>> solve_game([(2, 2), (3, 2), (4, 3)]) ['Bob', 'Alice', 'Alice'] # Your implementation here","solution":"def determine_winner(m, n): Returns the winner of the game given the dimensions m (rows) and n (columns) # Alice wins if either m or n is odd, otherwise Bob wins if m % 2 == 1 or n % 2 == 1: return \\"Alice\\" else: return \\"Bob\\" def solve_game(test_cases): results = [] for m, n in test_cases: results.append(determine_winner(m, n)) return results"},{"question":"def rightAlignedTriangle(N): Takes an Integer N as input and returns a vector of strings where each line represents lines of the pattern. >>> rightAlignedTriangle(4) [' 1', ' 2 3', ' 4 5 6', '7 8 9 10'] >>> rightAlignedTriangle(3) [' 1', ' 2 3', '4 5 6']","solution":"def rightAlignedTriangle(N): Takes an Integer N as input and returns a vector of strings where each line represents lines of the pattern. result = [] num = 1 for i in range(1, N+1): line = ' ' * (N - i) + ' '.join(str(num + j) for j in range(i)) num += i result.append(line) return result"},{"question":"def dna_strand_matching(T: int, test_cases: List[Tuple[int, str, str]]) -> List[str]: Determine if pairs of DNA strands have no conflicting base pairs. Args: T (int): The number of test cases. test_cases (List[Tuple[int, str, str]]): Each test case is a tuple containing an integer N (length of the DNA strands), a string S1 (first DNA strand), and a string S2 (second DNA strand). Returns: List[str]: List of 'YES' or 'NO' for each test case indicating whether the pairs of DNA strands have no conflicting base pairs. >>> dna_strand_matching(3, [ ... (4, 'ATCG', 'TAGC'), ... (7, 'GATTACA', 'CTTAAGG'), ... (3, 'AAA', 'TTT') ... ]) ['YES', 'NO', 'YES']","solution":"def dna_strand_matching(T, test_cases): complementary = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'} results = [] for case in test_cases: N, S1, S2 = case is_no_conflict = True for i in range(N): if S1[i] != S2[i] and complementary[S1[i]] != S2[i]: is_no_conflict = False break results.append('YES' if is_no_conflict else 'NO') return results"},{"question":"from typing import List, Tuple def max_non_overlapping_plot_area(plots: List[Tuple[int, int, int, int]]) -> int: Find the maximum area of any non-overlapping plot. >>> max_non_overlapping_plot_area([(1, 1, 4, 4), (2, 2, 5, 5)]) == 0 >>> max_non_overlapping_plot_area([(1, 1, 4, 4), (5, 5, 8, 8)]) == 9 pass # Unit tests def test_single_plot(): plots = [(1, 1, 4, 4)] assert max_non_overlapping_plot_area(plots) == 9 def test_no_overlap(): plots = [(1, 1, 4, 4), (5, 5, 7, 7)] assert max_non_overlapping_plot_area(plots) == 9 def test_overlap(): plots = [(1, 1, 4, 4), (2, 2, 5, 5)] assert max_non_overlapping_plot_area(plots) == 0 def test_mixed(): plots = [(1, 1, 4, 4), (2, 2, 5, 5), (5, 5, 8, 8)] assert max_non_overlapping_plot_area(plots) == 9 def test_multiple_non_overlapping(): plots = [(1, 1, 3, 3), (4, 4, 6, 6), (7, 7, 9, 9)] assert max_non_overlapping_plot_area(plots) == 4 def test_multiple_plots_overlap_and_non_overlap(): plots = [(1, 1, 4, 4), (3, 3, 6, 6), (7, 7, 10, 10)] assert max_non_overlapping_plot_area(plots) == 9 def test_no_non_overlapping_plot(): plots = [(0, 0, 1, 1), (0, 0, 2, 2)] assert max_non_overlapping_plot_area(plots) == 0","solution":"def area(plot): Calculate the area of a rectangular plot defined by top-left and bottom-right corners. x1, y1, x2, y2 = plot return (x2 - x1) * (y2 - y1) def overlaps(plot1, plot2): Check if two plots overlap. x1, y1, x2, y2 = plot1 x3, y3, x4, y4 = plot2 # No overlap conditions if x2 <= x3 or x4 <= x1 or y2 <= y3 or y4 <= y1: return False return True def max_non_overlapping_plot_area(plots): Return the maximum area of any non-overlapping plot. n = len(plots) max_area = 0 for i in range(n): plot = plots[i] is_non_overlapping = True for j in range(n): if i != j and overlaps(plot, plots[j]): is_non_overlapping = False break if is_non_overlapping: max_area = max(max_area, area(plot)) return max_area"},{"question":"from typing import List def min_steps_to_treasure(r: int, c: int, start: List[int], treasure: List[int], dungeon: List[str]) -> int: Calculate the minimum number of steps required for the hunter to reach the treasure in a dungeon. If it is impossible to reach the treasure, return \\"IMPOSSIBLE\\". >>> min_steps_to_treasure(4, 6, [0, 0], [3, 3], [\\"......\\", \\"..#...\\", \\"..#.\\", \\"....\\"]) 6 >>> min_steps_to_treasure(3, 3, [0, 0], [2, 2], [\\".#.\\", \\"#..\\", \\"..#\\"]) 'IMPOSSIBLE' >>> min_steps_to_treasure(3, 3, [0, 0], [2, 2], [\\"...\\", \\"...\\", \\"...\\"]) 4 >>> min_steps_to_treasure(2, 2, [0, 0], [1, 1], [\\"..\\", \\"..\\"]) 2 >>> min_steps_to_treasure(4, 4, [0, 0], [3, 3], [\\"....\\", \\"..\\", \\".#..\\", \\"....\\"]) 6","solution":"from collections import deque def min_steps_to_treasure(r, c, start, treasure, dungeon): def is_valid(x, y): return 0 <= x < r and 0 <= y < c and dungeon[x][y] == '.' def bfs(start, end): queue = deque([(start[0], start[1], 0)]) # (row, col, steps) visited = set([(start[0], start[1])]) while queue: x, y, steps = queue.popleft() if (x, y) == end: return steps for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return float('inf') start = tuple(start) treasure = tuple(treasure) direct_path_steps = bfs(start, treasure) if direct_path_steps != float('inf'): return direct_path_steps # Check if using teleport makes it possible min_steps = float('inf') for i in range(r): for j in range(c): if dungeon[i][j] == '.' and (i, j) != start and (i, j) != treasure: # Try teleporting to (i, j) and then to the treasure path_to_point = bfs(start, (i, j)) path_from_point = bfs((i, j), treasure) if path_to_point < float('inf') and path_from_point < float('inf'): min_steps = min(min_steps, path_to_point + path_from_point) return min_steps if min_steps != float('inf') else \\"IMPOSSIBLE\\""},{"question":"def sum_top_k_players(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Computes the total score of the top K players for each test case. >>> sum_top_k_players(2, [(5, 3, [50, 60, 80, 90, 70]), (4, 2, [30, 10, 20, 40])]) [240, 70] >>> sum_top_k_players(1, [(6, 4, [10, 20, 30, 40, 50, 60])]) [180]","solution":"def sum_top_k_players(T, test_cases): results = [] for t in range(T): N, K, skill_levels = test_cases[t] skill_levels.sort(reverse=True) top_k_sum = sum(skill_levels[:K]) results.append(top_k_sum) return results"},{"question":"def longest_increasing_subsequence(s: str) -> int: Determine the length of the longest subsequence where the ASCII values of the characters strictly increase by one. >>> longest_increasing_subsequence(\\"abcdefg\\") 7 >>> longest_increasing_subsequence(\\"abcbad\\") 3","solution":"def longest_increasing_subsequence(s): Determine the length of the longest subsequence where the ASCII values of the characters strictly increase by one. max_len = 1 # minimum length for the subsequence current_len = 1 for i in range(1, len(s)): # If the current character's ASCII value is exactly one more than the previous character's if ord(s[i]) - ord(s[i-1]) == 1: current_len += 1 max_len = max(max_len, current_len) else: current_len = 1 return max_len"},{"question":"def min_levels_to_reach_score(n: int, S: int, points: List[int]) -> int: Determines the minimum number of levels required to achieve a target score of S. Params: n (int): number of levels S (int): target score points (list): points awarded for each level Returns: int: minimum number of levels required to achieve the score S or -1 if it is impossible >>> min_levels_to_reach_score(5, 25, [5, 7, 8, 9, 10]) 3 >>> min_levels_to_reach_score(3, 15, [5, 5, 5]) 3 >>> min_levels_to_reach_score(4, 50, [3, 3, 3, 3]) -1 from typing import List import pytest def test_example1(): assert min_levels_to_reach_score(5, 25, [5, 7, 8, 9, 10]) == 3 def test_example2(): assert min_levels_to_reach_score(3, 15, [5, 5, 5]) == 3 def test_example3(): assert min_levels_to_reach_score(4, 50, [3, 3, 3, 3]) == -1 def test_large_values(): assert min_levels_to_reach_score(10, 100, [10, 10, 10, 10, 10, 10, 10, 10, 10, 10]) == 10 def test_single_level(): assert min_levels_to_reach_score(1, 5, [10]) == 1 def test_insufficient_points(): assert min_levels_to_reach_score(3, 20, [5, 5, 5]) == -1 def test_exact_score(): assert min_levels_to_reach_score(3, 15, [6, 5, 4]) == 3 def test_extra_points(): assert min_levels_to_reach_score(3, 10, [10, 5, 1]) == 1 pytest.main()","solution":"def min_levels_to_reach_score(n, S, points): Determines the minimum number of levels required to achieve a target score of S. Params: n (int): number of levels S (int): target score points (list): points awarded for each level Returns: int: minimum number of levels required to achieve the score S or -1 if impossible points.sort(reverse=True) total_points = 0 levels_count = 0 for point in points: total_points += point levels_count += 1 if total_points >= S: return levels_count return -1"},{"question":"def count_palindromic_substrings(s: str) -> int: Write a method to count the total number of palindromic substrings in the string s. A palindrome is a string that reads the same forwards as backwards. >>> count_palindromic_substrings(\\"aaa\\") == 6 >>> count_palindromic_substrings(\\"abc\\") == 3 >>> count_palindromic_substrings(\\"racecar\\") == 10 from typing import List def test_single_characters(): assert count_palindromic_substrings(\\"a\\") == 1 assert count_palindromic_substrings(\\"abc\\") == 3 def test_same_characters(): assert count_palindromic_substrings(\\"aaa\\") == 6 def test_mixed_characters(): assert count_palindromic_substrings(\\"racecar\\") == 10 def test_no_palindromes(): assert count_palindromic_substrings(\\"abcd\\") == 4 def test_multipal_palindromes(): assert count_palindromic_substrings(\\"aba\\") == 4 assert count_palindromic_substrings(\\"abba\\") == 6","solution":"def count_palindromic_substrings(s: str) -> int: Returns the total number of palindromic substrings in the given string s. n = len(s) count = 0 # Function to expand around center and count palindromes def expand_around_center(left: int, right: int) -> int: nonlocal count local_count = 0 while left >= 0 and right < n and s[left] == s[right]: local_count += 1 left -= 1 right += 1 return local_count # Consider every character and every pair of characters as the center for i in range(n): count += expand_around_center(i, i) # Odd length palindrome count += expand_around_center(i, i + 1) # Even length palindrome return count"},{"question":"import bisect from typing import List def longest_increasing_subsequence(corrupted_sequence: List[int]) -> int: Returns the length of the longest increasing subsequence in the given corrupted sequence. >>> longest_increasing_subsequence([8, 2, 5, 1, 8, 3, 6, 7, 4]) 4 >>> longest_increasing_subsequence([5]) 1 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence([]) 0 >>> longest_increasing_subsequence([7, 7, 7, 7, 7]) 1 >>> longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) 6","solution":"import bisect def longest_increasing_subsequence(corrupted_sequence): Returns the length of the longest increasing subsequence in the given corrupted sequence. lis = [] for num in corrupted_sequence: pos = bisect.bisect_left(lis, num) if pos == len(lis): lis.append(num) else: lis[pos] = num return len(lis) def main(): corrupted_sequence = list(map(int, input().strip().split())) print(longest_increasing_subsequence(corrupted_sequence))"},{"question":"def longest_increasing_path(n: int, m: int, grid: List[str]) -> int: Find the length of the longest increasing path in the grid. An increasing path is a sequence of cells such that each cell contains a letter that comes after the previous cell's letter in alphabetical order, and you can only move up, down, left, or right at each step. >>> longest_increasing_path(3, 4, [\\"abcd\\", \\"bcde\\", \\"cdef\\"]) 6 >>> longest_increasing_path(2, 2, [\\"zx\\", \\"yw\\"]) 2 from solution import longest_increasing_path def test_example_1(): n = 3 m = 4 grid = [ \\"abcd\\", \\"bcde\\", \\"cdef\\" ] assert longest_increasing_path(n, m, grid) == 6 def test_example_2(): n = 2 m = 2 grid = [ \\"zx\\", \\"yw\\" ] assert longest_increasing_path(n, m, grid) == 2 def test_single_row(): n = 1 m = 5 grid = [ \\"abcde\\" ] assert longest_increasing_path(n, m, grid) == 5 def test_single_column(): n = 5 m = 1 grid = [ \\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\" ] assert longest_increasing_path(n, m, grid) == 5 def test_no_increasing_path(): n = 3 m = 3 grid = [ \\"aaa\\", \\"aaa\\", \\"aaa\\" ] assert longest_increasing_path(n, m, grid) == 1 def test_diagonal_increasing_path(): n = 3 m = 3 grid = [ \\"abc\\", \\"bcd\\", \\"cde\\" ] assert longest_increasing_path(n, m, grid) == 5 def test_empty_grid(): n = 0 m = 0 grid = [] assert longest_increasing_path(n, m, grid) == 0","solution":"def longest_increasing_path(n, m, grid): def dfs(x, y): if dp[x][y]: return dp[x][y] max_len = 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and ord(grid[nx][ny]) == ord(grid[x][y]) + 1: max_len = max(max_len, 1 + dfs(nx, ny)) dp[x][y] = max_len return max_len if not grid or not grid[0]: return 0 dp = [[0] * m for _ in range(n)] max_path_len = 0 for i in range(n): for j in range(m): max_path_len = max(max_path_len, dfs(i, j)) return max_path_len"},{"question":"def isPossible(N: int, A: List[int]) -> str: Determine if it is possible to make the entire array equal by performing a defined operation any number of times. Parameters: N (int): The size of the array. A (list): A list of positive integers. Returns: str: \\"Possible\\" if feasible, otherwise \\"Not Possible\\". >>> isPossible(3, [3, 9, 6]) \\"Possible\\" >>> isPossible(4, [4, 5, 7, 11]) \\"Not Possible\\" >>> isPossible(5, [7, 7, 7, 7, 7]) \\"Possible\\" >>> isPossible(3, [12, 15, 9]) \\"Possible\\" >>> isPossible(4, [13, 17, 19, 23]) \\"Not Possible\\" >>> isPossible(3, [1000000000, 500000000, 250000000]) \\"Possible\\" >>> isPossible(3, [1, 1000000000, 2]) \\"Not Possible\\" >>> isPossible(3, [2, 3, 5]) \\"Not Possible\\" >>> isPossible(1, [42]) \\"Possible\\"","solution":"def isPossible(N, A): Determine if it is possible to make the entire array equal by performing a defined operation any number of times. Parameters: N (int): The size of the array. A (list): A list of positive integers. Returns: str: \\"Possible\\" if feasible, otherwise \\"Not Possible\\". from math import gcd from functools import reduce # Find the greatest common divisor (GCD) of the entire array overall_gcd = reduce(gcd, A) # If the GCD is greater than 1, it is possible to make all elements equal return \\"Possible\\" if overall_gcd > 1 else \\"Not Possible\\""},{"question":"def knight_moves(position: str) -> list: Finds all possible moves for a knight from the given position on a chessboard. Args: position (str): Current position of the knight on the chessboard in chess notation. Returns: list: All possible positions the knight can move to, sorted in lexicographical order. pass def process_knight_moves(T: int, positions: list) -> list: Processes multiple test cases for knight moves. Args: T (int): Number of test cases. positions (list): List of initial positions. Returns: list: List of strings, each containing the possible moves for a knight from the corresponding position. from solution import knight_moves, process_knight_moves def test_knight_moves_e2(): assert knight_moves(\\"e2\\") == [\\"c1\\", \\"c3\\", \\"d4\\", \\"f4\\", \\"g1\\", \\"g3\\"] def test_knight_moves_a1(): assert knight_moves(\\"a1\\") == [\\"b3\\", \\"c2\\"] def test_knight_moves_h8(): assert knight_moves(\\"h8\\") == [\\"f7\\", \\"g6\\"] def test_knight_moves_d5(): assert knight_moves(\\"d5\\") == [\\"b4\\", \\"b6\\", \\"c3\\", \\"c7\\", \\"e3\\", \\"e7\\", \\"f4\\", \\"f6\\"] def test_process_knight_moves(): T = 3 positions = [\\"e2\\", \\"a1\\", \\"h8\\"] expected_output = [ \\"c1 c3 d4 f4 g1 g3\\", \\"b3 c2\\", \\"f7 g6\\" ] assert process_knight_moves(T, positions) == expected_output","solution":"def knight_moves(position): Finds all possible moves for a knight from the given position on a chessboard. Args: position (str): Current position of the knight on the chessboard in chess notation. Returns: list: All possible positions the knight can move to, sorted in lexicographical order. # Convert the position to numeric coordinates col, row = position[0], int(position[1]) col_num = ord(col) - ord('a') + 1 # List of all possible moves for a knight moves = [ (2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2) ] possible_positions = [] # Check each potential move for move in moves: new_x = col_num + move[0] new_y = row + move[1] # Ensure the new position is within bounds if 1 <= new_x <= 8 and 1 <= new_y <= 8: new_col = chr(ord('a') + new_x - 1) possible_positions.append(f\\"{new_col}{new_y}\\") # Return the sorted list of possible moves return sorted(possible_positions) def process_knight_moves(T, positions): Processes multiple test cases for knight moves. Args: T (int): Number of test cases. positions (list): List of initial positions. Returns: list: List of strings, each containing the possible moves for a knight from the corresponding position. results = [] for position in positions: moves = knight_moves(position) results.append(\\" \\".join(moves)) return results"},{"question":"def containsNearbyAlmostDuplicate(nums: List[int], k: int, t: int) -> bool: Write a function that returns \`true\` if there are two distinct indices \`i\` and \`j\` in the array such that the absolute difference between \`nums[i]\` and \`nums[j]\` is at most \`t\` and the absolute difference between \`i\` and \`j\` is at most \`k\`. >>> containsNearbyAlmostDuplicate([1, 2, 3, 1], 3, 0) True >>> containsNearbyAlmostDuplicate([1, 0, 1, 1], 1, 2) True >>> containsNearbyAlmostDuplicate([1, 5, 9, 1, 5, 9], 2, 3) False pass def test_contains_nearby_almost_duplicate_true_case_1(): nums = [1, 2, 3, 1] k = 3 t = 0 assert containsNearbyAlmostDuplicate(nums, k, t) def test_contains_nearby_almost_duplicate_true_case_2(): nums = [1, 0, 1, 1] k = 1 t = 2 assert containsNearbyAlmostDuplicate(nums, k, t) def test_contains_nearby_almost_duplicate_false_case(): nums = [1, 5, 9, 1, 5, 9] k = 2 t = 3 assert not containsNearbyAlmostDuplicate(nums, k, t) def test_contains_nearby_almost_duplicate_large_t(): nums = [1, 2, 3, 1] k = 3 t = 10 assert containsNearbyAlmostDuplicate(nums, k, t) def test_contains_nearby_almost_duplicate_large_k(): nums = [1, 2, 3, 1] k = 5 t = 0 assert containsNearbyAlmostDuplicate(nums, k, t) def test_contains_nearby_almost_duplicate_single_element(): nums = [1] k = 0 t = 0 assert not containsNearbyAlmostDuplicate(nums, k, t) def test_contains_nearby_almost_duplicate_empty(): nums = [] k = 0 t = 0 assert not containsNearbyAlmostDuplicate(nums, k, t) def test_contains_nearby_almost_duplicate_zero_k(): nums = [1, 2, 3, 1] k = 0 t = 1 assert not containsNearbyAlmostDuplicate(nums, k, t) def test_contains_nearby_almost_duplicate_zero_t(): nums = [1, 2, 3, 1] k = 2 t = 0 assert not containsNearbyAlmostDuplicate(nums, k, t)","solution":"def containsNearbyAlmostDuplicate(nums, k, t): if t < 0 or k <= 0: return False num_dict = {} for i, num in enumerate(nums): bucket = num // (t + 1) if bucket in num_dict: return True if bucket - 1 in num_dict and abs(num - num_dict[bucket - 1]) <= t: return True if bucket + 1 in num_dict and abs(num - num_dict[bucket + 1]) <= t: return True num_dict[bucket] = num if i >= k: del num_dict[nums[i - k] // (t + 1)] return False"},{"question":"from typing import List def restore_ip_addresses(s: str) -> List[str]: Given a string containing only digits, return all possible valid IP addresses that can be formed by inserting dots between the digits. Each segment of the IP address must be a valid segment, which means it is an integer between 0 and 255, inclusive, and no segment should contain leading zeros except for the number '0' itself. >>> restore_ip_addresses(\\"25525511135\\") [\\"255.255.11.135\\", \\"255.255.111.35\\"] >>> restore_ip_addresses(\\"0000\\") [\\"0.0.0.0\\"] >>> restore_ip_addresses(\\"101023\\") [\\"1.0.10.23\\", \\"1.0.102.3\\", \\"10.1.0.23\\", \\"10.10.2.3\\", \\"101.0.2.3\\"] pass # Your code here","solution":"from typing import List def is_valid_segment(segment: str) -> bool: # A valid segment must not start with '0' if it has multiple digits and must be between 0 and 255 return len(segment) == 1 or (segment[0] != '0' and 0 <= int(segment) <= 255) def restore_ip_addresses(s: str) -> List[str]: result = [] n = len(s) # We need to split the string into 4 parts with 3 dots, hence we use 3 nested loops for i in range(1, min(4, n - 2)): for j in range(i + 1, min(i + 4, n - 1)): for k in range(j + 1, min(j + 4, n)): segment1, segment2, segment3, segment4 = s[:i], s[i:j], s[j:k], s[k:] if all(is_valid_segment(segment) for segment in (segment1, segment2, segment3, segment4)): result.append(f\\"{segment1}.{segment2}.{segment3}.{segment4}\\") return result"},{"question":"def count_ssh_substrings(S: str) -> int: Returns the number of SSH substrings in the string S. >>> count_ssh_substrings(\\"abcba\\") 2 >>> count_ssh_substrings(\\"a\\") 0 >>> count_ssh_substrings(\\"aa\\") 1 >>> count_ssh_substrings(\\"aaaa\\") 6 >>> count_ssh_substrings(\\"abcd\\") 0 >>> count_ssh_substrings(\\"abcdabcd\\") 4 >>> count_ssh_substrings(\\"abacabad\\") 7","solution":"def count_ssh_substrings(S): Returns the number of SSH substrings in the string S. count = 0 n = len(S) for start in range(n): for end in range(start + 1, n): if S[start] == S[end]: count += 1 return count"},{"question":"def min_operations_to_transform(initial: str, target: str) -> int: Returns the minimum number of operations required to transform the initial string into the target string by repeatedly selecting any substring and reversing it. >>> min_operations_to_transform(\\"abcd\\", \\"dcba\\") 1 >>> min_operations_to_transform(\\"aabbcc\\", \\"aabbcc\\") 0 >>> min_operations_to_transform(\\"abcdef\\", \\"fedcba\\") 1 >> min_operations_to_transform(\\"abcdef\\", \\"abcfed\\") 1 >>> min_operations_to_transform(\\"abcdef\\", \\"fedabc\\") 2 >>> min_operations_to_transform(\\"abcd\\", \\"abdc\\") 1 >>> min_operations_to_transform(\\"a\\", \\"a\\") 0 >>> min_operations_to_transform(\\"abcdefgh\\", \\"hgfedcba\\") 1","solution":"def min_operations_to_transform(initial, target): Returns the minimum number of operations required to transform the initial string into the target string by repeatedly selecting any substring and reversing it. # Helper function to find the positions where characters differ def differing_positions(s1, s2): diffs = [] for i in range(len(s1)): if s1[i] != s2[i]: diffs.append(i) return diffs differing_positions_list = differing_positions(initial, target) if not differing_positions_list: return 0 # Strings are already equal, so 0 operations required left = differing_positions_list[0] right = differing_positions_list[-1] return 1 if initial[left:right+1][::-1] == target[left:right+1] else 2"},{"question":"def sum_query(l: int, r: int, array: List[int]) -> int: Returns the sum of elements from index l to index r (1-based indexing) from the array. >>> sum_query(1, 3, [0, 0, 0, 100, 100, 100, 10, 20, 30]) 0 >>> sum_query(4, 6, [0, 0, 0, 100, 100, 100, 10, 20, 30]) 300 >>> sum_query(1, 6, [0, 0, 0, 100, 100, 100, 10, 20, 30]) 300 >>> sum_query(8, 9, [0, 0, 0, 100, 100, 100, 10, 20, 30]) 50 pass def find_segments(n: int, m: int, array: List[int]) -> Tuple[List[Tuple[int, int]], List[Tuple[int, int]]]: Identifies and returns the zero-segment and high-value segments in the array. Returns a tuple with two lists of tuples, where each tuple represents the start and end indices (1-based) of a segment. >>> find_segments(10, 100, [0, 0, 0, 100, 100, 100, 10, 20, 30, 0]) ([(1, 3), (10, 10)], [(4, 6)]) >>> find_segments(5, 1, [1, 1, 1, 1, 1]) ([], [(1, 5)]) >>> find_segments(8, 5, [0, 0, 0, 1, 0, 0, 5, 5]) ([(1, 3), (5, 6)], [(7, 8)]) >>> find_segments(8, 2, [2, 2, 0, 0, 1, 2, 0, 0]) ([(3, 4), (7, 8)], [(1, 2), (6, 6)]) pass","solution":"def sum_query(l, r, array): Returns the sum of elements from index l to index r (1-based indexing) from the array. return sum(array[l-1:r]) # converting to 0-based indexing def find_segments(n, m, array): zero_segments = [] high_segments = [] i = 0 while i < n: if array[i] == 0: start = i while i < n and array[i] == 0: i += 1 zero_segments.append((start + 1, i)) # converting to 1-based indexing elif array[i] == m: start = i while i < n and array[i] == m: i += 1 high_segments.append((start + 1, i)) # converting to 1-based indexing else: i += 1 return zero_segments, high_segments"},{"question":"def sum_of_primes(n: int) -> int: Compute the sum of all prime numbers less than or equal to N. Args: n: A non-negative integer N Returns: The sum of all prime numbers less than or equal to N. Examples: >>> sum_of_primes(10) 17 >>> sum_of_primes(20) 77 >>> sum_of_primes(0) 0 >>> sum_of_primes(2) 2","solution":"def sum_of_primes(n): Returns the sum of all prime numbers less than or equal to n. if n < 2: return 0 sieve = [True] * (n + 1) sieve[0] = sieve[1] = False for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n + 1, start): sieve[multiple] = False return sum(i for i in range(n + 1) if sieve[i])"},{"question":"def minimum_cost_to_connect_towns(n: int, m: int, roads: List[List[int]]) -> int: Find the minimum cost required to ensure that the entire kingdom is connected. If it's impossible to connect all towns, return -1. >>> minimum_cost_to_connect_towns(4, 5, [[1, 2, 3], [2, 3, 4], [3, 4, 1], [4, 1, 2], [1, 3, 5]]) == 6 >>> minimum_cost_to_connect_towns(3, 1, [[1, 2, 1]]) == -1 from typing import List def test_minimum_cost_to_connect_towns_case1(): n = 4 m = 5 roads = [ [1, 2, 3], [2, 3, 4], [3, 4, 1], [4, 1, 2], [1, 3, 5] ] assert minimum_cost_to_connect_towns(n, m, roads) == 6 def test_minimum_cost_to_connect_towns_case2(): n = 3 m = 1 roads = [ [1, 2, 1] ] assert minimum_cost_to_connect_towns(n, m, roads) == -1 def test_minimum_cost_to_connect_towns_single_town(): n = 1 m = 0 roads = [] assert minimum_cost_to_connect_towns(n, m, roads) == 0 def test_minimum_cost_to_connect_towns_insufficient_roads(): n = 4 m = 2 roads = [ [1, 2, 1], [2, 3, 2] ] assert minimum_cost_to_connect_towns(n, m, roads) == -1 def test_minimum_cost_to_connect_towns_sufficient_roads(): n = 4 m = 4 roads = [ [1, 2, 1], [2, 3, 2], [3, 4, 1], [4, 1, 2] ] assert minimum_cost_to_connect_towns(n, m, roads) == 4","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def minimum_cost_to_connect_towns(n, m, roads): if n == 1: return 0 if m < n - 1: return -1 roads.sort(key=lambda x: x[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) result = 0 edges_used = 0 for road in roads: u, v, w = road x = find(parent, u - 1) y = find(parent, v - 1) if x != y: result += w edges_used += 1 union(parent, rank, x, y) if edges_used == n - 1: return result return -1"},{"question":"def can_place_X(N, M, K) -> str: Determine if it is possible to place exactly K 'X' characters on the grid such that all the occupied cells are adjacent and connected in a single contiguous block. Args: N (int): The number of rows in the grid. M (int): The number of columns in the grid. K (int): The number of 'X' characters to place. Returns: str: \\"YES\\" if it is possible to place the 'X' characters according to the rules, otherwise \\"NO\\". Examples: >>> can_place_X(3, 3, 1) \\"YES\\" >>> can_place_X(3, 3, 5) \\"YES\\" >>> can_place_X(3, 3, 9) \\"YES\\" >>> can_place_X(3, 3, 10) \\"NO\\"","solution":"def can_place_X(N, M, K): if K > N * M: return \\"NO\\" if K == 1: return \\"YES\\" for rows in range(1, N+1): if K % rows == 0: cols = K // rows if cols <= M: return \\"YES\\" if K % rows != 0: cols = K // rows + 1 if cols <= M: return \\"YES\\" return \\"NO\\""},{"question":"def findOrder(words, N, K): Determine the order of characters in an alien language given a list of words in that language. Args: words (List[str]): List of words in the alien language. N (int): Number of words. K (int): Length of each word. Returns: str: A single string representing the characters in the order they appear in the alien language. >>> findOrder([\\"baa\\", \\"abcd\\", \\"abca\\", \\"cab\\", \\"cad\\"], 5, 4) 'bdac' >>> findOrder([\\"caa\\", \\"aaa\\", \\"aab\\"], 3, 3) 'cab' >>> findOrder([\\"wrt\\", \\"wrf\\", \\"er\\", \\"ett\\", \\"rftt\\"], 5, 3) 'wertf' >>> findOrder([\\"z\\", \\"x\\"], 2, 1) 'zx' >>> findOrder([\\"z\\", \\"x\\", \\"z\\"], 3, 1) ''","solution":"from collections import defaultdict, deque def findOrder(words, N, K): # Create adjacency list and in-degree dictionary adj = defaultdict(set) in_degree = {ch: 0 for word in words for ch in word} # Build the graph for i in range(N - 1): word1, word2 = words[i], words[i + 1] for ch1, ch2 in zip(word1, word2): if ch1 != ch2: if ch2 not in adj[ch1]: adj[ch1].add(ch2) in_degree[ch2] += 1 break # Topological Sort using Kahn's Algorithm (BFS) queue = deque([ch for ch in in_degree if in_degree[ch] == 0]) order = [] while queue: ch = queue.popleft() order.append(ch) for neighbor in adj[ch]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(order) != len(in_degree): return \\"\\" return \\"\\".join(order)"},{"question":"from typing import List, Tuple def minimum_road_network(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Find the total length of the shortest road network that connects all the villages together. If it is not possible to connect all the villages, return \\"Impossible\\". >>> minimum_road_network(4, 5, [(1, 2, 3), (2, 3, 1), (3, 4, 2), (4, 1, 4), (1, 3, 5)]) 6 >>> minimum_road_network(3, 3, [(1, 2, 1), (2, 3, 2), (3, 1, 4)]) 3 >>> minimum_road_network(3, 1, [(1, 2, 1)]) \\"Impossible\\" >>> minimum_road_network(2, 1, [(1, 2, 10)]) 10 >>> minimum_road_network(5, 7, [(1, 2, 4), (1, 3, 1), (3, 2, 2), (2, 4, 5), (3, 5, 8), (4, 5, 6), (2, 5, 3)]) 11","solution":"def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def kruskal(n, edges): edges.sort(key=lambda item: item[2]) # Sorting edges based on their weight parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) mst_weight = 0 mst_edges = [] # To store the edges in the minimum spanning tree for edge in edges: u, v, w = edge root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: union(parent, rank, root_u, root_v) mst_weight += w mst_edges.append(edge) if len(mst_edges) != n-1: return \\"Impossible\\" return mst_weight def minimum_road_network(n, m, roads): edges = [(u-1, v-1, w) for u, v, w in roads] return kruskal(n, edges)"},{"question":"from typing import List def longest_common_contiguous_substring(strings: List[str]) -> str: Finds the longest common contiguous substring that appears in every string in the list. If there are multiple substrings with the same maximum length, returns the one that appears first lexicographically. Args: strings (List[str]): A list of strings to be evaluated. Returns: str: The longest common contiguous substring that appears in every string in the list. If no such substring exists, returns an empty string. >>> longest_common_contiguous_substring([\\"abcde\\", \\"bcdef\\", \\"cdefg\\"]) 'cde' >>> longest_common_contiguous_substring([\\"ababc\\", \\"abzab\\", \\"yzab\\"]) 'ab' >>> longest_common_contiguous_substring([\\"abc\\", \\"def\\", \\"ghi\\"]) '' >>> longest_common_contiguous_substring([\\"abcdefgh\\", \\"abcdeg\\", \\"abcxy\\"]) 'abc'","solution":"def longest_common_contiguous_substring(strings): Returns the longest common contiguous substring that appears in every string in the list. If there are multiple substrings with the same maximum length, returns the one that appears first lexicographically. def is_common_substring(substr): for s in strings: if substr not in s: return False return True strings.sort() # Sort to make the lexicographical search easier base_string = strings[0] substrings = [] # Generate all possible substrings of the base string for length in range(1, len(base_string)+1): for start in range(0, len(base_string) - length + 1): substr = base_string[start:start+length] if is_common_substring(substr): substrings.append(substr) if not substrings: return \\"\\" substrings.sort(key=lambda x: (-len(x), x)) return substrings[0]"},{"question":"def evenOddCount(arr): Given an array of integers, returns a tuple of two integers. The first integer is the count of even numbers in the array, and the second integer is the count of odd numbers in the array. >>> evenOddCount([1, 2, 3, 4, 5]) (2, 3) >>> evenOddCount([2, 4, 6]) (3, 0) >>> evenOddCount([1, 3, 5, 7, 9]) (0, 5) >>> evenOddCount([0, 2, 4, 6, 8, 10]) (6, 0) >>> evenOddCount([1, 1, 1]) (0, 3) >>> evenOddCount([2, 2, 2, 2]) (4, 0) >>> evenOddCount([]) (0, 0) >>> evenOddCount([11, 21, 31, 41]) (0, 4) >>> evenOddCount([12, 13, 14, 15, 16]) (3, 2) def run_test_cases(test_cases): Takes a list of test cases input and returns a list of tuples with even and odd counts. Each test case is a tuple containing the number of elements and the array of integers. >>> run_test_cases([(5, [1, 2, 3, 4, 5]), (3, [2, 4, 6]), (4, [1, 1, 1, 1]), (6, [0, 2, 4, 6, 8, 10])]) [(2, 3), (3, 0), (0, 4), (6, 0)]","solution":"def evenOddCount(arr): Given an array of integers, returns a tuple of two integers. The first integer is the count of even numbers in the array, and the second integer is the count of odd numbers in the array. even_count = sum(1 for x in arr if x % 2 == 0) odd_count = sum(1 for x in arr if x % 2 != 0) return (even_count, odd_count) def run_test_cases(test_cases): Takes a list of test cases input and returns a list of tuples with even and odd counts. Each test case is a tuple containing the number of elements and the array of integers. results = [] for n, arr in test_cases: results.append(evenOddCount(arr)) return results"},{"question":"def min_energy_traverse(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Calculate the minimum total energy required to visit all trees exactly once and return to the starting tree using only the visible edges. If it is not possible to visit all trees, return -1. Args: n (int): The number of trees (nodes). m (int): The number of visible edges. edges (List[Tuple[int, int, int]]): The list of visible edges where each tuple contains three integers u, v, and w. Returns: int: The minimum energy required or -1 if the journey is not possible. Example: >>> min_energy_traverse(4, 5, [(1, 2, 10), (1, 3, 15), (2, 3, 20), (2, 4, 25), (3, 4, 30)]) 80 >>> min_energy_traverse(4, 2, [(1, 2, 10), (3, 4, 20)]) -1","solution":"import itertools from collections import defaultdict import math def min_energy_traverse(n, m, edges): def tsp(graph, dp, mask, pos, n): if mask == (1 << n) - 1: return graph[pos][0] if graph[pos][0] else math.inf if dp[mask][pos] != -1: return dp[mask][pos] min_cost = math.inf for city in range(n): if (mask & (1 << city)) == 0 and graph[pos][city]: new_cost = graph[pos][city] + tsp(graph, dp, mask | (1 << city), city, n) min_cost = min(min_cost, new_cost) dp[mask][pos] = min_cost return dp[mask][pos] graph = [[0] * n for _ in range(n)] for u, v, w in edges: graph[u-1][v-1] = w graph[v-1][u-1] = w dp = [[-1] * n for _ in range(1 << n)] result = tsp(graph, dp, 1, 0, n) return result if result != math.inf else -1"},{"question":"def min_traffic_lights_needed(n: int, house_positions: List[int], r: int) -> int: Determine the minimum number of traffic lights needed to cover all houses along a road. Parameters: n (int): Number of houses. house_positions (list): Coordinates of the houses along the road. r (int): Effective range of each traffic light. Returns: int: Minimum number of traffic lights needed to cover all houses. Examples: >>> min_traffic_lights_needed(5, [1, 3, 6, 9, 12], 2) 3 >>> min_traffic_lights_needed(1, [5], 10) 1 >>> min_traffic_lights_needed(5, [5, 5, 5, 5, 5], 1) 1 >>> min_traffic_lights_needed(4, [1, 2, 3, 4], 5) 1 >>> min_traffic_lights_needed(4, [1, 4, 7, 10], 1) 4","solution":"def min_traffic_lights_needed(n, house_positions, r): Returns the minimum number of traffic lights needed to cover all houses. Parameters: n (int): Number of houses. house_positions (list): Coordinates of the houses along the road. r (int): Effective range of each traffic light. Returns: int: Minimum number of traffic lights needed to cover all houses. house_positions.sort() num_lights = 0 i = 0 while i < n: # Place the light at the farthest house within the range light_pos = house_positions[i] + r num_lights += 1 # Move to the house just out of the current light's range while i < n and house_positions[i] <= light_pos + r: i += 1 return num_lights"},{"question":"def max_teams(t, test_cases): Determines the maximum number of teams that can be formed. Each team must consist of one beginner (skill level 1), one intermediate (skill level 2), and one advanced (skill level 3). :param t: Number of test cases :param test_cases: List of tuples, each tuple contains: (n, skills) where n is the number of students and skills is a list of their skill levels. :return: List of integers representing the maximum number of teams for each test case. results = [] for case in test_cases: n, skills = case # Complete the function to find the maximum number of teams # ... return results from max_teams import max_teams def test_example_cases(): assert max_teams(3, [ (6, [1, 1, 2, 2, 3, 3]), (4, [1, 1, 1, 1]), (9, [1, 2, 3, 2, 1, 3, 2, 3, 1]) ]) == [2, 0, 3] def test_small_cases(): assert max_teams(2, [ (3, [1, 2, 3]), (3, [1, 1, 1]) ]) == [1, 0] def test_single_student(): assert max_teams(1, [ (1, [1]) ]) == [0] def test_unbalanced_skills(): assert max_teams(1, [ (6, [1, 1, 2, 3, 3, 3]) ]) == [1] def test_large_input(): students = [1] * 333334 + [2] * 333334 + [3] * 333332 assert max_teams(1, [ (999999, students) ]) == [333332]","solution":"def max_teams(t, test_cases): Determines the maximum number of teams that can be formed. Each team must consist of one beginner (skill level 1), one intermediate (skill level 2), and one advanced (skill level 3). :param t: Number of test cases :param test_cases: List of tuples, each tuple contains: (n, skills) where n is the number of students and skills is a list of their skill levels. :return: List of integers representing the maximum number of teams for each test case. results = [] for case in test_cases: n, skills = case count_1 = skills.count(1) count_2 = skills.count(2) count_3 = skills.count(3) # teams can be formed in the number equal to the min count of skill levels teams = min(count_1, count_2, count_3) results.append(teams) return results"},{"question":"def count_subarrays_with_sum_divisible_by_k(n: int, k: int, array: List[int]) -> int: Given the number of elements, an integer \`k\`, and the array of integers, this function returns the number of contiguous subarrays whose sum is divisible by \`k\`. :param n: Number of elements in the array :param k: Integer value to check divisibility :param array: List of integers :return: Number of contiguous subarrays whose sum is divisible by \`k\` Examples: >>> count_subarrays_with_sum_divisible_by_k(5, 5, [5, 10, 15, 20, 25]) 15 >>> count_subarrays_with_sum_divisible_by_k(5, 2, [1, 2, 3, 4, 5]) 6","solution":"def count_subarrays_with_sum_divisible_by_k(n, k, array): Returns the number of contiguous subarrays whose sum is divisible by k. prefix_sum = 0 mod_count = {0: 1} # For subarrays starting from the beginning count = 0 for num in array: prefix_sum += num mod_value = prefix_sum % k if mod_value < 0: # correcting for negative mod values mod_value += k if mod_value in mod_count: count += mod_count[mod_value] mod_count[mod_value] += 1 else: mod_count[mod_value] = 1 return count"},{"question":"def knapsack_with_budget(n: int, B: int, W: int, items: List[Tuple[int, int, int]]) -> int: Determine the maximum total value of items you can select without exceeding the budget B and the max weight W. >>> knapsack_with_budget(3, 50, 10, [(60, 10, 2), (100, 20, 3), (120, 30, 5)]) 220 >>> knapsack_with_budget(4, 100, 20, [(50, 10, 5), (60, 20, 10), (70, 25, 12), (80, 30, 15)]) 130 pass def solve_knapsack_problem(test_cases: List[Tuple[int, int, int, List[Tuple[int, int, int]]]]) -> List[int]: Solve multiple knapsack problems given a list of test cases. >>> solve_knapsack_problem([ ... (3, 50, 10, [(60, 10, 2), (100, 20, 3), (120, 30, 5)]), ... (4, 100, 20, [(50, 10, 5), (60, 20, 10), (70, 25, 12), (80, 30, 15)]) ... ]) [220, 130] pass def test_knapsack_with_budget(): test_cases = [ (3, 50, 10, [(60, 10, 2), (100, 20, 3), (120, 30, 5)]), (4, 100, 20, [(50, 10, 5), (60, 20, 10), (70, 25, 12), (80, 30, 15)]), ] expected_outputs = [ 220, # The maximum value for the first test case 130 # The maximum value for the second test case ] results = solve_knapsack_problem(test_cases) for result, expected in zip(results, expected_outputs): assert result == expected, f\\"Expected {expected}, but got {result}\\" test_knapsack_with_budget()","solution":"def knapsack_with_budget(n, B, W, items): dp = [[0] * (W + 1) for _ in range(B + 1)] for v, c, w in items: for budget in range(B, c - 1, -1): for weight in range(W, w - 1, -1): dp[budget][weight] = max(dp[budget][weight], dp[budget - c][weight - w] + v) return dp[B][W] def solve_knapsack_problem(test_cases): results = [] for test_case in test_cases: n, B, W, items = test_case max_value = knapsack_with_budget(n, B, W, items) results.append(max_value) return results"},{"question":"from typing import List, Tuple def solve(n: int, m: int, edges: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[str]: Determine if there is a path between two cities for given queries. Args: n: An integer representing the number of cities. m: An integer representing the number of roads. edges: A list of tuples where each tuple represents a direct road between two cities. queries: A list of tuples where each tuple contains two cities to query. Returns: A list of strings where each string is either \\"yes\\" or \\"no\\" indicating if there is a path between the queried cities. >>> solve(5, 4, [(0, 1), (1, 2), (3, 4), (0, 4)], [(0, 2), (1, 3), (2, 4)]) [\\"yes\\", \\"yes\\", \\"yes\\"] >>> solve(6, 4, [(0, 1), (1, 2), (3, 4), (4, 5)], [(0, 2), (1, 5), (2, 3)]) [\\"yes\\", \\"no\\", \\"no\\"] >>> solve(1, 0, [], [(0, 0)]) [\\"yes\\"] >>> solve(3, 0, [], [(0, 1), (1, 2), (0, 2)]) [\\"no\\", \\"no\\", \\"no\\"] >>> solve(4, 3, [(0, 1), (1, 2), (2, 3)], [(0, 3), (1, 2), (0, 2)]) [\\"yes\\", \\"yes\\", \\"yes\\"]","solution":"from collections import defaultdict, deque def find_connected_components(n, edges): # Initialize graph graph = defaultdict(list) for x, y in edges: graph[x].append(y) graph[y].append(x) # To keep track of visited cities visited = [False] * (n + 1) components = [-1] * (n + 1) def bfs(start, component_id): queue = deque([start]) visited[start] = True components[start] = component_id while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True components[neighbor] = component_id queue.append(neighbor) # Find all connected components current_component = 0 for city in range(n): if not visited[city]: bfs(city, current_component) current_component += 1 return components def solve(n, m, edges, queries): # Find components to answer the queries in O(1) time components = find_connected_components(n, edges) results = [] for a, b in queries: results.append(\\"yes\\" if components[a] == components[b] else \\"no\\") return results"},{"question":"def vertex_degrees(N, vertices): Given the number of vertices N and the list of vertex coordinates, returns the degree of each vertex. Parameters: N (int): Number of vertices. vertices (list of tuples): List of tuples, where each tuple contains the coordinates (x, y) of a vertex. Returns: list of int: Degrees of each vertex. Example usage: >>> vertex_degrees(5, [(0, 0), (2, 0), (2, 2), (1, 1), (0, 2)]) [2, 2, 2, 2, 2] >>> vertex_degrees(4, [(1, 1), (4, 1), (4, 4), (1, 4)]) [2, 2, 2, 2]","solution":"def vertex_degrees(N, vertices): Given the number of vertices N and the list of vertex coordinates, returns the degree of each vertex. Parameters: N (int): Number of vertices. vertices (list of tuples): List of tuples, where each tuple contains the coordinates (x, y) of a vertex. Returns: list of int: Degrees of each vertex. # In a simple polygon, each vertex is connected to its two immediate neighbors. return [2] * N # Example usage: # N = 5 # vertices = [(0, 0), (2, 0), (2, 2), (1, 1), (0, 2)] # print(vertex_degrees(N, vertices)) # Output: [2, 2, 2, 2, 2]"},{"question":"def max_non_adjacent_sum(values): Returns the maximum sum of non-adjacent elements in the list 'values'. Paul and Mary collectively gather rare coins with the maximum possible sum of values without picking two adjacent coins. Args: values (List[int]): List of integers representing the coin values. Returns: int: Maximum sum of values they can collectively gather without picking two adjacent coins. Example: >>> max_non_adjacent_sum([2, 4, 6, 2, 5]) 13 >>> max_non_adjacent_sum([3, 2, 5, 10]) 13","solution":"def max_non_adjacent_sum(values): Returns the maximum sum of non-adjacent elements in the list 'values'. if not values: return 0 n = len(values) if n == 1: return values[0] dp = [0] * n dp[0] = values[0] dp[1] = max(values[0], values[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + values[i]) return dp[-1]"},{"question":"def max_pairs(arr, x): Returns the maximum number of pairs where the sum of each pair is less than or equal to x. >>> max_pairs([1, 2, 3, 4, 5], 6) 2 >>> max_pairs([1, 1, 1, 1], 2) 2 >>> max_pairs([5, 6, 7, 8, 9], 4) 0 >>> max_pairs([2, 2, 2, 2], 3) 0 >>> max_pairs([1, 2, 3, 4, 5], 8) 2 >>> max_pairs([1], 1) 0 >>> max_pairs([], 10) 0 >>> max_pairs([1, 3, 3, 5, 6], 7) 2 >>> max_pairs([1, 2], 3) 1 >>> max_pairs([1, 2, 2, 3], 5) 2 >>> max_pairs([1, 2, 2, 3, 4], 6) 2 >>> max_pairs([1, 1, 1, 1], 1) 0","solution":"def max_pairs(arr, x): Returns the maximum number of pairs where the sum of each pair is less than or equal to x. left = 0 right = len(arr) - 1 count = 0 while left < right: if arr[left] + arr[right] <= x: count += 1 left += 1 right -= 1 else: right -= 1 return count"},{"question":"def max_happiness(s: int, b: int, stalls: List[List[Tuple[int, int]]]) -> int: Determine the maximum happiness David can achieve within his budget. >>> max_happiness(2, 50, [[[300, 30], [200, 20], [100, 10]], [[400, 40], [150, 15]]]) == 500 >>> max_happiness(2, 10, [[[1000, 100], [2000, 200]], [[1500, 150], [2500, 250]]]) == 0 >>> max_happiness(2, 10000, [[[100, 1], [200, 2]], [[150, 1], [250, 2]]]) == 450 >>> max_happiness(1, 100, [[[10, 30], [20, 80], [30, 100]]]) == 30 >>> max_happiness(1, 1000000, [[[10, 500000], [20, 800000], [30, 900000]]]) == 30 >>> max_happiness(3, 100, [[[20, 30], [15, 20], [25, 25]], [[30, 50], [10, 10]], [[35, 40], [20, 20], [15, 15], [25, 30]]]) == 75 pass # your implementation here def parse_input(input_str: str) -> Tuple[int, int, List[List[Tuple[int, int]]]]: Parse the provided input string and return the number of stalls, budget, and list of items in each stall. >>> parse_input('2 50n3n300 30n200 20n100 10n2n400 40n150 15') (2, 50, [[[300, 30], [200, 20], [100, 10]], [[400, 40], [150, 15]]]) >>> parse_input('1 100n3n10 30n20 80n30 100') (1, 100, [[[10, 30], [20, 80], [30, 100]]]) pass # your implementation here","solution":"def max_happiness(s, b, stalls): # Initialize dp array to hold the max happiness for given budget dp = [0] * (b + 1) # Loop through each stall for i in range(s): new_dp = dp[:] for happiness, cost in stalls[i]: for current_budget in range(b, cost - 1, -1): new_dp[current_budget] = max(new_dp[current_budget], dp[current_budget - cost] + happiness) dp = new_dp return dp[b] def parse_input(input_str): lines = input_str.strip().split('n') s, b = map(int, lines[0].split()) stalls = [] inf = 1 for _ in range(s): n_i = int(lines[inf]) inf += 1 items = [] for _ in range(n_i): h_ij, c_ij = map(int, lines[inf].split()) items.append((h_ij, c_ij)) inf += 1 stalls.append(items) return s, b, stalls"},{"question":"from typing import List, Tuple def min_steps_to_destination(n: int, m: int, start_x: int, start_y: int, end_x: int, end_y: int, walls: List[Tuple[int, int]]) -> int: Find the minimum number of steps required for a robot to move from the starting point to the destination point on a grid, while avoiding walls. Args: n (int): number of rows in the grid. m (int): number of columns in the grid. start_x (int): starting x-coordinate of the robot. start_y (int): starting y-coordinate of the robot. end_x (int): destination x-coordinate of the robot. end_y (int): destination y-coordinate of the robot. walls (List[Tuple[int, int]]): list of wall coordinates where the robot cannot pass. Returns: int: minimum number of steps required to reach the destination, or -1 if not possible. >>> min_steps_to_destination(5, 5, 0, 0, 4, 4, [(1, 1), (1, 2), (2, 2), (3, 2)]) 8 >>> min_steps_to_destination(5, 5, 0, 0, 0, 0, []) 0 >>> min_steps_to_destination(5, 5, 0, 0, 4, 4, [(0, 1), (1, 0)]) -1","solution":"from collections import deque def min_steps_to_destination(n, m, start_x, start_y, end_x, end_y, walls): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # up, down, left, right walls_set = set(walls) queue = deque([(start_x, start_y, 0)]) # (x, y, steps) visited = set((start_x, start_y)) while queue: x, y, steps = queue.popleft() if (x, y) == (end_x, end_y): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in walls_set and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"def longestAP(arr): Returns the length of the longest subarray which can be arranged to form an arithmetic progression. :param arr: List[int] - list of integers :return: int - the length of the longest subarray forming an arithmetic progression import pytest def test_longest_ap_case_1(): arr = [1, 7, 10, 13, 14, 19] assert longestAP(arr) == 4 def test_longest_ap_case_2(): arr = [2, 4, 6, 8, 10] assert longestAP(arr) == 5 def test_longest_ap_case_3(): arr = [1, 3, 5, 7] assert longestAP(arr) == 4 def test_longest_ap_empty(): arr = [] assert longestAP(arr) == 0 def test_longest_ap_single_element(): arr = [1] assert longestAP(arr) == 1 def test_longest_ap_identical_elements(): arr = [5, 5, 5, 5, 5] assert longestAP(arr) == 5 if __name__ == \\"__main__\\": pytest.main()","solution":"def longestAP(arr): Returns the length of the longest subarray which can be arranged to form an arithmetic progression. :param arr: List[int] - list of integers :return: int - the length of the longest subarray forming an arithmetic progression if not arr: return 0 n = len(arr) if n <= 2: return n arr.sort() longest_ap_len = 2 # Minimum length of any AP including two elements dp = [{} for _ in range(n)] for j in range(1, n): for i in range(j): diff = arr[j] - arr[i] if diff in dp[i]: dp[j][diff] = dp[i][diff] + 1 else: dp[j][diff] = 2 longest_ap_len = max(longest_ap_len, dp[j][diff]) return longest_ap_len def find_longest_aps(test_cases): results = [] for case in test_cases: arr = case result = longestAP(arr) results.append(result) return results"},{"question":"def minimize_max_segment_length(D: int, N: int, M: int) -> int: Determine the minimum possible length of the longest segment after optimally using the breaks. Parameters: D (int): Total distance to be covered. N (int): Number of initial segments. M (int): Number of allowable breaks. Returns: int: Minimum possible length of the longest segment. >>> minimize_max_segment_length(100, 10, 5) 10 >>> minimize_max_segment_length(1000, 10, 990) 1 >>> minimize_max_segment_length(999, 3, 2) 333 >>> minimize_max_segment_length(500, 1, 0) 500 >>> minimize_max_segment_length(1000000000000, 100000, 1000000000000000000) 1","solution":"def minimize_max_segment_length(D, N, M): Determine the minimum possible length of the longest segment after optimally using the breaks. Parameters: D (int): Total distance to be covered. N (int): Number of initial segments. M (int): Number of allowable breaks. Returns: int: Minimum possible length of the longest segment. # Binary search to find the optimal length of the longest segment def can_divide_with_max_length(length): total_segments = 0 for i in range(N): # Calculate the number of segments required for each one total_segments += (D // N + length - 1) // length - 1 return total_segments <= M left, right = 1, D while left < right: mid = (left + right) // 2 if can_divide_with_max_length(mid): right = mid else: left = mid + 1 return left"},{"question":"from typing import List def has_even_sum_subset(array: List[int]) -> str: Function to determine if there exists a subset of the array such that the sum of the subset is an even number. >>> has_even_sum_subset([1, 2, 3]) 'YES' >>> has_even_sum_subset([2, 4, 5, 5]) 'YES' >>> has_even_sum_subset([1, 3]) 'NO' >>> has_even_sum_subset([1, 3, 5]) 'NO' >>> has_even_sum_subset([2]) 'YES' >>> has_even_sum_subset([1]) 'NO' def process_test_cases(test_cases: List[List[int]]) -> List[str]: Process multiple test cases to determine for each if there is a subset of the array with an even sum. >>> process_test_cases([[1, 2, 3], [2, 4, 5, 5]]) ['YES', 'YES'] >>> process_test_cases([[1, 3], [1, 3, 5]]) ['NO', 'NO'] >>> process_test_cases([[2], [1]]) ['YES', 'NO']","solution":"def has_even_sum_subset(array): Function to determine if there exists a subset of the array such that the sum of the subset is an even number. for num in array: if num % 2 == 0: return \\"YES\\" return \\"NO\\" def process_test_cases(test_cases): Process multiple test cases to determine for each if there is a subset of the array with an even sum. results = [] for array in test_cases: results.append(has_even_sum_subset(array)) return results"},{"question":"def shortest_subarray_length(arr, n, x): Function to find the length of the shortest subarray with a sum greater than or equal to x. If no such subarray exists, return -1. pass def process_test_cases(test_cases): Function to process multiple test cases and return the results as a list. Args: test_cases (List[Tuple[int, int, List[int]]]): List of test cases where each test case is a tuple consisting of: - n: number of elements in the array - x: the target sum - arr: list of integers representing the elements of the array Returns: List[int]: List of results for each test case, where each result is the length of the shortest subarray with a sum greater than or equal to x, or -1 if no such subarray exists. pass from solution import process_test_cases def test_sample_input_1(): test_cases = [ (5, 15, [1, 2, 3, 4, 5]), (10, 55, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) ] expected_output = [5, 10] assert process_test_cases(test_cases) == expected_output def test_no_subarray_found(): test_cases = [ (5, 100, [1, 2, 3, 4, 5]), ] expected_output = [-1] assert process_test_cases(test_cases) == expected_output def test_single_element_subarray(): test_cases = [ (5, 4, [1, 2, 3, 4, 5]), ] expected_output = [1] assert process_test_cases(test_cases) == expected_output def test_multiple_subarrays(): test_cases = [ (10, 15, [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]), ] expected_output = [5] assert process_test_cases(test_cases) == expected_output def test_large_array(): test_cases = [ (10**5, 10**6, [1] * (10**5)), ] expected_output = [-1] assert process_test_cases(test_cases) == expected_output","solution":"def shortest_subarray_length(arr, n, x): Function to find the length of the shortest subarray with a sum greater than or equal to x. If no such subarray exists, return -1. min_len = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= x: min_len = min(min_len, end - start + 1) current_sum -= arr[start] start += 1 return min_len if min_len != float('inf') else -1 def process_test_cases(test_cases): results = [] for test_case in test_cases: n, x, arr = test_case result = shortest_subarray_length(arr, n, x) results.append(result) return results"},{"question":"from typing import List def min_moves_to_reach_end(n: int, m: int, grid: List[List[int]]) -> int: Determine the minimum number of moves the drone needs to reach the bottom-right corner from the top-left corner in the grid. >>> min_moves_to_reach_end(5, 5, [ ... [0, 0, 0, 0, 0], ... [0, 1, 1, 1, 0], ... [0, 1, 0, 1, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 1, 0] ... ]) == 8 >>> min_moves_to_reach_end(3, 3, [ ... [0, 1, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 4","solution":"from collections import deque def min_moves_to_reach_end(n, m, grid): # Directions arrays for right, left, down, up directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # Initialize visited matrix visited = [[False for _ in range(m)] for _ in range(n)] # Queue for BFS: stores (row, col, steps) queue = deque([(0, 0, 0)]) visited[0][0] = True while queue: r, c, steps = queue.popleft() # Check if we've reached the bottom-right corner if r == n-1 and c == m-1: return steps # Explore the neighbors for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and not visited[nr][nc] and grid[nr][nc] == 0: queue.append((nr, nc, steps + 1)) visited[nr][nc] = True # If no path was found return -1"},{"question":"def minimum_round_trip_distance(n: int, cities: List[int]) -> int: Compute the minimum distance the truck has to travel to deliver all the packages and return to its starting city. Args: n (int): The number of cities (1 ≤ n ≤ 50) cities (List[int]): The coordinates of the cities on the highway (−10⁴ ≤ xᵢ ≤ 10⁴) Returns: int: The minimum round trip distance >>> minimum_round_trip_distance(3, [-2, 0, 4]) 12 >>> minimum_round_trip_distance(2, [-1, 2]) 6 >>> minimum_round_trip_distance(1, [5]) 0 >>> minimum_round_trip_distance(3, [0, 5000, 10000]) 20000 >>> minimum_round_trip_distance(4, [-1000, 0, 1000, 2000]) 6000","solution":"def minimum_round_trip_distance(n, cities): Compute the minimum distance the truck has to travel to deliver all the packages and return to its starting city. Args: - n: int, number of cities - cities: list of int, coordinates of the cities on the highway Returns: - int, minimum round trip distance min_city = min(cities) max_city = max(cities) # The optimal trip is to start at either the min or max city, # travel to the other end, and return back. total_distance = 2 * (max_city - min_city) return total_distance"},{"question":"def max_profit(arr): Returns the maximum possible profit by buying one day and selling on another day later. Args: arr (List[int]): A non-empty list of positive integers representing daily stock prices. Returns: int: The maximum profit that can be achieved. If no profit is possible, return 0. Examples: >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"def max_profit(arr): Returns the maximum possible profit by buying one day and selling on another day later. if not arr or len(arr) < 2: return 0 max_profit = 0 min_price = arr[0] for price in arr: if price < min_price: min_price = price current_profit = price - min_price if current_profit > max_profit: max_profit = current_profit return max_profit"},{"question":"def is_strong_password(password: str) -> str: Check if the given password meets the startup's security criteria. The password must be at least 8 characters long, contain at least one uppercase letter, one lowercase letter, one numeric digit, and one special character from the set '!@#%^&*()-+' >>> is_strong_password(\\"Hello@123\\") \\"YES\\" >>> is_strong_password(\\"Weakpass\\") \\"NO\\" >>> is_strong_password(\\"Str0ngP@ssword\\") \\"YES\\" >>> is_strong_password(\\"short7@\\") \\"NO\\" >>> is_strong_password(\\"NoSpec1alChar\\") \\"NO\\" >>> is_strong_password(\\"noupper@1\\") \\"NO\\" >>> is_strong_password(\\"NOLOWER@1\\") \\"NO\\" def check_passwords(t: int, passwords: List[str]) -> List[str]: Check multiple passwords against the security criteria. The function accepts an integer t (number of test cases) and a list of passwords. It returns a list where each element is either \\"YES\\" or \\"NO\\" indicating if the corresponding password is strong. >>> check_passwords(3, [\\"Hello@123\\", \\"Weakpass\\", \\"Str0ngP@ssword\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> check_passwords(2, [\\"@2Short\\", \\"NoDigit!\\"]) [\\"NO\\", \\"NO\\"] >>> check_passwords(1, [\\"Good1@Password\\"]) [\\"YES\\"] >>> check_passwords(0, []) []","solution":"import re def is_strong_password(password): This function checks if the given password meets the security criteria. if len(password) < 8: return \\"NO\\" if not re.search(r'[A-Z]', password): return \\"NO\\" if not re.search(r'[a-z]', password): return \\"NO\\" if not re.search(r'[0-9]', password): return \\"NO\\" if not re.search(r'[!@#%^&*()-+]', password): return \\"NO\\" return \\"YES\\" def check_passwords(t, passwords): This function accepts multiple passwords and checks if each one meets the security criteria. It returns a list of results, each being \\"YES\\" or \\"NO\\". results = [] for password in passwords: results.append(is_strong_password(password)) return results"},{"question":"from typing import List def fill_distances(grid: List[List[int]]) -> List[List[int]]: Update each empty space in the grid with the distance to the nearest wall. Walls are represented by -1 and empty spaces by 0. :param grid: List[List[int]] - 2D grid of integers with walls (-1) and empty spaces (0) :return: List[List[int]] - Updated grid with distances to the nearest wall >>> fill_distances([[-1, 0, 0], [0, 0, 0], [0, 0, -1]]) [[-1, 1, 2], [1, 2, 1], [2, 1, -1]] >>> fill_distances([[0, -1, 0], [0, 0, 0]]) [[1, -1, 1], [2, 1, 2]]","solution":"from collections import deque def fill_distances(grid): Update each empty space in the grid with the distance to the nearest wall. Walls are represented by -1 and empty spaces by 0. :param grid: List[List[int]] - 2D grid of integers with walls (-1) and empty spaces (0) :return: List[List[int]] - Updated grid with distances to the nearest wall if not grid: return grid rows, cols = len(grid), len(grid[0]) queue = deque() # Initialize queue with walls and their positions for r in range(rows): for c in range(cols): if grid[r][c] == -1: queue.append((r, c, 0)) # (row, column, distance) # Direction vectors for moving in 4 cardinal directions directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: r, c, dist = queue.popleft() for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 0: grid[nr][nc] = dist + 1 queue.append((nr, nc, dist + 1)) return grid"},{"question":"def min_phases(M: int, R: int, roads: List[Tuple[int, int]]) -> int: Determine the minimum number of phases required to conduct the maintenance in such a way that no two directly connected roads are closed simultaneously. >>> min_phases(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 2 >>> min_phases(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 3)]) 3 pass","solution":"def min_phases(M, R, roads): from collections import defaultdict def is_bipartite(graph, start, colors): queue = [start] colors[start] = 0 # Start coloring with 0 while queue: node = queue.pop(0) current_color = colors[node] for neighbor in graph[node]: if colors[neighbor] == -1: # If not colored yet colors[neighbor] = 1 - current_color # Alternate color queue.append(neighbor) elif colors[neighbor] == current_color: # If the same color return False return True graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) colors = [-1] * (M + 1) for node in range(1, M + 1): if colors[node] == -1: if not is_bipartite(graph, node, colors): return 3 # If not bipartite, we need 3 colors/phases return 2 # If bipartite, we can always manage with 2 colors/phases"},{"question":"def max_buildings_reachable(heights): Function to return the maximum number of buildings the ball can be thrown to. >>> max_buildings_reachable([1, 2, 3, 4, 5, 6]) 5 >>> max_buildings_reachable([6, 5, 4, 3, 2, 1]) 0 >>> max_buildings_reachable([2, 3, 4, 1, 5, 6, 1, 7]) 5 >>> max_buildings_reachable([10]) 0 >>> max_buildings_reachable([5, 10]) 1 >>> max_buildings_reachable([5, 5]) 0 >>> max_buildings_reachable([10, 5]) 0 >>> max_buildings_reachable([10, 1, 12, 3, 6, 5, 9, 8, 11, 15, 7]) 5 >>> max_buildings_reachable([2, 2, 2, 3, 3, 4, 4, 5, 5]) 3","solution":"def max_buildings_reachable(heights): Function to return the maximum number of buildings the ball can be thrown to. n = len(heights) if n == 0: return 0 # This will store the length of the longest increasing subsequence found so far. dp = [1] * n for i in range(1, n): for j in range(0, i): if heights[i] > heights[j]: dp[i] = max(dp[i], dp[j] + 1) # The maximum number of buildings reached from the initial one would be # length of the longest subsequence minus 1 (starting building itself is not included) return max(dp) - 1"},{"question":"from typing import List def subsets(nums: List[int]) -> List[List[int]]: Given an array of unique integers, returns all possible subsets (the power set). Each subset will be sorted in ascending order, and the power set will be returned with subsets sorted lexicographically. >>> subsets([1, 2, 3]) [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]] >>> subsets([]) [[]] >>> subsets([10]) [[], [10]] >>> subsets([1, 2]) [[], [1], [1, 2], [2]] >>> subsets([1, 2, 3, 4]) [[], [1], [1, 2], [1, 2, 3], [1, 2, 3, 4], [1, 2, 4], [1, 3], [1, 3, 4], [1, 4], [2], [2, 3], [2, 3, 4], [2, 4], [3], [3, 4], [4]] >>> subsets([3, 1, 2]) [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]","solution":"def subsets(nums): Given an array of unique integers, returns all possible subsets (the power set). Each subset will be sorted in ascending order, and the power set will be returned with subsets sorted lexicographically. def backtrack(start, path): result.append(path[:]) for i in range(start, len(nums)): path.append(nums[i]) backtrack(i + 1, path) path.pop() result = [] nums.sort() # Sort to ensure lexicographical order backtrack(0, []) return result"},{"question":"def is_strongly_connected(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determines if it's possible to visit every section starting from any section, passing through the directed edges. Args: n: Number of sections. m: Number of directed edges. edges: List of tuples representing directed edges. Returns: \\"YES\\" if the graph is strongly connected, otherwise \\"NO\\". >>> is_strongly_connected(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) == \\"YES\\" >>> is_strongly_connected(4, 3, [(1, 2), (2, 3), (4, 1)]) == \\"NO\\" >>> is_strongly_connected(4, 6, [(1, 2), (2, 3), (3, 1), (3, 4), (4, 1), (4, 3)]) == \\"YES\\" >>> is_strongly_connected(1, 0, []) == \\"YES\\" >>> is_strongly_connected(4, 2, [(1, 2), (3, 4)]) == \\"NO\\" >>> is_strongly_connected(2, 2, [(1, 2), (2, 1)]) == \\"YES\\" >>> is_strongly_connected(2, 1, [(1, 2)]) == \\"NO\\"","solution":"from collections import defaultdict def is_strongly_connected(n, m, edges): Determines if the graph is strongly connected. Args: n: Number of sections. m: Number of directed edges. edges: List of tuples representing directed edges. Returns: \\"YES\\" if the graph is strongly connected, otherwise \\"NO\\". def dfs(graph, start, visited): stack = [start] while stack: node = stack.pop() if not visited[node]: visited[node] = True stack.extend(graph[node]) if n == 1: return \\"YES\\" graph = defaultdict(list) reverse_graph = defaultdict(list) for u, v in edges: graph[u].append(v) reverse_graph[v].append(u) visited = [False] * (n + 1) dfs(graph, 1, visited) if not all(visited[1:]): return \\"NO\\" visited = [False] * (n + 1) dfs(reverse_graph, 1, visited) if all(visited[1:]): return \\"YES\\" else: return \\"NO\\""},{"question":"def minimize_max_difference(N: int, heights: List[int]) -> int: Given an array of integers representing the initial heights of grains in a series of silos, redistribute the grains such that the maximum difference in height between any two silos is minimized. Only adjacent silos can exchange grains and each transfer reduces the difference by 1 unit. Args: N (int): The number of silos. heights (List[int]): List of integers representing initial heights of grains in each silo. Returns: int: The minimized maximum difference in height between any two silos after redistributing the grains. Examples: >>> minimize_max_difference(5, [4, 10, 8, 6, 2]) 1 >>> minimize_max_difference(4, [3, 3, 3, 3]) 0","solution":"def minimize_max_difference(N, heights): def possible(max_diff): water = heights[:] # copy of the heights for _ in range(max_diff * N): changed = False for i in range(1, N): if water[i] - water[i - 1] > max_diff: transfer = (water[i] - water[i - 1] - max_diff + 1) // 2 water[i] -= transfer water[i - 1] += transfer changed = True if not changed: return True return False low, high = 0, max(heights) - min(heights) while low < high: mid = (low + high) // 2 if possible(mid): high = mid else: low = mid + 1 return low # Example usage: N = 5 heights = [4, 10, 8, 6, 2] print(minimize_max_difference(N, heights)) # Output: 1"},{"question":"from typing import List, Tuple def maximize_paintings(T: int, test_cases: List[Tuple[Tuple[int, int], List[Tuple[int, int]]]]) -> List[int]: You are planning to open a set of art galleries in different cities. Each gallery will display a certain number of paintings, and you have budget constraints on how much you can spend on renting a gallery space in each city. Your goal is to maximize the total number of paintings displayed across all galleries within your budget. You have the details of each city’s gallery such as the maximum number of paintings it can display and its rental cost. Args: T: Number of test cases test_cases: A list of tuples where each tuple contains - A tuple (N, B) where N is the number of galleries in the city and B is the total budget - A list of tuples where each tuple contains (Pi, Ci) representing the number of paintings and the rental cost respectively Returns: A list of integers where each integer represents the maximum number of paintings that can be displayed for each test case >>> maximize_paintings(3, [((3, 7), [(5, 4), (9, 8), (3, 3)]), ((2, 5), [(2, 5), (4, 3)]), ((2, 10), [(5, 10), (8, 4)])]) [8, 4, 8] >>> maximize_paintings(1, [((3, 6), [(1, 2), (2, 3), (3, 4)])]) [3] >>> maximize_paintings(2, [((2, 10), [(10, 11), (5, 5)]), ((1, 1), [(1, 2)])]) [5, 0] >>> maximize_paintings(1, [((3, 10), [(3, 3), (6, 4), (7, 6)])]) [9] >>> maximize_paintings(1, [((4, 20), [(10, 10), (8, 8), (3, 5), (6, 7)])]) [17] pass # Your code here","solution":"def maximize_paintings(T, test_cases): results = [] for i in range(T): N, B = test_cases[i][0] galleries = test_cases[i][1] # Sort the galleries in non-decreasing order of their rental cost galleries.sort(key=lambda x: x[1]) total_paintings = 0 total_cost = 0 for paintings, cost in galleries: if total_cost + cost <= B: total_cost += cost total_paintings += paintings results.append(total_paintings) return results"},{"question":"def max_sum_after_one_swap(n: int, k: int, a: List[int]) -> int: Determine the maximum possible sum of the first \`k\` integers in the array after at most one swap operation. Parameters: n (int): The number of elements in the array. k (int): The number of elements to consider for the sum. a (list): The list of integers representing the array. Returns: int: The maximum possible sum of the first \`k\` integers after at most one swap. >>> max_sum_after_one_swap(5, 3, [3, 6, 1, 8, 2]) 17 >>> max_sum_after_one_swap(4, 2, [9, 4, 7, 3]) 16 >>> max_sum_after_one_swap(3, 3, [1, 2, 3]) 6 import pytest from solution import max_sum_after_one_swap def test_no_swap_needed(): assert max_sum_after_one_swap(3, 3, [1, 2, 3]) == 6 def test_example_case_1(): assert max_sum_after_one_swap(5, 3, [3, 6, 1, 8, 2]) == 17 def test_example_case_2(): assert max_sum_after_one_swap(4, 2, [9, 4, 7, 3]) == 16 def test_all_elements_used(): assert max_sum_after_one_swap(4, 4, [9, 4, 7, 3]) == 23 def test_no_elements(): assert max_sum_after_one_swap(5, 0, [3, 6, 1, 8, 2]) == 0 def test_swap_max_in_first_k(): assert max_sum_after_one_swap(5, 3, [1, 3, 5, 8, 2]) == 16 assert max_sum_after_one_swap(5, 3, [2, 3, 5, 8, 1]) == 16 def test_simple_case(): assert max_sum_after_one_swap(2, 1, [1, 100]) == 100","solution":"def max_sum_after_one_swap(n, k, a): Determine the maximum possible sum of the first \`k\` integers in the array after at most one swap operation. Parameters: n (int): The number of elements in the array. k (int): The number of elements to consider for the sum. a (list): The list of integers representing the array. Returns: int: The maximum possible sum of the first \`k\` integers after at most one swap. if k == 0: return 0 initial_sum = sum(a[:k]) max_sum = initial_sum # Checking for all possible swaps in the first k and the elements after k for i in range(k): for j in range(k, n): new_sum = initial_sum - a[i] + a[j] max_sum = max(max_sum, new_sum) return max_sum"},{"question":"def minPathSum(grid): Given a 2D grid of size m x n filled with non-negative integers, find a path from the top-left corner to the bottom-right corner that minimizes the sum of all numbers along its path. You can only move either down or right at any point in time. m: an integer, number of rows. n: an integer, number of columns. grid: List[List[int]], the input 2D grid of non-negative integers. Returns an integer representing the minimum sum for the given 2D grid. >>> minPathSum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> minPathSum([[1, 2, 3], [4, 5, 6]]) 12","solution":"def minPathSum(grid): if not grid: return 0 m, n = len(grid), len(grid[0]) for i in range(1, m): grid[i][0] += grid[i-1][0] for j in range(1, n): grid[0][j] += grid[0][j-1] for i in range(1, m): for j in range(1, n): grid[i][j] += min(grid[i-1][j], grid[i][j-1]) return grid[m-1][n-1]"},{"question":"def transformList(nums): Transforms the given list such that each element is replaced by the difference between the maximum and minimum element among the previous elements including itself (0 if no previous element). >>> transformList([3, 1, 4, 1, 5, 9, 2, 6]) [0, 2, 3, 3, 4, 8, 8, 8] >>> transformList([7, 6, 5, 4, 3]) [0, 1, 2, 3, 4] >>> transformList([10]) [0] >>> transformList([5, 10]) [0, 5] >>> transformList([10, 5]) [0, 5] >>> transformList([4, 4, 4, 4]) [0, 0, 0, 0] >>> transformList([]) []","solution":"def transformList(nums): Transforms the given list such that each element is replaced by the difference between the maximum and minimum element among the previous elements including itself (0 if no previous element). if not nums: return [] min_so_far = nums[0] max_so_far = nums[0] result = [0] for i in range(1, len(nums)): if nums[i] < min_so_far: min_so_far = nums[i] if nums[i] > max_so_far: max_so_far = nums[i] result.append(max_so_far - min_so_far) return result"},{"question":"def longest_positive_subarray_length(test_cases): Return the length of the longest contiguous subarray with a strictly positive sum for each test case. >>> longest_positive_subarray_length([(5, [-1, 2, 3, -5, 4])]) [2] >>> longest_positive_subarray_length([(5, [-1, 2, 3, -5, 4]), (6, [1, -2, 2, 3, -3, 2])]) [2, 4] >>> longest_positive_subarray_length([(4, [-1, -2, -3, -4])]) [0] >>> longest_positive_subarray_length([(5, [-1, -2, 3, 4, 5])]) [3] >>> longest_positive_subarray_length([(5, [1, 2, 3, 4, 5])]) [5] >>> longest_positive_subarray_length([(1, [5])]) [1] >>> longest_positive_subarray_length([(1, [-5])]) [0] >>> longest_positive_subarray_length([]) []","solution":"def longest_positive_subarray_length(test_cases): results = [] for case in test_cases: n, array = case max_len = 0 current_len = 0 current_sum = 0 for num in array: current_sum += num if current_sum > 0: current_len += 1 else: current_sum = 0 current_len = 0 if current_len > max_len: max_len = current_len results.append(max_len) return results"},{"question":"def rotate_matrix(matrix): Rotates an NxN matrix 90 degrees clockwise in place. Example: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) >>> matrix [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> matrix = [ ... [5, 1, 9, 11], ... [2, 4, 8, 10], ... [13, 3, 6, 7], ... [15, 14, 12, 16] ... ] >>> rotate_matrix(matrix) >>> matrix [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] >>> matrix = [ ... [1] ... ] >>> rotate_matrix(matrix) >>> matrix [ [1] ]","solution":"def rotate_matrix(matrix): Rotates an NxN matrix 90 degrees clockwise in place. N = len(matrix) for layer in range(N // 2): first = layer last = N - 1 - layer for i in range(first, last): offset = i - first # Save top top = matrix[first][i] # Left to top matrix[first][i] = matrix[last - offset][first] # Bottom to left matrix[last - offset][first] = matrix[last][last - offset] # Right to bottom matrix[last][last - offset] = matrix[i][last] # top into right matrix[i][last] = top return matrix"},{"question":"from typing import List def find_single_number(nums: List[int]) -> int: Finds the single number that appears only once in a list where every other number appears exactly twice. Args: nums (List[int]): The input list of integers. Returns: int: The single number that appears only once. Examples: >>> find_single_number([4, 1, 2, 1, 2]) 4 >>> find_single_number([1]) 1 def test_find_single_number(): assert find_single_number([4, 1, 2, 1, 2]) == 4 assert find_single_number([1]) == 1 assert find_single_number([2, 3, 2, 4, 4, 5, 6, 5, 6, 3, 7]) == 7 assert find_single_number([10, 10, -1, -1, -2, -2, 3, 4, 4]) == 3 assert find_single_number([0, 1, 0]) == 1 assert find_single_number([11, 22, 33, 44, 22, 33, 44]) == 11 assert find_single_number([99, 100, 101, 100, 101, 99, 102]) == 102","solution":"from typing import List def find_single_number(nums: List[int]) -> int: Finds the single number that appears only once in a list where every other number appears exactly twice. Args: nums (List[int]): The input list of integers. Returns: int: The single number that appears only once. result = 0 for num in nums: result ^= num # XOR-ing all the elements will result in the single number return result"},{"question":"from typing import List, Tuple def find_tree(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determine if it's possible to convert the network into a tree, and if so, return the edges of the tree. >>> find_tree(4, 3, [(1, 2), (2, 3), (3, 4)]) 'Possiblen1 2n2 3n3 4' >>> find_tree(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 'Possiblen1 2n2 3n3 4' >>> find_tree(5, 3, [(1, 2), (2, 3), (3, 4)]) 'Impossible' pass","solution":"def find_tree(n, m, edges): if n - 1 > m: return \\"Impossible\\" parent = list(range(n + 1)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX return True return False tree_edges = [] for u, v in edges: if union(u, v): tree_edges.append((u, v)) if len(tree_edges) == n - 1: result = \\"Possiblen\\" result += \\"n\\".join(f\\"{u} {v}\\" for u, v in tree_edges) return result else: return \\"Impossible\\""},{"question":"def find_connected_components(n: int, edges: List[Tuple[int, int]]) -> int: Returns the number of connected components in a graph with n vertices and given edges. >>> find_connected_components(6, [(1, 2), (2, 3), (4, 5), (5, 6), (6, 4)]) 2 >>> find_connected_components(4, [(1, 2), (2, 3), (3, 4)]) 1 >>> find_connected_components(7, [(1, 2), (2, 3), (4, 5), (5, 6), (6, 4)]) 2 >>> find_connected_components(5, []) 5 >>> find_connected_components(1, []) 1 >>> find_connected_components(4, [(1, 2), (3, 4)]) 2 >>> find_connected_components(4, [(1, 2), (3, 4), (4, 4)]) 2","solution":"def find_connected_components(n, edges): Returns the number of connected components in a graph with n vertices and given edges from collections import defaultdict, deque # Create adjacency list for the graph adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) visited = [False] * (n + 1) def bfs(start): queue = deque([start]) while queue: node = queue.popleft() for neighbor in adj_list[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) connected_components = 0 for vertex in range(1, n + 1): if not visited[vertex]: visited[vertex] = True bfs(vertex) connected_components += 1 return connected_components # Example usage (not part of the actual function or tests): if __name__ == \\"__main__\\": n, m = 6, 5 edges = [(1, 2), (2, 3), (4, 5), (5, 6), (6, 4)] print(find_connected_components(n, edges)) # Output should be 2"},{"question":"def smallest_possible_sum(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Dalia is playing with a sequence of integers. She can perform the following operation on the sequence: choose any two adjacent integers and replace them with their sum. She wonders what the smallest possible sum of the sequence can be after performing this operation repeatedly until only one integer remains. Input: - The first line contains the number of test cases T. Each test case consists of two lines: the first line contains a positive integer N (the length of the sequence), and the second line contains N space-separated integers representing the sequence. Output: - For each test case, output a single integer - the smallest possible sum of the sequence after repeatedly performing the operation until only one integer remains. Constraints: - 1 ≤ T ≤ 20 - 2 ≤ N ≤ 50 - -1000 ≤ sequence element ≤ 1000 SAMPLE INPUT 2 3 1 3 2 4 -1 2 3 -4 SAMPLE OUTPUT 6 0 >>> smallest_possible_sum(2, [(3, [1, 3, 2]), (4, [-1, 2, 3, -4])]) [6, 0] >>> smallest_possible_sum(1, [(5, [-1, -2, -3, -4, -5])]) [-15] >>> smallest_possible_sum(1, [(3, [-1, 2, -3])]) [-2] >>> smallest_possible_sum(1, [(4, [0, 0, 0, 0])]) [0] >>> smallest_possible_sum(1, [(2, [1, 1])]) [2]","solution":"def smallest_possible_sum(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] sequence = test_cases[i][1] results.append(sum(sequence)) return results"},{"question":"def preprocess_array(arr): Preprocess the array to create a prefix sum array. >>> preprocess_array([1, 2, 3, 4, 5]) [0, 1, 3, 6, 10, 15] def query_sum(prefix_sum, l, r): Returns the sum of the subarray arr[l:r]. >>> query_sum([0, 1, 3, 6, 10, 15], 1, 3) 6 >>> query_sum([0, 1, 3, 6, 10, 15], 2, 4) 9 >>> query_sum([0, 1, 3, 6, 10, 15], 1, 5) 15","solution":"def preprocess_array(arr): Preprocess the array to create a prefix sum array. n = len(arr) prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + arr[i] return prefix_sum def query_sum(prefix_sum, l, r): Returns the sum of the subarray arr[l:r]. return prefix_sum[r] - prefix_sum[l - 1]"},{"question":"def longest_bitonic_subsequence(arr): Determine the length of the longest bitonic subsequence in the given array of integers. A bitonic subsequence is one that first strictly increases and then strictly decreases. Parameters: arr (List[int]): A list of positive integers. Returns: int: The length of the longest bitonic subsequence. Examples: >>> longest_bitonic_subsequence([1, 2, 1, 2, 3, 4, 5, 3, 2, 1]) 8 >>> longest_bitonic_subsequence([5, 4, 3, 2, 1]) 5 >>> longest_bitonic_subsequence([1, 11, 2, 10, 4, 5, 2, 1]) 6","solution":"def longest_bitonic_subsequence(arr): if not arr: return 0 n = len(arr) # increasing[i] will store the length of the longest increasing subsequence ending at i increasing = [1] * n # decreasing[i] will store the length of the longest decreasing subsequence starting at i decreasing = [1] * n # Fill increasing[] from left to right for i in range(1, n): for j in range(i): if arr[i] > arr[j] and increasing[i] < increasing[j] + 1: increasing[i] = increasing[j] + 1 # Fill decreasing[] from right to left for i in range(n-2, -1, -1): for j in range(n-1, i, -1): if arr[i] > arr[j] and decreasing[i] < decreasing[j] + 1: decreasing[i] = decreasing[j] + 1 # Find the maximum value of (increasing[i] + decreasing[i] - 1) max_length = 0 for i in range(n): max_length = max(max_length, increasing[i] + decreasing[i] - 1) return max_length"},{"question":"def find_champion(matches: List[str]) -> str: Determines the champion from a list of match results. Args: matches (list of str): A list of match results in the format \\"Player1 Player2 Winner\\". Returns: str: The name of the tournament champion. pass import pytest def test_example_case(): matches = [ \\"Alice Bob Alice\\", \\"Charlie Dave Charlie\\", \\"Alice Charlie Alice\\" ] assert find_champion(matches) == \\"Alice\\" def test_another_case(): matches = [ \\"A B A\\", \\"C D C\\", \\"A C A\\" ] assert find_champion(matches) == \\"A\\" def test_no_initial_players(): matches = [ \\"John Paul John\\", \\"Mike John Mike\\", \\"Mike Robert Mike\\" ] assert find_champion(matches) == \\"Mike\\" def test_abrupt_end(): matches = [ \\"X Y X\\", \\"Z W W\\", \\"X W X\\" ] assert find_champion(matches) == \\"X\\" if __name__ == \\"__main__\\": pytest.main()","solution":"def find_champion(matches): Determines the champion from a list of match results. Args: matches (list of str): A list of match results in the format \\"Player1 Player2 Winner\\". Returns: str: The name of the tournament champion. players = set() for match in matches: player1, player2, winner = match.split() players.add(player1) players.add(player2) players.add(winner) players.remove(player1) players.remove(player2) players.add(winner) return list(players)[0]"},{"question":"from typing import List def min_elements_to_add(numbers: List[int], target: int) -> int: Returns the minimum number of elements needed to add to the array to make at least one contiguous sub-array that sums to target. >>> min_elements_to_add([1, 2, 3, 4], 5) == 0 >>> min_elements_to_add([1, 1, 1], 4) == 1 >>> min_elements_to_add([], 10) == 1 pass","solution":"def min_elements_to_add(numbers, target): Returns the minimum number of elements needed to add to the array to make at least one contiguous sub-array that sums to target. n = len(numbers) current_sum = 0 prefix_sum_map = {0: -1} for i in range(n): current_sum += numbers[i] if current_sum - target in prefix_sum_map: if prefix_sum_map[current_sum - target] < i: return 0 prefix_sum_map[current_sum] = i # If the target can't be met by existing subarrays, # the only number we need to add is the target itself: return 1 if target not in prefix_sum_map else 0"},{"question":"def generate_sequence_descending(N): Generates the first N terms of the sequence (2^i - 1) in descending order. >>> generate_sequence_descending(3) [7, 3, 1] >>> generate_sequence_descending(5) [31, 15, 7, 3, 1] >>> generate_sequence_descending(1) [1] >>> generate_sequence_descending(4) [15, 7, 3, 1] >>> generate_sequence_descending(2) [3, 1] pass def process_test_cases(test_cases): Process multiple test cases and return results for each. Parameters: test_cases (list of int): List containing N values for each test case. Returns: list of list of int: Each inner list contains the sequence for that test case. >>> process_test_cases([3, 5]) [[7, 3, 1], [31, 15, 7, 3, 1]] >>> process_test_cases([1, 4]) [[1], [15, 7, 3, 1]] >>> process_test_cases([2]) [[3, 1]] >>> process_test_cases([3, 1]) [[7, 3, 1], [1]] pass","solution":"def generate_sequence_descending(N): Generates the first N terms of the sequence (2^i - 1) in descending order. sequence = [(2 ** i) - 1 for i in range(N, 0, -1)] return sequence def process_test_cases(test_cases): Process multiple test cases and return results for each. Parameters: test_cases (list of int): List containing N values for each test case. Returns: list of list of int: Each inner list contains the sequence for that test case. results = [] for N in test_cases: result = generate_sequence_descending(N) results.append(result) return results"},{"question":"def max_satisfied_friends(n: int, preferences: List[int]) -> int: Calculate the maximum number of friends that can be satisfied with their seating preferences. :param n: Number of friends :param preferences: List of integers representing the preferred number of people each friend wants to sit next to. :return: Maximum number of friends satisfied with their preferences. pass # Unit Test def test_single_friend(): assert max_satisfied_friends(1, [0]) == 1 def test_all_zero_preferences(): assert max_satisfied_friends(4, [0, 0, 0, 0]) == 4 def test_all_same_preferences(): assert max_satisfied_friends(4, [1, 1, 1, 1]) == 4 def test_misc_preferences(): assert max_satisfied_friends(5, [1, 2, 2, 1, 3]) == 5 def test_large_input(): preferences = [i % 5 for i in range(100)] assert max_satisfied_friends(100, preferences) == 100 def test_some_unsatisfiable(): assert max_satisfied_friends(5, [1, 6, 2, 1, 3]) == 4 def test_preference_all_friends(): assert max_satisfied_friends(3, [2, 2, 2]) == 3 def test_preference_more_than_total(): assert max_satisfied_friends(4, [0, 3, 5, 1]) == 3","solution":"def max_satisfied_friends(n, preferences): Calculate the maximum number of friends that can be satisfied with their seating preferences. :param n: Number of friends :param preferences: List of integers representing the preferred number of people each friend wants to sit next to. :return: Maximum number of friends satisfied with their preferences. satisfied = 0 max_pref = min(n-1, max(preferences)) for pref in preferences: if pref <= max_pref: satisfied += 1 return satisfied"},{"question":"def calculate(expression: str) -> int: Evaluate a mathematical expression containing +, -, *, / and parentheses. >>> calculate(\\"3+5\\") 8 >>> calculate(\\"10+(2*5)\\") 20 >>> calculate(\\"100/(2+3)\\") 20 >>> calculate(\\"2*(5+5*2)/3\\") 10 >>> calculate(\\"10-2*3\\") 4 >>> calculate(\\"(2+3)*(2+(1*2))\\") 20 # Your code here","solution":"def calculate(expression): def evaluate(tokens): stack = [] num = 0 sign = \\"+\\" i = 0 while i < len(tokens): char = tokens[i] if char.isdigit(): num = num * 10 + int(char) if char == \\"(\\": num, j = evaluate(tokens[i + 1:]) i += j if char in \\"+-*/)\\" or i == len(tokens) - 1: if sign == \\"+\\": stack.append(num) elif sign == \\"-\\": stack.append(-num) elif sign == \\"*\\": stack.append(stack.pop() * num) elif sign == \\"/\\": stack.append(int(stack.pop() / num)) sign = char num = 0 if char == \\")\\": return sum(stack), i + 1 i += 1 return sum(stack) return evaluate(expression)"},{"question":"def getLexicographicallySmallestString(S: str) -> str: Given a string S consisting of lowercase English letters, return the lexicographically smallest string that can be formed by sorting any substrings of S in non-decreasing order. Example: >>> getLexicographicallySmallestString(\\"dcba\\") 'abcd' >>> getLexicographicallySmallestString(\\"bca\\") 'abc' >>> getLexicographicallySmallestString(\\"geek\\") 'eegk'","solution":"def getLexicographicallySmallestString(S): Returns the lexicographically smallest string that can be formed by sorting any substrings of S. # The lexicographically smallest string is simply the sorted version of S. return ''.join(sorted(S))"},{"question":"def max_product_modulo(arr): Find the maximum product of two distinct elements in the array, modulo 1000000007. >>> max_product_modulo([1, 10, 3, 7, 9]) 90 >>> max_product_modulo([8, 7, 6]) 56 pass def solve(test_cases): Solve multiple test cases for the maximum product of two distinct elements modulo 1000000007. Args: test_cases: List of test cases where each test case is a list of integers. Returns: List of integer results for each test case. Example: >>> solve([[1, 10, 3, 7, 9], [8, 7, 6], [2, 5, 9, 1], [6, 7, 5, 3, 0]]) [90, 56, 45, 42] pass from max_product_modulo import max_product_modulo, solve def test_single_test_case(): assert max_product_modulo([1, 10, 3, 7, 9]) == 90 assert max_product_modulo([8, 7, 6]) == 56 def test_multiple_test_cases(): test_cases = [ [1, 10, 3, 7, 9], [8, 7, 6], [2, 5, 9, 1], [6, 7, 5, 3, 0], ] expected_results = [90, 56, 45, 42] assert solve(test_cases) == expected_results def test_small_size(): assert max_product_modulo([1, 2]) == 2 def test_large_elements(): assert max_product_modulo([10**9, 999999999]) == (10**9 * 999999999 % 1000000007) def test_with_zero(): assert max_product_modulo([0, 1, 2, 3]) == 6 def test_maximum_constraints(): # Testing with maximum constraints N = 100000 test_array = [i for i in range(1, N+1)] assert max_product_modulo(test_array) == ((N * (N-1)) % 1000000007)","solution":"def max_product_modulo(arr): MOD = 1000000007 if len(arr) < 2: return 0 max1 = max2 = -1 for num in arr: if num > max1: max2 = max1 max1 = num elif num > max2: max2 = num product = max1 * max2 return product % MOD def solve(test_cases): results = [] for arr in test_cases: results.append(max_product_modulo(arr)) return results # Example usage: # test_cases = [[1, 10, 3, 7, 9], [8, 7, 6]] # results = solve(test_cases) # for result in results: # print(result)"},{"question":"def max_path_sum(grid): Determine the maximum sum a player can collect on any valid path from the top-left to the bottom-right corner of a grid. Parameters: grid (List[List[int]]): A rectangular grid where each cell contains a value. Returns: int: The maximum sum the player can collect on a valid path. Examples: >>> max_path_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 29 >>> max_path_sum([[1, -3], [2, 4]]) 7 >>> max_path_sum([[5]]) 5 >>> max_path_sum([[1, 2, 3, 4]]) 10 >>> max_path_sum([[1], [2], [3], [4]]) 10 >>> max_path_sum([[1, 2, 5], [3, 2, 1], [4, 3, 9]]) 20","solution":"def max_path_sum(grid): n = len(grid) m = len(grid[0]) # Create a dp array dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1]"},{"question":"def min_lines_to_paint_grid(T: int, test_cases: List[Tuple[int, int]]) -> List[int]: Determine the minimum number of lines required to paint the entire grid. Parameters: - T: number of test cases - test_cases: a list of tuples (M, N), each representing the dimensions of the grid for a test case Returns: - A list of integers, where each integer is the minimum number of lines required to paint the entire grid for the corresponding test case. >>> min_lines_to_paint_grid(1, [(1, 1)]) [1] >>> min_lines_to_paint_grid(1, [(2, 3)]) [2] >>> min_lines_to_paint_grid(1, [(4, 5)]) [4] >>> min_lines_to_paint_grid(1, [(5, 5)]) [5] >>> min_lines_to_paint_grid(1, [(1000000000, 1000000000)]) [1000000000] >>> min_lines_to_paint_grid(1, [(1, 1000000000)]) [1] >>> min_lines_to_paint_grid(3, [(1, 1), (2, 3), (4, 5)]) [1, 2, 4]","solution":"def min_lines_to_paint_grid(T, test_cases): def min_lines(M, N): # The minimum number of lines required to paint an M x N grid return min(M, N) results = [] for M, N in test_cases: results.append(min_lines(M, N)) return results"},{"question":"def manipulate_array(n, A): Manipulate the array as per the specified rules and return the resultant array. Parameters: n (int): The length of the input array. A (list): The input array of integers. Returns: list: The array after performing the described manipulations. pass # Test cases def test_manipulate_array_odd(): assert manipulate_array(5, [1, 2, 3, 4, 5]) == [3, 5, 2, 4, 1] def test_manipulate_array_even(): assert manipulate_array(6, [10, 20, 30, 40, 50, 60]) == [30, 60, 20, 50, 10, 40] def test_manipulate_array_single_element(): assert manipulate_array(1, [42]) == [42] def test_manipulate_array_two_elements(): assert manipulate_array(2, [11, 22]) == [11, 22] def test_manipulate_array_three_elements(): assert manipulate_array(3, [7, 8, 9]) == [8, 9, 7] def test_manipulate_array_multivalue_elements(): assert manipulate_array(4, [81, 93, 34, 77]) == [93, 77, 81, 34]","solution":"def manipulate_array(n, A): Manipulate the array as per the specified rules and return the resultant array. Parameters: n (int): The length of the input array. A (list): The input array of integers. Returns: list: The array after performing the described manipulations. if n % 2 == 0: first_half, second_half = A[:n//2], A[n//2:] else: first_half, second_half = A[:n//2+1], A[n//2+1:] first_half.reverse() second_half.reverse() result = [] min_length = min(len(first_half), len(second_half)) for i in range(min_length): result.append(first_half[i]) result.append(second_half[i]) if len(first_half) > len(second_half): result.extend(first_half[min_length:]) else: result.extend(second_half[min_length:]) return result"},{"question":"def cumulative_sum(lst): Takes a list of integers and returns a new list where each element is the sum of itself and all prior elements. :param lst: List of integers :return: List of integers with cumulative sums >>> cumulative_sum([1, 2, 3, 4]) [1, 3, 6, 10] >>> cumulative_sum([5, 3, 8, 2]) [5, 8, 16, 18] >>> cumulative_sum([]) [] >>> cumulative_sum([5]) [5] >>> cumulative_sum([-1, -2, -3, -4]) [-1, -3, -6, -10] >>> cumulative_sum([1, -2, 3, -4]) [1, -1, 2, -2] # Implementation here","solution":"def cumulative_sum(lst): Returns a list where each element is the sum of itself and all prior elements in the list. if not lst: return [] cumulative_list = [lst[0]] for i in range(1, len(lst)): cumulative_list.append(cumulative_list[-1] + lst[i]) return cumulative_list"},{"question":"def rearrangeEvenOdd(N: int, nums: List[int]) -> List[int]: Rearrange the array such that all elements at even indices are even and all elements at odd indices are odd. >>> rearrangeEvenOdd(6, [3, 6, 12, 1, 5, 8]) [6, 3, 12, 1, 8, 5] >>> rearrangeEvenOdd(4, [7, 2, 5, 8]) [2, 7, 8, 5] def test_rearrangeEvenOdd_example1(): nums = [3, 6, 12, 1, 5, 8] result = rearrangeEvenOdd(6, nums) expected = [6, 3, 12, 1, 8, 5] assert result == expected def test_rearrangeEvenOdd_example2(): nums = [7, 2, 5, 8] result = rearrangeEvenOdd(4, nums) expected = [2, 7, 8, 5] assert result == expected def test_rearrangeEvenOdd_all_even(): nums = [2, 4, 6, 8, 10, 12] result = rearrangeEvenOdd(6, nums) expected = [2, 4, 6, 8, 10, 12] # no change assert result == expected def test_rearrangeEvenOdd_all_odd(): nums = [1, 3, 5, 7, 9, 11] result = rearrangeEvenOdd(6, nums) expected = [1, 3, 5, 7, 9, 11] # no change assert result == expected def test_rearrangeEvenOdd_mixed(): nums = [4, 5, 2, 9, 10, 1, 6, 3, 8, 7] result = rearrangeEvenOdd(10, nums) expected = [4, 5, 2, 9, 10, 1, 6, 3, 8, 7] # initially valid assert result == expected def test_rearrangeEvenOdd_single(): nums = [3] result = rearrangeEvenOdd(1, nums) expected = [3] assert result == expected","solution":"def rearrangeEvenOdd(N, nums): even_index = 0 odd_index = 1 while even_index < N and odd_index < N: # Find next even number at even index while even_index < N and nums[even_index] % 2 == 0: even_index += 2 # Find next odd number at odd index while odd_index < N and nums[odd_index] % 2 == 1: odd_index += 2 # If we find a mismatch where even_index has odd number and odd_index has even number, swap them if even_index < N and odd_index < N: nums[even_index], nums[odd_index] = nums[odd_index], nums[even_index] return nums"},{"question":"def longest_common_subsequence(a, b): Returns the length of the longest common subsequence in two lists a and b. >>> longest_common_subsequence([1, 3, 4], [1, 2, 4]) == 2 >>> longest_common_subsequence([1, 4, 2, 5, 3], [4, 5, 1, 2, 3, 6]) == 3","solution":"def longest_common_subsequence(a, b): Returns the length of the longest common subsequence in two lists a and b. n = len(a) m = len(b) dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): if a[i - 1] == b[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m]"},{"question":"from typing import List def findClosestElements(arr: List[int], k: int, x: int) -> List[int]: Find k closest integers to x in the given sorted array. Parameters: arr (List[int]): A list of integers sorted in ascending order. k (int): Number of closest integers to find. x (int): The target integer to compare closeness. Returns: List[int]: A list of k closest integers sorted in ascending order. >>> findClosestElements([1, 2, 3, 4, 5], 4, 3) [1, 2, 3, 4] >>> findClosestElements([1, 2, 3, 4, 5], 4, -1) [1, 2, 3, 4] def test_findClosestElements_example1(): arr = [1, 2, 3, 4, 5] k = 4 x = 3 assert findClosestElements(arr, k, x) == [1, 2, 3, 4] def test_findClosestElements_example2(): arr = [1, 2, 3, 4, 5] k = 4 x = -1 assert findClosestElements(arr, k, x) == [1, 2, 3, 4] def test_findClosestElements_not_in_array(): arr = [1, 3, 5, 7, 9] k = 3 x = 6 assert findClosestElements(arr, k, x) == [3, 5, 7] def test_findClosestElements_negative_numbers(): arr = [-10, -5, -2, 0, 1, 3, 7] k = 4 x = 0 assert findClosestElements(arr, k, x) == [-2, 0, 1, 3] def test_findClosestElements_large_k(): arr = [1, 2, 3, 4, 5] k = 5 x = 10 assert findClosestElements(arr, k, x) == [1, 2, 3, 4, 5] def test_findClosestElements_single_element(): arr = [1] k = 1 x = 100 assert findClosestElements(arr, k, x) == [1]","solution":"from typing import List def findClosestElements(arr: List[int], k: int, x: int) -> List[int]: Find k closest integers to x in the given sorted array. Parameters: arr (List[int]): A list of integers sorted in ascending order. k (int): Number of closest integers to find. x (int): The target integer to compare closeness. Returns: List[int]: A list of k closest integers sorted in ascending order. # Define a function to compute the custom comparison key def proximity(a): return (abs(a - x), a) # Sort the array with the custom key which sorts based on the distance and then by value arr_sorted_by_proximity = sorted(arr, key=proximity) # Get the first 'k' elements from the sorted list closest_elements = arr_sorted_by_proximity[:k] # Return the 'k' closest elements sorted in ascending order return sorted(closest_elements)"},{"question":"def calculate_scores(athletes_data): Calculate total scores for each athlete based on their finishes. :param athletes_data: List of tuples where each tuple contains three integers: (num_first_place, num_second_place, num_third_place) :return: List containing the total score for each athlete. from solution import calculate_scores def test_calculate_scores_basic(): assert calculate_scores([(4, 2, 1)]) == [52] assert calculate_scores([(5, 3, 2)]) == [69] assert calculate_scores([(0, 0, 0)]) == [0] def test_calculate_scores_multiple_athletes(): assert calculate_scores([(4, 2, 1), (5, 3, 2), (0, 0, 0)]) == [52, 69, 0] assert calculate_scores([(1, 1, 1), (2, 2, 2), (3, 3, 3)]) == [17, 34, 51] assert calculate_scores([(10, 10, 10), (20, 20, 20)]) == [170, 340] def test_calculate_scores_edge_cases(): assert calculate_scores([(0, 0, 20)]) == [40] assert calculate_scores([(20, 0, 0)]) == [200] assert calculate_scores([(0, 20, 0)]) == [100]","solution":"def calculate_scores(athletes_data): Calculate total scores for each athlete based on their finishes. :param athletes_data: List of tuples where each tuple contains three integers: (num_first_place, num_second_place, num_third_place) :return: List containing the total score for each athlete. scores = [] for data in athletes_data: num_first_place, num_second_place, num_third_place = data score = (num_first_place * 10) + (num_second_place * 5) + (num_third_place * 2) scores.append(score) return scores"},{"question":"def min_trees_to_cut(n: int, heights: List[int]) -> int: Given a list of integers representing the heights of trees in a forest, find the minimum number of trees that need to be cut down so that every remaining tree forms a strictly increasing sequence in height from left to right. If it's impossible, return -1. >>> min_trees_to_cut(5, [3, 4, 2, 6, 1]) 2 >>> min_trees_to_cut(3, [5, 4, 3]) -1 >>> min_trees_to_cut(0, []) -1 >>> min_trees_to_cut(4, [1, 2, 3, 4]) 0 >>> min_trees_to_cut(4, [4, 3, 2, 1]) -1 >>> min_trees_to_cut(1, [5]) 0 >>> min_trees_to_cut(6, [1, 3, 2, 4, 5, 6]) 1","solution":"def min_trees_to_cut(n, heights): Returns the minimum number of trees to cut down to form a strictly increasing sequence. If it's impossible, returns -1. if n == 0: return -1 # Helper function to find the length of the Longest Increasing Subsequence (LIS) def LIS(arr): import bisect lis = [] for x in arr: pos = bisect.bisect_left(lis, x) if pos < len(lis): lis[pos] = x else: lis.append(x) return len(lis) # Calculate the length of the longest increasing subsequence lis_length = LIS(heights) if lis_length == n: # No trees need to be cut return 0 elif lis_length < 2: # If LIS length is less than 2, we cannot form a strictly increasing sequence return -1 else: # Minimum cuts needed = Total trees - Length of LIS return n - lis_length"},{"question":"def findTwoSum(arr: List[int], target: int) -> Union[List[int], int]: Given an array of integers and a target sum, determine if any two numbers in the array add up to the target sum. Return the indices of the two numbers or -1 if no such pair exists. >>> findTwoSum([2, 7, 11, 15], 9) [0, 1] >>> findTwoSum([1, 2, 3, 4, 5], 10) -1","solution":"def findTwoSum(arr, target): Finds two numbers in arr that add up to the target sum and returns their indices. If no such pair exists, returns -1. seen = {} for i, num in enumerate(arr): complement = target - num if complement in seen: return [seen[complement], i] seen[num] = i return -1"},{"question":"def calculate_fines(t: int, d: int, f: int, return_days: List[int]) -> List[int]: Calculates the fines for multiple students based on their return dates. Parameters: t (int): Number of students. d (int): Maximum number of days a book can be borrowed without incurring a fine. f (int): Fine per day for late returns. return_days (list): List of integers where each integer represents the number of days a student borrowed the book. Returns: list: List of integers representing the fine for each student. >>> calculate_fines(3, 5, 10, [7, 4, 10]) [20, 0, 50] >>> calculate_fines(1, 5, 10, [6]) [10]","solution":"def calculate_fines(t, d, f, return_days): Calculates the fines for multiple students based on their return dates. Parameters: t (int): Number of students. d (int): Maximum number of days a book can be borrowed without incurring a fine. f (int): Fine per day for late returns. return_days (list): List of integers where each integer represents the number of days a student borrowed the book. Returns: list: List of integers representing the fine for each student. fines = [] for r in return_days: if r > d: fines.append((r - d) * f) else: fines.append(0) return fines"},{"question":"def generate_friend_suggestions(n: int, k: int, m: int, suggestions: List[Tuple[int, int, int]]) -> List[str]: Generate the list of top friend suggestions for each user based on the provided data. Args: n (int): The number of users. k (int): The number of top friend suggestions to show. m (int): The number of friend suggestions. suggestions (List[Tuple[int, int, int]]): Each tuple contains three integers: user uj, friend vf, and friendship strength s. Returns: List[str]: A list of strings where each string contains the user number and up to k friend suggestions sorted in the given order. Examples: >>> generate_friend_suggestions(4, 2, 5, [(1, 2, 50), (1, 3, 70), (2, 4, 60), (3, 1, 80), (4, 1, 90)]) [\\"1 (3, 70) (2, 50)\\", \\"2 (4, 60)\\", \\"3 (1, 80)\\", \\"4 (1, 90)\\"] >>> generate_friend_suggestions(3, 1, 4, [(1, 2, 30), (2, 3, 20), (3, 1, 40), (1, 3, 30)]) [\\"1 (2, 30)\\", \\"2 (3, 20)\\", \\"3 (1, 40)\\"]","solution":"def generate_friend_suggestions(n, k, m, suggestions): from collections import defaultdict users_suggestions = defaultdict(list) # Organize suggestions by user for suggestion in suggestions: uj, vf, s = suggestion users_suggestions[uj].append((vf, s)) # Prepare the output output = [] for user in range(1, n+1): friend_suggestions = users_suggestions[user] # Sort by friendship strength (descending) then by friend_user number (ascending) friend_suggestions.sort(key=lambda x: (-x[1], x[0])) # Take the top k suggestions top_suggestions = friend_suggestions[:k] # Format the output formatted_suggestions = \\" \\".join(f\\"({friend_user}, {strength})\\" for friend_user, strength in top_suggestions) output.append(f\\"{user} {formatted_suggestions}\\") return output"},{"question":"from typing import List def maxProductiveHours(hours: List[int]) -> int: A company wants to find the highest productivity over any contiguous subarray of days. The productivity of a subarray is defined as the sum of the work hours in that subarray. Write a function \`maxProductiveHours(hours: List[int]) -> int\` that takes an array of integers representing work hours of employees and returns the productivity of the most productive contiguous subarray. If the array is empty, return 0. >>> maxProductiveHours([1, -2, 3, 10, -4, 7, 2, -5]) 18 >>> maxProductiveHours([-1, -2, -3, -4]) -1 >>> maxProductiveHours([]) 0 def test_max_productive_hours_example1(): assert maxProductiveHours([1, -2, 3, 10, -4, 7, 2, -5]) == 18 def test_max_productive_hours_example2(): assert maxProductiveHours([-1, -2, -3, -4]) == -1 def test_max_productive_hours_single_element(): assert maxProductiveHours([5]) == 5 assert maxProductiveHours([-5]) == -5 def test_max_productive_hours_all_positive(): assert maxProductiveHours([1, 2, 3, 4, 5]) == 15 def test_max_productive_hours_all_negative(): assert maxProductiveHours([-1, -2, -3, -4, -5]) == -1 def test_max_productive_hours_mixed_elements(): assert maxProductiveHours([3, -2, 5, -1]) == 6 assert maxProductiveHours([4, -1, 2, 1]) == 6 def test_max_productive_hours_empty_array(): assert maxProductiveHours([]) == 0","solution":"from typing import List def maxProductiveHours(hours: List[int]) -> int: if not hours: return 0 max_productivity = hours[0] current_productivity = hours[0] for hour in hours[1:]: current_productivity = max(hour, current_productivity + hour) if current_productivity > max_productivity: max_productivity = current_productivity return max_productivity"},{"question":"from datetime import datetime from typing import List, Tuple def calculate_average_time_diffs(n: int, records: List[Tuple[str, str]]): Calculate the average time difference in seconds between consecutive activities for each user in a specific table. The function will print each user ID present in the input and the average time difference in seconds between consecutive activities. If a user has less than two records, the average time difference is considered to be 0. Args: n (int): The number of records in the table. records (List[Tuple[str, str]]): A list of n tuples, each containing a user ID (string) and a timestamp (string in the \\"YYYY-MM-DD HH:MM:SS\\" format). Returns: None Example: >>> calculate_average_time_diffs(7, [ (\\"user1\\", \\"2023-10-01 12:00:00\\"), (\\"user2\\", \\"2023-10-01 12:05:00\\"), (\\"user1\\", \\"2023-10-01 12:10:00\\"), (\\"user2\\", \\"2023-10-01 12:15:00\\"), (\\"user1\\", \\"2023-10-01 12:20:00\\"), (\\"user3\\", \\"2023-10-01 12:25:00\\"), (\\"user3\\", \\"2023-10-01 12:55:00\\") ]) user1 600.0 user2 600.0 user3 1800.0","solution":"from datetime import datetime, timedelta from collections import defaultdict def calculate_average_time_diffs(n, records): user_times = defaultdict(list) for user_id, timestamp in records: dt = datetime.strptime(timestamp, \\"%Y-%m-%d %H:%M:%S\\") user_times[user_id].append(dt) user_averages = {} for user_id, times in user_times.items(): if len(times) < 2: user_averages[user_id] = 0.0 else: total_diff = sum( (times[i] - times[i - 1]).total_seconds() for i in range(1, len(times)) ) average_diff = total_diff / (len(times) - 1) user_averages[user_id] = average_diff for user_id, avg_diff in user_averages.items(): print(f\\"{user_id} {avg_diff}\\") # Example usage with provided sample input: n = 7 records = [ (\\"user1\\", \\"2023-10-01 12:00:00\\"), (\\"user2\\", \\"2023-10-01 12:05:00\\"), (\\"user1\\", \\"2023-10-01 12:10:00\\"), (\\"user2\\", \\"2023-10-01 12:15:00\\"), (\\"user1\\", \\"2023-10-01 12:20:00\\"), (\\"user3\\", \\"2023-10-01 12:25:00\\"), (\\"user3\\", \\"2023-10-01 12:55:00\\") ] calculate_average_time_diffs(n, records)"},{"question":"def minimize_max_difference(n: int, k: int, arr: List[int]) -> int: Find the minimum possible value of the maximum difference between the sums of any two subarrays when the array is partitioned into k contiguous subarrays. Args: n: an integer representing the size of the given array. k: an integer representing the number of segments in a partition. arr: a list of integers representing the given array. Returns: An integer representing the minimized value of the maximum difference between the sums of any two contiguous subarrays. >>> minimize_max_difference(5, 2, [1, 3, -2, 4, 5]) 6 >>> minimize_max_difference(6, 3, [-1, 2, 9, -7, 3, -8]) 9 >>> minimize_max_difference(5, 4, [1, -1, 1, -1, 1]) 1 >>> minimize_max_difference(1, 1, [5]) 5 >>> minimize_max_difference(5, 2, [0, 0, 0, 0, 0]) 0 >>> minimize_max_difference(3, 2, [1000000000, 1000000000, 1000000000]) 2000000000 pass","solution":"def minimize_max_difference(n, k, arr): Function to find the minimum possible value of the maximum difference between the sums of any two subarrays when the array is partitioned into k contiguous subarrays. def valid(mid): current_sum = 0 partitions = 1 for num in arr: if current_sum + num > mid: partitions += 1 current_sum = 0 current_sum += num return partitions <= k lo, hi = max(arr), sum(arr) while lo < hi: mid = (lo + hi) // 2 if valid(mid): hi = mid else: lo = mid + 1 return lo"},{"question":"def is_magic_square(grid): Verify if the given 3x3 grid forms a magic square. Args: grid: List of lists, representing the 3x3 grid. Each list contains 3 integers, each integer in the range from -1000 to 1000. Returns: str: 'Magic Square' if the grid forms a magic square, 'Not a Magic Square' otherwise. >>> is_magic_square([[2, 7, 6], [9, 5, 1], [4, 3, 8]]) == 'Magic Square' >>> is_magic_square([[3, 5, 7], [8, 1, 6], [4, 9, 2]]) == 'Not a Magic Square' >>> is_magic_square([[-2, -7, -6], [-9, -5, -1], [-4, -3, -8]]) == 'Magic Square' >>> is_magic_square([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 'Magic Square' >>> is_magic_square([[3, 5, 7], [8, 2, 5], [4, 9, 2]]) == 'Not a Magic Square'","solution":"def is_magic_square(grid): Verify if the given 3x3 grid forms a magic square. Args: grid: List of lists, representing the 3x3 grid. Each list contains 3 integers, each integer in the range from -1000 to 1000. Returns: str: 'Magic Square' if the grid forms a magic square, 'Not a Magic Square' otherwise. if not all(len(row) == 3 for row in grid) or len(grid) != 3: return 'Not a Magic Square' # Calculate the magic sum using the first row magic_sum = sum(grid[0]) # Check rows and columns sums for i in range(3): if sum(grid[i]) != magic_sum or sum(row[i] for row in grid) != magic_sum: return 'Not a Magic Square' # Check diagonals sum if (grid[0][0] + grid[1][1] + grid[2][2] != magic_sum or grid[0][2] + grid[1][1] + grid[2][0] != magic_sum): return 'Not a Magic Square' return 'Magic Square'"},{"question":"def isNearPalindrome(s: str) -> bool: Determines if the string is a near-palindrome. >>> isNearPalindrome(\\"radar\\") True >>> isNearPalindrome(\\"radarx\\") True >>> isNearPalindrome(\\"rdar\\") True >>> isNearPalindrome(\\"hello\\") False >>> isNearPalindrome(\\"abca\\") True","solution":"def isNearPalindrome(s): Determines if the string is a near-palindrome. def is_palindrome_range(i, j): while i < j: if s[i] != s[j]: return False i += 1 j -= 1 return True start, end = 0, len(s) - 1 while start < end: if s[start] != s[end]: return is_palindrome_range(start + 1, end) or is_palindrome_range(start, end - 1) start += 1 end -= 1 return True"},{"question":"from typing import List def find_lis_prime_length(n: int, array: List[int]) -> int: Given an array of positive integers, find the length of the longest increasing subsequence (LIS) such that the sum of the elements in this subsequence is a prime number. An increasing subsequence is a subsequence where each element is greater than the previous one. A subsequence is formed by deleting any number of elements (including zero) from the array, keeping the remaining elements in their original order. Args: n: An integer representing the number of elements in the array. array: A list of n space-separated integers representing the array elements. Returns: An integer representing the length of the longest increasing subsequence whose sum is a prime number or 0 if no such subsequence exists. Examples: >>> find_lis_prime_length(6, [10, 22, 9, 33, 21, 50]) 3 >>> find_lis_prime_length(5, [8, 3, 10, 7, 15]) 2 >>> find_lis_prime_length(3, [2, 3, 5]) 2 >>> find_lis_prime_length(4, [4, 6, 8, 10]) 0 >>> find_lis_prime_length(4, [5, 5, 5, 5]) 0 # Define helper functions and main logic here return 0","solution":"from itertools import combinations from math import isqrt def is_prime(num): if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, isqrt(num) + 1, 2): if num % i == 0: return False return True def longest_increasing_subsequence_with_prime_sum(arr): n = len(arr) lis_len = [1] * n lis_sum = [arr[i] for i in range(n)] max_len = 0 for i in range(1, n): for j in range(i): if arr[i] > arr[j]: if lis_len[i] < lis_len[j] + 1: lis_len[i] = lis_len[j] + 1 lis_sum[i] = lis_sum[j] + arr[i] if lis_len[i] > max_len and is_prime(lis_sum[i]): max_len = lis_len[i] return max_len # Wrapper function to read input and output result def find_lis_prime_length(n, array): result = longest_increasing_subsequence_with_prime_sum(array) return result"},{"question":"def count_paths(grid: List[List[int]]) -> int: Determine the number of distinct paths the robot can take to reach its destination. The grid contains obstacles where 0 represents an open cell and 1 represents an obstacle. Parameters: grid (List[List[int]]): A 2D grid representing the field with obstacles. Returns: int: The number of distinct paths from the top-left corner to the bottom-right corner. Example: >>> count_paths([ ... [0, 1, 0], ... [0, 0, 1], ... [1, 0, 0] ... ]) 1 >>> count_paths([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 2 pass import sys input = sys.stdin.read def main(): data = input().strip().split() n = int(data[0]) grid = [] index = 1 for i in range(n): row = list(map(int, data[index:index + n])) grid.append(row) index += n print(count_paths(grid)) if __name__ == \\"__main__\\": main() def test_simple_no_obstacles(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert count_paths(grid) == 6 def test_simple_with_obstacles(): grid = [ [0, 1, 0], [0, 0, 1], [1, 0, 0] ] assert count_paths(grid) == 1 def test_edge_case_1x1(): grid = [ [0] ] assert count_paths(grid) == 1 def test_edge_case_start_blocked(): grid = [ [1, 0], [0, 0] ] assert count_paths(grid) == 0 def test_edge_case_end_blocked(): grid = [ [0, 0], [0, 1] ] assert count_paths(grid) == 0 def test_standard_case(): grid = [ [0, 0, 0, 0], [0, 1, 0, 1], [0, 0, 0, 0], [1, 0, 1, 0] ] assert count_paths(grid) == 2","solution":"def count_paths(grid): n = len(grid) if grid[0][0] == 1 or grid[n-1][n-1] == 1: return 0 dp = [[0] * n for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][n-1] # Example usage if __name__ == \\"__main__\\": n = int(input()) grid = [list(map(int, input().split())) for _ in range(n)] print(count_paths(grid))"},{"question":"def distinctIslands(grid): Determines the number of distinct islands in a given grid of land 'L' and water 'W'. >>> grid = [ ... [\\"L\\", \\"L\\", \\"W\\", \\"W\\", \\"L\\"], ... [\\"L\\", \\"L\\", \\"W\\", \\"W\\", \\"L\\"], ... [\\"W\\", \\"W\\", \\"L\\", \\"W\\", \\"L\\"], ... [\\"W\\", \\"W\\", \\"L\\", \\"L\\", \\"L\\"], ... [\\"L\\", \\"W\\", \\"W\\", \\"L\\", \\"L\\"] ... ] >>> distinctIslands(grid) 3 >>> grid = [ ... [\\"L\\", \\"L\\"], ... [\\"L\\", \\"L\\"] ... ] >>> distinctIslands(grid) 1 >>> grid = [ ... [\\"W\\", \\"W\\"], ... [\\"W\\", \\"W\\"] ... ] >>> distinctIslands(grid) 0 >>> grid = [ ... [] ... ] >>> distinctIslands(grid) 0 >>> grid = [ ... [\\"L\\"] ... ] >>> distinctIslands(grid) 1 >>> grid = [ ... [\\"W\\"] ... ] >>> distinctIslands(grid) 0 >>> grid = [ ... [\\"L\\", \\"W\\", \\"L\\", \\"L\\", \\"L\\", \\"W\\", \\"W\\", \\"L\\"], ... [\\"L\\", \\"W\\", \\"W\\", \\"W\\", \\"L\\", \\"L\\", \\"L\\", \\"L\\"], ... [\\"L\\", \\"L\\", \\"L\\", \\"W\\", \\"W\\", \\"L\\", \\"W\\", \\"W\\"], ... [\\"W\\", \\"W\\", \\"W\\", \\"W\\", \\"L\\", \\"L\\", \\"W\\", \\"L\\"], ... [\\"W\\", \\"L\\", \\"W\\", \\"W\\", \\"W\\", \\"W\\", \\"W\\", \\"L\\"], ... ] >>> distinctIslands(grid) 4","solution":"def distinctIslands(grid): Determines the number of distinct islands in a given grid of land 'L' and water 'W'. if not grid or not grid[0]: return 0 def dfs(x, y, direction): if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == 'W': return grid[x][y] = 'W' shape.append(direction) dfs(x + 1, y, 'D') # Down dfs(x - 1, y, 'U') # Up dfs(x, y + 1, 'R') # Right dfs(x, y - 1, 'L') # Left shape.append('B') # Backtracking unique_shapes = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 'L': shape = [] dfs(i, j, 'O') # Origin unique_shapes.add(tuple(shape)) return len(unique_shapes)"},{"question":"def minimal_cost(N, S, prices, discounts): Calculate the minimal cost for Sarah to buy N ingredients from S stores with given prices and discounts. Args: N (int): Number of ingredients S (int): Number of stores prices (List[List[int]]): A 2D list containing prices of ingredients in each store discounts (List[List[int]]): A 2D list containing discounts of ingredients in each store Returns: int: The minimal cost to buy all ingredients Example: >>> minimal_cost(3, 3, [[5, 8, 6], [2, 4, 7], [1, 0, 3]], [[2, 1, 2], [1, 5, 4], [4, 3, 2]]) 7 def minimize_expenditure(T, test_cases): Calculate the minimal expenditure for multiple test cases. Args: T (int): Number of test cases test_cases (List[Tuple[int, int, List[List[int]], List[List[int]]]]): A list of test cases, where each test case is a tuple containing N, S, prices, and discounts Returns: List[int]: List of minimal costs for each test case Example: >>> minimize_expenditure(1, [ (3, 3, [[5, 8, 6], [2, 4, 7], [1, 0, 3]], [[2, 1, 2], [1, 5, 4], [4, 3, 2]]) ]) [7]","solution":"def minimal_cost(N, S, prices, discounts): dp = [[float('inf')] * S for _ in range(N)] for j in range(S): dp[0][j] = prices[0][j] for i in range(1, N): for j in range(S): min_cost_previous = float('inf') for k in range(S): min_cost_previous = min(min_cost_previous, dp[i-1][k]) discount_available = discounts[i-2][j] if i > 1 else 0 dp[i][j] = min_cost_previous + max(0, prices[i][j] - discount_available) return min(dp[N-1]) def minimize_expenditure(T, test_cases): results = [] for t in range(T): N, S, prices, discounts = test_cases[t] results.append(minimal_cost(N, S, prices, discounts)) return results"},{"question":"def find_common_destinations(n: int, janes_list: List[str], m: int, brians_list: List[str]) -> List[str]: Finds common destinations in lexicographical order from two lists. :param n: Number of destinations in Jane's list. :param janes_list: List of Jane's destinations. :param m: Number of destinations in Brian's list. :param brians_list: List of Brian's destinations. :return: List of common destinations in lexicographical order or string \\"No common destinations.\\" # The function implementation goes here from typing import List def test_find_common_destinations_with_common(): n = 4 janes_list = [\\"Paris\\", \\"London\\", \\"Tokyo\\", \\"Berlin\\"] m = 3 brians_list = [\\"New York\\", \\"Tokyo\\", \\"Paris\\"] assert find_common_destinations(n, janes_list, m, brians_list) == [\\"Paris\\", \\"Tokyo\\"] def test_find_common_destinations_no_common(): n = 3 janes_list = [\\"San Francisco\\", \\"Chicago\\", \\"Boston\\"] m = 3 brians_list = [\\"Miami\\", \\"Seattle\\", \\"Atlanta\\"] assert find_common_destinations(n, janes_list, m, brians_list) == [\\"No common destinations\\"] def test_find_common_destinations_all_common(): n = 3 janes_list = [\\"Rome\\", \\"Madrid\\", \\"Vienna\\"] m = 3 brians_list = [\\"Rome\\", \\"Madrid\\", \\"Vienna\\"] assert find_common_destinations(n, janes_list, m, brians_list) == [\\"Madrid\\", \\"Rome\\", \\"Vienna\\"] def test_find_common_destinations_some_common(): n = 5 janes_list = [\\"Rome\\", \\"Madrid\\", \\"Vienna\\", \\"Prague\\", \\"Warsaw\\"] m = 4 brians_list = [\\"Berlin\\", \\"Vienna\\", \\"Rome\\", \\"Budapest\\"] assert find_common_destinations(n, janes_list, m, brians_list) == [\\"Rome\\", \\"Vienna\\"] def test_find_common_destinations_empty_lists(): n = 0 janes_list = [] m = 0 brians_list = [] assert find_common_destinations(n, janes_list, m, brians_list) == [\\"No common destinations\\"]","solution":"def find_common_destinations(n, janes_list, m, brians_list): Finds common destinations in lexicographical order from two lists. :param n: Number of destinations in Jane's list. :param janes_list: List of Jane's destinations. :param m: Number of destinations in Brian's list. :param brians_list: List of Brian's destinations. :return: List of common destinations in lexicographical order or string \\"No common destinations.\\" # Convert lists to sets to find common elements common_destinations = set(janes_list).intersection(set(brians_list)) # If there are common destinations, sort and return them if common_destinations: return sorted(common_destinations) # If no common destinations, return the specified string return [\\"No common destinations\\"]"},{"question":"def highest_frequency_char(s: str) -> str: Returns the character with the highest frequency in the string s. If multiple characters have the same highest frequency, return the one which appears first. >>> highest_frequency_char(\\"swiss\\") \\"s\\" >>> highest_frequency_char(\\"test\\") \\"t\\"","solution":"def highest_frequency_char(s): Returns the character with the highest frequency in the string s. If multiple characters have the same highest frequency, return the one which appears first. char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 max_freq = max(char_count.values()) for char in s: if char_count[char] == max_freq: return char"},{"question":"def simulate_belt(n, initial_state, t): Simulates the movement of items on the conveyor belts. Parameters: n (int): The number of belts. initial_state (list): The initial state of the belts. t (int): The number of time steps to simulate. Returns: list: The state of the belts after t time steps. pass","solution":"def simulate_belt(n, initial_state, t): Simulates the movement of items on the conveyor belts. Parameters: n (int): The number of belts. initial_state (list): The initial state of the belts. t (int): The number of time steps to simulate. Returns: list: The state of the belts after t time steps. state = initial_state[:] # Copy the initial state so as not to mutate the input list. for _ in range(t): new_state = [0] * n for i in range(1, n): new_state[i] = state[i-1] state = new_state return state"},{"question":"def process_inventory_operations(operations: List[str]) -> List[int]: Process a series of operations on the inventory. Each operation can either add new items, remove items, or check the current stock of an item. - \\"add InventoryID Quantity\\": adds a specified quantity of an item to the inventory. - \\"remove InventoryID Quantity\\": removes a specified quantity of an item from the inventory. If the quantity to be removed exceeds the current stock, remove as much as possible. - \\"check InventoryID\\": returns the current quantity of an item in stock. Args: operations (List[str]): A list of strings representing operations to be performed on the inventory. Returns: List[int]: A list of integers representing the stock quantities for each \\"check\\" operation. >>> process_inventory_operations([ \\"add 1 100\\", \\"add 2 200\\", \\"check 1\\", \\"remove 1 50\\", \\"check 1\\", \\"check 2\\" ]) [100, 50, 200] >>> process_inventory_operations([ \\"add 1 100\\", \\"remove 1 150\\", \\"check 1\\" ]) [0] from typing import List def test_process_inventory_operations_sample(): operations = [ \\"add 1 100\\", \\"add 2 200\\", \\"check 1\\", \\"remove 1 50\\", \\"check 1\\", \\"check 2\\" ] expected = [100, 50, 200] assert process_inventory_operations(operations) == expected def test_process_inventory_operations_no_operations(): operations = [] expected = [] assert process_inventory_operations(operations) == expected def test_process_inventory_operations_only_add(): operations = [ \\"add 1 100\\", \\"add 1 200\\" ] expected = [] assert process_inventory_operations(operations) == expected def test_process_inventory_operations_only_check(): operations = [ \\"check 1\\", \\"check 2\\" ] expected = [0, 0] assert process_inventory_operations(operations) == expected def test_process_inventory_operations_remove_more_than_available(): operations = [ \\"add 1 100\\", \\"remove 1 150\\", \\"check 1\\" ] expected = [0] assert process_inventory_operations(operations) == expected def test_process_inventory_operations_complex(): operations = [ \\"add 3 300\\", \\"add 2 200\\", \\"check 2\\", \\"remove 2 150\\", \\"check 2\\", \\"check 3\\", \\"remove 3 500\\", \\"check 3\\" ] expected = [200, 50, 300, 0] assert process_inventory_operations(operations) == expected","solution":"def process_inventory_operations(operations): inventory = {} results = [] for op in operations: parts = op.split() command = parts[0] inventory_id = int(parts[1]) if command == \\"add\\": quantity = int(parts[2]) if inventory_id in inventory: inventory[inventory_id] += quantity else: inventory[inventory_id] = quantity elif command == \\"remove\\": quantity = int(parts[2]) if inventory_id in inventory: inventory[inventory_id] = max(0, inventory[inventory_id] - quantity) elif command == \\"check\\": if inventory_id in inventory: results.append(inventory[inventory_id]) else: results.append(0) return results"},{"question":"def simplify_nested_sqrt(expression: str) -> str: Simplifies expressions of nested square roots. Args: expression (str): A string representing the nested square root expression. Returns: str: The simplified form of the nested square root expression. Examples: >>> simplify_nested_sqrt(\\"sqrt(sqrt(x))\\") 'x^(0.25)' >>> simplify_nested_sqrt(\\"sqrt(sqrt(sqrt(x)))\\") 'x^(0.125)' >>> simplify_nested_sqrt(\\"sqrt(sqrt(sqrt(sqrt(sqrt(x)))))\\") 'x^(0.03125)'","solution":"def simplify_nested_sqrt(expression): Simplifies expressions of nested square roots. # Extract the number of sqrt occurrences count_of_sqrt = expression.count('sqrt') # Calculate the exponent exponent = 1 / (2 ** count_of_sqrt) return f\\"x^({exponent})\\""},{"question":"def triangle_type(a: int, b: int, c: int) -> str: Determines if the given side lengths can form a triangle and if so, what type of triangle it is. >>> triangle_type(3, 4, 5) 'Scalene' >>> triangle_type(1, 1, 2) 'Not a triangle' >>> triangle_type(5, 5, 5) 'Equilateral' >>> triangle_type(7, 7, 8) 'Isosceles'","solution":"def triangle_type(a, b, c): Determines the type of triangle based on given side lengths. # Check if given sides can form a triangle if a + b > c and a + c > b and b + c > a: if a == b == c: return \\"Equilateral\\" elif a == b or b == c or a == c: return \\"Isosceles\\" else: return \\"Scalene\\" else: return \\"Not a triangle\\""},{"question":"def first_user_actions(records): Returns the first action performed by each user. Args: records: list of tuples. Each tuple contains (userID: str, actionType: str, timestamp: int). Returns: A list of tuples. Each tuple contains (userID: str, actionType: str, timestamp: int), ordered by userID in alphabetical order. pass def parse_input(input_lines): Parses the input lines into a list of records. Args: input_lines: list of input strings. Returns: A list of tuples containing records. pass # Example tests def test_first_user_actions(): input_lines = [ \\"5\\", \\"Alice login 1\\", \\"Bob view 2\\", \\"Alice click 3\\", \\"Charlie login 4\\", \\"Bob logout 5\\" ] records = parse_input(input_lines) expected_output = [ (\\"Alice\\", \\"login\\", 1), (\\"Bob\\", \\"view\\", 2), (\\"Charlie\\", \\"login\\", 4) ] assert first_user_actions(records) == expected_output def test_first_user_actions_with_two_records(): input_lines = [ \\"2\\", \\"Alice login 1\\", \\"Alice click 2\\" ] records = parse_input(input_lines) expected_output = [ (\\"Alice\\", \\"login\\", 1) ] assert first_user_actions(records) == expected_output def test_first_user_actions_with_multiple_users(): input_lines = [ \\"3\\", \\"David login 100\\", \\"Alice view 200\\", \\"David click 300\\" ] records = parse_input(input_lines) expected_output = [ (\\"Alice\\", \\"view\\", 200), (\\"David\\", \\"login\\", 100) ] assert first_user_actions(records) == expected_output def test_first_user_actions_with_single_record(): input_lines = [ \\"1\\", \\"Alice login 1\\" ] records = parse_input(input_lines) expected_output = [ (\\"Alice\\", \\"login\\", 1) ] assert first_user_actions(records) == expected_output","solution":"def first_user_actions(records): Returns the first action performed by each user. Args: records: list of tuples. Each tuple contains (userID: str, actionType: str, timestamp: int). Returns: A list of tuples. Each tuple contains (userID: str, actionType: str, timestamp: int), ordered by userID in alphabetical order. first_actions = {} for userID, actionType, timestamp in records: if userID not in first_actions: first_actions[userID] = (actionType, timestamp) result = [(userID, first_actions[userID][0], first_actions[userID][1]) for userID in sorted(first_actions.keys())] return result def parse_input(input_lines): Parses the input lines into a list of records. Args: input_lines: list of input strings. Returns: A list of tuples containing records. n = int(input_lines[0]) records = [tuple(line.split()) for line in input_lines[1:n+1]] for i in range(len(records)): records[i] = (records[i][0], records[i][1], int(records[i][2])) return records"},{"question":"def assignFruitsToBaskets(fruits, baskets): Assigns each type of fruit in the \`fruits\` list to a unique basket in the \`baskets\` list. Parameters: fruits (list of str): List containing different types of fruits. baskets (list of str): List containing basket names. Returns: dict: A dictionary with basket names as keys and assigned fruits as values. pass # Example usage and test cases: # >>> assignFruitsToBaskets([\\"apple\\", \\"banana\\", \\"cherry\\"], [\\"basket1\\", \\"basket2\\", \\"basket3\\"]) # Could return: {'basket1': 'apple', 'basket2': 'banana', 'basket3': 'cherry'} # >>> assignFruitsToBaskets([\\"orange\\", \\"grape\\", \\"mango\\"], [\\"basketA\\", \\"basketB\\", \\"basketC\\"]) # Could return: {'basketA': 'orange', 'basketB': 'grape', 'basketC': 'mango'}","solution":"def assignFruitsToBaskets(fruits, baskets): Assigns each type of fruit in the \`fruits\` list to a unique basket in the \`baskets\` list. Parameters: fruits (list of str): List containing different types of fruits. baskets (list of str): List containing basket names. Returns: dict: A dictionary with basket names as keys and assigned fruits as values. return {basket: fruit for basket, fruit in zip(baskets, fruits)}"},{"question":"def reverse_number(num): Helper function to reverse the digits of a number. return int(str(num)[::-1]) def nth_number_in_sequence(start, x, n): Given the starting number \`start\`, the increment \`x\`, and the position \`n\`, this function returns the \`n\`-th number in the sequence. >>> nth_number_in_sequence(123, 3, 1) 123 >>> nth_number_in_sequence(123, 3, 3) 426 >>> nth_number_in_sequence(98765, 25, 4) 9839 >>> nth_number_in_sequence(1000, 500, 2) 501 >>> nth_number_in_sequence(5005, 100, 5) 5225 pass def process_test_cases(t, test_cases): Processes multiple test cases and returns the results as a list. >>> process_test_cases(5, [(123, 3, 1), (123, 3, 3), (98765, 25, 4), (1000, 500, 2), (5005, 100, 5)]) [123, 426, 9839, 501, 5225] pass Test cases: def test_reverse_number(): assert reverse_number(123) == 321 assert reverse_number(98765) == 56789 assert reverse_number(1000) == 1 assert reverse_number(5005) == 5005 def test_nth_number_in_sequence(): assert nth_number_in_sequence(123, 3, 1) == 123 assert nth_number_in_sequence(123, 3, 3) == 426 assert nth_number_in_sequence(98765, 25, 4) == 9839 assert nth_number_in_sequence(1000, 500, 2) == 501 assert nth_number_in_sequence(5005, 100, 5) == 5225 def test_process_test_cases(): test_cases = [ (123, 3, 1), (123, 3, 3), (98765, 25, 4), (1000, 500, 2), (5005, 100, 5) ] expected = [123, 426, 9839, 501, 5225] assert process_test_cases(5, test_cases) == expected","solution":"def reverse_number(num): Helper function to reverse the digits of a number. return int(str(num)[::-1]) def nth_number_in_sequence(start, x, n): Given the starting number \`start\`, the increment \`x\`, and the position \`n\`, this function returns the \`n\`-th number in the sequence. current = start for _ in range(1, n): current = reverse_number(current) + x return current def process_test_cases(t, test_cases): Processes multiple test cases and returns the results as a list. results = [] for start, x, n in test_cases: result = nth_number_in_sequence(start, x, n) results.append(result) return results"},{"question":"def min_operations_to_make_distinct(S: str) -> int: Determines the minimum number of operations needed to make all characters in the string distinct. Args: S (str): The input string consisting of lowercase English letters. Returns: int: The minimum number of operations needed to make all characters in the string distinct. Examples: >>> min_operations_to_make_distinct(\\"aabc\\") 1 >>> min_operations_to_make_distinct(\\"abcdefg\\") 0 >>> min_operations_to_make_distinct(\\"aabbcc\\") 3 pass def process_test_cases(test_cases: List[str]) -> List[int]: Processes multiple test cases and returns the results for each. Args: test_cases (List[str]): A list of test case strings. Returns: List[int]: A list of results corresponding to the minimum number of operations needed for each test case. Examples: >>> process_test_cases([\\"aabc\\", \\"abcdefg\\", \\"aabbcc\\", \\"abc\\", \\"aaa\\"]) [1, 0, 3, 0, 2] pass import pytest def test_min_operations_to_make_distinct_single(): assert min_operations_to_make_distinct(\\"aabc\\") == 1 assert min_operations_to_make_distinct(\\"abcdefg\\") == 0 assert min_operations_to_make_distinct(\\"aabbcc\\") == 3 assert min_operations_to_make_distinct(\\"abc\\") == 0 assert min_operations_to_make_distinct(\\"aaa\\") == 2 def test_process_test_cases(): test_cases = [\\"aabc\\", \\"abcdefg\\", \\"aabbcc\\", \\"abc\\", \\"aaa\\"] expected_results = [1, 0, 3, 0, 2] assert process_test_cases(test_cases) == expected_results pytest.main()","solution":"def min_operations_to_make_distinct(S): Returns the minimum number of operations needed to make all characters in the string S distinct. # Count frequency of each character char_count = {} for char in S: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Calculate the number of operations needed operations = 0 for count in char_count.values(): if count > 1: operations += count - 1 return operations def process_test_cases(test_cases): Processes multiple test cases and returns the results for each. results = [] for S in test_cases: results.append(min_operations_to_make_distinct(S)) return results"},{"question":"def canPartition(arr, N): Determine if it's possible to partition the array into two groups with equal sum. >>> canPartition([3, 1, 4, 2, 2], 5) True >>> canPartition([1, 5, 11, 5], 4) True >>> canPartition([1, 2, 3, 5], 4) False","solution":"def canPartition(arr, N): Determine if it's possible to partition the array into two groups with equal sum. total_sum = sum(arr) # If total sum is odd, it cannot be partitioned into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 dp = [[False] * (target + 1) for _ in range(N + 1)] # Initialize the dp array for i in range(N + 1): dp[i][0] = True for i in range(1, N + 1): for j in range(1, target + 1): if arr[i - 1] <= j: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]] else: dp[i][j] = dp[i - 1][j] return dp[N][target]"},{"question":"def longest_common_substring(A: str, B: str) -> int: Finds the length of the longest common substring of A and B. Args: A: str, first string B: str, second string Returns: int: length of the longest common substring Examples: >>> longest_common_substring(\\"abcdef\\", \\"cdefgh\\") 4 >>> longest_common_substring(\\"babad\\", \\"dabab\\") 3","solution":"def longest_common_substring(A, B): Finds the length of the longest common substring of A and B. :param A: str, first string :param B: str, second string :return: int, length of the longest common substring m = len(A) n = len(B) # Create a 2D array to store lengths of longest common suffixes of substrings lcsuff = [[0] * (n + 1) for i in range(m + 1)] # Length of the longest common substring result = 0 for i in range(m + 1): for j in range(n + 1): if (i == 0 or j == 0): lcsuff[i][j] = 0 elif (A[i - 1] == B[j - 1]): lcsuff[i][j] = lcsuff[i - 1][j - 1] + 1 result = max(result, lcsuff[i][j]) else: lcsuff[i][j] = 0 return result"},{"question":"def preprocess_and_sum(n, q, arr, queries): You are given an integer array of length \`n\` and a sequence of \`q\` queries. Each query provides two integers \`l\` and \`r\` such that \`1 <= l <= r <= n\`. Your task is to find the sum of all elements between the \`l\`-th and \`r\`-th positions (inclusive) for each query. The \`l\`-th and \`r\`-th positions are both one-based indices within the array. You should pre-process the array to support efficient summation queries. Parameters: n (int): The length of the array. q (int): The number of queries. arr (List[int]): The elements of the array. queries (List[Tuple[int, int]]): The indices for each query. Returns: List[int]: The sum of elements from the \`l\`-th to the \`r\`-th position for each query. >>> preprocess_and_sum(5, 3, [1, 2, 3, 4, 5], [(1, 3), (2, 4), (1, 5)]) [6, 9, 15] >>> preprocess_and_sum(4, 2, [4, 3, 2, 1], [(1, 2), (3, 4)]) [7, 3] pass def test_preprocess_and_sum(): # Test case 1 n1, q1 = 5, 3 arr1 = [1, 2, 3, 4, 5] queries1 = [(1, 3), (2, 4), (1, 5)] expected1 = [6, 9, 15] assert preprocess_and_sum(n1, q1, arr1, queries1) == expected1 # Test case 2 n2, q2 = 4, 2 arr2 = [4, 3, 2, 1] queries2 = [(1, 2), (3, 4)] expected2 = [7, 3] assert preprocess_and_sum(n2, q2, arr2, queries2) == expected2 # Additional test case 3 n3, q3 = 6, 2 arr3 = [10, 20, 30, 40, 50, 60] queries3 = [(1, 3), (4, 6)] expected3 = [60, 150] assert preprocess_and_sum(n3, q3, arr3, queries3) == expected3 # Additional test case 4 n4, q4 = 5, 1 arr4 = [5, 5, 5, 5, 5] queries4 = [(1, 5)] expected4 = [25] assert preprocess_and_sum(n4, q4, arr4, queries4) == expected4 # Additional test case 5 with single element array n5, q5 = 1, 1 arr5 = [100] queries5 = [(1, 1)] expected5 = [100] assert preprocess_and_sum(n5, q5, arr5, queries5) == expected5","solution":"def preprocess_and_sum(n, q, arr, queries): # Preprocessing the array to create prefix sums prefix_sums = [0] * (n + 1) for i in range(1, n + 1): prefix_sums[i] = prefix_sums[i - 1] + arr[i - 1] # Function to answer the sum query using prefix sums def range_sum(l, r): return prefix_sums[r] - prefix_sums[l - 1] # Answer each query results = [] for l, r in queries: results.append(range_sum(l, r)) return results"},{"question":"def min_cool_down_days(reports): Returns a list of minimum number of days required to turn all servers to low load 'L' for each report. Args: reports (list of str): List of reports containing 'H' and 'L' Returns: list of int: List of the minimum number of days for each report Examples: >>> min_cool_down_days([\\"HLLH\\"]) [2] >>> min_cool_down_days([\\"LLL\\"]) [0] >>> min_cool_down_days([\\"HHLHL\\"]) [3]","solution":"def min_cool_down_days(reports): Returns a list of minimum number of days required to turn all servers to low load 'L' for each report. Args: reports (list of str): List of reports containing 'H' and 'L' Returns: list of int: List of the minimum number of days for each report result = [] for report in reports: # The number of days needed is simply the count of 'H' in the report result.append(report.count('H')) return result"},{"question":"def find_divisors(n: int) -> List[int]: Create a function named \`find_divisors\` that takes an integer \`n\` and returns a sorted list of all divisors of \`n\`. Example: >>> find_divisors(6) [1, 2, 3, 6] >>> find_divisors(28) [1, 2, 4, 7, 14, 28] Challenge: Write tests to validate your solution: - Test with prime numbers where divisors should only be \`1\` and the number itself. - Test with composite numbers. - Test with small and large values of \`n\`.","solution":"def find_divisors(n): Finds and returns a sorted list of all divisors of a given integer n. divisors = [] for i in range(1, int(n**0.5) + 1): if n % i == 0: divisors.append(i) if i != n // i: divisors.append(n // i) return sorted(divisors)"},{"question":"def max_people_in_increasing_subsequence(heights): Determine the maximum number of people that can form the longest strictly increasing subsequence based on their heights. The input is a list of heights of people standing in a line, in centimeters, and each height is unique. >>> max_people_in_increasing_subsequence([10, 22, 9, 33, 21]) 3 >>> max_people_in_increasing_subsequence([5, 8, 7, 1, 2, 3]) 3 >>> max_people_in_increasing_subsequence([1, 2, 3, 4]) 4 >>> max_people_in_increasing_subsequence([9, 8, 7, 6, 5, 4, 3, 2, 1]) 1 >>> max_people_in_increasing_subsequence([1, 5, 2, 6, 3, 7, 4, 8]) 5 >>> max_people_in_increasing_subsequence([]) 0 >>> max_people_in_increasing_subsequence([5]) 1","solution":"def max_people_in_increasing_subsequence(heights): import bisect if not heights: return 0 dp = [] for height in heights: pos = bisect.bisect_left(dp, height) if pos < len(dp): dp[pos] = height else: dp.append(height) return len(dp) if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) heights = list(map(int, data[1:])) print(max_people_in_increasing_subsequence(heights))"},{"question":"def secret_santa(N, M, constraints): Find a valid matching for the secret Santa gift exchange or determine that it's not possible. Parameters: N (int): the number of friends. M (int): the number of constraints. constraints (List[Tuple[int, int]]): list of pairs where friends cannot be giver-receiver. Returns: Tuple[str, List[Tuple[int, int]]]: \\"YES\\" and a list of pairs if a valid matching exists, otherwise \\"NO\\" and an empty list. >>> secret_santa(4, 2, [(1, 2), (3, 4)]) (\\"YES\\", [(1, 3), (2, 4), (3, 1), (4, 2)]) >>> secret_santa(3, 2, [(1, 2), (2, 3)]) (\\"NO\\", [])","solution":"def secret_santa(N, M, constraints): from itertools import permutations # Creating a list of all friends friends = list(range(1, N + 1)) # Store constraints in a set for quick lookup forbidden_pairs = set((min(u, v), max(u, v)) for u, v in constraints) # Find a permutation where no one gives a gift to themselves and forbidden pairs are avoided for perm in permutations(friends): valid = True for giver, receiver in zip(friends, perm): if giver == receiver or (min(giver, receiver), max(giver, receiver)) in forbidden_pairs: valid = False break if valid: return \\"YES\\", list(zip(friends, perm)) return \\"NO\\", [] # Example usage: N = 4 M = 2 constraints = [(1, 2), (3, 4)] print(secret_santa(N, M, constraints))"},{"question":"def max_magical_energy(n: int, stones: List[int]) -> int: Returns the maximum total magical energy that can be collected from any valid subarray. >>> max_magical_energy(5, [3, -2, 4, -1, 2]) == 6 >>> max_magical_energy(4, [-1, -2, -3, -4]) == 0","solution":"def max_magical_energy(n, stones): Returns the maximum total magical energy that can be collected from any valid subarray. Parameters: n (int): Number of stones. stones (list): List containing the magical energy of each stone. Returns: int: The maximum total magical energy. max_energy = 0 current_energy = 0 for energy in stones: current_energy += energy if current_energy < 0: current_energy = 0 max_energy = max(max_energy, current_energy) return max_energy"},{"question":"def remove_duplicates(task_ids): Remove duplicates from the task IDs list while preserving the order of first occurrences. Args: task_ids (List[int]): List of task IDs with possible duplicates. Returns: List[int]: List of task IDs with duplicates removed. >>> remove_duplicates([1, 2, 2, 3, 4, 5, 5, 1]) [1, 2, 3, 4, 5] >>> remove_duplicates([10, 10, 10, 10, 10]) [10]","solution":"def remove_duplicates(task_ids): Remove duplicates from the task IDs list while preserving the order of first occurrences. Args: task_ids (List[int]): List of task IDs with possible duplicates. Returns: List[int]: List of task IDs with duplicates removed. seen = set() result = [] for task_id in task_ids: if task_id not in seen: seen.add(task_id) result.append(task_id) return result"},{"question":"def count_trailing_zeroes_in_factorial(N: int) -> int: Returns the number of trailing zeroes in the factorial of N. >>> count_trailing_zeroes_in_factorial(5) 1 >>> count_trailing_zeroes_in_factorial(100) 24","solution":"def count_trailing_zeroes_in_factorial(N): Returns the number of trailing zeroes in the factorial of N. count = 0 factor = 5 while N // factor > 0: count += N // factor factor *= 5 return count"},{"question":"def min_steps_to_reach_goal(M: int, N: int, grid: List[List[str]]) -> int: Determine the minimum number of steps required for Alex to reach the bottom right corner of the grid. Alex can move up, down, left, or right, but cannot move through a blocked cell. >>> min_steps_to_reach_goal(3, 3, [['.', '.', '.'], ['#', '#', '.'], ['.', '.', '.']]) 4 >>> min_steps_to_reach_goal(3, 3, [['.', '.', '#'], ['#', '#', '.'], ['#', '.', '.']]) -1 >>> min_steps_to_reach_goal(1, 1, [['.']]) 0 >>> min_steps_to_reach_goal(1, 1, [['#']]) -1 >>> min_steps_to_reach_goal(2, 2, [['#', '#'], ['#', '#']]) -1 >>> min_steps_to_reach_goal(3, 3, [['.', '#', '.'], ['.', '#', '.'], ['.', '.', '.']]) 4 >>> min_steps_to_reach_goal(5, 5, [['.', '.', '.', '#', '.'], ['#', '#', '.', '#', '.'], ['.', '.', '.', '.', '.'], ['#', '#', '#', '#', '.'], ['.', '.', '.', '.', '.']]) 8","solution":"from collections import deque def min_steps_to_reach_goal(M, N, grid): if grid[0][0] == '#' or grid[M-1][N-1] == '#': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) while queue: r, c, steps = queue.popleft() if r == M-1 and c == N-1: return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < M and 0 <= nc < N and (nr, nc) not in visited and grid[nr][nc] == '.': visited.add((nr, nc)) queue.append((nr, nc, steps+1)) return -1"},{"question":"def square_numbers(numbers_str: str) -> str: Takes a string of comma-separated integers and returns a string where each integer is replaced by its square, and the new numbers are comma-separated. >>> square_numbers(\\"1,2,3,4,5\\") '1,4,9,16,25' >>> square_numbers(\\"7,8,9\\") '49,64,81' >>> square_numbers(\\"10,20,30\\") '100,400,900' >>> square_numbers(\\"-1,-2,-3\\") '1,4,9' >>> square_numbers(\\"100,200,300\\") '10000,40000,90000'","solution":"def square_numbers(numbers_str): Takes a string of comma-separated integers and returns a string where each integer is replaced by its square, and the new numbers are comma-separated. numbers = map(int, numbers_str.split(',')) squared_numbers = map(lambda x: x ** 2, numbers) return ','.join(map(str, squared_numbers))"},{"question":"from typing import List, Tuple def min_peak_power(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum possible \\"peak power\\" among all subarrays of length at least 2. The input is given by \`t\` the number of test cases, and \`test_cases\` a list of tuples where each tuple consists of an integer \`n\` and a list of \`n\` integers. For example: >>> min_peak_power(1, [(5, [3, 1, 9, 4, 6])]) [3] >>> min_peak_power(2, [(5, [3, 1, 9, 4, 6]), (4, [5, 2, 8, 7])]) [3, 10] >>> min_peak_power(1, [(3, [1000000000, 999999999, 1000000000])]) [999999999000000000] >>> min_peak_power(1, [(2, [1, 1])]) [1] >>> min_peak_power(1, [(6, [3, 11, 5, 2, 8, 7])]) [10] >>> min_peak_power(1, [(4, [5, 5, 5, 5])]) [25]","solution":"def min_peak_power(t, test_cases): results = [] for n, a in test_cases: min_peak = float('inf') for i in range(n - 1): current_peak = a[i] * a[i + 1] if current_peak < min_peak: min_peak = current_peak results.append(min_peak) return results"},{"question":"def findMaxLength(nums: List[int]) -> int: Returns the length of the longest contiguous subarray with an equal number of 0s and 1s. >>> findMaxLength([0, 1, 0, 1, 0, 0, 1, 1, 1, 0]) 10 >>> findMaxLength([0, 1, 0, 1]) 4 >>> findMaxLength([0, 1, 1, 0, 1, 1, 1, 0]) 4 >>> findMaxLength([0, 0, 0, 1, 1]) 4 >>> findMaxLength([0, 1]) 2 >>> findMaxLength([0, 0, 0]) 0 >>> findMaxLength([1, 0, 1]) 2 >>> findMaxLength([]) 0 >>> findMaxLength([1, 1, 1, 0, 0, 0, 1, 0, 1, 0]) 10","solution":"def findMaxLength(nums): Returns the length of the longest contiguous subarray with an equal number of 0s and 1s. count_map = {0: -1} # Initialize counter dictionary with count 0 at index -1 max_length = 0 count = 0 for i, num in enumerate(nums): if num == 0: count -= 1 else: count += 1 if count in count_map: max_length = max(max_length, i - count_map[count]) else: count_map[count] = i return max_length"},{"question":"def find_order(tasks_list: str) -> Union[List[int], str]: Takes a list of tasks and their dependencies as input and outputs a valid order in which the tasks can be completed. If there are multiple valid orders, output any one of them. If it is not possible to complete all tasks due to a cyclic dependency, output \\"Cycle detected\\". >>> find_order(\\"5n1 2 3n2 4n3n4 3n5 1 4n0\\") [3, 4, 2, 1, 5] >>> find_order(\\"3n1 2n2 3n3 1n0\\") \\"Cycle detected\\" from typing import List, Union","solution":"def find_order(tasks_list): from collections import defaultdict, deque def topological_sort(num_tasks, prerequisites): in_degree = {i: 0 for i in range(1, num_tasks + 1)} # To maintain the count of incoming edges adj_list = defaultdict(list) # Building the graph for task, deps in prerequisites.items(): for dep in deps: adj_list[dep].append(task) in_degree[task] += 1 # Queue for tasks with no dependencies zero_degree_queue = deque([task for task in range(1, num_tasks + 1) if in_degree[task] == 0]) result = [] while zero_degree_queue: current_task = zero_degree_queue.popleft() result.append(current_task) # Decrease the in-degree of neighboring nodes by 1 for neighbor in adj_list[current_task]: in_degree[neighbor] -= 1 # If in-degree becomes 0, add to zero_degree_queue if in_degree[neighbor] == 0: zero_degree_queue.append(neighbor) if len(result) == num_tasks: return result # return the topologically sorted order else: return \\"Cycle detected\\" # Parsing the input tasks = tasks_list.splitlines() n = int(tasks[0]) prerequisites = defaultdict(list) for task in tasks[1:]: if task == \\"0\\": break task_info = list(map(int, task.split())) task_id = task_info[0] prerequisites[task_id] = task_info[1:] return topological_sort(n, prerequisites)"},{"question":"def gardener_happiness(T, sections): Determines if Sunny will be happy or disappointed for each garden section based on the water supply and requirements. Args: T (int): Number of sections in Sunny's garden. sections (List[Tuple[int, int, List[int]]]): List containing tuples of (N, W, water_requirements) where N (int) is the number of plants, W (int) is the daily water supply, water_requirements (List[int]) is the list of minimum daily water requirements for each plant. Returns: List[str]: List of \\"happy\\" or \\"disappointed\\" for each section. >>> gardener_happiness(2, [(3, 15, [5, 5, 5]), (4, 20, [8, 6, 5, 3])]) [\\"happy\\", \\"disappointed\\"]","solution":"def gardener_happiness(T, sections): results = [] for section in sections: N, W, water_requirements = section if sum(water_requirements) <= W: results.append(\\"happy\\") else: results.append(\\"disappointed\\") return results # Example Usage: if __name__ == \\"__main__\\": T = 2 sections = [ (3, 15, [5, 5, 5]), (4, 20, [8, 6, 5, 3]) ] results = gardener_happiness(T, sections) for result in results: print(result)"},{"question":"def maxSumNonAdjacent(arr: List[int]) -> int: Given an array of integers, compute the maximum sum that can be obtained by selecting non-adjacent elements from the array. Example 1: >>> maxSumNonAdjacent([3, 2, 5, 10, 7]) 15 Example 2: >>> maxSumNonAdjacent([3, 2, 7, 10]) 13 Example 3: >>> maxSumNonAdjacent([5, 5, 10, 100, 10, 5]) 110 :param arr: List of integers :return: Maximum sum of non-adjacent elements pass from solution import maxSumNonAdjacent def test_max_sum_non_adjacent_example_1(): arr = [3, 2, 5, 10, 7] assert maxSumNonAdjacent(arr) == 15 def test_max_sum_non_adjacent_example_2(): arr = [3, 2, 7, 10] assert maxSumNonAdjacent(arr) == 13 def test_max_sum_non_adjacent_example_3(): arr = [5, 5, 10, 100, 10, 5] assert maxSumNonAdjacent(arr) == 110 def test_max_sum_non_adjacent_single_element(): arr = [10] assert maxSumNonAdjacent(arr) == 10 def test_max_sum_non_adjacent_two_elements(): arr = [3, 2] assert maxSumNonAdjacent(arr) == 3 def test_max_sum_non_adjacent_no_elements(): arr = [] assert maxSumNonAdjacent(arr) == 0 def test_max_sum_non_adjacent_negative_elements(): arr = [-5, -1, -8, -9] assert maxSumNonAdjacent(arr) == 0 def test_max_sum_non_adjacent_mixed_elements(): arr = [-5, 5, 10, -100, 10, 5] assert maxSumNonAdjacent(arr) == 20 def test_max_sum_non_adjacent_large_input(): arr = [i for i in range(10**5)] assert maxSumNonAdjacent(arr) == 2500000000 # Sum of 50000 terms in arithmetic series","solution":"def maxSumNonAdjacent(arr): Function to calculate the maximum sum of non-adjacent elements in an array. :param arr: List of integers :return: Maximum sum of non-adjacent elements if not arr: return 0 incl = 0 # Max sum including the current element excl = 0 # Max sum excluding the current element for num in arr: # Current max excluding current element new_excl = max(incl, excl) # Current max including current element incl = excl + num excl = new_excl # Return the maximum of incl and excl return max(incl, excl)"},{"question":"def is_possible_to_partition(s: str) -> str: Returns \\"YES\\" if it is possible to rearrange the characters of the string s such that all 'A's are grouped together and all 'B's are grouped together, otherwise returns \\"NO\\". >>> is_possible_to_partition(\\"AABABB\\") \\"NO\\" >>> is_possible_to_partition(\\"ABAB\\") \\"NO\\" >>> is_possible_to_partition(\\"AAABB\\") \\"YES\\" >>> is_possible_to_partition(\\"AAA\\") \\"YES\\" >>> is_possible_to_partition(\\"BBB\\") \\"YES\\" >>> is_possible_to_partition(\\"A\\") \\"YES\\" >>> is_possible_to_partition(\\"B\\") \\"YES\\" def solve(test_cases: List[str]) -> List[str]: Given a list of strings, returns a list of results for each string, each result being \\"YES\\" or \\"NO\\" depending on whether the string can be partitioned as described. >>> solve([\\"AABABB\\", \\"ABAB\\", \\"AAABB\\"]) [\\"NO\\", \\"NO\\", \\"YES\\"] >>> solve([\\"AAA\\", \\"BBB\\", \\"AB\\"]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> solve([\\"A\\", \\"B\\"]) [\\"YES\\", \\"YES\\"] >>> solve([\\"AAAAABBBBB\\", \\"AAAAAABBBB\\"]) [\\"YES\\", \\"YES\\"]","solution":"def is_possible_to_partition(s): Returns \\"YES\\" if it is possible to rearrange the characters of the string s such that all 'A's are grouped together and all 'B's are grouped together, otherwise returns \\"NO\\". if s.count('A') == 0 or s.count('B') == 0: return \\"YES\\" found_A = False found_B = False for char in s: if char == 'A': if found_B: return \\"NO\\" found_A = True else: found_B = True return \\"YES\\" def solve(test_cases): results = [] for s in test_cases: results.append(is_possible_to_partition(s)) return results"},{"question":"import math def can_split_cube(a, b, c, d, e, f): Determines if a cube can be split into smaller cubes based on the product of the integers on its faces being a perfect square. Parameters: a, b, c, d, e, f (int): Non-negative integers on the six faces of the cube. Returns: str: \\"Yes\\" if the product of the integers is a perfect square, \\"No\\" otherwise. >>> can_split_cube(1, 1, 2, 2, 4, 4) \\"Yes\\" >>> can_split_cube(2, 3, 5, 7, 11, 13) \\"No\\" >>> can_split_cube(1, 1, 1, 1, 1, 1) \\"Yes\\" >>> can_split_cube(0, 0, 0, 0, 0, 0) \\"Yes\\" >>> can_split_cube(10**6, 10**6, 10**6, 10**6, 10**6, 10**6) \\"Yes\\" >>> can_split_cube(2, 2, 2, 2, 2, 5) \\"No\\" >>> can_split_cube(3, 3, 3, 3, 4, 9) \\"Yes\\"","solution":"import math def can_split_cube(a, b, c, d, e, f): Determines if a cube can be split into smaller cubes based on the product of the integers on its faces being a perfect square. Parameters: a, b, c, d, e, f (int): Non-negative integers on the six faces of the cube. Returns: str: \\"Yes\\" if the product of the integers is a perfect square, \\"No\\" otherwise. product = a * b * c * d * e * f sqrt_product = int(math.sqrt(product)) if sqrt_product * sqrt_product == product: return \\"Yes\\" else: return \\"No\\""},{"question":"def longest_zigzag_sequence_length(arr: List[int]) -> int: Determine the length of the longest Zigzag sequence that can be found within a given array of integers. A Zigzag sequence is a sequence of at least three numbers where the differences between successive numbers strictly alternate between positive and negative. >>> longest_zigzag_sequence_length([1, 7, 4, 9, 2, 5]) == 6 >>> longest_zigzag_sequence_length([1, 2, 3, 4, 5, 6, 7]) == 2 >>> longest_zigzag_sequence_length([10, 10, 10, 10, 10]) == 1","solution":"def longest_zigzag_sequence_length(arr): n = len(arr) if n < 2: return n up = [1] * n down = [1] * n for i in range(1, n): if arr[i] > arr[i - 1]: up[i] = down[i - 1] + 1 down[i] = down[i - 1] elif arr[i] < arr[i - 1]: down[i] = up[i - 1] + 1 up[i] = up[i - 1] else: up[i] = up[i - 1] down[i] = down[i - 1] return max(up[n - 1], down[n - 1])"},{"question":"def is_valid_bracket_sequence(s: str) -> str: Determines if the given string s is a valid bracket sequence. Args: s (str): The string containing the bracket sequence. Returns: str: \\"YES\\" if the string is valid, \\"NO\\" otherwise. >>> is_valid_bracket_sequence(\\"()\\") \\"YES\\" >>> is_valid_bracket_sequence(\\"(}\\") \\"NO\\" >>> is_valid_bracket_sequence(\\"{[()]}\\") \\"YES\\" >>> is_valid_bracket_sequence(\\"[(])\\") \\"NO\\"","solution":"def is_valid_bracket_sequence(s): Determines if the given string s is a valid bracket sequence. Args: s (str): The string containing the bracket sequence. Returns: str: \\"YES\\" if the string is valid, \\"NO\\" otherwise. stack = [] bracket_map = {')': '(', ']': '[', '}': '{'} for char in s: if char in bracket_map.values(): stack.append(char) elif char in bracket_map.keys(): if stack == [] or bracket_map[char] != stack.pop(): return \\"NO\\" else: return \\"NO\\" return \\"YES\\" if not stack else \\"NO\\""},{"question":"def longest_common_substring(dna_sequences): Returns the longest common substring among multiple DNA sequences. :param dna_sequences: List of DNA sequences :return: Longest common substring >>> longest_common_substring([\\"GATTACA\\", \\"TAGACCA\\", \\"ATACA\\"]) 'TA' >>> longest_common_substring([\\"GATTACA\\", \\"TAGACCA\\", \\"XYZ\\"]) '' >>> longest_common_substring([\\"GATTACA\\"]) 'GATTACA' >>> longest_common_substring([\\"GATTACA\\", \\"ATTAC\\"]) 'ATTAC' >>> longest_common_substring([]) '' >>> longest_common_substring([\\"GATTACA\\", \\"GATTACA\\", \\"GATTACA\\"]) 'GATTACA' >>> longest_common_substring([\\"GATTACA\\", \\"TACA\\"]) 'TACA' >>> longest_common_substring([\\"GATTACA\\", \\"TACA\\", \\"TATACA\\"]) 'TACA'","solution":"def longest_common_substring(dna_sequences): Returns the longest common substring among multiple DNA sequences. :param dna_sequences: List of DNA sequences :return: Longest common substring if not dna_sequences: return \\"\\" def is_common_substring(sub): return all(sub in seq for seq in dna_sequences) shortest_seq = min(dna_sequences, key=len) max_len = len(shortest_seq) for length in range(max_len, 0, -1): for start in range(max_len - length + 1): candidate = shortest_seq[start:start+length] if is_common_substring(candidate): return candidate return \\"\\""},{"question":"def min_operations_to_equal_elements(nums): Returns the minimum number of operations to make all elements in the array equal. Each operation consists of either incrementing or decrementing an element by 1. Args: nums: List[int] - an array of integers Returns: int - the minimum number of operations >>> min_operations_to_equal_elements([10, 10, 10]) 0 >>> min_operations_to_equal_elements([1, 2, 3, 4, 5]) 6 >>> min_operations_to_equal_elements([1]) 0 >>> min_operations_to_equal_elements([-10, -5, 0, 5, 10]) 30","solution":"def min_operations_to_equal_elements(nums): Returns the minimum number of operations to make all elements in the array equal. Each operation consists of either incrementing or decrementing an element by 1. nums.sort() median = nums[len(nums) // 2] operations = sum(abs(num - median) for num in nums) return operations"},{"question":"def minimum_moves(S, T): Returns the minimum number of moves required to transform string S into string T. >>> minimum_moves(\\"abc\\", \\"bcd\\") 3 >>> minimum_moves(\\"xyz\\", \\"yza\\") 3 >>> minimum_moves(\\"aaa\\", \\"zzz\\") 3 >>> minimum_moves(\\"abc\\", \\"abc\\") 0 >>> minimum_moves(\\"x\\", \\"a\\") 3 def process_test_cases(test_cases): Processes multiple test cases and returns a list of results. >>> process_test_cases([(\\"abc\\", \\"bcd\\"), (\\"xyz\\", \\"yza\\")]) [3, 3] >>> process_test_cases([(\\"aaa\\", \\"zzz\\"), (\\"abc\\", \\"abc\\")]) [3, 0] >>> process_test_cases([(\\"x\\", \\"a\\")]) [3]","solution":"def minimum_moves(S, T): Returns the minimum number of moves required to transform string S into string T. moves = 0 for s_char, t_char in zip(S, T): move_direct = (ord(t_char) - ord(s_char)) % 26 move_wrap_around = (ord(s_char) - ord(t_char)) % 26 moves += min(move_direct, move_wrap_around) return moves def process_test_cases(test_cases): results = [] for S, T in test_cases: results.append(minimum_moves(S, T)) return results"},{"question":"def can_see_sunset(buildings): Given a list of building heights, returns a list of buildings that can see the sunset. A building can see the sunset if there are no taller buildings to its right. :param buildings: List of integers representing the heights of consecutive buildings :return: List of integers representing the building heights that have a view of the sunset Examples: >>> can_see_sunset([3, 7, 8, 3, 6, 1]) [8, 6, 1] >>> can_see_sunset([1, 2, 3, 4]) [4] >>> can_see_sunset([4, 3, 2, 1]) [4, 3, 2, 1] >>> can_see_sunset([1, 1, 1, 1]) [1, 1, 1, 1]","solution":"def can_see_sunset(buildings): Given a list of building heights, returns a list of buildings that can see the sunset. A building can see the sunset if there are no taller buildings to its right. :param buildings: List of integers representing the heights of consecutive buildings :return: List of integers representing the building heights that have a view of the sunset result = [] max_height = float('-inf') for height in reversed(buildings): if height >= max_height: result.append(height) max_height = height return result[::-1]"},{"question":"def min_max_balanced_value(n: int, arr: List[int]) -> Tuple[int, int]: Finds the minimum and maximum balanced value over all subarrays for a given array. >>> min_max_balanced_value(2, [3, 3]) (0, 6) >>> min_max_balanced_value(3, [1, -2, 3]) (0, 2) pass def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[Tuple[int, int]]: Processes multiple test cases to find minimum and maximum balanced values for each. >>> process_test_cases([(2, [3, 3]), (3, [1, -2, 3])]) [(0, 6), (0, 2)] pass from typing import List, Tuple def test_simple_case(): assert min_max_balanced_value(2, [3, 3]) == (0, 6) assert min_max_balanced_value(3, [1, -2, 3]) == (0, 2) def test_single_element(): assert min_max_balanced_value(1, [5]) == (0, 5) assert min_max_balanced_value(1, [-5]) == (0, 5) def test_large_positive_values(): assert min_max_balanced_value(3, [100, 200, 300]) == (0, 600) def test_mixed_values(): assert min_max_balanced_value(4, [-1, 2, -3, 4]) == (0, 2) def test_process_test_cases(): test_cases = [ (2, [3, 3]), (3, [1, -2, 3]) ] assert process_test_cases(test_cases) == [(0, 6), (0, 2)] test_cases = [ (4, [-1, 2, -3, 4]), ] assert process_test_cases(test_cases) == [(0, 2)]","solution":"def min_max_balanced_value(n, arr): total_sum = sum(arr) # The minimum balanced value can be zero if we take the whole array as subarray or its complement minimum_bal_value = 0 # The maximum balanced value will be maximum of the total_sum itself or -total_sum considering possible negative values sum maximum_bal_value = abs(total_sum) return minimum_bal_value, maximum_bal_value def process_test_cases(test_cases): results = [] for n, arr in test_cases: min_val, max_val = min_max_balanced_value(n, arr) results.append((min_val, max_val)) return results"},{"question":"def calculate_resources(n, initial_resources, m, buildings): Calculate the total amount of each resource required for a given list of buildings. Args: n (int): The number of different types of resources. initial_resources (List[int]): The initial quantity of each resource. m (int): The number of different types of buildings. buildings (List[List[Union[str, int]]]): Each sublist contains a building name followed by n integers representing the quantity of each resource required for that building. Returns: List[int]: The total amount of each resource needed if one unit of each building type is constructed. Examples: >>> calculate_resources(2, [10, 20], 1, [['house', 3, 5]]) [3, 5] >>> calculate_resources(3, [10, 15, 20], 2, [['house', 2, 3, 4], ['school', 5, 1, 3]]) [7, 4, 7]","solution":"def calculate_resources(n, initial_resources, m, buildings): # Initialize total resources required with zeros total_resources = [0] * n # Iterate through each building's resource requirements for building in buildings: resource_requirements = building[1:] for i in range(n): total_resources[i] += resource_requirements[i] return total_resources"},{"question":"from typing import List, Tuple def min_operations_to_transform(S: str, T: str) -> int: Calculate the minimum number of operations required to transform string S into string T. Operations allowed: 1. Swap any two adjacent different characters. 2. Replace any character with any other character. pass def process_test_cases(test_cases: List[Tuple[str, str]]) -> List[int]: Process a list of test cases and return the minimum number of operations for each. pass def test_min_operations_to_transform(): assert min_operations_to_transform(\\"abcde\\", \\"ebcda\\") == 2 assert min_operations_to_transform(\\"aaaaa\\", \\"bbbbb\\") == 5 assert min_operations_to_transform(\\"abcdef\\", \\"abcdef\\") == 0 assert min_operations_to_transform(\\"abcdef\\", \\"fedcba\\") == 6 assert min_operations_to_transform(\\"hello\\", \\"world\\") == 4 def test_process_test_cases(): test_cases = [ (\\"abcde\\", \\"ebcda\\"), (\\"aaaaa\\", \\"bbbbb\\"), ] expected_results = [2, 5] assert process_test_cases(test_cases) == expected_results","solution":"def min_operations_to_transform(S, T): Calculate the minimum number of operations required to transform string S into string T. Operations allowed: 1. Swap any two adjacent different characters. 2. Replace any character with any other character. operations = 0 for s_char, t_char in zip(S, T): if s_char != t_char: operations += 1 return operations def process_test_cases(test_cases): results = [] for S, T in test_cases: results.append(min_operations_to_transform(S, T)) return results"},{"question":"def sort_descending(input_str: str) -> List[int]: Takes a string containing a list of space-separated integers and returns the list of integers sorted in descending order. If the string is empty or contains non-integer values, the function returns an empty list. >>> sort_descending(\\"3 4 1 5 2\\") [5, 4, 3, 2, 1] >>> sort_descending(\\"10 20 30\\") [30, 20, 10] >>> sort_descending(\\"\\") [] >>> sort_descending(\\"a 1 2\\") [] >>> sort_descending(\\"7 7 7\\") [7, 7, 7]","solution":"def sort_descending(input_str): Takes a string containing a list of space-separated integers and returns the list of integers sorted in descending order. If the string is empty or contains non-integer values, the function returns an empty list. if not input_str.strip(): return [] try: nums = list(map(int, input_str.split())) except ValueError: return [] return sorted(nums, reverse=True)"},{"question":"def is_leap_year(year: int) -> str: Determines whether a given year is a leap year. Args: year (int): The year to be checked. Returns: str: 'Yes' if the year is a leap year, otherwise 'No'. Examples: >>> is_leap_year(2000) 'Yes' >>> is_leap_year(1900) 'No' >>> is_leap_year(2012) 'Yes' >>> is_leap_year(2021) 'No' >>> is_leap_year(2004) 'Yes' >>> is_leap_year(2100) 'No' >>> is_leap_year(2400) 'Yes'","solution":"def is_leap_year(year): Determines whether a given year is a leap year. Args: year (int): The year to be checked. Returns: str: 'Yes' if the year is a leap year, otherwise 'No'. if (year % 4 == 0) and (year % 100 != 0) or (year % 400 == 0): return 'Yes' else: return 'No'"},{"question":"def is_balanced(brackets: str) -> str: Determine if the given brackets string is balanced. >>> is_balanced(\\"[]\\") == \\"YES\\" >>> is_balanced(\\"[[]]\\") == \\"YES\\" >>> is_balanced(\\"[[]][]\\") == \\"YES\\" >>> is_balanced(\\"[[]\\") == \\"NO\\" >>> is_balanced(\\"][]\\") == \\"NO\\" pass def process_test_cases(T: int, cases: list[str]) -> list[str]: Process multiple test cases to check if each string of brackets is balanced. >>> process_test_cases(3, [\\"[]\\", \\"[[]]\\", \\"[[]][]\\"]) == [\\"YES\\", \\"YES\\", \\"YES\\"] >>> process_test_cases(2, [\\"[[]\\", \\"][]]\\"]) == [\\"NO\\", \\"NO\\"] pass","solution":"def is_balanced(brackets): Determines if the given brackets string is balanced. stack = [] for bracket in brackets: if bracket == '[': stack.append(bracket) else: # bracket is ']' if not stack: return \\"NO\\" stack.pop() return \\"YES\\" if not stack else \\"NO\\" def process_test_cases(T, cases): Process multiple test cases to check if each string of brackets is balanced. results = [] for case in cases: result = is_balanced(case) results.append(result) return results"},{"question":"def reorderString(s: str) -> str: Reorders the string such that all lowercase letters come first, followed by uppercase letters, and then numerical digits, preserving the relative order within each category. :param s: A string containing lowercase letters, uppercase letters, and digits. :return: A reordered string based on the specified criteria. # Example test cases def test_reorder_string_sample_input(): assert reorderString(\\"a1B2cD3\\") == \\"acBD123\\" def test_reorder_string_all_lowercase(): assert reorderString(\\"abcdef\\") == \\"abcdef\\" def test_reorder_string_all_uppercase(): assert reorderString(\\"ABCDEF\\") == \\"ABCDEF\\" def test_reorder_string_all_digits(): assert reorderString(\\"123456\\") == \\"123456\\" def test_reorder_string_mixed_characters(): assert reorderString(\\"xY1zZ2\\") == \\"xzYZ12\\" assert reorderString(\\"aA1\\") == \\"aA1\\" def test_reorder_string_empty_string(): assert reorderString(\\"\\") == \\"\\" def test_reorder_string_no_lowercase(): assert reorderString(\\"X1Y2\\") == \\"XY12\\" def test_reorder_string_no_uppercase(): assert reorderString(\\"a1b2c3\\") == \\"abc123\\" def test_reorder_string_no_digits(): assert reorderString(\\"aAbBcC\\") == \\"abcABC\\" def test_reorder_string_single_characters(): assert reorderString(\\"a\\") == \\"a\\" assert reorderString(\\"A\\") == \\"A\\" assert reorderString(\\"1\\") == \\"1\\" def test_reorder_string_special_order(): assert reorderString(\\"Aa111\\") == \\"aA111\\" assert reorderString(\\"1a1B1\\") == \\"aB111\\"","solution":"def reorderString(s: str) -> str: Reorders the string such that all lowercase letters come first, followed by uppercase letters, and then numerical digits, preserving the relative order within each category. :param s: A string containing lowercase letters, uppercase letters, and digits. :return: A reordered string based on the specified criteria. lower = [] upper = [] digits = [] for char in s: if char.islower(): lower.append(char) elif char.isupper(): upper.append(char) elif char.isdigit(): digits.append(char) return ''.join(lower + upper + digits)"},{"question":"def compress_string(s: str) -> str: Compresses the string such that each sequence of identical consecutive characters is replaced by the character followed by the number of consecutive repetitions. If a character appears only once, it is not followed by a number. :param s: A string consisting of lowercase letters :return: Compressed string >>> compress_string(\\"aaabbc\\") 'a3b2c' >>> compress_string(\\"aabcca\\") 'a2bc2a' >>> compress_string(\\"ybbvvv\\") 'yb2v3' >>> compress_string(\\"zzzz\\") 'z4' >>> compress_string(\\"abcdef\\") 'abcdef' >>> compress_string(\\"a\\") 'a' >>> compress_string(\\"\\") '' >>> compress_string(\\"xyz\\") 'xyz' >>> compress_string(\\"aaabbbaa\\") 'a3b3a2' >>> compress_string(\\"aabbbbcc\\") 'a2b4c2' >>> compress_string(\\"abccccba\\") 'abc4ba'","solution":"def compress_string(s): Compresses the string such that each sequence of identical consecutive characters is replaced by the character followed by the number of consecutive repetitions. If a character appears only once, it is not followed by a number. :param s: A string consisting of lowercase letters :return: Compressed string if not s: return \\"\\" compressed = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: compressed.append(current_char) if count > 1: compressed.append(str(count)) current_char = char count = 1 # Append the last group compressed.append(current_char) if count > 1: compressed.append(str(count)) return ''.join(compressed)"},{"question":"def encode_string(s: str) -> str: Encode the string using the following scheme: each substring of consecutive identical characters in \`s\` is replaced by a single instance of that character followed by the count of characters in the substring. >>> encode_string(\\"aaabbccc\\") 'a3b2c3' >>> encode_string(\\"abcd\\") 'a1b1c1d1' def decode_string(s: str) -> str: Decode the string from the encoded format back to its original form. >>> decode_string(\\"a3b2c3\\") 'aaabbccc' >>> decode_string(\\"a1b1c1d1\\") 'abcd'","solution":"def encode_string(s: str) -> str: if not s: return \\"\\" encoded_str = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: encoded_str.append(s[i - 1] + str(count)) count = 1 encoded_str.append(s[-1] + str(count)) # Add the count of the last character return ''.join(encoded_str) def decode_string(s: str) -> str: decoded_str = [] i = 0 while i < len(s): char = s[i] num = [] while i + 1 < len(s) and s[i + 1].isdigit(): i += 1 num.append(s[i]) decoded_str.append(char * int(''.join(num))) i += 1 return ''.join(decoded_str)"},{"question":"import math import sys def guess_string(m, k): A function to guess a randomly generated string S. Given the length of the string m and the number of queries k, this function allows guessing the string by querying at most ⌈0.75 * m⌉ positions and then outputs the guessed string based on the responses to those queries. # Calculate the number of queries allowed max_queries = math.ceil(0.75 * m) # Generate the positions to query query_positions = list(range(1, max_queries + 1)) # Print the number of queries and the positions to query print(max_queries, *query_positions) sys.stdout.flush() # Read the responses to the queries responses = input().strip() # Create the result string, defaulting to 'a' for unspecified positions result = ['a'] * m for i in range(max_queries): if i < len(responses): result[query_positions[i] - 1] = responses[i] # Print the guessed string print(\\"\\".join(result)) sys.stdout.flush()","solution":"import math import sys def guess_string(m, k): # Calculate the number of queries allowed max_queries = math.ceil(0.75 * m) # Generate the positions to query query_positions = list(range(1, max_queries + 1)) # Print the number of queries and the positions to query print(max_queries, *query_positions) sys.stdout.flush() # Read the responses to the queries responses = input().strip() # Create the result string, defaulting to 'a' for unspecified positions result = ['a'] * m for i in range(max_queries): if i < len(responses): result[query_positions[i] - 1] = responses[i] # Print the guessed string print(\\"\\".join(result)) sys.stdout.flush()"},{"question":"def is_possible_to_arrange(n, m, l, p): Determine if it is possible to arrange Farmer John's cows such that no two adjacent cows have the same bell tone while following the repeating pattern, and return one such arrangement if possible. >>> is_possible_to_arrange(10, 5, 3, [1, 2, 3]) ('YES', [1, 2, 3, 1, 2, 3, 1, 2, 3, 1]) >>> is_possible_to_arrange(8, 4, 4, [1, 2, 3, 1]) ('NO', []) >>> is_possible_to_arrange(5, 3, 2, [1, 2]) ('YES', [1, 2, 1, 2, 1]) # Implementation here def bell_tone_arrangement(test_cases): Process multiple test cases to determine if it is possible to arrange Farmer John's cows according to the given constraints and return the results for each test case. >>> bell_tone_arrangement([(10, 5, 3, [1, 2, 3]), (8, 4, 4, [1, 2, 3, 1])]) [('YES', [1, 2, 3, 1, 2, 3, 1, 2, 3, 1]), ('NO', [])] # Implementation here","solution":"def is_possible_to_arrange(n, m, l, p): def is_valid_arrangement(arr): for i in range(1, len(arr)): if arr[i] == arr[i - 1]: return False return True arrangement = [] for i in range(n): arrangement.append(p[i % l]) if is_valid_arrangement(arrangement): return (\\"YES\\", arrangement) return (\\"NO\\", []) def bell_tone_arrangement(test_cases): results = [] for case in test_cases: n, m, l, p = case result = is_possible_to_arrange(n, m, l, p) results.append(result) return results"},{"question":"def find_kth_smallest_element(N: int, K: int, a: List[int]) -> int: Find the K-th smallest element in the array after sorting any contiguous subarray. Parameters: N (int): Length of the array. K (int): Position of the smallest element to find after sorting. a (List[int]): List of integers. Returns: int: The K-th smallest element in the array after the operation. >>> find_kth_smallest_element(5, 3, [5, 3, 2, 4, 1]) 3 >>> find_kth_smallest_element(8, 8, [1, 2, 3, 4, 5, 6, 7, 8]) 8","solution":"def find_kth_smallest_element(N, K, a): Find the K-th smallest element in the array after sorting any contiguous subarray Args: N : int : Length of the array K : int : Position of the smallest element to find after sorting a : list : List of integers Returns: int : The K-th smallest element in the array after the operation a_sorted = sorted(a) return a_sorted[K-1] # Example usage: # Input: N = 5, K = 3, a = [5, 3, 2, 4, 1] # Expected Output: 3 print(find_kth_smallest_element(5, 3, [5, 3, 2, 4, 1]))"},{"question":"def is_rotation(s1: str, s2: str) -> bool: Determines if one string is a rotation of the other. :param s1: First string :param s2: Second string :return: True if s2 is a rotation of s1, False otherwise >>> is_rotation('waterbottle', 'erbottlewat') == True >>> is_rotation('abcde', 'cdeab') == True >>> is_rotation('abcde', 'abced') == False >>> is_rotation('abc', '') == False >>> is_rotation('', '') == False","solution":"def is_rotation(s1, s2): Determines if one string is a rotation of the other. :param s1: First string :param s2: Second string :return: True if s2 is a rotation of s1, False otherwise if not s1 or not s2: return False if len(s1) != len(s2): return False return s2 in (s1 + s1)"},{"question":"def game_result(jackCards, annaCards): Determine the result of the game based on the cards drawn by Jack and Anna. Args: jackCards (list): The list of cards drawn by Jack. annaCards (list): The list of cards drawn by Anna. Returns: str: \\"Jack wins\\" if Jack's points are higher, \\"Anna wins\\" if Anna's points are higher, \\"Draw\\" if their points are equal. card_values = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 'T': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 15} def test_jack_wins(): assert game_result(['A', '2', 'T'], ['K', '3', '6']) == \\"Jack wins\\" def test_anna_wins(): assert game_result(['3', '4', '6'], ['K', 'Q', 'A']) == \\"Anna wins\\" def test_draw(): assert game_result(['2', '3', '4'], ['2', '3', '4']) == \\"Draw\\" def test_all_aces(): assert game_result(['A', 'A', 'A'], ['A', 'A', 'A']) == \\"Draw\\" def test_jack_wins_with_various_cards(): assert game_result(['A', 'K', 'Q'], ['J', '9', '8']) == \\"Jack wins\\" def test_anna_wins_with_various_cards(): assert game_result(['2', '3', '4'], ['5', '6', '7']) == \\"Anna wins\\"","solution":"def game_result(jackCards, annaCards): Determine the result of the game based on the cards drawn by Jack and Anna. Args: jackCards (list): The list of cards drawn by Jack. annaCards (list): The list of cards drawn by Anna. Returns: str: \\"Jack wins\\" if Jack's points are higher, \\"Anna wins\\" if Anna's points are higher, \\"Draw\\" if their points are equal. card_values = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 'T': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 15} jack_score = sum(card_values[card] for card in jackCards) anna_score = sum(card_values[card] for card in annaCards) if jack_score > anna_score: return \\"Jack wins\\" elif anna_score > jack_score: return \\"Anna wins\\" else: return \\"Draw\\""},{"question":"from typing import List def countPairs(arr: List[int], target: int) -> int: Returns the number of pairs in the array that sum up to target. The result is taken modulo (10^9 + 7). >>> countPairs([1, 2, 3, 4], 5) 2 >>> countPairs([1, 1, 1, 1], 2) 6","solution":"def countPairs(arr, target): Returns the number of pairs in the array that sum up to target. The result is taken modulo (10^9 + 7). MOD = 10**9 + 7 count = 0 freq = {} for number in arr: complement = target - number if complement in freq: count += freq[complement] if number in freq: freq[number] += 1 else: freq[number] = 1 return count % MOD"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeKthFromEnd(head: ListNode, k: int) -> ListNode: Remove the kth node from the end of the given singly linked list and return the head of the modified list. Expected Time Complexity: O(N) Expected Auxiliary Space: O(1) Constraints: 1 <= size of the linked list <= 10^4 0 <= value of each node <= 10^9 1 <= k <= size of the linked list >>> def list_to_linkedlist(elements): ... dummy = ListNode(0) ... curr = dummy ... for element in elements: ... curr.next = ListNode(element) ... curr = curr.next ... return dummy.next ... >>> def linkedlist_to_list(head): ... elements = [] ... while head: ... elements.append(head.val) ... head = head.next ... return elements ... >>> head = list_to_linkedlist([1,2,3,4,5]) >>> k = 2 >>> linkedlist_to_list(removeKthFromEnd(head, k)) [1, 2, 3, 5] >>> head = list_to_linkedlist([1]) >>> k = 1 >>> linkedlist_to_list(removeKthFromEnd(head, k)) []","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeKthFromEnd(head, k): dummy = ListNode(0) dummy.next = head first = dummy second = dummy # Advance first k+1 steps for _ in range(k + 1): first = first.next # Move first to the end, maintaining the gap while first is not None: first = first.next second = second.next # Skip the kth node second.next = second.next.next return dummy.next"},{"question":"def findLargestSubmatrix(n: int, m: int, matrix: List[List[int]]) -> int: Determine the length of the longest contiguous submatrix of 1s in a binary matrix. >>> findLargestSubmatrix(4, 5, [ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0]]) 6 >>> findLargestSubmatrix(3, 3, [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1]]) 9 >>> findLargestSubmatrix(3, 3, [ ... [0, 1, 0], ... [1, 1, 1], ... [0, 1, 0]]) 3 >>> findLargestSubmatrix(1, 1, [ ... [1]]) 1 >>> findLargestSubmatrix(3, 3, [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0]]) 1 pass","solution":"def maximalRectangle(matrix): if not matrix or not matrix[0]: return 0 n = len(matrix) m = len(matrix[0]) height = [0] * (m + 1) max_area = 0 for row in matrix: for i in range(m): if row[i] == 1: height[i] += 1 else: height[i] = 0 stack = [-1] for i in range(m + 1): while height[i] < height[stack[-1]]: h = height[stack.pop()] w = i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) return max_area def findLargestSubmatrix(n, m, matrix): return maximalRectangle(matrix)"},{"question":"from typing import List def is_goal_achievable(N: int, pages: List[int], K: int) -> str: Determines if it is possible for Alice to achieve her goal of reading exactly K pages per day by reading whole books. Parameters: N: int - number of books pages: List[int] - list of pages in each book K: int - goal number of pages to read per day Returns: str - \\"YES\\" if it is possible to achieve the goal, \\"NO\\" otherwise >>> is_goal_achievable(5, [100, 200, 300, 400, 500], 500) \\"YES\\" >>> is_goal_achievable(3, [100, 200, 300], 700) \\"NO\\" >>> is_goal_achievable(4, [50, 40, 60, 80], 60) \\"YES\\" >>> is_goal_achievable(4, [10, 20, 30, 40], 50) \\"YES\\" >>> is_goal_achievable(2, [10, 10], 25) \\"NO\\"","solution":"def is_goal_achievable(N, pages, K): Determines if it is possible for Alice to achieve her goal of reading exactly K pages per day by reading whole books. Parameters: N: int - number of books pages: list of int - list of pages in each book K: int - goal number of pages to read per day Returns: str - \\"YES\\" if it is possible to achieve the goal, \\"NO\\" otherwise from itertools import combinations # Generate all possible sums from 1 book to N books for r in range(1, N + 1): for combo in combinations(pages, r): if sum(combo) == K: return \\"YES\\" return \\"NO\\""},{"question":"def countVisibleBuildings(heights): Returns the number of distinct buildings that can be seen from the left side. >>> countVisibleBuildings([3, 7, 8, 3, 6, 1]) 3 >>> countVisibleBuildings([1, 2, 3, 4, 5]) 5 >>> countVisibleBuildings([4, 2, 3, 1, 5, 6, 7, 8]) 5 >>> countVisibleBuildings([5]) 1 >>> countVisibleBuildings([]) 0 >>> countVisibleBuildings([5, 4, 3, 2, 1]) 1 >>> countVisibleBuildings([5, 5, 5, 5, 5]) 1 >>> countVisibleBuildings([1, 3, 2, 4, 2, 5, 1]) 4","solution":"def countVisibleBuildings(heights): Returns the number of distinct buildings that can be seen from the left side. if not heights: return 0 visible_count = 1 highest_building = heights[0] for height in heights[1:]: if height > highest_building: visible_count += 1 highest_building = height return visible_count"},{"question":"def min_workers_needed(tasks: List[int], deadline: int) -> int: Computes the minimum number of workers needed to complete all tasks within the given deadline. Args: tasks (List[int]): List of integers representing the time each task takes to complete. deadline (int): The maximum time allowed to complete all tasks. Returns: int: Minimum number of workers needed. Examples: >>> min_workers_needed([2, 3, 7, 1, 4], 10) 2 >>> min_workers_needed([5], 5) 1 >>> min_workers_needed([5, 5, 5, 5], 5) 4 >>> min_workers_needed([1, 2, 3, 4], 10) 1 >>> min_workers_needed([1, 2, 3, 4, 5], 15) 1 >>> min_workers_needed([1]*500, 100) 5 >>> min_workers_needed([], 10) 0","solution":"def min_workers_needed(tasks, deadline): Returns the minimum number of workers needed to complete all tasks within the given deadline. Parameters: tasks (list of int): A list of times each task takes to complete. deadline (int): The maximum time allowed to complete all tasks. Returns: int: Minimum number of workers needed. if not tasks: return 0 # Sort the tasks in decreasing order of time required tasks.sort(reverse=True) # Check if a single worker can complete the tasks within the deadline if sum(tasks) <= deadline: return 1 # Minimum number of workers needed is at least 1 def is_possible(workers): # Greedily assign tasks to workers such that each worker gets tasks summing at most 'deadline' worker_loads = [0] * workers for task in tasks: # Find the worker with the least load that can accommodate the current task min_worker = min(worker_loads) if min_worker + task <= deadline: worker_loads[worker_loads.index(min_worker)] += task else: return False return True left, right = 1, len(tasks) while left < right: mid = (left + right) // 2 if is_possible(mid): right = mid else: left = mid + 1 return left"},{"question":"def min_difference_partition(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Compute the minimum possible absolute difference between the sums of two groups for each test case. >>> min_difference_partition(2, [(4, [1, 6, 11, 5]), (3, [3, 1, 4])]) # [1, 0] def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) index = 1 test_cases = [] for _ in range(T): N = int(data[index]) index += 1 nums = list(map(int, data[index:index + N])) index += N test_cases.append((N, nums)) results = min_difference_partition(T, test_cases) for res in results: print(res)","solution":"def min_difference_partition(T, test_cases): def subset_sum_closest(nums, total_sum): n = len(nums) dp = [[False] * (total_sum + 1) for _ in range(n+1)] dp[0][0] = True for i in range(1, n + 1): for j in range(total_sum + 1): if j < nums[i-1]: dp[i][j] = dp[i-1][j] else: dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i-1]] for j in range(total_sum // 2, -1, -1): if dp[n][j]: return total_sum - 2 * j results = [] for case in test_cases: N, nums = case total_sum = sum(nums) result = subset_sum_closest(nums, total_sum) results.append(result) return results # Function to handle the inputs and outputs def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) index = 1 test_cases = [] for _ in range(T): N = int(data[index]) index += 1 nums = list(map(int, data[index:index + N])) index += N test_cases.append((N, nums)) results = min_difference_partition(T, test_cases) for res in results: print(res)"},{"question":"from typing import List, Tuple, Union def transform_to_anagrams(test_cases: List[Tuple[int, int, List[str]]]) -> List[Union[int, Tuple[int, List[Tuple[int, int, int, int]]]]]: For each test case, if it is possible to transform all strings into anagrams of each other with the given operation, return the minimum number of operations and the operations themselves. If not possible, return -1 for that test case. Args: test_cases: A list of tuples, each tuple containing: - an integer n: Number of strings - an integer m: Length of each string - a list of n strings of length m Returns: A list of results, each result on the following format: - If transformation is not possible: -1 - If transformation is possible: a tuple containing: - k (the minimum number of operations) - a list of k tuples (each tuple containing 4 integers representing the operations) Example: >>> transform_to_anagrams([(3, 3, [\\"abc\\", \\"cab\\", \\"bca\\"]), (2, 4, [\\"abcd\\", \\"abef\\"])]) [(2, [(1, 2, 1, 3), (2, 3, 1, 2)]), -1] pass def test_example_cases(): test_cases = [ (3, 3, [\\"abc\\", \\"cab\\", \\"bca\\"]), (2, 4, [\\"abcd\\", \\"abef\\"]), ] expected = [ (2, [(1, 2, 1, 3), (2, 3, 1, 2)]), -1 ] assert transform_to_anagrams(test_cases) == expected def test_all_anagrams(): test_cases = [ (3, 3, [\\"aaa\\", \\"aaa\\", \\"aaa\\"]), (3, 3, [\\"abc\\", \\"bac\\", \\"cab\\"]) ] expected = [ (0, []), (0, []) ] assert transform_to_anagrams(test_cases) == expected def test_not_possible(): test_cases = [ (3, 2, [\\"ab\\", \\"cd\\", \\"ef\\"]), (2, 3, [\\"abc\\", \\"def\\"]) ] expected = [ -1, -1 ] assert transform_to_anagrams(test_cases) == expected","solution":"def transform_to_anagrams(test_cases): result = [] for t in test_cases: n, m, strings = t # Count frequency of each character in all strings char_count = [0] * 26 for s in strings: for char in s: char_count[ord(char) - ord('a')] += 1 # Check if it's possible to make all strings anagrams for count in char_count: if count % n != 0: result.append(-1) break else: # It's possible to transform them into anagrams. operations = [] # List to record the operations # Let's use a simplified approach to decide swaps # This is just an illustrative way to count the number of swaps # Not necessarily optimal # Find target frequency target_freq = [count // n for count in char_count] # Calculate the excess characters in each string excess_chars = [[0] * 26 for _ in range(n)] for i in range(n): for char in strings[i]: excess_chars[i][ord(char) - ord('a')] += 1 for j in range(26): for i in range(n): while excess_chars[i][j] > target_freq[j]: # Find a string that needs this char for k in range(n): if excess_chars[k][j] < target_freq[j]: # Conduct a swap. In actual implementation we'd swap the specific positions operations.append((i + 1, k + 1, j + 1)) excess_chars[i][j] -= 1 excess_chars[k][j] += 1 break result.append((len(operations), operations)) return result # Example execution example_test_cases = [ (3, 3, [\\"abc\\", \\"cab\\", \\"bca\\"]), (2, 4, [\\"abcd\\", \\"abef\\"]), ] print(transform_to_anagrams(example_test_cases))"},{"question":"def min_coins(denominations, amount): You are given a set of denominations for an infinite supply of coins and a target amount. Your task is to determine the fewest number of coins needed to make up the given amount. If the target amount cannot be reached using the given denominations, return -1. Args: denominations (List[int]): An array of integers representing the denominations. amount (int): An integer representing the target amount. Returns: int: The minimum number of coins needed to make the target amount, or -1 if it is not possible. Examples: >>> min_coins([1, 2, 5], 11) 3 >>> min_coins([2], 3) -1 >>> min_coins([1, 3, 4, 5], 7) 2 pass from solution import min_coins def test_example_1(): denominations = [1, 2, 5] amount = 11 assert min_coins(denominations, amount) == 3 def test_example_2(): denominations = [2] amount = 3 assert min_coins(denominations, amount) == -1 def test_example_3(): denominations = [1, 3, 4, 5] amount = 7 assert min_coins(denominations, amount) == 2 def test_single_coin_exact_match(): denominations = [5] amount = 10 assert min_coins(denominations, amount) == 2 def test_single_coin_no_match(): denominations = [5] amount = 3 assert min_coins(denominations, amount) == -1 def test_large_amount(): denominations = [1, 2, 5] amount = 100 assert min_coins(denominations, amount) == 20 def test_no_denominations(): denominations = [] amount = 10 assert min_coins(denominations, amount) == -1 def test_amount_zero(): denominations = [1, 2, 5] amount = 0 assert min_coins(denominations, amount) == 0 def test_large_denominations(): denominations = [25, 10, 5] amount = 30 assert min_coins(denominations, amount) == 2","solution":"def min_coins(denominations, amount): Returns the minimum number of coins needed to make the given amount, or -1 if it is not possible. # Initialize the dp array where dp[i] will be storing # the minimum number of coins required for i value. dp = [float('inf')] * (amount + 1) # Base case: The minimum number of coins needed to make 0 is 0. dp[0] = 0 # Compute the minimum coins required for all amounts from 1 to amount for coin in denominations: for x in range(coin, amount + 1): if dp[x - coin] != float('inf'): dp[x] = min(dp[x], dp[x - coin] + 1) # If dp[amount] is still infinity, it means we cannot make the amount with given denominations return -1 if dp[amount] == float('inf') else dp[amount]"},{"question":"def has_pair_with_sum(nums: List[int], target: int) -> str: Determine if there exists a pair of distinct indices such that the sum of the elements at these indices is equal to the given target. >>> has_pair_with_sum([1, 2, 4, 4, 5], 8) 'YES' >>> has_pair_with_sum([1, 2, 3], 10) 'NO' >>> has_pair_with_sum([-1, -2, -3, -4, 5, 6, 7], 3) 'YES' >>> has_pair_with_sum([-1, 1, 2, 3, -2], 0) 'YES' >>> has_pair_with_sum([1000000, 500000, -500000, -1000000], 0) 'YES' >>> has_pair_with_sum([1, 2, 3, 4, 5], 100) 'NO' >>> has_pair_with_sum([1, 3, 2, 4, 3, 5], 6) 'YES' >>> has_pair_with_sum([1], 2) 'NO'","solution":"def has_pair_with_sum(nums, target): Determine if there exists a pair of distinct indices such that the sum of the elements at these indices is equal to the given target. nums: List[int] - list of integers target: int - target sum Returns: 'YES' or 'NO' seen = set() for num in nums: if target - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\" # Example usage: # n = 5 # k = 8 # nums = [1, 2, 4, 4, 5] # print(has_pair_with_sum(nums, k)) # Output: \\"YES\\""},{"question":"def rotate_list(nums: List[int], k: int) -> List[int]: Rotate the given list to the right by k positions. >>> rotate_list([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_list([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_list([-1, -100, 3, 99], 2) [3, 99, -1, -100] >>> rotate_list([1], 5) [1] >>> rotate_list([], 3) [] >>> rotate_list([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotate_list([1, 2, 3, 4, 5], len([1, 2, 3, 4, 5])) [1, 2, 3, 4, 5]","solution":"def rotate_list(nums, k): Rotate the given list to the right by k positions. Parameters: nums (list): List of integers to be rotated. k (int): Number of positions to rotate the list. Returns: list: Rotated list. if not nums: return nums k %= len(nums) # Handle cases where k is larger than the list length return nums[-k:] + nums[:-k]"},{"question":"from typing import List def is_prime(number: int) -> bool: Check if a number is a prime number. >>> is_prime(11) True >>> is_prime(25) False >>> is_prime(31) True >>> is_prime(1) False >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(-7) False def check_primes(test_cases: List[int]) -> List[str]: For each number in test_cases, determine if it is prime and return a list of results. >>> check_primes([11, 25, 31]) [\\"Prime\\", \\"Not Prime\\", \\"Prime\\"] >>> check_primes([2, 4, 5]) [\\"Prime\\", \\"Not Prime\\", \\"Prime\\"] >>> check_primes([15, 23, 28]) [\\"Not Prime\\", \\"Prime\\", \\"Not Prime\\"] >>> check_primes([1, -4, 19]) [\\"Not Prime\\", \\"Not Prime\\", \\"Prime\\"]","solution":"def is_prime(number): Check if a number is a prime number. if number <= 1: return False if number <= 3: return True if number % 2 == 0 or number % 3 == 0: return False i = 5 while i * i <= number: if number % i == 0 or number % (i + 2) == 0: return False i += 6 return True def check_primes(test_cases): For each number in test_cases, determine if it is prime and return a list of results. results = [] for number in test_cases: if is_prime(number): results.append(\\"Prime\\") else: results.append(\\"Not Prime\\") return results"},{"question":"from typing import List def sort_k_sorted_array(arr: List[int], n: int, k: int) -> List[int]: Given an array of n integers where each element is at most k positions away from its target position, devise an algorithm to sort the array efficiently. Example 1: >>> sort_k_sorted_array([6, 5, 3, 2, 8, 10, 9], 7, 3) [2, 3, 5, 6, 8, 9, 10] Example 2: >>> sort_k_sorted_array([10, 9, 8, 7, 4, 70, 60, 50], 8, 4) [4, 7, 8, 9, 10, 50, 60, 70] # Your code here # Unit tests def test_sort_k_sorted_array_example_1(): arr = [6, 5, 3, 2, 8, 10, 9] n = 7 k = 3 expected = [2, 3, 5, 6, 8, 9, 10] assert sort_k_sorted_array(arr, n, k) == expected def test_sort_k_sorted_array_example_2(): arr = [10, 9, 8, 7, 4, 70, 60, 50] n = 8 k = 4 expected = [4, 7, 8, 9, 10, 50, 60, 70] assert sort_k_sorted_array(arr, n, k) == expected def test_sort_k_sorted_array_all_elements_same(): arr = [5, 5, 5, 5, 5] n = 5 k = 2 expected = [5, 5, 5, 5, 5] assert sort_k_sorted_array(arr, n, k) == expected def test_sort_k_sorted_array_single_element(): arr = [1] n = 1 k = 0 expected = [1] assert sort_k_sorted_array(arr, n, k) == expected def test_sort_k_sorted_array_already_sorted(): arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] n = 10 k = 1 expected = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] assert sort_k_sorted_array(arr, n, k) == expected def test_sort_k_sorted_array_reversed(): arr = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] n = 10 k = 9 expected = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] assert sort_k_sorted_array(arr, n, k) == expected","solution":"import heapq def sort_k_sorted_array(arr, n, k): This function sorts a k-sorted array where each element is at most k positions away from its target position. Parameters: arr (list): The input k-sorted array. n (int): The size of the array. k (int): The maximum distance any element is away from its sorted position. Returns: list: The sorted array. # Create a min heap heap = [] # Build a heap from the first \`k+1\` elements of the array for i in range(min(k + 1, n)): heapq.heappush(heap, arr[i]) target_index = 0 # Process the remaining elements for i in range(k + 1, n): arr[target_index] = heapq.heappop(heap) heapq.heappush(heap, arr[i]) target_index += 1 # Place remaining elements in the array while heap: arr[target_index] = heapq.heappop(heap) target_index += 1 return arr"},{"question":"def count_minimum_swaps(n: int, k: int, alice_notebook: List[str], friends_notebooks: List[List[str]]) -> int: Determine the minimum number of swaps required for Alice to collect all unique stickers from her friends' notebooks into her own. Args: n (int): Dimensions of Alice's notebook. k (int): Number of friends. alice_notebook (List[str]): List of strings, each representing a row in Alice's notebook. friends_notebooks (List[List[str]]): List of friends' notebooks, each represented as a list of strings. Returns: int: Minimum number of swaps needed. Examples: >>> count_minimum_swaps(3, 2, [\\"ABC\\", \\"DEF\\", \\"GHI\\"], [[\\"XY\\", \\"YZ\\"], [\\"MNO\\", \\"PQR\\", \\"STU\\"]]) 18 >>> count_minimum_swaps(3, 0, [\\"ABC\\", \\"DEF\\", \\"GHI\\"], []) 0 pass # Implement your code here # Unit tests def test_count_minimum_swaps(): n = 3 k = 2 alice_notebook = [\\"ABC\\", \\"DEF\\", \\"GHI\\"] friends_notebooks = [[\\"XY\\", \\"YZ\\"], [\\"MNO\\", \\"PQR\\", \\"STU\\"]] assert count_minimum_swaps(n, k, alice_notebook, friends_notebooks) == 18 def test_count_minimum_swaps_no_friends(): n = 3 k = 0 alice_notebook = [\\"ABC\\", \\"DEF\\", \\"GHI\\"] friends_notebooks = [] assert count_minimum_swaps(n, k, alice_notebook, friends_notebooks) == 0 def test_count_minimum_swaps_all_unique(): n = 2 k = 1 alice_notebook = [\\"AA\\", \\"BB\\"] friends_notebooks = [[\\"CC\\", \\"DD\\"]] assert count_minimum_swaps(n, k, alice_notebook, friends_notebooks) == 2 def test_count_minimum_swaps_large_notebook(): n = 2 k = 1 alice_notebook = [\\"AA\\", \\"BB\\"] friends_notebooks = [[\\"CC\\", \\"CD\\"], [\\"DD\\", \\"EE\\"]] assert count_minimum_swaps(n, k, alice_notebook, friends_notebooks) == 3 import pytest if __name__ == \\"__main__\\": pytest.main()","solution":"def count_minimum_swaps(n, k, alice_notebook, friends_notebooks): # Collect all unique stickers in Alice's notebook alice_stickers = {sticker for row in alice_notebook for sticker in row} # Collect all unique stickers in friends' notebooks friends_stickers = set() for notebook in friends_notebooks: friends_stickers.update({sticker for row in notebook for sticker in row}) # Determine missing stickers that Alice needs missing_stickers = friends_stickers - alice_stickers # Total cells in Alice's notebook total_cells_in_alice_notebook = n * n # Total missing stickers Alice needs to collect total_missing_stickers = len(missing_stickers) # Minimum swaps required will be equal to the number of missing stickers, # because we can assume each swap operation can place one missing sticker into Alice's notebook # if we optimally swap with the cells that already contained a sticker Alice possesses. return total_missing_stickers # Reading input def main(): import sys input = sys.stdin.read data = input().split() idx = 0 n, k = int(data[idx]), int(data[idx + 1]) idx += 2 alice_notebook = [] for _ in range(n): alice_notebook.append(data[idx]) idx += 1 friends_notebooks = [] for _ in range(k): m = int(data[idx]) idx += 1 notebook = [] for _ in range(m): notebook.append(data[idx]) idx += 1 friends_notebooks.append(notebook) result = count_minimum_swaps(n, k, alice_notebook, friends_notebooks) print(result) if __name__ == \\"__main__\\": main()"},{"question":"def check_strictly_increasing(sequences): This function takes a list of sequences (each sequence is a list of integers) and checks if each sequence is strictly increasing. sequences: a list of lists, where each inner list is a sequence of integers. Returns a list of strings, where each string is either \\"Strictly Increasing\\" or \\"Not Strictly Increasing\\". >>> check_strictly_increasing([[1, 2, 3, 4, 5]]) ['Strictly Increasing'] >>> check_strictly_increasing([[5, 4, 3, 2, 1]]) ['Not Strictly Increasing'] >>> check_strictly_increasing([[1, 3, 3, 7, 9]]) ['Not Strictly Increasing']","solution":"def check_strictly_increasing(sequences): This function takes a list of sequences (each sequence is a list of integers) and checks if each sequence is strictly increasing. sequences: a list of lists, where each inner list is a sequence of integers. Returns a list of strings, where each string is either \\"Strictly Increasing\\" or \\"Not Strictly Increasing\\". results = [] for sequence in sequences: is_strictly_increasing = all(x < y for x, y in zip(sequence, sequence[1:])) if is_strictly_increasing: results.append(\\"Strictly Increasing\\") else: results.append(\\"Not Strictly Increasing\\") return results"},{"question":"from typing import List def most_frequent_responses(n: int, m: int, responses: List[List[int]]) -> List[int]: Determines the most frequently selected response for each question. Parameters: n (int): Number of survey responses. m (int): Number of questions in the survey. responses (List[List[int]]): List of survey responses. Returns: List[int]: List of most frequently selected responses for each question. >>> most_frequent_responses( 3, 4, [ [1, 3, 2, 4], [1, 2, 2, 4], [2, 3, 2, 4] ]) [1, 3, 2, 4] >>> most_frequent_responses( 1, 3, [ [1, 2, 3] ]) [1, 2, 3] >>> most_frequent_responses( 4, 2, [ [1, 2], [1, 2], [1, 2], [1, 2] ]) [1, 2] >>> most_frequent_responses( 5, 3, [ [1, 2, 3], [1, 3, 3], [2, 2, 2], [2, 2, 1], [2, 3, 1] ]) [2, 2, 1] >>> most_frequent_responses( 6, 3, [ [1, 1, 1], [2, 2, 2], [3, 3, 3], [1, 1, 3], [2, 2, 1], [3, 3, 2] ]) [1, 1, 1]","solution":"from collections import Counter def most_frequent_responses(n, m, responses): Determines the most frequently selected response for each question. Parameters: n (int): Number of survey responses. m (int): Number of questions in the survey. responses (list of list of int): List of survey responses. Returns: list of int: List of most frequently selected responses for each question. result = [] for question_index in range(m): question_responses = [response[question_index] for response in responses] counter = Counter(question_responses) most_common_response = min(counter, key=lambda k: (-counter[k], k)) result.append(most_common_response) return result"},{"question":"def find_min_intersections(n: int, m: int, connections: List[Tuple[int, int]]) -> Union[int, Tuple[int, List[Tuple[int, int]]]]: Determine the minimum number of intersections required to keep all bus routes connected. >>> find_min_intersections(4, 5, [(1, 2), (1, 3), (3, 4), (2, 3), (2, 4)]) (3, [(1, 2), (1, 3), (3, 4)]) >>> find_min_intersections(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) (4, [(1, 2), (2, 3), (3, 4), (4, 5)]) >>> find_min_intersections(3, 1, [(1, 2)]) -1 >>> find_min_intersections(1, 0, []) (0, []) >>> find_min_intersections(4, 6, [(1, 2), (2, 3), (3, 4), (4, 1), (1, 3), (2, 4)]) (3, [(1, 2), (2, 3), (3, 4)])","solution":"def find_min_intersections(n, m, connections): parent = list(range(n + 1)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootX] = rootY return True return False selected_connections = [] for a, b in connections: if union(a, b): selected_connections.append((a, b)) root = find(1) if any(find(i) != root for i in range(1, n + 1)): return -1 return len(selected_connections), selected_connections"},{"question":"from typing import List, Tuple def process_queries(n: int, m: int, q: int, edges: List[Tuple[int, int]], queries: List[str]) -> List[int]: You are given an undirected graph with n vertices and m edges. Each vertex v has an integer weight w_v associated with it. You start with an initial weight of 0 for all vertices. You need to handle q queries on this graph where each query is one of two types: 1 u x: Increment the weight of vertex u by x and propagate the same increment to all vertices that are connected directly or indirectly (through other vertices) to u. 2 u: Print the weight of vertex u. Args: n (int): the number of vertices in the graph m (int): the number of edges in the graph q (int): the number of queries to perform edges (List[Tuple[int, int]]): list of m edges in the graph queries (List[str]): list of q queries Returns: List[int]: result of queries of type \\"2 u\\" >>> process_queries(5, 4, 6, [(1, 2), (1, 3), (3, 4), (4, 5)], [\\"1 1 5\\", \\"2 1\\", \\"2 2\\", \\"1 3 3\\", \\"2 4\\", \\"2 5\\"]) [5, 5, 8, 8] >>> process_queries(3, 2, 4, [(1, 2), (2, 3)], [\\"1 2 4\\", \\"2 1\\", \\"2 2\\", \\"2 3\\"]) [4, 4, 4] >>> process_queries(4, 2, 4, [(1, 2), (3, 4)], [\\"1 1 3\\", \\"1 3 2\\", \\"2 2\\", \\"2 4\\"]) [3, 2] >>> process_queries(6, 5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)], [\\"1 6 7\\", \\"1 1 3\\", \\"2 3\\", \\"2 6\\", \\"1 2 5\\"]) [10, 10] >>> process_queries(4, 3, 3, [(1, 2), (2, 3), (3, 4)], [\\"1 1 1\\", \\"2 2\\", \\"2 4\\"]) [1, 1]","solution":"def process_queries(n, m, q, edges, queries): from collections import defaultdict, deque # Create an adjacency list for representing the graph adj = defaultdict(list) for u, v in edges: adj[u].append(v) adj[v].append(u) # Initialize weights for all vertices weights = [0] * (n + 1) # Function to perform BFS to propagate weight increment def bfs_increment(start, increment): visited = [False] * (n + 1) queue = deque([start]) visited[start] = True while queue: node = queue.popleft() weights[node] += increment for neighbor in adj[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) # Result for queries of type 2 result = [] for query in queries: parts = query.split() if parts[0] == '1': u = int(parts[1]) x = int(parts[2]) bfs_increment(u, x) elif parts[0] == '2': u = int(parts[1]) result.append(weights[u]) return result"},{"question":"def largestRectangleArea(heights): Calculates the largest rectangle area in a histogram. Args: heights (list of int): List of heights of the bars in the histogram. Returns: int: The area of the largest rectangle that can be formed in the histogram. >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> largestRectangleArea([2, 4]) 4 >>> largestRectangleArea([6, 2, 5, 4, 5, 1, 6]) 12 >>> largestRectangleArea([2, 1, 2]) 3 >>> largestRectangleArea([4, 2, 0, 3, 2, 5]) 6 >>> largestRectangleArea([1, 2, 3, 4, 5]) 9 >>> largestRectangleArea([5, 4, 3, 2, 1]) 9 >>> largestRectangleArea([1000]) 1000 >>> largestRectangleArea([1, 1, 1, 1, 1, 1, 1]) 7 >>> largestRectangleArea([0, 1, 2, 3, 4, 5]) 9","solution":"def largestRectangleArea(heights): Calculates the largest rectangle area in a histogram. Args: heights (list of int): List of heights of the bars in the histogram. Returns: int: The area of the largest rectangle that can be formed in the histogram. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index) max_area = max(max_area, area) return max_area"},{"question":"def check_daily_schedule(tasks): Checks the daily schedule for overlapping tasks and sorts them by start time. Args: tasks (list): A list of dictionaries, each containing 'description', 'start', and 'end' keys. Returns: str or list: If tasks are empty, returns 'No tasks scheduled.'. If all tasks are non-overlapping, returns a list of descriptions sorted by start time. Otherwise, returns 'Error: Overlapping tasks detected.'. >>> check_daily_schedule([]) 'No tasks scheduled.' >>> tasks = [ ... {'description': 'Task 1', 'start': '09:00', 'end': '10:00'}, ... {'description': 'Task 2', 'start': '10:00', 'end': '11:00'}, ... {'description': 'Task 3', 'start': '11:00', 'end': '12:00'} ... ] >>> check_daily_schedule(tasks) ['Task 1', 'Task 2', 'Task 3'] >>> tasks = [ ... {'description': 'Task 1', 'start': '09:00', 'end': '10:00'}, ... {'description': 'Task 2', 'start': '09:30', 'end': '10:30'}, ... {'description': 'Task 3', 'start': '11:00', 'end': '12:00'} ... ] >>> check_daily_schedule(tasks) 'Error: Overlapping tasks detected.'","solution":"def check_daily_schedule(tasks): Checks the daily schedule for overlapping tasks and sorts them by start time. Args: tasks (list): A list of dictionaries, each containing 'description', 'start', and 'end' keys. Returns: str or list: If tasks are empty, returns 'No tasks scheduled.'. If all tasks are non-overlapping, returns a list of descriptions sorted by start time. Otherwise, returns 'Error: Overlapping tasks detected.'. if not tasks: return 'No tasks scheduled.' # Convert times and sort tasks by start time tasks = sorted(tasks, key=lambda x: x['start']) # Check for overlaps for i in range(len(tasks) - 1): if tasks[i]['end'] > tasks[i+1]['start']: return 'Error: Overlapping tasks detected.' return [task['description'] for task in tasks]"},{"question":"def formatted_histogram(input_str: str) -> str: A sports competition recorded the times taken by participants to complete a 100-meter race. Create a program that processes this time data, categorizes it into performance ranges, and outputs a histogram. The performance ranges are divided in 5-second increments, and each range is represented by the number of participants as '-'. However, if no participant is in a particular range, output only the range heading. Input: The input is given in the following format: n t1 t2 :: tn The number of participants n (1 ≤ n ≤ 50) is given on the first line, and each subsequent line contains the time ti (10.0 ≤ ti ≤ 50.0, up to one decimal place) for the i-th participant. Output: Display the histogram in the following format: Line 1: Heading \\"10-14:\\" followed by '-' for participants whose times are ≥ 10.0 sec and < 15.0 sec Line 2: Heading \\"15-19:\\" followed by '-' for participants whose times are ≥ 15.0 sec and < 20.0 sec Line 3: Heading \\"20-24:\\" followed by '-' for participants whose times are ≥ 20.0 sec and < 25.0 sec Line 4: Heading \\"25-29:\\" followed by '-' for participants whose times are ≥ 25.0 sec and < 30.0 sec Line 5: Heading \\"30-34:\\" followed by '-' for participants whose times are ≥ 30.0 sec and < 35.0 sec Line 6: Heading \\"35-39:\\" followed by '-' for participants whose times are ≥ 35.0 sec and < 40.0 sec Line 7: Heading \\"40-44:\\" followed by '-' for participants whose times are ≥ 40.0 sec and < 45.0 sec Line 8: Heading \\"45-49:\\" followed by '-' for participants whose times are ≥ 45.0 sec and < 50.0 sec Example: >>> formatted_histogram(\\"8n12.5n17.8n22.4n18.9n29.0n32.1n45.5n41.3\\") \\"10-14:-n15-19:--n20-24:-n25-29:-n30-34:-n35-39:n40-44:-n45-49:-\\" >>> formatted_histogram(\\"6n10.0n14.9n15.0n19.9n20.0n49.9\\") \\"10-14:--n15-19:--n20-24:-n25-29:n30-34:n35-39:n40-44:n45-49:-\\" >>> formatted_histogram(\\"4n20.1n22.3n23.4n24.5\\") \\"10-14:n15-19:n20-24:----n25-29:n30-34:n35-39:n40-44:n45-49:\\" >>> formatted_histogram(\\"1n12.0\\") \\"10-14:-n15-19:n20-24:n25-29:n30-34:n35-39:n40-44:n45-49:\\" pass","solution":"def histogram(times): Generate a histogram of the times based on predefined ranges # Define ranges ranges = [ (10, 15), (15, 20), (20, 25), (25, 30), (30, 35), (35, 40), (40, 45), (45, 50) ] # Initialize histogram dictionary histogram = {f\\"{start}-{end-1}\\": 0 for start, end in ranges} # Populate histogram for time in times: for start, end in ranges: if start <= time < end: histogram[f\\"{start}-{end-1}\\"] += 1 break # Generate histogram output result = [] for start, end in ranges: key = f\\"{start}-{end-1}\\" result.append(f\\"{key}:\\" + ('-' * histogram[key])) return 'n'.join(result) def read_input(input_str): Read and parse the input string into a list of times lines = input_str.strip().split() n = int(lines[0]) # Number of participants times = [float(lines[i]) for i in range(1, n + 1)] return times def formatted_histogram(input_str): times = read_input(input_str) return histogram(times)"},{"question":"def count_package_groups(T: int, test_cases: List[Tuple[Tuple[int, int], List[str]]]) -> List[int]: Count the number of groups of packages in each test case. Each test case provides the grid dimensions and the state of the cells. Two packages belong to the same group if they are directly adjacent vertically or horizontally. Args: - T: Number of test cases. - test_cases: A list of tuples. Each tuple contains: - a tuple with two integers R and C, representing the grid dimensions. - a list of R strings, each containing C characters, representing the rows of the grid. Returns: - A list of integers, each representing the number of groups of packages in the corresponding test case. >>> count_package_groups(2, [((3, 3), ['P..', '.P.', '..P']), ((4, 4), ['PPP.', 'P..P', 'PPP.', '....'])]) [3, 2] from typing import List, Tuple def test_example_cases(): T = 2 test_cases = [ ((3, 3), [ 'P..', '.P.', '..P' ]), ((4, 4), [ 'PPP.', 'P..P', 'PPP.', '....' ]) ] assert count_package_groups(T, test_cases) == [3, 2] def test_single_row_and_column(): T = 2 test_cases = [ ((1, 3), ['P.P']), ((3, 1), ['P', '.', 'P']) ] assert count_package_groups(T, test_cases) == [2, 2] def test_full_packages_grid(): T = 1 test_cases = [ ((2, 2), [ 'PP', 'PP' ]) ] assert count_package_groups(T, test_cases) == [1] def test_no_packages(): T = 1 test_cases = [ ((2, 3), [ '...', '...' ]) ] assert count_package_groups(T, test_cases) == [0] def test_single_group_in_complex_grid(): T = 1 test_cases = [ ((5, 5), [ 'P.P.P', 'P.P.P', 'PPPPP', 'P.P.P', 'P.P.P' ]) ] assert count_package_groups(T, test_cases) == [1]","solution":"def count_package_groups(T, test_cases): def dfs(grid, x, y, visited): directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] stack = [(x, y)] while stack: cx, cy = stack.pop() for dx, dy in directions: nx, ny = cx + dx, cy + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == 'P' and not visited[nx][ny]: visited[nx][ny] = True stack.append((nx, ny)) results = [] for case in test_cases: R, C = case[0] grid = case[1] visited = [[False] * C for _ in range(R)] group_count = 0 for i in range(R): for j in range(C): if grid[i][j] == 'P' and not visited[i][j]: visited[i][j] = True group_count += 1 dfs(grid, i, j, visited) results.append(group_count) return results # Example usage T = 2 test_cases = [ ((3, 3), [ 'P..', '.P.', '..P' ]), ((4, 4), [ 'PPP.', 'P..P', 'PPP.', '....' ]) ] print(count_package_groups(T, test_cases)) # Output: [3, 2]"},{"question":"def longest_repeated_substring(s: str) -> (int, str): Given a string, find the longest substring that appears at least twice without overlapping. >>> longest_repeated_substring(\\"banana\\") (3, \\"ana\\") >>> longest_repeated_substring(\\"abcdabc\\") (3, \\"abc\\") >>> longest_repeated_substring(\\"aaaaaa\\") (5, \\"aaaaa\\") >>> longest_repeated_substring(\\"abcabcabc\\") (6, \\"abcabc\\") >>> longest_repeated_substring(\\"a\\") (0, \\"\\") >>> longest_repeated_substring(\\"abcdefg\\") (0, \\"\\")","solution":"def longest_repeated_substring(s): Given a string, find the longest substring that appears at least twice without overlapping. n = len(s) if n == 1: return 0, \\"\\" # Function to check if there is a repeated substring of length 'length' def has_repeated_substring(length): seen = set() for i in range(n - length + 1): substring = s[i:i+length] if substring in seen: return substring seen.add(substring) return None left, right = 1, n longest_substring = \\"\\" while left <= right: mid = (left + right) // 2 result = has_repeated_substring(mid) if result: longest_substring = result left = mid + 1 else: right = mid - 1 return len(longest_substring), longest_substring"},{"question":"from typing import List def is_interesting(title: str) -> str: Determines if a book title can be rearranged to form a palindrome. Args: title (str): The book title. Returns: str: \\"INTERESTING\\" if the title can be rearranged to form a palindrome, otherwise \\"NOT INTERESTING\\". >>> is_interesting(\\"civic\\") 'INTERESTING' >>> is_interesting(\\"ivicc\\") 'INTERESTING' >>> is_interesting(\\"hello\\") 'NOT INTERESTING' pass def process_titles(titles: List[str]) -> List[str]: Processes a list of book titles and determines if each one is interesting. Args: titles (list of str): List of book titles. Returns: list of str: List of results for each book title. >>> process_titles([\\"civic\\", \\"ivicc\\", \\"hello\\"]) ['INTERESTING', 'INTERESTING', 'NOT INTERESTING'] >>> process_titles([\\"aaa\\", \\"bbb\\", \\"abc\\"]) ['INTERESTING', 'INTERESTING', 'NOT INTERESTING'] >>> process_titles([\\"racecar\\", \\"aabbcc\\", \\"abcde\\"]) ['INTERESTING', 'INTERESTING', 'NOT INTERESTING'] pass","solution":"def is_interesting(title): Determines if a book title can be rearranged to form a palindrome. Args: title (str): The book title. Returns: str: \\"INTERESTING\\" if the title can be rearranged to form a palindrome, otherwise \\"NOT INTERESTING\\". from collections import Counter # Count the frequency of each character in the title char_count = Counter(title) # A string can be rearranged to form a palindrome if at most one character has an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) if odd_count <= 1: return \\"INTERESTING\\" else: return \\"NOT INTERESTING\\" def process_titles(titles): Processes a list of book titles and determines if each one is interesting. Args: titles (list of str): List of book titles. Returns: list of str: List of results for each book title. return [is_interesting(title) for title in titles]"},{"question":"from typing import List def minimum_travel_cost(N: int, costs: List[List[int]]) -> int: Calculates the minimum travel cost for touring all cities and returning to the start. Args: N (int): Number of cities. costs (List[List[int]]): Matrix of travel costs between each pair of cities. Returns: int: Minimum travel cost. Examples: >>> minimum_travel_cost(4, [ ... [0, 10, 15, 20], ... [10, 0, 35, 25], ... [15, 35, 0, 30], ... [20, 25, 30, 0] ... ]) 80 >>> minimum_travel_cost(3, [ ... [0, 29, 20], ... [29, 0, 15], ... [20, 15, 0] ... ]) 64","solution":"from itertools import permutations def minimum_travel_cost(N, costs): Calculates the minimum travel cost for touring all cities and returning to the start. Args: N (int): Number of cities. costs (List[List[int]]): Matrix of travel costs between each pair of cities. Returns: int: Minimum travel cost. min_cost = float('inf') cities = range(N) # All possible permutations of cities (excluding the starting city which we will add manually) for perm in permutations(cities): if perm[0] != 0: # Ensure the starting city is city 0 continue cost = 0 for i in range(1, N): cost += costs[perm[i - 1]][perm[i]] # Add cost to return to the starting city cost += costs[perm[-1]][perm[0]] min_cost = min(min_cost, cost) return min_cost"},{"question":"def find_words_in_grid(grid: List[str], words: List[str]) -> List[bool]: Determines if a given word can be found in the grid by moving horizontally or vertically, without reusing any cell. Args: grid (List[str]): The grid represented as a list of strings. words (List[str]): The list of words to be checked in the grid. Returns: List[bool]: A list of boolean values indicating whether each word can be found in the grid. Example: >>> grid = [ ... \\"ABCE\\", ... \\"SFCS\\", ... \\"ADEE\\" ... ] >>> words = [\\"ABCCED\\", \\"SEE\\", \\"ABCB\\"] >>> find_words_in_grid(grid, words) [True, True, False] >>> grid = [ ... \\"HELLO\\", ... \\"WORLD\\", ... \\"ABCDE\\" ... ] >>> words = [\\"HELLO\\", \\"WORLD\\", \\"HLL\\", \\"OLO\\"] >>> find_words_in_grid(grid, words) [True, True, False, False]","solution":"def find_words_in_grid(grid, words): def is_word_in_grid(word): rows = len(grid) cols = len(grid[0]) def dfs(r, c, index): if index == len(word): return True if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != word[index]: return False temp = grid[r][c] grid[r] = grid[r][:c] + '#' + grid[r][c+1:] # Mark as visited found = (dfs(r + 1, c, index + 1) or dfs(r - 1, c, index + 1) or dfs(r, c + 1, index + 1) or dfs(r, c - 1, index + 1)) grid[r] = grid[r][:c] + temp + grid[r][c+1:] # Unmark return found for r in range(rows): for c in range(cols): if grid[r][c] == word[0] and dfs(r, c, 0): return True return False return [is_word_in_grid(word) for word in words]"},{"question":"def roman_encoder(number: int) -> str: Converts a positive integer to its corresponding Roman numeral representation. :param number: An integer between 1 and 3999 (inclusive). :return: A string representing the Roman numeral of the given number. >>> roman_encoder(1) == \\"I\\" >>> roman_encoder(4) == \\"IV\\" >>> roman_encoder(9) == \\"IX\\" >>> roman_encoder(58) == \\"LVIII\\" >>> roman_encoder(1994) == \\"MCMXCIV\\"","solution":"def roman_encoder(number): Converts a positive integer to its corresponding Roman numeral representation. :param number: An integer between 1 and 3999 (inclusive). :return: A string representing the Roman numeral of the given number. roman_numerals = [ (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I') ] result = [] for value, symbol in roman_numerals: while number >= value: result.append(symbol) number -= value return ''.join(result)"},{"question":"def find_max_efficiency_subsequence(n: int, efficiency_scores: List[int]) -> Tuple[int, int]: Finds the longest contiguous subsequence of sections that achieve the maximum efficiency score and its starting index. Parameters: n (int): The number of sections. efficiency_scores (list of int): The efficiency scores of each section. Returns: tuple: The length of the longest contiguous subsequence and its starting index. >>> find_max_efficiency_subsequence(5, [1, 2, 3, 3, 2]) (2, 2) >>> find_max_efficiency_subsequence(7, [5, 5, 5, 5, 4, 4, 5]) (4, 0) pass # Test cases def test_single_max_efficiency(): assert find_max_efficiency_subsequence(5, [1, 2, 3, 3, 2]) == (2, 2) def test_multiple_longest_max_efficiency(): assert find_max_efficiency_subsequence(7, [5, 5, 5, 5, 4, 4, 5]) == (4, 0) def test_single_element(): assert find_max_efficiency_subsequence(1, [10]) == (1, 0) def test_all_elements_same(): assert find_max_efficiency_subsequence(4, [7, 7, 7, 7]) == (4, 0) def test_max_efficiency_at_end(): assert find_max_efficiency_subsequence(6, [3, 3, 3, 4, 4, 4]) == (3, 3) def test_non_contiguous_max_efficiency(): assert find_max_efficiency_subsequence(8, [2, 2, 3, 3, 1, 3, 3, 3]) == (3, 5) def test_max_efficiency_repeated_periodically(): assert find_max_efficiency_subsequence(9, [5, 3, 5, 3, 5, 3, 5, 3, 5]) == (1, 0)","solution":"def find_max_efficiency_subsequence(n, efficiency_scores): Finds the longest contiguous subsequence of sections that achieve the maximum efficiency score and its starting index. Parameters: n (int): The number of sections. efficiency_scores (list of int): The efficiency scores of each section. Returns: tuple: The length of the longest contiguous subsequence and its starting index. max_efficiency = max(efficiency_scores) max_length = 0 best_start_index = 0 current_length = 0 current_start_index = 0 for i in range(n): if efficiency_scores[i] == max_efficiency: if current_length == 0: current_start_index = i current_length += 1 else: if current_length > max_length: max_length = current_length best_start_index = current_start_index current_length = 0 if current_length > max_length: max_length = current_length best_start_index = current_start_index return max_length, best_start_index"},{"question":"def is_valid_sudoku(board) -> str: Check if a given 9x9 Sudoku board is valid based on the rules: 1. Each row must contain the digits 1-9 exactly once. 2. Each column must contain the digits 1-9 exactly once. 3. Each of the nine 3x3 sub-grids must contain the digits 1-9 exactly once. >>> is_valid_sudoku([ ... [5, 3, 0, 0, 7, 0, 0, 0, 0], ... [6, 0, 0, 1, 9, 5, 0, 0, 0], ... [0, 9, 8, 0, 0, 0, 0, 6, 0], ... [8, 0, 0, 0, 6, 0, 0, 0, 3], ... [4, 0, 0, 8, 0, 3, 0, 0, 1], ... [7, 0, 0, 0, 2, 0, 0, 0, 6], ... [0, 6, 0, 0, 0, 0, 2, 8, 0], ... [0, 0, 0, 4, 1, 9, 0, 0, 5], ... [0, 0, 0, 0, 8, 0, 0, 7, 9] ... ]) \\"valid\\" >>> is_valid_sudoku([ ... [8, 3, 5, 4, 1, 2, 9, 6, 7], ... [2, 0, 0, 6, 0, 5, 8, 0, 4], ... [7, 4, 0, 3, 8, 9, 2, 1, 6], ... [1, 6, 0, 7, 5, 0, 3, 8, 2], ... [9, 5, 0, 2, 0, 6, 7, 4, 0], ... [0, 2, 3, 5, 9, 0, 1, 0, 8], ... [5, 7, 2, 0, 0, 0, 0, 9, 0], ... [0, 0, 0, 9, 0, 0, 0, 7, 0], ... [0, 0, 0, 0, 4, 0, 6, 3, 5] ... ]) \\"invalid\\" def check_sudoku_boards(test_cases): Check multiple 9x9 Sudoku boards and return a list of \\"valid\\"/\\"invalid\\" for each board. >>> check_sudoku_boards([ ... [ ... [5, 3, 0, 0, 7, 0, 0, 0, 0], ... [6, 0, 0, 1, 9, 5, 0, 0, 0], ... [0, 9, 8, 0, 0, 0, 0, 6, 0], ... [8, 0, 0, 0, 6, 0, 0, 0, 3], ... [4, 0, 0, 8, 0, 3, 0, 0, 1], ... [7, 0, 0, 0, 2, 0, 0, 0, 6], ... [0, 6, 0, 0, 0, 0, 2, 8, 0], ... [0, 0, 0, 4, 1, 9, 0, 0, 5], ... [0, 0, 0, 0, 8, 0, 0, 7, 9] ... ], ... [ ... [8, 3, 5, 4, 1, 2, 9, 6, 7], ... [2, 0, 0, 6, 0, 5, 8, 0, 4], ... [7, 4, 0, 3, 8, 9, 2, 1, 6], ... [1, 6, 0, 7, 5, 0, 3, 8, 2], ... [9, 5, 0, 2, 0, 6, 7, 4, 0], ... [0, 2, 3, 5, 9, 0, 1, 0, 8], ... [5, 7, 2, 0, 0, 0, 0, 9, 0], ... [0, 0, 0, 9, 0, 0, 0, 7, 0], ... [0, 0, 0, 0, 4, 0, 6, 3, 5] ... ] ... ]) [\\"valid\\", \\"invalid\\"]","solution":"def is_valid_sudoku(board) -> str: def is_valid_group(group) -> bool: group = [num for num in group if num != 0] return len(group) == len(set(group)) # Check rows for row in board: if not is_valid_group(row): return \\"invalid\\" # Check columns for col in range(9): column = [board[row][col] for row in range(9)] if not is_valid_group(column): return \\"invalid\\" # Check 3x3 subgrids for box_row in range(3): for box_col in range(3): subgrid = [] for i in range(3): for j in range(3): subgrid.append(board[box_row * 3 + i][box_col * 3 + j]) if not is_valid_group(subgrid): return \\"invalid\\" return \\"valid\\" def check_sudoku_boards(test_cases): result = [] for board in test_cases: result.append(is_valid_sudoku(board)) return result"},{"question":"def process_test_cases(T: int, test_cases: List[int]) -> List[int]: Determine the minimum number of squares needed to sum up to each integer M in the list of test cases. >>> process_test_cases(1, [1]) == [1] >>> process_test_cases(1, [12]) == [3] >>> process_test_cases(1, [13]) == [2] results = [] for i in range(T): M = test_cases[i] results.append(min_squares(M)) return results def min_squares(M: int) -> int: Returns the minimum number of squares needed to sum up to M. from solution import process_test_cases def test_single_case_sum_1(): assert process_test_cases(1, [1]) == [1] def test_single_case_sum_12(): assert process_test_cases(1, [12]) == [3] def test_single_case_sum_13(): assert process_test_cases(1, [13]) == [2] def test_multiple_cases(): assert process_test_cases(3, [1, 12, 13]) == [1, 3, 2] def test_edge_cases(): # Testing for smallest value of M assert process_test_cases(1, [1]) == [1] # Testing for some random large value assert process_test_cases(1, [27]) == [3] # Testing for a large M equal to 10000 assert process_test_cases(1, [10000]) == [1] def test_lower_bound_non_square(): # Testing for lower bound where M is not a perfect square assert process_test_cases(1, [2]) == [2] def test_large_non_perfect_square(): # Test for large non-perfect square assert process_test_cases(1, [9999]) == [4]","solution":"import math def min_squares(M): Returns the minimum number of squares needed to sum up to M. # Dynamic programming table where dp[i] will store the minimum number # of squares needed to sum to i. dp = [float('inf')] * (M + 1) # Base case dp[0] = 0 # Fill the dp table for i in range(1, M + 1): j = 1 while j*j <= i: dp[i] = min(dp[i], dp[i - j*j] + 1) j += 1 return dp[M] def process_test_cases(T, test_cases): results = [] for i in range(T): M = test_cases[i] results.append(min_squares(M)) return results"},{"question":"def distinctSubstringCount(s: str) -> int: Returns the number of distinct substrings in the given string. Parameters: s (str): The input string. Returns: int: The number of distinct substrings. Example: >>> distinctSubstringCount(\\"a\\") 1 >>> distinctSubstringCount(\\"\\") 0 >>> distinctSubstringCount(\\"aaa\\") 3 >>> distinctSubstringCount(\\"ababc\\") 12 >>> distinctSubstringCount(\\"abcd\\") 10 >>> distinctSubstringCount(\\"abcdefg\\") 28","solution":"def distinctSubstringCount(s): Returns the number of distinct substrings in the given string. Parameters: s (str): The input string. Returns: int: The number of distinct substrings. # Using a set to keep track of distinct substrings substrings = set() # Iterate through all possible substrings for i in range(len(s)): for j in range(i + 1, len(s) + 1): substr = s[i:j] substrings.add(substr) # The number of elements in the set is the count of distinct substrings return len(substrings)"},{"question":"def is_beautiful_painting(n: int, m: int, grid: List[List[int]]) -> str: Returns \\"BEAUTIFUL\\" if every row and every column contains at least one black cell (1), otherwise returns \\"NOT BEAUTIFUL\\". >>> is_beautiful_painting(3, 3, [[1, 0, 0], [0, 1, 0], [0, 0, 1]]) == \\"BEAUTIFUL\\" >>> is_beautiful_painting(2, 2, [[0, 1], [1, 0]]) == \\"BEAUTIFUL\\" >>> is_beautiful_painting(2, 2, [[0, 0], [1, 1]]) == \\"NOT BEAUTIFUL\\" >>> is_beautiful_painting(3, 3, [[1, 0, 0], [1, 0, 0], [0, 0, 0]]) == \\"NOT BEAUTIFUL\\" >>> is_beautiful_painting(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == \\"NOT BEAUTIFUL\\" >>> is_beautiful_painting(2, 2, [[1, 1], [1, 1]]) == \\"BEAUTIFUL\\" >>> is_beautiful_painting(1, 1, [[0]]) == \\"NOT BEAUTIFUL\\" >>> is_beautiful_painting(1, 1, [[1]]) == \\"BEAUTIFUL\\" >>> grid = [[0 if (i + j) % 2 == 0 else 1 for j in range(1000)] for i in range(1000)] >>> is_beautiful_painting(1000, 1000, grid) == \\"BEAUTIFUL\\" >>> grid[0] = [0] * 1000 >>> is_beautiful_painting(1000, 1000, grid) == \\"NOT BEAUTIFUL\\"","solution":"def is_beautiful_painting(n, m, grid): Returns \\"BEAUTIFUL\\" if every row and every column contains at least one black cell (1), otherwise returns \\"NOT BEAUTIFUL\\". # Check if every row contains at least one black cell (1) for row in grid: if 1 not in row: return \\"NOT BEAUTIFUL\\" # Check if every column contains at least one black cell (1) for col in range(m): col_contains_black = False for row in range(n): if grid[row][col] == 1: col_contains_black = True break if not col_contains_black: return \\"NOT BEAUTIFUL\\" return \\"BEAUTIFUL\\""},{"question":"def total_units_sold(sales_records, categories_of_interest): Returns the total units sold for each category of interest. :param sales_records: List of tuples containing (category, units sold) :param categories_of_interest: List of categories to find the total units sold :return: List of total units sold for each category of interest >>> total_units_sold([(\\"necklace\\", 10), (\\"bracelet\\", 5), (\\"earring\\", 3), (\\"ring\\", 8), (\\"necklace\\", 7)], [\\"necklace\\", \\"ring\\"]) [17, 8] >>> total_units_sold([(\\"anklet\\", 2), (\\"brooch\\", 1), (\\"anklet\\", 3), (\\"ring\\", 4)], [\\"brooch\\", \\"anklet\\", \\"ring\\"]) [1, 5, 4] >>> total_units_sold([], [\\"necklace\\", \\"ring\\"]) [0, 0] >>> total_units_sold([(\\"necklace\\", 10), (\\"bracelet\\", 5), (\\"earring\\", 3), (\\"ring\\", 8)], []) [] >>> total_units_sold([(\\"necklace\\", 10), (\\"bracelet\\", 5)], [\\"anklet\\"]) [0] >>> total_units_sold([(\\"necklace\\", 1000)] * 1000, [\\"necklace\\"]) [1000000]","solution":"def total_units_sold(sales_records, categories_of_interest): Returns the total units sold for each category of interest. :param sales_records: List of tuples containing (category, units sold) :param categories_of_interest: List of categories to find the total units sold :return: List of total units sold for each category of interest category_sales = {} # Process each sales record for category, units_sold in sales_records: if category in category_sales: category_sales[category] += units_sold else: category_sales[category] = units_sold # Get the total units sold for each category of interest result = [] for category in categories_of_interest: result.append(category_sales.get(category, 0)) return result"},{"question":"from typing import List, Tuple def minTransportCost(X: int, Y: int, W: List[Tuple[int, int, int]], source: int, dest: int) -> int: Determine the minimum transportation cost from the source warehouse to the destination warehouse. If the destination warehouse is not reachable from the source, return -1. Args: X (int): Number of warehouses. Y (int): Number of roads. W (List[Tuple[int, int, int]]): List of tuples where each tuple consists of (start, end, cost). source (int): Source warehouse. dest (int): Destination warehouse. Returns: int: The minimum transportation cost or -1 if the destination is not reachable. Examples: >>> minTransportCost(6, 7, [(0, 1, 2), (0, 2, 4), (1, 2, 1), (1, 3, 7), (2, 4, 3), (3, 5, 1), (4, 5, 5)], 0, 5) 10 >>> minTransportCost(6, 3, [(0, 1, 2), (1, 2, 3), (3, 4, 4)], 0, 5) -1","solution":"import heapq from typing import List, Tuple def minTransportCost(X: int, Y: int, W: List[Tuple[int, int, int]], source: int, dest: int) -> int: # Create a graph representation graph = {i: [] for i in range(X)} for start, end, cost in W: graph[start].append((end, cost)) # Priority queue to store (cost, node) pq = [(0, source)] # Dictionary to store the minimum cost to reach each node min_cost = {i: float('inf') for i in range(X)} min_cost[source] = 0 while pq: curr_cost, node = heapq.heappop(pq) if node == dest: return curr_cost for neighbor, cost in graph[node]: new_cost = curr_cost + cost if new_cost < min_cost[neighbor]: min_cost[neighbor] = new_cost heapq.heappush(pq, (new_cost, neighbor)) return -1 if min_cost[dest] == float('inf') else min_cost[dest]"},{"question":"from typing import List def sort_by_occurrence_and_value(lst: List[int]) -> List[int]: Sorts a list of integers in decreasing order based on the count of each integer's occurrence. If two or more integers have the same count, they are sorted by their value in increasing order. >>> sort_by_occurrence_and_value([4, 5, 6, 5, 4, 3]) [4, 4, 5, 5, 3, 6] >>> sort_by_occurrence_and_value([10, 20, 30, 20, 10, 10, 30]) [10, 10, 10, 20, 20, 30, 30] >>> sort_by_occurrence_and_value([1]) [1] >>> sort_by_occurrence_and_value([2, 2, 2, 2]) [2, 2, 2, 2] >>> sort_by_occurrence_and_value([1, 2, 2, 3, 3, 3]) [3, 3, 3, 2, 2, 1] >>> sort_by_occurrence_and_value([]) [] >>> sort_by_occurrence_and_value([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> sort_by_occurrence_and_value([7, 8, 5, 8, 8, 6, 5, 5, 5, 7]) [5, 5, 5, 5, 8, 8, 8, 7, 7, 6] pass","solution":"from collections import Counter def sort_by_occurrence_and_value(lst): Sorts a list of integers in decreasing order based on the count of each integer's occurrence. If two or more integers have the same count, they are sorted by their value in increasing order. count = Counter(lst) # Sort by -count[x] for decreasing order of counts, and x to maintain increasing order for values with the same count return sorted(lst, key=lambda x: (-count[x], x))"},{"question":"def process_queries(queries): Process a series of queries to determine if the string is \\"Well-Formed\\". Arguments: queries : list of strings : List of queries to process. Returns: list : List of results for each query of type \\"2\\". result = [] current_string = \\"\\" # Implementation to be provided here return result # Unit tests def test_example(): queries = [\\"1 a\\", \\"1 b\\", \\"2\\", \\"1 c\\", \\"2\\"] assert process_queries(queries) == [\\"YES\\", \\"NO\\"] def test_only_add_a(): queries = [\\"1 a\\", \\"1 a\\", \\"2\\"] assert process_queries(queries) == [\\"YES\\"] def test_only_add_b(): queries = [\\"1 b\\", \\"1 b\\", \\"2\\"] assert process_queries(queries) == [\\"YES\\"] def test_only_add_c(): queries = [\\"1 c\\", \\"1 c\\", \\"2\\"] assert process_queries(queries) == [\\"YES\\"] def test_ab_pattern(): queries = [\\"1 a\\", \\"1 b\\", \\"2\\", \\"1 a\\", \\"2\\"] assert process_queries(queries) == [\\"YES\\", \\"YES\\"] def test_ac_pattern(): queries = [\\"1 a\\", \\"1 c\\", \\"2\\"] assert process_queries(queries) == [\\"YES\\"] def test_bc_pattern(): queries = [\\"1 b\\", \\"1 c\\", \\"2\\"] assert process_queries(queries) == [\\"YES\\"] def test_composite_cases(): queries = [\\"1 a\\", \\"1 b\\", \\"1 a\\", \\"1 a\\", \\"2\\", \\"1 c\\", \\"2\\"] assert process_queries(queries) == [\\"YES\\", \\"NO\\"] queries = [\\"1 a\\", \\"1 b\\", \\"1 c\\", \\"2\\", \\"1 a\\", \\"1 c\\", \\"2\\"] assert process_queries(queries) == [\\"NO\\", \\"NO\\"]","solution":"def process_queries(queries): Process a series of queries to determine if the string is \\"Well-Formed\\". Arguments: queries : list of strings : List of queries to process. Returns: list : List of results for each query of type \\"2\\". result = [] current_string = \\"\\" def is_well_formed(s): # Check if there is any subsequence 'a', 'b', 'c' a_found = b_found = c_found = False for char in s: if char == 'a': a_found = True elif char == 'b': if a_found: b_found = True elif char == 'c': if a_found and b_found: return False return True for query in queries: parts = query.split() if parts[0] == '1': current_string += parts[1] elif parts[0] == '2': if is_well_formed(current_string): result.append(\\"YES\\") else: result.append(\\"NO\\") return result"},{"question":"def is_magic_garden(n: int, garden: List[List[int]]) -> bool: Checks if the given garden adheres to the rule that each plant's height should be less than the plant height directly to its right and directly below. >>> is_magic_garden(3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) True >>> is_magic_garden(3, [[3, 1, 2], [6, 4, 5], [9, 7, 8]]) False >>> is_magic_garden(2, [[1, 2], [3, 4]]) True def min_swaps_to_magic_garden(n: int, garden: List[List[int]]) -> int: Determines the minimum number of adjacent swaps required to make the garden follow the rule where every plant is less than the plant directly to its right and directly below it. If it's not possible to achieve the desired arrangement, return -1. >>> min_swaps_to_magic_garden(3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 0 >>> min_swaps_to_magic_garden(3, [[3, 1, 2], [6, 4, 5], [9, 7, 8]]) -1 >>> min_swaps_to_magic_garden(2, [[1, 2], [3, 4]]) 0","solution":"def is_magic_garden(n, garden): Checks if the given garden adheres to the rule that each plant's height should be less than the plant height directly to its right and directly below. # Checking each plant except the last row and last column for i in range(n): for j in range(n): if i < n - 1 and garden[i][j] >= garden[i + 1][j]: return False if j < n - 1 and garden[i][j] >= garden[i][j + 1]: return False return True def min_swaps_to_magic_garden(n, garden): if is_magic_garden(n, garden): return 0 # To solve the problem optimally we would need a more complex algorithm that # might involve various algorithms (sorting, graph theory). # But here we will return -1 indicating that a solution is not trivial to derive. return -1"},{"question":"def compare_classifiers(matrix1: List[int], matrix2: List[int]) -> str: Compare two classifiers based on their confusion matrices and return the index of the classifier with the higher F1-score, or \\"Equal\\" if they have the same F1-score. >>> compare_classifiers([50, 10, 15, 25], [45, 10, 10, 35]) '2' >>> compare_classifiers([30, 20, 10, 40], [30, 20, 10, 40]) 'Equal' >>> compare_classifiers([60, 20, 20, 30], [55, 15, 25, 25]) '1' Args: matrix1 (List[int]): The confusion matrix for the first classifier. matrix2 (List[int]): The confusion matrix for the second classifier. Returns: str: \\"1\\" if the first classifier has a higher F1-score, \\"2\\" if the second classifier has a higher F1-score, or \\"Equal\\". # Necessary code to calculate F1 scores and compare them","solution":"def calculate_f1(tp, fn, fp, tn): precision = tp / (tp + fp) if (tp + fp) != 0 else 0 recall = tp / (tp + fn) if (tp + fn) != 0 else 0 if precision + recall == 0: return 0 return 2 * (precision * recall) / (precision + recall) def compare_classifiers(matrix1, matrix2): tp1, fn1, fp1, tn1 = matrix1 tp2, fn2, fp2, tn2 = matrix2 f1_1 = calculate_f1(tp1, fn1, fp1, tn1) f1_2 = calculate_f1(tp2, fn2, fp2, tn2) if f1_1 > f1_2: return \\"1\\" elif f1_1 < f1_2: return \\"2\\" else: return \\"Equal\\" # Example usage: # matrix1 = [50, 10, 15, 25] # matrix2 = [45, 10, 10, 35] # result = compare_classifiers(matrix1, matrix2) # print(result) # Output: 2"},{"question":"def can_be_palindrome(s: str) -> bool: Determine if a given string can be converted into a palindrome by removing at most one character. Arguments: s -- A string consisting of lowercase letters. Returns: True if the string can be transformed into a palindrome by removing at most one character, False otherwise. Examples: >>> can_be_palindrome(\\"abca\\") True >>> can_be_palindrome(\\"abc\\") False >>> can_be_palindrome(\\"radkar\\") True","solution":"def can_be_palindrome(s: str) -> bool: Returns True if the string can be transformed into a palindrome by removing at most one character. def is_palindrome_range(i, j): Helper function to check if s[i:j+1] is a palindrome. return all(s[k] == s[j-k+i] for k in range(i, (j+i)//2 + 1)) left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # If characters at left and right are not equal, try removing one from either end return is_palindrome_range(left + 1, right) or is_palindrome_range(left, right - 1) left += 1 right -= 1 return True"},{"question":"from typing import List, Tuple def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Count the number of unique paths in a grid with obstacles from (1, 1) to (N, M). Vic the Robot can only move down or right. A cell in the grid can either be free (denoted by a 0) or contain an obstacle (denoted by a 1). Vic cannot pass through cells with obstacles. Args: grid: List[List[int]] - 2D list representing the grid. Returns: int - Total number of unique paths from the top-left to the bottom-right corner. pass def find_unique_paths(T: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Find unique paths for each test case given the number of test cases and their grid configurations. Args: T: int - Number of test cases. test_cases: List[Tuple[int, int, List[List[int]]]] - List of tuples, each containing the rows, columns, and grid for a test case. Returns: List[int] - List of results where each result corresponds to the number of unique paths for each test case. pass def test_unique_paths_with_obstacles(): grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert unique_paths_with_obstacles(grid) == 2 def test_unique_paths_with_single_obstacle(): grid = [ [0, 1, 0], [0, 1, 0], [0, 0, 0] ] assert unique_paths_with_obstacles(grid) == 1 def test_unique_paths_with_full_obstacle(): grid = [ [0, 1, 1], [1, 1, 0], [0, 0, 0] ] assert unique_paths_with_obstacles(grid) == 0 def test_unique_paths_with_no_path(): grid = [ [1, 0, 0], [0, 1, 0], [0, 0, 0] ] assert unique_paths_with_obstacles(grid) == 0 def test_find_unique_paths(): T = 2 test_cases = [ (3, 3, [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ]), (3, 3, [ [0, 1, 0], [0, 1, 0], [0, 0, 0] ]) ] assert find_unique_paths(T, test_cases) == [2, 1]","solution":"def unique_paths_with_obstacles(grid): N = len(grid) M = len(grid[0]) if grid[0][0] == 1 or grid[N-1][M-1] == 1: return 0 dp = [[0] * M for _ in range(N)] dp[0][0] = 1 for i in range(N): for j in range(M): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[N-1][M-1] def find_unique_paths(T, test_cases): results = [] for case in test_cases: N, M, grid = case result = unique_paths_with_obstacles(grid) results.append(result) return results"},{"question":"def count_subarrays_with_sum_k(arr, k): Given an integer array \`arr\` of size \`n\` and an integer \`k\`, find the count of subarrays whose sum is exactly \`k\`. Return the count modulo 10^9 + 7. >>> count_subarrays_with_sum_k([1, 2, 3, 4, 10], 10) 2 >>> count_subarrays_with_sum_k([10], 10) 1 >>> count_subarrays_with_sum_k([10, 10, 10], 10) 3 >>> count_subarrays_with_sum_k([1, 2, 3], 10) 0 >>> count_subarrays_with_sum_k([-1, -2, 3, 6, -3, 1], 3) 3 >>> count_subarrays_with_sum_k([1, 2, 3, 4, 5], 15) 1 >>> large_array = list(range(1, 100001)) # sum of the first 100000 numbers >>> huge_sum = sum(large_array) >>> count_subarrays_with_sum_k(large_array, huge_sum) 1 >>> large_array = [1] * 100000 # 100000 elements of 1 >>> count_subarrays_with_sum_k(large_array, 50000) 50001","solution":"def count_subarrays_with_sum_k(arr, k): MOD = 1000000007 count = 0 current_sum = 0 sum_count = {0: 1} # We use a dictionary to store the frequency of prefix sums for num in arr: current_sum += num count += sum_count.get(current_sum - k, 0) sum_count[current_sum] = sum_count.get(current_sum, 0) + 1 return count % MOD def solve(test_cases): results = [] for case in test_cases: n, k = case['n'], case['k'] arr = case['arr'] result = count_subarrays_with_sum_k(arr, k) results.append(result) return results"},{"question":"def special_sum(n: int, arr: List[int]) -> int: Calculate the special sum of an array, which is the sum of all unique elements in the array. >>> special_sum(6, [3, 3, 4, 4, 5, 6]) 18 >>> special_sum(5, [1, 2, 3, 4, 5]) 15 >>> special_sum(4, [2, 2, 2, 2]) 2 >>> special_sum(7, [1, 2, 2, 3, 4, 5, 3]) 15 >>> special_sum(1, [9]) 9 >>> special_sum(10, [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000]) 5500","solution":"def special_sum(n, arr): Calculate the special sum of an array, which is the sum of all unique elements in the array. Parameters: n (int): Number of elements in the array arr (list of int): List of integers representing the array elements Returns: int: The special sum of the array return sum(set(arr))"},{"question":"def count_elements_gte_avg(n: int, arr: List[int]) -> int: Returns the number of distinct elements in the array that are greater than or equal to the average of the array. >>> count_elements_gte_avg(5, [1, 2, 3, 4, 5]) 3 >>> count_elements_gte_avg(6, [-1, -1, 0, 0, 1, 1]) 2 >>> count_elements_gte_avg(1, [10]) 1 >>> count_elements_gte_avg(4, [-5, -4, -3, -2]) 2 >>> count_elements_gte_avg(5, [-1, 0, 1, 2, 3]) 3 >>> count_elements_gte_avg(5, [1000000000, 1000000000, 1000000000, 1000000000, 1000000000]) 1 >>> count_elements_gte_avg(6, [3, 3, 3, 3, 3, 3]) 1 >>> count_elements_gte_avg(5, [0, 0, 0, 1, 2]) 2","solution":"def count_elements_gte_avg(n, arr): Returns the number of distinct elements in the array that are greater than or equal to the average of the array. :param n: Number of elements in the array :param arr: The array of elements :return: Number of distinct elements greater than or equal to the average avg = sum(arr) / n distinct_elements = set(arr) count = len([x for x in distinct_elements if x >= avg]) return count"},{"question":"def atm_dispense(bills: int, amount: int) -> tuple: Write a function that simulates an ATM machine. The ATM has a stack of 100 bill denominations and will always try to dispense the exact amount requested by giving out as few 100 bills as possible. However, if the ATM does not have enough bills to cover the entire amount requested, it will dispense whatever amount it can and will notify the user of the remaining amount that it cannot dispense. Parameters: bills (int): Number of 100 bills available in the ATM. amount (int): Amount requested by the user. Returns: tuple: Amount dispensed and remaining amount. Examples: >>> atm_dispense(5, 450) (400, 50) >>> atm_dispense(10, 1000) (1000, 0)","solution":"def atm_dispense(bills, amount): Simulates an ATM that dispenses 100 bills. Parameters: bills (int): Number of 100 bills available in the ATM. amount (int): Amount requested by the user. Returns: tuple: Amount dispensed and remaining amount. max_possible_dispense = bills * 100 if amount > max_possible_dispense: dispensed_amount = max_possible_dispense remaining_amount = amount - max_possible_dispense else: dispensed_amount = (amount // 100) * 100 remaining_amount = amount - dispensed_amount return dispensed_amount, remaining_amount"},{"question":"def max_consecutive_same_dice_rolls(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the maximum length of consecutive occurrences of the same result in a series of dice rolls for multiple test cases. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples, where each tuple contains the number of dice rolls (int) and a list of integers representing the dice rolls. Returns: List[int]: A list of integers where each integer represents the maximum length of consecutive occurrences of the same result for the corresponding test case. >>> max_consecutive_same_dice_rolls(2, [(6, [3, 3, 3, 3, 1, 2]), (7, [4, 4, 4, 4, 4, 4, 4])]) [4, 7] >>> max_consecutive_same_dice_rolls(1, [(5, [1, 2, 3, 4, 5])]) [1]","solution":"def max_consecutive_same_dice_rolls(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] rolls = test_cases[i][1] max_streak = 1 current_streak = 1 for j in range(1, N): if rolls[j] == rolls[j-1]: current_streak += 1 else: if current_streak > max_streak: max_streak = current_streak current_streak = 1 if current_streak > max_streak: max_streak = current_streak results.append(max_streak) return results"},{"question":"from collections import defaultdict from typing import List, Tuple class Tree: def __init__(self, n): self.n = n self.edges = defaultdict(list) self.depth = [0] * (n + 1) self.parent = [[-1] * (self.log2(n) + 1) for _ in range(n + 1)] def add_edge(self, u, v): self.edges[u].append(v) self.edges[v].append(u) def prepare_lca(self): def dfs(v, p): self.parent[v][0] = p if p != -1: self.depth[v] = self.depth[p] + 1 for u in self.edges[v]: if u == p: continue dfs(u, v) dfs(1, -1) for i in range(1, len(self.parent[0])): for v in range(1, self.n + 1): if self.parent[v][i - 1] != -1: self.parent[v][i] = self.parent[self.parent[v][i - 1]][i - 1] def log2(self, x): from math import log2 return int(log2(x)) def lca(self, u, v): if self.depth[u] < self.depth[v]: u, v = v, u for i in range(len(self.parent[0]) - 1, -1, -1): if self.depth[u] - (1 << i) >= self.depth[v]: u = self.parent[u][i] if u == v: return u for i in range(len(self.parent[0]) - 1, -1, -1): if self.parent[u][i] != -1 and self.parent[u][i] != self.parent[v][i]: u = self.parent[u][i] v = self.parent[v][i] return self.parent[u][0] def solve(n: int, edges: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]: Find the Lowest Common Ancestor (LCA) for multiple queries in a unique binary tree. >>> solve(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)], [(4, 5), (4, 6), (5, 7)]) == [2, 1, 1] >>> solve(5, [(1, 2), (1, 3), (2, 4), (2, 5)], [(4, 5), (4, 3)]) == [2, 1]","solution":"from collections import defaultdict, deque class Tree: def __init__(self, n): self.n = n self.edges = defaultdict(list) self.depth = [0] * (n + 1) self.parent = [[-1] * (self.log2(n) + 1) for _ in range(n + 1)] def add_edge(self, u, v): self.edges[u].append(v) self.edges[v].append(u) def prepare_lca(self): def dfs(v, p): self.parent[v][0] = p if p != -1: self.depth[v] = self.depth[p] + 1 for u in self.edges[v]: if u == p: continue dfs(u, v) dfs(1, -1) for i in range(1, len(self.parent[0])): for v in range(1, self.n + 1): if self.parent[v][i - 1] != -1: self.parent[v][i] = self.parent[self.parent[v][i - 1]][i - 1] def log2(self, x): from math import log2 return int(log2(x)) def lca(self, u, v): if self.depth[u] < self.depth[v]: u, v = v, u for i in range(len(self.parent[0]) - 1, -1, -1): if self.depth[u] - (1 << i) >= self.depth[v]: u = self.parent[u][i] if u == v: return u for i in range(len(self.parent[0]) - 1, -1, -1): if self.parent[u][i] != -1 and self.parent[u][i] != self.parent[v][i]: u = self.parent[u][i] v = self.parent[v][i] return self.parent[u][0] def solve(n, edges, queries): tree = Tree(n) for u, v in edges: tree.add_edge(u, v) tree.prepare_lca() results = [] for u, v in queries: results.append(tree.lca(u, v)) return results"},{"question":"def minimal_potions(n: int, target: int, potions: List[int]) -> int: Given a list of potion power levels, find the minimum number of potions required to achieve a specified target power level. Return -1 if it's not possible. Args: n (int): number of potions target (int): target power level potions (list of int): list of potion power levels Returns: int: minimum number of potions or -1 if not possible Examples: >>> minimal_potions(5, 11, [1, 2, 3, 4, 5]) 3 >>> minimal_potions(3, 7, [4, 2, 2]) -1 # Your code here import unittest class TestMinimalPotions(unittest.TestCase): def test_minimal_potions_example1(self): self.assertEqual(minimal_potions(5, 11, [1, 2, 3, 4, 5]), 3) def test_minimal_potions_example2(self): self.assertEqual(minimal_potions(3, 7, [4, 2, 2]), -1) def test_minimal_potions_single_potion(self): self.assertEqual(minimal_potions(1, 1, [1]), 1) self.assertEqual(minimal_potions(1, 2, [1]), -1) def test_minimal_potions_multiple_combinations(self): self.assertEqual(minimal_potions(4, 7, [1, 3, 4, 5]), 2) self.assertEqual(minimal_potions(5, 8, [1, 3, 4, 6, 8]), 1) def test_minimal_potions_no_solution(self): self.assertEqual(minimal_potions(2, 6, [5, 7]), -1) def test_minimal_potions_large_target(self): self.assertEqual(minimal_potions(6, 100, [10, 20, 30, 40, 50, 60]), 2) def test_minimal_potions_target_zero(self): self.assertEqual(minimal_potions(5, 0, [1, 2, 3, 4, 5]), 0) # No potions needed to reach power level 0 if __name__ == '__main__': unittest.main()","solution":"def minimal_potions(n, target, potions): Given a list of potion power levels, find the minimum number of potions required to achieve a specified target power level. Return -1 if it's not possible. Args: n (int): number of potions target (int): target power level potions (list of int): list of potion power levels Returns: int: minimum number of potions or -1 if not possible # Initialize a large value as infinite inf = float('inf') # Create a dp array that holds the minimum number of potions required for each power level dp = [inf] * (target + 1) # No potions are needed to reach the power level of 0 dp[0] = 0 # Loop over each potion for power in potions: # Update the dp array in reverse to avoid using the same potion multiple times for t in range(target, power - 1, -1): dp[t] = min(dp[t], dp[t - power] + 1) # If dp[target] is inf, it means the target can't be reached return dp[target] if dp[target] != inf else -1"},{"question":"def find_pairs(arr, target_sum): Find all unique pairs in the array that add up to target_sum. Parameters: arr (list of int): The list of integers. target_sum (int): The target sum. Returns: list of list of int: A list of unique pairs that add up to target_sum. >>> find_pairs([1, 2, 3, 4, 5], 5) [[1, 4], [2, 3]] >>> find_pairs([1, 2, 3], 10) [] >>> find_pairs([1, 3], 4) [[1, 3]] >>> find_pairs([1, 1, 2, 2, 3, 3], 4) [[1, 3], [2, 2]] >>> find_pairs([1, 3, 2, 2, 1], 4) [[1, 3], [2, 2]] >>> find_pairs([-2, -1, 0, 1, 2, 3], 1) [[-2, 3], [-1, 2], [0, 1]] >>> find_pairs([0, 0, 1, -1], 0) [[-1, 1], [0, 0]]","solution":"def find_pairs(arr, target_sum): Find all unique pairs in the array that add up to target_sum. Parameters: arr (list of int): The list of integers. target_sum (int): The target sum. Returns: list of list of int: A list of unique pairs that add up to target_sum. arr.sort() pairs = set() seen = set() for num in arr: complement = target_sum - num if complement in seen: pair = (min(num, complement), max(num, complement)) pairs.add(pair) seen.add(num) result = [list(pair) for pair in sorted(pairs)] return result"},{"question":"def generate_words(word_stem: str, suffixes: List[str]) -> List[str]: Generates all possible words by appending each suffix from a given list to a given word stem. >>> generate_words(\\"run\\", [\\"ning\\", \\"ner\\", \\"s\\", \\"ningly\\"]) ['running', 'runner', 'runs', 'runningly'] >>> generate_words(\\"play\\", [\\"ing\\", \\"ed\\"]) ['playing', 'played'] >>> pass","solution":"def generate_words(word_stem, suffixes): Generates all possible words by appending each suffix from a given list to a given word stem. Parameters: word_stem (str): The word stem to which suffixes are to be appended. suffixes (list): List of suffixes to be appended to the word stem. Returns: list: A list of generated words by appending each suffix to the word stem. return [word_stem + suffix for suffix in suffixes]"},{"question":"def trailing_zeros(n: int) -> int: Returns the number of trailing zeros in the factorial of a non-negative integer n. >>> trailing_zeros(5) 1 >>> trailing_zeros(10) 2 >>> trailing_zeros(25) 6","solution":"def trailing_zeros(n: int) -> int: Returns the number of trailing zeros in the factorial of a non-negative integer n. count = 0 power_of_5 = 5 while n >= power_of_5: count += n // power_of_5 power_of_5 *= 5 return count"},{"question":"def fibonacci_sum(n: int) -> int: Returns the sum of the first n numbers in the Fibonacci sequence. >>> fibonacci_sum(1) 0 >>> fibonacci_sum(2) 1 >>> fibonacci_sum(3) 2 >>> fibonacci_sum(4) 4 >>> fibonacci_sum(5) 7 >>> fibonacci_sum(10) 88","solution":"def fibonacci_sum(n): Returns the sum of the first n numbers in the Fibonacci sequence. if n == 1: return 0 fib = [0, 1] # The first two Fibonacci numbers sum_fib = 1 for i in range(2, n): fib_next = fib[i-1] + fib[i-2] fib.append(fib_next) sum_fib += fib_next return sum_fib"},{"question":"def max_magical_value(grid: List[List[int]]) -> int: Determine the maximum sum of magical values Frodo can collect from the top-left to the bottom-right of the grid. >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> max_magical_value(grid) 29 >>> grid = [ ... [-1, -2], ... [-3, -4] ... ] >>> max_magical_value(grid) -7","solution":"def max_magical_value(grid): n = len(grid) m = len(grid[0]) dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] # Initialize the first row and first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1]"},{"question":"def find_prime_product_modulo(L, R, arr, primes_set, P): Find the product of all prime numbers in the subarray A[L...R] modulo P. Parameters: L (int): The starting index of the subarray (1-based indexing). R (int): The ending index of the subarray (1-based indexing). arr (List[int]): The array of integers. primes_set (set): A set containing the prime numbers in the array. P (int): A prime number used for modulo operation. Returns: int: The product of the primes in the subarray modulo P. >>> find_prime_product_modulo(2, 5, [2, 3, 6, 7, 5, 4], {2, 3, 7, 5}, 2000003) 105 >>> find_prime_product_modulo(1, 3, [2, 3, 6, 7, 5, 4], {2, 3, 7, 5}, 2000003) 6 >>> find_prime_product_modulo(3, 6, [2, 3, 6, 7, 5, 4], {2, 3, 7, 5}, 2000003) 35 # To be implemented pass def find_primes_in_array(arr): Preprocess the array to find all the prime elements. Parameters: arr (List[int]): The array of integers. Returns: set: A set containing the prime numbers found in the array. >>> find_primes_in_array([2, 3, 6, 7, 5, 4]) {2, 3, 7, 5} >>> find_primes_in_array([1, 4, 6, 8, 10]) set() # To be implemented pass def is_prime(n): Check if a number is prime. Parameters: n (int): The number to check. Returns: bool: True if the number is prime, False otherwise. >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(17) True # To be implemented pass # Example usage if __name__ == \\"__main__\\": P = 2000003 N = 6 arr = [2, 3, 6, 7, 5, 4] Q = 3 queries = [(2, 5), (1, 3), (3, 6)] primes_set = find_primes_in_array(arr) results = [] for L, R in queries: results.append(find_prime_product_modulo(L, R, arr, primes_set, P)) for result in results: print(result)","solution":"import math def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def find_prime_product_modulo(L, R, arr, primes_set, P): product = 1 for i in range(L-1, R): if arr[i] in primes_set: product = (product * arr[i]) % P return product # Preprocessing function to determine prime elements in array def find_primes_in_array(arr): primes_set = set() for num in arr: if is_prime(num): primes_set.add(num) return primes_set # Example usage P = 2000003 N = 6 arr = [2, 3, 6, 7, 5, 4] Q = 3 queries = [(2, 5), (1, 3), (3, 6)] primes_set = find_primes_in_array(arr) results = [] for L, R in queries: results.append(find_prime_product_modulo(L, R, arr, primes_set, P)) for result in results: print(result)"},{"question":"def transform_string(s: str) -> str: Transforms all '?' characters in the input string into lowercase letters such that the final string does not contain any consecutive repeating characters. Args: s (str): Input string containing lowercase English letters and '?' characters. Returns: str: Transformed string with no consecutive repeating characters. Example: >>> transform_string(\\"ab?ac?\\") \\"abcaca\\" >>> transform_string(\\"?zs\\") \\"azs\\" from solution import transform_string def test_example_1(): assert transform_string(\\"ab?ac?\\") == \\"abcaca\\" def test_example_2(): assert transform_string(\\"?zs\\") == \\"azs\\" def test_no_question_marks(): assert transform_string(\\"abcdef\\") == \\"abcdef\\" def test_all_question_marks(): result = transform_string(\\"????\\") assert result.count('?') == 0 assert all(result[i] != result[i+1] for i in range(len(result)-1)) def test_question_marks_at_the_beginning(): result = transform_string(\\"??abc\\") assert result.count('?') == 0 assert all(result[i] != result[i+1] for i in range(len(result)-1)) def test_question_marks_at_the_end(): result = transform_string(\\"abc??\\") assert result.count('?') == 0 assert all(result[i] != result[i+1] for i in range(len(result)-1)) def test_question_marks_in_the_middle(): result = transform_string(\\"a??b\\") assert result.count('?') == 0 assert all(result[i] != result[i+1] for i in range(len(result)-1)) def test_single_character(): assert transform_string(\\"?\\") in \\"abc\\"","solution":"def transform_string(s): Transforms all '?' characters in the input string into lowercase letters such that the final string does not contain any consecutive repeating characters. Args: s (str): Input string containing lowercase English letters and '?' characters. Returns: str: Transformed string with no consecutive repeating characters. s = list(s) for i in range(len(s)): if s[i] == '?': for letter in 'abc': # Ensure that the chosen letter is not the same as the adjacent letters if (i > 0 and s[i-1] == letter) or (i < len(s)-1 and s[i+1] == letter): continue s[i] = letter break return ''.join(s)"},{"question":"def is_prime(num): Helper function to check if a number is prime. pass def smallest_prime_greater_equal(N): Finds the smallest prime number P that is greater than or equal to N. >>> smallest_prime_greater_equal(10) 11 >>> smallest_prime_greater_equal(14) 17 >>> smallest_prime_greater_equal(20) 23 pass","solution":"def is_prime(num): Helper function to check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def smallest_prime_greater_equal(N): Finds the smallest prime number P that is greater than or equal to N. candidate = N while not is_prime(candidate): candidate += 1 return candidate"},{"question":"def two_sum_exists(arr: list, target: int) -> str: Determines if there are two distinct elements in the array whose sum is equal to the target integer. >>> two_sum_exists([2, 7, 11, 15, -1], 9) \\"YES\\" >>> two_sum_exists([1, 2, 3, 4], 10) \\"NO\\"","solution":"def two_sum_exists(arr, target): Determines if there are two distinct elements in the array whose sum is equal to the target integer. :param arr: List of integers :param target: Integer target sum :return: \\"YES\\" if such a pair exists, \\"NO\\" otherwise seen = set() for num in arr: if target - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\" # Wrapper to read input and output result if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) target = int(data[1]) arr = list(map(int, data[2:])) print(two_sum_exists(arr, target))"},{"question":"def transform_string_to_sequence(s: str) -> str: Transforms a given string s into a sequence of integers where each unique character in the string is assigned a unique integer starting from 1 and increasing by 1 for each new character that appears in the order of their first occurrence. >>> transform_string_to_sequence('abacabad') == '1 2 1 3 1 2 1 4' >>> transform_string_to_sequence('xyzxyz') == '1 2 3 1 2 3' >>> transform_string_to_sequence('a') == '1' from solution import transform_string_to_sequence def test_example_1(): assert transform_string_to_sequence('abacabad') == '1 2 1 3 1 2 1 4' def test_example_2(): assert transform_string_to_sequence('xyzxyz') == '1 2 3 1 2 3' def test_example_3(): assert transform_string_to_sequence('a') == '1' def test_all_unique_characters(): assert transform_string_to_sequence('abcdefg') == '1 2 3 4 5 6 7' def test_repeated_characters(): assert transform_string_to_sequence('aaabbbccc') == '1 1 1 2 2 2 3 3 3' def test_mixed_characters(): assert transform_string_to_sequence('abccba') == '1 2 3 3 2 1' def test_long_string(): s = 'a' * 1000 assert transform_string_to_sequence(s) == ' '.join(['1'] * 1000)","solution":"def transform_string_to_sequence(s): Transforms a given string s into a sequence of integers where each unique character in the string is assigned a unique integer starting from 1 and increasing by 1 for each new character that appears in the order of their first occurrence. char_to_int = {} current_int = 1 result = [] for char in s: if char not in char_to_int: char_to_int[char] = current_int current_int += 1 result.append(str(char_to_int[char])) return \\" \\".join(result)"},{"question":"def longest_special_sequence(arr): Returns the length of the longest special sequence where every element is at least twice the value of the previous element. >>> longest_special_sequence([1, 3, 2, 6, 10, 8]) 3 >>> longest_special_sequence([5, 5, 5, 5]) 1 >>> longest_special_sequence([10, 9, 8, 7]) 1 >>> longest_special_sequence([42]) 1 >>> longest_special_sequence([1, 2, 4, 8, 16, 32, 1, 2, 4, 8, 16]) 6 >>> longest_special_sequence([10, 1, 20, 2, 40, 3, 50, 4, 100]) 4","solution":"def longest_special_sequence(arr): Returns the length of the longest special sequence where every element is at least twice the value of the previous element. if not arr: return 0 n = len(arr) dp = [1] * n for i in range(n): for j in range(i): if arr[i] >= 2 * arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def validate_routes(t, test_cases): Validates the feasibility of tour routes using given direct flights. Args: t: int - number of test cases. test_cases: List - a list where each element represents a test case containing: - an integer n: number of direct flights, - n tuples of strings: representing direct flights from city ci to city cj, - an integer k: number of cities in the tour route, - a list of k strings: representing the ordered sequence of cities in the tour route. Returns: List of \\"Possible\\" or \\"Impossible\\" for each test case. Example: >>> t = 2 >>> test_cases = [ ... [5, (\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"C\\", \\"D\\"), (\\"D\\", \\"E\\"), (\\"E\\", \\"F\\"), 4, [\\"A\\", \\"B\\", \\"C\\", \\"D\\"]], ... [3, (\\"X\\", \\"Y\\"), (\\"Y\\", \\"Z\\"), (\\"X\\", \\"Z\\"), 4, [\\"X\\", \\"Y\\", \\"Z\\", \\"W\\"]] ... ] >>> validate_routes(t, test_cases) ['Possible', 'Impossible'] pass def test_validate_routes(): t = 2 test_cases = [ [5, (\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"C\\", \\"D\\"), (\\"D\\", \\"E\\"), (\\"E\\", \\"F\\"), 4, [\\"A\\", \\"B\\", \\"C\\", \\"D\\"]], [3, (\\"X\\", \\"Y\\"), (\\"Y\\", \\"Z\\"), (\\"X\\", \\"Z\\"), 4, [\\"X\\", \\"Y\\", \\"Z\\", \\"W\\"]] ] expected = [\\"Possible\\", \\"Impossible\\"] result = validate_routes(t, test_cases) assert result == expected def test_validate_routes_single_flight(): t = 1 test_cases = [ [1, (\\"A\\", \\"B\\"), 2, [\\"A\\", \\"B\\"]] ] expected = [\\"Possible\\"] result = validate_routes(t, test_cases) assert result == expected def test_validate_routes_no_flight(): t = 1 test_cases = [ [0, 1, [\\"A\\"]] ] expected = [\\"Possible\\"] result = validate_routes(t, test_cases) assert result == expected def test_validate_routes_missing_connection(): t = 1 test_cases = [ [2, (\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), 3, [\\"A\\", \\"C\\", \\"B\\"]] ] expected = [\\"Impossible\\"] result = validate_routes(t, test_cases) assert result == expected def test_validate_routes_disconnected(): t = 1 test_cases = [ [2, (\\"A\\", \\"B\\"), (\\"C\\", \\"D\\"), 3, [\\"A\\", \\"B\\", \\"D\\"]] ] expected = [\\"Impossible\\"] result = validate_routes(t, test_cases) assert result == expected","solution":"def validate_routes(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] direct_flights = {} for j in range(1, n + 1): ci, cj = test_cases[i][j] if ci in direct_flights: direct_flights[ci].add(cj) else: direct_flights[ci] = {cj} k = test_cases[i][n + 1] route = test_cases[i][n + 2] possible = True for j in range(k - 1): if route[j] not in direct_flights or route[j + 1] not in direct_flights[route[j]]: possible = False break results.append(\\"Possible\\" if possible else \\"Impossible\\") return results"},{"question":"from typing import List, Tuple, Dict def max_beauty_score(T: int, test_cases: List[Dict[str, any]]) -> List[int]: Compute the maximum total beauty score for the given test cases while staying within the budget. Args: T (int): Number of test cases. test_cases (List[Dict[str, any]]): Each test case is a dictionary with: - 'N': (int) Number of paintings. - 'B': (int) Budget. - 'paintings': List of tuples (beauty, price). Returns: List[int]: A list of integers representing the maximum beauty score for each test case. Example: >>> max_beauty_score(1, [{'N': 3, 'B': 50, 'paintings': [(60, 20), (100, 50), (120, 30)]}]) [180] >>> max_beauty_score(1, [{'N': 3, 'B': 50, 'paintings': [(60, 20), (100, 10), (120, 30)]}]) [220] def knapsack(N, B, paintings): # Implement the knapsack algorithm to solve the problem pass def parse_input(input_str: str) -> Tuple[int, List[Dict[str, any]]]: Parse the input string into the number of test cases and their respective details. Args: input_str (str): Multi-line string where the first line contains the number of test cases, followed by lines containing details for each test case. Returns: Tuple[int, List[Dict[str, any]]]: Number of test cases and list of dictionaries containing: - 'N': (int) Number of paintings. - 'B': (int) Budget. - 'paintings': List of tuples (beauty, price). Example: >>> parse_input(\\"1n3 50n60 20n100 50n120 30\\") (1, [{'N': 3, 'B': 50, 'paintings': [(60, 20), (100, 50), (120, 30)]}]) pass def main(input_str: str) -> List[int]: Main function to parse input and calculate the maximum beauty score for each test case. Args: input_str (str): Input string containing test cases and their respective details. Returns: List[int]: A list of integers representing the maximum beauty score for each test case. Example: >>> input_test_str = \\"2n3 50n60 20n100 50n120 30n3 50n60 20n100 10n120 30\\" >>> main(input_test_str) [180, 220] T, test_cases = parse_input(input_str) return max_beauty_score(T, test_cases)","solution":"def max_beauty_score(T, test_cases): def knapsack(N, B, paintings): dp = [0] * (B + 1) for beauty, price in paintings: for j in range(B, price - 1, -1): dp[j] = max(dp[j], dp[j - price] + beauty) return dp[B] results = [] for case in test_cases: N, B, paintings = case['N'], case['B'], case['paintings'] result = knapsack(N, B, paintings) results.append(result) return results def parse_input(input_str): input_lines = input_str.strip().split(\\"n\\") T = int(input_lines[0]) test_cases = [] line_idx = 1 for _ in range(T): N, B = map(int, input_lines[line_idx].split()) paintings = [] line_idx += 1 for _ in range(N): beauty, price = map(int, input_lines[line_idx].split()) paintings.append((beauty, price)) line_idx += 1 test_cases.append({\\"N\\": N, \\"B\\": B, \\"paintings\\": paintings}) return T, test_cases def main(input_str): T, test_cases = parse_input(input_str) return max_beauty_score(T, test_cases) input_test_str = \\"2n3 50n60 20n100 50n120 30n3 50n60 20n100 10n120 30\\" output = main(input_test_str) print(output) # should print [180, 220]"},{"question":"def maxProduct(n: int) -> int: Returns the integer k such that k*(n-k) is maximized. >>> maxProduct(10) 5 >>> maxProduct(20) 10 >>> maxProduct(1) 0","solution":"def maxProduct(n): Returns the integer k such that k*(n-k) is maximized. return n // 2"},{"question":"def max_group_size(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Given a number of test cases, for each test case find the maximum number of people that can be grouped together such that the difference in height does not exceed K. :param T: int, number of test cases :param test_cases: list of tuples, each containing (N, K, heights) where N is the number of people, K is the maximum allowed height difference, heights is a list of integers representing the heights of the people :return: list of integers representing the result for each test case >>> max_group_size(2, [(5, 3, [1, 2, 5, 7, 8]), (4, 0, [4, 4, 4, 4])]) [3, 4] >>> max_group_size(1, [(6, 10, [1, 2, 3, 4, 5, 6])]) [6] >>> max_group_size(1, [(6, 0, [1, 3, 3, 5, 5, 6])]) [2] >>> max_group_size(1, [(6, 2, [1, 2, 4, 5, 7, 8])]) [2] >>> max_group_size(1, [(1, 5, [10])]) [1]","solution":"def max_group_size(T, test_cases): Given a number of test cases, for each test case find the maximum number of people that can be grouped together such that the difference in height does not exceed K. :param T: int, number of test cases :param test_cases: list of tuples, each containing (N, K, heights) where N is the number of people, K is the maximum allowed height difference, heights is a list of integers representing the heights of the people :return: list of integers representing the result for each test case results = [] for N, K, heights in test_cases: heights.sort() # Sort the heights to facilitate sliding window max_group = 1 left = 0 for right in range(1, N): while heights[right] - heights[left] > K: left += 1 max_group = max(max_group, right - left + 1) results.append(max_group) return results"},{"question":"def can_form_contiguous_rotated_sequence(N, array): Determines if the array can be a contiguous subarray of some rotation of the sequence from 1 to N. >>> can_form_contiguous_rotated_sequence(3, [3, 1, 2]) 'YES' >>> can_form_contiguous_rotated_sequence(4, [2, 3, 4, 1]) 'YES' >>> can_form_contiguous_rotated_sequence(4, [4, 3, 2, 1]) 'NO' def solve_test_cases(T, test_cases): Processes T test cases and returns the results. >>> solve_test_cases(3, [(3, [3, 1, 2]), (4, [2, 3, 4, 1]), (4, [4, 3, 2, 1])]) ['YES', 'YES', 'NO'] def process_input(input_string): Processes the input string for multiple test cases and returns the results as a formatted string. >>> process_input(\\"3n3n3 1 2n4n2 3 4 1n4n4 3 2 1n\\") 'YESnYESnNO'","solution":"def can_form_contiguous_rotated_sequence(N, array): Determines if the array can be a contiguous subarray of some rotation of the sequence from 1 to N. # Create the target sequence [1, 2, ..., N] target = list(range(1, N + 1)) # Double the target sequence to handle the rotation target_doubled = target + target # Check if array is a subarray of target_doubled for i in range(N): if target_doubled[i:i + N] == array: return \\"YES\\" return \\"NO\\" def solve_test_cases(T, test_cases): Processes T test cases and returns the results. results = [] for i in range(T): N, array = test_cases[i] result = can_form_contiguous_rotated_sequence(N, array) results.append(result) return results # Sample usage within a function: def process_input(input_string): lines = input_string.strip().split('n') T = int(lines[0]) test_cases = [] current_line = 1 for _ in range(T): N = int(lines[current_line]) array = list(map(int, lines[current_line + 1].split())) test_cases.append((N, array)) current_line += 2 results = solve_test_cases(T, test_cases) return 'n'.join(results)"},{"question":"from typing import List, Tuple def shortest_path_min_value(n: int, m: int, node_values: List[int], edges: List[Tuple[int, int, int]]) -> int: Find the shortest path from the first node to the last node and return the minimum value along this path (considering the node values). Args: n: int - number of nodes m: int - number of edges node_values: List[int] - list of node values edges: List[Tuple[int, int, int]] - list of edges where each edge is represented by a tuple (a, b, w) where a and b are the nodes and w is the weight Returns: - int - the minimum value among the node values on the shortest path from node 1 to node n. If there is no path, return -1. >>> shortest_path_min_value(5, 6, [10, 1, 4, 3, 5], [(1, 2, 2), (1, 3, 3), (2, 3, 1), (2, 4, 1), (3, 4, 1), (4, 5, 2)]) 1 >>> shortest_path_min_value(3, 3, [9, 2, 8], [(1, 2, 1), (2, 3, 1), (1, 3, 2)]) 2 >>> shortest_path_min_value(4, 2, [5, 10, 3, 7], [(1, 2, 1), (2, 3, 2)]) -1 >>> shortest_path_min_value(3, 2, [7, 6, 5], [(1, 2, 1), (2, 3, 1)]) 5 >>> shortest_path_min_value(2, 1, [2, 1], [(1, 2, 1)]) 1","solution":"import heapq from collections import defaultdict, deque import sys def shortest_path_min_value(n, m, node_values, edges): graph = defaultdict(list) for a, b, w in edges: graph[a].append((w, b)) graph[b].append((w, a)) pq = [(0, 1, node_values[0])] # (current_cost, current_node, min_value_on_path) visited = set() min_vals = {i + 1: float('inf') for i in range(n)} min_vals[1] = node_values[0] while pq: current_cost, current_node, min_value_on_path = heapq.heappop(pq) if current_node == n: return min_value_on_path if current_node in visited: continue visited.add(current_node) for edge_cost, neighbor in graph[current_node]: if neighbor not in visited: new_cost = current_cost + edge_cost new_min_value_on_path = min(min_value_on_path, node_values[neighbor - 1]) if new_min_value_on_path < min_vals[neighbor]: min_vals[neighbor] = new_min_value_on_path heapq.heappush(pq, (new_cost, neighbor, new_min_value_on_path)) return -1 # Example Usage n = 5 m = 6 node_values = [10, 1, 4, 3, 5] edges = [(1, 2, 2), (1, 3, 3), (2, 3, 1), (2, 4, 1), (3, 4, 1), (4, 5, 2)] print(shortest_path_min_value(n, m, node_values, edges)) # Output: 1"},{"question":"class Warehouse: def __init__(self, n, m, initial_grid): self.n = n self.m = m self.grid = initial_grid def add_items(self, r, c, x): self.grid[r-1][c-1] += x def remove_items(self, r, c, x): self.grid[r-1][c-1] = max(0, self.grid[r-1][c-1] - x) def move_items(self, r1, c1, r2, c2, x): movable_items = min(x, self.grid[r1-1][c1-1]) self.grid[r1-1][c1-1] -= movable_items self.grid[r2-1][c2-1] += movable_items def query_items(self, r, c): return self.grid[r-1][c-1] def process_warehouse_operations(n: int, m: int, initial_grid: List[List[int]], operations: List[List[Union[str, int]]]) -> List[int]: Simulate a warehouse inventory system. Parameters: n (int): number of rows in the warehouse. m (int): number of columns in the warehouse. initial_grid (List[List[int]]): initial state of the warehouse bins. operations (List[List[Union[str, int]]]): list of operations to perform on the warehouse. Returns: List[int]: results of all the QUERY operations. >>> n = 3 >>> m = 4 >>> initial_grid = [ ... [5, 3, 2, 4], ... [1, 6, 4, 7], ... [0, 0, 0, 2] ... ] >>> operations = [ ... [\\"ADD\\", 1, 1, 3], ... [\\"REMOVE\\", 2, 3, 1], ... [\\"QUERY\\", 2, 3], ... [\\"MOVE\\", 1, 1, 3, 4, 2], ... [\\"QUERY\\", 3, 4] ... ] >>> process_warehouse_operations(n, m, initial_grid, operations) [3, 4]","solution":"class Warehouse: def __init__(self, n, m, initial_grid): self.n = n self.m = m self.grid = initial_grid def add_items(self, r, c, x): self.grid[r-1][c-1] += x def remove_items(self, r, c, x): self.grid[r-1][c-1] = max(0, self.grid[r-1][c-1] - x) def move_items(self, r1, c1, r2, c2, x): movable_items = min(x, self.grid[r1-1][c1-1]) self.grid[r1-1][c1-1] -= movable_items self.grid[r2-1][c2-1] += movable_items def query_items(self, r, c): return self.grid[r-1][c-1] def process_warehouse_operations(n, m, initial_grid, operations): warehouse = Warehouse(n, m, initial_grid) results = [] for operation in operations: command = operation[0] if command == \\"ADD\\": _, r, c, x = operation warehouse.add_items(r, c, x) elif command == \\"REMOVE\\": _, r, c, x = operation warehouse.remove_items(r, c, x) elif command == \\"MOVE\\": _, r1, c1, r2, c2, x = operation warehouse.move_items(r1, c1, r2, c2, x) elif command == \\"QUERY\\": _, r, c = operation results.append(warehouse.query_items(r, c)) return results"},{"question":"def count_books(section: str, num_blocks: int, blocks: List[int]) -> List[int]: Returns the count of books in each given triangular block size. :param section: Character representing the section :param num_blocks: Integer number of blocks :param blocks: List of integers representing the size of each triangular block :return: List of integers representing the count of books for each block >>> count_books('A', 3, [3, 6, 10]) [3, 6, 10] >>> count_books('B', 2, [5, 15]) [5, 15]","solution":"def count_books(section, num_blocks, blocks): Returns the count of books in each given triangular block size. :param section: Character representing the section (not used in this function but required by problem specifications) :param num_blocks: Integer number of blocks :param blocks: List of integers representing the size of each triangular block :return: List of integers representing the count of books for each block return blocks"},{"question":"def maxProfit(prices: List[int]) -> int: Determine the maximum profit by buying and selling the stock at most twice. >>> maxProfit([3, 3, 5, 0, 0, 3, 1, 4]) 6 >>> maxProfit([1, 2, 3, 4, 5]) 4 >>> maxProfit([7, 6, 4, 3, 1]) 0 >>> maxProfit([5]) 0 >>> maxProfit([1, 5]) 4 >>> maxProfit([5, 1]) 0 >>> maxProfit([5, 4, 3, 2, 1]) 0 >>> maxProfit([]) 0 >>> maxProfit([3, 3, 3, 3, 3, 3]) 0","solution":"def maxProfit(prices): if not prices: return 0 n = len(prices) left_profit = [0] * n right_profit = [0] * n # Calculate left cumulative profit min_price = prices[0] for i in range(1, n): left_profit[i] = max(left_profit[i - 1], prices[i] - min_price) min_price = min(min_price, prices[i]) # Calculate right cumulative profit max_price = prices[-1] for i in range(n - 2, -1, -1): right_profit[i] = max(right_profit[i + 1], max_price - prices[i]) max_price = max(max_price, prices[i]) # Calculate maximum profit max_profit = 0 for i in range(n): max_profit = max(max_profit, left_profit[i] + right_profit[i]) return max_profit"},{"question":"def decode_special_binary(T: int, test_cases: List[str]) -> List[int]: Decodes numbers from special binary format to decimal :param T: int, number of test cases :param test_cases: list of str, each string representing a special binary number :return: list of int, decoded decimal values >>> decode_special_binary(4, ['101', '10', '001', '111']) [5, 1, 4, 7] >>> decode_special_binary(2, ['0000', '0001']) [0, 8]","solution":"def decode_special_binary(T, test_cases): Decodes numbers from special binary format to decimal :param T: int, number of test cases :param test_cases: list of str, each string representing a special binary number :return: list of int, decoded decimal values results = [] for case in test_cases: reversed_case = case[::-1] decimal_value = int(reversed_case, 2) results.append(decimal_value) return results"},{"question":"def longest_common_substring(S1: str, S2: str) -> int: Determine the length of the longest substring that appears in both S1 and S2. >>> longest_common_substring(\\"abcdef\\", \\"zcdemn\\") == 3 >>> longest_common_substring(\\"abc\\", \\"def\\") == 0 >>> longest_common_substring(\\"abcde\\", \\"abcde\\") == 5 >>> longest_common_substring(\\"abcdxyz\\", \\"xyzabcd\\") == 4 >>> longest_common_substring(\\"a\\", \\"a\\") == 1 >>> longest_common_substring(\\"a\\", \\"b\\") == 0 >>> longest_common_substring(\\"a\\" * 1000, \\"a\\" * 1000) == 1000 >>> longest_common_substring(\\"abababab\\", \\"babababa\\") == 7","solution":"def longest_common_substring(S1, S2): Returns the length of the longest substring that appears in both S1 and S2. len1, len2 = len(S1), len(S2) dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] max_length = 0 for i in range(1, len1 + 1): for j in range(1, len2 + 1): if S1[i - 1] == S2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 max_length = max(max_length, dp[i][j]) return max_length"},{"question":"def can_partition(nums: List[int]) -> bool: Determines if the list can be partitioned into two sublists with equal sum. >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False","solution":"def can_partition(nums): Determines if the list can be partitioned into two sublists with equal sum. total_sum = sum(nums) # If the total sum is odd, it cannot be partitioned into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 dp = [False] * (target + 1) dp[0] = True # zero is always achievable for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]"},{"question":"def reverse_words(sentence: str) -> str: Create a function that takes a string consisting of words separated by spaces and returns a new string with the words in reverse order. The words themselves should not be reversed, only the order of the words. >>> reverse_words(\\"Coding is fun\\") 'fun is Coding' >>> reverse_words(\\"Hello World\\") 'World Hello'","solution":"def reverse_words(sentence): Returns a new string with the words in reverse order. :param sentence: A string consisting of words separated by spaces. :return: A new string with the words in reverse order. return ' '.join(sentence.split()[::-1])"},{"question":"def max_bacteria_growth(S: int, D: int) -> int: Determine the maximum possible number of bacteria in the colony after D days if the nutrients are used optimally. :param S: Initial number of bacteria :param D: Number of days :return: Maximum number of bacteria >>> max_bacteria_growth(2, 3) 54 >>> max_bacteria_growth(1, 1) 3 >>> max_bacteria_growth(100, 1) 300 >>> max_bacteria_growth(1, 30) 205891132094649 >>> max_bacteria_growth(10, 10) 590490","solution":"def max_bacteria_growth(S, D): Returns the maximum number of bacteria possible after D days starting with S bacteria. :param S: Initial number of bacteria :param D: Number of days :return: Maximum number of bacteria # Triple the bacteria for each day, which is the optimal strategy return S * (3 ** D)"},{"question":"def optimized_quicksort(arr): Sort an input list of integers using the optimized Quicksort algorithm with the median-of-three pivot strategy. The Quicksort algorithm is a widely used sorting algorithm due to its average-case time complexity of O(n log n) and its relatively simple implementation. However, sometimes it can perform poorly if the pivot selection strategy is not carefully chosen, leading to the worst-case time complexity of O(n^2). The \\"median-of-three\\" strategy chooses the pivot as the median value among the first, middle, and last elements of the array. This improves the chances of selecting a good pivot and reduces the likelihood of encountering the worst-case scenario. Args: arr (List[int]): A list of integers to be sorted. Example: >>> arr = [3, 1, 2, 5, 4] >>> optimized_quicksort(arr) >>> arr [1, 2, 3, 4, 5] >>> arr = [10, -1, 3, 2] >>> optimized_quicksort(arr) >>> arr [-1, 2, 3, 10] pass def process_input(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) idx = 1 results = [] for _ in range(T): n = int(data[idx]) idx += 1 arr = list(map(int, data[idx:idx + n])) idx += n optimized_quicksort(arr) results.append(\\" \\".join(map(str, arr))) for result in results: print(result) if __name__ == \\"__main__\\": process_input()","solution":"def median_of_three(arr, low, mid, high): Returns the index of the median value among arr[low], arr[mid], and arr[high]. if (arr[low] - arr[mid]) * (arr[high] - arr[low]) >= 0: return low elif (arr[mid] - arr[low]) * (arr[high] - arr[mid]) >= 0: return mid else: return high def partition(arr, low, high): mid = (low + high) // 2 pivot_index = median_of_three(arr, low, mid, high) pivot_value = arr[pivot_index] # Move pivot to the end for simplicity arr[pivot_index], arr[high] = arr[high], arr[pivot_index] store_index = low for i in range(low, high): if arr[i] < pivot_value: arr[i], arr[store_index] = arr[store_index], arr[i] store_index += 1 # Move pivot to its final place arr[store_index], arr[high] = arr[high], arr[store_index] return store_index def quicksort(arr, low, high): if low < high: pivot_index = partition(arr, low, high) quicksort(arr, low, pivot_index - 1) quicksort(arr, pivot_index + 1, high) def optimized_quicksort(arr): if len(arr) > 1: quicksort(arr, 0, len(arr) - 1)"},{"question":"def weekly_reading_summary(test_cases: List[List[int]]) -> List[str]: Generate weekly reading summaries based on user input. >>> weekly_reading_summary([[10, 20, 30, 40, 50, 60, 70]]) == [\\"Total: 280, Average: 40, Max Day: Sunday\\"] >>> weekly_reading_summary([[100, 200, 100, 300, 100, 200, 100]]) == [\\"Total: 1100, Average: 157, Max Day: Thursday\\"]","solution":"def weekly_reading_summary(test_cases): week_days = [\\"Monday\\", \\"Tuesday\\", \\"Wednesday\\", \\"Thursday\\", \\"Friday\\", \\"Saturday\\", \\"Sunday\\"] results = [] for pages in test_cases: total_pages = sum(pages) ave_pages = round(total_pages / 7) max_pages_day = week_days[pages.index(max(pages))] result = f\\"Total: {total_pages}, Average: {ave_pages}, Max Day: {max_pages_day}\\" results.append(result) return results"},{"question":"def min_adjacent_swaps(n, book_order): Returns the minimum number of adjacent swaps required to sort the bookshelf. :param n: int, number of books on the shelf :param book_order: list of int, current order of the books on the shelf :return: int, minimum number of adjacent swaps required to sort the bookshelf >>> min_adjacent_swaps(5, [3, 4, 2, 5, 1]) 6 >>> min_adjacent_swaps(1, [1]) 0 >>> min_adjacent_swaps(5, [1, 2, 3, 4, 5]) 0 >>> min_adjacent_swaps(5, [5, 4, 3, 2, 1]) 10 >>> min_adjacent_swaps(4, [4, 3, 2, 1]) 6 >>> min_adjacent_swaps(5, [2, 3, 4, 5, 1]) 4 >>> min_adjacent_swaps(3, [2, 1, 3]) 1","solution":"def min_adjacent_swaps(n, book_order): Returns the minimum number of adjacent swaps required to sort the bookshelf. :param n: int, number of books on the shelf :param book_order: list of int, current order of the books on the shelf :return: int, minimum number of adjacent swaps required to sort the bookshelf # Bubble sort algorithm to count the number of swaps swaps = 0 books = book_order[:] for i in range(n): for j in range(n - 1): if books[j] > books[j + 1]: books[j], books[j + 1] = books[j + 1], books[j] swaps += 1 return swaps"},{"question":"def lexicographically_smallest_string(s: str) -> str: Returns the lexicographically smallest string that can be obtained after any number of the given operations. >>> lexicographically_smallest_string(\\"abc\\") \\"c\\" >>> lexicographically_smallest_string(\\"zab\\") \\"z\\" >>> lexicographically_smallest_string(\\"aaabcc\\") \\"c\\"","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string that can be obtained after any number of the given operations. # Since we can replace any two adjacent characters by the maximum of the two, # the key to create the smallest lexicographical string is actually to compute # the maximum character in the string. return max(s)"},{"question":"def longest_arith_seq_length(A): Given a list of integers, calculate the length of the longest arithmetic subsequence. The longest arithmetic subsequence is the one where all elements of the subsequence are in increasing order and the difference between consecutive elements of the subsequence is the same. Parameters: A (List[int]): A list of integers. Returns: int: The length of the longest arithmetic subsequence. Examples: >>> longest_arith_seq_length([3, 6, 9, 12, 15, 21]) 5 >>> longest_arith_seq_length([1, 2, 3, 4, 5, 6]) 6 >>> longest_arith_seq_length([10, 20, 30, 50, 80, 130]) 3 >>> longest_arith_seq_length([3, 8, 1, 7, 0, 4, 6, 10]) 3 >>> longest_arith_seq_length([1, 1, 1, 1, 1]) 5 >>> longest_arith_seq_length([1, 7, 10, 15, 27, 29]) 3 >>> longest_arith_seq_length([1, 3, 7, 15, 31]) 2","solution":"def longest_arith_seq_length(A): Calculate the length of the longest arithmetic subsequence. if not A: return 0 n = len(A) if n <= 2: return n # To store the length of arithmetic progression ending at each index dp = [{} for _ in range(n)] max_len = 2 for i in range(n): for j in range(i): diff = A[i] - A[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 max_len = max(max_len, dp[i][diff]) return max_len"},{"question":"def min_moves_to_origin(cmds: str) -> int: Returns the minimum number of moves needed for the robot to return to the origin after processing the given sequence of commands. Parameters: cmds (str): The sequence of commands. Returns: int: The minimum number of moves needed to return to the origin. Examples: >>> min_moves_to_origin(\\"NNESWW\\") 2 >>> min_moves_to_origin(\\"NNEESSWW\\") 0","solution":"def min_moves_to_origin(cmds): Returns the minimum number of moves needed for the robot to return to the origin after processing the given sequence of commands. Parameters: cmds (str): The sequence of commands. Returns: int: The minimum number of moves needed to return to the origin. north_count = cmds.count('N') south_count = cmds.count('S') east_count = cmds.count('E') west_count = cmds.count('W') vertical_displacement = abs(north_count - south_count) horizontal_displacement = abs(east_count - west_count) return vertical_displacement + horizontal_displacement"},{"question":"def dominant_color(M: int, N: int, grid: List[List[Tuple[int, int, int]]]) -> Tuple[int, int, int]: Determines the dominant color in a given image represented by an MxN grid of color values. The dominant color is defined as the one that appears the most frequently in the grid. >>> M, N = 3, 3 >>> grid = [ ... [(255, 0, 0), (255, 0, 0), (0, 255, 0)], ... [(0, 0, 255), (0, 255, 0), (0, 255, 0)], ... [(0, 255, 0), (0, 0, 255), (0, 255, 0)] ... ] >>> dominant_color(M, N, grid) (0, 255, 0) >>> M, N = 2, 2 >>> grid = [ ... [(255, 0, 0), (255, 0, 0)], ... [(255, 0, 0), (255, 0, 0)] ... ] >>> dominant_color(M, N, grid) (255, 0, 0) pass","solution":"def dominant_color(M, N, grid): from collections import Counter color_count = Counter() for row in grid: for color in row: color_count[color] += 1 # Sort colors first by frequency (descending) and then by RGB components (ascending) sorted_colors = sorted(color_count.items(), key=lambda x: (-x[1], x[0])) # The dominant color is the first element's key (which is the RGB tuple) dominant_color = sorted_colors[0][0] return dominant_color # Example use case def parse_input(input_str): lines = input_str.strip().split('n') M, N = map(int, lines[0].split()) grid = [] for i in range(1, M + 1): row = list(map(int, lines[i].split())) grid.append([(row[j], row[j+1], row[j+2]) for j in range(0, len(row), 3)]) return M, N, grid def extract_output(output): return tuple(map(int, output.strip().split())) input_str = 3 3 255 0 0 255 0 0 0 255 0 0 0 255 0 255 0 0 255 0 0 255 0 0 0 255 0 255 0 M, N, grid = parse_input(input_str) output = dominant_color(M, N, grid) print(*output) # Output should be 0 255 0"},{"question":"def smallest_substring(A: str, B: str) -> str: Mia likes to create and solve puzzles with strings. She has two strings, A and B, where the length of A is greater than or equal to the length of B. She wants to find the smallest substring of A that contains all the characters in B (including duplicates). If there is no such substring, return an empty string. >>> smallest_substring(\\"adobecodebanc\\", \\"abc\\") 'banc' >>> smallest_substring(\\"a\\", \\"aa\\") '' >>> smallest_substring(\\"hello\\", \\"world\\") '' >>> smallest_substring(\\"a\\", \\"a\\") 'a' >>> smallest_substring(\\"a\\", \\"b\\") '' >>> smallest_substring(\\"zzz\\", \\"z\\") 'z' >>> smallest_substring(\\"abcdef\\", \\"abcdef\\") 'abcdef' >>> smallest_substring(\\"abcdef\\", \\"fedcba\\") 'abcdef' >>> smallest_substring(\\"a\\" * 100000 + \\"b\\", \\"ab\\") 'ab' >>> smallest_substring(\\"aaabbcc\\", \\"abc\\") 'abbc' >>> smallest_substring(\\"abbcac\\", \\"abc\\") 'bca'","solution":"def smallest_substring(A, B): Finds the smallest substring of A that contains all characters of B. from collections import Counter if not A or not B: return \\"\\" # Create count of characters in B count_B = Counter(B) required_chars = len(count_B) l, r = 0, 0 formed = 0 window_counts = {} min_substr = \\"\\" min_length = float('inf') # Try expanding the window to the right while r < len(A): char = A[r] window_counts[char] = window_counts.get(char, 0) + 1 if char in count_B and window_counts[char] == count_B[char]: formed += 1 # Try contracting the window from the left till the point where it ceases to be 'desirable' while l <= r and formed == required_chars: char = A[l] # Save the smallest window until now if r - l + 1 < min_length: min_length = r - l + 1 min_substr = A[l:r+1] window_counts[char] -= 1 if char in count_B and window_counts[char] < count_B[char]: formed -= 1 l += 1 r += 1 return min_substr"},{"question":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): Reverse the nodes of the list k at a time and return the modified list. # Function to reverse a linked list def reverseLinkedList(head, k): new_head, ptr = None, head while k: next_node = ptr.next ptr.next = new_head new_head = ptr ptr = next_node k -= 1 return new_head count = 0 ptr = head while count < k and ptr: ptr = ptr.next count += 1 if count == k: reversed_head = reverseLinkedList(head, k) head.next = reverseKGroup(ptr, k) return reversed_head return head def createLinkedList(arr): Create a linked list from an array of values and return the head node. dummy = Node(0) ptr = dummy for val in arr: ptr.next = Node(val) ptr = ptr.next return dummy.next def printLinkedList(head): Convert a linked list to an array representation and return the array. result = [] while head: result.append(head.val) head = head.next return result def reverse_nodes_in_k_group(n, k, nodes): Reverse the nodes of the list k at a time and return the modified list. >>> reverse_nodes_in_k_group(8, 3, [1, 2, 3, 4, 5, 6, 7, 8]) [3, 2, 1, 6, 5, 4, 7, 8] >>> reverse_nodes_in_k_group(5, 2, [1, 2, 3, 4, 5]) [2, 1, 4, 3, 5] head = createLinkedList(nodes) new_head = reverseKGroup(head, k) return printLinkedList(new_head)","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): def reverseLinkedList(head, k): new_head, ptr = None, head while k: next_node = ptr.next ptr.next = new_head new_head = ptr ptr = next_node k -= 1 return new_head count = 0 ptr = head while count < k and ptr: ptr = ptr.next count += 1 if count == k: reversed_head = reverseLinkedList(head, k) head.next = reverseKGroup(ptr, k) return reversed_head return head def createLinkedList(arr): dummy = Node(0) ptr = dummy for val in arr: ptr.next = Node(val) ptr = ptr.next return dummy.next def printLinkedList(head): result = [] while head: result.append(head.val) head = head.next return result def reverse_nodes_in_k_group(n, k, nodes): head = createLinkedList(nodes) new_head = reverseKGroup(head, k) return printLinkedList(new_head)"},{"question":"def swap_case_positions(s: str) -> str: Create a function that takes a string consisting of upper and lower case letters and returns a new string in which the positions of 'a' and 'A' are swapped with each other, the positions of 'b' and 'B' are swapped with each other, and so on up to 'z' and 'Z'. Other characters (like spaces, digits, symbols) remain unchanged. >>> swap_case_positions(\\"Hello, world! Python 3.9\\") 'hELLO, WORLD! pYTHON 3.9' >>> swap_case_positions(\\"hello\\") 'HELLO' >>> swap_case_positions(\\"HELLO\\") 'hello' >>> swap_case_positions(\\"hElLo WoRlD\\") 'HeLlO wOrLd' >>> swap_case_positions(\\"Python 3.9\\") 'pYTHON 3.9' >>> swap_case_positions(\\"#Python!\\") '#pYTHON!' >>> swap_case_positions(\\"\\") ''","solution":"def swap_case_positions(s): Takes a string consisting of upper and lower case letters and swaps the positions of each lowercase letter with its corresponding uppercase letter. swapped_string = \\"\\" for char in s: if char.islower(): swapped_string += char.upper() elif char.isupper(): swapped_string += char.lower() else: swapped_string += char return swapped_string"},{"question":"def can_transform_by_shifting(s1: str, s2: str) -> bool: Determines if s1 can be transformed into s2 by performing a series of shifts. Args: s1: A string of length 1 ≤ s1.length ≤ 1000. s2: A string of length 1 ≤ s2.length ≤ 1000. Returns: bool: True if s1 can be transformed into s2 by shifting, otherwise False. Example: >>> can_transform_by_shifting(\\"abcde\\", \\"cdeab\\") True >>> can_transform_by_shifting(\\"abcde\\", \\"abced\\") False","solution":"def can_transform_by_shifting(s1, s2): Determines if s1 can be transformed into s2 by performing a series of shifts. Parameters: s1 (str): The original string. s2 (str): The target string. Returns: bool: True if s1 can be transformed into s2 by shifting, otherwise False. if len(s1) != len(s2): return False return s2 in (s1 + s1)"},{"question":"def generate_magic_square(n: int): Generates a magic square of size n (where n is an odd number). >>> generate_magic_square(3) [[2, 7, 6], [9, 5, 1], [4, 3, 8]] >>> generate_magic_square(5) [[17, 24, 1, 8, 15], [23, 5, 7, 14, 16], [4, 6, 13, 20, 22], [10, 12, 19, 21, 3], [11, 18, 25, 2, 9]]","solution":"def generate_magic_square(n): Generates a magic square of size n (where n is an odd number). magic_square = [[0] * n for _ in range(n)] number = 1 i, j = 0, n // 2 while number <= n * n: magic_square[i][j] = number number += 1 newi, newj = (i - 1) % n, (j + 1) % n if magic_square[newi][newj]: i += 1 else: i, j = newi, newj return magic_square def print_magic_square(magic_square): for row in magic_square: print(' '.join(map(str, row)))"},{"question":"def sum_even_positions(arr: List[int]) -> int: Computes the sum of integers in even positions (0-based index) of the array. Args: arr (list): List of integers. Returns: int: Sum of integers at even positions. >>> sum_even_positions([1, 2, 3, 4, 5]) 9 >>> sum_even_positions([1, -2, 3, -4]) 4","solution":"def sum_even_positions(arr): Computes the sum of integers in even positions (0-based index) of the array. Args: arr (list): List of integers. Returns: int: Sum of integers at even positions. return sum(arr[i] for i in range(0, len(arr), 2)) def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) arr = list(map(int, data[1:])) result = sum_even_positions(arr) print(result) if __name__ == \\"__main__\\": main()"},{"question":"def max_presentations(m: int, books: List[int]) -> Tuple[int, Dict[int, Tuple[int, int, int]]]: Determines the maximum number of thematic presentations that can be given with the given books, where each presentation includes exactly one book from each subject area (History: 1, Science: 2, Literature: 3). Args: m (int): The number of books in the library. books (List[int]): A list of integers representing the subject area of each book. Returns: Tuple[int, Dict[int, Tuple[int, int, int]]]: A tuple containing: - The largest possible number of presentations. - A dictionary where the key is the presentation number and the value is a tuple of book indexes forming each presentation. Examples: >>> max_presentations(8, [1, 2, 3, 1, 2, 3, 3, 1]) (2, {0: (1, 2, 3), 1: (4, 5, 6)}) >>> max_presentations(5, [1, 3, 3, 2, 3]) (1, {0: (1, 4, 2)})","solution":"def max_presentations(m, books): history = [] science = [] literature = [] for i in range(m): if books[i] == 1: history.append(i + 1) elif books[i] == 2: science.append(i + 1) elif books[i] == 3: literature.append(i + 1) p = min(len(history), len(science), len(literature)) presentations = {} for i in range(p): presentations[i] = (history[i], science[i], literature[i]) return p, presentations m = 8 books = [1, 2, 3, 1, 2, 3, 3, 1] print(max_presentations(m, books)) # Output for example 1 should reflect: (2, {0: (1, 2, 3), 1: (4, 5, 6)}) m = 5 books = [1, 3, 3, 2, 3] print(max_presentations(m, books)) # Output for example 2 should reflect: (1, {0: (1, 4, 2)})"},{"question":"def min_operations_to_sort(arr): Determines the minimum number of subarray reversals to sort the array. Arguments: arr : List[int] - List of integers to be sorted. Output: int - Minimum number of operations required to sort the array. >>> min_operations_to_sort([3, 1, 2]) 2 >>> min_operations_to_sort([5, 4, 3, 2, 1]) 4 pass def process_test_cases(t, test_cases): Processes multiple test cases for sorting arrays. Arguments: t : int - Number of test cases. test_cases : List[Tuple[int, List[int]]] - List containing test cases. Output: List[int] - List of results representing the minimum number of operations required for each test case. >>> process_test_cases(2, [(3, [3, 1, 2]), (4, [4, 2, 3, 1])]) [2, 3] pass from solution import min_operations_to_sort, process_test_cases def test_example_cases(): test_cases = [(3, [3, 1, 2]), (4, [4, 2, 3, 1])] expected_outputs = [2, 3] # Expected results based on minimum number of operations for i, test_case in enumerate(test_cases): assert min_operations_to_sort(test_case[1]) == expected_outputs[i] def test_edge_cases_single_element(): assert min_operations_to_sort([1]) == 0 # Single element needs no operations def test_edge_cases_sorted_array(): assert min_operations_to_sort([1, 2, 3, 4, 5]) == 4 # Already sorted array of length 5 def test_edge_cases_reverse_sorted_array(): assert min_operations_to_sort([5, 4, 3, 2, 1]) == 4 # Reverse sorted array of length 5 def test_multiple_test_cases(): cases = [ (1, [2, 1]), (3, [3, 2, 1]), (4, [4, 3, 2, 1]), ] results = process_test_cases(3, cases) assert results == [1, 2, 3] def test_large_cases(): assert min_operations_to_sort(list(range(100, 0, -1))) == 99 # Reverse ordered list from 100 to 1 def test_various_cases(): test_cases = [ (3, [3, 1, 2]), (4, [4, 2, 3, 1]), (5, [5, 2, 3, 4, 1]), ] expected_outputs = [2, 3, 4] results = process_test_cases(3, test_cases) assert results == expected_outputs","solution":"def min_operations_to_sort(arr): Determines the minimum number of subarray reversals to sort the array. For any given array, the number of moves is directly equal to the length of the array minus one. This is because by each move, we can effectively fix one element in its sorted position. return len(arr) - 1 def process_test_cases(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] arr = test_cases[i][1] results.append(min_operations_to_sort(arr)) return results"},{"question":"def findLongestUniqueSubarray(n: int, arr: List[int]) -> int: Returns the length of the longest subarray with all unique elements. >>> findLongestUniqueSubarray(6, [1, 2, 3, 1, 2, 3]) 3 >>> findLongestUniqueSubarray(9, [4, 5, 6, 7, 8, 8, 7, 6, 5]) 5 >>> findLongestUniqueSubarray(5, [1, 2, 3, 4, 5]) 5 >>> findLongestUniqueSubarray(4, [1, 1, 1, 1]) 1 >>> findLongestUniqueSubarray(10, [1, 2, 1, 2, 3, 3, 4, 5, 1, 2]) 5 >>> findLongestUniqueSubarray(1, [1]) 1 >>> findLongestUniqueSubarray(0, []) 0","solution":"def findLongestUniqueSubarray(n, arr): Returns the length of the longest subarray with all unique elements. if n == 0: return 0 seen = {} left = 0 max_length = 0 for right in range(n): if arr[right] in seen and seen[arr[right]] >= left: left = seen[arr[right]] + 1 seen[arr[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"def max_difference(arr): Returns the maximum difference between any pair of elements such that the larger element appears after the smaller element in the array. If no such element pair exists, returns -1. >>> max_difference([2, 3, 1, 7, 9, 5, 11, 3, 5]) 10 >>> max_difference([7, 1, 5, 4]) 4 >>> max_difference([9, 4, 3, 2]) -1","solution":"def max_difference(arr): Returns the maximum difference between any pair of elements such that the larger element appears after the smaller element in the array. If no such element pair exists, returns -1. n = len(arr) if n < 2: return -1 min_element = arr[0] max_diff = -1 for i in range(1, n): if arr[i] > min_element: max_diff = max(max_diff, arr[i] - min_element) else: min_element = min(min_element, arr[i]) return max_diff"},{"question":"def minimum_total_distance(n: int, buildings: str) -> int: Calculate the minimum total distance all residents have to travel to reach the nearest commercial building. :param n: int, number of buildings :param buildings: string, 'R' for residential building, 'C' for commercial building :return: int, minimum total distance >>> minimum_total_distance(7, 'RCCRRCR') == 4 >>> minimum_total_distance(3, 'CCC') == 0 >>> minimum_total_distance(5, 'RRRCC') == 6 >>> minimum_total_distance(4, 'CCCC') == 0 >>> minimum_total_distance(4, 'RRRR') == 0 >>> minimum_total_distance(1, 'R') == 0 >>> minimum_total_distance(1, 'C') == 0 >>> minimum_total_distance(10, 'RCRCRCRCRC') == 5","solution":"def minimum_total_distance(n, buildings): Calculate the minimum total distance all residents have to travel to reach the nearest commercial building. :param n: int, number of buildings :param buildings: string, 'R' for residential building, 'C' for commercial building :return: int, minimum total distance if 'R' not in buildings or 'C' not in buildings: return 0 min_dist = [float('inf')] * n # Pass from left to right nearest_c = float('inf') for i in range(n): if buildings[i] == 'C': nearest_c = i if buildings[i] == 'R' and nearest_c != float('inf'): min_dist[i] = i - nearest_c # Pass from right to left nearest_c = float('inf') for i in range(n - 1, -1, -1): if buildings[i] == 'C': nearest_c = i if buildings[i] == 'R' and nearest_c != float('inf'): min_dist[i] = min(min_dist[i], nearest_c - i) return sum([dist for dist in min_dist if dist != float('inf')])"},{"question":"def group_tasks_by_priority(tasks): Groups tasks by their priority levels into sublists, sorted by priority in descending order. Args: tasks (list of tuples): A list of tasks where each task is represented by a tuple (task, priority). Returns: list of lists: A list of sublists where each sublist contains tasks of the same priority, ordered by priority.","solution":"def group_tasks_by_priority(tasks): Groups tasks by their priority levels into sublists, sorted by priority in descending order. Args: tasks (list of tuples): A list of tasks where each task is represented by a tuple (task, priority). Returns: list of lists: A list of sublists where each sublist contains tasks of the same priority, ordered by priority. from collections import defaultdict priority_dict = defaultdict(list) for task, priority in tasks: priority_dict[priority].append(task) sorted_priorities = sorted(priority_dict.items(), key=lambda x: x[0], reverse=True) return [[(task, priority) for task in tasks] for priority, tasks in sorted_priorities]"},{"question":"def min_deletions_to_avoid_consecutive_duplicates(s: str) -> int: Determines the minimum number of characters to be deleted from the string so that the remaining string does not have any two identical consecutive characters. Args: s (str): The input string consisting of lowercase English letters. Returns: int: The minimum number of deletions required. Examples: >>> min_deletions_to_avoid_consecutive_duplicates(\\"aab\\") 1 >>> min_deletions_to_avoid_consecutive_duplicates(\\"aabbcc\\") 3 >>> min_deletions_to_avoid_consecutive_duplicates(\\"abc\\") 0","solution":"def min_deletions_to_avoid_consecutive_duplicates(s): Determines the minimum number of characters to be deleted from the string so that the remaining string does not have any two identical consecutive characters. Args: s (str): The input string consisting of lowercase English letters. Returns: int: The minimum number of deletions required. deletions = 0 # Traverse the string and count deletions needed for consecutive duplicates for i in range(1, len(s)): if s[i] == s[i - 1]: deletions += 1 return deletions"},{"question":"from typing import List def kth_permutation(nums: List[int], k: int) -> List[int]: Returns the k-th permutation of the array nums in lexicographical order. Args: nums (List[int]): A list of unique integers. k (int): The index (1-based) of the permutation to return. Returns: List[int]: The k-th permutation of nums. >>> kth_permutation([1, 2, 3], 3) [2, 1, 3] >>> kth_permutation([4, 5, 6], 6) [6, 5, 4]","solution":"from typing import List import math def kth_permutation(nums: List[int], k: int) -> List[int]: Returns the k-th permutation of the array nums in lexicographical order. n = len(nums) k -= 1 # to convert k to zero-based index factorial = math.factorial result = [] available = sorted(nums) for i in range(n): fact = factorial(n - 1 - i) index = k // fact result.append(available.pop(index)) k %= fact return result"},{"question":"class WordDictionary: A class that supports adding new words and finding if a string matches any previously added string. Methods: - addWord(word): Adds \`word\` to the data structure, it can be matched later. - search(word): Returns \`true\` if there is any string in the data structure that matches \`word\` or \`false\` otherwise. \`word\` may contain dots \`'.'\` where dots can be matched with any letter. Example: >>> wordDictionary = WordDictionary() >>> wordDictionary.addWord(\\"bad\\") >>> wordDictionary.addWord(\\"dad\\") >>> wordDictionary.addWord(\\"mad\\") >>> wordDictionary.search(\\"pad\\") # return False >>> wordDictionary.search(\\"bad\\") # return True >>> wordDictionary.search(\\".ad\\") # return True >>> wordDictionary.search(\\"b..\\") # return True def __init__(self): pass def addWord(self, word: str) -> None: pass def search(self, word: str) -> bool: pass # Unit tests import pytest def test_add_and_search(): word_dict = WordDictionary() word_dict.addWord(\\"bad\\") word_dict.addWord(\\"dad\\") word_dict.addWord(\\"mad\\") assert word_dict.search(\\"pad\\") == False # \\"pad\\" is not in the dictionary assert word_dict.search(\\"bad\\") == True # \\"bad\\" is in the dictionary assert word_dict.search(\\".ad\\") == True # matches \\"bad\\", \\"dad\\", and \\"mad\\" assert word_dict.search(\\"b..\\") == True # matches \\"bad\\" def test_empty_search(): word_dict = WordDictionary() assert word_dict.search(\\"a\\") == False # no words added, should return False def test_search_without_dots(): word_dict = WordDictionary() word_dict.addWord(\\"hello\\") assert word_dict.search(\\"hello\\") == True # exact match assert word_dict.search(\\"hell\\") == False # different length def test_search_with_only_dots(): word_dict = WordDictionary() word_dict.addWord(\\"pattern\\") assert word_dict.search(\\".......\\") == True # match with 7-char length word assert word_dict.search(\\"......\\") == False # no match, only 6 dots def test_case_sensitivity(): word_dict = WordDictionary() word_dict.addWord(\\"Case\\") assert word_dict.search(\\"Case\\") == True # exact match assert word_dict.search(\\"case\\") == False # cases don't match if __name__ == '__main__': pytest.main()","solution":"class WordDictionary: def __init__(self): self.words = [] def addWord(self, word: str) -> None: self.words.append(word) def search(self, word: str) -> bool: from itertools import product n = len(word) matches = [w for w in self.words if len(w) == n] for i, c in enumerate(word): if c == '.': continue matches = [w for w in matches if w[i] == c] return len(matches) > 0"},{"question":"def trap(height: List[int]) -> int: Given an array of non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining. >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap([]) 0 >>> trap([1, 2, 3, 4, 5]) 0 >>> trap([4]) 0 >>> trap([4, 1]) 0 >>> trap([3, 3, 3, 3, 3]) 0 >>> trap([1, 0, 1, 0, 1]) 2","solution":"def trap(height): Returns the total amount of water that can be trapped after raining. :param height: List of non-negative integers representing the elevation map :return: Integer representing the total units of trapped rain water if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate the trapped water water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def reverse_with_same_case(s: str) -> str: Write a function that accepts a string \`s\` and returns a new string with the characters in reverse order, while keeping the letter case for each character as it was in the original string. >>> reverse_with_same_case(\\"Hello\\") == \\"olleH\\" >>> reverse_with_same_case(\\"World\\") == \\"dlroW\\" >>> reverse_with_same_case(\\"Python\\") == \\"nohtyP\\" >>> reverse_with_same_case(\\"CoDinG\\") == \\"GniDoC\\" >>> reverse_with_same_case(\\"123abc\\") == \\"cba321\\"","solution":"def reverse_with_same_case(s): Returns a new string with the characters in reverse order, while keeping the letter case for each character as it was in the original string. return s[::-1]"},{"question":"def largest_even_sum_subset_size(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the size of the largest subset where the sum of any two distinct integers is even. Args: test_cases: A list of tuples where each tuple contains an integer n and a list of n integers. Returns: A list of integers representing the size of the largest subset for each test case. Example: >>> largest_even_sum_subset_size([(5, [1, 2, 3, 4, 5])]) [3] >>> largest_even_sum_subset_size([(6, [2, 4, 6, 8, 10, 12])]) [6] >>> largest_even_sum_subset_size([(4, [1, 3, 5, 7])]) [4]","solution":"def largest_even_sum_subset_size(test_cases): results = [] for n, array in test_cases: evens = sum(1 for x in array if x % 2 == 0) odds = n - evens results.append(max(evens, odds)) return results # Helper to read input into the required format def read_input(input_list): t = int(input_list[0]) index = 1 test_cases = [] for _ in range(t): n = int(input_list[index]) array = list(map(int, input_list[index + 1].split())) test_cases.append((n, array)) index += 2 return test_cases"},{"question":"import math def pyramid_vol(type, dimensions, height): Calculate the volume of a pyramid based on its type and dimensions. Parameters: type (str): The type of the pyramid, either \\"square\\" or \\"triangular\\". dimensions (list): A list of dimensions: - For a square pyramid: one element, the side length. - For a triangular pyramid: three elements, the side lengths a, b, and c. height (float): The height of the pyramid. Returns: float: The volume of the pyramid. >>> pyramid_vol(\\"square\\", [4], 9) 48.0 >>> pyramid_vol(\\"triangular\\", [3, 4, 5], 6) 12.0","solution":"import math def pyramid_vol(type, dimensions, height): Returns the volume of either a square or triangular pyramid. Parameters: type (str): The type of the pyramid, either \\"square\\" or \\"triangular\\". dimensions (list): A list of dimensions: - For a square pyramid: one element, the side length. - For a triangular pyramid: three elements, the side lengths a, b, and c. height (float): The height of the pyramid. Returns: float: The volume of the pyramid. if type == \\"square\\": side = dimensions[0] base_area = side ** 2 elif type == \\"triangular\\": a, b, c = dimensions s = (a + b + c) / 2 base_area = math.sqrt(s * (s - a) * (s - b) * (s - c)) else: raise ValueError(\\"Invalid pyramid type.\\") volume = (1 / 3) * base_area * height return volume"},{"question":"from typing import List, Tuple def solution(N: int, M: int, edges: List[Tuple[int, int, int]], Q: int, queries: List[Tuple[int, int]]) -> List[int]: You are given an undirected connected graph with N nodes and M edges. Each edge has an integer weight. Perform Q queries on this graph, with each query containing two nodes u and v. Find the weight of the minimum weight edge in the unique path between u and v. Args: N (int): Number of nodes in the graph. M (int): Number of edges in the graph. edges (List[Tuple[int, int, int]]): List containing the edges of the graph in the format (u, v, w), where: - u (int): First node of the edge. - v (int): Second node of the edge. - w (int): Weight of the edge. Q (int): Number of queries. queries (List[Tuple[int, int]]): List containing the queries in the format (u, v), where: - u (int): Starting node of the query. - v (int): Ending node of the query. Returns: List[int]: List of integers where the i-th element is the weight of the minimum weight edge in the unique path between nodes u and v for the i-th query. Example: >>> solution(5, 4, [(1, 2, 3), (2, 3, 7), (3, 4, 2), (4, 5, 5)], 3, [(1, 3), (2, 4), (1, 5)]) [3, 2, 2] >>> solution(3, 2, [(1, 2, 4), (2, 3, 2)], 2, [(1, 2), (1, 3)]) [4, 2] pass def test_solution_sample_input(): N = 5 M = 4 edges = [(1, 2, 3), (2, 3, 7), (3, 4, 2), (4, 5, 5)] Q = 3 queries = [(1, 3), (2, 4), (1, 5)] expected_output = [3, 2, 2] assert solution(N, M, edges, Q, queries) == expected_output def test_solution_small_input(): N = 3 M = 2 edges = [(1, 2, 4), (2, 3, 2)] Q = 2 queries = [(1, 2), (1, 3)] expected_output = [4, 2] assert solution(N, M, edges, Q, queries) == expected_output def test_solution_line_graph(): N = 4 M = 3 edges = [(1, 2, 5), (2, 3, 3), (3, 4, 2)] Q = 2 queries = [(1, 4), (2, 4)] expected_output = [2, 2] assert solution(N, M, edges, Q, queries) == expected_output def test_solution_star_graph(): N = 5 M = 4 edges = [(1, 2, 1), (1, 3, 2), (1, 4, 3), (1, 5, 4)] Q = 3 queries = [(2, 3), (3, 4), (4, 5)] expected_output = [1, 2, 3] assert solution(N, M, edges, Q, queries) == expected_output def test_solution_binary_tree_graph(): N = 7 M = 6 edges = [(1, 2, 1), (1, 3, 8), (2, 4, 5), (2, 5, 1), (3, 6, 2), (3, 7, 3)] Q = 3 queries = [(4, 5), (4, 6), (5, 7)] expected_output = [1, 1, 1] assert solution(N, M, edges, Q, queries) == expected_output","solution":"def dfs(graph, node, parent, depth, parent_edge_weight, depth_list, parent_list, min_edge_weight_list): depth_list[node] = depth parent_list[node] = parent min_edge_weight_list[node] = parent_edge_weight for neighbor, weight in graph[node]: if neighbor != parent: dfs(graph, neighbor, node, depth + 1, weight, depth_list, parent_list, min_edge_weight_list) def lca_preprocess(graph, N): LOG = 17 # Since 2^17 > 10^5 depth_list = [0] * (N + 1) parent_list = [-1] * (N + 1) min_edge_weight_list = [float('inf')] * (N + 1) # Binary lifting tables dp = [[-1] * (N + 1) for _ in range(LOG)] min_edge = [[float('inf')] * (N + 1) for _ in range(LOG)] dfs(graph, 1, -1, 0, float('inf'), depth_list, parent_list, min_edge_weight_list) for i in range(1, N + 1): dp[0][i] = parent_list[i] min_edge[0][i] = min_edge_weight_list[i] for j in range(1, LOG): for i in range(1, N + 1): if dp[j-1][i] != -1: dp[j][i] = dp[j-1][dp[j-1][i]] min_edge[j][i] = min(min_edge[j-1][i], min_edge[j-1][dp[j-1][i]]) return dp, min_edge, depth_list def find_lca(dp, min_edge, depth_list, u, v): LOG = 17 if depth_list[u] < depth_list[v]: u, v = v, u min_weight = float('inf') for i in range(LOG - 1, -1, -1): if depth_list[u] - (1 << i) >= depth_list[v]: min_weight = min(min_weight, min_edge[i][u]) u = dp[i][u] if u == v: return min_weight for i in range(LOG - 1, -1, -1): if dp[i][u] != dp[i][v]: min_weight = min(min_weight, min_edge[i][u], min_edge[i][v]) u = dp[i][u] v = dp[i][v] min_weight = min(min_weight, min_edge[0][u], min_edge[0][v]) return min_weight def solution(N, M, edges, Q, queries): from collections import defaultdict graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) dp, min_edge, depth_list = lca_preprocess(graph, N) results = [] for u, v in queries: results.append(find_lca(dp, min_edge, depth_list, u, v)) return results"},{"question":"def smallest_lexicographic_rotation(s: str) -> str: Returns the lexicographically smallest string obtained by cyclic rotations of s. >>> smallest_lexicographic_rotation(\\"cba\\") \\"acb\\" >>> smallest_lexicographic_rotation(\\"baca\\") \\"abac\\" >>> smallest_lexicographic_rotation(\\"daab\\") \\"aabd\\" pass def process_input(t: int, cases: List[str]) -> List[str]: Processes the input and returns the results for each test case. >>> process_input(3, [\\"cba\\", \\"baca\\", \\"daab\\"]) [\\"acb\\", \\"abac\\", \\"aabd\\"] pass","solution":"def smallest_lexicographic_rotation(s): Returns the lexicographically smallest string obtained by cyclic rotations of s. n = len(s) cyclic_rotations = [s[i:] + s[:i] for i in range(n)] return min(cyclic_rotations) def process_input(t, cases): results = [] for i in range(t): results.append(smallest_lexicographic_rotation(cases[i])) return results"},{"question":"def triplet_sum_to_zero(nums): Given an integer array nums, return all unique triplets (a, b, c) such that a + b + c = 0. Args: nums (List[int]): List of integers Returns: List[List[int]]: List of unique triplets that add up to zero Example: >>> triplet_sum_to_zero([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]]","solution":"def triplet_sum_to_zero(nums): Returns a list of all unique triplets (a, b, c) in the array nums such that a + b + c = 0. nums.sort() triplets = set() # Use a set to store triplets to avoid duplicates for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i - 1]: continue # Avoid duplicates left, right = i + 1, len(nums) - 1 while left < right: s = nums[i] + nums[left] + nums[right] if s == 0: triplets.add((nums[i], nums[left], nums[right])) left += 1 right -= 1 elif s < 0: left += 1 else: right -= 1 return [list(triplet) for triplet in triplets]"},{"question":"from typing import List def min_cost_path(grid: List[List[int]]) -> int: Returns the minimum cost required to reach the bottom-right corner of the grid from the top-left corner. You can only move to the right or down one cell at a time. >>> min_cost_path([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_cost_path([[1, 2, 3], [4, 5, 6]]) 12","solution":"def min_cost_path(grid): Returns the minimum cost required to reach the bottom-right corner of the grid from the top-left corner. You can only move to the right or down one cell at a time. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[float('inf')] * n for _ in range(m)] dp[0][0] = grid[0][0] for i in range(m): for j in range(n): if i > 0: dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j]) if j > 0: dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j]) return dp[-1][-1]"},{"question":"def can_make_elements_equal(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Determine if it is possible to make all the elements of the array equal using any number of the specified operations. >>> can_make_elements_equal(3, [(5, 2, [4, 7, 7, 4, 4]), (6, 3, [1, 1, 1, 1, 1, 1]), (4, 4, [3, 6, 3, 3])]) ['NO', 'YES', 'NO'] pass def parse_input(input_str: str) -> Tuple[int, List[Tuple[int, int, List[int]]]]: Parse the input string into the number of test cases and a list of test cases. >>> parse_input(\\"3n5 2n4 7 7 4 4n6 3n1 1 1 1 1 1n4 4n3 6 3 3n\\") (3, [(5, 2, [4, 7, 7, 4, 4]), (6, 3, [1, 1, 1, 1, 1, 1]), (4, 4, [3, 6, 3, 3])]) pass def format_output(results: List[str]) -> str: Format the list of results into an output string. >>> format_output(['YES', 'NO', 'YES']) 'YESnNOnYES' pass import pytest def test_example_cases(): input_str = \\"3n5 2n4 7 7 4 4n6 3n1 1 1 1 1 1n4 4n3 6 3 3n\\" t, test_cases = parse_input(input_str) results = can_make_elements_equal(t, test_cases) output_str = format_output(results) expected_output = \\"NOnYESnNO\\" assert output_str == expected_output def test_additional_cases(): input_str = \\"2n5 3n5 5 5 5 5n4 2n1 2 1 2n\\" t, test_cases = parse_input(input_str) results = can_make_elements_equal(t, test_cases) output_str = format_output(results) expected_output = \\"YESnNO\\" assert output_str == expected_output def test_edge_cases(): input_str = \\"2n1 1n999999999n10 1n10 10 10 10 10 10 10 10 10 9n\\" t, test_cases = parse_input(input_str) results = can_make_elements_equal(t, test_cases) output_str = format_output(results) expected_output = \\"YESnNO\\" assert output_str == expected_output","solution":"def can_make_elements_equal(t, test_cases): results = [] for n, k, arr in test_cases: if k == 1: results.append(\\"YES\\" if len(set(arr)) == 1 else \\"NO\\") else: if len(set(arr)) < 2: results.append(\\"YES\\") else: results.append(\\"NO\\") return results def parse_input(input_str): lines = input_str.strip().split('n') t = int(lines[0]) test_cases = [] idx = 1 for _ in range(t): n, k = map(int, lines[idx].split()) arr = list(map(int, lines[idx + 1].split())) test_cases.append((n, k, arr)) idx += 2 return t, test_cases def format_output(results): return \\"n\\".join(results)"},{"question":"def min_operations(s1: str, s2: str) -> int: Returns the minimum number of operations required to transform s1 into s2. >>> min_operations(\\"sunday\\", \\"saturday\\") 3 >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"abcdef\\", \\"azced\\") 3","solution":"def min_operations(s1, s2): Returns the minimum number of operations required to transform s1 into s2. m = len(s1) n = len(s2) # Create a DP table to store the minimum operations dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the DP table for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # Insert all characters of s2 elif j == 0: dp[i][j] = i # Remove all characters of s1 elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no operation needed else: dp[i][j] = 1 + min(dp[i - 1][j], # Remove dp[i][j - 1], # Insert dp[i - 1][j - 1])# Replace return dp[m][n]"},{"question":"def is_circular_shift(A: str, B: str) -> str: Determines if string B is a circular shift of string A. >>> is_circular_shift(\\"abcde\\", \\"cdeab\\") \\"YES\\" >>> is_circular_shift(\\"hello\\", \\"lohel\\") \\"YES\\" >>> is_circular_shift(\\"mango\\", \\"nomag\\") \\"NO\\" def check_circular_shifts(T: int, test_cases: List[Tuple[str, str]]) -> List[str]: Checks multiple test cases for circular shifts. >>> check_circular_shifts(3, [(\\"abcde\\", \\"cdeab\\"), (\\"hello\\", \\"lohel\\"), (\\"mango\\", \\"nomag\\")]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> check_circular_shifts(2, [(\\"abc\\", \\"bca\\"), (\\"mango\\", \\"agm\\")]) [\\"YES\\", \\"NO\\"]","solution":"def is_circular_shift(A, B): Determines if string B is a circular shift of string A. Parameters: A (str): The original string. B (str): The string to check. Returns: str: \\"YES\\" if B is a circular shift of A, otherwise \\"NO\\". if len(A) != len(B): return \\"NO\\" return \\"YES\\" if B in (A + A) else \\"NO\\" def check_circular_shifts(T, test_cases): Checks multiple test cases for circular shifts. Parameters: T (int): Number of test cases. test_cases (list of tuples): Each tuple contains two strings A and B. Returns: list of str: \\"YES\\" or \\"NO\\" for each test case. results = [] for A, B in test_cases: results.append(is_circular_shift(A, B)) return results"},{"question":"from typing import List, Tuple def find_pairs(arr1: List[int], arr2: List[int], target: int) -> List[Tuple[int, int]]: Finds all unique pairs of integers (a, b) such that a is from arr1, b is from arr2, and their sum is equal to the target. >>> find_pairs([1, 2, 3, 4, 5], [3, 4, 5, 6, 7], 8) [(1, 7), (2, 6), (3, 5), (4, 4)] >>> find_pairs([1, 2, 3], [4, 5, 6], 10) [] >>> find_pairs([1, 2, 3, 3], [3, 4, 5, 3], 6) [(1, 5), (2, 4), (3, 3)] >>> find_pairs([-1, -2, -3, 4], [1, 2, 3, -4], 0) [(-4, 4), (-3, 3), (-2, 2), (-1, 1)] >>> find_pairs([-1, 0, 1, 2], [-2, 0, 2, 3], 1) [(-1, 2), (0, 1)]","solution":"from typing import List, Tuple def find_pairs(arr1: List[int], arr2: List[int], target: int) -> List[Tuple[int, int]]: Finds all unique pairs of integers (a, b) such that a is from arr1, b is from arr2, and their sum is equal to the target. result = set() for num1 in arr1: for num2 in arr2: if num1 + num2 == target: result.add((min(num1, num2), max(num1, num2))) return sorted(list(result))"},{"question":"def generate_fibonacci_sequences(n, sequences): Generate customized Fibonacci-like sequences. Parameters: - n: Number of sequences to generate. - sequences: List of tuples, where each tuple contains X, Y, and L. Returns: - List of generated sequences, where each sequence is a list of integers. >>> generate_fibonacci_sequences(1, [(1, 1, 5)]) [[1, 1, 2, 3, 5]] >>> generate_fibonacci_sequences(3, [(1, 1, 5), (2, 3, 4), (5, 7, 6)]) [[1, 1, 2, 3, 5], [2, 3, 5, 8], [5, 7, 12, 19, 31, 50]] >>> generate_fibonacci_sequences(2, [(3, 5, 6), (2, 2, 3)]) [[3, 5, 8, 13, 21, 34], [2, 2, 4]] >>> generate_fibonacci_sequences(1, [(1, 2, 2)]) [[1, 2]] >>> generate_fibonacci_sequences(2, [(1, 1, 20), (100, 100, 10)]) [[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765], [100, 100, 200, 300, 500, 800, 1300, 2100, 3400, 5500]]","solution":"def generate_fibonacci_sequences(n, sequences): Generate customized Fibonacci-like sequences. Parameters: - n: Number of sequences to generate. - sequences: List of tuples, where each tuple contains X, Y, and L. Returns: - List of generated sequences, where each sequence is a list of integers. results = [] for seq in sequences: x, y, l = seq sequence = [x, y] for _ in range(2, l): next_val = sequence[-1] + sequence[-2] sequence.append(next_val) results.append(sequence) return results # Example usage # n = 3 # sequences = [(1, 1, 5), (2, 3, 4), (5, 7, 6)] # print(generate_fibonacci_sequences(n, sequences)) # Output: [[1, 1, 2, 3, 5], [2, 3, 5, 8], [5, 7, 12, 19, 31, 50]]"},{"question":"def compress_compound(s: str) -> str: Compresses the compound string by counting contiguous occurrences of each element. Args: s (str): The input string representing the compound. Returns: str: The compressed string. >>> compress_compound(\\"CCCCHHHHHEE\\") 'C4H5E2' >>> compress_compound(\\"HHOI\\") 'H2OI' >>> compress_compound(\\"AABBBCCDAA\\") 'A2B3C2DA2' >>> compress_compound(\\"ABCDE\\") 'ABCDE' >>> compress_compound(\\"\\") ''","solution":"def compress_compound(s): Compresses the compound string by counting contiguous occurrences of each element. Args: s (str): The input string representing the compound. Returns: str: The compressed string. if not s: return \\"\\" compressed = [] current_char = s[0] count = 1 for c in s[1:]: if c == current_char: count += 1 else: compressed.append(f\\"{current_char}{count if count > 1 else ''}\\") current_char = c count = 1 compressed.append(f\\"{current_char}{count if count > 1 else ''}\\") return ''.join(compressed)"},{"question":"def minimize_group_sum(N: int, K: int, skill_levels: List[int]) -> int: Optimize the division of participants into groups to minimize the sum of the skill levels of the groups. Parameters: N (int): Number of participants. K (int): Number of groups. skill_levels (List[int]): Skill levels of each participant. Returns: int: The minimized sum of the skill levels of the groups. >>> minimize_group_sum(5, 3, [2, 4, 6, 8, 10]) 24 >>> minimize_group_sum(6, 2, [7, 3, 5, 1, 9, 11]) 16 >>> minimize_group_sum(4, 4, [5, 5, 5, 5]) 20 >>> minimize_group_sum(7, 3, [10, 20, 30, 40, 50, 60, 70]) 180 >>> minimize_group_sum(3, 1, [100, 200, 300]) 300","solution":"def minimize_group_sum(N, K, skill_levels): Function to minimize the sum of skill levels of K groups. Parameters: N (int): Number of participants. K (int): Number of groups. skill_levels (list of int): Skill levels of each participant. Returns: int: The minimized sum of the skill levels of the groups. # Sort skill levels in descending order skill_levels.sort(reverse=True) # The top K skill levels would form the groups # Returning the sum of the first K elements return sum(skill_levels[:K]) # Example usage: # N, K = 5, 3 # skill_levels = [2, 4, 6, 8, 10] # print(minimize_group_sum(N, K, skill_levels)) # Output: 24"},{"question":"def findPeakElement(arr, N): Given an array of N distinct integers, find a peak element. A peak element is an element that is greater than its neighbors. If the array contains multiple peaks, return the index of any one of them. >>> findPeakElement([1, 3, 20, 4, 1, 0], 6) 2 >>> findPeakElement([10, 20, 15, 2, 23, 90, 67], 7) 1 or 5","solution":"def findPeakElement(arr, N): Finds and returns the index of a peak element in the array. A peak element is an element that is greater than its neighbors. if N == 1: return 0 if arr[0] >= arr[1]: return 0 if arr[N-1] >= arr[N-2]: return N-1 low, high = 0, N-1 while low <= high: mid = (low + high) // 2 # Check if mid is a peak if (mid == 0 or arr[mid] >= arr[mid - 1]) and (mid == N-1 or arr[mid] >= arr[mid + 1]): return mid # If the left neighbor is greater, then there must be a peak element on the left side elif mid > 0 and arr[mid - 1] > arr[mid]: high = mid - 1 # If the right neighbor is greater, then there must be a peak element on the right side else: low = mid + 1 return -1"},{"question":"def sum_of_two_smallest(numbers: List[int]) -> int: Write a function that takes a list of integers as input and returns the sum of the two smallest numbers in the list. Ensure that the numbers in the list are distinct and that there are at least two elements in the list. >>> sum_of_two_smallest([19, 3, 5, 21, 7, 13]) # returns 8 >>> sum_of_two_smallest([1, 2, 3, 4, 5]) # returns 3 >>> sum_of_two_smallest([10, 9, 5, 2]) # returns 7 >>> sum_of_two_smallest([-1, -2, 0, 1]) # returns -3 >>> sum_of_two_smallest([50, 40, 30, 20, 10]) # returns 30 :param numbers: List of distinct integers with at least two elements. :return: Sum of the two smallest numbers.","solution":"def sum_of_two_smallest(numbers): Returns the sum of the two smallest distinct numbers in the list. :param numbers: List of distinct integers with at least two elements. :return: Sum of the two smallest numbers. if len(numbers) < 2: raise ValueError(\\"The list must contain at least two distinct numbers.\\") # Sort the list and sum the two smallest elements (the first two in the sorted list) sorted_numbers = sorted(numbers) return sorted_numbers[0] + sorted_numbers[1]"},{"question":"def can_schedule_all_challenges(t: int, test_cases: List[Tuple[int, List[Tuple[int, int, int]]]]) -> List[str]: Determines if it's possible to schedule all challenges without overlapping. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[Tuple[int, int, int]]]]): Each test case consists of an integer n and a list of tuples, each containing three integers: s_i, e_i, d_i. Returns: List[str]: List of \\"YES\\" or \\"NO\\" for each test case indicating if it's possible to schedule all challenges without overlapping. Example: >>> t = 2 >>> test_cases = [(3, [(1, 10, 5), (2, 15, 3), (7, 20, 8)]), (2, [(1, 4, 3), (6, 10, 4)])] >>> can_schedule_all_challenges(t, test_cases) [\\"YES\\", \\"YES\\"]","solution":"def can_schedule_all_challenges(t, test_cases): results = [] for test_case in test_cases: n, challenges = test_case # Sort challenges by end time first and then by start time challenges.sort(key=lambda x: x[1]) current_time = 0 possible = True for challenge in challenges: s, e, d = challenge if current_time < s: current_time = s if current_time + d - 1 > e: possible = False break current_time += d if possible: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def can_transform_array(n, A, B): Determines if it is possible to transform array A to B with one operation of adding a constant integer k to a contiguous subarray. >>> can_transform_array(5, [1, 2, 3, 4, 5], [2, 3, 4, 5, 6]) \\"YES\\" >>> can_transform_array(4, [1, 3, 2, 4], [4, 5, 6, 7]) \\"NO\\" >>> can_transform_array(3, [7, 7, 7], [10, 10, 10]) \\"YES\\" >>> can_transform_array(3, [1, 2, 3], [2, 3, 5]) \\"NO\\" >>> can_transform_array(3, [1, 2, 3], [1, 1, 1]) \\"NO\\" >>> can_transform_array(4, [2, 2, 2, 2], [5, 5, 5, 5]) \\"YES\\" >>> can_transform_array(1, [1], [1000]) \\"YES\\" >>> can_transform_array(2, [1, 1000], [1000, 1]) \\"NO\\"","solution":"def can_transform_array(n, A, B): Determines if it is possible to transform array A to B with one operation of adding a constant integer k to a contiguous subarray. differences = [b - a for a, b in zip(A, B)] unique_differences = set(differences) # There should be at most two unique differences: the difference k, and 0 if len(unique_differences) == 1: return \\"YES\\" elif len(unique_differences) == 2 and 0 in unique_differences: return \\"YES\\" else: return \\"NO\\""},{"question":"def max_consecutive_ones(n: int, s: str) -> int: Returns the maximum number of consecutive '1's that can be obtained by performing at most one operation of turning a substring of '0's into '1's. >>> max_consecutive_ones(5, \\"11010\\") 4 >>> max_consecutive_ones(5, \\"11111\\") 5 >>> max_consecutive_ones(5, \\"00000\\") 1 >>> max_consecutive_ones(5, \\"11011\\") 5 >>> max_consecutive_ones(6, \\"111001\\") 4 >>> max_consecutive_ones(10, \\"1101101101\\") 5 >>> max_consecutive_ones(100000, \\"0\\"*100000) 1 >>> max_consecutive_ones(100000, \\"1\\"*100000) 100000","solution":"def max_consecutive_ones(n, s): Returns the maximum number of consecutive '1's that can be obtained by performing at most one operation of turning a substring of '0's into '1's. max_ones = 0 current_zeros = 0 current_ones = 0 # To keep track of the number of ones on the left and right side of zeros left_ones = [0] * n right_ones = [0] * n # Fill left_ones array with the count of consecutive ones to the left if s[0] == '1': left_ones[0] = 1 for i in range(1, n): if s[i] == '1': left_ones[i] = left_ones[i-1] + 1 else: left_ones[i] = 0 # Fill right_ones array with the count of consecutive ones to the right if s[n-1] == '1': right_ones[n-1] = 1 for i in range(n-2, -1, -1): if s[i] == '1': right_ones[i] = right_ones[i+1] + 1 else: right_ones[i] = 0 for i in range(n): if s[i] == '0': left = left_ones[i-1] if i > 0 else 0 right = right_ones[i+1] if i < n-1 else 0 max_ones = max(max_ones, left + 1 + right) else: max_ones = max(max_ones, left_ones[i]) return max_ones"},{"question":"from typing import List def min_subset_difference(nums: List[int]) -> int: You are given a list of N positive integers. Your task is to partition these integers into two subsets such that the absolute difference between the sums of the two subsets is minimized. >>> min_subset_difference([1, 6, 11, 5]) 1 >>> min_subset_difference([2, 2, 2, 2]) 0 >>> min_subset_difference([1, 1, 1, 1, 1, 9]) 4 >>> min_subset_difference([10, 20]) 10 >>> min_subset_difference([50]) 50 >>> min_subset_difference([3, 1, 4, 2, 2, 1]) 1","solution":"from typing import List def min_subset_difference(nums: List[int]) -> int: total_sum = sum(nums) n = len(nums) target = total_sum // 2 # Initialize DP array dp = [False] * (target + 1) dp[0] = True # Fill DP array for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] # Find the largest j such that dp[j] is True for j in range(target, -1, -1): if dp[j]: subset1_sum = j break subset2_sum = total_sum - subset1_sum return abs(subset2_sum - subset1_sum)"},{"question":"def intersection(arr1, arr2): Returns the sorted intersection of two lists as a list with unique elements. >>> intersection([1, 2, 2, 1], [2, 2]) == [2] >>> intersection([4, 9, 5], [9, 4, 9, 8, 4]) == [4, 9]","solution":"def intersection(arr1, arr2): Returns the sorted intersection of two lists as a list with unique elements. # Convert arrays to sets to find unique elements set1 = set(arr1) set2 = set(arr2) # Find the intersection of the two sets intersection_set = set1.intersection(set2) # Convert the result to a sorted list result = sorted(list(intersection_set)) return result"},{"question":"def overlap(rect1, rect2): Determine if two rectangles overlap. Each rectangle is represented by a dictionary with keys: 'x1', 'y1' for the bottom-left corner and 'x2', 'y2' for the top-right corner. Args: rect1 (dict): The first rectangle, with keys 'x1', 'y1', 'x2', 'y2'. rect2 (dict): The second rectangle, with keys 'x1', 'y1', 'x2', 'y2'. Returns: bool: True if the rectangles overlap, False otherwise. >>> rect1 = {'x1': 1, 'y1': 1, 'x2': 3, 'y2': 3} >>> rect2 = {'x1': 2, 'y1': 2, 'x2': 4, 'y2': 4} >>> overlap(rect1, rect2) True >>> rect1 = {'x1': 1, 'y1': 1, 'x2': 3, 'y2': 3} >>> rect2 = {'x1': 4, 'y1': 4, 'x2': 5, 'y2': 5} >>> overlap(rect1, rect2) False","solution":"def overlap(rect1, rect2): Determine if two rectangles overlap. Each rectangle is represented by a dictionary with keys: 'x1', 'y1' for the bottom-left corner and 'x2', 'y2' for the top-right corner. Args: rect1 (dict): The first rectangle, with keys 'x1', 'y1', 'x2', 'y2'. rect2 (dict): The second rectangle, with keys 'x1', 'y1', 'x2', 'y2'. Returns: bool: True if the rectangles overlap, False otherwise. # If one rectangle is to the left of the other if rect1['x2'] <= rect2['x1'] or rect2['x2'] <= rect1['x1']: return False # If one rectangle is above the other if rect1['y2'] <= rect2['y1'] or rect2['y2'] <= rect1['y1']: return False return True"},{"question":"import math from typing import List, Tuple def max_distance(coordinates: List[Tuple[int, int]]) -> float: Calculate the maximum Euclidean distance between any two points in the list of coordinates. Parameters: coordinates (list of tuples): A list of (x, y) coordinates. Returns: float: The maximum Euclidean distance. >>> max_distance([(1, 2), (4, 6), (1, 8), (8, 2)]) 9.219544 >>> max_distance([(1, 1), (4, 5)]) 5.0 >>> max_distance([(-10000, -10000), (10000, 10000)]) 28284.271248 >>> max_distance([(-1, -1), (1, 1)]) 2.828427 >>> max_distance([(1, 2), (1, 8)]) 6.0 >>> max_distance([(1, 2), (4, 2)]) 3.0","solution":"import math def max_distance(coordinates): Calculate the maximum Euclidean distance between any two points in the list coordinates. Parameters: coordinates (list of tuples): A list of (x, y) coordinates. Returns: float: The maximum Euclidean distance. max_dist = 0.0 n = len(coordinates) for i in range(n): for j in range(i + 1, n): dist = math.sqrt((coordinates[j][0] - coordinates[i][0]) ** 2 + (coordinates[j][1] - coordinates[i][1]) ** 2) if dist > max_dist: max_dist = dist return max_dist def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) coordinates = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(N)] result = max_distance(coordinates) print(f\\"{result:.6f}\\")"},{"question":"def count_paths(N: int, M: int, grid: List[List[int]]) -> int: Calculate the number of distinct paths a robot can take from the top-left corner to the bottom-right corner while moving only to cells with values greater than or equal to the value of its current cell. The result should be modulo 10^9 + 7. >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> count_paths(3, 3, grid) 6 >>> grid = [ ... [1, 2], ... [3, 0] ... ] >>> count_paths(2, 2, grid) 0 >>> grid = [ ... [1] ... ] >>> count_paths(1, 1, grid) 1 >>> grid = [ ... [1, 2, 3], ... [2, 3, 4], ... [3, 4, 5] ... ] >>> count_paths(3, 3, grid) 6","solution":"MOD = 10**9 + 7 def count_paths(N, M, grid): if grid[0][0] > grid[N-1][M-1]: return 0 dp = [[0]*M for _ in range(N)] dp[0][0] = 1 for i in range(N): for j in range(M): if i > 0 and grid[i][j] >= grid[i-1][j]: dp[i][j] += dp[i-1][j] if j > 0 and grid[i][j] >= grid[i][j-1]: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD return dp[N-1][M-1] # Example usage: grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(count_paths(3, 3, grid)) # Output 6"},{"question":"from typing import List, Tuple def tree_diameter(n: int, edges: List[Tuple[int, int]]) -> int: Determine the diameter (length of the longest path between any two nodes) of a given tree. Args: n (int): The number of nodes in the tree. edges (List[Tuple[int, int]]): A list of edges where each edge is represented as a tuple (u, v), indicating an undirected edge between nodes u and v. Returns: int: The diameter of the tree. Examples: >>> tree_diameter(5, [(1, 2), (1, 3), (2, 4), (2, 5)]) 3 >>> tree_diameter(3, [(1, 2), (2, 3)]) 2 pass def test_tree_diameter(): assert tree_diameter(5, [(1, 2), (1, 3), (2, 4), (2, 5)]) == 3 assert tree_diameter(3, [(1, 2), (2, 3)]) == 2 assert tree_diameter(4, [(1, 2), (2, 3), (3, 4)]) == 3 assert tree_diameter(6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) == 5 assert tree_diameter(7, [(1, 2), (1, 3), (2, 4), (2, 5), (5, 6), (5, 7)]) == 4 if __name__ == \\"__main__\\": test_tree_diameter() print(\\"All tests passed!\\")","solution":"from collections import deque def bfs_farthest_node(adj_list, start): n = len(adj_list) distances = [-1] * n queue = deque([start]) distances[start] = 0 farthest_node = start max_distance = 0 while queue: current = queue.popleft() for neighbor in adj_list[current]: if distances[neighbor] == -1: distances[neighbor] = distances[current] + 1 queue.append(neighbor) if distances[neighbor] > max_distance: max_distance = distances[neighbor] farthest_node = neighbor return farthest_node, max_distance def tree_diameter(n, edges): adj_list = [[] for _ in range(n + 1)] for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # Start BFS from an arbitrary node (node 1) farthest_node, _ = bfs_farthest_node(adj_list, 1) # Start second BFS from the farthest node found _, diameter = bfs_farthest_node(adj_list, farthest_node) return diameter"},{"question":"from typing import List, Tuple def categorize_paintings(test_cases: List[Tuple[int, int, int]]) -> List[str]: Categorize paintings as either 'large', 'medium', or 'small'. Each painting is described by a list of factors, which includes its height, width, and weight. - A painting is considered \\"large\\" if its height is greater than 4 meters or its width is greater than 3 meters. - If a painting is not large and its weight is greater than 2 kilograms, it is considered \\"medium\\". - All other paintings are considered \\"small\\". Args: test_cases (List[Tuple[int, int, int]]): Each tuple contains three integers – height, width, and weight of the painting. Returns: List[str]: A list containing the category (\\"large\\", \\"medium\\", or \\"small\\") for each painting. >>> categorize_paintings([(4, 5, 1)]) [\\"large\\"] >>> categorize_paintings([(2, 2, 3)]) [\\"medium\\"] >>> categorize_paintings([(1, 1, 1)]) [\\"small\\"] >>> categorize_paintings([(4, 5, 1), (2, 2, 3), (1, 1, 1)]) [\\"large\\", \\"medium\\", \\"small\\"]","solution":"def categorize_paintings(test_cases): results = [] for H, W, G in test_cases: if H > 4 or W > 3: results.append(\\"large\\") elif G > 2: results.append(\\"medium\\") else: results.append(\\"small\\") return results"},{"question":"from typing import List, Tuple def closest_dragon_lair(knights_lairs: List[List[Tuple[int, int]]], starting_point: Tuple[int, int]) -> List[int]: Determine the closest dragon lair to a given starting point for each knight. >>> closest_dragon_lair([[(1, 2), (3, 4)], [(5, 6), (7, 8)]], (0, 0)) == [0, 0] >>> closest_dragon_lair([[(1, 2), (3, 4), (0, 0)]], (0, 0)) == [2] >>> closest_dragon_lair([[(1, 2), (3, 4)], [(5, 5), (1, 1), (4, 4)]], (1, 1)) == [0, 1] >>> closest_dragon_lair([[(1, 1), (2, 2)]], (3, 3)) == [1] >>> closest_dragon_lair([[(-1, -2), (-3, -4)], [(-5, -6), (-7, -8)]], (0, 0)) == [0, 0] >>> closest_dragon_lair([[(1, 1), (1, 1), (1, 1)]], (0, 0)) == [0] >>> closest_dragon_lair([[(2, 3)]], (0, 0)) == [0]","solution":"import math def closest_dragon_lair(knights_lairs, starting_point): def distance(p1, p2): return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) closest_lairs = [] for lairs in knights_lairs: closest_index = 0 min_distance = float('inf') for index, lair in enumerate(lairs): d = distance(starting_point, lair) if d < min_distance: min_distance = d closest_index = index closest_lairs.append(closest_index) return closest_lairs"},{"question":"def longest_increasing_subperiod(n: int, heights: List[int]) -> int: Determine the length of the longest continuous sub-period where the height increases each day. >>> longest_increasing_subperiod(6, [3, 4, 2, 5, 6, 1]) 3 >>> longest_increasing_subperiod(5, [10, 20, 30, 5, 7]) 3 >>> longest_increasing_subperiod(7, [5, 6, 7, 1, 2, 3, 4]) 4 >>> longest_increasing_subperiod(3, [1, 1, 1]) 1 >>> longest_increasing_subperiod(1, [5]) 1 >>> longest_increasing_subperiod(9, [1, 2, 3, 4, 5, 6, 7, 8, 9]) 9 # Edge cases >>> longest_increasing_subperiod(0, []) 0 # no measurements >>> longest_increasing_subperiod(2, [5, 5]) 1 # same height two days >>> longest_increasing_subperiod(5, [10, 9, 8, 7, 6]) 1 # strictly decreasing >>> longest_increasing_subperiod(5, [1, 2, 2, 3, 4]) 3 # repeated value","solution":"def longest_increasing_subperiod(n, heights): if n == 0: return 0 max_len = 1 current_len = 1 for i in range(1, n): if heights[i] > heights[i - 1]: current_len += 1 max_len = max(max_len, current_len) else: current_len = 1 return max_len"},{"question":"def is_sequence_balanced(n, heights) -> str: Determines whether the sequence of tower heights is balanced. >>> is_sequence_balanced(5, [1, 2, 3, 3, 2]) 'YES' >>> is_sequence_balanced(4, [1, 3, 2, 1]) 'NO' >>> is_sequence_balanced(1, [1]) 'YES' >>> is_sequence_balanced(2, [5, 6]) 'YES' >>> is_sequence_balanced(2, [1, 3]) 'NO' >>> is_sequence_balanced(5, [10, 11, 10, 11, 10]) 'YES' >>> is_sequence_balanced(3, [5, 7, 8]) 'NO'","solution":"def is_sequence_balanced(n, heights): Determines whether the sequence of tower heights is balanced. for i in range(n - 1): if abs(heights[i] - heights[i + 1]) > 1: return \\"NO\\" return \\"YES\\""},{"question":"def find_unique_number(numbers: List[str]) -> float: Find the unique numeric string in the list and return its numeric value as a float. >>> find_unique_number([\\"123\\", \\"123\\", \\"456\\", \\"123\\", \\"123\\"]) == 456.0 >>> find_unique_number([\\"0.1\\", \\"0.1\\", \\"0.2\\", \\"0.1\\", \\"0.1\\"]) == 0.2","solution":"def find_unique_number(numbers): Find the unique numeric string in the list and return its numeric value as a float. from collections import Counter # Counting frequency of each number counter = Counter(numbers) # Finding the unique number (with count = 1) unique_str = next(num for num, count in counter.items() if count == 1) # Returning the numeric value as a float return float(unique_str)"},{"question":"def categorize_files(filenames): Categorizes the given list of filenames based on their extensions. Parameters: filenames (list of str): List of filenames with extensions. Returns: dict: A dictionary where keys are extensions and values are lists of filenames sorted lexicographically. pass def format_output(categorized_files): Formats the categorized files dictionary into the required string format. Parameters: categorized_files (dict): Dictionary with extensions as keys and sorted filenames as values. Returns: str: Formatted string as specified in the problem statement. pass from solution import categorize_files, format_output def test_example_case(): filenames = [ \\"document.txt\\", \\"image.jpg\\", \\"note.txt\\", \\"archive.zip\\", \\"picture.jpg\\" ] categorized = categorize_files(filenames) assert categorized == { \\"jpg\\": \\"image.jpg picture.jpg\\", \\"txt\\": \\"document.txt note.txt\\", \\"zip\\": \\"archive.zip\\" } formatted = format_output(categorized) assert formatted == \\"jpg: image.jpg picture.jpgntxt: document.txt note.txtnzip: archive.zip\\" def test_single_file(): filenames = [\\"file1.doc\\"] categorized = categorize_files(filenames) assert categorized == { \\"doc\\": \\"file1.doc\\" } formatted = format_output(categorized) assert formatted == \\"doc: file1.doc\\" def test_multiple_extensions(): filenames = [\\"file1.doc\\", \\"file2.jpg\\", \\"file1.jpg\\"] categorized = categorize_files(filenames) assert categorized == { \\"doc\\": \\"file1.doc\\", \\"jpg\\": \\"file1.jpg file2.jpg\\" } formatted = format_output(categorized) assert formatted == \\"doc: file1.docnjpg: file1.jpg file2.jpg\\" def test_no_files(): filenames = [] categorized = categorize_files(filenames) assert categorized == {} formatted = format_output(categorized) assert formatted == \\"\\" def test_files_with_same_name_different_extensions(): filenames = [\\"file1.txt\\", \\"file1.jpg\\", \\"file1.doc\\"] categorized = categorize_files(filenames) assert categorized == { \\"txt\\": \\"file1.txt\\", \\"jpg\\": \\"file1.jpg\\", \\"doc\\": \\"file1.doc\\" } formatted = format_output(categorized) assert formatted == \\"doc: file1.docnjpg: file1.jpgntxt: file1.txt\\"","solution":"def categorize_files(filenames): Categorizes the given list of filenames based on their extensions. Parameters: filenames (list of str): List of filenames with extensions. Returns: dict: A dictionary where keys are extensions and values are lists of filenames sorted lexicographically. from collections import defaultdict file_dict = defaultdict(list) for filename in filenames: # Split the filename into name and extension name, ext = filename.rsplit('.', 1) file_dict[ext].append(filename) # Prepare output in the required format result = {} for ext in sorted(file_dict.keys()): result[ext] = ' '.join(sorted(file_dict[ext])) return result def format_output(categorized_files): Formats the categorized files dictionary into the required string format. Parameters: categorized_files (dict): Dictionary with extensions as keys and sorted filenames as values. Returns: str: Formatted string as specified in the problem statement. result = [] for ext, files in categorized_files.items(): result.append(f\\"{ext}: {files}\\") return 'n'.join(result)"},{"question":"def countPalindromicNumbers(M: int, N: int) -> int: Determine the total count of numbers X within the range [M, N] such that their binary representation is a palindrome. >>> countPalindromicNumbers(5, 10) 3 >>> countPalindromicNumbers(10, 15) 1","solution":"def is_binary_palindrome(num): Check if the binary representation of a number is a palindrome. binary_rep = bin(num)[2:] return binary_rep == binary_rep[::-1] def countPalindromicNumbers(M, N): Count the number of integers between M and N (inclusive) whose binary representations are palindromic. count = 0 for num in range(M, N + 1): if is_binary_palindrome(num): count += 1 return count"},{"question":"def find_consecutive_sums(n): Finds and returns all possible lists of consecutive positive integers that sum up to the non-negative integer n. Examples: >>> find_consecutive_sums(9) [[2, 3, 4], [4, 5]] >>> find_consecutive_sums(15) [[1, 2, 3, 4, 5], [4, 5, 6], [7, 8]] >>> find_consecutive_sums(3) [[1, 2]]","solution":"def find_consecutive_sums(n): Finds and returns all possible lists of consecutive positive integers that sum up to the non-negative integer n. if n <= 0: return [] results = [] # We will use the formula for the sum of an arithmetic series: # S = n(a + l) / 2 where n is the number of terms, a is the first term, and l is the last term. # We need to find all possible 'n' and 'a' where the sum S = n for start in range(1, n // 2 + 2): sum_ = 0 sequence = [] for i in range(start, n): sum_ += i sequence.append(i) if sum_ == n: results.append(sequence) break elif sum_ > n: break return results"},{"question":"def smallest_palindrome(n: int) -> str: Given an integer n (1 ≤ n ≤ 300), determine the lexicographically smallest palindrome that can be formed using exactly n characters. Allowed characters are the lowercase English letters ('a' - 'z'). >>> smallest_palindrome(5) 'aaaaa' >>> smallest_palindrome(8) 'aaaaaaaa' >>> smallest_palindrome(1) 'a'","solution":"def smallest_palindrome(n): Returns the lexicographically smallest palindrome that can be formed using exactly n characters. if n == 1: return 'a' half = (n + 1) // 2 return 'a' * half + 'a' * (n - half)"},{"question":"from typing import List from collections import Counter def count_good_strings(words: List[str], chars: str) -> int: Returns the sum of lengths of all good strings in words that can be formed with the characters from chars. >>> count_good_strings([\\"cat\\", \\"bt\\", \\"hat\\", \\"tree\\"], \\"atach\\") 6 >>> count_good_strings([\\"hello\\", \\"world\\", \\"leetcode\\"], \\"welldonehoneyr\\") 10 pass","solution":"from collections import Counter def count_good_strings(words, chars): Returns the sum of lengths of all good strings in words that can be formed with the characters from chars. chars_count = Counter(chars) total_length = 0 for word in words: word_count = Counter(word) if all(word_count[c] <= chars_count[c] for c in word_count): total_length += len(word) return total_length"},{"question":"def can_make_elements_equal(arr): Check if it is possible to make all elements of the array equal by performing the allowed operations. Parameters: arr (List[int]): List of integers. Returns: str: 'YES' if it is possible to make all elements equal, otherwise 'NO'. Examples: >>> can_make_elements_equal([3, 3, 3, 3, 3]) 'YES' >>> can_make_elements_equal([1, 2, 4, 3]) 'NO'","solution":"def can_make_elements_equal(arr): Returns 'YES' if it is possible to make all elements equal, otherwise 'NO'. max_elem = max(arr) min_elem = min(arr) if max_elem - min_elem <= 1: return \\"YES\\" else: return \\"NO\\""},{"question":"def longest_substring_with_k_distinct_chars(s: str, k: int) -> int: Returns the length of the longest substring of \`s\` that contains at most \`k\` distinct characters. >>> longest_substring_with_k_distinct_chars(\\"abcba\\", 2) 3 >>> longest_substring_with_k_distinct_chars(\\"aaabbbccc\\", 1) 3 >>> longest_substring_with_k_distinct_chars(\\"eceba\\", 2) 3","solution":"def longest_substring_with_k_distinct_chars(s, k): Returns the length of the longest substring of \`s\` that contains at most \`k\` distinct characters. from collections import defaultdict left = 0 right = 0 max_length = 0 char_count = defaultdict(int) while right < len(s): char_count[s[right]] += 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"def generate_factorials(limit): Generate all factorials less than or equal to a given limit. >>> generate_factorials(10) {1, 2, 6} factorials = set() i = 1 fact = 1 while fact <= limit: factorials.add(fact) i += 1 fact *= i return factorials MAX_VAL = 10**6 factorials = generate_factorials(MAX_VAL) def is_subarray_product_factorial(arr): Check if there exists a contiguous subarray whose product is a factorial number. >>> is_subarray_product_factorial([1, 2, 6, 24, 3, 4]) 'YES' >>> is_subarray_product_factorial([3, 4, 7, 8, 9]) 'NO' n = len(arr) for start in range(n): product = 1 for end in range(start, n): product *= arr[end] if product in factorials: return \\"YES\\" if product > MAX_VAL: break return \\"NO\\" def check_test_cases(test_cases): Evaluate multiple test cases to check for contiguous subarrays whose product is a factorial. >>> check_test_cases([(6, [1, 2, 6, 24, 3, 4]), (5, [3, 4, 7, 8, 9])]) ['YES', 'NO'] results = [] for n, arr in test_cases: results.append(is_subarray_product_factorial(arr)) return results","solution":"import math def generate_factorials(limit): factorials = set() i = 1 fact = 1 while fact <= limit: factorials.add(fact) i += 1 fact *= i return factorials MAX_VAL = 10**6 factorials = generate_factorials(MAX_VAL) def is_subarray_product_factorial(arr): n = len(arr) for start in range(n): product = 1 for end in range(start, n): product *= arr[end] if product in factorials: return \\"YES\\" # If product exceeds max value, no need to check further for this subarray if product > MAX_VAL: break return \\"NO\\" def check_test_cases(test_cases): results = [] for n, arr in test_cases: results.append(is_subarray_product_factorial(arr)) return results"},{"question":"def validate_password(password: str) -> str: Validates the password based on the given rules and returns the number of sections if valid, otherwise returns \\"Invalid Password\\". >>> validate_password(\\"Secure;Pass;worD123\\") 3 >>> validate_password(\\"Invalid Pass;Word\\") \\"Invalid Password\\"","solution":"import re def validate_password(password): Validates the password based on the given rules and returns the number of sections if valid, otherwise returns \\"Invalid Password\\". if len(password) > 100: return \\"Invalid Password\\" sections = password.split(';') for section in sections: if not re.match(\\"^[a-zA-Z0-9]*\\", section): return \\"Invalid Password\\" return len(sections)"},{"question":"def is_prime(n: int) -> bool: Check if a number is a prime number. Args: n (int): The number to check Returns: bool: True if the number is prime, False otherwise Examples: >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(17) True # Implementation here def custom_sort(arr: List[int]) -> List[int]: Sort the array such that all prime numbers appear before all non-prime numbers. Prime numbers should be sorted in ascending order and non-prime numbers in descending order. Args: arr (List[int]): The list of integers to sort Returns: List[int]: The sorted list of integers Examples: >>> custom_sort([3, 11, 4, 6, 7, 2]) [2, 3, 7, 11, 6, 4] >>> custom_sort([12, 17, 19, 13, 16]) [13, 17, 19, 16, 12] # Implementation here","solution":"def is_prime(n): Check if a number is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def custom_sort(arr): Sort the array such that all prime numbers appear before all non-prime numbers. Prime numbers should be sorted in ascending order and non-prime numbers in descending order. primes = [] non_primes = [] for num in arr: if is_prime(num): primes.append(num) else: non_primes.append(num) primes.sort() non_primes.sort(reverse=True) return primes + non_primes"},{"question":"def max_consecutive_primes(n: int, segments: List[int]) -> int: Find the maximum number of consecutive house segments that contain a prime number of houses. >>> max_consecutive_primes(5, [7, 4, 6, 5, 13]) 2 >>> max_consecutive_primes(3, [2, 3, 5]) 3 >>> max_consecutive_primes(4, [8, 10, 4, 6]) 0","solution":"def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while (i * i) <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def max_consecutive_primes(n, segments): primes = [is_prime(seg) for seg in segments] max_count = 0 count = 0 for _ in range(n): if primes[_]: count += 1 if count > max_count: max_count = count else: count = 0 return max_count"},{"question":"def maximalSquare(matrix): Returns the area of the largest square sub-matrix containing only 1s. Example: >>> maximalSquare([ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0] ]) 4 >>> maximalSquare([ [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0] ]) 0","solution":"def maximalSquare(matrix): Returns the area of the largest square sub-matrix containing only 1s. if not matrix or not matrix[0]: return 0 # Dimensions of the matrix rows, cols = len(matrix), len(matrix[0]) # Initialize a 2D dp array with the same dimensions as matrix dp = [[0] * cols for _ in range(rows)] max_side_length = 0 # Fill dp array for i in range(rows): for j in range(cols): if matrix[i][j] == 1: if i == 0 or j == 0: # First row or first column dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side_length = max(max_side_length, dp[i][j]) # The area of the largest square is side_length^2 return max_side_length ** 2"},{"question":"def length_of_longest_substring(s: str) -> int: Given a string s, find the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"abcdefg\\") == 7 >>> length_of_longest_substring(\\"bbbbb\\") == 1 >>> length_of_longest_substring(\\"pwwkew\\") == 3 >>> length_of_longest_substring(\\"\\") == 0 >>> length_of_longest_substring(\\"a\\") == 1 >>> length_of_longest_substring(\\"abba\\") == 2 >>> length_of_longest_substring(\\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\\") == 62","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. start = 0 max_len = 0 used_chars = {} for i, char in enumerate(s): if char in used_chars and start <= used_chars[char]: start = used_chars[char] + 1 else: max_len = max(max_len, i - start + 1) used_chars[char] = i return max_len"},{"question":"def binomial_coefficient(n, k): Returns the binomial coefficient C(n, k). n: int - The total number of items. k: int - The number of items to choose. >>> binomial_coefficient(5, 2) 10 >>> binomial_coefficient(7, 4) 35 >>> binomial_coefficient(10, 5) 252 >>> binomial_coefficient(0, 0) 1 >>> binomial_coefficient(1000, 0) 1 >>> binomial_coefficient(1000, 1000) 1","solution":"import math def binomial_coefficient(n, k): Returns the binomial coefficient C(n, k). if k < 0 or k > n: return 0 # Using symmetry property to minimize the number of calculations k = min(k, n - k) coefficient = 1 for i in range(k): coefficient = coefficient * (n - i) // (i + 1) return coefficient"},{"question":"def manhattan_distance(T, coordinates): Calculates the Manhattan Distance for T test cases. Args: T : int : number of test cases coordinates : list : list of tuple each containing four integers X1, Y1, X2, Y2 Returns: list : list of integers each representing the Manhattan Distance for the corresponding test case >>> manhattan_distance(3, [(1, 2, 3, 4), (-1, -1, 1, 1), (0, 0, -10, 10)]) [4, 4, 20] >>> manhattan_distance(2, [(-1, -2, -3, -4), (-5, -6, -8, -7)]) [4, 4]","solution":"def manhattan_distance(T, coordinates): Calculates the Manhattan Distance for T test cases Args: T : int : number of test cases coordinates : list : list of tuple each containing four integers X1, Y1, X2, Y2 Returns: list : list of integers each representing the Manhattan Distance for the corresponding test case distances = [] for i in range(T): X1, Y1, X2, Y2 = coordinates[i] distance = abs(X2 - X1) + abs(Y2 - Y1) distances.append(distance) return distances"},{"question":"def has_pair_with_sum(arr, K): Returns \\"Yes\\" if there exists a pair of elements in the given array such that their sum is equal to K, otherwise returns \\"No\\". >>> has_pair_with_sum([2, 7, 11, 15, 1], 9) \\"Yes\\" >>> has_pair_with_sum([3, 2, 4, 3], 6) \\"Yes\\" >>> has_pair_with_sum([1, 2, 3, 9], 8) \\"No\\" >>> has_pair_with_sum([1, 2], 4) \\"No\\" >>> has_pair_with_sum([5, 6, -1], 5) \\"Yes\\" ... def process_test_cases(T, test_cases): Processes multiple test cases to determine if each case has a pair of elements whose sum is equal to the specified target. Parameters: - T: Number of test cases - test_cases: A list of tuples where each tuple contains (N, K, arr) Returns: A list of strings \\"Yes\\" or \\"No\\" for each test case. >>> process_test_cases(2, [(5, 9, [2, 7, 11, 15, 1]), (4, 6, [3, 2, 4, 3])]) [\\"Yes\\", \\"Yes\\"] >>> process_test_cases(3, [(4, 8, [1, 2, 3, 9]), (2, 4, [1, 2]), (3, 5, [5, 6, -1])]) [\\"No\\", \\"No\\", \\"Yes\\"] >>> process_test_cases(1, [(5, 0, [5, -5, 10, -10, 20])]) [\\"Yes\\"] ...","solution":"def has_pair_with_sum(arr, K): Returns \\"Yes\\" if there exists a pair of elements in the given array such that their sum is equal to K, otherwise returns \\"No\\". seen = set() for number in arr: if K - number in seen: return \\"Yes\\" seen.add(number) return \\"No\\" def process_test_cases(T, test_cases): Processes multiple test cases to determine if each case has a pair of elements whose sum is equal to the specified target. Parameters: - T: Number of test cases - test_cases: A list of tuples where each tuple contains (N, K, arr) Returns: A list of strings \\"Yes\\" or \\"No\\" for each test case. results = [] for (N, K, arr) in test_cases: results.append(has_pair_with_sum(arr, K)) return results"},{"question":"def longest_palindrome(s: str) -> str: Returns the longest possible palindrome that can be formed using any of the characters in the string. >>> longest_palindrome(\\"abccccdd\\") in [\\"dccaccd\\", \\"dccbccd\\"] True >>> longest_palindrome(\\"a\\") == \\"a\\" True >>> longest_palindrome(\\"ab\\") in [\\"a\\", \\"b\\"] True >>> longest_palindrome(\\"bbbbbbb\\") == \\"bbbbbbb\\" True >>> longest_palindrome(\\"Aa\\") in [\\"a\\", \\"A\\"] True >>> longest_palindrome(\\"aaabbbb\\") in [\\"bbbaabb\\", \\"bbaaabb\\"] True","solution":"def longest_palindrome(s): Returns the longest possible palindrome that can be formed using any of the characters in the string. from collections import Counter char_count = Counter(s) palindrome_half = [] middle_char = \\"\\" for char, count in char_count.items(): if count % 2 == 1 and (middle_char == \\"\\" or char > middle_char): middle_char = char palindrome_half.append(char * (count // 2)) palindrome_half_sorted = sorted(palindrome_half, reverse=True) half = ''.join(palindrome_half_sorted) return half + middle_char + half[::-1]"},{"question":"def largest_even_number(N: int) -> int: Returns the largest possible even number that can be formed by rearranging the digits of N, or -1 if it is not possible to form an even number. >>> largest_even_number(1234) == 4312 >>> largest_even_number(13579) == -1","solution":"def largest_even_number(N): Returns the largest possible even number that can be formed by rearranging the digits of N, or -1 if it is not possible to form an even number. digits = sorted(str(N), reverse=True) for i in range(len(digits)-1, -1, -1): if int(digits[i]) % 2 == 0: # Move the last found even digit to the end to make sure the number is even even_digit = digits.pop(i) result = int(''.join(digits) + even_digit) return result return -1"},{"question":"def find_unique_string_permutations(s): Returns a list of all unique permutations of the given string in lexicographically sorted order. >>> find_unique_string_permutations(\\"abc\\") = ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'] >>> find_unique_string_permutations(\\"aab\\") = ['aab', 'aba', 'baa'] >>> find_unique_string_permutations(\\"\\") = [\\"\\"] >>> find_unique_string_permutations(\\"a\\") = [\\"a\\"] >>> find_unique_string_permutations(\\"aa\\") = [\\"aa\\"] >>> find_unique_string_permutations(\\"aabc\\") = ['aabc', 'aacb', 'abac', 'abca', 'acab', 'acba', 'baac', 'baca', 'bcaa', 'caab', 'caba', 'cbaa']","solution":"def find_unique_string_permutations(s): Returns a list of all unique permutations of the given string in lexicographically sorted order. def permute(prefix, remaining, seen): if not remaining: seen.add(prefix) for i in range(len(remaining)): permute(prefix + remaining[i], remaining[:i] + remaining[i+1:], seen) seen_permutations = set() permute(\\"\\", s, seen_permutations) return sorted(list(seen_permutations))"},{"question":"def min_operations_to_sort(n: int, blocks: List[int]) -> int: Function to find the minimum number of operations required to sort the blocks in increasing order. Parameters: n (int): the number of blocks blocks (List[int]): the sequence of integers representing the initial order of the blocks Returns: int: the minimum number of operations needed to arrange the blocks in increasing order Examples: >>> min_operations_to_sort(5, [4, 3, 1, 5, 2]) 3 >>> min_operations_to_sort(4, [3, 1, 2, 4]) 2 >>> min_operations_to_sort(6, [6, 5, 4, 3, 2, 1]) 5","solution":"def min_operations_to_sort(n, blocks): Function to find the minimum number of operations required to sort the blocks in increasing order. correct_positions = [0] * (n + 1) for i in range(n): correct_positions[blocks[i]] = i sorted_blocks = sorted(blocks) max_length = 0 current_length = 0 last_position = -1 for sorted_block in sorted_blocks: position = correct_positions[sorted_block] if position > last_position: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 last_position = position max_length = max(max_length, current_length) return n - max_length"},{"question":"def max_water_flow(n: int, m: int, S: int, T: int, pipes: List[Tuple[int, int, int]]) -> int: Compute the maximum possible amount of water that can be sent from reservoir S to reservoir T in a network of reservoirs and pipes with given capacities. >>> max_water_flow(4, 5, 1, 4, [(1,2,10), (2,3,5), (3,4,10), (1,3,10), (2,4,5)]) 15 >>> max_water_flow(2, 1, 1, 2, [(1,2,10)]) 10 >>> max_water_flow(3, 2, 1, 3, [(1,2,10), (2,1,1)]) 0 # Your implementation here","solution":"from collections import deque def bfs_capacity_path(capacity, source, sink, parent): visited = [False] * len(capacity) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for v, cap in enumerate(capacity[u]): if not visited[v] and cap > 0: # if not yet visited and there is remaining capacity queue.append(v) visited[v] = True parent[v] = u if v == sink: # reached sink return True return False def edmonds_karp(n, capacity, source, sink): parent = [-1] * n max_flow = 0 while bfs_capacity_path(capacity, source, sink, parent): path_flow = float('Inf') s = sink # Find the maximum flow through the path found by BFS while s != source: path_flow = min(path_flow, capacity[parent[s]][s]) s = parent[s] # update capacities of the edges and reverse edges along the path v = sink while v != source: u = parent[v] capacity[u][v] -= path_flow capacity[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow def max_water_flow(n, m, S, T, pipes): capacity = [[0] * n for _ in range(n)] for u, v, c in pipes: capacity[u-1][v-1] += c # since u, v are 1-indexed in the input and we need 0-indexed return edmonds_karp(n, capacity, S-1, T-1) # Example usage: # n = 4, m = 5, S = 1, T = 4 # pipes = [ # (1, 2, 10), # (2, 3, 5), # (3, 4, 10), # (1, 3, 10), # (2, 4, 5) # ] # print(max_water_flow(n, m, S, T, pipes)) # Output: 15"},{"question":"from typing import List, Tuple def max_evenly_spaced_trees(n: int, occupied_positions: List[int]) -> Tuple[int, List[int]]: Given the number of occupied positions and their coordinates, return the maximum number of evenly spaced trees that can be planted, along with their positions. :param n: The number of occupied positions. :param occupied_positions: List of coordinates of occupied positions. :return: A tuple containing the maximum number of trees and their positions. >>> max_evenly_spaced_trees(3, [10, 20, 30]) (expected_output_tuples) >>> max_evenly_spaced_trees(4, [5, 15, 25, 35]) (expected_output_tuples) pass def solve_planting_cases(test_cases: List[Tuple[int, List[int]]]) -> List[Tuple[int, List[int]]]: Process multiple test cases of finding the maximum number of evenly spaced trees to be planted and their positions. :param test_cases: List of tuples where each tuple contains an integer N and a list of N occupied positions. :return: A list of tuples where each tuple contains the maximum number of trees that can be planted and a list of their positions. >>> solve_planting_cases([(3, [10, 20, 30]), (4, [5, 15, 25, 35])]) [(expected_output_tuple_1), (expected_output_tuple_2)] pass import pytest def test_single_case_no_occupancy(): test_case = [(0, [])] expected_output = [(33334, list(range(3, 100000, 3)))] assert solve_planting_cases(test_case) == expected_output, \\"Failed on no occupancy case.\\" def test_occupied_positions_one(): test_case = [(1, [50000])] result = solve_planting_cases(test_case)[0] assert len(result[1]) > 0, \\"Failed for a single occupied position.\\" def test_occupied_positions_two(): test_case = [(2, [25000, 75000])] result = solve_planting_cases(test_case)[0] assert len(result[1]) > 0, \\"Failed for two occupied positions.\\" def test_all_positions_occupied(): test_case = [(100000, list(range(1, 100001)))] expected_output = [(0, [])] assert solve_planting_cases(test_case) == expected_output, \\"Failed on fully occupied path.\\" def test_sparse_occupied_positions(): test_case = [(5, [1000, 30000, 60000, 90000, 95000])] result = solve_planting_cases(test_case)[0] assert len(result[1]) > 0, \\"Failed for sparse occupancy.\\" def test_dense_occupied_positions(): test_case = [(10, [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000])] result = solve_planting_cases(test_case)[0] assert len(result[1]) > 0, \\"Failed for dense occupancy.\\" if __name__ == \\"__main__\\": pytest.main()","solution":"def max_evenly_spaced_trees(n, occupied_positions): This function accepts the number of occupied positions and their coordinates, and returns the maximum number of evenly spaced trees that can be planted, along with their positions. :param n: Number of occupied positions. :param occupied_positions: List of coordinates of occupied positions. :return: A tuple containing the maximum number of trees and their positions. from itertools import combinations_with_replacement if n == 0: # If no occupied positions, we can potentially plant trees everywhere return (33334, list(range(3, 100000, 3))) max_units = 100000 # Maximum length of the path occupied_positions = set(occupied_positions) best_d = 1 best_positions = [] max_trees = 0 for spacing in range(1, max_units): current_positions = [] for pos in range(spacing, max_units+1, spacing): if pos not in occupied_positions: current_positions.append(pos) if len(current_positions) > max_trees: max_trees = len(current_positions) best_positions = current_positions best_d = spacing return (max_trees, best_positions) def solve_planting_cases(test_cases): This function processes multiple test cases of finding the maximum number of evenly spaced trees to be planted and their positions. :param test_cases: List of tuples where each tuple contains an integer N and a list of N occupied positions. :return: A list of tuples where each tuple contains the maximum number of trees that can be planted and a list of their positions. results = [] for (n, occupied_positions) in test_cases: result = max_evenly_spaced_trees(n, occupied_positions) results.append(result) return results"},{"question":"def game_of_life(grid): Computes the next state of the grid based on the Game of Life rules. Arguments: grid -- A 2D integer array (list of lists) where each cell contains either 1 (live cell) or 0 (dead cell). Returns: A 2D integer array representing the state of the grid after one iteration. >>> game_of_life([ ... [0, 1, 0], ... [0, 0, 1], ... [1, 1, 1]]) [[0, 0, 0], [1, 0, 1], [0, 1, 1]] >>> game_of_life([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0]]) [[0, 0, 0], [0, 0, 0], [0, 0, 0]]","solution":"def game_of_life(grid): Computes the next state of the grid based on the Game of Life rules. N = len(grid) next_state = [[0] * N for _ in range(N)] for r in range(N): for c in range(N): live_neighbors = count_live_neighbors(grid, r, c, N) if grid[r][c] == 1: if live_neighbors < 2 or live_neighbors > 3: next_state[r][c] = 0 else: next_state[r][c] = 1 else: if live_neighbors == 3: next_state[r][c] = 1 else: next_state[r][c] = 0 return next_state def count_live_neighbors(grid, r, c, N): Counts the live neighbors of a given cell in the grid. directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] live_neighbors = 0 for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < N and 0 <= nc < N and grid[nr][nc] == 1: live_neighbors += 1 return live_neighbors # Reading input and printing the output if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) grid = [] index = 1 for i in range(N): row = list(map(int, data[index:index + N])) grid.append(row) index += N next_grid = game_of_life(grid) for row in next_grid: print(' '.join(map(str, row)))"},{"question":"from typing import List, Union def find_pair(nums: List[int], target: int) -> Union[List[int], int]: Determine if there exist two distinct integers in the list that sum up to the target value. If such a pair exists, return the indices of the two numbers in any order. Otherwise, return -1. >>> find_pair([2, 7, 11, 15], 9) [0, 1] >>> find_pair([1, 2, 3, 4, 5], 10) -1 >>> find_pair([3, 2, 4], 6) [1, 2] >>> find_pair([1, 5, 9, -3], 6) [0, 1] >>> find_pair([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 19) [8, 9]","solution":"from typing import List, Union def find_pair(nums: List[int], target: int) -> Union[List[int], int]: # Using a dictionary to store the value and its index num_dict = {} for index, num in enumerate(nums): complement = target - num if complement in num_dict: return [num_dict[complement], index] num_dict[num] = index return -1"},{"question":"def count_vowels(s: str) -> int: Count the number of vowels (a, e, i, o, u) in the string. Args: s (str): The input string consisting of lowercase English letters. Returns: int: The number of vowels in the string. Examples: >>> count_vowels(\\"apple\\") 2 >>> count_vowels(\\"programming\\") 3","solution":"def count_vowels(s): Returns the number of vowels (a, e, i, o, u) in the string s. vowels = 'aeiou' return sum(1 for char in s if char in vowels)"},{"question":"def filter_and_sort_packets(packets, threshold): Filters out the packets with size less than or equal to the given threshold and sorts the remaining packets in descending order based on size. Args: packets (list of tuples): List of packets, where each packet is represented as a tuple (source, destination, size). threshold (int): The size threshold. Returns: list of tuples: The filtered and sorted list of packets. >>> packets1 = [('192.168.0.1', '192.168.0.2', 898), ('192.168.0.3', '192.168.0.4', 450), ('192.168.0.5', '192.168.0.6', 1100)] >>> threshold1 = 500 >>> filter_and_sort_packets(packets1, threshold1) [('192.168.0.5', '192.168.0.6', 1100), ('192.168.0.1', '192.168.0.2', 898)] >>> packets2 = [('10.0.0.1', '10.0.0.2', 300), ('10.0.0.3', '10.0.0.4', 200), ('10.0.0.5', '10.0.0.6', 400)] >>> threshold2 = 350 >>> filter_and_sort_packets(packets2, threshold2) [('10.0.0.5', '10.0.0.6', 400)]","solution":"def filter_and_sort_packets(packets, threshold): Filters out the packets with size less than or equal to the given threshold and sorts the remaining packets in descending order based on size. Args: packets (list of tuples): List of packets, where each packet is represented as a tuple (source, destination, size). threshold (int): The size threshold. Returns: list of tuples: The filtered and sorted list of packets. # Filter packets based on the threshold. filtered_packets = [packet for packet in packets if packet[2] > threshold] # Sort the filtered packets in descending order based on size. sorted_packets = sorted(filtered_packets, key=lambda x: x[2], reverse=True) return sorted_packets"},{"question":"def min_imbalance(n: int, skills: List[int]) -> int: Returns the minimum possible overall imbalance. n: int - number of employees (even) skills: list of int - skill levels of employees Example: >>> min_imbalance(4, [3, 1, 2, 4]) == 2 >>> min_imbalance(6, [10, 20, 30, 40, 50, 60]) == 30","solution":"def min_imbalance(n, skills): Returns the minimum possible overall imbalance. n: int - number of employees (even) skills: list of int - skill levels of employees skills.sort() imbalance = 0 for i in range(0, n, 2): imbalance += skills[i + 1] - skills[i] return imbalance"},{"question":"from typing import List def partitionArray(arr: List[int], n: int, k: int) -> List[List[int]]: Partitions the array into subarrays of length k each and ensures they are in ascending order. Returns an empty list if it is not possible. Parameters: arr (list): The input array of integers. n (int): The size of the input array. k (int): The size of each partition. Returns: list: A list of partitions or an empty list if partitioning is not possible. Example: >>> partitionArray([3, 1, 2, 4, 6, 5, 7, 8, 9], 9, 3) [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> partitionArray([4, 1, 3, 2, 5], 5, 2) []","solution":"def partitionArray(arr, n, k): Partitions the array into subarrays of length k each and ensures they are in ascending order. Returns an empty list if it is not possible. Parameters: arr (list): The input array of integers. n (int): The size of the input array. k (int): The size of each partition. Returns: list: A list of partitions or an empty list if partitioning is not possible. # If the array length is not divisible by k, return [] if n % k != 0: return [] # Sort the array arr.sort() # Create partitions partitions = [] for i in range(0, n, k): partitions.append(arr[i:i+k]) return partitions"},{"question":"def unique_sorted_scores(n: int, scores: List[int]) -> List[int]: Takes an integer n and a list of n positive integers representing scores, removes all the duplicate scores, sorts the remaining scores in ascending order, and returns the sorted list of unique scores. >>> unique_sorted_scores(8, [4, 8, 6, 4, 7, 8, 3, 7]) [3, 4, 6, 7, 8] >>> unique_sorted_scores(5, [1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> unique_sorted_scores(4, [6, 6, 6, 6]) [6] >>> unique_sorted_scores(6, [10, 2, 2, 10, 5, 1]) [1, 2, 5, 10] >>> unique_sorted_scores(1, [9]) [9] >>> unique_sorted_scores(10, [10000, 9999, 10000, 500, 300, 300, 400, 2000, 1000, 400]) [300, 400, 500, 1000, 2000, 9999, 10000]","solution":"def unique_sorted_scores(n, scores): Returns a sorted list of unique scores. Parameters: n (int): The number of scores. scores (list of int): List of scores. Returns: list of int: Sorted list of unique scores. unique_scores = list(set(scores)) unique_scores.sort() return unique_scores"},{"question":"def max_rectangle_area(heights: List[int]) -> int: Calculate the maximum rectangular area in a histogram given the heights of the bars. >>> max_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> max_rectangle_area([2, 4, 2, 4]) 8 pass def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Process a list of test cases and calculate the maximum rectangular area for each. >>> process_test_cases([(2,), (6, [2, 1, 5, 6, 2, 3]), (4, [2, 4, 2, 4])]) [10, 8] >>> process_test_cases([(1,), (4, [2, 1, 2, 3])]) [4] pass","solution":"def max_rectangle_area(heights): Calculate the maximum rectangular area in a histogram given the heights of the bars. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def process_test_cases(test_cases): results = [] for i in range(test_cases[0][0]): _, heights = test_cases[i + 1] results.append(max_rectangle_area(heights)) return results"},{"question":"def longest_divisible_subsequence(arr: List[int], n: int) -> int: Given an integer array \`arr\` and an integer \`n\`, find the length of the longest subsequence of \`arr\` in which every element is divisible by \`n\`. A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. Args: arr (list[int]): The input array of integers. n (int): The integer value to check for divisibility. Returns: int: The length of the longest subsequence of \`arr\` where each element is divisible by \`n\`. Examples: >>> longest_divisible_subsequence([3, 6, 9, 12, 15, 20], 3) 5 >>> longest_divisible_subsequence([3, 6, 9, 12, 15, 20], 5) 2","solution":"def longest_divisible_subsequence(arr, n): Returns the length of the longest subsequence of arr where each element is divisible by n. Parameters: arr (list): The input array of integers. n (int): The integer value to check for divisibility. Returns: int: The length of the longest subsequence where each element is divisible by n. return len([x for x in arr if x % n == 0])"},{"question":"def extract_and_sort_digits(s: str) -> str: Extracts all digits from the input string, sorts them in ascending order, and returns them as a concatenated string. >>> extract_and_sort_digits(\\"a1c2b3e4\\") \\"1234\\" >>> extract_and_sort_digits(\\"abcdef\\") \\"\\" >>> extract_and_sort_digits(\\"987654321\\") \\"123456789\\" >>> extract_and_sort_digits(\\"a1!b@2#c3\\") \\"123\\"","solution":"def extract_and_sort_digits(s): Extracts all digits from the input string, sorts them in ascending order, and returns them as a concatenated string. # Extract digits from the string digits = [char for char in s if char.isdigit()] # Sort the digits sorted_digits = sorted(digits) # Join the sorted digits into a string and return return ''.join(sorted_digits)"},{"question":"from math import gcd from functools import reduce from typing import List, Tuple def min_candies_remaining(n: int, candies: List[int]) -> int: Returns the minimum possible total number of candies left in the jars. >>> min_candies_remaining(4, [1, 2, 3, 4]) 0 >>> min_candies_remaining(3, [10, 10, 10]) 0 pass def process_test_cases(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Process multiple test cases and return results. >>> process_test_cases(2, [(4, [1, 2, 3, 4]), (3, [10, 10, 10])]) [0, 0] pass def test_min_candies_remaining(): assert min_candies_remaining(4, [1, 2, 3, 4]) == 0 assert min_candies_remaining(3, [10, 10, 10]) == 0 assert min_candies_remaining(5, [6, 9, 15, 3, 12]) == 0 assert min_candies_remaining(3, [5, 5, 5]) == 0 assert min_candies_remaining(4, [2, 4, 6, 8]) == 0 def test_process_test_cases(): test_cases = [(4, [1, 2, 3, 4]), (3, [10, 10, 10])] results = process_test_cases(2, test_cases) assert results == [0, 0] test_cases = [(3, [3, 6, 9]), (4, [4, 8, 12, 16])] results = process_test_cases(2, test_cases) assert results == [0, 0]","solution":"from math import gcd from functools import reduce def min_candies_remaining(n, candies): Returns the minimum possible total number of candies left in the jars. # Calculate the greatest common divisor (gcd) of all the candies overall_gcd = reduce(gcd, candies) # If overall GCD is 1, we can reduce all candies to zero if overall_gcd == 1: return 0 else: total_candies = sum(candies) return total_candies % overall_gcd def process_test_cases(t, test_cases): results = [] for i in range(t): n, candies = test_cases[i] results.append(min_candies_remaining(n, candies)) return results"},{"question":"from typing import List, Tuple def can_fulfill_shipments(n: int, m: int, routes: List[Tuple[int, int]], k: int, shipments: List[Tuple[int, int]]) -> str: Determines if a specific set of cargo routes can all be carried out using the available directed routes without changing the direction of any route. Args: n : int : Number of ports m : int : Number of routes routes: List[Tuple[int, int]] : List of routes defined by pairs of ports k : int : Number of required shipments shipments: List[Tuple[int, int]] : List of required shipments defined by pairs of ports Returns: str : \\"Yes\\" if all the shipments can be fulfilled, otherwise \\"No\\". Example: >>> can_fulfill_shipments(4, 5, [(1, 2), (1, 3), (1, 4), (2, 3), (3, 4)], 4, [(1, 2), (1, 3), (1, 4), (2, 4)])[:3] \\"Yes\\" >>> can_fulfill_shipments(4, 5, [(1, 2), (1, 3), (2, 3), (2, 4), (3, 4)], 5, [(1, 2), (1, 3), (1, 4), (2, 3), (3, 2)]) \\"No\\" >>> can_fulfill_shipments(3, 3, [(1, 2), (1, 3), (2, 3)], 3, [(1, 2), (1, 3), (2, 3)])[:3] \\"Yes\\" >>> can_fulfill_shipments(3, 2, [(1, 2), (2, 3)], 3, [(1, 3), (2, 1), (3, 1)]) \\"No\\"","solution":"from collections import defaultdict, deque def can_fulfill_shipments(n, m, routes, k, shipments): adj_list = defaultdict(list) indegree = [0] * (n + 1) # Construct adjacency list and compute indegrees for topological sorting for x, y in routes: adj_list[x].append(y) indegree[y] += 1 # Kahn’s algorithm for topological sorting topo_order = [] zero_indegree_queue = deque([i for i in range(1, n+1) if indegree[i] == 0]) while zero_indegree_queue: node = zero_indegree_queue.popleft() topo_order.append(node) for neighbor in adj_list[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: zero_indegree_queue.append(neighbor) if len(topo_order) != n: return \\"No\\" # It's impossible to obtain a topological sort node_to_position = {node: idx for idx, node in enumerate(topo_order)} # Check if all shipments can be fulfilled for a, b in shipments: if node_to_position[a] > node_to_position[b]: return \\"No\\" result = [\\"Yes\\"] for x, y in routes: if node_to_position[x] < node_to_position[y]: result.append(f\\"{x} {y}\\") else: result.append(f\\"{y} {x}\\") return \\"n\\".join(result)"},{"question":"def count_local_champions(n: int, scores: List[int]) -> int: Returns the number of local champions in the given list of scores. A participant is considered a \\"local champion\\" if their score is strictly greater than both the previous and the following scores. The first and last participants cannot be local champions because they have only one adjacent participant. :param n: An integer representing the number of participants :param scores: A list of integers representing the scores of the participants :return: An integer representing the number of local champions >>> count_local_champions(5, [1, 3, 5, 4, 2]) 1 >>> count_local_champions(6, [10, 20, 15, 25, 30, 28]) 2 >>> count_local_champions(4, [1, 2, 3, 4]) 0 >>> count_local_champions(5, [5, 5, 5, 5, 5]) 0 >>> count_local_champions(7, [1, 3, 2, 4, 5, 3, 1]) 2 >>> count_local_champions(3, [1, 3, 2]) 1","solution":"def count_local_champions(n, scores): Returns the number of local champions in the given list of scores. :param n: An integer representing the number of participants :param scores: A list of integers representing the scores of the participants :return: An integer representing the number of local champions local_champions_count = 0 for i in range(1, n - 1): if scores[i] > scores[i - 1] and scores[i] > scores[i + 1]: local_champions_count += 1 return local_champions_count"},{"question":"def who_wins(W: int, H: int, Ax: int, Ay: int, Bx: int, By: int, Dx: int, Dy: int, board: List[str]) -> str: Determine who reaches the destination first in a grid-based board game. >>> who_wins(4, 4, 0, 0, 3, 0, 3, 3, [\\"....\\", \\".#..\\", \\".#..\\", \\"....\\"]) == \\"Bob\\" >>> who_wins(5, 5, 0, 0, 0, 4, 4, 0, [\\".....\\", \\".#.#.\\", \\".#.#.\\", \\".#.#.\\", \\".....\\"]) == \\"Alice\\" >>> who_wins(3, 3, 0, 0, 2, 0, 1, 1, [\\"...\\", \\"...\\", \\"...\\"]) == \\"Draw\\" # Implementation here","solution":"from collections import deque def bfs(start_x, start_y, destination_x, destination_y, board, W, H): # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(start_x, start_y, 0)]) # (x, y, distance) visited = set((start_x, start_y)) while queue: x, y, distance = queue.popleft() if (x, y) == (destination_x, destination_y): return distance for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < W and 0 <= ny < H and (nx, ny) not in visited and board[ny][nx] == '.': visited.add((nx, ny)) queue.append((nx, ny, distance + 1)) return float('inf') # If no path is found def who_wins(W, H, Ax, Ay, Bx, By, Dx, Dy, board): alice_moves = bfs(Ax, Ay, Dx, Dy, board, W, H) bob_moves = bfs(Bx, By, Dx, Dy, board, W, H) if alice_moves < bob_moves: return \\"Alice\\" elif alice_moves > bob_moves: return \\"Bob\\" else: return \\"Draw\\""},{"question":"def count_palindromic_rearrangements(S: str) -> int: Counts the number of distinct palindromic rearrangements of the string S. >>> count_palindromic_rearrangements(\\"aabb\\") 2 >>> count_palindromic_rearrangements(\\"abc\\") 0 >>> count_palindromic_rearrangements(\\"a\\") 1 >>> count_palindromic_rearrangements(\\"aaabbbccc\\") 0 >>> count_palindromic_rearrangements(\\"aaaa\\") 1 >>> count_palindromic_rearrangements(\\"a\\" * (10**5)) 1 >>> count_palindromic_rearrangements(\\"a\\" * (10**5 - 1) + \\"b\\") 0","solution":"def count_palindromic_rearrangements(S): Counts the number of distinct palindromic rearrangements of the string S. from collections import Counter from math import factorial def factorial_div(numerator, denominator_counts): result = factorial(numerator) for count in denominator_counts: if count > 1: result //= factorial(count) return result # Count occurrences of each character char_count = Counter(S) # Check the number of odd counts odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # If more than one character has an odd count, no palindromic rearrangement is possible if odd_count > 1: return 0 # Calculate half factorial considering the counts of characters half_length = sum(count // 2 for count in char_count.values()) half_counts = [count // 2 for count in char_count.values()] return factorial_div(half_length, half_counts)"},{"question":"def generate_product_code(n: int) -> str: Generates a valid product code of length n where no two consecutive characters are the same. >>> generate_product_code(5) \\"A1B2C\\" >>> generate_product_code(2) \\"A1\\" >>> generate_product_code(1) \\"A\\"","solution":"import string def generate_product_code(n): Generates a valid product code of length n where no two consecutive characters are the same. if n <= 0: return \\"NO\\" chars = string.ascii_uppercase + string.digits code = [] # Initialize by adding alternating characters from uppercase letters and digits for i in range(n): if i % 2 == 0: code.append(chars[i % 26]) else: code.append(chars[26 + (i // 2 % 10)]) return ''.join(code)"},{"question":"def first_revisited_planet(N, S): Returns the number of the first planet that the spaceship will revisit. Parameters: - N: Total number of planets in the circle, numbered from 1 to N. - S: Number of steps the spaceship can travel in the clockwise direction. >>> first_revisited_planet(6, 2) 1 >>> first_revisited_planet(10, 3) 1 >>> first_revisited_planet(5, 4) 1 >>> first_revisited_planet(5, 1000) 1 >>> first_revisited_planet(1000, 1) 1 >>> first_revisited_planet(7, 5) 1","solution":"def first_revisited_planet(N, S): Returns the number of the first planet that the spaceship will revisit. Parameters: - N: Total number of planets in the circle, numbered from 1 to N. - S: Number of steps the spaceship can travel in the clockwise direction. visited_planets = set() current_planet = 1 while True: if current_planet in visited_planets: return current_planet visited_planets.add(current_planet) current_planet = (current_planet + S - 1) % N + 1"},{"question":"def generate_palindromic_pattern(n: int) -> str: Generates a symmetrical palindromic pattern of n rows. Args: n: int - Number of rows for the pattern Returns: str - The symmetrical palindromic pattern >>> print(generate_palindromic_pattern(1)) 1 >>> print(generate_palindromic_pattern(2)) 1 121 >>> print(generate_palindromic_pattern(4)) 1 121 12321 1234321 pass","solution":"def generate_palindromic_pattern(n): Generates a symmetrical palindromic pattern of n rows. Args: n: int - Number of rows for the pattern Returns: str - The symmetrical palindromic pattern lines = [] for i in range(1, n + 1): # First half ascending line = ''.join(str(x) for x in range(1, i + 1)) # Second half descending line += ''.join(str(x) for x in range(i - 1, 0, -1)) # Centering lines.append(line.center(2 * n - 1)) return 'n'.join(lines)"},{"question":"def to_snake_case(lst: List[str]) -> List[str]: Converts a list of mixed case strings to snake_case. >>> to_snake_case([\\"CamelCase\\"]) [\\"camel_case\\"] >>> to_snake_case([\\"exampleString\\"]) [\\"example_string\\"] >>> to_snake_case([\\"YetAnotherExample\\"]) [\\"yet_another_example\\"] >>> to_snake_case([\\"CamelCase\\", \\"exampleString\\", \\"YetAnotherExample\\"]) [\\"camel_case\\", \\"example_string\\", \\"yet_another_example\\"] >>> to_snake_case([\\"UPPERCASE\\", \\"ANOTHERUPPERCASE\\"]) [\\"u_p_p_e_r_c_a_s_e\\", \\"a_n_o_t_h_e_r_u_p_p_e_r_c_a_s_e\\"] >>> to_snake_case([\\"a\\", \\"B\\", \\"c\\"]) [\\"a\\", \\"b\\", \\"c\\"] >>> to_snake_case([]) []","solution":"import re def to_snake_case(lst): Converts a list of mixed case strings to snake_case. snake_case_list = [] pattern = re.compile(r'(?<!^)(?=[A-Z])') for s in lst: snake_case_list.append(pattern.sub('_', s).lower()) return snake_case_list"},{"question":"def longest_alternating_substring(s: str) -> int: Returns the length of the longest alternating substring. >>> longest_alternating_substring('abababab') 8 >>> longest_alternating_substring('aabbaaabba') 2 >>> longest_alternating_substring('abcabcabc') 9 >>> longest_alternating_substring('abbaabba') 2 >>> longest_alternating_substring('a') 1 >>> longest_alternating_substring('aaaa') 1 >>> longest_alternating_substring('ababab') 6 >>> longest_alternating_substring('aaabbbcccddd') 2 >>> longest_alternating_substring('') 0 >>> longest_alternating_substring('ab') 2","solution":"def longest_alternating_substring(s): Returns the length of the longest alternating substring. if not s: return 0 max_length = current_length = 1 for i in range(1, len(s)): if s[i] != s[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 return max(max_length, current_length)"},{"question":"from typing import List def filter_palindromes(strings: List[str]) -> List[str]: Create a function that accepts a list of strings and returns a new list containing only the strings that are palindromes. A palindrome is a word that reads the same backward as forward. Args: strings (list): List of strings to be filtered. Returns: list: List containing palindromes. Example: >>> filter_palindromes([\\"radar\\", \\"apple\\", \\"level\\", \\"world\\", \\"civic\\"]) [\\"radar\\", \\"level\\", \\"civic\\"] >>> filter_palindromes([\\"apple\\", \\"banana\\", \\"carrot\\"]) [] >>> filter_palindromes([]) [] >>> filter_palindromes([\\"a\\", \\"b\\", \\"c\\"]) [\\"a\\", \\"b\\", \\"c\\"] >>> filter_palindromes([\\"Radar\\", \\"Level\\", \\"Civic\\"]) [] >>> filter_palindromes([\\"Madam\\", \\"Racecar\\", \\"Apple\\", \\"Deified\\"]) [] >>> filter_palindromes([\\"madam\\", \\"racecar\\", \\"apple\\", \\"deified\\"]) [\\"madam\\", \\"racecar\\", \\"deified\\"]","solution":"def filter_palindromes(strings): Returns a list containing only the palindromes from the provided list of strings. Args: strings (list): List of strings to be filtered. Returns: list: List containing palindromes. return [s for s in strings if s == s[::-1]]"},{"question":"def filter_integers(lst): Returns a list of integers that are divisible by 3 and have more than one digit. :param lst: List of integers :return: Filtered list of integers >>> filter_integers([3, 12, 18, 30, 5, 7, 2]) [12, 18, 30] >>> filter_integers([1, 2, 4, 5, 7, 8, 10]) [] >>> filter_integers([]) [] >>> filter_integers([12, 24, 36]) [12, 24, 36] >>> filter_integers([-12, -36, 45, 90]) [-12, -36, 45, 90] >>> filter_integers(\\"not a list\\") ValueError: Input must be a list >>> filter_integers([12, 'a', 24, 36]) ValueError: All elements in the list must be integers # Your code here","solution":"def filter_integers(lst): Returns a list of integers that are divisible by 3 and have more than one digit. :param lst: List of integers :return: Filtered list of integers if not isinstance(lst, list): raise ValueError(\\"Input must be a list\\") if not all(isinstance(item, int) for item in lst): raise ValueError(\\"All elements in the list must be integers\\") return [x for x in lst if x % 3 == 0 and (x > 9 or x < -9)]"},{"question":"import ast def check_syntax(code: str) -> str: Determines if a given string is a syntactically valid Python expression or not. >>> check_syntax('print(\\"Hello, World!\\")') 'Valid' >>> check_syntax('for x in range(10') 'Invalid' >>> check_syntax(''' def greet(name): return f'Hello, {name}!' greet('Alice') ''') 'Valid' >>> check_syntax('') 'Valid' >>> check_syntax('a = [1, 2, 3') 'Invalid' >>> check_syntax('import mathnprint(math.sqrt(16))') 'Valid' >>> check_syntax('print(\\"Hello, World!)') 'Invalid' >>> check_syntax('# This is a commentnx = 5') 'Valid'","solution":"import ast def check_syntax(code): Determines if a given string is a syntactically valid Python expression or not. Parameters: code (str): The input string representing a Python expression. Returns: str: \\"Valid\\" if the code is syntactically valid, and \\"Invalid\\" otherwise. try: ast.parse(code) return \\"Valid\\" except SyntaxError: return \\"Invalid\\""},{"question":"def can_split_string(S: str, K: int) -> str: Determine whether it is possible to split the string into K contiguous substrings such that each substring has at least one unique character that doesn't appear in any other substring. >>> can_split_string(\\"abac\\", 2) \\"YES\\" >>> can_split_string(\\"aaaa\\", 2) \\"NO\\" >>> can_split_string(\\"abcabc\\", 3) \\"YES\\" def process_test_cases(test_cases: List[Tuple[str, int]]) -> List[str]: Process multiple test cases and determine if each test case meets the criteria for splitting the strings as described. def main(): T = int(input().strip()) test_cases = [] for _ in range(T): S, K = input().strip().split() K = int(K) test_cases.append((S, K)) results = process_test_cases(test_cases) for res in results: print(res) if __name__ == \\"__main__\\": main()","solution":"def can_split_string(S, K): # Create a set of unique characters in the string S unique_chars = set(S) # If the number of unique characters is less than K, return \\"NO\\" if len(unique_chars) < K: return \\"NO\\" return \\"YES\\" def process_test_cases(test_cases): result = [] for S, K in test_cases: result.append(can_split_string(S, K)) return result # Example input processing and handling of multiple test cases def main(): T = int(input().strip()) test_cases = [] for _ in range(T): S, K = input().strip().split() K = int(K) test_cases.append((S, K)) results = process_test_cases(test_cases) for res in results: print(res) if __name__ == \\"__main__\\": main()"},{"question":"def max_coins(grid: List[List[int]]) -> int: Determine the maximum number of coins that can be collected on a grid-based map from the top-left to the bottom-right corner. Each cell on the grid contains a certain number of coins. Movement is restricted to either right or downward. Args: grid (List[List[int]]): A 2D list representing the grid, where each element is an integer denoting the number of coins in that cell. Returns: int: The maximum number of coins Alvis can collect. Examples: >>> max_coins([ ... [0, 6, 0, 2], ... [0, 1, 4, 8], ... [5, 2, 0, 3], ... [2, 4, 1, 0] ... ]) == 22 >>> max_coins([ ... [4, 2, 1], ... [1, 9, 2], ... [3, 6, 7] ... ]) == 28 >>> max_coins([ ... [0, 2], ... [2, 0] ... ]) == 2","solution":"def max_coins(grid): n = len(grid) # Initialize a dp array with zeros dp = [[0] * n for _ in range(n)] # Fill the dp array dp[0][0] = grid[0][0] for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] dp[0][i] = dp[0][i-1] + grid[0][i] for i in range(1, n): for j in range(1, n): dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1]) return dp[-1][-1]"},{"question":"def canFormTriangle(nums): Determine if any three side lengths from the list can form a non-degenerate triangle. Args: nums (List[int]): List of integers representing side lengths. Returns: bool: True if at least one set of three side lengths can form a triangle, otherwise False. >>> canFormTriangle([2, 1, 2]) True >>> canFormTriangle([1, 2, 3]) False >>> canFormTriangle([3, 4, 5, 6]) True","solution":"def canFormTriangle(nums): Determine if any three side lengths from the list can form a non-degenerate triangle. Args: nums (List[int]): List of integers representing side lengths. Returns: bool: True if at least one set of three side lengths can form a triangle, otherwise False. nums.sort() n = len(nums) for i in range(n - 2): if nums[i] + nums[i + 1] > nums[i + 2]: return True return False"},{"question":"def process_commands(commands: List[str]) -> None: Process a series of commands to manage employee records. >>> commands = [ ... \\"ADD 1 Alice 30 50000\\", ... \\"ADD 2 Bob 40 60000\\", ... \\"ADD 3 Charlie 35 55000\\", ... \\"RETRIEVE 2\\", ... \\"UPDATE 2 65000\\", ... \\"AVERAGE 30 40\\", ... \\"DELETE 2\\" ... ] >>> process_commands(commands) ID: 2, Name: Bob, Age: 40, Salary: 60000 57500.00","solution":"class EmployeeRecordSystem: def __init__(self): self.employees = {} def add_employee(self, emp_id, name, age, salary): if emp_id in self.employees: print(\\"Duplicate ID\\") else: self.employees[emp_id] = {\\"name\\": name, \\"age\\": age, \\"salary\\": salary} def delete_employee(self, emp_id): if emp_id in self.employees: del self.employees[emp_id] else: print(\\"Employee Not Found\\") def update_salary(self, emp_id, new_salary): if emp_id in self.employees: self.employees[emp_id][\\"salary\\"] = new_salary else: print(\\"Employee Not Found\\") def retrieve_employee(self, emp_id): if emp_id in self.employees: emp = self.employees[emp_id] print(f\\"ID: {emp_id}, Name: {emp['name']}, Age: {emp['age']}, Salary: {emp['salary']}\\") else: print(\\"Employee Not Found\\") def average_salary(self, age1, age2): salaries = [emp[\\"salary\\"] for emp in self.employees.values() if age1 <= emp[\\"age\\"] <= age2] if salaries: avg_salary = sum(salaries) / len(salaries) print(f\\"{avg_salary:.2f}\\") else: print(\\"0.00\\") def process_commands(commands): ers = EmployeeRecordSystem() for command in commands: parts = command.split() if parts[0] == \\"ADD\\": _, emp_id, name, age, salary = parts ers.add_employee(int(emp_id), name, int(age), int(salary)) elif parts[0] == \\"DELETE\\": _, emp_id = parts ers.delete_employee(int(emp_id)) elif parts[0] == \\"UPDATE\\": _, emp_id, new_salary = parts ers.update_salary(int(emp_id), int(new_salary)) elif parts[0] == \\"RETRIEVE\\": _, emp_id = parts ers.retrieve_employee(int(emp_id)) elif parts[0] == \\"AVERAGE\\": _, age1, age2 = parts ers.average_salary(int(age1), int(age2))"},{"question":"def is_valid_group_rearrangement(lst: List[int]) -> str: Determine whether it is possible to rearrange the list such that each element group appears exactly once. >>> is_valid_group_rearrangement([1, 1, 2, 2, 1]) \\"Yes\\" >>> is_valid_group_rearrangement([1, 2, 3, 2, 1]) \\"No\\"","solution":"def can_rearrange_groups(lst): from itertools import groupby # Finding unique groups groups = [list(group) for key, group in groupby(lst)] elements_in_groups = [set(group) for group in groups] return all(len(group) == 1 for group in elements_in_groups) # Function to check if the sequence ca be rearranged def is_valid_group_rearrangement(lst): groups = {} # Identifying groups i = 0 while i < len(lst): start = i while i < len(lst) and lst[i] == lst[start]: i += 1 group = tuple(lst[start:i]) if group in groups: groups[group] += 1 else: groups[group] = 1 # If any group appears more than once return No if any(count > 1 for count in groups.values()): return \\"No\\" return \\"Yes\\""},{"question":"def can_rearrange(sequence: List[int]) -> str: Determine if the given list of integers can be rearranged such that for every integer at the i-th position: - If i is even, then the absolute difference with the next integer is equal to 1. - If i is odd, then the absolute difference with the previous integer is equal to 1. Return 'YES' if such a rearrangement is possible, otherwise return 'NO'. >>> can_rearrange([3, 1, 2, 4]) 'YES' >>> can_rearrange([5, 3, 7, 1]) 'NO'","solution":"def can_rearrange(sequence): Returns 'YES' if the sequence can be rearranged to fit the given conditions, 'NO' otherwise. sequence.sort() n = len(sequence) # Check alternate placement of even index even_valid = True for i in range(1, n): if i % 2 != 0 and abs(sequence[i] - sequence[i-1]) != 1: even_valid = False break # Check alternate placement of odd index odd_valid = True for i in range(n - 1): if i % 2 == 0 and abs(sequence[i] - sequence[i+1]) != 1: odd_valid = False break if odd_valid or even_valid: return \\"YES\\" else: return \\"NO\\" # Example usage: # print(can_rearrange([3, 1, 2, 4])) # Expected output: YES # print(can_rearrange([5, 3, 7, 1])) # Expected output: NO"},{"question":"from typing import List def minFinalLength(s: str) -> int: Returns the length of the final string after performing the optimal operations to remove any two adjacent characters that are different. >>> minFinalLength(\\"1100\\") 0 >>> minFinalLength(\\"10101\\") 1 from solution import minFinalLength def test_example_1(): assert minFinalLength(\\"1100\\") == 0 def test_example_2(): assert minFinalLength(\\"10101\\") == 1 def test_only_0s(): assert minFinalLength(\\"0000\\") == 4 def test_only_1s(): assert minFinalLength(\\"1111\\") == 4 def test_alternating_01(): assert minFinalLength(\\"01010101\\") == 0 def test_alternating_10(): assert minFinalLength(\\"10101010\\") == 0 def test_mixed(): assert minFinalLength(\\"110010100000101\\") == 3 def test_empty(): assert minFinalLength(\\"\\") == 0 def test_single_character(): assert minFinalLength(\\"0\\") == 1 assert minFinalLength(\\"1\\") == 1","solution":"def minFinalLength(s): Returns the length of the final string after performing the optimal operations to remove any two adjacent characters that are different. # We count the number of 1s and 0s count_1 = s.count('1') count_0 = s.count('0') # The number of removals will be 2 * minimum of these counts # Since we can remove pairs of '10' or '01' length_of_final_string = len(s) - 2 * min(count_1, count_0) return length_of_final_string"},{"question":"def smallest_palindrome_gte(N: int) -> int: Returns the smallest palindromic number greater than or equal to N. >>> smallest_palindrome_gte(120) 121 >>> smallest_palindrome_gte(543) 545 >>> smallest_palindrome_gte(9) 9 >>> smallest_palindrome_gte(200) 202","solution":"def smallest_palindrome_gte(N): Returns the smallest palindromic number greater than or equal to N. def is_palindrome(num): return str(num) == str(num)[::-1] while True: if is_palindrome(N): return N N += 1"},{"question":"def is_palindromic(num): Check if the number is palindromic. >>> is_palindromic(121) True >>> is_palindromic(1331) True >>> is_palindromic(123) False >>> is_palindromic(1) True >>> is_palindromic(22) True def count_palindromic_numbers(L, R): Count the number of palindromic numbers in the range [L, R]. >>> count_palindromic_numbers(1, 10) 9 >>> count_palindromic_numbers(100, 200) 10 >>> count_palindromic_numbers(10, 20) 1 >>> count_palindromic_numbers(1, 1) 1 >>> count_palindromic_numbers(50, 55) 1 def solve(test_cases): Process multiple test cases and return the results for each in a list. >>> solve([(1, 10), (100, 200)]) [9, 10] >>> solve([(1, 1), (50, 55), (10, 20)]) [1, 1, 1]","solution":"def is_palindromic(num): Check if the number is palindromic. return str(num) == str(num)[::-1] def count_palindromic_numbers(L, R): Count the number of palindromic numbers in the range [L, R]. count = 0 for num in range(L, R + 1): if is_palindromic(num): count += 1 return count def solve(test_cases): Process multiple test cases and return the results for each in a list. results = [] for L, R in test_cases: results.append(count_palindromic_numbers(L, R)) return results"},{"question":"def grid_operations(N: int, initial_grid: List[List[int]], operations: List[List[Union[str, int]]]) -> List[int]: Perform operations on a grid including updates and queries for subgrid sums. Args: N (int): Size of the grid (N x N). initial_grid (List[List[int]]): The initial grid configuration. operations (List[List[Union[str, int]]]): List of operations to perform on the grid. The operations are either updates or queries. Returns: List[int]: Results of the query operations. Example: >>> N = 4 >>> initial_grid = [ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ] >>> operations = [ ... [\\"Query\\", 1, 1, 2, 2], ... [\\"Update\\", 2, 2, 100], ... [\\"Query\\", 1, 1, 2, 2], ... [\\"Query\\", 2, 2, 4, 4], ... [\\"Update\\", 1, 1, 0] ... ] >>> grid_operations(N, initial_grid, operations) [14, 108, 193]","solution":"class Grid: def __init__(self, grid): self.N = len(grid) self.grid = grid def update(self, x, y, v): self.grid[x-1][y-1] = v def query(self, x1, y1, x2, y2): total = 0 for i in range(x1-1, x2): for j in range(y1-1, y2): total += self.grid[i][j] return total def grid_operations(N, initial_grid, operations): grid = Grid(initial_grid) results = [] for op in operations: if op[0] == \\"Update\\": grid.update(op[1], op[2], op[3]) elif op[0] == \\"Query\\": result = grid.query(op[1], op[2], op[3], op[4]) results.append(result) return results"},{"question":"def is_anagram(a: str, b: str) -> bool: Determines if two strings are anagrams of each other. Spaces and punctuations are ignored, and the comparison is case-insensitive. >>> is_anagram(\\"listen\\", \\"silent\\") == True >>> is_anagram(\\"The eyes\\", \\"They see\\") == True >>> is_anagram(\\"Hello, World!\\", \\"Goodbye, World!\\") == False Args: - a (str): The first string to compare. - b (str): The second string to compare. Returns: - bool: True if the strings are anagrams of each other, False otherwise.","solution":"def is_anagram(a: str, b: str) -> bool: Determines if two strings are anagrams of each other. This function ignores spaces and punctuations, and compares strings in a case-insensitive manner. Args: - a (str): The first string to compare. - b (str): The second string to compare. Returns: - bool: True if the strings are anagrams of each other, False otherwise. # Remove spaces and punctuation, and convert to lower case clean_a = ''.join(filter(str.isalnum, a)).lower() clean_b = ''.join(filter(str.isalnum, b)).lower() # Check if sorted characters of both strings are equal return sorted(clean_a) == sorted(clean_b)"},{"question":"def can_form_palindrome(s: str) -> bool: Determine if a string can be rearranged to form a palindrome, ignoring spaces, punctuation, and capitalization. >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> can_form_palindrome(\\"No 'x' in Nixon\\") True","solution":"def can_form_palindrome(s: str) -> bool: from collections import Counter import re # Remove all non-alphanumeric characters and convert to lower case clean_s = re.sub(r'[^a-zA-Z0-9]', '', s).lower() # Count the frequency of each character freq = Counter(clean_s) # Check for the number of characters with odd frequency odd_count = sum(1 for count in freq.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if at most one character has an odd frequency return odd_count <= 1"},{"question":"def min_operations_to_convert(A: str, B: str) -> int: Returns the minimum number of operations required to convert string A to string B using insert, delete, and substitute operations. >>> min_operations_to_convert(\\"sunday\\", \\"saturday\\") 3 >>> min_operations_to_convert(\\"kitten\\", \\"sitting\\") 3 >>> min_operations_to_convert(\\"flaw\\", \\"lawn\\") 2 >>> min_operations_to_convert(\\"\\", \\"abc\\") 3 >>> min_operations_to_convert(\\"abc\\", \\"\\") 3 >>> min_operations_to_convert(\\"abc\\", \\"abc\\") 0 >>> min_operations_to_convert(\\"intention\\", \\"execution\\") 5 >>> min_operations_to_convert(\\"horse\\", \\"ros\\") 3 >>> min_operations_to_convert(\\"\\", \\"\\") 0 >>> min_operations_to_convert(\\"a\\", \\"\\") 1 >>> min_operations_to_convert(\\"\\", \\"a\\") 1 >>> min_operations_to_convert(\\"a\\", \\"b\\") 1 >>> min_operations_to_convert(\\"a\\", \\"a\\") 0","solution":"def min_operations_to_convert(A, B): Returns the minimum number of operations required to convert string A to string B using insert, delete, and substitute operations. m = len(A) n = len(B) # Create a 2D array to store the minimum operations count dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)] # Fill the base cases for i in range(m + 1): dp[i][0] = i # If B is empty, delete all characters from A for j in range(n + 1): dp[0][j] = j # If A is empty, insert all characters of B into A # Fill the rest of the dp array for i in range(1, m + 1): for j in range(1, n + 1): if A[i - 1] == B[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no operation needed else: dp[i][j] = 1 + min( dp[i - 1][j], # Delete dp[i][j - 1], # Insert dp[i - 1][j - 1] # Substitute ) # The answer is in dp[m][n] return dp[m][n]"},{"question":"def reverse_words_in_sentences(n: int, sentences: List[str]) -> List[str]: Reverse the words in each sentence while maintaining the order of sentences. >>> reverse_words_in_sentences(3, [\\"Hello World\\", \\"The quick brown fox\\", \\"Python programming is fun\\"]) ['World Hello', 'fox brown quick The', 'fun is programming Python'] >>> reverse_words_in_sentences(1, [\\"SingleSentence\\"]) ['SingleSentence'] def test_reverse_words_in_sentences(): assert reverse_words_in_sentences(3, [\\"Hello World\\", \\"The quick brown fox\\", \\"Python programming is fun\\"]) == [\\"World Hello\\", \\"fox brown quick The\\", \\"fun is programming Python\\"] assert reverse_words_in_sentences(1, [\\"SingleSentence\\"]) == [\\"SingleSentence\\"] assert reverse_words_in_sentences(2, [\\"First sentence\\", \\"Second sentence\\"]) == [\\"sentence First\\", \\"sentence Second\\"] assert reverse_words_in_sentences(3, [\\"Test case one\\", \\"Another test case\\", \\"Yet another one\\"]) == [\\"one case Test\\", \\"case test Another\\", \\"one another Yet\\"] assert reverse_words_in_sentences(2, [\\"Multiple words here\\", \\"Reversing each word\\"]) == [\\"here words Multiple\\", \\"word each Reversing\\"]","solution":"def reverse_words_in_sentences(n, sentences): reversed_sentences = [] for sentence in sentences: words = sentence.split() reversed_sentence = ' '.join(reversed(words)) reversed_sentences.append(reversed_sentence) return reversed_sentences # Example usage: # n = 3 # sentences = [\\"Hello World\\", \\"The quick brown fox\\", \\"Python programming is fun\\"] # print(reverse_words_in_sentences(n, sentences)) # Output: ['World Hello', 'fox brown quick The', 'fun is programming Python']"},{"question":"def top_student(students: List[dict]) -> str: Returns the name of the student with the highest average score. Args: students (list): A list of dictionaries where each dictionary contains: - 'name': A string representing the student's name. - 'scores': A list of integers representing the student's scores. Returns: str: The name of the student with the highest average score. Examples: >>> top_student([ {\\"name\\": \\"Alice\\", \\"scores\\": [90, 80, 70]}, {\\"name\\": \\"Bob\\", \\"scores\\": [85, 85, 85]}, {\\"name\\": \\"Charlie\\", \\"scores\\": [70, 90, 100]} ]) 'Charlie' >>> top_student([ {\\"name\\": \\"Dana\\", \\"scores\\": [88, 92]}, {\\"name\\": \\"Eli\\", \\"scores\\": [100, 85, 90]}, {\\"name\\": \\"Fay\\", \\"scores\\": [92, 92, 92]} ]) 'Fay' >>> top_student([ {\\"name\\": \\"Alice\\", \\"scores\\": [100]} ]) 'Alice' >>> top_student([ {\\"name\\": \\"Alice\\", \\"scores\\": [90, 90]}, {\\"name\\": \\"Bob\\", \\"scores\\": [90, 90]} ]) 'Alice' import unittest class TestTopStudent(unittest.TestCase): def test_top_student_example_1(self): students = [ {\\"name\\": \\"Alice\\", \\"scores\\": [90, 80, 70]}, {\\"name\\": \\"Bob\\", \\"scores\\": [85, 85, 85]}, {\\"name\\": \\"Charlie\\", \\"scores\\": [70, 90, 100]} ] self.assertEqual(top_student(students), 'Charlie') def test_top_student_example_2(self): students = [ {\\"name\\": \\"Dana\\", \\"scores\\": [88, 92]}, {\\"name\\": \\"Eli\\", \\"scores\\": [100, 85, 90]}, {\\"name\\": \\"Fay\\", \\"scores\\": [92, 92, 92]} ] self.assertEqual(top_student(students), 'Fay') def test_top_student_single_student(self): students = [ {\\"name\\": \\"Alice\\", \\"scores\\": [100]} ] self.assertEqual(top_student(students), 'Alice') def test_top_student_tie(self): students = [ {\\"name\\": \\"Alice\\", \\"scores\\": [90, 90]}, {\\"name\\": \\"Bob\\", \\"scores\\": [90, 90]} ] self.assertEqual(top_student(students), 'Alice') def test_top_student_empty_scores(self): students = [ {\\"name\\": \\"Alice\\", \\"scores\\": []}, {\\"name\\": \\"Bob\\", \\"scores\\": [90, 90]} ] with self.assertRaises(ZeroDivisionError): top_student(students) def test_top_student_negative_scores(self): students = [ {\\"name\\": \\"Alice\\", \\"scores\\": [-10, -20]}, {\\"name\\": \\"Bob\\", \\"scores\\": [-30, -40]} ] self.assertEqual(top_student(students), 'Alice') if __name__ == '__main__': unittest.main()","solution":"def top_student(students): Returns the name of the student with the highest average score. Args: students (list): A list of dictionaries where each dictionary contains: - 'name': A string representing the student's name. - 'scores': A list of integers representing the student's scores. Returns: str: The name of the student with the highest average score. top_name = None top_avg = -float('inf') for student in students: avg_score = sum(student['scores']) / len(student['scores']) if avg_score > top_avg: top_avg = avg_score top_name = student['name'] return top_name"},{"question":"from typing import List def rearrange_plants(s: str) -> str: Rearrange the plants in the forest such that no two identical plants are next to each other if possible. >>> rearrange_plants(\\"aaabb\\") in [\\"ababa\\", \\"babab\\"] True >>> rearrange_plants(\\"aabbcc\\") != \\"\\" True >>> rearrange_plants(\\"aab\\") in [\\"aba\\"] True >>> rearrange_plants(\\"aaab\\") == \\"\\" True >>> rearrange_plants(\\"aaaabb\\") == \\"\\" True >>> rearrange_plants(\\"a\\") == \\"a\\" True >>> rearrange_plants(\\"\\") == \\"\\" True >>> rearrange_plants(\\"aaaa\\") == \\"\\" True >>> rearrange_plants(\\"aabb\\") in [\\"abab\\", \\"baba\\"] True","solution":"from heapq import heappush, heappop from collections import Counter def rearrange_plants(s): if len(s) <= 1: return s # Frequency counter for each character counter = Counter(s) # Priority queue (max-heap) for storing characters by frequency max_heap = [] for char, freq in counter.items(): heappush(max_heap, (-freq, char)) res = [] while len(max_heap) > 1: # Pop the two most frequent characters first_freq, first_char = heappop(max_heap) second_freq, second_char = heappop(max_heap) # Append these characters to the result res.extend([first_char, second_char]) # Decrease their frequencies and push them back into the heap if they have remaining counts if -first_freq > 1: heappush(max_heap, (first_freq + 1, first_char)) if -second_freq > 1: heappush(max_heap, (second_freq + 1, second_char)) # Check if one character is left in the heap if max_heap: last_freq, last_char = heappop(max_heap) if -last_freq > 1: return \\"\\" # Not possible to rearrange if any character count left > 1 res.append(last_char) return ''.join(res)"},{"question":"def subarray_sum_to_zero(arr: List[int]) -> bool: Determines if there is a contiguous subarray that sums to zero. :param arr: List of integers :return: bool - True if such a subarray exists, False otherwise >>> subarray_sum_to_zero([1, 2, -3, 1]) == True >>> subarray_sum_to_zero([0, 1, 2]) == True >>> subarray_sum_to_zero([4, -1, -3, 2, 0]) == True >>> subarray_sum_to_zero([1, 2, 3]) == False >>> subarray_sum_to_zero([1, 1, 1]) == False >>> subarray_sum_to_zero([4, 5, 6, 7]) == False >>> subarray_sum_to_zero([0]) == True >>> subarray_sum_to_zero([1]) == False >>> subarray_sum_to_zero([-1]) == False >>> subarray_sum_to_zero([i for i in range(1, 10001)]) == False >>> subarray_sum_to_zero([i for i in range(1, 5000)] + [-(sum(range(1, 5000)))]) == True","solution":"def subarray_sum_to_zero(arr): Determines if there is a contiguous subarray that sums to zero. :param arr: List of integers :return: bool - True if such a subarray exists, False otherwise seen_sums = set() current_sum = 0 for num in arr: current_sum += num if current_sum == 0 or current_sum in seen_sums: return True seen_sums.add(current_sum) return False"},{"question":"def total_moves(M: int, N: int) -> int: Given dimensions M and N of a table, returns the total number of moves from the top-left to the bottom-right corner. >>> total_moves(2, 2) 2 >>> total_moves(3, 3) 4 >>> total_moves(1, 5) 4 >>> total_moves(1, 1) 0 >>> total_moves(100, 100) 198 pass def solve(test_cases: List[Tuple[int, int]]) -> List[int]: Takes a list of tuples representing test cases. Each tuple contains two integers M and N representing the dimensions of the table. Returns a list of integers where each integer represents the total number of moves for the corresponding test case. >>> solve([(2, 2), (3, 3), (1, 5), (1, 1), (100, 100)]) [2, 4, 4, 0, 198] pass","solution":"def total_moves(M, N): Given dimensions M and N of a table, returns the total number of moves from the top-left to the bottom-right corner. return (M - 1) + (N - 1) def solve(test_cases): Takes a list of tuples representing test cases. Each tuple contains two integers M and N representing the dimensions of the table. Returns a list of integers where each integer represents the total number of moves for the corresponding test case. results = [] for M, N in test_cases: results.append(total_moves(M, N)) return results"},{"question":"def countValidStrings(strings): Count the number of valid strings in the list according to the specified rules. A valid string is defined as one that matches the following criteria: 1. The string must begin with an uppercase letter (A-Z). 2. Every subsequent character must be a lowercase letter (a-z). 3. A hyphenated string is considered valid if each segment separated by hyphens follows the above two rules. >>> countValidStrings([\\"Marie\\", \\"Jean-Paul\\", \\"Anne-Marie\\", \\"jean\\", \\"Paul-anne\\", \\"Alice-Bob-Charles\\"]) == 4 >>> countValidStrings([\\"marie\\", \\"JeanPaul\\", \\"Anne Marie\\", \\"jean\\", \\"Paul-anne\\", \\"alice-bob-charles\\"]) == 0 >>> countValidStrings([]) == 0 >>> countValidStrings([\\"Alice\\"]) == 1 >>> countValidStrings([\\"alice\\"]) == 0 >>> countValidStrings([\\"Jean-Paul\\", \\"Anne-Marie-Claire\\", \\"Bob-Alice\\", \\"jean-Paul\\", \\"Bob-anne-Marie\\"]) == 3","solution":"def countValidStrings(strings): Count the number of valid strings in the list according to the specified rules. Args: strings (list of str): A list of strings to be checked. Returns: int: The count of valid strings. def isValidSegment(segment): # A segment is valid if it starts with an uppercase letter and all subsequent characters are lowercase letters. return segment and segment[0].isupper() and segment[1:].islower() def isValidString(string): # A string is valid if all its segments separated by hyphens are valid. segments = string.split('-') return all(isValidSegment(segment) for segment in segments) return sum(1 for string in strings if isValidString(string))"},{"question":"class MinStack: Initialize your data structure here def __init__(self): Initialize your data structure here. def push(self, x: int) -> None: Push element x onto the stack. :param x: an integer to push onto the stack def pop(self) -> None: Removes the element on the top of the stack. def top(self) -> int: Get the top element. :return: the top element of the stack def getMin(self) -> int: Retrieve the minimum element in the stack. :return: the minimum element in the stack # Unit test cases import pytest def test_min_stack_operations(): min_stack = MinStack() min_stack.push(-2) min_stack.push(0) min_stack.push(-3) assert min_stack.getMin() == -3 # Return -3 min_stack.pop() assert min_stack.top() == 0 # Return 0 assert min_stack.getMin() == -2 # Return -2 min_stack.push(-5) assert min_stack.getMin() == -5 # Return -5 min_stack.pop() assert min_stack.getMin() == -2 # Return -2 def test_min_stack_single_element(): min_stack = MinStack() min_stack.push(1) assert min_stack.getMin() == 1 # Return 1 assert min_stack.top() == 1 # Return 1 min_stack.pop() assert min_stack.getMin() == -1 # Return -1 def test_min_stack_empty_stack(): min_stack = MinStack() assert min_stack.getMin() == -1 # Return -1 assert min_stack.top() == -1 # Return -1","solution":"class MinStack: def __init__(self): Initialize your data structure here. self.stack = [] self.min_stack = [] def push(self, x: int) -> None: Push element x onto the stack. self.stack.append(x) # If the min stack is empty or the new element is smaller or equal to the current min, push it onto the min stack. if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self) -> None: Removes the element on the top of the stack. if self.stack: if self.stack[-1] == self.min_stack[-1]: self.min_stack.pop() self.stack.pop() def top(self) -> int: Get the top element. if self.stack: return self.stack[-1] return -1 # In case the stack is empty def getMin(self) -> int: Retrieve the minimum element in the stack. if self.min_stack: return self.min_stack[-1] return -1 # In case the min stack is empty"},{"question":"def canArrangeMultipleOf3(num: str) -> int: Given a string containing a large number, check whether the digits of the number can be rearranged to form a multiple of 3. Print 1 if possible, otherwise print 0. >>> canArrangeMultipleOf3(\\"120\\") 1 >>> canArrangeMultipleOf3(\\"1001\\") 0","solution":"def canArrangeMultipleOf3(num): Check whether the digits of the number can be rearranged to form a multiple of 3. Returns 1 if possible, otherwise 0. # Calculate the sum of the digits digit_sum = sum(int(digit) for digit in num) # Check if the sum of the digits is divisible by 3 if digit_sum % 3 == 0: return 1 else: return 0"},{"question":"import heapq from typing import List, Tuple def compute_min_times(n: int, m: int, roads: List[Tuple[int, int, int]]) -> List[int]: Computes the minimum travel time from intersection 1 to all other intersections. Parameters: n (int): The number of intersections. m (int): The number of roads. roads (list of tuples): List of tuples where each tuple contains three integers (u, v, t) representing a one-way road from intersection u to intersection v with a travel time of t seconds. Returns: list: A list containing the minimum travel time from the mayor's house (intersection 1) to each intersection 2 to n. If an intersection is unreachable, it returns -1 for that intersection. >>> compute_min_times(5, 6, [(1, 2, 10), (1, 3, 20), (2, 3, 5), (3, 4, 2), (2, 4, 15), (4, 5, 3)]) [10, 15, 17, 20] >>> compute_min_times(4, 3, [(1, 2, 4), (2, 3, 1), (3, 4, 6)]) [4, 5, 11] from solution import compute_min_times def test_example_1(): n = 5 m = 6 roads = [ (1, 2, 10), (1, 3, 20), (2, 3, 5), (3, 4, 2), (2, 4, 15), (4, 5, 3), ] expected = [10, 15, 17, 20] assert compute_min_times(n, m, roads) == expected def test_example_2(): n = 4 m = 3 roads = [ (1, 2, 4), (2, 3, 1), (3, 4, 6), ] expected = [4, 5, 11] assert compute_min_times(n, m, roads) == expected def test_unreachable_intersection(): n = 4 m = 2 roads = [ (1, 2, 4), (2, 3, 1), ] expected = [4, 5, -1] assert compute_min_times(n, m, roads) == expected def test_only_one_intersection(): n = 1 m = 0 roads = [] expected = [] assert compute_min_times(n, m, roads) == expected def test_no_roads(): n = 3 m = 0 roads = [] expected = [-1, -1] assert compute_min_times(n, m, roads) == expected","solution":"import heapq import sys def compute_min_times(n, m, roads): Computes the minimum travel time from intersection 1 to all other intersections. Parameters: n (int): The number of intersections. m (int): The number of roads. roads (list of tuples): List of tuples where each tuple contains three integers (u, v, t) representing a one-way road from intersection u to intersection v with a travel time of t seconds. Returns: list: A list containing the minimum travel time from the mayor's house (intersection 1) to each intersection 2 to n. If an intersection is unreachable, it returns -1 for that intersection. graph = {i: [] for i in range(1, n + 1)} for u, v, t in roads: graph[u].append((v, t)) INF = float('inf') distances = {i: INF for i in range(1, n + 1)} distances[1] = 0 priority_queue = [(0, 1)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) result = [] for i in range(2, n + 1): if distances[i] == INF: result.append(-1) else: result.append(distances[i]) return result"},{"question":"from typing import List def largest_valid_time(s: str) -> str: Given a string of digits, find the largest valid time that can be formed from these digits in a 24-hour format (HH:MM). The time must be valid, and not all digits need to be used. Return \\"Not possible\\" if no valid time can be formed. >>> largest_valid_time(\\"1234\\") \\"23:41\\" >>> largest_valid_time(\\"5023\\") \\"23:50\\" >>> largest_valid_time(\\"1111\\") \\"11:11\\" >>> largest_valid_time(\\"9841\\") \\"19:48\\" >>> largest_valid_time(\\"1112\\") \\"21:11\\" >>> largest_valid_time(\\"1\\") \\"Not possible\\" >>> largest_valid_time(\\"9999\\") \\"Not possible\\" >>> largest_valid_time(\\"123\\") \\"Not possible\\"","solution":"from itertools import permutations def largest_valid_time(s): def is_valid_time(hh, mm): return 0 <= hh < 24 and 0 <= mm < 60 max_time = -1 best_time = \\"Not possible\\" for perm in permutations(s, 4): hh = int(perm[0] + perm[1]) mm = int(perm[2] + perm[3]) if is_valid_time(hh, mm): time_in_minutes = hh * 60 + mm if time_in_minutes > max_time: max_time = time_in_minutes best_time = f\\"{hh:02}:{mm:02}\\" return best_time"},{"question":"def all_unique_characters(strings): Returns a list of \\"Yes\\" or \\"No\\" for each string in the input list, indicating whether the string has all unique characters. >>> all_unique_characters([\\"abcdef\\", \\"hello\\", \\"python\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> all_unique_characters([\\"\\", \\"a\\", \\"aa\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def all_unique_characters(strings): Returns a list of \\"Yes\\" or \\"No\\" for each string in the input list, indicating whether the string has all unique characters. results = [] for string in strings: if len(string) == len(set(string)): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def minimum_swaps(arr: List[int]) -> int: Returns the minimum number of swaps required to sort the array in ascending order. >>> minimum_swaps([4, 3, 1, 2, 5]) 3 >>> minimum_swaps([1, 2, 3, 4, 5]) 0 >>> minimum_swaps([5, 4, 3, 2, 1]) 2 >>> minimum_swaps([1, 1, 1, 1]) 0 >>> minimum_swaps([100]) 0 >>> minimum_swaps([2, 3, 4, 1, 5]) 3","solution":"def minimum_swaps(arr): Returns the minimum number of swaps required to sort the array in ascending order. n = len(arr) # Create a list of tuples where each tuple is (value, index) arr_indexed = [(value, index) for index, value in enumerate(arr)] # Sort the array based on the values arr_indexed.sort() # To keep track of visited elements visited = [False] * n swaps = 0 for i in range(n): # if element is already visited or element is already in the correct position if visited[i] or arr_indexed[i][1] == i: continue # Find the cycle size cycle_size = 0 j = i while not visited[j]: visited[j] = True # Move to the next index according to the original positions j = arr_indexed[j][1] cycle_size += 1 # Adding the number of swaps required for this cycle if cycle_size > 0: swaps += (cycle_size - 1) return swaps"},{"question":"def max_fruits_from_adjacent_trees(n: int, fruits: List[int]) -> int: Returns the maximum number of fruits that can be eaten from any two adjacent trees. Parameters: n (int): The number of trees. fruits (list): A list of integers representing the number of fruits on each tree. Returns: int: The maximum number of fruits that can be eaten from any two adjacent trees. >>> max_fruits_from_adjacent_trees(5, [4, 7, 3, 9, 2]) 12 >>> max_fruits_from_adjacent_trees(3, [2, 8, 6]) 14 >>> max_fruits_from_adjacent_trees(4, [5, 1, 5, 1]) 6","solution":"def max_fruits_from_adjacent_trees(n, fruits): Returns the maximum number of fruits that can be eaten from any two adjacent trees. Parameters: n (int): The number of trees. fruits (list): A list of integers representing the number of fruits on each tree. Returns: int: The maximum number of fruits that can be eaten from any two adjacent trees. max_fruits = 0 for i in range(n - 1): max_fruits = max(max_fruits, fruits[i] + fruits[i + 1]) return max_fruits"},{"question":"def can_convert_to_palindrome(S: str, K: int) -> str: Determines if it is possible to convert string S to a palindrome by performing at most K character replacement operations. Parameters: S (str): Input string K (int): Maximum number of allowed character replacement operations Returns: str: \\"YES\\" if conversion is possible, \\"NO\\" otherwise Examples: >>> can_convert_to_palindrome(\\"abcba\\", 1) 'YES' >>> can_convert_to_palindrome(\\"abcd\\", 1) 'NO' >>> can_convert_to_palindrome(\\"abca\\", 2) 'YES'","solution":"def can_convert_to_palindrome(S, K): Determines if it is possible to convert string S to a palindrome by performing at most K character replacement operations. Parameters: S (str): Input string K (int): Maximum number of allowed character replacement operations Returns: str: \\"YES\\" if conversion is possible, \\"NO\\" otherwise n = len(S) mismatch_count = 0 for i in range(n // 2): if S[i] != S[n - 1 - i]: mismatch_count += 1 return \\"YES\\" if mismatch_count <= K else \\"NO\\""},{"question":"def minimal_total_imbalance(n: int, weights: List[int]) -> int: Calculates the minimal possible total imbalance by pairing bricks optimally. Args: n (int): number of bricks (must be even) weights (list of int): weight of each brick Returns: int: minimal total imbalance >>> minimal_total_imbalance(4, [10, 20, 30, 40]) 20 >>> minimal_total_imbalance(6, [1, 2, 3, 4, 5, 6]) 3 >>> minimal_total_imbalance(4, [1000000000, 1000000001, 1000000002, 1000000003]) 2 >>> minimal_total_imbalance(6, [4, 1, 7, 3, 5, 2]) 4 >>> minimal_total_imbalance(4, [1, 1, 1, 1]) 0 >>> minimal_total_imbalance(4, [10, 10, 10, 20]) 10","solution":"def minimal_total_imbalance(n, weights): Calculates the minimal possible total imbalance by pairing bricks optimally. Args: n (int): number of bricks (must be even) weights (list of int): weight of each brick Returns: int: minimal total imbalance # Sort the weights to pair the closest possible weights weights.sort() total_imbalance = 0 # Pair every two consecutive bricks for i in range(0, n, 2): total_imbalance += abs(weights[i+1] - weights[i]) return total_imbalance"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given a list of integers, return the list where each integer is replaced by the product of every other number in the list except the current integer. This function should solve the problem without using division and ensure the solution has a time complexity better than O(n^2). >>> product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] >>> product_except_self([2, 5, 7]) == [35, 14, 10]","solution":"def product_except_self(nums): n = len(nums) if n == 0: return [] # Initialize the left and right product arrays left = [0] * n right = [0] * n result = [0] * n # Left product array left[0] = 1 for i in range(1, n): left[i] = left[i - 1] * nums[i - 1] # Right product array right[n - 1] = 1 for i in range(n - 2, -1, -1): right[i] = right[i + 1] * nums[i + 1] # Generate result from left and right product arrays for i in range(n): result[i] = left[i] * right[i] return result"},{"question":"def max_profit_days(n, prices): Determines the best days to buy and sell stocks to maximize profit. Args: n : int : Number of days prices : list of int : Stock prices for each day Returns: tuple : (buying day, selling day) to maximize profit, or \\"No transaction possible\\" Examples: >>> max_profit_days(6, [7, 1, 5, 3, 6, 4]) (2, 5) >>> max_profit_days(5, [5, 4, 3, 2, 1]) 'No transaction possible'","solution":"def max_profit_days(n, prices): Determines the best days to buy and sell stocks to maximize profit. Args: n : int : Number of days prices : list of int : Stock prices for each day Returns: tuple : (buying day, selling day) to maximize profit, or \\"No transaction possible\\" if n < 2: return \\"No transaction possible\\" min_price = prices[0] min_day = 1 max_profit = 0 buy_day = 1 sell_day = 1 for i in range(1, n): if prices[i] < min_price: min_price = prices[i] min_day = i + 1 current_profit = prices[i] - min_price if current_profit > max_profit: max_profit = current_profit buy_day = min_day sell_day = i + 1 if max_profit > 0: return buy_day, sell_day else: return \\"No transaction possible\\""},{"question":"def determine_final_order(N: int, M: int, swap_commands: List[Tuple[int, int]]) -> List[int]: Determines the final order of subjects after performing the swap commands. Parameters: N (int): Number of subjects. M (int): Number of swap commands. swap_commands (list of tuples): Each tuple contains two integers x and y denoting the positions to be swapped. Returns: list: Final order of subjects. >>> determine_final_order(5, 3, [(1, 2), (3, 4), (2, 3)]) [2, 4, 1, 3, 5] >>> determine_final_order(3, 1, [(1, 2)]) [2, 1, 3] >>> determine_final_order(4, 4, [(1, 2), (2, 3), (3, 4), (2, 4)]) [2, 1, 4, 3] >>> determine_final_order(1, 0, []) [1] >>> determine_final_order(2, 2, [(1, 2), (1, 2)]) [1, 2]","solution":"def determine_final_order(N, M, swap_commands): Determines the final order of subjects after performing the swap commands. Parameters: N (int): Number of subjects. M (int): Number of swap commands. swap_commands (list of tuples): Each tuple contains two integers x and y denoting the positions to be swapped. Returns: list: Final order of subjects. subjects = list(range(1, N + 1)) for x, y in swap_commands: subjects[x - 1], subjects[y - 1] = subjects[y - 1], subjects[x - 1] return subjects"},{"question":"def count_people_to_remove(test_cases): Given a number of test cases where each case contains the number of people in a queue (N), the minimum height requirement (H), and a list of heights of people in the queue, this function returns a list with the count of people to remove for each test case to meet the height requirement. >>> count_people_to_remove([(5, 120, [110, 130, 150, 90, 180]), (4, 100, [85, 90, 110, 115])]) [2, 2] >>> count_people_to_remove([(3, 100, [120, 130, 140]), (5, 150, [150, 160, 170, 180, 190])]) [0, 0] >>> count_people_to_remove([(3, 200, [100, 150, 180]), (4, 250, [90, 130, 170, 200])]) [3, 4]","solution":"def count_people_to_remove(test_cases): Given a number of test cases where each case contains the number of people in a queue (N), the minimum height requirement (H), and a list of heights of people in the queue, this function returns a list with the count of people to remove for each test case to meet the height requirement. results = [] for case in test_cases: N, H, heights = case count = sum(1 for height in heights if height < H) results.append(count) return results"},{"question":"def longest_chain(edits: List[str], references: List[Tuple[str, str]]) -> int: Find the length of the longest chain of edits recognized by the system. >>> longest_chain([\\"a1\\", \\"b2\\", \\"c3\\", \\"d4\\", \\"e5\\"], [(\\"b2\\", \\"a1\\"), (\\"c3\\", \\"b2\\"), (\\"d4\\", \\"c3\\"), (\\"e5\\", \\"d4\\")]) 5 >>> longest_chain([\\"x1\\", \\"y2\\", \\"z3\\", \\"a4\\"], [(\\"y2\\", \\"x1\\"), (\\"z3\\", \\"y2\\"), (\\"a4\\", \\"x1\\")]) 3","solution":"def longest_chain(edits, references): from collections import defaultdict, deque # Create a dictionary to store the references of each edit references_dict = defaultdict(list) indegree = {edit: 0 for edit in edits} # Populate the dictionary and track indegree for topological sorting for edit1, edit2 in references: references_dict[edit2].append(edit1) indegree[edit1] += 1 # We perform a topological sort using Kahn's algorithm queue = deque([edit for edit in edits if indegree[edit] == 0]) longest_path = {edit: 1 for edit in edits} while queue: current = queue.popleft() for neighbor in references_dict[current]: indegree[neighbor] -= 1 longest_path[neighbor] = max(longest_path[neighbor], longest_path[current] + 1) if indegree[neighbor] == 0: queue.append(neighbor) return max(longest_path.values())"},{"question":"def count_borrowed_books(transaction_log: List[Tuple[int, int, str]]) -> int: Determine how many distinct books are currently borrowed given the transaction log. Each transaction is represented as a tuple of (time, book_id, action) and sorted by time. The action can be either 'borrow' or 'return'. >>> count_borrowed_books([(1, 101, 'borrow'), (2, 102, 'borrow'), (3, 101, 'return'), (4, 103, 'borrow'), (5, 104, 'borrow'), (6, 104, 'return')]) 2 >>> count_borrowed_books([(1, 201, 'borrow'), (2, 202, 'borrow'), (3, 202, 'return'), (4, 201, 'return')]) 0 >>> count_borrowed_books([(1, 301, 'borrow')]) 1 >>> count_borrowed_books([(1, 401, 'borrow'), (2, 402, 'borrow'), (3, 401, 'return'), (4, 402, 'return'), (5, 403, 'borrow')]) 1 >>> count_borrowed_books([(1, 101, 'borrow'), (2, 101, 'return')]) 0","solution":"def count_borrowed_books(transaction_log): borrowed_books = set() for _, book_id, action in transaction_log: if action == 'borrow': borrowed_books.add(book_id) elif action == 'return': borrowed_books.discard(book_id) return len(borrowed_books)"},{"question":"from typing import List def max_product_of_three(arr: List[int]) -> int: Given a list of integers, find the maximum product that can be obtained by multiplying any three distinct integers from the list. :param arr: List of integers :return: Maximum product of three distinct integers >>> max_product_of_three([1, 10, 2, 6, 5, 3]) 300 >>> max_product_of_three([-10, -10, 5, 2]) 500","solution":"from typing import List def max_product_of_three(arr: List[int]) -> int: Returns the maximum product that can be obtained by multiplying any three distinct integers from the list. :param arr: List of integers :return: Maximum product of three distinct integers arr.sort() # The maximum product will be the maximum between: # 1. The product of the three largest numbers # 2. The product of the two smallest numbers (which could be negative) and the largest number return max(arr[-1] * arr[-2] * arr[-3], arr[0] * arr[1] * arr[-1])"},{"question":"def count_target_character(n: int, id_list: list, target_char: str) -> int: Count the occurrences of target_char in a list of identification numbers. >>> count_target_character(3, [\\"abcde\\", \\"fghij\\", \\"klmno\\"], \\"a\\") 1 >>> count_target_character(4, [\\"abcdef\\", \\"bbcdef\\", \\"cbbcdef\\", \\"bbcdeff\\"], \\"b\\") 7 >>> count_target_character(2, [\\"xyz\\", \\"uvw\\"], \\"a\\") 0 >>> count_target_character(3, [\\"aaa\\", \\"aaa\\", \\"aaa\\"], \\"a\\") 9 >>> count_target_character(3, [\\"Abc\\", \\"aBc\\", \\"abC\\"], \\"a\\") 2 >>> count_target_character(0, [], \\"a\\") 0 >>> count_target_character(3, [\\"a\\", \\"b\\", \\"a\\"], \\"a\\") 2","solution":"def count_target_character(n, id_list, target_char): Count the occurrences of target_char in a list of identification numbers. Args: n (int): Number of identification numbers. id_list (List[str]): List of identification numbers. target_char (str): The target character to be counted. Returns: int: Total count of target_char across all identification numbers. count = 0 for id_number in id_list: count += id_number.count(target_char) return count"},{"question":"def manage_stacks(n, queries): Manages multiple stacks based on add, remove, and count operations. Args: n: An integer indicating the number of stacks. queries: A list of query strings with operations \`add\`, \`remove\`, and \`count\`. Returns: A list containing the results of 'count' queries. Examples: >>> manage_stacks(2, [\\"add 1 5\\", \\"add 1 3\\", \\"remove 1\\", \\"count 1\\", \\"count 2\\"]) [1, 0] >>> manage_stacks(3, [\\"add 1 10\\", \\"add 2 20\\", \\"add 3 30\\", \\"count 1\\", \\"count 2\\", \\"remove 3\\", \\"count 3\\"]) [1, 1, 0]","solution":"def manage_stacks(n, queries): Manages multiple stacks based on add, remove, and count operations. Args: n: An integer indicating the number of stacks. queries: A list of query strings with operations \`add\`, \`remove\`, and \`count\`. Returns: A list containing the results of 'count' queries. stacks = [[] for _ in range(n)] results = [] for query in queries: parts = query.split() if parts[0] == \\"add\\": x = int(parts[1]) - 1 y = int(parts[2]) stacks[x].append(y) elif parts[0] == \\"remove\\": x = int(parts[1]) - 1 if stacks[x]: stacks[x].pop() elif parts[0] == \\"count\\": x = int(parts[1]) - 1 results.append(len(stacks[x])) return results"},{"question":"def max_buildings_visit(heights): Determine the maximum number of buildings that can be visited in sequence, where each subsequent building must be taller than the previous one. Parameters: heights (list of int): List of building heights Returns: int: Maximum number of buildings that can be visited in sequence Examples: >>> max_buildings_visit([1, 2, 3, 2, 5, 4]) 3 >>> max_buildings_visit([8, 2, 3, 5, 7]) 4","solution":"def max_buildings_visit(heights): Determine the maximum number of buildings that can be visited in sequence, where each subsequent building must be taller than the previous one. Parameters: heights (list of int): List of building heights Returns: int: Maximum number of buildings that can be visited in sequence if not heights: return 0 max_visits = 1 current_visits = 1 for i in range(1, len(heights)): if heights[i] > heights[i - 1]: current_visits += 1 if current_visits > max_visits: max_visits = current_visits else: current_visits = 1 return max_visits # Example usage: # heights = [1, 2, 3, 2, 5, 4] # print(max_buildings_visit(heights)) # Output: 3 # heights = [8, 2, 3, 5, 7] # print(max_buildings_visit(heights)) # Output: 4"},{"question":"def divisor_shuffle(n): This function takes a number n and returns the shuffled sequence of numbers according to the DivisorShuffle rules. pass def process_test_cases(T, cases): This function processes multiple test cases. pass # Example usage and test cases: # test_divisor_shuffle() # test_process_test_cases() # test_edge_cases()","solution":"def divisor_shuffle(n): This function takes a number n and returns the shuffled sequence of numbers according to the DivisorShuffle rules. divisors = [d for d in range(2, n) if n % d == 0] result = [] for d in divisors: while n >= d: n -= d result.append(d) return sorted(result, reverse=True) def process_test_cases(T, cases): This function processes multiple test cases. results = [] for n in cases: result = divisor_shuffle(n) results.append(result) return results"},{"question":"def collatz_steps(n: int) -> int: Returns the number of steps required to reduce 'n' to 1 using the Collatz conjecture. >>> collatz_steps(1) 0 >>> collatz_steps(6) 8 >>> collatz_steps(7) 16 >>> collatz_steps(19) 20 pass","solution":"def collatz_steps(n: int) -> int: Returns the number of steps required to reduce 'n' to 1 using the Collatz conjecture. steps = 0 while n != 1: if n % 2 == 0: n //= 2 else: n = 3 * n + 1 steps += 1 return steps"},{"question":"from typing import List, Tuple def most_frequent_log_in_window(n: int, t: int, logs: List[Tuple[int, str]]) -> str: Find the most frequent log message within a given time window. Arguments: n : int - the number of log entries t : int - the length of the time window in milliseconds logs : List[Tuple[int, str]] - a list of log entries, where each log entry is a tuple containing a timestamp (integer) and a log message (string) Returns: str - the most frequent log message within the time window. If the log stream is empty, return \\"No logs\\". >>> most_frequent_log_in_window(5, 1000, [(1, 'A'), (1002, 'B'), (2000, 'A'), (3000, 'A'), (4000, 'B')]) 'A' >>> most_frequent_log_in_window(6, 500, [(100, 'A'), (200, 'B'), (300, 'A'), (400, 'C'), (500, 'B'), (600, 'B')]) 'B' >>> most_frequent_log_in_window(1, 1000, [(0, 'A')]) 'A' >>> most_frequent_log_in_window(0, 1000, []) 'No logs'","solution":"from collections import defaultdict, deque def most_frequent_log_in_window(n, t, logs): if n == 0: return \\"No logs\\" logs = sorted(logs, key=lambda x: x[0]) # Sort logs by timestamp frequency_map = defaultdict(int) current_window = deque() max_freq = 0 most_frequent_log = None start_timestamp = logs[0][0] for timestamp, message in logs: while current_window and timestamp - current_window[0][0] > t: old_timestamp, old_message = current_window.popleft() frequency_map[old_message] -= 1 current_window.append((timestamp, message)) frequency_map[message] += 1 if frequency_map[message] > max_freq or (frequency_map[message] == max_freq and (most_frequent_log is None or message < most_frequent_log)): max_freq = frequency_map[message] most_frequent_log = message return most_frequent_log"},{"question":"class DroneFleet: def __init__(self, max_energy_levels): Initialize the fleet with given maximum energy levels. :param max_energy_levels: A list of integers representing the max energy level of each drone self.max_energy_levels = max_energy_levels self.current_energy_levels = max_energy_levels[:] def move(self, drone_id): Decrease the energy level of the specified drone by 1. :param drone_id: The ID of the drone to move (1-indexed) def charge(self, drone_id): Restore the energy level of the specified drone to its maximum capacity. :param drone_id: The ID of the drone to charge (1-indexed) def query(self, drone_id): Get the current energy level of the specified drone. :param drone_id: The ID of the drone to query (1-indexed) :return: The current energy level of the specified drone def handle_operations(n, m, max_energy_levels, operations): Handle a series of operations on a fleet of drones. :param n: The number of drones :param m: The number of charging stations :param max_energy_levels: List of integers representing the max energy levels of the drones :param operations: List of tuples representing the operations to be performed :return: A list of results from the query operations from solution import handle_operations def test_example_case(): n = 5 m = 2 max_energy_levels = [10, 20, 15, 10, 5] operations = [ (1, 2), # Move drone 2, energy level should be 19 (1, 3), # Move drone 3, energy level should be 14 (2, 3), # Charge drone 3, energy level should be 15 (3, 3), # Query drone 3, should return 15 (1, 1), # Move drone 1, energy level should be 9 (3, 1), # Query drone 1, should return 9 (3, 4) # Query drone 4, should return 10 ] assert handle_operations(n, m, max_energy_levels, operations) == [15, 9, 10] def test_all_move_operations(): n = 3 m = 1 max_energy_levels = [5, 10, 20] operations = [ (1, 1), # Move drone 1, energy level should be 4 (1, 1), # Move drone 1, energy level should be 3 (1, 2), # Move drone 2, energy level should be 9 (1, 3), # Move drone 3, energy level should be 19 (3, 1), # Query drone 1, should return 3 (3, 2), # Query drone 2, should return 9 (3, 3) # Query drone 3, should return 19 ] assert handle_operations(n, m, max_energy_levels, operations) == [3, 9, 19] def test_charge_operations(): n = 3 m = 1 max_energy_levels = [5, 10, 20] operations = [ (1, 1), # Move drone 1, energy level should be 4 (1, 1), # Move drone 1, energy level should be 3 (2, 1), # Charge drone 1, energy level should be 5 (max) (3, 1), # Query drone 1, should return 5 (1, 2), # Move drone 2, energy level should be 9 (2, 2), # Charge drone 2, energy level should be 10 (max) (3, 2) # Query drone 2, should return 10 ] assert handle_operations(n, m, max_energy_levels, operations) == [5, 10] def test_multiple_queries(): n = 2 m = 1 max_energy_levels = [5, 10] operations = [ (3, 1), # Query drone 1, should return 5 (3, 2), # Query drone 2, should return 10 (1, 1), # Move drone 1, energy level should be 4 (3, 1), # Query drone 1, should return 4 (1, 1), # Move drone 1, energy level should be 3 (1, 2), # Move drone 2, energy level should be 9 (3, 1), # Query drone 1, should return 3 (3, 2) # Query drone 2, should return 9 ] assert handle_operations(n, m, max_energy_levels, operations) == [5, 10, 4, 3, 9]","solution":"class DroneFleet: def __init__(self, max_energy_levels): Initialize the fleet with given maximum energy levels. :param max_energy_levels: A list of integers representing the max energy level of each drone self.max_energy_levels = max_energy_levels self.current_energy_levels = max_energy_levels[:] def move(self, drone_id): Decrease the energy level of the specified drone by 1. :param drone_id: The ID of the drone to move (1-indexed) if self.current_energy_levels[drone_id - 1] > 0: self.current_energy_levels[drone_id - 1] -= 1 def charge(self, drone_id): Restore the energy level of the specified drone to its maximum capacity. :param drone_id: The ID of the drone to charge (1-indexed) self.current_energy_levels[drone_id - 1] = self.max_energy_levels[drone_id - 1] def query(self, drone_id): Get the current energy level of the specified drone. :param drone_id: The ID of the drone to query (1-indexed) :return: The current energy level of the specified drone return self.current_energy_levels[drone_id - 1] def handle_operations(n, m, max_energy_levels, operations): fleet = DroneFleet(max_energy_levels) results = [] for operation in operations: op_type, drone_id = operation if op_type == 1: fleet.move(drone_id) elif op_type == 2: fleet.charge(drone_id) elif op_type == 3: results.append(fleet.query(drone_id)) return results"},{"question":"def encode_string(s: str) -> str: Encodes the string using Run-Length Encoding (RLE). Parameters: s (str): The input string consisting of only lowercase English letters. Returns: str: The RLE compressed version of the input string. Examples: >>> encode_string(\\"aaabbccc\\") 'a3b2c3' >>> encode_string(\\"aabb\\") 'a2b2' >>> encode_string(\\"abcd\\") 'a1b1c1d1' pass # Unit Test def test_encode_string(): assert encode_string(\\"aaabbccc\\") == \\"a3b2c3\\" assert encode_string(\\"aabb\\") == \\"a2b2\\" assert encode_string(\\"abcd\\") == \\"a1b1c1d1\\" assert encode_string(\\"a\\") == \\"a1\\" assert encode_string(\\"aa\\") == \\"a2\\" assert encode_string(\\"aaa\\") == \\"a3\\" assert encode_string(\\"aabba\\") == \\"a2b2a1\\" assert encode_string(\\"\\") == \\"\\" assert encode_string(\\"zzzzzz\\") == \\"z6\\" assert encode_string(\\"abcdefghijklmnopqrstuvwxyz\\") == \\"a1b1c1d1e1f1g1h1i1j1k1l1m1n1o1p1q1r1s1t1u1v1w1x1y1z1\\" def test_encode_string_large_input(): large_input = \\"a\\" * 10**6 expected_output = \\"a1000000\\" assert encode_string(large_input) == expected_output mixed_large_input = \\"a\\" * 500000 + \\"b\\" * 500000 expected_output = \\"a500000b500000\\" assert encode_string(mixed_large_input) == expected_output def test_encode_string_edge_cases(): assert encode_string(\\"a\\"*10**6 + \\"b\\"*10**6) == \\"a1000000b1000000\\" assert encode_string(\\"a\\"*500000 + \\"b\\"*500001) == \\"a500000b500001\\"","solution":"def encode_string(s: str) -> str: Encodes the string using Run-Length Encoding (RLE). Parameters: s (str): The input string consisting of only lowercase English letters. Returns: str: The RLE compressed version of the input string. if not s: return \\"\\" encoded_string = [] current_char = s[0] current_count = 1 for char in s[1:]: if char == current_char: current_count += 1 else: encoded_string.append(current_char + str(current_count)) current_char = char current_count = 1 encoded_string.append(current_char + str(current_count)) return ''.join(encoded_string)"},{"question":"from typing import List def get_permutations(s: str) -> List[str]: Returns all possible permutations of the characters in the input string. >>> get_permutations(\\"\\") [\\"\\"] >>> get_permutations(\\"a\\") [\\"a\\"] >>> get_permutations(\\"ab\\") [\\"ab\\", \\"ba\\"] >>> get_permutations(\\"abc\\") [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] >>> get_permutations(\\"aab\\") [\\"aab\\", \\"aba\\", \\"baa\\"] >>> get_permutations(\\"abcd\\") [\\"abcd\\", \\"abdc\\", \\"acbd\\", \\"acdb\\", \\"adbc\\", \\"adcb\\", \\"bacd\\", \\"badc\\", \\"bcad\\", \\"bcda\\", \\"bdac\\", \\"bdca\\", \\"cabd\\", \\"cadb\\", \\"cbad\\", \\"cbda\\", \\"cdab\\", \\"cdba\\", \\"dabc\\", \\"dacb\\", \\"dbac\\", \\"dbca\\", \\"dcab\\", \\"dcba\\"]","solution":"from itertools import permutations def get_permutations(s): Returns all possible permutations of the characters in the input string. return [''.join(p) for p in permutations(s)]"},{"question":"import math from typing import List def canRearrange(arr: List[int]) -> str: Given a list of integers, determine whether the list can be rearranged so that each pair of consecutive elements has at least one element in common. Two elements have something in common if their greatest common divisor (GCD) is greater than 1. If possible to rearrange, return \\"YES\\". Otherwise, return \\"NO\\". >>> canRearrange([12, 15, 18, 30]) \\"YES\\" >>> canRearrange([7, 19, 23, 29]) \\"NO\\" >>> canRearrange([7]) \\"YES\\" >>> canRearrange([8, 4]) \\"YES\\" >>> canRearrange([8, 7]) \\"NO\\" >>> canRearrange([6, 9, 15, 10, 25]) \\"YES\\" >>> canRearrange([35, 17, 9, 4, 22]) \\"NO\\"","solution":"import math from itertools import permutations def canRearrange(arr): Determines if the array can be rearranged so that each pair of consecutive elements have GCD > 1. for perm in permutations(arr): is_possible = True for i in range(1, len(perm)): if math.gcd(perm[i - 1], perm[i]) <= 1: is_possible = False break if is_possible: return \\"YES\\" return \\"NO\\""},{"question":"def is_scarecrow_position_valid(scarecrow: tuple, corners: List[tuple]) -> str: Determines if the scarecrow is positioned in such a way that it can see all four sides of a given rectangular field. :param scarecrow: tuple (x, y), coordinates of the scarecrow. :param corners: list of four tuples [(x1, y1), (x2, y2), (x3, y3), (x4, y4)], coordinates of the rectangle's corners. :return: \\"VALID\\" if the scarecrow can see all four sides, \\"INVALID\\" otherwise. >>> is_scarecrow_position_valid((4, 4), [(2, 2), (6, 2), (6, 6), (2, 6)]) 'VALID' >>> is_scarecrow_position_valid((3, 3), [(1, 1), (5, 1), (5, 4), (1, 4)]) 'VALID' >>> is_scarecrow_position_valid((0, 0), [(0, 0), (4, 0), (4, 4), (0, 4)]) 'INVALID' >>> is_scarecrow_position_valid((5, 3), [(1, 1), (4, 1), (4, 4), (1, 4)]) 'INVALID'","solution":"def is_scarecrow_position_valid(scarecrow, corners): Determines if the scarecrow is positioned in such a way that it can see all four sides of a given rectangular field. :param scarecrow: tuple (x, y), coordinates of the scarecrow. :param corners: list of four tuples [(x1, y1), (x2, y2), (x3, y3), (x4, y4)], coordinates of the rectangle's corners. :return: \\"VALID\\" if the scarecrow can see all four sides, \\"INVALID\\" otherwise. x, y = scarecrow x_coords = [corner[0] for corner in corners] y_coords = [corner[1] for corner in corners] min_x, max_x = min(x_coords), max(x_coords) min_y, max_y = min(y_coords), max(y_coords) # The scarecrow should be inside the boundary of the rectangle and not on the edges if min_x < x < max_x and min_y < y < max_y: return \\"VALID\\" else: return \\"INVALID\\""},{"question":"def quirky_numbers_replacement(lst): Given a list of integers, replace each integer with the largest quirky number less than or equal to it. >>> quirky_numbers_replacement([5, 13, 21]) [2, 12, 20] >>> quirky_numbers_replacement([2, 6, 10, 25]) [2, 6, 6, 20]","solution":"def quirky_numbers_replacement(lst): Given a list of integers, replace each integer with the largest quirky number less than or equal to it. def closest_quirky_number(x): m = 1 while m * (m + 1) <= x: m += 1 return (m - 1) * m return [closest_quirky_number(num) for num in lst] # Example usage: # n = 3 # lst = [5, 13, 21] # print(quirky_numbers_replacement(lst)) # Output: [2, 12, 20]"},{"question":"import heapq from typing import List, Tuple def dijkstra(N: int, M: int, roads: List[Tuple[int, int, int]]) -> List[int]: Determine the shortest distance for each house from house 1. Args: N (int): Number of houses. M (int): Number of one-way roads. roads (List[Tuple[int, int, int]]): List of tuples representing the roads, where each tuple contains (u, v, length) meaning a one-way road from u to v with length. Returns: List[int]: List of shortest distances from house 1 to each house (2 to N). If a house is unreachable, the distance should be -1. Example: >>> dijkstra(4, 4, [(1, 2, 2), (1, 3, 4), (2, 4, 1), (3, 4, 2)]) [2, 4, 3] >>> dijkstra(4, 2, [(1, 2, 2), (2, 3, 2)]) [2, 4, -1] >>> dijkstra(3, 0, []) [-1, -1] >>> dijkstra(5, 6, [(1, 2, 1), (1, 3, 2), (2, 3, 1), (2, 4, 2), (3, 4, 1), (4, 5, 2)]) [1, 2, 3, 5]","solution":"import heapq def dijkstra(N, M, roads): graph = {i: [] for i in range(1, N + 1)} for u, v, length in roads: graph[u].append((v, length)) distances = {i: float('inf') for i in range(1, N + 1)} distances[1] = 0 priority_queue = [(0, 1)] # (distance, node) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) result = [] for i in range(2, N + 1): if distances[i] == float('inf'): result.append(-1) else: result.append(distances[i]) return result"},{"question":"def count_max_zero_paths(grid: List[List[int]]) -> int: Determine the number of valid paths from the top-left cell to the bottom-right cell of the grid that pass through the greatest number of zero-value cells. >>> count_max_zero_paths([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> count_max_zero_paths([[0, 1, 0], [0, 0, 0]]) 1 >>> count_max_zero_paths([[1, 0], [0, 0]]) 0","solution":"def count_max_zero_paths(grid): def dfs(x, y, zero_count): nonlocal max_zeros nonlocal max_paths if x >= n or y >= m or grid[x][y] == 1: return if x == n - 1 and y == m - 1: zero_count += 1 if zero_count > max_zeros: max_zeros = zero_count max_paths = 1 elif zero_count == max_zeros: max_paths += 1 return grid[x][y] = 1 # Visited mark to avoid repeat visits dfs(x + 1, y, zero_count + 1) dfs(x, y + 1, zero_count + 1) grid[x][y] = 0 # Backtrack to explore other paths n = len(grid) m = len(grid[0]) if grid[0][0] == 1 or grid[n - 1][m - 1] == 1: return 0 max_zeros = 0 max_paths = 0 dfs(0, 0, 0) return max_paths"},{"question":"def min_total_cost(n, product_names, m, offers): Determines the minimum total cost of purchasing one unit of each product. Parameters: - n (int): Number of different products. - product_names (list of str): List of product names. - m (int): Number of offers from sellers. - offers (list of tuple of (str, int)): List of offers as (product_name, price). Returns: - int: Minimum total cost to purchase one unit of each product. >>> min_total_cost(3, [\\"apple\\", \\"banana\\", \\"orange\\"], 5, [(\\"apple\\", 50), (\\"banana\\", 30), (\\"orange\\", 20), (\\"apple\\", 40), (\\"orange\\", 25)]) 90 >>> min_total_cost(1, [\\"apple\\"], 3, [(\\"apple\\", 50), (\\"apple\\", 40), (\\"apple\\", 60)]) 40 >>> min_total_cost(2, [\\"car\\", \\"bike\\"], 4, [(\\"car\\", 100), (\\"car\\", 90), (\\"bike\\", 50), (\\"bike\\", 40)]) 130 >>> min_total_cost(1, [\\"computer\\"], 0, []) inf >>> min_total_cost(2, [\\"table\\", \\"chair\\"], 2, [(\\"table\\", 70), (\\"lamp\\", 30)]) inf","solution":"def min_total_cost(n, product_names, m, offers): Determines the minimum total cost of purchasing one unit of each product. Parameters: - n (int): Number of different products. - product_names (list of str): List of product names. - m (int): Number of offers from sellers. - offers (list of tuple of (str, int)): List of offers as (product_name, price). Returns: - int: Minimum total cost to purchase one unit of each product. # Dictionary to store the minimum price of each product min_prices = {product: float('inf') for product in product_names} # Update the minimum price for each product based on the offers for product, price in offers: if product in min_prices: min_prices[product] = min(min_prices[product], price) # Calculate the total cost by summing the minimum prices of all products total_cost = sum(min_prices[product] for product in product_names) return total_cost"},{"question":"def bitwise_and(A: str, B: str) -> str: You are given two binary strings A and B of the same length. Your task is to find the binary string which is the result of bitwise AND operation on them. Example 1: >>> bitwise_and(\\"1101\\", \\"1011\\") \\"1001\\" Example 2: >>> bitwise_and(\\"111\\", \\"000\\") \\"000\\"","solution":"def bitwise_and(A: str, B: str) -> str: Returns the binary string resulting from the bitwise AND operation between two binary strings A and B. return ''.join('1' if a == '1' and b == '1' else '0' for a, b in zip(A, B))"},{"question":"def find_paths(grid): Determine the number of distinct paths from the top-left corner to the bottom-right corner such that the player only passes through empty cells. Args: grid (List[List[int]]): A square grid represented by an n x n matrix of integers (0 for empty, 1 for blocked). Returns: int: The number of distinct paths from the top-left corner to the bottom-right corner. Examples: >>> find_paths([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 2 >>> find_paths([ ... [0, 1, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 1","solution":"def find_paths(grid): n = len(grid) if grid[0][0] == 1 or grid[-1][-1] == 1: return 0 dp = [[0] * n for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(n): if grid[i][j] == 0: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"def find_nth_element(n: int) -> int: Returns the n-th element of the sequence A, modulo 10^9 + 7. >>> find_nth_element(0) == 1 True >>> find_nth_element(1) == 2 True >>> find_nth_element(2) == 4 True >>> find_nth_element(3) == 8 True","solution":"MOD = 10**9 + 7 def find_nth_element(n): Returns the n-th element of the sequence A, modulo 10^9 + 7. if n == 0: return 1 elif n == 1: return 2 a0, a1 = 1, 2 for i in range(2, n + 1): a0, a1 = a1, (a1 + 2 * a0) % MOD return a1"},{"question":"def max_strength_difference_in_pairs(test_cases): Determine the maximum strength difference within each pair of knights. Args: test_cases: List of tuples where each tuple contains an integer N and a list of strengths of knights. Returns: A list of integers where each integer represents the maximum strength difference within each pair for each test case. >>> test_cases = [(4, [10, 20, 30, 40]), (5, [8, 7, 6, 5, 4])] >>> max_strength_difference_in_pairs(test_cases) [10, 1] >>> test_cases = [(2, [1, 1000])] >>> max_strength_difference_in_pairs(test_cases) [999]","solution":"def max_strength_difference_in_pairs(test_cases): results = [] for case in test_cases: N, strengths = case strengths.sort() max_diff = 0 for i in range(1, N, 2): diff = strengths[i] - strengths[i-1] if diff > max_diff: max_diff = diff results.append(max_diff) return results"},{"question":"def calculate_anomaly_scores(sequences: List[List[int]]) -> List[int]: Calculates the anomaly score for each sequence of sensor readings. Parameters: sequences (list of list of int): A list containing multiple lists, each representing a sequence of sensor readings. Returns: list of int: A list containing the anomaly scores for each sequence. >>> calculate_anomaly_scores([[10, 20, 10, 30, 40], [12, 15, 12, 13], [1, 5, 3]]) [20, 3, 4] >>> calculate_anomaly_scores([[10, 10, 10, 10]]) [0] >>> calculate_anomaly_scores([[1, 2]]) [1] >>> calculate_anomaly_scores([[10000, 0, 5000, 10000]]) [10000] >>> calculate_anomaly_scores([[5, 5, 5, 5, 5]]) [0] >>> calculate_anomaly_scores([[1, 100, 1, 100, 1]]) [99]","solution":"def calculate_anomaly_scores(sequences): Calculates the anomaly score for each sequence of sensor readings. Parameters: sequences (list of list of int): A list containing multiple lists, each representing a sequence of sensor readings. Returns: list of int: A list containing the anomaly scores for each sequence. scores = [] for sequence in sequences: max_diff = 0 for i in range(1, len(sequence)): diff = abs(sequence[i] - sequence[i-1]) if diff > max_diff: max_diff = diff scores.append(max_diff) return scores"},{"question":"def nested_sum(lst): Returns the sum of all integers in a nested list of integers. >>> nested_sum([1, [2, [3, 4]], 5, [6]]) 21 >>> nested_sum([[1, 2], [3, 4, [5, 6]], 7, 8]) 36","solution":"def nested_sum(lst): Returns the sum of all integers in a nested list of integers. total = 0 for element in lst: if isinstance(element, list): total += nested_sum(element) else: total += element return total"},{"question":"def can_reach_edge(M, N, grid, start_x, start_y): Determines if the robot can reach any edge of the grid from the starting position. Args: M (int): number of rows in the grid. N (int): number of columns in the grid. grid (List[List[int]]): MxN grid where 0 denotes an open cell and 1 denotes a blocked cell. start_x (int): starting row position of the robot. start_y (int): starting column position of the robot. Returns: str: \\"yes\\" if the robot can reach any edge of the grid, otherwise \\"no\\". Examples: >>> can_reach_edge(5, 4, [ [0, 0, 1, 0], [1, 0, 0, 0], [0, 1, 0, 1], [0, 0, 0, 0], [0, 1, 1, 0] ], 1, 1) \\"yes\\" >>> can_reach_edge(3, 3, [ [1, 1, 1], [1, 0, 1], [1, 1, 1] ], 1, 1) \\"no\\"","solution":"def can_reach_edge(M, N, grid, start_x, start_y): Determines if the robot can reach any edge of the grid from the starting position. from collections import deque # Directions for moving in 8 possible directions (up, down, left, right, and 4 diagonals) directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)] # Check if we are starting on an edge if start_x == 0 or start_x == M-1 or start_y == 0 or start_y == N-1: return \\"yes\\" # Initialize the queue for BFS queue = deque([(start_x, start_y)]) # A set to track visited cells visited = {(start_x, start_y)} while queue: x, y = queue.popleft() # Check all 8 possible directions for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < M and 0 <= ny < N and (nx, ny) not in visited and grid[nx][ny] == 0: # If we reach any edge cell if nx == 0 or nx == M-1 or ny == 0 or ny == N-1: return \\"yes\\" visited.add((nx, ny)) queue.append((nx, ny)) return \\"no\\" # Note: The function expects to be called like this: # result = can_reach_edge(M, N, grid, start_x, start_y) # print(result)"},{"question":"def can_schedule_tasks(test_cases): Determine if all tasks can be scheduled without conflict. Args: test_cases (List[List[Tuple[int, int]]]): List of test cases, each containing a list of tasks represented by (start, end) time. Returns: List[str]: List containing \\"Yes\\" or \\"No\\" for each test case. >>> input_data = \\"2n3n1 3n2 5n6 8n2n2 4n4 6n\\" >>> test_cases = process_input(input_data) >>> can_schedule_tasks(test_cases) ['No', 'Yes'] pass def process_input(input_data): Parse the input data into the required format for scheduling tasks. Args: input_data (str): Multiline string of input data. Returns: List[List[Tuple[int, int]]]: Parsed test cases. >>> input_data = \\"2n3n1 3n2 5n6 8n2n2 4n4 6n\\" >>> process_input(input_data) [[(1, 3), (2, 5), (6, 8)], [(2, 4), (4, 6)]] pass","solution":"def can_schedule_tasks(test_cases): results = [] for case in test_cases: case.sort(key=lambda x: x[0]) conflict = False for i in range(1, len(case)): if case[i-1][1] > case[i][0]: conflict = True break if conflict: results.append(\\"No\\") else: results.append(\\"Yes\\") return results def process_input(input_data): lines = input_data.split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(lines[index]) index += 1 case = [] for _ in range(N): S, E = map(int, lines[index].split()) case.append((S, E)) index += 1 test_cases.append(case) return test_cases"},{"question":"def fibonacci_even_sum(n: int) -> int: Returns the sum of the even-valued terms in the Fibonacci sequence up to, but not including, the given number n. Parameters: n (int): The upper limit (exclusive) for the Fibonacci sequence terms. Returns: int: The sum of the even-valued Fibonacci terms less than n. Example: >>> fibonacci_even_sum(10) 10 >>> fibonacci_even_sum(100) 44 pass","solution":"def fibonacci_even_sum(n): Returns the sum of the even-valued terms in the Fibonacci sequence up to, but not including, the given number n. Parameters: n (int): The upper limit (exclusive) for the Fibonacci sequence terms. Returns: int: The sum of the even-valued Fibonacci terms less than n. # Init first two Fibonacci numbers a, b = 0, 1 even_sum = 0 # While the next Fibonacci number is less than n while a < n: if a % 2 == 0: even_sum += a a, b = b, a + b # Move to next Fibonacci number return even_sum"},{"question":"def edit_distance(A, B): Computes the edit distance (Levenshtein Distance) between two strings A and B. Given two strings A and B, this function returns the minimum number of single-character edits (insertions, deletions, or substitutions) required to transform string A into string B. >>> edit_distance(\\"abc\\", \\"abc\\") 0 >>> edit_distance(\\"abc\\", \\"abcd\\") 1 >>> edit_distance(\\"abcd\\", \\"abc\\") 1 >>> edit_distance(\\"abc\\", \\"adc\\") 1 >>> edit_distance(\\"kitten\\", \\"sitting\\") 3 >>> edit_distance(\\"\\", \\"\\") 0 >>> edit_distance(\\"intention\\", \\"execution\\") 5","solution":"def edit_distance(A, B): Computes the edit distance between strings A and B. m, n = len(A), len(B) dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize base cases for DP array for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Fill DP array for i in range(1, m + 1): for j in range(1, n + 1): if A[i - 1] == B[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min(dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + 1) # Substitution return dp[m][n]"},{"question":"def length_of_longest_unique_substring(s: str) -> int: Returns the length of the longest substring that contains only unique characters. >>> length_of_longest_unique_substring(\\"abcabcbb\\") 3 >>> length_of_longest_unique_substring(\\"bbbbb\\") 1 >>> length_of_longest_unique_substring(\\"pwwkew\\") 3 from solution import length_of_longest_unique_substring def test_unique_case(): assert length_of_longest_unique_substring(\\"abcabcbb\\") == 3 assert length_of_longest_unique_substring(\\"bbbbb\\") == 1 assert length_of_longest_unique_substring(\\"pwwkew\\") == 3 assert length_of_longest_unique_substring(\\"abcdef\\") == 6 assert length_of_longest_unique_substring(\\"a\\") == 1 assert length_of_longest_unique_substring(\\"ab\\") == 2 assert length_of_longest_unique_substring(\\"aaaa\\") == 1 assert length_of_longest_unique_substring(\\"abrkaabcdefghijjxxx\\") == 10 assert length_of_longest_unique_substring(\\"dvdf\\") == 3 assert length_of_longest_unique_substring(\\"\\") == 0","solution":"def length_of_longest_unique_substring(s): Returns the length of the longest substring with all unique characters. n = len(s) char_index = {} max_length = 0 start = 0 for end in range(n): if s[end] in char_index: start = max(start, char_index[s[end]] + 1) char_index[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def min_roads_to_add(n: int, m: int, roads: List[Tuple[int, int]]) -> int: Determines the minimum number of roads that need to be added to make the cities form a single connected component. Parameters: n (int): Number of cities. m (int): Number of existing roads. roads (List[Tuple[int, int]]): List of tuples representing existing roads. Returns: int: Minimum number of roads to be added. >>> min_roads_to_add(4, 2, [(1, 2), (3, 4)]) 1 >>> min_roads_to_add(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 0 >>> min_roads_to_add(5, 2, [(1, 2), (2, 3)]) 2 >>> min_roads_to_add(1, 0, []) 0 >>> min_roads_to_add(3, 0, []) 2 >>> min_roads_to_add(4, 3, [(1, 2), (2, 3), (3, 4)]) 0","solution":"def min_roads_to_add(n, m, roads): Determines the minimum number of roads that need to be added to make the cities form a single connected component. Parameters: n (int): Number of cities. m (int): Number of existing roads. roads (List[Tuple[int, int]]): List of tuples representing existing roads. Returns: int: Minimum number of roads to be added. from collections import defaultdict, deque # Build adjacency list adj = defaultdict(list) for u, v in roads: adj[u].append(v) adj[v].append(u) # Function to perform BFS and find all connected components def bfs(start): queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in adj[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) visited = [False] * (n + 1) connected_components = 0 # Count the number of connected components for i in range(1, n + 1): if not visited[i]: connected_components += 1 bfs(i) # We need (number of connected components - 1) roads to connect all components return connected_components - 1"},{"question":"def minStepsToAnagram(str1: str, str2: str) -> int: Find the minimum number of steps required to make two strings anagrams of each other. In one step, you can insert a character into, delete a character from, or replace a character in either of the strings. >>> minStepsToAnagram(\\"abc\\", \\"bcf\\") 2 >>> minStepsToAnagram(\\"abcdef\\", \\"azced\\") 3 >>> minStepsToAnagram(\\"test\\", \\"test\\") 0 >>> minStepsToAnagram(\\"abcdef\\", \\"uvwxyz\\") 12 >>> minStepsToAnagram(\\"anagram\\", \\"mangaar\\") 0 >>> minStepsToAnagram(\\"\\", \\"\\") 0 >>> minStepsToAnagram(\\"\\", \\"abc\\") 3 >>> minStepsToAnagram(\\"abc\\", \\"\\") 3 >>> minStepsToAnagram(\\"a\\", \\"b\\") 2 >>> minStepsToAnagram(\\"a\\", \\"a\\") 0","solution":"def minStepsToAnagram(str1, str2): from collections import Counter # Count frequency of each character in both strings count1 = Counter(str1) count2 = Counter(str2) # Calculate the number of deletions or insertions needed to make the two strings anagrams deletions = 0 for char in count1: if char in count2: deletions += abs(count1[char] - count2[char]) else: deletions += count1[char] for char in count2: if char not in count1: deletions += count2[char] return deletions"},{"question":"def max_subarray_sum(arr: List[int]) -> int: Returns the maximum sum of a subarray in the given array. >>> max_subarray_sum([1, -2, 3, 4, -1]) 7 >>> max_subarray_sum([-5]) 0 >>> max_subarray_sum([2, 3, -6, 4]) 5 >>> max_subarray_sum([-1, 2, -3, 4, 5, -2, 1]) 9","solution":"def max_subarray_sum(arr): Returns the maximum sum of a subarray in the given array. max_sum = 0 current_sum = 0 for num in arr: current_sum = max(0, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def find_duplicates(nums): Returns a list of integers that appear twice in the input list nums. >>> find_duplicates([4,3,2,7,8,2,3,1]) == [2, 3] >>> find_duplicates([1,1,2]) == [1] >>> find_duplicates([1]) == [] >>> find_duplicates([2,2,3,3,4]) == [2, 3] >>> find_duplicates([4,6,5,5,6,3,2,1]) == [5, 6] >>> find_duplicates([10,1,2,3,4,5,6,7,8,9]) == []","solution":"def find_duplicates(nums): Returns a list of integers that appear twice in the input list nums. result = [] for i in range(len(nums)): index = abs(nums[i]) - 1 if nums[index] < 0: result.append(abs(nums[i])) else: nums[index] = -nums[index] return result"},{"question":"def evaluate_expression(expression: str) -> float: Write a function \`evaluate_expression(expression)\` that evaluates a mathematical expression given as a string and returns the result. The function should handle addition, subtraction, multiplication, and division operations, and respect the order of operations (PEMDAS). The input expression may contain spaces, which should be ignored. The evaluation should follow the standard order of operations: parentheses first, then multiplication and division (from left to right), and finally addition and subtraction (from left to right). If a division by zero is encountered, the function should raise a \`ZeroDivisionError\`. Args: expression (str): The mathematical expression to evaluate. Returns: float: The result of evaluating the expression. Constraints: 1. The \`expression\` will be a valid mathematical expression. Examples: >>> evaluate_expression(\\"3 + 2 * 2\\") 7 >>> evaluate_expression(\\" 10 + 2 * 6 \\") 22 >>> evaluate_expression(\\"100 * 2 + 12\\") 212 >>> evaluate_expression(\\"100 * ( 2 + 12 )\\") 1400 >>> evaluate_expression(\\"100 * ( 2 + 12 ) / 14\\") 100.0","solution":"def evaluate_expression(expression): Evaluates a given mathematical expression and returns the result. The expression is given as a string which may contain spaces. try: result = eval(expression) return result except ZeroDivisionError: raise ZeroDivisionError(\\"Division by zero is not allowed.\\") except Exception as e: raise ValueError(f\\"Invalid expression: {expression}. Error: {e}\\")"},{"question":"def rearrangeArray(nums, k): Re-arrange the array such that every kth element is moved to the beginning. Args: nums: List of integers. k: The k value indicating the position interval. Returns: A modified list based on the given condition. Examples: >>> rearrangeArray([1, 2, 3, 4, 5, 6, 7, 8], 2) [2, 4, 6, 8, 1, 3, 5, 7] >>> rearrangeArray([10, 20, 30, 40, 50], 3) [30, 10, 20, 40, 50]","solution":"def rearrangeArray(nums, k): Re-arrange the array such that every kth element is moved to the beginning. Args: nums: List of integers. k: The k value indicating the position interval. Returns: A modified list based on the given condition. # Extract elements at positions k, 2k, 3k,... (1-based indexing) kth_elements = [nums[i] for i in range(k-1, len(nums), k)] # Remaining elements (those not at k, 2k, 3k,... positions) remaining_elements = [nums[i] for i in range(len(nums)) if (i % k) != (k-1)] # Concatenate kth_elements followed by remaining_elements result = kth_elements + remaining_elements return result"},{"question":"def find_matching_positions(n: int, s: str) -> list: Given an integer n and a periodic pattern string s, return the first m positions in the sequence that match the last m positions where m is the length of the repeating pattern. >>> find_matching_positions(15, \\"ABC\\") [0, 1, 2] >>> find_matching_positions(10, \\"AB\\") [0, 1]","solution":"def find_matching_positions(n, s): Given an integer n and a periodic pattern string s, return the first m positions in the sequence that match the last m positions where m is the length of the repeating pattern. m = len(s) result = list(range(m)) return result"},{"question":"def min_deletions_to_make_equal(s1: str, s2: str) -> int: Returns the minimum number of characters to be deleted from both s1 and s2 so that the remaining substrings are identical. >>> min_deletions_to_make_equal(\\"sea\\", \\"eat\\") 2 >>> min_deletions_to_make_equal(\\"abcde\\", \\"ace\\") 2","solution":"def min_deletions_to_make_equal(s1, s2): Returns the minimum number of deletions needed from both strings s1 and s2 to make the remaining substrings identical. m, n = len(s1), len(s2) # Create a DP table to store lengths of longest common subsequence. dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp table for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: dp[i][j] = 0 elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Length of longest common subsequence lcs_length = dp[m][n] # The minimum number of deletions return (m - lcs_length) + (n - lcs_length)"},{"question":"from collections import Counter def can_rearrange_string(s: str) -> str: Determines if the characters in the string can be rearranged such that no two adjacent characters are the same. :param s: str - input string consisting of lowercase and uppercase letters :return: str - \\"Yes\\" if it's possible to rearrange, \\"No\\" otherwise >>> can_rearrange_string(\\"aaabbc\\") Yes >>> can_rearrange_string(\\"aaab\\") No >>> can_rearrange_string(\\"aA\\") Yes >>> can_rearrange_string(\\"zzzzyyyy\\") Yes >>> can_rearrange_string(\\"abcdefghijabcdefghijabcdefghijabcdefghij\\") Yes","solution":"from collections import Counter def can_rearrange_string(s): Determines if the characters in the string can be rearranged such that no two adjacent characters are the same. :param s: str - input string consisting of lowercase and uppercase letters :return: str - \\"Yes\\" if it's possible to rearrange, \\"No\\" otherwise freq = Counter(s) max_freq = max(freq.values()) # The condition to check if rearrangement is possible if max_freq > (len(s) + 1) // 2: return \\"No\\" return \\"Yes\\""},{"question":"from typing import List, Tuple def count_paths(n: int, edges: List[Tuple[int, int]]) -> List[int]: Write a program to help Alice find out the number of distinct paths from room 1 to every other room. >>> count_paths(5, [(1, 2), (1, 3), (2, 4), (2, 5)]) [1, 1, 2, 2] >>> count_paths(3, [(1, 2), (1, 3)]) [1, 1] import pytest def test_sample_case(): n = 5 edges = [(1, 2), (1, 3), (2, 4), (2, 5)] assert count_paths(n, edges) == [1, 1, 2, 2] def test_three_nodes(): n = 3 edges = [(1, 2), (1, 3)] assert count_paths(n, edges) == [1, 1] def test_five_nodes_with_linear_structure(): n = 5 edges = [(1, 2), (2, 3), (3, 4), (4, 5)] assert count_paths(n, edges) == [1, 2, 3, 4] def test_complex_structure(): n = 6 edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)] assert count_paths(n, edges) == [1, 1, 2, 2, 2] def test_two_nodes(): n = 2 edges = [(1, 2)] assert count_paths(n, edges) == [1] def test_minimum_case(): n = 2 edges = [(1, 2)] assert count_paths(n, edges) == [1]","solution":"def count_paths(n, edges): from collections import defaultdict, deque # Build the adjacency list for the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Distance array to store the number of distinct paths to each node distance = [-1] * (n + 1) distance[1] = 0 # BFS to calculate the distances from node 1 queue = deque([1]) while queue: node = queue.popleft() for neighbor in graph[node]: if distance[neighbor] == -1: # if not visited distance[neighbor] = distance[node] + 1 queue.append(neighbor) # The result for nodes 2 to N result = [distance[i] for i in range(2, n + 1)] return result # Example code to test the function if __name__ == \\"__main__\\": n = 5 edges = [(1, 2), (1, 3), (2, 4), (2, 5)] print(count_paths(n, edges)) # Should output [1, 1, 2, 2]"},{"question":"def maximize_beauty_score(P: int, T: int, plants: List[Tuple[int, int]]) -> int: Calculate the maximum beauty score achievable given the total units of land P and the details of T types of plants. >>> maximize_beauty_score(5, 3, [(1, 3), (2, 5), (3, 7)]) == 15 >>> maximize_beauty_score(8, 2, [(2, 4), (3, 5)]) == 16 >>> maximize_beauty_score(10, 1, [(2, 1)]) == 5 >>> maximize_beauty_score(7, 3, [(2, 2), (2, 3), (2, 2)]) == 9 >>> maximize_beauty_score(0, 3, [(1, 2), (2, 3), (3, 4)]) == 0 >>> maximize_beauty_score(10, 0, []) == 0 >>> maximize_beauty_score(10**6, 1, [(10**6, 10**6)]) == 10**6 >>> maximize_beauty_score(5, 2, [(8, 10), (3, 7)]) == 7","solution":"def maximize_beauty_score(P, T, plants): dp = [0] * (P + 1) for ai, bi in plants: for j in range(ai, P + 1): dp[j] = max(dp[j], dp[j - ai] + bi) return dp[P]"},{"question":"from typing import List def k_most_frequent_words(words: List[str], k: int) -> List[str]: Given a list of words and an integer k, return the k most frequent words sorted by their frequency from highest to lowest. If multiple words have the same frequency, they are sorted alphabetically within that frequency. >>> k_most_frequent_words([\\"the\\", \\"day\\", \\"is\\", \\"sunny\\", \\"the\\", \\"the\\", \\"the\\", \\"sunny\\", \\"is\\", \\"is\\"], 4) [\\"the\\", \\"is\\", \\"sunny\\", \\"day\\"] >>> k_most_frequent_words([\\"apple\\"], 1) [\\"apple\\"] >>> k_most_frequent_words([\\"a\\", \\"b\\", \\"c\\", \\"d\\"], 2) [\\"a\\", \\"b\\"] >>> k_most_frequent_words([\\"a\\", \\"b\\", \\"c\\", \\"a\\", \\"b\\", \\"c\\"], 3) [\\"a\\", \\"b\\", \\"c\\"] >>> k_most_frequent_words([\\"a\\", \\"b\\", \\"c\\", \\"a\\", \\"b\\", \\"c\\"], 10) [\\"a\\", \\"b\\", \\"c\\"] >>> k_most_frequent_words([\\"word\\"] * 10000, 1) [\\"word\\"]","solution":"from collections import Counter def k_most_frequent_words(words, k): Given a list of words and an integer k, return the k most frequent words sorted by their frequency from highest to lowest. If multiple words have the same frequency, they are sorted alphabetically within that frequency. # Count the frequency of each word word_count = Counter(words) # Create a sorted list of words first by frequency (descending) then by lexically order sorted_words = sorted(word_count.items(), key=lambda x: (-x[1], x[0])) # Extract the first k words from the sorted list result = [word for word, _ in sorted_words[:k]] return result # Example usage: # words = [\\"the\\", \\"day\\", \\"is\\", \\"sunny\\", \\"the\\", \\"the\\", \\"the\\", \\"sunny\\", \\"is\\", \\"is\\"] # k = 4 # print(k_most_frequent_words(words, k))"},{"question":"def count_invalid_substrings(s: str) -> int: Count the number of contiguous substrings of s that have more distinct characters than the length of the substring. Args: s (str): A string containing only lowercase English alphabets. Returns: int: Number of contiguous substrings that satisfy the condition. Examples: >>> count_invalid_substrings(\\"abcabc\\") 0 >>> count_invalid_substrings(\\"a\\") 0 >>> count_invalid_substrings(\\"ab\\") 0 >>> count_invalid_substrings(\\"aa\\") 0 >>> count_invalid_substrings(\\"abcdefghijklmno\\") 0 >>> count_invalid_substrings(\\"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\\") 0","solution":"def count_invalid_substrings(s): # The number of contiguous substrings with more distinct characters than their length is always zero. return 0"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def verticalOrderTraversal(root): Perform a vertical order traversal of the binary tree and return the nodes in a list of lists. Args: root (TreeNode): head reference of the binary tree Returns: List[List[int]]: nodes vertically ordered Examples: >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> verticalOrderTraversal(root) [[9], [3, 15], [20], [7]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(6) >>> verticalOrderTraversal(root) [[4], [2], [1, 5], [3], [6]]","solution":"from collections import deque, defaultdict class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def verticalOrderTraversal(root): if not root: return [] column_table = defaultdict(list) queue = deque([(root, 0)]) while queue: node, column = queue.popleft() if node is not None: column_table[column].append(node.val) queue.append((node.left, column - 1)) queue.append((node.right, column + 1)) sorted_columns = sorted(column_table.keys()) return [column_table[column] for column in sorted_columns]"},{"question":"def canUnlockTreasureChest(key: str, lock: str) -> bool: Determines if the key can unlock the treasure chest. The key can unlock the treasure chest if and only if it is possible to rearrange the letters in the key to match the lock. Args: key (str): The string representing the key. lock (str): The string representing the lock. Returns: bool: True if the key can unlock the treasure chest, False otherwise. Examples: >>> canUnlockTreasureChest(\\"listen\\", \\"silent\\") True >>> canUnlockTreasureChest(\\"apple\\", \\"pale\\") False","solution":"def canUnlockTreasureChest(key: str, lock: str) -> bool: Determines if the key can unlock the treasure chest. The key can unlock the treasure chest if and only if it is possible to rearrange the letters in the key to match the lock. Args: key (str): The string representing the key. lock (str): The string representing the lock. Returns: bool: True if the key can unlock the treasure chest, False otherwise. return sorted(key) == sorted(lock)"},{"question":"def can_reach(n: int, m: int, edges: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[str]: For a given directed graph, determine if there is a path from node u to node v for a set of queries. >>> can_reach(5, 6, [(0, 1), (1, 2), (2, 3), (3, 4), (1, 3), (3, 1)], [(0, 4), (1, 4), (3, 0), (0, 2)]) [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"] >>> can_reach(3, 1, [(0, 1)], [(0, 2), (1, 2), (2, 0)]) [\\"NO\\", \\"NO\\", \\"NO\\"]","solution":"def can_reach(n, m, edges, queries): from collections import deque def bfs(start, end): queue = deque([start]) visited = [False] * n visited[start] = True while queue: node = queue.popleft() if node == end: return True for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return False # Build the graph graph = [[] for _ in range(n)] for u, v in edges: graph[u].append(v) results = [] for a, b in queries: if bfs(a, b): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def is_palindrome(s: str) -> str: Determines if the given string is a palindrome, ignoring spaces, punctuation, and capitalization differences. :param s: input string :return: \\"Palindrome\\" if the string is a palindrome, otherwise \\"Not a palindrome\\" >>> is_palindrome(\\"A man a plan a canal Panama\\") \\"Palindrome\\" >>> is_palindrome(\\"No lemon, no melon\\") \\"Palindrome\\" >>> is_palindrome(\\"This is not a palindrome\\") \\"Not a palindrome\\" >>> is_palindrome(\\" \\") \\"Palindrome\\" >>> is_palindrome(\\"Able was I ere I saw Elba\\") \\"Palindrome\\" >>> is_palindrome(\\"Madam, in Eden, I'm Adam\\") \\"Palindrome\\" >>> is_palindrome(\\"12321\\") \\"Palindrome\\" >>> is_palindrome(\\"12345\\") \\"Not a palindrome\\"","solution":"def is_palindrome(s): Determines if the given string is a palindrome, ignoring spaces, punctuation, and capitalization differences. :param s: input string :return: \\"Palindrome\\" if the string is a palindrome, otherwise \\"Not a palindrome\\" # Remove all spaces and convert to lowercase cleaned = ''.join(c.lower() for c in s if c.isalnum()) # Check if the cleaned string is the same as its reverse if cleaned == cleaned[::-1]: return \\"Palindrome\\" else: return \\"Not a palindrome\\""},{"question":"def sortingString(s: str) -> str: Returns a sorted string with all digits before the letters. Parameters: s (str): A string consisting of lowercase English letters and digits Returns: str: The sorted string Example: >>> sortingString(\\"a1c2b3\\") '123abc' >>> sortingString(\\"a9b8c7\\") '789abc' def test_sorting_string(): assert sortingString(\\"a1c2b3\\") == \\"123abc\\" assert sortingString(\\"a9b8c7\\") == \\"789abc\\" assert sortingString(\\"9a5b4c6\\") == \\"4569abc\\" assert sortingString(\\"z9x8y7\\") == \\"789xyz\\" assert sortingString(\\"1a2b3c4d5e\\") == \\"12345abcde\\" assert sortingString(\\"a\\") == \\"a\\" assert sortingString(\\"9\\") == \\"9\\" assert sortingString(\\"a1b2c3d4e5f6g7h8i9j0\\") == \\"0123456789abcdefghij\\"","solution":"def sortingString(s): Returns a sorted string with all digits before the letters. Parameters: s (str): A string consisting of lowercase English letters and digits Returns: str: The sorted string digits = sorted([char for char in s if char.isdigit()]) letters = sorted([char for char in s if char.isalpha()]) return ''.join(digits + letters)"},{"question":"def num_distinct_paths(grid): Returns the number of distinct paths from the top-left corner to the bottom-right corner of the given grid. The player can only move through cells containing 0 and can only move vertically or horizontally. >>> grid1 = [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> num_distinct_paths(grid1) 2 >>> grid2 = [ ... [0, 1], ... [0, 0] ... ] >>> num_distinct_paths(grid2) 1 >>> grid3 = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> num_distinct_paths(grid3) 6 >>> grid4 = [ ... [0, 0, 1], ... [0, 1, 0], ... [1, 0, 0] ... ] >>> num_distinct_paths(grid4) 0 >>> grid5 = [[0]] >>> num_distinct_paths(grid5) 1 >>> grid6 = [ ... [0, 0, 0, 0], ... [0, 1, 1, 0], ... [0, 0, 0, 0] ... ] >>> num_distinct_paths(grid6) 2 >>> grid7 = [ ... [0, 1], ... [1, 0] ... ] >>> num_distinct_paths(grid7) 0","solution":"def num_distinct_paths(grid): Returns the number of distinct paths from the top-left corner to the bottom-right corner of the given grid. The player can only move through cells containing 0 and can only move vertically or horizontally. n = len(grid) m = len(grid[0]) # Early exit if start or end is blocked if grid[0][0] == 1 or grid[n-1][m-1] == 1: return 0 # DP array to store number of paths to each cell dp = [[0] * m for _ in range(n)] # Starting point dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == 1: dp[i][j] = 0 # No path through obstacles else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1]"},{"question":"from typing import List def find_books_with_genres(N: int, M: int, books: List[List[int]], Q: int, query_genres: List[int]) -> str: Find all books that belong to all specified genres in a user's search query. >>> find_books_with_genres(5, 5, [[1, 2, 3], [2, 4], [1, 2, 3, 5], [3], [1, 5]], 2, [1, 2]) '1 3' >>> find_books_with_genres(3, 4, [[1, 2], [3, 4], [2, 4]], 2, [1, 4]) 'No books found'","solution":"def find_books_with_genres(N, M, books, Q, query_genres): result = [] query_set = set(query_genres) for i in range(N): book_genres = set(books[i]) if query_set.issubset(book_genres): result.append(i + 1) if result: return \\" \\".join(map(str, result)) else: return \\"No books found\\""},{"question":"def can_achieve_threshold(d, r, m): Determines if Jerry can achieve at least distance d by running exactly r rounds, each with a minimum distance of m in each round. Parameters: d (int): The total distance to cover. r (int): The minimum distance of each round. m (int): The number of rounds. Returns: str: \\"POSSIBLE\\" if the total distance d can be achieved, otherwise \\"IMPOSSIBLE\\". >>> can_achieve_threshold(10, 4, 3) \\"POSSIBLE\\" >>> can_achieve_threshold(9, 3, 2) \\"IMPOSSIBLE\\"","solution":"def can_achieve_threshold(d, r, m): Determines if Jerry can achieve at least distance d by running exactly r rounds, each with a minimum distance of m in each round. Parameters: d (int): The total distance to cover. r (int): The minimum distance of each round. m (int): The number of rounds. Returns: str: \\"POSSIBLE\\" if the total distance d can be achieved, otherwise \\"IMPOSSIBLE\\". if r * m >= d: return \\"POSSIBLE\\" else: return \\"IMPOSSIBLE\\""},{"question":"def calculate_internal_angles(triangles): Given a list of tuples representing the vertices of triangles, returns the list with the sum of internal angles for each triangle. >>> calculate_internal_angles([[(1, 2), (3, 4), (5, 6)]]) [180] >>> calculate_internal_angles([[(0, 0), (1, 0), (0, 1)], [(2, 2), (3, 3), (4, 4)]]) [180, 180] return [180] * len(triangles) def parse_input(input_string): Given an input string containing the number of triangles followed by their vertex coordinates, returns a list of triangles with their vertices as tuples. >>> parse_input(\\"1n1 1n2 3n4 5\\") [[(1, 1), (2, 3), (4, 5)]] >>> parse_input(\\"2n0 0n1 0n0 1n2 2n3 3n4 4\\") [[(0, 0), (1, 0), (0, 1)], [(2, 2), (3, 3), (4, 4)]] lines = input_string.strip().split('n') t = int(lines[0]) triangles = [] for i in range(1, len(lines), 3): triangle = [] for j in range(i, i + 3): x, y = map(int, lines[j].split()) triangle.append((x, y)) triangles.append(triangle) return triangles","solution":"def calculate_internal_angles(triangles): Given a list of tuples representing the vertices of triangles, returns the list with the sum of internal angles for each triangle. return [180] * len(triangles) # Parsing function def parse_input(input_string): lines = input_string.strip().split('n') t = int(lines[0]) triangles = [] for i in range(1, len(lines), 3): triangle = [] for j in range(i, i + 3): x, y = map(int, lines[j].split()) triangle.append((x, y)) triangles.append(triangle) return triangles"},{"question":"def can_be_palindrome_by_one_replacement(s: str) -> str: Determine whether the string can be made to be a palindrome by replacing at most one of its characters. Args: s (str): The input string consisting of lowercase letters. Returns: str: \\"YES\\" if the string can be made a palindrome by replacing at most one character, otherwise \\"NO\\". Examples: >>> can_be_palindrome_by_one_replacement(\\"abca\\") \\"YES\\" >>> can_be_palindrome_by_one_replacement(\\"abc\\") \\"NO\\" >>> can_be_palindrome_by_one_replacement(\\"a\\") \\"YES\\" >>> can_be_palindrome_by_one_replacement(\\"racecar\\") \\"YES\\" >>> can_be_palindrome_by_one_replacement(\\"abccba\\") \\"YES\\"","solution":"def can_be_palindrome_by_one_replacement(s): Returns 'YES' if string can be a palindrome by replacing at most one character, otherwise 'NO'. def is_palindrome_range(i, j): while i < j: if s[i] != s[j]: return False i += 1 j -= 1 return True left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Check either by skipping left or right character return \\"YES\\" if is_palindrome_range(left + 1, right) or is_palindrome_range(left, right - 1) else \\"NO\\" left += 1 right -= 1 return \\"YES\\""},{"question":"def min_cost_path(grid): Returns the minimum cost to move from the top-left to the bottom-right of the grid. pass def test_min_cost_example_1(): grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert min_cost_path(grid) == 7 def test_min_cost_example_2(): grid = [ [1, 2], [1, 1] ] assert min_cost_path(grid) == 3 def test_min_cost_single_cell(): grid = [ [0] ] assert min_cost_path(grid) == 0 def test_min_cost_single_row(): grid = [ [1, 2, 3, 4] ] assert min_cost_path(grid) == 10 def test_min_cost_single_column(): grid = [ [1], [2], [3], [4] ] assert min_cost_path(grid) == 10 def test_min_cost_larger_grid(): grid = [ [1, 3, 1, 2], [2, 4, 2, 1], [4, 4, 2, 1], [5, 2, 2, 1] ] assert min_cost_path(grid) == 10","solution":"def min_cost_path(grid): Returns the minimum cost to move from the top-left to the bottom-right of the grid. m = len(grid) n = len(grid[0]) # Create a dp array to store the minimum costs dp = [[0]*n for _ in range(m)] # Initialize the starting point dp[0][0] = grid[0][0] # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) # Return the minimum cost to reach the bottom-right corner return dp[m-1][n-1]"},{"question":"def min_dirt_path(m, grid): Finds the minimum total amount of dirt Alice needs to clear to reach the bottom-right cell from the top-left cell by only moving right or down at each step. Parameters: - m: int, the number of rows and columns in the grid - grid: List[List[int]], a 2D list representing the amount of dirt in each cell of the grid Returns: - int, the minimum total amount of dirt Alice needs to clear Examples: >>> min_dirt_path(3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_dirt_path(2, [[1, 2], [3, 4]]) 7","solution":"def min_dirt_path(m, grid): Finds the minimum total amount of dirt Alice needs to clear to reach the bottom-right cell from the top-left cell by only moving right or down at each step. Parameters: - m: int, the number of rows and columns in the grid. - grid: List[List[int]], a 2D list representing the amount of dirt in each cell of the grid Returns: - int, the minimum total amount of dirt Alice needs to clear. dp = [[0]*m for _ in range(m)] dp[0][0] = grid[0][0] for i in range(1, m): dp[0][i] = dp[0][i-1] + grid[0][i] dp[i][0] = dp[i-1][0] + grid[i][0] for i in range(1, m): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][j]"},{"question":"def validate_encryption_mapping(n: int, mappings: List[Tuple[str, str]]) -> bool: Validates the encryption mapping to ensure each key maps to a unique value. Args: n (int): The number of key-value pairs. mappings (list of tuples): List of (key, value) pairs. Returns: bool: True if the mapping is valid, False otherwise. Examples: >>> validate_encryption_mapping(3, [('a', 'b'), ('c', 'd'), ('e', 'f')]) True >>> validate_encryption_mapping(4, [('a', 'b'), ('c', 'd'), ('e', 'b'), ('f', 'g')]) False","solution":"def validate_encryption_mapping(n, mappings): Validates the encryption mapping to ensure each key maps to a unique value. Args: n (int): The number of key-value pairs. mappings (list of tuples): List of (key, value) pairs. Returns: bool: True if the mapping is valid, False otherwise. value_set = set() for key, value in mappings: if value in value_set: return False value_set.add(value) return True"},{"question":"def sort_odds(array): Given an array of integers, sort the odd numbers in ascending order while leaving the even numbers in their original positions. :param array: List of integers. :return: List of integers with sorted odd numbers. pass def process_input(n, array): Process the input according to the problem statement. :param n: The number of integers in the array. :param array: The list of integers. :return: Modified list as per the solution. pass # Unit tests: def test_process_input_with_sample_data(): assert process_input(7, [5, 3, 2, 8, 1, 4, 11]) == [1, 3, 2, 8, 5, 4, 11] def test_process_input_with_all_odds(): assert process_input(5, [9, 7, 3, 1, 5]) == [1, 3, 5, 7, 9] def test_process_input_with_all_evens(): assert process_input(5, [4, 2, 8, 6, 10]) == [4, 2, 8, 6, 10] def test_process_input_with_mixed_numbers(): assert process_input(6, [11, 4, 7, 2, 5, 8]) == [5, 4, 7, 2, 11, 8] def test_process_input_with_negatives(): assert process_input(5, [5, -1, -3, 2, -5]) == [-5, -3, -1, 2, 5] def test_process_input_with_single_element(): assert process_input(1, [10]) == [10] assert process_input(1, [9]) == [9]","solution":"def sort_odds(array): Given an array of integers, sort the odd numbers in ascending order while leaving the even numbers in their original positions. :param array: List of integers. :return: List of integers with sorted odd numbers. # Extract odd numbers and sort them odds = sorted([x for x in array if x % 2 != 0]) # Generator to iterate through the sorted odd numbers odd_iter = iter(odds) # Reconstruct the array with sorted odds and original evens result = [next(odd_iter) if x % 2 != 0 else x for x in array] return result def process_input(n, array): Process the input according to the problem statement. :param n: The number of integers in the array. :param array: The list of integers. :return: Modified list as per the solution. return sort_odds(array)"},{"question":"def countOccurrences(N: int, A: List[int], target: int) -> int: Finds the occurrence count of the target number in the array using binary search technique. If the target is not present in the array, returns 0. :param N: int - size of the array :param A: List[int] - sorted array of integers :param target: int - target number to count :return: int - count of occurrences of target in the array >>> countOccurrences(6, [1, 2, 2, 3, 3, 3], 3) 3 >>> countOccurrences(5, [1, 1, 2, 4, 5], 3) 0 >>> countOccurrences(5, [1, 1, 2, 3, 5], 3) 1 >>> countOccurrences(5, [1, 1, 2, 4, 5], 6) 0 >>> countOccurrences(10, [1, 2, 2, 2, 3, 3, 4, 4, 4, 4], 4) 4 >>> countOccurrences(5, [5, 5, 5, 5, 5], 5) 5 >>> countOccurrences(0, [], 3) 0","solution":"def countOccurrences(N, A, target): Finds the occurrence count of the target number in the array using binary search technique. If the target is not present in the array, returns 0. :param N: int - size of the array :param A: List[int] - sorted array of integers :param target: int - target number to count :return: int - count of occurrences of target in the array def find_first_occurrence(A, target): low, high = 0, len(A) - 1 first_occurrence = -1 while low <= high: mid = (low + high) // 2 if A[mid] == target: first_occurrence = mid high = mid - 1 elif A[mid] < target: low = mid + 1 else: high = mid - 1 return first_occurrence def find_last_occurrence(A, target): low, high = 0, len(A) - 1 last_occurrence = -1 while low <= high: mid = (low + high) // 2 if A[mid] == target: last_occurrence = mid low = mid + 1 elif A[mid] < target: low = mid + 1 else: high = mid - 1 return last_occurrence first = find_first_occurrence(A, target) if first == -1: return 0 last = find_last_occurrence(A, target) return (last - first + 1)"},{"question":"def find_hidden_number(n, k, numbers, queries_responses): This function finds the hidden number in the list using a limited number of queries. Parameters: n (int): The size of the list k (int): The maximum number of queries allowed numbers (list of int): The list of numbers queries_responses (dict): A dictionary containing the response for each query index Returns: int: The hidden number pass # Test cases def test_find_in_middle(): numbers = [4, 2, 7, 5, 3] queries_responses = { 1: 0, 2: 0, 3: 0, 4: 1, 5: 0, } assert find_hidden_number(5, 3, numbers, queries_responses) == 5 def test_find_at_start(): numbers = [1, 3, 5, 7, 9] queries_responses = { 1: 1, 2: 0, 3: 0, 4: 0, 5: 0, } assert find_hidden_number(5, 5, numbers, queries_responses) == 1 def test_find_at_end(): numbers = [10, 20, 30, 40, 50] queries_responses = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 1, } assert find_hidden_number(5, 5, numbers, queries_responses) == 50 def test_no_queries(): numbers = [8, 6, 4, 2, 7] queries_responses = {} assert find_hidden_number(5, 5, numbers, queries_responses) is None def test_find_in_large_list(): numbers = list(range(1, 101)) queries_responses = {50: 1} assert find_hidden_number(100, 10, numbers, queries_responses) == 50","solution":"def find_hidden_number(n, k, numbers, queries_responses): This function finds the hidden number in the list using a limited number of queries. Parameters: n (int): The size of the list k (int): The maximum number of queries allowed numbers (list of int): The list of numbers queries_responses (dict): A dictionary containing the response for each query index Returns: int: The hidden number for index in range(1, n+1): response = queries_responses.get(index, 0) if response == 1: return numbers[index-1] return None"},{"question":"def highest_efficiency_session(N, sessions): Determines the session with the highest solved/minutes ratio. :param N: Number of sessions (integer) :param sessions: List of tuples [(solved, minutes)] :return: 1-based index of the session with the highest efficiency >>> highest_efficiency_session(3, [(10, 5), (6, 2), (8, 4)]) == 2 >>> highest_efficiency_session(2, [(6, 2), (6, 2)]) == 1 >>> highest_efficiency_session(4, [(12, 4), (8, 2), (9, 3), (15, 5)]) == 2 >>> highest_efficiency_session(1, [(10, 5)]) == 1 >>> highest_efficiency_session(5, [(10, 5), (15, 15), (1, 1), (7, 1), (5, 5)]) == 4","solution":"def highest_efficiency_session(N, sessions): Determines the session with the highest solved/minutes ratio. :param N: Number of sessions (integer) :param sessions: List of tuples [(solved, minutes)] :return: 1-based index of the session with the highest efficiency max_efficiency = 0 best_session = 0 for i in range(N): solved, minutes = sessions[i] efficiency = solved / minutes if efficiency > max_efficiency: max_efficiency = efficiency best_session = i + 1 return best_session"},{"question":"from typing import List from collections import Counter def word_wrangler(words: List[str], scrambled: str) -> List[str]: Create a function that takes a list of words and a string of scrambled letters. The function should return a list of words (from the given list) that can be formed using some or all of the letters in the scrambled string. Each letter from the scrambled string can only be used as many times as it appears in the given string. >>> word_wrangler([\\"bat\\", \\"tab\\", \\"cat\\", \\"car\\"], \\"tacb\\") [\\"bat\\", \\"tab\\", \\"cat\\"] >>> word_wrangler([\\"dog\\", \\"pig\\", \\"rat\\"], \\"cat\\") [] pass def similar_lists(list1: List[str], list2: List[str]) -> bool: return sorted(list1) == sorted(list2) def test_basic_case(): assert similar_lists(word_wrangler([\\"bat\\", \\"tab\\", \\"cat\\", \\"car\\"], \\"tacb\\"), [\\"bat\\", \\"tab\\", \\"cat\\"]) def test_case_with_all_letters(): assert similar_lists(word_wrangler([\\"bat\\", \\"tab\\", \\"tac\\", \\"car\\"], \\"tacb\\"), [\\"bat\\", \\"tab\\", \\"tac\\"]) def test_case_with_no_matches(): assert word_wrangler([\\"dog\\", \\"pig\\", \\"rat\\"], \\"cat\\") == [] def test_case_with_duplicate_letters(): assert similar_lists(word_wrangler([\\"bat\\", \\"tab\\", \\"tatt\\", \\"tattoo\\"], \\"tattb\\"), [\\"bat\\", \\"tab\\", \\"tatt\\"]) def test_case_with_empty_scrambled(): assert word_wrangler([\\"bat\\", \\"tab\\", \\"cat\\"], \\"\\") == [] def test_case_with_empty_word_list(): assert word_wrangler([], \\"tacb\\") == [] def test_case_with_partial_match(): assert similar_lists(word_wrangler([\\"bat\\", \\"tab\\", \\"at\\", \\"batman\\"], \\"tab\\"), [\\"bat\\", \\"tab\\", \\"at\\"])","solution":"from collections import Counter def word_wrangler(words, scrambled): Returns a list of words that can be formed using some or all of the letters in the scrambled string. scrambled_count = Counter(scrambled) result = [] for word in words: word_count = Counter(word) can_form = True for letter, count in word_count.items(): if scrambled_count[letter] < count: can_form = False break if can_form: result.append(word) return result"},{"question":"def can_be_palindrome(T: int, test_cases: List[Tuple[int, str]]) -> List[str]: Determine if it is possible to make the entire string a palindrome using allowed operations. >>> can_be_palindrome(4, [(5, \\"11011\\"), (6, \\"100001\\"), (3, \\"010\\"), (4, \\"1110\\")]) [\\"Yes\\", \\"Yes\\", \\"Yes\\", \\"No\\"] >>> can_be_palindrome(1, [(1, \\"0\\")]) [\\"Yes\\"] >>> can_be_palindrome(1, [(2, \\"00\\")]) [\\"Yes\\"] >>> can_be_palindrome(1, [(6, \\"110100\\")]) [\\"No\\"] >>> can_be_palindrome(1, [(5, \\"11010\\")]) [\\"Yes\\"] >>> can_be_palindrome(1, [(4, \\"1111\\")]) [\\"Yes\\"] >>> can_be_palindrome(3, [(7, \\"1000001\\"), (4, \\"0001\\"), (5, \\"10100\\")]) [\\"Yes\\", \\"No\\", \\"Yes\\"]","solution":"def can_be_palindrome(T, test_cases): results = [] for i in range(T): N, S = test_cases[i] if S == S[::-1]: # If the string is already a palindrome results.append(\\"Yes\\") elif N % 2 == 1: # If the length of the string is odd, we can always make it a palindrome results.append(\\"Yes\\") else: # Check if there is any difference between the original and reversed string found_difference = False for j in range(N // 2): if S[j] != S[N - j - 1]: found_difference = True break if found_difference: results.append(\\"No\\") else: results.append(\\"Yes\\") return results"},{"question":"import heapq from collections import Counter from typing import List def rearrange_string(s: str) -> str: Rearranges the characters of the string s such that no two adjacent characters are the same. If it is possible to achieve such an arrangement, return any valid rearrangement, otherwise return an empty string. >>> rearrange_string(\\"aab\\") in [\\"aba\\"] True >>> rearrange_string(\\"aaab\\") '' >>> rearrange_string(\\"abcdef\\") 'abcdef' >>> rearrange_string(\\"aabbcc\\") in [\\"abcabc\\", \\"ababac\\", \\"bacbac\\"] True >>> rearrange_string(\\"ccc\\") '' def solve(tc: int, strings: List[str]) -> List[str]: For each test case, rearrange the string such that no two adjacent characters are the same. >>> solve(5, [\\"aab\\", \\"aaab\\", \\"abcdef\\", \\"aabbcc\\", \\"ccc\\"]) ['aba', '', 'abcdef', 'abcabc', ''] >>> solve(1, [\\"aaa\\"]) [''] >>> solve(2, [\\"aabc\\", \\"ab\\"]) in [[\\"abac\\", \\"ab\\"], [\\"acab\\", \\"ab\\"], [\\"caba\\", \\"ab\\"], [\\"cbaa\\", \\"ab\\"], [\\"caab\\", \\"ab\\"]] True >>> solve(3, [\\"aa\\", \\"a\\", \\"\\"]) ['', 'a', ''] >>> solve(2, [\\"zzzzzz\\", \\"zz\\"]) ['', '']","solution":"import heapq from collections import Counter def rearrange_string(s): freq = Counter(s) max_heap = [(-count, char) for char, count in freq.items()] heapq.heapify(max_heap) prev_count = 0 prev_char = '' result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count = count + 1 # decrement count prev_char = char if len(result) == len(s): return ''.join(result) else: return '' def solve(tc, strings): results = [] for s in strings: results.append(rearrange_string(s)) return results"},{"question":"from typing import List, Tuple def combine(n: int, k: int) -> List[Tuple[int]]: Return all possible combinations of k numbers out of the range [1, n]. >>> combine(4, 2) [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)] >>> combine(5, 3) [(1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 3, 4), (1, 3, 5), (1, 4, 5), (2, 3, 4), (2, 3, 5), (2, 4, 5), (3, 4, 5)] >>> combine(1, 1) [(1,)] >>> combine(4, 4) [(1, 2, 3, 4)] >>> combine(3, 3) [(1, 2, 3)]","solution":"from itertools import combinations def combine(n, k): Return all possible combinations of k numbers out of the range [1, n]. return list(combinations(range(1, n+1), k))"},{"question":"from typing import List, Tuple def find_max_weights(N: int, M: int, edges: List[Tuple[int, int, int]]) -> List[List[int]]: Finds the maximum possible weight of a package that can be transported between each pair of distinct warehouses. :param N: int, number of warehouses :param M: int, number of connections :param edges: List of tuples, each containing (u, v, w) :return: List of lists representing the N x N matrix with maximum weights Example: >>> find_max_weights(3, 3, [(1, 2, 10), (2, 3, 20), (1, 3, 5)]) [[0, 10, 10], [10, 0, 20], [10, 20, 0]] >>> find_max_weights(4, 5, [(1, 2, 50), (2, 3, 40), (3, 4, 30), (4, 1, 20), (1, 3, 10)]) [[0, 50, 40, 30], [50, 0, 40, 30], [40, 40, 0, 30], [30, 30, 30, 0]]","solution":"def find_max_weights(N, M, edges): Finds the maximum possible weight of a package that can be transported between each pair of distinct warehouses. :param N: int, number of warehouses :param M: int, number of connections :param edges: List of tuples, each containing (u, v, w) :return: List of lists representing the N x N matrix with maximum weights # Initialize distance matrix with 0 dist = [[0] * N for _ in range(N)] # Place the maximum weight capacity of direct connections for u, v, w in edges: dist[u-1][v-1] = w dist[v-1][u-1] = w # Floyd-Warshall Algorithm to find all-pairs max weights for k in range(N): for i in range(N): for j in range(N): if i != j: # No need to update self-loops, they should be zero dist[i][j] = max(dist[i][j], min(dist[i][k], dist[k][j])) return dist"},{"question":"def min_moves_to_uniform_string(N: int, S: str) -> int: Returns the minimum number of moves required to make all characters in string S the same. >>> min_moves_to_uniform_string(5, 'ababa') == 2 >>> min_moves_to_uniform_string(4, 'aaaa') == 0 >>> min_moves_to_uniform_string(7, 'baaaabb') == 3 def process_test_cases(T: int, test_cases: list) -> list: Processes multiple test cases and returns the results as a list. >>> process_test_cases(3, [(5, 'ababa'), (4, 'aaaa'), (7, 'baaaabb')]) == [2, 0, 3] >>> process_test_cases(2, [(2, 'aa'), (2, 'ab')]) == [0, 1]","solution":"def min_moves_to_uniform_string(N, S): Returns the minimum number of moves required to make all characters in string S the same. count_a = S.count('a') count_b = N - count_a # Since the only characters are 'a' and 'b' return min(count_a, count_b) def process_test_cases(T, test_cases): results = [] for i in range(T): N, S = test_cases[i] results.append(min_moves_to_uniform_string(N, S)) return results"},{"question":"from typing import List def num_unique_emails(emails: List[str]) -> int: Given a list of emails, returns the number of unique email addresses after normalization. Emails are normalized by removing dots in the local part and ignoring everything after a plus sign. >>> num_unique_emails([\\"test.email+alex@leetcode.com\\", \\"test.e.mail+bob.cathy@leetcode.com\\", \\"testemail+david@lee.tcode.com\\"]) 2 >>> num_unique_emails([\\"a@leetcode.com\\", \\"b@leetcode.com\\", \\"c@leetcode.com\\"]) 3 >>> num_unique_emails([\\"a.b.c@leetcode.com\\", \\"abc@leetcode.com\\"]) 1 >>> num_unique_emails([\\"a+b@leetcode.com\\", \\"a@leetcode.com\\"]) 1 >>> num_unique_emails([\\"test.email+alex@leetcode.com\\", \\"test.e.mail.leet+alex@code.com\\"]) 2 >>> num_unique_emails([\\"abc+123+def@leetcode.com\\", \\"abc@leetcode.com\\"]) 1 >>> num_unique_emails([\\"test.email@leetcode.com\\", \\"test.e.mail+alex@leetcode.com\\", \\"test.email@leetcode.COM\\"]) 2","solution":"def num_unique_emails(emails): def normalize(email): local, domain = email.split('@') local = local.split('+')[0] local = local.replace('.', '') return local + '@' + domain unique_emails = set(normalize(email) for email in emails) return len(unique_emails)"},{"question":"from typing import List, Union def navigate_lake(grid: List[List[Union[str, int]]]) -> int: Returns the minimum number of steps required to reach the destination checkpoint 'D' from the starting checkpoint 'S'. If it is not possible to reach the destination, returns -1. Args: grid (list of list of str/int): 2D list representing the lake. Returns: int: Minimum number of steps to reach 'D' or -1 if not possible. >>> navigate_lake([ ... [\\"S\\", 0, 1, 0, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 0, 0], ... [1, 0, 1, 1, 1], ... [0, 0, 0, 0, \\"D\\"] ... ]) == 8 >>> navigate_lake([ ... [\\"S\\", 1, 1, 1, \\"D\\"], ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1] ... ]) == -1 >>> navigate_lake([ ... [\\"S\\", 0, 0, 0, \\"D\\"], ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1] ... ]) == 4","solution":"from collections import deque def navigate_lake(grid): Returns the minimum number of steps required to reach the destination checkpoint 'D' from the starting checkpoint 'S'. If it is not possible to reach the destination, returns -1. Args: grid (list of list of str/int): 2D list representing the lake. Returns: int: Minimum number of steps to reach 'D' or -1 if not possible def get_neighbors(x, y): # returns the valid neighbors (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] != 1: yield (nx, ny) # Find the start (S) and destination (D) points start = destination = None for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 'S': start = (i, j) elif grid[i][j] == 'D': destination = (i, j) if start and destination: break if not start or not destination: return -1 # Use BFS to find the shortest path from start to destination queue = deque([(start[0], start[1], 0)]) # queue of (x, y, steps) visited = set() visited.add(start) while queue: x, y, steps = queue.popleft() if (x, y) == destination: return steps for nx, ny in get_neighbors(x, y): if (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"def sumAtDepth(tree, depth): Returns the sum of the values of all nodes at the specified depth. Args: tree (list): The list representing the tree in level-order traversal. depth (int): The specified depth. Returns: int: Sum of the values of all nodes at the specified depth. >>> sumAtDepth([1, 2, 3, 4, 5, None, None], 2) 9 >>> sumAtDepth([1, None, 2, 3, None, None, 4], 1) 2 >>> sumAtDepth([1, 2, 3], 3) 0 >>> sumAtDepth([1, 2, 3], 0) 1 >>> sumAtDepth([], 1) 0 >>> sumAtDepth([1, 2, 3], -1) 0 >>> sumAtDepth([1, 2, 3, 4, 5, 6, 7], 2) 22","solution":"def sumAtDepth(tree, depth): Returns the sum of the values of all nodes at the specified depth. Args: tree (list): The list representing the tree in level-order traversal. depth (int): The specified depth. Returns: int: Sum of the values of all nodes at the specified depth. if not tree or depth < 0: return 0 current_depth = 0 level_start = 0 level_end = 1 while level_start < len(tree): if current_depth == depth: return sum(node for node in tree[level_start:level_end] if node is not None) level_start = level_end level_end = level_start + 2 ** (current_depth + 1) current_depth += 1 return 0"},{"question":"from typing import List def filterWeekendBirthdays(birthdates: List[str]) -> List[str]: Filters the list of birthdates and returns those that fall on a weekend (Saturday or Sunday). >>> filterWeekendBirthdays([\\"2023-01-01\\", \\"2023-01-03\\", \\"2023-01-07\\", \\"2023-01-09\\"]) [\\"2023-01-01\\", \\"2023-01-07\\"] >>> filterWeekendBirthdays([\\"2023-05-02\\", \\"2023-05-03\\", \\"2023-05-04\\"]) []","solution":"from datetime import datetime def filterWeekendBirthdays(birthdates): Filters the list of birthdates and returns those that fall on a weekend (Saturday or Sunday) weekend_birthdays = [] for date_str in birthdates: date_obj = datetime.strptime(date_str, \\"%Y-%m-%d\\") if date_obj.weekday() in (5, 6): # 5 is Saturday, 6 is Sunday weekend_birthdays.append(date_str) return weekend_birthdays"},{"question":"from typing import List, Tuple def most_projects_pair(records: List[Tuple[int, int, int]]) -> Tuple[int, int, int]: Determines the pair of employees that worked together the most and the number of projects they worked on. >>> most_projects_pair([(1, 2, 3)]) (1, 2, 3) >>> most_projects_pair([(1, 2, 3), (1, 3, 2), (2, 3, 1), (1, 2, 4)]) (1, 2, 7) >>> most_projects_pair([(1, 2, 5), (2, 3, 5), (1, 3, 5)]) (1, 2, 5) >>> most_projects_pair([(1, 2, 4), (2, 3, 4), (1, 2, 3), (2, 3, 3)]) (1, 2, 7)","solution":"def most_projects_pair(records): Determines the pair of employees that worked together the most and the number of projects they worked on. from collections import defaultdict pair_projects = defaultdict(int) for a, b, p in records: pair_projects[(a, b)] += p max_projects = 0 best_pair = None for pair, project_count in pair_projects.items(): if project_count > max_projects or (project_count == max_projects and (best_pair is None or pair < best_pair)): max_projects = project_count best_pair = pair return best_pair[0], best_pair[1], max_projects def get_input(): Reads input from user. m = int(input()) records = [] for _ in range(m): a, b, p = map(int, input().split()) records.append((a, b, p)) return records"},{"question":"def find_unique_element(seq): Returns the element that appears exactly once in the sequence. >>> find_unique_element([1, 2, 3, 2, 1]) == 3 >>> find_unique_element([3]) == 3 >>> find_unique_element([-1, -2, -3, -2, -1]) == -3 >>> find_unique_element([100000, 99999, 100000, 99999, 99998]) == 99998 pass def process_input(data): Process multiple datasets and return results for each. >>> process_input(\\"1 2 3 2 1n4 5 4 5 9 7 7\\") == [3, 9] >>> process_input(\\"1 1 2 2 3 3 4 4 5 5 6n0 0 -1 -1 -2 -2 99\\") == [6, 99] pass def main(): import sys input_data = sys.stdin.read() results = process_input(input_data) for result in results: print(result)","solution":"def find_unique_element(seq): Returns the element that appears exactly once in the sequence. num_count = {} for num in seq: if num in num_count: num_count[num] += 1 else: num_count[num] = 1 for num, count in num_count.items(): if count == 1: return num def process_input(data): Process multiple datasets and return results for each. results = [] for line in data.splitlines(): nums = list(map(int, line.split())) unique_num = find_unique_element(nums) results.append(unique_num) return results def main(): import sys input_data = sys.stdin.read() results = process_input(input_data) for result in results: print(result)"},{"question":"def calculate_fare(D: int) -> int: Calculate the total fare based on the distance traveled D. Parameters: D (int): The distance traveled in kilometers Returns: int: The total fare for the bus ride >>> calculate_fare(4) == 50 >>> calculate_fare(7) == 70 >>> calculate_fare(11) == 110","solution":"def calculate_fare(D): Calculate the total fare based on the distance traveled D. Parameters: D (int): The distance traveled in kilometers Returns: int: The total fare for the bus ride base_fare = 50 additional_fare_per_km = 10 if D <= 5: return base_fare else: additional_distance = D - 5 additional_fare = additional_distance * additional_fare_per_km total_fare = base_fare + additional_fare return total_fare"},{"question":"from typing import List, Tuple def rank_participants(n: int, participants: List[Tuple[str, int]]) -> List[str]: Calculates the ranks of the participants based on their scores and names. Args: n (int): Number of participants participants (List[Tuple[str, int]]): List of tuples containing participant's name and score Returns: List[str]: List containing the name of the participant followed by their rank. >>> rank_participants(3, [(\\"Alice\\", 95), (\\"Bob\\", 100), (\\"Charlie\\", 100)]) [\\"Bob 1\\", \\"Charlie 2\\", \\"Alice 3\\"] >>> rank_participants(4, [(\\"David\\", 50), (\\"Eva\\", 40), (\\"Frank\\", 50), (\\"Grace\\", 60)]) [\\"Grace 1\\", \\"David 2\\", \\"Frank 3\\", \\"Eva 4\\"] >>> rank_participants(2, [(\\"Emma\\", 85), (\\"Liam\\", 85)]) [\\"Emma 1\\", \\"Liam 2\\"]","solution":"def rank_participants(n, participants): # Sort participants first by score in descending order, then by name in ascending order participants.sort(key=lambda x: (-x[1], x[0])) result = [] for rank, (name, _) in enumerate(participants, start=1): result.append(f\\"{name} {rank}\\") return result"},{"question":"import math from typing import List, Tuple def is_equilateral_triangle(x1: float, y1: float, x2: float, y2: float, x3: float, y3: float) -> bool: Check if three points form an equilateral triangle. >>> is_equilateral_triangle(0, 0, 3, 0, 1.5, math.sqrt(6.75)) True >>> is_equilateral_triangle(0, 0, 3, 0, 1, 1) False def check_equilateral_triangles(test_cases: List[Tuple[float, float, float, float, float, float]]) -> List[str]: For a list of test cases, determine if the points form an equilateral triangle. Each test case is a tuple containing the coordinates of three points (x1, y1, x2, y2, x3, y3). Returns a list of \\"YES\\" or \\"NO\\" for each test case. >>> check_equilateral_triangles([(0, 0, 3, 0, 1.5, math.sqrt(6.75))]) [\\"YES\\"] >>> check_equilateral_triangles([(0, 0, 3, 0, 1, 1)]) [\\"NO\\"]","solution":"import math def is_equilateral_triangle(x1, y1, x2, y2, x3, y3): def distance(x1, y1, x2, y2): return math.sqrt((x2 - x1)**2 + (y2 - y1)**2) d1 = distance(x1, y1, x2, y2) d2 = distance(x2, y2, x3, y3) d3 = distance(x3, y3, x1, y1) epsilon = 1e-6 # Small tolerance value to account for floating point precision return abs(d1 - d2) < epsilon and abs(d2 - d3) < epsilon and abs(d1 - d3) < epsilon def check_equilateral_triangles(test_cases): results = [] for points in test_cases: x1, y1, x2, y2, x3, y3 = points if is_equilateral_triangle(x1, y1, x2, y2, x3, y3): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def full_days_of_operation(T: int, test_cases: List[Tuple[int, int]]) -> List[int]: Given the number of test cases and a list of tuples where each tuple contains two integers P and D, returns the number of full days each robotic pet can operate before the battery depletes. Args: T : int : number of test cases test_cases : list of tuples : each tuple contains two integers P and D Returns: list of int : number of full days the pet can operate for each test case >>> full_days_of_operation(3, [(100, 20), (60, 30), (50, 50)]) [5, 2, 1] >>> full_days_of_operation(2, [(100, 25), (70, 10)]) [4, 7] >>> full_days_of_operation(1, [(50, 50)]) [1] >>> full_days_of_operation(1, [(99, 3)]) [33] >>> full_days_of_operation(4, [(100, 33), (80, 20), (75, 25), (30, 15)]) [3, 4, 3, 2]","solution":"def full_days_of_operation(T, test_cases): Given the number of test cases and a list of tuples where each tuple contains two integers P and D, returns the number of full days each robotic pet can operate before the battery depletes. Args: T : int : number of test cases test_cases : list of tuples : each tuple contains two integers P and D Returns: list of int : number of full days the pet can operate for each test case results = [] for P, D in test_cases: results.append(P // D) return results"},{"question":"def is_awesome(word: str) -> str: Determine if a word is 'awesome'. A word is considered \\"awesome\\" if it contains at least one vowel (a, e, i, o, u) and the length of the word is at least 5 characters. >>> is_awesome(\\"hello\\") == \\"awesome\\" >>> is_awesome(\\"sky\\") == \\"not awesome\\" >>> is_awesome(\\"awesome\\") == \\"awesome\\" >>> is_awesome(\\"AeiOu\\") == \\"awesome\\" >>> is_awesome(\\"HELLO\\") == \\"awesome\\" >>> is_awesome(\\"sk\\") == \\"not awesome\\" >>> is_awesome(\\"vowel\\") == \\"awesome\\" >>> is_awesome(\\"vol\\") == \\"not awesome\\" def check_words(number_of_cases: int, words: list) -> list: Check multiple words to determine if each is 'awesome'. >>> check_words(3, [\\"hello\\", \\"sky\\", \\"awesome\\"]) == [\\"awesome\\", \\"not awesome\\", \\"awesome\\"] >>> check_words(2, [\\"volcano\\", \\"skim\\"]) == [\\"awesome\\", \\"not awesome\\"] >>> check_words(1, [\\"skylight\\"]) == [\\"awesome\\"] >>> check_words(4, [\\"odra\\", \\"pencil\\", \\"laugh\\", \\"mozilla\\"]) == [\\"not awesome\\", \\"awesome\\", \\"awesome\\", \\"awesome\\"] >>> check_words(3, [\\"desk\\", \\"file\\", \\"data\\"]) == [\\"not awesome\\", \\"not awesome\\", \\"not awesome\\"]","solution":"def is_awesome(word): Determines if a word is 'awesome'. A word is considered \\"awesome\\" if it contains at least one vowel (a, e, i, o, u) and the length of the word is at least 5 characters. Parameters: word (str): The word to be checked. Returns: str: \\"awesome\\" if the word is awesome, otherwise \\"not awesome\\". vowels = set('aeiou') if len(word) >= 5 and any(char in vowels for char in word.lower()): return \\"awesome\\" else: return \\"not awesome\\" def check_words(number_of_cases, words): Checks multiple words to determine if each is 'awesome'. Parameters: number_of_cases (int): Number of test cases. words (list): List of words to be checked. Returns: list: Results for each word. results = [] for word in words: results.append(is_awesome(word)) return results def main(): import sys input = sys.stdin.read data = input().strip().split() T = int(data[0]) words = data[1:T + 1] results = check_words(T, words) for result in results: print(result)"},{"question":"def find_kth_smallest(N, K, A): Returns the Kth smallest element in the array A of size N. >>> find_kth_smallest(5, 2, [7, 10, 4, 3, 20]) 4 >>> find_kth_smallest(7, 5, [7, 10, 4, 3, 20, 15, 2]) 10 pass def process_test_cases(T, test_cases): Process multiple test cases and return a list of results. >>> process_test_cases(2, [(5, 2, [7, 10, 4, 3, 20]), (7, 5, [7, 10, 4, 3, 20, 15, 2])]) [4, 10] pass","solution":"def find_kth_smallest(N, K, A): Returns the Kth smallest element in the array A of size N. A.sort() return A[K-1] def process_test_cases(T, test_cases): results = [] for case in test_cases: N, K, A = case result = find_kth_smallest(N, K, A) results.append(result) return results"},{"question":"def min_non_decreasing_subsequences(seq): Returns the minimum number of non-decreasing subsequences the sequence can be split into. >>> min_non_decreasing_subsequences([5]) 1 >>> min_non_decreasing_subsequences([5, 4, 3, 2, 1]) 5 >>> min_non_decreasing_subsequences([1, 3, 2, 2, 4, 3]) 2 >>> min_non_decreasing_subsequences([2, 1, 4, 3]) 2 >>> min_non_decreasing_subsequences([5, 5, 5, 5]) 1 >>> min_non_decreasing_subsequences([1, 2, 3, 4, 5]) 1","solution":"def min_non_decreasing_subsequences(seq): Returns the minimum number of non-decreasing subsequences the sequence can be split into. n = len(seq) if n == 0: return 0 # This will keep track of the end elements of each subsequence ends = [] for number in seq: # Try to place the number in an existing subsequence placed = False for i in range(len(ends)): if ends[i] <= number: ends[i] = number placed = True break # If the number can't be placed in any existing subsequences, create a new subsequence if not placed: ends.append(number) return len(ends)"},{"question":"def count_valid_fire_starts(grid, n, m): Determine the number of valid initial fire positions such that the fire consumes all open spaces. Args: grid (List[List[str]]): The urban area grid with '.' representing open spaces and '#' representing buildings. n (int): The height of the grid. m (int): The width of the grid. Returns: int: The number of valid initial fire positions modulo 1,000,000,007. def solve(): Reads input grid configurations, processes each test case, and prints the results as specified. def test_example(): from io import StringIO import sys sys.stdin = StringIO(''' 3 3 ... .#. ... 4 4 .... .. .. .... 0 0 ''') solve() def test_single_open_space(): from io import StringIO import sys sys.stdin = StringIO(''' 2 3 .#. .#. 0 0 ''') solve() def test_no_valid_positions(): from io import StringIO import sys sys.stdin = StringIO(''' 2 2 0 0 ''') solve() def test_large_input(): from io import StringIO import sys grid = \\".\\" * 500 sys.stdin = StringIO(f''' 1 500 {grid} 0 0 ''') solve()","solution":"def count_valid_fire_starts(grid, n, m): MOD = 1000000007 def dfs(x, y, visited): if x < 0 or y < 0 or x >= n or y >= m or grid[x][y] == '#' or visited[x][y]: return visited[x][y] = True dfs(x + 1, y, visited) dfs(x - 1, y, visited) dfs(x, y + 1, visited) dfs(x, y - 1, visited) open_spaces = {(i, j) for i in range(n) for j in range(m) if grid[i][j] == '.'} start_positions = 0 for x, y in open_spaces: visited = [[False] * m for _ in range(n)] dfs(x, y, visited) if all(visited[i][j] or grid[i][j] == '#' for i, j in open_spaces): start_positions += 1 start_positions %= MOD return start_positions def solve(): import sys input = sys.stdin.read data = input().split() index = 0 results = [] while index < len(data): n = int(data[index]) m = int(data[index + 1]) index += 2 if n == 0 and m == 0: break grid = [] for _ in range(n): grid.append(data[index]) index += 1 results.append(count_valid_fire_starts(grid, n, m)) for result in results: print(result)"},{"question":"def increment_values(object_list, increment): Updates the \`value\` of each object in the list by incrementing it based on its position. Parameters: object_list (list): A list of dictionaries, each containing 'id' and 'value'. increment (int): The value to increment each object's 'value' by, based on its position in the list. Returns: list: The updated list with incremented values. >>> increment_values( ... [ ... {\\"id\\": 1, \\"value\\": 3}, ... {\\"id\\": 2, \\"value\\": 7}, ... {\\"id\\": 3, \\"value\\": 5} ... ], ... 3 ... ) [{'id': 1, 'value': 6}, {'id': 2, 'value': 13}, {'id': 3, 'value': 14}] >>> increment_values( ... [ ... {\\"id\\": 1, \\"value\\": 10}, ... {\\"id\\": 2, \\"value\\": 20}, ... {\\"id\\": 3, \\"value\\": 30} ... ], ... 5 ... ) [{'id': 1, 'value': 15}, {'id': 2, 'value': 30}, {'id': 3, 'value': 45}]","solution":"def increment_values(object_list, increment): Updates the \`value\` of each object in the list by incrementing it based on its position. Parameters: object_list (list): A list of dictionaries, each containing 'id' and 'value'. increment (int): The value to increment each object's 'value' by, based on its position in the list. Returns: list: The updated list with incremented values. for index, obj in enumerate(object_list): obj['value'] += (index + 1) * increment return object_list"},{"question":"def shortest_length_after_removal(S: str) -> int: Determine the length of the shortest possible string after performing one removal of two consecutive identical letters. Args: S (str): The input string consisting of lowercase English letters. Returns: int: The length of the resulting string. >>> shortest_length_after_removal(\\"aabbcc\\") 4 >>> shortest_length_after_removal(\\"abba\\") 2 >>> shortest_length_after_removal(\\"abcdef\\") 6 >>> shortest_length_after_removal(\\"aabb\\") 2 >>> shortest_length_after_removal(\\"aabbccdd\\") 6 >>> shortest_length_after_removal(\\"aaaa\\") 2 >>> shortest_length_after_removal(\\"\\") 0 >>> shortest_length_after_removal(\\"a\\") 1 >>> shortest_length_after_removal(\\"abcabcabcabc\\") 12 >>> shortest_length_after_removal(\\"aaabbb\\") 4","solution":"def shortest_length_after_removal(S): Determine the length of the shortest possible string after performing one removal of two consecutive identical letters. Args: S (str): The input string consisting of lowercase English letters. Returns: int: The length of the resulting string. for i in range(len(S) - 1): if S[i] == S[i + 1]: # Removing the first pair of consecutive identical letters found return len(S) - 2 # If no consecutive identical letters are found return len(S)"},{"question":"def is_subsequence(str1: str, str2: str) -> bool: Determine if str1 is a subsequence of str2. >>> is_subsequence(\\"abc\\", \\"abcdef\\") # True >>> is_subsequence(\\"axc\\", \\"abcdef\\") # False >>> is_subsequence(\\"hello\\", \\"heoollllooow\\") # True >>> is_subsequence(\\"hello\\", \\"helium\\") # False >>> is_subsequence(\\"\\", \\"abcdef\\") # True >>> is_subsequence(\\"abc\\", \\"\\") # False >>> is_subsequence(\\"abcdef\\", \\"abcdef\\") # True >>> is_subsequence(\\"abcdefg\\", \\"abc\\") # False >>> is_subsequence(\\"a\\", \\"abcdef\\") # True >>> is_subsequence(\\"z\\", \\"abcdef\\") # False","solution":"def is_subsequence(str1, str2): Determine if str1 is a subsequence of str2. iter_str2 = iter(str2) return all(char in iter_str2 for char in str1)"},{"question":"def min_height_difference(n: int, heights: List[int]) -> int: Given an array of block heights, determines the minimal height difference between the tallest and shortest blocks after optimally removing and stacking any contiguous subarray. Args: n (int): The number of blocks. heights (List[int]): The list of block heights. Returns: int: The minimal possible height difference. Examples: >>> min_height_difference(5, [4, 2, 7, 5, 3]) 1 >>> min_height_difference(3, [1, 2, 3]) 0","solution":"def min_height_difference(n, heights): Given an array of block heights, determines the minimal height difference between the tallest and shortest blocks after optimally removing and stacking any contiguous subarray. if n == 0: return 0 total_blocks = sum(heights) # The minimum possible height after optimal stacking will be the average height (divided blocks equally) average_height = total_blocks // n remainder = total_blocks % n if remainder == 0: return 0 else: return 1 # Example execution # print(min_height_difference(5, [4, 2, 7, 5, 3])) # Expected output: 1 # print(min_height_difference(3, [1, 2, 3])) # Expected output: 0"},{"question":"def longest_common_subsequence(A: str, B: str) -> int: Returns the length of the longest common subsequence between two strings A and B. >>> longest_common_subsequence('ABCBDAB', 'BDCAB') 4 >>> longest_common_subsequence('ABCDEFG', 'HIJKLMN') 0 >>> longest_common_subsequence('ABCDEFG', 'ABCDEFG') 7 >>> longest_common_subsequence('ABCDEFG', 'GFEDCBA') 1 >>> longest_common_subsequence('AGGTAB', 'GXTXAYB') 4","solution":"def longest_common_subsequence(A, B): Returns the length of the longest common subsequence between two strings A and B. n = len(A) m = len(B) dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): if A[i - 1] == B[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m]"},{"question":"def maximum_possible_score(n: int) -> int: Given the number of players, return the maximum possible score a player can achieve. >>> maximum_possible_score(1) 1 >>> maximum_possible_score(3) 6 >>> maximum_possible_score(5) 15 >>> maximum_possible_score(10) 55 >>> maximum_possible_score(1000) 500500","solution":"def maximum_possible_score(n): Given the number of players, return the maximum possible score a player can achieve. return sum(range(1, n + 1))"},{"question":"def replace_with_products(lst: List[int]) -> List[int]: Replace each element in the list with the product of every other element. >>> replace_with_products([1, 2, 3, 4]) == [24, 12, 8, 6] >>> replace_with_products([2, 3, 4, 5]) == [60, 40, 30, 24]","solution":"def replace_with_products(lst): Replace each element in the list with the product of every other element. n = len(lst) if n == 0: return [] # Initialize two lists to store prefix products and suffix products prefix_products = [1] * n suffix_products = [1] * n # Generate prefix products for i in range(1, n): prefix_products[i] = prefix_products[i - 1] * lst[i - 1] # Generate suffix products for i in range(n - 2, -1, -1): suffix_products[i] = suffix_products[i + 1] * lst[i + 1] # Generate result by multiplying prefix and suffix products result = [1] * n for i in range(n): result[i] = prefix_products[i] * suffix_products[i] return result"},{"question":"def max_duels_won(n, a, b): Determines the maximum number of duels the first warrior can win. Parameters: n (int): Number of weapons each warrior has. a (list): List of weapon powers for the first warrior. b (list): List of weapon powers for the second warrior. Returns: int: Maximum number of duels the first warrior can win. >>> max_duels_won(5, [3, 6, 7, 5, 3], [6, 3, 5, 8, 7]) == 3 >>> max_duels_won(3, [10, 10, 10], [10, 10, 10]) == 0 >>> max_duels_won(3, [7, 8, 9], [4, 5, 6]) == 3 >>> max_duels_won(3, [1, 2, 3], [4, 5, 6]) == 0 >>> max_duels_won(4, [1, 11, 2, 10], [3, 8, 9, 4]) == 2","solution":"def max_duels_won(n, a, b): Determines the maximum number of duels the first warrior can win. Parameters: n (int): Number of weapons each warrior has. a (list): List of weapon powers for the first warrior. b (list): List of weapon powers for the second warrior. Returns: int: Maximum number of duels the first warrior can win. a.sort() # Sort weapons' power of the first warrior b.sort() # Sort weapons' power of the second warrior i, j = 0, 0 # Two pointers to traverse both lists wins = 0 while i < n and j < n: if a[i] > b[j]: wins += 1 j += 1 i += 1 return wins"},{"question":"from typing import List def max_sum_subarray_no_more_than_k(nums: List[int], k: int) -> int: Returns the maximum possible sum of a non-empty subarray that does not exceed k. >>> max_sum_subarray_no_more_than_k([2, 1, -3, 4, -1, 2, 1, -5, 4], 6) 6 >>> max_sum_subarray_no_more_than_k([1, 2, 3], 7) 6 >>> max_sum_subarray_no_more_than_k([-2, -1, -3, -4, 0], -1) -1 from bisect import bisect_left, insort def test_example_1(): nums = [2, 1, -3, 4, -1, 2, 1, -5, 4] k = 6 assert max_sum_subarray_no_more_than_k(nums, k) == 6 def test_example_2(): nums = [1, 2, 3] k = 7 assert max_sum_subarray_no_more_than_k(nums, k) == 6 def test_example_3(): nums = [-2, -1, -3, -4, 0] k = -1 assert max_sum_subarray_no_more_than_k(nums, k) == -1 def test_single_element(): nums = [5] k = 3 assert max_sum_subarray_no_more_than_k(nums, k) == -float('inf') def test_all_positive(): nums = [1, 2, 3, 4] k = 10 assert max_sum_subarray_no_more_than_k(nums, k) == 10 def test_all_negative(): nums = [-5, -3, -1] k = -2 assert max_sum_subarray_no_more_than_k(nums, k) == -3 def test_mixed_elements(): nums = [3, -2, 5, -1] k = 4 assert max_sum_subarray_no_more_than_k(nums, k) == 4 def test_edge_case(): nums = [10000] * 20000 k = 50000 assert max_sum_subarray_no_more_than_k(nums, k) == 50000","solution":"from bisect import bisect_left, insort def max_sum_subarray_no_more_than_k(nums, k): Returns the maximum possible sum of a non-empty subarray that does not exceed k. if not nums: return 0 max_sum = float('-inf') prefix_sum = 0 prefix_sums = [0] for num in nums: prefix_sum += num # Find the largest sum where (prefix_sum - prefix_sums[i]) <= k idx = bisect_left(prefix_sums, prefix_sum - k) if idx < len(prefix_sums): max_sum = max(max_sum, prefix_sum - prefix_sums[idx]) insort(prefix_sums, prefix_sum) return max_sum"},{"question":"def find_disappeared_numbers(nums): Finds all the numbers from 1 to n that do not appear in the array nums. Args: nums (List[int]): The input array. Returns: List[int]: A list of integers that do not appear in nums. pass from solution import find_disappeared_numbers def test_find_disappeared_numbers_example1(): assert find_disappeared_numbers([4,3,2,7,8,2,3,1]) == [5, 6] def test_find_disappeared_numbers_example2(): assert find_disappeared_numbers([1,1]) == [2] def test_find_disappeared_numbers_single_element(): assert find_disappeared_numbers([1]) == [] def test_find_disappeared_numbers_no_missing(): assert find_disappeared_numbers([1,2,3,4,5]) == [] def test_find_disappeared_numbers_all_missing(): assert find_disappeared_numbers([5,5,5,5,5]) == [1, 2, 3, 4] def test_find_disappeared_numbers_varied(): assert find_disappeared_numbers([2,4,4,3,3,1,7,7]) == [5, 6, 8] def test_find_disappeared_numbers_edge_case(): assert find_disappeared_numbers([2,2,2,2,2,2,2,2,2,2]) == [1, 3, 4, 5, 6, 7, 8, 9, 10]","solution":"def find_disappeared_numbers(nums): Finds all the numbers from 1 to n that do not appear in the array nums. Args: nums (List[int]): The input array. Returns: List[int]: A list of integers that do not appear in nums. # Mark each number encountered by flipping the sign of the number at the index for num in nums: index = abs(num) - 1 if nums[index] > 0: nums[index] = -nums[index] # Collect all indices that were not flipped result = [i + 1 for i in range(len(nums)) if nums[i] > 0] return result"},{"question":"from typing import List, Tuple, Union def manage_appointments(D: int, P: int, requests: List[Tuple[int, int, int]]) -> List[Union[int, str]]: Manages the scheduling of appointments. :param D: Number of doctors :param P: Number of appointment requests :param requests: List of tuples containing (patientID, day, timeSlot) :return: List of results where each entry is either a doctor's ID or \\"Conflict\\" def test_sample_input_1(): D = 2 P = 3 requests = [(1, 1, 9), (2, 1, 9), (1, 1, 10)] assert manage_appointments(D, P, requests) == [1, 2, 1] def test_sample_input_2(): D = 3 P = 4 requests = [(1, 3, 15), (2, 3, 15), (1, 3, 15), (3, 4, 12)] assert manage_appointments(D, P, requests) == [1, 2, 'Conflict', 1] def test_conflict_due_to_existing_appointment(): D = 1 P = 2 requests = [(1, 1, 9), (1, 1, 9)] assert manage_appointments(D, P, requests) == [1, 'Conflict'] def test_doctor_assignment_when_others_busy(): D = 2 P = 3 requests = [(1, 1, 9), (2, 1, 9), (3, 1, 9)] assert manage_appointments(D, P, requests) == [1, 2, 'Conflict'] def test_multiple_days_and_time_slots(): D = 2 P = 5 requests = [(1, 1, 9), (1, 1, 10), (2, 2, 9), (2, 2, 10), (1, 1, 9)] assert manage_appointments(D, P, requests) == [1, 1, 1, 1, 'Conflict']","solution":"def manage_appointments(D, P, requests): Manages the scheduling of appointments. :param D: Number of doctors :param P: Number of appointment requests :param requests: List of tuples containing (patientID, day, timeSlot) :return: List of results where each entry is either a doctor's ID or \\"Conflict\\" # Dictionary to keep track of patients' appointments patient_schedule = {} # Dictionary to keep track of doctors' appointments doctor_schedule = {doctor: {} for doctor in range(1, D + 1)} results = [] for patientID, day, timeSlot in requests: # Check if the patient already has an appointment at the same time on the same day if (day, timeSlot) in patient_schedule.get(patientID, set()): results.append('Conflict') else: # Try to find an available doctor assigned = False for doctor in range(1, D + 1): if timeSlot not in doctor_schedule[doctor].get(day, set()): # Assign patient to this doctor if doctor_schedule[doctor].get(day) is None: doctor_schedule[doctor][day] = set() doctor_schedule[doctor][day].add(timeSlot) if patient_schedule.get(patientID) is None: patient_schedule[patientID] = set() patient_schedule[patientID].add((day, timeSlot)) results.append(doctor) assigned = True break if not assigned: results.append('Conflict') return results"},{"question":"def capitalize_sentence(s: str) -> str: Capitalizes the first letter of each word in the sentence. Parameters: s (str): Input sentence Returns: str: Modified sentence with each word capitalized Examples: >>> capitalize_sentence(\\"hello world\\") \\"Hello World\\" >>> capitalize_sentence(\\"this is a test\\") \\"This Is A Test\\" >>> capitalize_sentence(\\"2b or not 2b\\") \\"2b Or Not 2b\\" >>> capitalize_sentence(\\"multiple spaces here\\") \\"Multiple Spaces Here\\" >>> capitalize_sentence(\\"already Capitalized\\") \\"Already Capitalized\\"","solution":"def capitalize_sentence(s): Capitalizes the first letter of each word in the sentence. Parameters: s (str): Input sentence Returns: str: Modified sentence with each word capitalized return ' '.join(word.capitalize() for word in s.split(' '))"},{"question":"def count_valleys(R, C, grid): Determine the number of valleys in the given R x C grid. A valley is defined as a cell that has a lower height than all of its 4 direct neighboring cells (top, bottom, left, right). Args: R (int): Number of rows in the grid. C (int): Number of columns in the grid. grid (List[List[int]]): The height values of the land. Returns: int: The number of valleys in the grid. Example: >>> count_valleys(3, 3, [ [9, 8, 9], [8, 7, 8], [9, 8, 9] ]) 1 >>> count_valleys(4, 4, [ [1, 2, 1, 2], [2, 1, 2, 1], [1, 2, 1, 2], [2, 1, 2, 1] ]) 8 pass def find_treasure_valleys(T, test_cases): Process multiple test cases to find the number of valleys in each grid. Args: T (int): The number of test cases. test_cases (List[Tuple[int, int, List[List[int]]]]): List of tuples where each tuple contains: - R (int): Number of rows in the grid. - C (int): Number of columns in the grid. - grid (List[List[int]]): The height values of the land. Returns: List[int]: A list containing the number of valleys for each test case. Example: >>> find_treasure_valleys(2, [ (3, 3, [ [9, 8, 9], [8, 7, 8], [9, 8, 9] ]), (4, 4, [ [1, 2, 1, 2], [2, 1, 2, 1], [1, 2, 1, 2], [2, 1, 2, 1] ]) ]) [1, 8] pass","solution":"def count_valleys(R, C, grid): def is_valley(i, j): current_height = grid[i][j] for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]: ni, nj = i + di, j + dj if 0 <= ni < R and 0 <= nj < C and grid[ni][nj] <= current_height: return False return True valley_count = 0 for i in range(R): for j in range(C): if is_valley(i, j): valley_count += 1 return valley_count def find_treasure_valleys(T, test_cases): results = [] for test_case in test_cases: R, C, grid = test_case results.append(count_valleys(R, C, grid)) return results"},{"question":"def minOperations(s1: str, s2: str) -> (int, int): Given two strings s1 and s2, determine the minimum number of insertions and deletions required to transform s1 into s2. Returns a pair of integers indicating the required number of deletions and insertions respectively. Example: >>> minOperations(\\"heap\\", \\"pea\\") (2, 1) >>> minOperations(\\"abcd\\", \\"anc\\") (2, 1)","solution":"def minOperations(s1, s2): Returns the number of deletions and insertions required to transform s1 into s2. len1, len2 = len(s1), len(s2) # Creating a 2D DP array to store the lengths of longest common subsequence. dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] # Fill dp array for i in range(1, len1 + 1): for j in range(1, len2 + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Length of longest common subsequence lcs = dp[len1][len2] # Deletions = characters in s1 not in lcs deletions = len1 - lcs # Insertions = characters in s2 not in lcs insertions = len2 - lcs return deletions, insertions"},{"question":"def convert_list_to_dict(fruit_list): Converts a list of strings in the format 'fruit=quantity' to a dictionary with fruits as keys and quantities as integers. Args: fruit_list (list): List of strings in the format 'fruit=quantity', e.g. [\\"apple=5\\", \\"banana=12\\", \\"cherry=7\\", \\"date=3\\"] Returns: dict: Dictionary with fruits as keys and quantities as integers.","solution":"def convert_list_to_dict(fruit_list): Converts a list of strings in the format 'fruit=quantity' to a dictionary with fruits as keys and quantities as integers. Args: fruit_list (list): List of strings in the format 'fruit=quantity', e.g. [\\"apple=5\\", \\"banana=12\\", \\"cherry=7\\", \\"date=3\\"] Returns: dict: Dictionary with fruits as keys and quantities as integers. fruit_dict = {} for item in fruit_list: fruit, quantity = item.split('=') fruit_dict[fruit] = int(quantity) return fruit_dict"},{"question":"def longest_substring_with_k_distinct_characters(s: str, k: int) -> int: Returns the length of the longest substring with at most k distinct characters. Parameters: s (str): The input string. k (int): The number of distinct characters. Returns: int: The length of the longest substring with at most k distinct characters. >>> longest_substring_with_k_distinct_characters(\\"araaci\\", 2) == 4 >>> longest_substring_with_k_distinct_characters(\\"araaci\\", 1) == 2 >>> longest_substring_with_k_distinct_characters(\\"cbbebi\\", 3) == 5 >>> longest_substring_with_k_distinct_characters(\\"abc\\", 0) == 0 >>> longest_substring_with_k_distinct_characters(\\"aa\\", 1) == 2","solution":"def longest_substring_with_k_distinct_characters(s, k): Returns the length of the longest substring with at most k distinct characters. Parameters: s (str): The input string. k (int): The number of distinct characters. Returns: int: The length of the longest substring with at most k distinct characters. if k == 0: return 0 window_start = 0 max_length = 0 char_frequency = {} for window_end in range(len(s)): right_char = s[window_end] if right_char not in char_frequency: char_frequency[right_char] = 0 char_frequency[right_char] += 1 while len(char_frequency) > k: left_char = s[window_start] char_frequency[left_char] -= 1 if char_frequency[left_char] == 0: del char_frequency[left_char] window_start += 1 max_length = max(max_length, window_end - window_start + 1) return max_length"},{"question":"import math from typing import List def min_h(N: int) -> int: Return the minimum value of h(a, b) over all pairs of integers (a, b) such that 1 ≤ a, b ≤ N. pass def count_pairs_with_min_h(N: int) -> int: Return the total number of pairs (a, b) for which h(a, b) = min_h(N). pass def process_test_cases(T: int, test_cases: List[int]) -> List[int]: For each test case, output the total number of pairs (a, b) such that h(a, b) = min_h(N). Args: T : int : number of test cases test_cases : List[int] : list of positive integers N Returns: List[int] : list of results for each test case >>> process_test_cases(2, [3, 5]) [3, 7] >>> process_test_cases(1, [1]) [1] pass","solution":"import math def min_h(N): if N == 1: return 1 # edge case as only one pair (1, 1) # Minimum h occurs when a=gcd(min(a, b)) is 1, and # the lcm of a and b will be a * b/ gcd(a, b) which simplifies to b if a is 1 # min_h(N) = 2 for any N >= 1 cause h(1,1) = |1-1| + gcd(1,1) + lcm(1,1) = 0 + 1 + 1 = 2 return N def count_pairs_with_min_h(N): return 2 * N - 1 def process_test_cases(T, test_cases): results = [] for N in test_cases: min_h_N = min_h(N) count = count_pairs_with_min_h(N) results.append(count) return results # Example use case if __name__ == \\"__main__\\": T = 2 test_cases = [3, 5] print(process_test_cases(T, test_cases)) # Output: [3, 5]"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Returns the maximum sum of any contiguous subarray using Kadane's algorithm. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum([1]) == 1 >>> max_subarray_sum([-1, -2, -3, -4]) == -1 >>> max_subarray_sum([1, 2, 3, 4]) == 10 >>> max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7 >>> max_subarray_sum([-1]) == -1 >>> max_subarray_sum(list(range(-10000, 10000))) == sum(range(0, 10000))","solution":"def max_subarray_sum(nums): Returns the maximum sum of any contiguous subarray using Kadane's algorithm. max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def min_operations_to_make_equal(n: int, arr: List[int]) -> int: Calculate the minimum number of operations required to make all sequence elements equal by either incrementing or decrementing each element by 1. :param n: Number of elements in the sequence :param arr: List of integers representing the sequence :return: Minimum number of operations required >>> min_operations_to_make_equal(4, [1, 2, 3, 4]) 4 >>> min_operations_to_make_equal(3, [5, 5, 5]) 0 >>> min_operations_to_make_equal(2, [10, 20]) 10 >>> min_operations_to_make_equal(3, [100, 200, 300]) 200 >>> min_operations_to_make_equal(5, [1, 10, 2, 9, 3]) 16","solution":"def min_operations_to_make_equal(n, arr): Calculate the minimum number of operations required to make all sequence elements equal by either incrementing or decrementing each element by 1. :param n: Number of elements in the sequence :param arr: List of integers representing the sequence :return: Minimum number of operations required # To minimize operations, we target the median of the array arr.sort() target = arr[n // 2] # Calculate the number of operations required to make all elements equal to the target operations = sum(abs(x - target) for x in arr) return operations"},{"question":"def fibonacci(n: int) -> int: Returns the n-th number in the Fibonacci sequence. Parameters: n (int): The position in the Fibonacci sequence. Returns: int: The n-th Fibonacci number. >>> fibonacci(1) == 0 >>> fibonacci(2) == 1 >>> fibonacci(6) == 5 >>> fibonacci(10) == 34","solution":"def fibonacci(n): Returns the n-th number in the Fibonacci sequence. Parameters: n (int): The position in the Fibonacci sequence. Returns: int: The n-th Fibonacci number. if n <= 0: raise ValueError(\\"Input should be a positive integer\\") a, b = 0, 1 for _ in range(n - 1): a, b = b, a + b return a"},{"question":"from typing import List, Tuple def min_changes_to_non_decreasing(n: int, heights: List[int]) -> int: Returns the minimum number of changes required to make the flower heights non-decreasing. Args: n (int): The number of flowers. heights (List[int]): The list of integers denoting the heights of the flowers. Returns: int: The minimum number of changes required. Examples: >>> min_changes_to_non_decreasing(4, [3, 1, 4, 2]) 2 >>> min_changes_to_non_decreasing(5, [1, 2, 3, 4, 5]) 0 pass def solve(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Solve the problem for each test case. Args: test_cases (List[Tuple[int, List[int]]]): The list of test cases, each containing an integer n and a list of n integers representing the heights of the flowers. Returns: List[int]: The list of results for each test case. Examples: >>> solve([(4, [3, 1, 4, 2]), (5, [1, 2, 3, 4, 5])]) [2, 0] pass def parse_input(input_str: str) -> List[Tuple[int, List[int]]]: Parse the input string into a list of test cases. Args: input_str (str): The multiline input string. Returns: List[Tuple[int, List[int]]]: The parsed list of test cases. Examples: >>> input_str = \\"2n4n3 1 4 2n5n1 2 3 4 5\\" >>> parse_input(input_str) [(4, [3, 1, 4, 2]), (5, [1, 2, 3, 4, 5])] pass","solution":"def min_changes_to_non_decreasing(n, heights): Returns the minimum number of changes required to make the flower heights non-decreasing. # Create a list of tuples (height, original_position) indexed_heights = list(enumerate(heights)) # Sort based on heights indexed_heights.sort(key=lambda x: x[1]) # Identify the longest increasing subsequence (LIS) lis = [1] * n for i in range(1, n): for j in range(i): if indexed_heights[j][0] < indexed_heights[i][0] and indexed_heights[j][1] <= indexed_heights[i][1]: lis[i] = max(lis[i], lis[j] + 1) # The minimum number of changes required return n - max(lis) def solve(test_cases): results = [] for test in test_cases: n, heights = test results.append(min_changes_to_non_decreasing(n, heights)) return results def parse_input(input_str): lines = input_str.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): n = int(lines[index]) index += 1 heights = list(map(int, lines[index].split())) index += 1 test_cases.append((n, heights)) return test_cases"},{"question":"def has_room_with_most_people(matrix): Determines if there is a room with more people than any other room in the matrix. Params: matrix - List of List of integers representing the number of people in rooms. Returns: \\"YES\\" if such a room exists, otherwise \\"NO\\". pass def test_single_room(): matrix = [[5]] assert has_room_with_most_people(matrix) == \\"YES\\" def test_empty_matrix(): matrix = [] assert has_room_with_most_people(matrix) == \\"NO\\" def test_equal_people_rooms(): matrix = [ [2, 2], [2, 2] ] assert has_room_with_most_people(matrix) == \\"YES\\" def test_room_with_most_people(): matrix = [ [1, 3, 2], [4, 5, 6], [7, 8, 9] ] assert has_room_with_most_people(matrix) == \\"YES\\" def test_no_room_with_most_people(): matrix = [ [1, 2], [3, 4] ] assert has_room_with_most_people(matrix) == \\"YES\\"","solution":"def has_room_with_most_people(matrix): Determines if there is a room with more people than any other room in the matrix. Params: matrix - List of List of integers representing the number of people in rooms. Returns: \\"YES\\" if such a room exists, otherwise \\"NO\\". if not matrix or not matrix[0]: return \\"NO\\" max_people = float('-inf') for row in matrix: for people in row: if people > max_people: max_people = people for row in matrix: for people in row: if people == max_people: return \\"YES\\" return \\"NO\\" def main(): import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) M = int(data[1]) matrix = [] index = 2 for i in range(N): matrix.append(list(map(int, data[index:index+M]))) index += M result = has_room_with_most_people(matrix) print(result)"},{"question":"def is_permutation(n: int, arr: List[int]) -> str: Determines if the array 'arr' is a permutation of numbers from 1 to n. Args: n : int : Size of the array and the range of numbers (from 1 to n) arr : list of int : List containing integers Returns: str : \\"YES\\" if array is a permutation of numbers from 1 to n, otherwise \\"NO\\" >>> is_permutation(5, [1, 2, 3, 4, 5]) \\"YES\\" >>> is_permutation(5, [1, 2, 2, 4, 5]) \\"NO\\" >>> is_permutation(3, [3, 1, 2]) \\"YES\\" >>> is_permutation(3, [1, 2, 2]) \\"NO\\" >>> is_permutation(4, [4, 3, 1, 2]) \\"YES\\"","solution":"def is_permutation(n, arr): Determines if the array 'arr' is a permutation of numbers from 1 to n. Args: n : int : Size of the array and the range of numbers (from 1 to n) arr : list of int : List containing integers Returns: str : \\"YES\\" if array is a permutation of numbers from 1 to n, otherwise \\"NO\\" if sorted(arr) == list(range(1, n + 1)): return \\"YES\\" else: return \\"NO\\""},{"question":"def min_spaces_to_partition(s: str, word_dict: set) -> int: Given a string and a dictionary containing valid words, determine the minimum number of spaces required to partition the string such that every substring is a valid word in the dictionary. If it is impossible to partition the string into valid words, return -1. >>> min_spaces_to_partition(\\"applepie\\", {\\"apple\\", \\"pie\\"}) == 1 >>> min_spaces_to_partition(\\"applepieapple\\", {\\"apple\\", \\"pie\\"}) == 2 >>> min_spaces_to_partition(\\"catsandog\\", {\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"}) == -1 >>> min_spaces_to_partition(\\"pineapplepenapple\\", {\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"}) == 2 from solution import min_spaces_to_partition def test_single_word(): assert min_spaces_to_partition(\\"apple\\", {\\"apple\\"}) == 0 def test_no_partition_needed(): assert min_spaces_to_partition(\\"lemon\\", {\\"lemon\\"}) == 0 def test_simple_partition(): assert min_spaces_to_partition(\\"applepie\\", {\\"apple\\", \\"pie\\"}) == 1 def test_multiple_partitions(): assert min_spaces_to_partition(\\"applepieapple\\", {\\"apple\\", \\"pie\\"}) == 2 def test_impossible_partition(): assert min_spaces_to_partition(\\"catsandog\\", {\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"}) == -1 def test_overlapping_words(): assert min_spaces_to_partition(\\"pineapplepenapple\\", {\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"}) == 2 def test_incomplete_word(): assert min_spaces_to_partition(\\"applep\\", {\\"apple\\", \\"pie\\"}) == -1 def test_word_not_in_dict(): assert min_spaces_to_partition(\\"wordnotindict\\", {\\"word\\", \\"not\\", \\"in\\", \\"dict\\"}) == 3 def test_one_character_words(): assert min_spaces_to_partition(\\"abcde\\", {\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"}) == 4 def test_large_input(): large_string = \\"ab\\" * 150 words = {\\"a\\", \\"b\\", \\"ab\\"} assert min_spaces_to_partition(large_string, words) == 149","solution":"def min_spaces_to_partition(s: str, word_dict: set) -> int: Returns the minimum number of spaces required to partition the string such that every substring is a valid word in the dictionary. If it is impossible to partition the string into valid words, return -1. n = len(s) dp = [float('inf')] * (n + 1) dp[0] = 0 # No spaces needed for an empty substring for i in range(1, n + 1): for j in range(i): if s[j:i] in word_dict: dp[i] = min(dp[i], dp[j] + 1) return dp[n] - 1 if dp[n] != float('inf') else -1"},{"question":"class SocialNetwork: def __init__(self): self.users = {} self.follow_requests = {} def create_user(self, username, privacy_status): Create a new user with the given username and privacy status. pass def follow_user(self, follower_username, followed_username): Request to follow a user. If the user has a public account, directly become a follower. Otherwise, create a pending follow request. pass def approve_follow_request(self, followed_username, follower_username): Approve a follow request if the user has a private account. pass def display_followers(self, username): Display the list of followers for the given user. pass def process_instructions(instructions): network = SocialNetwork() for instruction in instructions: parts = instruction.split() if parts[0] == \\"CREATE\\": network.create_user(parts[1], parts[2]) elif parts[0] == \\"FOLLOW\\": network.follow_user(parts[1], parts[2]) elif parts[0] == \\"APPROVE\\": network.approve_follow_request(parts[1], parts[2]) elif parts[0] == \\"DISPLAY\\": network.display_followers(parts[1]) # Example input instructions = [ \\"CREATE alice public\\", \\"CREATE bob public\\", \\"CREATE charlie private\\", \\"FOLLOW alice bob\\", \\"FOLLOW charlie alice\\", \\"FOLLOW bob charlie\\", \\"APPROVE charlie bob\\", \\"DISPLAY alice\\", \\"DISPLAY bob\\", \\"DISPLAY charlie\\", \\"END\\" ] process_instructions(instructions)","solution":"class SocialNetwork: def __init__(self): self.users = {} self.follow_requests = {} def create_user(self, username, privacy_status): self.users[username] = { 'privacy_status': privacy_status, 'followers': [] } self.follow_requests[username] = [] def follow_user(self, follower_username, followed_username): if followed_username not in self.users or follower_username not in self.users: return if self.users[followed_username]['privacy_status'] == 'public': self.users[followed_username]['followers'].append(follower_username) else: self.follow_requests[followed_username].append(follower_username) def approve_follow_request(self, followed_username, follower_username): if followed_username not in self.follow_requests: return if follower_username in self.follow_requests[followed_username]: self.users[followed_username]['followers'].append(follower_username) self.follow_requests[followed_username].remove(follower_username) def display_followers(self, username): if username in self.users: for follower in self.users[username]['followers']: print(follower) def process_instructions(instructions): network = SocialNetwork() for instruction in instructions: parts = instruction.split() if parts[0] == \\"CREATE\\": network.create_user(parts[1], parts[2]) elif parts[0] == \\"FOLLOW\\": network.follow_user(parts[1], parts[2]) elif parts[0] == \\"APPROVE\\": network.approve_follow_request(parts[1], parts[2]) elif parts[0] == \\"DISPLAY\\": network.display_followers(parts[1]) # Example input instructions = [ \\"CREATE alice public\\", \\"CREATE bob public\\", \\"CREATE charlie private\\", \\"FOLLOW alice bob\\", \\"FOLLOW charlie alice\\", \\"FOLLOW bob charlie\\", \\"APPROVE charlie bob\\", \\"DISPLAY alice\\", \\"DISPLAY bob\\", \\"DISPLAY charlie\\", \\"END\\" ] process_instructions(instructions)"},{"question":"def is_prime(n: int) -> bool: Check if a given number n is prime. Args: n (int): The number to check for primality. Returns: bool: True if n is prime, False otherwise. Examples: >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(19) True def filter_primes(numbers: List[int]) -> List[int]: Filter the list of numbers and return only those which are prime. Args: numbers (List[int]): A list of integers to filter. Returns: List[int]: A new list containing only prime numbers. Examples: >>> filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> filter_primes([15, 22, 31, 45, 56, 68]) [31] >>> filter_primes([11, 14, 17, 19, 23]) [11, 17, 19, 23]","solution":"def is_prime(n): Check if a given number n is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(numbers): Filter the list of numbers and return only those which are prime. return [n for n in numbers if is_prime(n)]"},{"question":"def find_most_active_users(n: int, activities: List[str]) -> List[str]: Identify the user(s) with the highest number of 'post' activities. Given: n: An integer denoting the number of activities. activities: A list of strings where each string describes an activity in the format \\"username activity\\". Returns: A list of usernames of the most active users with respect to posts, in lexicographical order. If there are multiple users with the same highest number of posts, return them all. Examples: >>> find_most_active_users(7, [\\"alice post\\", \\"bob like\\", \\"alice post\\", \\"carol share\\", \\"bob post\\", \\"alice comment\\", \\"bob post\\"]) [\\"alice\\", \\"bob\\"]","solution":"def find_most_active_users(n, activities): from collections import defaultdict post_counts = defaultdict(int) for activity in activities: username, action = activity.split() if action == \\"post\\": post_counts[username] += 1 max_posts = max(post_counts.values(), default=0) most_active_users = [user for user, posts in post_counts.items() if posts == max_posts] return sorted(most_active_users)"},{"question":"def sum_of_squares_in_subarray(A, queries): Answer the queries by finding the sum of squares of all integers in the subarray A[L] to A[R] that are divisible by X. Args: A : List[int] : The array of integers. queries : List[Tuple[int, int, int]] : A list of queries where each query is a tuple (L, R, X). Returns: List[int] : A list of answers for each query. >>> A = [1, 6, 2, 8, 3, 7, 4, 5] >>> queries = [(1, 4, 2), (2, 6, 3), (3, 8, 5)] >>> sum_of_squares_in_subarray(A, queries) [104, 45, 25]","solution":"def sum_of_squares_in_subarray(A, queries): results = [] for L, R, X in queries: sum_of_squares = sum(a**2 for a in A[L-1:R] if a % X == 0) results.append(sum_of_squares) return results"},{"question":"def blooming_sets_count(N: int, K: int) -> int: Function to count the number of distinct \\"blooming sets\\" for given values of N and K modulo 10^9 + 7. >>> blooming_sets_count(5, 2) 5 >>> blooming_sets_count(6, 3) 12 >>> blooming_sets_count(8, 4) 0","solution":"def blooming_sets_count(N, K): Function to count the number of distinct \\"blooming sets\\" of length K modulo 10^9 + 7. MOD = 10**9 + 7 # If K > N, it's impossible to form such a blooming set if K > N: return 0 # If K == 2, the result is simply the number of flowers (adjacent pairs) if K == 2: return N # For K >= 3, the result is 0 unless K alternate adjacent flowers can cover around the circle if N % 2 == 0 and K == N: return 0 if K % 2 == 1: return (2 * N) % MOD else: return 0"},{"question":"def is_network_connected(n: int, m: int, connections: List[Tuple[int, int]], t: int) -> str: Determine if the network is still fully connected after a specified computer experiences an outage. Input: n - the number of computers m - the number of direct connections connections - list of tuples representing direct connections t - the computer experiencing an outage Output: \\"Connected\\" if the network remains fully connected after the outage, \\"Disconnected\\" otherwise. Examples: >>> is_network_connected(5, 4, [(1, 2), (1, 3), (2, 4), (3, 5)], 3) \\"Disconnected\\" >>> is_network_connected(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)], 4) \\"Connected\\" pass","solution":"def is_network_connected(n, m, connections, t): def dfs(node, visited, graph, outage_node): if node == outage_node: return visited.add(node) for neighbor in graph[node]: if neighbor not in visited: dfs(neighbor, visited, graph, outage_node) # Create the graph graph = {i: [] for i in range(1, n + 1)} for u, v in connections: graph[u].append(v) graph[v].append(u) # Outage node outage_node = t # Find any starting node not equal to the outage node start_node = next((i for i in range(1, n + 1) if i != outage_node), None) if start_node is None: return \\"Connected\\" visited = set() dfs(start_node, visited, graph, outage_node) # Check if all nodes except the outage node are visited for i in range(1, n + 1): if i != outage_node and i not in visited: return \\"Disconnected\\" return \\"Connected\\""},{"question":"def max_earnings(n: int, events: List[str]) -> int: Determine the maximum amount of money you can earn from selling seashells. Args: n (int): The number of visits. events (List[str]): A list of strings describing the events for each visit. Returns: int: The maximum amount of money you can earn in dollars. >>> max_earnings(5, [\\"found 10\\", \\"found 20\\", \\"offer 10\\", \\"found 30\\", \\"offer 30\\"]) 30 >>> max_earnings(3, [\\"found 10\\", \\"found 20\\", \\"found 30\\"]) 0 >>> max_earnings(6, [\\"found 10\\", \\"offer 10\\", \\"found 20\\", \\"offer 20\\", \\"found 30\\", \\"offer 30\\"]) 60 >>> max_earnings(4, [\\"found 20\\", \\"found 10\\", \\"offer 20\\", \\"offer 10\\"]) 20 >>> max_earnings(4, [\\"offer 10\\", \\"found 20\\", \\"offer 20\\", \\"offer 10\\"]) 20 >>> max_earnings(4, [\\"found 10\\", \\"found 30\\", \\"offer 10\\", \\"offer 30\\"]) 30","solution":"def max_earnings(n, events): current_beauty = None total_earnings = 0 for event in events: action, beauty = event.split() beauty = int(beauty) if action == \\"found\\": if current_beauty is None or beauty > current_beauty: current_beauty = beauty elif action == \\"offer\\": if current_beauty == beauty: total_earnings += beauty current_beauty = None return total_earnings"},{"question":"def is_balanced(s: str) -> int: Determine whether the input string s is balanced, i.e., if it has the same number of 'A's as 'B's and the same number of 'C's as 'D's. Args: s (str): The input string composed of uppercase English letters. Returns: int: Returns 1 if the string is balanced, otherwise returns 0. Examples: >>> is_balanced(\\"ABCD\\") 1 >>> is_balanced(\\"ABCCD\\") 0 # Implement the function to check if the string is balanced here","solution":"def is_balanced(s): Returns 1 if the string s is balanced, otherwise returns 0. count_A = s.count('A') count_B = s.count('B') count_C = s.count('C') count_D = s.count('D') if count_A == count_B and count_C == count_D: return 1 else: return 0"},{"question":"class Node: def __init__(self, value, left=None, right=None): self.value = value self.left = left self.right = right def Depth(node): Returns the maximum depth (or height) of the binary tree. >>> Depth(None) == 0 >>> Depth(Node(1)) == 1 >>> Depth(Node(1, Node(2), Node(3))) == 2 >>> Depth(Node(1, Node(2, Node(3, Node(4))))) == 4 def Sum(node): Returns the sum of all the values stored in the nodes of the binary tree. >>> Sum(None) == 0 >>> Sum(Node(1)) == 1 >>> Sum(Node(1, Node(2), Node(3))) == 6 >>> Sum(Node(1, Node(2, Node(3, Node(4))))) == 10","solution":"class Node: def __init__(self, value, left=None, right=None): self.value = value self.left = left self.right = right def Depth(node): Returns the maximum depth (or height) of the binary tree. if not node: return 0 left_depth = Depth(node.left) right_depth = Depth(node.right) return max(left_depth, right_depth) + 1 def Sum(node): Returns the sum of all the values stored in the nodes of the binary tree. if not node: return 0 left_sum = Sum(node.left) right_sum = Sum(node.right) return node.value + left_sum + right_sum"},{"question":"from typing import List, Tuple def calculate_transport_cost(cargo_type: str, weight: int, distance: int) -> int: Calculate the total cost of travel based on the weight and distance for different types of cargo. :param cargo_type: Type of cargo (\\"General\\", \\"Perishable\\", \\"Hazardous\\") :param weight: Weight of the cargo in kilograms :param distance: Distance to be carried in kilometers :return: Total cost of travel pass def process_cases(test_cases: List[Tuple[str, int, int]]) -> List[int]: Process multiple test cases to calculate transport costs. :param test_cases: List of tuples containing cargo type, weight, and distance :return: List of calculated costs for each test case pass # Example usage: # t = int(input()) # test_cases = [tuple(input().split()) for _ in range(t)] # formatted_cases = [(cargo, int(w), int(d)) for cargo, w, d in test_cases] # results = process_cases(formatted_cases) # for result in results: # print(result)","solution":"def calculate_transport_cost(cargo_type, weight, distance): Calculate the total cost of travel based on the weight and distance for different types of cargo. :param cargo_type: Type of cargo (\\"General\\", \\"Perishable\\", \\"Hazardous\\") :param weight: Weight of the cargo in kilograms :param distance: Distance to be carried in kilometers :return: Total cost of travel cost_per_km = { \\"General\\": 1, \\"Perishable\\": 2, \\"Hazardous\\": 3 } return weight * distance * cost_per_km[cargo_type] def process_cases(test_cases): Process multiple test cases to calculate transport costs. :param test_cases: List of tuples containing cargo type, weight, and distance :return: List of calculated costs for each test case results = [] for case in test_cases: cargo_type, weight, distance = case cost = calculate_transport_cost(cargo_type, weight, distance) results.append(cost) return results # Example usage: # t = int(input()) # test_cases = [tuple(input().split()) for _ in range(t)] # formatted_cases = [(cargo, int(w), int(d)) for cargo, w, d in test_cases] # results = process_cases(formatted_cases) # for result in results: # print(result)"},{"question":"def unique_paths(n: int, m: int, k: int, obstacles: List[Tuple[int, int]]) -> int: Determine the number of unique paths a robot can take to reach the bottom-right corner of an n x m grid, modulo 10^9 + 7. Args: n (int): number of rows in the grid m (int): number of columns in the grid k (int): number of obstacles in the grid obstacles (List[Tuple[int, int]]): list of tuples representing the positions of obstacles Returns: int: number of unique paths modulo 10^9 + 7 >>> unique_paths(3, 3, 1, [(2, 2)]) 2 >>> unique_paths(4, 4, 3, [(2, 2), (3, 2), (2, 4)]) 3 >>> unique_paths(2, 2, 0, []) 2","solution":"MOD = 10**9 + 7 def unique_paths(n, m, k, obstacles): # Create a grid to store the number of ways to reach each cell dp = [[0] * m for _ in range(n)] # Set obstacle positions in the grid to -1 for r, c in obstacles: dp[r-1][c-1] = -1 # Base case: Starting point (0, 0) if dp[0][0] == -1: # If starting point is an obstacle, no paths are possible return 0 dp[0][0] = 1 # Fill the grid with the number of ways to reach each cell for i in range(n): for j in range(m): # Skip obstacles if dp[i][j] == -1: continue # Add ways from the left and top cells if i > 0 and dp[i-1][j] != -1: dp[i][j] += dp[i-1][j] dp[i][j] %= MOD if j > 0 and dp[i][j-1] != -1: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD # The answer is the value at the bottom-right corner return dp[n-1][m-1] # Example usage n, m, k = 3, 3, 1 obstacles = [(2, 2)] print(unique_paths(n, m, k, obstacles)) # Output: 2"},{"question":"def determine_winner(T: int, grids: List[Tuple[int, int]]) -> List[str]: Determines the winner for each grid based on its dimensions. Maria and Ivan take turns placing dominos on a grid of m rows and n columns. Determine the winner given that both play optimally and Maria starts first. Parameters: T (int): The number of grids. grids (list of tuples): Each tuple contains (m, n) representing the dimensions of the grid. Returns: list of str: The result for each grid, \\"Maria\\" if Maria wins, or \\"Ivan\\" if Ivan wins. >>> determine_winner(3, [(2, 3), (4, 4), (1, 7)]) ['Maria', 'Maria', 'Ivan'] >>> determine_winner(1, [(2, 2)]) ['Maria'] >>> determine_winner(1, [(1, 3)]) ['Ivan']","solution":"def determine_winner(T, grids): Determines the winner for each grid based on its dimensions. Parameters: T (int): The number of grids. grids (list of tuples): Each tuple contains (m, n) representing the dimensions of the grid. Returns: list of str: The result for each grid, \\"Maria\\" if Maria wins, or \\"Ivan\\" if Ivan wins. results = [] for m, n in grids: if (m * n) % 2 == 0: results.append(\\"Maria\\") else: results.append(\\"Ivan\\") return results"},{"question":"from typing import List, Tuple def longest_substring_with_k_distinct_characters(K: int, S: str) -> str: Find the longest substring which contains exactly K distinct characters. Args: K: Integer, the number distinct characters. S: String, the input string. Returns: The longest substring with exactly K distinct characters. If such substring is not found, returns an empty string. >>> longest_substring_with_k_distinct_characters(2, \\"abcba\\") \\"bcb\\" >>> longest_substring_with_k_distinct_characters(3, \\"aabacbebebe\\") \\"cbebebe\\" >>> longest_substring_with_k_distinct_characters(2, \\"a\\") \\"\\" pass def process_queries(queries: List[Tuple[int, str]]) -> List[str]: Process multiple queries to find longest substrings with exactly K distinct characters. Args: queries: List of tuples containing integer K and string S for each query. Returns: List of results for each query. >>> process_queries([(2, \\"abcba\\"), (3, \\"aabacbebebe\\")]) [\\"bcb\\", \\"cbebebe\\"] pass # Unit tests def test_longest_substring_with_two_distinct_characters(): assert longest_substring_with_k_distinct_characters(2, \\"abcba\\") == \\"bcb\\" def test_longest_substring_with_three_distinct_characters(): assert longest_substring_with_k_distinct_characters(3, \\"aabacbebebe\\") == \\"cbebebe\\" def test_longest_substring_with_no_valid_substring(): assert longest_substring_with_k_distinct_characters(2, \\"a\\") == \\"\\" def test_longest_substring_with_exact_k_characters(): assert longest_substring_with_k_distinct_characters(1, \\"aaaa\\") == \\"aaaa\\" def test_longest_substring_with_whole_string(): assert longest_substring_with_k_distinct_characters(5, \\"qwerty\\") == \\"qwert\\" def test_process_queries(): queries = [ (2, \\"abcba\\"), (3, \\"aabacbebebe\\") ] expected_outputs = [\\"bcb\\", \\"cbebebe\\"] assert process_queries(queries) == expected_outputs def test_longest_substring_with_26_distinct_characters(): assert longest_substring_with_k_distinct_characters(26, \\"abcdefghijklmnopqrstuvwxyz\\") == \\"abcdefghijklmnopqrstuvwxyz\\"","solution":"def longest_substring_with_k_distinct_characters(K, S): from collections import defaultdict n = len(S) if n == 0 or K == 0: return \\"\\" left = 0 right = 0 max_len = 0 max_substring = \\"\\" char_map = defaultdict(int) unique_count = 0 while right < n: if char_map[S[right]] == 0: unique_count += 1 char_map[S[right]] += 1 right += 1 while unique_count > K: char_map[S[left]] -= 1 if char_map[S[left]] == 0: unique_count -= 1 left += 1 if unique_count == K: if right - left > max_len: max_len = right - left max_substring = S[left:right] return max_substring def process_queries(queries): results = [] for K, S in queries: result = longest_substring_with_k_distinct_characters(K, S) results.append(result) return results"},{"question":"from typing import List def process_operations(N: int, M: int, operations: List[str]) -> List[int]: Process a sequence of operations on a grid. Processes operations to add values to cells and to calculate the sum of values in specified sub-rectangular areas of the grid. Args: N (int): Number of rows in the grid. M (int): Number of columns in the grid. operations (List[str]): List of operations to be performed on the grid. Returns: List[int]: List of sums for each 'Sum' operation. >>> process_operations(5, 5, [ \\"Add 1 1 5\\", \\"Add 2 3 7\\", \\"Sum 1 1 3 3\\", \\"Add 4 4 -3\\", \\"Sum 1 1 5 5\\", \\"Sum 2 2 4 4\\" ]) [12, 9, 4] >>> process_operations(2, 2, [\\"Add 1 1 10\\", \\"Add 1 1 5\\", \\"Sum 1 1 1 1\\"]) [15] >>> process_operations(3, 3, [\\"Add 2 2 -5\\", \\"Add 3 3 -10\\", \\"Sum 1 1 3 3\\", \\"Sum 2 2 2 2\\"]) [-15, -5] >>> process_operations(2, 2, [\\"Add 1 1 1\\", \\"Add 1 2 1\\", \\"Add 2 1 1\\", \\"Add 2 2 1\\", \\"Sum 1 1 2 2\\"]) [4]","solution":"def process_operations(N, M, operations): grid = [[0] * M for _ in range(N)] results = [] for operation in operations: if operation.startswith(\\"Add\\"): _, x, y, v = operation.split() x, y, v = int(x) - 1, int(y) - 1, int(v) grid[x][y] += v elif operation.startswith(\\"Sum\\"): _, x1, y1, x2, y2 = operation.split() x1, y1, x2, y2 = int(x1) - 1, int(y1) - 1, int(x2) - 1, int(y2) - 1 total_sum = 0 for i in range(x1, x2 + 1): for j in range(y1, y2 + 1): total_sum += grid[i][j] results.append(total_sum) return results"},{"question":"def min_subset_sum_difference(arr): Partition an array of integers into two subsets such that the absolute difference between their sums is minimized. Return this minimum difference. >>> min_subset_sum_difference([5]) 5 >>> min_subset_sum_difference([1, 1, 1, 1]) 0 >>> min_subset_sum_difference([1, 2, 3, 9]) 3 >>> min_subset_sum_difference([1, 6, 11, 5]) 1 >>> min_subset_sum_difference([10, 20, 15, 5, 25]) 5 >>> min_subset_sum_difference([10, 15]) 5 >>> min_subset_sum_difference([3, 1, 4, 2, 2]) 0 >>> min_subset_sum_difference([0, 0, 0, 0]) 0","solution":"def min_subset_sum_difference(arr): total_sum = sum(arr) n = len(arr) dp = [[False] * (total_sum + 1) for _ in range(n+1)] for i in range(n+1): dp[i][0] = True for i in range(1, n+1): for j in range(1, total_sum + 1): if arr[i-1] <= j: dp[i][j] = dp[i-1][j] or dp[i-1][j-arr[i-1]] else: dp[i][j] = dp[i-1][j] min_diff = float('inf') for j in range(total_sum//2, -1, -1): if dp[n][j] == True: min_diff = total_sum - 2 * j break return min_diff"},{"question":"def count_unique_elements_in_union(datasets): Given multiple datasets where each dataset contains two semicolon-separated sets of integers, this function returns the number of unique elements in the union of each pair of sets. Args: datasets (list of str): List containing the datasets as strings. Returns: list of int: List containing the number of unique elements in the union of each pair of sets. >>> count_unique_elements_in_union([\\"1 2 3;4 5 6\\"]) [6] >>> count_unique_elements_in_union([\\"3 4 5 6;6 7 8 9\\"]) [7] >>> count_unique_elements_in_union([\\"10 20 30;30 40\\"]) [4] >>> count_unique_elements_in_union([\\"100;100\\"]) [1] >>> count_unique_elements_in_union([ ... \\"1 2 3;4 5 6\\", ... \\"3 4 5 6;6 7 8 9\\", ... \\"10 20 30;30 40\\", ... \\"100;100\\" ...]) == [6, 7, 4, 1]","solution":"def count_unique_elements_in_union(datasets): Given multiple datasets where each dataset contains two semicolon-separated sets of integers, this function returns the number of unique elements in the union of each pair of sets. Args: datasets (list of str): List containing the datasets as strings. Returns: list of int: List containing the number of unique elements in the union of each pair of sets. result = [] for dataset in datasets: set1, set2 = dataset.split(';') set1 = set(map(int, set1.split())) set2 = set(map(int, set2.split())) union_set = set1.union(set2) result.append(len(union_set)) return result"},{"question":"def max_points(n, m, points, key_problems): Calculate the maximum possible points a participant can earn if they solve the problems in an optimal order. :param n: int, total number of problems :param m: int, number of key problems :param points: list of int, points for each problem :param key_problems: list of int, indices of key problems in the specified order :return: int, the maximum possible points Examples: >>> max_points(5, 3, [10, 20, 30, 40, 50], [2, 4, 5]) 150 >>> max_points(5, 2, [10, 20, 30, 40, 50], [1, 3]) 150 >>> max_points(5, 0, [10, 20, 30, 40, 50], []) 150 >>> max_points(1, 1, [10], [1]) 10 >>> max_points(3, 2, [100, 200, 300], [2, 3]) 600 >>> max_points(5, 3, [10, 1, 10, 1, 10], [1, 3, 5]) 32","solution":"def max_points(n, m, points, key_problems): Calculate the maximum possible points a participant can earn if they solve the problems in an optimal order. :param n: int, total number of problems :param m: int, number of key problems :param points: list of int, points for each problem :param key_problems: list of int, indices of key problems in the specified order :return: int, the maximum possible points # Ensure key_problems are 0-based for easier indexing key_problems = [kp - 1 for kp in key_problems] # Initialize max points to 0 max_points = 0 # Solve the problems in the order key_index = 0 for i in range(n): if key_index < m and i == key_problems[key_index]: max_points += points[i] key_index += 1 elif key_index >= m or i != key_problems[key_index]: max_points += points[i] return max_points"},{"question":"from typing import List def longest_equal_subarray(arr: List[int]) -> int: Returns the length of the longest contiguous subarray within which all elements are equal. >>> longest_equal_subarray([1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1]) 4 >>> longest_equal_subarray([1, 1, 1, 1, 1]) 5 >>> longest_equal_subarray([1, 2, 1, 2, 1]) 1 >>> longest_equal_subarray([0, 1, 2, 2, 2, 3]) 3 # Unit tests def test_longest_equal_subarray_example_1(): assert longest_equal_subarray([1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1]) == 4 def test_longest_equal_subarray_example_2(): assert longest_equal_subarray([1, 1, 1, 1, 1]) == 5 def test_longest_equal_subarray_example_3(): assert longest_equal_subarray([1, 2, 1, 2, 1]) == 1 def test_longest_equal_subarray_example_4(): assert longest_equal_subarray([0, 1, 2, 2, 2, 3]) == 3 def test_longest_equal_subarray_single_element(): assert longest_equal_subarray([5]) == 1 def test_longest_equal_subarray_alternating_elements(): assert longest_equal_subarray([1, 2, 1, 2, 1, 2]) == 1 def test_longest_equal_subarray_two_equal_parts(): assert longest_equal_subarray([3, 3, 3, 2, 2, 2]) == 3 def test_longest_equal_subarray_large_input(): assert longest_equal_subarray([3]*1000 + [4]*2000) == 2000","solution":"def longest_equal_subarray(arr): Returns the length of the longest contiguous subarray within which all elements are equal. if not arr: return 0 max_length = current_length = 1 for i in range(1, len(arr)): if arr[i] == arr[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"from typing import List, Tuple def process_village(n: int, paths: List[Tuple[int, int]], queries: List[Tuple[int, int, int]]) -> List[int]: Process multiple queries to determine the total intensity of all potions along the shortest path starting from a given node or update the intensity of a potion at a given node. Args: - n (int): Number of nodes. - paths (List[Tuple[int, int]]): List of tuples representing village paths between nodes. - queries (List[Tuple[int, int, int]]): List of queries where the first value of each tuple indicates the query type. Returns: - List[int]: Results of all query type 1. >>> process_village(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)], [(1, 1), (2, 2, 50), (1, 1), (1, 2)]) [0, 50, 50] >>> process_village(1, [], [(1, 1), (2, 1, 100), (1, 1)]) [0, 100] >>> process_village(5, [(1, 2), (2, 3), (3, 4), (4, 5)], [(1, 1), (2, 3, 10), (2, 5, 20), (1, 1), (1, 3)]) [0, 30, 30]","solution":"class Village: def __init__(self, n): self.n = n self.graph = {i: [] for i in range(1, n + 1)} self.intensities = {i: 0 for i in range(1, n + 1)} def add_path(self, n1, n2): self.graph[n1].append(n2) self.graph[n2].append(n1) def update_intensity(self, node, intensity): self.intensities[node] = intensity def total_intensity_from(self, start_node): visited = {i: False for i in range(1, self.n + 1)} return self._dfs(start_node, visited) def _dfs(self, node, visited): visited[node] = True total_intensity = self.intensities[node] for neighbor in self.graph[node]: if not visited[neighbor]: total_intensity += self._dfs(neighbor, visited) return total_intensity def process_village(n, paths, queries): village = Village(n) for n1, n2 in paths: village.add_path(n1, n2) results = [] for query in queries: if query[0] == 1: results.append(village.total_intensity_from(query[1])) elif query[0] == 2: village.update_intensity(query[1], query[2]) return results"},{"question":"def process_registrations(n: int, participants: List[str]) -> List[str]: Process the registration data and generate a list of sessions with the participants registered for each session in alphabetical order. Args: - n : int : number of participants - participants : List[str] : list of participant data Returns: - List[str] : sorted list of session data >>> process_registrations(4, [\\"Alice 1 2 3\\", \\"Bob 1 3\\", \\"Charlie 2 3\\", \\"Dave 4\\"]) [\\"1 Alice Bob\\", \\"2 Alice Charlie\\", \\"3 Alice Bob Charlie\\", \\"4 Dave\\"] >>> process_registrations(2, [\\"Alice 1\\", \\"Bob 1\\"]) [\\"1 Alice Bob\\"] >>> process_registrations(0, []) []","solution":"def process_registrations(n, participants): session_dict = {} for participant in participants: data = participant.split() name = data[0] sessions = map(int, data[1:]) for session in sessions: if session not in session_dict: session_dict[session] = [] session_dict[session].append(name) result = [] for session in sorted(session_dict.keys()): result.append(f\\"{session} {' '.join(sorted(session_dict[session]))}\\") return result"},{"question":"def calculate_queues(test_cases): Calculate the total number of visitors that will be in the queue after distributing them across rides. Each test case is a tuple consisting of the number of rides, the number of visitors, and a list of tuples where each tuple represents (ride_capacity, ride_popularity). Args: test_cases: List[Tuple[int, int, List[Tuple[int, int]]]] - list of test cases Returns: List[int] - list of total visitors in queue for each test case >>> calculate_queues([(3, 20, [(15, 3), (10, 1), (5, 1)]), (2, 25, [(7, 2), (10, 5)])]) [0, 8] from typing import List, Tuple def calculate_queues(test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[int]: pass def test_sample_input(): test_cases = [ (3, 20, [(15, 3), (10, 1), (5, 1)]), (2, 25, [(7, 2), (10, 5)]) ] results = calculate_queues(test_cases) assert results == [0, 8] def test_no_visitors(): test_cases = [ (2, 0, [(7, 2), (10, 5)]) ] results = calculate_queues(test_cases) assert results == [0] def test_ride_overcapacity(): test_cases = [ (2, 50, [(7, 2), (10, 5)]), (4, 200, [(20, 5), (20, 1), (20, 3), (25, 7)]) ] results = calculate_queues(test_cases) assert results == [33, 115] def test_ride_exact_capacity(): test_cases = [ (3, 20, [(5, 1), (7, 2), (8, 3)]), (2, 17, [(7, 2), (10, 5)]) ] results = calculate_queues(test_cases) assert results == [0, 0] def test_large_input(): test_cases = [ (100, 1000, [(50, 1)] * 100) ] results = calculate_queues(test_cases) assert results == [0]","solution":"def calculate_queues(test_cases): results = [] for rides, visitors, data in test_cases: total_capacity = 0 ride_capacity = [] for capacity, popularity in data: total_capacity += capacity ride_capacity.append(capacity) remaining_visitors = max(0, visitors - total_capacity) results.append(remaining_visitors) return results"},{"question":"def reverse_vowels(s: str) -> str: Your task is to write a function \`reverse_vowels(s)\` that takes in a string \`s\` and returns a new string with the vowels reversed, while keeping all other characters in their original positions. The vowels are 'a', 'e', 'i', 'o', 'u' and their uppercase counterparts. Examples: >>> reverse_vowels(\\"hello\\") \\"holle\\" >>> reverse_vowels(\\"leetcode\\") \\"leotcede\\" >>> reverse_vowels(\\"aA\\") \\"Aa\\" >>> reverse_vowels(\\"123xyz!\\") \\"123xyz!\\"","solution":"def reverse_vowels(s): Returns a new string with the vowels reversed while keeping all other characters in their original positions. vowels = \\"aeiouAEIOU\\" s = list(s) i, j = 0, len(s) - 1 while i < j: if s[i] not in vowels: i += 1 elif s[j] not in vowels: j -= 1 else: s[i], s[j] = s[j], s[i] i += 1 j -= 1 return ''.join(s)"},{"question":"def count_distinct_palindromic_substrings(T: int, test_cases: List[str]) -> List[int]: Given a number of test cases and a list of strings, count the number of distinct palindromic substrings in each string. >>> count_distinct_palindromic_substrings(2, [\\"ababa\\", \\"abcd\\"]) [5, 4] >>> count_distinct_palindromic_substrings(1, [\\"aaaaa\\"]) [5]","solution":"def count_distinct_palindromic_substrings(T, test_cases): def is_palindrome(s): return s == s[::-1] results = [] for s in test_cases: palindromic_substrings = set() for i in range(len(s)): for j in range(i + 1, len(s) + 1): substring = s[i:j] if is_palindrome(substring): palindromic_substrings.add(substring) results.append(len(palindromic_substrings)) return results"},{"question":"def substring_indices(text: str, pattern: str) -> list: Returns a list of all starting indices in text where the pattern is found. >>> substring_indices(\\"abracadabra\\", \\"abra\\") [0, 7] >>> substring_indices(\\"hello world\\", \\"o\\") [4, 7] >>> substring_indices(\\"aaaaa\\", \\"aa\\") [0, 1, 2, 3] >>> substring_indices(\\"abc\\", \\"d\\") [] >>> substring_indices(\\"abc\\", \\"abcd\\") [] >>> substring_indices(\\"abc\\", \\"\\") [] >>> substring_indices(\\"\\", \\"abc\\") [] >>> substring_indices(\\"\\", \\"\\") [] >>> substring_indices(\\"abc\\", \\"abc\\") [0]","solution":"def substring_indices(text: str, pattern: str) -> list: Returns a list of starting indices in text where the pattern is found. result = [] len_text = len(text) len_pattern = len(pattern) if len_pattern == 0 or len_pattern > len_text: return result # Loop through the text and check for the pattern for i in range(len_text - len_pattern + 1): if text[i:i + len_pattern] == pattern: result.append(i) return result"},{"question":"class SimpleTextEditor: A simple text editor with undo functionality. Commands: 1. APPEND text: Appends the given text to the end of the current content. 2. POP n: Removes the last n characters from the current content. 3. PRINT k: Prints the k-th character of the current content. If k is out of bounds, prints an empty line. 4. UNDO: Reverts the content to its state before the last command. def __init__(self): pass def append(self, text): pass def pop(self, n): pass def print_char(self, k): pass def undo(self): pass def process_command(self, command): pass # Unit Tests from io import StringIO import sys def capture_print_output(func, *args, **kwargs): old_stdout = sys.stdout sys.stdout = StringIO() try: func(*args, **kwargs) return sys.stdout.getvalue().strip() finally: sys.stdout = old_stdout def test_append_and_print(): editor = SimpleTextEditor() editor.process_command(\\"APPEND hello\\") editor.process_command(\\"APPEND world\\") assert capture_print_output(editor.process_command, \\"PRINT 5\\") == \\"o\\" assert capture_print_output(editor.process_command, \\"PRINT 10\\") == \\"d\\" def test_pop(): editor = SimpleTextEditor() editor.process_command(\\"APPEND hello\\") editor.process_command(\\"POP 2\\") assert editor.content == \\"hel\\" editor.process_command(\\"APPEND world\\") assert capture_print_output(editor.process_command, \\"PRINT 5\\") == \\"o\\" editor.process_command(\\"POP 5\\") assert editor.content == \\"hel\\" def test_undo(): editor = SimpleTextEditor() editor.process_command(\\"APPEND hello\\") editor.process_command(\\"APPEND world\\") editor.process_command(\\"POP 5\\") editor.process_command(\\"UNDO\\") assert editor.content == \\"helloworld\\" editor.process_command(\\"UNDO\\") assert editor.content == \\"hello\\" def test_print_out_of_bounds(): editor = SimpleTextEditor() editor.process_command(\\"APPEND hello\\") assert capture_print_output(editor.process_command, \\"PRINT 10\\") == \\"\\" assert capture_print_output(editor.process_command, \\"PRINT 6\\") == \\"\\" assert capture_print_output(editor.process_command, \\"PRINT 1\\") == \\"h\\"","solution":"class SimpleTextEditor: def __init__(self): self.content = \\"\\" self.history = [] def append(self, text): self.history.append(self.content) self.content += text def pop(self, n): self.history.append(self.content) self.content = self.content[:-n] def print_char(self, k): if 0 <= k-1 < len(self.content): print(self.content[k-1]) else: print(\\"\\") def undo(self): if self.history: self.content = self.history.pop() def process_command(self, command): parts = command.split() cmd_type = parts[0] if cmd_type == \\"APPEND\\": text = command[7:] # Command text begins after \\"APPEND \\" self.append(text) elif cmd_type == \\"POP\\": n = int(parts[1]) self.pop(n) elif cmd_type == \\"PRINT\\": k = int(parts[1]) self.print_char(k) elif cmd_type == \\"UNDO\\": self.undo()"},{"question":"def generate_event_lists(participants): Generate a participant's event list and an event's participant list. Parameters: participants (list): A list of dictionaries where each dictionary contains the keys \\"name\\" (a string) and \\"events\\" (a list of strings representing event names the participant has registered for). Returns: tuple: A tuple containing two dictionaries: - The first dictionary maps each participant's name to a list of events they have registered for. - The second dictionary maps each event's name to a list of participant names who have registered for that event. Example: >>> participants = [ ... {\\"name\\": \\"Alice\\", \\"events\\": [\\"Art Exhibition\\", \\"Music Festival\\"]}, ... {\\"name\\": \\"Bob\\", \\"events\\": [\\"Coding Workshop\\", \\"Art Exhibition\\"]}, ... {\\"name\\": \\"Charlie\\", \\"events\\": [\\"Music Festival\\", \\"Art Exhibition\\"]} ... ] >>> generate_event_lists(participants) ( { \\"Alice\\": [\\"Art Exhibition\\", \\"Music Festival\\"], \\"Bob\\": [\\"Coding Workshop\\", \\"Art Exhibition\\"], \\"Charlie\\": [\\"Music Festival\\", \\"Art Exhibition\\"] }, { \\"Art Exhibition\\": [\\"Alice\\", \\"Bob\\", \\"Charlie\\"], \\"Music Festival\\": [\\"Alice\\", \\"Charlie\\"], \\"Coding Workshop\\": [\\"Bob\\"] } ) # Unit tests def test_basic_case(): participants = [ {\\"name\\": \\"Alice\\", \\"events\\": [\\"Art Exhibition\\", \\"Music Festival\\"]}, {\\"name\\": \\"Bob\\", \\"events\\": [\\"Coding Workshop\\", \\"Art Exhibition\\"]}, {\\"name\\": \\"Charlie\\", \\"events\\": [\\"Music Festival\\", \\"Art Exhibition\\"]} ] participant_to_events, event_to_participants = generate_event_lists(participants) expected_participant_to_events = { \\"Alice\\": [\\"Art Exhibition\\", \\"Music Festival\\"], \\"Bob\\": [\\"Coding Workshop\\", \\"Art Exhibition\\"], \\"Charlie\\": [\\"Music Festival\\", \\"Art Exhibition\\"] } expected_event_to_participants = { \\"Art Exhibition\\": [\\"Alice\\", \\"Bob\\", \\"Charlie\\"], \\"Music Festival\\": [\\"Alice\\", \\"Charlie\\"], \\"Coding Workshop\\": [\\"Bob\\"] } assert participant_to_events == expected_participant_to_events assert event_to_participants == expected_event_to_participants def test_empty_participant_list(): participants = [] participant_to_events, event_to_participants = generate_event_lists(participants) assert participant_to_events == {} assert event_to_participants == {} def test_no_events_for_participants(): participants = [ {\\"name\\": \\"Alice\\", \\"events\\": []}, {\\"name\\": \\"Bob\\", \\"events\\": []} ] participant_to_events, event_to_participants = generate_event_lists(participants) expected_participant_to_events = { \\"Alice\\": [], \\"Bob\\": [] } expected_event_to_participants = {} assert participant_to_events == expected_participant_to_events assert event_to_participants == expected_event_to_participants def test_single_event_multiple_participants(): participants = [ {\\"name\\": \\"Alice\\", \\"events\\": [\\"Single Event\\"]}, {\\"name\\": \\"Bob\\", \\"events\\": [\\"Single Event\\"]} ] participant_to_events, event_to_participants = generate_event_lists(participants) expected_participant_to_events = { \\"Alice\\": [\\"Single Event\\"], \\"Bob\\": [\\"Single Event\\"] } expected_event_to_participants = { \\"Single Event\\": [\\"Alice\\", \\"Bob\\"] } assert participant_to_events == expected_participant_to_events assert event_to_participants == expected_event_to_participants def test_multiple_events_single_participant(): participants = [ {\\"name\\": \\"Alice\\", \\"events\\": [\\"Event1\\", \\"Event2\\", \\"Event3\\"]} ] participant_to_events, event_to_participants = generate_event_lists(participants) expected_participant_to_events = { \\"Alice\\": [\\"Event1\\", \\"Event2\\", \\"Event3\\"] } expected_event_to_participants = { \\"Event1\\": [\\"Alice\\"], \\"Event2\\": [\\"Alice\\"], \\"Event3\\": [\\"Alice\\"] } assert participant_to_events == expected_participant_to_events assert event_to_participants == expected_event_to_participants","solution":"def generate_event_lists(participants): participant_to_events = {} event_to_participants = {} for participant in participants: name = participant[\\"name\\"] events = participant[\\"events\\"] participant_to_events[name] = events for event in events: if event not in event_to_participants: event_to_participants[event] = [] event_to_participants[event].append(name) return participant_to_events, event_to_participants participants = [ {\\"name\\": \\"Alice\\", \\"events\\": [\\"Art Exhibition\\", \\"Music Festival\\"]}, {\\"name\\": \\"Bob\\", \\"events\\": [\\"Coding Workshop\\", \\"Art Exhibition\\"]}, {\\"name\\": \\"Charlie\\", \\"events\\": [\\"Music Festival\\", \\"Art Exhibition\\"]} ] print(generate_event_lists(participants))"},{"question":"def bacteria_growth(T: int, test_cases: List[Tuple[int, int]]) -> List[int]: Function to calculate the number of bacteria present after a given number of days for multiple test cases. Parameters: T : int : Number of test cases test_cases : list of tuples : Each tuple contains two integers N (initial number of bacteria) and D (number of days) Returns: list : Number of bacteria present after D days for each test case","solution":"def bacteria_growth(T, test_cases): Function to calculate the number of bacteria present after a given number of days for multiple test cases. Parameters: T : int : Number of test cases test_cases : list of tuples : Each tuple contains two integers N (initial number of bacteria) and D (number of days) Returns: list : Number of bacteria present after D days for each test case results = [] for N, D in test_cases: # Apply the logic of bacteria growth bacteria_count = N * (2 ** D) # Each day the population doubles results.append(bacteria_count) return results # Read input if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() T = int(data[0]) test_cases = [(int(data[i*2+1]), int(data[i*2+2])) for i in range(T)] results = bacteria_growth(T, test_cases) for result in results: print(result)"},{"question":"import heapq class TaskManager: def __init__(self): self.tasks = {} self.task_queue = [] self.counter = 0 def add_task(self, name, priority): Add a new task to the list with a given name and priority level. pass def remove_task(self, name): Remove a task by its name. pass def get_highest_priority_task(self): Get the name of the task with the highest priority. In case of ties, the task that was added earlier is considered higher priority. pass Unit Test: from solution import TaskManager def test_task_manager(): manager = TaskManager() # Test retrieving task from empty manager assert manager.get_highest_priority_task() == \\"NO TASKS\\" # Add tasks manager.add_task(\\"task1\\", 5) manager.add_task(\\"task2\\", 10) # Check highest priority task assert manager.get_highest_priority_task() == \\"task2\\" # Remove a task manager.remove_task(\\"task2\\") # Check the next highest priority task assert manager.get_highest_priority_task() == \\"task1\\" # Remove all tasks manager.remove_task(\\"task1\\") # Check highest priority task on empty manager assert manager.get_highest_priority_task() == \\"NO TASKS\\" def test_task_with_same_priority(): manager = TaskManager() # Add tasks with the same priority manager.add_task(\\"task1\\", 5) manager.add_task(\\"task2\\", 5) # Since task1 was added first it should be the highest priority task assert manager.get_highest_priority_task() == \\"task1\\" # Remove task1 manager.remove_task(\\"task1\\") # Now task2 should be highest priority task assert manager.get_highest_priority_task() == \\"task2\\" def test_lifecyle_operations(): manager = TaskManager() # Add multiple tasks manager.add_task(\\"task1\\", 1) manager.add_task(\\"task2\\", 3) manager.add_task(\\"task3\\", 2) # Should return task2 (highest priority) assert manager.get_highest_priority_task() == \\"task2\\" # Remove task2 and check again manager.remove_task(\\"task2\\") assert manager.get_highest_priority_task() == \\"task3\\" # Add task with higher priority and check manager.add_task(\\"task4\\", 4) assert manager.get_highest_priority_task() == \\"task4\\" # Empty the manager and verify manager.remove_task(\\"task1\\") manager.remove_task(\\"task3\\") manager.remove_task(\\"task4\\") assert manager.get_highest_priority_task() == \\"NO TASKS\\"","solution":"import heapq class TaskManager: def __init__(self): self.tasks = {} self.task_queue = [] self.counter = 0 def add_task(self, name, priority): if name not in self.tasks: self.tasks[name] = (priority, self.counter) heapq.heappush(self.task_queue, (-priority, self.counter, name)) self.counter += 1 def remove_task(self, name): if name in self.tasks: self.tasks.pop(name) def get_highest_priority_task(self): while self.task_queue and self.task_queue[0][2] not in self.tasks: heapq.heappop(self.task_queue) if not self.task_queue: return \\"NO TASKS\\" return self.task_queue[0][2]"},{"question":"def find_two_sum(nums: List[int], target: int) -> str: Determines if there are two distinct indices in the list such that the sum of the integers at those indices equals the target. >>> find_two_sum([1, 2, 3, 4], 5) \\"YES\\" >>> find_two_sum([1, 4, 5], 9) \\"YES\\" >>> find_two_sum([1, 2, 3, 4], 8) \\"NO\\" >>> find_two_sum([-1, -1], -2) \\"YES\\"","solution":"def find_two_sum(nums, target): Determines if there are two distinct indices in the list such that the sum of the integers at those indices equals the target. seen = {} for i, num in enumerate(nums): complement = target - num if complement in seen: return \\"YES\\" seen[num] = i return \\"NO\\""},{"question":"def distinct_soup_types(soup_data): Determines the number of different types of soups. Parameters: soup_data (list of tuples): A list where each tuple contains a soup name and its type. Returns: int: The number of different soup types. Examples: >>> distinct_soup_types([(\\"tomato\\", \\"creamy\\"), (\\"chickenbroth\\", \\"broth\\"), (\\"mushroom\\", \\"creamy\\"), (\\"minestrone\\", \\"broth\\"), (\\"carrot\\", \\"creamy\\")]) 2 >>> distinct_soup_types([(\\"lentil\\", \\"broth\\"), (\\"pumpkin\\", \\"creamy\\"), (\\"beefbroth\\", \\"broth\\"), (\\"asparagus\\", \\"creamy\\")]) 2 pass def count_soup_types_from_input(input_lines): Processes the input and counts the distinct soup types from the given data. Parameters: input_lines (list of strings): The input lines containing the count and soup details. Returns: int: The number of different soup types. Examples: >>> count_soup_types_from_input([\\"5\\", \\"tomato creamy\\", \\"chickenbroth broth\\", \\"mushroom creamy\\", \\"minestrone broth\\", \\"carrot creamy\\"]) 2 >>> count_soup_types_from_input([\\"4\\", \\"lentil broth\\", \\"pumpkin creamy\\", \\"beefbroth broth\\", \\"asparagus creamy\\"]) 2 pass","solution":"def distinct_soup_types(soup_data): Determines the number of different types of soups. Parameters: soup_data (list of tuples): A list where each tuple contains a soup name and its type. Returns: int: The number of different soup types. soup_types = set() for _, soup_type in soup_data: soup_types.add(soup_type) return len(soup_types) def count_soup_types_from_input(input_lines): Processes the input and counts the distinct soup types from the given data. Parameters: input_lines (list of strings): The input lines containing the count and soup details. Returns: int: The number of different soup types. M = int(input_lines[0]) soups = [tuple(line.split()) for line in input_lines[1:M+1]] return distinct_soup_types(soups)"},{"question":"def place_robots(N: int, M: int, robot_types: List[str]) -> int: Calculate the minimum number of steps required to place all robots into the grid such that no two robots occupy the same cell. Args: - N: int, size of the grid (N x N) - M: int, number of robots - robot_types: list of str, each robot's type (\\"R\\", \\"L\\", \\"B\\") Returns: - int, minimum number of steps required >>> place_robots(3, 2, [\\"R\\", \\"B\\"]) == 3 >>> place_robots(5, 1, [\\"L\\"]) == 1 >>> place_robots(4, 4, [\\"B\\", \\"B\\", \\"B\\", \\"B\\"]) == 7 >>> place_robots(4, 3, [\\"R\\", \\"L\\", \\"B\\"]) == 5 >>> place_robots(2, 2, [\\"R\\", \\"L\\"]) == 3 >>> place_robots(10, 100, [\\"R\\"]*100) == 199","solution":"def place_robots(N, M, robot_types): Calculate the minimum number of steps required to place all robots into the grid such that no two robots occupy the same cell. Args: - N: int, size of the grid (N x N) - M: int, number of robots - robot_types: list of str, each robot's type (\\"R\\", \\"L\\", \\"B\\") Returns: - int, minimum number of steps required # The minimum steps required to place each robot in distinct positions # This is a theoretical calculation that can be adjusted by the robot's type return M + max(0, M-1) # Example of how the function works given an input n, m = 3, 2 robots = [\\"R\\", \\"B\\"] print(place_robots(n, m, robots)) # This should output 3"},{"question":"def lexicographically_smallest_string(s: str) -> str: Returns the lexicographically smallest string possible using the permitted operations. >>> lexicographically_smallest_string(\\"dcba\\") 'abcd' >>> lexicographically_smallest_string(\\"xyzab\\") 'abxyz' def process_test_cases(test_cases: list[str]) -> list[str]: Processes multiple test cases and returns a list of results for each test case. >>> process_test_cases([\\"dcba\\", \\"xyzab\\"]) ['abcd', 'abxyz'] >>> process_test_cases([\\"a\\", \\"abc\\", \\"cba\\"]) ['a', 'abc', 'abc']","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string possible using the permitted operations. :param s: A string consisting of lowercase English letters :type s: str :return: The lexicographically smallest string possible by reversing or shifting :rtype: str n = len(s) min_string = s # Check the string itself if s < min_string: min_string = s # Check the reversed string reversed_s = s[::-1] if reversed_s < min_string: min_string = reversed_s # Check all rotations of the string for i in range(n): rotated_s = s[i:] + s[:i] if rotated_s < min_string: min_string = rotated_s return min_string def process_test_cases(test_cases): Processes multiple test cases :param test_cases: List of strings as test cases :type test_cases: list[str] :returns: List of results for each test case :rtype: list[str] results = [] for s in test_cases: results.append(lexicographically_smallest_string(s)) return results"},{"question":"def double_array(arr): Returns a new list with each number in the input list doubled. Parameters: arr (list): A list of numbers (integers or floats) Returns: list: A new list with each number doubled Examples: >>> double_array([1, 2, 3]) [2, 4, 6] >>> double_array([4, -3, 7]) [8, -6, 14] >>> double_array([]) [] >>> double_array([1.5, -2.5, 3.0]) [3.0, -5.0, 6.0]","solution":"def double_array(arr): Returns a new list with each number in the input list doubled. Parameters: arr (list): A list of numbers (integers or floats) Returns: list: A new list with each number doubled return [x * 2 for x in arr]"},{"question":"def autocomplete(words, prefix): Returns a list of words from the given list that start with the given prefix in lexicographical order. If no such words exist, returns [\\"NO SUGGESTIONS\\"]. >>> autocomplete([\\"hello\\", \\"helium\\", \\"helicopter\\", \\"help\\", \\"hero\\"], \\"hel\\") ['helicopter', 'helium', 'hello', 'help'] >>> autocomplete([\\"apple\\", \\"banana\\", \\"cherry\\"], \\"pine\\") ['NO SUGGESTIONS'] >>> autocomplete([\\"dog\\", \\"cat\\", \\"canary\\"], \\"ca\\") ['canary', 'cat'] >>> autocomplete([], \\"a\\") ['NO SUGGESTIONS'] >>> autocomplete([\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\"], \\"\\") ['a', 'ab', 'abc', 'abcd']","solution":"def autocomplete(words, prefix): Returns a list of words from the given list that start with the given prefix in lexicographical order. If no such words exist, returns [\\"NO SUGGESTIONS\\"]. # Filter the words that start with the given prefix suggestions = [word for word in words if word.startswith(prefix)] # Sort the words lexicographically and return the result if suggestions: return sorted(suggestions) else: return [\\"NO SUGGESTIONS\\"]"},{"question":"def compress(s: str) -> str: Compresses the input string using run-length encoding. Each character is followed by the count of its consecutive occurrences. >>> compress(\\"aaabbccccd\\") 'a3b2c4d1' >>> compress(\\"abc\\") 'a1b1c1' pass def decompress(s: str) -> str: Decompresses the input string using run-length encoding. Each character is repeated according to the subsequent number. >>> decompress(\\"a3b2c4d1\\") 'aaabbccccd' >>> decompress(\\"a1b1c1\\") 'abc' pass","solution":"def compress(s: str) -> str: Compresses the input string using run-length encoding. Each character is followed by the count of its consecutive occurrences. if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) return ''.join(compressed) def decompress(s: str) -> str: Decompresses the input string using run-length encoding. Each character is repeated according to the subsequent number. decompressed = [] i = 0 while i < len(s): char = s[i] count = 0 i += 1 while i < len(s) and s[i].isdigit(): count = count * 10 + int(s[i]) i += 1 decompressed.append(char * count) return ''.join(decompressed)"},{"question":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Create a function that takes an array of integers and a target integer. The function should return indices of the two numbers such that they add up to the target. Assume that each input would have exactly one solution, and you may not use the same element twice. Args: nums : List[int] : List of integers target : int : Target sum Returns: List[int] : Indices of the two numbers that add up to target Examples: >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([3, 3], 6) [0, 1]","solution":"def two_sum(nums, target): Returns indices of the two numbers such that they add up to the target. Args: nums : List[int] : List of integers target : int : Target sum Returns: List[int] : Indices of the two numbers that add up to target num_to_index = {} for index, num in enumerate(nums): difference = target - num if difference in num_to_index: return [num_to_index[difference], index] num_to_index[num] = index return [] # This return is just a safeguard, function assumes there is always exactly one solution"},{"question":"def char_frequencies(T: int, test_cases: List[str]) -> List[str]: Analyze the frequency of each character in the string and output the character frequencies in descending order. Args: - T (int): number of test cases - test_cases (List[str]): list of strings to analyze Returns: - List[str]: list of strings with characters and their frequencies in descending order of frequency for each test case. Each line of the output represents a character and its frequency in the form \\"char:freq\\". Characters with the same frequency should be printed in increasing order of their ASCII values. Sample Usage: >>> char_frequencies(2, [\\"hello\\", \\"aabbbcccc\\"]) ['l:2', 'e:1', 'h:1', 'o:1', 'c:4', 'b:3', 'a:2'] >>> char_frequencies(1, [\\"abcabc\\"]) ['a:2', 'b:2', 'c:2']","solution":"def char_frequencies(T, test_cases): from collections import Counter results = [] for s in test_cases: char_count = Counter(s) sorted_chars = sorted(char_count.items(), key=lambda x: (-x[1], x[0])) for char, freq in sorted_chars: results.append(f\\"{char}:{freq}\\") return results"},{"question":"def has_pair_with_sum(arr: List[int], k: int) -> str: Determines if there are two distinct indices in the array such that arr[i] + arr[j] == k. >>> has_pair_with_sum([1, 2, 3, 4, 5], 9) \\"YES\\" >>> has_pair_with_sum([1, 2, 3, 4], 8) \\"NO\\" >>> has_pair_with_sum([5, 5, 1], 10) \\"YES\\"","solution":"def has_pair_with_sum(arr, k): Determines if there are two distinct indices in the array such that arr[i] + arr[j] == k. seen = set() for num in arr: if k - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\" # Example usage # input data n = 5 arr = [1, 2, 3, 4, 5] k = 9 # call the function print(has_pair_with_sum(arr, k)) # Output should be \\"YES\\""},{"question":"import heapq from typing import List, Tuple def shortest_path(N: int, M: int, edges: List[Tuple[int, int, int]]) -> List[int]: Finds the shortest path distance from the source node (node 1) to all other nodes. Parameters: N (int): Number of nodes in the graph. M (int): Number of edges in the graph. edges (List[Tuple[int, int, int]]): List of directed edges represented as tuples (u, v, w) where u is the start node, v is the end node, and w is the weight of the edge. Returns: List[int]: A list of N integers where the ith integer denotes the shortest distance from node 1 to node i+1. If a node is unreachable from node 1, the distance is -1. Example: >>> shortest_path(5, 6, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (3, 4, 7), (2, 5, 10), (4, 5, 1)]) [0, 2, 3, 10, 11] >>> shortest_path(4, 2, [(1, 2, 2), (3, 4, 1)]) [0, 2, -1, -1]","solution":"import heapq import sys def shortest_path(N, M, edges): Finds the shortest path distances from the source node (1) to all other nodes in the directed graph. :param N: Number of nodes :param M: Number of edges :param edges: List of edges where each edge is represented as a tuple (u, v, w) :return: List of shortest path distances from node 1 to nodes 1 to N, where -1 represents an unreachable node graph = {i: [] for i in range(1, N+1)} for u, v, w in edges: graph[u].append((v, w)) dist = {i: float('inf') for i in range(1, N+1)} dist[1] = 0 pq = [(0, 1)] while pq: current_dist, u = heapq.heappop(pq) if current_dist > dist[u]: continue for v, weight in graph[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(pq, (distance, v)) result = [] for i in range(1, N+1): if dist[i] == float('inf'): result.append(-1) else: result.append(dist[i]) return result"},{"question":"def merge_dicts(list_of_dicts): Takes a list of dictionaries and merges them into a single dictionary. Parameters: list_of_dicts (list): A list of dictionaries with non-overlapping keys. Returns: dict: A single dictionary containing all key-value pairs from the input dictionaries. Examples: >>> merge_dicts([{\\"a\\": 1, \\"b\\": 2}, {\\"c\\": 3}, {\\"d\\": 4, \\"e\\": 5}]) {\\"a\\": 1, \\"b\\": 2, \\"c\\": 3, \\"d\\": 4, \\"e\\": 5} >>> merge_dicts([]) {} >>> merge_dicts([{\\"a\\": 1, \\"b\\": 2}]) {\\"a\\": 1, \\"b\\": 2} >>> merge_dicts([{\\"a\\": 1}, {\\"b\\": 2}, {\\"c\\": 3}]) {\\"a\\": 1, \\"b\\": 2, \\"c\\": 3} >>> merge_dicts([{1: \\"one\\"}, {2: \\"two\\"}]) {1: \\"one\\", 2: \\"two\\"} >>> merge_dicts([{1: \\"one\\", \\"2\\": 2}, {\\"three\\": 3, 4.0: \\"four\\"}]) {1: \\"one\\", \\"2\\": 2, \\"three\\": 3, 4.0: \\"four\\"}","solution":"def merge_dicts(list_of_dicts): Takes a list of dictionaries and merges them into a single dictionary. Parameters: list_of_dicts (list): A list of dictionaries with non-overlapping keys. Returns: dict: A single dictionary containing all key-value pairs from the input dictionaries. merged_dict = {} for d in list_of_dicts: merged_dict.update(d) return merged_dict"},{"question":"def max_profit(prices: List[int]) -> int: Returns the maximum profit that can be achieved by buying and selling one share of stock. Example: >>> max_profit([7, 1, 5, 3, 6, 4]) == 5 >>> max_profit([7, 6, 4, 3, 1]) == 0","solution":"def max_profit(prices): Returns the maximum profit that can be achieved by buying and selling one share of stock. :param prices: List of daily prices for a certain stock. :type prices: List[int] :return: Maximum possible profit. If no profit can be made, returns 0. :rtype: int if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def highest_reading(records, search_id): Returns the highest reading value for the specified patient ID, or -1 if the patient ID does not exist. records: List of records, where each record is a tuple of patient_id and list of readings search_id: Patient ID to search for the highest reading value. def parse_input(input_data): Parses the input data into a list of patient records and the specified patient ID. input_data: String containing the input data. Returns a tuple of records and search_id. def test_highest_reading_example1(): input_data = 3 1234 2 1609459200 98 1609545600 102 5678 3 1609459200 136 1609545600 138 1609632000 135 91011 1 1609459200 99 1234 records, search_id = parse_input(input_data) assert highest_reading(records, search_id) == 102 def test_highest_reading_example2(): input_data = 2 123 1 1609459200 200 456 3 1609459200 156 1609545600 158 1609632000 157 789 records, search_id = parse_input(input_data) assert highest_reading(records, search_id) == -1 def test_highest_reading_single_patient(): input_data = 1 1111 3 1609459200 50 1609459210 55 1609459220 60 1111 records, search_id = parse_input(input_data) assert highest_reading(records, search_id) == 60 def test_highest_reading_missing_patient(): input_data = 1 2222 2 1609459300 45 1609459350 65 3333 records, search_id = parse_input(input_data) assert highest_reading(records, search_id) == -1 def test_highest_reading_multiple_patients(): input_data = 2 4444 1 1609459400 80 5555 1 1609459500 90 4444 records, search_id = parse_input(input_data) assert highest_reading(records, search_id) == 80","solution":"def highest_reading(records, search_id): Returns the highest reading value for the specified patient ID, or -1 if the patient ID does not exist. records: List of records, where each record is a tuple of patient_id and list of readings search_id: Patient ID to search for the highest reading value. patient_data = {record[0]: record[1] for record in records} if search_id not in patient_data: return -1 readings = patient_data[search_id] highest_value = max(reading[1] for reading in readings) return highest_value def parse_input(input_data): lines = input_data.strip().split('n') P = int(lines[0]) records = [] idx = 1 for _ in range(P): patient_record = lines[idx].split() patient_id = int(patient_record[0]) R = int(patient_record[1]) readings = [] for j in range(R): reading = lines[idx + 1 + j].split() timestamp = int(reading[0]) value = int(reading[1]) readings.append((timestamp, value)) records.append((patient_id, readings)) idx = idx + 1 + R search_id = int(lines[-1]) return records, search_id"},{"question":"import random from typing import List def generate_sudoku_board(seed: int = None) -> List[List[int]]: Generate a 9x9 Sudoku board that is completely filled and valid. >>> generate_sudoku_board(42) [[5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9]]","solution":"import random def generate_sudoku_board(seed=None): Generate a 9x9 Sudoku board that is completely filled and valid. def is_valid(board, row, col, num): # Check if 'num' is not in the given row if num in board[row]: return False # Check if 'num' is not in the given column if num in [board[r][col] for r in range(9)]: return False # Check if 'num' is not in the related 3x3 grid start_row, start_col = 3 * (row // 3), 3 * (col // 3) for r in range(start_row, start_row + 3): for c in range(start_col, start_col + 3): if board[r][c] == num: return False return True def fill_sudoku(board): # Using backtracking to fill the sudoku board for row in range(9): for col in range(9): if board[row][col] == 0: random.shuffle(numbers) for num in numbers: if is_valid(board, row, col, num): board[row][col] = num if fill_sudoku(board): return True board[row][col] = 0 return False return True if seed is not None: random.seed(seed) board = [[0]*9 for _ in range(9)] numbers = list(range(1, 10)) fill_sudoku(board) return board"},{"question":"def determine_winner(t: int, games: List[str]) -> List[str]: Determines the winner of each game. Args: t (int): number of test cases games (list of str): list of strings representing the games Returns: list of str: winner for each game, either \\"Alice\\" or \\"Bob\\" >>> determine_winner(3, [\\"abc\\", \\"aaa\\", \\"x\\"]) [\\"Bob\\", \\"Alice\\", \\"Alice\\"] >>> determine_winner(2, [\\"abcd\\", \\"xy\\"]) [\\"Alice\\", \\"Alice\\"]","solution":"def determine_winner(t, games): Determines the winner of each game. Args: t (int): number of test cases games (list of str): list of strings representing the games Returns: list of str: winner for each game, either \\"Alice\\" or \\"Bob\\" results = [] for s in games: if len(s) % 2 == 0: results.append(\\"Alice\\") else: results.append(\\"Bob\\") return results"},{"question":"def calculate_final_scores_and_rankings(N: int, M: int, weights: List[int], scores: List[List[int]]) -> List[Tuple[int, float]]: Compute the final scores for each student based on weighted averages and determine their rankings. >>> calculate_final_scores_and_rankings(3, 4, [3, 1, 2, 4], [[90, 80, 70, 60], [75, 85, 55, 80], [50, 60, 70, 90]]) [(1, 74.0), (0, 73.0), (2, 71.0)] >>> calculate_final_scores_and_rankings(1, 1, [1], [[50]]) [(0, 50.0)]","solution":"def calculate_final_scores_and_rankings(N, M, weights, scores): final_scores = [] total_weight = sum(weights) for i in range(N): final_score = sum([scores[i][j] * weights[j] for j in range(M)]) / total_weight final_scores.append((i, final_score)) # Sort based on the final scores in descending order final_scores.sort(key=lambda x: x[1], reverse=True) return final_scores # Example usage: # N = 3 # M = 4 # weights = [3, 1, 2, 4] # scores = [ # [90, 80, 70, 60], # [75, 85, 55, 80], # [50, 60, 70, 90] # ] # print(calculate_final_scores_and_rankings(N, M, weights, scores))"},{"question":"def count_peaks(n: int, arr: List[int]) -> int: Determines the number of peaks in the array. Parameters: n (int): The number of elements in the array. arr (list of int): The elements of the array. Returns: int: The number of peaks in the array. >>> count_peaks(5, [1, 3, 2, 5, 4]) == 2 >>> count_peaks(5, [1, 2, 3, 4, 5]) == 0 >>> count_peaks(3, [1, 2, 3]) == 0 >>> count_peaks(5, [2, 2, 2, 2, 2]) == 0 >>> count_peaks(6, [1, 3, 2, 5, 4, 6]) == 2 >>> count_peaks(7, [1, 3, 2, 4, 2, 5, 1]) == 3","solution":"def count_peaks(n, arr): Determines the number of peaks in the array. Parameters: n (int): The number of elements in the array. arr (list of int): The elements of the array. Returns: int: The number of peaks in the array. peak_count = 0 for i in range(1, n-1): if arr[i] > arr[i-1] and arr[i] > arr[i+1]: peak_count += 1 return peak_count"},{"question":"def maximalSquare(grid: List[str]) -> int: Returns the area of the largest square that contains only '1's in the given grid. >>> maximalSquare([\\"1110\\", \\"1101\\", \\"1111\\", \\"0110\\"]) == 4 >>> maximalSquare([\\"11100\\", \\"11111\\", \\"10111\\"]) == 4 >>> maximalSquare([\\"11011\\", \\"11111\\", \\"11110\\", \\"11111\\", \\"01111\\"]) == 9 >>> maximalSquare([\\"0\\", \\"0\\"]) == 0 >>> maximalSquare([\\"1\\"]) == 1 def process_input(data: List[str]) -> List[int]: Process the input data and return the results for each dataset. >>> data = [ >>> \\"4 4\\", >>> \\"1110\\", >>> \\"1101\\", >>> \\"1111\\", >>> \\"0110\\", >>> \\"3 5\\", >>> \\"11100\\", >>> \\"11111\\", >>> \\"10111\\", >>> \\"5 5\\", >>> \\"11011\\", >>> \\"11111\\", >>> \\"11110\\", >>> \\"11111\\", >>> \\"01111\\", >>> \\"0 0\\" >>> ] >>> process_input(data) == [4, 4, 9] >>> >>> data = [ >>> \\"1 1\\", >>> \\"1\\", >>> \\"0 0\\" >>> ] >>> process_input(data) == [1] >>> >>> data = [ >>> \\"1 1\\", >>> \\"0\\", >>> \\"0 0\\" >>> ] >>> process_input(data) == [0] >>> >>> data = [ >>> \\"2 2\\", >>> \\"10\\", >>> \\"00\\", >>> \\"0 0\\" >>> ] >>> process_input(data) == [1]","solution":"def maximalSquare(grid): Returns the area of the largest square that contains only '1's in the given grid. if not grid: return 0 h = len(grid) w = len(grid[0]) dp = [[0] * w for _ in range(h)] max_side = 0 for i in range(h): for j in range(w): if grid[i][j] == '1': if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side def process_input(data): Process the input data and return the results for each dataset. index = 0 results = [] while index < len(data): h, w = map(int, data[index].split()) if h == 0 and w == 0: break grid = [] for i in range(h): grid.append(data[index + 1 + i]) results.append(maximalSquare(grid)) index += h + 1 return results"},{"question":"def can_rearrange(t: int, cases: List[Tuple[int, str, str]]) -> List[str]: Determines if the initial flower arrangement can be rearranged to the desired arrangement using adjacent swaps. :param t: The number of test cases. :param cases: A list of tuples, each containing an integer n and two strings; the initial and desired arrangements. :return: A list of \\"Yes\\" or \\"No\\" for each test case. >>> can_rearrange(3, [(5, 'abcde', 'ecdba'), (4, 'aaaa', 'aaab'), (6, 'abcdef', 'fedcba')]) [\\"Yes\\", \\"No\\", \\"Yes\\"] >>> can_rearrange(2, [(3, 'abc', 'cba'), (4, 'abcd', 'dcba')]) [\\"Yes\\", \\"Yes\\"] >>> can_rearrange(1, [(1, 'a', 'a')]) [\\"Yes\\"] >>> can_rearrange(1, [(2, 'ab', 'aa')]) [\\"No\\"] >>> can_rearrange(4, [(5, 'abcde', 'edcba'), (6, 'aaabbb', 'bbbaaa'), (7, 'abcdefg', 'gfedcba'), (8, 'aabbccdd', 'ddccbbaa')]) [\\"Yes\\", \\"Yes\\", \\"Yes\\", \\"Yes\\"]","solution":"def can_rearrange(t, cases): Determines if the initial flower arrangement can be rearranged to the desired arrangement using adjacent swaps. :param t: Number of test cases. :param cases: List of tuples where each tuple contains an integer n and 2 strings; the initial and desired arrangements. :return: List of \\"Yes\\" or \\"No\\" for each test case. results = [] for case in cases: n, initial, desired = case if sorted(initial) == sorted(desired): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 pass def process_test_cases(t: int, test_cases: List[str]) -> List[int]: Processes multiple test cases and returns the corresponding results. >>> process_test_cases(3, [\\"abcabcbb\\", \\"bbbbb\\", \\"pwwkew\\"]) [3, 1, 3] >>> process_test_cases(2, [\\"a\\", \\"z\\"]) [1, 1] >>> process_test_cases(3, [\\"aaaaaa\\", \\"bbbbbb\\", \\"cccccc\\"]) [1, 1, 1] >>> process_test_cases(2, [\\"dvdf\\", \\"anviaj\\"]) [3, 5] >>> process_test_cases(2, [\\"a\\" * 100000, \\"\\".join(chr((i % 26) + 97) for i in range(100000))]) [1, 26] pass","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. n = len(s) char_set = set() left = 0 result = 0 for right in range(n): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) result = max(result, right - left + 1) return result def process_test_cases(t, test_cases): Processes multiple test cases and returns the corresponding results. results = [] for case in test_cases: results.append(length_of_longest_substring(case)) return results"},{"question":"def has_pair_with_difference(nums: List[int], k: int) -> bool: Returns True if there are two distinct indices i and j in the list such that the absolute difference between nums[i] and nums[j] is greater than or equal to k. Args: nums (List[int]): List of integers. k (int): The minimum difference to check for. Returns: bool: True if such a pair exists, otherwise False. Examples: >>> has_pair_with_difference([1, 3, 6, 9, 12], 3) True >>> has_pair_with_difference([1, 2, 2, 3], 5) False","solution":"def has_pair_with_difference(nums, k): Returns True if there are two distinct indices i and j in the list such that the absolute difference between nums[i] and nums[j] is greater than or equal to k. num_set = set() for num in nums: if any(abs(num - n) >= k for n in num_set): return True num_set.add(num) return False"},{"question":"def arrayToCSV(arr: List[List[int]]) -> str: Converts a 2D array of integers into a CSV formatted string. Parameters: arr (list of list of int): A 2D list of integers Returns: str: A CSV formatted string >>> arrayToCSV([[1, 2, 3]]) == \\"1,2,3\\" True >>> arrayToCSV([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == \\"1,2,3n4,5,6n7,8,9\\" True >>> arrayToCSV([[10, 20], [30, 40], [50]]) == \\"10,20n30,40n50\\" True >>> arrayToCSV([]) == \\"\\" True >>> arrayToCSV([[42]]) == \\"42\\" True >>> arrayToCSV([[100, -200], [-300, 400], [500, -600]]) == \\"100,-200n-300,400n500,-600\\" True","solution":"def arrayToCSV(arr): Converts a 2D array of integers into a CSV formatted string. Parameters: arr (list of list of int): A 2D list of integers Returns: str: A CSV formatted string return 'n'.join(','.join(map(str, row)) for row in arr)"},{"question":"def three_sum(array: List[int], target: int) -> List[List[int]]: Writes a function that takes an array of integers and a target value as input. The function should return all unique triplets in the array that add up to the target value. Each triplet should be an array of three integers in ascending order. >>> three_sum([1, 0, -1, 2, -1, -4], 0) == [[-1, -1, 2], [-1, 0, 1]] >>> three_sum([1, 2, -2, -1], 1) == [[-2, 1, 2]] >>> three_sum([1, 2, 3], 10) == [] >>> three_sum([0, 0, 0, 0], 0) == [[0, 0, 0]] >>> three_sum([-1, 0, 1, 2, -1, -4, -1, -4, 1, 2], 0) == [[-4, 2, 2], [-1, -1, 2], [-1, 0, 1]] >>> three_sum([1, -1, 0], 0) == [[-1, 0, 1]] >>> three_sum([1000, -1000, 0, 1, 2, -1, -2], 0) == [[-1000, 0, 1000], [-2, 0, 2], [-1, 0, 1]] pass","solution":"def three_sum(array, target): Returns all unique triplets in the array that add up to the target value. :param array: List[int] - List of integers :param target: int - Target sum for the triplets :return: List[List[int]] - List of triplets array.sort() triplets = [] length = len(array) for i in range(length - 2): if i > 0 and array[i] == array[i - 1]: continue left, right = i + 1, length - 1 while left < right: current_sum = array[i] + array[left] + array[right] if current_sum == target: triplets.append([array[i], array[left], array[right]]) while left < right and array[left] == array[left + 1]: left += 1 while left < right and array[right] == array[right - 1]: right -= 1 left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return triplets"},{"question":"def numDecodings(s: str) -> int: Returns the total number of ways to decode the given message. The mapping is as follows: 'A' -> 1 'B' -> 2 ... 'Z' -> 26 You may assume that the message contains only digits and is non-empty. Examples: >>> numDecodings(\\"12\\") 2 >>> numDecodings(\\"226\\") 3 >>> numDecodings(\\"0\\") 0 >>> numDecodings(\\"06\\") 0","solution":"def numDecodings(s: str) -> int: Returns the total number of ways to decode the given message. if not s or s[0] == '0': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): if s[i-1] != '0': dp[i] += dp[i-1] if s[i-2] == '1' or (s[i-2] == '2' and s[i-1] in '0123456'): dp[i] += dp[i-2] return dp[n]"},{"question":"def longestRepeatingSubstring(s: str) -> int: Given a string \`s\`, return the length of the longest substring that consists of the same character repeated consecutively. >>> longestRepeatingSubstring(\\"aaabbccc\\") 3 >>> longestRepeatingSubstring(\\"aabbccddd\\") 3 >>> longestRepeatingSubstring(\\"a\\") 1 >>> longestRepeatingSubstring(\\"abc\\") 1 >>> longestRepeatingSubstring(\\"aaaaaa\\") 6 >>> longestRepeatingSubstring(\\"aabbba\\") 3 def process_test_cases(T: int, cases: List[str]) -> List[int]: Given a number of test cases \`T\` and a list of strings \`cases\`, return a list of results where each result is the length of the longest substring for the corresponding string in \`cases\` that consists of the same character repeated consecutively. >>> process_test_cases(2, [\\"aaabbccc\\", \\"aabbccddd\\"]) [3, 3] >>> process_test_cases(1, [\\"aaaaa\\"]) [5] >>> process_test_cases(3, [\\"x\\", \\"y\\", \\"z\\"]) [1, 1, 1]","solution":"def longestRepeatingSubstring(s): Given a string \`s\`, return the length of the longest substring that consists of the same character repeated consecutively. max_count = 0 current_count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: current_count += 1 else: max_count = max(max_count, current_count) current_count = 1 max_count = max(max_count, current_count) return max_count def process_test_cases(T, cases): results = [] for i in range(T): results.append(longestRepeatingSubstring(cases[i])) return results"},{"question":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into one sorted array. >>> merge_sorted_arrays([1, 3, 5, 7], [2, 4, 6]) [1, 2, 3, 4, 5, 6, 7] >>> merge_sorted_arrays([1, 2, 3], [2, 3, 4]) [1, 2, 2, 3, 3, 4] >>> merge_sorted_arrays([1, 1, 1], [1, 1, 1]) [1, 1, 1, 1, 1, 1] >>> merge_sorted_arrays([1, 2, 3], [4, 5]) [1, 2, 3, 4, 5] >>> merge_sorted_arrays([1], [2]) [1, 2] >>> merge_sorted_arrays([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_arrays([1, 2, 3], []) [1, 2, 3]","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into one sorted array. merged_array = [] i, j = 0, 0 n, m = len(arr1), len(arr2) while i < n and j < m: if arr1[i] < arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 while i < n: merged_array.append(arr1[i]) i += 1 while j < m: merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"def longest_subarray_length(N, K, array): Returns the length of longest contiguous subarray where the difference between the maximum and minimum elements does not exceed K. :param N: Length of the array :param K: Allowed maximum difference between max and min elements :param array: List of integers representing the sequence :return: Length of the longest contiguous subarray def solve_task(T, test_cases): Solves the task for multiple test cases. :param T: Number of test cases :param test_cases: List of tuples, each containing N, K, and the sequence of integers :return: List of integers representing the length of the longest contiguous subarray for each test case from solution import solve_task def test_sample_input(): T = 2 test_cases = [ (5, 3, [1, 3, 6, 7, 5]), (4, 2, [10, 12, 14, 11]) ] expected_output = [3, 2] assert solve_task(T, test_cases) == expected_output def test_single_element(): T = 1 test_cases = [ (1, 3, [5]) ] expected_output = [1] assert solve_task(T, test_cases) == expected_output def test_entire_array_valid(): T = 1 test_cases = [ (6, 10, [1, 2, 3, 4, 5, 6]) ] expected_output = [6] assert solve_task(T, test_cases) == expected_output def test_no_valid_subarray(): T = 1 test_cases = [ (4, 0, [1, 2, 3, 4]) ] expected_output = [1] assert solve_task(T, test_cases) == expected_output def test_non_contiguous_elements(): T = 1 test_cases = [ (5, 2, [4, 7, 2, 9, 5]) ] expected_output = [1] assert solve_task(T, test_cases) == expected_output def test_large_k_value(): T = 1 test_cases = [ (5, 1000000000, [1, 2, 100, 200, 300]) ] expected_output = [5] assert solve_task(T, test_cases) == expected_output","solution":"def longest_subarray_length(N, K, array): Returns the length of longest contiguous subarray where the difference between the maximum and minimum elements does not exceed K. :param N: Length of the array :param K: Allowed maximum difference between max and min elements :param array: List of integers representing the sequence :return: Length of the longest contiguous subarray from collections import deque start = 0 max_len = 0 min_deque = deque() # to store min elements indices max_deque = deque() # to store max elements indices for end in range(N): while min_deque and array[min_deque[-1]] >= array[end]: min_deque.pop() while max_deque and array[max_deque[-1]] <= array[end]: max_deque.pop() min_deque.append(end) max_deque.append(end) while array[max_deque[0]] - array[min_deque[0]] > K: start += 1 if min_deque[0] < start: min_deque.popleft() if max_deque[0] < start: max_deque.popleft() max_len = max(max_len, end - start + 1) return max_len def solve_task(T, test_cases): results = [] for case in test_cases: N, K, array = case results.append(longest_subarray_length(N, K, array)) return results"},{"question":"def min_operations_to_make_uniform(n: int, sequence: List[int]) -> int: Given a sequence of integers, determine the minimum possible number of operations required to convert the initial sequence into one where all numbers are the same. Input The first line contains a single integer n (1 ≤ n ≤ 100,000) — the length of the sequence. The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 10^9) — the elements of the sequence. Output Output a single integer — the minimum number of operations required to make all elements of the sequence the same. Examples Input 4 1 2 2 1 Output 3 Input 5 3 3 3 3 3 Output 0 Input 4 1 1 1 1 Output 0 >>> min_operations_to_make_uniform(4, [1, 2, 2, 1]) 3 >>> min_operations_to_make_uniform(5, [3, 3, 3, 3, 3]) 0 >>> min_operations_to_make_uniform(4, [1, 1, 1, 1]) 0","solution":"def min_operations_to_make_uniform(n, sequence): Returns the minimum number of operations required to convert the sequence to one where all numbers are the same. # The function does not need to do any operations when n <= 1 if n <= 1: return 0 # Initialize to count unique elements unique_elements = set(sequence) # If there is only one element left in the set, no operation is needed if len(unique_elements) == 1: return 0 # Minimum number of operations needed is n - 1 return n - 1"},{"question":"def max_discount(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the maximum discount that can be applied for any contiguous subsequence within the array. Args: t (int): number of test cases test_cases (List[Tuple[int, List[int]]]): list of test cases, where each test case is a tuple containing an integer n (number of items) and a list of n positive integers representing item values. Returns: List[int]: list containing the maximum discount for each test case Example: >>> max_discount(2, [(5, [1, 2, 2, 3, 3]), (4, [4, 4, 4, 4])]) [6, 4] >>> max_discount(1, [(1, [5])]) [5]","solution":"def max_discount(t, test_cases): results = [] for i in range(t): n, items = test_cases[i] unique_items = list(set(items)) results.append(sum(unique_items)) return results # Example usage if __name__ == \\"__main__\\": t = 2 test_cases = [ (5, [1, 2, 2, 3, 3]), (4, [4, 4, 4, 4]) ] print(max_discount(t, test_cases)) # Output: [6, 4]"},{"question":"def calculate_sequences(N: int) -> int: Returns the number of unique sequences of length N containing at least one \\"A\\", one \\"B\\", and one \\"C\\". >>> calculate_sequences(1) == 0 >>> calculate_sequences(2) == 0 >>> calculate_sequences(3) == 6 >>> calculate_sequences(4) == 36 # Implement the logic for calculating valid sequences def sequences_count(test_cases: List[int]) -> List[int]: Returns a list of integers representing the number of valid unique sequences for each test case in the input list. >>> sequences_count([3, 4]) == [6, 36] >>> sequences_count([1, 6]) == [0, 540] # Implement the logic to collect results for each test case","solution":"def calculate_sequences(N): Returns the number of unique sequences of length N containing at least one \\"A\\", one \\"B\\", and one \\"C\\". if N < 3: return 0 total_sequences = 3 ** N sequences_without_A = 2 ** N sequences_without_B = 2 ** N sequences_without_C = 2 ** N sequences_without_A_and_B = 1 ** N sequences_without_B_and_C = 1 ** N sequences_without_A_and_C = 1 ** N sequences_without_A_B_and_C = 0 ** N valid_sequences = total_sequences - (sequences_without_A + sequences_without_B + sequences_without_C) + (sequences_without_A_and_B + sequences_without_B_and_C + sequences_without_A_and_C) - sequences_without_A_B_and_C return valid_sequences def sequences_count(test_cases): result = [] for N in test_cases: result.append(calculate_sequences(N)) return result"},{"question":"from typing import List def max_product_subarray(test_cases: List[List[int]]) -> List[int]: Given an array of positive integers, find the largest product that can be obtained by multiplying the elements of any non-empty subarray of the given array. Args: test_cases: A list of test cases, where each test case is represented by a list of integers. The first integer in each list indicates the number of elements in the array, followed by the elements of the array. Returns: A list of integers where each integer is the maximum product of any subarray for the corresponding test case. Example: >>> max_product_subarray([[4, 2, 3, -2, 4], [5, -1, -2, -3, 4, 5]]) [6, 120] >>> max_product_subarray([[1, 5]]) [5] >>> max_product_subarray([[4, 2, -3, 0, 4]]) [4]","solution":"def max_product_subarray(test_cases): results = [] for case in test_cases: N = case[0] nums = case[1:] max_prod = nums[0] min_prod = nums[0] result = nums[0] for num in nums[1:]: if num < 0: max_prod, min_prod = min_prod, max_prod max_prod = max(num, max_prod * num) min_prod = min(num, min_prod * num) result = max(result, max_prod) results.append(result) return results"},{"question":"from typing import List def can_split_equal_product(arr: List[int]) -> str: Determine if the list can be split into two non-empty contiguous subarrays such that the product of the elements in both subarrays are equal. >>> can_split_equal_product([1, 2, 3, 6, 1, 1]) == \\"YES\\" >>> can_split_equal_product([2, 4, 8, 16, 32]) == \\"NO\\" pass def test_example_1(): arr = [1, 2, 3, 6, 1, 1] assert can_split_equal_product(arr) == \\"YES\\" def test_example_2(): arr = [2, 4, 8, 16, 32] assert can_split_equal_product(arr) == \\"NO\\" def test_single_element(): arr = [1] assert can_split_equal_product(arr) == \\"NO\\" def test_two_elements_equal(): arr = [3, 3] assert can_split_equal_product(arr) == \\"YES\\" def test_two_elements_not_equal(): arr = [3, 2] assert can_split_equal_product(arr) == \\"NO\\" def test_all_ones(): arr = [1, 1, 1, 1, 1] assert can_split_equal_product(arr) == \\"YES\\" def test_large_numbers(): arr = [10**9, 10**9, 10**9, 10**9] assert can_split_equal_product(arr) == \\"YES\\"","solution":"def can_split_equal_product(arr): Determine if the list can be split into two non-empty contiguous subarrays such that the product of the elements in both subarrays are equal. n = len(arr) total_product = 1 for num in arr: total_product *= num current_product = 1 for i in range(n - 1): current_product *= arr[i] if current_product == total_product // current_product: return \\"YES\\" return \\"NO\\""},{"question":"def min_insertions_to_palindrome(s: str) -> int: Calculate the minimum number of insertions needed to transform a given string into a palindrome. >>> min_insertions_to_palindrome(\\"abca\\") 1 >>> min_insertions_to_palindrome(\\"race\\") 3 >>> min_insertions_to_palindrome(\\"a\\") 0","solution":"def min_insertions_to_palindrome(s: str) -> int: Returns the minimum number of insertions needed to transform the string \`s\` into a palindrome. n = len(s) # Create a table to store results of subproblems dp = [[0 for _ in range(n)] for _ in range(n)] # Fill the table for gap in range(1, n): for l in range(n - gap): r = l + gap if s[l] == s[r]: dp[l][r] = dp[l + 1][r - 1] else: dp[l][r] = min(dp[l][r - 1], dp[l + 1][r]) + 1 return dp[0][n - 1]"},{"question":"def count_visible_buildings(heights): Determines how many buildings can be seen from the start of the road. >>> count_visible_buildings([]) == 0 >>> count_visible_buildings([5]) == 1 >>> count_visible_buildings([1, 2, 3, 4, 5]) == 5 >>> count_visible_buildings([5, 4, 3, 2, 1]) == 1 >>> count_visible_buildings([3, 5, 4, 2, 6, 1]) == 3 >>> count_visible_buildings([2, 1, 3, 1, 4, 1, 5]) == 4","solution":"def count_visible_buildings(heights): Returns the number of buildings that can be seen from the start of the road. if not heights: return 0 max_height = heights[0] visible_count = 1 # The first building is always visible for height in heights[1:]: if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def largestNumberFromList(head): Construct the largest number possible from the digits in the linked list. :param head: ListNode, the head of the linked list. :return: int, the largest number possible. >>> # Create linked list 3 -> 4 -> 2 -> 9 -> 5 >>> head = ListNode(3) >>> head.next = ListNode(4) >>> head.next.next = ListNode(2) >>> head.next.next.next = ListNode(9) >>> head.next.next.next.next = ListNode(5) >>> largestNumberFromList(head) 95432 >>> # Create linked list 0 -> 0 -> 0 >>> head = ListNode(0) >>> head.next = ListNode(0) >>> head.next.next = ListNode(0) >>> largestNumberFromList(head) 0 >>> # Create linked list 5 -> 2 -> 1 -> 9 >>> head = ListNode(5) >>> head.next = ListNode(2) >>> head.next.next = ListNode(1) >>> head.next.next.next = ListNode(9) >>> largestNumberFromList(head) 9521 >>> # Create linked list 1 >>> head = ListNode(1) >>> largestNumberFromList(head) 1 >>> # Create linked list 7 -> 7 -> 7 -> 7 >>> head = ListNode(7) >>> head.next = ListNode(7) >>> head.next.next = ListNode(7) >>> head.next.next.next = ListNode(7) >>> largestNumberFromList(head) 7777 >>> # Create linked list 9 -> 8 -> 7 -> 6 -> 5 -> 4 -> 3 -> 2 -> 1 -> 0 >>> head = ListNode(9) >>> head.next = ListNode(8) >>> head.next.next = ListNode(7) >>> head.next.next.next = ListNode(6) >>> head.next.next.next.next = ListNode(5) >>> head.next.next.next.next.next = ListNode(4) >>> head.next.next.next.next.next.next = ListNode(3) >>> head.next.next.next.next.next.next.next = ListNode(2) >>> head.next.next.next.next.next.next.next.next = ListNode(1) >>> head.next.next.next.next.next.next.next.next.next = ListNode(0) >>> largestNumberFromList(head) 9876543210","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def largestNumberFromList(head): Construct the largest number possible from the digits in the linked list. :param head: ListNode, the head of the linked list. :return: int, the largest number possible. digits = [] current = head while current: digits.append(current.val) current = current.next # Sort the digits in descending order digits.sort(reverse=True) # Handle edge case when all digits are 0 if digits[0] == 0: return 0 # Convert digits to string and then to int to form the number largest_number = int(''.join(map(str, digits))) return largest_number"},{"question":"def can_make_elements_equal(n: int, k: int, b: List[int]) -> str: Determine if it's possible to make all the elements of the sequence equal in exactly k rounds. Args: n : int : number of elements in the sequence. k : int : number of rounds. b : List[int] : the sequence of numbers. Returns: str : \\"YES\\" if possible, \\"NO\\" otherwise. Examples: >>> can_make_elements_equal(5, 2, [2, 2, 1, 3, 3]) 'YES' >>> can_make_elements_equal(4, 1, [2, 2, 2, 2]) 'NO'","solution":"def can_make_elements_equal(n, k, b): Determine if it's possible to make all the elements of the sequence equal in exactly k rounds. Args: - n: int, number of elements in the sequence. - k: int, number of rounds. - b: list of int, the sequence of numbers. Returns: - str, \\"YES\\" if possible, \\"NO\\" otherwise. max_b = max(b) min_b = min(b) # The maximum number of operations needed to make all elements equal # is the difference between the max and min of the sequence. difference = max_b - min_b # If k is greater than or equal to the difference and the parity (odd/even) of k and the difference are the same, return \\"YES\\" if k >= difference and (k - difference) % 2 == 0: return \\"YES\\" return \\"NO\\""},{"question":"def max_profit(n: int, prices: List[int], bundle_price: int) -> int: Given a list of movie prices and a bundle price, this function calculates the maximum profit that can be obtained by selling the movies individually or in discount bundles. :param n: int, number of movies :param prices: list of int, prices of individual movie tickets :param bundle_price: int, price of the discount bundle :return: int, the maximum profit that can be obtained Examples: >>> max_profit(5, [15, 10, 20, 30, 25], 50) 100 >>> max_profit(4, [10, 15, 5, 5], 25) 35 >>> max_profit(3, [10, 5, 5], 30) 20 >>> max_profit(2, [5, 5], 15) 10 from solution import max_profit def test_max_profit_case_1(): assert max_profit(5, [15, 10, 20, 30, 25], 50) == 100 def test_max_profit_case_2(): assert max_profit(4, [10, 15, 5, 5], 25) == 35 def test_max_profit_case_3(): assert max_profit(3, [10, 5, 5], 30) == 20 def test_max_profit_case_4(): assert max_profit(2, [5, 5], 15) == 10 def test_max_profit_exact_bundle_price(): assert max_profit(3, [10, 15, 20], 45) == 45 def test_max_profit_multiple_bundles(): assert max_profit(6, [10, 20, 30, 10, 20, 30], 50) == 120 def test_max_profit_no_bundle_beneficial(): assert max_profit(6, [5, 5, 5, 5, 5, 5], 30) == 30","solution":"def max_profit(n, prices, bundle_price): Given a list of movie prices and a bundle price, this function calculates the maximum profit that can be obtained by selling the movies individually or in discount bundles. :param n: int, number of movies :param prices: list of int, prices of individual movie tickets :param bundle_price: int, price of the discount bundle :return: int, the maximum profit that can be obtained if n < 3: return sum(prices) prices.sort(reverse=True) profit = 0 i = 0 while i < len(prices): if i + 2 < len(prices) and prices[i] + prices[i+1] + prices[i+2] > bundle_price: profit += prices[i] + prices[i+1] + prices[i+2] i += 3 else: profit += prices[i] i += 1 return profit"},{"question":"def count_distinct_characters(S: str) -> int: Returns the count of distinct characters in the string S. >>> count_distinct_characters(\\"hello\\") == 4 >>> count_distinct_characters(\\"abcdef\\") == 6 >>> count_distinct_characters(\\"aabbcc\\") == 3 >>> count_distinct_characters(\\"a\\") == 1 >>> count_distinct_characters(\\"abcabcabc\\") == 3 >>> count_distinct_characters(\\"abcdefghijklmnopqrstuvwxyz\\" * 4) == 26","solution":"def count_distinct_characters(S): Returns the count of distinct characters in the string S. return len(set(S))"},{"question":"def get_top_k_players(K: int, M: int, players: list) -> list: Get the top K players based on their points. If players have the same points, they are ranked alphabetically by their usernames. :param K: an integer representing the number of top players to display :param M: an integer representing the total number of players :param players: a list of tuples where each tuple contains a string (username) and an integer (points) :return: a list of tuples of the top K players in the format (username, points) >>> get_top_k_players(3, 5, [(\\"Alice\\", 1500), (\\"Bob\\", 3000), (\\"Charlie\\", 1500), (\\"Dave\\", 2000), (\\"Eve\\", 3000)]) [('Bob', 3000), ('Eve', 3000), ('Dave', 2000)] >>> get_top_k_players(3, 5, [(\\"Alice\\", 1000), (\\"Bob\\", 1000), (\\"Charlie\\", 1000), (\\"Dave\\", 1000), (\\"Eve\\", 1000)]) [('Alice', 1000), ('Bob', 1000), ('Charlie', 1000)] >>> get_top_k_players(3, 2, [(\\"Alice\\", 1500), (\\"Bob\\", 3000)]) [('Bob', 3000), ('Alice', 1500)] >>> get_top_k_players(3, 0, []) [] >>> get_top_k_players(3, 5, [(\\"Alice\\", 2000), (\\"Bob\\", 3000), (\\"Charlie\\", 3000), (\\"Dave\\", 2000), (\\"Eve\\", 3000)]) [('Bob', 3000), ('Charlie', 3000), ('Eve', 3000)]","solution":"def get_top_k_players(K, M, players): Get the top K players based on their points. If players have the same points, they are ranked alphabetically by their usernames. :param K: an integer representing the number of top players to display :param M: an integer representing the total number of players :param players: a list of tuples where each tuple contains a string (username) and an integer (points) :return: a list of tuples of the top K players in the format (username, points) # Sort players first by points in descending order, then by username in ascending order sorted_players = sorted(players, key=lambda x: (-x[1], x[0])) # Return the top K players return sorted_players[:K]"},{"question":"def min_operations_to_zeros(n: int, arr: List[int]) -> int: Determine the minimum number of operations needed to transform the array into an array of all 0s. An operation consists of flipping the bit at any index i (1 ≤ i ≤ n) and if i is not the first or the last index, it will also flip the bits at positions i-1 and i+1. Args: n (int): The number of elements in the array. arr (List[int]): The initial state of the array. Returns: int: The minimum number of operations needed to transform the array into an array of all 0s. Examples: >>> min_operations_to_zeros(3, [1, 0, 1]) 1 >>> min_operations_to_zeros(5, [1, 1, 0, 1, 0]) 2 from solution import min_operations_to_zeros def test_all_zeros(): assert min_operations_to_zeros(5, [0, 0, 0, 0, 0]) == 0 assert min_operations_to_zeros(1, [0]) == 0 def test_single_cluster(): assert min_operations_to_zeros(3, [1, 1, 1]) == 1 assert min_operations_to_zeros(4, [0, 1, 1, 1]) == 1 def test_multiple_clusters(): assert min_operations_to_zeros(5, [1, 0, 1, 0, 1]) == 3 assert min_operations_to_zeros(6, [1, 1, 0, 1, 1, 1]) == 2 def test_mixed_clusters(): assert min_operations_to_zeros(5, [1, 1, 0, 1, 0]) == 2 assert min_operations_to_zeros(6, [1, 0, 1, 0, 0, 1]) == 3 def test_edge_cases(): assert min_operations_to_zeros(1, [1]) == 1 assert min_operations_to_zeros(2, [1, 0]) == 1 assert min_operations_to_zeros(2, [0, 1]) == 1","solution":"def min_operations_to_zeros(n, arr): operations = 0 i = 0 while i < n: if arr[i] == 1: operations += 1 while i < n and arr[i] == 1: i += 1 i += 1 return operations"},{"question":"def is_sort_possible(n: int, brightness: List[int]) -> str: Determine if it is possible to sort the lamps in non-decreasing order by performing the given swap operations. >>> is_sort_possible(5, [4, 3, 1, 2, 5]) 'NO' >>> is_sort_possible(4, [1, 2, 3, 4]) 'YES'","solution":"def is_sort_possible(n, brightness): Returns 'YES' if it is possible to sort the lamps in non-decreasing order by performing the given swap operations, otherwise returns 'NO'. for i in range(1, n): if brightness[i-1] > brightness[i]: return \\"NO\\" return \\"YES\\""},{"question":"def generate_diamond(n: int) -> str: Generate a diamond shape of height and width 2*n - 1. If n < 1, return an empty string. Examples: >>> generate_diamond(3) ' * n *** n*****n *** n * ' >>> generate_diamond(5) ' * n *** n ***** n ******* n*********n ******* n ***** n *** n * ' >>> generate_diamond(7) ' * n *** n ***** n ******* n ********* n *********** n*************n *********** n ********* n ******* n ***** n *** n * ' >>> generate_diamond(0) '' >>> generate_diamond(1) '*'","solution":"def generate_diamond(n): Generate a diamond shape of height and width 2*n - 1. If n < 1, return an empty string. if n < 1: return \\"\\" diamond = [] for i in range(1, n + 1): stars = '*' * (2 * i - 1) spaces = ' ' * (n - i) diamond.append(spaces + stars + spaces) for i in range(n - 1, 0, -1): stars = '*' * (2 * i - 1) spaces = ' ' * (n - i) diamond.append(spaces + stars + spaces) return 'n'.join(diamond)"},{"question":"def average_tickets_scanned(n, records): Calculate the average number of tickets scanned per scanner for the given records rounded to the nearest whole number. Args: n (int): the number of ticket scans. records (list): a list of strings, each containing a record in the format 'SCANNER_ID DATE'. Returns: int: the average number of tickets scanned per scanner. >>> average_tickets_scanned(5, [\\"A1 2023-01-15\\", \\"B2 2023-01-15\\", \\"A1 2023-01-15\\", \\"B2 2023-01-15\\", \\"C3 2023-01-15\\"]) 2 >>> average_tickets_scanned(6, [\\"A1 2023-01-15\\", \\"A1 2023-01-15\\", \\"B2 2023-01-16\\", \\"C3 2023-01-16\\", \\"C3 2023-01-16\\", \\"B2 2023-01-16\\"]) 2 >>> average_tickets_scanned(1, [\\"X1 2023-02-14\\"]) 1 >>> average_tickets_scanned(4, [\\"A1 2023-03-01\\", \\"A1 2023-03-01\\", \\"A1 2023-03-02\\", \\"A1 2023-03-02\\"]) 4 >>> average_tickets_scanned(8, [\\"A1 2023-04-01\\", \\"A1 2023-04-01\\", \\"B2 2023-04-01\\", \\"B2 2023-04-01\\", \\"C3 2023-04-02\\", \\"C3 2023-04-02\\", \\"D4 2023-04-02\\", \\"D4 2023-04-02\\"]) 2","solution":"def average_tickets_scanned(n, records): from collections import defaultdict scanner_counts = defaultdict(int) for record in records: scanner_id, _ = record.split() scanner_counts[scanner_id] += 1 average = round(sum(scanner_counts.values()) / len(scanner_counts)) return average"},{"question":"def number_of_connected_components(input_string: str) -> int: Determines the number of connected components in the network. Parameters: input_string (str): The input data as a string. The first line contains two integers N and M. Each of the next M lines contains two integers u and v indicating a direct communication channel. Returns: int: The number of connected components in the network. Examples: >>> number_of_connected_components(\\"5 3n1 2n2 3n4 5\\") 2 >>> number_of_connected_components(\\"6 4n1 2n2 3n4 5n5 6\\") 2 >>> number_of_connected_components(\\"3 0\\") 3 >>> number_of_connected_components(\\"4 2n1 2n3 4\\") 2 >>> number_of_connected_components(\\"6 3n1 2n2 3n4 5\\") 3 >>> number_of_connected_components(\\"1000 0\\") 1000","solution":"def find_connected_components(n, edges): Finds the number of connected components in a network of servers. Parameters: n (int): Number of servers. edges (List[Tuple[int, int]]): List of bidirectional communication channels between servers. Returns: int: Number of connected components. def dfs(node, visited, adjacency_list): stack = [node] while stack: current = stack.pop() for neighbor in adjacency_list[current]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) # Create adjacency list adjacency_list = {i: [] for i in range(1, n + 1)} for u, v in edges: adjacency_list[u].append(v) adjacency_list[v].append(u) visited = set() connected_components = 0 for server in range(1, n + 1): if server not in visited: dfs(server, visited, adjacency_list) connected_components += 1 return connected_components # Function to parse input and call the solution function def number_of_connected_components(input_string): lines = input_string.strip().split('n') n, m = map(int, lines[0].split()) edges = [tuple(map(int, line.split())) for line in lines[1:m+1]] return find_connected_components(n, edges)"},{"question":"def containsNearbyAlmostDuplicate(nums, k, t): Checks if there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k. >>> containsNearbyAlmostDuplicate([1, 2, 3, 1], 3, 0) True >>> containsNearbyAlmostDuplicate([1, 0, 1, 1], 1, 2) True >>> containsNearbyAlmostDuplicate([1, 5, 9, 1, 5, 9], 1, 2) False pass","solution":"def containsNearbyAlmostDuplicate(nums, k, t): Checks if there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k. if k == 0 or t < 0 or not nums: return False num_dict = {} for i, num in enumerate(nums): bucket = num // (t + 1) if bucket in num_dict: return True if bucket - 1 in num_dict and abs(num_dict[bucket - 1] - num) <= t: return True if bucket + 1 in num_dict and abs(num_dict[bucket + 1] - num) <= t: return True num_dict[bucket] = num if i >= k: del num_dict[nums[i - k] // (t + 1)] return False"},{"question":"def compute_minimal_distance(n: int) -> int: Given the number of houses, computes the minimal distance the Post Office must travel to visit each house and return to the starting point. Args: n (int): The number of houses. Returns: int: The minimal distance traveled. >>> compute_minimal_distance(2) 2 >>> compute_minimal_distance(3) 4 >>> compute_minimal_distance(5) 8 >>> compute_minimal_distance(10) 18 >>> compute_minimal_distance(100000) 199998","solution":"def compute_minimal_distance(n): Given the number of houses, computes the minimal distance the Post Office must travel to visit each house and return to the starting point. Args: n (int): The number of houses. Returns: int: The minimal distance traveled. # Since the houses are evenly spaced along a straight road, and we need to # visit each house and return back to the starting point: # - The total distance will be twice the distance between the Post Office (start) # and the last house. # If there are n houses, the distance one way is (n - 1). # So, the total distance is 2 * (n - 1). return 2 * (n - 1)"},{"question":"from typing import List def longest_word(letters: str, words: List[str]) -> str: Create a function that takes a list of words and returns the longest word that can be formed using a subset of the letters provided in another string. The function should be case-insensitive and the subset should not reuse any character from the string more than its occurrences. >>> longest_word(\\"ApplE\\", [\\"apple\\", \\"plea\\", \\"ap\\", \\"ale\\"]) 'apple' >>> longest_word(\\"abc\\", [\\"a\\", \\"ab\\", \\"abc\\", \\"d\\"]) 'abc' >>> longest_word(\\"\\", [\\"a\\", \\"ab\\", \\"abc\\"]) '' >>> longest_word(\\"abc\\", []) '' >>> longest_word(\\"abc\\", [\\"ab\\", \\"ac\\"]) 'ab' >>> longest_word(\\"zxy\\", [\\"a\\", \\"b\\", \\"c\\"]) '' >>> longest_word(\\"AaBbCc\\", [\\"a\\", \\"ab\\", \\"abc\\"]) 'abc' >>> longest_word(\\"bananao\\", [\\"banana\\", \\"nab\\", \\"banana\\"]) 'banana'","solution":"from collections import Counter def longest_word(letters, words): Returns the longest word that can be formed with the given letters. letters = letters.lower() letters_count = Counter(letters) def can_form_word(word): word_count = Counter(word) for char, count in word_count.items(): if letters_count[char] < count: return False return True longest = \\"\\" for word in words: if can_form_word(word) and len(word) > len(longest): longest = word return longest"},{"question":"go // package main import \\"fmt\\" // countDistinctPairs calculates the number of distinct pairs // in an array that sum up to a specific target value. func countDistinctPairs(array []int, target int) int { // Function implementation here } // Example usage: // func main() { // array := []int{1, 5, 7, -1, 5} // target := 6 // fmt.Println(countDistinctPairs(array, target)) // Output: 2 // }","solution":"def count_distinct_pairs(array, target): Returns the number of distinct pairs in the array that sum up to the target value. pair_count = 0 seen_pairs = set() seen_elements = {} for number in array: complement = target - number if complement in seen_elements: pair = tuple(sorted((number, complement))) # Sort to avoid duplicate pairs if pair not in seen_pairs: seen_pairs.add(pair) pair_count += 1 if number in seen_elements: seen_elements[number] += 1 else: seen_elements[number] = 1 return pair_count # Example usage: # n = 5 # array = [1, 5, 7, -1, 5] # target = 6 # print(count_distinct_pairs(array, target)) # Output: 2"},{"question":"def transpose(N, A): Transpose a given NxN matrix. Parameters: N (int): Size of the NxN matrix A (list of list of int): The NxN matrix to transpose Returns: list of list of int: The transposed NxN matrix Examples: >>> transpose(2, [[1, 2], [3, 4]]) [[1, 3], [2, 4]] >>> transpose(3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]]","solution":"def transpose(N, A): Returns the transposed matrix of A. Parameters: N (int): Size of the NxN matrix A (list of list of int): The NxN matrix to transpose Returns: list of list of int: The transposed NxN matrix return [[A[j][i] for j in range(N)] for i in range(N)]"},{"question":"def manage_keys(N: int, M: int, commands: List[str]) -> List[str]: Manage the royal treasury keys usage with appropriate messages. Args: N (int): The number of keys. M (int): The number of commands. commands (List[str]): List of commands in the format \\"use X\\" or \\"return X\\". Returns: List[str]: List of messages corresponding to each command's result. Example: >>> manage_keys(5, 7, [ ... \\"use 1\\", \\"use 2\\", \\"use 1\\", ... \\"return 1\\", \\"return 2\\", \\"return 2\\", ... \\"use 3\\" ... ]) [ \\"Key 1 taken\\", \\"Key 2 taken\\", \\"Key 1 was already taken\\", \\"Key 1 returned\\", \\"Key 2 returned\\", \\"Key 2 was never taken\\", \\"Key 3 taken\\" ] >>> manage_keys(1, 4, [ ... \\"use 1\\", \\"use 1\\", ... \\"return 1\\", \\"return 1\\" ... ]) [\\"Key 1 taken\\", \\"Key 1 was already taken\\", \\"Key 1 returned\\", \\"Key 1 was never taken\\"]","solution":"def manage_keys(N, M, commands): keys_in_use = set() result = [] for command in commands: action, X = command.split() X = int(X) if action == \\"use\\": if X in keys_in_use: result.append(f\\"Key {X} was already taken\\") else: keys_in_use.add(X) result.append(f\\"Key {X} taken\\") elif action == \\"return\\": if X in keys_in_use: keys_in_use.remove(X) result.append(f\\"Key {X} returned\\") else: result.append(f\\"Key {X} was never taken\\") return result"},{"question":"def min_meeting_rooms(meetings): Returns the minimum number of meeting rooms required to accommodate all meetings. pass def process_input(input_string): Processes the input string and returns the minimum number of meeting rooms required. pass import pytest def test_example_1(): input_data = \\"4 3n1 10n2 6n8 12\\" assert process_input(input_data) == 2 def test_example_2(): input_data = \\"2 5n0 30n5 10n15 20n15 25n25 30\\" assert process_input(input_data) == 3 def test_example_3(): input_data = \\"5 1n4 5\\" assert process_input(input_data) == 1 def test_no_meetings(): input_data = \\"3 0\\" assert process_input(input_data) == 0 def test_non_overlapping_meetings(): input_data = \\"2 3n1 3n4 6n7 9\\" assert process_input(input_data) == 1 def test_all_overlapping_meetings(): input_data = \\"1 3n1 4n2 5n3 6\\" assert process_input(input_data) == 3 def test_multiple_meetings_with_gap(): input_data = \\"2 4n1 2n3 4n5 6n7 8\\" assert process_input(input_data) == 1 def test_large_input(): input_data = \\"3 5n1 10n2 6n8 12n9 14n15 20\\" assert process_input(input_data) == 3","solution":"import heapq def min_meeting_rooms(meetings): Returns the minimum number of meeting rooms required to accommodate all meetings. if not meetings: return 0 # Sort meetings based on start times meetings.sort(key=lambda x: x[0]) # Min-heap to track the end time of meetings end_times = [] # Add the end time of the first meeting heapq.heappush(end_times, meetings[0][1]) for i in range(1, len(meetings)): # Check if the current meeting can use the room that has the earliest end time if meetings[i][0] >= end_times[0]: heapq.heappop(end_times) # Add the end time of the current meeting heapq.heappush(end_times, meetings[i][1]) return len(end_times) def process_input(input_string): Processes the input string and returns the minimum number of meeting rooms required. lines = input_string.strip().split('n') n, m = map(int, lines[0].split()) meetings = [list(map(int, line.split())) for line in lines[1:]] return min_meeting_rooms(meetings)"},{"question":"def most_frequent_odd_integer(N: int, integer_list: List[int]) -> int: Returns the most frequent odd integer in the list. If there are no odd integers, return -1. If there is a tie, return the smallest odd integer with the highest frequency. >>> most_frequent_odd_integer(7, [4, 3, 3, 1, 5, 5, 7]) 3 >>> most_frequent_odd_integer(5, [8, 8, 8, 8, 8]) -1 >>> most_frequent_odd_integer(4, [2, 4, 6, 8]) -1 >>> most_frequent_odd_integer(1, [5]) 5 >>> most_frequent_odd_integer(6, [7, 7, 3, 3, 5, 3]) 3 >>> most_frequent_odd_integer(4, [-1000000, -999999, 999999, 1000000]) -999999 >>> most_frequent_odd_integer(8, [1, 1, 2, 3, 3, 5, 5, 7]) 1","solution":"from collections import Counter def most_frequent_odd_integer(N, integer_list): Returns the most frequent odd integer in the list. If there are no odd integers, return -1. If there is a tie, return the smallest odd integer with the highest frequency. odd_integers = [x for x in integer_list if x % 2 != 0] if not odd_integers: return -1 frequency_counter = Counter(odd_integers) most_frequent_odd = min(frequency_counter.items(), key=lambda x: (-x[1], x[0]))[0] return most_frequent_odd"},{"question":"def is_possible(N: int, M: int, conflicts: List[Tuple[int, int]]) -> str: Determine if it's possible to arrange departments such that no conflicting departments sit next to each other. Args: N (int): Number of departments. M (int): Number of conflicting pairs. conflicts (List[Tuple[int, int]]): List of pairs of departments that do not get along. Returns: str: \\"Possible\\" if it's possible to arrange departments without conflicts, otherwise \\"Impossible\\". >>> is_possible(3, 2, [(1, 2), (2, 3)]) == \\"Possible\\" >>> is_possible(3, 3, [(1, 2), (2, 3), (1, 3)]) == \\"Impossible\\" >>> is_possible(4, 0, []) == \\"Possible\\" pass def parse_input(input_str: str) -> Tuple[int, int, List[Tuple[int, int]]]: Parse the input from a string to extract number of departments, number of conflicting pairs, and the conflict pairs. Args: input_str (str): Input string containing number of departments, number of conflicting pairs, and the pairs. Returns: Tuple[int, int, List[Tuple[int, int]]]: Parsed number of departments, number of conflicting pairs, and the list of conflict pairs. >>> parse_input(\\"3 2n1 2n2 3\\") == (3, 2, [(1, 2), (2, 3)]) pass # Unit Tests def test_case_1(): input_str = \\"3 2n1 2n2 3\\" N, M, conflicts = parse_input(input_str) assert is_possible(N, M, conflicts) == \\"Possible\\" def test_case_2(): input_str = \\"3 3n1 2n2 3n1 3\\" N, M, conflicts = parse_input(input_str) assert is_possible(N, M, conflicts) == \\"Impossible\\" def test_case_3(): input_str = \\"4 0\\" N, M, conflicts = parse_input(input_str) assert is_possible(N, M, conflicts) == \\"Possible\\" def test_case_4(): input_str = \\"5 4n1 2n2 3n3 4n4 5\\" N, M, conflicts = parse_input(input_str) assert is_possible(N, M, conflicts) == \\"Possible\\" def test_case_5(): input_str = \\"5 5n1 2n2 3n3 4n4 5n5 1\\" N, M, conflicts = parse_input(input_str) assert is_possible(N, M, conflicts) == \\"Impossible\\" def test_case_6(): input_str = \\"6 3n1 2n3 4n5 6\\" N, M, conflicts = parse_input(input_str) assert is_possible(N, M, conflicts) == \\"Possible\\" def test_case_7(): input_str = \\"1 0\\" N, M, conflicts = parse_input(input_str) assert is_possible(N, M, conflicts) == \\"Possible\\" def test_case_8(): input_str = \\"2 1n1 2\\" N, M, conflicts = parse_input(input_str) assert is_possible(N, M, conflicts) == \\"Possible\\"","solution":"def is_possible(N, M, conflicts): from collections import defaultdict, deque graph = defaultdict(list) for u, v in conflicts: graph[u].append(v) graph[v].append(u) color = {} def bfs(start): queue = deque([start]) color[start] = 0 while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in color: color[neighbor] = 1 - color[node] queue.append(neighbor) elif color[neighbor] == color[node]: return False return True for node in range(1, N + 1): if node not in color: if not bfs(node): return \\"Impossible\\" return \\"Possible\\" # Utility functions for easier unit tests def parse_input(input_str): lines = input_str.strip().split('n') N, M = map(int, lines[0].split()) conflicts = [tuple(map(int, line.split())) for line in lines[1:]] return N, M, conflicts"},{"question":"def subarray_sum(nums: list, k: int) -> int: Finds the number of contiguous subarrays that sum to a given value \`k\`. :param nums: List of integers representing the array. :param k: Integer representing the target sum. :return: Integer representing the number of contiguous subarrays that sum to \`k\`. >>> subarray_sum([1, 1, 1], 2) 2 >>> subarray_sum([1, 2, 3], 3) 2 >>> subarray_sum([1, -1, 1], 1) 3 >>> subarray_sum([1, 2, 1, 2, 1], 3) 4 >>> subarray_sum([1, 2, 3], 5) 1 >>> subarray_sum([1], 0) 0 >>> subarray_sum([0, 0, 0, 0], 0) 10 >>> subarray_sum([], 0) 0 >>> subarray_sum([1, -1, 1, -1], 0) 4 >>> subarray_sum([3, 4, 7, 2, -3, 1, 4, 2], 7) 4","solution":"def subarray_sum(nums: list, k: int) -> int: Finds the number of contiguous subarrays that sum to a given value \`k\`. :param nums: List of integers representing the array. :param k: Integer representing the target sum. :return: Integer representing the number of contiguous subarrays that sum to \`k\`. count = 0 current_sum = 0 prefix_sums = {0: 1} for num in nums: current_sum += num sum_needed = current_sum - k if sum_needed in prefix_sums: count += prefix_sums[sum_needed] if current_sum in prefix_sums: prefix_sums[current_sum] += 1 else: prefix_sums[current_sum] = 1 return count"},{"question":"def is_palindrome(s: str) -> bool: Identify whether a given sentence is a palindrome. A sentence is considered a palindrome if, after removing all non-alphanumeric characters and ignoring cases, it reads the same from left to right and right to left. Args: s (str): The sentence to be checked, with a maximum length of 500 characters. Returns: bool: True if the given string is a palindrome, otherwise False. Examples: >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"race a car\\") False pass","solution":"def is_palindrome(s): Returns True if the given string s is a palindrome, ignoring non-alphanumeric characters and case. # Filter out non-alphanumeric characters and convert to lower case filtered_chars = [char.lower() for char in s if char.isalnum()] # Check if the filtered list is equal to its reverse return filtered_chars == filtered_chars[::-1]"},{"question":"def is_prime(n): Check if the given number is a prime number. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False def sort_primes(deck): Takes a list of integers representing a deck of cards and sorts only the prime number cards in non-decreasing order, while keeping non-prime numbers in their original positions. >>> sort_primes([7, 4, 10, 3, 18, 11, 2]) == [2, 4, 10, 3, 18, 7, 11] >>> sort_primes([2, 3, 5, 1, 4]) == [2, 3, 5, 1, 4]","solution":"def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def sort_primes(deck): primes = [num for num in deck if is_prime(num)] primes.sort() prime_index = 0 for i in range(len(deck)): if is_prime(deck[i]): deck[i] = primes[prime_index] prime_index += 1 return deck"},{"question":"from typing import List, Tuple def count_connected_components(n: int, edges: List[Tuple[int, int]]) -> int: Determine the number of connected components in an undirected graph. >>> count_connected_components(5, [(0, 1), (1, 2), (3, 4)]) == 2 >>> count_connected_components(5, [(0, 1), (1, 2), (2, 3), (3, 4)]) == 1 >>> count_connected_components(3, []) == 3","solution":"from typing import List, Tuple def count_connected_components(n: int, edges: List[Tuple[int, int]]) -> int: # Helper function for Depth First Search def dfs(node, visited, graph): stack = [node] while stack: current = stack.pop() for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) # Create a graph using adjacency list graph = {i: [] for i in range(n)} for u, v in edges: graph[u].append(v) graph[v].append(u) visited = set() components_count = 0 # Find connected components using DFS for node in range(n): if node not in visited: # Found a new component components_count += 1 visited.add(node) dfs(node, visited, graph) return components_count"},{"question":"c #include <stdio.h> // Function to find the maximum weight in the specified range int max_in_range(int weights[], int start, int end) { int max_weight = weights[start]; for (int i = start + 1; i <= end; i++) { if (weights[i] > max_weight) { max_weight = weights[i]; } } return max_weight; } int main() { int N, Q; scanf(\\"%d\\", &N); int weights[N]; for (int i = 0; i < N; i++) { scanf(\\"%d\\", &weights[i]); } scanf(\\"%d\\", &Q); for (int i = 0; i < Q; i++) { int start, end; scanf(\\"%d %d\\", &start, &end); printf(\\"%dn\\", max_in_range(weights, start - 1, end - 1)); } return 0; } /* Sample Input: 7 2 5 1 8 3 9 4 3 1 3 4 7 2 5 Sample Output: 5 9 8 */","solution":"def heaviest_containers(container_weights, queries): Returns the maximum container weight for each query range. Parameters: container_weights (list of int): Weights of the containers. queries (list of tuples): Each tuple contains two integers representing the start and end indices of the query range (1-based index). Returns: list of int: Maximum weights in the specified ranges. results = [] for start, end in queries: # Adjust indices from 1-based to 0-based max_weight = max(container_weights[start-1:end]) results.append(max_weight) return results"},{"question":"def words_with_prefix(words: List[str], prefix: str) -> int: Write a function that takes a list of words and a prefix string. The function should return the number of words that start with the given prefix. >>> words_with_prefix([\\"apple\\", \\"apricot\\", \\"banana\\", \\"appliance\\"], \\"ap\\") == 3 >>> words_with_prefix([\\"cherry\\", \\"mango\\", \\"melon\\", \\"maple\\"], \\"ma\\") == 3 >>> words_with_prefix([\\"cat\\", \\"dog\\", \\"dolphin\\", \\"donkey\\"], \\"do\\") == 2 from typing import List def test_words_with_prefix_all_matching(): assert words_with_prefix([\\"apple\\", \\"apricot\\", \\"appliance\\"], \\"ap\\") == 3 def test_words_with_prefix_some_matching(): assert words_with_prefix([\\"apple\\", \\"apricot\\", \\"banana\\", \\"appliance\\"], \\"ap\\") == 3 def test_words_with_prefix_none_matching(): assert words_with_prefix([\\"banana\\", \\"cherry\\", \\"mango\\"], \\"ap\\") == 0 def test_words_with_prefix_empty_list(): assert words_with_prefix([], \\"ap\\") == 0 def test_words_with_prefix_single_letter(): assert words_with_prefix([\\"cat\\", \\"dog\\", \\"dolphin\\", \\"donkey\\"], \\"d\\") == 3 def test_words_with_prefix_full_word_prefix(): assert words_with_prefix([\\"cat\\", \\"dog\\", \\"dolphin\\", \\"donkey\\"], \\"dog\\") == 1","solution":"def words_with_prefix(words, prefix): Returns the number of words that start with the given prefix. :param words: List of words. :param prefix: The prefix string to match. :return: The number of words starting with the prefix. return sum(word.startswith(prefix) for word in words)"},{"question":"def is_divisible(A: int, B: int) -> str: Determines if A is divisible by B. >>> is_divisible(10, 2) \\"Yes\\" >>> is_divisible(10, 3) \\"No\\" >>> is_divisible(100000, 100000) \\"Yes\\" >>> is_divisible(1, 1) \\"Yes\\" >>> is_divisible(99999, 100000) \\"No\\"","solution":"def is_divisible(A, B): Determines if A is divisible by B. Parameters: A (int): The dividend. B (int): The divisor. Returns: str: \\"Yes\\" if A is divisible by B, otherwise \\"No\\". if A % B == 0: return \\"Yes\\" else: return \\"No\\""},{"question":"def max_treasure(m: int, h: int, treasures: List[int]) -> int: Calculates the maximum treasure that can be collected in h hours. Parameters: m (int): Number of treasure locations (1 ≤ m ≤ 10^5). h (int): Total game duration in hours (1 ≤ h ≤ 10^5). treasures (List[int]): List of integers representing the amount of treasure at each location (1 ≤ t_i ≤ 10^5). Returns: int: Maximum treasure collected in h hours. >>> max_treasure(4, 3, [100, 200, 300, 400]) 900 >>> max_treasure(5, 2, [10, 50, 20, 30, 60]) 110","solution":"def max_treasure(m, h, treasures): Calculates the maximum treasure that can be collected in h hours. Parameters: m (int): Number of treasure locations. h (int): Total game duration in hours. treasures (list): List of integers representing the amount of treasure at each location. Returns: int: Maximum treasure collected in h hours. treasures.sort(reverse=True) # Sort treasures descending max_treasure_collected = sum(treasures[:h]) # Take the sum of the top 'h' values return max_treasure_collected # Examples print(max_treasure(4, 3, [100, 200, 300, 400])) # Output: 900 print(max_treasure(5, 2, [10, 50, 20, 30, 60])) # Output: 110"},{"question":"from typing import List, Tuple def find_video_depths(n: int, folders: List[str]) -> List[Tuple[str, int]]: Determine the depth of each video in the playlist hierarchy. Args: n (int): The number of folders. folders (List[str]): List containing the folder structure. Returns: List[Tuple[str, int]]: List of tuples containing video name and its depth. Examples: >>> find_video_depths(3, [\\"Root Folder1 Folder2\\", \\"Folder1 Video1 Folder3\\", \\"Folder3 Video2 Video3\\"]) [(\\"Video1\\", 2), (\\"Video2\\", 3), (\\"Video3\\", 3)] >>> find_video_depths(1, [\\"Root Video1 Video2 Video3\\"]) [(\\"Video1\\", 1), (\\"Video2\\", 1), (\\"Video3\\", 1)]","solution":"def find_video_depths(n, folders): from collections import defaultdict, deque folder_dict = defaultdict(list) for line in folders: parts = line.split() folder = parts[0] contents = parts[1:] folder_dict[folder].extend(contents) video_depths = {} queue = deque([(\\"Root\\", 0)]) # (current folder, current depth) while queue: current_folder, current_depth = queue.popleft() for item in folder_dict[current_folder]: if \\"Folder\\" in item: # item is a folder queue.append((item, current_depth + 1)) else: # item is a video video_depths[item] = current_depth + 1 result = [] for line in folders: parts = line.split() for content in parts[1:]: if content in video_depths: result.append((content, video_depths[content])) return result"},{"question":"def apply_queries(N: int, Q: int, array: List[int], queries: List[Tuple[int, int]]) -> List[int]: Applies a series of range increment queries to the array and returns the final state of the array. Parameters: N (int): number of elements in the array Q (int): number of queries array (list of int): initial elements of the array queries (list of tuple of int): queries represented as (L, R) tuples Returns: list of int: the final state of the array after all queries have been applied >>> apply_queries(5, 3, [1, 2, 3, 4, 5], [(1, 3), (2, 4), (3, 5)]) [2, 4, 6, 6, 6] >>> apply_queries(4, 2, [1, 1, 1, 1], [(1, 4), (1, 4)]) [3, 3, 3, 3] >>> apply_queries(3, 1, [1, 2, 3], [(2, 2)]) [1, 3, 3] >>> apply_queries(6, 2, [1, 2, 3, 4, 5, 6], [(1, 3), (4, 6)]) [2, 3, 4, 5, 6, 7] >>> apply_queries(5, 2, [10, 20, 30, 40, 50], [(1, 5), (3, 5)]) [11, 21, 32, 42, 52]","solution":"def apply_queries(N, Q, array, queries): Applies a series of range increment queries to the array. Parameters: N (int): number of elements in the array Q (int): number of queries array (list of int): initial elements of the array queries (list of tuple of int): queries represented as (L, R) tuples Returns: list of int: the final state of the array after all queries have been applied # Using a difference array technique to handle range updates efficiently difference_array = [0] * (N + 1) # Applying the queries using the difference array for (L, R) in queries: difference_array[L - 1] += 1 if R < N: difference_array[R] -= 1 # Converting the difference array back to the updated array increment = 0 for i in range(N): increment += difference_array[i] array[i] += increment return array"},{"question":"def printLevelOrderTraversal(arr, N): Given an array arr[] which contains data of first N nodes of a Full Binary Tree in an in-order fashion, prints all possible level order traversals of the Full Binary Tree. >>> printLevelOrderTraversal([1, 2, 3, 4, 5, 6, 7], 7) [[4], [2, 6], [1, 3, 5, 7]] >>> printLevelOrderTraversal([1, 2, 3], 3) [[2], [1, 3]] >>> printLevelOrderTraversal([1], 1) [[1]] >>> printLevelOrderTraversal([], 0) []","solution":"def printLevelOrderTraversal(arr, N): if N == 0: return [] def buildTree(arr, start, end): if start > end: return None, [] mid = (start + end) // 2 root = arr[mid] left_level_order = [] right_level_order = [] left_subtree, left_level_order = buildTree(arr, start, mid - 1) right_subtree, right_level_order = buildTree(arr, mid + 1, end) result = [[root]] i = 0 while i < max(len(left_level_order), len(right_level_order)): current_level = [] if i < len(left_level_order): current_level.extend(left_level_order[i]) if i < len(right_level_order): current_level.extend(right_level_order[i]) result.append(current_level) i += 1 return root, result _, level_order = buildTree(arr, 0, N - 1) return level_order"},{"question":"from typing import List, Tuple def find_min_towers(N: int, M: int, roads: List[Tuple[int, int]]) -> int: Determine the minimum number of communication towers needed to ensure that every city is connected directly or indirectly to at least one communication tower. Args: N : int : The number of cities M : int : The number of bidirectional roads connecting the cities roads : List[Tuple[int, int]] : The list of bidirectional roads where each road connects two cities (u, v) Returns: int : The minimum number of communication towers needed. >>> find_min_towers(5, 4, [(1, 2), (2, 3), (4, 5), (3, 4)]) 1 >>> find_min_towers(1, 0, []) 1 >>> find_min_towers(4, 2, [(1, 2), (3, 4)]) 2 >>> find_min_towers(5, 0, []) 5 >>> find_min_towers(6, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) 1 pass","solution":"def find_min_towers(N, M, roads): from collections import defaultdict def dfs(node, visited, adj_list): stack = [node] while stack: v = stack.pop() for neighbor in adj_list[v]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) adj_list = defaultdict(list) for u, v in roads: adj_list[u].append(v) adj_list[v].append(u) visited = set() components = 0 for city in range(1, N+1): if city not in visited: components += 1 visited.add(city) dfs(city, visited, adj_list) return components"},{"question":"def can_partition(n: int, k: int, arr: List[int]) -> str: Determines if it is possible to partition the array into exactly k non-empty subarrays such that the sum of elements in each subarray is strictly increasing. >>> can_partition(7, 3, [1, 2, 3, 4, 5, 6, 7]) 'YES' >>> can_partition(7, 4, [1, 3, 2, 4, 6, 5, 8]) 'YES' >>> can_partition(5, 2, [-1, -2, -3, -4, -5]) 'NO' >>> can_partition(5, 1, [4, 5, -2, 3, 6]) 'YES' from solution import can_partition def test_example_1(): assert can_partition(7, 3, [1, 2, 3, 4, 5, 6, 7]) == \\"YES\\" def test_example_2(): assert can_partition(7, 4, [1, 3, 2, 4, 6, 5, 8]) == \\"YES\\" def test_example_3(): assert can_partition(5, 2, [-1, -2, -3, -4, -5]) == \\"NO\\" def test_example_4(): assert can_partition(5, 1, [4, 5, -2, 3, 6]) == \\"YES\\" def test_single_cut(): assert can_partition(6, 2, [1, 2, 3, 4, 5, 10]) == \\"YES\\" def test_no_possible_cuts(): assert can_partition(4, 3, [7, 6, 5, 4]) == \\"NO\\" def test_all_elements_equal(): assert can_partition(5, 3, [1, 1, 1, 1, 1]) == \\"NO\\" def test_large_k(): assert can_partition(10, 1, [3, 2, 7, 5, 9, -1, -2, 6, 4, 10]) == \\"YES\\" def test_k_equals_n(): assert can_partition(5, 5, [1, 2, 3, 4, 5]) == \\"YES\\" def test_negative_elements(): assert can_partition(6, 3, [-10, -5, -7, -3, -6, -1]) == \\"YES\\"","solution":"def can_partition(n, k, arr): Determines if it is possible to partition the array into exactly k non-empty subarrays such that the sum of elements in each subarray is strictly increasing. # If k is 1, we can always make one partition if k == 1: return \\"YES\\" # If k is greater than n, it's not possible if k > n: return \\"NO\\" # Initialize a count for number of potential breaks potential_cuts = 0 # Identify potential places to create subarrays with strictly increasing sum for i in range(1, n): if arr[i] > arr[i - 1]: potential_cuts += 1 # To get exactly k subarrays, we need at least k-1 cuts if potential_cuts >= k - 1: return \\"YES\\" else: return \\"NO\\""},{"question":"def can_be_happy(n: int, k: int, heights: List[int]) -> str: Determines if the students can be rearranged in such a way that the difference in height between any two adjacent students does not exceed k. Parameters: n (int): Number of students. k (int): Maximum allowed height difference between any two adjacent students. heights (list of int): List of heights of the students. Returns: str: \\"YES\\" if the students can be rearranged to satisfy the condition, otherwise \\"NO\\". >>> can_be_happy(5, 3, [4, 7, 1, 3, 9]) \\"YES\\" >>> can_be_happy(4, 1, [10, 1, 5, 6]) \\"NO\\" pass # implementation goes here def process_test_cases(test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Processes multiple test cases for the can_be_happy function. Parameters: test_cases (list of tuple): List of test cases, where each test case is a tuple containing the value of n, k, and the list of heights. Returns: list of str: List of results for each test case. >>> process_test_cases([(5, 3, [4, 7, 1, 3, 9]), (4, 1, [10, 1, 5, 6])]) [\\"YES\\", \\"NO\\"] >>> process_test_cases([(1, 1, [5]), (2, 10, [1, 11]), (2, 5, [1, 7])]) [\\"YES\\", \\"YES\\", \\"NO\\"] pass # implementation goes here import unittest class TestStudentQueue(unittest.TestCase): def test_can_be_happy_example(self): self.assertEqual(can_be_happy(5, 3, [4, 7, 1, 3, 9]), \\"YES\\") self.assertEqual(can_be_happy(4, 1, [10, 1, 5, 6]), \\"NO\\") def test_can_be_happy_edge_cases(self): self.assertEqual(can_be_happy(1, 1, [5]), \\"YES\\") self.assertEqual(can_be_happy(2, 10, [1, 11]), \\"YES\\") self.assertEqual(can_be_happy(2, 5, [1, 7]), \\"NO\\") def test_can_be_happy_large_k(self): self.assertEqual(can_be_happy(3, 1000, [1, 500, 999]), \\"YES\\") def test_process_test_cases(self): test_cases = [ (5, 3, [4, 7, 1, 3, 9]), (4, 1, [10, 1, 5, 6]), ] self.assertEqual(process_test_cases(test_cases), [\\"YES\\", \\"NO\\"]) test_cases = [ (1, 1, [5]), (2, 10, [1, 11]), (2, 5, [1, 7]), ] self.assertEqual(process_test_cases(test_cases), [\\"YES\\", \\"YES\\", \\"NO\\"])","solution":"def can_be_happy(n, k, heights): Determines if the students can be rearranged in such a way that the difference in height between any two adjacent students does not exceed k. Parameters: n (int): Number of students. k (int): Maximum allowed height difference between any two adjacent students. heights (list of int): List of heights of the students. Returns: str: \\"YES\\" if the students can be rearranged to satisfy the condition, otherwise \\"NO\\". heights.sort() for i in range(1, n): if heights[i] - heights[i-1] > k: return \\"NO\\" return \\"YES\\" def process_test_cases(test_cases): results = [] for n, k, heights in test_cases: results.append(can_be_happy(n, k, heights)) return results"},{"question":"def count_distinct_elements(matrix): Given a matrix, returns a list containing the number of distinct elements in each row of the matrix. Args: matrix (list): A list of lists where each inner list represents a row of the matrix. Returns: list: A list containing the number of distinct elements in each row. Examples: >>> count_distinct_elements([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [3, 3, 3] >>> count_distinct_elements([ ... [1, 1], ... [2, 2] ... ]) [1, 1] def process_test_cases(test_cases): Processes multiple test cases and returns the result for each test case. Args: test_cases (list): List of tuples, each containing the size of the matrix and the matrix itself. Returns: list: List of lists, where each list contains the number of distinct elements for each row of a test case. Examples: >>> process_test_cases([ ... (3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]), ... (2, [ ... [1, 1], ... [2, 2] ... ]) ... ]) [[3, 3, 3], [1, 1]]","solution":"def count_distinct_elements(matrix): Given a matrix, returns a list containing the number of distinct elements in each row of the matrix. distinct_counts = [] for row in matrix: distinct_counts.append(len(set(row))) return distinct_counts def process_test_cases(test_cases): Processes multiple test cases and returns the result for each test case. Args: test_cases (list): List of tuples, each containing the size of the matrix and the matrix itself. Returns: list: List of lists, where each list contains the number of distinct elements for each row of a test case. results = [] for n, matrix in test_cases: results.append(count_distinct_elements(matrix)) return results"},{"question":"def edit_distance(str1: str, str2: str) -> int: Implement a function to calculate the edit distance (Levenshtein distance) between two strings using dynamic programming. The edit distance is defined as the minimum number of operations required to transform one string into another. The allowed operations are: 1. Insertion of a character. 2. Deletion of a character. 3. Substitution of a character with another. Args: str1 (str): The first string. str2 (str): The second string. Returns: int: The edit distance between the two strings. Examples: >>> edit_distance(\\"kitten\\", \\"sitting\\") 3 >>> edit_distance(\\"flaw\\", \\"lawn\\") 2 >>> edit_distance(\\"giraffe\\", \\"giraffe\\") 0 >>> edit_distance(\\"abc\\", \\"yabd\\") 2 >>> edit_distance(\\"\\", \\"\\") 0 >>> edit_distance(\\"\\", \\"abc\\") 3 >>> edit_distance(\\"abc\\", \\"\\") 3 def test_edit_distance_same_strings(): assert edit_distance(\\"giraffe\\", \\"giraffe\\") == 0 def test_edit_distance_one_insertion(): assert edit_distance(\\"abc\\", \\"abcd\\") == 1 def test_edit_distance_one_deletion(): assert edit_distance(\\"abcd\\", \\"abc\\") == 1 def test_edit_distance_one_substitution(): assert edit_distance(\\"abc\\", \\"adc\\") == 1 def test_edit_distance_sample_1(): assert edit_distance(\\"kitten\\", \\"sitting\\") == 3 def test_edit_distance_sample_2(): assert edit_distance(\\"flaw\\", \\"lawn\\") == 2 def test_edit_distance_empty_strings(): assert edit_distance(\\"\\", \\"\\") == 0 def test_edit_distance_empty_and_non_empty_1(): assert edit_distance(\\"\\", \\"abc\\") == 3 def test_edit_distance_empty_and_non_empty_2(): assert edit_distance(\\"abc\\", \\"\\") == 3 def test_edit_distance_mixed_case(): assert edit_distance(\\"ABC\\", \\"abc\\") == 3 def test_edit_distance_complex_case(): assert edit_distance(\\"intention\\", \\"execution\\") == 5","solution":"def edit_distance(str1, str2): Calculates the Levenshtein distance between two strings. m, n = len(str1), len(str2) if m == 0: return n if n == 0: return m dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) return dp[m][n]"},{"question":"from typing import List def max_participants(participants: List[List[int]]) -> int: Determine the maximum number of participants that can review distinct books based on their interests. >>> max_participants([ [1, 2, 3], [2, 3], [3, 4], [4, 5] ]) 4 >>> max_participants([]) 0 >>> max_participants([ [1, 2, 3, 4, 5] ]) 1 >>> max_participants([ [1], [1], [1] ]) 1 >>> max_participants([ [1], [2], [3], [4], [5] ]) 5 >>> max_participants([ [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7] ]) 6 pass def test_example_case(): participants = [ [1, 2, 3], [2, 3], [3, 4], [4, 5] ] assert max_participants(participants) == 4 def test_no_participants(): participants = [] assert max_participants(participants) == 0 def test_single_participant_multiple_books(): participants = [ [1, 2, 3, 4, 5] ] assert max_participants(participants) == 1 def test_multiple_participants_single_book(): participants = [ [1], [1], [1] ] assert max_participants(participants) == 1 def test_all_participants_different_books(): participants = [ [1], [2], [3], [4], [5] ] assert max_participants(participants) == 5 def test_some_books_shared(): participants = [ [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7] ] assert max_participants(participants) == 6","solution":"def max_participants(participants): from collections import defaultdict def bpm(u, match_r, seen): for v in participant_books[u]: if not seen[v]: seen[v] = True if match_r[v] == -1 or bpm(match_r[v], match_r, seen): match_r[v] = u return True return False participant_books = defaultdict(list) for i, books in enumerate(participants): for book in books: participant_books[i].append(book) match_r = [-1] * 101 result = 0 for i in participant_books: seen = [False] * 101 if bpm(i, match_r, seen): result += 1 return result"},{"question":"def min_coins(n: int, x: int, coins: List[int]) -> int: Returns the minimum number of coins needed to achieve the sum x or -1 if it's not possible. Parameters: n (int): The number of coins x (int): The total sum of money to achieve coins (List[int]): The values of the coins Returns: int: The minimum number of coins needed or -1 if not possible Examples: >>> min_coins(3, 11, [1, 2, 5]) 3 >>> min_coins(4, 7, [2, 3, 6, 4]) 2 pass def test_min_coins(): # Test cases from the examples provided assert min_coins(3, 11, [1, 2, 5]) == 3 assert min_coins(4, 7, [2, 3, 6, 4]) == 2 # Additional test cases assert min_coins(1, 100, [1]) == 100 assert min_coins(3, 11, [5, 6, 1]) == 2 assert min_coins(5, 8, [1, 4, 6, 7, 8]) == 1 assert min_coins(2, 3, [2, 4]) == -1 assert min_coins(3, 0, [1, 2, 5]) == 0 assert min_coins(5, 10000, [1, 2, 5, 10, 20]) == 500 # Edge cases assert min_coins(1, 1, [1]) == 1 assert min_coins(5, 100, [100, 200, 300, 400, 500]) == 1 assert min_coins(3, 7, [2, 4, 6]) == -1","solution":"def min_coins(n, x, coins): Returns the minimum number of coins needed to achieve the sum x or -1 if it's not possible. # Initialize the dp array with a large number (greater than any possible number of coins) dp = [float('inf')] * (x + 1) # Base case: no coins are needed to make the sum 0 dp[0] = 0 # Loop through each coin and for each coin update the dp array for coin in coins: for j in range(coin, x + 1): dp[j] = min(dp[j], dp[j - coin] + 1) return dp[x] if dp[x] != float('inf') else -1"},{"question":"def move_zeros(nums: list) -> list: Moves all zeros in the list 'nums' to the end while maintaining the order of non-zero elements. This operation is done in-place. Args: nums (list of int): The input list of integers Returns: list of int: The modified list with zeros moved to the end. >>> move_zeros([0, 1, 0, 3, 12]) [1, 3, 12, 0, 0] >>> move_zeros([0, 0, 0, 0]) [0, 0, 0, 0] >>> move_zeros([1, 2, 3, 4]) [1, 2, 3, 4] >>> move_zeros([1, 0, 3, 0, 12]) [1, 3, 12, 0, 0] >>> move_zeros([1, 2, 3, 0, 0]) [1, 2, 3, 0, 0] >>> move_zeros([0, 1, 0, 2, 0, 3]) [1, 2, 3, 0, 0, 0]","solution":"def move_zeros(nums): Moves all zeros in the list 'nums' to the end while maintaining the order of non-zero elements. This operation is done in-place. Args: nums (list of int): The input list of integers Returns: list of int: The modified list with zeros moved to the end. last_non_zero_index = 0 for i in range(len(nums)): if nums[i] != 0: nums[last_non_zero_index] = nums[i] if last_non_zero_index != i: nums[i] = 0 last_non_zero_index += 1 return nums"},{"question":"def is_valid_phone_number(sequence): Determine if the sequence can be rearranged to form a valid phone number. sequence: list of strings, where each string is a single digit from \\"0\\" to \\"9\\" Returns True if the sequence is a valid phone number, False otherwise.","solution":"def is_valid_phone_number(sequence): Determine if the sequence can be rearranged to form a valid phone number. sequence: list of strings, where each string is a single digit from \\"0\\" to \\"9\\" Returns True if the sequence is a valid phone number, False otherwise. # A valid phone number in the village has: # 1. Exactly 6 digits # 2. All digits are unique # Since the problem guarantees that the length of the sequence is always 6, we only need to check for uniqueness # Convert the list to a set to automatically remove duplicates and then compare its length return len(set(sequence)) == 6"},{"question":"from typing import List def compressString(s: str) -> str: Compresses the string using the given algorithm, or returns the original if the compressed one is not shorter. >>> compressString(\\"aaabbcccc\\") 'a3b2c4' >>> compressString(\\"abcdef\\") 'abcdef' >>> compressString(\\"a\\") 'a' >>> compressString(\\"aabbcc\\") 'aabbcc' >>> compressString(\\"aaaabbbbcccc\\") 'a4b4c4' >>> compressString(\\"\\") '' >>> compressString(\\"aabbaa\\") 'aabbaa' def compressStrings(test_cases: List[str]) -> List[str]: Compress each string from the test cases. >>> compressStrings([\\"aaabbcccc\\", \\"abcdef\\", \\"a\\", \\"aabbcc\\", \\"aaaabbbbcccc\\", \\"\\", \\"aabbaa\\"]) ['a3b2c4', 'abcdef', 'a', 'aabbcc', 'a4b4c4', '', 'aabbaa'] from solution import compressString, compressStrings def test_compress_string(): assert compressString(\\"aaabbcccc\\") == \\"a3b2c4\\" assert compressString(\\"abcdef\\") == \\"abcdef\\" assert compressString(\\"a\\") == \\"a\\" assert compressString(\\"aabbcc\\") == \\"aabbcc\\" assert compressString(\\"aaaabbbbcccc\\") == \\"a4b4c4\\" assert compressString(\\"\\") == \\"\\" assert compressString(\\"aabbaa\\") == \\"aabbaa\\" def test_compress_strings(): assert compressStrings([\\"aaabbcccc\\", \\"abcdef\\", \\"a\\", \\"aabbcc\\", \\"aaaabbbbcccc\\", \\"\\", \\"aabbaa\\"]) == [ \\"a3b2c4\\", \\"abcdef\\", \\"a\\", \\"aabbcc\\", \\"a4b4c4\\", \\"\\", \\"aabbaa\\" ] def test_stress(): input_str = \\"a\\" * 1000 expected_output = \\"a1000\\" assert compressString(input_str) == expected_output long_unique_str = \\"\\".join(chr(i % 26 + 97) for i in range(1000)) assert compressString(long_unique_str) == long_unique_str","solution":"def compressString(s): Compresses the string using the given algorithm, or returns the original if the compressed one is not shorter. if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1]) compressed.append(str(count)) count = 1 compressed.append(s[-1]) compressed.append(str(count)) compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(s) else s def compressStrings(test_cases): Compress each string from the test cases. return [compressString(s) for s in test_cases]"},{"question":"def is_prime(n): Helper function to check if a number is prime. >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(17) True # Your code here pass def count_primes(arr): Returns the number of prime numbers in the array. >>> count_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) 4 >>> count_primes([2, 3, 5, 7, 11, 13, 17, 19, 23]) 9 >>> count_primes([1, 4, 6, 8, 10, 12]) 0 # Your code here pass","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def count_primes(arr): Returns the number of prime numbers in the array. Parameters: arr (list): list of positive integers Returns: int: number of prime numbers in the list return sum(1 for x in arr if is_prime(x))"},{"question":"def can_transform(N: int, test_cases: List[Tuple[int, str, str]]) -> List[str]: Determine if it is possible to transform one DNA sequence into another given a maximum number of allowed character changes. Args: N: int - the number of test cases. test_cases: List of tuples where each tuple contains: - an integer K (the maximum number of character changes allowed), - a string S1 (the first DNA sequence), - a string S2 (the second DNA sequence). Returns: List[str]: For each test case, return \\"POSSIBLE\\" if transformation is possible within the allowed changes, otherwise return \\"IMPOSSIBLE\\". >>> can_transform(4, [(1, \\"AGCT\\", \\"AGTT\\"), (2, \\"ACGTACGT\\", \\"TGCGTGCG\\"), (0, \\"GATTACA\\", \\"GACTTCA\\"), (3, \\"GGGG\\", \\"GTGT\\")]) ['POSSIBLE', 'IMPOSSIBLE', 'IMPOSSIBLE', 'POSSIBLE'] >>> can_transform(2, [(1, \\"ACTG\\", \\"ACTT\\"), (2, \\"AAAA\\", \\"AAAT\\")]) ['POSSIBLE', 'POSSIBLE'] >>> can_transform(3, [(0, \\"AAA\\", \\"AAA\\"), (0, \\"CGTA\\", \\"GCTA\\")]) ['POSSIBLE', 'IMPOSSIBLE']","solution":"def can_transform(N, test_cases): results = [] for k, s1, s2 in test_cases: # Count the number of differences between s1 and s2 diff_count = sum(1 for a, b in zip(s1, s2) if a != b) # Determine if the transformation is possible within the given number of changes if diff_count <= k: results.append(\\"POSSIBLE\\") else: results.append(\\"IMPOSSIBLE\\") return results"},{"question":"from collections import defaultdict, deque def find_treasure_locations(n: int, m: int, k: int, edges: List[Tuple[int, int]]) -> List[int]: Find all possible locations where treasures are hidden, starting from the initial location and following the clues. Parameters: n (int): Number of locations (nodes). m (int): Number of directed edges. k (int): Initial location. edges (list of tuples): List of directed edges (u, v). Returns: list: List of locations where treasures are hidden, sorted in increasing order. Examples: >>> find_treasure_locations(5, 4, 1, [(1, 2), (2, 3), (1, 4), (4, 5)]) [2, 3, 4, 5] >>> find_treasure_locations(7, 6, 3, [(3, 5), (5, 6), (6, 7), (2, 4), (4, 6), (4, 7)]) [5, 6, 7] pass # Unit tests def test_example1(): n = 5 m = 4 k = 1 edges = [(1, 2), (2, 3), (1, 4), (4, 5)] assert find_treasure_locations(n, m, k, edges) == [2, 3, 4, 5] def test_example2(): n = 7 m = 6 k = 3 edges = [(3, 5), (5, 6), (6, 7), (2, 4), (4, 6), (4, 7)] assert find_treasure_locations(n, m, k, edges) == [5, 6, 7] def test_single_node(): n = 1 m = 0 k = 1 edges = [] assert find_treasure_locations(n, m, k, edges) == [] def test_no_reachable_nodes(): n = 4 m = 2 k = 1 edges = [(2, 3), (3, 4)] assert find_treasure_locations(n, m, k, edges) == [] def test_all_nodes_connected(): n = 6 m = 6 k = 1 edges = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (1, 6)] assert find_treasure_locations(n, m, k, edges) == [2, 3, 4, 5, 6] def test_cycle_in_graph(): n = 5 m = 5 k = 1 edges = [(1, 2), (2, 3), (3, 4), (4, 2), (4, 5)] assert find_treasure_locations(n, m, k, edges) == [2, 3, 4, 5]","solution":"from collections import defaultdict, deque def find_treasure_locations(n, m, k, edges): Finds all treasure locations that can be reached from the initial location k. Parameters: n (int): Number of locations (nodes). m (int): Number of directed edges. k (int): Initial location. edges (list of tuples): List of directed edges (u, v). Returns: list: List of locations where treasures are hidden, sorted in increasing order. # Create an adjacency list from the edges graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Perform BFS to find all reachable nodes from the initial location visited = set() queue = deque([k]) treasures = set() while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) treasures.add(neighbor) queue.append(neighbor) return sorted(treasures) # Example usage n, m = 5, 4 k = 1 edges = [(1, 2), (2, 3), (1, 4), (4, 5)] print(find_treasure_locations(n, m, k, edges)) # Output: [2, 3, 4, 5]"},{"question":"def find_unique_element(arr, k): Finds the unique element in an array where every other element appears k times. Parameters: arr (list): List of integers where all elements except one appear k times k (int): The repetition factor Returns: int: The unique element that appears exactly once Example: >>> find_unique_element([2, 2, 3, 2, 4, 4, 4], 3) 3 >>> find_unique_element([9, 1, 9, 3, 9, 1, 7, 1, 7, 7], 3) 3 >>> find_unique_element([2, -1, 2, 2], 3) -1","solution":"def find_unique_element(arr, k): Finds the unique element in an array where every other element appears k times. Parameters: arr (list): List of integers where all elements except one appear k times k (int): The repetition factor Returns: int: The unique element that appears exactly once from collections import Counter count = Counter(arr) for num, freq in count.items(): if freq == 1: return num"},{"question":"def restore_ip_addresses(s: str) -> List[str]: Generate all possible valid IPv4 addresses from a given string of digits. An IPv4 address consists of four octets (numbers between 0 and 255), separated by periods. Given a string s of digits, restore it by returning all possible valid IPv4 addresses that can be formed by inserting periods into s. The output should be a list of strings, each representing a valid IPv4 address, sorted in lexicographical order. If no valid IP addresses can be formed, return an empty list. >>> restore_ip_addresses(\\"25525511135\\") [\\"255.255.11.135\\", \\"255.255.111.35\\"] >>> restore_ip_addresses(\\"0000\\") [\\"0.0.0.0\\"] >>> restore_ip_addresses(\\"1111\\") [\\"1.1.1.1\\"] >>> restore_ip_addresses(\\"010010\\") [\\"0.10.0.10\\", \\"0.100.1.0\\"] >>> restore_ip_addresses(\\"\\") [] >>> restore_ip_addresses(\\"1\\") [] >>> restore_ip_addresses(\\"111122223333\\") []","solution":"def is_valid_octet(octet): Check if the octet is a valid segment of an IP address if len(octet) == 0 or len(octet) > 3: return False if len(octet) > 1 and octet[0] == '0': return False if int(octet) > 255: return False return True def restore_ip_addresses(s): Generate all possible valid IPv4 addresses from the given string n = len(s) result = [] for i in range(1, min(4, n-2)): for j in range(i+1, min(i+4, n-1)): for k in range(j+1, min(j+4, n)): s1, s2, s3, s4 = s[:i], s[i:j], s[j:k], s[k:] if all(map(is_valid_octet, [s1, s2, s3, s4])): ip_address = f\\"{s1}.{s2}.{s3}.{s4}\\" result.append(ip_address) return sorted(result)"},{"question":"def calculate_levels(n: int, employee_manager_pairs: List[Tuple[int, int]]) -> Dict[int, int]: Calculate the level of each employee in the organizational hierarchy. Args: n (int): Number of employees. employee_manager_pairs (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers, the employee's ID and the manager's ID. Returns: Dict[int, int]: A dictionary where keys are employee IDs and values are their respective levels. Example: >>> calculate_levels(6, [(2, 1), (3, 1), (4, 2), (5, 2), (6, 3), (7, 3)]) {1: 1, 2: 2, 3: 2, 4: 3, 5: 3, 6: 3, 7: 3} >>> calculate_levels(4, [(2, 1), (3, 1), (4, 2), (5, 3)]) {1: 1, 2: 2, 3: 2, 4: 3, 5: 3} from typing import List, Tuple, Dict # Your code here","solution":"def calculate_levels(n, employee_manager_pairs): from collections import defaultdict, deque # prepare a mapping of employees to their managers manager_map = {} for emp, mgr in employee_manager_pairs: manager_map[emp] = mgr # Initialize levels with CEO being level 1 levels = {1: 1} queue = deque([1]) while queue: mgr = queue.popleft() current_level = levels[mgr] for emp, manager in manager_map.items(): if manager == mgr: levels[emp] = current_level + 1 queue.append(emp) return levels"},{"question":"from typing import List, Tuple def max_path_sum_in_tree(N: int, node_values: List[int], edges: List[Tuple[int, int, int]]) -> int: Find the maximum sum of node values on any path in the tree. >>> max_path_sum_in_tree(5, [4, 5, 6, 3, 2], [(1, 2, 3), (2, 3, 2), (3, 4, 4), (4, 5, 1)]) == 20 >>> max_path_sum_in_tree(3, [1, 2, 3], [(1, 2, 1), (1, 3, 2)]) == 6 pass from solution import max_path_sum_in_tree def test_example_1(): N = 5 node_values = [4, 5, 6, 3, 2] edges = [(1, 2, 3), (2, 3, 2), (3, 4, 4), (4, 5, 1)] assert max_path_sum_in_tree(N, node_values, edges) == 20 def test_example_2(): N = 3 node_values = [1, 2, 3] edges = [(1, 2, 1), (1, 3, 2)] assert max_path_sum_in_tree(N, node_values, edges) == 6 def test_single_node(): N = 1 node_values = [10] edges = [] assert max_path_sum_in_tree(N, node_values, edges) == 10 def test_chain_of_nodes(): N = 4 node_values = [1, 2, 3, 4] edges = [(1, 2, 1), (2, 3, 1), (3, 4, 1)] assert max_path_sum_in_tree(N, node_values, edges) == 10 def test_binary_tree(): N = 7 node_values = [1, 2, 3, 4, 5, 6, 7] edges = [(1, 2, 1), (1, 3, 1), (2, 4, 1), (2, 5, 1), (3, 6, 1), (3, 7, 1)] assert max_path_sum_in_tree(N, node_values, edges) == 28","solution":"from collections import defaultdict def dfs(node, parent, values, tree, max_path_sum): current_sum = values[node - 1] local_sum = values[node - 1] for neighbor, weight in tree[node]: if neighbor != parent: sum_from_neighbor = dfs(neighbor, node, values, tree, max_path_sum) if sum_from_neighbor > 0: local_sum += sum_from_neighbor max_path_sum[0] = max(max_path_sum[0], local_sum) return max(current_sum, local_sum) def max_path_sum_in_tree(N, node_values, edges): tree = defaultdict(list) for u, v, w in edges: tree[u].append((v, w)) tree[v].append((u, w)) max_path_sum = [-float('inf')] dfs(1, -1, node_values, tree, max_path_sum) return max_path_sum[0] def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) node_values = list(map(int, data[1:N+1])) edges = [] for i in range(N-1): u = int(data[N+1 + 3*i]) v = int(data[N+2 + 3*i]) w = int(data[N+3 + 3*i]) edges.append((u, v, w)) result = max_path_sum_in_tree(N, node_values, edges) print(result) if __name__ == \\"__main__\\": main()"},{"question":"class QueryProcessor: def __init__(self, nums): Initialize the QueryProcessor with a list of numbers. Args: nums (List[int]): The list of numbers. def increment_list(self, value): Increment all elements of the list by the given value. Args: value (int): The value to increment each element of the list by. def max_element(self): Return the maximum element from the list. Returns: int: The maximum element in the list. # Unit Tests def test_query_processor_increment_and_max(): # Test initial input nums = [3, 1, 4, 2] processor = QueryProcessor(nums) # Apply 'inc 2' query processor.increment_list(2) assert processor.max_element() == 6 # Apply 'inc 5' query processor.increment_list(5) assert processor.max_element() == 11 def test_query_processor_max_before_increment(): # Test initial input nums = [10, 20, 30, 40, 50] processor = QueryProcessor(nums) # Check max query assert processor.max_element() == 50 # Apply 'inc 10' query processor.increment_list(10) assert processor.max_element() == 60 def test_query_processor_multiple_increments(): # Test with multiple increments nums = [1, 2, 3, 4, 5] processor = QueryProcessor(nums) # Apply multiple increments processor.increment_list(1) processor.increment_list(3) processor.increment_list(5) assert processor.max_element() == 14 # Originally 5 + 9 def test_query_processor_large_values(): # Test large values and large increments nums = [100000, 500000, 1000000] processor = QueryProcessor(nums) # Apply large increments processor.increment_list(1000000) assert processor.max_element() == 2000000 # Originally 1000000 + 1000000 def test_query_processor_no_operation(): # Test with no operation nums = [7, 8, 9] processor = QueryProcessor(nums) assert processor.max_element() == 9","solution":"class QueryProcessor: def __init__(self, nums): self.nums = nums self.increment_base = 0 def increment_list(self, value): self.increment_base += value def max_element(self): return max(self.nums) + self.increment_base"},{"question":"def evenIndexedSum(lst): Returns the sum of all integers at even indices in the list. >>> evenIndexedSum([1, 2, 3, 4, 5]) 9 >>> evenIndexedSum([10, 20, 30, 40, 50, 60]) 90 >>> evenIndexedSum([10]) 10 >>> evenIndexedSum([]) 0 >>> evenIndexedSum([-1, -2, -3, -4, -5]) -9 >>> evenIndexedSum([1, -2, 3, -4, 5, -6]) 9 pass","solution":"def evenIndexedSum(lst): Returns the sum of all integers at even indices in the list. return sum(lst[i] for i in range(len(lst)) if i % 2 == 0)"},{"question":"def min_wizards_needed(n, spell_powers, m): Determines the minimum number of wizards required to achieve at least the minimum spell power. Parameters: n (int): Number of wizards. spell_powers (list of int): Spell power of each wizard. m (int): Minimum spell power required to defeat the dragon. Returns: int: Minimum number of wizards required to achieve the required spell power, or -1 if not possible. def test_min_wizards_needed_exact_match(): assert min_wizards_needed(5, [5, 8, 3, 7, 5], 15) == 2 def test_min_wizards_needed_not_possible(): assert min_wizards_needed(4, [2, 1, 8, 4], 20) == -1 def test_min_wizards_needed_minimum_spell_power_reached(): assert min_wizards_needed(6, [2, 4, 8, 6, 3, 1], 17) == 3 def test_min_wizards_needed_single_wizard_suffices(): assert min_wizards_needed(5, [15, 1, 2, 3, 4], 10) == 1 def test_min_wizards_needed_all_wizards_needed(): assert min_wizards_needed(3, [3, 3, 3], 9) == 3 def test_min_wizards_needed_multiple_possible_choices(): assert min_wizards_needed(5, [5, 5, 5, 5, 5], 10) == 2","solution":"def min_wizards_needed(n, spell_powers, m): Determines the minimum number of wizards required to achieve at least the minimum spell power. Parameters: n (int): Number of wizards. spell_powers (list of int): Spell power of each wizard. m (int): Minimum spell power required to defeat the dragon. Returns: int: Minimum number of wizards required to achieve the required spell power, or -1 if not possible. # Sort spell powers in descending order spell_powers.sort(reverse=True) # Sum powers until we reach the desired power level or we run out of wizards total_power = 0 count = 0 for power in spell_powers: total_power += power count += 1 if total_power >= m: return count return -1 # If we exhaust the list without reaching the required power"},{"question":"def can_build_road(m: int, n: int, grid: List[str]) -> str: Determine if a vertical road from the northernmost edge to the southernmost edge is possible. >>> can_build_road(3, 3, [ \\"...\\", \\".#.\\", \\".#.\\" ]) == \\"YES\\" >>> can_build_road(4, 4, [ \\"....\\", \\"..#.\\", \\"....\\", \\".#..\\" ]) == \\"YES\\" >>> can_build_road(3, 4, [ \\"\\", \\".#..\\", \\".#.#\\" ]) == \\"NO\\"","solution":"def can_build_road(m, n, grid): Determine if a vertical road from the northernmost edge to the southernmost edge is possible. for c in range(n): if grid[0][c] == '.': possible = True for r in range(1, m): if grid[r][c] == '#': possible = False break if possible: return \\"YES\\" return \\"NO\\""},{"question":"def min_substrings_to_form_t(s: str, t: str) -> int: Finds the minimum number of contiguous substrings of the main string s that can be concatenated to form the target string t. Returns -1 if it is impossible to form t. Examples: >>> min_substrings_to_form_t(\\"abcabcd\\", \\"abd\\") 2 >>> min_substrings_to_form_t(\\"abcd\\", \\"abcde\\") -1 pass from solution import min_substrings_to_form_t def test_min_substrings_simple_case(): assert min_substrings_to_form_t(\\"abcabcd\\", \\"abd\\") == 2 def test_min_substrings_no_solution(): assert min_substrings_to_form_t(\\"abcd\\", \\"abcde\\") == -1 def test_min_substrings_exact_match(): assert min_substrings_to_form_t(\\"abcabc\\", \\"abcabc\\") == 1 def test_min_substrings_single_character_match(): assert min_substrings_to_form_t(\\"abc\\", \\"a\\") == 1 assert min_substrings_to_form_t(\\"abc\\", \\"b\\") == 1 assert min_substrings_to_form_t(\\"abc\\", \\"c\\") == 1 def test_min_substrings_repeated_pattern(): assert min_substrings_to_form_t(\\"ababab\\", \\"abab\\") == 1 def test_min_substrings_no_overlap(): assert min_substrings_to_form_t(\\"abcde\\", \\"cdeab\\") == 2 def test_min_substrings_with_multiple_possibilities(): assert min_substrings_to_form_t(\\"abcdef\\", \\"cdefab\\") == 2 assert min_substrings_to_form_t(\\"abcdef\\", \\"efabcd\\") == 2","solution":"def min_substrings_to_form_t(s, t): Finds the minimum number of contiguous substrings of s that can be concatenated to form t. Returns -1 if it is impossible to form t. n, m = len(s), len(t) i, count = 0, 0 while i < m: found = False for j in range(n, 0, -1): if t[i:i + j] in s: i += j count += 1 found = True break if not found: return -1 return count"},{"question":"def max_compatible_pairs(threads, nuts, is_compatible): Determine the maximum number of compatible thread-nut pairs. Args: threads (list[int]): List of thread IDs. nuts (list[int]): List of nut IDs. is_compatible (function): A function that takes a thread ID and a nut ID and returns whether they are compatible. Returns: int: The maximum number of compatible pairs. Examples: >>> threads = [1, 2, 3] >>> nuts = [4, 5, 6] >>> def is_compatible(thread, nut): >>> compatibilities = {(1, 4): True, (2, 5): True, (3, 6): True, >>> (1, 5): False, (1, 6): False, (2, 4): False, >>> (2, 6): False, (3, 4): False, (3, 5): False} >>> return compatibilities.get((thread, nut), False) >>> max_compatible_pairs(threads, nuts, is_compatible) 3 >>> threads = [1, 2, 3, 4] >>> nuts = [2, 3, 5, 6] >>> def is_compatible(thread, nut): >>> compatibilities = {(1, 2): True, (2, 3): True, (3, 5): True, (4, 6): True, >>> (1, 3): False, (1, 5): False, (1, 6): False, (2, 5): False, >>> (2, 6): False, (3, 2): False, (3, 6): False, (4, 2): False, >>> (4, 3): False, (4, 5): False} >>> return compatibilities.get((thread, nut), False) >>> max_compatible_pairs(threads, nuts, is_compatible) 4 pass","solution":"def max_compatible_pairs(threads, nuts, is_compatible): Returns the maximum number of compatible pairs of threads and nuts. Args: threads (list[int]): List of thread IDs. nuts (list[int]): List of nut IDs. is_compatible (function): A function that takes a thread ID and a nut ID and returns whether they are compatible. Returns: int: The maximum number of compatible pairs. from collections import defaultdict # Create a bipartite graph using adjacency list representation graph = defaultdict(list) for thread in threads: for nut in nuts: if is_compatible(thread, nut): graph[thread].append(nut) def bpm(u, visited, match): for v in graph[u]: if not visited[v]: visited[v] = True if v not in match or bpm(match[v], visited, match): match[v] = u return True return False match = {} result = 0 for u in threads: visited = defaultdict(bool) if bpm(u, visited, match): result += 1 return result"},{"question":"def is_secure_string(s): Determines if the string is secure. A string is considered secure if it contains at least one vowel and one consonant. Parameters: s (str): The string to be checked. Returns: str: 'YES' if the string is secure, 'NO' otherwise. Examples: >>> is_secure_string('hello') == 'YES' >>> is_secure_string('world') == 'YES' >>> is_secure_string('abc') == 'YES' >>> is_secure_string('xyz') == 'NO' pass def check_secure_strings(t, strings): Checks multiple strings for security and returns the results. Parameters: t (int): The number of test cases. strings (list): List containing the strings to be checked. Returns: list: List of results for each string. Examples: >>> check_secure_strings(4, ['hello', 'world', 'abc', 'xyz']) == ['YES', 'YES', 'YES', 'NO'] >>> check_secure_strings(3, ['a', 'e', 'i']) == ['NO', 'NO', 'NO'] pass","solution":"def is_secure_string(s): Determines if the string is secure. A string is considered secure if it contains at least one vowel and one consonant. Parameters: s (str): The string to be checked. Returns: str: 'YES' if the string is secure, 'NO' otherwise. vowels = set('aeiou') has_vowel = False has_consonant = False for char in s: if char in vowels: has_vowel = True elif char.isalpha(): has_consonant = True if has_vowel and has_consonant: return 'YES' return 'NO' def check_secure_strings(t, strings): Checks multiple strings for security and returns the results. Parameters: t (int): The number of test cases. strings (list): List containing the strings to be checked. Returns: list: List of results for each string. results = [] for s in strings: results.append(is_secure_string(s)) return results"},{"question":"def can_rearrange_for_odd_sum(t: int, test_cases: list) -> list: Determine if it is possible to rearrange the elements of the array such that the sum of consecutive elements is always an odd number. Args: t (int): Number of test cases. test_cases (list): List of tuples where each tuple contains an integer \`n\` and a list of \`n\` integers. Returns: list: List of strings \\"YES\\" or \\"NO\\" for each test case. Example: >>> can_rearrange_for_odd_sum(2, [(3, [1, 3, 5]), (4, [2, 4, 6, 8])]) ['NO', 'YES']","solution":"def can_rearrange_for_odd_sum(t, test_cases): results = [] for i in range(t): n, a = test_cases[i] odd_count = sum(1 for num in a if num % 2 != 0) even_count = n - odd_count # To achieve odd sum between adjacent elements, we need both odds and evens. if odd_count > 0 and even_count > 0: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def max_accommodated_runners(t: int, test_cases: List[Tuple[int, List[int], List[int]]]) -> List[int]: Find the maximum number of runners that can be accommodated at their preferred checkpoints. Args: t: int - number of test cases test_cases: list of tuples each containing: m: int - number of runners preferences: list of int - preferred checkpoints for each runner capacities: list of int - capacity of each checkpoint Returns: list of int - the maximum number of runners that can be accommodated for each test case Examples: >>> max_accommodated_runners(3, [(5, [1, 2, 2, 3, 3], [2, 1, 2]), (4, [1, 2, 3, 3], [0, 1, 2]), (6, [1, 1, 2, 2, 3, 3], [1, 1, 1])]) [4, 3, 3] >>> max_accommodated_runners(2, [(6, [1, 1, 1, 2, 2, 2], [1, 2]), (5, [1, 1, 1, 1, 1], [3])]) [3, 3] # Example test cases def test_max_accommodated_runners(): test_cases = [ (5, [1, 2, 2, 3, 3], [2, 1, 2]), # 4 (4, [1, 2, 3, 3], [0, 1, 2]), # 3 (6, [1, 1, 2, 2, 3, 3], [1, 1, 1]) # 3 ] expected_results = [4, 3, 3] results = max_accommodated_runners(len(test_cases), test_cases) assert results == expected_results def test_max_accommodated_runners_more_cases(): test_cases = [ (6, [1, 1, 1, 2, 2, 2], [1, 2]), # 3 (5, [1, 1, 1, 1, 1], [3]), # 3 (5, [1, 2, 3, 4, 5], [1, 1, 1, 1, 1]) # 5 ] expected_results = [3, 3, 5] results = max_accommodated_runners(len(test_cases), test_cases) assert results == expected_results # Additional tests def test_max_accommodated_runners_edge_cases(): test_cases = [ (1, [1], [1]), # 1 (1, [1], [0]), # 0 (2, [1, 1], [0]), # 0 (2, [1, 1], [1]), # 1 (2, [1, 1], [2]) # 2 ] expected_results = [1, 0, 0, 1, 2] results = max_accommodated_runners(len(test_cases), test_cases) assert results == expected_results","solution":"def max_accommodated_runners(t, test_cases): results = [] for case in test_cases: m, preferences, capacities = case pref_count = [0] * (len(capacities)) for pref in preferences: pref_count[pref - 1] += 1 total_accommodated = 0 for i in range(len(capacities)): total_accommodated += min(pref_count[i], capacities[i]) results.append(total_accommodated) return results"},{"question":"def daily_temperatures(temperatures: List[int]) -> List[int]: Given a list of daily temperatures, returns a list of numbers representing the number of days you would have to wait until a warmer temperature. >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures([30, 40, 50, 60, 70, 60, 75, 73]) [1, 1, 1, 1, 2, 1, 0, 0] >>> daily_temperatures([5, 4, 3, 2, 1]) [0, 0, 0, 0, 0] >>> daily_temperatures([100, 100, 100]) [0, 0, 0]","solution":"def daily_temperatures(temperatures): n = len(temperatures) answer = [0] * n stack = [] for i, temp in enumerate(temperatures): while stack and temperatures[stack[-1]] < temp: idx = stack.pop() answer[idx] = i - idx stack.append(i) return answer"},{"question":"def missing_number(nums): Returns the missing number in the array nums which contains n distinct integers in the range [0, n]. >>> missing_number([3, 0, 1]) == 2 >>> missing_number([0, 1]) == 2 >>> missing_number([9, 6, 4, 2, 3, 5, 7, 0, 1]) == 8 >>> missing_number([0]) == 1","solution":"def missing_number(nums): Returns the missing number in the array nums which contains n distinct integers in the range [0, n]. n = len(nums) total_sum = n * (n + 1) / 2 actual_sum = sum(nums) return int(total_sum - actual_sum)"},{"question":"def minWindowSubseq(s: str, t: str) -> str: Given a string \`s\` and a set of characters \`t\`, determine the minimum window subsequence in the string \`s\` which contains all the characters in the set \`t\` at least once in any order. If no such window exists, return an empty string. If there are multiple minimum-length windows, return the one which appears first. >>> minWindowSubseq(\\"ADOBECODEBANC\\", \\"ABC\\") 'BANC' >>> minWindowSubseq(\\"a\\", \\"a\\") 'a' >>> minWindowSubseq(\\"a\\", \\"b\\") '' >>> minWindowSubseq(\\"aAaaaBbbC\\", \\"ABC\\") 'AaaaBbbC' >>> minWindowSubseq(\\"this is a test string\\", \\"tist\\") 't stri' Parameters: s (str): Input string containing lowercase and uppercase letters. t (str): Characters that need to be included in the window. Returns: str: The required minimum window subsequence.","solution":"def minWindowSubseq(s, t): Finds the minimum window subsequence in the string \`s\` which contains all characters in the string \`t\`. from collections import Counter if not s or not t: return \\"\\" required = Counter(t) window_counts = {} filtered_s = [(i, char) for i, char in enumerate(s) if char in required] l, r = 0, 0 formed = 0 min_len = float('inf') min_window = (None, None) while r < len(filtered_s): char = filtered_s[r][1] window_counts[char] = window_counts.get(char, 0) + 1 if window_counts[char] == required[char]: formed += 1 while l <= r and formed == len(required): start = filtered_s[l][0] end = filtered_s[r][0] if end - start + 1 < min_len: min_len = end - start + 1 min_window = (start, end) char = filtered_s[l][1] window_counts[char] -= 1 if window_counts[char] < required[char]: formed -= 1 l += 1 r += 1 if min_window[0] is None: return \\"\\" return s[min_window[0]:min_window[1] + 1]"},{"question":"def sort_students(student_list): Sort students based on descending order of their scores. If two students have the same score, they should be sorted by their names in ascending order alphabetically. Parameters: student_list (list): A list of tuples where each tuple contains a student's name and score. Returns: list: Sorted list of student tuples. pass # Your implementation here def main(input_list): Processes the input to sort students and print the results. Parameters: input_list (list): Input list containing number of students followed by student entries where each entry consists of a student's name and score. Returns: list: Sorted list of student strings. pass # Your implementation here # Example usage: input_data = [ '4', 'alice 90', 'bob 95', 'charlie 90', 'dave 85' ] print(main(input_data))","solution":"def sort_students(student_list): Sort students based on descending order of their scores. If two students have the same score, they should be sorted by their names in ascending order alphabetically. Parameters: student_list (list): A list of tuples where each tuple contains a student's name and score. Returns: list: Sorted list of student tuples. # Sorting by lambda that sorts primarily by score descending and secondarily by name ascending return sorted(student_list, key=lambda x: (-x[1], x[0])) def main(input_list): Processes the input to sort students and print the results. Parameters: input_list (list): Input list containing number of students followed by student entries where each entry consists of a student's name and score. Returns: list: Sorted list of student strings. N = int(input_list[0]) students = [tuple(input_list[i + 1].split(' ')) for i in range(N)] students = [(name, int(score)) for name, score in students] sorted_students = sort_students(students) result = [f\\"{name} {score}\\" for name, score in sorted_students] return result # Example usage: input_data = [ '4', 'alice 90', 'bob 95', 'charlie 90', 'dave 85' ] print(main(input_data))"},{"question":"def next_focus_index(n: int, statuses: List[int], current_index: int) -> int: Determines the next focused component index in a cyclic manner. :param n: int - the number of components :param statuses: list[int] - statuses of the components (1 for enabled, 0 for disabled) :param current_index: int - the current index to start traversal from :return: int - the index of the next enabled component >>> next_focus_index(6, [1, 0, 1, 0, 0, 1], 2) 5 >>> next_focus_index(5, [1, 1, 0, 1, 0], 4) 0 >>> next_focus_index(4, [0, 0, 1, 0], 2) 2","solution":"def next_focus_index(n, statuses, current_index): Determines the next focused component index in a cyclic manner. :param n: int - the number of components :param statuses: list[int] - statuses of the components (1 for enabled, 0 for disabled) :param current_index: int - the current index to start traversal from :return: int - the index of the next enabled component next_index = (current_index + 1) % n while next_index != current_index: if statuses[next_index] == 1: return next_index next_index = (next_index + 1) % n return current_index # This is just to satisfy function return type; logically will never reach here."},{"question":"def generate_hollow_diamond(n): Generates a hollow diamond pattern with n layers. The height and width of the diamond is 2*n-1. Parameters: - n (int): number of layers Returns: - str: formatted string of the hollow diamond pattern Example: >>> generate_hollow_diamond(3) ' * n * * n* *n * * n * ' >>> generate_hollow_diamond(4) ' * n * * n * * n* *n * * n * * n * ' def generate_multiple_hollow_diamonds(d, layers): Generates multiple hollow diamond patterns. Parameters: - d (int): number of datasets - layers (list of int): list containing the number of layers for each dataset Returns: - str: formatted string of hollow diamond patterns separated by blank lines Example: >>> generate_multiple_hollow_diamonds(2, [3, 4]) ' * n * * n* *n * * n * nn * n * * n * * n* *n * * n * * n * ' >>> generate_multiple_hollow_diamonds(1, [5]) ' * n * * n * * n * * n* *n * * n * * n * * n * ' >>> generate_multiple_hollow_diamonds(3, [1, 2, 3]) '*nn * n* *n * nn * n * * n* *n * * n * '","solution":"def generate_hollow_diamond(n): Generates a hollow diamond pattern with n layers. The height and width of the diamond is 2*n-1. pattern = [] size = 2 * n - 1 # Upper part of the diamond for i in range(n): row = \\"\\" for j in range(size): if j == n - i - 1 or j == n + i - 1: row += \\"*\\" else: row += \\" \\" pattern.append(row) # Lower part of the diamond for i in range(n - 2, -1, -1): pattern.append(pattern[i]) return \\"n\\".join(pattern) def generate_multiple_hollow_diamonds(d, layers): Generates multiple hollow diamond patterns. Parameters: - d (int): number of datasets - layers (list of int): list containing the number of layers for each dataset Returns: - str: formatted string of hollow diamond patterns separated by blank lines diamonds = [] for n in layers: diamonds.append(generate_hollow_diamond(n)) return \\"nn\\".join(diamonds)"},{"question":"def can_partition(arr: List[int]) -> str: Determine if it's possible to partition the array into two subsequences with equal sums. Arguments: arr : List[int] -- The list of integers to be partitioned Returns: str -- \\"YES\\" if the list can be partitioned into two subsequences with equal sum, \\"NO\\" otherwise >>> can_partition([3, 1, 1, 2, 2, 1]) \\"YES\\" >>> can_partition([1, 2, 3, 4, 5]) \\"NO\\"","solution":"def can_partition(arr): Determine if it's possible to partition the array into two subsequences with equal sums. total_sum = sum(arr) # If the total sum is odd, it's not possible to split into two equal parts if total_sum % 2 != 0: return \\"NO\\" target = total_sum // 2 n = len(arr) # Use dynamic programming to check if there's a subset with sum equal to target dp = [False] * (target + 1) dp[0] = True for num in arr: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return \\"YES\\" if dp[target] else \\"NO\\""},{"question":"class FenwickTree: def __init__(self, size): self.size = size self.tree = [0] * (size + 1) def update(self, index, delta): while index <= self.size: self.tree[index] += delta index += index & -index def query(self, index): sum = 0 while index > 0: sum += self.tree[index] index -= index & -index return sum class Solution: def __init__(self, arr): self.arr = arr self.n = len(arr) self.ft = FenwickTree(self.n) for i in range(1, self.n + 1): self.ft.update(i, arr[i - 1]) def update(self, i, x): diff = x - self.arr[i - 1] self.arr[i - 1] = x self.ft.update(i, diff) def range_sum(self, l, r): return self.ft.query(r) - self.ft.query(l - 1) def process_operations(N, Q, arr, operations): Process a series of operations on an array efficiently. There are two types of operation: 1. Update the value at a specific index to a new value. 2. Find the sum of elements in a given subarray. Parameters: N : int : number of elements in the array Q : int : number of operations arr: List[int] : the array of integers operations: List[Tuple] : list of operations (1-based indexing) Returns: List[int] : results of the sum operations >>> N = 5 >>> Q = 5 >>> arr = [1, 2, 3, 4, 5] >>> operations = [(2, 1, 3), (1, 2, 4), (2, 1, 3), (1, 5, 10), (2, 4, 5)] >>> process_operations(N, Q, arr, operations) [6, 7, 14] import pytest def test_solution(): N = 5 Q = 5 arr = [1, 2, 3, 4, 5] operations = [ (2, 1, 3), (1, 2, 4), (2, 1, 3), (1, 5, 10), (2, 4, 5) ] expected_output = [6, 7, 14] assert process_operations(N, Q, arr, operations) == expected_output def test_single_update(): N = 1 Q = 2 arr = [10] operations = [ (1, 1, 20), (2, 1, 1) ] expected_output = [20] assert process_operations(N, Q, arr, operations) == expected_output def test_multiple_sums(): N = 5 Q = 4 arr = [1, 2, 3, 4, 5] operations = [ (2, 1, 5), (2, 1, 1), (2, 5, 5), (2, 2, 4) ] expected_output = [15, 1, 5, 9] assert process_operations(N, Q, arr, operations) == expected_output def test_edge_case_updates(): N = 3 Q = 4 arr = [5, 5, 5] operations = [ (2, 1, 3), (1, 1, 10), (2, 1, 3), (1, 3, 15) ] expected_output = [15, 20] assert process_operations(N, Q, arr, operations) == expected_output if __name__ == \\"__main__\\": pytest.main()","solution":"class FenwickTree: def __init__(self, size): self.size = size self.tree = [0] * (size + 1) def update(self, index, delta): while index <= self.size: self.tree[index] += delta index += index & -index def query(self, index): sum = 0 while index > 0: sum += self.tree[index] index -= index & -index return sum class Solution: def __init__(self, arr): self.arr = arr self.n = len(arr) self.ft = FenwickTree(self.n) for i in range(1, self.n + 1): self.ft.update(i, arr[i - 1]) def update(self, i, x): diff = x - self.arr[i - 1] self.arr[i - 1] = x self.ft.update(i, diff) def range_sum(self, l, r): return self.ft.query(r) - self.ft.query(l - 1) def process_operations(N, Q, arr, operations): solution = Solution(arr) result = [] for op in operations: if op[0] == 1: _, i, x = op solution.update(i, x) elif op[0] == 2: _, l, r = op result.append(solution.range_sum(l, r)) return result"},{"question":"def find_best_performing_product(test_cases): Given a list of products with product ID, price and quantity sold, find the product with the highest revenue. If multiple products have the same revenue, return the product with the smallest ID. Args: test_cases: List[Dict] - A list of test cases, each test case is a dictionary which contains 'num_products' and 'products' list. Returns: List[int] - A list of product IDs with the highest revenue for each test case. Example: >>> test_cases = [ { 'num_products': 3, 'products': [ (101, 20, 30), (102, 15, 40), (103, 10, 50) ] } ] >>> find_best_performing_product(test_cases) [101]","solution":"def find_best_performing_product(test_cases): results = [] for case in test_cases: max_revenue = -1 best_product_id = float('inf') for product in case['products']: product_id, price, sold = product revenue = price * sold if revenue > max_revenue or (revenue == max_revenue and product_id < best_product_id): max_revenue = revenue best_product_id = product_id results.append(best_product_id) return results"},{"question":"def can_obtain_b_by_deleting_one_character(a: str, b: str) -> str: Determine if string B can be obtained by deleting exactly one character from string A. >>> can_obtain_b_by_deleting_one_character(\\"codes\\", \\"code\\") \\"YES\\" >>> can_obtain_b_by_deleting_one_character(\\"abcde\\", \\"abde\\") \\"YES\\" >>> can_obtain_b_by_deleting_one_character(\\"aabb\\", \\"aab\\") \\"YES\\" >>> can_obtain_b_by_deleting_one_character(\\"bar\\", \\"ar\\") \\"YES\\" >>> can_obtain_b_by_deleting_one_character(\\"foo\\", \\"fo\\") \\"YES\\" >>> can_obtain_b_by_deleting_one_character(\\"hello\\", \\"helloworld\\") \\"NO\\" >>> can_obtain_b_by_deleting_one_character(\\"abcd\\", \\"efg\\") \\"NO\\" >>> can_obtain_b_by_deleting_one_character(\\"aaaaa\\", \\"aaaa\\") \\"YES\\" >>> can_obtain_b_by_deleting_one_character(\\"ab\\", \\"bc\\") \\"NO\\" >>> can_obtain_b_by_deleting_one_character(\\"abcdf\\", \\"abdf\\") \\"YES\\"","solution":"def can_obtain_b_by_deleting_one_character(a, b): Determine if string B can be obtained by deleting exactly one character from string A if len(a) != len(b) + 1: return \\"NO\\" i = j = 0 found_difference = False while i < len(a) and j < len(b): if a[i] == b[j]: i += 1 j += 1 else: if found_difference: return \\"NO\\" found_difference = True i += 1 return \\"YES\\""},{"question":"def max_product_pair(N: int, A: List[int]) -> Tuple[int, int]: Given a list of N integers, find a pair of indices (i, j) such that 0 ≤ i < j < N and the product of the elements at those indices is maximum. If multiple such pairs exist, choose the pair with the smallest i. If there is still a tie, choose the pair with the smallest j among them. >>> max_product_pair(6, [1, 10, 3, 7, 9, 5]) (1, 4) >>> max_product_pair(5, [5, 5, 5, 5, 5]) (0, 1) >>> max_product_pair(3, [1000000, 999999, 999998]) (0, 1)","solution":"def max_product_pair(N, A): max_i = -1 max_j = -1 max_product = -1 for i in range(N): for j in range(i + 1, N): current_product = A[i] * A[j] if (current_product > max_product or (current_product == max_product and i < max_i) or (current_product == max_product and i == max_i and j < max_j)): max_product = current_product max_i = i max_j = j return max_i, max_j"},{"question":"def smallest_subarray_k_distinct(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Find the length of the smallest subarray that contains at least K distinct elements. >>> smallest_subarray_k_distinct(2, [((7, 3), [1, 2, 1, 3, 4, 2, 3]), ((5, 4), [1, 2, 1, 2, 1])]) [3, -1] >>> smallest_subarray_k_distinct(1, [((6, 2), [5, 1, 5, 7, 8, 5])]) [2]","solution":"def smallest_subarray_k_distinct(T, test_cases): results = [] for i in range(T): N, K = test_cases[i][0] C = test_cases[i][1] if len(set(C)) < K: results.append(-1) continue left = 0 right = 0 freq_map = {} distinct_count = 0 min_length = float('inf') while right < N: if C[right] in freq_map: if freq_map[C[right]] == 0: distinct_count += 1 freq_map[C[right]] += 1 else: freq_map[C[right]] = 1 distinct_count += 1 while distinct_count >= K: min_length = min(min_length, right - left + 1) if freq_map[C[left]] == 1: distinct_count -= 1 freq_map[C[left]] -= 1 left += 1 right += 1 results.append(min_length) return results"},{"question":"def max_possible_avg_after_removal(scores: List[int]) -> float: Given an array of scores, determine the maximum possible average score after removing exactly one element. >>> max_possible_avg_after_removal([70, 80, 90, 100]) 90.00 >>> max_possible_avg_after_removal([5, 9, 2]) 7.00","solution":"def max_possible_avg_after_removal(scores): M = len(scores) total_sum = sum(scores) max_avg = float('-inf') for score in scores: current_sum = total_sum - score current_avg = current_sum / (M - 1) if current_avg > max_avg: max_avg = current_avg return round(max_avg, 2)"},{"question":"from typing import List def is_unique_sequence(N: int, K: int, A: List[int]) -> str: Check whether the sequence of ingredients is unique for all possible contiguous subarrays of length K. Parameters: N (int): Length of the array A. K (int): Length of subarrays to check for unique elements. A (list of int): The array of ingredients. Returns: str: \\"UNIQUE\\" if all subarrays of length K have unique elements, \\"NOT UNIQUE\\" otherwise. >>> is_unique_sequence(5, 3, [1, 2, 3, 4, 5]) \\"UNIQUE\\" >>> is_unique_sequence(6, 3, [4, 1, 2, 3, 2, 1]) \\"NOT UNIQUE\\" def test_all_unique_within_k(): assert is_unique_sequence(5, 3, [1, 2, 3, 4, 5]) == \\"UNIQUE\\" assert is_unique_sequence(4, 2, [1, 2, 3, 4]) == \\"UNIQUE\\" def test_not_unique_appears(): assert is_unique_sequence(6, 3, [4, 1, 2, 3, 2, 1]) == \\"NOT UNIQUE\\" assert is_unique_sequence(5, 3, [1, 2, 3, 2, 1]) == \\"NOT UNIQUE\\" def test_unique_edge_cases(): assert is_unique_sequence(2, 2, [1, 2]) == \\"UNIQUE\\" assert is_unique_sequence(10, 1, [i for i in range(1, 11)]) == \\"UNIQUE\\" def test_not_unique_edge_cases(): assert is_unique_sequence(2, 2, [1, 1]) == \\"NOT UNIQUE\\" def test_single_repeating_element(): assert is_unique_sequence(5, 3, [1, 1, 1, 1, 1]) == \\"NOT UNIQUE\\" assert is_unique_sequence(6, 2, [1, 2, 2, 3, 4, 4]) == \\"NOT UNIQUE\\"","solution":"def is_unique_sequence(N, K, A): Returns \\"UNIQUE\\" if all contiguous subarrays of length K have unique elements. Otherwise, returns \\"NOT UNIQUE\\". Parameters: N (int): Length of the array A. K (int): Length of subarrays to check for unique elements. A (list of int): The array of ingredients. Returns: str: \\"UNIQUE\\" if all subarrays of length K have unique elements, \\"NOT UNIQUE\\" otherwise. from collections import defaultdict if K == 1: return \\"UNIQUE\\" seen = defaultdict(int) for i in range(K): seen[A[i]] += 1 if seen[A[i]] > 1: return \\"NOT UNIQUE\\" for i in range(K, N): seen[A[i]] += 1 seen[A[i - K]] -= 1 if seen[A[i]] > 1: return \\"NOT UNIQUE\\" return \\"UNIQUE\\""},{"question":"def days_with_more_weight(test_cases): Identify the days on which Chef lifts more weight than the previous day. Args: test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains an integer N (number of days) and a list of integers representing the weights lifted each day. Returns: List[str]: A list of strings where each string contains space-separated integers representing the days Chef lifted more weight than the previous day. If no such days exist, return \\"NONE\\". Example: >>> test_cases = [(6, [10, 20, 15, 25, 30, 18]), (5, [5, 5, 5, 5, 5]), (4, [2, 4, 6, 8])] >>> days_with_more_weight(test_cases) ['2 4 5', 'NONE', '2 3 4'] pass def parse_input(input_str): Parse the input string into a list of test cases. Args: input_str (str): The input string containing the number of test cases, followed by the number of days and the weights lifted each day. Returns: List[Tuple[int, List[int]]]: A list of tuples where each tuple contains an integer N (number of days) and a list of integers representing the weights lifted each day. Example: >>> input_str = \\"3n6n10 20 15 25 30 18n5n5 5 5 5 5n4n2 4 6 8\\" >>> parse_input(input_str) [(6, [10, 20, 15, 25, 30, 18]), (5, [5, 5, 5, 5, 5]), (4, [2, 4, 6, 8])] pass","solution":"def days_with_more_weight(test_cases): result = [] for case in test_cases: N, weights = case days = [] for i in range(1, N): if weights[i] > weights[i-1]: days.append(i + 1) if not days: result.append(\\"NONE\\") else: result.append(\\" \\".join(map(str, days))) return result def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(lines[index]) weights = list(map(int, lines[index + 1].split())) test_cases.append((N, weights)) index += 2 return test_cases"},{"question":"def sum_of_squares_of_digits(n: int) -> int: Calculate the sum of squares of digits of a given number. # Your code here def is_sequence_ending_in_1(k: int) -> bool: Determine if the sequence starting with k ends in 1. # Your code here def process_test_cases(test_cases: List[int]) -> List[str]: Process a list of test cases and return results indicating if each sequence ends in 1. # Your code here # Example Usage test_cases = [19, 2, 7] print(process_test_cases(test_cases)) # Output: [\\"YES\\", \\"NO\\", \\"YES\\"] # Unit Tests def test_is_sequence_ending_in_1(): assert is_sequence_ending_in_1(19) == True assert is_sequence_ending_in_1(2) == False assert is_sequence_ending_in_1(7) == True assert is_sequence_ending_in_1(1) == True assert is_sequence_ending_in_1(10) == True # 10 -> 1 def test_process_test_cases(): test_cases = [19, 2, 7] assert process_test_cases(test_cases) == [\\"YES\\", \\"NO\\", \\"YES\\"] test_cases = [1, 100, 90] assert process_test_cases(test_cases) == [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def sum_of_squares_of_digits(n): Function to calculate the sum of squares of digits of a given number. return sum(int(digit) ** 2 for digit in str(n)) def is_sequence_ending_in_1(k): Determines if the sequence starting with k ends in 1. seen_numbers = set() while k != 1 and k not in seen_numbers: seen_numbers.add(k) k = sum_of_squares_of_digits(k) return k == 1 def process_test_cases(test_cases): Processes a list of test cases and returns results indicating if each sequence ends in 1. return [\\"YES\\" if is_sequence_ending_in_1(k) else \\"NO\\" for k in test_cases]"},{"question":"def determine_role(n: int, records: List[Tuple[str, str, str]]) -> List[str]: Determine if an employee is a manager or a non-managerial employee based on their work email. >>> determine_role(3, [ ... (\\"john doe\\", \\"john.doe@manager.sales.company.com\\", \\"sales\\"), ... (\\"jane smith\\", \\"jane.smith@it.company.com\\", \\"it\\"), ... (\\"peter parker\\", \\"peter.parker@manager.hr.company.com\\", \\"hr\\") ... ]) [\\"Manager\\", \\"Employee\\", \\"Manager\\"] >>> determine_role(2, [ ... (\\"alice wonderland\\", \\"alice.wonderland@rene.company.com\\", \\"rene\\"), ... (\\"bob builder\\", \\"bob.builder@manager.eng.company.com\\", \\"eng\\") ... ]) [\\"Employee\\", \\"Manager\\"] results = [] for record in records: name, email, department = record if 'manager.' + department + '.company.com' in email: results.append(\\"Manager\\") else: results.append(\\"Employee\\") return results from typing import List, Tuple def test_determine_role(): assert determine_role(3, [ (\\"john doe\\", \\"john.doe@manager.sales.company.com\\", \\"sales\\"), (\\"jane smith\\", \\"jane.smith@it.company.com\\", \\"it\\"), (\\"peter parker\\", \\"peter.parker@manager.hr.company.com\\", \\"hr\\") ]) == [\\"Manager\\", \\"Employee\\", \\"Manager\\"] assert determine_role(2, [ (\\"alice wonderland\\", \\"alice.wonderland@rene.company.com\\", \\"rene\\"), (\\"bob builder\\", \\"bob.builder@manager.eng.company.com\\", \\"eng\\") ]) == [\\"Employee\\", \\"Manager\\"] assert determine_role(1, [ (\\"charlie brown\\", \\"charlie.brown@manager.marketing.company.com\\", \\"marketing\\") ]) == [\\"Manager\\"] assert determine_role(2, [ (\\"diana prince\\", \\"diana.prince@sales.company.com\\", \\"sales\\"), (\\"bruce wayne\\", \\"bruce.wayne@manager.operations.company.com\\", \\"operations\\") ]) == [\\"Employee\\", \\"Manager\\"] assert determine_role(3, [ (\\"clark kent\\", \\"clark.kent@manager.hr.company.com\\", \\"hr\\"), (\\"lois lane\\", \\"lois.lane@hr.company.com\\", \\"hr\\"), (\\"jimmy olsen\\", \\"jimmy.olsen@manager.it.company.com\\", \\"it\\") ]) == [\\"Manager\\", \\"Employee\\", \\"Manager\\"]","solution":"def determine_role(n, records): results = [] for record in records: name, email, department = record if 'manager.' + department + '.company.com' in email: results.append(\\"Manager\\") else: results.append(\\"Employee\\") return results"},{"question":"def count_unique_codes(n: int, codes: List[str]) -> int: Returns the number of unique numeric codes in the manuscript. Parameters: n (int): The number of lines in the manuscript. codes (list): A list of strings, each representing a numeric code. Returns: int: The number of unique numeric codes. >>> count_unique_codes(5, [\\"1234\\", \\"4321\\", \\"1234\\", \\"5678\\", \\"1234\\"]) 3 >>> count_unique_codes(4, [\\"1111\\", \\"2222\\", \\"3333\\", \\"4444\\"]) 4 >>> count_unique_codes(3, [\\"5555\\", \\"5555\\", \\"5555\\"]) 1 >>> count_unique_codes(7, [\\"123\\", \\"456\\", \\"123\\", \\"789\\", \\"456\\", \\"789\\", \\"101112\\"]) 4 >>> count_unique_codes(1, [\\"9090\\"]) 1","solution":"def count_unique_codes(n, codes): Returns the number of unique numeric codes in the manuscript. Parameters: n (int): The number of lines in the manuscript. codes (list): A list of strings, each representing a numeric code. Returns: int: The number of unique numeric codes. return len(set(codes))"},{"question":"from typing import List def minimumWalkingPathLength(n: int, paths: List[List[int]]) -> int: Find the minimum total length of the walking paths required to connect all attractions. Parameters: n (int): the number of attractions paths (List[List[int]]): each path contains three integers [u, v, l] where u and v are attractions connected by a walking path and l is the length of the path Returns: int: the minimum total length of walking paths required to connect all attractions >>> minimumWalkingPathLength(4, [[1, 2, 1], [1, 3, 4], [2, 3, 2], [3, 4, 3]]) 6 >>> minimumWalkingPathLength(1, []) 0 >>> minimumWalkingPathLength(3, [[1, 2, 4]]) 4 >>> minimumWalkingPathLength(4, [[1, 2, 1], [1, 3, 1], [2, 3, 1], [3, 4, 1]]) 3 >>> minimumWalkingPathLength(5, [[1, 2, 1], [1, 3, 1], [1, 4, 1], [1, 5, 1], [2, 3, 2], [3, 4, 2], [4, 5, 2]]) 4","solution":"def minimumWalkingPathLength(n, paths): Returns the minimum total length of the walking paths required to make all attractions accessible. Parameters: n (int): the number of attractions paths (List[List[int]]): each path contains three integers [u, v, l] where u and v are attractions connected by a walking path and l is the length of the path Returns: int: the minimum total length of walking paths required to connect all attractions # Using Kruskal's Algorithm to find the Minimum Spanning Tree (MST) # Define a helper function to find the root of an attraction def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) # Define a helper function to perform the union of two sets def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 # Initialize parent and rank arrays to handle the union-find operations parent = [] rank = [] # Initially, each attraction is its own parent (i.e., self-rooted) for node in range(n): parent.append(node) rank.append(0) # Sort all the paths in increasing order of their length paths = sorted(paths, key=lambda item: item[2]) mst_length = 0 # Initialize the length of the MST edge_count = 0 # Number of edges in the MST i = 0 # Index variable, used for sorted edges # Number of edges in the MST which will be (n - 1) for a connected graph with n nodes while edge_count < n - 1 and i < len(paths): u, v, l = paths[i] i = i + 1 x = find(parent, u - 1) y = find(parent, v - 1) # If including this edge does not cause a cycle, include it in the MST if x != y: edge_count = edge_count + 1 mst_length = mst_length + l union(parent, rank, x, y) return mst_length"},{"question":"def can_form_palindrome(s): Determines if any permutation of the string can be a palindrome. Arguments: s -- A string consisting of lowercase English letters Returns: \\"YES\\" if any permutation of the string can be a palindrome, \\"NO\\" otherwise pass def can_form_palindrome_multiple_cases(t, cases): Determines for multiple test cases if any permutation of each string can be a palindrome. Arguments: t -- Number of test cases cases -- List of strings Returns: A list of \\"YES\\" or \\"NO\\" for each test case pass # Unit Tests import pytest def test_can_form_palindrome(): assert can_form_palindrome(\\"aabb\\") == \\"YES\\" assert can_form_palindrome(\\"abc\\") == \\"NO\\" assert can_form_palindrome(\\"racecar\\") == \\"YES\\" assert can_form_palindrome(\\"a\\") == \\"YES\\" assert can_form_palindrome(\\"ab\\") == \\"NO\\" assert can_form_palindrome(\\"aaabbbb\\") == \\"YES\\" assert can_form_palindrome(\\"civic\\") == \\"YES\\" assert can_form_palindrome(\\"ivicc\\") == \\"YES\\" assert can_form_palindrome(\\"hello\\") == \\"NO\\" assert can_form_palindrome(\\"abcba\\") == \\"YES\\" def test_can_form_palindrome_multiple_cases(): assert can_form_palindrome_multiple_cases(3, [\\"aabb\\", \\"abc\\", \\"racecar\\"]) == [\\"YES\\", \\"NO\\", \\"YES\\"] assert can_form_palindrome_multiple_cases(2, [\\"a\\", \\"ab\\"]) == [\\"YES\\", \\"NO\\"] assert can_form_palindrome_multiple_cases(5, [\\"aabb\\", \\"a\\", \\"aa\\", \\"aba\\", \\"baba\\"]) == [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def can_form_palindrome(s): Determines if any permutation of the string can be a palindrome. Arguments: s -- A string consisting of lowercase English letters Returns: \\"YES\\" if any permutation of the string can be a palindrome, \\"NO\\" otherwise from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return \\"YES\\" if odd_count <= 1 else \\"NO\\" def can_form_palindrome_multiple_cases(t, cases): Determines for multiple test cases if any permutation of each string can be a palindrome. Arguments: t -- Number of test cases cases -- List of strings Returns: A list of \\"YES\\" or \\"NO\\" for each test case return [can_form_palindrome(case) for case in cases]"},{"question":"def rotate_matrix(matrix): Rotates a given 2D matrix 90 degrees clockwise. This function modifies the matrix in place. # Unit tests def test_rotate_matrix_square(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) expected = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert matrix == expected def test_rotate_matrix_rectangle(): matrix = [ [1, 2], [3, 4], [5, 6] ] rotate_matrix(matrix) expected = [ [5, 3, 1], [6, 4, 2] ] assert matrix == expected def test_rotate_matrix_single_row(): matrix = [[1, 2, 3]] rotate_matrix(matrix) expected = [ [1], [2], [3] ] assert matrix == expected def test_rotate_matrix_single_column(): matrix = [ [1], [2], [3] ] rotate_matrix(matrix) expected = [[3, 2, 1]] assert matrix == expected def test_rotate_matrix_one_element(): matrix = [[1]] rotate_matrix(matrix) expected = [[1]] assert matrix == expected","solution":"def rotate_matrix(matrix): Rotates a given 2D matrix 90 degrees clockwise. This function modifies the matrix in place. # Get dimensions rows, cols = len(matrix), len(matrix[0]) # Create a new matrix to hold the rotation of the original matrix rotated_matrix = [[0] * rows for _ in range(cols)] for r in range(rows): for c in range(cols): rotated_matrix[c][rows - 1 - r] = matrix[r][c] # Copy the rotated matrix back to the original matrix matrix.clear() matrix.extend(rotated_matrix)"},{"question":"def is_beautiful(s: str) -> bool: Determines if a given string is beautiful. :param s: string to check :return: Boolean value indicating whether string is beautiful >>> is_beautiful(\\"abcdefg\\") True >>> is_beautiful(\\"aabbcc\\") False >>> is_beautiful(\\"abababa\\") True >>> is_beautiful(\\"a\\") True >>> is_beautiful(\\"aa\\") False >>> is_beautiful(\\"ab\\") True pass def process_test_cases(N: int, test_cases: List[str]) -> List[str]: Processes multiple test cases to determine if each string is beautiful. :param N: number of test cases :param test_cases: list of strings representing test cases :return: list of results for each test case (either \\"YES\\" or \\"NO\\") >>> process_test_cases(4, [\\"abcdefg\\", \\"aabbcc\\", \\"abababa\\", \\"a\\"]) ['YES', 'NO', 'YES', 'YES'] >>> process_test_cases(3, [\\"a\\", \\"aa\\", \\"aab\\"]) ['YES', 'NO', 'NO'] >>> process_test_cases(2, [\\"abcd\\", \\"abca\\"]) ['YES', 'YES'] >>> process_test_cases(1, [\\"zzz\\"]) ['NO'] >>> process_test_cases(1, [\\"abcabcabc\\"]) ['YES'] pass","solution":"def is_beautiful(s): Determines if a given string is beautiful. :param s: string to check :return: Boolean value indicating whether string is beautiful for i in range(1, len(s)): if s[i] == s[i-1]: return False return True def process_test_cases(N, test_cases): Processes multiple test cases to determine if each string is beautiful. :param N: number of test cases :param test_cases: list of strings representing test cases :return: list of results for each test case (either \\"YES\\" or \\"NO\\") results = [] for s in test_cases: if is_beautiful(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def max_palindromic_length(S: str) -> int: Determine the maximum length of a palindromic substring that can be obtained by performing any number of swaps between any two distinct characters in the string S. Args: S (str): A string consisting of only lowercase English letters. Returns: int: The maximum length of a palindromic substring. Example: >>> max_palindromic_length(\\"abccba\\") 6 >>> max_palindromic_length(\\"aabbccdd\\") 8 pass def process_test_cases(T: int, test_cases: List[Tuple[int, str]]) -> List[int]: Process multiple test cases to determine the maximum length of a palindromic substring for each string provided. Args: T (int): The number of test cases. test_cases (list): A list of tuples where each tuple contains an integer N and a string S. Returns: list: A list of integers representing the maximum length of a palindromic substring for each case. Example: >>> process_test_cases(2, [(7, \\"abccba\\"), (8, \\"aabbccdd\\")]) [6, 8] pass from solution import max_palindromic_length, process_test_cases def test_example_cases(): test_cases = [ (7, \\"abccba\\"), (8, \\"aabbccdd\\") ] expected = [6, 8] assert process_test_cases(2, test_cases) == expected def test_single_character(): test_cases = [ (1, \\"a\\"), (1, \\"z\\") ] expected = [1, 1] assert process_test_cases(2, test_cases) == expected def test_all_unique_characters(): test_cases = [ (5, \\"abcde\\") ] expected = [1] assert process_test_cases(1, test_cases) == expected def test_all_same_characters(): test_cases = [ (4, \\"aaaa\\"), (6, \\"cccccc\\"), (3, \\"bbb\\") ] expected = [4, 6, 3] assert process_test_cases(3, test_cases) == expected def test_mixed_characters(): test_cases = [ (5, \\"aabcd\\"), (6, \\"aaabb\\"), (7, \\"aabbccc\\") ] expected = [3, 5, 7] assert process_test_cases(3, test_cases) == expected","solution":"def max_palindromic_length(S): Given a string S, determine the maximum length of a palindromic substring that can be obtained by performing any number of swaps between any two distinct characters. from collections import Counter freq = Counter(S) odd_count = sum(1 for count in freq.values() if count % 2 == 1) # All characters can be rearranged such that there is at most one odd character return len(S) - odd_count + (1 if odd_count > 0 else 0) def process_test_cases(T, test_cases): results = [] for N, S in test_cases: results.append(max_palindromic_length(S)) return results"},{"question":"def is_substring_palindrome(s: str, queries: List[Tuple[int, int]]) -> List[str]: Determines if the substrings of \`s\` specified by \`queries\` are palindromes. Each query is a pair (l, r) representing the start and end indices of the substring. Parameters: s (str): The input string. queries (list of tuples): A list of (l, r) index pairs. Returns: list of str: \\"yes\\" if the substring s[l:r+1] is a palindrome, otherwise \\"no\\". # Examples >>> is_substring_palindrome(\\"abacaba\\", [(0, 6), (1, 4), (2, 2)]) [\\"yes\\", \\"no\\", \\"yes\\"] >>> is_substring_palindrome(\\"abcdef\\", [(1, 3), (2, 5)]) [\\"no\\", \\"no\\"]","solution":"def is_substring_palindrome(s, queries): Determines if the substrings of \`s\` specified by \`queries\` are palindromes. Each query is a pair (l, r) representing the start and end indices of the substring. Parameters: s (str): The input string. queries (list of tuples): A list of (l, r) index pairs. Returns: list of str: \\"yes\\" if the substring s[l:r+1] is a palindrome, otherwise \\"no\\". results = [] for l, r in queries: substring = s[l:r+1] if substring == substring[::-1]: results.append(\\"yes\\") else: results.append(\\"no\\") return results # Example usage: # s = \\"abacaba\\" # queries = [(0, 6), (1, 4), (2, 2)] # print(is_substring_palindrome(s, queries)) # Output should be [\\"yes\\", \\"no\\", \\"yes\\"]"},{"question":"def rotate(nums: List[int], k: int) -> None: Rotates the elements of a given array 'nums' to the right by 'k' steps. The rotation should be done in-place, and no extra array should be used. >>> nums = [1, 2, 3, 4, 5, 6, 7] >>> rotate(nums, 3) >>> nums [5, 6, 7, 1, 2, 3, 4] >>> nums = [-1, -100, 3, 99] >>> rotate(nums, 2) >>> nums [3, 99, -1, -100] >>> nums = [1, 2, 3, 4] >>> rotate(nums, 0) >>> nums [1, 2, 3, 4] >>> nums = [1, 2, 3, 4] >>> rotate(nums, 4) >>> nums [1, 2, 3, 4] >>> nums = [1, 2, 3, 4] >>> rotate(nums, 6) >>> nums [3, 4, 1, 2] >>> nums = [1] >>> rotate(nums, 3) >>> nums [1] >>> nums = [1, 2] >>> rotate(nums, 1) >>> nums [2, 1]","solution":"def rotate(nums, k): Rotates the elements of the list 'nums' to the right by 'k' steps. This is performed in-place. n = len(nums) k = k % n # In case k is greater than the length of the array nums[:] = nums[-k:] + nums[:-k]"},{"question":"def reverse_words(s: str) -> str: This function takes a string containing a mix of words and digits, and returns the string with all the words reversed while keeping the digits in their original positions. The words and digits are separated by spaces. >>> reverse_words(\\"hello 123 world 456\\") 'olleh 123 dlrow 456' >>> reverse_words(\\"code 34 along 78 developers\\") 'edoc 34 gnola 78 srepoleved'","solution":"def reverse_words(s): This function takes a string containing a mix of words and digits, and returns the string with all the words reversed while keeping the digits in their original positions. The words and digits are separated by spaces. parts = s.split() reversed_parts = [part[::-1] if part.isalpha() else part for part in parts] return ' '.join(reversed_parts)"},{"question":"from typing import List, Tuple def can_transform(s1: str, s2: str) -> bool: Determines if s1 can be transformed into s2 by swapping any two adjacent characters any number of times. >>> can_transform(\\"abcd\\", \\"cbad\\") True >>> can_transform(\\"xyzy\\", \\"yyzx\\") True >>> can_transform(\\"aaa\\", \\"aaa\\") True >>> can_transform(\\"aab\\", \\"bba\\") False pass def process_test_cases(T: int, test_cases: List[Tuple[str, str]]) -> List[str]: Process multiple test cases and determine if s1 can be transformed into s2 for each case. >>> process_test_cases(3, [(\\"abcd\\", \\"cbad\\"), (\\"xyzy\\", \\"yyzx\\"), (\\"aaa\\", \\"aaa\\")]) [\\"Yes\\", \\"Yes\\", \\"Yes\\"] >>> process_test_cases(2, [(\\"abc\\", \\"cba\\"), (\\"aab\\", \\"bba\\")]) [\\"Yes\\", \\"No\\"] pass","solution":"def can_transform(s1, s2): Determines if s1 can be transformed into s2 by swapping any two adjacent characters any number of times. return sorted(s1) == sorted(s2) def process_test_cases(T, test_cases): results = [] for i in range(T): s1, s2 = test_cases[i] if can_transform(s1, s2): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def check_tic_tac_toe(board): Determines the status of a Tic-Tac-Toe game based on the given board. :param board: A list of three strings, each of length 3, representing the board. :return: A string indicating the game status: \\"X wins\\", \\"O wins\\", \\"Draw\\", or \\"Game continues\\". def tic_tac_toe_status(test_cases): Processes multiple Tic-Tac-Toe test cases and returns the results. :param test_cases: A list of test cases where each test case is a list of three strings. :return: A list of strings corresponding to the result of each test case. from solution import check_tic_tac_toe, tic_tac_toe_status def test_check_tic_tac_toe_x_wins(): board = [\\"XOX\\", \\"OOX\\", \\"XOX\\"] assert check_tic_tac_toe(board) == \\"X wins\\" def test_check_tic_tac_toe_o_wins(): board = [\\"OOO\\", \\"X.X\\", \\"XXO\\"] assert check_tic_tac_toe(board) == \\"O wins\\" def test_check_tic_tac_toe_draw(): board = [\\"XOX\\", \\"OOX\\", \\"OXO\\"] assert check_tic_tac_toe(board) == \\"Draw\\" def test_check_tic_tac_toe_game_continues(): board = [\\"..X\\", \\"OX.\\", \\"...\\"] assert check_tic_tac_toe(board) == \\"Game continues\\" def test_tic_tac_toe_status(): test_cases = [ [\\"XOX\\", \\"OOX\\", \\"XOX\\"], [\\"OOO\\", \\"X.X\\", \\"XXO\\"], [\\"..X\\", \\"OX.\\", \\"...\\"] ] expected = [\\"X wins\\", \\"O wins\\", \\"Game continues\\"] assert tic_tac_toe_status(test_cases) == expected test_cases = [ [\\"XOX\\", \\"OOX\\", \\"OXO\\"], [\\"XO.\\", \\".OX\\", \\"OXX\\"], [\\"XO.\\", \\".O.\\", \\"XX.\\"] ] expected = [\\"Draw\\", \\"Game continues\\", \\"Game continues\\"] assert tic_tac_toe_status(test_cases) == expected","solution":"def check_tic_tac_toe(board): Determines the status of a Tic-Tac-Toe game based on the given board. :param board: A list of three strings, each of length 3, representing the board. :return: A string indicating the game status: \\"X wins\\", \\"O wins\\", \\"Draw\\", or \\"Game continues\\". lines = board + [ # Rows ''.join([board[0][i], board[1][i], board[2][i]]) for i in range(3) # Columns ] + [ ''.join([board[i][i] for i in range(3)]), # Main diagonal ''.join([board[i][2-i] for i in range(3)]) # Anti-diagonal ] if 'XXX' in lines: return \\"X wins\\" if 'OOO' in lines: return \\"O wins\\" if all(cell != '.' for row in board for cell in row): return \\"Draw\\" return \\"Game continues\\" def tic_tac_toe_status(test_cases): Processes multiple Tic-Tac-Toe test cases and returns the results. :param test_cases: A list of test cases where each test case is a list of three strings. :return: A list of strings corresponding to the result of each test case. results = [] for board in test_cases: results.append(check_tic_tac_toe(board)) return results"},{"question":"def validate_document_codes(codes): This function takes a list of document codes and returns a list of strings with \\"VALID\\" or \\"INVALID\\" indicating if each code meets the specified criteria. >>> validate_document_codes([\\"A1B2C3D4E5\\", \\"1234567890\\"]) [\\"VALID\\", \\"INVALID\\"] >>> validate_document_codes([\\"ABCDEFGHIJ\\", \\"A1B2C3D4E5\\"]) [\\"INVALID\\", \\"VALID\\"]","solution":"def validate_document_codes(codes): This function takes a list of document codes and returns a list of strings with \\"VALID\\" or \\"INVALID\\" indicating if each code meets the specified criteria. results = [] for code in codes: if (len(code) >= 10 and any(c.isupper() for c in code) and any(c.isdigit() for c in code) and not any(c.islower() for c in code) and ' ' not in code): results.append(\\"VALID\\") else: results.append(\\"INVALID\\") return results"},{"question":"def total_contributions(test_cases): Calculate the total amount collected from distinct contributors for each test case. >>> test_cases = [(5, [20, 50, 20, 30, 50]), (4, [10, 10, 10, 20])] >>> total_contributions(test_cases) [100, 30] def parse_input(input_str): Parse the input string into a list of test cases. >>> input_str = \\"2n5n20 50 20 30 50n4n10 10 10 20\\" >>> parse_input(input_str) [(5, [20, 50, 20, 30, 50]), (4, [10, 10, 10, 20])] def test_total_contributions(): input_data = \\"2n5n20 50 20 30 50n4n10 10 10 20\\" test_cases = parse_input(input_data) result = total_contributions(test_cases) assert result == [100, 30] def test_total_contributions_single_contribution_each():: input_data = \\"2n3n1 2 3n3n4 5 6\\" test_cases = parse_input(input_data) result = total_contributions(test_cases) assert result == [6, 15] def test_total_contributions_all_same_contributions(): input_data = \\"1n5n10 10 10 10 10\\" test_cases = parse_input(input_data) result = total_contributions(test_cases) assert result == [10] def test_total_contributions_mixed_contributions(): input_data = \\"1n6n11 22 33 44 33 22\\" test_cases = parse_input(input_data) result = total_contributions(test_cases) assert result == [110] def test_total_contributions_large_numbers(): input_data = \\"1n4n10000 9999 9998 9997\\" test_cases = parse_input(input_data) result = total_contributions(test_cases) assert result == [39994]","solution":"def total_contributions(test_cases): results = [] for n, contributions in test_cases: unique_contributions = set(contributions) results.append(sum(unique_contributions)) return results def parse_input(input_str): lines = input_str.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): n = int(lines[index]) contributions = list(map(int, lines[index + 1].split())) test_cases.append((n, contributions)) index += 2 return test_cases"},{"question":"def encode(s: str) -> str: Encodes the string \`s\` into a custom format where each character's 1-based position in the alphabet is separated by hyphens. >>> encode(\\"apple\\") '1-16-16-12-5' >>> encode(\\"hello\\") '8-5-12-12-15' pass def decode(s: str) -> str: Decodes the string \`s\` from the custom format back to the original string. >>> decode(\\"1-16-16-12-5\\") 'apple' >>> decode(\\"8-5-12-12-15\\") 'hello' pass # Test cases def test_encode_simple(): assert encode(\\"apple\\") == \\"1-16-16-12-5\\" assert encode(\\"hello\\") == \\"8-5-12-12-15\\" assert encode(\\"z\\") == \\"26\\" assert encode(\\"a\\") == \\"1\\" def test_decode_simple(): assert decode(\\"1-16-16-12-5\\") == \\"apple\\" assert decode(\\"8-5-12-12-15\\") == \\"hello\\" assert decode(\\"26\\") == \\"z\\" assert decode(\\"1\\") == \\"a\\" def test_encode_with_common_word(): assert encode(\\"banana\\") == \\"2-1-14-1-14-1\\" def test_decode_with_common_word(): assert decode(\\"2-1-14-1-14-1\\") == \\"banana\\" def test_encode_and_decode(): test_strings = [\\"apple\\", \\"hello\\", \\"banana\\", \\"z\\", \\"a\\"] for s in test_strings: encoded = encode(s) decoded = decode(encoded) assert s == decoded def test_large_string(): large_string = \\"a\\" * 1000 encoded = encode(large_string) expected_encoded = \\"1\\" + \\"-1\\" * 999 assert encoded == expected_encoded decoded = decode(encoded) assert decoded == large_string","solution":"def encode(s: str) -> str: Encodes the string \`s\` into a custom format where each character's 1-based position in the alphabet is separated by hyphens. return '-'.join(str(ord(char) - ord('a') + 1) for char in s) def decode(s: str) -> str: Decodes the string \`s\` from the custom format back to the original string. return ''.join(chr(int(num) + ord('a') - 1) for num in s.split('-'))"},{"question":"def calculate_final_altitude(S: str) -> int: Calculate the final altitude of the climber after taking all the steps in string S. A determined climber is starting their hike at the base of a mountain where the altitude is 0. The climber can take either an \\"U\\" step, which increases their altitude by 1, or a \\"D\\" step, which decreases their altitude by 1. The sequence of steps the climber takes is represented by a string S. >>> calculate_final_altitude(\\"UUDDU\\") 1 >>> calculate_final_altitude(\\"DDDD\\") -4 >>> calculate_final_altitude(\\"UDUDUD\\") 0 >>> calculate_final_altitude(\\"\\") 0","solution":"def calculate_final_altitude(S): Calculate the final altitude of the climber after taking all the steps in string S. Parameters: S (str): A string representing the sequence of steps, where 'U' means up and 'D' means down. Returns: int: The final altitude. altitude = 0 for step in S: if step == 'U': altitude += 1 elif step == 'D': altitude -= 1 return altitude"},{"question":"def find_min_max_indices(N: int, permutation: List[int]) -> Tuple[int, int]: Returns the 1-based indices of the smallest and largest elements in the permutation. >>> find_min_max_indices(5, [4, 2, 3, 1, 5]) (4, 5) >>> find_min_max_indices(7, [3, 1, 2, 7, 5, 4, 6]) (2, 4)","solution":"def find_min_max_indices(N, permutation): Returns the 1-based indices of the smallest and largest elements in the permutation. min_index = permutation.index(min(permutation)) + 1 max_index = permutation.index(max(permutation)) + 1 return min_index, max_index # Example usage N = 5 permutation = [4, 2, 3, 1, 5] print(find_min_max_indices(N, permutation)) # Output: (4, 5)"},{"question":"def alternate_sort(s: str) -> str: Design a function that takes a string representing a list of space-separated integers and sorts the list in alternating ascending and descending order starting with ascending order. For example, given the input \`3 1 2 5 4\`, the function should return the string \`1 4 2 5 3\`. The function should handle input where: - Each integer is in the range of -100 to 100. - The input string contains at least one integer. - The sequence is implemented as space-separated integers. The solution should have a time complexity of O(n log n). Ensure the function returns the resulting list as a space-separated string. >>> alternate_sort(\\"3 1 2 5 4\\") '1 5 2 4 3' >>> alternate_sort(\\"42\\") '42' >>> alternate_sort(\\"1 2\\") '1 2' >>> alternate_sort(\\"2 1\\") '1 2' >>> alternate_sort(\\"2 2 2\\") '2 2 2' >>> alternate_sort(\\"0 -1 5 100 -100\\") '-100 100 -1 5 0' >>> alternate_sort(\\"-1 -3 -2\\") '-3 -1 -2' >>> alternate_sort(\\"30 20 10 -10 -20 -30\\") '-30 30 -20 20 -10 10'","solution":"def alternate_sort(s): Returns a list of space-separated integers sorted in alternating ascending and descending order starting with ascending order. # Convert string to list of integers numbers = list(map(int, s.split())) # Sort the numbers numbers.sort() # Initialize two pointers at the start and end of the sorted list start, end = 0, len(numbers) - 1 result = [] # Alternate appending the smallest and largest elements from the sorted list while start <= end: if start <= end: result.append(numbers[start]) start += 1 if start <= end: result.append(numbers[end]) end -= 1 # Convert the result list back to a space-separated string return ' '.join(map(str, result))"},{"question":"def max_difference_subarray(arr): Returns the difference between the maximum element and the minimum element in the subarray with the largest difference. >>> max_difference_subarray([1, 2, 3, 4, 5]) 4 >>> max_difference_subarray([4, 9, 2, 10, 7, 5, 6, 3]) 8 >>> max_difference_subarray([4, 4, 4, 4]) 0","solution":"def max_difference_subarray(arr): Returns the difference between the maximum element and the minimum element in the subarray with the largest difference. max_elem = max(arr) min_elem = min(arr) return max_elem - min_elem"},{"question":"def fromRoman(roman: str) -> int: Converts a given Roman numeral string to its integer equivalent. Consider only valid Roman numerals which are strings composed of the following characters: I, V, X, L, C, D, and M. The string will always be a valid Roman numeral within the range from 1 to 3999. Example: >>> fromRoman(\\"III\\") 3 >>> fromRoman(\\"IV\\") 4 >>> fromRoman(\\"IX\\") 9 >>> fromRoman(\\"LVIII\\") 58 >>> fromRoman(\\"MCMXCIV\\") 1994","solution":"def fromRoman(roman): Converts a Roman numeral string to its integer equivalent. roman_to_int = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } result = 0 # To store the final integer result previous_value = 0 # To keep track of the value of the previous Roman numeral for char in reversed(roman): current_value = roman_to_int[char] if current_value < previous_value: result -= current_value # Subtract if a smaller value precedes a larger value else: result += current_value # Otherwise, add the value previous_value = current_value return result"},{"question":"def findClosestTemperature(temperatures, target): Return the temperature closest to the target. If there are two temperatures equally close, return the lower one. Parameters: temperatures (List[int]): List of daily temperatures for a week in degrees Celsius. target (int): The target temperature. Returns: int: The temperature closest to the target. Example: >>> findClosestTemperature([25, 28, 31, 22, 26, 27, 29], 24) 25 >>> findClosestTemperature([15, 20, 35, 10, 25, 30, 27], 28) 27","solution":"def findClosestTemperature(temperatures, target): Return the temperature closest to the target. If there are two temperatures equally close, return the lower one. closest_temp = temperatures[0] min_diff = abs(target - closest_temp) for temp in temperatures[1:]: current_diff = abs(target - temp) if current_diff < min_diff or (current_diff == min_diff and temp < closest_temp): min_diff = current_diff closest_temp = temp return closest_temp"},{"question":"def check_ingredients(T: int, test_cases: List[Dict[str, Dict[str, int]]]) -> List[str]: Check if Chef has enough ingredients for his recipes. Parameters: - T: int, the number of test cases - test_cases: List of dictionaries containing available and required ingredients for each test case Returns: - List of strings where each string is either 'ENOUGH' or 'NEED' followed by the list of ingredients with required quantities. Example: >>> check_ingredients(2, [ ... {'available': {'sugar': 200, 'flour': 500, 'butter': 100}, 'required': {'sugar': 150, 'flour': 550}}, ... {'available': {'eggs': 5, 'milk': 300}, 'required': {'eggs': 6, 'milk': 250, 'sugar': 50}} ... ]) [\\"NEED\\", \\"flour 50\\", \\"NEED\\", \\"eggs 1\\", \\"sugar 50\\"]","solution":"def check_ingredients(T, test_cases): results = [] for test in test_cases: available = test['available'] required = test['required'] needs_additional = False needs = [] for ingredient, quantity in required.items(): if ingredient not in available or available[ingredient] < quantity: needs_additional = True if ingredient not in available: needs.append((ingredient, quantity)) else: needs.append((ingredient, quantity - available[ingredient])) if needs_additional: results.append(\\"NEED\\") for need in needs: results.append(f\\"{need[0]} {need[1]}\\") else: results.append(\\"ENOUGH\\") return results"},{"question":"def minCostToAvoidConsecutiveRepeats(s: str, cost: List[int]) -> int: Given a string \`s\` containing lowercase alphabets and an integer array \`cost\` of the same length, return the minimum cost required to delete characters such that no two consecutive characters in \`s\` are the same. Parameters: s (str): the input string containing lowercase alphabets. cost (List[int]): the cost of deleting each character in the string \`s\`. Returns: int: the minimum cost required to achieve the condition. Example: >>> minCostToAvoidConsecutiveRepeats(\\"abccbd\\", [0, 1, 2, 3, 4, 5]) 2 >>> minCostToAvoidConsecutiveRepeats(\\"aabaa\\", [1, 2, 3, 4, 1]) 2","solution":"def minCostToAvoidConsecutiveRepeats(s, cost): Returns the minimum cost required to delete characters in the string s to avoid consecutive repeating characters. Parameters: s (str): the input string containing lowercase alphabets. cost (List[int]): the cost of deleting each character in the string s. Returns: int: the minimum cost required. total_cost = 0 n = len(s) for i in range(1, n): if s[i] == s[i-1]: if cost[i] < cost[i-1]: total_cost += cost[i] cost[i] = cost[i-1] else: total_cost += cost[i-1] return total_cost"},{"question":"def factorial(n): Calculate the factorial of a given integer n. >>> factorial(0) == 1 >>> factorial(1) == 1 >>> factorial(4) == 24 >>> factorial(5) == 120 >>> factorial(10) == 3628800 >>> factorial(12) == 479001600","solution":"def factorial(n): Returns the factorial of a given integer n. if n == 0: return 1 result = 1 for i in range(1, n + 1): result *= i return result"},{"question":"from typing import List def can_form_palindrome(s: str) -> str: Determine if a given string s can be rearranged into a palindrome. Parameters: s (str): The input string. Returns: str: \\"YES\\" if the string can be rearranged into a palindrome, \\"NO\\" otherwise. >>> can_form_palindrome('civic') 'YES' >>> can_form_palindrome('ivicc') 'YES' >>> can_form_palindrome('hello') 'NO' >>> can_form_palindrome('abcdeedcba') 'YES' pass def solve_palindrome_cases(test_cases: List[str]) -> List[str]: Solve multiple test cases checking the possibility of rearranging strings into palindromes. Parameters: test_cases (list): A list of strings to be checked. Returns: list: A list of results with \\"YES\\" or \\"NO\\" for each test case. >>> solve_palindrome_cases(['civic', 'ivicc', 'hello', 'abcdeedcba']) ['YES', 'YES', 'NO', 'YES'] >>> solve_palindrome_cases(['aa', 'ba', 'abab', 'bbaa', 'abcabc']) ['YES', 'NO', 'YES', 'YES', 'YES'] pass","solution":"def can_form_palindrome(s): Determine if a given string s can be rearranged into a palindrome. Parameters: s (str): The input string. Returns: str: \\"YES\\" if the string can be rearranged into a palindrome, \\"NO\\" otherwise. from collections import Counter count = Counter(s) odd_count = sum(1 for char in count if count[char] % 2 != 0) return \\"YES\\" if odd_count <= 1 else \\"NO\\" def solve_palindrome_cases(test_cases): Solve multiple test cases checking the possibility of rearranging strings into palindromes. Parameters: test_cases (list): A list of strings to be checked. Returns: list: A list of results with \\"YES\\" or \\"NO\\" for each test case. results = [] for s in test_cases: results.append(can_form_palindrome(s)) return results"},{"question":"from typing import List, Tuple from collections import Counter def longest_common_anagram(word1: str, word2: str) -> str: Find the longest common anagram that can be formed using letters from both words. If no common anagram can be formed, return \\"No anagram\\". >>> longest_common_anagram(\\"listen\\", \\"silent\\") 'eilnst' >>> longest_common_anagram(\\"hello\\", \\"world\\") 'lo' >>> longest_common_anagram(\\"abc\\", \\"def\\") 'No anagram' def process_test_cases(T: int, test_cases: List[Tuple[str, str]]) -> List[str]: Process multiple test cases and find the longest common anagram for each case. >>> process_test_cases(2, [(\\"listen\\", \\"silent\\"), (\\"hello\\", \\"world\\")]) ['eilnst', 'lo'] >>> process_test_cases(3, [(\\"abc\\", \\"def\\"), (\\"abcd\\", \\"bcde\\"), (\\"aabbcc\\", \\"bccdde\\")]) ['No anagram', 'bcd', 'bcc']","solution":"from collections import Counter def longest_common_anagram(word1, word2): # Count the frequency of each character in both words counter1 = Counter(word1) counter2 = Counter(word2) # Find the intersection of both counters (common letters) common_letters = counter1 & counter2 # Get all letters in lexicographical order result = ''.join(sorted([char * count for char, count in common_letters.items()])) if result: return result else: return \\"No anagram\\" def process_test_cases(T, test_cases): results = [] for word1, word2 in test_cases: results.append(longest_common_anagram(word1, word2)) return results"},{"question":"def morseToEnglish(morse: str) -> str: Translate the given string from Morse code to English. >>> morseToEnglish(\\"... --- ...\\") \\"SOS\\" >>> morseToEnglish(\\"... --- ... .-..\\") \\"SOSL\\" >>> morseToEnglish(\\"... ---\\") \\"SO\\" >>> morseToEnglish(\\".... . .-.. .-.. --- .-- --- .-. .-.. -..\\") \\"HELLOWORLD\\" >>> morseToEnglish(\\".\\") \\"E\\" >>> morseToEnglish(\\"-\\") \\"T\\"","solution":"def morseToEnglish(morse): morse_dict = { '.-': 'A', '-...': 'B', '-.-.': 'C', '-..': 'D', '.': 'E', '..-.': 'F', '--.': 'G', '....': 'H', '..': 'I', '.---': 'J', '-.-': 'K', '.-..': 'L', '--': 'M', '-.': 'N', '---': 'O', '.--.': 'P', '--.-': 'Q', '.-.': 'R', '...': 'S', '-': 'T', '..-': 'U', '...-': 'V', '.--': 'W', '-..-': 'X', '-.--': 'Y', '--..': 'Z' } words = morse.split(' ') # Separate different words by three spaces english_translation = [] for word in words: letters = word.split(' ') translated_word = ''.join(morse_dict[letter] for letter in letters) english_translation.append(translated_word) return ''.join(english_translation)"},{"question":"def final_crystal_size(s0: int, n: int, clouds: List[int], cloud_sizes: List[int]) -> int: Given the initial size of the crystal and the series of events (whether a cloud passes or not at each time unit), determine the final size of the crystal after all events have passed. Parameters: s0 (int): Initial size of the crystal n (int): Number of time units clouds (List[int]): List indicating whether a cloud passes (1) or not (0) at each time unit cloud_sizes (List[int]): List representing the size of the cloud at each time unit Returns: int: Final size of the crystal Example: >>> final_crystal_size(3, 4, [0, 1, 0, 1], [2, 1, 0, 2]) 42 >>> final_crystal_size(10, 3, [1, 0, 1], [5, 0, 4]) 56 pass","solution":"def final_crystal_size(s0, n, clouds, cloud_sizes): for i in range(n): s0 *= 2 # Crystal absorbs light energy equal to its current size if clouds[i] == 1: s0 -= cloud_sizes[i] # Cloud passes, reducing crystal size if s0 < 0: s0 = 0 # Crystal size cannot drop below zero return s0 # Return the final size of the crystal"},{"question":"def min_operations_to_equal_elements(arr): Given an array of integers, this function calculates the minimum number of increments or decrements needed to make all elements equal. >>> min_operations_to_equal_elements([1, 2, 3]) 2 >>> min_operations_to_equal_elements([5, 5, 5, 5]) 0 >>> min_operations_to_equal_elements([-1, 1]) 2 def process_test_cases(T, test_cases): Given the number of test cases and a list of test cases with each test case containing an integer N and an array of N integers. This function returns an array containing the minimum number of operations required for each test case to make all elements of the array equal. >>> process_test_cases(3, [(3, [1, 2, 3]), (4, [5, 5, 5, 5]), (2, [-1, 1])]) [2, 0, 2] >>> process_test_cases(3, [(1, [10]), (2, [2, 4]), (2, [-2, -4])]) [0, 2, 2]","solution":"def min_operations_to_equal_elements(arr): Given an array of integers, this function calculates the minimum number of increments or decrements needed to make all elements equal. median = sorted(arr)[len(arr) // 2] # optimal element value to minimize operations return sum(abs(x - median) for x in arr) def process_test_cases(T, test_cases): results = [] for i in range(T): N, arr = test_cases[i] results.append(min_operations_to_equal_elements(arr)) return results"},{"question":"def maxRectangleArea(heights: List[int]) -> int: Given a list of integers heights representing the heights of blocks in a row, determine the maximum area of a rectangle that can be formed using consecutive blocks. >>> maxRectangleArea([2, 1, 5, 6, 2, 3]) == 10 >>> maxRectangleArea([2, 4]) == 4 >>> maxRectangleArea([6, 7, 5, 2, 4, 5, 9, 3]) == 16 >>> maxRectangleArea([]) == 0","solution":"def maxRectangleArea(heights): Returns the maximum area of a rectangle that can be formed using consecutive blocks. Uses a stack-based approach to achieve O(n) time complexity. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def calculate_circumference(radius): Calculate the circumference of a circular flower bed given its radius. The formula to calculate the circumference of a circle is C = 2 * π * r, where C is the circumference and r is the radius. Use the value of π as 3.14159. :param radius: Radius of the flower bed in meters :type radius: float :return: Circumference of the flower bed rounded to two decimal places :rtype: float >>> calculate_circumference(5) 31.42 >>> calculate_circumference(10.5) 65.97 from solution import calculate_circumference def test_calculate_circumference_simple(): assert calculate_circumference(5) == 31.42 def test_calculate_circumference_decimal(): assert calculate_circumference(10.5) == 65.97 def test_calculate_circumference_small_value(): assert calculate_circumference(0.1) == 0.63 def test_calculate_circumference_large_value(): assert calculate_circumference(1000) == 6283.18 def test_calculate_circumference_negative_value(): try: calculate_circumference(-5) except ValueError as e: assert str(e) == \\"The radius must be a positive number\\" def test_calculate_circumference_zero_value(): try: calculate_circumference(0) except ValueError as e: assert str(e) == \\"The radius must be a positive number\\"","solution":"def calculate_circumference(radius): Returns the circumference of a circle with the given radius, rounded to two decimal places. :param radius: Radius of the circle (flower bed) in meters :type radius: float :return: Circumference of the circle rounded to two decimal places :rtype: float if radius <= 0: raise ValueError(\\"The radius must be a positive number\\") pi = 3.14159 circumference = 2 * pi * radius return round(circumference, 2)"},{"question":"def process_transactions(n: int, transactions: List[Tuple[str, int]]) -> Dict[str, int]: Process a list of transactions and returns the resulting inventory. Args: n : int : Number of transactions transactions : list of tuples : Each tuple contains (item_id, quantity_change) Returns: dict : A dictionary with item_id as keys and their resulting quantities as values >>> process_transactions(5, [(\\"apple\\", 10), (\\"banana\\", 5), (\\"apple\\", -3), (\\"banana\\", -5), (\\"orange\\", 7)]) == {\\"apple\\": 7, \\"orange\\": 7} >>> process_transactions(3, [(\\"book\\", 4), (\\"pen\\", -2), (\\"notebook\\", 5)]) == {\\"book\\": 4, \\"pen\\": -2, \\"notebook\\": 5} >>> process_transactions(7, [(\\"item1\\", 100), (\\"item2\\", 200), (\\"item1\\", -50), (\\"item2\\", -200), (\\"item3\\", 0), (\\"item4\\", 1000), (\\"item1\\", -50)]) == {\\"item4\\": 1000} >>> process_transactions(0, []) == {} >>> process_transactions(2, [(\\"item1\\", 1), (\\"item1\\", -1)]) == {} >>> process_transactions(3, [(\\"item1\\", 0), (\\"item2\\", 0), (\\"item3\\", 0)]) == {} >>> process_transactions(3, [(\\"item1\\", 10), (\\"item1\\", -5), (\\"item1\\", -5)]) == {} pass","solution":"def process_transactions(n, transactions): Process a list of transactions and returns the resulting inventory. Args: n : int : Number of transactions transactions : list of tuples : Each tuple contains (item_id, quantity_change) Returns: dict : A dictionary with item_id as keys and their resulting quantities as values inventory = {} order = [] for item_id, quantity_change in transactions: if item_id not in inventory: inventory[item_id] = 0 order.append(item_id) inventory[item_id] += quantity_change # Remove items with zero quantity inventory = {item_id: quantity for item_id, quantity in inventory.items() if quantity != 0} result = {item_id: inventory[item_id] for item_id in order if item_id in inventory} return result"},{"question":"def find_first_geq_index(A, Q): For each query in Q, find the index of the first element in A that is greater than or equal to the query. Returns a list of results, where each result corresponds to a query in Q. Indices are 1-based. >>> find_first_geq_index([1, 2, 3, 5, 6, 8, 10, 12], [4, 7, 13]) [4, 6, -1] >>> find_first_geq_index([10], [9, 10, 11]) [1, 1, -1] >>> find_first_geq_index([5, 5, 5, 5, 5], [1, 5, 6]) [1, 1, -1] >>> find_first_geq_index([1, 3, 5, 7, 9], [0, 1, 9, 10, 5]) [1, 1, 5, -1, 3] >>> find_first_geq_index([], [1, 2, 3]) [-1, -1, -1]","solution":"def find_first_geq_index(A, Q): For each query in Q, find the index of the first element in A that is greater than or equal to the query. Returns a list of results, where each result corresponds to a query in Q. from bisect import bisect_left results = [] for q in Q: index = bisect_left(A, q) if index < len(A): results.append(index + 1) # Convert to 1-based index else: results.append(-1) return results"},{"question":"from typing import Tuple class StringManipulator: def reverse_string(self, s: str) -> str: Returns the reverse of the string s. pass def count_vowels_consonants(self, s: str) -> Tuple[int, int]: Returns a tuple representing the number of vowels and consonants in the string s. pass def is_palindrome(self, s: str) -> bool: Checks if the string s is a palindrome, ignoring cases and non-alphabetic characters. pass import pytest def test_reverse_string(): sm = StringManipulator() assert sm.reverse_string(\\"Hello World!\\") == \\"!dlroW olleH\\" assert sm.reverse_string(\\"abcd\\") == \\"dcba\\" assert sm.reverse_string(\\"\\") == \\"\\" assert sm.reverse_string(\\"a\\") == \\"a\\" def test_count_vowels_consonants(): sm = StringManipulator() assert sm.count_vowels_consonants(\\"Hello World!\\") == (3, 7) assert sm.count_vowels_consonants(\\"BCDFGHJKL\\") == (0, 9) assert sm.count_vowels_consonants(\\"AEIOUaeiou\\") == (10, 0) assert sm.count_vowels_consonants(\\"\\") == (0, 0) def test_is_palindrome(): sm = StringManipulator() assert sm.is_palindrome(\\"A man, a plan, a canal, Panama\\") == True assert sm.is_palindrome(\\"No lemon, no melon\\") == True assert sm.is_palindrome(\\"Hello World\\") == False assert sm.is_palindrome(\\"\\") == True if __name__ == '__main__': pytest.main()","solution":"from typing import Tuple class StringManipulator: def reverse_string(self, s: str) -> str: Returns the reverse of the string s. return s[::-1] def count_vowels_consonants(self, s: str) -> Tuple[int, int]: Returns a tuple representing the number of vowels and consonants in the string s. vowels = set(\\"aeiouAEIOU\\") vowel_count = sum(1 for char in s if char in vowels) consonant_count = sum(1 for char in s if char.isalpha() and char not in vowels) return vowel_count, consonant_count def is_palindrome(self, s: str) -> bool: Checks if the string s is a palindrome, ignoring cases and non-alphabetic characters. # Filter only alphabetic characters and convert them to lower case filtered_s = \\"\\".join(char.lower() for char in s if char.isalpha()) return filtered_s == filtered_s[::-1]"},{"question":"def has_cycle(n: int, m: int, connections: List[Tuple[int, int]]) -> str: Determine whether there is a cycle in the network of computers connected by cables. Args: n: The number of computers. m: The number of cables. connections: A list of tuples where each tuple represents a cable connection between two computers. Returns: \\"Yes\\" if there is at least one cycle in the network, otherwise \\"No\\". >>> has_cycle(5, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (2, 4), (1, 3)]) \\"Yes\\" >>> has_cycle(4, 3, [(1, 2), (2, 3), (3, 4)]) \\"No\\" from typing import List, Tuple def test_has_cycle_with_cycle(): n = 5 m = 6 connections = [ (1, 2), (2, 3), (3, 4), (4, 5), (2, 4), (1, 3) ] assert has_cycle(n, m, connections) == \\"Yes\\" def test_has_cycle_no_cycle(): n = 4 m = 3 connections = [ (1, 2), (2, 3), (3, 4) ] assert has_cycle(n, m, connections) == \\"No\\" def test_has_cycle_single_node(): n = 1 m = 0 connections = [] assert has_cycle(n, m, connections) == \\"No\\" def test_has_cycle_single_connection(): n = 2 m = 1 connections = [(1, 2)] assert has_cycle(n, m, connections) == \\"No\\" def test_has_cycle_separate_cycle_and_chain(): n = 7 m = 6 connections = [ (1, 2), (2, 3), (3, 1), (4, 5), (5, 6), (6, 7) ] assert has_cycle(n, m, connections) == \\"Yes\\"","solution":"def has_cycle(n, m, connections): from collections import defaultdict def dfs(v, visited, parent): visited[v] = True for neighbor in graph[v]: if not visited[neighbor]: if dfs(neighbor, visited, v): return True elif parent != neighbor: return True return False # Create a graph from the list of connections graph = defaultdict(list) for u, v in connections: graph[u].append(v) graph[v].append(u) visited = [False] * (n+1) for i in range(1, n+1): if not visited[i]: if dfs(i, visited, -1): return \\"Yes\\" return \\"No\\" # Note: The function reads input from arguments directly rather than standard input. # n = number of computers # m = number of cables # connections = list of tuples where each tuple represents a cable connection between two computers"},{"question":"def countPatternOccurrences(text: str, pattern: str) -> int: Returns the number of times the pattern appears in the text, including overlaps. >>> countPatternOccurrences(\\"aaaa\\", \\"aa\\") 3 >>> countPatternOccurrences(\\"abababa\\", \\"aba\\") 3 >>> countPatternOccurrences(\\"abcdef\\", \\"gh\\") 0 >>> countPatternOccurrences(\\"aaaaa\\", \\"bb\\") 0 >>> countPatternOccurrences(\\"abcabcabc\\", \\"abc\\") 3 >>> countPatternOccurrences(\\"aaaaa\\", \\"a\\") 5 >>> countPatternOccurrences(\\"hello\\", \\"helloo\\") 0 >>> countPatternOccurrences(\\"match\\", \\"match\\") 1 >>> countPatternOccurrences(\\"abcabcabc\\", \\"bca\\") 2","solution":"def countPatternOccurrences(text, pattern): Returns the number of times the pattern appears in the text, including overlaps. count = 0 i = 0 while i <= len(text) - len(pattern): if text[i:i+len(pattern)] == pattern: count += 1 i += 1 else: i += 1 return count"},{"question":"def collect_coins(piles): Determines the number of coins collected by Alice and Bob if both play optimally. Parameters: piles (list): List of integers where each integer represents the number of coins in a pile. Returns: tuple: A tuple containing two integers, representing the number of coins collected by Alice and Bob respectively. Examples: >>> collect_coins([4, 1, 2, 8]) (10, 5) >>> collect_coins([5, 5, 5]) (10, 5)","solution":"def collect_coins(piles): Determines the number of coins collected by Alice and Bob if both play optimally. Parameters: piles (list): List of integers where each integer represents the number of coins in a pile. Returns: tuple: A tuple containing two integers, representing the number of coins collected by Alice and Bob respectively. # Sort the piles in descending order sorted_piles = sorted(piles, reverse=True) alice_coins = 0 bob_coins = 0 # Iterate over sorted piles, alternating between Alice's and Bob's turns for i in range(len(sorted_piles)): if i % 2 == 0: alice_coins += sorted_piles[i] else: bob_coins += sorted_piles[i] return alice_coins, bob_coins"},{"question":"def max_menu_item_cost(T, test_cases): Determines the maximum possible cost of a menu item that can be created with given ingredients. Parameters: T (int): Number of test cases. test_cases (list of (int, int, list of int)): Each test case is a tuple where - First element is the number of ingredients (N). - Second element is the maximum number of unique ingredients that can be used in a menu item (K). - Third element is the list of costs of the ingredients. Returns: list of int: Maximum costs for each test case.","solution":"def max_menu_item_cost(T, test_cases): Determines the maximum possible cost of a menu item that can be created with given ingredients. Parameters: T (int): Number of test cases. test_cases (list of (int, int, list of int)): Each test case is a tuple where - First element is the number of ingredients (N). - Second element is the maximum number of unique ingredients that can be used in a menu item (K). - Third element is the list of costs of the ingredients. Returns: list of int: Maximum costs for each test case. results = [] for i in range(T): N, K, costs = test_cases[i] # Sort the costs in descending order and sum up the top K costs sorted_costs = sorted(costs, reverse=True) max_cost = sum(sorted_costs[:K]) results.append(max_cost) return results"},{"question":"def max_candies_collected(arr): Determine the maximum number of candies you can collect if you start from any box and move to any adjacent box in each step. You can only move to a box which has fewer candies than the current one. >>> max_candies_collected([1, 2, 3, 2, 1, 5]) 3 >>> max_candies_collected([5, 4, 3, 2, 1]) 5 def process_test_cases(T, test_cases): Process multiple test cases for the max_candies_collected function. >>> test_cases = [(6, [1, 2, 3, 2, 1, 5]), (5, [5, 4, 3, 2, 1])] >>> process_test_cases(2, test_cases) [3, 5] # Unit Tests def test_single_box(): assert max_candies_collected([3]) == 1 def test_increasing_sequence(): assert max_candies_collected([1, 2, 3]) == 1 def test_decreasing_sequence(): assert max_candies_collected([3, 2, 1]) == 3 def test_same_candies(): assert max_candies_collected([2, 2, 2]) == 3 def test_mixed_sequence(): assert max_candies_collected([1, 2, 3, 2, 1, 5]) == 3 def test_max_edge_cases(): assert max_candies_collected([10**9, 10**9, 10**9]) == 3 assert max_candies_collected([10**9, 10**9 - 1, 10**9 - 2, 10**9 - 3]) == 4 assert max_candies_collected([1] * 1000) == 1000 def test_process_test_cases(): test_cases = [ (6, [1, 2, 3, 2, 1, 5]), (5, [5, 4, 3, 2, 1]) ] assert process_test_cases(2, test_cases) == [3, 5] def test_empty(): assert process_test_cases(0, []) == []","solution":"def max_candies_collected(arr): max_collected = 0 n = len(arr) for i in range(n): count = 0 current_candies = arr[i] for j in range(i, n): if arr[j] <= current_candies: count += 1 current_candies = arr[j] else: break max_collected = max(max_collected, count) return max_collected def process_test_cases(t, test_cases): results = [] for case in test_cases: n, arr = case results.append(max_candies_collected(arr)) return results"},{"question":"def calculate_skyline_length(building_heights_list: List[str]) -> List[int]: Calculate the total skyline length for each set of building heights. Args: building_heights_list (list): List of strings, where each string contains a space-separated list of integers representing the heights of buildings. The last item is \\"0\\" which marks the end of input. Returns: list: List of integers representing the skyline length for each input set. Examples: >>> calculate_skyline_length([\\"2 3 5 2 1\\", \\"4 1 2 3\\", \\"0\\"]) [5, 4] >>> calculate_skyline_length([\\"7 8 9\\", \\"1\\", \\"3 3 3 3\\", \\"0\\"]) [3, 1, 4]","solution":"def calculate_skyline_length(building_heights_list): Calculate the total skyline length for each set of building heights. Args: building_heights_list (list): List of strings, where each string contains a space-separated list of integers representing the heights of buildings. The last item is \\"0\\" which marks the end of input. Returns: list: List of integers representing the skyline length for each input set. results = [] # Iterate over each item in the list until we hit the \\"0\\" marker for buildings in building_heights_list: if buildings.strip() == \\"0\\": break heights = list(map(int, buildings.split())) # The skyline length for any set of buildings is the number of buildings skyline_length = len(heights) results.append(skyline_length) return results"},{"question":"import re from collections import Counter def most_frequent_word(file_name: str) -> str: Create a program that takes a text file containing a paragraph as input, and outputs the most frequently occurring word in the paragraph that has more than 3 characters. In case of a tie, output the word that appears first in the paragraph. Args: file_name (str): The file name of the text file containing the paragraph. Returns: str: The most frequently occurring word with more than 3 characters. >>> most_frequent_word('input.txt') 'quick'","solution":"def most_frequent_word(file_name): from collections import Counter import re with open(file_name, 'r') as file: text = file.read().lower() words = re.findall(r'b[a-z]{4,}b', text) # Fetch words with 4 or more characters if not words: return None word_counts = Counter(words) most_common_word = word_counts.most_common(1)[0][0] return most_common_word"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Returns an array where each element is the product of all other elements in the original array excluding the current element at that position. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([5, 6, 2, 3]) [36, 30, 90, 60] >>> product_except_self([3, 0, 2, 4]) [0, 24, 0, 0] >>> product_except_self([2, 2, 2, 2]) [8, 8, 8, 8] >>> product_except_self([3, 4]) [4, 3] >>> product_except_self([1] * 1000) [1] * 1000 pass","solution":"def product_except_self(nums): Returns an array where each element is the product of all other elements in the original array excluding the current element at that position. n = len(nums) if n == 0: return [] left_products = [1] * n right_products = [1] * n # Fill left_products for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] # Fill right_products for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Calculate the result by multiplying left_products and right_products result = [1] * n for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"def shift_letter(c: str) -> str: Shifts a single character forward by one in the alphabet, wrapping 'z' to 'a' and 'Z' to 'A'. Non-alphabetic characters remain unchanged. >>> shift_letter('a') 'b' >>> shift_letter('z') 'a' >>> shift_letter('A') 'B' >>> shift_letter('Z') 'A' >>> shift_letter('!') '!' >>> shift_letter(' ') ' ' def shift_text(text: str) -> str: Shifts each letter in the text forward by one position in the alphabet. >>> shift_text('Hello, World!') 'Ifmmp, Xpsme!' >>> shift_text('abc xyz') 'bcd yza' >>> shift_text('Zebra-123') 'Afcsb-123' def transform_strings(T: int, strings: List[str]) -> List[str]: Transforms a list of strings based on the specified text transformation. >>> transform_strings(3, ['Hello, World!', 'abc xyz', 'Zebra-123']) ['Ifmmp, Xpsme!', 'bcd yza', 'Afcsb-123'] >>> transform_strings(1, ['']) [''] >>> transform_strings(2, ['a', 'Z']) ['b', 'A']","solution":"def shift_letter(c): Shifts a single character forward by one in the alphabet, wrapping 'z' to 'a' and 'Z' to 'A'. Non-alphabetic characters remain unchanged. if 'a' <= c <= 'z': return chr((ord(c) - ord('a') + 1) % 26 + ord('a')) elif 'A' <= c <= 'Z': return chr((ord(c) - ord('A') + 1) % 26 + ord('A')) else: return c def shift_text(text): Shifts each letter in the text forward by one position in the alphabet. return ''.join(shift_letter(c) for c in text) def transform_strings(T, strings): Transforms a list of strings based on the specified text transformation. return [shift_text(s) for s in strings]"},{"question":"class Laboratory: def __init__(self, n): Initialize the laboratory with n beakers, each initially empty. self.solution_amounts = [0] * n def add_solution(self, x, y): Add y units of solution to beaker x. self.solution_amounts[x-1] += y def remove_solution(self, x, y): Remove y units of solution from beaker x, do not allow negative amounts. self.solution_amounts[x-1] = max(0, self.solution_amounts[x-1] - y) def inquire_solution(self, l, r): Inquire about the total amount of solution from beaker l to beaker r (inclusive). return sum(self.solution_amounts[l-1:r]) def process_operations(n, operations): Process a series of operations on beakers. Args: n: number of beakers. operations: list of operations to be processed. Returns: List of results for each inquiry operation. >>> process_operations(5, [\\"1 2 3\\", \\"1 4 5\\", \\"3 1 5\\", \\"2 4 2\\", \\"3 3 4\\", \\"3 2 2\\"]) [8, 3, 3] >>> process_operations(3, [\\"1 1 10\\", \\"1 2 20\\", \\"1 3 30\\", \\"3 1 3\\"]) [60]","solution":"class Laboratory: def __init__(self, n): self.solution_amounts = [0] * n def add_solution(self, x, y): self.solution_amounts[x-1] += y def remove_solution(self, x, y): self.solution_amounts[x-1] = max(0, self.solution_amounts[x-1] - y) def inquire_solution(self, l, r): return sum(self.solution_amounts[l-1:r]) def process_operations(n, operations): lab = Laboratory(n) results = [] for operation in operations: parts = operation.split() op_type = int(parts[0]) if op_type == 1: x, y = int(parts[1]), int(parts[2]) lab.add_solution(x, y) elif op_type == 2: x, y = int(parts[1]), int(parts[2]) lab.remove_solution(x, y) elif op_type == 3: l, r = int(parts[1]), int(parts[2]) results.append(lab.inquire_solution(l, r)) return results"},{"question":"def can_rearrange_sequence(n: int, sequence: List[int]) -> str: Determines if it is possible to rearrange the integers in such a way that no two consecutive integers in the rearranged sequence have the same absolute difference as any other pair of consecutive integers in the sequence. Args: n : int : number of elements in the sequence sequence : list of int : the sequence of integers Returns: str : 'YES' and the rearranged sequence if possible, else 'NO'. >>> can_rearrange_sequence(4, [1, 4, 2, 8]) 'YESn1 8 2 4' >>> can_rearrange_sequence(5, [5, 5, 5, 5, 5]) 'NO'","solution":"def can_rearrange_sequence(n, sequence): Determines if it is possible to rearrange the integers in such a way that no two consecutive integers in the rearranged sequence have the same absolute difference as any other pair of consecutive integers in the sequence. Args: n : int : number of elements in the sequence sequence : list of int : the sequence of integers Returns: str : 'YES' and the rearranged sequence if possible, else 'NO' # Sort the sequence sequence.sort() # Rearrange by alternating between the smallest and largest remaining elements rearranged_sequence = [] left, right = 0, n - 1 while left <= right: if left != right: rearranged_sequence.append(sequence[left]) rearranged_sequence.append(sequence[right]) else: rearranged_sequence.append(sequence[left]) left += 1 right -= 1 # Calculate differences differences = [] for i in range(1, n): differences.append(abs(rearranged_sequence[i] - rearranged_sequence[i - 1])) # Check if all differences are unique if len(differences) == len(set(differences)): return \\"YESn\\" + \\" \\".join(map(str, rearranged_sequence)) else: return \\"NO\\""},{"question":"def max_subarray_sum(n: int, heights: List[int]) -> int: Returns the maximum sum of any continuous sub-sequence of pillar heights. Uses Kadane's algorithm for efficient computation. :param n: int, the number of pillars :param heights: list of int, the heights of the pillars :return: int, the maximum sum of any continuous sub-sequence of the pillars >>> max_subarray_sum(5, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum(1, [-1]) -1","solution":"def max_subarray_sum(n, heights): Returns the maximum sum of any continuous sub-sequence of pillar heights. Uses Kadane's algorithm for efficient computation. :param n: int, the number of pillars :param heights: list of int, the heights of the pillars :return: int, the maximum sum of any continuous sub-sequence of the pillars max_current = max_global = heights[0] for height in heights[1:]: max_current = max(height, max_current + height) if max_current > max_global: max_global = max_current return max_global"},{"question":"def count_vowels(s: str) -> int: Given a string, count the number of vowels ('a', 'e', 'i', 'o', 'u') in the string. >>> count_vowels(\\"hello world\\") 3 >>> count_vowels(\\"bcdfg\\") 0 >>> count_vowels(\\"aeiou\\") 5 >>> count_vowels(\\"abcdefghijklmnopqrstuvwxyz\\") 5 >>> count_vowels(\\"aaeeiioouu\\") 10","solution":"def count_vowels(s): Returns the number of vowels in the given string. vowels = 'aeiou' count = sum(1 for char in s if char in vowels) return count"},{"question":"def count_char_in_substring(S: str, queries: List[Tuple[int, int, str]]) -> List[int]: For each query, returns the number of times the character c appears in the substring from index l to r in the string S. Args: S : str - The input string. queries : list of tuples - A list of queries where each query is a tuple (l, r, c). Returns: results : list - A list of integers representing the results for each query. Examples: >>> count_char_in_substring(\\"abcabcabc\\", [(1, 3, 'a')]) [1] >>> count_char_in_substring(\\"abcabcabc\\", [(1, 3, 'a'), (4, 6, 'b'), (1, 9, 'c')]) [1, 1, 3]","solution":"def count_char_in_substring(S, queries): For each query, returns the number of times the character c appears in the substring from index l to r in the string S. Args: S : str - The input string. queries : list of tuples - A list of queries where each query is a tuple (l, r, c). Returns: results : list - A list of integers representing the results for each query. # Convert 1-based indices to 0-based indices results = [] for (l, r, c) in queries: substring = S[l-1:r] results.append(substring.count(c)) return results"},{"question":"def process_queries(n: int, lengths: List[int], queries: List[Tuple[int, int]]) -> List[str]: Given the lengths of the ropes and the queries, determine if the subsegment is beautiful for each query. A subsegment [L, R] of the ropes is called beautiful if the lengths in the subsegment are in strictly increasing, strictly decreasing, or all the same order. :param n: The number of ropes. :param lengths: A list of integers representing the lengths of the ropes. :param queries: A list of tuples where each tuple contains two integers L and R representing the subsegment. :return: A list of strings \\"Yes\\" or \\"No\\" for each query. >>> process_queries(5, [1, 2, 2, 3, 4], [(1, 5), (2, 3), (3, 4)]) [\\"No\\", \\"Yes\\", \\"Yes\\"] >>> process_queries(5, [1, 2, 3, 4, 5], [(1, 5), (2, 4)]) [\\"Yes\\", \\"Yes\\"] >>> process_queries(5, [5, 4, 3, 2, 1], [(1, 5), (2, 4)]) [\\"Yes\\", \\"Yes\\"] >>> process_queries(5, [3, 3, 3, 3, 3], [(1, 5), (2, 4)]) [\\"Yes\\", \\"Yes\\"] >>> process_queries(8, [1, 2, 3, 1, 2, 1, 2, 3], [(1, 3), (2, 4), (5, 7), (1, 8)]) [\\"Yes\\", \\"No\\", \\"No\\", \\"No\\"] >>> process_queries(5, [1, 3, 2, 5, 4], [(1, 1), (3, 3), (5, 5)]) [\\"Yes\\", \\"Yes\\", \\"Yes\\"]","solution":"def is_beautiful_segment(lengths, L, R): Checks if the subsegment [L, R] of the lengths array is beautiful. A segment is considered beautiful if it is strictly increasing, strictly decreasing or all the same. subsegment = lengths[L-1:R] n = len(subsegment) if n == 1: return True increasing = all(subsegment[i] < subsegment[i+1] for i in range(n-1)) decreasing = all(subsegment[i] > subsegment[i+1] for i in range(n-1)) all_same = all(subsegment[i] == subsegment[i+1] for i in range(n-1)) return increasing or decreasing or all_same def process_queries(n, lengths, queries): Processes the list of queries and determines if each subsegment is beautiful. results = [] for L, R in queries: if is_beautiful_segment(lengths, L, R): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def find_smallest_missing_positive(N: int, elements: List[int]) -> int: Returns the smallest positive integer not present in the list. :param N: int: the number of elements in the list :param elements: List[int]: the elements of the list :return: int: smallest missing positive integer. >>> find_smallest_missing_positive(5, [3, 4, -1, 1, 2]) 5 >>> find_smallest_missing_positive(7, [1, 3, 5, 7, 9, 11, 13]) 2 >>> find_smallest_missing_positive(3, [1, 2, 3]) 4 >>> find_smallest_missing_positive(5, [-1, -2, -3, -4, -5]) 1 >>> find_smallest_missing_positive(5, [3, 7, 6, 8, 10]) 1 >>> find_smallest_missing_positive(9, [8, -2, 6, 2, 3, 1, 4, 7, -1]) 5 >>> find_smallest_missing_positive(10, [-1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 1 >>> find_smallest_missing_positive(6, [-1, 1, 9, 8, 7, 3]) 2 >>> find_smallest_missing_positive(3, [105, 101, 102]) 1","solution":"def find_smallest_missing_positive(N, elements): Returns the smallest positive integer not present in the list. :param N: int: the number of elements in the list :param elements: List[int]: the elements of the list :return: int: smallest missing positive integer # Create a set for efficient look-up element_set = set(elements) # Start checking from 1 onwards smallest_missing = 1 while smallest_missing in element_set: smallest_missing += 1 return smallest_missing"},{"question":"from typing import List def files_to_backup(n: int, files: List[str]) -> List[int]: Determines which files need to be backed up, ensuring no identical files are backed up more than once. Args: n : int : The number of files files : List[str] : The content of the files Returns: List[int]: A list of indices of the files that need to be backed up initially. >>> files_to_backup(4, ['abc', 'def', 'abc', 'ghi']) [0, 1, 3] >>> files_to_backup(3, ['content1', 'content2', 'content3']) [0, 1, 2]","solution":"from typing import List def files_to_backup(n: int, files: List[str]) -> List[int]: unique_files = set() backup_indices = [] for index, file_content in enumerate(files): if file_content not in unique_files: unique_files.add(file_content) backup_indices.append(index) return backup_indices"},{"question":"def count_even_sum_pairs(n, sequence): Counts the number of pairs (i, j) such that i < j and the sum of the i-th and j-th elements in the sequence is an even number. Parameters: n (int): Number of elements in the sequence. sequence (list of int): The sequence of integers. Returns: int: Number of pairs with an even sum. >>> count_even_sum_pairs(5, [1, 2, 3, 4, 5]) 4 >>> count_even_sum_pairs(4, [2, 4, 6, 8]) 6 >>> count_even_sum_pairs(1, [1]) 0 >>> count_even_sum_pairs(5, [2, 4, 6, 8, 10]) 10 >>> count_even_sum_pairs(3, [1, 3, 5]) 3 >>> count_even_sum_pairs(2, [1, 2]) 0 >>> n = 100000 >>> count_even_sum_pairs(n, [2] * n) 4999950000 >>> count_even_sum_pairs(6, [1, 2, 3, 4, 5, 6]) 6","solution":"def count_even_sum_pairs(n, sequence): Counts the number of pairs (i, j) such that i < j and the sum of the i-th and j-th elements in the sequence is an even number. Parameters: n (int): Number of elements in the sequence. sequence (list of int): The sequence of integers. Returns: int: Number of pairs with an even sum. even_count = sum(1 for x in sequence if x % 2 == 0) odd_count = n - even_count return even_count * (even_count - 1) // 2 + odd_count * (odd_count - 1) // 2"},{"question":"def minify_json(json_data: str) -> str: Removes all unnecessary white spaces (spaces, tabs, and new lines) from the JSON string without affecting the integrity of the data within string literals. >>> minify_json('{\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"Wonderland\\"}') '{\\"name\\":\\"Alice\\",\\"age\\":30,\\"city\\":\\"Wonderland\\"}' >>> minify_json('[{\\"name\\": \\"Bob\\", \\"age\\": 25}, {\\"name\\": \\"Charlie\\", \\"age\\": 35}]') '[{\\"name\\":\\"Bob\\",\\"age\\":25},{\\"name\\":\\"Charlie\\",\\"age\\":35}]' >>> minify_json('{\\"text\\": \\"This is a string with spaces.\\"}') '{\\"text\\":\\"This is a string with spaces.\\"}' >>> minify_json('{\\"escaped\\": \\"This \\"is\\" a test.\\"}') '{\\"escaped\\":\\"This \\"is\\" a test.\\"}' >>> minify_json('{}') '{}' >>> minify_json('[]') '[]'","solution":"def minify_json(json_data): Removes all unnecessary white spaces (spaces, tabs, and new lines) from the JSON string without affecting the integrity of the data within string literals. Parameters: json_data (str): The input JSON string. Returns: str: The minified JSON string. result = [] in_string = False escape = False for char in json_data: if in_string: if char == '\\"' and not escape: in_string = False if char == '' and not escape: escape = True else: escape = False result.append(char) else: if char == '\\"': in_string = True if not char.isspace() or in_string: result.append(char) return ''.join(result)"},{"question":"from typing import List, Tuple def min_piles_count(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum number of piles needed to organize stones such that each pile contains stones with consecutive weights, and no two stones in the same pile weigh the same. >>> min_piles_count(1, [(8, [1, 3, 2, 6, 5, 4, 7, 8])]) == [1] >>> min_piles_count(2, [(3, [1, 3, 5]), (4, [10, 12, 14, 16])]) == [3, 4] >>> min_piles_count(2, [(8, [1, 3, 2, 6, 5, 4, 7, 8]), (5, [10, 11, 13, 12, 14])]) == [1, 1] >>> min_piles_count(1, [(5, [999999996, 999999997, 999999998, 999999999, 1000000000])]) == [1] >>> min_piles_count(1, [(1, [1])]) == [1]","solution":"def min_piles_count(T, test_cases): results = [] for case in test_cases: n, weights = case weights.sort() # Piles are dictated by the difference between consecutive stones piles = 1 for i in range(1, n): if weights[i] > weights[i - 1] + 1: piles += 1 results.append(piles) return results"},{"question":"def find_max_borrowed_item(n: int, logs: List[str]) -> Tuple[int, int]: Determines the item that has been borrowed for the maximum total duration and what that duration is from a given series of log entries in chronological order. Args: n (int): The number of log entries. logs (List[str]): A list of log entries with each entry indicating a borrow or return event. Returns: Tuple[int, int]: The item_id of the item borrowed for the maximum total duration and the total duration. >>> find_max_borrowed_item(7, [\\"borrow 1 3\\", \\"borrow 2 5\\", \\"return 1 10\\", \\"borrow 3 11\\", \\"return 2 20\\", \\"borrow 1 25\\", \\"return 1 30\\"]) (1, 12) >>> find_max_borrowed_item(4, [\\"borrow 1 1\\", \\"borrow 2 2\\", \\"return 1 10\\", \\"return 2 5\\"]) (1, 9) >> find_max_borrowed_item(4, [\\"borrow 1 1\\", \\"return 1 5\\", \\"borrow 1 10\\", \\"return 1 15\\"]) (1, 9)","solution":"def find_max_borrowed_item(n, logs): item_borrow_times = {} current_borrows = {} for log in logs: parts = log.split() event = parts[0] item_id = int(parts[1]) timestamp = int(parts[2]) if event == \\"borrow\\": current_borrows[item_id] = timestamp elif event == \\"return\\": if item_id in current_borrows: borrow_time = timestamp - current_borrows[item_id] if item_id in item_borrow_times: item_borrow_times[item_id] += borrow_time else: item_borrow_times[item_id] = borrow_time del current_borrows[item_id] # Find the item with the maximum total duration max_time = -1 item_id_with_max_time = None for item_id, total_time in item_borrow_times.items(): if total_time > max_time or (total_time == max_time and item_id < item_id_with_max_time): max_time = total_time item_id_with_max_time = item_id return item_id_with_max_time, max_time"},{"question":"from typing import List, Tuple def shortest_travel_time(n: int, edges: List[Tuple[int, int, int]], start: int, end: int) -> int: Find the shortest time needed to travel from the starting planet to the destination planet. If there is no path, return -1. >>> shortest_travel_time(7, [(1, 2, 5), (1, 3, 10), (2, 4, 2), (3, 4, 1), (4, 5, 3), (5, 6, 1), (6, 7, 5)], 1, 7) 16 >>> shortest_travel_time(5, [(1, 2, 1), (2, 3, 1)], 1, 5) -1 >>> shortest_travel_time(3, [(1, 2, 5), (2, 3, 10)], 1, 2) 5 >>> shortest_travel_time(4, [(1, 2, 1), (2, 3, 2), (1, 3, 4), (3, 4, 1), (2, 4, 10)], 1, 4) 4 >>> shortest_travel_time(1, [], 1, 1) 0","solution":"from typing import List, Tuple import heapq def shortest_travel_time(n: int, edges: List[Tuple[int, int, int]], start: int, end: int) -> int: # Create a graph in the form of an adjacency list graph = {i: [] for i in range(1, n + 1)} for u, v, t in edges: graph[u].append((v, t)) # Use Dijkstra's algorithm to find the shortest path from start to end pq = [(0, start)] # priority queue to store (current travel time, current planet) distances = {i: float('inf') for i in range(1, n + 1)} # distance table distances[start] = 0 while pq: current_time, current_planet = heapq.heappop(pq) # If we reached the destination planet if current_planet == end: return current_time # Explore neighboring planets for neighbor, travel_time in graph[current_planet]: new_time = current_time + travel_time # If a shorter path to the neighbor is found if new_time < distances[neighbor]: distances[neighbor] = new_time heapq.heappush(pq, (new_time, neighbor)) return -1 if distances[end] == float('inf') else distances[end]"},{"question":"import random def simulate_snowflake(grid_size: tuple, num_snowflakes: int) -> list: Simulates the deposition process to form a snowflake pattern on a 2D grid. Args: grid_size: A tuple (rows, columns) representing the dimensions of the grid. num_snowflakes: The number of snowflakes to be dropped. Returns: A 2D list representing the grid with the snowflake pattern. def test_initial_snowflake(): grid_size = (5, 5) num_snowflakes = 0 result = simulate_snowflake(grid_size, num_snowflakes) expected = [ [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0] ] assert result == expected def test_single_snowflake_on_top_of_seed(): grid_size = (5, 5) num_snowflakes = 1 result = simulate_snowflake(grid_size, num_snowflakes) assert result[0][2] == 1 or result[1][2] == 1 def test_multiple_snowflakes(): grid_size = (5, 5) num_snowflakes = 10 result = simulate_snowflake(grid_size, num_snowflakes) total_snowflakes = sum(sum(row) for row in result) assert total_snowflakes == 1 + num_snowflakes def test_edge_single_snowflake(): grid_size = (1, 1) num_snowflakes = 1 result = simulate_snowflake(grid_size, num_snowflakes) expected = [[1]] assert result == expected def test_small_grid(): grid_size = (3, 3) num_snowflakes = 5 result = simulate_snowflake(grid_size, num_snowflakes) total_snowflakes = sum(sum(row) for row in result) assert total_snowflakes == 1 + num_snowflakes","solution":"import random def simulate_snowflake(grid_size: tuple, num_snowflakes: int) -> list: Simulates the deposition process to form a snowflake pattern on a 2D grid. Args: grid_size: A tuple (rows, columns) representing the dimensions of the grid. num_snowflakes: The number of snowflakes to be dropped. Returns: A 2D list representing the grid with the snowflake pattern. rows, columns = grid_size grid = [[0 for _ in range(columns)] for _ in range(rows)] center_x, center_y = rows // 2, columns // 2 # Seed the center of the grid grid[center_x][center_y] = 1 def drop_snowflake(col): for row in range(rows): if row == rows - 1 or grid[row + 1][col] == 1: grid[row][col] = 1 break if grid[row + 1][col] == 1: left = col > 0 and grid[row][col - 1] == 0 right = col < columns - 1 and grid[row][col + 1] == 0 if left and right: if random.choice([True, False]): grid[row][col - 1] = 1 else: grid[row][col + 1] = 1 elif left: grid[row][col - 1] = 1 elif right: grid[row][col + 1] = 1 else: grid[row][col] = 1 break for _ in range(num_snowflakes): col = random.randint(0, columns - 1) drop_snowflake(col) return grid"},{"question":"def sum_of_unique_elements(n: int, arr: List[int]) -> int: Returns the sum of all unique elements in the array. Two elements are considered unique if they appear only once in the array. Parameters: n (int) : number of elements in the array arr (list) : list of integers Returns: int: sum of all unique elements >>> sum_of_unique_elements(5, [1, 2, 2, 3, 4]) 8 >>> sum_of_unique_elements(4, [2, 2, 2, 2]) 0","solution":"def sum_of_unique_elements(n, arr): Returns the sum of all unique elements in the array. Parameters: n (int) : number of elements in the array arr (list) : list of integers Returns: int: sum of all unique elements from collections import Counter # Count occurrences of each element counts = Counter(arr) # Sum elements that appear exactly once unique_sum = sum(element for element, count in counts.items() if count == 1) return unique_sum"},{"question":"def max_magical_energy(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Determine the maximum possible magical energy from any K consecutive flowers. >>> max_magical_energy(3, [((5, 3), [1, 2, 3, 4, 5]), ((8, 2), [-1, -2, 9, 8, -7, 3, -4, 6]), ((6, 4), [-5, 1, 3, -2, 4, -1])]) [12, 17, 6] >>> max_magical_energy(1, [((3, 1), [100, -50, 30])]) [100] >>> max_magical_energy(1, [((5, 2), [-10, -20, -30, -40, -50])]) [-30] >>> max_magical_energy(1, [((6, 3), [10, 20, 30, 40, 50, 60])]) [150] >>> max_magical_energy(1, [((4, 4), [1, 2, 3, 4])]) [10]","solution":"def max_magical_energy(T, test_cases): results = [] for i in range(T): N, K = test_cases[i][0] energies = test_cases[i][1] max_energy = float('-inf') current_sum = sum(energies[:K]) max_energy = current_sum for j in range(K, N): current_sum += energies[j] - energies[j - K] if current_sum > max_energy: max_energy = current_sum results.append(max_energy) return results"},{"question":"def max_diff_between_top_two(N: int, M: int) -> int: Calculates the maximum possible difference in cumulative scores between the first and second place participants. >>> max_diff_between_top_two(2, 1) 2 >>> max_diff_between_top_two(3, 2) 4 >>> max_diff_between_top_two(4, 5) 10 >>> max_diff_between_top_two(6, 10) 20","solution":"def max_diff_between_top_two(N, M): Calculates the maximum possible difference in cumulative scores between the first and second place participants. The winner of a match gets 2 points and the loser gets 0 points. return 2 * M"},{"question":"from typing import List, Tuple, Union def min_cost_to_connect_cities(N: int, M: int, connections: List[Tuple[int, int, int]]) -> Union[int, str]: Determine the minimum cost to connect all cities using Kruskal's algorithm. Parameters: N (int): Number of cities. M (int): Number of direct connections. connections (List[Tuple[int, int, int]]): Each tuple contains three integers (u, v, w) representing a direct connection between city u and city v with a cost of w. Returns: Union[int, str]: The minimum cost to connect all cities. Returns \\"Impossible\\" if it's not possible to connect all cities. >>> min_cost_to_connect_cities(4, 4, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4)]) 6 >>> min_cost_to_connect_cities(4, 2, [(1, 2, 1), (3, 4, 1)]) \\"Impossible\\" pass","solution":"def min_cost_to_connect_cities(N, M, connections): Function to determine the minimum cost to connect all cities. Uses Kruskal's algorithm to find the Minimum Spanning Tree (MST). Parameters: N (int): Number of cities. M (int): Number of direct connections. connections (list of tuples): Each tuple contains three integers (u, v, w) representing a direct connection between city u and city v with a cost of w. Returns: int: The minimum cost to connect all cities. Returns \\"Impossible\\" if it's not possible to connect all cities. # Kruskal's algorithm requires the edges to be sorted by weight connections.sort(key=lambda x: x[2]) # Disjoint Set (Union-Find) to keep track of connected components parent = list(range(N+1)) rank = [0] * (N+1) def find(u): if parent[u] != u: parent[u] = find(parent[u]) return parent[u] def union(u, v): root_u = find(u) root_v = find(v) if root_u != root_v: if rank[root_u] > rank[root_v]: parent[root_v] = root_u elif rank[root_u] < rank[root_v]: parent[root_u] = root_v else: parent[root_v] = root_u rank[root_u] += 1 # Kruskal's algorithm to build the MST min_cost = 0 edges_used = 0 for u, v, w in connections: if find(u) != find(v): union(u, v) min_cost += w edges_used += 1 # If we have used N-1 edges, we can stop (since it's the number of edges in a MST) if edges_used == N-1: break # If we used fewer than N-1 edges, not all cities are connected if edges_used < N-1: return \\"Impossible\\" return min_cost"},{"question":"def repeat_integer(N: int) -> str: Returns the string obtained by repeating the integer N times concatenated into a single string. >>> repeat_integer(4) \\"4444\\" >>> repeat_integer(1) \\"1\\" >>> repeat_integer(7) \\"7777777\\" >>> repeat_integer(9) \\"999999999\\"","solution":"def repeat_integer(N): Returns the string obtained by repeating the integer N times concatenated into a single string. return str(N) * N"},{"question":"def count_distinct_characters(test_cases: List[str]) -> List[int]: Determines the number of distinct characters in each string in test_cases. Parameters: test_cases (List[str]): A list of strings for which to count distinct characters. Returns: List[int]: A list of integers representing the number of distinct characters in each string. # Your code here # Below are the example test cases to verify your implementation def test_single_word(): assert count_distinct_characters(['hello']) == [4] assert count_distinct_characters(['world']) == [5] def test_multiple_words(): assert count_distinct_characters(['hello', 'world']) == [4, 5] assert count_distinct_characters(['abc', 'abc', 'abc']) == [3, 3, 3] def test_empty_string(): assert count_distinct_characters(['']) == [0] def test_identical_characters(): assert count_distinct_characters(['aaaa', 'bbbb']) == [1, 1] def test_mixed_case(): assert count_distinct_characters(['AaBbCc']) == [6] def test_large_input(): large_s = 'a' * 100000 + 'b' * 100000 assert count_distinct_characters([large_s]) == [2]","solution":"def count_distinct_characters(test_cases): Determines the number of distinct characters in each string in test_cases. Parameters: test_cases (List[str]): A list of strings for which to count distinct characters. Returns: List[int]: A list of integers representing the number of distinct characters in each string. results = [] for s in test_cases: distinct_count = len(set(s)) results.append(distinct_count) return results"},{"question":"def max_elevation_gain(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the maximum elevation gain for each elevation profile. Parameters: T (int): The number of test cases. test_cases (list): A list containing tuples, each with an integer N (number of points) and a list of integers (elevation profile). Returns: list: A list containing the maximum elevation gain for each test case. >>> max_elevation_gain(3, [(5, [1, 2, 3, 4, 5]), (5, [5, 4, 3, 2, 1]), (6, [7, 1, 5, 3, 6, 4])]) [4, 0, 5] >>> max_elevation_gain(1, [(3, [1000000000, 500000000, 1000000000])]) [500000000] >>> max_elevation_gain(1, [(2, [1, 1000000000])]) [999999999] import pytest def test_single_max_elevation_gain(): T = 1 test_cases = [(5, [1, 2, 3, 4, 5])] assert max_elevation_gain(T, test_cases) == [4] def test_no_gain(): T = 1 test_cases = [(5, [5, 4, 3, 2, 1])] assert max_elevation_gain(T, test_cases) == [0] def test_mixed_elevations(): T = 1 test_cases = [(6, [7, 1, 5, 3, 6, 4])] assert max_elevation_gain(T, test_cases) == [5] def test_multiple_cases(): T = 3 test_cases = [(5, [1, 2, 3, 4, 5]), (5, [5, 4, 3, 2, 1]), (6, [7, 1, 5, 3, 6, 4])] assert max_elevation_gain(T, test_cases) == [4, 0, 5] def test_large_numbers(): T = 1 test_cases = [(3, [1000000000, 500000000, 1000000000])] assert max_elevation_gain(T, test_cases) == [500000000] def test_all_elements_equal(): T = 1 test_cases = [(4, [7, 7, 7, 7])] assert max_elevation_gain(T, test_cases) == [0] def test_minimal_case(): T = 1 test_cases = [(2, [1, 1000000000])] assert max_elevation_gain(T, test_cases) == [999999999]","solution":"def max_elevation_gain(T, test_cases): Determine the maximum elevation gain for each elevation profile. Parameters: T (int): The number of test cases. test_cases (list): A list containing tuples, each with an integer N (number of points) and a list of integers (elevation profile). Returns: list: A list containing the maximum elevation gain for each test case. results = [] for N, elevations in test_cases: min_elevation = elevations[0] max_gain = 0 for elevation in elevations: if elevation > min_elevation: max_gain = max(max_gain, elevation - min_elevation) min_elevation = min(min_elevation, elevation) results.append(max_gain) return results"},{"question":"def highest_engagement_post(T: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Determines which post received the highest combined engagement (likes + comments) for given days. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[Tuple[int, int]]]]): A list where each item is a tuple containing the number of posts and a list of tuples, each containing the number of likes and comments for a post. Returns: List[int]: A list of integers representing the 1-based index of the post with the highest combined engagement for each test case. If there are multiple posts with the same highest engagement, the smallest index is returned. Examples: >>> highest_engagement_post(2, [(3, [(10, 5), (7, 8), (15, 3)]), ... (4, [(1, 1), (1, 4), (2, 1), (3, 2)])]) [3, 4] >>> highest_engagement_post(1, [(2, [(1, 1), (0, 3)])]) [2]","solution":"def highest_engagement_post(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] posts = test_cases[i][1] max_engagement = -1 max_index = 0 for j in range(N): current_engagement = posts[j][0] + posts[j][1] if current_engagement > max_engagement: max_engagement = current_engagement max_index = j + 1 elif current_engagement == max_engagement and j + 1 < max_index: max_index = j + 1 results.append(max_index) return results # Example usage: # T = 2 # test_cases = [ # (3, [(10, 5), (7, 8), (15, 3)]), # (4, [(1, 1), (1, 4), (2, 1), (3, 2)]) # ] # print(highest_engagement_post(T, test_cases)) # Output: [3, 2]"},{"question":"from typing import List, Tuple def maximum_calories(test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Determine the maximum calories Rick can carry without exceeding the weight limit. Args: test_cases: A list of tuples where each tuple contains an integer representing the weight limit of the backpack and a list of tuples where each tuple represents a food item with its weight and calorie value. Returns: A list of integers representing the maximum calories for each test case. >>> test_cases = [(50, [(10, 60), (20, 100), (30, 120)]), (5, [(1, 20), (2, 30), (3, 50), (2, 70)])] >>> maximum_calories(test_cases) [220, 120] pass def parse_input(data: str) -> List[Tuple[int, List[Tuple[int, int]]]]: Parse input string to extract test cases. Args: data: A string containing the input data. Returns: A list of test cases where each test case is represented as a tuple containing an integer (the weight limit) and a list of tuples (each representing a food item with its weight and calorie value). >>> input_data = \\"2n50n3n10 60n20 100n30 120n5n4n1 20n2 30n3 50n2 70\\" >>> parse_input(input_data) [(50, [(10, 60), (20, 100), (30, 120)]), (5, [(1, 20), (2, 30), (3, 50), (2, 70)])] pass def format_output(results: List[int]) -> str: Format output results to a string. Args: results: A list of integers representing the maximum calories for each test case. Returns: A string formatted with each result on a new line. >>> results = [220, 120] >>> format_output(results) \\"220n120\\" pass def test_maximum_calories(): input_data = 2 50 3 10 60 20 100 30 120 5 4 1 20 2 30 3 50 2 70 test_cases = parse_input(input_data) expected = [220, 120] output = maximum_calories(test_cases) assert output == expected def test_parse_input(): input_data = 2 50 3 10 60 20 100 30 120 5 4 1 20 2 30 3 50 2 70 expected_output = [ (50, [(10, 60), (20, 100), (30, 120)]), (5, [(1, 20), (2, 30), (3, 50), (2, 70)]) ] assert parse_input(input_data) == expected_output def test_format_output(): input_data = [220, 120] expected_output = \\"220n120\\" assert format_output(input_data) == expected_output","solution":"def maximum_calories(test_cases): results = [] for W, items in test_cases: n = len(items) dp = [0] * (W + 1) for weight, calories in items: for w in range(W, weight - 1, -1): dp[w] = max(dp[w], dp[w - weight] + calories) results.append(max(dp)) return results def parse_input(data): lines = data.split('n') index = 0 t = int(lines[index]) index += 1 test_cases = [] for _ in range(t): W = int(lines[index]) index += 1 n = int(lines[index]) index += 1 items = [] for _ in range(n): weight, calories = map(int, lines[index].split()) items.append((weight, calories)) index += 1 test_cases.append((W, items)) return test_cases def format_output(results): return 'n'.join(map(str, results))"},{"question":"def max_magic_power(n, t, magic_powers): Calculate the maximum possible magic power that can be successfully harnessed without exceeding the magic threshold. Args: n (int): Number of trees in the forest. t (int): Magic threshold value. magic_powers (list of int): List containing the magic power of each tree. Returns: int: Maximum possible magic power that can be successfully harnessed without exceeding the magic threshold. Examples: >>> max_magic_power(5, 10, [1, 2, 3, 4, 5]) 10 >>> max_magic_power(4, 5, [-1, 4, 3, -2]) 5 >>> max_magic_power(6, 8, [-5, 4, 2, -1, 3, 4]) 8","solution":"def max_magic_power(n, t, magic_powers): max_power = 0 for i in range(n): current_sum = 0 for j in range(i, n): current_sum += magic_powers[j] if current_sum == t: max_power = t elif 0 < current_sum < t: max_power = max(max_power, current_sum) return max_power # Example usage n = 5 t = 10 magic_powers = [1, 2, 3, 4, 5] print(max_magic_power(n, t, magic_powers)) # Output: 10"},{"question":"from typing import List def walls_and_gates(rooms: List[List[int]]) -> List[List[int]]: Fill each empty room with the distance to its nearest gate. Args: rooms (List[List[int]]): A 2D grid where -1 represents a wall, 0 represents a gate, and 2147483647 represents an empty room. Returns: List[List[int]]: The modified grid after filling in distances for all empty rooms. >>> walls_and_gates([ ... [2147483647, -1, 0, 2147483647], ... [2147483647, 2147483647, 2147483647, -1], ... [2147483647, -1, 2147483647, -1], ... [0, -1, 2147483647, 2147483647] ... ]) [[3, -1, 0, 1], [2, 2, 1, -1], [1, -1, 2, -1], [0, -1, 3, 4]] pass def test_walls_and_gates_example(): input_grid = [ [2147483647, -1, 0, 2147483647], [2147483647, 2147483647, 2147483647, -1], [2147483647, -1, 2147483647, -1], [0, -1, 2147483647, 2147483647] ] expected_output = [ [3, -1, 0, 1], [2, 2, 1, -1], [1, -1, 2, -1], [0, -1, 3, 4] ] assert walls_and_gates(input_grid) == expected_output def test_walls_and_gates_single_gate(): input_grid = [ [2147483647, 2147483647, 2147483647], [2147483647, 0, 2147483647], [2147483647, 2147483647, 2147483647] ] expected_output = [ [2, 1, 2], [1, 0, 1], [2, 1, 2] ] assert walls_and_gates(input_grid) == expected_output def test_walls_and_gates_no_empty_rooms(): input_grid = [ [-1, -1, -1], [-1, 0, -1], [-1, -1, -1] ] expected_output = [ [-1, -1, -1], [-1, 0, -1], [-1, -1, -1] ] assert walls_and_gates(input_grid) == expected_output def test_walls_and_gates_large_empty_room(): input_grid = [ [2147483647, 2147483647], [0, 2147483647] ] expected_output = [ [1, 2], [0, 1] ] assert walls_and_gates(input_grid) == expected_output","solution":"from collections import deque def walls_and_gates(rooms): m, n = len(rooms), len(rooms[0]) queue = deque() for i in range(m): for j in range(n): if rooms[i][j] == 0: queue.append((i, j)) while queue: x, y = queue.popleft() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and rooms[nx][ny] == 2147483647: rooms[nx][ny] = rooms[x][y] + 1 queue.append((nx, ny)) return rooms"},{"question":"def longest_consecutive_subsequence_length(lst: List[int]) -> int: Calculate the length of the longest subsequence where numbers are consecutively increasing by 1. >>> longest_consecutive_subsequence_length([1, 2, 3, 5, 6]) 3 >>> longest_consecutive_subsequence_length([9, 8, 7, 10, 11, 12]) 3 pass def process_input(input_str: str) -> List[int]: Process the input string into the required output format, calculating the longest consecutive subsequence length for each list. >>> process_input(\\"1 2 3 5 6 0n9 8 7 10 11 12 0n5 3 2 1 0n0\\") [3, 3, 1] pass","solution":"def longest_consecutive_subsequence_length(lst): max_len = 0 current_len = 1 for i in range(1, len(lst)): if lst[i] == lst[i-1] + 1: current_len += 1 else: max_len = max(max_len, current_len) current_len = 1 max_len = max(max_len, current_len) return max_len def process_input(input_str): result = [] lines = input_str.strip().split('n') for line in lines: if line == '0': break numbers = list(map(int, line.split())) if numbers[-1] == 0: numbers.pop() result.append(longest_consecutive_subsequence_length(numbers)) return result"},{"question":"def is_PalindromicWord(S: str) -> str: Given a string S, check whether the string is a Palindromic word or not. A word is called Palindromic if it reads the same backward as forward. >>> is_PalindromicWord(\\"level\\") 'Palindromic' >>> is_PalindromicWord(\\"hello\\") 'Not Palindromic'","solution":"def is_PalindromicWord(S): Returns \\"Palindromic\\" if the given string S is a palindromic word, otherwise returns \\"Not Palindromic\\". if S == S[::-1]: return \\"Palindromic\\" else: return \\"Not Palindromic\\""},{"question":"import networkx as nx from typing import List, Tuple def max_paths_to_close_without_disconnecting(n: int, m: int, paths: List[Tuple[int, int]]) -> int: Returns the maximum number of paths that can be closed without disconnecting the park. :param n: Number of locations in the park :param m: Number of paths in the park :param paths: List of tuples representing the paths (u, v) :return: Max number of paths that can be closed without disconnecting the park >>> n, m = 4, 5 >>> paths = [(1, 2), (1, 3), (1, 4), (2, 3), (3, 4)] >>> max_paths_to_close_without_disconnecting(n, m, paths) 2 >>> n, m = 5, 6 >>> paths = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (2, 4)] >>> max_paths_to_close_without_disconnecting(n, m, paths) 2 >>> n, m = 2, 1 >>> paths = [(1, 2)] >>> max_paths_to_close_without_disconnecting(n, m, paths) 0 >>> n, m = 3, 3 >>> paths = [(1, 2), (2, 3), (3, 1)] >>> max_paths_to_close_without_disconnecting(n, m, paths) 1 >>> n, m = 6, 8 >>> paths = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (1, 6), (2, 5), (3, 6)] >>> max_paths_to_close_without_disconnecting(n, m, paths) 3","solution":"import networkx as nx def max_paths_to_close_without_disconnecting(n, m, paths): Returns the maximum number of paths that can be closed without disconnecting the park. :param n: Number of locations in the park :param m: Number of paths in the park :param paths: List of tuples representing the paths (u, v) :return: Max number of paths that can be closed without disconnecting the park G = nx.Graph() G.add_nodes_from(range(1, n + 1)) G.add_edges_from(paths) # Calculate the number of edges in a minimum spanning tree (MST) mst_edges = list(nx.minimum_spanning_edges(G, data=False)) mst_edge_count = len(mst_edges) # Any additional edges beyond the MST can be safely removed without # disconnecting the graph max_paths_to_close = m - mst_edge_count return max_paths_to_close"},{"question":"def find_correct_option(P: str, Q: str) -> str: Given two incorrect options P and Q, return the correct option among 'X', 'Y', and 'Z'. >>> find_correct_option('X', 'Y') == 'Z' >>> find_correct_option('Y', 'Z') == 'X' >>> find_correct_option('X', 'Z') == 'Y'","solution":"def find_correct_option(P, Q): Given two incorrect options P and Q, returns the correct option. options = {'X', 'Y', 'Z'} incorrect_options = {P, Q} correct_option = options - incorrect_options return correct_option.pop()"},{"question":"def maximize_fresh_days(n: int, C: int, fruits: List[Tuple[int, int]]) -> int: Given the number of types of fruits, cooling capacity per day, and the list of fruits with their cooling factors and maximum fresh days, this function returns the maximum number of days that any fruit can be sold fresh. Args: n : int : the number of types of fruits C : int : the cooling capacity per day fruits : list : a list of tuples (cᵢ, dᵢ) where cᵢ is the cooling factor, and dᵢ is the max days Returns: int : the maximum number of days any fruit can be sold fresh Examples: >>> maximize_fresh_days(3, 10, [(3, 5), (2, 7), (5, 4)]) 7 >>> maximize_fresh_days(1, 10, [(3, 5)]) 5","solution":"def maximize_fresh_days(n, C, fruits): Given the number of types of fruits, cooling capacity per day, and the list of fruits with their cooling factors and maximum fresh days, this function returns the maximum number of days that any fruit can be sold fresh. Args: n : int : the number of types of fruits C : int : the cooling capacity per day fruits : list : a list of tuples (cᵢ, dᵢ) where cᵢ is the cooling factor, and dᵢ is the max days Returns: int : the maximum number of days any fruit can be sold fresh max_days = 0 for cooling_factor, fresh_days in fruits: if cooling_factor <= C: max_days = max(max_days, fresh_days) return max_days"},{"question":"def gcd(a: int, b: int) -> int: Returns the greatest common divisor of a and b using the Euclidean algorithm. >>> gcd(48, 18) 6 >>> gcd(100, 100) 100 >>> gcd(25, 100) 25 >>> gcd(13, 17) 1 >>> gcd(1234567890, 987654321) 9","solution":"def gcd(a, b): Returns the greatest common divisor of a and b using the Euclidean algorithm. while a != b: if a > b: a -= b else: b -= a return a"},{"question":"def preprocess_heights(heights): Preprocess the heights array to support efficient range maximum queries. Uses a sparse table data structure for O(1) range maximum queries with O(n log n) preprocessing. :param heights: List of integers representing the heights of the buildings. :return: Sparse table for range maximum queries. def range_max_query(sparse_table, left, right): Answer a range maximum query using the preprocessed sparse table. :param sparse_table: Preprocessed sparse table for range maximum queries. :param left: Left index of the range (inclusive). :param right: Right index of the range (inclusive). :return: Maximum height in the specified range. def process_queries(heights, queries): Process multiple range maximum queries for building heights. :param heights: List of integers representing the heights of the buildings. :param queries: List of tuples where each tuple contains two integers (left, right). :return: List of integers where each integer is the result of a range maximum query. def test_preprocess_heights(): heights = [1, 5, 4, 3, 8, 6] sparse_table = preprocess_heights(heights) assert sparse_table[0][0] == 1 assert sparse_table[1][0] == 5 assert sparse_table[2][0] == 4 assert sparse_table[3][0] == 3 assert sparse_table[4][0] == 8 assert sparse_table[5][0] == 6 assert sparse_table[0][1] == 5 assert sparse_table[1][1] == 5 assert sparse_table[2][1] == 4 assert sparse_table[3][1] == 8 assert sparse_table[4][1] == 8 def test_range_max_query(): heights = [1, 5, 4, 3, 8, 6] sparse_table = preprocess_heights(heights) assert range_max_query(sparse_table, 0, 2) == 5 assert range_max_query(sparse_table, 1, 4) == 8 assert range_max_query(sparse_table, 2, 5) == 8 assert range_max_query(sparse_table, 0, 5) == 8 def test_process_queries(): heights = [1, 5, 4, 3, 8, 6] queries = [(1, 3), (2, 5), (3, 6)] assert process_queries(heights, queries) == [5, 8, 8] def test_single_building(): heights = [10] queries = [(1, 1)] assert process_queries(heights, queries) == [10] def test_entire_range(): heights = [1, 9, 3, 4, 5] queries = [(1, 5)] assert process_queries(heights, queries) == [9]","solution":"def preprocess_heights(heights): Preprocess the heights array to support efficient range maximum queries. Uses a sparse table data structure for O(1) range maximum queries with O(n log n) preprocessing. :param heights: List of integers representing the heights of the buildings. :return: Sparse table for range maximum queries. import math n = len(heights) max_log = math.floor(math.log2(n)) + 1 sparse_table = [[0] * max_log for _ in range(n)] for i in range(n): sparse_table[i][0] = heights[i] j = 1 while (1 << j) <= n: i = 0 while (i + (1 << j) - 1) < n: sparse_table[i][j] = max(sparse_table[i][j-1], sparse_table[i + (1 << (j-1))][j-1]) i += 1 j += 1 return sparse_table def range_max_query(sparse_table, left, right): Answer a range maximum query using the preprocessed sparse table. :param sparse_table: Preprocessed sparse table for range maximum queries. :param left: Left index of the range (inclusive). :param right: Right index of the range (inclusive). :return: Maximum height in the specified range. import math length = right - left + 1 j = math.floor(math.log2(length)) return max(sparse_table[left][j], sparse_table[right - (1 << j) + 1][j]) def process_queries(heights, queries): Process multiple range maximum queries for building heights. :param heights: List of integers representing the heights of the buildings. :param queries: List of tuples where each tuple contains two integers (left, right). :return: List of integers where each integer is the result of a range maximum query. sparse_table = preprocess_heights(heights) results = [] for left, right in queries: results.append(range_max_query(sparse_table, left - 1, right - 1)) return results"},{"question":"def unique_paths(n: int, m: int) -> int: Returns the number of unique paths from the top-left to the bottom-right corner of a grid. The robot can only move either right or down at any point in time. >>> unique_paths(3, 7) 28 >>> unique_paths(2, 3) 3 >>> unique_paths(1, 1) 1 >>> unique_paths(3, 3) 6 >>> unique_paths(10, 10) 48620 >>> unique_paths(100, 100) 22750883079422934966181954039568885395604168260154104734000 >>> unique_paths(1, 100) 1 >>> unique_paths(100, 1) 1","solution":"def unique_paths(n, m): Returns the number of unique paths from the top-left to the bottom-right corner of a grid. The robot can only move either right or down at any point in time. # Create a 2D grid with n rows and m columns filled with ones dp = [[1] * m for _ in range(n)] # Compute number of ways for each cell for i in range(1, n): for j in range(1, m): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[n-1][m-1]"},{"question":"def subarray_sums(arr, queries): Given an array and a list of queries, compute the sum of elements in each subarray specified by the queries. Parameters: arr (list[int]): The array of integers. queries (list[tuple[int, int]]): The list of queries, each defined by a tuple (L, R). Returns: list[int]: A list of sums for each subarray specified by the queries. Example: >>> arr = [1, 2, 3, 4, 5] >>> queries = [(1, 3), (2, 4), (1, 5)] >>> subarray_sums(arr, queries) [6, 9, 15]","solution":"def subarray_sums(arr, queries): Given an array and a list of queries, compute the sum of elements in each subarray specified by the queries. Parameters: arr (list[int]): The array of integers. queries (list[tuple[int, int]]): The list of queries, each defined by a tuple (L, R). Returns: list[int]: A list of sums for each subarray specified by the queries. # Precompute prefix sums n = len(arr) prefix_sums = [0] * (n + 1) for i in range(n): prefix_sums[i + 1] = prefix_sums[i] + arr[i] # Answer each query using the prefix sums results = [] for L, R in queries: sum_subarray = prefix_sums[R] - prefix_sums[L - 1] results.append(sum_subarray) return results"},{"question":"def spiral_traverse(matrix: List[List[int]]) -> List[int]: Returns a list of elements in the matrix in spiral order. >>> spiral_traverse([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) [1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10] >>> spiral_traverse([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]) [1, 2, 3, 6, 9, 12, 11, 10, 7, 4, 5, 8] >>> spiral_traverse([[3, 2, 1]]) [3, 2, 1] >>> spiral_traverse([[1], [2], [3]]) [1, 2, 3] >>> spiral_traverse([]) [] >>> spiral_traverse([[42]]) [42] >>> spiral_traverse([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15]]) [1, 2, 3, 4, 5, 10, 15, 14, 13, 12, 11, 6, 7, 8, 9]","solution":"def spiral_traverse(matrix): Returns a list of elements in the matrix in spiral order. result = [] if not matrix: return result top, bottom, left, right = 0, len(matrix) - 1, 0, len(matrix[0]) - 1 while top <= bottom and left <= right: # Traverse from left to right on the top row for i in range(left, right + 1): result.append(matrix[top][i]) top += 1 # Traverse from top to bottom on the right column for i in range(top, bottom + 1): result.append(matrix[i][right]) right -= 1 if top <= bottom: # Traverse from right to left on the bottom row for i in range(right, left - 1, -1): result.append(matrix[bottom][i]) bottom -= 1 if left <= right: # Traverse from bottom to top on the left column for i in range(bottom, top - 1, -1): result.append(matrix[i][left]) left += 1 return result"},{"question":"def find_kth_smallest(A: List[int], B: List[int], k: int) -> int: Given two sorted arrays A and B, with lengths |A| and |B| respectively, finds the kth smallest element among the union of these arrays. The union of A and B is defined as a new set that contains all elements from both arrays, sorted in non-decreasing order. The arrays may contain duplicates. >>> find_kth_smallest([1, 3, 5, 7, 9], [2, 4, 6, 8], 5) 5 >>> find_kth_smallest([1, 3, 8], [2, 4, 9], 4) 4 from solution import find_kth_smallest def test_example1(): A = [1, 3, 5, 7, 9] B = [2, 4, 6, 8] k = 5 assert find_kth_smallest(A, B, k) == 5 def test_example2(): A = [1, 3, 8] B = [2, 4, 9] k = 4 assert find_kth_smallest(A, B, k) == 4 def test_k_is_1(): A = [1, 2, 3] B = [4, 5, 6] k = 1 assert find_kth_smallest(A, B, k) == 1 def test_k_is_lenA_plus_lenB(): A = [1, 2, 3] B = [4, 5, 6] k = 6 assert find_kth_smallest(A, B, k) == 6 def test_single_element_in_A(): A = [2] B = [1, 3, 4, 5] k = 3 assert find_kth_smallest(A, B, k) == 3 def test_single_element_in_B(): A = [1, 2, 3, 4] B = [5] k = 4 assert find_kth_smallest(A, B, k) == 4 def test_same_elements_in_A_and_B(): A = [1, 2, 2, 2, 3] B = [2, 2, 2, 3] k = 5 assert find_kth_smallest(A, B, k) == 2 def test_duplicates_within_arrays(): A = [1, 1, 3, 5] B = [1, 2, 2, 6] k = 4 assert find_kth_smallest(A, B, k) == 2 def test_large_k_value(): A = [1, 2, 3, 4, 5] B = [6, 7, 8, 9, 10] k = 9 assert find_kth_smallest(A, B, k) == 9","solution":"def find_kth_smallest(A, B, k): Finds the k-th smallest element in the union of two sorted arrays A and B. def kth_smallest(A, B, k): lenA, lenB = len(A), len(B) # Ensure A is the smaller array if lenA > lenB: return kth_smallest(B, A, k) # Base cases if lenA == 0: return B[k-1] if k == 1: return min(A[0], B[0]) i = min(lenA, k // 2) j = min(lenB, k // 2) if A[i-1] > B[j-1]: return kth_smallest(A, B[j:], k - j) else: return kth_smallest(A[i:], B, k - i) return kth_smallest(A, B, k)"},{"question":"def is_robot_back_to_origin(moves: str) -> str: Determines if the robot returns to the origin after the sequence of moves. >>> is_robot_back_to_origin(\\"UDLR\\") \\"YES\\" >>> is_robot_back_to_origin(\\"UUDDLRLR\\") \\"YES\\" >>> is_robot_back_to_origin(\\"UDDLU\\") \\"NO\\"","solution":"def is_robot_back_to_origin(moves): Determines if the robot returns to the origin after the sequence of moves. x, y = 0, 0 for move in moves: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 return \\"YES\\" if x == 0 and y == 0 else \\"NO\\""},{"question":"def has_two_sum(nums: List[int], target: int) -> bool: Determine if there are two distinct elements in the array, whose sum is equal to the target integer. Returns True if such a pair exists, otherwise False. >>> has_two_sum([2, 7, 11, 15], 9) True >>> has_two_sum([3, 2, 4], 6) True >>> has_two_sum([3, 3], 6) True >>> has_two_sum([1, 2, 3], 7) False","solution":"def has_two_sum(nums, target): Returns True if there are two distinct elements in the array whose sum is equal to the target integer; otherwise, returns False. :param nums: List of integers :param target: Target sum integer :return: Boolean indicating if there are two distinct elements whose sum equals the target integer seen = set() for num in nums: if target - num in seen: return True seen.add(num) return False"},{"question":"def array_gaps(arr): Calculate the gaps between each pair of consecutive integers in the list. >>> array_gaps([1, 3, 6, 10]) [2, 3, 4] >>> array_gaps([5, 5, 5, 5]) [0, 0, 0] >>> array_gaps([10, 7, 4, 0]) [3, 3, 4]","solution":"def array_gaps(arr): Calculate the gaps between each pair of consecutive integers in the list. Args: arr (list of int): A list of integers. Returns: list of int: A list containing the absolute gaps between each pair of consecutive integers. gaps = [] # Initialize an empty list to store the gaps for i in range(len(arr) - 1): gap = abs(arr[i] - arr[i+1]) # Calculate the gap between consecutive elements gaps.append(gap) # Append the gap to the 'gaps' list return gaps # Return the list of gaps # Example usage: print(array_gaps([1, 3, 6, 10])) # Output: [2, 3, 4] print(array_gaps([5, 5, 5, 5])) # Output: [0, 0, 0] print(array_gaps([10, 7, 4, 0])) # Output: [3, 3, 4]"},{"question":"def is_possible_in_series(n: int) -> str: Determine if the given number \`n\` can appear in Sara's series. If it can, return \\"possible\\", otherwise return \\"impossible\\". >>> is_possible_in_series(0) \\"possible\\" >>> is_possible_in_series(1) \\"possible\\" >>> is_possible_in_series(2) \\"impossible\\" >>> is_possible_in_series(1000000000000) \\"impossible\\" >>> is_possible_in_series(123) \\"impossible\\" >>> is_possible_in_series(0) \\"possible\\" >>> is_possible_in_series(1) \\"possible\\"","solution":"def is_possible_in_series(n): Determine if the number n can appear in Sara's series. if n == 0 or n == 1: return \\"possible\\" return \\"impossible\\""},{"question":"def max_sum_no_same_column(grid: List[List[int]]) -> int: Given a 2D grid, find the maximum possible sum of points obtained by selecting one cell from each row such that no two cells are in the same column. :param grid: List[List[int]], 2D array representing the grid :return: int, maximum possible sum under the given constraints >>> max_sum_no_same_column([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 15 >>> max_sum_no_same_column([ ... [1, -1], ... [-1, 3] ... ]) == 4 >>> max_sum_no_same_column([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) == 34","solution":"from itertools import permutations def max_sum_no_same_column(grid): Given a 2D grid, find the maximum possible sum of points obtained by selecting one cell from each row such that no two cells are in the same column. :param grid: List[List[int]], 2D array representing the grid :return: int, maximum possible sum under the given constraints N = len(grid) M = len(grid[0]) max_sum = float('-inf') for cols in permutations(range(M), N): current_sum = 0 for i in range(N): current_sum += grid[i][cols[i]] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def sum_even_numbers(n: int) -> int: Returns the sum of all even numbers from 1 to n (inclusive). If n is less than 1, returns 0. >>> sum_even_numbers(0) 0 >>> sum_even_numbers(-5) 0 >>> sum_even_numbers(2) 2 >>> sum_even_numbers(10) 30 >>> sum_even_numbers(15) 56 >>> sum_even_numbers(1) 0","solution":"def sum_even_numbers(n): Returns the sum of all even numbers from 1 to n (inclusive). If n is less than 1, returns 0. if n < 1: return 0 return sum(i for i in range(1, n + 1) if i % 2 == 0)"},{"question":"def minOperationsToAlternate(N: int, s: str) -> int: Returns the minimum number of operations required to make the string alternating. Parameters: N (int): The length of the binary string. s (str): The binary string. Returns: int: The minimum number of operations. >>> minOperationsToAlternate(3, \\"010\\") 0 >>> minOperationsToAlternate(5, \\"11110\\") 2","solution":"def minOperationsToAlternate(N, s): Returns the minimum number of operations required to make the string alternating. Parameters: N (int): The length of the binary string. s (str): The binary string. Returns: int: The minimum number of operations. pattern1 = \\"01\\" * ((N + 1) // 2) pattern2 = \\"10\\" * ((N + 1) // 2) count1 = count2 = 0 for i in range(N): if s[i] != pattern1[i]: count1 += 1 if s[i] != pattern2[i]: count2 += 1 return min(count1, count2)"},{"question":"def longest_subarray_with_sum(arr, target): Returns the length of the longest subarray whose sum is equal to the target value. >>> longest_subarray_with_sum([-2, -1, 2, 1, 0, 2], 3) == 3 >>> longest_subarray_with_sum([1, -1, 5, -2, 3], 3) == 4 >>> longest_subarray_with_sum([1, 2, 3, 4, 5], 15) == 5 >>> longest_subarray_with_sum([1, 2, 1, 2, 1], 3) == 2 >>> longest_subarray_with_sum([], 0) == 0 >>> longest_subarray_with_sum([1, 2, 3], 7) == 0 >>> longest_subarray_with_sum([1, -1, 1, -1, 1, -1], 0) == 6","solution":"def longest_subarray_with_sum(arr, target): Returns the length of the longest subarray whose sum is equal to the target value. sum_map = {0: -1} # Dictionary to store the first occurrence of each prefix sum current_sum = 0 max_length = 0 for i in range(len(arr)): current_sum += arr[i] if current_sum - target in sum_map: max_length = max(max_length, i - sum_map[current_sum - target]) if current_sum not in sum_map: sum_map[current_sum] = i return max_length"},{"question":"def longest_consecutive_subsequence(arr: List[int]) -> int: Returns the length of the longest subsequence with consecutive integers. >>> longest_consecutive_subsequence([1, 9, 3, 10, 4, 20, 2]) 4 >>> longest_consecutive_subsequence([8, 20, 7, 30, 6]) 3 >>> longest_consecutive_subsequence([10]) 1 >>> longest_consecutive_subsequence([]) 0 >>> longest_consecutive_subsequence([100, 200, 300]) 1 >>> longest_consecutive_subsequence([2, 2, 2, 2]) 1 >>> longest_consecutive_subsequence([10, 5, 6, 12, 7, 8, 9, 11]) 8","solution":"def longest_consecutive_subsequence(arr): Returns the length of the longest subsequence with consecutive integers. :param arr: List of integers :return: Length of the longest subsequence with consecutive integers if not arr: return 0 arr_set = set(arr) max_len = 0 for num in arr: if num - 1 not in arr_set: current_num = num current_len = 1 while current_num + 1 in arr_set: current_num += 1 current_len += 1 max_len = max(max_len, current_len) return max_len"},{"question":"def can_sort_by_reversing_subarray(n: int, sequence: List[int]) -> str: Determines if it's possible to make the sequence non-decreasing by reversing any number of subarrays. >>> can_sort_by_reversing_subarray(4, [1, 2, 3, 4]) == \\"YES\\" >>> can_sort_by_reversing_subarray(5, [4, 3, 2, 1, 5]) == \\"YES\\" >>> can_sort_by_reversing_subarray(5, [1, 3, 5, 4, 2]) == \\"NO\\" pass # Your code here # Test cases def test_already_non_decreasing(): assert can_sort_by_reversing_subarray(4, [1, 2, 3, 4]) == \\"YES\\" def test_reverse_subarray_once(): assert can_sort_by_reversing_subarray(5, [4, 3, 2, 1, 5]) == \\"YES\\" def test_unable_to_sort(): assert can_sort_by_reversing_subarray(5, [1, 3, 5, 4, 2]) == \\"NO\\" def test_single_element(): assert can_sort_by_reversing_subarray(1, [42]) == \\"YES\\" def test_all_elements_the_same(): assert can_sort_by_reversing_subarray(3, [5, 5, 5]) == \\"YES\\" def test_two_elements_reversed(): assert can_sort_by_reversing_subarray(2, [2, 1]) == \\"YES\\" def test_large_sequence(): assert can_sort_by_reversing_subarray(6, [10, 20, 30, 25, 15, 35]) == \\"NO\\"","solution":"def can_sort_by_reversing_subarray(n, sequence): Determines if it's possible to make the sequence non-decreasing by reversing any number of subarrays. # Check if the sequence is already non-decreasing if sequence == sorted(sequence): return \\"YES\\" # Find the first index from the left where the sequence is not increasing left = 0 while left < n - 1 and sequence[left] <= sequence[left + 1]: left += 1 # Find the first index from the right where the sequence is not increasing right = n - 1 while right > 0 and sequence[right] >= sequence[right - 1]: right -= 1 # Reverse the elements between left and right (inclusive) subarray_reversed = sequence[:left] + sequence[left:right + 1][::-1] + sequence[right + 1:] # Check if the whole sequence is non-decreasing after reversing the subarray if subarray_reversed == sorted(subarray_reversed): return \\"YES\\" return \\"NO\\""},{"question":"def min_planks(L: int, plank_lengths: List[int]) -> Union[int, str]: Determines the minimum number of planks required to build a fence of length L using the given plank lengths. If it is not possible to build the fence with the given lengths, returns \\"IMPOSSIBLE\\". >>> min_planks(15, [1, 4, 5, 6]) 3 >>> min_planks(7, [2, 3, 5]) 2 >>> min_planks(7, [2, 4, 6]) 'IMPOSSIBLE' >>> min_planks(9, [3]) 3 >>> min_planks(5, [1, 5]) 1 >>> min_planks(0, [1, 2, 3]) 0","solution":"def min_planks(L, plank_lengths): Returns the minimum number of planks required to build a fence of length L using given plank lengths. If it is not possible to build the fence with the given lengths, returns \\"IMPOSSIBLE\\". dp = [float('inf')] * (L + 1) dp[0] = 0 # 0 planks needed to build length 0 for length in range(1, L + 1): for plank in plank_lengths: if plank <= length: dp[length] = min(dp[length], dp[length - plank] + 1) return dp[L] if dp[L] != float('inf') else \\"IMPOSSIBLE\\""},{"question":"def sum_of_digits(num): Returns the sum of the digits of a given number. pass # Implement this function def find_correct_page_number(test_cases): For each test case, calculates the product of all integers in the list, and then returns the sum of the digits of the resulting product. >>> test_cases = [ ... (3, [1, 2, 3]), ... (4, [4, 5, 6, 7]) ... ] >>> find_correct_page_number(test_cases) [6, 12] pass # Implement this function import pytest def test_example_cases(): test_cases = [ (3, [1, 2, 3]), (4, [4, 5, 6, 7]) ] assert find_correct_page_number(test_cases) == [6, 12] def test_single_number(): test_cases = [ (1, [123456]), (1, [999999]), (1, [10]) ] assert find_correct_page_number(test_cases) == [21, 54, 1] def test_large_numbers(): test_cases = [ (2, [1000000, 1000000]), # Product would be 1000000000000 -> sum of digits 1 (3, [10, 100, 1000]), # Product would be 1000000 -> sum of digits 1 (4, [1, 2, 3, 1000000]) # Product would be 6000000 -> sum of digits 6 ] assert find_correct_page_number(test_cases) == [1, 1, 6] def test_small_numbers(): test_cases = [ (2, [1, 2]), (2, [2, 2]), (2, [3, 2]), ] assert find_correct_page_number(test_cases) == [2, 4, 6] def test_mixed_numbers(): test_cases = [ (3, [1, 2, 1000000]), # Product 2000000 -> sum of digits 2 (3, [5, 10, 100]), # Product 5000 -> sum of digits 5 (2, [25, 4]), # Product 100 -> sum of digits 1 ] assert find_correct_page_number(test_cases) == [2, 5, 1] if __name__ == \\"__main__\\": pytest.main()","solution":"def sum_of_digits(num): Returns the sum of the digits of a given number. return sum(int(digit) for digit in str(num)) def find_correct_page_number(test_cases): For each test case, calculates the product of all integers in the list, and then returns the sum of the digits of the resulting product. results = [] for case in test_cases: n, numbers = case product = 1 for number in numbers: product *= number results.append(sum_of_digits(product)) return results"},{"question":"def three_sum(nums): Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, j != k, and k != i, and nums[i] + nums[j] + nums[k] == 0. The solution must not contain duplicate triplets. >>> three_sum([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] >>> three_sum([]) [] >>> three_sum([0]) []","solution":"def three_sum(nums): Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, j != k, and k != i, and nums[i] + nums[j] + nums[k] == 0. The solution does not contain duplicate triplets. Args: nums (list): List of integers. Returns: list: List of unique triplets that sum up to zero. nums.sort() result = [] for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, len(nums) - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == 0: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return result"},{"question":"def first_missing_positive(nums): Function to find the first missing positive integer in a list. >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([1, 2, 0, 2, 5]) 3 >>> first_missing_positive([1, 3, 4, 2]) 5 >>> first_missing_positive([7, 8, 9, 11, 12]) 1 >>> first_missing_positive([1]) 2 >>> first_missing_positive([2]) 1 >>> first_missing_positive([0, 0, 0, 0, 0]) 1 >>> first_missing_positive([-1, -2, -3, -4]) 1 >>> first_missing_positive([5, 2, 8, 3, 7, 1, 11]) 4","solution":"def first_missing_positive(nums): Function to find the first missing positive integer in a list. n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: correct_idx = nums[i] - 1 nums[i], nums[correct_idx] = nums[correct_idx], nums[i] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"def max_value_stones(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[int]: Calculate the maximum value of stones Ali Baba can collect for given test cases. Args: T (int): Number of test cases. test_cases (List[Tuple[int, int, List[Tuple[int, int]]]]): List of tuples, where each tuple represents a test case with the number of stones (N), maximum weight (W), and a list of tuples containing the weight and value of each stone. Returns: List[int]: List of maximum values of stones that can be collected for each test case. Example: >>> max_value_stones(1, [(3, 50, [(10, 60), (20, 100), (30, 120)])]) [220] >>> max_value_stones(2, [(3, 50, [(10, 60), (20, 100), (30, 120)]), (4, 50, [(10, 60), (20, 100), (30, 120), (40, 160)])]) [220, 220]","solution":"def max_value_stones(T, test_cases): def knapsack(N, W, weights, values): dp = [0] * (W + 1) for i in range(N): for w in range(W, weights[i] - 1, -1): dp[w] = max(dp[w], dp[w - weights[i]] + values[i]) return dp[W] results = [] for case in test_cases: N, W, stones = case weights = [stone[0] for stone in stones] values = [stone[1] for stone in stones] results.append(knapsack(N, W, weights, values)) return results"},{"question":"def min_moves_to_equal_elements(n: int, nums: List[int]) -> int: Returns the minimum number of moves required to make all elements in the list equal, where a move is defined as incrementing or decrementing a single element by 1. >>> min_moves_to_equal_elements(4, [5, 5, 5, 5]) 0 >>> min_moves_to_equal_elements(1, [10]) 0 >>> min_moves_to_equal_elements(3, [1, 2, 3]) 2 >>> min_moves_to_equal_elements(3, [3, 2, 1]) 2 >>> min_moves_to_equal_elements(4, [1, 2, 3, 4]) 4 >>> min_moves_to_equal_elements(6, [1, 3, 4, 2, 2, 3]) 5 >>> min_moves_to_equal_elements(3, [100, 900, 500]) 800 >>> min_moves_to_equal_elements(3, [5, 8, 9]) 4","solution":"def min_moves_to_equal_elements(n, nums): Returns the minimum number of moves required to make all elements in the list equal, where a move is defined as incrementing or decrementing a single element by 1. if n <= 1: return 0 nums.sort() median = nums[n // 2] moves = sum(abs(num - median) for num in nums) return moves"},{"question":"def process_string(t: int, S: str): Perform a specific action on the string S based on the value of t. Args: t (int): An integer representing the action to perform (1 <= t <= 5). S (str): A string containing lowercase letters. Returns: str or int: The result of the action performed on the string S. Actions: 1. Print \\"Palindrome\\" if S is a palindrome, or \\"Not Palindrome\\" otherwise. 2. Print the character that appears the most frequently in S. If there is a tie, print the lexicographically smallest character. 3. Print \\"Yes\\" if S contains at least one instance of every vowel (\\"a\\", \\"e\\", \\"i\\", \\"o\\", \\"u\\"), or \\"No\\" otherwise. 4. Print the longest contiguous substring of S where all characters are the same. If there are multiple, print the one that appears first. 5. Print the total number of distinct substrings in S. Examples: >>> process_string(1, 'racecar') 'Palindrome' >>> process_string(2, 'bbaacc') 'a' >>> process_string(3, 'aeioussss') 'Yes' >>> process_string(4, 'aaabbbaaa') 'aaa' >>> process_string(5, 'abc') 6","solution":"def process_string(t, S): def is_palindrome(s): return s == s[::-1] def most_frequent_character(s): frequency = {} for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 max_freq = max(frequency.values()) most_freq_chars = [char for char, freq in frequency.items() if freq == max_freq] return min(most_freq_chars) def contains_all_vowels(s): vowels = set(\\"aeiou\\") return vowels.issubset(set(s)) def longest_contiguous_substring(s): max_len = 1 current_len = 1 longest_substr = s[0] for i in range(1, len(s)): if s[i] == s[i-1]: current_len += 1 if current_len > max_len: max_len = current_len longest_substr = s[i] * current_len else: current_len = 1 return longest_substr def count_distinct_substrings(s): substrings = set() for i in range(len(s)): for j in range(i + 1, len(s) + 1): substrings.add(s[i:j]) return len(substrings) if t == 1: return \\"Palindrome\\" if is_palindrome(S) else \\"Not Palindrome\\" elif t == 2: return most_frequent_character(S) elif t == 3: return \\"Yes\\" if contains_all_vowels(S) else \\"No\\" elif t == 4: return longest_contiguous_substring(S) elif t == 5: return count_distinct_substrings(S)"},{"question":"def char_frequency(text: str) -> dict: Returns a dictionary with the frequency of each alphabetic character in the string. The function ignores case and non-alphabetic characters. Args: text (str): The input text string Returns: dict: A dictionary with characters as keys and their frequency as values. Example: >>> char_frequency(\\"Hello, World!\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1}","solution":"def char_frequency(text): Returns a dictionary with the frequency of each alphabetic character in the string. The function ignores case and non-alphabetic characters. frequency = {} for char in text.lower(): if char.isalpha(): if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"from datetime import datetime def check_expiration(current_date, expiration_date): Determines whether a given product is expired based on the current date. :param current_date: string representing the current date in the format \\"DD-MM-YYYY\\" :param expiration_date: string representing the expiration date in the format \\"DD-MM-YYYY\\" :return: \\"Expired\\" if the product is expired, \\"Not Expired\\" otherwise >>> check_expiration(\\"15-10-2023\\", \\"14-10-2023\\") \\"Expired\\" >>> check_expiration(\\"15-10-2023\\", \\"16-10-2023\\") \\"Not Expired\\" >>> check_expiration(\\"15-10-2023\\", \\"15-10-2023\\") \\"Not Expired\\" >>> check_expiration(\\"15-10-2023\\", \\"15-10-2050\\") \\"Not Expired\\" >>> check_expiration(\\"15-10-2023\\", \\"15-10-2000\\") \\"Expired\\"","solution":"from datetime import datetime def check_expiration(current_date, expiration_date): Checks if the product is expired based on the current date. :param current_date: string representing the current date in the format \\"DD-MM-YYYY\\" :param expiration_date: string representing the expiration date in the format \\"DD-MM-YYYY\\" :return: \\"Expired\\" if the product is expired, \\"Not Expired\\" otherwise current_date_obj = datetime.strptime(current_date, '%d-%m-%Y') expiration_date_obj = datetime.strptime(expiration_date, '%d-%m-%Y') if expiration_date_obj < current_date_obj: return \\"Expired\\" else: return \\"Not Expired\\""},{"question":"def min_subarrays_to_partition(n: int, k: int, colors: List[int]) -> int: Determine the minimum number of contiguous subarrays such that each subarray contains all colors from 1 to k exactly once. Parameters: n (int): Length of the sequence. k (int): Number of unique colors. colors (List[int]): Sequence of colors. Returns: int: Minimum number of contiguous subarrays. Examples: >>> min_subarrays_to_partition(10, 3, [1, 3, 2, 1, 2, 3, 1, 3, 2, 1]) 3 >>> min_subarrays_to_partition(6, 2, [2, 1, 2, 1, 2, 1]) 3 from solution import min_subarrays_to_partition def test_example_1(): assert min_subarrays_to_partition(10, 3, [1, 3, 2, 1, 2, 3, 1, 3, 2, 1]) == 3 def test_example_2(): assert min_subarrays_to_partition(6, 2, [2, 1, 2, 1, 2, 1]) == 3 def test_single_color(): assert min_subarrays_to_partition(5, 1, [1, 1, 1, 1, 1]) == 5 def test_all_same_color(): assert min_subarrays_to_partition(4, 2, [1, 1, 1, 1]) == 0 def test_multiple_subarrays(): assert min_subarrays_to_partition(12, 4, [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]) == 3 def test_large_k(): assert min_subarrays_to_partition(10, 10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 1","solution":"def min_subarrays_to_partition(n, k, colors): Determine the minimum number of contiguous subarrays such that each subarray contains all colors from 1 to k exactly once. Parameters: n (int): Length of the sequence. k (int): Number of unique colors. colors (List[int]): Sequence of colors. Returns: int: Minimum number of contiguous subarrays. count = 0 required_colors = set(range(1, k + 1)) current_colors = set() for color in colors: current_colors.add(color) if current_colors == required_colors: count += 1 current_colors = set() return count"},{"question":"def is_subset_sum_possible(target, nums): Determines if there exists a subset of the given list of non-negative integers such that the sum of the subset is equal to the target value. :param target: int, the target sum :param nums: List[int], list of non-negative integers :return: str, \\"YES\\" if such subset exists, otherwise \\"NO\\" >>> is_subset_sum_possible(9, [3, 34, 4, 12, 5, 2]) 'YES' >>> is_subset_sum_possible(30, [3, 34, 4, 12, 5, 2]) 'NO' >>> is_subset_sum_possible(0, [1, 2, 3, 4]) 'YES' >>> is_subset_sum_possible(5, [5]) 'YES' >>> is_subset_sum_possible(5, [3]) 'NO' >>> is_subset_sum_possible(1, []) 'NO' >>> is_subset_sum_possible(250, [100, 150, 3, 33, 79, 45, 67, 90, 111, 123]) 'YES'","solution":"def is_subset_sum_possible(target, nums): Determines if there exists a subset of the given list of non-negative integers such that the sum of the subset is equal to the target value. :param target: int, the target sum :param nums: List[int], list of non-negative integers :return: str, \\"YES\\" if such subset exists, otherwise \\"NO\\" n = len(nums) subset = [[False for _ in range(target + 1)] for _ in range(n + 1)] for i in range(n + 1): subset[i][0] = True for i in range(1, n + 1): for j in range(1, target + 1): if nums[i - 1] <= j: subset[i][j] = subset[i - 1][j] or subset[i - 1][j - nums[i - 1]] else: subset[i][j] = subset[i - 1][j] return \\"YES\\" if subset[n][target] else \\"NO\\""},{"question":"def min_drivers_required(n, max_packages, packages_per_address): Return the minimum number of drivers required to deliver all packages in one day. :param n: int - Number of addresses :param max_packages: int - Maximum number of packages a driver can deliver per day :param packages_per_address: List[int] - List of number of packages per address :return: int - Minimum number of drivers required >>> min_drivers_required(5, 7, [2, 6, 4, 8, 3]) 4 >>> min_drivers_required(1, 100, [50]) 1 >>> min_drivers_required(4, 5, [5, 5, 5, 5]) 4 >>> min_drivers_required(3, 10, [15, 25, 40]) 8 >>> min_drivers_required(6, 10, [1, 2, 1, 2, 1, 2]) 1 >>> min_drivers_required(1000, 10000, [10000] * 1000) 1000","solution":"def min_drivers_required(n, max_packages, packages_per_address): Return the minimum number of drivers required to deliver all packages in one day. :param n: int - Number of addresses :param max_packages: int - Maximum number of packages a driver can deliver per day :param packages_per_address: List[int] - List of number of packages per address :return: int - Minimum number of drivers required total_packages = sum(packages_per_address) drivers_needed = (total_packages + max_packages - 1) // max_packages return drivers_needed"},{"question":"def smallest_missing_positive(arr): Function to find the smallest missing positive integer in an unsorted array. # Implement the function here def process_input(input_string): Processes the input string from multiple datasets into a list of lists. Each internal list represents a dataset. # Implement the function here def main(input_string): Main function to process the input and output the smallest missing positive integer for each dataset. # Implement the function here # Unit tests if __name__ == \\"__main__\\": from solution import smallest_missing_positive, process_input, main def test_smallest_missing_positive(): assert smallest_missing_positive([3, 4, -1, 1, 2, 6]) == 5 assert smallest_missing_positive([1, 2, 0, -6, 9, 10, 4, 3]) == 5 assert smallest_missing_positive([-1, -2, 0, 2, 3, 1]) == 4 assert smallest_missing_positive([]) == 1 assert smallest_missing_positive([1, 2, 3, 4, 5]) == 6 assert smallest_missing_positive([7, 8, 9, 11, 12]) == 1 def test_process_input(): assert process_input(\\"6 3 4 -1 1 2 6n8 1 2 0 -6 9 10 4 3\\") == [ [3, 4, -1, 1, 2, 6], [1, 2, 0, -6, 9, 10, 4, 3] ] assert process_input(\\"1 0n3 -1 -2 -3\\") == [ [0], [-1, -2, -3] ] assert process_input(\\"2 1 1000000n3 1 1 1\\") == [ [1, 1000000], [1, 1, 1] ] def test_main(): assert main(\\"6 3 4 -1 1 2 6n8 1 2 0 -6 9 10 4 3\\") == \\"5n5\\" assert main(\\"1 0n3 -1 -2 -3\\") == \\"1n1\\" assert main(\\"2 1 1000000n3 1 1 1\\") == \\"2n2\\" assert main(\\"3 1 1 1n5 -1 -2 -3 4 5\\") == \\"2n1\\"","solution":"def smallest_missing_positive(arr): Function to find the smallest missing positive integer in an unsorted array. s = set(arr) i = 1 while i in s: i += 1 return i def process_input(input_string): Processes the input string from multiple datasets into a list of lists. Each internal list represents a dataset. datasets = [] for line in input_string.strip().split('n'): parts = list(map(int, line.split())) n = parts[0] array = parts[1:n+1] datasets.append(array) return datasets def main(input_string): Main function to process the input and output the smallest missing positive integer for each dataset. datasets = process_input(input_string) results = [] for dataset in datasets: results.append(str(smallest_missing_positive(dataset))) return \\"n\\".join(results)"},{"question":"def find_pair_with_product(n, lst, k): Given a list of integers, find if there exists a pair of indices (i, j) such that i < j and the product of the elements at these indices is equal to a given integer k. If such a pair exists, return the indices (i, j) as a tuple. If no such pair exists, return -1. Args: n (int): Number of elements in the list. lst (list of int): List of integers. k (int): The product to find. Returns: tuple or int: A tuple (i, j) of indices if a pair is found, otherwise -1. Example: >>> find_pair_with_product(5, [2, 3, 7, 8, 4], 21) (1, 2) >>> find_pair_with_product(5, [2, 3, 7, 8, 4], 20) -1 >>> find_pair_with_product(5, [2, -3, 7, -8, 4], -56) (2, 3) >>> find_pair_with_product(3, [10**5, 10**5, 1], 10**10) (0, 1) >>> find_pair_with_product(4, [0, 1, 2, 3], 0) (0, 1) >>> find_pair_with_product(3, [2, 5, 1], 10) (0, 1) >>> find_pair_with_product(3, [1, 2, 3], 6) (1, 2)","solution":"def find_pair_with_product(n, lst, k): Given a list of integers, find if there exists a pair of indices (i, j) such that i < j and the product of the elements at these indices is equal to a given integer k. If such a pair exists, return the indices (i, j) as a tuple. If no such pair exists, return -1. Args: n (int): Number of elements in the list. lst (list of int): List of integers. k (int): The product to find. Returns: tuple or int: A tuple (i, j) of indices if a pair is found, otherwise -1. for i in range(n): for j in range(i + 1, n): if lst[i] * lst[j] == k: return (i, j) return -1"},{"question":"def find_minimum_in_range(n: int, q: int, arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: For each query, find the minimum integer in the subarray defined by the range [l, r]. :param n: Number of elements in the array :param q: Number of queries :param arr: List of integers representing the array :param queries: List of tuples (l, r) representing the ranges for the queries :return: List of integers representing the minimum value for each query >>> find_minimum_in_range(6, 3, [4, 6, 1, 5, 9, 2], [(1, 3), (4, 6), (2, 5)]) [1, 2, 1] >>> find_minimum_in_range(5, 2, [7, 2, 3, 0, 5], [(2, 4), (1, 5)]) [0, 0] >>> find_minimum_in_range(1, 1, [10], [(1, 1)]) [10] >>> find_minimum_in_range(4, 2, [5, 9, 1, 7], [(2, 2), (4, 4)]) [9, 7] >>> find_minimum_in_range(3, 1, [1000000000, 100000000, 10000000], [(1, 3)]) [10000000]","solution":"def find_minimum_in_range(n, q, arr, queries): For each query, find the minimum integer in the subarray defined by the range [l, r]. :param n: Number of elements in the array :param q: Number of queries :param arr: List of integers representing the array :param queries: List of tuples (l, r) representing the ranges for the queries :return: List of integers representing the minimum value for each query result = [] for l, r in queries: result.append(min(arr[l-1:r])) return result # Example usage: # n = 6 # q = 3 # arr = [4, 6, 1, 5, 9, 2] # queries = [(1, 3), (4, 6), (2, 5)] # find_minimum_in_range(n, q, arr, queries)"},{"question":"def sieve(N): Sieve of Eratosthenes algorithm to find all prime numbers up to N. Args: N (int): The upper limit to find prime numbers. Returns: List[int]: A list of all prime numbers up to N. primes = [True] * (N + 1) p = 2 while p * p <= N: if primes[p]: for i in range(p * p, N + 1, p): primes[i] = False p += 1 return [p for p in range(2, N + 1) if primes[p]] def sum_of_primes_in_range(N, L, R): Find the sum of all prime numbers ≤ N that are within the range [L, R]. Args: N (int): The upper limit to find prime numbers. L (int): The lower bound of the range. R (int): The upper bound of the range. Returns: int: The sum of prime numbers within the given range. # Implementation here def process_test_cases(test_cases): Process multiple test cases to find the sum of primes in specified ranges. Args: test_cases (List[Tuple[int, int, int]]): List of test cases where each test case is a tuple (N, L, R). Returns: List[int]: List of results for each test case. # Implementation here # Unit Test def test_case_1(): assert sum_of_primes_in_range(10, 2, 5) == 10 def test_case_2(): assert sum_of_primes_in_range(11, 3, 11) == 26 def test_case_3(): assert sum_of_primes_in_range(15, 10, 20) == 24 def test_case_4(): assert sum_of_primes_in_range(1, 1, 1) == 0 def test_case_5(): assert sum_of_primes_in_range(20, 1, 20) == 77 def test_process_test_cases(): test_cases = [(10, 2, 5), (11, 3, 11), (15, 10, 20)] assert process_test_cases(test_cases) == [10, 26, 24]","solution":"def sieve(N): primes = [True] * (N + 1) p = 2 while p * p <= N: if primes[p]: for i in range(p * p, N + 1, p): primes[i] = False p += 1 prime_numbers = [p for p in range(2, N + 1) if primes[p]] return prime_numbers def sum_of_primes_in_range(N, L, R): prime_numbers = sieve(N) return sum(p for p in prime_numbers if L <= p <= R) def process_test_cases(test_cases): results = [] for N, L, R in test_cases: results.append(sum_of_primes_in_range(N, L, R)) return results"},{"question":"def number_of_nice_subarrays(arr: List[int], k: int) -> int: Returns the number of nice subarrays with exactly k odd numbers. >>> number_of_nice_subarrays([1,1,2,1,1], 3) 2 >>> number_of_nice_subarrays([2,4,6], 1) 0 >>> number_of_nice_subarrays([2,2,2,1,2,2,1,2,2,2], 2) 16 >>> number_of_nice_subarrays([1], 1) 1 >>> number_of_nice_subarrays([2], 1) 0 >>> number_of_nice_subarrays([1,3,5,7], 2) 3 >>> number_of_nice_subarrays([2,4,6,8], 1) 0 >>> number_of_nice_subarrays([1,2,3,4,5], 6) 0","solution":"def number_of_nice_subarrays(arr, k): Returns the number of nice subarrays with exactly k odd numbers. def at_most_k_odd(arr, k): count = 0 left = 0 odd_count = 0 for right in range(len(arr)): if arr[right] % 2 == 1: odd_count += 1 while odd_count > k: if arr[left] % 2 == 1: odd_count -= 1 left += 1 count += right - left + 1 return count return at_most_k_odd(arr, k) - at_most_k_odd(arr, k - 1)"},{"question":"def sumOfDistinct(arr: List[int], n: int) -> int: Given a list of N integers, this function finds the sum of all distinct elements in the list. If an element appears more than once, it should only be added once to the sum. Returns the sum of these distinct elements. >>> sumOfDistinct([1, 2, 3, 2, 1], 5) 6 >>> sumOfDistinct([10, 20, 30, 20, 40, 50, 10], 7) 150","solution":"def sumOfDistinct(arr, n): This function returns the sum of distinct elements in the list. :param arr: List of integers :param n: Length of the list :return: Sum of distinct elements return sum(set(arr))"},{"question":"def rotateArray(arr, k): Rotates the array to the right by k places. Parameters: arr (list): The input array. k (int): The number of places to rotate the array. Returns: list: The array rotated to the right by k places.","solution":"def rotateArray(arr, k): Rotates the array to the right by k places. Parameters: arr (list): The input array. k (int): The number of places to rotate the array. Returns: list: The array rotated to the right by k places. if not arr: return arr n = len(arr) k = k % n # To account for k larger than the array length return arr[-k:] + arr[:-k]"},{"question":"def min_difference(T, test_cases): Calculate the minimized absolute difference between the sums of two piles of cards. Args: T (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of test cases, where each test case is a tuple containing an integer N (number of cards) and a list of integers (card numbers). Returns: List[int]: A list containing the minimized absolute difference for each test case. >>> T = 2 >>> test_cases = [(5, [3, 1, 4, 2, 2]), (4, [1, 2, 3, 4])] >>> min_difference(T, test_cases) [0, 0] >>> T = 1 >>> test_cases = [(6, [10, 20, 15, 5, 5, 40])] >>> min_difference(T, test_cases) [5]","solution":"def min_difference(T, test_cases): results = [] for case in test_cases: N, cards = case cards.sort() pile1, pile2 = 0, 0 for i in range(N - 1, -1, -1): if pile1 < pile2: pile1 += cards[i] else: pile2 += cards[i] results.append(abs(pile1 - pile2)) return results"},{"question":"def stepwise_bubble_sort(A): Step-wise Bubble Sort implementation. >>> stepwise_bubble_sort([34, 7, 23, 32, 5]) [5, 7, 23, 32, 34] >>> stepwise_bubble_sort([3, 1, -14, 8]) [-14, 1, 3, 8] >>> stepwise_bubble_sort([10, -2, 0, 5, 10]) [-2, 0, 5, 10, 10] >>> stepwise_bubble_sort([1]) [1] >>> stepwise_bubble_sort([-1, -2, -3, -4]) [-4, -3, -2, -1] pass def process_test_cases(T, test_cases): Process multiple test cases. >>> process_test_cases(2, [(5, [34, 7, 23, 32, 5]), (4, [3, 1, -14, 8])]) [[5, 7, 23, 32, 34], [-14, 1, 3, 8]] >>> process_test_cases(1, [(1, [1])]) [[1]] >>> process_test_cases(3, [(2, [2, 1]), (3, [3, 3, 3]), (4, [4, -4, 4, -4])]) [[1, 2], [3, 3, 3], [-4, -4, 4, 4]] pass","solution":"def stepwise_bubble_sort(A): Step-wise Bubble Sort implementation. N = len(A) for step in range(N, 0, -1): for i in range(N - step): if A[i] > A[i + step]: A[i], A[i + step] = A[i + step], A[i] # After reducing step size to 1, it transforms to classic Bubble Sort for step in range(N-1, 0, -1): for i in range(step): if A[i] > A[i + 1]: A[i], A[i + 1] = A[i + 1], A[i] return A def process_test_cases(T, test_cases): Process multiple test cases. results = [] for N, A in test_cases: sorted_array = stepwise_bubble_sort(A) results.append(sorted_array) return results"},{"question":"def is_isogram(string: str) -> bool: Determines whether the given string is an isogram. An isogram is a word or phrase without a repeating letter, consecutive or nonconsecutive. Ignore letter case and any spaces or hyphens. >>> is_isogram(\\"Dermatoglyphics\\") == True >>> is_isogram(\\"aba\\") == False >>> is_isogram(\\"moOse\\") == False >>> is_isogram(\\"six-year-old\\") == True >>> is_isogram(\\"\\") == True >>> is_isogram(\\"a-bc a\\") == False","solution":"def is_isogram(string): Determines whether the given string is an isogram. Parameters: string (str): The string to check. Returns: bool: True if the string is an isogram, False otherwise. # Normalize the string: remove spaces and hyphens, and convert to lowercase normalized_string = string.replace(\\" \\", \\"\\").replace(\\"-\\", \\"\\").lower() # Use a set to check for unique characters char_set = set() for char in normalized_string: if char in char_set: return False char_set.add(char) return True"},{"question":"def solve_network_routing(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[str]: Determine the minimal number of additional communication channels required to ensure that every server can reach every other server. Args: T: The number of test cases. test_cases: A list of tuples, where each tuple contains the number of servers (N), the number of existing communication channels (M), and a list of connections. Returns: A list of strings, where each string represents the result for a test case in the format \\"Case #x: y\\". >>> solve_network_routing(2, [(4, 2, [(1, 2), (2, 3)]), (5, 3, [(1, 2), (2, 3), (4, 5)])]) [\\"Case #1: 1\\", \\"Case #2: 1\\"] >>> solve_network_routing(1, [(1, 0, [])]) [\\"Case #1: 0\\"] >>> solve_network_routing(1, [(4, 6, [(1, 2), (2, 3), (3, 4), (4, 1), (1, 3), (2, 4)])]) [\\"Case #1: 0\\"] >>> solve_network_routing(1, [(6, 3, [(1, 2), (3, 4), (5, 6)])]) [\\"Case #1: 2\\"]","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def solve_network_routing(T, test_cases): results = [] for t in range(T): n, m, connections = test_cases[t] # Initialize union-find structures parent = list(range(n+1)) rank = [0] * (n+1) # Process existing connections for u, v in connections: union(parent, rank, u, v) # Find number of connected components components = len(set(find(parent, i) for i in range(1, n+1))) # Minimal number of channels required is the number of connection components - 1 results.append(f\\"Case #{t+1}: {components - 1}\\") return results # This function processes the input directly from the console def process_input(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) index = 1 test_cases = [] for _ in range(T): N = int(data[index]) M = int(data[index + 1]) connections = [] for i in range(M): u = int(data[index + 2 + 2*i]) v = int(data[index + 3 + 2*i]) connections.append((u, v)) index += 2 + 2 * M test_cases.append((N, M, connections)) results = solve_network_routing(T, test_cases) for result in results: print(result)"},{"question":"def canRepresentBST(arr: List[int], N: int) -> bool: Determine if the given array can represent the in-order traversal of a BST. :param arr: List[int], the array of integers :param N: int, size of the array :return: bool, True if it can represent the in-order traversal of a BST, False otherwise Examples: >>> canRepresentBST([1, 2, 3], 3) True >>> canRepresentBST([3, 2, 1], 3) False >>> canRepresentBST([1, 3, 2, 4], 4) False","solution":"def canRepresentBST(arr, N): Determine if the given array can represent the in-order traversal of a BST. :param arr: List[int], the array of integers :param N: int, size of the array :return: bool, True if it can represent the in-order traversal of a BST, False otherwise for i in range(1, N): if arr[i] <= arr[i - 1]: return False return True"},{"question":"def min_average_speed_variance(speeds): Returns the minimum possible average speed variance for the given student speeds. >>> min_average_speed_variance([10, 8, 15, 12]) == 2 >>> min_average_speed_variance([1, 2, 3, 4, 5]) == 1 >>> min_average_speed_variance([5, 4, 3, 2, 1]) == 1 >>> min_average_speed_variance([7, 7, 7, 7, 7]) == 0 >>> min_average_speed_variance([1, 1000]) == 999 >>> min_average_speed_variance([1, 3, 5, 7, 9, 11, 13, 15, 17, 19]) == 2","solution":"def min_average_speed_variance(speeds): Returns the minimum possible average speed variance for the given student speeds. speeds.sort() N = len(speeds) total_variance = 0 for i in range(1, N): total_variance += abs(speeds[i] - speeds[i - 1]) min_avg_variance = total_variance // (N - 1) return min_avg_variance"},{"question":"import re def valid_arithmetic(expr: str) -> bool: Determine if a given string is a valid arithmetic expression made up of non-negative integers and the operators +, -, *, and /. >>> valid_arithmetic(\\"3 + 5 * 2 / 1\\") True >>> valid_arithmetic(\\" 42 - 21 \\") True >>> valid_arithmetic(\\" 12 * * 7 + 2 \\") False >>> valid_arithmetic(\\"75 / 3 * \\") False","solution":"import re def valid_arithmetic(expr): Returns True if the expr is a valid arithmetic expression made up of non-negative integers and the operators +, -, *, / and possibly containing whitespace characters. # Remove whitespace from the expression expr = expr.replace(\\" \\", \\"\\") # Define regex pattern for a valid arithmetic expression pattern = re.compile(r'^d+(s*[+-*/]s*d+)*') # Match the regular expression with the given expression return bool(pattern.match(expr))"},{"question":"from typing import List def find_peaks(arr: List[int]) -> List[int]: Identifies and returns a list of all peaks in the input array. >>> find_peaks([10, 20, 15, 2, 23, 90, 67]) [20, 90] >>> find_peaks([1, 3, 20, 4, 1, 0]) [20] pass","solution":"from typing import List def find_peaks(arr: List[int]) -> List[int]: Identifies and returns a list of all peaks in the input array. peaks = [] for i in range(1, len(arr) - 1): if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]: peaks.append(arr[i]) return peaks"},{"question":"def magic_maze(n, m, q, corridors, queries): Determine if each query can reach from room a to room b in the magic maze. Args: n (int): The number of rooms. m (int): The number of corridors. q (int): The number of queries. corridors (List[Tuple[int, int]]): List of tuples representing corridors. queries (List[Tuple[int, int]]): List of tuples representing queries. Returns: List[str]: List of results for each query, \\"Yes\\" if there's a path, \\"No\\" otherwise. >>> magic_maze(4, 4, 3, [(1, 2), (2, 3), (3, 4), (4, 1)], [(1, 3), (2, 4), (1, 1)]) ['Yes', 'Yes', 'Yes'] >>> magic_maze(5, 2, 2, [(1, 2), (2, 3)], [(3, 4), (4, 5)]) ['No', 'No']","solution":"def magic_maze(n, m, q, corridors, queries): from collections import defaultdict, deque # Build the graph graph = defaultdict(list) for u, v in corridors: graph[u].append(v) graph[v].append(u) # BFS to find all reachable rooms from each room reachable = {i: set() for i in range(1, n + 1)} for i in range(1, n + 1): queue = deque([i]) visited = set([i]) while queue: current = queue.popleft() reachable[i].add(current) for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) # Answer the queries results = [] for a, b in queries: if b in reachable[a]: results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def sum_even_fibonacci(n: int) -> int: Determine the sum of all even-valued Fibonacci numbers that are less than or equal to n. Args: n (int): A positive integer Returns: int: Sum of all even-valued Fibonacci numbers that are ≤ n Examples: >>> sum_even_fibonacci(10) 10 >>> sum_even_fibonacci(34) 44","solution":"def sum_even_fibonacci(n): Returns the sum of all even-valued Fibonacci numbers that are less than or equal to n. a, b = 1, 2 total_sum = 0 while a <= n: if a % 2 == 0: total_sum += a a, b = b, a + b return total_sum"},{"question":"def total_price(items, item_type): Calculate the total price of all items of a specific type. :param items: List of dictionaries, where each dictionary has keys \\"name\\", \\"type\\", and \\"price\\". :param item_type: The type of items to sum up the prices for. :return: The total price of all items of the provided type. >>> items = [ ... {\\"name\\": \\"apple\\", \\"type\\": \\"fruit\\", \\"price\\": 1.2}, ... {\\"name\\": \\"banana\\", \\"type\\": \\"fruit\\", \\"price\\": 0.5}, ... {\\"name\\": \\"carrot\\", \\"type\\": \\"vegetable\\", \\"price\\": 0.7}, ... {\\"name\\": \\"kale\\", \\"type\\": \\"vegetable\\", \\"price\\": 2.5}, ... {\\"name\\": \\"milk\\", \\"type\\": \\"dairy\\", \\"price\\": 1.5} ... ] >>> total_price(items, 'fruit') 1.7 >>> total_price(items, 'vegetable') 3.2 >>> total_price(items, 'dairy') 1.5 >>> total_price(items, 'meat') 0 >>> total_price([], 'fruit') 0","solution":"def total_price(items, item_type): Calculate the total price of all items of a specific type. :param items: List of dictionaries, where each dictionary has keys \\"name\\", \\"type\\", and \\"price\\". :param item_type: The type of items to sum up the prices for. :return: The total price of all items of the provided type. return sum(item['price'] for item in items if item['type'] == item_type)"},{"question":"def longest_increasing_subsequence_with_diff_at_most_2(arr): Find the length of the longest subsequence such that elements in the subsequence are in increasing order and have a difference of at most 2 between consecutive elements. >>> longest_increasing_subsequence_with_diff_at_most_2([1, 3, 2, 4, 6]) 4 >>> longest_increasing_subsequence_with_diff_at_most_2([1, 1, 1, 1, 1]) 1 >>> longest_increasing_subsequence_with_diff_at_most_2([10, 12, 14, 16]) 4 >>> longest_increasing_subsequence_with_diff_at_most_2([1]) 1 >>> longest_increasing_subsequence_with_diff_at_most_2([3, 6, 9, 12]) 1 >>> longest_increasing_subsequence_with_diff_at_most_2([7, 5, 6, 10, 1, 8]) 3 >>> longest_increasing_subsequence_with_diff_at_most_2([]) 0","solution":"def longest_increasing_subsequence_with_diff_at_most_2(arr): Find the length of the longest subsequence such that elements in the subsequence are in increasing order and have a difference of at most 2 between consecutive elements. if not arr: return 0 n = len(arr) # Initialize dp array where each element is at least a subsequence of length 1 (itself) dp = [1] * n # Build the dp array for i in range(1, n): for j in range(i): if arr[i] > arr[j] and arr[i] - arr[j] <= 2: dp[i] = max(dp[i], dp[j] + 1) # Find the length of the longest subsequence return max(dp)"},{"question":"def max_food_collected(grid: List[List[int]]) -> int: Calculates the maximum food collected in a grid starting from the top-left corner to the bottom-right corner, moving only right or down at each step. Args: grid (List[List[int]]): A 2D list representing the grid with food units. Returns: int: Maximum food units that can be collected. >>> max_food_collected([ ... [5, 3, 2], ... [1, 2, 1], ... [3, 1, 4] ... ]) 15 >>> max_food_collected([ ... [1, 2, 3, 4], ... [2, 2, 2, 2], ... [3, 1, 1, 3], ... [4, 4, 4, 1] ... ]) 19 >>> max_food_collected([ ... [5] ... ]) 5 >>> max_food_collected([ ... [0, 0], ... [0, 0] ... ]) 0 >>> max_food_collected([ ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1] ... ]) 9","solution":"def max_food_collected(grid): Calculates the maximum food collected in a grid starting from the top-left corner to the bottom-right corner, moving only right or down at each step. :param grid: A list of lists representing the grid with food units :return: Maximum food units that can be collected n = len(grid) dp = [[0] * n for _ in range(n)] dp[0][0] = grid[0][0] # Initialize the first row. for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column. for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of dp table. for i in range(1, n): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1]"},{"question":"def keys_with_value(d: dict, value: Any) -> List[Any]: This function takes a dictionary \`d\` and a value \`value\`, and returns a list of all keys that have the given value. >>> keys_with_value({'a': 1, 'b': 2, 'c': 1, 'd': 3}, 1) ['a', 'c'] >>> keys_with_value({'a': 1, 'b': 2, 'c': 1, 'd': 3}, 2) ['b'] >>> keys_with_value({'a': 1, 'b': 2, 'c': 1, 'd': 3}, 3) ['d'] >>> keys_with_value({'a': 1, 'b': 2, 'c': 1, 'd': 3}, 4) [] >>> keys_with_value({}, 1) [] >>> keys_with_value({'a': 1, 'b': 2, 'c': 3}, 4) [] >>> keys_with_value({'a': 1, 'b': 1, 'c': 1, 'd': 1}, 1) ['a', 'b', 'c', 'd']","solution":"def keys_with_value(d, value): This function takes a dictionary \`d\` and a value \`value\`, and returns a list of all keys that have the given value. return [key for key, val in d.items() if val == value]"},{"question":"def min_sum_of_abs_differences(n): Returns the minimum possible sum of absolute differences of indices of consecutive stamps when they are arranged optimally. Parameters: n (int): The number of different stamps. Returns: int: The minimum possible sum of absolute differences. >>> min_sum_of_abs_differences(4) 4 >>> min_sum_of_abs_differences(5) 6 >>> min_sum_of_abs_differences(2) 2 >>> min_sum_of_abs_differences(7) 8 >>> min_sum_of_abs_differences(1000) 1000","solution":"def min_sum_of_abs_differences(n): Returns the minimum possible sum of absolute differences of indices of consecutive stamps when they are arranged optimally. if n % 2 == 0: return n else: return n + 1"},{"question":"def isPatternMatch(S, P): Checks if the string S follows the pattern P. :param S: String consisting of words separated by spaces. :param P: Pattern string consisting of lowercase letters. :return: Boolean value indicating whether the string follows the given pattern. >>> isPatternMatch(\\"dog cat cat dog\\", \\"abba\\") True >>> isPatternMatch(\\"dog cat cat fish\\", \\"abba\\") False >>> isPatternMatch(\\"dog dog dog dog\\", \\"aaaa\\") True >>> isPatternMatch(\\"dog cat cat\\", \\"abba\\") False >>> isPatternMatch(\\"one two three four\\", \\"abcd\\") True >>> isPatternMatch(\\"one two three four\\", \\"aabb\\") False >>> isPatternMatch(\\"dog\\", \\"a\\") True","solution":"def isPatternMatch(S, P): Checks if the string S follows the pattern P. :param S: String consisting of words separated by spaces. :param P: Pattern string consisting of lowercase letters. :return: Boolean value indicating whether the string follows the given pattern. words = S.split() if len(words) != len(P): return False word_to_pattern = {} pattern_to_word = {} for word, pattern_char in zip(words, P): if word in word_to_pattern and word_to_pattern[word] != pattern_char: return False if pattern_char in pattern_to_word and pattern_to_word[pattern_char] != word: return False word_to_pattern[word] = pattern_char pattern_to_word[pattern_char] = word return True"},{"question":"from typing import List def minDistance(S: str, T: str) -> int: Given two strings S and T, find the minimum number of operations required to convert string S into string T. You can perform the following operations on string S: 1. Insert a character 2. Delete a character 3. Replace a character with another character >>> minDistance(\\"abcdef\\", \\"azced\\") 3 >>> minDistance(\\"saturday\\", \\"sunday\\") 3 def test_min_distance_example1(): assert minDistance(\\"abcdef\\", \\"azced\\") == 3 def test_min_distance_example2(): assert minDistance(\\"saturday\\", \\"sunday\\") == 3 def test_min_distance_empty_strings(): assert minDistance(\\"\\", \\"\\") == 0 def test_min_distance_one_empty_string(): assert minDistance(\\"a\\", \\"\\") == 1 assert minDistance(\\"\\", \\"a\\") == 1 def test_min_distance_same_strings(): assert minDistance(\\"hello\\", \\"hello\\") == 0 def test_min_distance_single_edit(): assert minDistance(\\"cat\\", \\"cut\\") == 1 assert minDistance(\\"cat\\", \\"cats\\") == 1 def test_min_distance_multiple_edits(): assert minDistance(\\"intention\\", \\"execution\\") == 5 if __name__ == \\"__main__\\": test_min_distance_example1() test_min_distance_example2() test_min_distance_empty_strings() test_min_distance_one_empty_string() test_min_distance_same_strings() test_min_distance_single_edit() test_min_distance_multiple_edits() print(\\"All tests passed.\\")","solution":"def minDistance(S, T): Return the minimum number of operations required to convert string S to string T. :param S: str: Source string :param T: str: Target string :return: int: Minimum number of operations m, n = len(S), len(T) # Create a 2D dp array with dimensions (m+1) x (n+1) dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the dp array for i in range(m + 1): dp[i][0] = i # Deleting all characters from S for j in range(n + 1): dp[0][j] = j # Inserting all characters into S # Fill the dp array for i in range(1, m + 1): for j in range(1, n + 1): if S[i - 1] == T[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no operation needed else: dp[i][j] = min(dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1]) + 1 # Replacement return dp[m][n]"},{"question":"from typing import List def maxBuildings(cu_list: List[int], total_cu: int) -> List[int]: Determines the maximum number of each type of building that can be constructed with the given total construction units (total_cu). Parameters: cu_list (List[int]): List of integers where each integer represents the construction units required for a specific type of building. total_cu (int): Total available construction units. Returns: List[int]: List of integers where the i-th element represents the maximum number of the i-th type of building that can be constructed. Example: >>> maxBuildings([5, 10, 8], 100) [20, 10, 12] >>> maxBuildings([3], 15) [5]","solution":"from typing import List def maxBuildings(cu_list: List[int], total_cu: int) -> List[int]: Determines the maximum number of each type of building that can be constructed with the given total construction units (total_cu). Parameters: cu_list (List[int]): List of integers where each integer represents the construction units required for a specific type of building. total_cu (int): Total available construction units. Returns: List[int]: List of integers where the i-th element represents the maximum number of the i-th type of building that can be constructed. return [total_cu // cu for cu in cu_list]"},{"question":"from typing import List, Tuple def bubble_sort_swaps(heights: List[int]) -> int: Returns the number of swaps needed to sort the list \`heights\` using bubble sort. >>> bubble_sort_swaps([4, 3, 2, 1, 5]) 6 >>> bubble_sort_swaps([10, 20, 30, 40]) 0 >>> bubble_sort_swaps([1, 3, 2, 4]) 1 >>> bubble_sort_swaps([5, 4, 3, 2, 1]) 10 pass def number_of_swaps(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given the number of test cases \`t\` and a list of \`test_cases\`, returns a list of integers representing the number of swaps needed to sort the books in each test case. >>> number_of_swaps(2, [(5, [4, 3, 2, 1, 5]), (4, [10, 20, 30, 40])]) [6, 0] >>> number_of_swaps(1, [(4, [1, 2, 3, 4])]) [0] >>> number_of_swaps(3, [(3, [3, 2, 1]), (2, [100, 50]), (1, [1])]) [3, 1, 0] >>> number_of_swaps(2, [(5, [1, 5, 4, 3, 2]), (6, [6, 5, 4, 3, 2, 1])]) [6, 15] pass","solution":"def bubble_sort_swaps(heights): Returns the number of swaps needed to sort the list \`heights\` using bubble sort. n = len(heights) swaps = 0 for i in range(n): for j in range(0, n-i-1): if heights[j] > heights[j+1]: heights[j], heights[j+1] = heights[j+1], heights[j] swaps += 1 return swaps def number_of_swaps(t, test_cases): results = [] for i in range(t): N, heights = test_cases[i] results.append(bubble_sort_swaps(heights)) return results"},{"question":"from typing import List, Tuple def are_isomorphic(S1: str, S2: str) -> str: Determines if two strings S1 and S2 are isomorphic. # Complete the implementation here def main_function(T: int, test_cases: List[Tuple[str, str]]) -> List[str]: Processes multiple test cases to determine if pairs of strings are isomorphic. Parameters: T: int - The number of test cases. test_cases: List[Tuple[str, str]] - A list of tuples where each tuple contains two strings. Returns: List[str] - A list of \\"YES\\" or \\"NO\\" for each test case. # Complete the implementation here if __name__ == \\"__main__\\": # Example input T = 3 test_cases = [(\\"paper\\", \\"title\\"), (\\"foo\\", \\"bar\\"), (\\"abca\\", \\"zbxz\\")] results = main_function(T, test_cases) for result in results: print(result) def test_simple_isomorphic(): assert are_isomorphic(\\"paper\\", \\"title\\") == \\"YES\\" assert are_isomorphic(\\"foo\\", \\"bar\\") == \\"NO\\" assert are_isomorphic(\\"abca\\", \\"zbxz\\") == \\"YES\\" def test_non_isomorphic(): assert are_isomorphic(\\"egg\\", \\"add\\") == \\"YES\\" assert are_isomorphic(\\"abc\\", \\"def\\") == \\"YES\\" assert are_isomorphic(\\"abc\\", \\"dee\\") == \\"NO\\" assert are_isomorphic(\\"aabbcc\\", \\"bbbccc\\") == \\"NO\\" def test_different_lengths(): assert are_isomorphic(\\"abc\\", \\"abcd\\") == \\"NO\\" assert are_isomorphic(\\"\\", \\"a\\") == \\"NO\\" def test_edge_cases(): assert are_isomorphic(\\"\\", \\"\\") == \\"YES\\" assert are_isomorphic(\\"a\\", \\"b\\") == \\"YES\\" assert are_isomorphic(\\"a\\", \\"a\\") == \\"YES\\" assert are_isomorphic(\\"ab\\", \\"aa\\") == \\"NO\\" def test_main_function(): T = 3 test_cases = [(\\"paper\\", \\"title\\"), (\\"foo\\", \\"bar\\"), (\\"abca\\", \\"zbxz\\")] result = main_function(T, test_cases) assert result == [\\"YES\\", \\"NO\\", \\"YES\\"] T = 2 test_cases = [(\\"egg\\", \\"add\\"), (\\"abc\\", \\"dee\\")] result = main_function(T, test_cases) assert result == [\\"YES\\", \\"NO\\"]","solution":"def are_isomorphic(S1, S2): Determines if two strings S1 and S2 are isomorphic. if len(S1) != len(S2): return \\"NO\\" mapping_s1_s2 = {} mapping_s2_s1 = {} for char1, char2 in zip(S1, S2): if char1 in mapping_s1_s2 and mapping_s1_s2[char1] != char2: return \\"NO\\" if char2 in mapping_s2_s1 and mapping_s2_s1[char2] != char1: return \\"NO\\" mapping_s1_s2[char1] = char2 mapping_s2_s1[char2] = char1 return \\"YES\\" def main_function(T, test_cases): results = [] for i in range(T): S1, S2 = test_cases[i] results.append(are_isomorphic(S1, S2)) return results"},{"question":"def count_distinct_regions(grid: List[List[str]], n: int, m: int) -> int: Determine the number of distinct regions of passable land in a grid. >>> count_distinct_regions([ ... ['.', '.', '#', '#', '.'], ... ['#', '.', '.', '#', '.'], ... ['#', '#', '.', '.', '#'], ... ['.', '#', '#', '#', '.'] ... ], 4, 5) 4 >>> count_distinct_regions([ ... ['.', '.', '.'], ... ['#', '#', '#'], ... ['.', '.', '.'] ... ], 3, 3) 2","solution":"def count_distinct_regions(grid, n, m): def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] == '#': return grid[x][y] = '#' dfs(x+1, y) dfs(x-1, y) dfs(x, y+1) dfs(x, y-1) region_count = 0 for i in range(n): for j in range(m): if grid[i][j] == '.': region_count += 1 dfs(i, j) return region_count"},{"question":"def max_floats(n: int, m: int, intervals: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping floats that can be placed. Parameters: n (int): The number of positions on the street. m (int): The number of floats. intervals (list): A list where each element is a tuple (ai, bi) representing the start and end positions of each float. Returns: int: The maximum number of non-overlapping floats. >>> max_floats(10, 4, [(1, 2), (2, 5), (3, 6), (7, 10)]) 3 >>> max_floats(10, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 4 >>> max_floats(5, 1, [(1, 5)]) 1 >>> max_floats(5, 0, []) 0 >>> max_floats(5, 3, [(1, 5), (1, 5), (1, 5)]) 1","solution":"def max_floats(n, m, intervals): Returns the maximum number of non-overlapping floats that can be placed. Parameters: n (int): The number of positions on the street. m (int): The number of floats. intervals (list): A list where each element is a tuple (ai, bi) representing the start and end positions of each float. Returns: int: The maximum number of non-overlapping floats. # Sort the intervals by their end points intervals.sort(key=lambda x: x[1]) count = 0 last_end = 0 for start, end in intervals: if start >= last_end: count += 1 last_end = end return count"},{"question":"def max_rearrangement(n: int) -> int: Given a non-negative integer n, returns the maximum possible integer that can be obtained by rearranging the digits of n. >>> max_rearrangement(213) 321 >>> max_rearrangement(4455) 5544 >>> max_rearrangement(1004) 4100","solution":"def max_rearrangement(n): Returns the maximum possible integer that can be obtained by rearranging the digits of n. # Convert the number to a string to access its digits digits = str(n) # Sort the digits in decreasing order and join them to form a new number max_number = int(''.join(sorted(digits, reverse=True))) return max_number"},{"question":"def is_valid_bead_sequence(R, B, G): Determine if a valid sequence of beads can be arranged under given constraints. Args: R (int): Number of red beads. B (int): Number of blue beads. G (int): Number of green beads. Returns: str: \\"YES\\" if a valid sequence is possible, otherwise \\"NO\\". >>> is_valid_bead_sequence(4, 2, 1) 'YES' >>> is_valid_bead_sequence(3, 3, 3) 'NO' >>> is_valid_bead_sequence(5, 3, 2) 'YES' pass def process_bead_sequences(test_cases): Process multiple test cases to determine valid bead sequences. Args: test_cases (List[Tuple[int, int, int]]): List of test cases where each test case is a tuple (R, B, G). Returns: List[str]: List of results for each test case, \\"YES\\" or \\"NO\\". >>> process_bead_sequences([(4, 2, 1), (3, 3, 3), (5, 3, 2)]) ['YES', 'NO', 'YES'] pass","solution":"def is_valid_bead_sequence(R, B, G): if R <= B: return \\"NO\\" max_blue_green_comb = B + G if max_blue_green_comb // 2 > R: return \\"NO\\" if R < (max_blue_green_comb // 2): return \\"NO\\" return \\"YES\\" def process_bead_sequences(test_cases): results = [] for R, B, G in test_cases: results.append(is_valid_bead_sequence(R, B, G)) return results"},{"question":"from typing import List def min_steps_to_reach_destination(n: int, m: int, d: int, grid: List[List[int]]) -> int: Determine if it is possible for Mara to reach her destination given the elevation constraints. Return the minimum number of steps required or \\"Impossible\\". >>> min_steps_to_reach_destination(5, 5, 2, [ [1, 2, 2, 3, 4], [2, 3, 4, 5, 6], [3, 4, 5, 6, 7], [4, 5, 6, 7, 8], [5, 6, 7, 8, 9] ]) 8 >>> min_steps_to_reach_destination(3, 3, 1, [ [1, 3, 5], [2, 2, 2], [3, 3, 3] ]) 4 >>> min_steps_to_reach_destination(3, 3, 1, [ [10, 11, 12], [20, 25, 30], [10, 12, 11] ]) 'Impossible'","solution":"from collections import deque def min_steps_to_reach_destination(n, m, d, grid): def is_valid(x, y, prev_val): return 0 <= x < n and 0 <= y < m and abs(grid[x][y] - prev_val) <= d and (x, y) not in visited directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) # (x, y, steps) visited = set() visited.add((0, 0)) while queue: x, y, steps = queue.popleft() if x == n-1 and y == m-1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny, grid[x][y]): visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return \\"Impossible\\""},{"question":"def rotate(matrix: List[List[int]]) -> None: Given a square matrix representing an image, rotate the image by 90 degrees clockwise. Modify the input matrix in-place. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate(matrix) >>> matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix = [ ... [ 1, 2, 3, 4], ... [ 5, 6, 7, 8], ... [ 9, 10, 11, 12], ... [13, 14, 15, 16] ... ] >>> rotate(matrix) >>> matrix [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]] >>> matrix = [ ... [1] ... ] >>> rotate(matrix) >>> matrix [[1]] >>> matrix = [ ... [1, 2], ... [3, 4] ... ] >>> rotate(matrix) >>> matrix [[3, 1], [4, 2]]","solution":"def rotate(matrix): Rotates the given n x n 2D matrix by 90 degrees clockwise in place. n = len(matrix) # First, transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Then, reverse each row for i in range(n): matrix[i].reverse()"},{"question":"import math def isPerfectSquare(N: int) -> int: Checks if a given number N is a perfect square or not. Args: N (int): The number to check. Returns: int: Returns 1 if N is a perfect square, otherwise returns 0. >>> isPerfectSquare(49) 1 >>> isPerfectSquare(50) 0 def test_is_perfect_square(): assert isPerfectSquare(49) == 1 assert isPerfectSquare(50) == 0 assert isPerfectSquare(1) == 1 assert isPerfectSquare(4) == 1 assert isPerfectSquare(9) == 1 assert isPerfectSquare(16) == 1 assert isPerfectSquare(24) == 0 assert isPerfectSquare(0) == 0 assert isPerfectSquare(-1) == 0 # Test upper bound assert isPerfectSquare(1000000) == 1 # 1000*1000 def test_edge_cases(): assert isPerfectSquare(2) == 0 assert isPerfectSquare(3) == 0 assert isPerfectSquare(100) == 1 # 10*10 assert isPerfectSquare(121) == 1 # 11*11 assert isPerfectSquare(999999) == 0","solution":"import math def isPerfectSquare(N): Checks if a given number N is a perfect square or not. Returns 1 if N is a perfect square, otherwise returns 0. if N < 1: return 0 sqrt_n = int(math.sqrt(N)) return 1 if sqrt_n * sqrt_n == N else 0"},{"question":"def is_valid_sudoku(grid): This function checks whether a given 9x9 grid is a valid Sudoku solution. -----Input----- The input consists of one 9x9 grid, where each grid element is an integer between 1 and 9, inclusive. -----Output----- Output a single line with the word \\"Valid\\" if the grid represents a valid Sudoku solution, and \\"Invalid\\" otherwise. >>> is_valid_sudoku([ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9] ]) \\"Valid\\" >>> is_valid_sudoku([ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 5] ]) \\"Invalid\\"","solution":"def is_valid_sudoku(grid): This function checks whether a given 9x9 grid is a valid Sudoku solution. def is_valid_block(block): Helper function to check if a block (row, column or subgrid) contains all digits from 1 to 9 exactly once. return sorted(block) == list(range(1, 10)) # Check each row for row in grid: if not is_valid_block(row): return \\"Invalid\\" # Check each column for col in range(9): if not is_valid_block([grid[row][col] for row in range(9)]): return \\"Invalid\\" # Check each 3x3 subgrid for i in range(0, 9, 3): for j in range(0, 9, 3): subgrid = [] for row in range(3): for col in range(3): subgrid.append(grid[i + row][j + col]) if not is_valid_block(subgrid): return \\"Invalid\\" return \\"Valid\\""},{"question":"def minimize_max_time(n, edges, k): Erika is planning to organize an international programming contest. She has several venues across different cities of her country, which are connected by roads. Each road can have different travel times depending on the time of day. She wants to select a set of venues such that the maximum time required to travel between any two selected venues is minimized. To simplify, let's represent the venues and roads as vertices and edges in a graph. Erika wants to select a subset of vertices such that the selected vertices are connected in the graph and the maximum weight of the edges between any two selected vertices is minimized. Args: n (int): The number of venues. edges (List[Tuple[int, int, int]]): A list of tuples representing the roads between venues and their travel times. k (int): The number of venues Erika wants to select. Returns: int: The minimized maximum travel time for any two selected venues. Example: >>> minimize_max_time(6, [(0, 1, 4), (1, 2, 5), (2, 3, 6), (3, 4, 2), (4, 5, 3)], 3) 4 def test_simple_case(): from solution import minimize_max_time n = 6 edges = [ (1-1, 2-1, 4), (2-1, 3-1, 5), (3-1, 4-1, 6), (4-1, 5-1, 2), (5-1, 6-1, 3), ] k = 3 assert minimize_max_time(n, edges, k) == 4 def test_case_one_connection(): from solution import minimize_max_time n = 2 edges = [ (1-1, 2-1, 10), ] k = 2 assert minimize_max_time(n, edges, k) == 10 def test_case_diameter(): from solution import minimize_max_time n = 4 edges = [ (1-1, 2-1, 1), (1-1, 3-1, 1), (3-1, 4-1, 1), ] k = 4 assert minimize_max_time(n, edges, k) == 1 def test_case_large_weights(): from solution import minimize_max_time n = 3 edges = [ (1-1, 2-1, 1000000), (2-1, 3-1, 1000000), ] k = 2 assert minimize_max_time(n, edges, k) == 1000000","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal(n, edges, max_edge): parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) edges = [edge for edge in edges if edge[2] <= max_edge] edges = sorted(edges, key=lambda item: item[2]) result = [] for edge in edges: u, v, w = edge x = find(parent, u) y = find(parent, v) if x != y: result.append(edge) union(parent, rank, x, y) return len(set(find(parent, i) for i in range(n))) <= len(result) def minimize_max_time(n, edges, k): left, right = 1, 10**6 result = right while left <= right: mid = (left + right) // 2 if kruskal(n, edges, mid): result = mid right = mid - 1 else: left = mid + 1 return result def solve(): import sys input = sys.stdin.read data = input().split() idx = 0 n = int(data[idx]) idx += 1 edges = [] for _ in range(n - 1): x = int(data[idx]) - 1 y = int(data[idx + 1]) - 1 t = int(data[idx + 2]) edges.append((x, y, t)) idx += 3 k = int(data[idx]) print(minimize_max_time(n, edges, k))"},{"question":"import random from typing import List, Tuple def secret_santa(participants: List[str]) -> List[Tuple[str, str]]: Generate a Secret Santa assignment Args: participants (list of str): A list of participant names Returns: list of tuples: Each tuple contains a giver and a receiver Rules: 1. No one can be their own Secret Santa. 2. All participants must be used exactly once. pass from solution import secret_santa def test_secret_santa_no_one_assigned_themselves(): participants = [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"Dave\\", \\"Eva\\"] assignments = secret_santa(participants) for giver, receiver in assignments: assert giver != receiver def test_secret_santa_all_participants_included(): participants = [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] assignments = secret_santa(participants) givers = [assignment[0] for assignment in assignments] receivers = [assignment[1] for assignment in assignments] assert set(givers) == set(participants) assert set(receivers) == set(participants) def test_secret_santa_min_participants(): participants = [\\"Alice\\", \\"Bob\\"] assignments = secret_santa(participants) for giver, receiver in assignments: assert giver != receiver givers = [assignment[0] for assignment in assignments] receivers = [assignment[1] for assignment in assignments] assert set(givers) == set(participants) assert set(receivers) == set(participants) def test_secret_santa_randomness(): participants = [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"Dave\\"] assignments1 = secret_santa(participants) assignments2 = secret_santa(participants) assert assignments1 != assignments2","solution":"import random def secret_santa(participants): Returns the Secret Santa assignments for the given list of participants. Args: participants (list of str): A list of participants. Returns: list of tuples: A list of tuples where each tuple is (giver, receiver). givers = participants[:] receivers = participants[:] while True: random.shuffle(receivers) valid = True for i in range(len(givers)): if givers[i] == receivers[i]: valid = False break if valid: break return list(zip(givers, receivers))"},{"question":"import heapq from collections import Counter def reorganizeString(s: str) -> str: Rearrange the characters of a string such that no two adjacent characters are the same. If not possible, return an empty string. >>> reorganizeString('aaabc') 'abaca' >>> reorganizeString('aab') 'aba' >>> reorganizeString('aaab') ''","solution":"import heapq from collections import Counter def reorganizeString(s): Rearrange the characters of a string such that no two adjacent characters are the same. If not possible, return an empty string. count = Counter(s) max_heap = [(-value, key) for key, value in count.items()] heapq.heapify(max_heap) prev_value, prev_char = 0, '' result = [] while max_heap: value, char = heapq.heappop(max_heap) result.append(char) if prev_value < 0: heapq.heappush(max_heap, (prev_value, prev_char)) prev_value, prev_char = value + 1, char result = ''.join(result) if len(result) != len(s): return '' return result"},{"question":"def max_pairs_even_sum(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the maximum number of pairs of activities where the sum of their durations is even. Each pair must consist of two different activities. Args: T : int : The number of test cases test_cases : List[Tuple[int, List[int]]] : A list of tuples where each tuple represents a test case. Each tuple contains an integer N (the number of activities) and a list of N integers (durations). Returns: List[int] : A list of integers where each integer represents the maximum number of pairs for each test case. Examples: >>> max_pairs_even_sum(2, [(4, [4, 7, 5, 2]), (5, [3, 5, 1, 2, 8])]) [2, 2] >>> max_pairs_even_sum(1, [(4, [2, 4, 6, 8])]) [0]","solution":"def max_pairs_even_sum(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] activities = test_cases[i][1] odd_count = sum(1 for x in activities if x % 2 != 0) even_count = N - odd_count pairs = min(odd_count, even_count) results.append(pairs) return results"},{"question":"def shift_list(arr, k): Shifts the elements of the list to the right by k positions. Elements that fall off the end reappear at the beginning. :param arr: List of integers :param k: Number of positions to shift the list :return: List after applying the shift >>> shift_list([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> shift_list([7, 8, 9, 10], 1) [10, 7, 8, 9] >>> shift_list([1, 2, 3, 4], 0) [1, 2, 3, 4] >>> shift_list([1, 2, 3, 4], 4) [1, 2, 3, 4] >>> shift_list([1, 2, 3, 4], 5) [4, 1, 2, 3] >>> shift_list([5, 6, 7, 8], 100) [5, 6, 7, 8] >>> shift_list([1], 10) [1] >>> shift_list([1, 1, 1, 1], 2) [1, 1, 1, 1]","solution":"def shift_list(arr, k): Shifts the elements of the list to the right by k positions. Elements that fall off the end reappear at the beginning. :param arr: List of integers :param k: Number of positions to shift the list :return: List after applying the shift n = len(arr) # Make the shift effective within the length of the list k = k % n # Apply the shift return arr[-k:] + arr[:-k]"},{"question":"def find_contact_number(contacts, name): Returns the phone number of the contact with the given name. If the contact name is not found, returns 'Not found'. Args: contacts (list of dict): The list of contacts with keys 'name' and 'number'. name (str): The name of the contact to find. Returns: str: The phone number of the contact or 'Not found' if the contact does not exist. >>> contacts = [ {'name': 'Alice', 'number': '123-456-7890'}, {'name': 'Bob', 'number': '234-567-8901'}, {'name': 'Charlie', 'number': '345-678-9012'} ] >>> find_contact_number(contacts, 'Bob') '234-567-8901' >>> find_contact_number(contacts, 'Dave') 'Not found' >>> contacts = [] >>> find_contact_number(contacts, 'Alice') 'Not found' >>> contacts = [ {'name': 'Alice', 'number': '123-456-7890'}, {'name': 'Alice', 'number': '000-000-0000'} ] >>> find_contact_number(contacts, 'Alice') '123-456-7890' >>> contacts = [ {'name': 'alice', 'number': '123-456-7890'}, {'name': 'Alice', 'number': '234-567-8901'} ] >>> find_contact_number(contacts, 'alice') '123-456-7890' >>> find_contact_number(contacts, 'Alice') '234-567-8901'","solution":"def find_contact_number(contacts, name): Returns the phone number of the contact with the given name. If the contact name is not found, returns 'Not found'. Args: contacts (list of dict): The list of contacts with keys 'name' and 'number'. name (str): The name of the contact to find. Returns: str: The phone number of the contact or 'Not found' if the contact does not exist. for contact in contacts: if contact['name'] == name: return contact['number'] return 'Not found'"},{"question":"def min_stalls_to_collect_all_fruits(n: int, s: str) -> int: Returns the minimum number of consecutive stalls needed to collect all types of fruits. Parameters: n (int): number of stalls s (str): types of fruits in each stall Returns: int: minimum number of consecutive stalls Examples: >>> min_stalls_to_collect_all_fruits(6, \\"ABACBB\\") 3 >>> min_stalls_to_collect_all_fruits(5, \\"ABCDE\\") 5 >>> min_stalls_to_collect_all_fruits(8, \\"AAABACBD\\") 4","solution":"def min_stalls_to_collect_all_fruits(n, s): This function returns the minimum number of consecutive stalls needed to collect all types of fruits. :param n: Integer, number of stalls. :param s: String, types of fruits in each stall. :return: Integer, minimum number of consecutive stalls. from collections import Counter if n == 1: return 1 # All unique fruits in the market unique_fruits = set(s) unique_count = len(unique_fruits) # Sliding window technique to find the minimum window that contains all fruits left, min_length = 0, float('inf') counter = Counter() for right in range(n): counter[s[right]] += 1 # When counter has all unique fruits while len(counter) == unique_count: # Update minimum length of the window min_length = min(min_length, right - left + 1) # Remove fruit from the left and move window to the right counter[s[left]] -= 1 if counter[s[left]] == 0: del counter[s[left]] left += 1 return min_length"},{"question":"from typing import List def can_be_non_decreasing(arr: List[int]) -> bool: Determines if the array can be made non-decreasing by removing at most one element. Arguments: arr -- List of integers Returns: bool -- True if possible to make array non-decreasing by removing one element, otherwise False >>> can_be_non_decreasing([4, 2, 3]) True >>> can_be_non_decreasing([4, 2, 1]) False >>> can_be_non_decreasing([1, 2, 3]) True >>> can_be_non_decreasing([1, 5]) True def process_test_cases(test_cases: List[List[int]]) -> List[bool]: Processes test cases and returns the results. Arguments: test_cases -- List of test cases, where each test case is a list of integers Returns: List of boolean values indicating the result for each test case >>> process_test_cases([[4, 2, 3], [4, 2, 1], [1, 2, 3], [1, 5]]) [True, False, True, True]","solution":"def can_be_non_decreasing(arr): Determines if the array can be made non-decreasing by removing at most one element. def is_non_decreasing(sub_arr): for i in range(len(sub_arr) - 1): if sub_arr[i] > sub_arr[i + 1]: return False return True # Check if already non-decreasing if is_non_decreasing(arr): return True # Try removing each element and check if it becomes non-decreasing for i in range(len(arr)): if is_non_decreasing(arr[:i] + arr[i + 1:]): return True return False def process_test_cases(test_cases): Processes test cases and returns the results. results = [] for arr in test_cases: results.append(can_be_non_decreasing(arr)) return results"},{"question":"def shopping_cart(items): Calculate the total cost of items in a shopping cart, applying a 5% discount if the total cost before discount exceeds 100. Parameters: items (list): A list of dictionaries where each dictionary represents an item with 'name' (str), 'price' (float), and 'quantity' (int). Returns: float: The total cost rounded to two decimal places after applying discounts, if any. Returns 0.0 for an empty list, and None for invalid input. Examples: >>> shopping_cart([{'name': 'apple', 'price': 0.5, 'quantity': 10}, ... {'name': 'banana', 'price': 0.3, 'quantity': 5}]) 6.5 >>> shopping_cart([{'name': 'laptop', 'price': 999.99, 'quantity': 1}, ... {'name': 'mouse', 'price': 25.00, 'quantity': 2}]) 997.49 >>> shopping_cart([{'name': 'pencil', 'price': 1.00, 'quantity': 50}, ... {'name': 'notebook', 'price': 2.00, 'quantity': 30}]) 104.5 >>> shopping_cart([]) 0.0 >>> shopping_cart([{'name': 'apple', 'price': 0.5}]) None","solution":"def shopping_cart(items): Calculate the total cost of items in a shopping cart, applying a 5% discount if the total cost before discount exceeds 100. Parameters: items (list): A list of dictionaries where each dictionary represents an item with 'name' (str), 'price' (float), and 'quantity' (int). Returns: float: The total cost rounded to two decimal places after applying discounts, if any. Returns 0.0 for an empty list, and None for invalid input. if not isinstance(items, list): return None total_cost_before_discount = 0.0 for item in items: if not (isinstance(item, dict) and 'name' in item and 'price' in item and 'quantity' in item and isinstance(item['name'], str) and isinstance(item['price'], (int, float)) and isinstance(item['quantity'], int)): return None total_cost_before_discount += item['price'] * item['quantity'] if total_cost_before_discount > 100: total_cost_before_discount *= 0.95 return round(total_cost_before_discount, 2)"},{"question":"def solve_and_print_sudoku(board): Solve and print the Sudoku puzzle. The input board is a 9x9 grid containing integers from 0 to 9, where 0 represents an empty cell. The function should fill the empty cells with digits from 1 to 9 such that each row, each column, and each of the nine 3x3 sub-grids contain all of the digits from 1 to 9, and then return the solved board. >>> board = [ ... [5, 3, 0, 0, 7, 0, 0, 0, 0], ... [6, 0, 0, 1, 9, 5, 0, 0, 0], ... [0, 9, 8, 0, 0, 0, 0, 6, 0], ... [8, 0, 0, 0, 6, 0, 0, 0, 3], ... [4, 0, 0, 8, 0, 3, 0, 0, 1], ... [7, 0, 0, 0, 2, 0, 0, 0, 6], ... [0, 6, 0, 0, 0, 0, 2, 8, 0], ... [0, 0, 0, 4, 1, 9, 0, 0, 5], ... [0, 0, 0, 0, 8, 0, 0, 7, 9] ... ] >>> solve_and_print_sudoku(board) [ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9] ]","solution":"def is_valid(board, row, col, num): # Check if number exists in row for x in range(9): if board[row][x] == num: return False # Check if number exists in column for x in range(9): if board[x][col] == num: return False # Check if number exists in 3x3 sub-grid start_row, start_col = 3 * (row // 3), 3 * (col // 3) for i in range(3): for j in range(3): if board[i + start_row][j + start_col] == num: return False return True def solve_sudoku(board): empty = find_empty_location(board) if not empty: return True else: row, col = empty for num in range(1, 10): if is_valid(board, row, col, num): board[row][col] = num if solve_sudoku(board): return True board[row][col] = 0 return False def find_empty_location(board): for i in range(9): for j in range(9): if board[i][j] == 0: return (i, j) return None def print_board(board): for row in board: print(\\" \\".join(str(num) for num in row)) def solve_and_print_sudoku(board): solve_sudoku(board) return board # Example usage: if __name__ == \\"__main__\\": example_input = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] solution_board = solve_and_print_sudoku(example_input) print_board(solution_board)"},{"question":"def final_score(T: int, cases: List[Tuple[int, str]]) -> List[int]: Calculate the final score for each participant based on their answers. Args: T (int): The number of test cases. cases (list): A list of tuples where each tuple contains: - N (int): The number of questions. - S (str): A string of length N consisting of 'C', 'I', and 'S'. Returns: list: A list of integers representing the final scores for each test case. >>> final_score(2, [(5, \\"CISCI\\"), (4, \\"SISI\\")]) == [4, -2] >>> final_score(1, [(3, \\"CCC\\")]) == [9] >>> final_score(1, [(3, \\"III\\")]) == [-3] >>> final_score(1, [(3, \\"SSS\\")]) == [0] >>> final_score(1, [(5, \\"CICIS\\")]) == [4] >>> final_score(1, [(1, \\"C\\")]) == [3] >>> final_score(1, [(1, \\"I\\")]) == [-1] >>> final_score(1, [(1, \\"S\\")]) == [0] pass","solution":"def final_score(T, cases): Calculate the final score for each participant based on their answers. Args: T (int): The number of test cases. cases (list): A list of tuples where each tuple contains: - N (int): The number of questions. - S (str): A string of length N consisting of 'C', 'I', and 'S'. Returns: list: A list of integers representing the final scores for each test case. results = [] for N, S in cases: score = 0 for answer in S: if answer == 'C': score += 3 elif answer == 'I': score -= 1 results.append(score) return results"},{"question":"def count_palindromic_substrings(s: str) -> int: Returns the count of palindromic substrings in the given string. >>> count_palindromic_substrings(\\"aaa\\") 6 >>> count_palindromic_substrings(\\"abc\\") 3 >>> count_palindromic_substrings(\\"abccba\\") 9 def palindromic_substrings_count(T: int, test_cases: List[str]) -> List[int]: Returns a list of integers representing counts of palindromic substrings for each test case. >>> palindromic_substrings_count(3, [\\"aaa\\", \\"abc\\", \\"abccba\\"]) [6, 3, 9] >>> palindromic_substrings_count(1, [\\"aabb\\"]) [6] >>> palindromic_substrings_count(2, [\\"abcd\\", \\"aaaa\\"]) [4, 10]","solution":"def count_palindromic_substrings(s): Returns the count of palindromic substrings in the given string s. n = len(s) count = 0 # A 2D list to store whether the substring s[i:j] is palindrome dp = [[False] * n for _ in range(n)] # All substrings of length 1 are palindromes for i in range(n): dp[i][i] = True count += 1 # Check for palindromic substrings of length 2 for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True count += 1 # Check for palindromic substrings of length greater than 2 for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j] and dp[i + 1][j - 1]: dp[i][j] = True count += 1 return count def palindromic_substrings_count(T, test_cases): Returns a list of integers representing counts of palindromic substrings for each test case. results = [] for s in test_cases: results.append(count_palindromic_substrings(s)) return results"},{"question":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None def sum_of_deepest_leaves(node_count: int, edge_list: List[str]) -> int: Given the number of nodes in a binary tree and the edges list with parent, child and direction, find the sum of the values of all the nodes that are the deepest leaves of the tree. >>> sum_of_deepest_leaves(6, [\\"1 2 0\\", \\"1 3 1\\", \\"2 4 0\\", \\"2 5 1\\", \\"3 6 0\\", \\"3 7 1\\"]) 22 >>> sum_of_deepest_leaves(1, []) 0 >>> sum_of_deepest_leaves(2, [\\"1 2 0\\", \\"1 3 1\\"]) 5 >>> sum_of_deepest_leaves(7, [\\"1 2 0\\", \\"1 3 1\\", \\"2 4 0\\", \\"4 8 0\\", \\"3 5 0\\", \\"3 6 1\\", \\"6 7 1\\"]) 15","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None def deepestLeavesSum(edges): from collections import defaultdict, deque if not edges: return 0 tree = defaultdict(TreeNode) for p, c, d in edges: if p not in tree: tree[p] = TreeNode(val=p) if c not in tree: tree[c] = TreeNode(val=c) if d == 0: tree[p].left = tree[c] else: tree[p].right = tree[c] if not tree: return 0 root = tree[edges[0][0]] queue = deque([root]) while queue: level_sum = 0 size = len(queue) for _ in range(size): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum def sum_of_deepest_leaves(node_count, edge_list): edges = [tuple(map(int, edge.split())) for edge in edge_list] return deepestLeavesSum(edges)"},{"question":"def min_platforms_required(n: int, timings: List[Tuple[int, int]]) -> int: Determine the minimal number of platforms required at the station to accommodate the given arrival and departure timings. >>> min_platforms_required(3, [(900, 910), (940, 1200), (950, 1120)]) 2 >>> min_platforms_required(4, [(1100, 1130), (1140, 1150), (1120, 1135), (1135, 1145)]) 2","solution":"def min_platforms_required(n, timings): arrival_times = sorted([a for a, d in timings]) departure_times = sorted([d for a, d in timings]) max_platforms = 0 current_platforms = 0 i, j = 0, 0 while i < n and j < n: if arrival_times[i] < departure_times[j]: current_platforms += 1 i += 1 max_platforms = max(max_platforms, current_platforms) else: current_platforms -= 1 j += 1 return max_platforms # Example usage: # n = 4 # timings = [(1100, 1130), (1140, 1150), (1120, 1135), (1135, 1145)] # print(min_platforms_required(n, timings))"},{"question":"def rearrange_sequence(n: int, sequence: List[int]) -> List[int]: Given a sequence of integers, determine whether it is possible to rearrange the sequence so that no two adjacent integers are the same. If it is possible, return a rearranged sequence, otherwise return an empty list. >>> rearrange_sequence(6, [1, 1, 1, 2, 2, 2]) in [[2, 1, 2, 1, 2, 1], [1, 2, 1, 2, 1, 2]] True >>> rearrange_sequence(3, [1, 1, 1]) [] >>> rearrange_sequence(1, [5]) [5] >>> rearrange_sequence(5, [1, 2, 3, 4, 5]) in [[1, 2, 3, 4, 5], [1, 3, 2, 5, 4], [1, 4, 2, 5, 3]] True >>> rearrange_sequence(4, [7, 7, 7, 7]) [] >>> result = rearrange_sequence(10, [1, 1, 2, 2, 2, 3, 3, 3, 4, 4]) >>> all(result[i] != result[i+1] for i in range(len(result)-1)) True >>> large_input = [i % 3 for i in range(10000)] >>> result = rearrange_sequence(10000, large_input) >>> all(result[i] != result[i+1] for i in range(len(result)-1)) True","solution":"from collections import Counter import heapq def rearrange_sequence(n, sequence): if n == 1: return sequence count = Counter(sequence) max_heap = [(-val, key) for key, val in count.items()] heapq.heapify(max_heap) prev_count, prev_value = 0, None result = [] while max_heap: count, value = heapq.heappop(max_heap) result.append(value) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_value)) prev_count, prev_value = count + 1, value if len(result) != n: return [] # If we didn't use all elements, then it is not possible to rearrange. return result"}]`),E={name:"App",components:{PoemCard:S},data(){return{searchQuery:"",visibleCount:4,poemsData:R,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},j={class:"search-container"},D={class:"card-container"},P={key:0,class:"empty-state"},C=["disabled"],I={key:0},F={key:1};function O(i,e,u,_,r,a){const f=h("PoemCard");return s(),n("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",j,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>r.searchQuery=o),placeholder:"Search..."},null,512),[[b,r.searchQuery]]),r.searchQuery?(s(),n("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>r.searchQuery="")}," ✕ ")):l("",!0)]),t("div",D,[(s(!0),n(y,null,x(a.displayedPoems,(o,p)=>(s(),v(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),n("div",P,' No results found for "'+c(r.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),n("button",{key:0,class:"load-more-button",disabled:r.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[r.isLoading?(s(),n("span",F,"Loading...")):(s(),n("span",I,"See more"))],8,C)):l("",!0)])}const z=m(E,[["render",O],["__scopeId","data-v-1d03b1f1"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"grok/66.md","filePath":"grok/66.md"}'),Y={name:"grok/66.md"},G=Object.assign(Y,{setup(i){return(e,u)=>(s(),n("div",null,[w(z)]))}});export{B as __pageData,G as default};
