import{_ as d,o as s,c as i,a as t,m as c,t as _,C as h,M as g,U as b,f as l,F as y,p as x,e as v,q as w}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},T={class:"review"},L={class:"review-title"},N={class:"review-content"};function S(n,e,u,m,r,a){return s(),i("div",k,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(_(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(_(u.poem.solution),1)])])])}const E=d(q,[["render",S],["__scopeId","data-v-804c58da"]]),R=JSON.parse(`[{"question":"def digit_to_word(n: int) -> str: Converts an integer (0-9999) to its word representation in English. >>> digit_to_word(123) \\"one hundred twenty three\\" >>> digit_to_word(45) \\"forty five\\" >>> digit_to_word(900) \\"nine hundred\\" def process_cases(T: int, cases: List[int]) -> List[str]: Processes multiple test cases. >>> process_cases(3, [123, 45, 900]) [\\"one hundred twenty three\\", \\"forty five\\", \\"nine hundred\\"]","solution":"def digit_to_word(n): Converts an integer (0-9999) to its word representation in English. if n == 0: return \\"zero\\" units = [\\"\\", \\"one\\", \\"two\\", \\"three\\", \\"four\\", \\"five\\", \\"six\\", \\"seven\\", \\"eight\\", \\"nine\\"] teens = [\\"ten\\", \\"eleven\\", \\"twelve\\", \\"thirteen\\", \\"fourteen\\", \\"fifteen\\", \\"sixteen\\", \\"seventeen\\", \\"eighteen\\", \\"nineteen\\"] tens = [\\"\\", \\"\\", \\"twenty\\", \\"thirty\\", \\"forty\\", \\"fifty\\", \\"sixty\\", \\"seventy\\", \\"eighty\\", \\"ninety\\"] thousands = [\\"\\", \\"one thousand\\", \\"two thousand\\", \\"three thousand\\", \\"four thousand\\", \\"five thousand\\", \\"six thousand\\", \\"seven thousand\\", \\"eight thousand\\", \\"nine thousand\\"] words = [] if n // 1000 > 0: words.append(thousands[n // 1000]) n %= 1000 if n // 100 > 0: words.append(units[n // 100]) words.append(\\"hundred\\") n %= 100 if 10 <= n <= 19: words.append(teens[n - 10]) else: if n // 10 > 0: words.append(tens[n // 10]) if n % 10 > 0: words.append(units[n % 10]) return ' '.join(words).strip() def process_cases(T, cases): results = [] for number in cases: results.append(digit_to_word(number)) return results"},{"question":"def has_robot_returned_to_origin(s: str) -> str: Determines if the robot returns to the origin after following the sequence of commands. Parameters: s: A string of commands 'U', 'D', 'L', 'R'. Returns: \\"YES\\" if robot returns to the origin, \\"NO\\" otherwise. Examples: >>> has_robot_returned_to_origin(\\"UD\\") \\"YES\\" >>> has_robot_returned_to_origin(\\"LL\\") \\"NO\\" >>> has_robot_returned_to_origin(\\"UUDDLRLR\\") \\"YES\\" from has_robot_returned_to_origin import has_robot_returned_to_origin def test_robot_returns_to_origin(): assert has_robot_returned_to_origin(\\"UD\\") == \\"YES\\" def test_robot_does_not_return_to_origin(): assert has_robot_returned_to_origin(\\"LL\\") == \\"NO\\" def test_robot_returns_with_complex_movement(): assert has_robot_returned_to_origin(\\"UUDDLRLR\\") == \\"YES\\" def test_robot_with_single_command(): assert has_robot_returned_to_origin(\\"U\\") == \\"NO\\" assert has_robot_returned_to_origin(\\"D\\") == \\"NO\\" assert has_robot_returned_to_origin(\\"L\\") == \\"NO\\" assert has_robot_returned_to_origin(\\"R\\") == \\"NO\\" def test_robot_with_imbalanced_commands(): assert has_robot_returned_to_origin(\\"UUUUDDDDLLLLRRRR\\") == \\"YES\\" assert has_robot_returned_to_origin(\\"UUULLLRRR\\") == \\"NO\\"","solution":"def has_robot_returned_to_origin(s): Determines if the robot returns to the origin after following the sequence of commands. Parameters: s (str): A string of commands 'U', 'D', 'L', 'R'. Returns: str: \\"YES\\" if robot returns to the origin, \\"NO\\" otherwise. # Initialize starting position x, y = 0, 0 # Iterate through the command string for command in s: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 # Check if robot is back at the origin return \\"YES\\" if x == 0 and y == 0 else \\"NO\\""},{"question":"def longest_subarray_length(arr, N, D): Finds the length of the longest contiguous subarray where the difference between the maximum and minimum values in the subarray is less than or equal to D. >>> longest_subarray_length([1, 3, 6, 7, 9, 2], 6, 3) == 3 >>> longest_subarray_length([1, 2, 3, 4, 5], 5, 2) == 3 >>> longest_subarray_length([10, 1, 2, 4, 7, 2], 6, 5) == 4 >>> longest_subarray_length([1, 1, 1, 1, 1], 5, 0) == 5 >>> longest_subarray_length([5, 4, 3, 2, 1], 5, 4) == 5 >>> longest_subarray_length([10, 5, 2, 7, 8, 7], 6, 3) == 3","solution":"def longest_subarray_length(arr, N, D): Finds the length of the longest contiguous subarray where the difference between the maximum and minimum values in the subarray is less than or equal to D. max_len = 0 start = 0 min_val = arr[0] max_val = arr[0] for end in range(N): min_val = min(min_val, arr[end]) max_val = max(max_val, arr[end]) while max_val - min_val > D: start += 1 min_val = min(arr[start:end+1]) max_val = max(arr[start:end+1]) max_len = max(max_len, end - start + 1) return max_len # Drive function to read input and call the core function if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) D = int(data[1]) arr = list(map(int, data[2:])) print(longest_subarray_length(arr, N, D))"},{"question":"def is_prime(n: int) -> bool: Check if a number is prime >>> is_prime(1) False >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False def is_tree_beautiful(h: int) -> str: Determines if a perfect binary tree of height h is beautiful. A tree is beautiful if the number of non-leaf nodes is a prime number. >>> is_tree_beautiful(1) \\"NO\\" >>> is_tree_beautiful(2) \\"YES\\" >>> is_tree_beautiful(3) \\"YES\\" >>> is_tree_beautiful(4) \\"NO\\" >>> is_tree_beautiful(10) \\"NO\\" >>> is_tree_beautiful(20) \\"NO\\"","solution":"def is_prime(n): Check if a number is prime if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def is_tree_beautiful(h): Determines if a perfect binary tree of height h is beautiful. A tree is beautiful if the number of non-leaf nodes is a prime number. # Number of non-leaf nodes in a perfect binary tree of height h # The number of nodes at level i is 2^i # The total number of nodes in a perfect binary tree of height h is 2^(h+1) - 1 # The number of leaf nodes is 2^h # So, the number of non-leaf nodes is (2^(h+1) - 1) - 2^h = 2^h - 1 num_non_leaf_nodes = 2**h - 1 return \\"YES\\" if is_prime(num_non_leaf_nodes) else \\"NO\\""},{"question":"def unique_paths(n: int, m: int, grid: List[List[str]]) -> int: Determine the number of unique paths the treasure hunter can take to reach the treasure located at the bottom-right corner of the grid without stepping on an impassable cell. >>> unique_paths(3, 3, [['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.']]) 2 >>> unique_paths(3, 3, [['.', '.', '.'], ['#', '#', '.'], ['.', '.', '.']]) 1 >>> unique_paths(4, 4, [['.', '.', '.', '.'], ['.', '#', '.', '.'], ['.', '.', '#', '.'], ['.', '.', '.', '.']]) 4 from typing import List def test_example_case_1(): grid = [ ['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.'] ] assert unique_paths(3, 3, grid) == 2 def test_example_case_2(): grid = [ ['.', '.', '.'], ['#', '#', '.'], ['.', '.', '.'] ] assert unique_paths(3, 3, grid) == 1 def test_example_case_3(): grid = [ ['.', '.', '.', '.'], ['.', '#', '.', '.'], ['.', '.', '#', '.'], ['.', '.', '.', '.'] ] assert unique_paths(4, 4, grid) == 4 def test_no_possible_path(): grid = [ ['.', '#'], ['#', '.'] ] assert unique_paths(2, 2, grid) == 0 def test_entire_grid_passable(): grid = [ ['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.'] ] assert unique_paths(3, 3, grid) == 6 def test_starting_blocked(): grid = [ ['#', '.', '.'], ['.', '.', '.'], ['.', '.', '.'] ] assert unique_paths(3, 3, grid) == 0 def test_ending_blocked(): grid = [ ['.', '.', '.'], ['.', '.', '.'], ['.', '.', '#'] ] assert unique_paths(3, 3, grid) == 0","solution":"def unique_paths(n, m, grid): if grid[0][0] == '#' or grid[n-1][m-1] == '#': return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1]"},{"question":"def problems_solved_by_teams(n: int, m: int, problems: List[int], teams: List[int]) -> List[int]: Determines the number of problems each team can solve. :param n: Number of problems :param m: Number of teams :param problems: List of problem difficulties :param teams: List of team skill levels :return: List of integers representing the number of problems each team can solve Examples: >>> problems_solved_by_teams(5, 3, [4, 8, 7, 5, 6], [3, 10, 4]) [0, 5, 1] >>> problems_solved_by_teams(6, 4, [1, 2, 3, 4, 5, 6], [6, 1, 3, 4]) [6, 1, 3, 4]","solution":"def problems_solved_by_teams(n, m, problems, teams): Determines the number of problems each team can solve. :param n: Number of problems :param m: Number of teams :param problems: List of problem difficulties :param teams: List of team skill levels :return: List of integers representing the number of problems each team can solve problems.sort() result = [] for skill in teams: # Find the number of problems the team can solve count = 0 for difficulty in problems: if skill >= difficulty: count += 1 else: break # As problems are sorted, no need to check further result.append(count) return result"},{"question":"import heapq from typing import List, Tuple def shortest_time_to_cities(N: int, M: int, roads: List[Tuple[int, int, int]]) -> List[int]: Given a number of cities and one-way roads between them, determine the shortest time to travel from the capital city (city 1) to each of the other cities. Args: N: An integer, the number of cities. M: An integer, the number of roads. roads: A list of tuples representing the roads, where each tuple contains three integers (X, Y, L), with X being the start city, Y being the end city, and L being the travel time. Returns: A list of N-1 integers representing the shortest time to reach each city from city 1 in order from city 2 to city N. If a city is not reachable, return -1 for that city. >>> shortest_time_to_cities(4, 4, [(1, 2, 24), (1, 3, 3), (3, 4, 12), (2, 4, 15)]) [24, 3, 15] >>> shortest_time_to_cities(3, 1, [(2, 3, 10)]) [-1, -1] def test_shortest_time_to_cities_example_1(): N = 4 M = 4 roads = [ (1, 2, 24), (1, 3, 3), (3, 4, 12), (2, 4, 15) ] assert shortest_time_to_cities(N, M, roads) == [24, 3, 15] def test_shortest_time_to_cities_example_2(): N = 3 M = 1 roads = [ (2, 3, 10) ] assert shortest_time_to_cities(N, M, roads) == [-1, -1] def test_shortest_time_to_cities_no_connections(): N = 4 M = 0 roads = [] assert shortest_time_to_cities(N, M, roads) == [-1, -1, -1] def test_shortest_time_to_cities_single_connection(): N = 3 M = 1 roads = [ (1, 2, 5) ] assert shortest_time_to_cities(N, M, roads) == [5, -1] def test_shortest_time_to_cities_multiple_connections(): N = 5 M = 6 roads = [ (1, 2, 2), (1, 3, 3), (2, 4, 4), (3, 4, 1), (4, 5, 1), (5, 3, 1) ] assert shortest_time_to_cities(N, M, roads) == [2, 3, 4, 5]","solution":"import heapq def shortest_time_to_cities(N, M, roads): # Create adjacency list to represent the graph graph = {i: [] for i in range(1, N+1)} for x, y, l in roads: graph[x].append((y, l)) # Dijkstra's algorithm to find shortest path from city 1 distances = {i: float('inf') for i in range(1, N+1)} distances[1] = 0 priority_queue = [(0, 1)] # (distance, node) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) # Extract shortest times and convert unreachable to -1 result = [] for city in range(2, N+1): if distances[city] == float('inf'): result.append(-1) else: result.append(distances[city]) return result # Sample input for manual testing # N, M = 4, 4 # roads = [ # (1, 2, 24), # (1, 3, 3), # (3, 4, 12), # (2, 4, 15) # ] # print(shortest_time_to_cities(N, M, roads)) # Expected output: [24, 3, 15]"},{"question":"def min_number_of_trucks(n: int, weights: List[int], max_weight: int) -> int: Determines the minimum number of trucks required to transport all crates. Parameters: n (int): The number of crates. weights (list): A list of integers representing the weight of each crate. max_weight (int): The maximum allowable weight for each truck. Returns: int: The minimum number of trucks needed. >>> min_number_of_trucks(5, [2, 3, 5, 8, 3], 10) 3 >>> min_number_of_trucks(4, [4, 8, 2, 6], 15) 2 >>> min_number_of_trucks(3, [1, 1, 1], 2) 2 >>> min_number_of_trucks(6, [10, 9, 8, 7, 7, 1], 10) 5 >>> min_number_of_trucks(10, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 10) 1 >>> min_number_of_trucks(3, [4, 4, 4], 5) 3 >>> min_number_of_trucks(4, [9, 9, 9, 9], 10) 4","solution":"def min_number_of_trucks(n, weights, max_weight): Determines the minimum number of trucks required to transport all crates. Parameters: n (int): The number of crates. weights (list): A list of integers representing the weight of each crate. max_weight (int): The maximum allowable weight for each truck. Returns: int: The minimum number of trucks needed. weights.sort(reverse=True) trucks = [] for weight in weights: placed = False for i in range(len(trucks)): if trucks[i] + weight <= max_weight: trucks[i] += weight placed = True break if not placed: trucks.append(weight) return len(trucks)"},{"question":"def count_k_distinct_substrings(s: str, k: int) -> int: Given a string \`s\` and an integer \`k\`, find the count of all substrings of \`s\` that contain exactly \`k\` distinct characters. Args: s (str): The input string. k (int): The number of distinct characters. Returns: int: The count of substrings containing exactly \`k\` distinct characters. Example: >>> count_k_distinct_substrings(\\"pqpqs\\", 2) 7 >>> count_k_distinct_substrings(\\"aabab\\", 3) 0","solution":"def count_k_distinct_substrings(s, k): from collections import defaultdict n = len(s) result = 0 # Traverse s using a sliding window approach for i in range(n): distinct_count = 0 freq = defaultdict(int) for j in range(i, n): if freq[s[j]] == 0: distinct_count += 1 freq[s[j]] += 1 if distinct_count == k: result += 1 elif distinct_count > k: break return result"},{"question":"def count_special_pairs(nums: List[int], k: int) -> int: Returns the number of special pairs from the given list nums, such that the sum of these pairs is a multiple of k. >>> count_special_pairs([1, 2, 3, 4, 5], 3) 4 >>> count_special_pairs([1, 2, 3], 10) 0 >>> count_special_pairs([3, 6, 9], 3) 3 >>> count_special_pairs([5], 3) 0 >>> count_special_pairs([1000000000, 2000000000, 3000000000], 1000000) 3","solution":"def count_special_pairs(nums, k): Returns the number of special pairs from the given list nums, such that the sum of these pairs is a multiple of k. count = 0 n = len(nums) # Iterate over all pairs and check if their sum is a multiple of k for i in range(n): for j in range(i + 1, n): if (nums[i] + nums[j]) % k == 0: count += 1 return count"},{"question":"def can_fulfill_orders(n: int, m: int, orders: List[Tuple[int, int]]) -> str: Determines if the bakery can fulfill all the orders within the baking limit. Parameters: n (int): Number of orders. m (int): Daily baking limit. orders (list of tuples): Each tuple contains (type, quantity) for each order. Returns: str: \\"YES\\" if the bakery can fulfill all orders within the limit, \\"NO\\" otherwise. >>> can_fulfill_orders(3, 150, [(1, 30), (2, 60), (3, 50)]) 'YES' >>> can_fulfill_orders(4, 200, [(1, 80), (2, 70), (3, 60), (1, 50)]) 'NO'","solution":"def can_fulfill_orders(n, m, orders): Determines if the bakery can fulfill all the orders within the baking limit. Parameters: n (int): Number of orders. m (int): Daily baking limit. orders (list of tuples): Each tuple contains (type, quantity) for each order. Returns: str: \\"YES\\" if the bakery can fulfill all orders within the limit, \\"NO\\" otherwise. total_quantity = sum(quantity for _, quantity in orders) return \\"YES\\" if total_quantity <= m else \\"NO\\""},{"question":"def max_operations(n: int, a: List[int]) -> int: Returns the maximum number of operations that can be performed on the array. >>> max_operations(4, [1, 2, 3, 4]) 6 >>> max_operations(5, [1, 5, 5, 5, 5]) 4 >>> max_operations(3, [3, 3, 3]) 0","solution":"def max_operations(n, a): Returns the maximum number of operations that can be performed on the array. operations = 0 # Iterate through the array for i in range(n - 1): for j in range(i + 1, n): if a[i] < a[j]: operations += 1 return operations"},{"question":"import re def evaluate_password_strength(password: str) -> str: Evaluates the strength of the given password based on the following criteria: 1. It has at least 8 characters. 2. It contains at least one uppercase letter. 3. It contains at least one lowercase letter. 4. It contains at least one digit. 5. It contains at least one special character from the set: !@#%^&*()_+-=[]{}|;:'\\",.<>?/ Args: password (str): The password to be evaluated. Returns: str: \\"Strong\\" if the password meets all the criteria, and \\"Weak\\" otherwise. >>> evaluate_password_strength(\\"Password123!\\") == \\"Strong\\" >>> evaluate_password_strength(\\"Pas1!\\") == \\"Weak\\" >>> evaluate_password_strength(\\"password123!\\") == \\"Weak\\" >>> evaluate_password_strength(\\"PASSWORD123!\\") == \\"Weak\\" >>> evaluate_password_strength(\\"Password!!!\\") == \\"Weak\\" >>> evaluate_password_strength(\\"Password123\\") == \\"Weak\\" >>> evaluate_password_strength(\\"password\\") == \\"Weak\\" >>> evaluate_password_strength(\\"PASSWORD\\") == \\"Weak\\" >>> evaluate_password_strength(\\"12345678\\") == \\"Weak\\" >>> evaluate_password_strength(\\"!@#%^&*()\\") == \\"Weak\\"","solution":"import re def evaluate_password_strength(password): Evaluates the strength of the given password based on the following criteria: 1. It has at least 8 characters. 2. It contains at least one uppercase letter. 3. It contains at least one lowercase letter. 4. It contains at least one digit. 5. It contains at least one special character from the set: !@#%^&*()_+-=[]{}|;:'\\",.<>?/ Args: password (str): The password to be evaluated. Returns: str: \\"Strong\\" if the password meets all the criteria, and \\"Weak\\" otherwise. if len(password) < 8: return \\"Weak\\" if not re.search(r'[A-Z]', password): return \\"Weak\\" if not re.search(r'[a-z]', password): return \\"Weak\\" if not re.search(r'[0-9]', password): return \\"Weak\\" if not re.search(r'[!@#%^&*()_+-=[]{}|;:'\\",.<>?/]', password): return \\"Weak\\" return \\"Strong\\""},{"question":"def max_palindrome_substrings(n: int, s: str) -> int: Returns the maximum number of palindrome substrings by removing some characters. :param n: Length of the string :param s: The string of lowercase English letters :return: The maximum number of palindromes >>> max_palindrome_substrings(6, \\"abacbc\\") 3 >>> max_palindrome_substrings(1, \\"a\\") 1 >>> max_palindrome_substrings(4, \\"abcd\\") 4 >>> max_palindrome_substrings(5, \\"aaaaa\\") 1 >>> max_palindrome_substrings(7, \\"abbaccc\\") 3 >>> max_palindrome_substrings(10, \\"abcdeedcba\\") 5","solution":"def max_palindrome_substrings(n, s): Returns the maximum number of palindrome substrings by removing some characters. :param n: Length of the string :param s: The string :return: The maximum number of palindromes char_set = set(s) return len(char_set)"},{"question":"def most_frequent_word(s: str) -> str: Finds the word that appears most frequently in the given string. If multiple words have the same highest frequency, returns the one that appears first. >>> most_frequent_word(\\"apple banana apple strawberry banana apple\\") \\"apple\\" >>> most_frequent_word(\\"dog cat dog fish dog cat cat fish dog\\") \\"dog\\"","solution":"def most_frequent_word(s): Finds the word that appears most frequently in the given string. If multiple words have the same highest frequency, returns the one that appears first. words = s.split() frequency = {} for word in words: if word in frequency: frequency[word] += 1 else: frequency[word] = 1 max_freq = max(frequency.values()) for word in words: if frequency[word] == max_freq: return word"},{"question":"def can_partition(n, k, array): Determines if the array can be partitioned into k contiguous subarrays with equal sums. def process_test_cases(test_cases): Processes multiple test cases for the partition problem. results = [] for n, k, array in test_cases: result = can_partition(n, k, array) results.append(result) return results import pytest def test_can_partition(): assert can_partition(6, 3, [2, 1, 2, 1, 2, 1]) == \\"Yes\\" assert can_partition(6, 2, [2, 1, 1, 2, 2, 1]) == \\"No\\" assert can_partition(5, 5, [1, 2, 3, 4, 5]) == \\"No\\" assert can_partition(4, 2, [1, 1, 1, 1]) == \\"Yes\\" assert can_partition(1, 1, [5]) == \\"Yes\\" assert can_partition(8, 4, [1, 1, 1, 1, 1, 1, 1, 1]) == \\"Yes\\" assert can_partition(10, 2, [10, 1, 2, 3, 4, 5, 6, 7, 8, 9]) == \\"No\\" def test_process_test_cases(): input_test_cases = [ (6, 3, [2, 1, 2, 1, 2, 1]), (6, 2, [2, 1, 1, 2, 2, 1]), (5, 5, [1, 2, 3, 4, 5]), (4, 2, [1, 1, 1, 1]) ] expected_output = [\\"Yes\\", \\"No\\", \\"No\\", \\"Yes\\"] assert process_test_cases(input_test_cases) == expected_output if __name__ == '__main__': pytest.main()","solution":"def can_partition(n, k, array): Determines if the array can be partitioned into k contiguous subarrays with equal sums. total_sum = sum(array) # Check if the total sum is divisible by k if total_sum % k != 0: return \\"No\\" # Each partition must have this sum target_sum = total_sum // k current_sum = 0 partitions = 0 for num in array: current_sum += num if current_sum == target_sum: partitions += 1 current_sum = 0 if partitions == k: return \\"Yes\\" else: return \\"No\\" def process_test_cases(test_cases): results = [] for n, k, array in test_cases: result = can_partition(n, k, array) results.append(result) return results"},{"question":"def can_arrange_objects(total_objects: int, max_per_row: int) -> str: Determine if it's possible to arrange objects in rows such that each row has more or equal objects than the previous row and not exceeding the maximum limit per row. >>> can_arrange_objects(15, 5) == \\"YES\\" >>> can_arrange_objects(10, 10) == \\"YES\\" >>> can_arrange_objects(20, 4) == \\"NO\\" >>> can_arrange_objects(500000500000, 1000000) == \\"YES\\" >>> can_arrange_objects(1000000000000, 1000000) == \\"NO\\"","solution":"def can_arrange_objects(total_objects, max_per_row): current_objects = 0 row_count = 0 while total_objects > current_objects and row_count < max_per_row: row_count += 1 current_objects += row_count if current_objects == total_objects: return \\"YES\\" return \\"NO\\""},{"question":"def find_pair_with_sum(n: int, arr: list[int], target: int): Determine if there is a pair of indices (i, j) such that i < j and the sum of elements at these indices is equal to the target value. Args: n (int): Number of elements in the array. arr (list of int): The elements of the array. target (int): The target sum. Returns: tuple: \\"YES\\" and the 1-based indices (i, j) if such a pair is found, \\"NO\\" otherwise. >>> find_pair_with_sum(5, [1, 2, 3, 4, 5], 8) (\\"YES\\", 3, 5) >>> find_pair_with_sum(4, [1, 1, 1, 1], 2) (\\"YES\\", 1, 2) >>> find_pair_with_sum(3, [1, 5, 9], 20) \\"NO\\"","solution":"def find_pair_with_sum(n, arr, target): Determine if there is a pair of indices (i, j) such that i < j and the sum of elements at these indices is equal to the target value. Args: n (int): Number of elements in the array. arr (list of int): The elements of the array. target (int): The target sum. Returns: tuple: \\"YES\\" and the 1-based indices (i, j) if such a pair is found, \\"NO\\" otherwise. # Dictionary to store the value and its index value_index = {} for i in range(n): # Calculate the complement of the current value with the target complement = target - arr[i] # If the complement is found in the dictionary, return the answer if complement in value_index: return \\"YES\\", value_index[complement] + 1, i + 1 # Store the index of the current value value_index[arr[i]] = i return \\"NO\\""},{"question":"def process_string(input_str: str) -> int: Processes the input string as per the given rules. If the string starts with 'B', returns the sum of the digits. If the string starts with 'C', returns the difference between the sum of digits and the position of the first digit (1). Parameters: input_str (str): The input string of 8 characters starting with 'B' or 'C' followed by 7 digits. Returns: int: The computed result based on the rules. >>> process_string('B1234567') 28 >>> process_string('B7654321') 28 >>> process_string('C1234567') 22 >>> process_string('C7654321') 16","solution":"def process_string(input_str): Processes the input string as per the given rules. If the string starts with 'B', returns the sum of the digits. If the string starts with 'C', returns the difference between the sum of digits and the position of the first digit (1). Parameters: input_str (str): The input string of 8 characters starting with 'B' or 'C' followed by 7 digits. Returns: int: The computed result based on the rules. if not input_str or len(input_str) != 8 or input_str[0] not in {'B', 'C'} or not input_str[1:].isdigit(): raise ValueError(\\"Invalid input format\\") digits = list(map(int, input_str[1:])) digit_sum = sum(digits) if input_str[0] == 'B': return digit_sum elif input_str[0] == 'C': return digit_sum - 1 return 0 # Should never reach here due to input guarantee"},{"question":"def largest_divisible_subset(nums: List[int]) -> List[int]: Find the largest divisible subset from a given list of integers. A subset is called divisible if for every pair (x, y) of elements in this subset, either x % y == 0 or y % x == 0. Args: nums (List[int]): A list of distinct positive integers. Returns: List[int]: The largest subset where every pair of elements satisfies the divisibility condition. Examples: >>> sorted(largest_divisible_subset([1, 2, 4, 8, 3, 9])) [1, 2, 4, 8] >>> sorted(largest_divisible_subset([2, 3, 4, 9, 27])) [3, 9, 27] >>> sorted(largest_divisible_subset([6, 10, 15])) [6] >>> sorted(largest_divisible_subset([1])) [1] >>> sorted(largest_divisible_subset([1, 2, 4, 8, 16, 3, 9, 27])) [1, 2, 4, 8, 16] >>> sorted(largest_divisible_subset([2, 5, 7])) in [[2], [5], [7]] True >>> sorted(largest_divisible_subset([17, 31, 19, 23])) in [[17], [31], [19], [23]] True","solution":"def largest_divisible_subset(nums): if not nums: return [] nums.sort() dp = [] for num in nums: max_subset = [] for subset in dp: if num % subset[-1] == 0: if len(subset) > len(max_subset): max_subset = subset new_subset = max_subset + [num] dp.append(new_subset) return max(dp, key=len)"},{"question":"def stair_building_visible_area(n: int, k: int, levels: List[Tuple[int, int]]) -> Tuple[float, float]: Calculates the total visible area of the \\"Stair Building\\" and the highest y-coordinate. Args: n: int - number of levels k: int - width of each level levels: List[Tuple[int, int]] - list of tuples representing (xi, yi) coordinates for each level Returns: Tuple[float, float] - total visible area and the highest y-coordinate >>> stair_building_visible_area(3, 4, [(1, 3), (3, 5), (5, 8)]) (12.0, 8.0) >>> stair_building_visible_area(2, 2, [(1, 2), (2, 5)]) (4.0, 5.0) pass from typing import List, Tuple def test_case_1(): assert stair_building_visible_area(3, 4, [(1, 3), (3, 5), (5, 8)]) == (12.0, 8.0) def test_case_2(): assert stair_building_visible_area(2, 2, [(1, 2), (2, 5)]) == (4.0, 5.0) def test_single_level(): assert stair_building_visible_area(1, 5, [(2, 3)]) == (5.0, 3.0) def test_multiple_levels_same_height(): assert stair_building_visible_area(3, 3, [(1, 4), (3, 4), (5, 4)]) == (9.0, 4.0) def test_multiple_levels_different_widths(): assert stair_building_visible_area(4, 6, [(2, 1), (3, 2), (4, 6), (5, 10)]) == (24.0, 10.0)","solution":"def stair_building_visible_area(n, k, levels): Calculates the total visible area of the \\"Stair Building\\" and the highest y-coordinate. total_area = n * k # Each level contributes exactly k * 1 area unit highest_y = max(yi for _, yi in levels) return total_area, highest_y"},{"question":"def longest_adjacent_subsequence_diff_1(arr): Calculates the length of the longest subsequence where the difference between every adjacent element is exactly 1. >>> longest_adjacent_subsequence_diff_1([1, 2, 3, 4, 5, 6]) 6 >>> longest_adjacent_subsequence_diff_1([1, 2, 2, 3, 4, 5, 5, 6]) 6 >>> longest_adjacent_subsequence_diff_1([10, 9, 4, 5, 5]) 2 >>> longest_adjacent_subsequence_diff_1([]) 0 >>> longest_adjacent_subsequence_diff_1([1]) 1 >>> longest_adjacent_subsequence_diff_1([5, 5, 5, 5]) 1 >>> longest_adjacent_subsequence_diff_1([1, 3, 5, 7, 9]) 1 >>> longest_adjacent_subsequence_diff_1([-2, -1, 0, 1, 2]) 5 >>> longest_adjacent_subsequence_diff_1([1, 2, 3, 3, 4, 4, 5, 1, 2, 2, 3]) 5","solution":"def longest_adjacent_subsequence_diff_1(arr): Calculates the length of the longest subsequence where the difference between every adjacent element is exactly 1. from collections import defaultdict if not arr: return 0 count = defaultdict(int) max_length = 1 for num in arr: count[num] = max(count[num], count[num-1] + 1) max_length = max(max_length, count[num]) return max_length"},{"question":"import itertools from typing import List, Tuple def minimum_travel_time(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Determine the minimum total travel time for a round trip that visits all delivery points exactly once and returns to the warehouse. Args: n (int): number of delivery points (including the warehouse) m (int): number of roads roads (List[Tuple[int, int, int]]): list of roads where each road is represented as a tuple (u, v, t) Returns: int: minimum total travel time for a round trip Examples: >>> minimum_travel_time(4, 6, [(1, 2, 10), (1, 3, 15), (1, 4, 20), (2, 3, 35), (2, 4, 25), (3, 4, 30)]) 80 >>> minimum_travel_time(2, 1, [(1, 2, 10)]) 20 def test_example_case(): n, m = 4, 6 roads = [ (1, 2, 10), (1, 3, 15), (1, 4, 20), (2, 3, 35), (2, 4, 25), (3, 4, 30) ] assert minimum_travel_time(n, m, roads) == 80 def test_two_points_case(): n, m = 2, 1 roads = [ (1, 2, 10), ] assert minimum_travel_time(n, m, roads) == 20 def test_case_with_three_points(): n, m = 3, 3 roads = [ (1, 2, 10), (1, 3, 20), (2, 3, 30) ] assert minimum_travel_time(n, m, roads) == 60 def test_case_with_separate_paths(): n, m = 4, 6 roads = [ (1, 2, 10), (2, 3, 15), (1, 4, 10), (4, 3, 5), (1, 3, 50), (2, 4, 50) ] assert minimum_travel_time(n, m, roads) == 40","solution":"import itertools def calculate_min_travel_time(n, roads): # Create a 2D array (matrix) to store the travel times between points travel_times = [[float('inf')] * n for _ in range(n)] # Fill in the travel times from the roads data for u, v, t in roads: travel_times[u-1][v-1] = t travel_times[v-1][u-1] = t # Initialize the minimum travel time min_travel_time = float('inf') # Generate all permutations of delivery points (except the first point, which is the starting point) points = list(range(1, n)) for perm in itertools.permutations(points): # Calculate the travel time for this permutation current_time = 0 current_time += travel_times[0][perm[0]] for i in range(len(perm) - 1): current_time += travel_times[perm[i]][perm[i + 1]] current_time += travel_times[perm[-1]][0] # Update the minimum travel time min_travel_time = min(min_travel_time, current_time) return min_travel_time def minimum_travel_time(n, m, roads): return calculate_min_travel_time(n, roads)"},{"question":"def max_bloom_days(N, durations): Returns the maximum number of consecutive days the garden will bloom. Parameters: N (int): number of different flower seeds. durations (list of int): list of integers representing the number of days each flower seed blooms. Returns: int: maximum number of consecutive blooming days. >>> max_bloom_days(3, [4, 2, 1]) 7 >>> max_bloom_days(5, [10, 5, 2, 1, 3]) 21 pass def test_example_cases(): assert max_bloom_days(3, [4, 2, 1]) == 7 assert max_bloom_days(5, [10, 5, 2, 1, 3]) == 21 def test_single_seed(): assert max_bloom_days(1, [10]) == 10 assert max_bloom_days(1, [1]) == 1 def test_all_same_duration(): assert max_bloom_days(4, [5, 5, 5, 5]) == 20 assert max_bloom_days(3, [3, 3, 3]) == 9 def test_diverse_durations(): assert max_bloom_days(4, [1, 4, 6, 3]) == 14 assert max_bloom_days(6, [1, 2, 2, 3, 4, 10]) == 22 def test_edge_cases(): assert max_bloom_days(1, [100]) == 100 assert max_bloom_days(2, [1, 2]) == 3 assert max_bloom_days(3, [10, 20, 30]) == 60","solution":"def max_bloom_days(N, durations): Returns the maximum number of consecutive days the garden will bloom. Parameters: N (int): number of different flower seeds. durations (list of int): list of integers representing the number of days each flower seed blooms. Returns: int: maximum number of consecutive blooming days. durations.sort() return sum(durations)"},{"question":"def two_sum(arr, target): Returns the indices of the two numbers in \`arr\` that add up to \`target\`. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([1, 2, 3, 4, 5], 9) [3, 4] >>> two_sum([-3, 4, 3, 90], 0) [0, 2] >>> two_sum([0, 4, 3, 0], 0) [0, 3] >>> two_sum([1000000, -1000000, 4, 6], 0) [0, 1] >>> two_sum([1, 2], 3) [0, 1]","solution":"def two_sum(arr, target): Returns the indices of the two numbers in \`arr\` that add up to \`target\`. :param arr: List of integers :param target: Target integer :return: List containing the indices of the two numbers index_map = {} for index, num in enumerate(arr): complement = target - num if complement in index_map: return [index_map[complement], index] index_map[num] = index return None"},{"question":"from typing import List def min_jumps(h: List[int], k: int) -> int: Determine the minimum number of jumps required to reach the last building. If it is not possible to reach the last building, return -1. Args: h: a list of integers representing the heights of the buildings. k: an integer representing the maximum number of buildings you can jump over. Returns: An integer which is the minimum number of jumps needed to reach the last building, or -1 if it is not possible. Examples: >>> min_jumps([1, 2, 3, 4, 5], 2) 2 >>> min_jumps([1, 3, 2, 4, 5], 3) 2 >>> min_jumps([5, 4, 3, 2, 1], 2) -1","solution":"def min_jumps(h, k): from collections import deque n = len(h) if n == 1: return 0 # Already at the last building queue = deque([(0, 0)]) # (current index, current jump count) visited = [False] * n visited[0] = True while queue: current, jumps = queue.popleft() for i in range(1, k + 1): next_index = current + i if next_index >= n: break if h[next_index] >= h[current] and not visited[next_index]: if next_index == n - 1: return jumps + 1 queue.append((next_index, jumps + 1)) visited[next_index] = True return -1"},{"question":"def max_subarray_sum(n: int, arr: List[int]) -> int: Determine the maximum sum of a non-empty subarray that can be obtained from the list. :param n: Integer, the size of the list. :param arr: List of integers, the elements of the list. :return: Integer, the maximum sum of any non-empty subarray. >>> max_subarray_sum(5, [-2, 1, -3, 4, -1]) 4 >>> max_subarray_sum(5, [1, 2, 3, -2, 5]) 9","solution":"def max_subarray_sum(n, arr): Returns the maximum sum of any non-empty subarray of the given list. :param n: Integer, the size of the list. :param arr: List of integers, the elements of the list. :return: Integer, the maximum sum of any non-empty subarray. if n == 0: return 0 # Initialize current sum and max sum with the first element of the array current_sum = max_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from typing import List, Tuple def minimize_max_diff(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum possible maximum difference in total book thickness between any two shelves. >>> minimize_max_diff(2, [(3, [10, 10, 10, 10]), (2, [1, 2, 3, 4, 5])]) [0, 1] >>> minimize_max_diff(1, [(1, [100, 200, 300, 400])]) [1000] >>> minimize_max_diff(1, [(5, [10, 20])]) [0] >>> minimize_max_diff(1, [(3, [1, 2, 3])]) [0] >>> minimize_max_diff(1, [(50, [1] * 50)]) [0]","solution":"def min_max_diff(n, books): total_sum = sum(books) # dp[i] will be True if sum 'i' can be achieved with some subset of books dp = [False] * (total_sum // 2 + 1) dp[0] = True for book in books: for j in range(total_sum // 2, book - 1, -1): if dp[j - book]: dp[j] = True for i in range(total_sum // 2, -1, -1): if dp[i]: first_part = i break second_part = total_sum - first_part return abs(second_part - first_part) def minimize_max_diff(T, test_cases): results = [] for t in range(T): n, books = test_cases[t] if n == 1: results.append(sum(books)) # If there is only one shelf, the difference is the total sum elif n >= len(books): results.append(0) # If shelves are more than or equal to books, difference is zero else: results.append(min_max_diff(n, books)) return results"},{"question":"class Solution: def __init__(self, n, tree_edges): from collections import defaultdict def dfs(self, node, par, d, weight): pass def compute_lca(self): pass def lca(self, u, v): pass def query(self, u, v): pass def solve(n, q, edges, queries): Determine the minimum energy required to complete each journey between specified trees. If energy generation is possible, output the maximum energy generated. Example: >>> n = 6 >>> q = 3 >>> edges = [ ... [1, 2, 4], ... [1, 3, -2], ... [3, 4, 1], ... [3, 5, -5], ... [5, 6, 3] ... ] >>> queries = [ ... [2, 4], ... [4, 6], ... [2, 5] ... ] >>> solve(n, q, edges, queries) [3, -1, -3] pass","solution":"class Solution: def __init__(self, n, tree_edges): from collections import defaultdict import sys # Initializations self.n = n self.graph = defaultdict(list) self.depth = [0] * (n + 1) self.parent = [0] * (n + 1) self.dist = [0] * (n + 1) self.LOG = 17 # ceil(log2(10^5)) + 1 self.lca_table = [[-1 for _ in range(self.LOG)] for __ in range(n + 1)] # Construct the graph for u, v, w in tree_edges: self.graph[u].append((v, w)) self.graph[v].append((u, w)) # Preprocess the tree self.dfs(1, -1, 0, 0) self.compute_lca() def dfs(self, node, par, d, weight): self.depth[node] = d self.parent[node] = par self.dist[node] = weight for neighbor, w in self.graph[node]: if neighbor != par: self.dfs(neighbor, node, d + 1, weight + w) def compute_lca(self): for i in range(1, self.n + 1): self.lca_table[i][0] = self.parent[i] for j in range(1, self.LOG): for i in range(1, self.n + 1): if self.lca_table[i][j - 1] != -1: self.lca_table[i][j] = self.lca_table[self.lca_table[i][j - 1]][j - 1] def lca(self, u, v): if self.depth[u] < self.depth[v]: u, v = v, u diff = self.depth[u] - self.depth[v] for i in range(self.LOG): if (diff >> i) & 1: u = self.lca_table[u][i] if u == v: return u for i in reversed(range(self.LOG)): if self.lca_table[u][i] != -1 and self.lca_table[u][i] != self.lca_table[v][i]: u = self.lca_table[u][i] v = self.lca_table[v][i] return self.parent[u] def query(self, u, v): lca_uv = self.lca(u, v) return self.dist[u] + self.dist[v] - 2 * self.dist[lca_uv] def solve(n, q, edges, queries): sol = Solution(n, edges) result = [] for ai, bi in queries: total_energy = sol.query(ai, bi) result.append(total_energy if total_energy < 0 else total_energy) return result"},{"question":"def max_total_difficulty(n: int, difficulties: List[int]) -> int: Returns the maximum possible total difficulty Vasya can achieve by optimally pairing up the participants for the tasks. :param n: an integer, the number of participants (n is always even) :param difficulties: list of integers, the difficulty levels assigned to each participant :return: an integer, the maximum possible total difficulty >>> max_total_difficulty(4, [1, 2, 3, 4]) 10 >>> max_total_difficulty(6, [4, 1, 6, 2, 5, 3]) 21","solution":"def max_total_difficulty(n, difficulties): Returns the maximum possible total difficulty Vasya can achieve by optimally pairing up the participants for the tasks. :param n: an integer, the number of participants (n is always even) :param difficulties: list of integers, the difficulty levels assigned to each participant :return: an integer, the maximum possible total difficulty difficulties.sort() total_difficulty = 0 for i in range(n // 2): total_difficulty += difficulties[i] + difficulties[n - 1 - i] return total_difficulty"},{"question":"def count_violations(heights): Returns the number of violation buildings in the skyline. A building is considered a \\"violation\\" if its height is strictly greater than the height of both of its adjacent towers. >>> count_violations([3, 4, 2, 5, 1, 3]) 2 >>> count_violations([3, 3, 3, 3, 3]) 0 >>> count_violations([5, 4, 3, 2, 1]) 0 >>> count_violations([1, 2, 3, 4, 5]) 0 >>> count_violations([1, 3, 1]) 1 >>> count_violations([1, 3, 1, 3, 1, 3, 1]) 3 >>> count_violations([1, 2, 2, 3]) 0 >>> count_violations([1, 2, 1, 3, 2, 1]) 2","solution":"def count_violations(heights): Returns the number of violation buildings in the skyline. A building is considered a \\"violation\\" if its height is strictly greater than the height of both of its adjacent towers. violations = 0 n = len(heights) for i in range(1, n-1): if heights[i] > heights[i-1] and heights[i] > heights[i+1]: violations += 1 return violations"},{"question":"def calculate_minutes(start_time: str, end_time: str) -> int: Calculates the total number of minutes between two timestamps in the format HH:MM. If end_time is earlier than start_time, the end time is considered to be on the next day. Args: start_time (str): Start time in HH:MM format. end_time (str): End time in HH:MM format. Returns: int: Total number of minutes between the two timestamps. >>> calculate_minutes(\\"14:30\\", \\"16:00\\") 90 >>> calculate_minutes(\\"23:45\\", \\"00:15\\") 30 >>> calculate_minutes(\\"08:00\\", \\"08:05\\") 5","solution":"def calculate_minutes(start_time, end_time): Calculates the total number of minutes between two timestamps in the format HH:MM. If end_time is earlier than start_time, the end time is considered to be on the next day. Args: start_time (str): Start time in HH:MM format. end_time (str): End time in HH:MM format. Returns: int: Total number of minutes between the two timestamps. start_hours, start_minutes = map(int, start_time.split(\\":\\")) end_hours, end_minutes = map(int, end_time.split(\\":\\")) start_total_minutes = start_hours * 60 + start_minutes end_total_minutes = end_hours * 60 + end_minutes if end_total_minutes < start_total_minutes: end_total_minutes += 24 * 60 return end_total_minutes - start_total_minutes"},{"question":"def calculate_total_blocks(n: int, m: int, grid: List[List[int]]) -> int: Calculates the total number of blocks required to construct the structure. :param n: Number of rows in the grid. :param m: Number of columns in the grid. :param grid: A 2D list of integers representing the number of blocks at each position. :return: An integer representing the total number of blocks. >>> calculate_total_blocks(3, 4, [ ... [3, 0, 2, 1], ... [1, 2, 1, 0], ... [4, 1, 2, 3] ... ]) 20 >>> calculate_total_blocks(3, 3, [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 >>> calculate_total_blocks(1, 1, [ ... [7] ... ]) 7 >>> calculate_total_blocks(3, 2, [ ... [1, 0], ... [2, 3], ... [4, 1] ... ]) 11 >>> calculate_total_blocks(3, 3, [ ... [100, 200, 300], ... [400, 500, 600], ... [700, 800, 900] ... ]) 4500 total_blocks = 0 for row in grid: total_blocks += sum(row) return total_blocks","solution":"def calculate_total_blocks(n, m, grid): Calculates the total number of blocks required to construct the structure. :param n: Number of rows in the grid. :param m: Number of columns in the grid. :param grid: A 2D list of integers representing the number of blocks at each position. :return: An integer representing the total number of blocks. total_blocks = 0 for row in grid: total_blocks += sum(row) return total_blocks"},{"question":"from typing import List def can_rearrange_to_valid_sequence(n: int, sequence: List[int]) -> str: Checks if it is possible to rearrange the sequence so that it contains at least one pair of neighboring numbers in ascending order. :param n: int, size of the sequence :param sequence: list of int, the sequence of lock codes :return: str, \\"YES\\" if a valid rearrangement is possible, otherwise \\"NO\\" >>> can_rearrange_to_valid_sequence(5, [3, 2, 5, 5, 1]) \\"YES\\" >>> can_rearrange_to_valid_sequence(4, [4, 4, 4, 4]) \\"NO\\"","solution":"def can_rearrange_to_valid_sequence(n, sequence): Checks if it is possible to rearrange the sequence so that it contains at least one pair of neighboring numbers in ascending order. :param n: int, size of the sequence :param sequence: list of int, the sequence of lock codes :return: str, \\"YES\\" if a valid rearrangement is possible, otherwise \\"NO\\" if n < 2: return \\"NO\\" sequence.sort() for i in range(1, n): if sequence[i] > sequence[i - 1]: return \\"YES\\" return \\"NO\\""},{"question":"def max_boxes_in_row(n: int, boxes: List[Tuple[int, int]]) -> int: Find the maximum number of boxes that can be placed in a row with each row strictly increasing in width and height. >>> max_boxes_in_row(5, [(4, 6), (7, 8), (6, 5), (3, 4), (4, 6)]) 3 >>> max_boxes_in_row(3, [(2, 3), (3, 4), (5, 3)]) 2","solution":"def max_boxes_in_row(n, boxes): def can_place(prev, curr): return prev[0] < curr[0] and prev[1] < curr[1] # Each box can either be taken as is or rotated transformed_boxes = [] for w, h in boxes: transformed_boxes.append((min(w, h), max(w, h))) transformed_boxes.sort() dp = [1] * n # Initialize the dp array with 1 for i in range(n): for j in range(i): if can_place(transformed_boxes[j], transformed_boxes[i]): dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def minimum_bikes(S: int, K: int, stands: List[int]) -> int: Calculate the minimum number of bikes required to ensure each station has at least one bike initially. S: number of stations K: number of stations with high demand stands: list of integers where each value represents the number of additional bikes required for high demand stations >>> minimum_bikes(5, 2, [3, 2]) 10 >>> minimum_bikes(8, 3, [1, 4, 2]) 16","solution":"def minimum_bikes(S, K, stands): Returns the minimum number of bikes required. S: number of stations K: number of stations with high demand stands: list of integers where each value represents the number of additional bikes required for high demand stations return S + sum(stands) if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() S = int(data[0]) K = int(data[1]) stands = list(map(int, data[2:2+K])) print(minimum_bikes(S, K, stands))"},{"question":"def max_castles_visited(n: int, T: int, roads: List[Tuple[int, int, int]]) -> int: Determine the maximum number of unique castles that can be visited without exceeding the total travel time of T minutes. >>> max_castles_visited(4, 100, [(1, 2, 10), (2, 3, 60), (3, 4, 30)]) 4 >>> max_castles_visited(2, 50, [(1, 2, 100)]) 1","solution":"def max_castles_visited(n, T, roads): import heapq from collections import defaultdict graph = defaultdict(list) for a, b, t in roads: graph[a].append((t, b)) graph[b].append((t, a)) # Using Dijkstra's algorithm to find the max castles visited with given time T heap = [(0, 1)] # (current_time, current_castle) visited = {1: 0} # {castle: min_time_to_reach} while heap: curr_time, curr_castle = heapq.heappop(heap) for travel_time, next_castle in graph[curr_castle]: next_time = curr_time + travel_time if next_time <= T and (next_castle not in visited or next_time < visited[next_castle]): visited[next_castle] = next_time heapq.heappush(heap, (next_time, next_castle)) return len(visited) # Example input road_list = [(1, 2, 10), (2, 3, 60), (3, 4, 30)] print(max_castles_visited(4, 100, road_list)) # Output: 4"},{"question":"from typing import List, Tuple def shortest_path(n: int, m: int, k: int, obstacles: List[Tuple[int, int]]) -> int: Find the length of the shortest path for a drone to travel from the starting point (1, 1) to the destination point (n, m) in a grid with obstacles. If it is not possible to reach the destination, return -1. >>> shortest_path(4, 4, 1, [(2, 2)]) 6 >>> shortest_path(3, 3, 4, [(1, 2), (2, 1), (2, 3), (3, 2)]) -1 Args: n : int : number of rows in the grid m : int : number of columns in the grid k : int : number of obstacles obstacles : list of tuples : coordinates of obstacles in the grid Returns: int : length of the shortest path, or -1 if it is not possible to reach the destination","solution":"from collections import deque def shortest_path(n, m, k, obstacles): # Creating the grid representation grid = [[0]*m for _ in range(n)] # Placing obstacles on the grid for (r, c) in obstacles: grid[r-1][c-1] = -1 # Mark obstacle cells with -1 # Directions for movement in grid: up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Breadth First Search (BFS) initialization queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set() visited.add((0, 0)) while queue: r, c, dist = queue.popleft() # If destination is reached if r == n-1 and c == m-1: return dist # Exploring neighbors for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and (nr, nc) not in visited and grid[nr][nc] != -1: queue.append((nr, nc, dist + 1)) visited.add((nr, nc)) # If destination cannot be reached return -1"},{"question":"def distribute_cards(m: int, n: int, deck: List[int]) -> Tuple[List[int], List[int]]: Function to distribute cards between Federico and Giada. Parameters: m (int): number of rows in the deck n (int): number of columns in the deck deck (list): shuffled deck of mn cards Returns: tuple: cards collected by Federico and cards collected by Giada >>> distribute_cards(2, 3, [4, 5, 1, 6, 3, 2]) ([4, 1, 3], [5, 6, 2]) >>> distribute_cards(1, 2, [7, 8]) ([7], [8])","solution":"def distribute_cards(m, n, deck): Function to distribute cards between Federico and Giada. Parameters: m (int): number of rows in the deck n (int): number of columns in the deck deck (list): shuffled deck of mn cards Returns: tuple: cards collected by Federico and cards collected by Giada # Initialize pockets for both players federico_pocket = [] giada_pocket = [] # A flag to indicate whose turn it is. # True if it's Federico's turn, False if it's Giada's turn. federico_turn = True # Simulate the game while deck: if federico_turn: # Federico picks the first card federico_pocket.append(deck.pop(0)) else: # Giada picks the first card giada_pocket.append(deck.pop(0)) # Switch turns federico_turn = not federico_turn return federico_pocket, giada_pocket"},{"question":"def cyclic_shift(matrix, r, k): Perform a right cyclic shift on the given row of the matrix by k positions. >>> cyclic_shift([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 0, 1) [3, 1, 2] >>> cyclic_shift([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 2, 2) [8, 9, 7] n = len(matrix[r]) k = k % n # To handle cases where k is larger than the number of columns return matrix[r][-k:] + matrix[r][:-k] def sum_after_operations(n, m, matrix, operations): Perform a series of cyclic shift operations on the matrix and return the sum of all elements. >>> sum_after_operations(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [(1, 1), (3, 2)]) 45 >>> sum_after_operations(2, 2, [[1, 2], [3, 4]], [(1, 1), (2, 1)]) 10 >>> sum_after_operations(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]], []) 45 >>> sum_after_operations(2, 2, [[10**9, 10**9], [10**9, 10**9]], [(1, 1), (2, 1)]) 4000000000","solution":"def cyclic_shift(matrix, r, k): Perform a right cyclic shift on the given row of the matrix by k positions. n = len(matrix[r]) k = k % n # To handle cases where k is larger than the number of columns return matrix[r][-k:] + matrix[r][:-k] def sum_after_operations(n, m, matrix, operations): Perform a series of cyclic shift operations on the matrix and return the sum of all elements. for (r, k) in operations: r -= 1 # Convert to 0-based index matrix[r] = cyclic_shift(matrix, r, k) total_sum = sum(sum(row) for row in matrix) return total_sum"},{"question":"def letter_frequency(s: str) -> dict: Returns the frequency of each letter in the string s in alphabetical order. >>> letter_frequency(\\"aabbbcc\\") {'a': 2, 'b': 3, 'c': 2} >>> letter_frequency(\\"zxy\\") {'x': 1, 'y': 1, 'z': 1} pass","solution":"def letter_frequency(s): Returns the frequency of each letter in the string s in alphabetical order. :param s: The input string containing only lowercase English alphabet letters. :return: A dictionary with letters as keys and their frequencies as values. from collections import Counter # Count the frequency of each letter frequency = Counter(s) # Create a dictionary and populate it with frequencies sorted by letter sorted_frequency = dict(sorted(frequency.items())) return sorted_frequency"},{"question":"def rearrange_powers(test_cases): Rearrange the powers of weird creatures in a specific pattern to defeat Mr. XYZ. Each result list should alternate between the lowest and the highest remaining power levels. >>> rearrange_powers([(4, [1, 3, 2, 4]), (5, [5, 3, 1, 2, 4]), (3, [7, 6, 8])]) [[1, 4, 2, 3], [1, 5, 2, 4, 3], [6, 8, 7]] pass def parse_input(input_text): Parse the input text into test cases. >>> parse_input(\\"3n4n1 3 2 4n5n5 3 1 2 4n3n7 6 8n\\") [(4, [1, 3, 2, 4]), (5, [5, 3, 1, 2, 4]), (3, [7, 6, 8])] pass def format_output(results): Format the output from the results. >>> format_output([[1, 4, 2, 3], [1, 5, 2, 4, 3], [6, 8, 7]]) \\"1 4 2 3n1 5 2 4 3n6 8 7\\" pass","solution":"def rearrange_powers(test_cases): results = [] for case in test_cases: N, powers = case powers.sort() rearranged = [] i, j = 0, N - 1 while i <= j: rearranged.append(powers[i]) i += 1 if i <= j: rearranged.append(powers[j]) j -= 1 results.append(rearranged) return results def parse_input(input_text): lines = input_text.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] current_line = 1 for _ in range(T): N = int(lines[current_line]) powers = list(map(int, lines[current_line + 1].split())) test_cases.append((N, powers)) current_line += 2 return test_cases def format_output(results): output_lines = [] for result in results: output_lines.append(\\" \\".join(map(str, result))) return \\"n\\".join(output_lines)"},{"question":"def max_profit(n: int, prices: List[int]) -> int: Determines the maximum profit from the given stock prices. :param n: number of days :param prices: list of stock prices :return: maximum profit that can be achieved >>> max_profit(6, [7, 1, 5, 3, 6, 4]) 5 >>> max_profit(5, [7, 6, 4, 3, 1]) 0 >>> max_profit(3, [1, 2, 3]) 2 >>> max_profit(10, [3, 3, 5, 0, 0, 3, 1, 4, 2, 9]) 9","solution":"def max_profit(n, prices): Determines the maximum profit from the given stock prices. :param n: number of days :param prices: list of stock prices :return: maximum profit that can be achieved if n <= 1: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def longest_common_subsequence(S1: str, S2: str) -> int: Returns the length of the longest common subsequence of DNA sequences S1 and S2. >>> longest_common_subsequence(\\"AGGTAB\\", \\"GXTXAYB\\") 4 >>> longest_common_subsequence(\\"ACCGGTCGAGTGCGCGGAAGCCGGCCGAA\\", \\"GTCGTTCGGAATGCCGTTGCTCTGTAAA\\") 20 >>> longest_common_subsequence(\\"AGCT\\", \\"AGCT\\") 4 >>> longest_common_subsequence(\\"AAAA\\", \\"TTTT\\") 0 >>> longest_common_subsequence(\\"G\\", \\"T\\") 0 >>> longest_common_subsequence(\\"C\\", \\"C\\") 1 >>> longest_common_subsequence(\\"A\\" * 1000, \\"A\\" * 1000) 1000","solution":"def longest_common_subsequence(S1, S2): Returns the length of the longest common subsequence of DNA sequences S1 and S2. m, n = len(S1), len(S2) # Create a 2D DP array to store the lengths of longest common subsequence suffixes dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp array bottom-up for i in range(1, m + 1): for j in range(1, n + 1): if S1[i - 1] == S2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The length of the longest common subsequence is in dp[m][n] return dp[m][n]"},{"question":"from typing import List def is_beautiful_grid(grid: List[List[int]]) -> bool: Determine if the given grid is beautiful. A grid is beautiful if every row and every column contains exactly one peak element, where a peak element in a row or column is the maximum element in that row or column. Args: grid (List[List[int]]): 2D list of integers representing the grid's elements. Returns: bool: True if the grid is beautiful, False otherwise. Examples: >>> grid = [ ... [9, 4, 2], ... [1, 8, 3], ... [5, 6, 7] ... ] >>> is_beautiful_grid(grid) True >>> grid = [ ... [9, 9, 2], ... [1, 8, 3], ... [5, 6, 7] ... ] >>> is_beautiful_grid(grid) False >>> grid = [[5]] >>> is_beautiful_grid(grid) True >>> grid = [ ... [5, 5, 5], ... [5, 5, 5], ... [5, 5, 5] ... ] >>> is_beautiful_grid(grid) False >>> grid = [ ... [5, 2, 1, 3], ... [3, 7, 4, 2], ... [6, 4, 8, 1], ... [2, 1, 3, 9] ... ] >>> is_beautiful_grid(grid) True >>> grid = [ ... [5, 2, 1, 3], ... [3, 7, 4, 2], ... [6, 4, 8, 1], ... [2, 1, 9, 9] ... ] >>> is_beautiful_grid(grid) False","solution":"from typing import List def is_beautiful_grid(grid: List[List[int]]) -> bool: # Get the dimensions of the grid m = len(grid) n = len(grid[0]) # Check if each row has exactly one peak for row in grid: max_in_row = max(row) if row.count(max_in_row) != 1: return False # Check if each column has exactly one peak for j in range(n): col = [grid[i][j] for i in range(m)] max_in_col = max(col) if col.count(max_in_col) != 1: return False return True"},{"question":"from typing import List, Tuple def organize_hackathon(n: int, T: int, a: List[int]) -> Tuple[int, List[List[int]]]: Organize a Hackathon event to form teams that maximize network engagement and collaboration. Args: n (int): the number of participants. T (int): the maximum total skill rating allowed per team. a (List[int]): the skill ratings of each participant. Returns: Tuple[int, List[List[int]]]: The number of teams formed and the configurations of each team. >>> organize_hackathon(6, 10, [2, 3, 7, 5, 4, 1]) (3, [[2, 1, 6], [2, 2, 5], [2, 3, 4]]) >>> organize_hackathon(2, 5, [2, 2]) (1, [[2, 1, 2]]) >>> organize_hackathon(4, 3, [1, 1, 1, 1]) (2, [[2, 1, 2], [2, 3, 4]]) pass def test_organize_hackathon_example_case(): n, T = 6, 10 a = [2, 3, 7, 5, 4, 1] num_teams, teams = organize_hackathon(n, T, a) assert num_teams == 3 assert len(teams) == 3 for team in teams: assert len(team[1:]) == 2 # Ensure each team has exactly 2 members def test_organize_hackathon_minimal_case(): n, T = 2, 5 a = [2, 2] num_teams, teams = organize_hackathon(n, T, a) assert num_teams == 1 assert teams == [[2, 1, 2]] def test_organize_hackathon_exceeding_limit(): n, T = 4, 3 a = [1, 1, 1, 1] num_teams, teams = organize_hackathon(n, T, a) assert num_teams == 2 assert teams == [[2, 1, 2], [2, 3, 4]] def test_organize_hackathon_single_participant(): n, T = 1, 5 a = [2] num_teams, teams = organize_hackathon(n, T, a) assert num_teams == 0 assert teams == []","solution":"def form_teams(n, T, skill_ratings): participants = list(enumerate(skill_ratings, start=1)) participants.sort(key=lambda x: x[1], reverse=True) teams = [] visited = [False] * n for i in range(n): if visited[i]: continue for j in range(i + 1, n): if visited[j]: continue if participants[i][1] + participants[j][1] <= T: teams.append([participants[i][0], participants[j][0]]) visited[i] = True visited[j] = True break return teams def organize_hackathon(n, T, a): teams = form_teams(n, T, a) if len(teams) < n // 2: return (0, []) return (len(teams), [[len(team)] + team for team in teams])"},{"question":"def min_operations_to_equal_elements(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum number of operations required to make all elements of the sequence equal. Args: - T: The number of test cases. - test_cases: A list of tuples, each containing an integer N (the number of elements in the sequence) and a list of N integers representing the sequence. Returns: - A list of integers representing the minimum number of operations required for each test case. >>> min_operations_to_equal_elements(3, [(5, [1, 2, 3, 4, 5]), (4, [4, 4, 4, 4]), (3, [10, 1, 2])]) [10, 0, 17] >>> min_operations_to_equal_elements(2, [(2, [1, 100]), (3, [3, 3, 3])]) [99, 0] >>> min_operations_to_equal_elements(1, [(4, [4, 5, 6, 7])]) [6] >>> min_operations_to_equal_elements(2, [(2, [50, 51]), (5, [5, 5, 5, 5, 5])]) [1, 0]","solution":"def min_operations_to_equal_elements(T, test_cases): results = [] for i in range(T): N, sequence = test_cases[i] max_element = max(sequence) operations = sum(max_element - x for x in sequence) results.append(operations) return results"},{"question":"def count_heatwaves(n: int, temperatures: List[int]) -> int: Counts the number of heatwaves in the given temperature sequence. A \\"heatwave\\" is a sequence of at least 3 consecutive days with strictly increasing temperatures. Parameters: - n (int): The number of recorded days. - temperatures (list of int): The temperatures recorded each day. Returns: - int: The number of heatwaves.","solution":"def count_heatwaves(n, temperatures): Counts the number of heatwaves in the given temperature sequence. A \\"heatwave\\" is a sequence of at least 3 consecutive days with strictly increasing temperatures. Parameters: - n (int): The number of recorded days. - temperatures (list of int): The temperatures recorded each day. Returns: - int: The number of heatwaves. heatwaves = 0 i = 0 while i <= n - 3: if temperatures[i] < temperatures[i + 1] < temperatures[i + 2]: # Found the start of a heatwave heatwaves += 1 # Move to the end of this heatwave while i + 1 < n and temperatures[i] < temperatures[i + 1]: i += 1 else: i += 1 return heatwaves"},{"question":"from typing import List def can_equalize_crates(n: int, items: List[int]) -> str: Determines if it is possible to make all crates contain the same number of items with any number of operations. Parameters: n (int): Number of crates. items (list): List containing the number of items in each crate. Returns: str: \\"YES\\" if it is possible to make all crates contain the same number of items, otherwise \\"NO\\". pass # Example test cases print(can_equalize_crates(4, [3, 6, 9, 12])) # Output: \\"YES\\" print(can_equalize_crates(3, [1, 2, 3])) # Output: \\"NO\\" print(can_equalize_crates(5, [5, 5, 5, 5, 5]))# Output: \\"YES\\"","solution":"def can_equalize_crates(n, items): Determines if it is possible to make all crates contain the same number of items with any number of operations. Parameters: n (int): Number of crates. items (list): List containing the number of items in each crate. Returns: str: \\"YES\\" if possible, otherwise \\"NO\\". # If there is only one crate, it is already 'equalized' if n == 1: return \\"YES\\" # Finding the gcd for the list from math import gcd from functools import reduce def find_gcd_of_list(lst): return reduce(gcd, lst) common_gcd = find_gcd_of_list(items) # If the greatest common divisor of all numbers in the list is greater than 1 # then it's possible to manipulate the crates to have the same number of items if common_gcd == 1: return \\"NO\\" else: return \\"YES\\""},{"question":"def can_equalize_heights(n: int, heights: List[int], k: int) -> str: Determines if it's possible to equalize the height of all trees within k nights. Args: n (int): Number of trees. heights (list of int): Heights of the trees. k (int): Number of nights available. Returns: str: \\"YES\\" if it's possible to equalize the height, otherwise \\"NO\\". pass def test_equal_heights(): assert can_equalize_heights(5, [4, 3, 2, 1, 2], 3) == \\"YES\\" assert can_equalize_heights(4, [3, 5, 3, 5], 1) == \\"NO\\" assert can_equalize_heights(3, [1, 1, 1], 2) == \\"YES\\" assert can_equalize_heights(2, [100, 1], 99) == \\"YES\\" assert can_equalize_heights(3, [2, 2, 100], 98) == \\"YES\\" assert can_equalize_heights(3, [2, 2, 100], 97) == \\"NO\\" assert can_equalize_heights(2, [1, 100], 1) == \\"NO\\" assert can_equalize_heights(1, [10], 5) == \\"YES\\"","solution":"def can_equalize_heights(n, heights, k): Determines if it's possible to equalize the height of all trees within k nights. Args: n (int): Number of trees. heights (list of int): Heights of the trees. k (int): Number of nights available. Returns: str: \\"YES\\" if it's possible to equalize the height, otherwise \\"NO\\". min_height = min(heights) max_height = max(heights) # Calculate the maximum difference max_difference = max_height - min_height # Check if the difference can be covered within k nights if max_difference <= k: return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List, Tuple def single_element(nums: List[int]) -> int: This function finds the element that appears exactly once in an array where every other element appears exactly three times. >>> single_element([2, 2, 3, 2, 4, 4, 4]) 3 >>> single_element([5, 5, 5, 10, 20, 20, 20, 30, 30, 30]) 10 def process_input(tc: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: This function processes multiple test cases and finds the single element in each. >>> process_input(2, [(7, [2, 2, 3, 2, 4, 4, 4]), (10, [5, 5, 5, 10, 20, 20, 20, 30, 30, 30])]) [3, 10] >>> process_input(1, [(7, [1, 1, 1, 0, 3, 3, 3])]) [0]","solution":"def single_element(nums): This function finds the element that appears exactly once in an array where every other element appears exactly three times. ones, twos = 0, 0 for num in nums: # Accumulate num into twos if num is also in ones twos |= ones & num # XOR num with ones to track the num occurrence ones ^= num # Determine common bits in ones and twos common_bits = ones & twos # Remove common bits from ones and twos ones &= ~common_bits twos &= ~common_bits return ones def process_input(tc, test_cases): results = [] for i in range(tc): n = test_cases[i][0] nums = test_cases[i][1] single = single_element(nums) results.append(single) return results"},{"question":"def caesar_cipher(k: int, s: str) -> str: Encrypts the input text using a Caesar Cipher with shift k, ignoring spaces and punctuation. >>> caesar_cipher(3, \\"hello, world!\\") 'khoor, zruog!' >>> caesar_cipher(10, \\"ceasar cipher test.\\") 'mokiob mszrob dokd.' >>> caesar_cipher(5, \\"test123! abc.\\") 'yjxy123! fgh.' >>> caesar_cipher(2, \\"ABCD\\") 'CDEF' >>> caesar_cipher(3, \\"XYZ\\") 'ABC' >>> caesar_cipher(4, \\"Hello, World!\\") 'Lipps, Asvph!' >>> caesar_cipher(0, \\"No Change\\") 'No Change' >>> caesar_cipher(25, \\"abcdefghijklmnopqrstuvwxyz\\") 'zabcdefghijklmnopqrstuvwxy' >>> large_text = \\"a\\" * 10000 >>> shifted_large_text = \\"b\\" * 10000 >>> caesar_cipher(1, large_text) shifted_large_text","solution":"def caesar_cipher(k, s): Encrypts the input text using a Caesar Cipher with shift k, ignoring spaces and punctuation. Parameters: k (int): the number of positions to shift each letter. s (str): the input text to be encrypted. Returns: str: the encrypted text. encrypted = [] for char in s: if 'a' <= char <= 'z': # lowercase letters new_char = chr(((ord(char) - ord('a') + k) % 26) + ord('a')) encrypted.append(new_char) elif 'A' <= char <= 'Z': # uppercase letters new_char = chr(((ord(char) - ord('A') + k) % 26) + ord('A')) encrypted.append(new_char) else: # other characters remain unchanged encrypted.append(char) return ''.join(encrypted)"},{"question":"from typing import List, Tuple def max_served_customers(customers: List[Tuple[int, int]], num_clerks: int) -> int: Simulate a queue management system to return the maximum number of customers that can be served without overlap in their service times. >>> max_served_customers([(0, 3), (1, 9), (2, 6), (6, 3)], 2) 3 >>> max_served_customers([(0, 4), (2, 2), (4, 2)], 1) 2 >>> max_served_customers([(0, 2), (1, 2)], 2) 2","solution":"def max_served_customers(customers, num_clerks): customers.sort(key=lambda x: x[0]) busy_until = [0] * num_clerks # Track when each clerk will be free served_count = 0 for arrival, duration in customers: for i in range(num_clerks): if busy_until[i] <= arrival: busy_until[i] = arrival + duration served_count += 1 break return served_count"},{"question":"def count_matches(strings: List[str], queries: List[str]) -> List[int]: This function takes a list of strings and a list of query strings, and returns a list with the count of occurrences of each query string in the list of strings. >>> count_matches([\\"apple\\", \\"banana\\", \\"orange\\", \\"apple\\", \\"lemon\\"], [\\"apple\\", \\"grape\\", \\"banana\\"]) [2, 0, 1] >>> count_matches([\\"apple\\", \\"banana\\", \\"orange\\"], [\\"grape\\", \\"melon\\"]) [0, 0] >>> count_matches([\\"apple\\", \\"apple\\", \\"apple\\"], [\\"apple\\"]) [3]","solution":"def count_matches(strings, queries): This function takes a list of strings and a list of query strings, and returns a list with the count of occurrences of each query string in the list of strings. result = [] for query in queries: result.append(strings.count(query)) return result"},{"question":"def find_mutual_friends(case_count: int, cases: List[Tuple[int, int, List[str], List[str]]]) -> List[Union[List[str], str]]: Given the number of test cases and the details of each test case (number of friends of two users and their friend lists), find mutual friends between users in alphabetical order. Ignore case sensitivity when comparing names. Args: case_count (int): The number of test cases. cases (List[Tuple[int, int, List[str], List[str]]]): Each tuple consists of two integers (m and n) followed by two lists of friends of length m and n respectively. Returns: List[Union[List[str], str]]: For each test case, return a sorted list of mutual friends. If no such mutual friends exist, return \\"No mutual friends\\". Test cases: >>> input_str = '''2 ... 3 3 ... Alice ... Bob ... Charlie ... bob ... Charlie ... David ... 4 3 ... Eve ... Mallory ... Oscar ... Trudy ... alice ... EVE ... MALLORY''' >>> case_count, cases = parse_input(input_str) >>> find_mutual_friends(case_count, cases) [['bob', 'charlie'], ['eve', 'mallory']] >>> input_str = '''1 ... 3 3 ... Alice ... Bob ... Charlie ... David ... Eve ... Francis''' >>> case_count, cases = parse_input(input_str) >>> find_mutual_friends(case_count, cases) ['No mutual friends'] >>> input_str = '''1 ... 2 2 ... alice ... Bob ... Bob ... ALICE''' >>> case_count, cases = parse_input(input_str) >>> find_mutual_friends(case_count, cases) [['alice', 'bob']] >>> input_str = '''1 ... 0 0''' >>> case_count, cases = parse_input(input_str) >>> find_mutual_friends(case_count, cases) ['No mutual friends']","solution":"def find_mutual_friends(case_count, cases): results = [] for case in cases: m, n, friends_1, friends_2 = case friends_1_set = {friend.lower() for friend in friends_1} friends_2_set = {friend.lower() for friend in friends_2} mutual_friends = friends_1_set.intersection(friends_2_set) if mutual_friends: mutual_list = sorted(mutual_friends) results.append(mutual_list) else: results.append(\\"No mutual friends\\") return results # Helper function to parse input def parse_input(input_str): lines = input_str.strip().split('n') case_count = int(lines[0]) cases = [] index = 1 for _ in range(case_count): m, n = map(int, lines[index].split()) friends_1 = lines[index+1:index+1+m] friends_2 = lines[index+1+m:index+1+m+n] cases.append((m, n, friends_1, friends_2)) index += 1 + m + n return case_count, cases"},{"question":"from typing import List def smallest_repeating_pattern_length(s: str) -> int: Returns the length of the smallest repeating pattern within the given binary string s. >>> smallest_repeating_pattern_length(\\"010101\\") 2 >>> smallest_repeating_pattern_length(\\"001100\\") 6 >>> smallest_repeating_pattern_length(\\"1111\\") 1 def calculate_smallest_patterns(test_cases: List[str]) -> List[int]: Returns a list of lengths of the smallest repeating patterns for a list of binary strings. >>> calculate_smallest_patterns([\\"010101\\", \\"001100\\", \\"1111\\"]) [2, 6, 1] >>> calculate_smallest_patterns([\\"10\\", \\"0101\\", \\"0000\\"]) [2, 2, 1] from solution import smallest_repeating_pattern_length, calculate_smallest_patterns def test_smallest_repeating_pattern_length(): assert smallest_repeating_pattern_length(\\"010101\\") == 2 assert smallest_repeating_pattern_length(\\"001100\\") == 6 assert smallest_repeating_pattern_length(\\"1111\\") == 1 assert smallest_repeating_pattern_length(\\"10\\") == 2 assert smallest_repeating_pattern_length(\\"0101\\") == 2 assert smallest_repeating_pattern_length(\\"0000\\") == 1 assert smallest_repeating_pattern_length(\\"101\\") == 3 def test_calculate_smallest_patterns(): assert calculate_smallest_patterns([\\"010101\\", \\"001100\\", \\"1111\\"]) == [2, 6, 1] assert calculate_smallest_patterns([\\"10\\", \\"0101\\", \\"0000\\"]) == [2, 2, 1] assert calculate_smallest_patterns([\\"101\\", \\"110011\\", \\"100010001\\"]) == [3, 6, 9] assert calculate_smallest_patterns([]) == []","solution":"def smallest_repeating_pattern_length(s): Returns the length of the smallest repeating pattern in the binary string s. n = len(s) for i in range(1, n + 1): if n % i == 0: # i must be a divisor of n pattern = s[:i] if pattern * (n // i) == s: return i return n def calculate_smallest_patterns(test_cases): results = [] for s in test_cases: results.append(smallest_repeating_pattern_length(s)) return results"},{"question":"def concatenate_strings(s: str) -> str: Given a single input string containing two substrings separated by a space, concatenate the substrings and return the result. >>> concatenate_strings(\\"hello world\\") \\"helloworld\\" >>> concatenate_strings(\\"123 456\\") \\"123456\\"","solution":"def concatenate_strings(s): This function takes a single input string, splits it into two parts separated by a space, and returns the concatenated result of the two parts. s1, s2 = s.split(' ') return s1 + s2"},{"question":"def fibonacci_like(a: int, b: int, k: int) -> int: Returns the kth Fibonacci-like number in a sequence starting with a and b. >>> fibonacci_like(3, 5, 5) 21 >>> fibonacci_like(1, 1, 7) 13","solution":"def fibonacci_like(a, b, k): Returns the kth fibonacci-like number in a sequence starting with a and b. if k == 1: return a elif k == 2: return b fib = [a, b] for i in range(2, k): fib.append(fib[i-1] + fib[i-2]) return fib[k-1]"},{"question":"def max_tasks(n, tasks): Determines the maximum number of tasks that can be completed before their respective deadlines. Parameters: n (int): The number of tasks. tasks (list of tuples): A list of tuples where each tuple contains two integers, the duration and the deadline of the task. Returns: int: The maximum number of tasks that can be completed before their respective deadlines. pass def test_max_tasks_example1(): assert max_tasks(5, [(3, 10), (1, 3), (2, 6), (5, 5), (4, 8)]) == 4 def test_max_tasks_example2(): assert max_tasks(3, [(2, 2), (1, 5), (2, 10)]) == 3 def test_max_tasks_single_task(): assert max_tasks(1, [(2, 3)]) == 1 assert max_tasks(1, [(3, 2)]) == 0 def test_max_tasks_all_possible(): tasks = [(1, 10), (1, 20), (1, 30), (1, 40), (1, 50)] assert max_tasks(5, tasks) == 5 def test_max_tasks_none_possible(): tasks = [(10, 5), (20, 10), (30, 15)] assert max_tasks(3, tasks) == 0 def test_max_tasks_some_possible(): tasks = [(2, 2), (1, 2), (3, 4)] assert max_tasks(3, tasks) == 2","solution":"def max_tasks(n, tasks): Determines the maximum number of tasks that can be completed before their respective deadlines. Parameters: n (int): The number of tasks. tasks (list of tuples): A list of tuples where each tuple contains two integers, the duration and the deadline of the task. Returns: int: The maximum number of tasks that can be completed before their respective deadlines. # Sort tasks by deadline, breaking ties by shorter duration first tasks.sort(key=lambda x: (x[1], x[0])) current_time = 0 count = 0 for duration, deadline in tasks: if current_time + duration <= deadline: current_time += duration count += 1 return count"},{"question":"def min_removals(s: str) -> int: Calculate the minimum number of characters to remove to ensure no two adjacent characters are the same. >>> min_removals(\\"aab\\") 1 >>> min_removals(\\"aaaa\\") 3 >>> min_removals(\\"abc\\") 0","solution":"def min_removals(s: str) -> int: Calculate the minimum number of characters to remove to ensure no two adjacent characters are the same. if not s: return 0 removals = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: removals += 1 return removals"},{"question":"def place_squares(n: int): Finds one arrangement of the maximum number of non-overlapping 2x2 squares on an n x n grid. Parameters: n (int): Side length of the grid. Returns: (int, list): Number of 2x2 squares and the list of their top-left coordinates.","solution":"def place_squares(n): Finds one arrangement of the maximum number of non-overlapping 2x2 squares on an n x n grid. Parameters: n (int): Side length of the grid. Returns: (int, list): Number of 2x2 squares and the list of their top-left coordinates. squares = [] for i in range(1, n, 2): for j in range(1, n, 2): # Checking if the 2x2 square can fit within the bounds if i + 1 <= n and j + 1 <= n: squares.append((i, j)) return len(squares), squares"},{"question":"def minimize_characters(s: str) -> int: Returns the minimum number of distinct characters possible after any number of operations. >>> minimize_characters(\\"abac\\") 1 >>> minimize_characters(\\"xyz\\") 1 >>> minimize_characters(\\"abca\\") 1 # Unit test def test_minimize_characters(): assert minimize_characters(\\"abac\\") == 1 assert minimize_characters(\\"xyz\\") == 1 assert minimize_characters(\\"abca\\") == 1 assert minimize_characters(\\"a\\") == 1 assert minimize_characters(\\"aaaa\\") == 1 assert minimize_characters(\\"abbccddeeffgg\\") == 1 def test_minimize_characters_edge_cases(): assert minimize_characters(\\"abcdefghijklmnopqrstuvwxyz\\") == 1 assert minimize_characters(\\"a\\" * 105) == 1","solution":"def minimize_characters(s): Returns the minimum number of distinct characters possible after any number of operations. # The problem can be reduced to the fact that we can replace all characters to be the same. # Hence, the minimum number of distinct characters will always be 1. return 1"},{"question":"def max_non_overlapping_workshops(m: int, workshops: List[Tuple[int, int]]) -> int: Finds the maximum number of non-overlapping workshops that can be scheduled. Parameters: m (int) : the number of workshops workshops (list of tuple of int) : list of tuples where each tuple contains two integers (s, e) representing the start and end time of a workshop Returns: int: the maximum number of non-overlapping workshops Example: >>> max_non_overlapping_workshops(5, [(1, 3), (2, 4), (3, 5), (4, 6), (5, 7)]) 3 >>> max_non_overlapping_workshops(3, [(1, 2), (2, 3), (3, 4)]) 3 >>> max_non_overlapping_workshops(4, [(1, 3), (3, 5), (2, 6), (5, 7)]) 3","solution":"def max_non_overlapping_workshops(m, workshops): Finds the maximum number of non-overlapping workshops that can be scheduled. Parameters: m (int) : the number of workshops workshops (list of tuple of int) : list of tuples where each tuple contains two integers (s, e) representing the start and end time of a workshop Returns: int: the maximum number of non-overlapping workshops # Sorting workshops by their ending time workshops.sort(key=lambda x: x[1]) count = 0 last_end_time = 0 for start, end in workshops: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"import math from typing import List, Tuple def find_optimal_rain_distribution(n: int, m: int, roads: List[Tuple[int, int]]) -> Tuple[int, List[int]]: Given a map of cities and roads between them, determine whether it's possible to make it rain on either: - Exactly ⌈√{n}⌉ cities simultaneously. - Exactly n-⌈√{n}⌉ cities simultaneously. The input is a connected graph where nodes represent cities and edges represent roads. Args: n: Number of cities. m: Number of roads. roads: List of tuples representing the roads between cities. Returns: A tuple containing: - An integer (1 or 2) indicating the path chosen. - A list of integers representing the cities selected. Example: >>> find_optimal_rain_distribution(8, 9, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 1), (4, 6)]) (1, [1, 2, 3]) >>> find_optimal_rain_distribution(9, 10, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9), (2, 7), (3, 8)]) (2, [1, 2, 3, 4, 5, 6, 7])","solution":"import math from collections import deque def find_optimal_rain_distribution(n, m, roads): def bfs(start): visited = [False] * (n + 1) queue = deque([start]) visited[start] = True component = [] while queue: city = queue.popleft() component.append(city) for neighbor in graph[city]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return component graph = [[] for _ in range(n + 1)] for u, v in roads: graph[u].append(v) graph[v].append(u) sqrt_n = math.ceil(math.sqrt(n)) target1 = sqrt_n target2 = n - sqrt_n # Find connected components using BFS for i in range(1, n + 1): optimal_cities = bfs(i) if len(optimal_cities) >= min(target1, target2): if len(optimal_cities) >= target1: return [1, optimal_cities[:target1]] return [2, optimal_cities[:target2]] # Example usage: # n, m = 8, 9 # roads = [ # (1, 2), (2, 3), (3, 4), (4, 5), # (5, 6), (6, 7), (7, 8), (8, 1), (4, 6) # ] # result = find_optimal_rain_distribution(n, m, roads) # Outputs will be either: # [1, [1, 2, 3]] for finding 3 cities to rain on # [2, [1, 2, 3, 4, 5, 6, 7]] for finding n-3 = 5 cities to rain on"},{"question":"def longest_consecutive_sequence_length(arr: List[int]) -> int: Given an array of integers, return the length of the longest subarray that can be rearranged to form a consecutive sequence of integers. >>> longest_consecutive_sequence_length([1, 3, 5, 2, 4, 8]) 5 >>> longest_consecutive_sequence_length([10, 12, 11, 14, 13]) 5","solution":"def longest_consecutive_sequence_length(arr): arr_set = set(arr) max_length = 0 for num in arr_set: if num - 1 not in arr_set: # begin of a new sequence current_num = num current_length = 1 while current_num + 1 in arr_set: current_num += 1 current_length += 1 max_length = max(max_length, current_length) return max_length def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) arr = list(map(int, data[1:])) print(longest_consecutive_sequence_length(arr))"},{"question":"from typing import List def trap_rain_water(height_map: List[List[int]]) -> int: Calculate the total amount of rainwater that can be trapped after raining on a 2D grid of heights. Args: height_map (List[List[int]]): A 2D list of integers representing the height of each cell in the grid. Returns: int: The total amount of trapped rainwater. >>> trap_rain_water([[1, 4, 3], [3, 2, 3], [4, 3, 2]]) 1 >>> trap_rain_water([[5, 5, 5], [5, 5, 5], [5, 5, 5]]) 0 >>> trap_rain_water([[3, 3, 3], [3, 1, 3], [3, 3, 3]]) 2 >>> trap_rain_water([[1, 2, 2, 3], [3, 1, 2, 2], [2, 3, 1, 4], [2, 3, 4, 1]]) 2 >>> trap_rain_water([[5, 1, 5]]) 0 >>> trap_rain_water([[5], [1], [5]]) 0","solution":"import heapq def trap_rain_water(height_map): if not height_map or not height_map[0]: return 0 m, n = len(height_map), len(height_map[0]) if m <= 2 or n <= 2: return 0 visited = [[False] * n for _ in range(m)] heap = [] # Push all the boundary cells into the heap for i in range(m): heapq.heappush(heap, (height_map[i][0], i, 0)) heapq.heappush(heap, (height_map[i][n-1], i, n-1)) visited[i][0] = visited[i][n-1] = True for j in range(1, n-1): heapq.heappush(heap, (height_map[0][j], 0, j)) heapq.heappush(heap, (height_map[m-1][j], m-1, j)) visited[0][j] = visited[m-1][j] = True total_water = 0 directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] while heap: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True trapped_water = max(0, height - height_map[nx][ny]) total_water += trapped_water heapq.heappush(heap, (max(height, height_map[nx][ny]), nx, ny)) return total_water"},{"question":"from typing import List, Tuple def min_moves(n: int, m: int, k: int, grid: List[List[str]], special_cells: List[Tuple[int, int]]) -> int: Determine the minimum number of moves required to reach the bottom-right corner from the top-left corner, considering both normal moves and teleportation. pass def parse_input(input_text: str) -> Tuple[int, int, int, List[List[str]], List[Tuple[int, int]]]: Parse input from a given string format to the required arguments. pass # Unit Test def test_example_1(): input_text = 3 3 1 . . . . # . . . . 2 2 n, m, k, grid, special_cells = parse_input(input_text) assert min_moves(n, m, k, grid, special_cells) == 4 def test_example_2(): input_text = 4 4 2 . . . . . # . . . . . . # . # . 3 1 4 4 n, m, k, grid, special_cells = parse_input(input_text) assert min_moves(n, m, k, grid, special_cells) == 3 def test_impossible_case(): input_text = 3 3 0 . # . # # . . # . n, m, k, grid, special_cells = parse_input(input_text) assert min_moves(n, m, k, grid, special_cells) == -1 def test_no_special_cells(): input_text = 2 2 0 . . . . n, m, k, grid, special_cells = parse_input(input_text) assert min_moves(n, m, k, grid, special_cells) == 2 def test_start_and_end_are_special_cells(): input_text = 3 3 2 . . . . . . . . . 1 1 3 3 n, m, k, grid, special_cells = parse_input(input_text) assert min_moves(n, m, k, grid, special_cells) == 1","solution":"from collections import deque def min_moves(n, m, k, grid, special_cells): def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == '.' # Directions: right (0, 1), down (1, 0) directions = [(0, 1), (1, 0)] # Special cells positions set for O(1) access special_set = set((sx-1, sy-1) for sx, sy in special_cells) # BFS queue queue = deque([(0, 0, 0)]) # (x, y, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() # If we reach the bottom-right corner if x == n-1 and y == m-1: return dist # Move to adjacent passable cells for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) # Teleport to any other special cell if (x, y) in special_set: for sx, sy in special_set: if (sx, sy) != (x, y) and (sx, sy) not in visited: visited.add((sx, sy)) queue.append((sx, sy, dist + 1)) return -1 # If no path found # Helper function to parse the input in the expected format def parse_input(input_text): lines = input_text.strip().split('n') n, m, k = map(int, lines[0].split()) grid = [list(lines[i + 1].replace(' ', '')) for i in range(n)] special_cells = [tuple(map(int, lines[n + i + 1].split())) for i in range(k)] return n, m, k, grid, special_cells"},{"question":"def find_maximum(matrix): Returns the maximum element in the given matrix. :param matrix: List of List containing integer elements. :return: Integer which is the maximum element in the matrix. pass # Unit Test def test_find_maximum(): # Test case 1: Example given matrix1 = [ [15, 2, 8], [5, 12, 30], [20, 5, 4] ] assert find_maximum(matrix1) == 30 # Test case 2: Matrix with single row matrix2 = [[1, 2, 3, 4, 5]] assert find_maximum(matrix2) == 5 # Test case 3: Matrix with all elements the same matrix3 = [ [7, 7, 7], [7, 7, 7], [7, 7, 7] ] assert find_maximum(matrix3) == 7 # Test case 4: Matrix with negative numbers matrix4 = [ [-1, -2, -3], [-4, -5, -6], [-7, -8, -9] ] assert find_maximum(matrix4) == -1 # Test case 5: Mixed positive and negative numbers matrix5 = [ [1, -10, 3], [7, -3, -15], [-10, 20, -30] ] assert find_maximum(matrix5) == 20 # Test case 6: Large numbers matrix6 = [ [1000000, 500000, 750000], [300000, 200000, 900000], [800000, 600000, 100000] ] assert find_maximum(matrix6) == 1000000","solution":"def find_maximum(matrix): Returns the maximum element in the given matrix. :param matrix: List of List containing integer elements. :return: Integer which is the maximum element in the matrix. return max(max(row) for row in matrix) # Example usage: # matrix = [ # [15, 2, 8], # [5, 12, 30], # [20, 5, 4] # ] # print(find_maximum(matrix)) # Output should be 30"},{"question":"def canReachDestination(x: int, y: int, movements: str) -> str: Determines if the robot can reach the destination (x, y) after executing the movement instructions. Args: x (int): x-coordinate of the destination. y (int): y-coordinate of the destination. movements (str): Movement instructions consisting of 'U', 'D', 'L', 'R'. Returns: str: \\"Yes\\" if the robot can reach the destination, otherwise \\"No\\".","solution":"def canReachDestination(x, y, movements): Determines if the robot can reach the destination (x, y) after executing the movement instructions. Args: x (int): x-coordinate of the destination. y (int): y-coordinate of the destination. movements (str): Movement instructions consisting of 'U', 'D', 'L', 'R'. Returns: str: \\"Yes\\" if the robot can reach the destination, otherwise \\"No\\". current_x, current_y = 0, 0 for move in movements: if move == 'U': current_y += 1 elif move == 'D': current_y -= 1 elif move == 'L': current_x -= 1 elif move == 'R': current_x += 1 if current_x == x and current_y == y: return \\"Yes\\" return \\"No\\""},{"question":"def orientation(p, q, r): Return the orientation of the ordered triplet (p, q, r). 0 -> p, q and r are collinear 1 -> Clockwise 2 -> Counterclockwise pass def on_segment(p, q, r): Given three collinear points p, q, r, check if point q lies on segment pr. pass def segments_intersect(p1, q1, p2, q2): Return True if line segments p1q1 and p2q2 intersect. pass def do_segments_intersect(x1, y1, x2, y2, x3, y3, x4, y4): Determine if the segments defined by endpoints (x1, y1), (x2, y2) and (x3, y3), (x4, y4) intersect. >>> do_segments_intersect(1, 1, 4, 4, 1, 8, 2, 4) 'NO' >>> do_segments_intersect(1, 1, 4, 4, 2, 2, 3, 3) 'YES' >>> do_segments_intersect(1, 1, 4, 4, 4, 4, 5, 5) 'YES' pass","solution":"def orientation(p, q, r): Return the orientation of the ordered triplet (p, q, r). 0 -> p, q and r are collinear 1 -> Clockwise 2 -> Counterclockwise val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]) if val == 0: return 0 elif val > 0: return 1 else: return 2 def on_segment(p, q, r): Given three collinear points p, q, r, check if point q lies on segment pr. if q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1]): return True return False def segments_intersect(p1, q1, p2, q2): Return True if line segments p1q1 and p2q2 intersect. # Find the four orientations needed for general and special cases o1 = orientation(p1, q1, p2) o2 = orientation(p1, q1, q2) o3 = orientation(p2, q2, p1) o4 = orientation(p2, q2, q1) # General case if o1 != o2 and o3 != o4: return True # Special Cases # p1, q1 and p2 are collinear and p2 lies on segment p1q1 if o1 == 0 and on_segment(p1, p2, q1): return True # p1, q1 and q2 are collinear and q2 lies on segment p1q1 if o2 == 0 and on_segment(p1, q2, q1): return True # p2, q2 and p1 are collinear and p1 lies on segment p2q2 if o3 == 0 and on_segment(p2, p1, q2): return True # p2, q2 and q1 are collinear and q1 lies on segment p2q2 if o4 == 0 and on_segment(p2, q1, q2): return True # Doesn't fall in any of the above cases return False def do_segments_intersect(x1, y1, x2, y2, x3, y3, x4, y4): if segments_intersect((x1, y1), (x2, y2), (x3, y3), (x4, y4)): return \\"YES\\" else: return \\"NO\\""},{"question":"def max_sum_sequence(n: int, a: int, b: int) -> List[int]: Returns a sequence of n terms such that the first term is 'a' and each subsequent term is at least as large as the previous term, up to 'b', maximizing the sum of the sequence. >>> max_sum_sequence(3, 2, 5) == [5, 5, 5] >>> max_sum_sequence(5, 1, 3) == [3, 3, 3, 3, 3]","solution":"def max_sum_sequence(n, a, b): Returns a sequence of n terms such that the first term is 'a' and each subsequent term is at least as large as the previous term, up to 'b', maximizing the sum of the sequence. # The optimal sequence would be all terms equal to the maximum value b sequence = [b] * n return sequence"},{"question":"def calculate_ranks(scores: List[int]) -> List[int]: Given a list of scores, return the ranks of the players in the same order as their scores are provided. Args: scores (List[int]): List of integers representing scores. Returns: List[int]: List of integers representing ranks. Examples: >>> calculate_ranks([50, 30, 50, 20, 30]) [1, 3, 1, 5, 3] >>> calculate_ranks([70, 70, 100]) [2, 2, 1] >>> calculate_ranks([40, 40, 40, 40]) [1, 1, 1, 1] from typing import List # You can use the following test cases to verify your implementation. def test_example_case_1(): assert calculate_ranks([50, 30, 50, 20, 30]) == [1, 3, 1, 5, 3] def test_example_case_2(): assert calculate_ranks([70, 70, 100]) == [2, 2, 1] def test_example_case_3(): assert calculate_ranks([40, 40, 40, 40]) == [1, 1, 1, 1] def test_single_element(): assert calculate_ranks([100]) == [1] def test_all_different_scores(): assert calculate_ranks([10, 50, 30, 20, 40]) == [5, 1, 3, 4, 2] def test_large_range_of_scores(): assert calculate_ranks([1000000000, 500000000, 1000000000, 250000000]) == [1, 3, 1, 4]","solution":"def calculate_ranks(scores): Given a list of scores, return the ranks of the players in the same order as their scores are provided. :param scores: List of integers representing the scores. :return: List of integers representing the ranks. # Create a list of tuples containing the original index and the score indexed_scores = list(enumerate(scores)) # Sort the list of tuples based on scores in descending order indexed_scores.sort(key=lambda x: x[1], reverse=True) # Initialize ranks array with the same size as scores ranks = [0] * len(scores) # Initialize the first rank rank = 1 for i, (original_idx, score) in enumerate(indexed_scores): # If it's not the first score and the current score is different from the previous one, # update the rank to the current position + 1 (1-based index) if i > 0 and score != indexed_scores[i-1][1]: rank = i + 1 # Assign the calculated rank to the original index position ranks[original_idx] = rank return ranks"},{"question":"def is_connected_building(n: int, m: int, grid: List[str]) -> str: Determine if all rooms in the building are connected. Parameters: n (int): The number of rows in the building. m (int): The number of columns in the building. grid (List[str]): A list of strings representing the building layout where 'R' is a room and '.' is an open space. Returns: str: \\"YES\\" if all rooms are connected, otherwise \\"NO\\". Examples: >>> is_connected_building(3, 3, [\\"RRR\\", \\"R.R\\", \\"RRR\\"]) \\"YES\\" >>> is_connected_building(4, 4, [\\".R..\\", \\"RR.R\\", \\".R.R\\", \\"..R.\\"]) \\"NO\\"","solution":"def is_connected_building(n, m, grid): from collections import deque def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == 'R' # Find the first room position found_room = False for i in range(n): for j in range(m): if grid[i][j] == 'R': start = (i, j) found_room = True break if found_room: break if not found_room: # No rooms found return \\"YES\\" # BFS to check connectivity moves = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[False] * m for _ in range(n)] queue = deque([start]) visited[start[0]][start[1]] = True while queue: x, y = queue.popleft() for move in moves: nx, ny = x + move[0], y + move[1] if is_valid(nx, ny) and not visited[nx][ny]: visited[nx][ny] = True queue.append((nx, ny)) # Check if all rooms are visited for i in range(n): for j in range(m): if grid[i][j] == 'R' and not visited[i][j]: return \\"NO\\" return \\"YES\\""},{"question":"import collections from typing import List def min_operations_to_make_equal(s: str) -> int: Returns the minimum number of operations required to make all characters of the string equal. pass def process_cases(T: int, cases: List[str]) -> List[int]: Processes multiple test cases and returns the results as a list of integers. pass def test_min_operations_to_make_equal(): assert min_operations_to_make_equal(\\"aabb\\") == 2 assert min_operations_to_make_equal(\\"abc\\") == 2 assert min_operations_to_make_equal(\\"zzzz\\") == 0 assert min_operations_to_make_equal(\\"abcd\\") == 3 assert min_operations_to_make_equal(\\"aaaaaaaaaa\\") == 0 assert min_operations_to_make_equal(\\"aaabbbccc\\") == 6 def test_process_cases(): assert process_cases(3, [\\"aabb\\", \\"abc\\", \\"zzzz\\"]) == [2, 2, 0] assert process_cases(2, [\\"abcd\\", \\"aaaabbbb\\"]) == [3, 4] test_min_operations_to_make_equal() test_process_cases()","solution":"def min_operations_to_make_equal(s): Returns the minimum number of operations required to make all characters of the string equal. import collections # Create a frequency counter of characters in the string freq = collections.Counter(s) # Find the highest frequency of any character max_freq = max(freq.values()) # The minimum operations required will be the length of the string minus # the highest frequency (since we need to change all other characters) return len(s) - max_freq def process_cases(T, cases): Processes multiple test cases and returns the results as a list of integers. results = [] for s in cases: results.append(min_operations_to_make_equal(s)) return results"},{"question":"from typing import List, Tuple def shortest_travel_time(N: int, M: int, S: int, D: int, edges: List[Tuple[int, int, int]]) -> int: Returns the shortest travel time from the start node S to the destination node D in the given directed graph. If the destination is not reachable, return -1. Example: >>> N, M, S, D = 5, 7, 0, 4 >>> edges = [(0, 1, 10), (0, 2, 3), (1, 2, 1), (2, 1, 4), (1, 3, 2), (2, 3, 8), (3, 4, 7)] >>> shortest_travel_time(N, M, S, D, edges) 16 >>> N, M, S, D = 5, 7, 0, 4 >>> edges = [(0, 1, 10), (0, 2, 3), (1, 2, 1), (2, 1, 4), (1, 3, 2), (2, 3, 8)] >>> shortest_travel_time(N, M, S, D, edges) -1 pass","solution":"import heapq def shortest_travel_time(N, M, S, D, edges): Returns the shortest travel time from the start node S to the destination node D in the given directed graph. If the destination is not reachable, return -1. graph = [[] for _ in range(N)] for U, V, T in edges: graph[U].append((V, T)) # Dijkstra's algorithm pq = [(0, S)] distances = {node: float('inf') for node in range(N)} distances[S] = 0 while pq: current_distance, current_node = heapq.heappop(pq) if current_node == D: return current_distance if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return -1 if distances[D] == float('inf') else distances[D]"},{"question":"def can_rearrange_to_palindrome(s: str) -> str: Determines whether it is possible to make the string a palindrome by rearranging any substring once. Args: s (str): The input string consisting of lowercase English letters. Returns: str: \\"YES\\" if it's possible to rearrange any substring to make the string a palindrome, otherwise \\"NO\\". >>> can_rearrange_to_palindrome(\\"aabbcc\\") \\"YES\\" >>> can_rearrange_to_palindrome(\\"racecar\\") \\"YES\\" >>> can_rearrange_to_palindrome(\\"abcde\\") \\"NO\\" >>> can_rearrange_to_palindrome(\\"abcba\\") \\"YES\\"","solution":"def can_rearrange_to_palindrome(s): Determines whether it is possible to make the string a palindrome by rearranging any substring once. Args: s (str): The input string consisting of lowercase English letters. Returns: str: \\"YES\\" if it's possible to rearrange any substring to make the string a palindrome, otherwise \\"NO\\". # To form a palindrome, at most one character can have an odd frequency. from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to a palindrome if it has at most one character with an odd frequency return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"from typing import List def max_sum_of_strengths(runners: List[int]) -> int: Given a list of runner strengths, return the maximum possible sum of strengths with no two consecutive runners selected. >>> max_sum_of_strengths([3, 2, 7, 10, 12]) == 22 >>> max_sum_of_strengths([1, 2, 9, 4]) == 10 >>> max_sum_of_strengths([1, 20, 3]) == 20 def process_input(input_lines: List[str]) -> List[int]: Process input from multiple datasets to return the maximum possible sum of strengths for each dataset. >>> process_input([\\"5\\", \\"3 2 7 10 12\\", \\"4\\", \\"1 2 9 4\\", \\"3\\", \\"1 20 3\\", \\"0\\"]) == [22, 10, 20] import pytest def test_max_sum_of_strengths_single_runner(): assert max_sum_of_strengths([5]) == 5 def test_max_sum_of_strengths_all_runners_zero_strength(): assert max_sum_of_strengths([0, 0, 0, 0]) == 0 def test_max_sum_of_strengths_two_runners(): assert max_sum_of_strengths([5, 1]) == 5 assert max_sum_of_strengths([1, 5]) == 5 def test_max_sum_of_strengths_multiple_runners(): assert max_sum_of_strengths([3, 2, 7, 10, 12]) == 22 assert max_sum_of_strengths([1, 2, 9, 4]) == 10 assert max_sum_of_strengths([1, 20, 3]) == 20 def test_max_sum_of_strengths_edge_case(): assert max_sum_of_strengths([]) == 0 def test_process_input_example(): input_data = [ \\"5\\", \\"3 2 7 10 12\\", \\"4\\", \\"1 2 9 4\\", \\"3\\", \\"1 20 3\\", \\"0\\" ] expected_output = [22, 10, 20] assert process_input(input_data) == expected_output if __name__ == \\"__main__\\": pytest.main()","solution":"def max_sum_of_strengths(runners): Given a list of runner strengths, return the maximum possible sum of strengths with no two consecutive runners selected. if not runners: return 0 n = len(runners) if n == 1: return runners[0] # Initialize DP array where dp[i] represents maximum sum up to index i dp = [0] * n dp[0] = runners[0] dp[1] = max(runners[0], runners[1]) for i in range(2, n): dp[i] = max(dp[i-1], runners[i] + dp[i-2]) return dp[-1] import sys def process_input(input_lines): results = [] i = 0 while i < len(input_lines): n = int(input_lines[i]) if n == 0: break strengths = list(map(int, input_lines[i+1].split())) results.append(max_sum_of_strengths(strengths)) i += 2 return results"},{"question":"def knapsack(N, W, items): Returns the maximum value that can be carried in the knapsack with a given capacity. Parameters: N (int): Number of items W (int): Maximum weight capacity of the bag items (list of tuples): Each tuple contains two integers, the weight and value of the item Returns: int: The maximum value that can be carried in the bag >>> knapsack(4, 7, [(1, 1), (3, 4), (4, 5), (5, 7)]) 9 >>> knapsack(1, 5, [(3, 10)]) 10 >>> knapsack(1, 5, [(6, 10)]) 0 >>> knapsack(4, 5, [(1, 1), (2, 2), (3, 5), (4, 6)]) 7 >>> knapsack(3, 6, [(7, 10), (8, 20), (9, 30)]) 0 >>> knapsack(4, 15, [(2, 3), (3, 4), (4, 5), (5, 6)]) 18 >>> knapsack(3, 0, [(1, 1), (2, 2), (3, 3)]) 0","solution":"def knapsack(N, W, items): Returns the maximum value that can be carried in the knapsack with a given capacity. Parameters: N (int): Number of items W (int): Maximum weight capacity of the bag items (list of tuples): Each tuple contains two integers, the weight and value of the item Returns: int: The maximum value that can be carried in the bag # Initialize the DP table with 0 dp = [[0] * (W + 1) for _ in range(N + 1)] # Populate the DP table for i in range(1, N + 1): weight, value = items[i - 1] for w in range(W + 1): if weight <= w: # Can include the item dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weight] + value) else: # Cannot include the item dp[i][w] = dp[i - 1][w] return dp[N][W]"},{"question":"def longest_subarray_distinct(arr): This function returns the length of the longest contiguous subarray that contains only distinct elements. >>> longest_subarray_distinct([1, 2, 3, 1, 4]) 4 >>> longest_subarray_distinct([4, 5, 6, 5, 6, 7]) 3 >>> longest_subarray_distinct([1, 1, 1, 1]) 1 >>> longest_subarray_distinct([]) 0 >>> longest_subarray_distinct([1, 2, 3, 4, 5]) 5 def process_test_cases(input_data): This function processes the input data to solve the given problem for multiple test cases. >>> input_data = \\"2n5n1 2 3 1 4n6n4 5 6 5 6 7n\\" >>> process_test_cases(input_data) [4, 3] >>> input_data = \\"1n4n1 1 1 1n\\" >>> process_test_cases(input_data) [1] >>> input_data = \\"1n5n1 2 3 4 5n\\" >>> process_test_cases(input_data) [5]","solution":"def longest_subarray_distinct(arr): This function returns the length of the longest contiguous subarray that contains only distinct elements. n = len(arr) max_len = 0 start = 0 seen = {} for end in range(n): if arr[end] in seen: start = max(start, seen[arr[end]] + 1) seen[arr[end]] = end max_len = max(max_len, end - start + 1) return max_len def process_test_cases(input_data): input_lines = input_data.strip().split('n') T = int(input_lines[0]) results = [] index = 1 for _ in range(T): N = int(input_lines[index]) arr = list(map(int, input_lines[index + 1].split())) index += 2 results.append(longest_subarray_distinct(arr)) return results"},{"question":"def max_viewing_time(s: int, t: int, times: List[int]) -> int: Determines the maximum total viewing time without exceeding the available time t. :param s: int - number of scenic spots :param t: int - total time available in hours :param times: list - viewing time required for each scenic spot :return: int - maximum total viewing time possible Examples: >>> max_viewing_time(4, 10, [2, 5, 3, 7]) 10 >>> max_viewing_time(5, 7, [1, 3, 2, 6, 2]) 7","solution":"def max_viewing_time(s, t, times): Determines the maximum total viewing time without exceeding the available time t. :param s: int - number of scenic spots :param t: int - total time available in hours :param times: list - viewing time required for each scenic spot :return: int - maximum total viewing time possible # We will use a recursive solution with memoization to solve this problem. from functools import lru_cache @lru_cache(None) def dp(i, remaining_time): if i == s or remaining_time == 0: return 0 if times[i] > remaining_time: return dp(i + 1, remaining_time) # Choose to either skip the current spot or include it return max(dp(i + 1, remaining_time), times[i] + dp(i + 1, remaining_time - times[i])) return dp(0, t)"},{"question":"from typing import List def min_operations_to_palindrome(S: str) -> int: Returns the minimum number of operations required to make the string S a palindrome. >>> min_operations_to_palindrome(\\"abc\\") == 1 True >>> min_operations_to_palindrome(\\"abca\\") == 1 True >>> min_operations_to_palindrome(\\"abcd\\") == 2 True >>> min_operations_to_palindrome(\\"a\\") == 0 True >>> min_operations_to_palindrome(\\"racecar\\") == 0 True >>> min_operations_to_palindrome(\\"deified\\") == 0 True >>> min_operations_to_palindrome(\\"hello\\") == 2 True pass def min_operations_for_list_of_strings(T: int, cases: List[str]) -> List[int]: For each case, calculate the minimum number of operations required to make the string a palindrome. >>> min_operations_for_list_of_strings(3, [\\"abc\\", \\"abca\\", \\"abcd\\"]) [1, 1, 2] >>> min_operations_for_list_of_strings(2, [\\"racecar\\", \\"hello\\"]) [0, 2] >>> min_operations_for_list_of_strings(4, [\\"a\\", \\"bb\\", \\"ccc\\", \\"dddd\\"]) [0, 0, 0, 0] >>> min_operations_for_list_of_strings(1, [\\"radar\\"]) [0] pass","solution":"def min_operations_to_palindrome(S): Returns the minimum number of operations required to make the string S a palindrome. n = len(S) operations = 0 for i in range(n // 2): if S[i] != S[n - i - 1]: operations += 1 return operations def min_operations_for_list_of_strings(T, cases): results = [] for S in cases: results.append(min_operations_to_palindrome(S)) return results"},{"question":"def count_distinct_substrings(s: str, k: int) -> int: Returns the number of distinct substrings of length k in the given string s. >>> count_distinct_substrings(\\"abracadabra\\", 3) == 7 >>> count_distinct_substrings(\\"AAA\\", 2) == 1 >>> count_distinct_substrings(\\"abcde\\", 1) == 5 >>> count_distinct_substrings(\\"abcdefgh\\", 2) == 7 >>> count_distinct_substrings(\\"abcdefabcdef\\", 6) == 6 >>> count_distinct_substrings(\\"a\\", 1) == 1 >>> count_distinct_substrings(\\"aaaaaa\\", 1) == 1 >>> count_distinct_substrings(\\"AaAaAa\\", 2) == 2 >>> count_distinct_substrings(\\"AbCdEfGh\\", 3) == 6","solution":"def count_distinct_substrings(s, k): Returns the number of distinct substrings of length k in the given string s. distinct_substrings = set() for i in range(len(s) - k + 1): substring = s[i:i + k] distinct_substrings.add(substring) return len(distinct_substrings)"},{"question":"def max_score(n, scores, k): Returns the maximum score Luna can achieve by hitting at most k consecutive targets. Parameters: n (int): Number of targets scores (list of int): List with score values of each target k (int): Maximum length of the sequence she can hit Returns: int: Maximum score achieved Examples: >>> max_score(5, [2, 4, 5, 1, 6], 2) 9 >>> max_score(6, [3, 5, 7, 2, 1, 4], 3) 15 >>> max_score(4, [9, 3, 8, 7], 1) 9","solution":"def max_score(n, scores, k): Returns the maximum score Luna can achieve by hitting at most k consecutive targets. Parameters: n (int): Number of targets scores (list of int): List with score values of each target k (int): Maximum length of the sequence she can hit Returns: int: Maximum score achieved max_score = 0 for i in range(n): current_sum = 0 for j in range(k): if i + j < n: current_sum += scores[i + j] max_score = max(max_score, current_sum) return max_score"},{"question":"def min_final_element(arr): Computes the minimum possible final element by continually merging adjacent elements in the array until one element remains. >>> min_final_element([1, 3, 2]) 6 >>> min_final_element([-1, 2, -3, 4]) 2 >>> min_final_element([10, -5, 3, -2]) 6 >>> min_final_element([2, 3, 10, 1]) 16 >>> min_final_element([5, -1, -1, 5]) 8 >>> min_final_element([-1, -1, -1, -1]) -4 >>> min_final_element([100, -100]) 0 >>> min_final_element([50, 50, -100, 50]) 50","solution":"def min_final_element(arr): Computes the minimum possible final element by continually merging adjacent elements in the array until one element remains. while len(arr) > 1: # Find the smallest sum of two adjacent elements min_sum = float('inf') min_index = -1 for i in range(len(arr) - 1): current_sum = arr[i] + arr[i + 1] if current_sum < min_sum: min_sum = current_sum min_index = i # Replace the pair with their sum arr = arr[:min_index] + [min_sum] + arr[min_index + 2:] return arr[0] # Example usage: # print(min_final_element([1, 3, 2])) # Output: 6 # print(min_final_element([-1, 2, -3, 4])) # Output: 2"},{"question":"def calculate_final_scores(m: int, projects_scores: List[List[int]]) -> List[int]: Calculate the final scores for each project based on given rules. >>> calculate_final_scores(4, [[80, 90, 75], [60, 55, 70], [100, 100, 100], [45, 60, 50]]) [81, 61, 100, 51] >>> calculate_final_scores(1, [[1, 1, 1]]) [1] >>> calculate_final_scores(1, [[100, 100, 100]]) [100] >>> calculate_final_scores(3, [[23, 45, 67], [98, 87, 91], [30, 70, 100]]) [45, 92, 66] >>> calculate_final_scores(2, [[10, 20, 30], [100, 1, 99]]) [20, 66]","solution":"def calculate_final_scores(m, projects_scores): Calculate the final scores for each project based on given rules. Parameters: m (int): Number of projects. projects_scores (list of list of int): Scores given by three judges for each project. Returns: list of int: Final scores for each project. final_scores = [] for scores in projects_scores: a, b, c = scores final_score = (a + b + c) // 3 final_scores.append(final_score) return final_scores"},{"question":"def minimum_cost_to_decorate_kingdom(N, M, roads): Given a kingdom's road network, determine the minimum cost to decorate the kingdom such that each city is either part of the decorated area or has an immediate road (connecting directly) to at least one decorated city. Args: N : int : number of cities M : int : number of roads roads : List[Tuple[int, int]] : list of bidirectional roads between cities Returns: int : the minimum cost to decorate the kingdom Examples: >>> minimum_cost_to_decorate_kingdom(5, 3, [(1, 2), (1, 3), (4, 5)]) 2 >>> minimum_cost_to_decorate_kingdom(4, 2, [(1, 2), (3, 4)]) 2 >>> minimum_cost_to_decorate_kingdom(3, 0, []) 3","solution":"def minimum_cost_to_decorate_kingdom(N, M, roads): from collections import defaultdict, deque if M == 0: return N # Graph representation graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) visited = [False] * (N + 1) components = [] def bfs(start): queue = deque([start]) visited[start] = True component_size = 0 while queue: node = queue.popleft() component_size += 1 for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return component_size for city in range(1, N + 1): if not visited[city]: component_size = bfs(city) components.append(component_size) if len(components) == 1: return 1 else: return len(components)"},{"question":"from typing import List def count_greater_permutations(s: str) -> int: Returns the number of distinct permutations of the string s that are lexicographically greater than s. >>> count_greater_permutations(\\"abc\\") 5 >>> count_greater_permutations(\\"cba\\") 0 def process_input(T: int, test_cases: List[str]) -> List[int]: Given the number of test cases T and the list of test cases, returns the list of results for each test case. >>> process_input(2, [\\"abc\\", \\"cba\\"]) [5, 0] >>> process_input(2, [\\"aab\\", \\"aba\\"]) [2, 1]","solution":"from itertools import permutations def count_greater_permutations(s): Returns the number of distinct permutations of the string s that are lexicographically greater than s. perms = set(permutations(s)) count = 0 for perm in perms: if ''.join(perm) > s: count += 1 return count def process_input(T, test_cases): Given the number of test cases T and the list of test cases, returns the list of results for each test case. results = [] for s in test_cases: results.append(count_greater_permutations(s)) return results def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) test_cases = data[1:T + 1] results = process_input(T, test_cases) for result in results: print(result)"},{"question":"def segregate_even_odd(arr): Segregates the even and odd numbers from the given array of integers. Parameters: arr (list): List of integers. Returns: tuple: Two lists, first containing even integers and second containing odd integers. >>> segregate_even_odd([4, 3, 7, 8, 2]) ([4, 8, 2], [3, 7]) >>> segregate_even_odd([-1, 4, 5]) ([4], [-1, 5]) >>> segregate_even_odd([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) ([0, 2, 4, 6, 8], [1, 3, 5, 7, 9]) >>> segregate_even_odd([]) ([], []) >>> segregate_even_odd([10, 20, 30]) ([10, 20, 30], []) >>> segregate_even_odd([1, 3, 5, 7, 9]) ([], [1, 3, 5, 7, 9])","solution":"def segregate_even_odd(arr): Segregates the even and odd numbers from the given array of integers. Parameters: arr (list): List of integers. Returns: tuple: Two lists, first containing even integers and second containing odd integers. even = [x for x in arr if x % 2 == 0] odd = [x for x in arr if x % 2 != 0] return even, odd"},{"question":"def find_winner(num_players: int, scores: List[int]) -> Tuple[int, int]: Finds the highest score and the index of the first player who achieved it. Parameters: num_players (int): Number of players. scores (List[int]): List of scores for each player. Returns: Tuple[int, int]: A tuple containing the highest score and the 1-based index of the player. >>> find_winner(5, [7, 10, 4, 10, 6]) (10, 2) >>> find_winner(3, [8, 8, 8]) (8, 1) >>> find_winner(4, [9, 4, 12, 10]) (12, 3)","solution":"def find_winner(num_players, scores): Finds the highest score and the index of the first player who achieved it. Parameters: num_players (int): Number of players. scores (List[int]): List of scores for each player. Returns: Tuple[int, int]: A tuple containing the highest score and the 1-based index of the player. max_score = -1 winner_index = -1 for i in range(num_players): if scores[i] > max_score: max_score = scores[i] winner_index = i + 1 return (max_score, winner_index)"},{"question":"def min_num_of_roads(t: int, test_cases: List[Tuple[int, int]]) -> List[int]: Calculate the minimum number of two-way roads required to connect all neighborhoods in a grid. >>> min_num_of_roads(2, [(3, 4), (2, 2)]) [17, 4] >>> min_num_of_roads(1, [(1, 1)]) [0] >>> min_num_of_roads(1, [(1, 5)]) [4] >>> min_num_of_roads(1, [(5, 1)]) [4] >>> min_num_of_roads(1, [(1000000, 1000000)]) [1999998000000] result = [] for n, m in test_cases: # Calculate the minimum number of roads required roads = (n - 1) * m + (m - 1) * n result.append(roads) return result","solution":"def min_num_of_roads(t, test_cases): result = [] for n, m in test_cases: # Minimum number of roads (n - 1) * m + (m - 1) * n roads = (n - 1) * m + (m - 1) * n result.append(roads) return result"},{"question":"def can_rearrange_grid(n: int, grid: List[List[int]]) -> str: Determine whether it is possible to rearrange the grid such that all rows and columns are either strictly increasing or strictly decreasing. >>> can_rearrange_grid(3, [[2, 3, 1], [4, 2, 5], [9, 7, 8]]) \\"Impossible\\" >>> can_rearrange_grid(2, [[1, 2], [3, 4]]) \\"Possible\\" >>> can_rearrange_grid(4, [[6, 3, 8, 7], [2, 9, 1, 5], [10, 12, 4, 11], [15, 14, 13, 16]]) \\"Possible\\"","solution":"def can_rearrange_grid(n, grid): Determine whether it is possible to rearrange the grid such that all rows and columns are either strictly increasing or strictly decreasing. # Flatten the grid values and sort them to have a list of values to create an ordered grid values = sorted([grid[i][j] for i in range(n) for j in range(n)]) # Check if we can form a grid that satisfies the conditions by filling rows. # Fill a new grid with sorted values sorted_grid = [[0] * n for _ in range(n)] index = 0 for i in range(n): for j in range(n): sorted_grid[i][j] = values[index] index += 1 # Check if rows are strictly increasing for i in range(n): for j in range(n - 1): if sorted_grid[i][j] >= sorted_grid[i][j + 1]: return \\"Impossible\\" # Check if columns are strictly increasing for j in range(n): for i in range(n - 1): if sorted_grid[i][j] >= sorted_grid[i + 1][j]: return \\"Impossible\\" return \\"Possible\\""},{"question":"from typing import List, Tuple def max_non_overlapping_events(events: List[Tuple[int, int]]) -> int: Determines the maximum number of non-overlapping events that can be hosted in a single auditorium. Args: events (List[Tuple[int, int]]): List of tuples where each tuple contains the start and end time of an event. Returns: int: Maximum number of non-overlapping events. pass # Example usage and testing: def test_example_1(): events = [(1, 4), (2, 5), (5, 8), (3, 6), (8, 9)] assert max_non_overlapping_events(events) == 3 def test_example_2(): events = [(1, 3), (3, 5), (4, 6), (5, 7)] assert max_non_overlapping_events(events) == 3 def test_all_overlap(): events = [(1, 5), (2, 5), (3, 5)] assert max_non_overlapping_events(events) == 1 def test_no_overlap(): events = [(1, 2), (3, 4), (5, 6)] assert max_non_overlapping_events(events) == 3 def test_multiple_events_same_end(): events = [(1, 4), (2, 3), (1, 3), (3, 4)] assert max_non_overlapping_events(events) == 2 def test_large_number_of_events(): events = [(i, i + 2) for i in range(0, 200000, 3)] assert max_non_overlapping_events(events) == 66667 def test_large_gaps_between_events(): events = [(0, 1), (1000, 1001), (2000, 2001)] assert max_non_overlapping_events(events) == 3","solution":"def max_non_overlapping_events(events): Determines the maximum number of non-overlapping events that can be hosted in a single auditorium. Args: events (List[Tuple[int, int]]): List of tuples where each tuple contains the start and end time of an event. Returns: int: Maximum number of non-overlapping events. # Sort the events by their end time events.sort(key=lambda x: x[1]) max_events = 0 current_end_time = 0 for start, end in events: if start >= current_end_time: max_events += 1 current_end_time = end return max_events # Example usage: # n = int(input()) # events = [tuple(map(int, input().split())) for _ in range(n)] # print(max_non_overlapping_events(events))"},{"question":"def can_be_split_into_palindromic_subsequences(s: str) -> str: Given a string, determine if it is made up of two interleaved palindromic subsequences. Args: s (str): A string Returns: str: \\"YES\\" if the string can be split into two interleaved palindromic subsequences, otherwise \\"NO\\" Examples: >>> can_be_split_into_palindromic_subsequences(\\"abbaa\\") \\"YES\\" >>> can_be_split_into_palindromic_subsequences(\\"abcdef\\") \\"NO\\" # Implementation here def solution(t: int, test_cases: List[str]) -> List[str]: Solution function that processes multiple test cases. Args: t (int): Number of test cases test_cases (List[str]): A list of test case strings Returns: List[str]: List of results for each test case Examples: >>> solution(3, [\\"abbaa\\", \\"abcdef\\", \\"aaabbb\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] results = [] for s in test_cases: result = can_be_split_into_palindromic_subsequences(s) results.append(result) return results from solution import can_be_split_into_palindromic_subsequences, solution def test_single_case_yes(): assert solution(1, [\\"abbaa\\"]) == [\\"YES\\"] def test_single_case_no(): assert solution(1, [\\"abcdef\\"]) == [\\"NO\\"] def test_single_case_yes_2(): assert solution(1, [\\"aaabbb\\"]) == [\\"YES\\"] def test_multiple_cases(): assert solution(3, [\\"abbaa\\", \\"abcdef\\", \\"aaabbb\\"]) == [\\"YES\\", \\"NO\\", \\"YES\\"] def test_edge_case_empty_string(): assert solution(1, [\\"\\"]) == [\\"YES\\"] def test_edge_case_single_character(): assert solution(1, [\\"a\\"]) == [\\"YES\\"] def test_edge_case_repeated_character(): assert solution(1, [\\"aaaaa\\"]) == [\\"YES\\"] def test_edge_case_two_palindromic_pairs(): assert solution(1, [\\"abba\\"]) == [\\"YES\\"]","solution":"def can_be_split_into_palindromic_subsequences(s): Function to check if string can be split into two interleaved palindromic subsequences. from collections import Counter # Count frequency of each character in the string freq = Counter(s) # Count the number of characters that have odd frequency odd_count = sum(1 for count in freq.values() if count % 2 != 0) # A string can be split into 2 palindromic subsequences if and only if # it has at most 2 characters with an odd count return \\"YES\\" if odd_count <= 2 else \\"NO\\" def solution(t, test_cases): results = [] for s in test_cases: result = can_be_split_into_palindromic_subsequences(s) results.append(result) return results"},{"question":"def count_pairs_with_diff_k(n: int, k: int, array: List[int]) -> int: This function counts the number of distinct pairs (i, j) such that i < j and |A[i] - A[j]| = K. >>> count_pairs_with_diff_k(5, 3, [1, 5, 3, 4, 2]) 2 >>> count_pairs_with_diff_k(4, 1, [1, 2, 3, 4]) 3 from solution import count_pairs_with_diff_k def test_example_cases(): assert count_pairs_with_diff_k(5, 3, [1, 5, 3, 4, 2]) == 2 assert count_pairs_with_diff_k(4, 1, [1, 2, 3, 4]) == 3 def test_no_pairs(): assert count_pairs_with_diff_k(5, 10, [1, 2, 3, 4, 5]) == 0 def test_all_pairs(): assert count_pairs_with_diff_k(3, 1, [1, 2, 3]) == 2 def test_large_k_value(): assert count_pairs_with_diff_k(5, 10**9, [1, 10**9 + 1, 10**9 + 2, 10**9 + 3, 10**9 + 4]) == 1 def test_duplicates_in_array(): assert count_pairs_with_diff_k(6, 2, [1, 3, 1, 3, 5, 7]) == 3 def test_large_n(): assert count_pairs_with_diff_k(10**5, 1, list(range(1, 10**5+1))) == 10**5 - 1","solution":"def count_pairs_with_diff_k(n, k, array): This function counts the number of distinct pairs (i, j) such that i < j and |A[i] - A[j]| = K. :param n: Length of the array :param k: The difference value :param array: List of integers :return: Number of distinct pairs with the given difference count = 0 elements_set = set(array) for element in elements_set: if (element + k) in elements_set: count += 1 return count"},{"question":"def final_item_count(s: str) -> int: Given a string S representing the record of items processed in each of four shifts with 'I' or 'D', returns the final count of items processed. \`I\` represents an increase of 1 item processed. \`D\` represents a decrease of 1 item processed. Examples: >>> final_item_count('IIII') 4 >>> final_item_count('IDDI') 0 >>> final_item_count('DDID') -2","solution":"def final_item_count(s): Given a string S representing the record of items processed in each of four shifts with 'I' or 'D', returns the final count of items processed. \`I\` represents an increase of 1 item processed. \`D\` represents a decrease of 1 item processed. count = 0 for char in s: if char == 'I': count += 1 elif char == 'D': count -= 1 return count"},{"question":"def modify_distances(n: int, distances: List[int]) -> List[int]: Modify the sequence of distances such that no two consecutive distances are the same while making the fewest modifications possible. Parameters: n (int): The number of days in the training sequence. distances (list of int): The intended distances for each day. Returns: list of int: The modified sequence of distances. >>> modify_distances(5, [5, 5, 5, 5, 5]) [5, 4, 5, 4, 5] >>> modify_distances(3, [10, 10, 10]) [10, 9, 10] >>> modify_distances(6, [1, 2, 2, 3, 3, 4]) [1, 2, 1, 3, 2, 4]","solution":"def modify_distances(n, distances): Modify the sequence of distances such that no two consecutive distances are the same while making the fewest modifications possible. Parameters: n (int): The number of days in the training sequence. distances (list of int): The intended distances for each day. Returns: list of int: The modified sequence of distances. for i in range(1, n): if distances[i] == distances[i-1]: if distances[i] > 1: distances[i] -= 1 else: distances[i] += 1 return distances"},{"question":"def minimum_coins(n: int) -> int: Given an integer n (1 ≤ n ≤ 10^6), returns the minimum number of coins needed to make up that amount using coins of denominations 1, 2, and 5. Examples: >>> minimum_coins(11) 3 >>> minimum_coins(3) 2 >>> minimum_coins(14) 4 pass def test_minimum_coins(): assert minimum_coins(11) == 3 # 5 + 5 + 1 assert minimum_coins(3) == 2 # 2 + 1 assert minimum_coins(14) == 4 # 5 + 5 + 2 + 2 assert minimum_coins(0) == 0 # 0 coins needed for 0 cents assert minimum_coins(1) == 1 # 1 coin of 1 cent assert minimum_coins(2) == 1 # 1 coin of 2 cents assert minimum_coins(6) == 2 # 5 + 1 assert minimum_coins(7) == 2 # 5 + 2 assert minimum_coins(9) == 3 # 5 + 2 + 2 assert minimum_coins(15) == 3 # 5 + 5 + 5 assert minimum_coins(20) == 4 # 5 x 4 if __name__ == '__main__': test_minimum_coins() print(\\"All tests passed.\\")","solution":"def minimum_coins(n): Given an integer n (1 ≤ n ≤ 10^6), returns the minimum number of coins needed to make up that amount using coins of denominations 1, 2, and 5. coins_of_5 = n // 5 remainder_after_5 = n % 5 coins_of_2 = remainder_after_5 // 2 remainder_after_2 = remainder_after_5 % 2 coins_of_1 = remainder_after_2 return coins_of_5 + coins_of_2 + coins_of_1"},{"question":"def max_element_after_operations(n: int, m: int, array: List[int], operations: List[List[int]]) -> List[int]: This function modifies an array based on a series of operations and returns the maximum element in the array after each operation. Parameters: n (int): The length of the array. m (int): The number of operations. array (List[int]): The array of positive integers. operations (List[List[int]]): The list of operations to perform on the array. Returns: List[int]: A list containing the maximum element in the array after each operation. Example: >>> max_element_after_operations(6, 4, [1, 3, 5, 2, 4, 6], [[1, 4, 7], [2], [3, 3], [1, 2, 8]]) [7, 7, 7, 8] pass # Unit Test import pytest def test_example_case(): n = 6 m = 4 array = [1, 3, 5, 2, 4, 6] operations = [ [1, 4, 7], [2], [3, 3], [1, 2, 8] ] assert max_element_after_operations(n, m, array, operations) == [7, 7, 7, 8] def test_single_element_array(): n = 1 m = 1 array = [5] operations = [ [1, 1, 10], ] assert max_element_after_operations(n, m, array, operations) == [10] def test_multiple_replacements(): n = 4 m = 3 array = [1, 2, 3, 4] operations = [ [1, 2, 9], [1, 3, 7], [1, 4, 8] ] assert max_element_after_operations(n, m, array, operations) == [9, 9, 9] def test_reverse_operation(): n = 5 m = 2 array = [10, 20, 30, 40, 50] operations = [ [2], [2] ] assert max_element_after_operations(n, m, array, operations) == [50, 50] def test_rotate_operation(): n = 5 m = 2 array = [1, 2, 3, 4, 5] operations = [ [3, 2], [3, 3] ] assert max_element_after_operations(n, m, array, operations) == [5, 5]","solution":"def max_element_after_operations(n, m, array, operations): max_elements = [] for op in operations: if op[0] == 1: # Replace the integer at position pi with the integer vi pi, vi = op[1], op[2] array[pi - 1] = vi elif op[0] == 2: # Reverse the entire array array.reverse() elif op[0] == 3: #Rotate the array to the right by ri positions ri = op[1] array = array[-ri:] + array[:-ri] max_elements.append(max(array)) return max_elements # Example usage: # n = 6 # m = 4 # array = [1, 3, 5, 2, 4, 6] # operations = [ # [1, 4, 7], # [2], # [3, 3], # [1, 2, 8] # ] # print(max_element_after_operations(n, m, array, operations))"},{"question":"from typing import List def can_form_palindrome(s: str) -> str: Determines if a given string can be rearranged to form a palindrome. Args: s (str): Input string Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, \\"NO\\" otherwise. >>> can_form_palindrome(\\"aabb\\") \\"YES\\" >>> can_form_palindrome(\\"carerac\\") \\"YES\\" >>> can_form_palindrome(\\"hello\\") \\"NO\\" # Write your code here def check_palindrome_cases(n: int, cases: List[str]) -> List[str]: Given multiple test cases, determine if each can form a palindrome. Args: n (int): Number of test cases cases (List[str]): List of strings Returns: List[str]: List containing \\"YES\\" or \\"NO\\" for each test case >>> check_palindrome_cases(3, [\\"aabb\\", \\"carerac\\", \\"hello\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> check_palindrome_cases(2, [\\"abba\\", \\"aabbccdd\\"]) [\\"YES\\", \\"YES\\"] >>> check_palindrome_cases(3, [\\"abcdef\\", \\"a\\", \\"aa\\"]) [\\"NO\\", \\"YES\\", \\"YES\\"] # Write your code here","solution":"def can_form_palindrome(s): Determines if a given string can be rearranged to form a palindrome. Args: s (str): Input string Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, \\"NO\\" otherwise. from collections import Counter s = s.lower() char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return \\"YES\\" if odd_count <= 1 else \\"NO\\" def check_palindrome_cases(n, cases): Given multiple test cases, determine if each can form a palindrome. Args: n (int): Number of test cases cases (list): List of strings Returns: list: List containing \\"YES\\" or \\"NO\\" for each test case return [can_form_palindrome(s) for s in cases]"},{"question":"def can_split_sequence_equal_sum(T: int, testcases: List[Tuple[int, List[int]]]) -> List[str]: Determine if given sequences can be split into two non-empty subsequences with equal sum. >>> can_split_sequence_equal_sum(2, [(4, [1, 5, 3, 3]), (5, [2, -2, 3, 1, 2])]) [\\"YES\\", \\"YES\\"] >>> can_split_sequence_equal_sum(1, [(4, [1, 2, 3, 4])]) [\\"NO\\"] >>> can_split_sequence_equal_sum(1, [(3, [-1, -1, -2])]) [\\"YES\\"] >>> can_split_sequence_equal_sum(1, [(4, [0, 0, 0, 0])]) [\\"YES\\"] >>> can_split_sequence_equal_sum(1, [(2, [1, 2])]) [\\"NO\\"] >>> can_split_sequence_equal_sum(1, [(3, [100000, 50000, 50000])]) [\\"YES\\"]","solution":"def can_split_sequence_equal_sum(T, testcases): results = [] for i in range(T): N = testcases[i][0] sequence = testcases[i][1] total_sum = sum(sequence) if total_sum % 2 != 0: results.append(\\"NO\\") continue target_sum = total_sum // 2 current_sum = 0 for num in sequence: current_sum += num if current_sum == target_sum: results.append(\\"YES\\") break else: results.append(\\"NO\\") return results"},{"question":"def warehouse_operations(n, operations): Processes stack operations in a warehouse and returns the counts of specific widths after operations. Args: n (int): Number of operations operations (List[str]): List of operations Returns: List[int]: Result of each \\"cnt y\\" query Example: >>> warehouse_operations(7, [ \\"push 1 5\\", \\"push 2 6\\", \\"push 1 5\\", \\"push 3 5\\", \\"pop 1\\", \\"cnt 5\\", \\"cnt 6\\" ]) [2, 1] pass from solution import warehouse_operations def test_example_scenario(): operations = [ \\"push 1 5\\", \\"push 2 6\\", \\"push 1 5\\", \\"push 3 5\\", \\"pop 1\\", \\"cnt 5\\", \\"cnt 6\\" ] assert warehouse_operations(7, operations) == [2, 1] def test_single_push_and_count(): operations = [ \\"push 1 10\\", \\"cnt 10\\" ] assert warehouse_operations(2, operations) == [1] def test_push_multiple_and_count(): operations = [ \\"push 1 7\\", \\"push 1 7\\", \\"push 2 7\\", \\"cnt 7\\" ] assert warehouse_operations(4, operations) == [3] def test_push_and_pop(): operations = [ \\"push 1 4\\", \\"pop 1\\", \\"cnt 4\\" ] assert warehouse_operations(3, operations) == [0] def test_no_operations(): operations = [] assert warehouse_operations(0, operations) == [] def test_multiple_push_pop_count(): operations = [ \\"push 1 3\\", \\"push 2 3\\", \\"push 2 3\\", \\"pop 2\\", \\"cnt 3\\", \\"push 3 5\\", \\"cnt 5\\", \\"pop 3\\", \\"cnt 3\\" ] assert warehouse_operations(9, operations) == [2, 1, 2]","solution":"def warehouse_operations(n, operations): from collections import defaultdict, Counter, deque stacks = defaultdict(deque) width_counter = Counter() results = [] for operation in operations: parts = operation.split() if parts[0] == \\"push\\": stack_num = int(parts[1]) width = int(parts[2]) stacks[stack_num].append(width) width_counter[width] += 1 elif parts[0] == \\"pop\\": stack_num = int(parts[1]) if stacks[stack_num]: width = stacks[stack_num].pop() width_counter[width] -= 1 elif parts[0] == \\"cnt\\": width = int(parts[1]) results.append(width_counter[width]) return results"},{"question":"from typing import List, Tuple def max_independent_planetary_systems(m: int, k: int, highways: List[Tuple[int, int, int]]) -> int: Determine the maximum number of independent planetary systems that can be formed to meet the mission's strength requirement. >>> max_independent_planetary_systems(5, 10, [(1, 2, 3), (1, 3, 2), (2, 4, 4), (2, 5, 6)]) 2 >>> max_independent_planetary_systems(4, 7, [(1, 2, 1), (1, 3, 5), (3, 4, 2)]) 2 >>> max_independent_planetary_systems(3, 5, [(1, 2, 2), (2, 3, 3)]) 1 >>> max_independent_planetary_systems(6, 8, [(1, 2, 3), (1, 3, 3), (3, 4, 2), (3, 5, 1), (5, 6, 4)]) 2 >>> max_independent_planetary_systems(1, 5, []) 1","solution":"def max_independent_planetary_systems(m, k, highways): from collections import defaultdict # Build adjacency list for the tree tree = defaultdict(list) for u, v, s in highways: tree[u].append((v, s)) tree[v].append((u, s)) def dfs(node, parent): total_strength = 0 systems = 0 for neighbor, strength in tree[node]: if neighbor == parent: continue child_strength, child_systems = dfs(neighbor, node) # If adding this child does not exceed the limit, add its strength if total_strength + strength + child_strength <= k: total_strength += strength + child_strength systems += child_systems else: # Otherwise, consider it as a separate system systems += 1 return total_strength, systems # Total number of systems _, result = dfs(1, -1) # Include the initial system return result + 1"},{"question":"def min_cost_to_adjust_trees(n: int, A: int, B: int, heights: List[int]) -> int: Determine the minimum cost required to adjust the heights of a row of trees so that no two adjacent trees have the same height. >>> min_cost_to_adjust_trees(6, 1, 2, [3, 3, 4, 4, 5, 5]) 3 >>> min_cost_to_adjust_trees(4, 1, 2, [1, 2, 1, 2]) 0 >>> min_cost_to_adjust_trees(3, 3, 1, [2, 2, 2]) 1 >>> min_cost_to_adjust_trees(3, 1, 3, [2, 2, 2]) 1 >>> min_cost_to_adjust_trees(5, 2, 3, [3, 3, 2, 2, 1]) 4 >>> min_cost_to_adjust_trees(1, 2, 2, [100]) 0 >>> min_cost_to_adjust_trees(2, 1, 1, [100, 100]) 1","solution":"def min_cost_to_adjust_trees(n, A, B, heights): cost = 0 for i in range(1, n): if heights[i] == heights[i-1]: if A < B: heights[i] += 1 cost += A else: heights[i] -= 1 cost += B return cost"},{"question":"from typing import List, Tuple def is_creation_possible(N: int, blocks_data: List[Tuple[str, int]], M: int, required_data: List[Tuple[str, int]]) -> str: Determine whether it is possible to create a specific composite shape given the set of available building blocks. Args: N: int - Number of available building blocks blocks_data: List[Tuple[str, int]] - List of building blocks with shape and size M: int - Number of required shapes required_data: List[Tuple[str, int]] - List of required shapes with their maximum size Returns: str: 'Possible' if it is possible to create each of the specified composite shapes, otherwise 'Impossible' >>> is_creation_possible(4, [('circle', 10), ('circle', 20), ('square', 5), ('square', 10)], 2, [('circle', 25), ('square', 10)]) 'Possible' >>> is_creation_possible(4, [('circle', 10), ('circle', 15), ('triangle', 5), ('square', 10)], 2, [('circle', 30), ('triangle', 5)]) 'Impossible'","solution":"def can_create_composite_shapes(blocks, required_shapes): from collections import defaultdict # Parse block sizes by shape block_sizes = defaultdict(list) for shape, size in blocks: block_sizes[shape].append(size) # Sort each shape's block sizes for efficient comparison for shape in block_sizes: block_sizes[shape].sort() # Check each required shape for shape, max_size in required_shapes: if shape not in block_sizes: return 'Impossible' # Total size created by blocks of this shape total_size = sum(size for size in block_sizes[shape] if size <= max_size) # Check if the total size is within the required max_size limit if total_size < max_size: return 'Impossible' return 'Possible' # Main function to interface with the problem's input format def is_creation_possible(N, blocks_data, M, required_data): blocks = [(blocks_data[i][0], blocks_data[i][1]) for i in range(N)] required_shapes = [(required_data[i][0], required_data[i][1]) for i in range(M)] return can_create_composite_shapes(blocks, required_shapes)"},{"question":"def palindromic_transformation(input_data: str) -> List[int]: Palindromic Subsequence Transformation Determine whether it is possible to transform the sequence A into a palindromic sequence using the given transformation rules. If possible, compute the minimum number of transformations required to achieve it. >>> palindromic_transformation(\\"3 3n1 2 3n1 3n2 2n3 1n0 0n\\") == [1] >>> palindromic_transformation(\\"4 2n4 4 2 1n4 1n2 3n0 0n\\") == [-1] >>> palindromic_transformation(\\"3 3n1 1 1n1 3n2 2n3 1n0 0n\\") == [0] >>> palindromic_transformation(\\"3 3n1 2 1n1 3n2 2n3 1n0 0n\\") == [0] >>> palindromic_transformation(\\"5 2n1 5 3 5 1n5 5n3 3n0 0n\\") == [0] >>> palindromic_transformation(\\"5 5n1 2 3 4 5n1 2n2 3n3 4n4 5n5 1n0 0n\\") == [3]","solution":"from collections import defaultdict, deque def is_palindromic(seq): return seq == seq[::-1] def min_transformations_to_palindrome(n, r, A, transformations): if is_palindromic(A): return 0 transform_dict = defaultdict(list) for x, y in transformations: transform_dict[x].append(y) queue = deque([(A, 0)]) # (current sequence, steps) visited = set() visited.add(tuple(A)) while queue: current, steps = queue.popleft() for i in range(n): for j in transform_dict[current[i]]: new_seq = current[:i] + [j] + current[i+1:] if tuple(new_seq) in visited: continue if is_palindromic(new_seq): return steps + 1 visited.add(tuple(new_seq)) queue.append((new_seq, steps + 1)) return -1 def palindromic_transformation(input_data): datasets = input_data.strip().split('n') result = [] i = 0 while i < len(datasets): n, r = map(int, datasets[i].split()) if n == 0 and r == 0: break i += 1 A = list(map(int, datasets[i].split())) transformations = [] for _ in range(r): i += 1 transformations.append(tuple(map(int, datasets[i].split()))) result.append(min_transformations_to_palindrome(n, r, A, transformations)) i += 1 return result"},{"question":"def max_distance_sum(n: int, k: int, positions: List[int]) -> int: Returns the maximum possible sum of distances Rainbow Dash can achieve. Args: n: Integer, number of checkpoints. k: Integer, maximum allowed skip distance. positions: List of integers, positions of the checkpoints. Returns: Integer, maximum possible sum of distances. >>> max_distance_sum(6, 2, [1, 2, 3, 5, 6, 8]) 7 >>> max_distance_sum(5, 3, [1, 5, 8, 10, 13]) 12","solution":"def max_distance_sum(n, k, positions): Returns the maximum possible sum of distances Rainbow Dash can achieve. Args: n: Integer, number of checkpoints. k: Integer, maximum allowed skip distance. positions: List of integers, positions of the checkpoints. Returns: Integer, maximum possible sum of distances. # dp[i] will store the maximum distance sum ending at checkpoint i dp = [0] * n # Initialize the dp array for i in range(1, n): for j in range(max(0, i - k), i): dp[i] = max(dp[i], dp[j] + (positions[i] - positions[j])) return max(dp)"},{"question":"def can_accommodate_all_bookings(n: int, bookings: List[Tuple[int, int]], m: int) -> str: Determine whether you can accommodate all booking requests in your hotel. >>> can_accommodate_all_bookings(3, [(1, 5), (2, 6), (5, 10)], 2) 'YES' >>> can_accommodate_all_bookings(4, [(1, 3), (2, 5), (4, 6), (7, 8)], 1) 'NO'","solution":"def can_accommodate_all_bookings(n, bookings, m): events = [] # Create events for each booking's arrival and departure for booking in bookings: a, d = booking events.append((a, 1)) # arrival events.append((d, -1)) # departure # Sort events first by time and then by type (departure before arrival if on same day) events.sort(key=lambda x: (x[0], x[1])) current_rooms = 0 for event in events: current_rooms += event[1] if current_rooms > m: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List def generate_permutations(s: str) -> List[str]: Generate all possible permutations of string s in lexicographical order. >>> generate_permutations('abc') ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'] >>> generate_permutations('a') ['a'] >>> generate_permutations('bac') ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'] def test_generate_permutations(): assert generate_permutations('a') == ['a'] assert generate_permutations('ab') == ['ab', 'ba'] assert generate_permutations('abc') == ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'] result = generate_permutations('abcd') expected = [ 'abcd', 'abdc', 'acbd', 'acdb', 'adbc', 'adcb', 'bacd', 'badc', 'bcad', 'bcda', 'bdac', 'bdca', 'cabd', 'cadb', 'cbad', 'cbda', 'cdab', 'cdba', 'dabc', 'dacb', 'dbac', 'dbca', 'dcab', 'dcba' ] assert result == expected result = generate_permutations('abcdefgh') assert len(result) == 40320 # 8! assert generate_permutations('bac') == ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']","solution":"from itertools import permutations def generate_permutations(s): Returns all possible permutations of string s in lexicographical order. perm = sorted([''.join(p) for p in permutations(s)]) return perm"},{"question":"def can_form_arithmetic_progression(n: int, sequence: List[int]) -> str: Determines if a sequence of integers can form an arithmetic progression after reordering. Args: n (int): the number of elements in the sequence sequence (list): list of integers representing the sequence Returns: str: \\"YES\\" if the sequence can be reordered to form an arithmetic progression, otherwise \\"NO\\". >>> can_form_arithmetic_progression(4, [3, 5, 1, 7]) == \\"YES\\" >>> can_form_arithmetic_progression(3, [1, 2, 4]) == \\"NO\\" >>> can_form_arithmetic_progression(5, [1, 3, 5, 7, 9]) == \\"YES\\"","solution":"def can_form_arithmetic_progression(n, sequence): Determines if a sequence of integers can form an arithmetic progression after reordering. Args: n (int): the number of elements in the sequence sequence (list): list of integers representing the sequence Returns: str: \\"YES\\" if the sequence can be reordered to form an arithmetic progression, otherwise \\"NO\\". sequence.sort() difference = sequence[1] - sequence[0] for i in range(2, n): if sequence[i] - sequence[i-1] != difference: return \\"NO\\" return \\"YES\\""},{"question":"def calculate_final_heights(n: int, m: int, heights: List[int], formulas: List[Tuple[int, int, int]]) -> List[int]: Calculate the final heights of the plants after applying all growth formulas. :param n: Number of plants :param m: Number of growth formulas :param heights: List of initial heights of the plants :param formulas: List of growth formulas (li, ri, di) :return: List of final heights of the plants >>> calculate_final_heights(5, 3, [1, 2, 3, 4, 5], [(1, 3, 2), (2, 5, 1), (4, 5, 3)]) [3, 5, 6, 8, 9] >>> calculate_final_heights(4, 2, [5, 6, 7, 8], [(2, 4, 3), (1, 1, 4)]) [9, 9, 10, 11]","solution":"def calculate_final_heights(n, m, heights, formulas): Calculate the final heights of the plants after applying all growth formulas. :param n: Number of plants :param m: Number of growth formulas :param heights: List of initial heights of the plants :param formulas: List of growth formulas (li, ri, di) :return: List of final heights of the plants # Applying the growth formulas one by one for formula in formulas: li, ri, di = formula for i in range(li - 1, ri): heights[i] += di return heights"},{"question":"def has_pair_with_difference(nums: List[int], k: int) -> str: Determines if there exist two integers in the list whose absolute difference is equal to k. >>> has_pair_with_difference([1, 5, 3, 4, 2], 3) \\"YES\\" >>> has_pair_with_difference([8, 12, 16, 24], 4) \\"YES\\" >>> has_pair_with_difference([1, -1, 2], 10) \\"NO\\" nums_set = set(nums) for num in nums: if (num + k in nums_set) or (num - k in nums_set): return \\"YES\\" return \\"NO\\" # Unit Tests def test_example1(): nums = [1, 5, 3, 4, 2] k = 3 assert has_pair_with_difference(nums, k) == \\"YES\\" def test_example2(): nums = [8, 12, 16, 24] k = 4 assert has_pair_with_difference(nums, k) == \\"YES\\" def test_example3(): nums = [1, -1, 2] k = 10 assert has_pair_with_difference(nums, k) == \\"NO\\" def test_no_pairs_case(): nums = [2, 4, 6, 8] k = 7 assert has_pair_with_difference(nums, k) == \\"NO\\" def test_same_elements(): nums = [5, 5, 5, 5] k = 0 assert has_pair_with_difference(nums, k) == \\"YES\\" def test_large_difference(): nums = [1, 3, 6, 10] k = 20 assert has_pair_with_difference(nums, k) == \\"NO\\" def test_large_list(): nums = list(range(1000000)) k = 999999 assert has_pair_with_difference(nums, k) == \\"YES\\"","solution":"def has_pair_with_difference(nums, k): Determines if there exist two integers in the list whose absolute difference is equal to k. Args: nums : list of int : List of integers. k : int : Required absolute difference. Returns: str : \\"YES\\" if such a pair exists, \\"NO\\" otherwise. nums_set = set(nums) for num in nums: if (num + k in nums_set) or (num - k in nums_set): return \\"YES\\" return \\"NO\\" # Example usage n = 5 nums = [1, 5, 3, 4, 2] k = 3 print(has_pair_with_difference(nums, k)) # Output: YES"},{"question":"def min_operations_to_equalize(n: int, heights: List[int]) -> int: Returns the minimum number of operations required to make all blocks the same height. Parameters: n (int): the number of blocks heights (List[int]): heights of the blocks Returns: int: minimum number of operations to equalize all blocks Examples: >>> min_operations_to_equalize(5, [1, 2, 3, 4, 5]) 6 >>> min_operations_to_equalize(3, [7, 7, 7]) 0","solution":"def min_operations_to_equalize(n, heights): Returns the minimum number of operations required to make all blocks the same height. :param n: int, the number of blocks :param heights: list of int, heights of the blocks :return: int, minimum number of operations to equalize all blocks median_height = sorted(heights)[n // 2] return sum(abs(height - median_height) for height in heights)"},{"question":"def check_rounds_overlap(n: int, rounds: List[Tuple[int, int]]) -> str: Determines if any two rounds overlap based on their start and end times. Parameters: n (int): The number of rounds. rounds (List[Tuple[int, int]]): List of tuples where each tuple contains start and end times of a round. Returns: str: \\"YES\\" if any two rounds overlap, otherwise \\"NO\\". Examples: >>> check_rounds_overlap(3, [(1, 5), (6, 10), (4, 8)]) 'YES' >>> check_rounds_overlap(3, [(1, 5), (6, 10), (11, 15)]) 'NO'","solution":"def check_rounds_overlap(n, rounds): Determines if any two rounds overlap based on their start and end times. Parameters: n (int): The number of rounds. rounds (List[Tuple[int, int]]): List of tuples where each tuple contains start and end times of a round. Returns: str: \\"YES\\" if any two rounds overlap, otherwise \\"NO\\". # Sort rounds by their start times rounds.sort() # Iterate through the rounds and check for any overlap for i in range(n - 1): if rounds[i][1] > rounds[i + 1][0]: return \\"YES\\" return \\"NO\\""},{"question":"def find_corrupted_sequence(n: int, k: int, sequence: List[int]) -> Union[str, Tuple[int, int]]: This function checks if there is a corrupted subsequence in the given sequence. If there is, it returns the positions of the first corrupted subsequence found. Otherwise, it returns \\"OK\\". Parameters: n (int): The length of the sequence. k (int): The distance between potentially corrupted numbers. sequence (list): The sequence of numbers. Returns: tuple or str: Returns a tuple (i, j) if a corrupted subsequence is found, otherwise \\"OK\\". >>> find_corrupted_sequence(5, 3, [1, 2, 3, 4, 5]) \\"OK\\" >>> find_corrupted_sequence(6, 2, [1, 3, 1, 2, 1, 4]) (1, 3)","solution":"def find_corrupted_sequence(n, k, sequence): This function checks if there is a corrupted subsequence in the given sequence. If there is, it returns the positions of the first corrupted subsequence found. Otherwise, it returns \\"OK\\". Parameters: n (int): The length of the sequence. k (int): The distance between potentially corrupted numbers. sequence (list): The sequence of numbers. Returns: tuple or str: Returns a tuple (i, j) if a corrupted subsequence is found, otherwise \\"OK\\". for i in range(n - k): if sequence[i] == sequence[i + k]: return i + 1, i + k + 1 return \\"OK\\""},{"question":"def max_impact_weight(n: int, weights: List[int]) -> int: Returns the maximum impact weight that can be achieved by rearranging the sequence of dominoes. >>> max_impact_weight(4, [4, 1, 3, 2]) 10 >>> max_impact_weight(3, [10, 20, 30]) 60 from typing import List def test_max_impact_weight_single_element(): assert max_impact_weight(1, [5]) == 5 def test_max_impact_weight_all_equal(): assert max_impact_weight(3, [4, 4, 4]) == 12 def test_max_impact_weight_sorted_input(): assert max_impact_weight(4, [1, 3, 2, 4]) == 10 def test_max_impact_weight_reverse_sorted_input(): assert max_impact_weight(4, [4, 3, 2, 1]) == 10 def test_max_impact_weight_mixed_weights(): assert max_impact_weight(5, [8, 1, 7, 4, 5]) == 25 def test_max_impact_weight_large_numbers(): assert max_impact_weight(3, [1000, 200, 3000]) == 4200","solution":"def max_impact_weight(n, weights): Returns the maximum impact weight that can be achieved by rearranging the sequence of dominoes. Sorts the list of weights and returns the sum. return sum(sorted(weights))"},{"question":"from typing import List from collections import Counter def longest_palindrome_length(s: str) -> int: Returns the length of the longest possible palindrome that can be constructed using the characters from the set. >>> longest_palindrome_length(\\"abccccdd\\") 7 >>> longest_palindrome_length(\\"a\\") 1 # Unit Test from solution import longest_palindrome_length def test_longest_palindrome_example(): assert longest_palindrome_length(\\"abccccdd\\") == 7 def test_longest_palindrome_single_char(): assert longest_palindrome_length(\\"a\\") == 1 def test_longest_palindrome_all_even_counts(): assert longest_palindrome_length(\\"aabb\\") == 4 def test_longest_palindrome_all_odd_counts(): assert longest_palindrome_length(\\"abc\\") == 1 def test_longest_palindrome_mixed_even_odd(): assert longest_palindrome_length(\\"aabbccddde\\") == 9 def test_longest_palindrome_no_chars(): assert longest_palindrome_length(\\"\\") == 0","solution":"from collections import Counter def longest_palindrome_length(s): Returns the length of the longest palindrome that can be constructed using the characters from the set. char_count = Counter(s) length = 0 odd_found = False for count in char_count.values(): if count % 2 == 0: length += count else: length += count - 1 odd_found = True if odd_found: length += 1 return length"},{"question":"def min_deletions_to_palindrome(s: str) -> int: Returns the minimum number of deletions required to make the string a palindrome. >>> min_deletions_to_palindrome(\\"abab\\") 1 >>> min_deletions_to_palindrome(\\"abb\\") 1 >>> min_deletions_to_palindrome(\\"baab\\") 0 >>> min_deletions_to_palindrome(\\"aaaa\\") 0 >>> min_deletions_to_palindrome(\\"a\\") 0 >>> min_deletions_to_palindrome(\\"b\\") 0 >>> min_deletions_to_palindrome(\\"ab\\") 1 >>> min_deletions_to_palindrome(\\"aaabbb\\") 3","solution":"def min_deletions_to_palindrome(s): Returns the minimum number of deletions required to make the string a palindrome. # Initialize a variable to store the length of the longest palindromic subsequence n = len(s) dp = [[0] * n for _ in range(n)] # Strings of length 1 are palindromic for i in range(n): dp[i][i] = 1 # Build the table for length in range(2, n + 1): for i in range(n + 1 - length): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) # The result is the total length minus the length of the longest palindromic subsequence return n - dp[0][n - 1]"},{"question":"def min_length_after_removal(t: int, test_cases: List[str]) -> List[int]: You are given a string consisting of characters 'a' and 'b' only. You are allowed to perform at most one move where you can remove an arbitrary contiguous substring consisting of 'a's from the string. Afterward, you concatenate the remaining parts of the string. Your task is to find the minimum possible length of the string after performing this operation at most once. >>> min_length_after_removal(3, ['ab', 'aaa', 'aabab']) [1, 0, 2] >>> min_length_after_removal(1, ['bbbb']) [4]","solution":"def min_length_after_removal(t, test_cases): results = [] for s in test_cases: if 'a' not in s: results.append(len(s)) else: count_of_b = s.count('b') results.append(count_of_b) return results"},{"question":"from typing import List def perform_operations(s: str, operations: List[str]) -> List[str]: Performs given operations on the string and returns the result of each query operation. :param s: Initial string :param operations: List of operations to perform :return: List of results for each query operation >>> perform_operations(\\"hello\\", [\\"replace l x\\", \\"query\\", \\"replace e i\\", \\"query\\", \\"reverse\\", \\"query\\"]) [\\"hexxo\\", \\"hixxo\\", \\"oxxih\\"] >>> perform_operations(\\"aaaa\\", [\\"replace a b\\", \\"query\\"]) [\\"bbbb\\"] >>> perform_operations(\\"abcd\\", [\\"reverse\\", \\"query\\"]) [\\"dcba\\"] >>> perform_operations(\\"test\\", [\\"query\\", \\"reverse\\", \\"query\\", \\"replace t p\\", \\"query\\"]) [\\"test\\", \\"tset\\", \\"psep\\"] >>> perform_operations(\\"sample\\", []) [] >>> perform_operations(\\"queries\\", [\\"query\\", \\"query\\"]) [\\"queries\\", \\"queries\\"]","solution":"def perform_operations(s, operations): Performs given operations on the string and returns the result of each query operation. :param s: Initial string :param operations: List of operations to perform :return: List of results for each query operation results = [] for operation in operations: if operation.startswith(\\"replace\\"): _, old, new = operation.split() s = s.replace(old, new) elif operation == \\"reverse\\": s = s[::-1] elif operation == \\"query\\": results.append(s) return results"},{"question":"def calculate_reward_points(spent: int) -> int: Calculate the total reward points earned based on the total amount spent in a month. >>> calculate_reward_points(60) == 65 >>> calculate_reward_points(120) == 165 >>> calculate_reward_points(45) == 45 >>> calculate_reward_points(100) == 125 >>> calculate_reward_points(150) == 225 >>> calculate_reward_points(0) == 0 >>> calculate_reward_points(75) == 87.5 >>> calculate_reward_points(101) == 127 >>> calculate_reward_points(99) == 123.5 >>> calculate_reward_points(200) == 325","solution":"def calculate_reward_points(spent): if spent <= 50: return spent elif spent <= 100: return 50 + (spent - 50) * 1.5 else: return 50 + 50 * 1.5 + (spent - 100) * 2 def main(): T = int(input().strip()) for _ in range(T): S = int(input().strip()) print(int(calculate_reward_points(S))) if __name__ == \\"__main__\\": main()"},{"question":"def max_water_flow(n, e, edges, s, t): Calculates the maximum amount of water that can be transported from city S to city T in the network. >>> simulate_game('''4 5 1 2 100 1 3 100 2 3 1 2 4 100 3 4 100 1 4''') 200 >>> simulate_game('''4 2 1 2 100 3 4 100 1 4''') 0 >>> simulate_game('''3 2 1 2 10 2 3 5 1 3''') 5 >>> simulate_game('''4 4 1 2 10 1 3 10 2 4 10 3 4 10 1 4''') 20 >>> simulate_game('''2 1 1 2 1000000 1 2''') 1000000 pass def simulate_game(input_str): input_lines = input_str.strip().split('n') n, e = map(int, input_lines[0].split()) edges = [tuple(map(int, line.split())) for line in input_lines[1:e+1]] s, t = map(int, input_lines[e+1].split()) return max_water_flow(n, e, edges, s, t) def test_sample_input(): input_str = '''4 5 1 2 100 1 3 100 2 3 1 2 4 100 3 4 100 1 4''' assert simulate_game(input_str) == 200 def test_no_flow(): input_str = '''4 2 1 2 100 3 4 100 1 4''' assert simulate_game(input_str) == 0 def test_single_path(): input_str = '''3 2 1 2 10 2 3 5 1 3''' assert simulate_game(input_str) == 5 def test_multiple_paths(): input_str = '''4 4 1 2 10 1 3 10 2 4 10 3 4 10 1 4''' assert simulate_game(input_str) == 20 def test_large_capacity(): input_str = '''2 1 1 2 1000000 1 2''' assert simulate_game(input_str) == 1000000","solution":"from collections import deque, defaultdict class MaxFlow: def __init__(self, n): self.n = n self.capacity = defaultdict(lambda: defaultdict(int)) self.flow = defaultdict(lambda: defaultdict(int)) def add_edge(self, u, v, c): self.capacity[u][v] += c def bfs(self, source, sink, parent): visited = [False] * (self.n + 1) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for v in self.capacity[u]: if not visited[v] and self.capacity[u][v] - self.flow[u][v] > 0: queue.append(v) parent[v] = u visited[v] = True if v == sink: return True return False def edmonds_karp(self, source, sink): parent = [-1] * (self.n + 1) max_flow = 0 while self.bfs(source, sink, parent): path_flow = float('Inf') s = sink while s != source: path_flow = min(path_flow, self.capacity[parent[s]][s] - self.flow[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] self.flow[u][v] += path_flow self.flow[v][u] -= path_flow v = parent[v] max_flow += path_flow return max_flow def max_water_flow(n, e, edges, s, t): max_flow_instance = MaxFlow(n) for u, v, c in edges: max_flow_instance.add_edge(u, v, c) return max_flow_instance.edmonds_karp(s, t) # Function to read from inputs and invoke the max_water_flow function def simulate_game(input_str): input_lines = input_str.strip().split('n') n, e = map(int, input_lines[0].split()) edges = [tuple(map(int, line.split())) for line in input_lines[1:e+1]] s, t = map(int, input_lines[e+1].split()) return max_water_flow(n, e, edges, s, t) # Test example provided in the question example_input = '''4 5 1 2 100 1 3 100 2 3 1 2 4 100 3 4 100 1 4''' print(simulate_game(example_input)) # Expected output: 200"},{"question":"def wiggleSort(nums): Reorder the array such that every element at index \`i\` is greater than the element at index \`i-1\` and less than the element at index \`i+1\`, if such neighbors exist. Parameters: nums (List[int]): The array of integers to be reordered. Returns: None: Reorders the array in-place. Examples: >>> nums = [1, 5, 1, 1, 6] >>> wiggleSort(nums) >>> all(nums[i] < nums[i + 1] if i % 2 == 0 else nums[i] > nums[i + 1] for i in range(len(nums) - 1)) True >>> nums = [1, 3, 2, 2, 3, 1] >>> wiggleSort(nums) >>> all(nums[i] < nums[i + 1] if i % 2 == 0 else nums[i] > nums[i + 1] for i in range(len(nums) - 1)) True","solution":"def wiggleSort(nums): Rearranges the elements in nums such that every element at index \`i\` is greater than the element at index \`i-1\` and less than the element at index \`i+1\` if such neighbors exist. nums.sort() mid = (len(nums) + 1) // 2 # Create two halves, reverse the second half left, right = nums[:mid], nums[mid:] nums[::2], nums[1::2] = left[::-1], right[::-1]"},{"question":"def max_candies(n, k, candies): Determines the maximum number of candies the wizard can collect without exceeding capacity k. Args: n (int): The number of houses. k (int): The capacity of the magic bag. candies (list of int): List of candies each house produces. Returns: int: The maximum number of candies collected without exceeding capacity k. >>> max_candies(5, 10, [1, 2, 3, 4, 5]) 10 >>> max_candies(4, 7, [4, 3, 2, 1]) 7 >>> max_candies(3, 6, [1, 2, 3]) 6 >>> max_candies(4, 5, [2, 2, 2, 2]) 4 >>> max_candies(100, 1000, [10]*100) 1000 >>> max_candies(1, 5, [3]) 3 >>> max_candies(4, 5, [0, 0, 0, 0]) 0 >>> max_candies(4, 5, [1, 1, 1, 10]) 3","solution":"def max_candies(n, k, candies): Determines the maximum number of candies the wizard can collect without exceeding capacity k. Args: n (int): The number of houses. k (int): The capacity of the magic bag. candies (list of int): List of candies each house produces. Returns: int: The maximum number of candies collected without exceeding capacity k. max_candies_collected = 0 # Check starting from the first house current_candies = 0 for candy in candies: if current_candies + candy > k: break current_candies += candy max_candies_collected = max(max_candies_collected, current_candies) # Check starting from the last house current_candies = 0 for candy in reversed(candies): if current_candies + candy > k: break current_candies += candy max_candies_collected = max(max_candies_collected, current_candies) return max_candies_collected"},{"question":"def count_color_regions(h: int, w: int, grid: List[List[int]]) -> int: Identify and count distinct color regions in an image represented by a 2D grid. Two cells are in the same color region if they share an edge and have the same color. >>> count_color_regions(4, 5, [[1, 1, 2, 2, 3], [1, 1, 2, 3, 3], [4, 4, 4, 3, 3], [4, 3, 4, 4, 4]]) 5 >>> count_color_regions(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 9 >>> count_color_regions(2, 2, [[1, 1], [1, 1]]) 1","solution":"def count_color_regions(h, w, grid): def dfs(x, y, color): if x < 0 or x >= h or y < 0 or y >= w or grid[x][y] != color: return grid[x][y] = -1 # Mark as visited dfs(x + 1, y, color) dfs(x - 1, y, color) dfs(x, y + 1, color) dfs(x, y - 1, color) regions = 0 for i in range(h): for j in range(w): if grid[i][j] != -1: # Unvisited cell regions += 1 dfs(i, j, grid[i][j]) return regions"},{"question":"def tree_height(root: tuple) -> int: Computes the height of the binary tree. The height is the number of edges from the root to the deepest leaf. An empty tree has a height of -1, and a tree with a single node has a height of 0. >>> tree_height((3, (9, None, None), (20, (15, None, None), (7, None, None)))) == 2 True >>> tree_height((1, (2, (4, None, None), (5, None, None)), (3, None, None))) == 2 True >>> tree_height((1, None, None)) == 0 True >>> tree_height(None) == -1 True >>> tree_height((1, (2, (3, (4, None, None), None), None), None)) == 3 True >>> tree_height((1, None, (2, None, (3, None, (4, None, None))))) == 3 True >>> tree_height((1, (2, (4, None, None), None), None)) == 2 True >>> tree_height((1, (2, (4, None, None), (5, None, None)), (3, (6, None, None), (7, None, None)))) == 2 True","solution":"def tree_height(root: tuple) -> int: Computes the height of the binary tree. The height is the number of edges from the root to the deepest leaf. Parameters: root (tuple): A root node of the binary tree represented as a nested tuple. Returns: int: The height of the binary tree. if root is None: return -1 else: value, left, right = root left_height = tree_height(left) if left else -1 right_height = tree_height(right) if right else -1 return 1 + max(left_height, right_height)"},{"question":"def max_consecutive_cows(n: int, d: int, heights: List[int]) -> int: Returns the maximum number of consecutive cows that can be selected such that the difference in height between the tallest and the shortest cow in the selected group is less than or equal to d. :param n: Number of cows :param d: Maximum allowable height difference :param heights: List of cow heights :return: Maximum number of consecutive cows satisfying the condition >>> max_consecutive_cows(5, 3, [1, 4, 6, 8, 2]) == 2 >>> max_consecutive_cows(8, 4, [3, 5, 8, 6, 7, 2, 4, 1]) == 4 >>> max_consecutive_cows(6, 0, [7, 7, 7, 7, 7, 7]) == 6 >>> max_consecutive_cows(6, 10, [1, 2, 3, 6, 9, 12]) == 5 >>> max_consecutive_cows(4, 0, [5, 5, 5, 5]) == 4 >>> max_consecutive_cows(1, 3, [1]) == 1 >>> max_consecutive_cows(5, 0, [1, 2, 3, 4, 5]) == 1 >>> max_consecutive_cows(8, 6, [1, 2, 4, 6, 8, 10, 12, 14]) == 4","solution":"def max_consecutive_cows(n, d, heights): Returns the maximum number of consecutive cows that can be selected such that the difference in height between the tallest and the shortest cow in the selected group is less than or equal to d. :param n: Number of cows :param d: Maximum allowable height difference :param heights: List of cow heights :return: Maximum number of consecutive cows satisfying the condition # Initialize variables max_len = 0 l = 0 # left pointer of the sliding window for r in range(n): # right pointer of the sliding window window = heights[l:r+1] while max(window) - min(window) > d: l += 1 window = heights[l:r+1] max_len = max(max_len, r - l + 1) return max_len"},{"question":"def can_walk_across_buildings(n: int, x: int, heights: List[int]) -> str: Determine if it's possible to walk from the leftmost building to the rightmost building. Parameters: n (int): Number of buildings. x (int): Maximum step value. heights (list): List of heights of buildings. Returns: str: \\"YES\\" if possible to walk across buildings, \\"NO\\" otherwise. >>> can_walk_across_buildings(5, 3, [1, 2, 3, 4, 5]) 'YES' >>> can_walk_across_buildings(5, 1, [1, 3, 2, 3, 1]) 'NO' >>> can_walk_across_buildings(4, 2, [3, 3, 3, 3]) 'YES' >>> can_walk_across_buildings(1, 5, [1]) 'YES' >>> can_walk_across_buildings(3, 1, [1, 5, 10]) 'NO' >>> can_walk_across_buildings(4, 100000, [0, 0, 0, 100000]) 'YES'","solution":"def can_walk_across_buildings(n, x, heights): Determine if it's possible to walk from the leftmost building to the rightmost building. Parameters: n (int): Number of buildings. x (int): Maximum step value. heights (list): List of heights of buildings. Returns: str: \\"YES\\" if possible to walk across buildings, \\"NO\\" otherwise. for i in range(n - 1): if heights[i + 1] > heights[i] + x: return \\"NO\\" return \\"YES\\""},{"question":"def process_operations(s: str) -> int: Processes the input sequence of operations and returns the total sum of integers in the list. A -> appends 1 B -> appends 2 C -> appends 3 Any other character is ignored. Args: s (str): Input string with operations. Returns: int: Total sum of integers in the list after processing all operations. >>> process_operations(\\"AAABC\\") 8 >>> process_operations(\\"xyzAzyBzyC\\") 6","solution":"def process_operations(s): Processes the input sequence of operations and returns the total sum of integers in the list. A -> appends 1 B -> appends 2 C -> appends 3 Any other character is ignored. Args: s (str): Input string with operations. Returns: int: Total sum of integers in the list after processing all operations. operation_map = {'A': 1, 'B': 2, 'C': 3} total_sum = 0 for char in s: if char in operation_map: total_sum += operation_map[char] return total_sum"},{"question":"def decode_message(shift, message): Decodes the given message by shifting each letter in the opposite direction by the given shift value. Parameters: shift (int): The shift value. message (str): The encoded message. Returns: str: The decoded message. >>> decode_message(3, 'khoor') 'hello' >>> decode_message(2, 'jgnnq') 'hello' >>> decode_message(5, 'mjqqt') 'hello' >>> decode_message(1, 'zab') 'yza' ... def process_test_cases(T, test_cases): Processes multiple test cases and returns the decoded messages. Parameters: T (int): The number of test cases. test_cases (list): A list of tuples where each tuple contains the shift value and the encoded message. Returns: list: A list of decoded messages. >>> process_test_cases(3, [(3, 'khoor'), (2, 'jgnnq'), (5, 'mjqqt')]) ['hello', 'hello', 'hello'] >>> process_test_cases(1, [(1, 'zab')]) ['yza'] ...","solution":"def decode_message(shift, message): Decodes the given message by shifting each letter in the opposite direction by the given shift value. Parameters: shift (int): The shift value. message (str): The encoded message. Returns: str: The decoded message. decoded_message = [] for char in message: # Finding the original character by shifting back by 'shift' places original_char = chr((ord(char) - ord('a') - shift) % 26 + ord('a')) decoded_message.append(original_char) return ''.join(decoded_message) def process_test_cases(T, test_cases): Processes multiple test cases and returns the decoded messages. Parameters: T (int): The number of test cases. test_cases (list): A list of tuples where each tuple contains the shift value and the encoded message. Returns: list: A list of decoded messages. results = [] for shift, message in test_cases: results.append(decode_message(shift, message)) return results"},{"question":"def process_queries(n, initial_elements, q, queries): Processes a list of queries on an initial list of integers. Supports adding integers and querying sums over a range. :param n: Initial number of elements :param initial_elements: List of integers :param q: Number of queries :param queries: List of queries in the form of strings :return: List of results for \\"QUERY\\" operations Example: >>> process_queries(5, [1, 2, 3, 4, 5], 4, [\\"QUERY 1 3\\", \\"ADD 6\\", \\"QUERY 0 5\\", \\"ADD -1\\"]) [9, 21] >>> process_queries(3, [10, 20, 30], 3, [\\"ADD 40\\", \\"QUERY 0 3\\", \\"QUERY 1 2\\"]) [100, 50]","solution":"def process_queries(n, initial_elements, q, queries): Processes a list of queries on an initial list of integers. Supports adding integers and querying sums over a range. :param n: Initial number of elements :param initial_elements: List of integers :param q: Number of queries :param queries: List of queries in the form of strings :return: List of results for \\"QUERY\\" operations elements = initial_elements results = [] for query in queries: parts = query.split() operation = parts[0] if operation == \\"ADD\\": x = int(parts[1]) elements.append(x) elif operation == \\"QUERY\\": L = int(parts[1]) R = int(parts[2]) results.append(sum(elements[L:R+1])) return results # Example use case for function if __name__ == \\"__main__\\": n = 5 initial_elements = [1, 2, 3, 4, 5] q = 4 queries = [ \\"QUERY 1 3\\", \\"ADD 6\\", \\"QUERY 0 5\\", \\"ADD -1\\" ] results = process_queries(n, initial_elements, q, queries) for result in results: print(result)"},{"question":"def edit_distance(str1: str, str2: str) -> int: Calculates the edit distance between two strings. The edit distance between two strings is the minimum number of operations required to transform one string into the other. The allowed operations are: 1. Insert a character. 2. Remove a character. 3. Replace a character. Parameters: str1 (str): The first string. str2 (str): The second string. Returns: int: The edit distance between the two strings. Examples: >>> edit_distance(\\"kitten\\", \\"sitting\\") 3 >>> edit_distance(\\"flaw\\", \\"lawn\\") 2 def test_edit_distance_example1(): assert edit_distance(\\"kitten\\", \\"sitting\\") == 3 def test_edit_distance_example2(): assert edit_distance(\\"flaw\\", \\"lawn\\") == 2 def test_edit_distance_same_strings(): assert edit_distance(\\"abc\\", \\"abc\\") == 0 def test_edit_distance_one_empty_string(): assert edit_distance(\\"\\", \\"abc\\") == 3 assert edit_distance(\\"abc\\", \\"\\") == 3 def test_edit_distance_insertion(): assert edit_distance(\\"abc\\", \\"abcd\\") == 1 def test_edit_distance_deletion(): assert edit_distance(\\"abcd\\", \\"abc\\") == 1 def test_edit_distance_replacement(): assert edit_distance(\\"abc\\", \\"xbc\\") == 1 def test_edit_distance_complex_case(): assert edit_distance(\\"saturday\\", \\"sunday\\") == 3","solution":"def edit_distance(str1: str, str2: str) -> int: Calculates the edit distance between two strings using dynamic programming. :param str1: First string. :param str2: Second string. :return: Minimum number of operations required to transform str1 into str2. m, n = len(str1), len(str2) # Create a DP table to store results of sub-problems dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize dp table. for i in range(m + 1): for j in range(n + 1): # If first string is empty, only option is to insert all characters of str2 if i == 0: dp[i][j] = j # Min. operations = j # If second string is empty, only option is to remove all characters of str1 elif j == 0: dp[i][j] = i # Min. operations = i # If last characters are the same, ignore last character and recur for remaining substring elif str1[i-1] == str2[j-1]: dp[i][j] = dp[i-1][j-1] # If the last character is different, consider all possibilities and find minimum else: dp[i][j] = 1 + min(dp[i-1][j], # Remove dp[i][j-1], # Insert dp[i-1][j-1]) # Replace return dp[m][n]"},{"question":"def max_car_distance(n: int, m: List[int]) -> int: Returns the maximum distance any toy car can move from its initial position. Parameters: n (int): The number of toy cars. m (list of int): A list where mi is the maximum number of positions the i-th toy car can be moved. Returns: int: The maximum distance any toy car can move. Examples: >>> max_car_distance(4, [2, 3, 1, 4]) 4 >>> max_car_distance(5, [5, 5, 5, 5, 5]) 5 >>> max_car_distance(3, [1, 2, 3]) 3 >>> max_car_distance(6, [6, 2, 8, 3, 1, 4]) 8","solution":"def max_car_distance(n, m): Returns the maximum distance any toy car can move from its initial position. Parameters: n (int): The number of toy cars. m (list of int): A list where mi is the maximum number of positions the i-th toy car can be moved. Returns: int: The maximum distance any toy car can move. return max(m)"},{"question":"def smallest_string(s: str) -> str: Returns the lexicographically smallest string possible after performing any number of reversal and removal operations on the input string s. >>> smallest_string(\\"dcba\\") \\"a\\" >>> smallest_string(\\"xyzabc\\") \\"a\\" >>> smallest_string(\\"a\\") \\"a\\" >>> smallest_string(\\"abcd\\") \\"a\\" >>> smallest_string(\\"bbbb\\") \\"b\\" >>> smallest_string(\\"jklmnopqrstu\\") \\"j\\" >>> smallest_string(\\"z\\"*(10**5 - 1) + \\"a\\") \\"a\\"","solution":"def smallest_string(s: str) -> str: This function returns the lexicographically smallest string possible after performing any number of reversal and removal operations on the input string s. Since we can remove any characters, the smallest string is the smallest character in the original string after removing other characters. return min(s)"},{"question":"def largest_square_with_artifacts(n: int, m: int, grid: List[List[int]]) -> int: Given grid size n and m and the number of artifacts in each dig site, finds the size of the largest square subgrid where every site contains at least one artifact. >>> largest_square_with_artifacts(4, 5, [ ... [1, 0, 1, 0, 0], ... [1, 1, 1, 1, 0], ... [1, 1, 1, 1, 1], ... [0, 1, 1, 1, 1] ... ]) 3 >>> largest_square_with_artifacts(3, 3, [ ... [0, 0, 0], ... [0, 1, 1], ... [0, 1, 1] ... ]) 2 def test_largest_square_with_artifacts_1(): grid = [ [1, 0, 1, 0, 0], [1, 1, 1, 1, 0], [1, 1, 1, 1, 1], [0, 1, 1, 1, 1] ] assert largest_square_with_artifacts(4, 5, grid) == 3 def test_largest_square_with_artifacts_2(): grid = [ [0, 0, 0], [0, 1, 1], [0, 1, 1] ] assert largest_square_with_artifacts(3, 3, grid) == 2 def test_largest_square_with_artifacts_single_element(): grid = [ [1] ] assert largest_square_with_artifacts(1, 1, grid) == 1 def test_largest_square_with_artifacts_with_no_artifact(): grid = [ [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0] ] assert largest_square_with_artifacts(4, 4, grid) == 0 def test_largest_square_with_artifacts_entire_grid(): grid = [ [1, 1], [1, 1] ] assert largest_square_with_artifacts(2, 2, grid) == 2","solution":"def largest_square_with_artifacts(n, m, grid): # Initialize DP table with 0 dp = [[0] * m for _ in range(n)] max_side = 0 for i in range(n): for j in range(m): if grid[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"def max_min_product(N: int, A: list[int]) -> int: Returns the product of the maximum element and minimum element in the sequence A. Parameters: N (int): The number of elements in the sequence A. A (list of int): The sequence of integers. Returns: int: Product of the maximum and minimum elements in the sequence. >>> max_min_product(5, [1, 3, 4, 2, 5]) == 5 >>> max_min_product(6, [-1, 2, -3, 4, -5, 6]) == -30 >>> max_min_product(4, [-1, -2, -3, -4]) == 4","solution":"def max_min_product(N, A): Returns the product of the maximum element and minimum element in the sequence A. Parameters: N (int): The number of elements in the sequence A. A (list of int): The sequence of integers. Returns: int: Product of the maximum and minimum elements in the sequence. if N == 0 or not A: return 0 # If the sequence is empty, return 0 as no valid product can be obtained. max_elem = max(A) min_elem = min(A) return max_elem * min_elem"},{"question":"def knapsack(N: int, W: int, items: List[Tuple[int, int]]) -> int: Returns the maximum value that can be obtained without exceeding the total weight W. >>> knapsack(3, 50, [(10, 60), (20, 100), (30, 120)]) 220 >>> knapsack(4, 10, [(5, 50), (4, 40), (6, 30), (3, 20)]) 90 pass","solution":"def knapsack(N, W, items): Returns the maximum value that can be obtained without exceeding the total weight W. Parameters: N (int): Number of items W (int): Maximum weight capacity of the knapsack items (list of tuples): Each tuple contains weight and value of an item Returns: int: Maximum value that can be obtained # Initialize a 2D DP array dp = [[0] * (W + 1) for _ in range(N + 1)] for i in range(1, N + 1): weight, value = items[i - 1] for w in range(W + 1): if weight <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weight] + value) else: dp[i][w] = dp[i - 1][w] return dp[N][W] # Reading input from Standard Input (stdin) def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) W = int(data[1]) items = [] for i in range(N): weight = int(data[2 + i * 2]) value = int(data[3 + i * 2]) items.append((weight, value)) print(knapsack(N, W, items)) if __name__ == \\"__main__\\": main()"},{"question":"def process_queries(grid, queries): Process the grid based on given queries and return the results of max value queries. :param grid: List of lists representing the initial grid :param queries: List of queries, where each query is a list :return: List of results for max value queries >>> grid = [ >>> [1, 2, 3, 4, 5], >>> [5, 4, 3, 2, 1], >>> [1, 1, 1, 1, 1], >>> [2, 2, 2, 2, 2], >>> [5, 5, 5, 5, 5] >>> ] >>> queries = [ >>> [1, 1, 1, 3, 3], >>> [2, 1, 1, 6], >>> [1, 1, 1, 3, 3], >>> [1, 4, 4, 5, 5], >>> [1, 1, 1, 5, 5] >>> ] >>> process_queries(grid, queries) [5, 6, 5, 6]","solution":"def process_queries(grid, queries): Process the grid based on given queries and return the results of max value queries. :param grid: List of lists representing the initial grid :param queries: List of queries, where each query is a list :return: List of results for max value queries results = [] n = len(grid) m = len(grid[0]) if n > 0 else 0 for query in queries: if query[0] == 1: # max value query r1, c1, r2, c2 = query[1:] max_val = float('-inf') for i in range(r1 - 1, r2): for j in range(c1 - 1, c2): max_val = max(max_val, grid[i][j]) results.append(max_val) elif query[0] == 2: # update value query r, c, v = query[1:] grid[r - 1][c - 1] = v return results"},{"question":"def highest_digit_sum_count(n: int, badge_numbers: List[int]) -> Tuple[int, int]: This function takes in the number of participants and their badge numbers, then returns the highest digit sum and the number of participants having this highest sum. >>> highest_digit_sum_count(5, [123, 456, 789, 88, 99]) (24, 1) >>> highest_digit_sum_count(3, [12, 34, 56]) (11, 1) >>> highest_digit_sum_count(4, [11, 11, 11, 11]) (2, 4)","solution":"def highest_digit_sum_count(n, badge_numbers): This function takes in the number of participants and their badge numbers, then returns the highest digit sum and the number of participants having this highest sum. def digit_sum(num): return sum(int(digit) for digit in str(num)) max_sum = 0 count = 0 for number in badge_numbers: d_sum = digit_sum(number) if d_sum > max_sum: max_sum = d_sum count = 1 elif d_sum == max_sum: count += 1 return max_sum, count"},{"question":"def process_sales_data(n: int, datasets: List[List[str]]) -> List[str]: Processes the sales data to determine total items sold and hourly average for each day. Args: n : int : Number of datasets datasets : List[List[str]] : List of datasets, where each dataset is a list of strings representing hourly sales data Returns: List[str] : List of results, each formatted as required def parse_input(input_lines: List[str]) -> Tuple[int, List[List[str]]]: Parses the input lines to extract the number of datasets and the sales data. Args: input_lines : List[str] : List of input lines Returns: Tuple[int, List[List[str]]] : Number of datasets and the sales data from solution import process_sales_data, parse_input def test_example_input(): input_lines = [ \\"2\\", \\"\\", \\"10\\", \\"15\\", \\"13\\", \\"-\\", \\"18\\", \\"20\\", \\"-\\", \\"11\\", \\"\\", \\"12\\", \\"18\\", \\"-\\", \\"-\\", \\"25\\", \\"30\\", \\"16\\", \\"10\\" ] n, datasets = parse_input(input_lines) result = process_sales_data(n, datasets) expected = [ \\"Day 1:nTotal items sold: 87nHourly average: 14.50\\", \\"Day 2:nTotal items sold: 111nHourly average: 18.50\\" ] assert result == expected def test_all_dashes(): input_lines = [ \\"1\\", \\"\\", \\"-\\", \\"-\\", \\"-\\", \\"-\\", \\"-\\", \\"-\\", \\"-\\", \\"-\\" ] n, datasets = parse_input(input_lines) result = process_sales_data(n, datasets) expected = [ \\"Day 1:nTotal items sold: 0nHourly average: 0.00\\" ] assert result == expected def test_mixed_data(): input_lines = [ \\"1\\", \\"\\", \\"5\\", \\"-\\", \\"10\\", \\"-\\", \\"-\\", \\"15\\", \\"10\\", \\"-\\" ] n, datasets = parse_input(input_lines) result = process_sales_data(n, datasets) expected = [ \\"Day 1:nTotal items sold: 40nHourly average: 10.00\\" ] assert result == expected def test_no_dashes(): input_lines = [ \\"1\\", \\"\\", \\"1\\", \\"2\\", \\"3\\", \\"4\\", \\"5\\", \\"6\\", \\"7\\", \\"8\\" ] n, datasets = parse_input(input_lines) result = process_sales_data(n, datasets) expected = [ \\"Day 1:nTotal items sold: 36nHourly average: 4.50\\" ] assert result == expected def test_single_day_partial_data(): input_lines = [ \\"1\\", \\"\\", \\"1\\", \\"2\\", \\"-\\", \\"-\\", \\"-\\", \\"-\\", \\"3\\", \\"4\\" ] n, datasets = parse_input(input_lines) result = process_sales_data(n, datasets) expected = [ \\"Day 1:nTotal items sold: 10nHourly average: 2.50\\" ] assert result == expected","solution":"def process_sales_data(n, datasets): results = [] for day_index, data in enumerate(datasets): total_items_sold = 0 num_valid_hours = 0 for hour_data in data: if hour_data != '-': total_items_sold += int(hour_data) num_valid_hours += 1 hourly_average = total_items_sold / num_valid_hours if num_valid_hours > 0 else 0.0 results.append(f\\"Day {day_index + 1}:nTotal items sold: {total_items_sold}nHourly average: {hourly_average:.2f}\\") return results # Helper function to parse the input def parse_input(input_lines): n = int(input_lines[0]) datasets = [] data = [] for line in input_lines[1:]: line = line.strip() if not line: if data: datasets.append(data) data = [] else: data.append(line) if data: datasets.append(data) return n, datasets"},{"question":"def can_form_palindrome(n: int, s: str) -> str: Determine if it's possible to rearrange the letters of s to form a palindrome. :param n: Length of the string :param s: The string to check :return: \\"YES\\" if it's possible to rearrange the letters to form a palindrome, otherwise \\"NO\\" # Your code here # Unit tests def test_palindrome_possible_odd_case(): assert can_form_palindrome(7, \\"racecar\\") == \\"YES\\" def test_palindrome_possible_even_case(): assert can_form_palindrome(4, \\"aabb\\") == \\"YES\\" def test_palindrome_not_possible_case(): assert can_form_palindrome(5, \\"abcde\\") == \\"NO\\" def test_single_character(): assert can_form_palindrome(1, \\"a\\") == \\"YES\\" def test_long_non_palindrome(): assert can_form_palindrome(6, \\"abccba\\") == \\"YES\\" def test_combination(): assert can_form_palindrome(6, \\"abccbx\\") == \\"NO\\" def test_all_same(): assert can_form_palindrome(3, \\"aaa\\") == \\"YES\\" def test_empty_string(): assert can_form_palindrome(0, \\"\\") == \\"YES\\" def test_odd_count_characters(): assert can_form_palindrome(7, \\"aaabbbb\\") == \\"YES\\"","solution":"def can_form_palindrome(n, s): Determine if it's possible to rearrange the letters of s to form a palindrome. :param n: Length of the string :param s: The string to check :return: \\"YES\\" if it's possible to rearrange the letters to form a palindrome, otherwise \\"NO\\" from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if it has at most one character with an odd count if odd_count > 1: return \\"NO\\" else: return \\"YES\\""},{"question":"def nth_number_in_sequence(P, Q, N): Returns the Nth number in the sequence generated with the initial numbers P and Q. >>> nth_number_in_sequence(1, 1, 3) == 2 >>> nth_number_in_sequence(2, 3, 4) == 178 pass def process_input(input_data): Processes the input data and returns a list of results for each test case. >>> process_input(\\"2n1 1 3n2 3 4\\") == [2, 178] >>> process_input(\\"1n2 2 3\\") == [8] pass","solution":"def nth_number_in_sequence(P, Q, N): Returns the Nth number in the sequence generated with the initial numbers P and Q. if N == 1: return P elif N == 2: return Q sequence = [P, Q] for i in range(2, N): next_number = sequence[-1] ** 2 + sequence[-2] ** 2 sequence.append(next_number) return sequence[N-1] def process_input(input_data): output = [] lines = input_data.strip().split('n') T = int(lines[0]) for i in range(1, T + 1): P, Q, N = map(int, lines[i].split()) output.append(nth_number_in_sequence(P, Q, N)) return output"},{"question":"def max_profit(n, prices): Calculate the maximum profit by buying and selling items given that you can buy and sell the items any number of times. You cannot buy more than one item at a time and must sell the item before buying another one. :param n: Number of items (prices) :param prices: List of item prices :return: Maximum profit >>> max_profit(6, [7, 1, 5, 3, 6, 4]) 7 >>> max_profit(5, [1, 2, 3, 4, 5]) 4 >>> max_profit(5, [7, 6, 4, 3, 1]) 0","solution":"def max_profit(n, prices): Calculate the maximum profit by buying and selling items given that you can buy and sell the items any number of times. You cannot buy more than one item at a time and must sell the item before buying another one. :param n: Number of items (prices) :param prices: List of item prices :return: Maximum profit max_profit = 0 for i in range(1, n): if prices[i] > prices[i - 1]: max_profit += prices[i] - prices[i - 1] return max_profit"},{"question":"def can_make_equal(n, m, abacus1, abacus2, k1, k2): Determines if two abacuses can represent the same total value by flipping a limited number of beads. >>> can_make_equal(5, 4, [1, 0, 1, 1, 0], [0, 1, 0, 0], 2, 3) == \\"YES\\" >>> can_make_equal(3, 3, [1, 1, 1], [0, 0, 0], 1, 1) == \\"NO\\" >>> can_make_equal(1, 1, [0], [0], 0, 0) == \\"YES\\" >>> can_make_equal(1, 1, [0], [1], 1, 0) == \\"YES\\" >>> can_make_equal(1, 1, [0], [1], 0, 0) == \\"NO\\" >>> can_make_equal(4, 4, [1, 1, 1, 1], [1, 1, 1, 1], 0, 0) == \\"YES\\" >>> can_make_equal(4, 5, [0, 0, 0, 0], [0, 0, 0, 0, 0], 2, 3) == \\"YES\\"","solution":"def can_make_equal(n, m, abacus1, abacus2, k1, k2): Determines if two abacuses can represent the same total value by flipping a limited number of beads. sum1 = sum(abacus1) sum2 = sum(abacus2) # The difference between the two sums diff = abs(sum1 - sum2) # You are allowed to flip at most k1 beads on abacus1 and k2 beads on abacus2 # The maximum change you can make to the total difference is k1 + k2 if diff <= k1 + k2: return \\"YES\\" else: return \\"NO\\""},{"question":"def grid_path(n: int, m: int, grid_lines: List[str]) -> str: There is a rectangular grid with n rows and m columns. Some cells in this grid contain obstacles, while others are free. You want to find a path from the top-left corner (1,1) to the bottom-right corner (n,m) such that the path avoids obstacles and only moves right or down. Args: n: An integer denoting the number of rows of the grid. m: An integer denoting the number of columns of the grid. grid_lines: A list of strings representing the grid, where each string is a row of the grid with '.' representing a free cell and '#' representing an obstacle. Returns: A string - \\"YESn<path>\\" if a path exists, where <path> is a sequence of 'R' and 'D'. - \\"NO\\" if no path exists. >>> grid_path(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) \\"YESnRRDD\\" >>> grid_path(3, 3, [\\"..#\\", \\".#.\\", \\"...\\"]) \\"YESnDDRR\\" >>> grid_path(2, 2, [\\"\\", \\"..\\"]) \\"NO\\"","solution":"def find_path(n, m, grid): def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == '.' def dfs(x, y): if x == n - 1 and y == m - 1: return True if not is_valid(x, y): return False grid[x][y] = '#' # mark the cell as visited if y + 1 < m and dfs(x, y + 1): # move right path.append('R') return True if x + 1 < n and dfs(x + 1, y): # move down path.append('D') return True return False path = [] if dfs(0, 0): return \\"YESn\\" + ''.join(reversed(path)) else: return \\"NO\\" # Example of how to use the function with input parsing def grid_path(n, m, grid_lines): grid = [list(line) for line in grid_lines] return find_path(n, m, grid)"},{"question":"def max_subarray_sum(arr): Returns the maximum sum of the contiguous subarray for the given array. >>> max_subarray_sum([1, 2, 3, -2, 5]) 9 >>> max_subarray_sum([-1, -2, -3, -4, -5, -6, -7, -8]) -1 pass def process_test_cases(T, test_cases): Processes multiple test cases to find the maximum sum of the contiguous subarray for each test case. >>> process_test_cases(2, [(5, [1, 2, 3, -2, 5]), (8, [-1, -2, -3, -4, -5, -6, -7, -8])]) [9, -1] pass","solution":"def max_subarray_sum(arr): Returns the maximum sum of the contiguous subarray for the given array. max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global def process_test_cases(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] array = test_cases[i][1] results.append(max_subarray_sum(array)) return results"},{"question":"def max_subarray_bitwise_and(n: int, arr: List[int]) -> int: Returns the maximum bitwise AND value of any subarray. >>> max_subarray_bitwise_and(1, [7]) == 7 >>> max_subarray_bitwise_and(4, [4, 8, 10, 3]) == 10 >>> max_subarray_bitwise_and(3, [0, 0, 0]) == 0 >>> max_subarray_bitwise_and(5, [0, 1073741823, 536870912, 268435456, 134217728]) == 1073741823 >>> max_subarray_bitwise_and(6, [2, 3, 6, 8, 10, 1]) == 10 >>> max_subarray_bitwise_and(2, [2, 2]) == 2 pass","solution":"def max_subarray_bitwise_and(n, arr): Returns the maximum bitwise AND value of any subarray. max_value = 0 for num in arr: max_value = max(max_value, num) return max_value"},{"question":"def update_stock(max_storage: int, current_stock: int, shipment: int) -> int: Updates the stock level based on the shipment received, considering the max storage constraint. Arguments: max_storage (int): The maximum storage limit. current_stock (int): The current stock level. shipment (int): The quantity of shipment received. Returns: int: The updated stock level. Examples: >>> update_stock(100, 50, 30) 80 >>> update_stock(50, 45, 10) 50 >>> update_stock(45, 20, 30) 45","solution":"def update_stock(max_storage, current_stock, shipment): Updates the stock level based on the shipment received, considering the max storage constraint. Args: max_storage (int): The maximum storage limit. current_stock (int): The current stock level. shipment (int): The quantity of shipment received. Returns: int: The updated stock level. new_stock = current_stock + shipment if new_stock > max_storage: new_stock = max_storage return new_stock"},{"question":"from typing import List def min_houses_to_deliver(m: int, n: int, houses: List[List[int]]) -> int: Calculate the minimum number of houses you need to deliver mail to if you take the optimal path from the top-left corner to the bottom-right corner in an m x n grid of houses. >>> min_houses_to_deliver(3, 3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_houses_to_deliver(1, 4, [[1, 2, 3, 4]]) 10 >>> min_houses_to_deliver(4, 1, [[1], [2], [3], [4]]) 10 >>> min_houses_to_deliver(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> min_houses_to_deliver(3, 3, [[1000, 1000, 1000], [1000, 1, 1000], [1000, 1, 1000]]) 3002 >>> min_houses_to_deliver(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 21","solution":"from typing import List def min_houses_to_deliver(m: int, n: int, houses: List[List[int]]) -> int: # Create a 2D list for storing the minimum number of houses for each block. dp = [[0] * n for _ in range(m)] # Initialize the starting block dp[0][0] = houses[0][0] # Initialize the edges of the grid for i in range(1, m): dp[i][0] = dp[i-1][0] + houses[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + houses[0][j] # Fill in the rest of the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = houses[i][j] + min(dp[i-1][j], dp[i][j-1]) # The answer will be in the bottom-right corner of the array return dp[m-1][n-1]"},{"question":"def knot_positions(L: int, N: int) -> list: Determine the positions of the knots along the rope. Args: L (int): The total length of the rope. N (int): The number of desired segments. Returns: list: A list of positions of each knot formatted to 2 decimal places. Examples: >>> knot_positions(100, 5) ['20.00', '40.00', '60.00', '80.00'] >>> knot_positions(50, 3) ['16.67', '33.33'] >>> knot_positions(200, 4) ['50.00', '100.00', '150.00'] >>> knot_positions(1, 2) ['0.50'] >>> knot_positions(1000, 100) ['10.00', '20.00', '30.00', ..., '990.00']","solution":"def knot_positions(L, N): Returns the positions of the knots along the rope. Parameters: L (int): The total length of the rope. N (int): Number of desired segments. Returns: positions (list): List of positions of each knot formatted to 2 decimal places. segment_length = L / N positions = [segment_length * i for i in range(1, N)] return [f\\"{pos:.2f}\\" for pos in positions]"},{"question":"def max_non_adjacent_sum(arr): Function to return the maximum sum of non-adjacent elements in an array. :param arr: List[int] - List of integers :return: int - Maximum sum of non-adjacent elements >>> max_non_adjacent_sum([3, 2, 5, 10]) 13 >>> max_non_adjacent_sum([3, 2, 7]) 10 >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) 15 >>> max_non_adjacent_sum([]) 0 >>> max_non_adjacent_sum([5]) 5 >>> max_non_adjacent_sum([4, 1]) 4 >>> max_non_adjacent_sum([-2, -3, -4]) 0 >>> max_non_adjacent_sum([3, 2, -1, 5, -1, 6]) 14 >>> max_non_adjacent_sum([8, 8, 8, 8, 8, 8, 8, 8]) 32","solution":"def max_non_adjacent_sum(arr): Function to return the maximum sum of non-adjacent elements in an array. :param arr: List[int] - List of integers :return: int - Maximum sum of non-adjacent elements if not arr: return 0 incl = 0 excl = 0 for num in arr: # Current max excluding the current num new_excl = max(incl, excl) # Current max including the current num incl = excl + num excl = new_excl return max(incl, excl)"},{"question":"def determine_winner(M, N, grid): Determine who wins the game between Tom and Jerry. Both Tom and Jerry play optimally. Tom starts at (0, 0) and Jerry starts at (M-1, N-1). Tom can move right or down, and Jerry can move left or up. The grid may contain obstacles represented by '#' and empty cells by '.'. >>> determine_winner(3, 3, [\\"...\\", \\".#.\\", \\".#.\\"]) == \\"Tom wins\\" >>> determine_winner(3, 3, [\\"..#\\", \\".#.\\", \\".#.\\"]) == \\"Jerry wins\\"","solution":"from collections import deque def can_tom_win(grid, M, N): directions_tom = [(0, 1), (1, 0)] # right, down for Tom directions_jerry = [(0, -1), (-1, 0)] # left, up for Jerry start_tom = (0, 0) start_jerry = (M-1, N-1) # BFS to find shortest path distance for Tom and Jerry from their starts def bfs(start, directions): queue = deque([start]) visited = {start} distance = {start: 0} while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < M and 0 <= ny < N and (nx, ny) not in visited and grid[nx][ny] == '.': visited.add((nx, ny)) distance[(nx, ny)] = distance[(x, y)] + 1 queue.append((nx, ny)) return distance dist_tom = bfs(start_tom, directions_tom) dist_jerry = bfs(start_jerry, directions_jerry) if (M-1, N-1) in dist_tom and dist_tom[(M-1, N-1)] <= dist_jerry.get((0, 0), float('inf')): return \\"Tom wins\\" return \\"Jerry wins\\" def determine_winner(M, N, grid): return can_tom_win(grid, M, N)"},{"question":"def install_solar_panels(n: int, m: int): Determine a way to install the solar panels such that the given condition is always met. >>> install_solar_panels(3, 2) [ [2, 5], [4, 1], [6, 3] ] >>> install_solar_panels(1, 5) [ [1, 3, 5, 2, 4] ] from solution import install_solar_panels def test_single_element(): result = install_solar_panels(1, 1) expected = [[1]] assert result == expected def test_three_floors_two_windows(): result = install_solar_panels(3, 2) expected = [ [1, 2], [4, 3], [5, 6] ] assert result == expected def test_single_floor_five_windows(): result = install_solar_panels(1, 5) expected = [[1, 2, 3, 4, 5]] assert result == expected def test_edge_case_two_floors_one_window(): result = install_solar_panels(2, 1) expected = [ [1], [2] ] assert result == expected","solution":"def install_solar_panels(n, m): # Check for edge case when it's impossible to install panels satisfying the condition if n == 1 and m == 1: return [[1]] panels = [[0] * m for _ in range(n)] # Fill panels grid with zigzag pattern num = 1 for i in range(n): for j in range(m): panels[i][j] = num num += 1 for i in range(n): if i % 2 == 1: panels[i].reverse() # Print and return the grid for line in panels: print(' '.join(map(str, line))) return panels"},{"question":"def can_protect_castles(n: int, m: int, k: int, s: List[int], p: List[int]) -> str: Determine if it is possible to protect all castles using the given knights and positions. Parameters: n (int): The number of castles. m (int): The number of knights. k (int): The number of positions where knights can be stationed. s (list of int): The number of castles each knight can protect to both sides from their position. p (list of int): The positions where a knight can be stationed. Returns: str: \\"YES\\" if all castles can be protected, \\"NO\\" otherwise. >>> can_protect_castles(10, 3, 4, [2, 1, 3], [2, 5, 8, 10]) 'YES' >>> can_protect_castles(10, 2, 3, [1, 2], [1, 3, 5]) 'NO' >>> can_protect_castles(5, 1, 2, [2], [2, 4]) 'YES' >>> can_protect_castles(8, 2, 3, [1, 1], [1, 4, 6]) 'NO' >>> can_protect_castles(15, 3, 5, [3, 2, 5], [2, 6, 8, 10, 12]) 'YES'","solution":"def can_protect_castles(n, m, k, s, p): Determine if it is possible to protect all castles using the given knights and positions. Parameters: n (int): The number of castles. m (int): The number of knights. k (int): The number of positions where knights can be stationed. s (list of int): The number of castles each knight can protect to both sides from their position. p (list of int): The positions where a knight can be stationed. Returns: str: \\"YES\\" if all castles can be protected, \\"NO\\" otherwise. ranges = [] for i in range(m): for pos in p: left_limit = max(1, pos - s[i]) right_limit = min(n, pos + s[i]) ranges.append((left_limit, right_limit)) ranges.sort() current_end = 0 for r in ranges: if r[0] > current_end + 1: break current_end = max(current_end, r[1]) return \\"YES\\" if current_end >= n else \\"NO\\""},{"question":"def count_unique_rooks(input_data: str) -> List[int]: Given the input data representing several datasets of line segments, this function counts the number of unique rooks in each dataset. Each rook moves along a set of line segments, either horizontally or vertically. Parameters: input_data (str): A multiline string containing several datasets. Returns: List[int]: A list containing the number of unique rooks for each dataset. >>> count_unique_rooks(\\"4n1 2 1 5n2 3 2 7n3 4 3 5n4 6 4 8n5n0 0 0 4n4 0 4 4n2 2 5 2n3 1 5 1n0 2 4 2n0\\") [4, 4] >>> count_unique_rooks(\\"1n0 0 3 0n0\\") [1] >>> count_unique_rooks(\\"1n0 0 0 3n0\\") [1] >>> count_unique_rooks(\\"3n0 0 0 3n1 1 1 2n0 1 2 1n2n1 1 1 3n3 0 3 4n0\\") [3, 2] >>> count_unique_rooks(\\"4n0 0 0 4n0 2 0 3n2 2 5 2n3 2 5 2n0\\") [2]","solution":"def count_unique_rooks(input_data): Given the input data representing several datasets of line segments, this function counts the number of unique rooks in each dataset. Each rook moves along a set of line segments, either horizontally or vertically. Parameters: input_data (str): A multiline string containing several datasets. Returns: List[int]: A list containing the number of unique rooks for each dataset. lines = input_data.strip().split('n') index = 0 results = [] while index < len(lines): m = int(lines[index]) if m == 0: break segments = set() for i in range(1, m + 1): x1, y1, x2, y2 = map(int, lines[index + i].split()) if x1 == x2: segments.add((x1, 'v')) # vertical segment elif y1 == y2: segments.add((y1, 'h')) # horizontal segment results.append(len(segments)) index += m + 1 return results"},{"question":"def distribute_workers(w: int, t: int, priorities: List[int]) -> int: Distributes tasks among workers maximizing total priority. Args: w (int): number of workers t (int): number of tasks priorities (List[int]): list of task priorities Returns: int: maximum possible total priority >>> distribute_workers(3, 5, [1, 2, 3, 4, 5]) 15 >>> distribute_workers(10, 5, [10, 20, 30, 40, 50]) 150 >>> distribute_workers(5, 5, [5, 10, 15, 20, 25]) 75 >>> distribute_workers(1, 5, [5, 10, 15, 20, 25]) 75 >>> distribute_workers(5, 1, [100]) 100 >>> distribute_workers(4, 6, [3, 1, 7, 9, 5, 2]) 27 >>> distribute_workers(3, 3, [1000, 1000, 1000]) 3000 >>> distribute_workers(5, 5, [1, 1, 1, 1, 1]) 5","solution":"def distribute_workers(w, t, priorities): Distributes tasks among workers maximizing total priority. :param w: number of workers :param t: number of tasks :param priorities: list of task priorities :return: maximum possible total priority # Sort the priorities in descending order to maximize total priority. priorities.sort(reverse=True) # If there are more workers than tasks, all tasks can be assigned at full priority. # Otherwise, simply sum up all priorities because one task can be assigned to one worker. return sum(priorities)"},{"question":"def leftmost_largest_k_elements(n: int, k: int, a: List[int], m: int, queries: List[int]) -> List[int]: Find the leftmost largest k elements in the list, then return the q-th smallest among those for each query. Parameters: n (int): The length of the list \`a\`. k (int): The number of largest elements to find. a (List[int]): The list of elements. m (int): The number of queries. queries (List[int]): The queries to find the q-th smallest element. Returns: List[int]: The results for each query. Example: >>> leftmost_largest_k_elements(5, 3, [10, 20, 10, 5, 15], 2, [1, 2]) [10, 15] >>> leftmost_largest_k_elements(4, 2, [1, 2, 3, 4], 2, [1, 2]) [3, 4]","solution":"def leftmost_largest_k_elements(n, k, a, m, queries): Returns the q-th smallest element for each query from the k largest elements of array a. # Obtain the leftmost k largest elements sorted_a = sorted(enumerate(a), key=lambda x: (-x[1], x[0])) largest_k_elements = [a[i[0]] for i in sorted_a[:k]] # Sort the k largest elements to handle queries largest_k_elements_sorted = sorted(largest_k_elements) # Answer each query results = [] for q in queries: results.append(largest_k_elements_sorted[q-1]) return results"},{"question":"def min_window_substring(A: str, B: str) -> str: Given two strings, A and B, find the smallest substring in string A that contains all the characters of string B. If there is no such substring, return an empty string. >>> min_window_substring(\\"ADOBECODEBANC\\", \\"ABC\\") 'BANC' >>> min_window_substring(\\"A\\", \\"AA\\") '' >>> min_window_substring(\\"BANC\\", \\"BANC\\") 'BANC' >>> min_window_substring(\\"AA\\", \\"A\\") 'A' >>> min_window_substring(\\"AAABBBCCC\\", \\"ABC\\") 'ABBBC'","solution":"from collections import Counter, defaultdict def min_window_substring(A, B): Finds the smallest substring in string A that contains all characters of string B. If there is no such substring, returns an empty string. if not A or not B: return \\"\\" required = Counter(B) window_counts = defaultdict(int) l, r = 0, 0 formed = 0 required_length = len(required) ans = float(\\"inf\\"), None, None while r < len(A): char = A[r] window_counts[char] += 1 if char in required and window_counts[char] == required[char]: formed += 1 while l <= r and formed == required_length: char = A[l] if r - l + 1 < ans[0]: ans = (r - l + 1, l, r) window_counts[char] -= 1 if char in required and window_counts[char] < required[char]: formed -= 1 l += 1 r += 1 if ans[0] == float(\\"inf\\"): return \\"\\" return A[ans[1]: ans[2] + 1]"},{"question":"from typing import List, Tuple def sort_parcels_by_category(n: int, parcels: List[Tuple[int, str]]) -> List[str]: Returns the lexicographically smallest sequence of parcel IDs for each category. >>> sort_parcels_by_category(6, [(123, 'a'), (456, 'b'), (789, 'a'), (234, 'b'), (567, 'c'), (345, 'a')]) [\\"a 123 345 789\\", \\"b 234 456\\", \\"c 567\\"] >>> sort_parcels_by_category(4, [(12, 'd'), (9, 'd'), (15, 'd'), (5, 'd')]) [\\"d 5 9 12 15\\"]","solution":"def sort_parcels_by_category(n, parcels): from collections import defaultdict categories = defaultdict(list) for parcel in parcels: ID, category = parcel categories[category].append(ID) result = [] for category in sorted(categories.keys()): sorted_ids = sorted(categories[category]) result.append(f\\"{category} \\" + \\" \\".join(map(str, sorted_ids))) return result"},{"question":"def max_scenic_spots(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine the maximum number of scenic spots Aisha can visit without stopping at adjacent spots. Args: T : int : The number of test cases test_cases : List[Tuple[int, List[int]]] : Each tuple contains the number of paths and the list of scenic spots on each path Returns: List[str] : A list of result strings in the format \\"TestCase T: M\\" >>> max_scenic_spots(2, [(4, [4, 2, 3, 5]), (3, [1, 8, 7])]) [\\"TestCase 1: 9\\", \\"TestCase 2: 8\\"] >>> max_scenic_spots(1, [(3, [1, 2, 3])]) [\\"TestCase 1: 4\\"]","solution":"def max_scenic_spots(T, test_cases): results = [] for t in range(T): N = test_cases[t][0] spots = test_cases[t][1] if N == 0: results.append(f\\"TestCase {t+1}: 0\\") continue if N == 1: results.append(f\\"TestCase {t+1}: {spots[0]}\\") continue # Dynamic programming approach dp = [0] * N dp[0] = spots[0] dp[1] = max(spots[0], spots[1]) for i in range(2, N): dp[i] = max(dp[i-1], spots[i] + dp[i-2]) results.append(f\\"TestCase {t+1}: {dp[-1]}\\") return results"},{"question":"def count_consecutive_sum_ways(N: int) -> int: Returns the number of ways to express N as a sum of two or more consecutive positive integers. >>> count_consecutive_sum_ways(15) 3 >>> count_consecutive_sum_ways(10) 1 >>> count_consecutive_sum_ways(1) 0","solution":"def count_consecutive_sum_ways(N): Returns the number of ways to express N as a sum of two or more consecutive positive integers. count = 0 k = 1 while k * (k + 1) // 2 < N: if (N - k * (k + 1) // 2) % (k + 1) == 0: count += 1 k += 1 return count"},{"question":"def create_H_pattern(n: int, m: int) -> List[str]: Creates an n x m grid with an 'H' pattern. The 'H' pattern has 'H' characters at the first, middle, and last columns of each row. All other cells contain a dot character '.'. >>> create_H_pattern(5, 5) ['H...H', 'H...H', 'HHHHH', 'H...H', 'H...H'] >>> create_H_pattern(7, 7) ['H.....H', 'H.....H', 'H.....H', 'HHHHHHH', 'H.....H', 'H.....H', 'H.....H'] >>> create_H_pattern(5, 6) ['H....H', 'H....H', 'HHHHHH', 'H....H', 'H....H']","solution":"def create_H_pattern(n, m): Creates an n x m grid with an 'H' pattern. The 'H' pattern has 'H' characters at the first, middle, and last columns of each row. All other cells contain a dot character '.'. grid = [] for i in range(n): if i == n // 2: grid.append('H' * m) else: row = ['H'] + ['.'] * (m - 2) + ['H'] grid.append(''.join(row)) return grid"},{"question":"def min_moves_to_transform(s: str, t: str) -> int: Determine the minimum number of moves required to transform string s into string t. Args: s (str): The original string. t (str): The target string. Returns: int: The minimum number of moves required. Example: >>> min_moves_to_transform(\\"abcdef\\", \\"fedcba\\") 6 >>> min_moves_to_transform(\\"aaaaaa\\", \\"aaaaab\\") 1 >>> min_moves_to_transform(\\"aaaaaa\\", \\"aaaaaa\\") 0 pass # Test cases def test_min_moves_to_transform(): assert min_moves_to_transform(\\"abcdef\\", \\"fedcba\\") == 6 assert min_moves_to_transform(\\"aaaaaa\\", \\"aaaaaa\\") == 0 assert min_moves_to_transform(\\"aaaaaa\\", \\"aaaaab\\") == 1 assert min_moves_to_transform(\\"abcdef\\", \\"ghijkl\\") == 6 assert min_moves_to_transform(\\"a\\", \\"b\\") == 1 assert min_moves_to_transform(\\"x\\", \\"x\\") == 0","solution":"def min_moves_to_transform(s, t): Returns the minimum number of moves required to transform string s into string t. # Both strings are of the same length, as specified # So we can simply count the positions where characters differ moves = 0 for char_s, char_t in zip(s, t): if char_s != char_t: moves += 1 return moves"},{"question":"def is_symmetrical(n: int, heights: List[int]) -> str: Checks if the arrangement of flowers is symmetrical. :param n: Number of flowers :param heights: List of integers representing the heights of the flowers :return: \\"YES\\" if symmetrical, otherwise \\"NO\\" >>> is_symmetrical(5, [3, 2, 1, 2, 3]) \\"YES\\" >>> is_symmetrical(6, [1, 2, 3, 4, 2, 1]) \\"NO\\" >>> is_symmetrical(1, [7]) \\"YES\\"","solution":"def is_symmetrical(n, heights): Checks if the arrangement of flowers is symmetrical. :param n: Number of flowers :param heights: List of integers representing the heights of the flowers :return: \\"YES\\" if symmetrical, otherwise \\"NO\\" return \\"YES\\" if heights == heights[::-1] else \\"NO\\""},{"question":"def max_diff_sequence(n): Constructs a sequence of length n such that the function f(a) is maximized. The sequence is constructed by picking numbers in a strategic way to maximize the absolute differences. :param n: int number representing the length of the sequence (2 ≤ n ≤ 10^6) :return: a list of n integers for the sequence a that maximizes f(a) Examples: >>> max_diff_sequence(2) [1, 2] >>> max_diff_sequence(3) [1, 3, 2] >>> max_diff_sequence(4) [1, 4, 2, 3]","solution":"def max_diff_sequence(n): Constructs a sequence of length n such that the function f(a) is maximized. The sequence is constructed by picking numbers in a strategic way to maximize the absolute differences. :param n: int number representing the length of the sequence (2 ≤ n ≤ 10^6) :return: a list of n integers for the sequence a that maximizes f(a) if n == 2: return [1, 2] result = [] # We use two pointers approach, one pointer starts from 1 and the other from n, # and we keep alternating their values while adding to the result. i, j = 1, n while i <= j: if i != j: result.append(i) result.append(j) else: result.append(i) i += 1 j -= 1 return result # Example Usage: # n = 3 # print(max_diff_sequence(n)) # Output: [1, 3, 2]"},{"question":"from typing import List, Union def shortest_segment_path(w: int, h: int, grid: List[str]) -> Union[int, str]: Given a grid of W x H containing '.', '#', 'R', and 'D', find the shortest path from 'R' to 'D' utilizing segment jumps. Args: w : int : Width of the grid h : int : Height of the grid grid : List[str] : Grid layout Returns: int or str : Minimum number of moves (or \\"No\\" if not possible) Example: >>> shortest_segment_path(4, 4, [\\"R..#\\", \\".#.D\\", \\"..#.\\", \\"#...\\"]) 3 >>> shortest_segment_path(5, 5, [\\"....#\\", \\"..R.#\\", \\"#\\", \\"..#..\\", \\"D.#..\\"]) 'No' pass def process_grids(input_str: str) -> List[Union[int, str]]: Processes multiple grid inputs and returns the shortest path for each grid. Args: input_str : str : Multiline string containing grid descriptions Returns: List[Union[int, str]] : List containing the result for each grid Example: >>> process_grids(\\"4 4nR..#n.#.Dn..#.n#...n0 0\\") [3] >>> process_grids(\\"5 5n....#n..R.#n#n..#..nD.#..n0 0\\") ['No'] pass import pytest def test_single_valid_input(): input_str = ( \\"4 4n\\" \\"R..#n\\" \\".#.Dn\\" \\"..#.n\\" \\"#...n\\" \\"0 0\\" ) result = process_grids(input_str) assert result == [3] def test_single_invalid_input(): input_str = ( \\"5 5n\\" \\"....#n\\" \\"..R.#n\\" \\"#n\\" \\"..#..n\\" \\"D.#..n\\" \\"0 0\\" ) result = process_grids(input_str) assert result == [\\"No\\"] def test_multiple_inputs(): input_str = ( \\"4 4n\\" \\"R..#n\\" \\".#.Dn\\" \\"..#.n\\" \\"#...n\\" \\"5 5n\\" \\"....#n\\" \\"..R.#n\\" \\"#n\\" \\"..#..n\\" \\"D.#..n\\" \\"0 0\\" ) result = process_grids(input_str) assert result == [3, \\"No\\"] def test_direct_path(): input_str = ( \\"3 3n\\" \\"R.Dn\\" \\"...n\\" \\"...n\\" \\"0 0\\" ) result = process_grids(input_str) assert result == [1] def test_blocked_by_buildings(): input_str = ( \\"4 4n\\" \\"R.#.n\\" \\"n\\" \\"#.n\\" \\"D#n\\" \\"0 0\\" ) result = process_grids(input_str) assert result == [\\"No\\"]","solution":"from collections import deque def shortest_segment_path(w, h, grid): direction_vectors = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right start = None destination = None # Find the initial position and destination for i in range(h): for j in range(w): if grid[i][j] == 'R': start = (i, j) elif grid[i][j] == 'D': destination = (i, j) # Breadth-first search (BFS) queue queue = deque([(start[0], start[1], 0)]) # (row, col, moves) visited = set() visited.add(start) while queue: row, col, moves = queue.popleft() if (row, col) == destination: return moves for dr, dc in direction_vectors: r, c = row, col # Try to move in the direction until hitting a wall or edge of the grid while 0 <= r + dr < h and 0 <= c + dc < w and grid[r + dr][c + dc] in {'.', 'D'}: r += dr c += dc if (r, c) == destination: return moves + 1 # If we reach the destination # If the end cell of the segment is valid and not visited if (r, c) != (row, col) and (r, c) not in visited: visited.add((r, c)) queue.append((r, c, moves + 1)) return \\"No\\" # Entry function to process multiple grids def process_grids(input_str): lines = input_str.strip().split('n') index = 0 results = [] while index < len(lines): w, h = map(int, lines[index].split()) if w == 0 and h == 0: break grid = lines[index + 1 : index + 1 + h] result = shortest_segment_path(w, h, grid) results.append(result) index += h + 1 return results"},{"question":"def longest_possible_encoded_message(n: int, words: List[str]) -> Tuple[int, List[str]]: This function determines the longest possible encoded message that can be formed from the given words such that no two words in the message have the same length. :param n: The number of words in the language (integer) :param words: A list of words in the language (list of strings) :return: A tuple (k, encoded_message) where k is the number of words in the longest possible message and encoded_message is a list of encoded words (list of strings) from typing import List, Tuple def test_longest_possible_encoded_message_case_1(): n = 4 words = [\\"code\\", \\"up\\", \\"longest\\", \\"hello\\"] k, encoded_message = longest_possible_encoded_message(n, words) assert k == 4 assert \\"\\".join(sorted(encoded_message)) == \\"\\".join(sorted(['cdeo', 'pu', 'eglnost', 'ehllo'])) def test_longest_possible_encoded_message_case_2(): n = 3 words = [\\"code\\", \\"a\\", \\"beta\\"] k, encoded_message = longest_possible_encoded_message(n, words) assert k == 3 assert \\"\\".join(sorted(encoded_message)) == \\"\\".join(sorted(['a', 'cdeo', 'abet'])) def test_longest_possible_encoded_message_single_word(): n = 1 words = [\\"hello\\"] k, encoded_message = longest_possible_encoded_message(n, words) assert k == 1 assert encoded_message == ['ehllo'] def test_longest_possible_encoded_message_multiple_words_with_odd_lengths(): n = 3 words = [\\"xyz\\", \\"opq\\", \\"efgh\\"] k, encoded_message = longest_possible_encoded_message(n, words) assert k == 3 assert \\"\\".join(sorted(encoded_message)) == \\"\\".join(sorted(['xyz', 'opq', 'efgh']))","solution":"def longest_possible_encoded_message(n, words): This function determines the longest possible encoded message that can be formed from the given words such that no two words in the message have the same length. :param n: The number of words in the language (integer) :param words: A list of words in the language (list of strings) :return: A tuple (k, encoded_message) where k is the number of words in the longest possible message and encoded_message is a list of encoded words (list of strings) # Sort the words by their length words_sorted_by_length = sorted(words, key=len) # Create the encoded message by rearranging the letters of each word encoded_message = [''.join(sorted(word)) for word in words_sorted_by_length] return len(encoded_message), encoded_message # Example usage: # n = 4 # words = [\\"code\\", \\"up\\", \\"longest\\", \\"hello\\"] # k, encoded_message = longest_possible_encoded_message(n, words) # print(k) # Should return 4 # print(encoded_message) # Can return any valid rearrangement of the words"},{"question":"def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates a square matrix 90 degrees clockwise. Args: - matrix (list of list of int): The square matrix to be rotated. Returns: - list of list of int: The rotated matrix. >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[10, 20], [30, 40]]) [[30, 10], [40, 20]]","solution":"def rotate_matrix(matrix): Rotates a square matrix 90 degrees clockwise. Args: - matrix (list of list of int): The square matrix to be rotated. Returns: - list of list of int: The rotated matrix. n = len(matrix) # Create an empty matrix of the same dimensions rotated = [[0]*n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n-1-i] = matrix[i][j] return rotated"},{"question":"from typing import List def max_score_sequences(t: int, test_cases: List[str]) -> List[int]: Determine the maximum score Lee can achieve by performing any number of split operations on a binary sequence. >>> max_score_sequences(1, [\\"110\\"]) == [2] >>> max_score_sequences(4, [\\"110\\", \\"10101\\", \\"0000\\", \\"11111\\"]) == [2, 3, 0, 5]","solution":"def max_score_sequences(t, test_cases): results = [] for s in test_cases: count_ones = s.count('1') results.append(count_ones) return results"},{"question":"def find_unique_numbers(arr: List[int]) -> List[int]: Returns a list of integers that appear exactly once in the array, in ascending order. >>> find_unique_numbers([4, 3, 2, 7, 8, 2, 3]) [4, 7, 8] >>> find_unique_numbers([1, 2, 2, 3, 3]) [1] >>> find_unique_numbers([2, 2, 2, 2]) [] >>> find_unique_numbers([5, 1, 9, 7]) [1, 5, 7, 9] >>> find_unique_numbers([1]) [1] >>> find_unique_numbers([4, 4, 2, 2, 1, 1, 3, 5, 3]) [5] >>> find_unique_numbers([100000]) [100000] >>> find_unique_numbers([10, 9, 8, 7, 6, 5, 3]) [3, 5, 6, 7, 8, 9, 10]","solution":"def find_unique_numbers(arr): Returns a list of integers that appear exactly once in the array, in ascending order. from collections import Counter counter = Counter(arr) unique_numbers = [num for num, count in counter.items() if count == 1] unique_numbers.sort() return unique_numbers"},{"question":"def max_power_ups(n: int, power_ups: List[Tuple[int, int]]) -> int: Determine the maximum number of power-ups Charles can collect following the given conditions. Args: n: The number of power-ups on the grid. power_ups: A list of tuples where each tuple contains two integers representing the position (x, y) of a power-up. Returns: The maximum number of power-ups Charles can collect. Examples: >>> max_power_ups(5, [(1, 2), (2, 3), (3, 4), (2, 2), (1, 3)]) 3 >>> max_power_ups(4, [(1, 1), (2, 2), (3, 1), (4, 2)]) 2","solution":"def max_power_ups(n, power_ups): # Sort power-ups first by x in ascending order, then by y in ascending order power_ups.sort(key=lambda x: (x[0], x[1])) # Initialize the count and the last collected y-coordinate count = 0 last_y = -1 for x, y in power_ups: if y > last_y: count += 1 last_y = y return count"},{"question":"from typing import List def is_prime(n: int) -> bool: Check if a given number is a prime number. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(29) == True # Implement the function here def is_palindrome(n: int) -> bool: Check if a given number is a palindrome. >>> is_palindrome(121) == True >>> is_palindrome(123) == False >>> is_palindrome(1221) == True >>> is_palindrome(123421) == False # Implement the function here def smallest_prime_palindrome(X: int) -> int: Find the smallest prime palindrome greater than or equal to a given number X. >>> smallest_prime_palindrome(31) == 101 >>> smallest_prime_palindrome(100) == 101 >>> smallest_prime_palindrome(130) == 131 >>> smallest_prime_palindrome(200) == 313 # Implement the function here","solution":"def is_prime(n): Check if n is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def is_palindrome(n): Check if n is a palindrome. return str(n) == str(n)[::-1] def smallest_prime_palindrome(X): Find the smallest prime palindrome greater than or equal to X. while True: if is_palindrome(X) and is_prime(X): return X X += 1"},{"question":"def find_pair_with_sum(n: int, target: int, array: List[int]) -> str: Determine if there exist two distinct indices i and j in the array such that the sum of the elements at those indices equals the target sum. If such a pair exists, return the two indices as a string. If no such pair exists, return 'NONE'. >>> find_pair_with_sum(5, 9, [1, 2, 3, 7, 8]) '0 3' >>> find_pair_with_sum(4, 0, [1, -3, 4, 2]) 'NONE' >>> find_pair_with_sum(6, 10, [3, 4, 5, 6, 7, 8]) '1 4'","solution":"def find_pair_with_sum(n, target, array): This function takes in the length of array \`n\`, a target sum \`target\`, and the list \`array\`, and returns a pair of indices such that the sum of the elements at those indices equals the target sum. If no such pair is found, it returns 'NONE'. indices_map = {} for i in range(n): complement = target - array[i] if complement in indices_map: print(indices_map[complement], i) return indices_map[array[i]] = i print(\\"NONE\\")"},{"question":"def transpose_and_reverse(matrix): Transpose the given matrix and then reverse each row of the resulting matrix. :param matrix: List of lists of integers representing the matrix. :return: List of lists of integers representing the transposed and reversed matrix. pass def test_transpose_and_reverse(): # Test case 1 matrix = [ [1, 2, 3], [4, 5, 6] ] expected_output = [ [4, 1], [5, 2], [6, 3] ] assert transpose_and_reverse(matrix) == expected_output # Test case 2 matrix = [ [1, 2], [3, 4], [5, 6] ] expected_output = [ [5, 3, 1], [6, 4, 2] ] assert transpose_and_reverse(matrix) == expected_output # Test case 3 (1x1 matrix) matrix = [ [1] ] expected_output = [ [1] ] assert transpose_and_reverse(matrix) == expected_output # Test case 4 (1x3 matrix) matrix = [ [1, 2, 3] ] expected_output = [ [1], [2], [3] ] assert transpose_and_reverse(matrix) == expected_output # Test case 5 (3x1 matrix) matrix = [ [1], [2], [3] ] expected_output = [ [3, 2, 1] ] assert transpose_and_reverse(matrix) == expected_output # Test case 6 matrix = [ [5, 9, -2], [-1, 4, 7] ] expected_output = [ [-1, 5], [4, 9], [7, -2] ] assert transpose_and_reverse(matrix) == expected_output","solution":"def transpose_and_reverse(matrix): Transpose the given matrix and then reverse each row of the resulting matrix. :param matrix: List of lists of integers representing the matrix. :return: List of lists of integers representing the transposed and reversed matrix. # Transpose the matrix transposed_matrix = list(zip(*matrix)) # Reverse each row of the transposed matrix result_matrix = [list(row)[::-1] for row in transposed_matrix] return result_matrix"},{"question":"def count_unique_greater_than(N: int, M: int, lst: List[int]) -> int: Given an integer N, an integer M, and a list of N integers, this function returns the number of unique integers in the list that are greater than M. >>> count_unique_greater_than(5, 3, [3, 4, 4, 6, 7]) 3 >>> count_unique_greater_than(4, 1, [1, 2, 2, 3]) 2 >>> count_unique_greater_than(3, 0, [0, 0, 0]) 0","solution":"def count_unique_greater_than(N, M, lst): Given an integer N, an integer M, and a list of N integers, this function returns the number of unique integers in the list that are greater than M. unique_set = set() for num in lst: if num > M: unique_set.add(num) return len(unique_set)"},{"question":"def count_connected_components(n: int, m: int, grid: List[List[str]]) -> int: Determine the number of connected components of free cells in the grid. >>> count_connected_components(1, 1, [['.']]) 1 >>> count_connected_components(1, 1, [['#']]) 0 >>> count_connected_components(2, 2, [['.', '.'], ['.', '.']]) 1 >>> count_connected_components(2, 2, [['#', '#'], ['#', '#']]) 0 >>> count_connected_components(2, 2, [['.', '#'], ['#', '.']]) 2 >>> count_connected_components(3, 3, [['.', '#', '.'], ['#', '.', '#'], ['.', '#', '.']]) 5 >>> count_connected_components(4, 5, [ ... ['.', '.', '#', '.', '.'], ... ['#', '.', '.', '.', '.'], ... ['#', '#', '.', '.', '#'], ... ['.', '.', '#', '.', '#']]) 2","solution":"def count_connected_components(n, m, grid): def dfs(x, y): stack = [(x, y)] while stack: cx, cy = stack.pop() for nx, ny in [(cx-1, cy), (cx+1, cy), (cx, cy-1), (cx, cy+1)]: if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.': grid[nx][ny] = '#' # Mark as visited stack.append((nx, ny)) count = 0 for i in range(n): for j in range(m): if grid[i][j] == '.': dfs(i, j) count += 1 return count"},{"question":"def apply_discounts(products, discounts, sort_by): Apply discounts to products based on the given conditions and return the sorted list. Args: products (list): List of dictionaries with product information. discounts (list): List of dictionaries with discount information. sort_by (str): String to sort the final list by (\\"id\\", \\"price\\", or \\"category\\"). Returns: list: List of dictionaries with the discounted products. # Unit tests def test_apply_discounts_sorted_by_id(): products = [ {\\"id\\": \\"a1\\", \\"price\\": 120.0, \\"category\\": \\"electronics\\"}, {\\"id\\": \\"b2\\", \\"price\\": 80.0, \\"category\\": \\"books\\"}, {\\"id\\": \\"c3\\", \\"price\\": 200.0, \\"category\\": \\"electronics\\"} ] discounts = [ {\\"category\\": \\"electronics\\", \\"percent\\": 10, \\"min_price\\": 100.0}, {\\"category\\": \\"books\\", \\"percent\\": 5, \\"min_price\\": 50.0} ] sort_by = \\"id\\" result = apply_discounts(products, discounts, sort_by) expected = [ {\\"id\\": \\"a1\\", \\"price\\": 108.0, \\"category\\": \\"electronics\\"}, {\\"id\\": \\"b2\\", \\"price\\": 76.0, \\"category\\": \\"books\\"}, {\\"id\\": \\"c3\\", \\"price\\": 180.0, \\"category\\": \\"electronics\\"} ] assert result == expected def test_apply_discounts_sorted_by_price(): products = [ {\\"id\\": \\"a1\\", \\"price\\": 120.0, \\"category\\": \\"electronics\\"}, {\\"id\\": \\"b2\\", \\"price\\": 80.0, \\"category\\": \\"books\\"}, {\\"id\\": \\"c3\\", \\"price\\": 200.0, \\"category\\": \\"electronics\\"} ] discounts = [ {\\"category\\": \\"electronics\\", \\"percent\\": 10, \\"min_price\\": 100.0}, {\\"category\\": \\"books\\", \\"percent\\": 5, \\"min_price\\": 50.0} ] sort_by = \\"price\\" result = apply_discounts(products, discounts, sort_by) expected = [ {\\"id\\": \\"b2\\", \\"price\\": 76.0, \\"category\\": \\"books\\"}, {\\"id\\": \\"a1\\", \\"price\\": 108.0, \\"category\\": \\"electronics\\"}, {\\"id\\": \\"c3\\", \\"price\\": 180.0, \\"category\\": \\"electronics\\"} ] assert result == expected def test_apply_discounts_sorted_by_category(): products = [ {\\"id\\": \\"a1\\", \\"price\\": 120.0, \\"category\\": \\"electronics\\"}, {\\"id\\": \\"b2\\", \\"price\\": 80.0, \\"category\\": \\"books\\"}, {\\"id\\": \\"c3\\", \\"price\\": 200.0, \\"category\\": \\"electronics\\"} ] discounts = [ {\\"category\\": \\"electronics\\", \\"percent\\": 10, \\"min_price\\": 100.0}, {\\"category\\": \\"books\\", \\"percent\\": 5, \\"min_price\\": 50.0} ] sort_by = \\"category\\" result = apply_discounts(products, discounts, sort_by) expected = [ {\\"id\\": \\"b2\\", \\"price\\": 76.0, \\"category\\": \\"books\\"}, {\\"id\\": \\"a1\\", \\"price\\": 108.0, \\"category\\": \\"electronics\\"}, {\\"id\\": \\"c3\\", \\"price\\": 180.0, \\"category\\": \\"electronics\\"} ] assert result == expected def test_apply_discounts_no_discount_applicables(): products = [ {\\"id\\": \\"a1\\", \\"price\\": 50.0, \\"category\\": \\"electronics\\"}, {\\"id\\": \\"b2\\", \\"price\\": 40.0, \\"category\\": \\"books\\"} ] discounts = [ {\\"category\\": \\"electronics\\", \\"percent\\": 10, \\"min_price\\": 100.0}, {\\"category\\": \\"books\\", \\"percent\\": 5, \\"min_price\\": 50.0} ] sort_by = \\"id\\" result = apply_discounts(products, discounts, sort_by) expected = [ {\\"id\\": \\"a1\\", \\"price\\": 50.0, \\"category\\": \\"electronics\\"}, {\\"id\\": \\"b2\\", \\"price\\": 40.0, \\"category\\": \\"books\\"} ] assert result == expected","solution":"def apply_discounts(products, discounts, sort_by): Apply discounts to products based on the given conditions and return the sorted list. Args: products (list): List of dictionaries with product information. discounts (list): List of dictionaries with discount information. sort_by (str): String to sort the final list by (\\"id\\", \\"price\\", or \\"category\\"). Returns: list: List of dictionaries with the discounted products. # Create a dictionary to hold the best discount for each category best_discounts = {} for discount in discounts: category = discount['category'] if category not in best_discounts or discount['percent'] > best_discounts[category]['percent']: best_discounts[category] = discount # Adjust the product prices based on the best applicable discount discounted_products = [] for product in products: category = product['category'] if category in best_discounts: discount = best_discounts[category] if product['price'] >= discount['min_price']: discount_amount = product['price'] * (discount['percent'] / 100) product['price'] -= discount_amount discounted_products.append(product) # Sort the products by the given sort_by parameter sorted_products = sorted(discounted_products, key=lambda x: x[sort_by]) return sorted_products"},{"question":"def check_drones_distances(drones): Determine if each drone can complete its weekly routes without exceeding its maximum distance capacity for any single day. >>> check_drones_distances([ ... [500, 100, 200, 300, 400, 500, 600, 700, 800], ... [600, 100, 200, 300, 400, 500, 450, 600, 350], ... ]) ['Drone 1: FAIL on day 3', 'Drone 2: OK'] >>> check_drones_distances([ ... [1000, 100, 200, 300, 400, 500, 600, 700], ... [500, 100, 200, 300, 400, 500, 400, 450], ... [800, 100, 200, 150, 300, 350, 400, 500] ... ]) ['Drone 1: OK', 'Drone 2: OK', 'Drone 3: OK'] >>> check_drones_distances([ ... [100, 150, 150, 150, 150, 150, 150, 150], ... [200, 250, 250, 250, 250, 250, 250, 250], ... [300, 350, 350, 350, 350, 350, 350, 350] ... ]) ['Drone 1: FAIL on day 1', 'Drone 2: FAIL on day 1', 'Drone 3: FAIL on day 1'] >>> check_drones_distances([ ... [500, 400, 300, 600, 200, 100, 700, 500], ... [600, 500, 400, 300, 200, 100, 50, 600] ... ]) ['Drone 1: FAIL on day 3', 'Drone 2: OK'] >>> check_drones_distances([ ... [700, 100, 200, 300, 400, 500, 600, 800] ... ]) ['Drone 1: FAIL on day 7'] # Your code here","solution":"def check_drones_distances(drones): results = [] for i, drone_data in enumerate(drones): capacity = drone_data[0] distances = drone_data[1:] for day, distance in enumerate(distances): if distance > capacity: results.append(f\\"Drone {i + 1}: FAIL on day {day + 1}\\") break else: results.append(f\\"Drone {i + 1}: OK\\") return results"},{"question":"class ArrayProcessor: def __init__(self, arr): self.arr = arr def update_value(self, x, y): self.arr[x - 1] = y def max_in_subarray(self, l, r): return max(self.arr[l - 1:r]) def process_queries(n, q, arr, queries): Process the queries on the array. Parameters: n (int): The number of elements in the array. q (int): The number of queries. arr (List[int]): The initial elements of the array. queries (List[List[int]]): The list of queries where each query is represented by a list of three integers [t, x, y]. Returns: List[int]: The results for each query of type 2. Example: >>> n = 5 >>> q = 4 >>> arr = [1, 2, 3, 4, 5] >>> queries = [ ... [2, 1, 3], ... [1, 2, 10], ... [2, 2, 4], ... [2, 1, 5] ... ] >>> process_queries(n, q, arr, queries) [3, 10, 10]","solution":"class ArrayProcessor: def __init__(self, arr): self.arr = arr def update_value(self, x, y): self.arr[x - 1] = y def max_in_subarray(self, l, r): return max(self.arr[l - 1:r]) def process_queries(n, q, arr, queries): array_processor = ArrayProcessor(arr) results = [] for query in queries: if query[0] == 1: array_processor.update_value(query[1], query[2]) elif query[0] == 2: results.append(array_processor.max_in_subarray(query[1], query[2])) return results"},{"question":"def min_packages_to_handle(n: int, m: int, routes: List[Tuple[int, int, int]]) -> int: Determines the minimum number of packages that must be handled by a single distribution center. :param n: Number of distribution centers :param m: Number of delivery routes :param routes: List of tuples (u_i, v_i, p_i) representing the routes :return: Minimum number of packages handled by a single center to process all packages >>> min_packages_to_handle(4, 3, [(1, 2, 10), (2, 3, 5), (3, 4, 8)]) 15 >>> min_packages_to_handle(5, 2, [(1, 3, 12), (3, 4, 7)]) 19 # Test cases def test_min_packages_to_handle(): assert min_packages_to_handle(4, 3, [(1, 2, 10), (2, 3, 5), (3, 4, 8)]) == 15 assert min_packages_to_handle(5, 2, [(1, 3, 12), (3, 4, 7)]) == 19 assert min_packages_to_handle(2, 1, [(1, 2, 10)]) == 10 assert min_packages_to_handle(1, 0, []) == 0 assert min_packages_to_handle(3, 3, [(1, 2, 99999), (2, 3, 99999), (1, 3, 99999)]) == 199998","solution":"def min_packages_to_handle(n, m, routes): Determines the minimum number of packages that must be handled by a single distribution center. :param n: Number of distribution centers :param m: Number of delivery routes :param routes: List of tuples (u_i, v_i, p_i) representing the routes :return: Minimum number of packages handled by a single center to process all packages # Initialize a list to accumulate packages count for each center packages_count = [0] * (n + 1) for u, v, p in routes: packages_count[u] += p packages_count[v] += p # Find the max value in the packages_count, skipping the 0th index return max(packages_count) # Example Usage: # n, m = 4, 3 # routes = [(1, 2, 10), (2, 3, 5), (3, 4, 8)] # print(min_packages_to_handle(n, m, routes)) # Output: 15"},{"question":"def is_valid_parentheses(s: str) -> bool: Determine if the input string contains valid parentheses. >>> is_valid_parentheses(\\"()\\") True >>> is_valid_parentheses(\\"()[]{}\\") True >>> is_valid_parentheses(\\"(]\\") False >>> is_valid_parentheses(\\"([)]\\") False","solution":"def is_valid_parentheses(s: str) -> bool: stack = [] mapping = {')': '(', '}': '{', ']': '['} for char in s: if char in mapping: top_element = stack.pop() if stack else '#' if mapping[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"def find_max_value(M, N, queries): Finds the maximum value in the grid after processing the given queries. Parameters: M (int): Number of rows. N (int): Number of columns. queries (list of tuples): A list of queries, each represented as a tuple (x1, y1, x2, y2). Returns: int: The maximum value present in the grid after processing all the queries. # Implement the function here # Unit tests def test_example_case(): assert find_max_value(3, 3, [(1, 1, 2, 2), (2, 2, 3, 3)]) == 3 def test_single_query_full_grid(): assert find_max_value(5, 5, [(1, 1, 5, 5)]) == 2 def test_multiple_queries_no_overlap(): assert find_max_value(4, 4, [(1, 1, 2, 2), (3, 3, 4, 4)]) == 2 def test_multiple_queries_with_overlap(): assert find_max_value(4, 4, [(1, 1, 3, 3), (2, 2, 4, 4)]) == 3 def test_large_grid_single_query(): assert find_max_value(1000, 1000, [(1, 1, 1000, 1000)]) == 2 def test_large_grid_multiple_queries(): queries = [(1, 1, 500, 500), (500, 500, 1000, 1000), (250, 250, 750, 750)] assert find_max_value(1000, 1000, queries) == 4","solution":"def find_max_value(M, N, queries): Finds the maximum value in the grid after processing the given queries. Parameters: M (int): Number of rows. N (int): Number of columns. queries (list of tuples): A list of queries, each represented as a tuple (x1, y1, x2, y2). Returns: int: The maximum value present in the grid after processing all the queries. # Initialize the grid with zeros grid = [[0]* (N + 1) for _ in range(M + 1)] # Process queries using a difference array approach for x1, y1, x2, y2 in queries: grid[x1][y1] += 1 if x2 + 1 <= M: grid[x2 + 1][y1] -= 1 if y2 + 1 <= N: grid[x1][y2 + 1] -= 1 if x2 + 1 <= M and y2 + 1 <= N: grid[x2 + 1][y2 + 1] += 1 # Apply the difference approach to get the final grid values for i in range(1, M + 1): for j in range(1, N + 1): if i > 1: grid[i][j] += grid[i - 1][j] if j > 1: grid[i][j] += grid[i][j - 1] if i > 1 and j > 1: grid[i][j] -= grid[i - 1][j - 1] # Find the maximum value in the grid max_value = 0 for i in range(1, M + 1): for j in range(1, N + 1): max_value = max(max_value, grid[i][j] + 1) return max_value"},{"question":"def max_value_of_gift_bags(n: int, values: List[int]) -> int: Returns the maximum total value of gift bags given no two consecutive bags can be taken. Parameters: n (int): The number of gift bags. values (list): The values of the gift bags. Returns: int: The maximum possible value. >>> max_value_of_gift_bags(6, [5, 1, 1, 5, 1, 5]) 15 >>> max_value_of_gift_bags(1, [10]) 10 >>> max_value_of_gift_bags(2, [10, 5]) 10 >>> max_value_of_gift_bags(2, [5, 15]) 15 >>> max_value_of_gift_bags(5, [10, 1, 10, 1, 10]) 30 >>> max_value_of_gift_bags(3, [10000, 10000, 10000]) 20000 >>> max_value_of_gift_bags(4, [1, 1, 1, 1]) 2 >>> max_value_of_gift_bags(5, [1, 2, 3, 4, 5]) 9 >>> max_value_of_gift_bags(5, [5, 4, 3, 2, 1]) 9","solution":"def max_value_of_gift_bags(n, values): Returns the maximum total value of gift bags given no two consecutive bags can be taken. Parameters: n (int): The number of gift bags. values (list): The values of the gift bags. Returns: int: The maximum possible value. if n == 0: return 0 if n == 1: return values[0] dp = [0] * n dp[0] = values[0] dp[1] = max(values[0], values[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + values[i]) return dp[n-1]"},{"question":"def find_artifacts(N: int, M: int) -> List[Tuple[int, int]]: Find a set of unique artifacts with dimensions such that no two artifacts have the same dimensions. The function should return exactly M unique artifacts. Args: N (int): The maximum dimension for width and height. M (int): The number of unique artifacts needed. Returns: List[Tuple[int, int]]: A list of tuples representing the width and height of each artifact. >>> find_artifacts(4, 5) [(1, 1), (1, 2), (1, 3), (1, 4), (2, 1)] >>> find_artifacts(1, 1) [(1, 1)] >>> find_artifacts(2, 4) [(1, 1), (1, 2), (2, 1), (2, 2)] >>> find_artifacts(3, 9) [(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3)] >>> find_artifacts(3, 5) [(1, 1), (1, 2), (1, 3), (2, 1), (2, 2)]","solution":"def find_artifacts(N, M): artifacts = [] for w in range(1, N + 1): for h in range(1, N + 1): if len(artifacts) < M: artifacts.append((w, h)) else: break if len(artifacts) >= M: break return artifacts"},{"question":"def reverse_chunks(arr, k): Reverse the order of the first k elements of the array and then reverse the order of the last n-k elements of the array. Args: arr (List[int]): The array to be processed. k (int): The number of elements to reverse from the beginning. Returns: List[int]: The array after performing the reversed chunks operation. Examples: >>> reverse_chunks([1, 2, 3, 4, 5], 2) [2, 1, 3, 4, 5] >>> reverse_chunks([10, 20, 30, 40, 50, 60], 3) [30, 20, 10, 40, 50, 60] >>> reverse_chunks([4, 3, 2, 1], 0) [4, 3, 2, 1] >>> reverse_chunks([8, 7, 6], 5) [6, 7, 8] def process_test_cases(t, test_cases): Process multiple test cases for the reverse_chunks function. Args: t (int): The number of test cases. test_cases (List[Tuple[Tuple[int, int], List[int]]]): The test cases where each test case contains a tuple with (n, k) and the array to be processed. Returns: List[List[int]]: A list of resulting arrays after performing the reversed chunks operation on each test case. Examples: >>> process_test_cases(2, [((5, 2), [1, 2, 3, 4, 5]), ((6, 3), [10, 20, 30, 40, 50, 60])]) [[2, 1, 3, 4, 5], [30, 20, 10, 40, 50, 60]]","solution":"def reverse_chunks(arr, k): Reverse the order of the first k elements of the array and then reverse the order of the last n-k elements of the array. n = len(arr) if k > n: k = n first_part = arr[:k][::-1] second_part = arr[k:][::-1] return first_part + second_part def process_test_cases(t, test_cases): results = [] for i in range(t): n, k = test_cases[i][0] arr = test_cases[i][1] results.append(reverse_chunks(arr, k)) return results"},{"question":"def find_single_integer(n: int, nums: List[int]) -> int: Find the integer that appears only once in the list. All other integers appear exactly twice. Args: - n (int): Length of the sequence. - nums (List[int]): List of n space-separated integers. Returns: - int: The integer that appears only once. Examples: >>> find_single_integer(5, [1, 2, 3, 2, 1]) 3 >>> find_single_integer(7, [4, 1, 2, 1, 2, 4, 5]) 5 >>> find_single_integer(1, [99]) 99 >>> find_single_integer(3, [0, 1, 0]) 1 >>> find_single_integer(9, [7, 3, 5, 7, 3, 5, 10, 12, 12]) 10 pass","solution":"def find_single_integer(n, nums): Find the integer that appears only once in the list. All other integers appear exactly twice. result = 0 for num in nums: result ^= num return result"},{"question":"def control_temperature(records, threshold, reduction): Adjust the temperature records by operating the cooling unit if temperature exceeds the threshold. Args: records (list of int): List of temperature records. threshold (int): The threshold value to start the cooling unit. reduction (int): The reduction amount per second. Returns: list of int: Updated temperature records after operating the cooling unit. Examples: >>> control_temperature([28, 32, 35, 30, 33, 34, 29], 30, 3) [28, 29, 32, 30, 30, 31, 29] >>> control_temperature([25, 27, 29, 31, 33, 36, 38], 32, 4) [25, 27, 29, 31, 29, 32, 34] from solution import control_temperature def test_control_temperature_example1(): records = [28, 32, 35, 30, 33, 34, 29] threshold = 30 reduction = 3 assert control_temperature(records, threshold, reduction) == [28, 29, 32, 30, 30, 31, 29] def test_control_temperature_example2(): records = [25, 27, 29, 31, 33, 36, 38] threshold = 32 reduction = 4 assert control_temperature(records, threshold, reduction) == [25, 27, 29, 31, 29, 32, 34] def test_control_temperature_no_reduction_needed(): records = [28, 25, 29] threshold = 30 reduction = 3 assert control_temperature(records, threshold, reduction) == [28, 25, 29] def test_control_temperature_all_need_reduction(): records = [33, 35, 37, 39] threshold = 30 reduction = 3 assert control_temperature(records, threshold, reduction) == [30, 32, 34, 36] def test_control_temperature_mixed_values(): records = [40, 45, 20, 25, 55, 32] threshold = 30 reduction = 5 assert control_temperature(records, threshold, reduction) == [35, 40, 20, 25, 50, 27] def test_control_temperature_threshold_edge_case(): records = [30, 30, 30] threshold = 30 reduction = 3 assert control_temperature(records, threshold, reduction) == [30, 30, 30]","solution":"def control_temperature(records, threshold, reduction): Adjust the temperature records by operating the cooling unit if temperature exceeds the threshold. Args: records (list of int): List of temperature records. threshold (int): The threshold value to start the cooling unit. reduction (int): The reduction amount per second. Returns: list of int: Updated temperature records after operating the cooling unit. updated_records = records[:] for i, temp in enumerate(updated_records): if temp > threshold: updated_records[i] -= reduction return updated_records"},{"question":"from typing import List, Tuple def merge_intervals(intervals: List[Tuple[int, int]]) -> Tuple[int, int]: Merges overlapping intervals and returns the count of non-overlapping intervals and the total length covered by these intervals. >>> merge_intervals([(1, 3), (2, 6), (8, 10), (15, 18), (16, 17), (19, 20)]) (4, 11) >>> merge_intervals([(1, 4), (4, 5), (8, 10), (9, 11)]) (2, 7) >>> merge_intervals([(1, 2), (3, 4), (5, 6)]) (3, 3) >>> merge_intervals([(1, 10), (2, 5), (3, 6)]) (1, 9) >>> merge_intervals([(0, 0)]) (1, 0) >>> merge_intervals([(1, 3), (2, 5), (6, 10), (8, 12)]) (2, 10)","solution":"def merge_intervals(intervals): Merges overlapping intervals and returns the count of non-overlapping intervals and the total length covered by these intervals. if not intervals: return 0, 0 # Sort intervals by starting point intervals.sort(key=lambda x: x[0]) merged_intervals = [] current_start, current_end = intervals[0] for start, end in intervals[1:]: if start <= current_end: # there is overlap current_end = max(current_end, end) else: merged_intervals.append((current_start, current_end)) current_start, current_end = start, end # don't forget to add the last interval merged_intervals.append((current_start, current_end)) # Calculate the total length covered by the merged intervals total_length = sum(end - start for start, end in merged_intervals) return len(merged_intervals), total_length"},{"question":"def can_split_into_three_equal_sums(n: int, arr: List[int]) -> str: Determine if the array can be split into three non-empty contiguous subarrays with equal sums. :param n: integer, the number of elements in the array :param arr: list of integers, the array elements :return: string, \\"YES\\" if possible, otherwise \\"NO\\" >>> can_split_into_three_equal_sums(5, [1, 2, 3, 0, 3]) == \\"YES\\" >>> can_split_into_three_equal_sums(4, [0, 2, 3, 1]) == \\"NO\\" >>> can_split_into_three_equal_sums(6, [1, 1, 1, 1, 1, 1]) == \\"YES\\" >>> can_split_into_three_equal_sums(5, [10**9] * 5) == \\"NO\\" >>> can_split_into_three_equal_sums(1, [1]) == \\"NO\\" >>> can_split_into_three_equal_sums(6, [0, 0, 0, 0, 0, 0]) == \\"YES\\"","solution":"def can_split_into_three_equal_sums(n, arr): Determine if the array can be split into three non-empty contiguous subarrays with equal sums. :param n: integer, the number of elements in the array :param arr: list of integers, the array elements :return: string, \\"YES\\" if possible, otherwise \\"NO\\" total_sum = sum(arr) if total_sum % 3 != 0: return \\"NO\\" target_sum = total_sum // 3 prefix_sum = 0 count_one_third = 0 for i in range(n-1): prefix_sum += arr[i] # Check if we've encountered 2/3 total sum before reaching the last element if prefix_sum == 2 * target_sum and count_one_third > 0: return \\"YES\\" # Check if we've encountered 1/3 total sum if prefix_sum == target_sum: count_one_third += 1 return \\"NO\\""},{"question":"def traffic_lights(n: int, m: int, commands: List[str]) -> List[str]: Simulate the status of traffic lights on a grid based on a series of commands. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. commands (List[str]): List of commands to process. Returns: List[str]: The results of all query commands in the order they were processed. >>> traffic_lights(3, 3, [\\"S 2 2 >\\", \\"S 1 1 ^\\", \\"Q 2 2\\", \\"Q 1 1\\", \\"C 2 2\\", \\"Q 2 2\\"]) [\\">\\", \\"^\\", \\"N/A\\"] >>> traffic_lights(1, 1, [\\"S 1 1 v\\", \\"Q 1 1\\", \\"C 1 1\\", \\"Q 1 1\\"]) [\\"v\\", \\"N/A\\"] >>> traffic_lights(2, 2, [\\"S 1 2 <\\", \\"S 2 1 ^\\", \\"S 2 2 v\\", \\"Q 1 2\\", \\"Q 2 1\\", \\"C 1 2\\", \\"Q 1 2\\", \\"Q 2 2\\"]) [\\"<\\", \\"^\\", \\"N/A\\", \\"v\\"] >>> traffic_lights(3, 3, []) [] >>> traffic_lights(3, 3, [\\"Q 1 1\\", \\"Q 2 2\\"]) [\\"N/A\\", \\"N/A\\"]","solution":"def traffic_lights(n, m, commands): # Initialize the grid with None values grid = [[None for _ in range(m)] for _ in range(n)] results = [] for command in commands: parts = command.split() action = parts[0] x = int(parts[1]) - 1 y = int(parts[2]) - 1 if action == \\"S\\": c = parts[3] grid[x][y] = c elif action == \\"C\\": grid[x][y] = None elif action == \\"Q\\": results.append(grid[x][y] if grid[x][y] is not None else \\"N/A\\") return results"},{"question":"def process_string(s: str) -> str: Process the input string s according to the specified rules: - For all vowels and digits, remove them from the string. - For all consonants, insert a character \\".\\" before each one. - Replace all uppercase consonants with corresponding lowercase ones. >>> process_string(\\"t0u1r\\") '.t.r' >>> process_string(\\"Codeforc3s2021\\") '.c.d.f.r.c.s' >>> process_string(\\"aBAcAba7\\") '.b.c.b' >>> process_string(\\"aA0eE9\\") '' >>> process_string(\\"HeLLoWoRLD123\\") '.h.l.l.w.r.l.d' >>> process_string(\\"bcdfgh\\") '.b.c.d.f.g.h' >>> process_string(\\"BCDFGH\\") '.b.c.d.f.g.h'","solution":"def process_string(s): Process the input string s according to the specified rules: - Remove all vowels and digits. - Insert a character \\".\\" before each remaining consonant. - Replace all uppercase consonants with corresponding lowercase ones. vowels = set(\\"aoyeuiAOYEUI\\") result = \\"\\" for char in s: if char.isdigit() or char in vowels: continue if char.isalpha() and char not in vowels: result += '.' + char.lower() return result"},{"question":"def max_sum_after_operations(arr): Returns the maximum possible value of the sum of the elements of the array after performing zero or more operations. def process_test_cases(T, test_cases): results = [] for case in test_cases: n, arr = case results.append(max_sum_after_operations(arr)) return results # Unit test def test_max_sum_after_operations(): assert max_sum_after_operations([1, 2, 3]) == 18 assert max_sum_after_operations([-1, -2, -3, -4]) == -10 assert max_sum_after_operations([-1, 2, -3, 4]) == 8 assert max_sum_after_operations([0, 0, 0, 0]) == 0 def test_process_test_cases(): test_cases = [ (3, [1, 2, 3]), (4, [-1, -2, -3, -4]) ] results = process_test_cases(2, test_cases) assert results == [18, -10]","solution":"def max_sum_after_operations(arr): Returns the maximum possible value of the sum of the elements of the array after performing zero or more operations. total_sum = sum(arr) return total_sum * len(arr) if total_sum > 0 else total_sum def process_test_cases(T, test_cases): results = [] for case in test_cases: n, arr = case results.append(max_sum_after_operations(arr)) return results"},{"question":"def min_cost_to_sort_balls(n, colors): This function takes the number of beads n and a list of colors representing the beads' colors and returns the minimum total cost required to arrange the beads in non-decreasing order of their colors. Parameters: n (int): The number of beads. colors (list): A list of integers representing the colors of the beads. Returns: int: The minimum total cost to arrange the beads in non-decreasing order of their colors. pass import pytest def test_min_cost_to_sort_balls_example1(): assert min_cost_to_sort_balls(4, [3, 1, 2, 4]) == 2 def test_min_cost_to_sort_balls_example2(): assert min_cost_to_sort_balls(5, [5, 2, 3, 1, 4]) == 6 def test_min_cost_to_sort_balls_already_sorted(): assert min_cost_to_sort_balls(5, [1, 2, 3, 4, 5]) == 0 def test_min_cost_to_sort_balls_reverse_sorted(): assert min_cost_to_sort_balls(4, [4, 3, 2, 1]) == 6 def test_min_cost_to_sort_balls_all_same_color(): assert min_cost_to_sort_balls(4, [2, 2, 2, 2]) == 0 def test_min_cost_to_sort_balls_single_element(): assert min_cost_to_sort_balls(1, [1]) == 0 def test_min_cost_to_sort_balls_large_input(): colors = [i for i in range(1, 100001)] assert min_cost_to_sort_balls(100000, colors) == 0","solution":"def min_cost_to_sort_balls(n, colors): This function takes the number of beads n and a list of colors representing the beads' colors and returns the minimum total cost required to arrange the beads in non-decreasing order of their colors. Parameters: n (int): The number of beads. colors (list): A list of integers representing the colors of the beads. Returns: int: The minimum total cost to arrange the beads in non-decreasing order of their colors. indexed_colors = list(enumerate(colors)) indexed_colors.sort(key=lambda x: x[1]) # Use a Fenwick Tree (also known as Binary Indexed Tree) to calculate the cost effectively fenwick_tree = FenwickTree(n) total_cost = 0 for original_index, _ in indexed_colors: current_cost = fenwick_tree.range_sum(0, original_index) total_cost += original_index - current_cost fenwick_tree.update(original_index, 1) return total_cost class FenwickTree: def __init__(self, size): self.size = size self.data = [0] * (size + 1) def update(self, index, value): index += 1 while index <= self.size: self.data[index] += value index += index & -index def prefix_sum(self, index): index += 1 result = 0 while index > 0: result += self.data[index] index -= index & -index return result def range_sum(self, left, right): return self.prefix_sum(right) - self.prefix_sum(left - 1)"},{"question":"import math def discs_intersect(x1, y1, r1, x2, y2, r2): Determine if two discs intersect or touch each other. Args: x1, y1, r1: integer, integer, integer, coordinates of the center and radius of the first disc x2, y2, r2: integer, integer, integer, coordinates of the center and radius of the second disc Returns: string: \\"YES\\" if the discs intersect or touch, otherwise \\"NO\\" from solution import discs_intersect def test_discs_intersect_touching_at_one_point(): assert discs_intersect(0, 0, 5, 7, 0, 5) == \\"YES\\" def test_discs_do_not_intersect(): assert discs_intersect(0, 0, 3, 10, 0, 2) == \\"NO\\" def test_discs_intersect_sharing_more_than_one_point(): assert discs_intersect(1, 1, 4, 4, 5, 2) == \\"YES\\" def test_coincident_centers_intersect(): assert discs_intersect(0, 0, 5, 0, 0, 5) == \\"YES\\" def test_one_disc_inside_another_but_not_touching(): assert discs_intersect(0, 0, 5, 0, 0, 3) == \\"YES\\" def test_one_disc_far_away_from_another(): assert discs_intersect(0, 0, 2, 100, 100, 2) == \\"NO\\" def test_edges_exactly_meet(): assert discs_intersect(0, 0, 3, 6, 0, 3) == \\"YES\\"","solution":"import math def discs_intersect(x1, y1, r1, x2, y2, r2): Determine if two discs intersect or touch each other. Args: x1, y1, r1: integer, integer, integer, coordinates of the center and radius of the first disc x2, y2, r2: integer, integer, integer, coordinates of the center and radius of the second disc Returns: string: \\"YES\\" if the discs intersect or touch, otherwise \\"NO\\" distance_centers = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) if distance_centers <= r1 + r2: return \\"YES\\" else: return \\"NO\\""},{"question":"def good_string(s: str) -> str: Determine if the given string can become a good string by removing exactly one character. A string is defined as a \\"good string\\" if all its characters are distinct and the alphabetical order of characters in the string does not change. Args: s (str): The input string Returns: str: The modified good string if possible, otherwise \\"IMPOSSIBLE\\" Examples: >>> good_string(\\"cabd\\") 'abd' >>> good_string(\\"ddca\\") 'IMPOSSIBLE'","solution":"def good_string(s): n = len(s) # Early return if the string is already a good string if is_good_string(s): return s for i in range(n): modified_string = s[:i] + s[i+1:] if is_good_string(modified_string): return modified_string return \\"IMPOSSIBLE\\" def is_good_string(s): visited = set() for i in range(len(s)): if s[i] in visited: return False visited.add(s[i]) if i > 0 and s[i] < s[i - 1]: return False return True"},{"question":"from typing import List def min_steps_to_treasure(n: int, m: int, grid: List[str]) -> int: Calculate the minimum steps to reach the bottom-right corner of the grid (n-1, m-1) from the top-left corner (0, 0) without passing through obstacles. Parameters: n (int): the number of rows in the grid m (int): the number of columns in the grid grid (List[str]): a list of strings representing the grid Returns: int: The minimum number of steps to reach the destination, or -1 if impossible. Examples: >>> min_steps_to_treasure(3, 4, [\\"TT\\", \\"T#T#\\", \\"TTTT\\"]) 5 >>> min_steps_to_treasure(4, 4, [\\"T\\", \\"#T#\\", \\"#T#\\", \\"\\"]) -1","solution":"from collections import deque def min_steps_to_treasure(n, m, grid): # Directions arrays for moving up, down, left and right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Function to check if a position is valid and not an obstacle def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == 'T' # BFS to find the shortest path queue = deque([(0, 0, 0)]) # (x, y, steps) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() # If we reached the bottom-right corner if x == n - 1 and y == m - 1: return steps # Explore neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) # If no path found, return -1 return -1"},{"question":"def min_cost_path(matrix): Given an MxN matrix where each cell contains a non-negative integer representing the cost to step on that cell, this function returns the minimum cost path from the top-left corner (0,0) to the bottom-right corner (M-1,N-1). >>> min_cost_path([[1, 2, 3], [4, 8, 2], [1, 5, 3]]) 8 >>> min_cost_path([[5]]) 5","solution":"def min_cost_path(matrix): Given an MxN matrix where each cell contains a non-negative integer representing the cost to step on that cell, this function returns the minimum cost path from the top-left corner (0,0) to the bottom-right corner (M-1,N-1). if not matrix or not matrix[0]: return 0 M = len(matrix) N = len(matrix[0]) # Create a 2D dp array to store the minimum cost to reach each cell dp = [[0 for _ in range(N)] for _ in range(M)] # Initialize the dp array dp[0][0] = matrix[0][0] # Initialize the first row for j in range(1, N): dp[0][j] = dp[0][j-1] + matrix[0][j] # Initialize the first column for i in range(1, M): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the dp array for i in range(1, M): for j in range(1, N): dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + matrix[i][j] return dp[M-1][N-1]"},{"question":"def can_make_all_cells_equal(t: int, test_cases: List[Dict[str, Any]]) -> List[str]: Determine if it is possible to make all cells in the grid equal to a given target value X after some sequence of operations. Args: t (int): The number of test cases. test_cases (List[Dict[str, Any]]): A list of dictionaries, each representing a test case. Each dictionary contains: - 'n' (int): The number of rows in the grid. - 'm' (int): The number of columns in the grid. - 'X' (int): The target value for all cells. - 'grid' (List[List[int]]): The n x m grid of non-negative integers. Returns: List[str]: A list of results for each test case. \\"YES\\" if it is possible to make all cells in the grid equal to X, otherwise \\"NO\\". Examples: >>> can_make_all_cells_equal(2, [{'n': 2, 'm': 2, 'X': 0, 'grid': [[1, 1], [1, 1]]}, {'n': 3, 'm': 3, 'X': 2, 'grid': [[2, 3, 2], [3, 2, 3], [2, 3, 2]]}]) ['YES', 'NO'] pass def parse_input(input_data: str) -> Tuple[int, List[Dict[str, Any]]]: Parse the input data into structured test cases. Args: input_data (str): Raw input data as a string. Returns: Tuple[int, List[Dict[str, Any]]]: Number of test cases and a list of structured test cases. Examples: >>> parse_input(\\"2n2 2 0n1 1n1 1n3 3 2n2 3 2n3 2 3n2 3 2n\\") (2, [{'n': 2, 'm': 2, 'X': 0, 'grid': [[1, 1], [1, 1]]}, {'n': 3, 'm': 3, 'X': 2, 'grid': [[2, 3, 2], [3, 2, 3], [2, 3, 2]]}]) pass from typing import List, Dict, Any, Tuple def test_can_make_all_cells_equal(): sample_input = \\"2n2 2 0n1 1n1 1n3 3 2n2 3 2n3 2 3n2 3 2n\\" T, test_cases = parse_input(sample_input) result = can_make_all_cells_equal(T, test_cases) assert result == [\\"YES\\", \\"NO\\"] def test_edge_case_all_zeros(): sample_input = \\"1n3 3 0n0 0 0n0 0 0n0 0 0n\\" T, test_cases = parse_input(sample_input) result = can_make_all_cells_equal(T, test_cases) assert result == [\\"YES\\"] def test_edge_case_single_element(): sample_input = \\"1n1 1 5n5n\\" T, test_cases = parse_input(sample_input) result = can_make_all_cells_equal(T, test_cases) assert result == [\\"YES\\"] def test_large_values_no_possible(): sample_input = \\"1n2 2 1000n999 1001n1002 1003n\\" T, test_cases = parse_input(sample_input) result = can_make_all_cells_equal(T, test_cases) assert result == [\\"NO\\"] def test_large_grid(): sample_input = \\"1n50 50 10n\\" + (\\" \\".join([\\"10\\"] * 50) + \\"n\\") * 50 T, test_cases = parse_input(sample_input) result = can_make_all_cells_equal(T, test_cases) assert result == [\\"YES\\"] def test_no_change_needed(): sample_input = \\"1n3 3 5n5 5 5n5 5 5n5 5 5n\\" T, test_cases = parse_input(sample_input) result = can_make_all_cells_equal(T, test_cases) assert result == [\\"YES\\"] def test_diagonal_possible(): sample_input = \\"1n3 3 5n5 6 5n4 5 6n5 4 5n\\" T, test_cases = parse_input(sample_input) result = can_make_all_cells_equal(T, test_cases) assert result == [\\"NO\\"]","solution":"def can_make_all_cells_equal(t, test_cases): results = [] for test in test_cases: n, m, X, grid = test['n'], test['m'], test['X'], test['grid'] target_diff_count = set() # Store unique differences from target value X for i in range(n): for j in range(m): diff = grid[i][j] - X target_diff_count.add(diff) # If there are zero or one unique differences, it is already uniform or can be made uniform if len(target_diff_count) <= 1: results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Function to parse input and return structured test cases def parse_input(input_data): input_lines = input_data.strip().split('n') T = int(input_lines[0]) test_cases = [] index = 1 for _ in range(T): n, m, X = map(int, input_lines[index].split()) index += 1 grid = [] for _ in range(n): grid.append(list(map(int, input_lines[index].split()))) index += 1 test_cases.append({'n': n, 'm': m, 'X': X, 'grid': grid}) return T, test_cases"},{"question":"def can_transform_to_target_sum(m, n, grid, target_sum): Determine whether it is possible to transform the grid such that the sum of all the elements equals the target sum. Args: m (int): Number of rows in the grid. n (int): Number of columns in the grid. grid (List[List[int]]): The grid consisting of non-negative integers. target_sum (int): The target sum to achieve. Returns: str: \\"YES\\" if it is possible to achieve the target sum, \\"NO\\" otherwise. >>> can_transform_to_target_sum(2, 2, [[1, 2], [3, 4]], 10) 'YES' >>> can_transform_to_target_sum(3, 3, [[5, 5, 5], [5, 5, 5], [5, 5, 5]], 15) 'NO' pass def solve(test_cases): Solve the given test cases for transforming the grids to achieve the target sums. Args: test_cases (List[Dict]): List of test case dictionaries, with \\"dimensions\\" key for grid size and target sum, and \\"grid\\" key for the grid itself. Returns: List[str]: Results for each test case (\\"YES\\" or \\"NO\\"). >>> test_cases = [ ... {\\"dimensions\\": (2, 2, 10), \\"grid\\": [[1, 2], [3, 4]]}, ... {\\"dimensions\\": (3, 3, 15), \\"grid\\": [[5, 5, 5], [5, 5, 5], [5, 5, 5]]}, ... ] >>> solve(test_cases) ['YES', 'NO'] pass","solution":"def can_transform_to_target_sum(m, n, grid, target_sum): current_sum = sum(sum(row) for row in grid) return \\"YES\\" if target_sum % (m * n) == current_sum % (m * n) else \\"NO\\" def solve(test_cases): results = [] for case in test_cases: m, n, S = case[\\"dimensions\\"] grid = case[\\"grid\\"] result = can_transform_to_target_sum(m, n, grid, S) results.append(result) return results"},{"question":"def is_endless_loop(m: int, n: int, s: str) -> str: Determines if an endless loop exists such that the robot revisits a position it has already visited. Parameters: m - number of rows in the grid n - number of columns in the grid s - string of commands Returns: \\"YES\\" if the robot revisits a position, otherwise \\"NO\\". >>> is_endless_loop(3, 3, \\"URDLURD\\") \\"YES\\" >>> is_endless_loop(4, 4, \\"UUDDLLRR\\") \\"YES\\" >>> is_endless_loop(2, 2, \\"ULD\\") \\"NO\\"","solution":"def is_endless_loop(m, n, s): Determines if an endless loop exists such that the robot revisits a position it has already visited. Parameters: m - number of rows in the grid n - number of columns in the grid s - string of commands Returns: \\"YES\\" if the robot revisits a position, otherwise \\"NO\\". # Initial position x, y = 0, 0 # Set to store visited positions visited_positions = {(x, y)} # Command to direction mapping directions = {'U': (0, 1), 'D': (0, -1), 'L': (-1, 0), 'R': (1, 0)} for command in s: dx, dy = directions[command] x += dx y += dy if (x, y) in visited_positions: return \\"YES\\" visited_positions.add((x, y)) return \\"NO\\""},{"question":"def generate_diamond(n): Generates a diamond pattern of stars with N lines. >>> generate_diamond(1) == \\"*\\" >>> generate_diamond(2) == \\" *n* *n *\\" >>> generate_diamond(3) == \\" *n * *n* *n * *n *\\" >>> generate_diamond(4) == \\" *n * *n * *n* *n * *n * *n *\\" >>> generate_diamond(5) == \\" *n * *n * *n * *n* *n * *n * *n * *n *\\" def process_diamond_patterns(T, test_cases): Process multiple diamond patterns for the given test cases. >>> process_diamond_patterns(2, [1, 2]) == \\"*nn *n* *n *\\" >>> process_diamond_patterns(2, [3, 4]) == \\" *n * *n* *n * *n *nn *n * *n * *n* *n * *n * *n *\\" >>> process_diamond_patterns(3, [1, 2, 3]) == \\"*nn *n* *n *nn *n * *n* *n * *n *\\"","solution":"def generate_diamond(n): Generates a diamond pattern of stars with N lines diamond = [] # Top part of the diamond for i in range(n): line = ' ' * (n - i - 1) + '*' if i > 0: line += ' ' * (2 * i - 1) + '*' diamond.append(line) # Bottom part of the diamond for i in range(n - 2, -1, -1): line = ' ' * (n - i - 1) + '*' if i > 0: line += ' ' * (2 * i - 1) + '*' diamond.append(line) return 'n'.join(diamond) def process_diamond_patterns(T, test_cases): results = [] for n in test_cases: results.append(generate_diamond(n)) return 'nn'.join(results)"},{"question":"import itertools from typing import List def tsp_min_distance(n: int, distance_matrix: List[List[int]]) -> int: Determine the minimum travel distance for a traveling salesman to visit all cities exactly once and return to the starting city. Parameters: n (int): Number of cities distance_matrix (List[List[int]]): n x n matrix representing the distances between cities Returns: int: The minimum travel distance >>> tsp_min_distance(4, [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]) 80 >>> tsp_min_distance(3, [[0, 29, 20], [29, 0, 15], [20, 15, 0]]) 64","solution":"import itertools def tsp_min_distance(n, distance_matrix): Returns the minimum travel distance for the Traveling Salesman Problem. # Generate all permutations of city indices to visit (exclude starting city) city_indices = list(range(1, n)) min_distance = float('inf') for perm in itertools.permutations(city_indices): # Calculate the travel distance with the current permutation current_distance = distance_matrix[0][perm[0]] # Starting city to first city in permutation for i in range(len(perm) - 1): current_distance += distance_matrix[perm[i]][perm[i + 1]] current_distance += distance_matrix[perm[-1]][0] # Last city in permutation to starting city # Update minimum distance if current route is shorter if current_distance < min_distance: min_distance = current_distance return min_distance"},{"question":"def shortest_sequence_length(s: str) -> int: Returns the length of the shortest sequence of consecutive characters from the alphabet that includes all characters present in the string s. >>> shortest_sequence_length(\\"abc\\") 3 >>> shortest_sequence_length(\\"zab\\") 26 >>> shortest_sequence_length(\\"dddd\\") 1 >>> shortest_sequence_length(\\"cba\\") 3","solution":"def shortest_sequence_length(s): Returns the length of the shortest sequence of consecutive characters from the alphabet that includes all characters present in the string s. # Get all unique characters in the string and sort them unique_chars = sorted(set(s)) # Find the positions in the alphabet min_char = min(unique_chars) max_char = max(unique_chars) # Calculate the range length = ord(max_char) - ord(min_char) + 1 return length"},{"question":"def min_cost_to_rearrange_deck(n: int, colors: List[int], costs: List[int]) -> int: Returns the minimum cost required to arrange the deck so that no two consecutive cards have the same color. Parameters: n (int): The number of cards in the deck. colors (List[int]): The initial colors of the cards. costs (List[int]): The cost to change the color of each card. Returns: int: The minimum cost to arrange the deck. Examples: >>> min_cost_to_rearrange_deck(3, [1, 1, 2], [10, 50, 30]) 10 >>> min_cost_to_rearrange_deck(4, [3, 3, 3, 3], [5, 5, 5, 5]) 10 from solution import min_cost_to_rearrange_deck def test_min_cost_to_rearrange_deck(): assert min_cost_to_rearrange_deck(1, [1], [10]) == 0 assert min_cost_to_rearrange_deck(2, [1, 1], [10, 20]) == 10 assert min_cost_to_rearrange_deck(3, [1, 1, 2], [10, 50, 30]) == 10 assert min_cost_to_rearrange_deck(4, [3, 3, 3, 3], [5, 5, 5, 5]) == 10 assert min_cost_to_rearrange_deck(3, [1, 2, 3], [10, 20, 30]) == 0 assert min_cost_to_rearrange_deck(5, [2, 2, 2, 2, 2], [10, 10, 10, 10, 10]) == 20","solution":"def min_cost_to_rearrange_deck(n, colors, costs): Returns the minimum cost required to arrange the deck so that no two consecutive cards have the same color. if n == 1: return 0 # No need to change if there's only one card # Initialize dp arrays to track the min cost ending with each color dp_red = [0] * n dp_blue = [0] * n dp_green = [0] * n # Set up the first card's cost dp_red[0] = 0 if colors[0] == 1 else costs[0] dp_blue[0] = 0 if colors[0] == 2 else costs[0] dp_green[0] = 0 if colors[0] == 3 else costs[0] # Fill the dp arrays based on the previous values for i in range(1, n): dp_red[i] = min(dp_blue[i-1], dp_green[i-1]) + (0 if colors[i] == 1 else costs[i]) dp_blue[i] = min(dp_red[i-1], dp_green[i-1]) + (0 if colors[i] == 2 else costs[i]) dp_green[i] = min(dp_red[i-1], dp_blue[i-1]) + (0 if colors[i] == 3 else costs[i]) # The minimum cost is the minimum of the last values in dp arrays return min(dp_red[n-1], dp_blue[n-1], dp_green[n-1])"},{"question":"def min_skill_diff(n: int, m: int, skill_levels: List[int]) -> int: Returns the minimum difference between the highest and lowest skill levels among any selection of m members. >>> min_skill_diff(6, 3, [10, 20, 30, 40, 50, 60]) == 20 >>> min_skill_diff(5, 2, [8, 1, 4, 9, 7]) == 1 from typing import List def test_example_1(): n = 6 m = 3 skill_levels = [10, 20, 30, 40, 50, 60] assert min_skill_diff(n, m, skill_levels) == 20 def test_example_2(): n = 5 m = 2 skill_levels = [8, 1, 4, 9, 7] assert min_skill_diff(n, m, skill_levels) == 1 def test_single_element_selection(): n = 4 m = 1 skill_levels = [3, 1, 4, 1] assert min_skill_diff(n, m, skill_levels) == 0 def test_large_skill_values(): n = 6 m = 3 skill_levels = [1000000000, 999999999, 999999998, 999999997, 999999996, 999999995] assert min_skill_diff(n, m, skill_levels) == 2 def test_all_same_skill_values(): n = 4 m = 2 skill_levels = [5, 5, 5, 5] assert min_skill_diff(n, m, skill_levels) == 0 def test_alternating_numbers(): n = 5 m = 2 skill_levels = [1, 2, 1, 2, 1] assert min_skill_diff(n, m, skill_levels) == 0","solution":"def min_skill_diff(n, m, skill_levels): Returns the minimum difference between the highest and lowest skill levels among any selection of m members. # Sorting the list to efficiently find the minimum difference skill_levels.sort() # Initializing the minimum difference with a large value min_diff = float('inf') # Iterating through the sorted list and finding the minimum difference for i in range(n - m + 1): current_diff = skill_levels[i + m - 1] - skill_levels[i] if current_diff < min_diff: min_diff = current_diff return min_diff"},{"question":"def process_bookings(requests): Processes booking requests and returns a list indicating if each request is 'Accepted' or 'Rejected' based on the current confirmed bookings. Each request consists of three lines: 1. Event name (string) 2. Start time (string in \\"HH:MM\\" format) 3. End time (string in \\"HH:MM\\" format) from solution import process_bookings def test_no_overlap(): requests = [ \\"Concert\\", \\"10:00\\", \\"12:00\\", \\"Conference\\", \\"12:30\\", \\"14:00\\", \\"Yoga_Class\\", \\"15:00\\", \\"16:00\\" ] process_bookings(requests) def test_with_overlap(): requests = [ \\"Concert\\", \\"10:00\\", \\"12:00\\", \\"Basketball_Game\\", \\"11:00\\", \\"13:00\\", \\"Conference\\", \\"12:30\\", \\"14:00\\", \\"Yoga_Class\\", \\"12:00\\", \\"13:00\\", \\"Lunch_Meeting\\", \\"13:00\\", \\"14:00\\" ] process_bookings(requests) def test_edge_cases(): requests = [ \\"Event1\\", \\"10:00\\", \\"11:00\\", \\"Event2\\", \\"11:00\\", \\"12:00\\", \\"Event3\\", \\"10:00\\", \\"11:00\\", \\"Event4\\", \\"09:00\\", \\"10:00\\", \\"Event5\\", \\"08:00\\", \\"09:00\\" ] process_bookings(requests)","solution":"def process_bookings(requests): Processes booking requests and returns a list indicating if each request is 'Accepted' or 'Rejected' based on the current confirmed bookings. Each request consists of three lines: 1. Event name (string) 2. Start time (string in \\"HH:MM\\" format) 3. End time (string in \\"HH:MM\\" format) def time_to_minutes(t): hours, minutes = map(int, t.split(':')) return hours * 60 + minutes events = [] for i in range(0, len(requests), 3): name = requests[i] start_str = requests[i + 1] end_str = requests[i + 2] start = time_to_minutes(start_str) end = time_to_minutes(end_str) overlap = False for event in events: event_start, event_end = event if (start < event_end and end > event_start): overlap = True break if overlap: print(\\"Rejected\\") else: print(\\"Accepted\\") events.append((start, end))"},{"question":"from typing import List, Tuple def is_path_possible(grid: List[List[str]], N: int) -> str: Determine if there exists a path from 'S' to 'E' in a grid. >>> is_path_possible([ ['S', '.', '.'], ['.', '#', '.'], ['.', '.', 'E'] ], 3) == \\"POSSIBLE\\" >>> is_path_possible([ ['S', '.', '.'], ['#', '#', '#'], ['.', '.', 'E'] ], 3) == \\"IMPOSSIBLE\\" def bfs_solve_battlefield(T: int, cases: List[Tuple[int, List[List[str]]]]) -> List[str]: Solve multiple battlefield grid test cases. >>> bfs_solve_battlefield(2, [ (3, [ ['S', '.', '.'], ['.', '#', '.'], ['.', '.', 'E'] ]), (3, [ ['S', '.', '.'], ['#', '#', '#'], ['.', '.', 'E'] ]) ]) == [\\"POSSIBLE\\", \\"IMPOSSIBLE\\"] def test_is_path_possible(): assert is_path_possible([ ['S', '.', '.'], ['.', '#', '.'], ['.', '.', 'E'] ], 3) == \\"POSSIBLE\\" assert is_path_possible([ ['S', '.', '.'], ['#', '#', '#'], ['.', '.', 'E'] ], 3) == \\"IMPOSSIBLE\\" assert is_path_possible([ ['S', '#', '.'], ['#', '.', '#'], ['#', '.', 'E'] ], 3) == \\"IMPOSSIBLE\\" assert is_path_possible([ ['S', '.', '#'], ['.', '.', '.'], ['#', '.', 'E'] ], 3) == \\"POSSIBLE\\" def test_evaluate_grids(): test_cases = [ (3, [ ['S', '.', '.'], ['.', '#', '.'], ['.', '.', 'E'] ]), (3, [ ['S', '.', '.'], ['#', '#', '#'], ['.', '.', 'E'] ]) ] assert bfs_solve_battlefield(2, test_cases) == [\\"POSSIBLE\\", \\"IMPOSSIBLE\\"]","solution":"def is_path_possible(grid, N): from collections import deque def bfs(sx, sy, ex, ey): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(sx, sy)]) visited = set([(sx, sy)]) while queue: x, y = queue.popleft() if (x, y) == (ex, ey): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < N and (nx, ny) not in visited and grid[nx][ny] != '#': queue.append((nx, ny)) visited.add((nx, ny)) return False start = end = None for i in range(N): for j in range(N): if grid[i][j] == 'S': start = (i, j) elif grid[i][j] == 'E': end = (i, j) if not start or not end: return \\"IMPOSSIBLE\\" if bfs(start[0], start[1], end[0], end[1]): return \\"POSSIBLE\\" else: return \\"IMPOSSIBLE\\" def evaluate_grids(grids): results = [] for grid in grids: N = len(grid) result = is_path_possible(grid, N) results.append(result) return results def bfs_solve_battlefield(T, cases): results = [] for i in range(T): N = cases[i][0] grid = cases[i][1] result = is_path_possible(grid, N) results.append(result) return results"},{"question":"def best_representative(n: int, records: List[Tuple[str, int, int]]) -> str: Determine the customer service representative who, on average, managed customer interactions in the shortest amount of time. >>> best_representative(5, [(\\"Alice\\", 3, 6), (\\"Bob\\", 2, 4), (\\"Alice\\", 1, 2), (\\"Bob\\", 3, 5), (\\"Charlie\\", 0, 3)]) \\"Charlie\\" >>> best_representative(1, [(\\"Alice\\", 3, 6)]) \\"Alice\\" >>> best_representative(4, [(\\"Alice\\", 1, 1), (\\"Bob\\", 0, 2), (\\"Alice\\", 2, 0), (\\"Bob\\", 1, 1)]) \\"Alice\\" >>> best_representative(5, [(\\"Alice\\", 3, 6), (\\"Bob\\", 2, 4), (\\"Alice\\", 1, 9), (\\"Bob\\", 3, 7), (\\"Charlie\\", 1, 2)]) \\"Charlie\\" >>> best_representative(3, [(\\"Alice\\", 0, 0), (\\"Bob\\", 0, 0), (\\"Charlie\\", 0, 0)]) \\"Alice\\"","solution":"def best_representative(n, records): from collections import defaultdict import math reps = defaultdict(lambda: [0, 0]) # [total_time, count] for record in records: name, wait, handle = record wait, handle = int(wait), int(handle) total_time = wait + handle reps[name][0] += total_time reps[name][1] += 1 best_rep = None best_avg_time = math.inf for name, (total_time, count) in sorted(reps.items()): avg_time = total_time / count if avg_time < best_avg_time: best_avg_time = avg_time best_rep = name return best_rep"},{"question":"def is_valid_bus_path(n: int, inaccessible_intersections: List[Tuple[int, int]], bus_path: List[Tuple[int, int]]) -> str: Determines if the bus path is valid given the inaccessible intersections. :param n: Maximum number for streets and avenues (0 ≤ n ≤ 100) :param inaccessible_intersections: List of tuples representing inaccessible intersections :param bus_path: List of tuples representing the sequence of intersections in the bus path :return: \\"Valid\\" if the bus path is valid, otherwise \\"Invalid\\" from solution import is_valid_bus_path def test_path_valid(): n = 4 inaccessible_intersections = [(1, 2), (3, 3)] bus_path = [(0, 0), (1, 0), (1, 1), (2, 1)] assert is_valid_bus_path(n, inaccessible_intersections, bus_path) == \\"Valid\\" def test_path_invalid_due_to_inaccessible(): n = 3 inaccessible_intersections = [(0, 1), (1, 1), (2, 1)] bus_path = [(0, 0), (1, 0), (1, 1), (2, 0)] assert is_valid_bus_path(n, inaccessible_intersections, bus_path) == \\"Invalid\\" def test_path_valid_no_inaccessible_intersections(): n = 2 inaccessible_intersections = [] bus_path = [(0, 0), (1, 0), (1, 1), (0, 1)] assert is_valid_bus_path(n, inaccessible_intersections, bus_path) == \\"Valid\\" def test_path_invalid_with_all_inaccessible(): n = 2 inaccessible_intersections = [(0, 0), (1, 0), (1, 1)] bus_path = [(0, 0), (1, 0), (1, 1), (0, 1)] assert is_valid_bus_path(n, inaccessible_intersections, bus_path) == \\"Invalid\\" def test_path_valid_single_intersection(): n = 1 inaccessible_intersections = [(1, 0)] bus_path = [(0, 0)] assert is_valid_bus_path(n, inaccessible_intersections, bus_path) == \\"Valid\\" def test_path_invalid_long_path(): n = 100 inaccessible_intersections = [(99, 99)] bus_path = [(i, i) for i in range(101)] assert is_valid_bus_path(n, inaccessible_intersections, bus_path) == \\"Invalid\\"","solution":"def is_valid_bus_path(n, inaccessible_intersections, bus_path): Determines if the bus path is valid given the inaccessible intersections. :param n: Maximum number for streets and avenues (0 ≤ n ≤ 100) :param inaccessible_intersections: List of tuples representing inaccessible intersections :param bus_path: List of tuples representing the sequence of intersections in the bus path :return: \\"Valid\\" if the bus path is valid, otherwise \\"Invalid\\" inaccessible_set = set(inaccessible_intersections) for intersection in bus_path: if intersection in inaccessible_set: return \\"Invalid\\" return \\"Valid\\""},{"question":"def longest_straight_path(grid: List[List[int]]) -> int: A city is hosting a large marathon event, and you have been assigned to help manage the routes through its grid-based streets. The city is structured like a large grid, with streets running north-south and east-west. Certain streets have been marked as blocked and cannot be used for running. Your task is to help identify the longest possible straight-line running path a participant can take without hitting a blocked street. Given the dimensions of the city grid and the list of blocked streets, determine the length of the longest straight-line path on unblocked streets that can be formed either horizontally or vertically. >>> longest_straight_path([ ... [0, 0, 0, 0, 0], ... [0, 1, 1, 1, 0], ... [0, 1, 0, 1, 0], ... [0, 1, 0, 0, 0], ... [0, 0, 0, 0, 0] ... ]) 5 >>> longest_straight_path([ ... [0, 1, 0], ... [1, 0, 1], ... [0, 1, 0] ... ]) 1 >>> longest_straight_path([ ... [0, 0], ... [0, 0] ... ]) 2 >>> longest_straight_path([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 0 >>> longest_straight_path([ ... [0] ... ]) 1 >>> longest_straight_path([ ... [0, 0], ... [1, 0] ... ]) 2","solution":"def longest_straight_path(grid): m, n = len(grid), len(grid[0]) max_length = 0 for i in range(m): current_length = 0 for j in range(n): if grid[i][j] == 0: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 for j in range(n): current_length = 0 for i in range(m): if grid[i][j] == 0: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"from typing import List def findKthLargest(nums: List[int], k: int) -> int: Finds the k-th largest element in the array nums. Args: nums (List[int]): A list of integers. k (int): The k-th position to find the largest element. Returns: int: The k-th largest element in the array. Examples: >>> findKthLargest([3, 2, 1, 5, 6, 4], 2) 5 >>> findKthLargest([12, 3, 5, 7, 19, 4, 8, 26], 4) 8 >>> findKthLargest([1], 1) 1 >>> findKthLargest([5, 5, 5, 5, 5], 3) 5 >>> findKthLargest([10, 9, 8, 7, 6, 5, 4, 3, 2, 1], 5) 6 >>> findKthLargest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 6) 5 >>> findKthLargest([10, 4, 3, 9, 6, 7, 2, 8, 5, 1], 7) 4","solution":"from typing import List def findKthLargest(nums: List[int], k: int) -> int: Returns the k-th largest element in the array nums. nums.sort(reverse=True) return nums[k-1]"},{"question":"def max_flowers(n: int, m: int, grid: List[List[int]]) -> int: Returns the maximum number of flowers that can be picked from the garden grid such that exactly one flower is picked from each selected row and column. >>> max_flowers(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 15 >>> max_flowers(1, 1, [[5]]) == 5 >>> max_flowers(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 0 >>> max_flowers(2, 3, [[1, 3, 1], [4, 5, 6]]) == 9 >>> max_flowers(3, 3, [[1000, 1000, 1000], [1000, 1000, 1000], [1000, 1000, 1000]]) == 3000 >>> max_flowers(3, 3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 3","solution":"def max_flowers(n, m, grid): Returns the maximum number of flowers that can be picked from the garden grid such that exactly one flower is picked from each selected row and column. max_sum = 0 used_rows = set() used_columns = set() for _ in range(min(n, m)): max_value = -1 max_row, max_col = -1, -1 for i in range(n): if i in used_rows: continue for j in range(m): if j in used_columns: continue if grid[i][j] > max_value: max_value = grid[i][j] max_row, max_col = i, j max_sum += max_value used_rows.add(max_row) used_columns.add(max_col) return max_sum"},{"question":"def min_operations_to_remove(s: str) -> int: Returns the minimum number of operations required to completely remove all characters from the string. >>> min_operations_to_remove(\\"110001111\\") 3 >>> min_operations_to_remove(\\"000\\") 1 >>> min_operations_to_remove(\\"101010\\") 6","solution":"def min_operations_to_remove(s): Returns the minimum number of operations required to completely remove all characters from the string. if not s: return 0 operations = 1 for i in range(1, len(s)): if s[i] != s[i-1]: operations += 1 return operations"},{"question":"def max_loaves(L): Returns the maximum possible total number of loaves that can be distributed, such that each shop receives a distinct positive integer amount in an arithmetic sequence. Args: L: int - the total number of loaves Returns: int - the maximum total number of loaves that can be distributed >>> max_loaves(10) 10 >>> max_loaves(15) 15 def process_test_cases(t, test_cases): Process multiple test cases for the max_loaves function. Args: t: int - number of test cases test_cases: List[int] - list of total numbers of loaves for each test case Returns: List[int] - list of results for each test case >>> process_test_cases(2, [10, 15]) [10, 15] >>> process_test_cases(3, [10, 7, 20]) [10, 6, 15]","solution":"def max_loaves(L): Returns the maximum possible total number of loaves that can be distributed, such that each shop receives a distinct positive integer amount in an arithmetic sequence. loaves = 0 n = 1 while L >= loaves + n: loaves += n n += 1 return loaves def process_test_cases(t, test_cases): results = [] for i in range(t): results.append(max_loaves(test_cases[i])) return results"},{"question":"def count_valleys(n: int, prices: List[int]) -> int: Returns the number of valleys in the given list of stock prices. A valley is defined as a sequence of three consecutive days where the stock price on the first day is greater than the stock price on the second day, and the stock price on the second day is less than the stock price on the third day. Parameters: n (int): The number of days. prices (list of int): The stock prices on each day. Returns: int: The number of valleys. >>> count_valleys(6, [6, 2, 4, 7, 1, 3]) 2 >>> count_valleys(3, [1, 2, 3]) 0","solution":"def count_valleys(n, prices): Returns the number of valleys in the given list of stock prices. Parameters: n (int): The number of days. prices (list of int): The stock prices on each day. Returns: int: The number of valleys. valleys = 0 for i in range(1, n - 1): if prices[i - 1] > prices[i] < prices[i + 1]: valleys += 1 return valleys"},{"question":"from typing import List, Tuple def process_queries(n: int, q: int, k: int, arr: List[int], queries: List[Tuple[int, int, int]]) -> List[str]: You are given a list of n integers a1, a2, ..., an. You have to process q queries. Each query consists of three integers l, r, and x. For each query, you need to determine if the number x appears in the subarray from index l to index r (inclusive) more than k times, where k is a fixed integer given as part of the input. >>> process_queries(5, 3, 1, [1, 2, 3, 2, 1], [(1, 4, 2), (2, 5, 1), (1, 5, 3)]) ['YES', 'NO', 'NO'] >>> process_queries(6, 2, 2, [1, 2, 2, 1, 2, 2], [(1, 6, 2), (3, 6, 1)]) ['YES', 'NO']","solution":"def process_queries(n, q, k, arr, queries): results = [] for l, r, x in queries: subarray = arr[l-1:r] if subarray.count(x) > k: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def is_special_permutation(n, p): Determine if a given permutation is special. >>> is_special_permutation(5, [1, 3, 5, 4, 2]) \\"YES\\" >>> is_special_permutation(4, [1, 2, 3, 4]) \\"NO\\" >>> is_special_permutation(6, [1, 2, 4, 3, 5, 6]) \\"YES\\" >>> is_special_permutation(3, [2, 1, 3]) \\"YES\\" >>> is_special_permutation(3, [3, 2, 1]) \\"NO\\" def process_test_cases(t, test_cases): Process multiple test cases to determine if each permutation is special. >>> process_test_cases(3, [(5, [1, 3, 5, 4, 2]), (4, [1, 2, 3, 4]), (6, [1, 2, 4, 3, 5, 6])]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> process_test_cases(2, [(3, [2, 1, 3]), (3, [3, 2, 1])]) [\\"YES\\", \\"NO\\"] >>> process_test_cases(1, [(1, [1])]) [\\"NO\\"] >>> process_test_cases(1, [(2, [2, 1])]) [\\"YES\\"]","solution":"def is_special_permutation(n, p): for i in range(n): if p[i] == i + 2 or p[i] == i: # i + 2 when 1-indexed becomes i + 1 for 0-indexed return \\"YES\\" return \\"NO\\" def process_test_cases(t, test_cases): results = [] for n, p in test_cases: results.append(is_special_permutation(n, p)) return results # Example usage if __name__ == \\"__main__\\": t = 3 test_cases = [ (5, [1, 3, 5, 4, 2]), (4, [1, 2, 3, 4]), (6, [1, 2, 4, 3, 5, 6]) ] output = process_test_cases(t, test_cases) for result in output: print(result)"},{"question":"def is_leap_year(year: int) -> str: Returns 'YES' if the given year is a leap year, 'NO' otherwise. >>> is_leap_year(2000) 'YES' >>> is_leap_year(1900) 'NO' >>> is_leap_year(2004) 'YES' >>> is_leap_year(1999) 'NO' >>> is_leap_year(1600) 'YES' >>> is_leap_year(2020) 'YES' >>> is_leap_year(1800) 'NO' def leap_years(years: List[int]) -> List[str]: Given a list of years, returns a list indicating whether each year is a leap year. Parameters: years (list): List of integers representing years. Returns: list: List of strings 'YES' or 'NO' indicating leap years. >>> leap_years([2000, 1900, 2004]) ['YES', 'NO', 'YES'] >>> leap_years([1999, 1600, 2020, 1800]) ['NO', 'YES', 'YES', 'NO'] >>> leap_years([2016, 2017, 2018, 2019]) ['YES', 'NO', 'NO', 'NO'] >>> leap_years([2100, 2200, 2300, 2400]) ['NO', 'NO', 'NO', 'YES']","solution":"def is_leap_year(year): Returns 'YES' if the given year is a leap year, 'NO' otherwise. if (year % 400 == 0) or (year % 4 == 0 and year % 100 != 0): return \\"YES\\" else: return \\"NO\\" def leap_years(years): Given a list of years, returns a list indicating whether each year is a leap year. Parameters: years (list): List of integers representing years. Returns: list: List of strings 'YES' or 'NO' indicating leap years. return [is_leap_year(year) for year in years]"},{"question":"def find_pair_with_sum(n: int, arr: List[int], target: int) -> Union[Tuple[int, int], str]: Given an array of integers and a target sum, returns a pair of distinct elements whose sum is equal to the target sum. If such a pair exists, returns the pair in ascending order; otherwise returns \\"No pair found\\". >>> find_pair_with_sum(6, [1, 2, 3, 4, 5, 6], 7) (1, 6) >>> find_pair_with_sum(4, [-1, -2, -3, -4], -5) (-3, -2) >>> find_pair_with_sum(5, [1, 2, 3, 4, 5], 10) 'No pair found'","solution":"def find_pair_with_sum(n, arr, target): Given an array of integers and a target sum, returns a pair of distinct elements whose sum is equal to the target sum. If such a pair exists, returns the pair in ascending order; otherwise returns \\"No pair found\\". seen = set() for number in arr: complement = target - number if complement in seen: return (min(number, complement), max(number, complement)) seen.add(number) return \\"No pair found\\""},{"question":"from typing import List def calculate_minimum_distance(N: int, distance_matrix: List[List[int]]) -> int: Returns the minimum round-trip distance that visits all cities exactly once and returns to the starting city. >>> calculate_minimum_distance(3, [ [0, 10, 15], [10, 0, 20], [15, 20, 0] ]) 45 >>> calculate_minimum_distance(4, [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ]) 80 def route_optimization(data: List[int]) -> List[int]: Parses the input data and returns a list of results for each dataset, each representing the minimum round-trip distance. >>> route_optimization([ 3, \\"0 10 15\\", \\"10 0 20\\", \\"15 20 0\\", 4, \\"0 10 15 20\\", \\"10 0 35 25\\", \\"15 35 0 30\\", \\"20 25 30 0\\", -1 ]) [45, 80]","solution":"from itertools import permutations def calculate_minimum_distance(N, distance_matrix): Returns the minimum round-trip distance that visits all cities exactly once and returns to the starting city. if N == -1 or N == 0: return 0 cities = range(N) min_distance = float('inf') for perm in permutations(cities): current_distance = 0 for i in range(N): current_distance += distance_matrix[perm[i]][perm[(i + 1) % N]] min_distance = min(min_distance, current_distance) return min_distance def route_optimization(data): results = [] index = 0 while index < len(data): N = data[index] if N == -1: break distance_matrix = [] for i in range(1, N + 1): distance_matrix.append(list(map(int, data[index + i].split()))) result = calculate_minimum_distance(N, distance_matrix) results.append(result) index += N + 1 return results"},{"question":"MOD = 1000000007 def solve(test_cases: List[Tuple[str, str]]) -> List[int]: For each test case, returns the count of the subsequences in A that are equal to B. >>> solve([(\\"abc\\", \\"abc\\")]) [1] >>> solve([(\\"abcdabc\\", \\"abc\\")]) [4]","solution":"MOD = 1000000007 def count_subsequences(A, B): Counts the number of subsequences in string A that equal string B. len_a = len(A) len_b = len(B) # dp[i][j] will be storing the number of subsequences of A[0..i-1] # which equals B[0..j-1] dp = [[0] * (len_b + 1) for _ in range(len_a + 1)] # If B is empty, there is exactly one subsequence in A equals to B, which is an empty subsequence. for i in range(len_a + 1): dp[i][0] = 1 for i in range(1, len_a + 1): for j in range(1, len_b + 1): # If current characters in both strings are not the same. if A[i - 1] != B[j - 1]: dp[i][j] = dp[i - 1][j] % MOD else: # If the current character in both the strings are the same # Two cases are considered: dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1]) % MOD return dp[len_a][len_b] def solve(test_cases): results = [] for A, B in test_cases: results.append(count_subsequences(A, B)) return results"},{"question":"def longest_substring_with_one_distinct_char(k: int, s: str) -> int: Determines the length of the longest substring with at most one distinct character after performing at most k operations on the given string. :param k: Maximum number of operations allowed :param s: The given string :return: Length of the longest substring with at most one distinct character >>> longest_substring_with_one_distinct_char(2, 'aabbcc') 4 >>> longest_substring_with_one_distinct_char(0, 'aabbcc') 2 >>> longest_substring_with_one_distinct_char(1, 'aaaa') 4 >>> longest_substring_with_one_distinct_char(2, 'a') 1 >>> longest_substring_with_one_distinct_char(3, 'bbbb') 4 >>> longest_substring_with_one_distinct_char(4, 'abcde') 5 >>> longest_substring_with_one_distinct_char(0, 'abcabcabc') 1 >>> longest_substring_with_one_distinct_char(2, 'abcdef') 3","solution":"def longest_substring_with_one_distinct_char(k, s): Determines the length of the longest substring with at most one distinct character after performing at most k operations on the given string. :param k: Maximum number of operations allowed :param s: The given string :return: Length of the longest substring with at most one distinct character n = len(s) if n == 0: return 0 max_len = 0 start = 0 char_count = {} for end in range(n): char_count[s[end]] = char_count.get(s[end], 0) + 1 max_count = max(char_count.values()) while (end - start + 1) - max_count > k: char_count[s[start]] -= 1 if char_count[s[start]] == 0: del char_count[s[start]] start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"def has_pair_with_sum(array: list, target: int) -> str: Determines if any two distinct numbers in the array sum up to the target. Parameters: array (list of int): The list of integers. target (int): The target sum. Returns: str: \\"Yes\\" if a pair exists, otherwise \\"No\\". >>> has_pair_with_sum([1, 2, 3, 4, 5], 9) \\"Yes\\" >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) \\"No\\" from solution import has_pair_with_sum def test_has_pair_with_sum_found(): assert has_pair_with_sum([1, 2, 3, 4, 5], 9) == \\"Yes\\" assert has_pair_with_sum([2, 7, 11, 15], 9) == \\"Yes\\" assert has_pair_with_sum([-1, -2, -3, -4, -5], -9) == \\"Yes\\" assert has_pair_with_sum([0, 1, 2, 3, 5, 8], 8) == \\"Yes\\" def test_has_pair_with_sum_not_found(): assert has_pair_with_sum([1, 2, 3, 4, 5], 10) == \\"No\\" assert has_pair_with_sum([5, 10, 15, 20], 100) == \\"No\\" assert has_pair_with_sum([-2, -4, -6, -8], -1) == \\"No\\" def test_has_pair_with_sum_edge_cases(): assert has_pair_with_sum([1000000000, -1000000000], 0) == \\"Yes\\" assert has_pair_with_sum([1, 2], 3) == \\"Yes\\" assert has_pair_with_sum([1], 1) == \\"No\\" # Since the array needs at least two elements to form a pair. assert has_pair_with_sum([], 1) == \\"No\\"","solution":"def has_pair_with_sum(array, target): Determines if any two distinct numbers in the array sum up to the target. Parameters: array (list of int): The list of integers. target (int): The target sum. Returns: str: \\"Yes\\" if a pair exists, otherwise \\"No\\". seen = set() for num in array: complement = target - num if complement in seen: return \\"Yes\\" seen.add(num) return \\"No\\""},{"question":"class ActivityTracker: def __init__(self): Initialize the ActivityTracker with the initial data structures to hold status posts, comments, likes, and user activity counts. pass def post_status(self, u, s): User u posts a status update with content s. pass def post_comment(self, u, p, c): User u posts a comment with content c on the status p. pass def like_status(self, u, p): User u likes the status p. pass def unlike_status(self, u, p): User u unlikes the status p. pass def count_user_activities(self, u): Return the total number of activities (posts, comments, likes) that user u has made. pass # Unit tests def test_activity_tracker_initial_activities(): tracker = ActivityTracker() tracker.post_status(1, \\"Hello, world!\\") tracker.post_status(2, \\"Good morning!\\") tracker.post_comment(3, 1, \\"Nice to see you\\") tracker.post_comment(1, 2, \\"Great!\\") tracker.like_status(1, 1) tracker.like_status(3, 2) assert tracker.count_user_activities(1) == 3 assert tracker.count_user_activities(2) == 1 assert tracker.count_user_activities(3) == 2 def test_activity_tracker_new_activities(): tracker = ActivityTracker() tracker.post_status(4, \\"Learning coding\\") tracker.post_comment(1, 3, \\"Welcome!\\") tracker.like_status(2, 3) assert tracker.count_user_activities(4) == 1 assert tracker.count_user_activities(1) == 1 assert tracker.count_user_activities(2) == 1 def test_activity_tracker_unlike_status(): tracker = ActivityTracker() tracker.like_status(1, 1) assert tracker.count_user_activities(1) == 1 tracker.unlike_status(1, 1) assert tracker.count_user_activities(1) == 0 def test_activity_tracker_mixed_activities(): tracker = ActivityTracker() tracker.post_status(1, \\"Status 1\\") tracker.post_status(1, \\"Status 2\\") tracker.post_comment(1, 2, \\"Comment 1\\") tracker.like_status(1, 3) tracker.like_status(1, 3) # should not double count assert tracker.count_user_activities(1) == 4 tracker.unlike_status(1, 3) assert tracker.count_user_activities(1) == 3","solution":"class ActivityTracker: def __init__(self): self.statuses = {} self.comments = {} self.likes = {} self.activity_count = {} def post_status(self, u, s): if u not in self.statuses: self.statuses[u] = [] self.statuses[u].append(s) self._increment_activity_count(u) def post_comment(self, u, p, c): if p not in self.comments: self.comments[p] = [] self.comments[p].append((u, c)) self._increment_activity_count(u) def like_status(self, u, p): if p not in self.likes: self.likes[p] = set() if u not in self.likes[p]: self.likes[p].add(u) self._increment_activity_count(u) def unlike_status(self, u, p): if p in self.likes and u in self.likes[p]: self.likes[p].remove(u) self._decrement_activity_count(u) def count_user_activities(self, u): return self.activity_count.get(u, 0) def _increment_activity_count(self, u): if u not in self.activity_count: self.activity_count[u] = 0 self.activity_count[u] += 1 def _decrement_activity_count(self, u): if u in self.activity_count: self.activity_count[u] -= 1"},{"question":"def can_partition(nums: List[int]) -> bool: Determines if the array can be partitioned into two subsets with equal sum. >>> can_partition([1, 5, 11, 5]) == True >>> can_partition([1, 2, 3, 5]) == False >>> can_partition([1]) == False","solution":"def can_partition(nums): Determines if the array can be partitioned into two subsets with equal sum. total_sum = sum(nums) # If the total sum is odd, we cannot split it into two equal parts. if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # DP array to hold if subset with sum 'i' can be achieved. dp = [False] * (target + 1) dp[0] = True for num in nums: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"def collatz_steps(n: int) -> int: Calculate the number of steps required to reach 1 in the Collatz sequence for the given integer n. Parameters: n (int): The starting integer of the Collatz sequence (1 ≤ n ≤ 10^6) Returns: int: The number of steps to reach 1. >>> collatz_steps(6) 8 >>> collatz_steps(19) 20 >>> collatz_steps(1) 0 >>> collatz_steps(27) 111 >>> collatz_steps(1000000) 152","solution":"def collatz_steps(n: int) -> int: Calculate the number of steps required to reach 1 in the Collatz sequence for the given integer n. Parameters: n (int): The starting integer of the Collatz sequence (1 ≤ n ≤ 10^6) Returns: int: The number of steps to reach 1. steps = 0 while n != 1: if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 steps += 1 return steps"},{"question":"def min_containers(datasets): Determine the minimum number of containers required to store all objects without exceeding the weight limit of any container. >>> datasets = [(4, 10, [2, 3, 5, 8]), (5, 20, [10, 15, 8, 6, 8])] >>> min_containers(datasets) [2, 3] def parse_input(input_str): Parse the input string to extract the datasets. >>> input_str = \\"4 10n2n3n5n8n5 20n10n15n8n6n8n0n\\" >>> parse_input(input_str) [(4, 10, [2, 3, 5, 8]), (5, 20, [10, 15, 8, 6, 8])] def main(input_str): Main function to take input string, parse it, and determine the minimum number of containers required. >>> input_str = \\"4 10n2n3n5n8n5 20n10n15n8n6n8n0n\\" >>> main(input_str) 2 3","solution":"def min_containers(datasets): from bisect import bisect_right results = [] for n, W, weights in datasets: weights.sort() containers = [] for weight in weights: pos = bisect_right(containers, W - weight) if pos != 0: pos -= 1 containers[pos] += weight else: containers.append(weight) results.append(len(containers)) return results def parse_input(input_str): data = input_str.strip().split('n') datasets = [] i = 0 while i < len(data): line = data[i] if line == '0': break n, W = map(int, line.split()) weights = [int(data[j]) for j in range(i + 1, i + 1 + n)] datasets.append((n, W, weights)) i += n + 1 return datasets def main(input_str): datasets = parse_input(input_str) results = min_containers(datasets) for result in results: print(result)"},{"question":"def generate_identifier(first_name, last_name, dob, middle_name=\\"NONE\\"): Generate a unique identifier based on user's name and date of birth. :param first_name: str, user's first name :param last_name: str, user's last name :param dob: str, user's date of birth in the format YYYY-MM-DD :param middle_name: str, user's middle name or \\"NONE\\" :return: str, unique identifier >>> generate_identifier('Alice', 'Smith', '1990-06-15') 'AS19900615' >>> generate_identifier('John', 'Doe', '1985-12-04', 'James') 'JJD19851204' >>> generate_identifier('Jane', 'Doe', '1992-03-22', 'NONE') 'JD19920322' >>> generate_identifier('A', 'B', '2000-01-01', 'C') 'ACB20000101' >>> generate_identifier('E', 'F', '1999-12-31', 'NONE') 'EF19991231'","solution":"def generate_identifier(first_name, last_name, dob, middle_name=\\"NONE\\"): Generate a unique identifier based on user's name and date of birth. :param first_name: str, user's first name :param last_name: str, user's last name :param dob: str, user's date of birth in the format YYYY-MM-DD :param middle_name: str, user's middle name or \\"NONE\\" :return: str, unique identifier identifier = first_name[0] if middle_name != \\"NONE\\": identifier += middle_name[0] identifier += last_name[0] identifier += dob.replace(\\"-\\", \\"\\") return identifier # Example usage: # print(generate_identifier('Alice', 'Smith', '1990-06-15')) # Output: 'AS19900615' # print(generate_identifier('John', 'Doe', '1985-12-04', 'James')) # Output: 'JJD19851204'"},{"question":"def determine_winner(t: int, competitions: List[Tuple[int, List[int], List[int]]]) -> List[str]: Determine the winning team for each competition between The Even Coders and The Odd Coders. Parameters: t (int): The number of competitions. competitions (List[Tuple[int, List[int], List[int]]]): A list of tuples where each tuple contains: - An integer n representing the number of coders in each team. - A list of integers representing the scores of coders in The Even Coders team. - A list of integers representing the scores of coders in The Odd Coders team. Returns: List[str]: The results for each competition, either \\"The Even Coders\\", \\"The Odd Coders\\", or \\"Tie\\". Example: >>> determine_winner(1, [(5, [23, 45, 67, 89, 12], [34, 67, 45, 12, 89])]) [\\"The Odd Coders\\"] >>> determine_winner(1, [(3, [10, 20, 30], [10, 20, 30])]) [\\"Tie\\"] >>> determine_winner(2, [ ... (3, [10, 20, 30], [5, 25, 35]), # The Odd Coders ... (4, [40, 50, 60, 70], [30, 60, 50, 80]) # Tie ... ]) [\\"The Odd Coders\\", \\"Tie\\"]","solution":"def determine_winner(t, competitions): results = [] for competition in competitions: n, even_coders, odd_coders = competition even_coders_points = 0 odd_coders_points = 0 for i in range(n): if even_coders[i] > odd_coders[i]: even_coders_points += 1 elif odd_coders[i] > even_coders[i]: odd_coders_points += 1 if even_coders_points > odd_coders_points: results.append(\\"The Even Coders\\") elif odd_coders_points > even_coders_points: results.append(\\"The Odd Coders\\") else: results.append(\\"Tie\\") return results # Example usage of the function t = 1 competitions = [ (5, [23, 45, 67, 89, 12], [34, 67, 45, 12, 89]) ] # Expect [\\"The Odd Coders\\"] print(determine_winner(t, competitions))"},{"question":"def min_operations_to_turn_off_leds(n: int, s: str) -> int: Determine the minimum number of operations needed to turn all the LEDs off. >>> min_operations_to_turn_off_leds(6, \\"110011\\") 2 >>> min_operations_to_turn_off_leds(4, \\"1111\\") 1 >>> min_operations_to_turn_off_leds(5, \\"10001\\") 2 >>> min_operations_to_turn_off_leds(2, \\"10\\") 1 from solution import min_operations_to_turn_off_leds def test_example_cases(): assert min_operations_to_turn_off_leds(6, \\"110011\\") == 2 assert min_operations_to_turn_off_leds(4, \\"1111\\") == 1 assert min_operations_to_turn_off_leds(5, \\"10001\\") == 2 assert min_operations_to_turn_off_leds(2, \\"10\\") == 1 def test_all_zeros(): assert min_operations_to_turn_off_leds(4, \\"0000\\") == 0 def test_all_ones(): assert min_operations_to_turn_off_leds(5, \\"11111\\") == 1 def test_alternating_ones_and_zeros(): assert min_operations_to_turn_off_leds(6, \\"101010\\") == 3 assert min_operations_to_turn_off_leds(7, \\"0101010\\") == 3 def test_single_led(): assert min_operations_to_turn_off_leds(1, \\"0\\") == 0 assert min_operations_to_turn_off_leds(1, \\"1\\") == 1 def test_no_ones(): assert min_operations_to_turn_off_leds(3, \\"000\\") == 0 def test_no_zeros(): assert min_operations_to_turn_off_leds(3, \\"111\\") == 1","solution":"def min_operations_to_turn_off_leds(n, s): Returns the minimum number of operations needed to turn all the LEDs off. count = 0 within_one_segment = False for char in s: if char == '1' and not within_one_segment: count += 1 within_one_segment = True elif char == '0': within_one_segment = False return count"},{"question":"def min_deletions_to_palindrome(arr): Returns the minimum number of deletions required to make the array a palindrome. >>> min_deletions_to_palindrome([1, 2, 3, 4, 1]) == 2 >>> min_deletions_to_palindrome([3, 3, 3]) == 0 >>> min_deletions_to_palindrome([1, 3, 4, 9, 4, 3, 1]) == 0 >>> min_deletions_to_palindrome([1]) == 0 >>> min_deletions_to_palindrome([2, 2]) == 0 >>> min_deletions_to_palindrome([2, 3]) == 1 >>> min_deletions_to_palindrome([1, 2, 3, 2, 1]) == 0 >>> min_deletions_to_palindrome([10, 20, 30]) == 2","solution":"def min_deletions_to_palindrome(arr): Returns the minimum number of deletions required to make the array a palindrome. n = len(arr) # Create a table to store results of subproblems dp = [[0 for x in range(n)] for y in range(n)] # dp[i][j] will be the minimum number of deletions required to make arr[i..j] a palindrome for gap in range(1, n): l = 0 for h in range(gap, n): if arr[l] == arr[h]: dp[l][h] = dp[l + 1][h - 1] else: dp[l][h] = 1 + min(dp[l][h - 1], dp[l + 1][h]) l += 1 # The result is the minimum number of deletions for the whole array return dp[0][n - 1] def main(): # Read input import sys input = sys.stdin.read data = input().split() n = int(data[0]) array = list(map(int, data[1:])) # Get the result result = min_deletions_to_palindrome(array) # Print the result print(result)"},{"question":"def find_single_element(arr: List[int]) -> int: Finds the element that appears only once in the array where every other element appears exactly twice. >>> find_single_element([4, 3, 2, 4, 1, 3, 2]) 1 >>> find_single_element([10, 1, 1, 2, 2, 3, 3]) 10 >>> find_single_element([1, 2, 2, 3, 3, 4, 1, 5, 4]) 5 >>> find_single_element([99]) 99 >>> find_single_element([1000000000, 500000000, 500000000, 1000000000, 1]) 1 >>> find_single_element([12, 15, 12, 23, 23, 15, 42, 54, 54, 89, 42, 20, 89, 77, 77, 20, 64]) 64","solution":"def find_single_element(arr): Finds the element that appears only once in the array where every other element appears exactly twice. Args: arr (list): A list of integers where each element appears exactly twice except one element. Returns: int: The element that appears only once. unique_element = 0 for num in arr: unique_element ^= num return unique_element"},{"question":"def can_meet_in_maze(t: int, test_cases: List[Tuple[Tuple[int, int], List[List[int]], Tuple[int, int], Tuple[int, int]]]) -> List[str]: Determine if there exists a free cell in the maze where both adventurers can meet starting from their initial positions. Args: t (int): The number of test cases. test_cases (List[Tuple[Tuple[int, int], List[List[int]], Tuple[int, int], Tuple[int, int]]]): A list containing the description of each test case. Each test case consists of: - A tuple (n, m) where n is the number of rows and m is the number of columns of the maze. - A 2D list representing the maze with 0 for free space and -1 for walls. - A tuple (x1, y1) representing the starting coordinates of Alex. - A tuple (x2, y2) representing the starting coordinates of Sam. Returns: List[str]: A list of strings \\"YES\\" or \\"NO\\" for each test case indicating whether a common free cell meeting point exists. Example: >>> t = 3 >>> test_cases = [ >>> ((3, 3), [[0, 0, 0], [0, -1, 0], [0, 0, 0]], (1, 1), (3, 3)), >>> ((3, 3), [[0, 0, 0], [-1, -1, 0], [0, 0, 0]], (1, 1), (3, 3)), >>> ((3, 3), [[0, -1, 0], [-1, -1, -1], [0, 0, 0]], (1, 1), (3, 3)), >>> ] >>> can_meet_in_maze(t, test_cases) [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def can_meet_in_maze(t, test_cases): def bfs(start, maze): n = len(maze) m = len(maze[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = [start] visited = set() visited.add(start) while queue: x, y = queue.pop(0) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and maze[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return visited results = [] for i in range(t): n, m = test_cases[i][0] maze = test_cases[i][1] x1, y1 = test_cases[i][2] x2, y2 = test_cases[i][3] x1, y1 = x1 - 1, y1 - 1 x2, y2 = x2 - 1, y2 - 1 if maze[x1][y1] == -1 or maze[x2][y2] == -1: results.append(\\"NO\\") continue alex_reachable = bfs((x1, y1), maze) sam_reachable = bfs((x2, y2), maze) if alex_reachable & sam_reachable: # Check for intersection results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def largest_contiguous_block(n: int, m: int, grid: List[List[int]]) -> int: Find the size of the largest contiguous block of crops in a farm grid. Args: n (int): The number of rows. m (int): The number of columns. grid (List[List[int]]): The farm grid itself, where 1 represents a crop and 0 represents empty space. Returns: int: The size of the largest contiguous block of crops. Examples: >>> largest_contiguous_block(4, 5, [ ... [1, 0, 0, 1, 0], ... [1, 1, 0, 1, 1], ... [0, 1, 0, 0, 0], ... [1, 0, 0, 0, 1] ... ]) == 4 >>> largest_contiguous_block(3, 3, [ ... [1, 1, 0], ... [0, 1, 0], ... [1, 0, 1] ... ]) == 3 pass","solution":"def largest_contiguous_block(n, m, grid): def dfs(x, y): # Check boundaries if x < 0 or y < 0 or x >= n or y >= m or grid[x][y] == 0: return 0 # Mark visited grid[x][y] = 0 # Initialize block size count size = 1 # Explore all four directions size += dfs(x + 1, y) # Down size += dfs(x - 1, y) # Up size += dfs(x, y + 1) # Right size += dfs(x, y - 1) # Left return size max_block_size = 0 for i in range(n): for j in range(m): if grid[i][j] == 1: current_block_size = dfs(i, j) if current_block_size > max_block_size: max_block_size = current_block_size return max_block_size"},{"question":"def min_toggles(initial, desired): Calculate the minimum number of toggles required to transform the initial light sequence into the desired sequence. :param initial: str, the initial sequence of bulbs (binary string) :param desired: str, the desired sequence of bulbs (binary string) :return: int, the minimum number of toggles required >>> min_toggles(\\"000\\", \\"111\\") 3 >>> min_toggles(\\"101010\\", \\"010101\\") 6 >>> min_toggles(\\"111\\", \\"111\\") 0 >>> min_toggles(\\"0\\", \\"1\\") 1 >>> min_toggles(\\"1100\\", \\"1010\\") 2","solution":"def min_toggles(initial, desired): Calculate the minimum number of toggles required to transform the initial light sequence into the desired sequence. :param initial: str, the initial sequence of bulbs (binary string) :param desired: str, the desired sequence of bulbs (binary string) :return: int, the minimum number of toggles required if len(initial) != len(desired): raise ValueError(\\"Both initial and desired sequences must be of the same length\\") # Calculate the number of differing bits between initial and desired sequences toggles = sum(1 for ini, des in zip(initial, desired) if ini != des) return toggles"},{"question":"def check_subarray_square(t: int, cases: List[Tuple[int, List[int]]]) -> List[str]: Determines whether there exists a subarray with length greater than 1 such that the product of its elements is a perfect square. Args: t (int): Number of test cases. cases (List[Tuple[int, List[int]]]): List of test cases where each test case is a tuple containing an integer N (size of the array) and a list of N integers. Returns: List[str]: List containing \\"YES\\" if such a subarray exists, otherwise \\"NO\\". Example: >>> check_subarray_square(3, [(4, [1, 2, 2, 1]), (3, [3, 4, 2]), (5, [2, 3, 4, 6, 5])]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> check_subarray_square(1, [(2, [0, 0])]) [\\"YES\\"] from typing import List, Tuple def is_perfect_square(x: int) -> bool: Checks if a number x is a perfect square. pass # Implementation goes here def has_subarray_with_square_product(arr: List[int]) -> bool: Determines if there exists a subarray with length greater than 1 such that the product of its elements is a perfect square. pass # Implementation goes here def main(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Processes the list of test cases and returns the results. pass # Implementation goes here return main(t, cases) from solution import check_subarray_square def test_case_1(): t = 3 cases = [ (4, [1, 2, 2, 1]), (3, [3, 4, 2]), (5, [2, 3, 4, 6, 5]) ] expected = [\\"YES\\", \\"NO\\", \\"YES\\"] assert check_subarray_square(t, cases) == expected def test_case_2(): t = 1 cases = [ (2, [0, 0]) ] expected = [\\"YES\\"] assert check_subarray_square(t, cases) == expected def test_case_3(): t = 1 cases = [ (2, [1, 1]) ] expected = [\\"YES\\"] assert check_subarray_square(t, cases) == expected def test_case_4(): t = 2 cases = [ (3, [1, 1, 1]), (3, [1, 2, 2]) ] expected = [\\"YES\\", \\"YES\\"] assert check_subarray_square(t, cases) == expected def test_case_5(): t = 1 cases = [ (4, [-3, -6, -1, -8]) ] expected = [\\"YES\\"] assert check_subarray_square(t, cases) == expected","solution":"def is_perfect_square(x): Checks if a number x is a perfect square. if x < 0: return False root = int(x**0.5) return root * root == x def has_subarray_with_square_product(arr): Determines if there exists a subarray with length greater than 1 such that the product of its elements is a perfect square. from collections import defaultdict n = len(arr) for i in range(n): product = 1 for j in range(i, n): product *= arr[j] if j - i + 1 > 1 and is_perfect_square(product): return True return False def main(t, test_cases): Processes the list of test cases and returns the results. results = [] for case in test_cases: n, arr = case[0], case[1] if has_subarray_with_square_product(arr): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Function used for unit tests def check_subarray_square(t, cases): return main(t, cases)"},{"question":"def longest_consecutive_sequence(arr: List[int]) -> int: Finds the length of the longest consecutive elements sequence. Parameters: arr (list): A list of unique integers. Returns: int: Length of the longest consecutive elements sequence. >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2, 102, 101, 5]) 5 >>> longest_consecutive_sequence([0, 3, 7, 2, 5, 8, 4]) 4 >>> longest_consecutive_sequence([1, 2, 0, 1]) 3 >>> longest_consecutive_sequence([9,1,-1,8,7,10,11,12]) 6 >>> longest_consecutive_sequence([1, 3, 5, 2, 4, 9, 10, 8]) 5 >>> longest_consecutive_sequence([1]) 1 >>> longest_consecutive_sequence([]) 0 >>> longest_consecutive_sequence([10, 5, 15, 20, 25]) 1","solution":"def longest_consecutive_sequence(arr): Finds the length of the longest consecutive elements sequence. Parameters: arr (list): A list of unique integers. Returns: int: Length of the longest consecutive elements sequence. if not arr: return 0 num_set = set(arr) longest_streak = 0 for num in arr: if num - 1 not in num_set: # Check if it is the start of a sequence current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def remove_specific_book(m: int, p: int, books: List[str]) -> List[str]: Remove all instances of the specific book found at position P from the list of books. >>> remove_specific_book(5, 2, [\\"BOOKA\\", \\"BOOKB\\", \\"BOOKC\\", \\"BOOKB\\", \\"BOOKC\\"]) [\\"BOOKA\\", \\"BOOKB\\", \\"BOOKB\\"] >>> remove_specific_book(4, 0, [\\"BOOKA\\", \\"BOOKA\\", \\"BOOKB\\", \\"BOOKC\\"]) [\\"BOOKB\\", \\"BOOKC\\"] pass def main(): import sys input = sys.stdin.read data = input().strip().split() m = int(data[0]) p = int(data[1]) books = data[2:] result_books = remove_specific_book(m, p, books) print(\\" \\".join(result_books))","solution":"def remove_specific_book(m, p, books): specific_book = books[p] result_books = [book for book in books if book != specific_book] return result_books # Function to format the input and output def main(): import sys input = sys.stdin.read data = input().strip().split() m = int(data[0]) p = int(data[1]) books = data[2:] result_books = remove_specific_book(m, p, books) print(\\" \\".join(result_books))"},{"question":"def find_product_pair(arr, x): Determines if there exist two distinct indices i and j in the array such that the product of a[i] and a[j] is equal to x. Parameters: arr (List[int]): The list of integers. x (int): The target product. Returns: bool: True if such a pair exists, False otherwise. Examples: >>> find_product_pair([2, 4, 1, 6, 5], 8) True >>> find_product_pair([3, 7, 11, 5], 15) True >>> find_product_pair([3, 3, 3], 10) False","solution":"def find_product_pair(arr, x): Determines if there exist two distinct indices i and j in the array such that the product of a[i] and a[j] is equal to x. seen = set() for num in arr: if x % num == 0 and (x // num) in seen: return True seen.add(num) return False"},{"question":"def minimize_consecutive_differences(n, arr, k): Rearranges the list such that the difference between any two consecutive integers in the list is as small as possible by performing up to \`k\` swaps. Parameters: n (int): the length of the list arr (list): the list of integers k (int): the maximum number of swaps allowed Returns: list: the rearranged list from solution import minimize_consecutive_differences def test_minimal_differences_basic(): assert minimize_consecutive_differences(5, [4, 3, 2, 1, 5], 1) == [1, 2, 3, 4, 5] def test_minimal_differences_already_sorted(): assert minimize_consecutive_differences(3, [10, 20, 30], 2) == [10, 20, 30] def test_minimal_differences_no_swaps_needed(): assert minimize_consecutive_differences(4, [2, 4, 1, 3], 0) == [1, 2, 3, 4] def test_minimal_differences_max_swaps(): assert minimize_consecutive_differences(6, [6, 5, 4, 3, 2, 1], 10) == [1, 2, 3, 4, 5, 6] def test_minimal_differences_single_element(): assert minimize_consecutive_differences(1, [1], 1) == [1]","solution":"def minimize_consecutive_differences(n, arr, k): Rearranges the list such that the difference between any two consecutive integers in the list is as small as possible by performing up to \`k\` swaps. Parameters: n (int): the length of the list arr (list): the list of integers k (int): the maximum number of swaps allowed Returns: list: the rearranged list # Sorting the array will guarantee minimal differences between consecutive elements sorted_arr = sorted(arr) return sorted_arr"},{"question":"def sort_problems(n: int, problems: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Sorts a list of problems by their difficulty levels. If two problems have the same difficulty, they are sorted by their unique problem identifiers. Parameters: n (int): Number of problems problems (list of tuples): List of tuples where each tuple contains two integers, the difficulty level and unique problem identifier Returns: list of tuples: Sorted list of problems Examples: >>> sort_problems(4, [(5, 2), (3, 1), (5, 1), (4, 3)]) [(3, 1), (4, 3), (5, 1), (5, 2)] >>> sort_problems(3, [(4, 10), (4, 5), (2, 8)]) [(2, 8), (4, 5), (4, 10)] from typing import List, Tuple def test_sort_problems_with_varied_difficulties(): problems = [(5, 2), (3, 1), (5, 1), (4, 3)] sorted_problems = sort_problems(4, problems) assert sorted_problems == [(3, 1), (4, 3), (5, 1), (5, 2)] def test_sort_problems_with_same_difficulties(): problems = [(4, 10), (4, 5), (2, 8)] sorted_problems = sort_problems(3, problems) assert sorted_problems == [(2, 8), (4, 5), (4, 10)] def test_sort_problems_with_multiple_same_difficulties(): problems = [(5, 1), (5, 3), (2, 2), (3, 4), (5, 2)] sorted_problems = sort_problems(5, problems) assert sorted_problems == [(2, 2), (3, 4), (5, 1), (5, 2), (5, 3)] def test_sort_single_problem(): problems = [(1, 1)] sorted_problems = sort_problems(1, problems) assert sorted_problems == [(1, 1)] def test_sort_problems_with_identical_difficulties_and_identifiers(): problems = [(1, 1), (1, 1), (1, 1)] sorted_problems = sort_problems(3, problems) assert sorted_problems == [(1, 1), (1, 1), (1, 1)]","solution":"def sort_problems(n, problems): Sorts a list of problems by their difficulty levels. If two problems have the same difficulty, they are sorted by their unique problem identifiers. Parameters: n (int): Number of problems problems (list of tuples): List of tuples where each tuple contains two integers, the difficulty level and unique problem identifier Returns: list of tuples: Sorted list of problems # Sort problems first by difficulty, then by problem identifier in case of ties sorted_problems = sorted(problems, key=lambda x: (x[0], x[1])) return sorted_problems"},{"question":"from typing import List, Tuple def inventory_management(initial_products: List[Tuple[int, int]], operations: List[str]) -> List[int]: Handle operations that modify and query the status of the inventory. Args: initial_products: List of tuples where each tuple consists of product_id and its initial quantity. operations: List of strings where each string represents an operation (\\"ADD p q\\", \\"REMOVE p q\\", \\"QUERY p\\"). Returns: A list of integers which are the results of the \\"QUERY\\" operations. Examples: >>> inventory_management([(1, 50), (2, 100), (3, 150)], [\\"ADD 1 30\\", \\"REMOVE 2 40\\", \\"QUERY 1\\", \\"QUERY 2\\", \\"QUERY 4\\"]) [80, 60, 0] >>> inventory_management([(5, 100), (10, 50)], [\\"ADD 5 20\\", \\"REMOVE 10 30\\", \\"QUERY 5\\", \\"QUERY 10\\"]) [120, 20]","solution":"def inventory_management(initial_products, operations): inventory = {} # Initialize the inventory with the given initial product quantities for product_id, quantity in initial_products: inventory[product_id] = quantity # Process the operations results = [] for operation in operations: operation = operation.split() command = operation[0] product_id = int(operation[1]) if command == \\"ADD\\": quantity = int(operation[2]) if product_id in inventory: inventory[product_id] += quantity else: inventory[product_id] = quantity elif command == \\"REMOVE\\": quantity = int(operation[2]) if product_id in inventory and inventory[product_id] >= quantity: inventory[product_id] -= quantity elif command == \\"QUERY\\": results.append(inventory.get(product_id, 0)) return results"},{"question":"import heapq from typing import List, Tuple class PriorityQueue: def __init__(self): self.heap = [] self.counter = 0 # This acts like a timestamp to manage FIFO for packets with the same p and t def insert(self, p, t): Inserts a packet with priority p and maximum wait time t. heapq.heappush(self.heap, (-p, t, self.counter)) self.counter += 1 def process(self): Processes the packet with the highest priority and removes it from the queue. Returns a tuple (p, t) where p is the priority and t is the maximum wait time of the processed packet. Returns 'EMPTY' if the queue is empty. if not self.heap: return \\"EMPTY\\" p, t, _ = heapq.heappop(self.heap) return (-p, t) def packet_processing(operations: List[str]) -> List[str]: Processes a list of operations on the priority queue. Args: operations (List[str]): A list of strings representing the operations. Each operation is either \\"INSERT p t\\" or \\"PROCESS\\". Returns: List[str]: A list of results from processing \\"PROCESS\\" operations. Each result is either \\"EMPTY\\" (if the queue was empty) or \\"p t\\". >>> packet_processing([ \\"INSERT 1 20\\", \\"INSERT 2 15\\", \\"PROCESS\\", \\"PROCESS\\", \\"INSERT 2 10\\", \\"INSERT 3 5\\", \\"PROCESS\\" ]) ['2 15', '1 20', '3 5'] >>> packet_processing([ \\"PROCESS\\", \\"INSERT 1 5\\", \\"PROCESS\\", \\"PROCESS\\", \\"INSERT 2 10\\" ]) ['EMPTY', '1 5', 'EMPTY'] pq = PriorityQueue() results = [] for operation in operations: if operation.startswith(\\"INSERT\\"): _, p, t = operation.split() pq.insert(int(p), int(t)) elif operation == \\"PROCESS\\": result = pq.process() if result == \\"EMPTY\\": results.append(result) else: results.append(f\\"{result[0]} {result[1]}\\") return results","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] self.counter = 0 # This acts like a timestamp to manage FIFO for packets with the same p and t def insert(self, p, t): heapq.heappush(self.heap, (-p, t, self.counter)) self.counter += 1 def process(self): if not self.heap: return \\"EMPTY\\" p, t, _ = heapq.heappop(self.heap) return (-p, t) def packet_processing(operations): pq = PriorityQueue() results = [] for operation in operations: if operation.startswith(\\"INSERT\\"): _, p, t = operation.split() pq.insert(int(p), int(t)) elif operation == \\"PROCESS\\": result = pq.process() if result == \\"EMPTY\\": results.append(result) else: results.append(f\\"{result[0]} {result[1]}\\") return results"},{"question":"def longest_unique_substring_length(s: str) -> int: Returns the length of the longest substring with all distinct characters. >>> longest_unique_substring_length(\\"abcabcbb\\") 3 >>> longest_unique_substring_length(\\"bbbbb\\") 1 >>> longest_unique_substring_length(\\"pwwkew\\") 3 ... def process_test_cases(t: int, test_cases: List[str]) -> List[int]: Processes multiple test cases and returns the results. >>> process_test_cases(3, [\\"abcabcbb\\", \\"bbbbb\\", \\"pwwkew\\"]) [3, 1, 3] >>> process_test_cases(2, [\\"aab\\", \\"dvdf\\"]) [2, 3] ...","solution":"def longest_unique_substring_length(s): Returns the length of the longest substring with all distinct characters. n = len(s) char_index = {} max_length = 0 start = 0 for i in range(n): if s[i] in char_index and char_index[s[i]] >= start: start = char_index[s[i]] + 1 max_length = max(max_length, i - start + 1) char_index[s[i]] = i return max_length def process_test_cases(t, test_cases): Processes multiple test cases and returns the results. results = [] for s in test_cases: results.append(longest_unique_substring_length(s)) return results"},{"question":"def check_subarray_sum_exists(T, test_cases): Determines if there is a subarray of consecutive elements that sums up to k. Parameters: T (int): The number of test cases. test_cases (list of tuples): Each tuple contains (n, k, array) Returns: list of str: \\"YES\\" or \\"NO\\" for each test case. pass def test_check_subarray_sum_exists(): # Sample test case 1 T = 2 test_cases = [ (5, 15, [1, 2, 3, 4, 5]), (6, 7, [1, 2, 3, 4, 5, 6]) ] expected_outputs = [\\"YES\\", \\"YES\\"] assert check_subarray_sum_exists(T, test_cases) == expected_outputs # Sample test case 2 T = 1 test_cases = [ (3, 6, [1, 2, 3]) ] expected_outputs = [\\"YES\\"] assert check_subarray_sum_exists(T, test_cases) == expected_outputs # Test case no subarray equals k T = 1 test_cases = [ (4, 10, [1, 2, 3, 1]) ] expected_outputs = [\\"NO\\"] assert check_subarray_sum_exists(T, test_cases) == expected_outputs # Test case with negative numbers T = 1 test_cases = [ (5, 3, [1, -2, 3, -1, 2]) ] expected_outputs = [\\"YES\\"] assert check_subarray_sum_exists(T, test_cases) == expected_outputs # Test case with zero sum T = 1 test_cases = [ (5, 0, [1, 2, -3, 3, -3]) ] expected_outputs = [\\"YES\\"] assert check_subarray_sum_exists(T, test_cases) == expected_outputs # Test case without valid subarray T = 1 test_cases = [ (3, 10, [1, 2, 3]) ] expected_outputs = [\\"NO\\"] assert check_subarray_sum_exists(T, test_cases) == expected_outputs # Larger test case T = 1 test_cases = [ (8, 18, [1, 2, 3, 4, 5, 1, 2, 10]) ] expected_outputs = [\\"YES\\"] assert check_subarray_sum_exists(T, test_cases) == expected_outputs","solution":"def check_subarray_sum_exists(T, test_cases): Determines if there is a subarray of consecutive elements that sums up to k. Parameters: T (int): The number of test cases. test_cases (list of tuples): Each tuple contains (n, k, array) Returns: list of str: \\"YES\\" or \\"NO\\" for each test case. results = [] for n, k, arr in test_cases: found = False current_sum = 0 sum_set = set() for num in arr: current_sum += num if current_sum == k or (current_sum - k) in sum_set: found = True break sum_set.add(current_sum) if found: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def process_tickets(n: int, tickets: List[Tuple[int, int, str]]) -> List[Tuple[int, int, str]]: Processes the list of tickets based on the priority rules and prints them in the order they should be handled. Args: n: int - number of tickets. tickets: List[Tuple[int, int, str]] - list of tickets where each ticket is represented as (priority, submission_time, type). Returns: List[Tuple[int, int, str]]: List of tickets in the order they should be processed. Example: >>> n = 5 >>> tickets = [(3, 100, 'Bug'), (2, 90, 'Feature'), (1, 110, 'Bug'), (5, 120, 'Support'), (4, 105, 'Feature')] >>> result = process_tickets(n, tickets) >>> for ticket in result: print(ticket) (1, 110, Bug) (3, 100, Bug) (2, 90, Feature) (4, 105, Feature) (5, 120, Support) pass # Test cases def test_sorted_tickets(): n = 5 tickets = [ (3, 100, 'Bug'), (2, 90, 'Feature'), (1, 110, 'Bug'), (5, 120, 'Support'), (4, 105, 'Feature') ] expected_result = [ (1, 110, 'Bug'), (3, 100, 'Bug'), (2, 90, 'Feature'), (4, 105, 'Feature'), (5, 120, 'Support') ] assert process_tickets(n, tickets) == expected_result def test_same_priority_and_time(): n = 3 tickets = [ (2, 100, 'Feature'), (2, 100, 'Bug'), (2, 100, 'Support') ] expected_result = [ (2, 100, 'Bug'), (2, 100, 'Feature'), (2, 100, 'Support') ] assert process_tickets(n, tickets) == expected_result def test_all_bugs(): n = 3 tickets = [ (5, 200, 'Bug'), (3, 100, 'Bug'), (1, 150, 'Bug') ] expected_result = [ (1, 150, 'Bug'), (3, 100, 'Bug'), (5, 200, 'Bug') ] assert process_tickets(n, tickets) == expected_result def test_single_ticket(): n = 1 tickets = [(1, 90, 'Support')] expected_result = [(1, 90, 'Support')] assert process_tickets(n, tickets) == expected_result def test_multiple_types_with_different_priorities(): n = 4 tickets = [ (1, 50, 'Support'), (5, 20, 'Bug'), (4, 60, 'Feature'), (2, 40, 'Bug') ] expected_result = [ (2, 40, 'Bug'), (5, 20, 'Bug'), (4, 60, 'Feature'), (1, 50, 'Support') ] assert process_tickets(n, tickets) == expected_result","solution":"def process_tickets(n, tickets): Processes the list of tickets based on the priority rules and prints them in the order they should be handled. Args: n: int - number of tickets. tickets: List[Tuple[int, int, str]] - list of tickets where each ticket is represented as (priority, submission_time, type). Returns: List[Tuple[int, int, str]]: List of tickets in the order they should be processed. # Create a sorting key for the tickets type_priority = {'Bug': 0, 'Feature': 1, 'Support': 2} # Sort tickets based on custom rules: # - Type in the order: Bug, Feature, Support # - Priority (higher priority comes first) # - Submission time (earlier submission comes first) sorted_tickets = sorted(tickets, key=lambda ticket: (type_priority[ticket[2]], ticket[0], ticket[1])) return sorted_tickets # Example usage: n = 5 tickets = [ (3, 100, 'Bug'), (2, 90, 'Feature'), (1, 110, 'Bug'), (5, 120, 'Support'), (4, 105, 'Feature') ] result = process_tickets(n, tickets) for ticket in result: print(ticket)"},{"question":"def longest_streak(n: int, distances: List[int], K: int) -> int: Returns the longest streak of consecutive days where Aiko ran at least K kilometers. >>> longest_streak(7, [5, 3, 2, 6, 7, 1, 5], 5) 2 >>> longest_streak(10, [8, 8, 3, 4, 8, 8, 8, 8, 2, 2], 8) 4","solution":"def longest_streak(n, distances, K): Returns the longest streak of consecutive days where Aiko ran at least K kilometers. :param n: int, number of days :param distances: List[int], kilometers ran each day :param K: int, minimum kilometers to count for the streak :return: int, longest streak of consecutive days max_streak = 0 current_streak = 0 for distance in distances: if distance >= K: current_streak += 1 if current_streak > max_streak: max_streak = current_streak else: current_streak = 0 return max_streak"},{"question":"def minimum_scans(m: int, n: int, k: int, forest: List[str]) -> int: Determines the minimum number of scans required to cover the entire forest grid. Parameters: m (int): Number of rows in the forest grid n (int): Number of columns in the forest grid k (int): Dimension of the scanning device (k x k) forest (List[str]): The forest grid layout Returns: int: Minimum number of scans required >>> minimum_scans(5, 6, 3, [\\"......\\", \\"....\\", \\".#..#.\\", \\".#..\\", \\"......\\"]) 4 >>> minimum_scans(4, 4, 2, [\\"..#.\\", \\".#..\\", \\"#..#\\", \\".#.#\\"]) 4 >>> minimum_scans(3, 3, 3, [\\"...\\", \\"...\\", \\"...\\"]) 1 >>> minimum_scans(7, 5, 3, [\\".....\\", \\"..#..\\", \\".....\\", \\"#....\\", \\".....\\", \\"...#.\\", \\".....\\"]) 6 >>> minimum_scans(10, 10, 4, [\\"..........\\", \\"..........\\", \\"..........\\", \\"..........\\", \\"..........\\", \\"..........\\", \\"..........\\", \\"..........\\", \\"..........\\", \\"..........\\"]) 9","solution":"def minimum_scans(m, n, k, forest): Determines the minimum number of scans required to cover the entire forest grid. Parameters: m (int): Number of rows in the forest grid n (int): Number of columns in the forest grid k (int): Dimension of the scanning device (k x k) forest (List[str]): The forest grid layout Returns: int: Minimum number of scans required # Number of scans required along the rows and columns scans_along_rows = (m + k - 1) // k scans_along_cols = (n + k - 1) // k # Total minimum number of scans required total_scans = scans_along_rows * scans_along_cols return total_scans # Example usage: # m, n, k = 5, 6, 3 # forest = [ # \\"......\\", # \\"....\\", # \\".#..#.\\", # \\".#..\\", # \\"......\\" # ] # print(minimum_scans(m, n, k, forest)) # Output: 4"},{"question":"def largest_connected_component(grid): Find the size of the largest connected component of land cells in the given grid. Each cell in the grid is marked either as land ('L') or water ('W'). >>> largest_connected_component([ ... ['L', 'L', 'W', 'L'], ... ['W', 'L', 'L', 'L'], ... ['L', 'W', 'W', 'W'] ... ]) 6 def process_input(data): Process the input data and find the size of the largest connected component of land cells for each dataset. The input contains multiple datasets, ending with a single line containing '-1'. >>> process_input([ ... \\"3 4\\", ... \\"LLWL\\", ... \\"WLLL\\", ... \\"LWWW\\", ... \\"2 5\\", ... \\"LLWLL\\", ... \\"WLWLW\\", ... \\"-1\\" ... ]) [6, 3] import pytest from solution import process_input, largest_connected_component def test_largest_connected_component_single(): grid = [ ['L', 'L', 'W', 'L'], ['W', 'L', 'L', 'L'], ['L', 'W', 'W', 'W'] ] assert largest_connected_component(grid) == 6 def test_largest_connected_component_multiple(): data = [ \\"3 4\\", \\"LLWL\\", \\"WLLL\\", \\"LWWW\\", \\"2 5\\", \\"LLWLL\\", \\"WLWLW\\", \\"-1\\" ] expected = [6, 3] assert process_input(data) == expected def test_largest_connected_component_all_land(): grid = [ ['L', 'L'], ['L', 'L'] ] assert largest_connected_component(grid) == 4 def test_largest_connected_component_no_land(): grid = [ ['W', 'W'], ['W', 'W'] ] assert largest_connected_component(grid) == 0 def test_largest_connected_component_single_land(): grid = [ ['W', 'L'], ['W', 'W'] ] assert largest_connected_component(grid) == 1 # To run the tests, you can use pytest: # pytest -v","solution":"def largest_connected_component(grid): def dfs(x, y): stack = [(x, y)] size = 0 while stack: cx, cy = stack.pop() if 0 <= cx < N and 0 <= cy < M and grid[cx][cy] == 'L': grid[cx][cy] = 'V' # Mark cell as visited size += 1 # Explore adjacent cells for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: stack.append((cx + dx, cy + dy)) return size N = len(grid) M = len(grid[0]) if N > 0 else 0 max_size = 0 for i in range(N): for j in range(M): if grid[i][j] == 'L': max_size = max(max_size, dfs(i, j)) return max_size def process_input(data): index = 0 results = [] while index < len(data): line = data[index].strip() if line == '-1': break N, M = map(int, line.split()) grid = [] for i in range(1, N + 1): grid.append(list(data[index + i].strip())) results.append(largest_connected_component(grid)) index += N + 1 return results"},{"question":"def can_partition(nums): Returns True if the list can be partitioned into two subsets with equal sum. >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False def list_partition(T, lists): Given the number of test cases and their respective lists, returns a list of results. Each result is either \\"True\\" or \\"False\\" indicating if equal partitioning is possible. >>> list_partition(2, [[1, 5, 11, 5], [1, 2, 3, 5]]) [\\"True\\", \\"False\\"] >>> list_partition(1, [[1, 1, 1, 1, 1, 1]]) [\\"True\\"]","solution":"def can_partition(nums): Returns True if the list can be partitioned into two subsets with equal sum. total_sum = sum(nums) # If the total sum is odd, partitioning into two equal subsets is impossible if total_sum % 2 != 0: return False subset_sum = total_sum // 2 dp = [False] * (subset_sum + 1) dp[0] = True for num in nums: for j in range(subset_sum, num - 1, -1): dp[j] |= dp[j - num] return dp[subset_sum] def list_partition(T, lists): Given the number of test cases and their respective lists, returns a list of results. Each result is either \\"True\\" or \\"False\\" indicating if equal partitioning is possible. results = [] for nums in lists: results.append(str(can_partition(nums))) return results"},{"question":"def min_operations_to_make_equal(s: str) -> int: Returns the minimum number of operations required to make all characters in the string equal. :param s: A string consisting of lowercase alphabets :return: Minimum number of operations >>> min_operations_to_make_equal(\\"abca\\") 2 >>> min_operations_to_make_equal(\\"a\\") 0 >>> min_operations_to_make_equal(\\"aaaa\\") 0 >>> min_operations_to_make_equal(\\"abcde\\") 4 >>> min_operations_to_make_equal(\\"aabbbcccc\\") 5","solution":"def min_operations_to_make_equal(s): Returns the minimum number of operations required to make all characters in the string equal. :param s: A string consisting of lowercase alphabets :return: Minimum number of operations from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Find the character with maximum frequency max_freq = max(char_count.values()) # The minimum operations required is the length of string minus the maximum frequency min_operations = len(s) - max_freq return min_operations"},{"question":"def max_profit(prices): Calculates the maximum profit by making at most two transactions on the given stock prices. >>> max_profit([3, 3, 5, 0, 0, 3, 1, 4]) 6 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([7, 1, 5]) 4 >>> max_profit([7, 6, 4, 3]) 0 >>> max_profit([]) 0 >>> max_profit([1]) 0 >>> max_profit([3, 3, 7, 1, 5, 1, 5]) 8 >>> max_profit([5, 4, 3, 2, 1]) 0","solution":"def max_profit(prices): Calculates the maximum profit by making at most two transactions on the given stock prices. if not prices or len(prices) < 2: return 0 # Initialize the variables for tracking the profit. first_buy = second_buy = float('inf') first_profit = second_profit = 0 for price in prices: first_buy = min(first_buy, price) first_profit = max(first_profit, price - first_buy) second_buy = min(second_buy, price - first_profit) second_profit = max(second_profit, price - second_buy) return second_profit"},{"question":"def are_all_systems_connected(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Returns 'YES' if all planetary systems are fully connected, otherwise 'NO'. >>> are_all_systems_connected(4, 2, [(1, 2), (3, 4)]) \\"NO\\" >>> are_all_systems_connected(4, 3, [(1, 2), (2, 3), (3, 4)]) \\"YES\\" >>> are_all_systems_connected(1, 0, []) \\"YES\\" from typing import List, Tuple def test_all_disconnected(): assert are_all_systems_connected(4, 2, [(1, 2), (3, 4)]) == \\"NO\\" def test_all_connected(): assert are_all_systems_connected(4, 3, [(1, 2), (2, 3), (3, 4)]) == \\"YES\\" def test_single_system(): assert are_all_systems_connected(1, 0, []) == \\"YES\\" def test_disconnected_with_isolated_node(): assert are_all_systems_connected(3, 1, [(1, 2)]) == \\"NO\\" def test_connected_with_extra_links(): assert are_all_systems_connected(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) == \\"YES\\" def test_no_edges(): assert are_all_systems_connected(4, 0, []) == \\"NO\\" def test_large_connected(): assert are_all_systems_connected(100000, 99999, [(i, i+1) for i in range(1, 100000)]) == \\"YES\\" def test_large_disconnected(): assert are_all_systems_connected(100000, 50000, [(i, i+1) for i in range(1, 50000)]) == \\"NO\\"","solution":"def are_all_systems_connected(n, m, edges): Returns 'YES' if all planetary systems are fully connected, otherwise 'NO'. from collections import defaultdict, deque if n == 1: return \\"YES\\" adjacency_list = defaultdict(list) for a, b in edges: adjacency_list[a].append(b) adjacency_list[b].append(a) visited = [False] * (n + 1) def bfs(start_node): queue = deque([start_node]) visited[start_node] = True while queue: node = queue.popleft() for neighbor in adjacency_list[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) start_node = 1 bfs(start_node) return \\"YES\\" if all(visited[1:]) else \\"NO\\""},{"question":"def check_overlap(periods: list[tuple[str, str]]) -> str: Takes a list of study sessions/break periods and checks if any periods overlap. Parameters: periods (list of tuples): List of (start, end) time tuples in HH:MM format. Returns: str: \\"OVERLAP\\" if any periods overlap, otherwise \\"NO OVERLAP\\". >>> check_overlap([(\\"09:00\\", \\"10:30\\"), (\\"10:00\\", \\"11:00\\"), (\\"14:00\\", \\"15:00\\"), (\\"15:00\\", \\"16:00\\")]) \\"OVERLAP\\" >>> check_overlap([(\\"08:00\\", \\"09:00\\"), (\\"09:30\\", \\"10:30\\"), (\\"10:45\\", \\"11:45\\")]) \\"NO OVERLAP\\"","solution":"def check_overlap(periods): Takes a list of study sessions/break periods and checks if any periods overlap. Parameters: periods (list of tuples): List of (start, end) time tuples in HH:MM format. Returns: str: \\"OVERLAP\\" if any periods overlap, otherwise \\"NO OVERLAP\\". # Convert time periods to tuples of minutes since 00:00 time_periods = [] for start, end in periods: start_h, start_m = map(int, start.split(':')) end_h, end_m = map(int, end.split(':')) start_in_minutes = start_h * 60 + start_m end_in_minutes = end_h * 60 + end_m time_periods.append((start_in_minutes, end_in_minutes)) # Sort periods by start time time_periods.sort() # Check for overlaps for i in range(len(time_periods) - 1): if time_periods[i][1] > time_periods[i+1][0]: return \\"OVERLAP\\" return \\"NO OVERLAP\\""},{"question":"def is_valid_parentheses(s: str) -> str: Determines if the input string s is a valid string of parentheses. Returns \\"YES\\" if the string is valid and \\"NO\\" otherwise. >>> is_valid_parentheses(\\"()[]{}\\") == \\"YES\\" >>> is_valid_parentheses(\\"([)]\\") == \\"NO\\" >>> is_valid_parentheses(\\"{[()]}\\") == \\"YES\\"","solution":"def is_valid_parentheses(s): Determines if the input string s is a valid string of parentheses. Returns \\"YES\\" if the string is valid and \\"NO\\" otherwise. stack = [] matching_parentheses = {')': '(', ']': '[', '}': '{'} for char in s: if char in matching_parentheses: top_element = stack.pop() if stack else '#' if matching_parentheses[char] != top_element: return \\"NO\\" else: stack.append(char) return \\"YES\\" if not stack else \\"NO\\""},{"question":"def determine_dominant_hand(wall: str, direction: str) -> str: Determine if a person pressing the elevator knob is right-handed (R) or left-handed (L) based on the wall the knob is on and the direction the elevator is heading. :param wall: The wall where the knob is located (\\"left\\" or \\"right\\") :param direction: The direction the elevator is heading (\\"up\\" or \\"down\\") :return: \\"R\\" if the person is right-handed, \\"L\\" if the person is left-handed >>> determine_dominant_hand(\\"left\\", \\"up\\") \\"R\\" >>> determine_dominant_hand(\\"left\\", \\"down\\") \\"L\\" >>> determine_dominant_hand(\\"right\\", \\"up\\") \\"L\\" >>> determine_dominant_hand(\\"right\\", \\"down\\") \\"R\\" from solution import determine_dominant_hand def test_left_and_up(): assert determine_dominant_hand(\\"left\\", \\"up\\") == \\"R\\" def test_left_and_down(): assert determine_dominant_hand(\\"left\\", \\"down\\") == \\"L\\" def test_right_and_up(): assert determine_dominant_hand(\\"right\\", \\"up\\") == \\"L\\" def test_right_and_down(): assert determine_dominant_hand(\\"right\\", \\"down\\") == \\"R\\" def test_invalid_wall(): try: determine_dominant_hand(\\"middle\\", \\"up\\") assert False, \\"Expected ValueError\\" except ValueError: assert True def test_invalid_direction(): try: determine_dominant_hand(\\"left\\", \\"sideways\\") assert False, \\"Expected ValueError\\" except ValueError: assert True","solution":"def determine_dominant_hand(wall, direction): Determine if a person pressing the elevator knob is right-handed (R) or left-handed (L) based on the wall the knob is on and the direction the elevator is heading. :param wall: The wall where the knob is located (\\"left\\" or \\"right\\") :param direction: The direction the elevator is heading (\\"up\\" or \\"down\\") :return: \\"R\\" if the person is right-handed, \\"L\\" if the person is left-handed if wall == \\"left\\" and direction == \\"up\\": return \\"R\\" elif wall == \\"left\\" and direction == \\"down\\": return \\"L\\" elif wall == \\"right\\" and direction == \\"up\\": return \\"L\\" elif wall == \\"right\\" and direction == \\"down\\": return \\"R\\" else: raise ValueError(\\"Invalid input\\")"},{"question":"def find_smallest_missing_ticket(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given a list of ticket numbers for participants in the first raffle of the day, identify the smallest ticket number that is not yet assigned for each subsequent raffle. Args: t: int - Number of test cases. test_cases: List[Tuple[int, List[int]]] - A list of tuples where each tuple contains: - n (int): Number of participants in the first raffle. - List[int]: Ticket numbers assigned to the participants in the first raffle. Returns: List[int] - The smallest positive ticket number that is not assigned to any participant for each test case. >>> find_smallest_missing_ticket(3, [(5, [1, 2, 3, 4, 5]), (5, [3, 4, 5, 6, 10]), (3, [9, 8, 7])]) [6, 1, 1] >>> find_smallest_missing_ticket(1, [(1, [1])]) [2] >>> find_smallest_missing_ticket(1, [(1000, [i for i in range(1, 1001)])]) [1001]","solution":"def find_smallest_missing_ticket(t, test_cases): results = [] for case in test_cases: n, ticket_numbers = case ticket_set = set(ticket_numbers) i = 1 while i in ticket_set: i += 1 results.append(i) return results"},{"question":"def max_temp_difference(n: int, m: int, temperature_readings: List[List[int]]) -> int: Returns the maximum absolute difference in temperature readings between any two sensors at any hour. :param n: Number of hours :param m: Number of sensors :param temperature_readings: List of lists of hourly temperature readings from all sensors :return: Maximum absolute difference in temperature recordings >>> max_temp_difference(3, 4, [[15, 18, 10, 20], [7, 12, 8, 16], [22, 25, 21, 23]]) 12 >>> max_temp_difference(2, 3, [[30, 40, 35], [32, 33, 36]]) 10 # Implementation here","solution":"def max_temp_difference(n, m, temperature_readings): Returns the maximum absolute difference in temperature readings. :param n: Number of hours :param m: Number of sensors :param temperature_readings: List of lists of hourly temperature readings from all sensors :return: Maximum absolute difference in temperature recordings max_difference = 0 for readings in temperature_readings: max_diff_in_hour = max(readings) - min(readings) max_difference = max(max_difference, max_diff_in_hour) return max_difference"},{"question":"def min_visibility_height(n: int, heights: List[int]) -> int: Determines the minimum visibility height for new buildings that need to be added to the front such that no building is completely obscured. :param n: int - Number of buildings in the list :param heights: list of int - Heights of the buildings :return: int - Minimum height of new buildings to be added Example: >>> min_visibility_height(5, [3, 1, 4, 2, 5]) 6 >>> min_visibility_height(3, [2, 2, 3]) 4 from solution import min_visibility_height def test_case_1(): assert min_visibility_height(5, [3, 1, 4, 2, 5]) == 6 def test_case_2(): assert min_visibility_height(3, [2, 2, 3]) == 4 def test_case_3(): assert min_visibility_height(4, [1, 2, 3, 4]) == 5 def test_case_4(): assert min_visibility_height(1, [100]) == 101 def test_case_5(): assert min_visibility_height(2, [5, 5]) == 6 def test_with_max_height_at_start(): assert min_visibility_height(4, [5, 3, 4, 2]) == 6 def test_with_maximum_possible_values(): assert min_visibility_height(2, [100000, 100000]) == 100001","solution":"def min_visibility_height(n, heights): Determines the minimum visibility height for new buildings that need to be added to the front such that no building is completely obscured. :param n: int - Number of buildings in the list :param heights: list of int - Heights of the buildings :return: int - Minimum height of new buildings to be added max_height = max(heights) return max_height + 1"},{"question":"def generate_primes_upto(n): Generates all prime numbers up to n using the Sieve of Eratosthenes. pass def product_of_primes(k): Returns the product of the first k prime numbers modulo 10^9 + 7. >>> product_of_primes(3) 30 >>> product_of_primes(4) 210 pass def primes_product_for_turns(turns): For a given list of number of turns, returns the product of the prime numbers added to the list after each turn. >>> primes_product_for_turns([3, 4]) [30, 210] >>> primes_product_for_turns([1, 2, 3, 4]) [2, 6, 30, 210] pass if __name__ == '__main__': import sys input = sys.stdin.read data = input().split() T = int(data[0]) turns = [int(data[i]) for i in range(1, T + 1)] results = primes_product_for_turns(turns) for result in results: print(result)","solution":"def generate_primes_upto(n): Generates all prime numbers up to n using the Sieve of Eratosthenes. is_prime = [True] * (n + 1) p = 2 while p * p <= n: if is_prime[p]: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 primes = [p for p in range(2, n + 1) if is_prime[p]] return primes def product_of_primes(k): Returns the product of the first k prime numbers modulo 10^9 + 7. MOD = 10**9 + 7 # We need to make sure that we generate enough primes max_approx = k * (1.5 * (k * 2)) primes = generate_primes_upto(int(max_approx)) product = 1 for i in range(k): product = (product * primes[i]) % MOD return product def primes_product_for_turns(turns): results = [] for k in turns: results.append(product_of_primes(k)) return results # Function to read input def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) turns = [int(data[i]) for i in range(1, T + 1)] results = primes_product_for_turns(turns) for result in results: print(result)"},{"question":"def max_square_matrix_size(W: int, H: int) -> int: Determine the maximum side length of the largest possible square matrix of tulips that can fit within the given rectangular flower bed. Parameters: W (int): The width of the rectangular flower bed. H (int): The height of the rectangular flower bed. Returns: int: The side length of the largest possible square matrix. Examples: >>> max_square_matrix_size(8, 6) 6 >>> max_square_matrix_size(10, 15) 10","solution":"def max_square_matrix_size(W, H): Returns the side length of the largest possible square matrix that can fit within the given W x H rectangular flower bed. return min(W, H)"},{"question":"def is_palindrome(S: str) -> str: Determines if the given string S is a palindrome. A palindrome reads the same forward and backward ignoring spaces, punctuation, and capitalization. Args: S (str): The input string. Returns: str: 'Yes' if S is a palindrome, otherwise 'No'. pass Unit Test: from solution import is_palindrome def test_palindrome_simple(): assert is_palindrome(\\"racecar\\") == \\"Yes\\" def test_palindrome_with_mixed_case(): assert is_palindrome(\\"Aibohphobia\\") == \\"Yes\\" def test_non_palindrome(): assert is_palindrome(\\"hello\\") == \\"No\\" def test_single_character(): assert is_palindrome(\\"a\\") == \\"Yes\\" def test_case_insensitivity(): assert is_palindrome(\\"RaceCar\\") == \\"Yes\\" assert is_palindrome(\\"NooN\\") == \\"Yes\\" def test_edge_cases(): assert is_palindrome(\\"a\\" * 100) == \\"Yes\\" assert is_palindrome(\\"a\\" * 99 + \\"b\\") == \\"No\\"","solution":"def is_palindrome(S): Determines if the given string S is a palindrome. A palindrome reads the same forward and backward ignoring spaces, punctuation, and capitalization. Args: S (str): The input string. Returns: str: 'Yes' if S is a palindrome, otherwise 'No'. # Normalize the string by ignoring case normalized_str = S.lower() # Check if the normalized string reads the same forward and backward if normalized_str == normalized_str[::-1]: return \\"Yes\\" else: return \\"No\\""},{"question":"from typing import List, Tuple def compress(lst: List[str]) -> Tuple[str, str]: Compress a list of strings into a single string using a dynamically chosen non-alphanumeric delimiter. >>> compress([\\"hello\\", \\"world\\", \\"compression\\", \\"test\\"]) ('hello|world|compression|test', '|') >>> compress([\\"special!@#\\", \\"characters%^\\", \\"test*&^\\"]) ('special!@#|characters%^|test*&^', '|') pass def decompress(comp_str: str, delimiter: str) -> List[str]: Decompress a compressed string back into a list of strings using the given delimiter. >>> decompress(\\"hello|world|compression|test\\", '|') ['hello', 'world', 'compression', 'test'] >>> decompress(\\"special!@#|characters%^|test*&^\\", '|') ['special!@#', 'characters%^', 'test*&^'] pass","solution":"from typing import List def compress(lst: List[str]) -> str: Compress a list of strings into a single string using a dynamically chosen non-alphanumeric delimiter. # Start with the '|' delimiter as a candidate delimiter = '|' # Check if the delimiter is already in any of the strings. If so, choose another one. for string in lst: if delimiter in string: # Change to another delimiter delimiter = '~' break return delimiter.join(lst), delimiter def decompress(comp_str: str, delimiter: str) -> List[str]: Decompress a compressed string back into a list of strings using the given delimiter. return comp_str.split(delimiter)"},{"question":"from typing import List, Tuple def longest_increasing_subsequence(arr: List[int]) -> int: Helper function to find the length of the longest increasing subsequence in an array. Parameters: arr (List[int]): The array of integers. Returns: int: The length of the longest increasing subsequence. >>> longest_increasing_subsequence([4, 3, 1]) 1 >>> longest_increasing_subsequence([3, 1, 5, 6]) 3 >>> longest_increasing_subsequence([4, 3, 1, 5, 6, 2]) 3 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence([]) 0 pass def process_queries(n: int, array: List[int], q:int, queries: List[Tuple[int, int]]) -> List[int]: Processes multiple queries to find the longest increasing subsequence length in subarrays. Parameters: n (int): The number of elements in the array. array (List[int]): The array of integers. q (int): The number of queries. queries (List[Tuple[int, int]]): List of tuples where each tuple contains two integers representing query indices. Returns: List[int]: A list of results for each query. >>> process_queries(6, [4, 3, 1, 5, 6, 2], 3, [(1, 3), (2, 5), (1, 6)]) [1, 3, 3] >>> process_queries(5, [1, 2, 3, 4, 5], 2, [(1, 5), (2, 4)]) [5, 3] pass","solution":"def longest_increasing_subsequence(arr): Helper function to find the length of the longest increasing subsequence in an array. if not arr: return 0 dp = [1] * len(arr) for i in range(1, len(arr)): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) def process_queries(n, array, q, queries): results = [] for query in queries: li, ri = query subarray = array[li-1:ri] # Convert 1-based index to 0-based results.append(longest_increasing_subsequence(subarray)) return results"},{"question":"def longest_path_length(N: int, connections: list) -> int: Determines the length of the longest path in the given binary tree. Args: N (int): The number of nodes in the binary tree. connections (list of tuple): Each tuple (P, C) indicates a parent node P and a child node C. Returns: int: The length of the longest path in the binary tree. Examples: >>> longest_path_length(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) 3 >>> longest_path_length(3, [(1, 2), (1, 3)]) 2 >>> longest_path_length(6, [(1, 2), (1, 3), (2, 4), (2, 5), (4, 6)]) 4 # function implementation import pytest def test_example_1(): N = 5 connections = [(1, 2), (1, 3), (3, 4), (3, 5)] assert longest_path_length(N, connections) == 3 def test_example_2(): N = 3 connections = [(1, 2), (1, 3)] assert longest_path_length(N, connections) == 2 def test_example_3(): N = 6 connections = [(1, 2), (1, 3), (2, 4), (2, 5), (4, 6)] assert longest_path_length(N, connections) == 4 def test_single_edge(): N = 2 connections = [(1, 2)] assert longest_path_length(N, connections) == 1 def test_chain(): N = 4 connections = [(1, 2), (2, 3), (3, 4)] assert longest_path_length(N, connections) == 3 def test_balanced_tree(): N = 7 connections = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)] assert longest_path_length(N, connections) == 4 if __name__ == \\"__main__\\": pytest.main()","solution":"def longest_path_length(N, connections): from collections import defaultdict, deque # Create adjacency list representation of the tree tree = defaultdict(list) for P, C in connections: tree[P].append(C) tree[C].append(P) # To find the longest path in the tree, we can use 2 BFS (Breadth First Search) def bfs(start_node): visited = [-1] * (N + 1) queue = deque([start_node]) visited[start_node] = 0 farthest_node = start_node while queue: current = queue.popleft() for neighbor in tree[current]: if visited[neighbor] == -1: queue.append(neighbor) visited[neighbor] = visited[current] + 1 farthest_node = neighbor return farthest_node, visited[farthest_node] # Perform the first BFS from any node, we pick node 1 farthest_node_from_1, _ = bfs(1) # Perform the second BFS from the farthest node found in the first BFS _, diameter = bfs(farthest_node_from_1) return diameter # Helper function to read the input from standard input and call the main function def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) connections = [] for i in range(1, len(data), 2): P = int(data[i]) C = int(data[i+1]) connections.append((P, C)) print(longest_path_length(N, connections)) if __name__ == \\"__main__\\": main()"},{"question":"def process_plant_data(datasets: List[Dict[str, Any]]) -> List[str]: Process plant data to retrieve details of the tallest plant for a specific species. Args: datasets (List[Dict[str, Any]]): List of datasets, each containing information about plants and the species to query. Returns: List[str]: List of strings, each containing the species name, height, and coordinates of the tallest plant for the queried species or \\"not found\\". >>> datasets = [ ... {'n': 3, 'plants': [('oak', 12, 34, 56), ('maple', 15, 78, 90), ('oak', 20, 40, 50)], 'query_species': 'oak'}, ... {'n': 2, 'plants': [('pine', 25, 15, 30), ('pine', 30, 25, 40)], 'query_species': 'pine'}, ... {'n': 1, 'plants': [('cedar', 10, 10, 10)], 'query_species': 'fir'} ... ] >>> process_plant_data(datasets) [\\"oak 20 40 50\\", \\"pine 30 25 40\\", \\"not found\\"] pass # Test Cases def test_process_plant_data(): datasets = [ { 'n': 3, 'plants': [ ('oak', 12, 34, 56), ('maple', 15, 78, 90), ('oak', 20, 40, 50) ], 'query_species': 'oak' }, { 'n': 2, 'plants': [ ('pine', 25, 15, 30), ('pine', 30, 25, 40) ], 'query_species': 'pine' }, { 'n': 1, 'plants': [ ('cedar', 10, 10, 10) ], 'query_species': 'fir' } ] expected_results = [ \\"oak 20 40 50\\", \\"pine 30 25 40\\", \\"not found\\" ] assert process_plant_data(datasets) == expected_results def test_process_plant_data_no_plants(): datasets = [ { 'n': 0, 'plants': [], 'query_species': 'anything' } ] expected_results = [] assert process_plant_data(datasets) == expected_results def test_process_plant_data_single_plant(): datasets = [ { 'n': 1, 'plants': [ ('maple', 10, 15, 20) ], 'query_species': 'maple' } ] expected_results = [\\"maple 10 15 20\\"] assert process_plant_data(datasets) == expected_results def test_process_plant_data_same_height(): datasets = [ { 'n': 3, 'plants': [ ('oak', 12, 34, 56), ('oak', 12, 40, 50), ('maple', 15, 78, 90) ], 'query_species': 'oak' } ] expected_results = [\\"oak 12 34 56\\"] # Since heights are same, any one can be selected assert process_plant_data(datasets) == expected_results","solution":"def process_plant_data(datasets): results = [] for dataset in datasets: n, plants, query_species = dataset['n'], dataset['plants'], dataset['query_species'] if n == 0: break max_height = -1 max_plant = None for plant in plants: species_name, height, x, y = plant height = int(height) if species_name == query_species and height > max_height: max_height = height max_plant = plant if max_plant: results.append(f\\"{max_plant[0]} {max_plant[1]} {max_plant[2]} {max_plant[3]}\\") else: results.append(\\"not found\\") return results # Example input: datasets = [ { 'n': 3, 'plants': [ ('oak', 12, 34, 56), ('maple', 15, 78, 90), ('oak', 20, 40, 50) ], 'query_species': 'oak' }, { 'n': 2, 'plants': [ ('pine', 25, 15, 30), ('pine', 30, 25, 40) ], 'query_species': 'pine' }, { 'n': 1, 'plants': [ ('cedar', 10, 10, 10) ], 'query_species': 'fir' } ] # Process the input results = process_plant_data(datasets) for result in results: print(result)"},{"question":"def generate_magical_sequence(n: int) -> List[int]: Generate the smallest possible magical sequence of length N in non-decreasing order, starting from 1. >>> generate_magical_sequence(1) [1] >>> generate_magical_sequence(2) [1, 2] >>> generate_magical_sequence(3) [1, 1, 2] >>> generate_magical_sequence(4) [1, 1, 1, 2] def solve(t: int, cases: List[int]) -> List[str]: Solve the problem for multiple test cases and return the results. >>> solve(2, [3, 4]) [\\"1 1 2\\", \\"1 1 1 2\\"] >>> solve(3, [1, 2, 5]) [\\"1\\", \\"1 2\\", \\"1 1 1 1 2\\"] >>> solve(1, [1]) [\\"1\\"] >>> solve(1, [2]) [\\"1 2\\"]","solution":"def generate_magical_sequence(n): if n < 1: return -1 sequence = [1] * (n - 1) + [2] if n > 1 else [1] return sequence def solve(t, cases): results = [] for n in cases: sequence = generate_magical_sequence(n) if sequence == -1: results.append(\\"-1\\") else: results.append(\\" \\".join(map(str, sequence))) return results"},{"question":"import re from typing import List def extract_tags(text: str) -> List[str]: Extract all valid tags from the given text post. A valid tag starts with '@' followed by one or more alphanumeric characters (letters and numbers only), and it is not preceded by any character other than a space or the start of the string. Args: text (str): The input text post. Returns: List[str]: A list of distinct strings representing the extracted tags. Examples: >>> extract_tags(\\"Let's welcome our new team members: @john123, @janeDoe! #excited\\") ['john123', 'janeDoe'] >>> extract_tags(\\"Hey @john!\\") ['john'] >>> extract_tags(\\"check this@john, @jane!\\") ['jane'] # Implement the function here","solution":"import re def extract_tags(text): Extracts valid tags from the given text post. A valid tag starts with '@' followed by one or more alphanumeric characters, and it is not preceded by any character other than a space or the start of the string. # Regular expression to match valid tags pattern = r'(?<!S)@(w+)' matches = re.findall(pattern, text) return list(dict.fromkeys(matches)) # Remove duplicates while keeping order # Example usage text = \\"Let's welcome our new team members: @john123, @janeDoe! #excited\\" print(extract_tags(text)) # Output: ['john123', 'janeDoe']"},{"question":"def is_corridor_covered(length: int, sensors: List[Tuple[int, int]]) -> str: Determines if the entire corridor is covered by the sensors. >>> is_corridor_covered(10, [(2, 3), (5, 2), (7, 3)]) == \\"Yes\\" >>> is_corridor_covered(15, [(1, 2), (4, 3), (9, 4), (12, 2)]) == \\"No\\" pass def process_input(input_text: str) -> List[str]: Processes the input text and determines if each dataset's corridor is covered. >>> process_input(\\"10 3n2 3n5 2n7 3nn15 4n1 2n4 3n9 4n12 2nn0 0\\") == [\\"Yes\\", \\"No\\"] >>> process_input(\\"5 2n1 2n4 2nn5 1n1 1nn0 0\\") == [\\"Yes\\", \\"No\\"] pass","solution":"def is_corridor_covered(length, sensors): Determines if the entire corridor is covered by the sensors. Parameters: length (int): Length of the corridor. sensors (list): List of tuples (position, range) of sensors. Returns: str: \\"Yes\\" if the corridor is covered, \\"No\\" otherwise. covered = [0] * (length + 1) for position, range_ in sensors: start = max(0, position - range_) end = min(length, position + range_) for i in range(start, end + 1): covered[i] = 1 return \\"Yes\\" if all(covered) else \\"No\\" def process_input(input_text): Processes the input text and determines if each dataset's corridor is covered. Parameters: input_text (str): Multiline string with multiple datasets. Returns: list: List of \\"Yes\\" or \\"No\\" for each dataset. result = [] datasets = input_text.strip().split('nn') for data in datasets: lines = data.strip().split('n') if lines[0] == '0 0': break length, num_sensors = map(int, lines[0].split()) sensors = [tuple(map(int, line.split())) for line in lines[1:]] result.append(is_corridor_covered(length, sensors)) return result"},{"question":"def longest_arithmetic_subarray(n: int, arr: List[int]) -> int: Given an array of integers, an arithmetic subarray is defined as a subarray that contains at least two elements and the differences between consecutive elements are the same. Your task is to find the length of the longest arithmetic subarray in a given array. >>> longest_arithmetic_subarray(7, [10, 7, 4, 6, 8, 10, 11]) 4 >>> longest_arithmetic_subarray(5, [9, 7, 5, 3, 1]) 5 >>> longest_arithmetic_subarray(10, [1, 3, 5, 7, 9, 11, 13, 15, 10, 5]) 8","solution":"def longest_arithmetic_subarray(n, arr): if n < 2: return 0 longest = 2 current_length = 2 current_diff = arr[1] - arr[0] for i in range(2, n): if arr[i] - arr[i - 1] == current_diff: current_length += 1 else: current_diff = arr[i] - arr[i - 1] current_length = 2 longest = max(longest, current_length) return longest"},{"question":"def min_operations_to_equal(s: str) -> int: Returns the minimum number of operations needed to make all bits in the string equal. A subsequence is derived by deleting some or no elements of the string without changing the order. def min_operations_for_test_cases(t: int, test_cases: List[Tuple[int, str]]) -> List[int]: Processes multiple test cases for the min_operations_to_equal function. Parameters: t (int): the number of test cases. test_cases (List[Tuple[int, str]]): A list of tuples, each containing the length of the binary string and the binary string itself. Returns: List[int]: A list of results for each test case. # Test Cases def test_example_cases(): assert min_operations_for_test_cases(3, [(5, \\"11000\\"), (6, \\"011101\\"), (3, \\"101\\")]) == [1, 2, 1] def test_all_zeros(): # All bits are already 0s, no operations needed assert min_operations_for_test_cases(1, [(4, \\"0000\\")]) == [0] def test_all_ones(): # All bits are already 1s, no operations needed assert min_operations_for_test_cases(1, [(4, \\"1111\\")]) == [0] def test_alternating_bits(): # Requires flipping each segment of 0s and 1s individually assert min_operations_for_test_cases(1, [(4, \\"0101\\")]) == [2] def test_single_bit(): # Single bit string doesn't need any operation assert min_operations_for_test_cases(2, [(1, \\"0\\"), (1, \\"1\\")]) == [0, 0] def test_long_string_single_segment(): # In long strings with a single segment of 1s or 0s, only 1 operation is needed assert min_operations_for_test_cases(2, [(10, \\"1111000000\\"), (10, \\"0000011111\\")]) == [1, 1]","solution":"def min_operations_to_equal(s): Returns the minimum number of operations needed to make all bits in the string equal. A subsequence is derived by deleting some or no elements of the string without changing the order. # Count the number of contiguous segments of '1's count_ones_segments = 0 i = 0 while i < len(s): if s[i] == '1': count_ones_segments += 1 while i < len(s) and s[i] == '1': i += 1 i += 1 # Count the number of contiguous segments of '0's count_zeros_segments = 0 i = 0 while i < len(s): if s[i] == '0': count_zeros_segments += 1 while i < len(s) and s[i] == '0': i += 1 i += 1 # The answer is the minimum of those two counts return min(count_ones_segments, count_zeros_segments) def min_operations_for_test_cases(t, test_cases): results = [] for n, s in test_cases: results.append(min_operations_to_equal(s)) return results"},{"question":"class StringOperations: def __init__(self): self.string = [] def add(self, c): self.string.append(c) def remove(self): if self.string: self.string.pop() def current_string(self): return ''.join(self.string) def process_operations(operations): Perform a series of operations on a string. The operations are: + c: Add character c to the end of the string. - : Remove the last character from the string. ? : Output the current state of the string. >>> process_operations([\\"+ a\\", \\"+ b\\", \\"?\\", \\"-\\", \\"?\\"]) [\\"ab\\", \\"a\\"] >>> process_operations([\\"+ x\\", \\"+ y\\", \\"?\\"]) [\\"xy\\"] output = [] str_ops = StringOperations() for op in operations: if op.startswith('+'): _, c = op.split() str_ops.add(c) elif op == \\"-\\": str_ops.remove() elif op == \\"?\\": output.append(str_ops.current_string()) return output","solution":"class StringOperations: def __init__(self): self.string = [] def add(self, c): self.string.append(c) def remove(self): if self.string: self.string.pop() def current_string(self): return ''.join(self.string) def process_operations(operations): output = [] str_ops = StringOperations() for op in operations: if op.startswith('+'): _, c = op.split() str_ops.add(c) elif op == \\"-\\": str_ops.remove() elif op == \\"?\\": output.append(str_ops.current_string()) return output"},{"question":"def zero_subset_pairs(n: int, pairs: List[Tuple[int, int]]) -> str: Determines if there exists a subset of pairs such that the sum of their product is zero. Args: n : int : Number of pairs pairs : list of tuples : List of tuples where each tuple contains two integers Returns: str : \\"YES\\" if such a subset exists, otherwise \\"NO\\" >>> zero_subset_pairs(3, [(1, 2), (-2, 3), (2, -1)]) \\"YES\\" >>> zero_subset_pairs(2, [(1, 2), (3, 4)]) \\"NO\\" >>> zero_subset_pairs(1, [(0, 10)]) \\"YES\\" >>> zero_subset_pairs(1, [(10, 0)]) \\"YES\\" >>> zero_subset_pairs(1, [(1, 10)]) \\"NO\\" >>> zero_subset_pairs(5, [(1, 2), (-1, 2), (3, -1), (-3, 2), (-1, -2)]) \\"YES\\" >>> zero_subset_pairs(4, [(3, 5), (2, -2), (1, 1), (-1, 1)]) \\"YES\\"","solution":"def zero_subset_pairs(n, pairs): Determines if there exists a subset of pairs such that the sum of their product is zero. Args: n : int : Number of pairs pairs : list of tuples : List of tuples where each tuple contains two integers Returns: str : \\"YES\\" if such a subset exists, otherwise \\"NO\\" from itertools import combinations # Check all subsets for i in range(1, n+1): for subset in combinations(pairs, i): if sum(a * b for a, b in subset) == 0: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List, Tuple def find_most_central_temple(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[int]: In an ancient city, there are several temples connected by roads. The city has an intricate network of roads in such a way that between any two temples, there can be multiple ways to travel. The city planning department has been given the task to make sure each temple can be reachable by all others directly or indirectly. To optimize the resource distribution for temple maintenance, they have decided to categorize the most central temple. A temple is considered most central if it has the smallest maximum distance to all other temples. If there are multiple temples with the same maximum distance, choose the one with the smallest index. Args: t (int): Number of test cases. test_cases (List[Tuple[int, int, List[Tuple[int, int]]]]): A list of test cases where each test case is a tuple containing: - n (int): Number of temples. - m (int): Number of roads. - List[Tuple[int, int]]: List of roads connecting the temples represented as (u, v). Returns: List[int]: The index of the most central temple for each test case. pass # The function implementation goes here def parse_input(input_string: str) -> Tuple[int, List[Tuple[int, int, List[Tuple[int, int]]]]]: Parses the input string to extract the number of test cases and test case details. Args: input_string (str): A string containing the input details. Returns: Tuple[int, List[Tuple[int, int, List[Tuple[int, int]]]]]: The parsed number of test cases and test case details. pass # The function implementation goes here def main(input_string: str): Main function to read the input, process it to find the most central temple for each test case, and print the result. Args: input_string (str): A string containing the input details. t, test_cases = parse_input(input_string) results = find_most_central_temple(t, test_cases) for result in results: print(result) if __name__ == \\"__main__\\": import sys input_string = sys.stdin.read() main(input_string) # Unit tests def test_find_most_central_temple(): input_string = \\"2n4 4n1 2n2 3n3 4n4 1n3 2n1 2n2 3n\\" expected_output = [1, 2] t, test_cases = parse_input(input_string) assert find_most_central_temple(t, test_cases) == expected_output input_string = \\"1n3 3n1 2n2 3n3 1n\\" expected_output = [1] t, test_cases = parse_input(input_string) assert find_most_central_temple(t, test_cases) == expected_output input_string = \\"1n5 4n1 2n2 3n3 4n4 5n\\" expected_output = [3] t, test_cases = parse_input(input_string) assert find_most_central_temple(t, test_cases) == expected_output def test_parse_input(): input_string = \\"2n4 4n1 2n2 3n3 4n4 1n3 2n1 2n2 3n\\" expected_output = (2, [ (4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]), (3, 2, [(1, 2), (2, 3)]) ]) assert parse_input(input_string) == expected_output","solution":"import heapq def find_most_central_temple(t, test_cases): def dijkstra(graph, start): num_vertices = len(graph) distances = [float('inf')] * num_vertices distances[start] = 0 pq = [(0, start)] while pq: curr_distance, u = heapq.heappop(pq) if curr_distance > distances[u]: continue for neighbor, weight in graph[u]: distance = curr_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances def get_most_central_temple(n, edges): graph = [[] for _ in range(n)] for u, v in edges: graph[u - 1].append((v - 1, 1)) graph[v - 1].append((u - 1, 1)) min_max_dist = float('inf') most_central_temple = -1 for i in range(n): distances = dijkstra(graph, i) max_dist = max(distances) if max_dist < min_max_dist: min_max_dist = max_dist most_central_temple = i + 1 elif max_dist == min_max_dist: most_central_temple = min(most_central_temple, i + 1) return most_central_temple results = [] for test_case in test_cases: n, m, edges = test_case results.append(get_most_central_temple(n, edges)) return results def parse_input(input_string): lines = input_string.strip().split('n') t = int(lines[0]) index = 1 test_cases = [] for _ in range(t): n, m = map(int, lines[index].split()) index += 1 edges = [] for __ in range(m): u, v = map(int, lines[index].split()) edges.append((u, v)) index += 1 test_cases.append((n, m, edges)) return t, test_cases def main(input_string): t, test_cases = parse_input(input_string) results = find_most_central_temple(t, test_cases) for result in results: print(result)"},{"question":"def sieve_of_eratosthenes(n: int) -> List[int]: Returns a list of all prime numbers less than or equal to n using the Sieve of Eratosthenes algorithm. >>> sieve_of_eratosthenes(30) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] >>> sieve_of_eratosthenes(10) [2, 3, 5, 7]","solution":"def sieve_of_eratosthenes(n): Returns a list of all prime numbers less than or equal to n using the Sieve of Eratosthenes algorithm. if n < 2: return [] is_prime = [True] * (n + 1) is_prime[0] = is_prime[1] = False for start in range(2, int(n**0.5) + 1): if is_prime[start]: for multiples in range(start*start, n + 1, start): is_prime[multiples] = False return [num for num, prime in enumerate(is_prime) if prime]"},{"question":"def product_queries(n, array, queries): Find the product of elements in the subarray from index l to r (both inclusive) for each query. The product should be returned modulo 10^9 + 7. Args: n (int): Number of elements in the array. array (List[int]): The elements of the array. queries (List[Tuple[int, int]]): Queries containing the indices of the subarray for which to find the product. Returns: List[int]: The product of the subarray from index l to r for each query modulo 10^9 + 7. Example: >>> product_queries(5, [1, 2, 3, 4, 5], [(1, 3), (2, 4), (1, 5)]) [6, 24, 120] >>> product_queries(6, [1, 2, 3, 4, 5, 6], [(1, 6), (2, 5), (1, 4)]) [720, 120, 24]","solution":"MOD = 10**9 + 7 def product_queries(n, array, queries): # Precompute the prefix products modulo MOD prefix_products = [1] * (n + 1) for i in range(1, n + 1): prefix_products[i] = (prefix_products[i - 1] * array[i - 1]) % MOD results = [] for l, r in queries: result = (prefix_products[r] * pow(prefix_products[l - 1], MOD - 2, MOD)) % MOD results.append(result) return results"},{"question":"from typing import List, Tuple def min_operations_to_uniform_color(n: int, colors: List[int]) -> int: Calculate the minimum number of operations needed to make all cells in the array the same color. >>> min_operations_to_uniform_color(5, [1, 1, 2, 2, 1]) 2 >>> min_operations_to_uniform_color(6, [3, 3, 3, 3, 3, 3]) 0 def process_queries(queries: List[Tuple[int, List[int]]]) -> List[int]: Process multiple queries to find the minimum number of operations for each query. >>> process_queries([(5, [1, 1, 2, 2, 1]), (6, [3, 3, 3, 3, 3, 3])]) [2, 0] >>> process_queries([(4, [4, 4, 4, 5]), (7, [1, 2, 3, 4, 5, 6, 7])]) [1, 6] from solution import min_operations_to_uniform_color, process_queries def test_min_operations_to_uniform_color(): assert min_operations_to_uniform_color(5, [1, 1, 2, 2, 1]) == 2 assert min_operations_to_uniform_color(6, [3, 3, 3, 3, 3, 3]) == 0 assert min_operations_to_uniform_color(4, [4, 4, 4, 5]) == 1 assert min_operations_to_uniform_color(7, [1, 2, 3, 4, 5, 6, 7]) == 6 assert min_operations_to_uniform_color(3, [1, 1, 1]) == 0 def test_process_queries(): queries = [ (5, [1, 1, 2, 2, 1]), (6, [3, 3, 3, 3, 3, 3]), ] assert process_queries(queries) == [2, 0] queries = [ (4, [4, 4, 4, 5]), (7, [1, 2, 3, 4, 5, 6, 7]), ] assert process_queries(queries) == [1, 6] queries = [ (3, [1, 1, 1]), ] assert process_queries(queries) == [0]","solution":"def min_operations_to_uniform_color(n, colors): from collections import Counter # Count the frequency of each color color_count = Counter(colors) # Find the maximum frequency max_color_frequency = max(color_count.values()) # Minimum operations is the size of the array minus the frequency of the most common color return n - max_color_frequency def process_queries(queries): results = [] for n, colors in queries: results.append(min_operations_to_uniform_color(n, colors)) return results"},{"question":"def smallest_possible_element(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given multiple test cases, returns the smallest possible value of the remaining element after performing the defined operation on each array. >>> smallest_possible_element(3, [(5, [1, 2, 3, 4, 5]), (3, [8, 1, 4]), (4, [9, 2, 9, 4])]) [15, 13, 24] >>> smallest_possible_element(2, [(4, [5, 5, 5, 5]), (3, [3, 3, 4])]) [20, 10] # Unit tests from solution import smallest_possible_element def test_case_1(): assert smallest_possible_element(3, [ (5, [1, 2, 3, 4, 5]), (3, [8, 1, 4]), (4, [9, 2, 9, 4]) ]) == [15, 13, 24] def test_case_2(): # Testing additional scenarios assert smallest_possible_element(2, [ (4, [5, 5, 5, 5]), (3, [3, 3, 4]) ]) == [20, 10] def test_case_3(): # Only two elements assert smallest_possible_element(1, [ (2, [7, 2]) ]) == [9] def test_case_4(): # All elements are the same assert smallest_possible_element(1, [ (5, [10, 10, 10, 10, 10]) ]) == [50] def test_case_5(): # Large numbers of elements with small values assert smallest_possible_element(1, [ (6, [1, 1, 1, 1, 1, 1]) ]) == [6]","solution":"def smallest_possible_element(t, test_cases): Given multiple test cases, returns the smallest possible value of the remaining element after performing the defined operation on each array. results = [] for test_case in test_cases: n, arr = test_case # The smallest possible value after merging all elements is just the sum of all elements # This follows directly from the problem description and examples. results.append(sum(arr)) return results"},{"question":"def max_subarray_sum(arr: List[int], start: int, end: int) -> int: Returns the maximum sum of a contiguous subarray for the given range (inclusive). >>> max_subarray_sum([1, 3, 2, 5, 1, 1], 0, 2) 6 >>> max_subarray_sum([1, 3, 2, 5, 1, 1], 1, 3) 10 >>> max_subarray_sum([1, 3, 2, 5, 1, 1], 0, 5) 13 >>> max_subarray_sum([1, -1, 2, 3, -7, 4], 0, 5) 5 >>> max_subarray_sum([1, -3, 2, 1, -1, 2], 0, 5) 4 pass def solve(n: int, attendees: List[int], q: int, queries: List[Tuple[int, int]]) -> List[int]: Solves the event management queries for the given attendees array and query ranges. >>> solve(6, [1, 3, 2, 5, 1, 1], 3, [(1, 3), (2, 4), (1, 6)]) [6, 10, 13] >>> solve(5, [1, -1, 3, -2, 2], 2, [(1, 3), (1, 5)]) [3, 3] pass","solution":"def max_subarray_sum(arr, start, end): Returns the maximum sum of contiguous subarray for the given range (inclusive). max_sum = -float('inf') current_sum = 0 for i in range(start, end + 1): current_sum += arr[i] if current_sum > max_sum: max_sum = current_sum if current_sum < 0: current_sum = 0 return max_sum def solve(n, attendees, q, queries): Solves the event management queries for the given attendees array and query ranges. :param n: Number of dates :param attendees: List of integers representing the number of attendees on each date :param q: Number of queries :param queries: List of tuples representing the ranges for each query :return: List of results for each query results = [] for l, r in queries: results.append(max_subarray_sum(attendees, l-1, r-1)) return results"},{"question":"def minimize_diff(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: For each test case, rearrange the array elements to minimize the difference between consecutive elements. Parameters: t (int): Number of test cases (1 ≤ t ≤ 100) test_cases (list of tuples): Each tuple contains n (length of array, 2 ≤ n ≤ 10^5) and the array itself (1 ≤ arr[i] ≤ 10^9). Returns: list of lists: Arrays rearranged to minimize differences for each test case. Example: >>> minimize_diff(1, [(5, [4, 2, 1, 3, 5])]) [[1, 2, 3, 4, 5]] >>> minimize_diff(1, [(6, [10, 12, 8, 9, 15, 5])]) [[5, 8, 9, 10, 12, 15]] # Implementation goes here","solution":"def minimize_diff(t, test_cases): For each test case, sort the array to minimize the difference between consecutive elements. Parameters: t (int): Number of test cases test_cases (list of tuples): Each tuple contains n (length of array) and the array itself. Returns: list of lists: Sorted arrays for each test case. results = [] for i in range(t): n, arr = test_cases[i] arr.sort() results.append(arr) return results # Example Usage # t = 2 # test_cases = [ # (5, [4, 2, 1, 3, 5]), # (6, [10, 12, 8, 9, 15, 5]) # ] # Result should be [[1, 2, 3, 4, 5], [5, 8, 9, 10, 12, 15]]"},{"question":"from typing import List def rotate_90(mat: List[List[int]]) -> List[List[int]]: Rotate the matrix 90 degrees clockwise. >>> rotate_90([[1,2,3], [4,5,6], [7,8,9]]) [[7,4,1], [8,5,2], [9,6,3]] pass def is_rotation(a: List[List[int]], b: List[List[int]]) -> bool: Check if matrix b is a rotation of matrix a by 0, 90, 180, or 270 degrees. >>> is_rotation([[1,2,3], [4,5,6], [7,8,9]], [[1,2,3], [4,5,6], [7,8,9]]) True >>> is_rotation([[1,2,3], [4,5,6], [7,8,9]], [[7,4,1], [8,5,2], [9,6,3]]) True >>> is_rotation([[1,2,3], [4,5,6], [7,8,9]], [[9,8,7], [6,5,4], [3,2,1]]) True >>> is_rotation([[1,2,3], [4,5,6], [7,8,9]], [[3,6,9], [2,5,8], [1,4,7]]) True pass def check_matrix_rotation(m: int, n: int, a: List[List[int]], b: List[List[int]]) -> str: Check if matrix B can be obtained by rotating matrix A 0, 90, 180, or 270 degrees. >>> check_matrix_rotation(3, 3, [[1,2,3], [4,5,6], [7,8,9]], [[7,4,1], [8,5,2], [9,6,3]]) \\"Yes\\" >>> check_matrix_rotation(3, 3, [[1,2,3], [4,5,6], [7,8,9]], [[9,7,8], [6,4,5], [3,1,2]]) \\"No\\" pass","solution":"def rotate_90(mat): return [list(row) for row in zip(*mat[::-1])] def is_rotation(a, b): if a == b: return True rotated_90 = rotate_90(a) if rotated_90 == b: return True rotated_180 = rotate_90(rotated_90) if rotated_180 == b: return True rotated_270 = rotate_90(rotated_180) if rotated_270 == b: return True return False def check_matrix_rotation(m, n, a, b): if is_rotation(a, b): return \\"Yes\\" return \\"No\\""},{"question":"def max_value_from_operations(matrix: List[List[int]]) -> int: Returns the maximum value that can be obtained by performing a series of operations removing either rows or columns from the matrix. Parameters: matrix (list of list of int): 2D list representing the matrix. Returns: int: Maximum value obtained from operations. >>> max_value_from_operations([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 45 >>> max_value_from_operations([ ... [1, 2, 3, 4] ... ]) 10 >>> max_value_from_operations([ ... [1], ... [2], ... [3], ... [4] ... ]) 10 >>> max_value_from_operations([ ... [5] ... ]) 5 >>> max_value_from_operations([ ... [100, 200, 300], ... [400, 500, 600], ... [700, 800, 900], ... [10, 20, 30] ... ]) 4560","solution":"def max_value_from_operations(matrix): Returns the maximum value that can be obtained by performing a series of operations removing either rows or columns from the matrix. Parameters: matrix (list of list of int): 2D list representing the matrix. Returns: int: Maximum value obtained from operations. total_sum = 0 while matrix: # Calculate the sum of each row row_sums = [sum(row) for row in matrix] # Calculate the sum of each column col_sums = [sum(matrix[i][j] for i in range(len(matrix))) for j in range(len(matrix[0]))] # Pick the maximum sum of either rows or columns max_row_sum = max(row_sums) if row_sums else 0 max_col_sum = max(col_sums) if col_sums else 0 if max_row_sum >= max_col_sum: total_sum += max_row_sum max_row_index = row_sums.index(max_row_sum) matrix.pop(max_row_index) else: total_sum += max_col_sum max_col_index = col_sums.index(max_col_sum) for row in matrix: row.pop(max_col_index) return total_sum # Usage Example: # n = 3 # m = 3 # matrix = [ # [1, 2, 3], # [4, 5, 6], # [7, 8, 9] # ] # result = max_value_from_operations(matrix) # Expected: 45"},{"question":"from typing import List, Tuple def diagonal_sums(matrix: List[List[int]]) -> Tuple[int, int]: Calculate the sum of the primary and secondary diagonals of a n x n matrix of integers. >>> diagonal_sums([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) (15, 15) >>> diagonal_sums([ ... [2, 2, 2], ... [2, 2, 2], ... [2, 2, 2] ... ]) (6, 6) def test_example_cases(): matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert diagonal_sums(matrix1) == (15, 15) matrix2 = [ [2, 2, 2], [2, 2, 2], [2, 2, 2] ] assert diagonal_sums(matrix2) == (6, 6) def test_single_value_matrix(): matrix = [[42]] assert diagonal_sums(matrix) == (42, 42) def test_larger_matrix(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] assert diagonal_sums(matrix) == (34, 34) def test_negative_values(): matrix = [ [-1, -2, -3], [-4, -5, -6], [-7, -8, -9] ] assert diagonal_sums(matrix) == (-15, -15) def test_mixed_values(): matrix = [ [-1, 0, 1], [0, -2, 0], [1, 0, -3] ] assert diagonal_sums(matrix) == (-6, 0)","solution":"from typing import List, Tuple def diagonal_sums(matrix: List[List[int]]) -> Tuple[int, int]: n = len(matrix) primary_diagonal_sum = 0 secondary_diagonal_sum = 0 for i in range(n): primary_diagonal_sum += matrix[i][i] secondary_diagonal_sum += matrix[i][n - 1 - i] return (primary_diagonal_sum, secondary_diagonal_sum)"},{"question":"def max_deliveries(drones: int, drone_limits: List[int], planets: List[List[int]]) -> int: Determine the maximum number of package deliveries that can be made with the available drones. >>> max_deliveries(5, [4, 8, 2, 6, 3], [[5, 2, 8], [1, 7, 3, 2]]) 5 >>> max_deliveries(4, [5, 5, 5, 5], [[4, 4], [1, 5, 9], [2, 2]]) 4","solution":"def max_deliveries(drones, drone_limits, planets): # Combine all packages into a single list. all_packages = [] for planet in planets: all_packages.extend(planet) # Sort packages in descending order (to try to fit the biggest packages first). all_packages.sort(reverse=True) # Sort drone limits in descending order. drone_limits.sort(reverse=True) delivered_count = 0 # Two pointers: for drones and for packages i, j = 0, 0 while i < len(drone_limits) and j < len(all_packages): if drone_limits[i] >= all_packages[j]: delivered_count += 1 i += 1 j += 1 else: j += 1 return delivered_count if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() d = int(data[0]) drone_limits = list(map(int, data[1:d+1])) p_idx = d + 1 p = int(data[p_idx]) p_idx += 1 planets = [] for _ in range(p): np = int(data[p_idx]) packages = list(map(int, data[p_idx + 1: p_idx + 1 + np])) planets.append(packages) p_idx += 1 + np result = max_deliveries(d, drone_limits, planets) print(result)"},{"question":"from typing import List, Tuple, Union def sorted_array_to_bst(nums: List[int]) -> Union[None, Tuple[int, Union[None, Tuple], Union[None, Tuple]]]: Converts a sorted array of distinct integers into a balanced BST. Args: nums (List[int]): The sorted array of integers. Returns: Tuple[int, Union[None, Tuple], Union[None, Tuple]]: The root of the balanced BST. >>> sorted_array_to_bst([1]) (1, None, None) >>> sorted_array_to_bst([1, 2]) (1, None, (2, None, None)) >>> sorted_array_to_bst([1, 2, 3]) (2, (1, None, None), (3, None, None)) >>> sorted_array_to_bst([1, 2, 3, 4, 5, 6, 7]) (4, (2, (1, None, None), (3, None, None)), (6, (5, None, None), (7, None, None))) >>> sorted_array_to_bst([]) None","solution":"def sorted_array_to_bst(nums): Converts a sorted array of distinct integers into a balanced BST. Args: nums (List[int]): The sorted array of integers. Returns: Tuple[int, Union[None, Tuple], Union[None, Tuple]]: The root of the balanced BST. def helper(left, right): if left > right: return None mid = (left + right) // 2 root_value = nums[mid] left_subtree = helper(left, mid - 1) right_subtree = helper(mid + 1, right) return (root_value, left_subtree, right_subtree) return helper(0, len(nums) - 1) # Example usage: # nums = [1, 2, 3, 4, 5, 6, 7] # bst_root = sorted_array_to_bst(nums) # print(bst_root) # Output: (4, (2, (1, None, None), (3, None, None)), (6, (5, None, None), (7, None, None)))"},{"question":"from typing import List, Tuple def is_assignment_possible(N: int, M: int, tasks: List[int], volunteers: List[int]) -> str: Checks if it is possible to assign all tasks to volunteers without exceeding volunteers' maximum difficulty levels. Args: N (int): Number of tasks. M (int): Number of volunteers. tasks (list of int): Difficulty levels of the tasks. volunteers (list of int): Maximum difficulty levels the volunteers can handle. Returns: str: \\"POSSIBLE\\" if assignment is possible, otherwise \\"IMPOSSIBLE\\". pass def task_assignment(T: int, test_cases: List[Tuple[int, int, List[int], List[int]]]) -> List[str]: Given multiple test cases, determine if it is possible to assign all tasks to the volunteers for each test case. Args: T (int): Number of test cases. test_cases (list of tuples): Each tuple contains: - an integer N (number of tasks) - an integer M (number of volunteers) - a list of N integers (difficulty levels of the tasks) - a list of M integers (maximum difficulty levels the volunteers can handle) Returns: list of str: \\"POSSIBLE\\" or \\"IMPOSSIBLE\\" for each test case. pass def test_is_assignment_possible(): assert is_assignment_possible(3, 3, [3, 5, 7], [8, 6, 4]) == \\"POSSIBLE\\" assert is_assignment_possible(2, 3, [2, 2], [3, 2, 2]) == \\"POSSIBLE\\" assert is_assignment_possible(4, 2, [4, 2, 3, 8], [5, 5]) == \\"IMPOSSIBLE\\" assert is_assignment_possible(5, 5, [1, 2, 3, 4, 5], [5, 5, 5, 5, 5]) == \\"POSSIBLE\\" assert is_assignment_possible(3, 3, [1, 2, 3], [1, 1, 1]) == \\"IMPOSSIBLE\\" assert is_assignment_possible(1, 1, [1000], [1000]) == \\"POSSIBLE\\" assert is_assignment_possible(2, 1, [1, 2], [2]) == \\"IMPOSSIBLE\\" def test_task_assignment(): test_cases = [ (3, 3, [3, 5, 7], [8, 6, 4]), (2, 3, [2, 2], [3, 2, 2]), (4, 2, [4, 2, 3, 8], [5, 5]) ] assert task_assignment(3, test_cases) == [\\"POSSIBLE\\", \\"POSSIBLE\\", \\"IMPOSSIBLE\\"] test_cases_2 = [ (1, 1, [1000], [1000]), (2, 1, [1, 2], [2]), (5, 5, [1, 2, 3, 4, 5], [5, 5, 5, 5, 5]), ] assert task_assignment(3, test_cases_2) == [\\"POSSIBLE\\", \\"IMPOSSIBLE\\", \\"POSSIBLE\\"]","solution":"def is_assignment_possible(N, M, tasks, volunteers): Checks if it is possible to assign all tasks to volunteers without exceeding volunteers' maximum difficulty levels. Args: N (int): Number of tasks. M (int): Number of volunteers. tasks (list of int): Difficulty levels of the tasks. volunteers (list of int): Maximum difficulty levels the volunteers can handle. Returns: str: \\"POSSIBLE\\" if assignment is possible, otherwise \\"IMPOSSIBLE\\". if N > M: return \\"IMPOSSIBLE\\" tasks.sort() volunteers.sort() for i in range(N): if tasks[i] > volunteers[i]: return \\"IMPOSSIBLE\\" return \\"POSSIBLE\\" def task_assignment(T, test_cases): results = [] for case in test_cases: N, M, tasks, volunteers = case result = is_assignment_possible(N, M, tasks, volunteers) results.append(result) return results"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def build_tree(nodes_info): nodes = {} for value, left, right in nodes_info: if value not in nodes: nodes[value] = TreeNode(value) node = nodes[value] if left != -1: if left not in nodes: nodes[left] = TreeNode(left) node.left = nodes[left] if right != -1: if right not in nodes: nodes[right] = TreeNode(right) node.right = nodes[right] return nodes[nodes_info[0][0]] # Return the root of the tree def max_depth(root): if root is None: return 0 left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1 def calculate_tree_depths(test_cases): Calculate the depth of binary trees given the nodes and edges. >>> calculate_tree_depths([ [ (1, 2, 3), (2, -1, -1), (3, -1, -1) ], [ (1, 2, 3), (2, -1, -1), (3, 4, 5), (4, -1, -1), (5, -1, -1) ] ]) == [1, 2] results = [] for nodes_info in test_cases: root = build_tree(nodes_info) depth = max_depth(root) results.append(depth - 1) return results # Example usage def main(): import sys input = sys.stdin.read data = input().split() idx = 0 T = int(data[idx]) idx += 1 test_cases = [] for _ in range(T): N = int(data[idx]) idx += 1 nodes_info = [] for _ in range(N): value = int(data[idx]) left = int(data[idx + 1]) right = int(data[idx + 2]) nodes_info.append((value, left, right)) idx += 3 test_cases.append(nodes_info) results = calculate_tree_depths(test_cases) for result in results: print(result)","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def build_tree(nodes_info): nodes = {} for value, left, right in nodes_info: if value not in nodes: nodes[value] = TreeNode(value) node = nodes[value] if left != -1: if left not in nodes: nodes[left] = TreeNode(left) node.left = nodes[left] if right != -1: if right not in nodes: nodes[right] = TreeNode(right) node.right = nodes[right] return nodes[nodes_info[0][0]] # Return the root of the tree def max_depth(root): if root is None: return 0 left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1 def calculate_tree_depths(test_cases): results = [] for nodes_info in test_cases: root = build_tree(nodes_info) depth = max_depth(root) results.append(depth - 1) return results # Example usage def main(): import sys input = sys.stdin.read data = input().split() idx = 0 T = int(data[idx]) idx += 1 test_cases = [] for _ in range(T): N = int(data[idx]) idx += 1 nodes_info = [] for _ in range(N): value = int(data[idx]) left = int(data[idx + 1]) right = int(data[idx + 2]) nodes_info.append((value, left, right)) idx += 3 test_cases.append(nodes_info) results = calculate_tree_depths(test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring that contains at most two distinct characters. Args: s (str): The input string consisting of lowercase English letters. Returns: int: The length of the longest substring with at most two distinct characters. Examples: >>> length_of_longest_substring_two_distinct(\\"abcbbbbcccbdddadacb\\") 10 >>> length_of_longest_substring_two_distinct(\\"eceba\\") 3","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring that contains at most two distinct characters. start = 0 max_length = 0 char_frequency = {} for end in range(len(s)): right_char = s[end] if right_char not in char_frequency: char_frequency[right_char] = 0 char_frequency[right_char] += 1 while len(char_frequency) > 2: left_char = s[start] char_frequency[left_char] -= 1 if char_frequency[left_char] == 0: del char_frequency[left_char] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"from typing import List, Tuple def min_carousels(t: int, tests: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Determine the minimum number of unique carousels required to handle all the luggage without any time conflict. Args: t (int): Number of test cases. tests (List[Tuple[int, List[Tuple[int, int]]]]): List containing tuples where each tuple contains an integer n and a list of tuples with arrival and departure times. Returns: List[int]: List of integers representing the minimum number of unique carousels required for each test case. Example: >>> min_carousels(2, [(3, [(1, 5), (2, 6), (8, 10)]), (2, [(1, 3), (2, 5)])]) [2, 2] pass def parse_input(input_string: str) -> Tuple[int, List[Tuple[int, List[Tuple[int, int]]]]]: Parse input string into the required format for min_carousels function. Args: input_string (str): Input string containing test cases. Returns: Tuple[int, List[Tuple[int, List[Tuple[int, int]]]]]: Tuple containing number of test cases and list of test cases with arrival and departure times. Example: >>> parse_input(\\"2n3n1 5n2 6n8 10n2n1 3n2 5\\") (2, [(3, [(1, 5), (2, 6), (8, 10)]), (2, [(1, 3), (2, 5)])]) pass def format_output(results: List[int]) -> str: Format the results into a string for output. Args: results (List[int]): List of integers representing the minimum number of unique carousels required for each test case. Returns: str: Formatted string of results. Example: >>> format_output([2, 2]) '2n2' pass","solution":"from heapq import heappop, heappush def min_carousels(t, tests): results = [] for test in tests: n, intervals = test intervals.sort() # Min-heap to track the end times of carousels heap = [] for interval in intervals: start, end = interval if heap and heap[0] <= start: heappop(heap) heappush(heap, end) results.append(len(heap)) return results def parse_input(input_string): lines = input_string.strip().split('n') t = int(lines[0]) tests = [] i = 1 for _ in range(t): n = int(lines[i]) intervals = [] for j in range(n): a, b = map(int, lines[i + 1 + j].split()) intervals.append((a, b)) tests.append((n, intervals)) i += n + 1 return t, tests def format_output(results): return \\"n\\".join(map(str, results))"},{"question":"def find_palindromes(start: int, end: int) -> List[int]: Returns a list of palindrome numbers between the specified range (inclusive). Args: start (int): The starting point of the range. end (int): The ending point of the range. Returns: List[int]: A list of palindrome numbers in the range. >>> find_palindromes(10, 50) [11, 22, 33, 44] >>> find_palindromes(1, 9) [1, 2, 3, 4, 5, 6, 7, 8, 9] # Unit test def test_palindromes_within_range(): assert find_palindromes(10, 50) == [11, 22, 33, 44] assert find_palindromes(1, 9) == [1, 2, 3, 4, 5, 6, 7, 8, 9] def test_palindromes_at_boundaries(): assert find_palindromes(100, 101) == [101] def test_palindromes_multiple_in_range(): assert find_palindromes(50, 150) == [55, 66, 77, 88, 99, 101, 111, 121, 131, 141] def test_no_palindromes_in_range(): assert find_palindromes(200, 220) == [202, 212] assert find_palindromes(222, 230) == [222] def test_complete_range(): assert find_palindromes(1, 1000) == [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, 212, 222, 232, 242, 252, 262, 272, 282, 292, 303, 313, 323, 333, 343, 353, 363, 373, 383, 393, 404, 414, 424, 434, 444, 454, 464, 474, 484, 494, 505, 515, 525, 535, 545, 555, 565, 575, 585, 595, 606, 616, 626, 636, 646, 656, 666, 676, 686, 696, 707, 717, 727, 737, 747, 757, 767, 777, 787, 797, 808, 818, 828, 838, 848, 858, 868, 878, 888, 898, 909, 919, 929, 939, 949, 959, 969, 979, 989, 999 ]","solution":"def find_palindromes(start, end): Returns a list of palindrome numbers between the specified range (inclusive). palindromes = [] for num in range(start, end + 1): if str(num) == str(num)[::-1]: palindromes.append(num) return palindromes # Example usage to print the palindromes start, end = 10, 50 print(find_palindromes(start, end))"},{"question":"def active_intervals(intervals, timestamps): Returns the number of active intervals for each timestamp. Parameters: intervals (list of tuples): List where each tuple contains the start and end times (inclusive) of the interval. timestamps (list of ints): List of timestamps. Returns: list of ints: List containing the count of active intervals for each timestamp. # Example usage and test cases # Unit Test: from solution import active_intervals def test_example_case_1(): intervals = [(1, 4), (2, 6), (8, 10)] timestamps = [2, 5, 9] result = active_intervals(intervals, timestamps) assert result == [2, 1, 1] def test_example_case_2(): intervals = [(1, 3), (4, 6), (5, 8), (10, 15)] timestamps = [0, 2, 5, 7, 12] result = active_intervals(intervals, timestamps) assert result == [0, 1, 2, 1, 1] def test_all_intervals_active(): intervals = [(1, 5), (2, 5), (3, 5)] timestamps = [3, 4, 5] result = active_intervals(intervals, timestamps) assert result == [3, 3, 3] def test_no_intervals_active(): intervals = [(1, 2), (2, 3), (3, 4)] timestamps = [5, 6, 7] result = active_intervals(intervals, timestamps) assert result == [0, 0, 0] def test_single_interval_multiple_timestamps(): intervals = [(1, 10)] timestamps = [1, 2, 5, 10, 11] result = active_intervals(intervals, timestamps) assert result == [1, 1, 1, 1, 0] def test_edge_case_empty_intervals(): intervals = [] timestamps = [1, 2, 3] result = active_intervals(intervals, timestamps) assert result == [0, 0, 0] def test_edge_case_empty_timestamps(): intervals = [(1, 3), (2, 5)] timestamps = [] result = active_intervals(intervals, timestamps) assert result == [] def test_edge_case_large_number_of_intervals(): intervals = [(i, i+2) for i in range(100000)] timestamps = [50000] result = active_intervals(intervals, timestamps) assert result == [3]","solution":"def active_intervals(intervals, timestamps): Returns the number of active intervals for each timestamp. Parameters: intervals (list of tuples): List where each tuple contains the start and end times (inclusive) of the interval. timestamps (list of ints): List of timestamps. Returns: list of ints: List containing the count of active intervals for each timestamp. result = [] for t in timestamps: count = sum(1 for start, end in intervals if start <= t <= end) result.append(count) return result"},{"question":"class Library: A class to manage a collection of books in a library, where each book is identified by a unique integer ID and belongs to one or more genres. Methods: - add_book(book_id: int, genres: List[str]): Adds a book with given genres to the library. - remove_book(book_id: int): Removes a book from the library using its ID. - get_genres(book_id: int) -> str: Retrieves the list of genres for the given book as a space-separated string. Returns \\"NOT FOUND\\" if the book doesn't exist. Usage Examples: >>> library = Library() >>> library.add_book(101, [\\"Science\\", \\"Fiction\\"]) >>> library.get_genres(101) 'Science Fiction' >>> library.remove_book(101) >>> library.get_genres(101) 'NOT FOUND' >>> library.add_book(102, [\\"History\\", \\"Politics\\"]) >>> library.get_genres(102) 'History Politics' def add_book(self, book_id, genres): pass def remove_book(self, book_id): pass def get_genres(self, book_id): pass # Unit Tests def test_add_and_get_book(): library = Library() library.add_book(101, [\\"Science\\", \\"Fiction\\"]) assert library.get_genres(101) == \\"Science Fiction\\" library.add_book(102, [\\"History\\", \\"Politics\\"]) assert library.get_genres(102) == \\"History Politics\\" def test_remove_book(): library = Library() library.add_book(101, [\\"Science\\", \\"Fiction\\"]) library.remove_book(101) assert library.get_genres(101) == \\"NOT FOUND\\" def test_get_nonexistent_book(): library = Library() assert library.get_genres(999) == \\"NOT FOUND\\" def test_add_remove_and_get_book(): library = Library() library.add_book(103, [\\"Mystery\\"]) assert library.get_genres(103) == \\"Mystery\\" library.remove_book(103) assert library.get_genres(103) == \\"NOT FOUND\\" library.add_book(103, [\\"Thriller\\"]) assert library.get_genres(103) == \\"Thriller\\"","solution":"class Library: def __init__(self): self.books = {} def add_book(self, book_id, genres): self.books[book_id] = genres def remove_book(self, book_id): if book_id in self.books: del self.books[book_id] def get_genres(self, book_id): if book_id in self.books: return ' '.join(self.books[book_id]) else: return \\"NOT FOUND\\""},{"question":"def can_concatenate_palindrome(s1: str, s2: str) -> str: Returns 'YES' if it is possible to concatenate the strings in some way such that the resulting string is the same when read forwards and backwards. Otherwise, returns 'NO'. >>> can_concatenate_palindrome(\\"ab\\", \\"ba\\") == \\"YES\\" >>> can_concatenate_palindrome(\\"abc\\", \\"def\\") == \\"NO\\" >>> can_concatenate_palindrome(\\"aab\\", \\"baa\\") == \\"YES\\" >>> can_concatenate_palindrome(\\"abcd\\", \\"dcba\\") == \\"YES\\" >>> can_concatenate_palindrome(\\"a\\", \\"b\\") == \\"NO\\"","solution":"def can_concatenate_palindrome(s1, s2): Returns \\"YES\\" if s1 and s2 can be concatenated in some way to form a palindrome, otherwise \\"NO\\". concatenation1 = s1 + s2 concatenation2 = s2 + s1 if concatenation1 == concatenation1[::-1] or concatenation2 == concatenation2[::-1]: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List, Tuple def is_parabolic_sequence(N: int, S: List[int]) -> str: Determines if a given list of integers S of size N is a Parabolic Sequence. A Parabolic Sequence has a single peak point where the sequence first strictly increases and then strictly decreases. Parameters: - N (int): The size of the sequence - S (list of int): The sequence of integers Returns: - str: \\"YES\\" if the sequence is a Parabolic Sequence, otherwise \\"NO\\" >>> is_parabolic_sequence(5, [1, 3, 5, 4, 2]) 'YES' >>> is_parabolic_sequence(4, [2, 2, 3, 4]) 'NO' pass def process_test_cases(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Processes multiple test cases to determine if each sequence is a Parabolic Sequence. Parameters: - T (int): The number of test cases - test_cases (list of tuples): Each tuple contains an integer N and a list of N integers Returns: - list of str: A list containing \\"YES\\" or \\"NO\\" for each test case >>> process_test_cases(2, [ ... (5, [1, 3, 5, 4, 2]), ... (4, [2, 2, 3, 4]) ... ]) ['YES', 'NO'] pass def test_is_parabolic_sequence(): assert is_parabolic_sequence(5, [1, 3, 5, 4, 2]) == \\"YES\\" assert is_parabolic_sequence(4, [2, 2, 3, 4]) == \\"NO\\" assert is_parabolic_sequence(3, [1, 3, 2]) == \\"YES\\" assert is_parabolic_sequence(2, [1, 2]) == \\"NO\\" assert is_parabolic_sequence(3, [3, 2, 1]) == \\"NO\\" assert is_parabolic_sequence(6, [1, 4, 6, 5, 3, 2]) == \\"YES\\" assert is_parabolic_sequence(4, [1, 2, 3, 2]) == \\"YES\\" assert is_parabolic_sequence(4, [1, 2, 1, 2]) == \\"NO\\" def test_process_test_cases(): assert process_test_cases(2, [ (5, [1, 3, 5, 4, 2]), (4, [2, 2, 3, 4]) ]) == [\\"YES\\", \\"NO\\"] assert process_test_cases(3, [ (3, [1, 3, 2]), (2, [1, 2]), (6, [1, 2, 3, 4, 3, 2]) ]) == [\\"YES\\", \\"NO\\", \\"YES\\"] assert process_test_cases(1, [ (3, [3, 2, 1]) ]) == [\\"NO\\"] if __name__ == \\"__main__\\": test_is_parabolic_sequence() test_process_test_cases() print(\\"All tests passed.\\")","solution":"def is_parabolic_sequence(N, S): Determines if a given list of integers S of size N is a Parabolic Sequence. Parameters: - N (int): The size of the sequence - S (list of int): The sequence of integers Returns: - str: \\"YES\\" if the sequence is a Parabolic Sequence, otherwise \\"NO\\" if N < 3: return \\"NO\\" # A parabolic sequence needs at least 3 elements peak_found = False for i in range(1, N): if not peak_found: if S[i] < S[i-1]: if i == 1: return \\"NO\\" # No increasing part found peak_found = True else: if S[i] >= S[i-1]: return \\"NO\\" # Not strictly decreasing after the peak return \\"YES\\" if peak_found else \\"NO\\" def process_test_cases(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] S = test_cases[i][1] results.append(is_parabolic_sequence(N, S)) return results"},{"question":"from typing import List def has_pair_with_sum(arr: List[int], k: int) -> str: Given an array of integers and a target integer k, determine if there are two distinct indices i and j in the array such that the sum of the elements at these indices is equal to k. >>> has_pair_with_sum([1, 2, 3, 4, 5], 8) 'YES' >>> has_pair_with_sum([-1, 0, 3, 2], 4) 'NO'","solution":"def has_pair_with_sum(arr, k): seen = set() for number in arr: if k - number in seen: return \\"YES\\" seen.add(number) return \\"NO\\" # Example usage n = 5 arr = [1, 2, 3, 4, 5] k = 8 print(has_pair_with_sum(arr, k)) # Output: YES n = 4 arr = [-1, 0, 3, 2] k = 4 print(has_pair_with_sum(arr, k)) # Output: NO"},{"question":"def preprocess_tracks(n, tracks): Preprocess the tracks to create data structures for track counts and direct connections. pass def process_queries(q, queries, track_count, direct_connections): Processes the queries using the preprocessed track count and direct connections. pass def railway_system(n, q, tracks, queries): The overall function to initialize and process the railway system queries. >>> n = 4 >>> q = 5 >>> tracks = [(1, 2), (2, 3), (3, 4), (4, 5)] >>> queries = [\\"1 3\\", \\"1 2\\", \\"1 3\\", \\"2 2 3\\", \\"2 3 5\\"] >>> results = railway_system(n, q, tracks, queries) >>> results [2, 2, 2, 1, 0] pass","solution":"def preprocess_tracks(n, tracks): from collections import defaultdict # Dictionary to store counts of tracks connected to each station track_count = defaultdict(int) # Sets to store unique connections direct_connections = defaultdict(set) for a, b in tracks: track_count[a] += 1 track_count[b] += 1 direct_connections[frozenset([a, b])] = 1 return track_count, direct_connections def process_queries(q, queries, track_count, direct_connections): result = [] for query in queries: parts = query.split() if parts[0] == \\"1\\": x = int(parts[1]) result.append(track_count[x]) elif parts[0] == \\"2\\": x, y = int(parts[1]), int(parts[2]) connection = frozenset([x, y]) result.append(direct_connections.get(connection, 0)) return result # The overall function to run the process def railway_system(n, q, tracks, queries): track_count, direct_connections = preprocess_tracks(n, tracks) return process_queries(q, queries, track_count, direct_connections) if __name__ == \\"__main__\\": n, q = map(int, input().split()) tracks = [tuple(map(int, input().split())) for _ in range(n)] queries = [input() for _ in range(q)] results = railway_system(n, q, tracks, queries) for result in results: print(result)"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Find two indices of numbers in 'nums' that add up to 'target'. Args: nums: List of integers. target: Integer representing the target sum. Returns: List of two integers representing the indices of the two numbers that add up to the target. Example: >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([1, 2, 3, 4, 5], 9) [3, 4] from solution import two_sum def test_example_case(): nums = [2, 7, 11, 15] target = 9 result = two_sum(nums, target) assert set(result) == {0, 1} def test_all_positive_numbers(): nums = [1, 2, 3, 4, 5] target = 9 result = two_sum(nums, target) assert set(result) == {3, 4} def test_with_negative_numbers(): nums = [-1, -2, -3, -4, -5] target = -8 result = two_sum(nums, target) assert set(result) == {2, 4} def test_with_mixed_numbers(): nums = [3, -3, 4, -4, -1, 1] target = 0 result = two_sum(nums, target) assert set(result) == {0, 1} or set(result) == {2, 3} or set(result) == {4, 5} def test_large_numbers(): nums = [1000000, 500000, -500000, -1000000] target = 500000 result = two_sum(nums, target) assert set(result) == {0, 2} def test_no_solution(): nums = [1, 2, 3, 4, 5] target = 10 result = two_sum(nums, target) assert result is None","solution":"def two_sum(nums, target): Find two indices of numbers in 'nums' that add up to 'target'. Args: nums: List[int] target: int Returns: List[int] - A list containing the indices of the two numbers that add up to the target. num_dict = {} for i, num in enumerate(nums): complement = target - num if complement in num_dict: return [num_dict[complement], i] num_dict[num] = i"},{"question":"from typing import List, Tuple def transform_grid(grid: List[str]) -> List[List[str]]: Transform the input grid from list of strings to list of list of characters. >>> transform_grid([\\"...\\", ... \\"#\\", ... \\"...\\"]) [['.', '.', '.'], ['#', '#', '#'], ['.', '.', '.']] def shortest_path(n: int, m: int, grid: List[List[str]], start: Tuple[int, int], end: Tuple[int, int]) -> int: Determine the shortest number of moves a character needs to reach from one cell to another in the grid. >>> grid = [\\".....\\", ... \\".#..#\\", ... \\".#..#\\", ... \\".#..#\\", ... \\".....\\"] >>> transformed_grid = transform_grid(grid) >>> shortest_path(5, 5, transformed_grid, (0, 0), (4, 4)) 8 >>> grid = [\\"...\\", ... \\"#\\", ... \\"...\\"] >>> transformed_grid = transform_grid(grid) >>> shortest_path(3, 3, transformed_grid, (0, 0), (2, 2)) -1","solution":"from collections import deque def shortest_path(n, m, grid, start, end): x1, y1 = start x2, y2 = end if grid[x1][y1] == '#' or grid[x2][y2] == '#': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(x1, y1, 0)]) visited = set((x1, y1)) while queue: x, y, dist = queue.popleft() if (x, y) == (x2, y2): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 def transform_grid(grid): return [list(row) for row in grid]"},{"question":"def can_reach_target(n: int, m: int, grid: List[str]) -> str: Determine whether the robot can reach the target position in a given grid. Parameters: n (int): Number of rows of the grid. m (int): Number of columns of the grid. grid (List[str]): The grid represented as a list of strings where '.' is an empty cell, '#' is an obstacle, and 'T' is the target position. Returns: str: \\"YES\\" if the robot can reach the target position, otherwise \\"NO\\". def test_case_1(): grid = [ \\"..#..\\", \\"..#..\\", \\"..#..\\", \\".....\\", \\"...T.\\" ] assert can_reach_target(5, 5, grid) == \\"YES\\" def test_case_2(): grid = [ \\"..#..\\", \\"..#..\\", \\"#\\", \\".....\\", \\"...T.\\" ] assert can_reach_target(5, 5, grid) == \\"NO\\" def test_case_3(): grid = [ \\".#T\\", \\"#\\", \\"..#\\" ] assert can_reach_target(3, 3, grid) == \\"NO\\" def test_case_4(): grid = [ \\"....\\", \\"....\\", \\"....\\", \\".T..\\" ] assert can_reach_target(4, 4, grid) == \\"YES\\" def test_case_5(): grid = [ \\".\\", \\"#\\", \\"T\\" ] assert can_reach_target(3, 1, grid) == \\"NO\\"","solution":"def can_reach_target(n, m, grid): from collections import deque def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] != '#' directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if grid[x][y] == 'T': return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return \\"NO\\""},{"question":"from typing import List def minimum_jumps(test_cases: List[List[int]]) -> List[int]: Calculate the minimum number of jumps required to reach the right-most building starting from the left-most building. Each sublist in a list of test cases represents the heights of buildings. Args: test_cases (List[List[int]]): A list of test cases where each test case is a list of integers representing building heights. Returns: List[int]: A list of integers where each integer represents the minimum number of jumps for the corresponding test case. Examples: >>> minimum_jumps([[1, 2, 3, 4, 5]]) [4] >>> minimum_jumps([[4, 4, 8, 8]]) [3] >>> minimum_jumps([[1, 2, 3, 1, 2, 3]]) [3]","solution":"def minimum_jumps(test_cases): results = [] for buildings in test_cases: jumps = 0 current_height = buildings[0] for height in buildings[1:]: if height >= current_height: jumps += 1 current_height = height results.append(jumps) return results"},{"question":"def can_rearrange_fruits(weights, threshold): Check if fruits can be rearranged such that the absolute difference between the weights of any two adjacent fruits is at most the given threshold. >>> can_rearrange_fruits([1, 3, 5, 2], 2) \\"Yes\\" >>> can_rearrange_fruits([10, 20, 15], 5) \\"Yes\\" >>> can_rearrange_fruits([4, 1, 8, 5], 0) \\"No\\" # Your code here def process_test_cases(T, test_cases): Process multiple test cases to determine if it is possible to rearrange the fruits. >>> process_test_cases(3, [([1, 3, 5, 2], 2), ([10, 20, 15], 5), ([4, 1, 8, 5], 0)]) [\\"Yes\\", \\"Yes\\", \\"No\\"] # Your code here","solution":"def can_rearrange_fruits(weights, threshold): Check if fruits can be rearranged such that the absolute difference between the weights of any two adjacent fruits is at most the given threshold. weights.sort() for i in range(1, len(weights)): if weights[i] - weights[i-1] > threshold: return \\"No\\" return \\"Yes\\" def process_test_cases(T, test_cases): results = [] for weights, threshold in test_cases: result = can_rearrange_fruits(weights, threshold) results.append(result) return results"},{"question":"def decode_message(s: str) -> str: Decodes the message by removing consecutive duplicate characters. Args: s (str): Encoded message with consecutive duplicate characters. Returns: str: Decoded message with consecutive duplicates removed. Examples: >>> decode_message('aaabbbcccaaa') 'abca' >>> decode_message('AABBAAC') 'ABAC' >>> decode_message('xyzzyxx') 'xyzyx' from solution import decode_message def test_single_character(): assert decode_message('a') == 'a' def test_no_duplicates(): assert decode_message('abcde') == 'abcde' def test_all_duplicates(): assert decode_message('aaabbbccc') == 'abc' def test_mixed_case(): assert decode_message('AABBAAC') == 'ABAC' def test_end_with_consecutive_duplicates(): assert decode_message('xyzzyxx') == 'xyzyx' def test_empty_string(): assert decode_message('') == '' def test_long_string(): assert decode_message('a' * 100000) == 'a' assert decode_message('ab' * 50000) == 'ab' * 50000 def test_alternating_characters(): assert decode_message('abababab') == 'abababab' assert decode_message('aabbaabb') == 'abab' def test_complex_case(): assert decode_message('aaabacccdbbdddc') == 'abacdbdc'","solution":"def decode_message(s): Decodes the message by removing consecutive duplicate characters. Args: s (str): Encoded message with consecutive duplicate characters. Returns: str: Decoded message with consecutive duplicates removed. if not s: return '' decoded_message = [s[0]] # Initialize the result with the first character of the string for char in s[1:]: if char != decoded_message[-1]: decoded_message.append(char) return ''.join(decoded_message)"},{"question":"def robot_final_position(T: int, test_cases: List[List[str]]) -> List[str]: Determine the final position of the robot after all the commands have been executed. >>> robot_final_position(3, [[\\"R 3\\", \\"U 2\\", \\"L 1\\"], [\\"R 1\\", \\"R 2\\", \\"D 1\\", \\"U 3\\"], [\\"L 5\\", \\"D 3\\"]]) ['2 2', '3 2', '-5 -3'] >>> robot_final_position(1, [[]]) ['0 0'] >>> robot_final_position(1, [[\\"R 10\\"]]) ['10 0'] >>> robot_final_position(1, [[\\"U 10\\"]]) ['0 10'] >>> robot_final_position(1, [[\\"L 10\\"]]) ['-10 0'] >>> robot_final_position(1, [[\\"D 10\\"]]) ['0 -10'] >>> robot_final_position(2, [[\\"R 5\\", \\"U 5\\", \\"L 5\\", \\"D 5\\"], [\\"R 3\\", \\"R 3\\", \\"L 6\\"]]) ['0 0', '0 0'] >>> robot_final_position(1, [[\\"R 1000\\", \\"U 1000\\", \\"L 1000\\", \\"D 1000\\"]]) ['0 0']","solution":"def robot_final_position(T, test_cases): results = [] for case in test_cases: x, y = 0, 0 for command in case: direction, steps = command.split() steps = int(steps) if direction == 'U': y += steps elif direction == 'D': y -= steps elif direction == 'L': x -= steps elif direction == 'R': x += steps results.append(f\\"{x} {y}\\") return results"},{"question":"def max_gold_coins(N: int, grid: List[List[int]]) -> int: Determine the maximum number of gold coins the wizard can collect on his journey from the top-left to the bottom-right corner of the grid. :param N: Size of the grid (N x N). :param grid: A list of lists representing the grid, where each element is either 0 (empty cell) or 1 (cell with a gold coin). :return: The maximum number of gold coins that can be collected. Examples: >>> max_gold_coins(4, [ ... [0, 1, 0, 0], ... [1, 0, 1, 1], ... [0, 0, 1, 0], ... [1, 1, 0, 1] ... ]) 4 >>> max_gold_coins(3, [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 >>> max_gold_coins(3, [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 5 >>> max_gold_coins(3, [ ... [1, 0, 1], ... [0, 1, 0], ... [1, 0, 1] ... ]) 3 >>> max_gold_coins(1, [ ... [1] ... ]) 1 >>> max_gold_coins(1, [ ... [0] ... ]) 0","solution":"def max_gold_coins(N, grid): # Create a 2D dp array to store intermediate results dp = [[0]*N for _ in range(N)] # Starting point (top-left corner) dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, N): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, N): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, N): for j in range(1, N): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The answer is in the bottom-right corner return dp[N-1][N-1]"},{"question":"def conveyor_belt_system(w, n, weights): Determines if the total weight of items on the conveyor belt is within the limit and the maximum additional weight that can be added without exceeding the limit. Parameters: w (int): Maximum weight capacity of the conveyor belt. n (int): Number of items on the conveyor belt. weights (list of int): Weights of the items on the conveyor belt. Returns: Tuple: - str: \\"YES\\" if the total weight is within the capacity, otherwise \\"NO\\". - int: Maximum additional weight that can be added or 0 if over capacity. Examples: >>> conveyor_belt_system(100, 3, [20, 30, 40]) ('YES', 10) >>> conveyor_belt_system(50, 4, [10, 20, 15, 10]) ('NO', 0)","solution":"def conveyor_belt_system(w, n, weights): Determines if the total weight of items on the conveyor belt is within the limit and the maximum additional weight that can be added without exceeding the limit. Parameters: w (int): Maximum weight capacity of the conveyor belt. n (int): Number of items on the conveyor belt. weights (list of int): Weights of the items on the conveyor belt. Returns: Tuple: - str: \\"YES\\" if the total weight is within the capacity, otherwise \\"NO\\". - int: Maximum additional weight that can be added or 0 if over capacity. current_total_weight = sum(weights) if current_total_weight <= w: return (\\"YES\\", w - current_total_weight) else: return (\\"NO\\", 0) # Example usage: # print(conveyor_belt_system(100, 3, [20, 30, 40])) # print(conveyor_belt_system(50, 4, [10, 20, 15, 10])) # print(conveyor_belt_system(200, 5, [30, 50, 40, 20, 10]))"},{"question":"def top_k_importance(n: int, k: int, importance: List[int], visits: List[int]) -> List[int]: Given the number of animals, the number of important animals needed, the importance values, and the required number of visits for each animal, find the k most important animals. Parameters: n (int): number of animals k (int): number of most important animals needed importance (list of int): importance values of each animal visits (list of int): required number of visits for each animal Returns: list of int: k most important animals' importance values in descending order pass # Unit tests def test_basic_case(): n = 4 k = 3 importance = [5, 8, 2, 6] visits = [3, 1, 2, 4] assert top_k_importance(n, k, importance, visits) == [8, 6, 5] def test_more_visits_than_importance(): n = 5 k = 2 importance = [1, 10, 5, 7, 3] visits = [9, 2, 3, 5, 1] assert top_k_importance(n, k, importance, visits) == [10, 7] def test_k_zero(): n = 7 k = 0 importance = [3, 4, 2, 7, 1, 9, 6] visits = [1, 1, 1, 1, 1, 1, 1] assert top_k_importance(n, k, importance, visits) == [] def test_k_greater_than_n(): n = 3 k = 5 importance = [2, 8, 5] visits = [2, 3, 4] assert top_k_importance(n, k, importance, visits) == [8, 5, 2] def test_single_animal(): n = 1 k = 1 importance = [5] visits = [1] assert top_k_importance(n, k, importance, visits) == [5]","solution":"def top_k_importance(n, k, importance, visits): Given the number of animals, the number of important animals needed, the importance values, and the required number of visits for each animal, find the k most important animals. Parameters: n (int): number of animals k (int): number of most important animals needed importance (list of int): importance values of each animal visits (list of int): required number of visits for each animal Returns: list of int: k most important animals' importance values in descending order import heapq # Create a list of tuples (importance, visits) for each animal animals = [(importance[i], visits[i]) for i in range(n)] # Sort the animals based on importance in descending order animals.sort(reverse=True, key=lambda x: x[0]) # Extract the importance values importance_values = [animal[0] for animal in animals] # Get the k most important values, considering the case when k is bigger than the number of animals top_k_importance_values = importance_values[:min(k, n)] return top_k_importance_values"},{"question":"class Library: def __init__(self): self.collection = {} def add_book(self, unique_id, title, author, pages): Add a new book to the collection. pass def remove_book(self, unique_id): Remove a book from the collection based on its unique identifier. pass def update_book(self, unique_id, pages): Update the number of pages for a given book. pass def get_book(self, unique_id): Retrieve information about a book based on its unique identifier. pass def list_books(self): Retrieve a list of all books in the collection sorted by the number of pages in descending order. pass def process_commands(commands): Process a series of commands to manage the library's collection of books. Commands: - \\"ADD unique_identifier title author pages\\" to add a new book. - \\"REMOVE unique_identifier\\" to remove a book. - \\"UPDATE unique_identifier pages\\" to update the number of pages for a book. - \\"GET unique_identifier\\" to get information about a book. - \\"LIST\\" to get a sorted list of all books. Returns: A list of results based on the \\"GET\\" and \\"LIST\\" commands. library = Library() results = [] return results # Unit Tests def test_add_and_get_book(): commands = [ \\"ADD 1 CatcherInTheRye JDSalinger 214\\", \\"GET 1\\" ] assert process_commands(commands) == [\\"1 CatcherInTheRye JDSalinger 214\\"] def test_remove_book(): commands = [ \\"ADD 1 CatcherInTheRye JDSalinger 214\\", \\"REMOVE 1\\", \\"GET 1\\" ] assert process_commands(commands) == [\\"Book not found\\"] def test_update_book(): commands = [ \\"ADD 1 CatcherInTheRye JDSalinger 214\\", \\"UPDATE 1 300\\", \\"GET 1\\" ] assert process_commands(commands) == [\\"1 CatcherInTheRye JDSalinger 300\\"] def test_list_books(): commands = [ \\"ADD 1 CatcherInTheRye JDSalinger 214\\", \\"ADD 2 ToKillAMockingbird HarperLee 281\\", \\"ADD 3 1984 GeorgeOrwell 328\\", \\"LIST\\" ] expected = [ \\"3 1984 GeorgeOrwell 328\\", \\"2 ToKillAMockingbird HarperLee 281\\", \\"1 CatcherInTheRye JDSalinger 214\\" ] assert process_commands(commands) == expected def test_get_nonexistent_book(): commands = [\\"GET 999\\"] assert process_commands(commands) == [\\"Book not found\\"] def test_remove_nonexistent_book(): commands = [\\"REMOVE 999\\"] assert process_commands(commands) == [\\"Book not found\\"]","solution":"class Library: def __init__(self): self.collection = {} def add_book(self, unique_id, title, author, pages): self.collection[unique_id] = {'title': title, 'author': author, 'pages': pages} def remove_book(self, unique_id): return self.collection.pop(unique_id, None) def update_book(self, unique_id, pages): if unique_id in self.collection: self.collection[unique_id]['pages'] = pages def get_book(self, unique_id): return self.collection.get(unique_id) def list_books(self): return sorted(self.collection.items(), key=lambda x: (-x[1]['pages'], x[0])) def process_commands(commands): library = Library() results = [] for command in commands: parts = command.split() action = parts[0] if action == \\"ADD\\": unique_id = int(parts[1]) title = parts[2] author = parts[3] pages = int(parts[4]) library.add_book(unique_id, title, author, pages) elif action == \\"REMOVE\\": unique_id = int(parts[1]) removed_book = library.remove_book(unique_id) if removed_book is None: results.append(\\"Book not found\\") elif action == \\"UPDATE\\": unique_id = int(parts[1]) pages = int(parts[2]) library.update_book(unique_id, pages) elif action == \\"GET\\": unique_id = int(parts[1]) book = library.get_book(unique_id) if book: results.append(f\\"{unique_id} {book['title']} {book['author']} {book['pages']}\\") else: results.append(\\"Book not found\\") elif action == \\"LIST\\": books = library.list_books() for unique_id, book in books: results.append(f\\"{unique_id} {book['title']} {book['author']} {book['pages']}\\") return results"},{"question":"def generate_matrix(n: int) -> List[List[int]]: Generates an n x n matrix where each element at position (i, j) is the sum of its row and column indices. Parameters: n (int): The size of the matrix (1 <= n <= 100) Returns: list of list of int: The generated n x n matrix >>> generate_matrix(1) [[0]] >>> generate_matrix(2) [[0, 1], [1, 2]] >>> generate_matrix(3) [[0, 1, 2], [1, 2, 3], [2, 3, 4]] >>> generate_matrix(5) [[0, 1, 2, 3, 4], [1, 2, 3, 4, 5], [2, 3, 4, 5, 6], [3, 4, 5, 6, 7], [4, 5, 6, 7, 8]]","solution":"def generate_matrix(n): Generates an n x n matrix where each element at position (i, j) is the sum of its row and column indices. Parameters: n (int): The size of the matrix (1 <= n <= 100) Returns: list of list of int: The generated n x n matrix matrix = [] for i in range(n): row = [] for j in range(n): row.append(i + j) matrix.append(row) return matrix"},{"question":"def count_paths(n: int, grid: List[str]) -> int: Count the number of distinct paths from the top-left cell (0, 0) to the bottom-right cell (n-1, n-1) in a grid with obstacles. Args: n (int): The size of the grid. grid (List[str]): The grid itself, where 'E' stands for empty cell and 'O' stands for obstacle. Returns: int: The number of distinct paths from top-left to bottom-right. Example: >>> count_paths(3, ['EEE', 'EOE', 'EEE']) 2 >>> count_paths(3, ['EOE', 'OOE', 'EEE']) 0","solution":"def count_paths(n, grid): # Initialize DP table with 0s. dp = [[0]*n for _ in range(n)] # If the starting point is an obstacle, return 0. if grid[0][0] == 'O': return 0 # Starting point dp[0][0] = 1 # Fill the dp table for i in range(n): for j in range(n): if grid[i][j] == 'O': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"def can_store_data(t: int, test_cases: List[Dict[str, Any]]) -> List[str]: Distributes a given amount of data across available disks and checks if the data can be stored successfully without exceeding disk capacities. Args: t (int): Number of test cases. test_cases (List[Dict[str, Any]]): The list of test cases where each test case contains the number of disks, their capacities, and the data to be stored. Returns: List[str]: List of strings, each indicating \\"Data stored successfully!\\" or \\"Insufficient disk space!\\" for each test case. Example: >>> t = 2 >>> test_cases = [ ... {'n': 3, 'capacities': [100, 200, 300], 'd': 400}, ... {'n': 2, 'capacities': [100, 100], 'd': 250} ... ] >>> can_store_data(t, test_cases) ['Data stored successfully!', 'Insufficient disk space!'] from typing import List, Dict, Any def test_example_cases(): t = 2 test_cases = [ {'n': 3, 'capacities': [100, 200, 300], 'd': 400}, {'n': 2, 'capacities': [100, 100], 'd': 250} ] results = can_store_data(t, test_cases) assert results == [\\"Data stored successfully!\\", \\"Insufficient disk space!\\"] def test_insufficient_space(): t = 1 test_cases = [ {'n': 3, 'capacities': [100, 200, 300], 'd': 1000} ] results = can_store_data(t, test_cases) assert results == [\\"Insufficient disk space!\\"] def test_exact_fit(): t = 1 test_cases = [ {'n': 2, 'capacities': [150, 150], 'd': 300} ] results = can_store_data(t, test_cases) assert results == [\\"Data stored successfully!\\"] def test_single_disk_fit(): t = 1 test_cases = [ {'n': 1, 'capacities': [500], 'd': 500} ] results = can_store_data(t, test_cases) assert results == [\\"Data stored successfully!\\"] def test_multiple_disks_fit(): t = 1 test_cases = [ {'n': 4, 'capacities': [50, 100, 150, 200], 'd': 500} ] results = can_store_data(t, test_cases) assert results == [\\"Data stored successfully!\\"] def test_large_number_of_disks(): t = 1 test_cases = [ {'n': 100, 'capacities': [1000] * 100, 'd': 50000} ] results = can_store_data(t, test_cases) assert results == [\\"Data stored successfully!\\"] def test_empty_case(): t = 1 test_cases = [ {'n': 0, 'capacities': [], 'd': 0} ] results = can_store_data(t, test_cases) assert results == [\\"Data stored successfully!\\"]","solution":"def can_store_data(t, test_cases): results = [] for case in test_cases: n = case['n'] capacities = case['capacities'] d = case['d'] if sum(capacities) >= d: results.append(\\"Data stored successfully!\\") else: results.append(\\"Insufficient disk space!\\") return results # Sample Driver t = 2 test_cases = [ {'n': 3, 'capacities': [100, 200, 300], 'd': 400}, {'n': 2, 'capacities': [100, 100], 'd': 250} ] results = can_store_data(t, test_cases) for result in results: print(result)"},{"question":"from typing import List def min_moves(n: int, grid: List[str]) -> int: Calculate the minimum number of moves required for a drone to deliver a package from the top-left corner to the bottom-right corner of an n x n grid. Args: n (int): the size of the grid. grid (List[str]): the grid represented by a list of strings, where '0' is a free space and '1' is an obstacle. Returns: int: the minimum number of moves required, or -1 if it is impossible to reach the destination. Examples: >>> min_moves(4, [\\"0000\\", \\"1100\\", \\"0010\\", \\"0000\\"]) 6 >>> min_moves(3, [\\"010\\", \\"111\\", \\"000\\"]) -1 pass def test_min_moves_path_exists(): grid = [ \\"0000\\", \\"1100\\", \\"0010\\", \\"0000\\" ] assert min_moves(4, grid) == 6 def test_min_moves_path_blocked(): grid = [ \\"010\\", \\"111\\", \\"000\\" ] assert min_moves(3, grid) == -1 def test_min_moves_single_cell(): grid = [ \\"0\\" ] assert min_moves(1, grid) == 0 def test_min_moves_all_obstacles(): grid = [ \\"111\\", \\"111\\", \\"111\\" ] assert min_moves(3, grid) == -1 def test_min_moves_large_grid(): grid = [ \\"0000000\\", \\"0111110\\", \\"0100010\\", \\"0101110\\", \\"0100000\\", \\"0111110\\", \\"0000000\\" ] assert min_moves(7, grid) == 12 def test_min_moves_no_obstacles(): grid = [ \\"000\\", \\"000\\", \\"000\\" ] assert min_moves(3, grid) == 4","solution":"from collections import deque def min_moves(n, grid): if n == 0 or grid[0][0] == '1' or grid[n-1][n-1] == '1': return -1 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] visited = [[False] * n for _ in range(n)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited[0][0] = True while queue: row, col, dist = queue.popleft() if row == n-1 and col == n-1: return dist for direction in directions: new_row, new_col = row + direction[0], col + direction[1] if 0 <= new_row < n and 0 <= new_col < n and not visited[new_row][new_col] and grid[new_row][new_col] == '0': queue.append((new_row, new_col, dist + 1)) visited[new_row][new_col] = True return -1"},{"question":"def does_subarray_with_zero_sum_exist(arr: List[int]) -> str: Determines if there exists a subarray with a sum of zero. :param arr: List of integers. :return: \\"Yes\\" if there exists a subarray with zero sum, \\"No\\" otherwise. >>> does_subarray_with_zero_sum_exist([4, 2, -3, 1, 6]) \\"Yes\\" >>> does_subarray_with_zero_sum_exist([1, 2, 3, 4]) \\"No\\" >>> does_subarray_with_zero_sum_exist([1, -1]) \\"Yes\\" >>> does_subarray_with_zero_sum_exist([0]) \\"Yes\\" >>> does_subarray_with_zero_sum_exist([1, 2, -2, 1]) \\"Yes\\" >>> does_subarray_with_zero_sum_exist([-1, -1, -1]) \\"No\\" >>> does_subarray_with_zero_sum_exist([]) \\"No\\" >>> does_subarray_with_zero_sum_exist([1, 2, 3, -5, 5, -1, -1]) \\"Yes\\"","solution":"def does_subarray_with_zero_sum_exist(arr): Determines if there exists a subarray with a sum of zero. :param arr: List of integers. :return: \\"Yes\\" if there exists a subarray with zero sum, \\"No\\" otherwise. sum_seen = set() sum_so_far = 0 for num in arr: sum_so_far += num # Check if cumulative sum is zero or is already seen if sum_so_far == 0 or sum_so_far in sum_seen: return \\"Yes\\" sum_seen.add(sum_so_far) return \\"No\\""},{"question":"def longest_repeated_subsequence(n: int, s: str) -> int: Returns the length of the longest subsequence that repeats itself twice non-overlapping in the string s. >>> longest_repeated_subsequence(6, \\"banana\\") 3 >>> longest_repeated_subsequence(4, \\"abcd\\") 0 >>> longest_repeated_subsequence(7, \\"abcbabc\\") 3 >>> longest_repeated_subsequence(5, \\"aaaaa\\") 4 >>> longest_repeated_subsequence(5, \\"abcde\\") 0 >>> longest_repeated_subsequence(1, \\"a\\") 0 >>> longest_repeated_subsequence(2, \\"ab\\") 0 >>> longest_repeated_subsequence(2, \\"aa\\") 1","solution":"def longest_repeated_subsequence(n, s): Returns the length of the longest subsequence that repeats itself twice non-overlapping in the string s. # Create a 2D DP array of size (n+1) x (n+1) dp = [[0] * (n + 1) for _ in range(n + 1)] # Fill the dp array for i in range(1, n + 1): for j in range(1, n + 1): if s[i - 1] == s[j - 1] and i != j: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][n]"},{"question":"def reverse_each_word(s: str) -> str: Takes a string as input and returns the string with each word reversed but words in the same order. >>> reverse_each_word(\\"hello world\\") \\"olleh dlrow\\" >>> reverse_each_word(\\"coding is fun\\") \\"gnidoc si nuf\\" >>> reverse_each_word(\\"reverse each word\\") \\"esrever hcae drow\\"","solution":"def reverse_each_word(s): Takes a string as input and returns the string with each word reversed but words in the same order. return ' '.join(word[::-1] for word in s.split())"},{"question":"def count_paths(m, n, blocked_cells): Returns the number of distinct paths from the top-left corner to the bottom-right corner in an m x n grid with specified blocked cells. >>> count_paths(3, 3, [(2, 2), (3, 1)]) == 1 >>> count_paths(3, 3, []) == 6 >>> count_paths(2, 2, [(1, 1)]) == 0 >>> count_paths(3, 3, [(1, 2), (2, 1)]) == 0 >>> count_paths(1, 1, []) == 1","solution":"def count_paths(m, n, blocked_cells): Returns the number of distinct paths from the top-left corner to the bottom-right corner in an m x n grid with specified blocked cells. # Create a grid to store the number of ways to reach each cell grid = [[0 for _ in range(n)] for _ in range(m)] # Initialize the starting point if (1, 1) in blocked_cells: return 0 grid[0][0] = 1 # Fill the grid for i in range(m): for j in range(n): if (i+1, j+1) in blocked_cells: grid[i][j] = 0 else: if i > 0: grid[i][j] += grid[i-1][j] if j > 0: grid[i][j] += grid[i][j-1] return grid[m-1][n-1] def solve(grid_cases): Process multiple test cases and return a list with number of paths for each case. results = [] for case in grid_cases: m, n, b, blocked_cells = case results.append(count_paths(m, n, blocked_cells)) return results"},{"question":"def min_scarecrows(m: int, n: int, farmland: List[List[int]]) -> int: Determine the minimum number of scarecrows needed to protect all the crop land. >>> min_scarecrows(3, 3, [ ... [1, 0, 1], ... [0, 1, 0], ... [1, 0, 1] ... ]) 5 >>> min_scarecrows(3, 3, [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 >>> min_scarecrows(3, 3, [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 5 >>> min_scarecrows(1, 6, [ ... [1, 0, 1, 1, 0, 1] ... ]) 3 >>> min_scarecrows(6, 1, [ ... [1], ... [0], ... [1], ... [1], ... [0], ... [1] ... ]) 3 >>> min_scarecrows(4, 2, [ ... [1, 0], ... [0, 1], ... [1, 0], ... [0, 1] ... ]) 4","solution":"def min_scarecrows(m, n, farmland): scarecrows = 0 protected = [[False] * n for _ in range(m)] for i in range(m): for j in range(n): if farmland[i][j] == 1 and not protected[i][j]: scarecrows += 1 # Protect this cell and its adjacent cells (if within bounds) for di, dj in [(0, 0), (1, 0), (0, 1), (-1, 0), (0, -1)]: ni, nj = i + di, j + dj if 0 <= ni < m and 0 <= nj < n: protected[ni][nj] = True return scarecrows"},{"question":"def is_prime(n: int) -> bool: Helper function to check if a number is a prime. >>> is_prime(1) False >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(29) True >>> is_prime(10) False >>> is_prime(11) True def filter_primes(lst: List[int]) -> List[int]: Returns a list containing only the prime numbers from the input list. >>> filter_primes([10, 3, 7, 15, 20, 11]) [3, 7, 11] >>> filter_primes([4, 6, 8, 9, 10]) [] >>> filter_primes([2, 3, 5, 7, 11]) [2, 3, 5, 7, 11] >>> filter_primes([14, 18, 22, 35, 40]) [] >>> filter_primes([17, 29, 41, 53, 67]) [17, 29, 41, 53, 67] >>> filter_primes([]) []","solution":"def is_prime(n): Helper function to check if a number is a prime. if n <= 1: return False if n == 2: return True # 2 is the only even prime number if n % 2 == 0: return False max_divisor = int(n**0.5) + 1 for d in range(3, max_divisor, 2): if n % d == 0: return False return True def filter_primes(lst): Returns a list containing only the prime numbers from the input list. return [x for x in lst if is_prime(x)]"},{"question":"from typing import List def max_solar_panel_efficiency(grid: List[List[int]]) -> int: Returns the maximum solar panel efficiency, which is the maximum value in the grid. >>> max_solar_panel_efficiency([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 1, 11], ... [12, 13, 14, 0] ... ]) == 14 >>> max_solar_panel_efficiency([ ... [0, 1, 2], ... [3, 0, 4], ... [2, 1, 0] ... ]) == 4","solution":"def max_solar_panel_efficiency(grid): Returns the maximum solar panel efficiency, which is the maximum value in the grid. # Initialize the maximum efficiency to a very small number max_efficiency = float('-inf') # Traverse each cell in the grid for row in grid: max_efficiency = max(max_efficiency, max(row)) return max_efficiency"},{"question":"def average_problems_solved(solved_list: List[int]) -> int: Returns the average number of problems solved, rounded down to the nearest integer. >>> average_problems_solved([4, 7, 2, 10]) == 5 >>> average_problems_solved([1, 1, 1, 1, 1]) == 1 def parse_input(input_string: str) -> List[int]: Parses the input string to a list of integers. >>> parse_input(\\"4 7 2 10\\") == [4, 7, 2, 10] >>> parse_input(\\"1 1 1 1 1\\") == [1, 1, 1, 1, 1] # Test cases from solution import average_problems_solved, parse_input def test_average_problems_solved(): assert average_problems_solved([4, 7, 2, 10]) == 5 assert average_problems_solved([1, 1, 1, 1, 1]) == 1 assert average_problems_solved([0, 0, 0, 0, 0]) == 0 assert average_problems_solved([10, 20, 30, 40, 50]) == 30 def test_parse_input(): assert parse_input(\\"4 7 2 10\\") == [4, 7, 2, 10] assert parse_input(\\"1 1 1 1 1\\") == [1, 1, 1, 1, 1] assert parse_input(\\"0 0 0 0 0\\") == [0, 0, 0, 0, 0] assert parse_input(\\"10 20 30 40 50\\") == [10, 20, 30, 40, 50] def test_integration(): input_data = \\"4 7 2 10\\" parsed_data = parse_input(input_data) assert average_problems_solved(parsed_data) == 5 input_data = \\"1 1 1 1 1\\" parsed_data = parse_input(input_data) assert average_problems_solved(parsed_data) == 1 input_data = \\"0 0 0 0 0\\" parsed_data = parse_input(input_data) assert average_problems_solved(parsed_data) == 0 input_data = \\"10 20 30 40 50\\" parsed_data = parse_input(input_data) assert average_problems_solved(parsed_data) == 30","solution":"def average_problems_solved(solved_list): Returns the average number of problems solved, rounded down to the nearest integer. total_problems = sum(solved_list) number_of_people = len(solved_list) return total_problems // number_of_people def parse_input(input_string): Parses the input string to a list of integers. return list(map(int, input_string.split()))"},{"question":"def count_unique_elements(n: int, q: int, arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Returns the number of unique elements in the specified subarrays for each query. Parameters: n (int): Size of the array. q (int): Number of queries. arr (list of int): The array of elements. queries (list of tuple): The list of queries, where each query is a tuple (left, right). Returns: list of int: The number of unique elements for each query's subarray. Examples: >>> count_unique_elements(5, 3, [1, 2, 1, 3, 2], [(1, 3), (2, 5), (1, 5)]) [2, 3, 3] >>> count_unique_elements(6, 2, [1, 1, 1, 1, 1, 1], [(1, 6), (2, 4)]) [1, 1]","solution":"def count_unique_elements(n, q, arr, queries): Returns the number of unique elements in the specified subarrays for each query. Parameters: n (int): Size of the array. q (int): Number of queries. arr (list of int): The array of elements. queries (list of tuple): The list of queries, where each query is a tuple (left, right). Returns: list of int: The number of unique elements for each query's subarray. results = [] for left, right in queries: subarray = arr[left-1:right] # Convert 1-based to 0-based index unique_elements = set(subarray) results.append(len(unique_elements)) return results"},{"question":"def count_triplets(arr: List[int]) -> int: Count the number of triplets (a[i], a[j], a[k]) in the array such that a[i] < a[j] < a[k] and i < j < k. >>> count_triplets([4, 7, 1, 9, 3, 10, 5]) 7 >>> count_triplets([4, 3, 2, 1]) 0 >>> count_triplets([1, 2, 3]) 1 from typing import List def count_triplets_from_input(n: int, elements: str) -> int: Convert the input string to a list of integers and count the triplets. >>> count_triplets_from_input(7, \\"4 7 1 9 3 10 5\\") 7","solution":"def count_triplets(arr): n = len(arr) if n < 3: return 0 count = 0 for i in range(n): for j in range(i+1, n): for k in range(j+1, n): if arr[i] < arr[j] < arr[k]: count += 1 return count def count_triplets_from_input(n, elements): arr = list(map(int, elements.split())) return count_triplets(arr)"},{"question":"def max_total_value(S: int, n: int, items: List[Tuple[str, int]]) -> int: Returns the maximum total value that can be stored in the warehouse without exceeding the given capacity. Parameters: S (int): Maximum storage capacity n (int): Number of different items items (list): List of tuples, each containing the name and value of an item Returns: int: The maximum total value >>> max_total_value(50, 3, [(\\"item1\\", 20), (\\"item2\\", 30), (\\"item3\\", 25)]) 50 >>> max_total_value(15, 2, [(\\"itemA\\", 20), (\\"itemB\\", 10)]) 10 >>> max_total_value(100, 4, [(\\"itemA\\", 10), (\\"itemB\\", 20), (\\"itemC\\", 30), (\\"itemD\\", 40)]) 100 from typing import List, Tuple def test_max_total_value_example1(): S = 50 n = 3 items = [(\\"item1\\", 20), (\\"item2\\", 30), (\\"item3\\", 25)] assert max_total_value(S, n, items) == 50 def test_max_total_value_example2(): S = 15 n = 2 items = [(\\"itemA\\", 20), (\\"itemB\\", 10)] assert max_total_value(S, n, items) == 10 def test_max_total_value_example3(): S = 100 n = 4 items = [(\\"itemA\\", 10), (\\"itemB\\", 20), (\\"itemC\\", 30), (\\"itemD\\", 40)] assert max_total_value(S, n, items) == 100 def test_max_total_value_full_capacity(): S = 5 n = 2 items = [(\\"itemA\\", 1), (\\"itemB\\", 3)] assert max_total_value(S, n, items) == 5 def test_max_total_value_single_item(): S = 100 n = 1 items = [(\\"itemA\\", 1)] assert max_total_value(S, n, items) == 100 def test_max_total_value_no_items(): S = 0 n = 0 items = [] assert max_total_value(S, n, items) == 0","solution":"def max_total_value(S, n, items): Returns the maximum total value that can be stored in the warehouse without exceeding the given capacity. Parameters: S (int): Maximum storage capacity n (int): Number of different items items (list): List of tuples, each containing the name and value of an item Returns: int: The maximum total value values = [value for name, value in items] # Initialize an array dp with S+1 elements, all set to 0 dp = [0] * (S + 1) # Iterate over each item value for value in values: # Update the dp array from right to left for i in range(value, S + 1): dp[i] = max(dp[i], dp[i-value] + value) return dp[S]"},{"question":"from typing import List, Tuple def calculate_discount(t: int, user_data: List[Tuple[int, List[int]]]) -> List[int]: Calculate the discount for each user based on their purchase history. Args: t (int): Number of users. user_data (list of tuples): Each tuple contains the number of purchases and the list of purchase prices for one user. Returns: list: List of discounts for each user. Example: >>> calculate_discount(3, [ ... (5, [100, 200, 100, 300, 200]), ... (4, [500, 500, 200, 200]), ... (3, [700, 800, 900]) ... ]) [200, 500, 900]","solution":"def calculate_discount(t, user_data): Calculate the discount for each user based on their purchase history. Args: t (int): Number of users. user_data (list of tuples): Each tuple contains the number of purchases and the list of purchase prices for one user. Returns: list: List of discounts for each user. discounts = [] for i in range(t): n, prices = user_data[i] frequency = {} # Calculate the frequency of each price for price in prices: if price in frequency: frequency[price] += 1 else: frequency[price] = 1 # Find the price with the highest frequency max_frequency = max(frequency.values()) most_frequent_prices = [price for price, freq in frequency.items() if freq == max_frequency] # The discount is the highest price among the most frequent prices discount = max(most_frequent_prices) discounts.append(discount) return discounts"},{"question":"from typing import List def longest_increasing_subsequence_length(temperatures: List[int]) -> int: Returns the length of the longest increasing subsequence of temperatures. >>> longest_increasing_subsequence_length([5, 3, 4, 8, 6, 7]) 4 >>> longest_increasing_subsequence_length([-5, -1, 0, 3, -4, 5]) 5 >>> longest_increasing_subsequence_length([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence_length([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence_length([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence_length([1, 3, 2, 1, 5, 4, 7, 3, 6, 5, 8]) 5 >>> longest_increasing_subsequence_length([]) 0 >>> longest_increasing_subsequence_length([7]) 1 >>> longest_increasing_subsequence_length([3, 10, 2, 1, 20]) 3 >>> longest_increasing_subsequence_length([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]) 6","solution":"def longest_increasing_subsequence_length(temperatures): Returns the length of the longest increasing subsequence of temperatures. if not temperatures: return 0 n = len(temperatures) dp = [1] * n # dp[i] will be the length of LIS ending at index i for i in range(1, n): for j in range(i): if temperatures[i] > temperatures[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def maximalSquare(matrix: List[List[int]]) -> int: Given a binary matrix representing a grid, returns the area of the largest square that can be constructed using only 1s. :param matrix: a list of lists of integers (0 or 1) representing the grid :return: an integer representing the area of the largest square >>> grid = [ ... [0, 1, 1, 0, 1], ... [1, 1, 0, 1, 0], ... [0, 1, 1, 1, 0], ... [1, 1, 1, 1, 0], ... [1, 1, 1, 1, 1] ... ] >>> maximalSquare(grid) 9 >>> grid = [ ... [1, 0, 1, 0], ... [1, 1, 1, 1], ... [0, 1, 1, 1] ... ] >>> maximalSquare(grid) 4","solution":"def maximalSquare(matrix): Given a binary matrix representing a grid, returns the area of the largest square that can be constructed using only 1s. :param matrix: a list of lists of integers (0 or 1) representing the grid :return: an integer representing the area of the largest square if not matrix: return 0 n = len(matrix) m = len(matrix[0]) dp = [[0] * (m + 1) for _ in range(n + 1)] max_side = 0 for i in range(1, n + 1): for j in range(1, m + 1): if matrix[i-1][j-1] == 1: dp[i][j] = min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side # Example usage: grid = [ [0, 1, 1, 0, 1], [1, 1, 0, 1, 0], [0, 1, 1, 1, 0], [1, 1, 1, 1, 0], [1, 1, 1, 1, 1] ] print(maximalSquare(grid)) # Output: 9"},{"question":"def find_triplets_with_zero_sum(n: int, array: List[int]) -> None: Given an array of integers, find all unique triplets that give a sum of zero. Output the unique triplets in non-descending order. Each triplet should be printed only once. >>> find_triplets_with_zero_sum(6, [-1, 0, 1, 2, -1, -4]) -1 -1 2 -1 0 1 >>> find_triplets_with_zero_sum(5, [1, 2, 3, 4, 5]) >>> find_triplets_with_zero_sum(4, [0, 0, 0, 0]) 0 0 0 >>> find_triplets_with_zero_sum(7, [-2, -1, 0, 1, 2, -1, -4]) -2 0 2 -1 -1 2 -1 0 1 >>> find_triplets_with_zero_sum(8, [-1, -1, -1, 0, 0, 1, 1, 1]) -1 0 1","solution":"def find_triplets_with_zero_sum(n, array): array.sort() triplets = set() for i in range(n): if i > 0 and array[i] == array[i - 1]: continue left, right = i + 1, n - 1 while left < right: sum = array[i] + array[left] + array[right] if sum == 0: triplets.add((array[i], array[left], array[right])) left += 1 right -= 1 while left < right and array[left] == array[left - 1]: left += 1 while left < right and array[right] == array[right + 1]: right -= 1 elif sum < 0: left += 1 else: right -= 1 for triplet in triplets: print(f\\"{triplet[0]} {triplet[1]} {triplet[2]}\\")"},{"question":"def is_all_planets_connected(n: int, grid: List[List[str]]) -> str: Determine whether it is possible to visit all the planets starting from any planet and only using portals. Args: n (int): The size of the grid. grid (List[List[str]]): The grid where each cell contains either '.' (a planet) or '#' (empty space). Returns: str: \\"YES\\" if it is possible to visit all planets starting from any planet, otherwise \\"NO\\". Examples: >>> is_all_planets_connected(4, [list(\\"....\\"), list(\\".#..\\"), list(\\".#..\\"), list(\\"....\\")]) \\"YES\\" >>> is_all_planets_connected(3, [list(\\"#\\"), list(\\"#.#\\"), list(\\".#\\")]) \\"NO\\"","solution":"def is_all_planets_connected(n, grid): def dfs(x, y): if x < 0 or y < 0 or x >= n or y >= n or grid[x][y] != '.': return grid[x][y] = '#' # Mark it as visited # Explore all adjacent cells dfs(x+1, y) dfs(x-1, y) dfs(x, y+1) dfs(x, y-1) components = 0 for i in range(n): for j in range(n): if grid[i][j] == '.': if components > 0: # If we find another component, return early return \\"NO\\" dfs(i, j) components += 1 return \\"YES\\" if components == 1 else \\"NO\\""},{"question":"def count_islands(matrix): Returns the number of distinct islands in the given matrix. An island is a group of adjacent 1s that are connected vertically or horizontally. >>> count_islands([ ... [1, 1, 0, 0, 0], ... [0, 1, 0, 0, 1], ... [1, 0, 0, 1, 1], ... [0, 0, 0, 0, 0] ... ]) == 3 >>> count_islands([ ... [1, 1, 0], ... [0, 0, 0], ... [1, 1, 1] ... ]) == 2","solution":"def count_islands(matrix): Returns the number of distinct islands in the given matrix. An island is a group of adjacent 1s that are connected vertically or horizontally. def dfs(x, y): if x < 0 or y < 0 or x >= N or y >= M or matrix[x][y] != 1: return matrix[x][y] = -1 # Mark the cell as visited # Explore all adjacent cells (vertically and horizontally) dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) N = len(matrix) M = len(matrix[0]) island_count = 0 for i in range(N): for j in range(M): if matrix[i][j] == 1: dfs(i, j) island_count += 1 return island_count"},{"question":"def reverse_str(s: str, k: int) -> str: Reverse the first k characters for every 2k characters from the start of the string. Args: s (str): The input string. k (int): The number of characters to reverse for each segment. Returns: str: The modified string. >>> reverse_str(\\"abcdefg\\", 2) 'bacdfeg' >>> reverse_str(\\"abcdefghij\\", 3) 'cbadefihgj'","solution":"def reverse_str(s, k): Reverse the first k characters for every 2k characters from the start of the string. Args: s (str): The input string. k (int): The number of characters to reverse for each segment. Returns: str: The modified string. result = [] n = len(s) for i in range(0, n, 2 * k): part = s[i:i + k][::-1] + s[i + k:i + 2 * k] result.append(part) return \\"\\".join(result)"},{"question":"from typing import List, Tuple def edmonds_karp(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Calculate the maximum flow from the source node (0) to sink node (n-1) using the Edmonds-Karp algorithm. Args: n (int): The number of reservoirs (nodes). m (int): The number of pipes (edges). edges (List[Tuple[int, int, int]]): The list of edges where each edge is represented by a tuple (U, V, C) indicating a pipe from reservoir U to reservoir V with a flow capacity of C. Returns: int: The maximum flow from the source node to the sink node. Example: >>> edmonds_karp(6, 9, [(0, 1, 16), (0, 2, 13), (1, 2, 10), (1, 3, 12), (2, 1, 4), (2, 4, 14), (3, 2, 9), (3, 5, 20), (4, 3, 7), (4, 5, 4)]) 23 >>> edmonds_karp(3, 1, [(0, 2, 1)]) 1 >>> edmonds_karp(4, 2, [(0, 1, 1), (2, 3, 1)]) 0 >>> edmonds_karp(4, 5, [(0, 1, 100), (0, 2, 100), (1, 3, 100), (2, 3, 100), (1, 2, 2)]) 200 >>> edmonds_karp(4, 5, [(0, 1, 10), (1, 0, 10), (1, 2, 20), (2, 1, 20), (2, 3, 10)]) 10 pass","solution":"from collections import deque def bfs(capacity, source, sink, parent): visited = [False] * len(capacity) queue = deque([source]) visited[source] = True while queue: current = queue.popleft() for adj, cap in enumerate(capacity[current]): if not visited[adj] and cap > 0: queue.append(adj) visited[adj] = True parent[adj] = current if adj == sink: return True return False def edmonds_karp(n, m, edges): source = 0 sink = n - 1 capacity = [[0] * n for _ in range(n)] for u, v, c in edges: capacity[u][v] += c parent = [-1] * n max_flow = 0 while bfs(capacity, source, sink, parent): path_flow = float('Inf') s = sink while s != source: path_flow = min(path_flow, capacity[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] capacity[u][v] -= path_flow capacity[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"from typing import List def count_possible_squads(n: int, k: int, a: List[int]) -> int: Returns the number of different possible squads of size k that can be formed with strictly increasing skill levels from the given recruits. >>> count_possible_squads(5, 3, [2, 5, 3, 6, 4]) 3 >>> count_possible_squads(4, 2, [1, 2, 3, 4]) 6 pass # Your code here","solution":"from itertools import combinations def count_possible_squads(n, k, a): Returns the number of different possible squads of size k that can be formed with strictly increasing skill levels from the given recruits. possible_squads = 0 # Generate all combinations of the array \`a\` of length \`k\` for squad in combinations(a, k): # Check if the combination is strictly increasing if list(squad) == sorted(squad): possible_squads += 1 return possible_squads"},{"question":"class DataStructure: def __init__(self): Initialize the data structure. pass def insert(self, x): Insert a value into the data structure. Args: x: int pass def delete(self, x): Delete a value from the data structure if it exists. Args: x: int pass def find_kth_smallest(self, k): Find the k-th smallest element in the data structure. Args: k: int Returns: int or str: the k-th smallest element, or \\"invalid\\" if there are fewer than k elements. pass def process_operations(n, operations): Process the operations on the data structure. Args: n: int - number of operations operations: list of tuples - each tuple contains an operation in the format (\\"I\\", x), (\\"D\\", x), or (\\"K\\", k) Returns: list: results of \\"K\\" operations ds = DataStructure() output = [] for operation in operations: if operation[0] == 'I': ds.insert(operation[1]) elif operation[0] == 'D': ds.delete(operation[1]) elif operation[0] == 'K': result = ds.find_kth_smallest(operation[1]) output.append(result) return output # Example Usage: # ds = DataStructure() # ds.insert(3) # ds.insert(1) # ds.insert(5) # assert ds.find_kth_smallest(2) == 3 # ds.delete(1) # assert ds.find_kth_smallest(2) == 5 # Unit Tests def test_process_operations(): operations = [ (\\"I\\", 3), (\\"I\\", 1), (\\"I\\", 5), (\\"K\\", 2), (\\"D\\", 1), (\\"K\\", 2) ] assert process_operations(6, operations) == [3, 5] def test_process_operations_with_invalid_k(): operations = [ (\\"I\\", 3), (\\"I\\", 1), (\\"K\\", 3) ] assert process_operations(3, operations) == [\\"invalid\\"] def test_process_operations_with_deletion(): operations = [ (\\"I\\", 3), (\\"I\\", 1), (\\"I\\", 5), (\\"D\\", 5), (\\"K\\", 1), (\\"D\\", 1), (\\"K\\", 1) ] assert process_operations(7, operations) == [1, 3] def test_process_operations_with_multiple_inserts(): operations = [ (\\"I\\", 3), (\\"I\\", 1), (\\"I\\", 1), (\\"K\\", 2) ] assert process_operations(4, operations) == [1] def test_process_operations_with_complex_case(): operations = [ (\\"I\\", 8), (\\"I\\", 3), (\\"I\\", 5), (\\"D\\", 8), (\\"K\\", 2), (\\"I\\", 7), (\\"D\\", 5), (\\"K\\", 2), (\\"I\\", 8), (\\"K\\", 3) ] assert process_operations(10, operations) == [5, 7, 8]","solution":"import bisect class DataStructure: def __init__(self): self.elements = [] def insert(self, x): bisect.insort(self.elements, x) def delete(self, x): idx = bisect.bisect_left(self.elements, x) if idx < len(self.elements) and self.elements[idx] == x: self.elements.pop(idx) def find_kth_smallest(self, k): if k <= 0 or k > len(self.elements): return \\"invalid\\" return self.elements[k-1] def process_operations(n, operations): ds = DataStructure() output = [] for operation in operations: if operation[0] == 'I': ds.insert(operation[1]) elif operation[0] == 'D': ds.delete(operation[1]) elif operation[0] == 'K': result = ds.find_kth_smallest(operation[1]) output.append(result) return output"},{"question":"import re def is_valid_password(password: str) -> bool: Validates if the given password adheres to the secret society's guidelines. The password should be at least 8 characters long, contain at least one uppercase letter, one lowercase letter, one digit, and one special character from the set \`!@#%^&*()-+\`. Args: password (str): The password to validate. Returns: bool: True if the password is valid, False otherwise. Examples: >>> is_valid_password(\\"Password123!\\") True >>> is_valid_password(\\"pass123\\") False >>> is_valid_password(\\"PASSWORD123@\\") False >>> is_valid_password(\\"Pa1\\") False >>> is_valid_password(\\"ValidPassword1\\") True pass","solution":"import re def is_valid_password(password): Validates if the given password adheres to the secret society's guidelines. Parameters: password (str): The password to validate. Returns: bool: True if the password is valid, False otherwise. if len(password) < 8: return False if not re.search(r'[A-Z]', password): return False if not re.search(r'[a-z]', password): return False if not re.search(r'[0-9]', password): return False if not re.search(r'[!@#%^&*()-+]', password): return False return True"},{"question":"def is_valid_subset(n: int, existing_parts: List[int], m: int, new_parts: List[int]) -> str: Determines if the new set of parts is a subset of the existing toy car's parts. :param n: Integer, number of unique parts in the existing toy car :param existing_parts: List of integers, parts of the existing toy car :param m: Integer, number of parts in the new set of parts :param new_parts: List of integers, parts of the new set :return: \\"VALID\\" if new_parts is a subset of existing_parts, otherwise \\"INVALID\\" >>> is_valid_subset(5, [1, 2, 3, 4, 5], 3, [2, 4, 1]) 'VALID' >>> is_valid_subset(6, [10, 20, 30, 40, 50, 60], 3, [15, 20, 30]) 'INVALID' pass # Test cases def test_is_valid_subset_all_included(): assert is_valid_subset(5, [1, 2, 3, 4, 5], 3, [2, 4, 1]) == \\"VALID\\" def test_is_valid_subset_partial(): assert is_valid_subset(6, [10, 20, 30, 40, 50, 60], 3, [15, 20, 30]) == \\"INVALID\\" def test_is_valid_subset_mixed_parts(): assert is_valid_subset(4, [1, 5, 9, 13], 2, [5, 13]) == \\"VALID\\" def test_is_valid_subset_none_match(): assert is_valid_subset(4, [1, 3, 5, 7], 2, [8, 9]) == \\"INVALID\\" def test_is_valid_subset_empty_subset(): assert is_valid_subset(4, [1, 3, 5, 7], 0, []) == \\"VALID\\" def test_is_valid_subset_equal_parts(): assert is_valid_subset(3, [3, 6, 9], 3, [3, 6, 9]) == \\"VALID\\" def test_is_valid_subset_empty_existing_parts(): assert is_valid_subset(0, [], 2, [1, 2]) == \\"INVALID\\" def test_is_valid_subset_identical_one_part(): assert is_valid_subset(1, [1], 1, [1]) == \\"VALID\\"","solution":"def is_valid_subset(n, existing_parts, m, new_parts): Determines if the new set of parts is a subset of the existing toy car's parts. :param n: Integer, number of unique parts in the existing toy car :param existing_parts: List of integers, parts of the existing toy car :param m: Integer, number of parts in the new set of parts :param new_parts: List of integers, parts of the new set :return: \\"VALID\\" if new_parts is a subset of existing_parts, otherwise \\"INVALID\\" existing_parts_set = set(existing_parts) new_parts_set = set(new_parts) if new_parts_set.issubset(existing_parts_set): return \\"VALID\\" else: return \\"INVALID\\""},{"question":"def calculate_total_amount(n: int, items: List[str]) -> str: Calculates the total amount for the selected items. >>> calculate_total_amount(1, ['Chocolate Cake']) \\"Total Amount: 15\\" >>> calculate_total_amount(1, ['Blueberry Muffin']) \\"Total Amount: 6\\" >>> calculate_total_amount(2, ['Strawberry Cake', 'Blueberry Muffin']) \\"Total Amount: 22\\" >>> calculate_total_amount(3, ['Chocolate Cake', 'Croissant', 'Cheese Tart']) \\"Total Amount: 27\\" >>> calculate_total_amount(5, ['Chocolate Cake', 'Strawberry Cake', 'Blueberry Muffin', 'Cheese Tart', 'Croissant']) \\"Total Amount: 49\\" >>> calculate_total_amount(3, ['Croissant', 'Croissant', 'Croissant']) \\"Total Amount: 12\\" >>> items = ['Chocolate Cake', 'Strawberry Cake', 'Blueberry Muffin', 'Cheese Tart', 'Croissant'] >>> large_input = items * 20 # makes a total of 100 items >>> calculate_total_amount(100, large_input) \\"Total Amount: 980\\"","solution":"def calculate_total_amount(n, items): Calculates the total amount for the selected items. menu = { 'Chocolate Cake': 15, 'Strawberry Cake': 16, 'Blueberry Muffin': 6, 'Cheese Tart': 8, 'Croissant': 4 } total_amount = sum(menu[item] for item in items) return f\\"Total Amount: {total_amount}\\""},{"question":"from typing import List def shortest_path_with_one_wall_change(n: int, m: int, grid: List[str]) -> int: Determine the length of the shortest path to reach the bottom-right corner while changing at most one wall ('1') to an empty cell ('0'). >>> shortest_path_with_one_wall_change(3, 3, [\\"011\\", \\"110\\", \\"000\\"]) 5 >>> shortest_path_with_one_wall_change(4, 4, [\\"0100\\", \\"1110\\", \\"1000\\", \\"0000\\"]) 7 >>> shortest_path_with_one_wall_change(2, 2, [\\"11\\", \\"11\\"]) -1 pass","solution":"from collections import deque def shortest_path_with_one_wall_change(n, m, grid): Function to find the shortest path from top-left to bottom-right in a grid with the option to change at most one wall to a free cell. if not grid or not grid[0]: return -1 # Directions for movement directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # BFS queue: (row, col, cost, wall_break_used) queue = deque([(0, 0, 1, 0)]) visited = set((0, 0, 0)) while queue: x, y, cost, wall_break = queue.popleft() # If we've reached the bottom-right corner if x == n - 1 and y == m - 1: return cost for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m: if grid[nx][ny] == '0' and (nx, ny, wall_break) not in visited: visited.add((nx, ny, wall_break)) queue.append((nx, ny, cost + 1, wall_break)) if grid[nx][ny] == '1' and wall_break == 0 and (nx, ny, 1) not in visited: visited.add((nx, ny, 1)) queue.append((nx, ny, cost + 1, 1)) return -1"},{"question":"def max_people_line(n: int, m: int, heights: List[int], edges: List[Tuple[int, int]]) -> int: Calculate the maximum number of people who can form a line such that each person can see the next person in the line and when standing in the line, each person is taller than the person in front of them. >>> max_people_line(5, 4, [150, 160, 170, 180, 190], [(1, 2), (2, 3), (3, 4), (4, 5)]) 5 >>> max_people_line(5, 3, [120, 140, 150, 160, 180], [(1, 2), (2, 3), (2, 4)]) 3 import pytest from solution import max_people_line def test_example_1(): n, m = 5, 4 heights = [150, 160, 170, 180, 190] edges = [(1, 2), (2, 3), (3, 4), (4, 5)] assert max_people_line(n, m, heights, edges) == 5 def test_example_2(): n, m = 5, 3 heights = [120, 140, 150, 160, 180] edges = [(1, 2), (2, 3), (2, 4)] assert max_people_line(n, m, heights, edges) == 3 def test_single_person(): n, m = 1, 0 heights = [150] edges = [] assert max_people_line(n, m, heights, edges) == 1 def test_no_valid_chain(): n, m = 3, 2 heights = [150, 140, 130] edges = [(1, 2), (2, 3)] assert max_people_line(n, m, heights, edges) == 1 def test_complex_case(): n, m = 6, 6 heights = [100, 120, 150, 140, 180, 200] edges = [(1, 2), (2, 3), (3, 4), (4, 5), (3, 6), (5, 6)] assert max_people_line(n, m, heights, edges) == 4 if __name__ == \\"__main__\\": pytest.main()","solution":"from collections import defaultdict, deque def max_people_line(n, m, heights, edges): graph = defaultdict(list) indegree = [0] * n for u, v in edges: if heights[u-1] < heights[v-1]: # Only consider edges where height is increasing graph[u-1].append(v-1) indegree[v-1] += 1 queue = deque([i for i in range(n) if indegree[i] == 0]) dp = [0] * n for i in range(n): dp[i] = 1 while queue: node = queue.popleft() for neighbor in graph[node]: indegree[neighbor] -= 1 dp[neighbor] = max(dp[neighbor], dp[node] + 1) if indegree[neighbor] == 0: queue.append(neighbor) return max(dp) # Example of usage: # n, m = 5, 4 # heights = [150, 160, 170, 180, 190] # edges = [(1, 2), (2, 3), (3, 4), (4, 5)] # print(max_people_line(n, m, heights, edges)) # Output: 5 # Another example: # n, m = 5, 3 # heights = [120, 140, 150, 160, 180] # edges = [(1, 2), (2, 3), (2, 4)] # print(max_people_line(n, m, heights, edges)) # Output: 3"},{"question":"def kenken_puzzle(q: int, test_cases: List[Tuple[int, List[str]]]) -> List[List[str]]: Create a new KenKen puzzle from a given solution by obscuring some of the numbers. >>> kenken_puzzle(1, [(3, [\\"312\\", \\"231\\", \\"123\\"])]) [['3_2', '2_1', '_23']] >>> kenken_puzzle(2, [(4, [\\"1234\\", \\"3412\\", \\"2143\\", \\"4321\\"]), (4, [\\"4321\\", \\"2143\\", \\"3412\\", \\"1234\\"])]) [['1_34', '3_12', '_143', '_321'], ['4_21', '2_43', '3_12', '_234']] from typing import List, Tuple import random def obscure_grid(grid, n): obscured_grid = [list(row) for row in grid] for i in range(n): num_to_obscure = random.randint(1, n-1) indices = list(range(n)) random.shuffle(indices) for j in indices[:num_to_obscure]: obscured_grid[i][j] = '_' return [''.join(row) for row in obscured_grid] def test_single_3x3_puzzle(): q = 1 test_cases = [ (3, [\\"312\\", \\"231\\", \\"123\\"]) ] results = kenken_puzzle(q, test_cases) assert len(results) == 1 assert len(results[0]) == 3 for row in results[0]: assert len(row) == 3 assert '_' in row def test_two_4x4_puzzles(): q = 2 test_cases = [ (4, [\\"1234\\", \\"3412\\", \\"2143\\", \\"4321\\"]), (4, [\\"4321\\", \\"2143\\", \\"3412\\", \\"1234\\"]) ] results = kenken_puzzle(q, test_cases) assert len(results) == 2 for obscured_grid in results: assert len(obscured_grid) == 4 for row in obscured_grid: assert len(row) == 4 assert '_' in row def test_single_5x5_puzzle(): q = 1 test_cases = [ (5, [\\"12345\\", \\"54321\\", \\"31254\\", \\"25413\\", \\"43512\\"]) ] results = kenken_puzzle(q, test_cases) assert len(results) == 1 assert len(results[0]) == 5 for row in results[0]: assert len(row) == 5 assert '_' in row","solution":"import random def obscure_grid(grid, n): obscured_grid = [list(row) for row in grid] # we will randomly obscure some numbers for i in range(n): # choose a number of cells to obscure in each row num_to_obscure = random.randint(1, n-1) indices = list(range(n)) random.shuffle(indices) for j in indices[:num_to_obscure]: obscured_grid[i][j] = '_' return [''.join(row) for row in obscured_grid] def kenken_puzzle(q, test_cases): result = [] for test_case in test_cases: n, grid = test_case obscured_grid = obscure_grid(grid, n) result.append(obscured_grid) return result"},{"question":"def sort_events(events): Sorts a list of events first by timestamp and then by identifier. :param events: List of strings, each representing an event in the format <identifier>,<timestamp> :return: List of sorted events. pass def handle_events(input_data): Processes multiple events and returns the sorted results. :param input_data: List of input strings; the first element is the number of events. :return: List of sorted event strings. pass # Test cases from solution import sort_events, handle_events def test_sort_events_single_event(): assert sort_events([\\"event1,2023-01-01 10:00:00\\"]) == [\\"event1,2023-01-01 10:00:00\\"] def test_sort_events_different_timestamps(): events = [ \\"event1,2023-01-01 10:00:00\\", \\"event3,2023-01-01 09:00:00\\", \\"event2,2023-01-01 11:00:00\\" ] expected = [ \\"event3,2023-01-01 09:00:00\\", \\"event1,2023-01-01 10:00:00\\", \\"event2,2023-01-01 11:00:00\\" ] assert sort_events(events) == expected def test_sort_events_same_timestamps(): events = [ \\"event1,2023-01-01 10:00:00\\", \\"event2,2023-01-01 10:00:00\\", \\"event3,2023-01-01 09:00:00\\" ] expected = [ \\"event3,2023-01-01 09:00:00\\", \\"event1,2023-01-01 10:00:00\\", \\"event2,2023-01-01 10:00:00\\" ] assert sort_events(events) == expected def test_sort_events_same_timestamps_with_sorting_needed(): events = [ \\"event1,2023-01-01 10:00:00\\", \\"event3,2023-01-01 10:00:00\\", \\"event2,2023-01-01 10:00:00\\" ] expected = [ \\"event1,2023-01-01 10:00:00\\", \\"event2,2023-01-01 10:00:00\\", \\"event3,2023-01-01 10:00:00\\" ] assert sort_events(events) == expected def test_handle_events(): input_data = [ \\"4\\", \\"event1,2023-01-01 10:00:00\\", \\"event3,2023-01-01 09:00:00\\", \\"event2,2023-01-01 10:00:00\\", \\"event4,2023-01-01 08:00:00\\" ] expected = [ \\"event4,2023-01-01 08:00:00\\", \\"event3,2023-01-01 09:00:00\\", \\"event1,2023-01-01 10:00:00\\", \\"event2,2023-01-01 10:00:00\\" ] assert handle_events(input_data) == expected","solution":"def sort_events(events): Sorts a list of events first by timestamp and then by identifier. :param events: List of strings, each representing an event in the format <identifier>,<timestamp> :return: List of sorted events. sorted_events = sorted(events, key=lambda event: (event.split(',')[1], event.split(',')[0])) return sorted_events def handle_events(input_data): Processes multiple events and returns the sorted results. :param input_data: List of input strings; the first element is the number of events. :return: List of sorted event strings. T = int(input_data[0]) events = input_data[1:T+1] return sort_events(events)"},{"question":"def max_product_min_sum(nums: List[int]) -> List[int]: Given a list of positive integers, find two integers in the list such that their product is the maximum possible among all pairs of integers in the list, but their sum is the minimum possible out of all pairs with the maximum product. If there are multiple such pairs, choose the one where the first number is smaller. >>> max_product_min_sum([1, 2, 3, 4, 5]) [4, 5] >>> max_product_min_sum([3, 1, 4, 2]) [3, 4]","solution":"def max_product_min_sum(nums): Finds two integers in the list such that their product is the maximum possible among all pairs in the list and their sum is the minimum possible out of all pairs with the same maximum product. Returns the pair where the first number is smaller. n = len(nums) max_product = 0 best_pair = (None, None) for i in range(n): for j in range(i + 1, n): product = nums[i] * nums[j] if (product > max_product or (product == max_product and (nums[i] + nums[j] < best_pair[0] + best_pair[1])) or (product == max_product and nums[i] + nums[j] == best_pair[0] + best_pair[1] and nums[i] < best_pair[0])): max_product = product best_pair = (nums[i], nums[j]) return sorted(best_pair)"},{"question":"def can_achieve_sequence(n: int, initial: List[int], final: List[int]) -> Tuple[str, List[Tuple[int, int]]]: Determines if it is possible to achieve the desired sequence from the initial sequence using swaps. Returns \\"No\\" if it's impossible, otherwise returns \\"Yes\\" and a list of swaps. >>> can_achieve_sequence(4, [4, 3, 2, 1], [1, 4, 3, 2]) (\\"Yes\\", [(1, 4), (2, 3), (3, 4)]) >>> can_achieve_sequence(3, [1, 1, 2], [1, 2, 2]) (\\"No\\", []) >>> can_achieve_sequence(2, [2, 1], [1, 2]) (\\"Yes\\", [(1, 2)]) pass","solution":"def can_achieve_sequence(n, initial, final): Determines if it is possible to achieve the desired sequence from the initial sequence using swaps. Returns \\"No\\" if it's impossible, otherwise returns \\"Yes\\" and a list of swaps. if sorted(initial) != sorted(final): return \\"No\\", [] swap_operations = [] initial = initial[:] pos = {value: idx for idx, value in enumerate(initial)} for i in range(n): if initial[i] != final[i]: correct_value = final[i] swap_idx = pos[correct_value] # perform the swap initial[i], initial[swap_idx] = initial[swap_idx], initial[i] # update positions pos[initial[swap_idx]] = swap_idx pos[correct_value] = i swap_operations.append((i + 1, swap_idx + 1)) return \\"Yes\\", swap_operations"},{"question":"from typing import List def find_combination(N: int, S: int, cards: List[int]) -> List[int]: Returns a combination of N cards that sum up to S or -1 if no such combination exists. >>> find_combination(3, 15, [2, 3, 6, 7, 4, 8, 5]) in [[2, 6, 7], [6, 7, 2], [7, 4, 4], [6, 5, 4]] True >>> find_combination(2, 10, [1, 2, 3, 4, 5]) -1 def solve_challenges(T: int, test_cases: List[tuple]) -> List[str]: Solves T test cases and returns the results for each one. def main(): Reads input from standard input and outputs the results for each test case.","solution":"from itertools import combinations def find_combination(N, S, cards): Returns a combination of N cards that sum up to S or -1 if no such combination exists. for combo in combinations(cards, N): if sum(combo) == S: return list(combo) return -1 def solve_challenges(T, test_cases): results = [] for case in test_cases: N, S, cards = case result = find_combination(N, S, cards) if result == -1: results.append(\\"-1\\") else: results.append(\\" \\".join(map(str, result))) return results # Here's how you would parse input and call the function for solving the challenges directly. def main(): import sys input = sys.stdin.read data = input().strip().split() index = 0 T = int(data[index]) index += 1 test_cases = [] for _ in range(T): N = int(data[index]) index += 1 S = int(data[index]) index += 1 cards = list(map(int, data[index:index + len(data[index:])])) test_cases.append((N, S, cards)) results = solve_challenges(T, test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def shortest_path(N: int, M: int, grid: List[str]) -> int: Determine the shortest path from 'S' to 'G' in a grid. The function takes the dimensions of the grid and the grid itself as input. If no path exists, it returns -1. >>> shortest_path(5, 5, [\\"S....\\", \\".\\", \\".#...\\", \\".#..G\\", \\"#\\"]) # Output: 7 >>> shortest_path(3, 3, [\\"S#.\\", \\".#.\\", \\".G\\"]) # Output: -1 # Example usage N = 5 M = 5 grid = [ \\"S....\\", \\".\\", \\".#...\\", \\".#..G\\", \\"#\\" ] print(shortest_path(N, M, grid)) # Output: 7","solution":"from collections import deque def shortest_path(N, M, grid): def bfs(start, goal): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited = set() visited.add((start[0], start[1])) while queue: x, y, dist = queue.popleft() if (x, y) == goal: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and (nx, ny) not in visited and grid[nx][ny] != '#': visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 start = goal = None for i in range(N): for j in range(M): if grid[i][j] == 'S': start = (i, j) elif grid[i][j] == 'G': goal = (i, j) if not start or not goal: return -1 # This should not happen based on problem constraints return bfs(start, goal) # Example usage: N = 5 M = 5 grid = [ \\"S....\\", \\".\\", \\".#...\\", \\".#..G\\", \\"#\\" ] print(shortest_path(N, M, grid)) # Output: 7"},{"question":"def pascal_row(n: int) -> list: Generate the n-th row of Pascal's triangle. >>> pascal_row(0) [1] >>> pascal_row(1) [1, 1] >>> pascal_row(2) [1, 2, 1] >>> pascal_row(3) [1, 3, 3, 1] >>> pascal_row(4) [1, 4, 6, 4, 1] >>> pascal_row(5) [1, 5, 10, 10, 5, 1]","solution":"def factorial(num): if num == 0 or num == 1: return 1 fact = 1 for i in range(2, num + 1): fact *= i return fact def pascal_row(n): row = [] for k in range(n + 1): row.append(factorial(n) // (factorial(k) * factorial(n - k))) return row"},{"question":"class Matrix: def __init__(self, n, m, matrix): Initialize the Matrix with given dimensions and contents. self.n = n self.m = m self.matrix = list(matrix) def update(self, x, y, c): Change the character at position (x, y) in the matrix to character 'c'. pass def query(self, x1, y1, x2, y2): Return the number of unique characters in the submatrix from (x1, y1) to (x2, y2), inclusive. pass def process_operations(n: int, m: int, initial_matrix: List[str], operations: List[str]) -> List[int]: Process a list of operations on a given initial matrix. >>> process_operations(3, 3, ['abc', 'def', 'ghi'], [\\"query 1 1 2 2\\", \\"update 2 2 z\\", \\"query 1 1 2 2\\", \\"query 3 1 3 3\\", \\"update 3 3 a\\"]) [4, 4, 1] pass def test_matrix_update(): matrix = Matrix(3, 3, [['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i']]) matrix.update(2, 2, 'z') assert matrix.matrix == [['a', 'b', 'c'], ['d', 'z', 'f'], ['g', 'h', 'i']] def test_matrix_query(): matrix = Matrix(3, 3, [['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i']]) assert matrix.query(1, 1, 2, 2) == 4 matrix.update(2, 2, 'z') assert matrix.query(1, 1, 2, 2) == 4 assert matrix.query(3, 1, 3, 3) == 3 matrix.update(3, 3, 'a') assert matrix.query(3, 1, 3, 3) == 3 def test_process_operations(): initial_matrix = ['abc', 'def', 'ghi'] operations = [\\"query 1 1 2 2\\", \\"update 2 2 z\\", \\"query 1 1 2 2\\", \\"query 3 1 3 3\\", \\"update 3 3 a\\"] results = process_operations(3, 3, initial_matrix, operations) assert results == [4, 4, 1]","solution":"class Matrix: def __init__(self, n, m, matrix): self.n = n self.m = m self.matrix = matrix def update(self, x, y, c): self.matrix[x-1][y-1] = c def query(self, x1, y1, x2, y2): unique_characters = set() for i in range(x1-1, x2): for j in range(y1-1, y2): unique_characters.add(self.matrix[i][j]) return len(unique_characters) def process_operations(n, m, initial_matrix, operations): matrix = Matrix(n, m, [list(row) for row in initial_matrix]) result = [] for operation in operations: parts = operation.split() if parts[0] == \\"update\\": _, x, y, c = parts matrix.update(int(x), int(y), c) elif parts[0] == \\"query\\": _, x1, y1, x2, y2 = parts result.append(matrix.query(int(x1), int(y1), int(x2), int(y2))) return result"},{"question":"def minimum_sum_of_differences(N: int, S: List[int]) -> int: Given the number of students N and their skill levels S, this function returns the minimum possible sum of differences for an optimal pairing. Example: >>> minimum_sum_of_differences(4, [1, 3, 2, 4]) 2 >>> minimum_sum_of_differences(4, [5, 5, 5, 5]) 0 >>> minimum_sum_of_differences(4, [1, 2, 3, 4]) 2 >>> minimum_sum_of_differences(4, [4, 3, 2, 1]) 2 >>> minimum_sum_of_differences(6, [10, 20, 30, 40, 50, 60]) 30 >>> minimum_sum_of_differences(2, [1, 1000000]) 999999 >>> minimum_sum_of_differences(4, [8, 1, 4, 7]) 4","solution":"def minimum_sum_of_differences(N, S): Given the number of students N and their skill levels S, this function returns the minimum possible sum of differences for an optimal pairing. # Sort the skill levels in ascending order S.sort() # Initialize the minimum sum of differences min_sum = 0 # Pair students with adjacent elements after sorting for i in range(0, N, 2): min_sum += S[i + 1] - S[i] return min_sum"},{"question":"from typing import List, Tuple def max_connected_cities(n: int, m: int, k: int, existing_roads: List[Tuple[int, int]], new_roads: List[Tuple[int, int, int]]) -> int: Determine the maximum number of cities that can be directly connected if exactly one of the new roads is constructed. Parameters: n (int): The number of cities. m (int): The number of possible new roads. k (int): The number of existing roads. existing_roads (List[Tuple[int, int]]): The list of existing roads represented by tuples of two cities. new_roads (List[Tuple[int, int, int]]): The list of possible new roads represented by tuples of two cities and road cost. Returns: int: The maximum number of directly connected cities after constructing exactly one of the new roads. Examples: >>> max_connected_cities(5, 3, 2, [(1, 2), (3, 4)], [(1, 3, 5), (1, 4, 10), (4, 5, 2)]) 4 >>> max_connected_cities(4, 2, 0, [], [(1, 2, 8), (3, 4, 7)]) 2","solution":"def max_connected_cities(n, m, k, existing_roads, new_roads): from collections import defaultdict def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 parent = {i: i for i in range(1, n + 1)} rank = {i: 0 for i in range(1, n + 1)} existing_road_components = defaultdict(set) for (u, v) in existing_roads: union(parent, rank, u, v) for city in range(1, n + 1): existing_road_components[find(parent, city)].add(city) max_cities = 0 for (u, v, c) in new_roads: temp_parent = parent.copy() temp_rank = rank.copy() union(temp_parent, temp_rank, u, v) connected_components = defaultdict(set) for city in range(1, n + 1): connected_components[find(temp_parent, city)].add(city) max_cities = max(max_cities, max(len(comp) for comp in connected_components.values())) return max_cities"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Implement a function that takes an array of integers and returns a new array such that each element at index i of the new array is the product of all the numbers in the original array except the one at i. This should be done in O(n) time complexity and without using division. Args: nums (List[int]): An array of integers Returns: List[int]: A new array with the product of all the numbers except the one at i Example: >>> product_except_self([1, 2, 3, 4, 5]) [120, 60, 40, 30, 24] >>> product_except_self([3, 2, 1]) [2, 3, 6] pass def test_product_except_self_example_1(): assert product_except_self([1, 2, 3, 4, 5]) == [120, 60, 40, 30, 24] def test_product_except_self_example_2(): assert product_except_self([3, 2, 1]) == [2, 3, 6] def test_product_except_self_single_element(): assert product_except_self([10]) == [1] def test_product_except_self_with_zeros(): assert product_except_self([0, 2, 3, 4]) == [24, 0, 0, 0] assert product_except_self([1, 0, 3, 0]) == [0, 0, 0, 0] def test_product_except_self_with_negatives(): assert product_except_self([-1, 2, -3, 4]) == [-24, 12, -8, 6] def test_product_except_self_empty_list(): assert product_except_self([]) == [] def test_product_except_self_large_input(): assert product_except_self([1] * 10**5) == [1] * 10**5","solution":"from typing import List def product_except_self(nums: List[int]) -> List[int]: n = len(nums) if n == 0: return [] # Initialize the result array where the product values will be stored result = [1] * n # temp value for left pass left_product = 1 for i in range(n): result[i] = left_product left_product *= nums[i] # temp value for right pass right_product = 1 for i in range(n-1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"def distinct_paths(n: int, m: int, x: int, grid: List[List[int]]) -> int: Find the number of distinct paths from (1, 1) to (n, m) such that the sum of elements along the path is exactly x. >>> distinct_paths(2, 2, 4, [[1, 2], [2, 1]]) 2 >>> distinct_paths(3, 3, 10, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 0 def solve_task(t: int, cases: List[Dict[str, Union[int, List[List[int]]]]]) -> List[int]: Solve multiple test cases for the distinct paths problem. >>> solve_task(2, [{'n': 2, 'm': 2, 'x': 4, 'grid': [[1, 2], [2, 1]]}, {'n': 3, 'm': 3, 'x': 10, 'grid': [[1, 2, 3], [4, 5, 6], [7, 8, 9]] }]) [2, 0]","solution":"def distinct_paths(n, m, x, grid): from collections import defaultdict # Helper function to perform the DP computation def find_paths(): dp = [[defaultdict(int) for _ in range(m)] for _ in range(n)] dp[0][0][grid[0][0]] = 1 for i in range(n): for j in range(m): if i > 0: for s in dp[i-1][j]: dp[i][j][s + grid[i][j]] += dp[i-1][j][s] if j > 0: for s in dp[i][j-1]: dp[i][j][s + grid[i][j]] += dp[i][j-1][s] return dp[n-1][m-1][x] return find_paths() def solve_task(t, cases): results = [] for case in cases: n, m, x, grid = case['n'], case['m'], case['x'], case['grid'] results.append(distinct_paths(n, m, x, grid)) return results"},{"question":"def max_points_per_case(g, r, b, g_points, r_points, b_points, k): Calculate the maximum points a player can collect based on the item points and their carrying capacity. >>> max_points_per_case(1, 2, 3, 10, 20, 30, 3) 90 >>> max_points_per_case(2, 2, 2, 5, 10, 15, 4) 50 >>> max_points_per_case(5, 5, 5, 1, 1, 1, 5) 5 def max_points(t, cases): Calculate the maximum points for multiple test cases. >>> cases = [(1, 2, 3, 10, 20, 30, 3), (2, 2, 2, 5, 10, 15, 4), (5, 5, 5, 1, 1, 1, 5)] >>> max_points(3, cases) [90, 50, 5]","solution":"def max_points_per_case(g, r, b, g_points, r_points, b_points, k): items = [] items.extend([g_points] * g) items.extend([r_points] * r) items.extend([b_points] * b) items.sort(reverse=True) max_points = sum(items[:k]) return max_points def max_points(t, cases): results = [] for case in cases: g, r, b, g_points, r_points, b_points, k = case results.append(max_points_per_case(g, r, b, g_points, r_points, b_points, k)) return results"},{"question":"def can_connect_all_stops(n: int, m: int, k: int, routes: List[Tuple[int, int, int]]) -> str: Determine if it's possible to create a way for residents to travel between all bus stops using at most k bus routes. Uses Kruskal's algorithm to find the Minimum Spanning Tree (MST). Parameters: - n (int): Number of bus stops. - m (int): Number of possible bus routes. - k (int): Maximum number of routes allowed in the final configuration. - routes (list of tuples): Each tuple contains (ui, vi, ti) acting as an edge between bus stops ui and vi with travel time ti. Returns: - str: \\"YES\\" if possible to connect all stops using at most k routes, otherwise \\"NO\\". >>> can_connect_all_stops(4, 5, 3, [(1, 2, 10), (2, 3, 10), (3, 4, 10), (1, 3, 15), (1, 4, 20)]) \\"YES\\" >>> can_connect_all_stops(4, 3, 2, [(1, 2, 5), (2, 3, 5), (3, 4, 5)]) \\"NO\\" pass","solution":"def can_connect_all_stops(n, m, k, routes): Determine if it's possible to create a way for residents to travel between all bus stops using at most k bus routes. Uses Kruskal's algorithm to find the Minimum Spanning Tree (MST). Parameters: - n (int): Number of bus stops. - m (int): Number of possible bus routes. - k (int): Maximum number of routes allowed in the final configuration. - routes (list of tuples): Each tuple contains (ui, vi, ti) acting as an edge between bus stops ui and vi with travel time ti. Returns: - str: \\"YES\\" if possible to connect all stops using at most k routes, otherwise \\"NO\\". parent = list(range(n + 1)) rank = [0] * (n + 1) def find(u): if u != parent[u]: parent[u] = find(parent[u]) return parent[u] def union(u, v): root_u = find(u) root_v = find(v) if root_u != root_v: if rank[root_u] > rank[root_v]: parent[root_v] = root_u elif rank[root_u] < rank[root_v]: parent[root_u] = root_v else: parent[root_v] = root_u rank[root_u] += 1 routes.sort(key=lambda x: x[2]) mst_edges = 0 for u, v, t in routes: if find(u) != find(v): union(u, v) mst_edges += 1 if mst_edges == n - 1: break return \\"YES\\" if mst_edges <= k and mst_edges == n - 1 else \\"NO\\""},{"question":"def has_consecutive_ap_triplet(n: int, sequence: List[int]) -> str: Determines if there are three consecutive integers in the sequence that form an arithmetic progression. Args: n : int : number of elements in the sequence sequence : list of int : the sequence of integers Returns: str : \\"YES\\" if there exists a triplet of consecutive integers that form an arithmetic progression, otherwise \\"NO\\" Examples: >>> has_consecutive_ap_triplet(6, [1, 3, 5, 7, 9, 11]) \\"YES\\" >>> has_consecutive_ap_triplet(6, [1, 2, 4, 7, 11, 16]) \\"NO\\"","solution":"def has_consecutive_ap_triplet(n, sequence): Determines if there are three consecutive integers in the sequence that form an arithmetic progression. Args: n : int : number of elements in the sequence sequence : list of int : the sequence of integers Returns: str : \\"YES\\" if there exists a triplet of consecutive integers that form an arithmetic progression, otherwise \\"NO\\" for i in range(n - 2): if sequence[i+1] - sequence[i] == sequence[i+2] - sequence[i+1]: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List def shortest_path(n: int, m: int, matrix: List[List[str]]) -> int: Function to find the shortest path from the top-left corner (1, 1) to the bottom-right corner (n, m) in the given matrix. Args: n (int): number of rows in the matrix m (int): number of columns in the matrix matrix (List[List[str]]): 2D grid representing the matrix Returns: int: length of the shortest path or -1 if no such path exists Examples: >>> shortest_path(4, 4, [['.', '.', '.', '#'], ['#', '#', '.', '#'], ['.', '#', '.', '#'], ['#', '.', '.', '.']]) 7 >>> shortest_path(3, 3, [['#', '.', '.'], ['#', '#', '.'], ['#', '.', '.']]) -1","solution":"from collections import deque def shortest_path(n, m, matrix): Function to find the shortest path from the top-left corner (1, 1) to the bottom-right corner (n, m) in the given matrix. # Check for edge cases where the start or end is blocked if matrix[0][0] == '#' or matrix[n-1][m-1] == '#': return -1 # Directions for moving right, down, left, and up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Initialize queue for BFS queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: row, col, dist = queue.popleft() # If we reach the bottom-right corner, return the distance if row == n - 1 and col == m - 1: return dist # Explore neighbors for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < n and 0 <= new_col < m and (new_row, new_col) not in visited and matrix[new_row][new_col] == '.': visited.add((new_row, new_col)) queue.append((new_row, new_col, dist + 1)) # If no path found, return -1 return -1"},{"question":"def distribute_gifts(n: int, d: int, values: List[int]) -> List[List[int]]: Distributes gifts among departments such that the sum of gift values in each department is approximately the same. Parameters: n (int): number of employees. d (int): number of departments. values (list of int): gift value for each employee. Returns: list of lists: each inner list contains the indices of employees assigned to that department. Examples: >>> distribute_gifts(6, 2, [1, 2, 3, 4, 5, 6]) [[0, 1, 4], [2, 3, 5]] >>> distribute_gifts(5, 3, [10, 10, 10, 10, 10]) [[0, 1], [2, 3], [4]] pass # Your solution here # Test cases if __name__ == \\"__main__\\": def test_distribute_gifts(): result = distribute_gifts(6, 2, [1, 2, 3, 4, 5, 6]) indices = [index for sublist in result for index in sublist] assert sorted(indices) == [0, 1, 2, 3, 4, 5] values = [1, 2, 3, 4, 5, 6] department_sums = [sum(values[i] for i in dept) for dept in result] assert max(department_sums) - min(department_sums) <= 5 result = distribute_gifts(5, 3, [10, 10, 10, 10, 10]) indices = [index for sublist in result for index in sublist] assert sorted(indices) == [0, 1, 2, 3, 4] values = [10, 10, 10, 10, 10] department_sums = [sum(values[i] for i in dept) for dept in result] assert max(department_sums) - min(department_sums) <= 10 result = distribute_gifts(3, 1, [5, 5, 5]) assert result == [[0, 1, 2]] result = distribute_gifts(4, 2, [1, 1, 1, 1]) indices = [index for sublist in result for index in sublist] assert sorted(indices) == [0, 1, 2, 3] values = [1, 1, 1, 1] department_sums = [sum(values[i] for i in dept) for dept in result] assert max(department_sums) - min(department_sums) <= 1 test_distribute_gifts()","solution":"def distribute_gifts(n, d, values): Distributes gifts among departments such that the sum of gift values in each department is approximately the same. Parameters: n (int): number of employees. d (int): number of departments. values (list of int): gift value for each employee. Returns: list of lists: each inner list contains the indices of employees assigned to that department. # Pair gift values with their original indices gift_index_pairs = list(enumerate(values)) # Sort the gifts by their values in descending order gift_index_pairs.sort(key=lambda x: x[1], reverse=True) # Initialize departments departments = [[] for _ in range(d)] department_sums = [0] * d # Assign gifts to departments trying to balance the sums for index, value in gift_index_pairs: # Find the department with the smallest current sum min_department = department_sums.index(min(department_sums)) # Assign current gift to this department departments[min_department].append(index) # Update the sum of the target department department_sums[min_department] += value return departments"},{"question":"def is_magic_word(word: str) -> str: Determine whether the given word is a \\"Magic Word\\" or not. A \\"Magic Word\\" means at least half of its characters appear the same number of times in both halves. If the length of the word is odd, the middle character is part of both halves. Parameters: word (str): The word to check. Returns: str: \\"YES\\" if the word is a \\"Magic Word,\\" else \\"NO\\" >>> is_magic_word(\\"abcabc\\") \\"YES\\" >>> is_magic_word(\\"aabbcc\\") \\"NO\\" >>> is_magic_word(\\"abccba\\") \\"YES\\" pass def check_magic_words(test_cases): Check a list of words and determine for each whether it is a \\"Magic Word.\\" Parameters: test_cases (List[str]): A list of words to check. Returns: List[str]: A list of \\"YES\\" or \\"NO\\" for each word. >>> check_magic_words([\\"abcabc\\", \\"aabbcc\\", \\"abccba\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] pass","solution":"def is_magic_word(word): length = len(word) if length % 2 == 0: first_half = word[:length//2] second_half = word[length//2:] else: first_half = word[:length//2 + 1] second_half = word[length//2:] char_count = {} for char in first_half: if char in char_count: char_count[char][0] += 1 else: char_count[char] = [1, 0] for char in second_half: if char in char_count: char_count[char][1] += 1 else: char_count[char] = [0, 1] matching_chars = 0 total_chars = len(first_half) for counts in char_count.values(): if counts[0] == counts[1]: matching_chars += 1 return \\"YES\\" if matching_chars >= total_chars / 2 else \\"NO\\" def check_magic_words(test_cases): results = [] for word in test_cases: results.append(is_magic_word(word)) return results"},{"question":"def find_first_reciprocal_exchange(n: int, m: int, exchanges: List[Tuple[int, int]]) -> int: Determine the first recorded exchange that results in a direct reciprocal gift exchange between two villagers. >>> find_first_reciprocal_exchange(4, 5, [(1, 2), (2, 3), (3, 4), (4, 1), (2, 1)]) == 5 >>> find_first_reciprocal_exchange(3, 3, [(1, 2), (2, 3), (3, 1)]) == 0 >>> find_first_reciprocal_exchange(5, 6, [(1, 3), (3, 4), (4, 2), (2, 5), (5, 1), (2, 3)]) == 0 >>> find_first_reciprocal_exchange(3, 4, [(1, 2), (2, 1), (2, 3), (3, 2)]) == 2 >>> exchanges = [(i, (i % 100) + 1) for i in range(1, 101)] >>> find_first_reciprocal_exchange(100, 100, exchanges) == 0 >>> exchanges.append((2, 1)) >>> find_first_reciprocal_exchange(100, 101, exchanges) == 101","solution":"def find_first_reciprocal_exchange(n, m, exchanges): # Dictionary to keep track of which villager each villager has given a gift to gift_given_to = {} for i, (a, b) in enumerate(exchanges): # Check if b has already given a gift to a if gift_given_to.get(b) == a: # If so, return the 1-indexed position return i + 1 # Record that a has given a gift to b gift_given_to[a] = b # If no reciprocal exchange found, return 0 return 0"},{"question":"from typing import List, Tuple, Union def find_pairs(arr: List[int], x: int) -> Union[None, Tuple[int, int]]: This function finds two distinct indices i and j in the array such that the sum of the elements at these indices is equal to x, if such indices exist. >>> find_pairs([1, 2, 3, 4, 5], 8) in [(2, 4), (4, 2)] True >>> find_pairs([1, 2, 3, 9], 8) is None True >>> find_pairs([1, 3, 3, 4, 5], 6) in [(1, 2), (2, 1)] True >>> find_pairs([-1, -2, -3, -4, -5], -8) in [(2, 4), (4, 2)] True >>> find_pairs([-1, 2, 3, -4, 5], 1) in [(0, 1), (1, 0)] True >>> find_pairs([10**9, -10**9, 3, 4, 5], 0) in [(0, 1), (1, 0)] True","solution":"from typing import List, Tuple, Union def find_pairs(arr: List[int], x: int) -> Union[None, Tuple[int, int]]: This function finds two distinct indices i and j in the array such that the sum of the elements at these indices is equal to x, if such indices exist. # Dictionary to keep track of the elements we have seen so far and their indices seen = {} for i, num in enumerate(arr): # Calculate the required complement to reach the sum x complement = x - num # Check if the complement exists in the seen dictionary if complement in seen: # Return the indices (i, seen[complement]) return (seen[complement], i) # Add the current number and its index to the seen dictionary seen[num] = i # If no pair is found, return None return None"},{"question":"def min_removals_to_get_non_decreasing_order(queues: List[List[int]]) -> List[int]: Determine the minimum number of people that need to be removed from the queue so that the remaining people are in non-decreasing order of height. Args: queues (List[List[int]]): A list where each element is a list representing the heights of people in a queue. Returns: List[int]: A list of integers where each integer represents the minimum number of people to remove for each queue. >>> min_removals_to_get_non_decreasing_order([[1, 3, 2, 3, 5]]) [1] >>> min_removals_to_get_non_decreasing_order([[4, 3, 2, 1], [1, 2, 3, 4, 5, 6]]) [3, 0] >>> min_removals_to_get_non_decreasing_order([[1, 2, 3, 4, 5]]) [0] >>> min_removals_to_get_non_decreasing_order([[5, 5, 5, 5]]) [0] >>> min_removals_to_get_non_decreasing_order([[1]]) [0] >>> min_removals_to_get_non_decreasing_order([[2, 1]]) [1] >>> min_removals_to_get_non_decreasing_order([[i for i in range(1, 10001)]]) [0]","solution":"def min_removals_to_get_non_decreasing_order(queues): def longest_non_decreasing_subsequence(seq): from bisect import bisect_right sub = [] for x in seq: if len(sub) == 0 or sub[-1] <= x: sub.append(x) else: idx = bisect_right(sub, x) sub[idx] = x return len(sub) results = [] for queue in queues: n = len(queue) lnds_length = longest_non_decreasing_subsequence(queue) removals = n - lnds_length results.append(removals) return results"},{"question":"def most_frequent_character(S: str) -> str: Returns the most frequently occurring character in the string S. If there is a tie, returns the character which comes first lexicographically. >>> most_frequent_character(\\"abbccc\\") == \\"c\\" >>> most_frequent_character(\\"bacabc\\") == \\"a\\" >>> most_frequent_character(\\"xyzzyx\\") == \\"x\\"","solution":"def most_frequent_character(S): Returns the most frequently occurring character in the string S. If there is a tie, returns the character which comes first lexicographically. from collections import Counter # Count the occurrences of each character in the string char_counter = Counter(S) # Determine the most frequent character(s) max_occurrence = max(char_counter.values()) candidates = [char for char, count in char_counter.items() if count == max_occurrence] # Return the smallest lexicographically candidate return min(candidates)"},{"question":"def is_prime(num): Helper function to check if a number is prime. >>> is_prime(2) True >>> is_prime(4) False pass def longest_prime_subsequence_length(n, a): Returns the length of the longest subsequence that consists of prime numbers only. >>> longest_prime_subsequence_length(7, [3, 4, 7, 10, 11, 13, 20]) 4 >>> longest_prime_subsequence_length(5, [15, 17, 19, 20, 22]) 2 pass","solution":"def is_prime(num): Helper function to check if a number is prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False sq = int(num**0.5) + 1 for i in range(3, sq, 2): if num % i == 0: return False return True def longest_prime_subsequence_length(n, a): Returns the length of the longest subsequence that consists of prime numbers only. return sum(1 for x in a if is_prime(x))"},{"question":"class Hackathon: TechCorp is organizing a Hackathon event where participants need to solve coding challenges within a limited time. Each participant is identified by an integer ID and starts with zero points. The points can be updated over time as participants solve more challenges. The organizer wants to keep track of the highest score as the competition progresses, and update the score of participants based on their performance. The number of participants N (1 ≤ N ≤ 100000) and the number of queries Q (1 ≤ Q ≤ 100000) are given on the first line. Each query is specified on a new line in one of the following formats: 'UPDATE id points': add the integer points (1 ≤ points ≤ 109) to the participant with the specified ID (1 ≤ id ≤ N). 'REPORT': output the ID and the current highest score of the participant with the highest score. If multiple participants have the highest score, return the one with the smallest ID. def __init__(self, n): pass def update(self, id, points): pass def report(self): pass def process_queries(n, queries): Process a list of queries and return the results of 'REPORT' commands. Args: n (int): Number of participants queries (List[str]): List of commands in the form \\"UPDATE id points\\" and \\"REPORT\\" Returns: List[Tuple[int, int]]: List of tuples with participant ID and their score for each REPORT command >>> process_queries(3, [\\"UPDATE 1 100\\", \\"UPDATE 2 150\\", \\"REPORT\\", \\"UPDATE 1 200\\", \\"REPORT\\"]) [(2, 150), (1, 300)] >>> process_queries(4, [\\"UPDATE 3 120\\", \\"REPORT\\", \\"REPORT\\"]) [(3, 120), (3, 120)] pass # Test cases def test_hackathon_example_1(): queries = [\\"UPDATE 1 100\\", \\"UPDATE 2 150\\", \\"REPORT\\", \\"UPDATE 1 200\\", \\"REPORT\\"] assert process_queries(3, queries) == [(2, 150), (1, 300)] def test_hackathon_example_2(): queries = [\\"UPDATE 3 120\\", \\"REPORT\\", \\"REPORT\\"] assert process_queries(4, queries) == [(3, 120), (3, 120)] def test_hackathon_all_same_score(): queries = [\\"UPDATE 1 50\\", \\"UPDATE 2 50\\", \\"UPDATE 3 50\\", \\"REPORT\\"] assert process_queries(3, queries) == [(1, 50)] def test_hackathon_multiple_reports(): queries = [\\"UPDATE 1 20\\", \\"UPDATE 2 40\\", \\"REPORT\\", \\"UPDATE 1 30\\", \\"REPORT\\", \\"UPDATE 2 10\\", \\"REPORT\\"] assert process_queries(2, queries) == [(2, 40), (1, 50), (1, 50)] def test_hackathon_edge_case_single_participant(): queries = [\\"UPDATE 1 10\\", \\"UPDATE 1 20\\", \\"REPORT\\", \\"UPDATE 1 30\\", \\"REPORT\\"] assert process_queries(1, queries) == [(1, 30), (1, 60)]","solution":"class Hackathon: def __init__(self, n): self.scores = [0] * (n + 1) # Initialize scores for n participants self.highest_id = 1 # Initially, the highest scoring id is 1 def update(self, id, points): self.scores[id] += points if self.scores[id] > self.scores[self.highest_id] or (self.scores[id] == self.scores[self.highest_id] and id < self.highest_id): self.highest_id = id def report(self): return self.highest_id, self.scores[self.highest_id] # Example usage: def process_queries(n, queries): hackathon = Hackathon(n) result = [] for query in queries: cmd = query.split() if cmd[0] == 'UPDATE': id = int(cmd[1]) points = int(cmd[2]) hackathon.update(id, points) elif cmd[0] == 'REPORT': result.append(hackathon.report()) return result"},{"question":"def max_power_combination(test_cases): Returns the highest possible sum of the power values of any subset of artifacts for each test case that does not exceed the maximum allowed power sum. >>> max_power_combination([(5, 10, [1, 2, 3, 4, 5]), (4, 7, [2, 2, 2, 9]), (3, 8, [3, 5, 7]), (6, 12, [1, 2, 3, 4, 5, 4]), (6, 15, [5, 5, 5, 5, 5, 5])]) [10, 6, 8, 12, 15] from solution import max_power_combination def test_max_power_combination(): test_cases = [ (5, 10, [1, 2, 3, 4, 5]), (4, 7, [2, 2, 2, 9]), (3, 8, [3, 5, 7]), (6, 12, [1, 2, 3, 4, 5, 4]), (6, 15, [5, 5, 5, 5, 5, 5]), ] expected_results = [10, 6, 8, 12, 15] assert max_power_combination(test_cases) == expected_results","solution":"def max_power_combination(test_cases): Returns the highest possible sum of the power values of any subset of artifacts for each test case that does not exceed the maximum allowed power sum. results = [] for case in test_cases: n, W, power_values = case dp = [0] * (W + 1) for power in power_values: for j in range(W, power - 1, -1): dp[j] = max(dp[j], dp[j - power] + power) results.append(dp[W]) return results"},{"question":"def check_books_in_collection(N: int, book_list: list, Q: int, query_list: list) -> list: Function to check if book titles in query_list exist in book_list. Parameters: N (int): Number of books in the collection book_list (list): List of book titles in the collection Q (int): Number of queries query_list (list): List of book titles to check for existence Returns: list: A list of strings \\"FOUND\\" or \\"NOT FOUND\\" for each query Examples: >>> check_books_in_collection(3, [\\"Harry Potter\\", \\"The Hobbit\\", \\"1984\\"], 2, [\\"Harry Potter\\", \\"1984\\"]) [\\"FOUND\\", \\"FOUND\\"] >>> check_books_in_collection(2, [\\"Harry Potter\\", \\"The Hobbit\\"], 2, [\\"Lord of the Rings\\", \\"1984\\"]) [\\"NOT FOUND\\", \\"NOT FOUND\\"] >>> check_books_in_collection(5, [\\"The Great Gatsby\\", \\"To Kill a Mockingbird\\", \\"1984\\", \\"Pride and Prejudice\\", \\"Moby Dick\\"], 3, [\\"War and Peace\\", \\"The Great Gatsby\\", \\"The Catcher in the Rye\\"]) [\\"NOT FOUND\\", \\"FOUND\\", \\"NOT FOUND\\"] >>> check_books_in_collection(3, [\\"Harry Potter\\", \\"The Hobbit\\", \\"1984\\"], 0, []) [] >>> check_books_in_collection(2, [\\"Harry Potter\\", \\"The Hobbit\\"], 2, [\\"harry potter\\", \\"THE HOBBIT\\"]) [\\"NOT FOUND\\", \\"NOT FOUND\\"]","solution":"def check_books_in_collection(N, book_list, Q, query_list): Function to check if book titles in query_list exist in book_list. Parameters: N (int): Number of books in the collection book_list (list): List of book titles in the collection Q (int): Number of queries query_list (list): List of book titles to check for existence Returns: list: A list of strings \\"FOUND\\" or \\"NOT FOUND\\" for each query book_set = set(book_list) results = [] for query in query_list: if query in book_set: results.append(\\"FOUND\\") else: results.append(\\"NOT FOUND\\") return results"},{"question":"from typing import List, Tuple def find_highest_improved_participant(test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Find the participant with the highest improvement in problem-solving skills for each test case. Improvement is defined as the difference between the number of problems solved and the number of problems attempted. :param test_cases: A list of tuples where each tuple contains an integer N (the number of participants) and a list of tuples with two integers A and S (the number of problems attempted and the number of problems solved by each participant). :return: A list of integers where each integer is the index (1-based) of the participant with the highest improvement for the corresponding test case. >>> find_highest_improved_participant([(3, [(5, 3), (7, 4), (4, 6)],)]) [3] >>>find_highest_improved_participant([(2, [(3, 2), (4, 4)],)]) [2]","solution":"def find_highest_improved_participant(test_cases): results = [] for case in test_cases: n, participants = case max_improvement = float('-inf') best_participant = -1 for i, (a, s) in enumerate(participants): improvement = s - a if improvement > max_improvement: max_improvement = improvement best_participant = i + 1 elif improvement == max_improvement: if i + 1 < best_participant: best_participant = i + 1 results.append(best_participant) return results"},{"question":"class TreeNode: def __init__(self, value=0): self.value = value self.left = None self.right = None def longest_path_length(root): Find the length of the longest path between any two nodes in the binary tree. >>> longest_path_length([1, 2, 3, 4, 5], [(1, 2), (1, 3), (2, 4), (2, 5)]) 3 def build_tree(edges, n): Helper function to build a tree from a list of edges. >>> build_tree([(1, 2), (1, 3), (2, 4), (2, 5)], 5) TreeNode(1) def find_longest_path(n, nodes, edges): You are given a binary tree with N nodes, where each node has a unique integer value. The task is to find the length of the longest path between any two nodes in the tree. The path may or may not pass through the root of the tree. >>> find_longest_path(5, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (2, 4), (2, 5)]) 3 >>> find_longest_path(3, [1, 2, 3], [(1, 2), (1, 3)]) 2 from collections import defaultdict, deque def test_find_longest_path(): assert find_longest_path(5, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (2, 4), (2, 5)]) == 3 assert find_longest_path(3, [1, 2, 3], [(1, 2), (1, 3)]) == 2 assert find_longest_path(6, [1, 2, 3, 4, 5, 6], [(1, 2), (1, 3), (2, 4), (2, 5), (5, 6)]) == 4 def test_single_path_tree(): assert find_longest_path(4, [1, 2, 3, 4], [(1, 2), (2, 3), (3, 4)]) == 3 def test_tree_with_two_paths(): assert find_longest_path(4, [1, 2, 3, 4], [(1, 2), (1, 3), (2, 4)]) == 3 def test_balanced_tree(): assert find_longest_path(7, [1, 2, 3, 4, 5, 6, 7], [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) == 4","solution":"class TreeNode: def __init__(self, value=0): self.value = value self.left = None self.right = None def longest_path_length(root): def dfs(node): nonlocal diameter if not node: return 0 left_length = dfs(node.left) right_length = dfs(node.right) diameter = max(diameter, left_length + right_length) return max(left_length, right_length) + 1 diameter = 0 dfs(root) return diameter def build_tree(edges, n): from collections import defaultdict, deque tree_nodes = {i: TreeNode(i) for i in range(1, n + 1)} adjacency_list = defaultdict(list) for u, v in edges: adjacency_list[u].append(v) adjacency_list[v].append(u) root = tree_nodes[1] visited = set() queue = deque([root]) visited.add(root.value) while queue: current = queue.popleft() for neighbor in adjacency_list[current.value]: if neighbor not in visited: neighbor_node = tree_nodes[neighbor] if not current.left: current.left = neighbor_node else: current.right = neighbor_node queue.append(neighbor_node) visited.add(neighbor) return root def find_longest_path(n, nodes, edges): root = build_tree(edges, n) return longest_path_length(root)"},{"question":"def smallest_sum_by_removing_one_element(test_cases): Identifies the smallest sum that can be obtained by removing exactly one element from the list and summing the remaining elements for each test case. Args: test_cases (List[Tuple[int, List[int]]]): List of test cases with each test case containing a tuple with the number of elements and the list of positive integers. Returns: List[int]: List of smallest possible sums for each test case. Example usage: >>> smallest_sum_by_removing_one_element([(5, [1, 2, 3, 4, 5]), (3, [10, 100, 1000]), (4, [7, 17, 19, 3])]) [10, 110, 27] def parse_input(input_string): Parses the input string into a structured list of test cases. Args: input_string (str): Input string containing the number of test cases and respective lists of integers. Returns: List[Tuple[int, List[int]]]: Parsed list of test cases. Example usage: >>> parse_input('3n5n1 2 3 4 5n3n10 100 1000n4n7 17 19 3') [(5, [1, 2, 3, 4, 5]), (3, [10, 100, 1000]), (4, [7, 17, 19, 3])] def format_output(outputs): Formats the output list of smallest possible sums into a string. Args: outputs (List[int]): List of smallest possible sums for each test case. Returns: str: Formatted output string. Example usage: >>> format_output([10, 110, 27]) '10n110n27'","solution":"def smallest_sum_by_removing_one_element(test_cases): results = [] for case in test_cases: N, numbers = case total_sum = sum(numbers) min_sum = total_sum - max(numbers) results.append(min_sum) return results def parse_input(input_string): lines = input_string.strip().split('n') T = int(lines[0]) test_cases = [] for i in range(T): N = int(lines[2 * i + 1]) numbers = list(map(int, lines[2 * i + 2].split())) test_cases.append((N, numbers)) return test_cases def format_output(outputs): return 'n'.join(map(str, outputs)) # Example usage: input_string = '''3 5 1 2 3 4 5 3 10 100 1000 4 7 17 19 3''' test_cases = parse_input(input_string) results = smallest_sum_by_removing_one_element(test_cases) output_string = format_output(results) print(output_string)"},{"question":"from typing import List, Tuple, Union def minimize_total_width(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[Union[int, str]]: Monocarp wants to arrange books with given widths on a shelf such that no two consecutive books have the same width. Find the minimum total width of the shelf used. Args: t (int): the number of test cases test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains: - an integer n (the number of books) - a list of integers representing the widths of the books Returns: List[Union[int, str]]: a list of results, where each result is either - the minimum possible total width of the arrangement of books - \\"impossible\\" if it cannot be arranged such that no two consecutive books have the same width Example: >>> minimize_total_width(1, [(4, [1, 1, 2, 3])]) [7] >>> minimize_total_width(1, [(3, [1, 1, 1])]) ['impossible'] >>> minimize_total_width(1, [(5, [4, 4, 4, 4, 5])]) [21] # Unit tests def test_single_case(): assert minimize_total_width(1, [(4, [1, 1, 2, 3])]) == [7] assert minimize_total_width(1, [(3, [1, 1, 1])]) == [\\"impossible\\"] assert minimize_total_width(1, [(5, [4, 4, 4, 4, 5])]) == [21] def test_multiple_cases(): test_cases = [ (4, [1, 1, 2, 3]), (3, [1, 1, 1]), (5, [4, 4, 4, 4, 5]) ] results = [7, \\"impossible\\", 21] assert minimize_total_width(3, test_cases) == results def test_edge_cases(): assert minimize_total_width(1, [(2, [1, 2])]) == [3] assert minimize_total_width(1, [(2, [1, 1])]) == [\\"impossible\\"] assert minimize_total_width(1, [(10**5, [10**9] * 10**5)]) == [\\"impossible\\"] widths = [i for i in range(1, 10**5 + 1)] assert minimize_total_width(1, [(10**5, widths)]) == [sum(widths)]","solution":"def minimize_total_width(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] widths = test_cases[i][1] width_set = set(widths) if len(width_set) == 1: results.append(\\"impossible\\") else: total_width = sum(widths) results.append(total_width) return results"},{"question":"def min_intervals_to_erase(events: List[Tuple[int, int]]) -> int: Returns the minimum number of events to remove so that no two events overlap. Args: events (list of tuple of int): The list of tuples where each tuple contains start time and end time of an event. Returns: int: The minimum number of events to remove. >>> min_intervals_to_erase([(0, 30), (5, 10), (15, 20)]) 1 >>> min_intervals_to_erase([(1, 3), (2, 4), (3, 5)]) 1 pass from typing import List, Tuple def test_no_overlap(): events = [(1, 2), (3, 4), (5, 6)] assert min_intervals_to_erase(events) == 0 def test_complete_overlap(): events = [(1, 5), (2, 6), (1, 8)] assert min_intervals_to_erase(events) == 2 def test_partial_overlap(): events = [(1, 3), (2, 4), (3, 5)] assert min_intervals_to_erase(events) == 1 def test_no_events(): events = [] assert min_intervals_to_erase(events) == 0 def test_complex_case(): events = [(0, 30), (5, 10), (15, 20)] assert min_intervals_to_erase(events) == 1 def test_edge_case_start_end_same(): events = [(0, 1440), (0, 1440)] assert min_intervals_to_erase(events) == 1","solution":"def min_intervals_to_erase(events): Returns the minimum number of events to remove so that no two events overlap. Args: events (list of tuple of int): The list of tuples where each tuple contains start time and end time of an event. Returns: int: The minimum number of events to remove. if not events: return 0 # Sort events by their ending times events.sort(key=lambda x: x[1]) removal_count = 0 last_end_time = float('-inf') for start, end in events: if start < last_end_time: removal_count += 1 else: last_end_time = end return removal_count"},{"question":"from typing import List def smallest_missing_positive(arr: List[int]) -> int: Returns the smallest positive integer missing from the array. >>> smallest_missing_positive([1, 3, 6, 4, 1, 2]) 5 >>> smallest_missing_positive([1, 2, 3, 4]) 5 >>> smallest_missing_positive([-1, -3, -6, -4, 2]) 1 >>> smallest_missing_positive([]) 1 >>> smallest_missing_positive([-1, -2, -3]) 1 >>> smallest_missing_positive([1]) 2 >>> smallest_missing_positive([2]) 1 >>> smallest_missing_positive([1, 2, 3, 10**6]) 4 pass def process_test_cases(test_cases: List[List[int]]) -> List[int]: Processes multiple test cases and finds the smallest missing positive integer for each case. >>> process_test_cases([[1, 3, 6, 4, 1, 2], [1, 2, 3, 4], [-1, -3, -6, -4, 2]]) [5, 5, 1] pass","solution":"def smallest_missing_positive(arr): Returns the smallest positive integer missing from the array. n = len(arr) # Correcting the values in the range 1 to n in their correct positions for i in range(n): while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]: arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1] # Finding the first position where the index does not match the value for i in range(n): if arr[i] != i + 1: return i + 1 return n + 1 def process_test_cases(test_cases): Processes multiple test cases and finds the smallest missing positive integer for each case. results = [] for arr in test_cases: results.append(smallest_missing_positive(arr)) return results"},{"question":"def exist(board: List[List[str]], word: str) -> bool: Determine if the word can be found in the matrix. The word can be constructed from letters of sequentially adjacent cells, where 'adjacent' cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. >>> board1 = [ ... ['A','B','C','E'], ... ['S','F','C','S'], ... ['A','D','E','E'] ... ] >>> word1 = \\"ABCCED\\" >>> exist(board1, word1) True >>> board2 = [ ... ['A','B','C','E'], ... ['S','F','C','S'], ... ['A','D','E','E'] ... ] >>> word2 = \\"SEE\\" >>> exist(board2, word2) True >>> board3 = [ ... ['A','B','C','E'], ... ['S','F','C','S'], ... ['A','D','E','E'] ... ] >>> word3 = \\"ABCB\\" >>> exist(board3, word3) False >>> board4 = [ ... ['C','A','A'], ... ['A','A','A'], ... ['B','C','D'] ... ] >>> word4 = \\"AAB\\" >>> exist(board4, word4) True >>> board5 = [ ... ['a','b'], ... ['c','d'] ... ] >>> word5 = \\"abcd\\" >>> exist(board5, word5) False","solution":"def exist(board, word): rows, cols = len(board), len(board[0]) def dfs(r, c, i): if i == len(word): return True if r < 0 or r >= rows or c < 0 or c >= cols or board[r][c] != word[i]: return False temp = board[r][c] board[r][c] = '#' # mark as visited found = (dfs(r+1, c, i+1) or dfs(r-1, c, i+1) or dfs(r, c+1, i+1) or dfs(r, c-1, i+1)) board[r][c] = temp # unmark return found for row in range(rows): for col in range(cols): if dfs(row, col, 0): return True return False"},{"question":"def is_reachable(n, grid): Determine whether it is possible to reach the bottom-right cell from the top-left cell following Lena's rule. Args: n (int): size of the grid grid (List[List[int]]): n x n grid of terrain difficulties Returns: str: \\"YES\\" if it is possible to reach the bottom-right cell, otherwise \\"NO\\" >>> is_reachable(3, [[2, 3, 6], [4, 12, 18], [9, 24, 8]]) \\"YES\\" >>> is_reachable(3, [[2, 3, 6], [5, 12, 18], [9, 24, 8]]) \\"NO\\" >>> is_reachable(1, [[1]]) \\"YES\\" >>> is_reachable(2, [[2, 4], [4, 8]]) \\"YES\\" >>> is_reachable(2, [[2, 5], [3, 7]]) \\"NO\\"","solution":"def is_reachable(n, grid): from collections import deque def is_compatible(a, b): return b % a == 0 or a % b == 0 directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] visited = [[False] * n for _ in range(n)] queue = deque([(0, 0)]) visited[0][0] = True while queue: x, y = queue.popleft() if x == n - 1 and y == n - 1: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and not visited[nx][ny] and is_compatible(grid[x][y], grid[nx][ny]): visited[nx][ny] = True queue.append((nx, ny)) return \\"NO\\" # Example usage n = 3 grid = [ [2, 3, 6], [4, 12, 18], [9, 24, 8] ] print(is_reachable(n, grid)) # Output: 'YES'"},{"question":"def max_elevation_difference(M: int, N: int, elevations: List[List[int]]) -> int: Find the maximum difference in elevation between any two cells such that there is a path connecting them, and the elevation is non-decreasing along the path. Parameters: M (int): Number of rows in the grid. N (int): Number of columns in the grid. elevations (List[List[int]]): 2D list representing elevation of each cell in the grid. Returns: int: The maximum difference in elevation between any two cells connected by a non-decreasing path. Example: >>> max_elevation_difference(3, 3, [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) 8 >>> max_elevation_difference(2, 2, [ [10, 1], [8, 7] ]) 9 >>> max_elevation_difference(4, 4, [ [9, 8, 7, 6], [8, 7, 6, 5], [7, 6, 5, 4], [6, 5, 4, 3] ]) 6","solution":"def max_elevation_difference(M, N, elevations): from collections import deque directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def bfs(r, c): max_elev = elevations[r][c] visited = [[False] * N for _ in range(M)] visited[r][c] = True queue = deque([(r, c)]) while queue: x, y = queue.popleft() max_elev = max(max_elev, elevations[x][y]) for dr, dc in directions: nx, ny = x + dr, y + dc if 0 <= nx < M and 0 <= ny < N and not visited[nx][ny] and elevations[nx][ny] >= elevations[x][y]: visited[nx][ny] = True queue.append((nx, ny)) return max_elev max_diff = 0 for i in range(M): for j in range(N): min_elev = elevations[i][j] max_elev = bfs(i, j) max_diff = max(max_diff, max_elev - min_elev) return max_diff # Example usage print(max_elevation_difference(3, 3, [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ])) # Output: 8 print(max_elevation_difference(2, 2, [ [10, 1], [8, 7] ])) # Output: 9 print(max_elevation_difference(4, 4, [ [9, 8, 7, 6], [8, 7, 6, 5], [7, 6, 5, 4], [6, 5, 4, 3] ])) # Output: 6"},{"question":"def longest_subarray_length(arr: List[int], M: int) -> int: Returns the length of the longest subarray such that the sum of its elements is at most M. >>> longest_subarray_length([1, 2, 3, 4, 5, 6], 15) 5 >>> longest_subarray_length([10, 20, 30], 5) 0 >>> longest_subarray_length([1, 2, 3, 4, 5], 15) 5 >>> longest_subarray_length([1, 2, 3, 4, 5], 6) 3 >>> longest_subarray_length([100, 200, 300], 200) 1","solution":"def longest_subarray_length(arr, M): Returns the length of the longest subarray such that the sum of its elements is at most M. :param arr: List of integers representing the array :param M: Integer representing the maximum allowed sum of subarray :return: Integer representing the length of the longest subarray N = len(arr) start = 0 end = 0 current_sum = 0 max_length = 0 while end < N: current_sum += arr[end] while current_sum > M and start <= end: current_sum -= arr[start] start += 1 max_length = max(max_length, end - start + 1) end += 1 return max_length"},{"question":"def largest_connected_component(R: int, C: int, grid: List[str]) -> int: Determine the size of the largest connected component of cells containing Planta. R: int - Number of rows in the grid C: int - Number of columns in the grid grid: List[str] - The garden grid containing cells with 'P' for Planta and 'D' for Desconhecido Returns an integer representing the size of the largest connected component of cells containing Planta. >>> largest_connected_component(4, 5, [\\"DDPPP\\", \\"DPDDP\\", \\"DPDDD\\", \\"DDDDD\\"]) 4 >>> largest_connected_component(1, 8, [\\"PDDPDPDP\\"]) 1 >>> largest_connected_component(6, 1, [\\"P\\", \\"D\\", \\"P\\", \\"P\\", \\"D\\", \\"P\\"]) 2 >>> largest_connected_component(4, 4, [\\"PPPP\\", \\"PPPP\\", \\"PPPP\\", \\"PPPP\\"]) 16 >>> largest_connected_component(4, 4, [\\"PDDD\\", \\"DPDP\\", \\"DDPD\\", \\"DDDP\\"]) 1 pass","solution":"def largest_connected_component(R, C, grid): def dfs(r, c): if r < 0 or r >= R or c < 0 or c >= C or grid[r][c] != 'P' or visited[r][c]: return 0 visited[r][c] = True size = 1 size += dfs(r+1, c) size += dfs(r-1, c) size += dfs(r, c+1) size += dfs(r, c-1) return size visited = [[False] * C for _ in range(R)] max_size = 0 for i in range(R): for j in range(C): if grid[i][j] == 'P' and not visited[i][j]: max_size = max(max_size, dfs(i, j)) return max_size"},{"question":"def shortest_path_to_fibonacci(P: int) -> int: Find the shortest path within the Fibonacci Tree from the root nodes to a given target Fibonacci number 'P'. Returns the number of steps required to reach 'P'. If 'P' is not a valid Fibonacci number, return -1. >>> shortest_path_to_fibonacci(1) == 1 >>> shortest_path_to_fibonacci(2) == 3 >>> shortest_path_to_fibonacci(3) == 4 >>> shortest_path_to_fibonacci(5) == 5 >>> shortest_path_to_fibonacci(8) == 6 >>> shortest_path_to_fibonacci(13) == 7 >>> shortest_path_to_fibonacci(21) == 8 >>> shortest_path_to_fibonacci(4) == -1 >>> shortest_path_to_fibonacci(6) == -1 # Example unit tests def test_shortest_path_to_fibonacci(): assert shortest_path_to_fibonacci(1) == 1 assert shortest_path_to_fibonacci(2) == 3 assert shortest_path_to_fibonacci(3) == 4 assert shortest_path_to_fibonacci(5) == 5 assert shortest_path_to_fibonacci(8) == 6 assert shortest_path_to_fibonacci(13) == 7 assert shortest_path_to_fibonacci(21) == 8 assert shortest_path_to_fibonacci(34) == 9 def test_non_fibonacci_numbers(): assert shortest_path_to_fibonacci(4) == -1 assert shortest_path_to_fibonacci(6) == -1 assert shortest_path_to_fibonacci(7) == -1 assert shortest_path_to_fibonacci(9) == -1 assert shortest_path_to_fibonacci(10) == -1 assert shortest_path_to_fibonacci(15) == -1 assert shortest_path_to_fibonacci(20) == -1 assert shortest_path_to_fibonacci(22) == -1","solution":"def shortest_path_to_fibonacci(P): Return the number of steps required to reach a Fibonacci number P. if P == 1: return 1 previous, current = 1, 1 step = 2 while current < P: previous, current = current, previous + current step += 1 return step if current == P else -1 # Return -1 if P is not a valid Fibonacci number"},{"question":"def total_distance_traveled(trips): Returns the total distance traveled based on the list of trips. Each trip is represented by a tuple (starting_point, ending_point). >>> total_distance_traveled([(0, 5), (3, 7), (-2, -6)]) 13 >>> total_distance_traveled([(1, 1), (10, 0), (0, 0)]) 10 >>> total_distance_traveled([(-100000, 100000)]) 200000 >>> total_distance_traveled([(0, 0)]) 0 def parse_input(input_str): Parses the input string and returns a list of trips. The input string includes an integer N followed by N pairs of integers. >>> parse_input(\\"3n0 5n3 7n-2 -6\\") [(0, 5), (3, 7), (-2, -6)] >>> parse_input(\\"1n-100000 100000\\") [(-100000, 100000)] >>> parse_input(\\"2n0 0n10 10\\") [(0, 0), (10, 10)] >>> parse_input(\\"4n1 2n2 3n3 4n4 5\\") [(1, 2), (2, 3), (3, 4), (4, 5)]","solution":"def total_distance_traveled(trips): Returns the total distance traveled based on the list of trips. Each trip is represented by a tuple (starting_point, ending_point). total_distance = 0 for start, end in trips: total_distance += abs(end - start) return total_distance def parse_input(input_str): Parses the input string and returns a list of trips. The input string includes an integer N followed by N pairs of integers. lines = input_str.strip().split('n') N = int(lines[0]) trips = [] for i in range(1, N + 1): start, end = map(int, lines[i].split()) trips.append((start, end)) return trips"},{"question":"def babylonian_square_root(n: float, tolerance=0.00001) -> float: Calculate the square root of a given positive number using the Babylonian method (also known as Heron's method). The Babylonian method involves making a guess (let's call it 'x') and then improving the guess with the formula: new_x = (x + n / x) / 2. Repeat this process until the difference between 'x' and 'new_x' is very small (e.g., less than 0.00001). Return the improved guess as the result. :param n: The number to find the square root of. :param tolerance: The tolerance level for the approximation. :return: The approximated square root of the number. >>> abs(babylonian_square_root(16) - 4.0) < 0.00001 True >>> abs(babylonian_square_root(25) - 5.0) < 0.00001 True >>> abs(babylonian_square_root(1) - 1.0) < 0.00001 True >>> abs(babylonian_square_root(2) - 1.41421) < 0.00001 True >>> abs(babylonian_square_root(100) - 10.0) < 0.00001 True","solution":"def babylonian_square_root(n, tolerance=0.00001): Calculate the square root of a given positive number using the Babylonian method. :param n: The number to find the square root of. :param tolerance: The tolerance level for the approximation. :return: The approximated square root of the number. x = n while True: new_x = (x + n / x) / 2 if abs(x - new_x) < tolerance: return new_x x = new_x # Example usage # print(babylonian_square_root(16)) # Should output 4.0"},{"question":"def unique_values_in_preorder(n: int, node_values: List[int], edges: List[Tuple[int, int]]) -> int: Find the number of unique values in all nodes of the tree when the tree is traversed using pre-order traversal. :param n: The number of nodes in the tree. :param node_values: A list of integers where the i-th integer represents the value of the i-th node. :param edges: A list of edges where each edge is represented as a tuple of two integers (u, v). :return: An integer representing the number of unique values in the nodes of the tree when traversed in pre-order. >>> unique_values_in_preorder(5, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (2, 4), (2, 5)]) 5 >>> unique_values_in_preorder(7, [1, 1, 2, 3, 2, 3, 4], [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) 4","solution":"def unique_values_in_preorder(n, node_values, edges): from collections import defaultdict, deque # Building the tree from the edge list tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # Pre-order traversal using DFS def preorder_traversal(root): stack = [root] visited = set() unique_values = set() while stack: node = stack.pop() if node not in visited: visited.add(node) unique_values.add(node_values[node-1]) # Add children to the stack (right to left to ensure left nodes are processed first) stack.extend(reversed(tree[node])) return unique_values unique_values = preorder_traversal(1) # Assuming node 1 is the root return len(unique_values)"},{"question":"def max_subarray_sum(arr: List[int]) -> int: Returns the maximum sum of a non-empty subarray of \`arr\`. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([-1]) -1 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([3, -1, 2, -1, 5]) 8 >>> max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) 7 >>> max_subarray_sum([-2, -5, 6, -2, -3, 1, 5, -6]) 7","solution":"def max_subarray_sum(arr): Returns the maximum sum of a non-empty subarray. max_sum = arr[0] current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumOfLeftLeaves(root: TreeNode) -> int: Calculate the sum of all left leaves in a binary tree. >>> Tree = TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))) >>> sumOfLeftLeaves(Tree) 24 >>> Tree = TreeNode(1) >>> sumOfLeftLeaves(Tree) 0 >>> Tree = TreeNode(1, TreeNode(2, TreeNode(3)), None) >>> sumOfLeftLeaves(Tree) 3 >>> Tree = TreeNode(1, None, TreeNode(2, None, TreeNode(3))) >>> sumOfLeftLeaves(Tree) 0 >>> Tree = TreeNode(5, TreeNode(3, TreeNode(1), TreeNode(4)), TreeNode(8, None, TreeNode(9))) >>> sumOfLeftLeaves(Tree) 1 >>> Tree = TreeNode(10, TreeNode(20, TreeNode(40), TreeNode(50)), TreeNode(30, TreeNode(60), TreeNode(70))) >>> sumOfLeftLeaves(Tree) 100 # Your code here","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_leaf(node: TreeNode) -> bool: return node is not None and node.left is None and node.right is None def sumOfLeftLeaves(root: TreeNode) -> int: if root is None: return 0 sum_left_leaves = 0 if root.left is not None: if is_leaf(root.left): sum_left_leaves += root.left.val else: sum_left_leaves += sumOfLeftLeaves(root.left) sum_left_leaves += sumOfLeftLeaves(root.right) return sum_left_leaves"},{"question":"import re from typing import List def predict_category(book_content: str) -> int: Predicts the category of the book based on the content using simplified keyword matching. >>> predict_category(\\"In the future, humanity may encounter alien spaceships and robots.\\") 1 >>> predict_category(\\"Their love story began with a romantic wedding by the beach.\\") 2 >>> predict_category(\\"The detective uncovered a clue that solved the old murder mystery.\\") 3 >>> predict_category(\\"His life story is an inspiring biography of a great person.\\") 4 >>> predict_category(\\"Philosophy involves exploring deep thoughts on ethics and existence.\\") 5 def classify_book(book_id: int, title: str, author: str, content: List[str]) -> int: Classifies the book into a category based on its content. >>> classify_book(123, \\"A Journey to the Stars\\", \\"John Doe\\", [\\"In the future, humanity may encounter alien spaceships and robots.\\"]) 1 >>> classify_book(124, \\"Love in the Time of Science\\", \\"Jane Smith\\", [\\"Their love story began with a romantic wedding by the beach.\\"]) 2 >>> classify_book(125, \\"Mystery of the Old Mansion\\", \\"Arthur Conan\\", [\\"The detective uncovered a clue that solved the old murder mystery.\\"]) 3 >>> classify_book(126, \\"Life of a Genius\\", \\"Emily Bronte\\", [\\"His life story is an inspiring biography of a great person.\\"]) 4 >>> classify_book(127, \\"Philosophical Thoughts\\", \\"Albert Camus\\", [\\"Philosophy involves exploring deep thoughts on ethics and existence.\\"]) 5","solution":"import re from collections import Counter import random # Predefined categories and related sample words for simplification. CATEGORY_WORDS = { 1: [\\"space\\", \\"robot\\", \\"time\\", \\"future\\", \\"alien\\"], 2: [\\"love\\", \\"romance\\", \\"heart\\", \\"kiss\\", \\"wedding\\"], 3: [\\"murder\\", \\"detective\\", \\"mystery\\", \\"crime\\", \\"clue\\"], 4: [\\"life\\", \\"biography\\", \\"story\\", \\"person\\", \\"achievement\\"], 5: [\\"philosophy\\", \\"thought\\", \\"mind\\", \\"ethics\\", \\"existence\\"], } def predict_category(book_content): Predicts the category of the book based on the content using simplified keyword matching. words = re.findall(r'w+', book_content.lower()) counts = Counter(words) # Score each category based on the presence of keywords category_scores = {cat: sum(counts[word] for word in words_list) for cat, words_list in CATEGORY_WORDS.items()} # Return the category with the highest score predicted_category = max(category_scores, key=category_scores.get) return predicted_category def classify_book(book_id, title, author, content): Classifies the book into a category based on its content. book_content = ' '.join(content) return predict_category(book_content)"},{"question":"def count_pairs_with_difference(arr, k): Count the number of unordered pairs (i, j) in an array such that |arr[i] - arr[j]| = k and i ≠ j. Parameters: arr (List[int]): List of integers representing the array k (int): The difference to check for Returns: int: The count of pairs with the specified difference >>> count_pairs_with_difference([1, 5, 3, 4, 2], 2) 3 >>> count_pairs_with_difference([1, 2, 3, 4], 1) 3 pass from solution import count_pairs_with_difference def test_example_1(): arr = [1, 5, 3, 4, 2] k = 2 assert count_pairs_with_difference(arr, k) == 3 def test_example_2(): arr = [1, 2, 3, 4] k = 1 assert count_pairs_with_difference(arr, k) == 3 def test_no_pairs(): arr = [1, 2, 3, 4] k = 5 assert count_pairs_with_difference(arr, k) == 0 def test_zero_difference(): arr = [1, 1, 1, 1] k = 0 assert count_pairs_with_difference(arr, k) == 6 def test_large_difference(): arr = [1, 1000000] k = 999999 assert count_pairs_with_difference(arr, k) == 1 def test_multiple_same_numbers(): arr = [1, 2, 2, 2, 5] k = 3 assert count_pairs_with_difference(arr, k) == 3 def test_large_array(): arr = list(range(2 * 10**5)) k = 1 assert count_pairs_with_difference(arr, k) == 2 * 10**5 - 1","solution":"def count_pairs_with_difference(arr, k): Counts the number of unordered pairs (i, j) in an array such that |arr[i] - arr[j]| = k and i ≠ j. :param arr: List of integers representing the array :param k: The difference to check for :return: The count of pairs with the specified difference from collections import Counter count = 0 freq_map = Counter(arr) if k == 0: # Special case when k is 0, we need counts of elements that appear more than once. for val in freq_map.values(): if val > 1: count += val * (val - 1) // 2 else: for num in freq_map: if num + k in freq_map: count += freq_map[num] * freq_map[num + k] return count"},{"question":"def calculate_total_cost(n: int, cities: List[str], ticket_prices: List[Tuple[str, str, int]]) -> int: Calculate the total cost of the journey. :param n: Number of cities in the itinerary :param cities: List of cities in the order Tom plans to visit them :param ticket_prices: List of tuples containing (city1, city2, price) representing the price of the train ticket between each consecutive pair of cities :return: Total cost of the journey Examples: >>> calculate_total_cost(5, [\\"PARIS\\", \\"BERLIN\\", \\"AMSTERDAM\\", \\"BRUSSELS\\", \\"LONDON\\"], [(\\"PARIS\\", \\"BERLIN\\", 50), (\\"BERLIN\\", \\"AMSTERDAM\\", 40), (\\"AMSTERDAM\\", \\"BRUSSELS\\", 30), (\\"BRUSSELS\\", \\"LONDON\\", 20)]) 140 >>> calculate_total_cost(3, [\\"NYC\\", \\"LA\\", \\"SF\\"], [(\\"NYC\\", \\"LA\\", 100), (\\"LA\\", \\"SF\\", 150)]) 250 >>> calculate_total_cost(4, [\\"A\\", \\"B\\", \\"C\\", \\"D\\"], [(\\"A\\", \\"B\\", 10), (\\"B\\", \\"C\\", 20), (\\"C\\", \\"D\\", 30)]) 60 >>> calculate_total_cost(4, [\\"A\\", \\"B\\", \\"C\\", \\"D\\"], [(\\"A\\", \\"C\\", 15), (\\"B\\", \\"D\\", 25)]) 0 >>> calculate_total_cost(4, [\\"A\\", \\"B\\", \\"C\\", \\"D\\"], [(\\"C\\", \\"D\\", 30), (\\"B\\", \\"C\\", 20), (\\"A\\", \\"B\\", 10)]) 60","solution":"def calculate_total_cost(n, cities, ticket_prices): Calculate the total cost of the journey. :param n: Number of cities in the itinerary :param cities: List of cities in the order Tom plans to visit them :param ticket_prices: List of tuples containing (city1, city2, price) representing the price of the train ticket between each consecutive pair of cities :return: Total cost of the journey city_index = {city: i for i, city in enumerate(cities)} total_cost = 0 for city1, city2, price in ticket_prices: if city_index[city1] + 1 == city_index[city2]: total_cost += price return total_cost"},{"question":"def can_make_same_height(buildings): Determines if it is possible to make all buildings the same height by decreasing the height of the taller building to match the height of the shorter one for any two adjacent buildings. Parameters: buildings (list): List of integers representing the heights of the buildings. Returns: str: \\"YES\\" if possible, \\"NO\\" otherwise. Examples: >>> can_make_same_height([3, 3, 3]) 'YES' >>> can_make_same_height([1, 2, 3, 4]) 'NO' >>> can_make_same_height([5, 5, 5, 5, 5]) 'YES' >>> can_make_same_height([10, 5]) 'YES' >>> can_make_same_height([7, 7, 6, 5, 5]) 'YES' >>> can_make_same_height([7, 7, 6, 8, 5]) 'NO' >>> can_make_same_height([5, 4, 4, 3, 3]) 'YES' >>> can_make_same_height([1, 1, 2, 1]) 'NO' >>> can_make_same_height([1]) 'YES'","solution":"def can_make_same_height(buildings): Determines if it is possible to make all buildings the same height by decreasing the height of the taller building to match the height of the shorter one for any two adjacent buildings. Parameters: buildings (list): List of integers representing the heights of the buildings. Returns: str: \\"YES\\" if possible, \\"NO\\" otherwise. N = len(buildings) # We only need to check if the heights of buildings form a non-increasing sequence for i in range(1, N): if buildings[i] > buildings[i-1]: return \\"NO\\" return \\"YES\\" # Reading from standard input if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) heights = list(map(int, data[1:N + 1])) result = can_make_same_height(heights) print(result)"},{"question":"def calculate_total_deliciousness(F, N, sweetness_values, crunchiness_values): Calculate the total deliciousness of the fruit salad. Args: F (int): The number of fruit types. N (int): The number of nut types. sweetness_values (list of int): The sweetness values of the fruits. crunchiness_values (list of int): The crunchiness values of the nuts. Returns: int: The total deliciousness of the fruit salad. def test_example_1(): F = 3 N = 2 sweetness_values = [3, 4, 2] crunchiness_values = [5, 6] assert calculate_total_deliciousness(F, N, sweetness_values, crunchiness_values) == 99 def test_example_2(): F = 1 N = 1 sweetness_values = [10] crunchiness_values = [10] assert calculate_total_deliciousness(F, N, sweetness_values, crunchiness_values) == 100 def test_minimum_values(): F = 1 N = 1 sweetness_values = [1] crunchiness_values = [1] assert calculate_total_deliciousness(F, N, sweetness_values, crunchiness_values) == 1 def test_different_values(): F = 2 N = 3 sweetness_values = [1, 2] crunchiness_values = [1, 2, 3] assert calculate_total_deliciousness(F, N, sweetness_values, crunchiness_values) == 18 def test_large_numbers(): F = 3 N = 3 sweetness_values = [1000, 1000, 1000] crunchiness_values = [1000, 1000, 1000] assert calculate_total_deliciousness(F, N, sweetness_values, crunchiness_values) == 9000000","solution":"def calculate_total_deliciousness(F, N, sweetness_values, crunchiness_values): Calculate the total deliciousness of the fruit salad. Args: F (int): The number of fruit types. N (int): The number of nut types. sweetness_values (list of int): The sweetness values of the fruits. crunchiness_values (list of int): The crunchiness values of the nuts. Returns: int: The total deliciousness of the fruit salad. total_deliciousness = 0 for sweetness in sweetness_values: for crunchiness in crunchiness_values: total_deliciousness += sweetness * crunchiness return total_deliciousness"},{"question":"def can_sum_to_target(nums: List[int], target: int) -> str: Check if there are two distinct integers in the array that add up to the target value. >>> can_sum_to_target([1, 2, 3, 4, 5], 9) \\"YES\\" >>> can_sum_to_target([1, 2, 4, 4], 8) \\"YES\\" >>> can_sum_to_target([1, 2, 3, 4, 5], 10) \\"NO\\" >>> can_sum_to_target([-1, -2, -3, -4, -5], -9) \\"YES\\" >>> can_sum_to_target([0, 0, 0, 0], 0) \\"YES\\" >>> can_sum_to_target([], 0) \\"NO\\" def process_test_cases(test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Process multiple test cases and return results for each as a list. >>> test_cases = [(5, 9, [1, 2, 3, 4, 5]), (4, 8, [1, 2, 4, 4]), (5, 10, [1, 2, 3, 4, 5]), (5, 7, [-1, -2, -3, -4, -5])] >>> process_test_cases(test_cases) [\\"YES\\", \\"YES\\", \\"NO\\", \\"NO\\"]","solution":"def can_sum_to_target(nums, target): Check if there are two distinct integers in the array that add up to the target value. num_set = set() for num in nums: if target - num in num_set: return \\"YES\\" num_set.add(num) return \\"NO\\" def process_test_cases(test_cases): Process multiple test cases and return results for each as a list. results = [] for t in test_cases: n, target, nums = t result = can_sum_to_target(nums, target) results.append(result) return results"},{"question":"def longest_unique_subsequence(strings: List[str]) -> List[str]: Given a list of strings, each string represents a sequence composed of lowercase English alphabets and digits from '0' to '9'. Find the longest contiguous subsequence within each string that contains unique characters. If there are multiple longest subsequences of the same length, return the first one found. >>> longest_unique_subsequence([\\"abcabcbb\\"]) == [\\"abc\\"] >>> longest_unique_subsequence([\\"bbbbb\\"]) == [\\"b\\"] >>> longest_unique_subsequence([\\"pwwkew\\"]) == [\\"wke\\"] >>> longest_unique_subsequence([\\"abcdefg\\"]) == [\\"abcdefg\\"] >>> longest_unique_subsequence([\\"\\"]) == [\\"\\"] >>> longest_unique_subsequence([\\"aabbccddeeff\\"]) == [\\"ab\\"] >>> longest_unique_subsequence([\\"abcdabc\\"]) == [\\"abcd\\"] >>> longest_unique_subsequence([\\"abca\\"]) == [\\"abc\\"] >>> longest_unique_subsequence([\\"123456123\\"]) == [\\"123456\\"]","solution":"def longest_unique_subsequence(strings): def get_longest_unique_subsequence(s): char_index = {} longest_subseq = \\"\\" current_subseq = \\"\\" start = 0 for end, char in enumerate(s): if char in char_index and char_index[char] >= start: start = char_index[char] + 1 current_subseq = s[start:end + 1] else: current_subseq += char char_index[char] = end if len(current_subseq) > len(longest_subseq): longest_subseq = current_subseq return longest_subseq return [get_longest_unique_subsequence(string) for string in strings]"},{"question":"def find_pair_with_sum(arr, k): Determines if there exists a pair of indices (i, j) such that i ≠ j and arr[i] + arr[j] == k. :param arr: List of integers :param k: Target sum :return: \\"YES\\" if such a pair exists, otherwise \\"NO\\" from solution import find_pair_with_sum def test_find_pair_with_sum_positive_case(): assert find_pair_with_sum([1, 2, 3, 4, 5], 6) == \\"YES\\" def test_find_pair_with_sum_large_negative_case(): assert find_pair_with_sum([1, 2, 3, 9], 8) == \\"NO\\" def test_find_pair_with_sum_mixed_elements(): assert find_pair_with_sum([10, 15, 3, 7], 17) == \\"YES\\" def test_find_pair_with_sum_no_pair(): assert find_pair_with_sum([1, 1, 1, 1], 3) == \\"NO\\" def test_find_pair_with_sum_zero_case(): assert find_pair_with_sum([1, -1, 2, -2], 0) == \\"YES\\" def test_find_pair_with_sum_single_pair(): assert find_pair_with_sum([1, 2], 3) == \\"YES\\" def test_find_pair_with_sum_no_possible_pair(): assert find_pair_with_sum([5, 6, 7, 8], 1) == \\"NO\\"","solution":"def find_pair_with_sum(arr, k): Determines if there exists a pair of indices (i, j) such that i ≠ j and arr[i] + arr[j] == k. :param arr: List of integers :param k: Target sum :return: \\"YES\\" if such a pair exists, otherwise \\"NO\\" seen = set() for num in arr: if k - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"def reverseAlternatingKChunks(s: str, k: int) -> str: Reverse k characters in a string and leave k characters unchanged, continuing this pattern throughout the string. >>> reverseAlternatingKChunks(\\"abcdefg\\", 2) \\"bacdfeg\\" >>> reverseAlternatingKChunks(\\"abc\\", 3) \\"cba\\" >>> reverseAlternatingKChunks(\\"abcdefghij\\", 3) \\"cbadefihgj\\"","solution":"def reverseAlternatingKChunks(s, k): result = [] i = 0 n = len(s) reverse_flag = True while i < n: if reverse_flag: # Reverse next k characters result.append(s[i:i+k][::-1]) else: # Leave next k characters as they are result.append(s[i:i+k]) i += k reverse_flag = not reverse_flag return ''.join(result)"},{"question":"def smallest_lexicographical_string(s: str) -> str: Determines the lexicographically smallest string that can be obtained by replacing any two adjacent characters with their lexicographically middle character. >>> smallest_lexicographical_string(\\"a\\") \\"a\\" >>> smallest_lexicographical_string(\\"zzzz\\") \\"zzzz\\" >>> smallest_lexicographical_string(\\"abcde\\") \\"aaaaa\\" >>> smallest_lexicographical_string(\\"bac\\") \\"aaa\\" >>> smallest_lexicographical_string(\\"azazaz\\") \\"aaaaaa\\" >>> smallest_lexicographical_string(\\"cba\\") \\"aaa\\"","solution":"def smallest_lexicographical_string(s): Determines the lexicographically smallest string that can be obtained by replacing any two adjacent characters with their lexicographically middle character. # In essence, the lexicographically smallest string # we can get is a string composed of the smallest character in the input return min(s) * len(s)"},{"question":"def manage_parking_spots(n: int, notices: List[Tuple[int, int, int, int]]): Manage parking spots in a parking garage. Each parking notice consists of four integers l, s, p, and m which indicate that m cars have parked in spot p of section s on level l. If m is negative, it means -m cars have exited. If m exceeds the number of available spots, do not park any cars from this notice. Args: n (int): Number of notices. notices (List[Tuple[int, int, int, int]]): A list of tuples with each tuple containing (l, s, p, m). Returns: None. The function prints the number of available spots for each section on each level of the parking garage. Example: >>> manage_parking_spots(0, []) 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 ===================== 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 ===================== 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 ===================== 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 ===================== 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4","solution":"def manage_parking_spots(n, notices): levels = [[[4] * 8 for _ in range(2)] for _ in range(5)] for notice in notices: l, s, p, m = notice l -= 1 # Adjust to zero-indexed s -= 1 # Adjust to zero-indexed p -= 1 # Adjust to zero-indexed if m > 0: # Trying to park cars if levels[l][s][p] >= m: levels[l][s][p] -= m else: # m < 0, meaning cars are exiting levels[l][s][p] -= m # m is negative, so we add the number of cars exiting for i in range(5): for section in levels[i]: print(\\" \\" + \\" \\".join(map(str, section))) if i < 4: print(\\"=\\" * 21)"},{"question":"def process_inventory_transactions(n: int, transactions: List[str]) -> List[str]: Processes a series of inventory transactions and returns the final stock levels for each item. :param n: Number of transactions :param transactions: List of transaction strings in the format \\"identifier quantity\\" :return: List of strings in the format \\"identifier: quantity\\" sorted lexicographically by the identifier pass def test_single_item_incoming(): transactions = [\\"apples 10\\"] assert process_inventory_transactions(1, transactions) == [\\"apples: 10\\"] def test_single_item_outgoing(): transactions = [\\"apples -5\\"] assert process_inventory_transactions(1, transactions) == [\\"apples: -5\\"] def test_multiple_items(): transactions = [\\"apples 10\\", \\"bananas 5\\", \\"apples -3\\", \\"oranges 12\\", \\"apples 7\\"] assert process_inventory_transactions(5, transactions) == [\\"apples: 14\\", \\"bananas: 5\\", \\"oranges: 12\\"] def test_no_transactions(): transactions = [] assert process_inventory_transactions(0, transactions) == [] def test_negative_quantity(): transactions = [\\"item1 5\\", \\"item2 10\\", \\"item1 -5\\"] assert process_inventory_transactions(3, transactions) == [\\"item1: 0\\", \\"item2: 10\\"] def test_multiple_updates(): transactions = [\\"item1 10\\", \\"item2 20\\", \\"item1 -5\\", \\"item3 15\\", \\"item2 5\\"] assert process_inventory_transactions(5, transactions) == [\\"item1: 5\\", \\"item2: 25\\", \\"item3: 15\\"] def test_lexicographical_order(): transactions = [\\"b 1\\", \\"a 2\\", \\"c 3\\"] assert process_inventory_transactions(3, transactions) == [\\"a: 2\\", \\"b: 1\\", \\"c: 3\\"]","solution":"def process_inventory_transactions(n, transactions): Processes a series of inventory transactions and returns the final stock levels for each item. :param n: Number of transactions :param transactions: List of transaction strings in the format \\"identifier quantity\\" :return: List of strings in the format \\"identifier: quantity\\" sorted lexicographically by the identifier inventory = {} for transaction in transactions: parts = transaction.split() identifier = parts[0] quantity = int(parts[1]) if identifier in inventory: inventory[identifier] += quantity else: inventory[identifier] = quantity result = [f\\"{key}: {inventory[key]}\\" for key in sorted(inventory.keys())] return result # Example usage: # transactions = [\\"apples 10\\", \\"bananas 5\\", \\"apples -3\\", \\"oranges 12\\", \\"apples 7\\"] # print(process_inventory_transactions(5, transactions))"},{"question":"def is_symmetric(matrix): Checks if the given matrix is symmetric. >>> is_symmetric([[1, 2, 3], [2, 1, 4], [3, 4, 1]]) 'Symmetric' >>> is_symmetric([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 'Not Symmetric' >>> is_symmetric([[1]]) 'Symmetric' >>> is_symmetric([[1, 2], [2, 1]]) 'Symmetric' >>> is_symmetric([[1, 2], [3, 4]]) 'Not Symmetric' >>> is_symmetric([[-1, -2, -3], [-2, -1, -4], [-3, -4, -1]]) 'Symmetric' >>> is_symmetric([[0, 2, 3], [2, 0, 4], [3, 4, 0]]) 'Symmetric' pass # Write your code here def read_matrix(input): Reads the matrix from the given input string. >>> read_matrix('3n1 2 3n2 1 4n3 4 1') [[1, 2, 3], [2, 1, 4], [3, 4, 1]] >>> read_matrix('3n1 2 3n4 5 6n7 8 9') [[1, 2, 3], [4, 5, 6], [7, 8, 9]] pass # Write your code here def main(input): Main function to check if the matrix is symmetric. >>> main('3n1 2 3n2 1 4n3 4 1') 'Symmetric' >>> main('3n1 2 3n4 5 6n7 8 9') 'Not Symmetric' matrix = read_matrix(input) return is_symmetric(matrix) if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"def is_symmetric(matrix): Checks if the given matrix is symmetric. n = len(matrix) for i in range(n): for j in range(n): if matrix[i][j] != matrix[j][i]: return \\"Not Symmetric\\" return \\"Symmetric\\" def read_matrix(input): Reads the matrix from the given input string. lines = input.strip().split('n') n = int(lines[0]) matrix = [] for i in range(1, n + 1): matrix.append(list(map(int, lines[i].split()))) return matrix def main(input): matrix = read_matrix(input) return is_symmetric(matrix)"},{"question":"def reading_order(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Given the list of book IDs, help Anna create her reading order that follows her pattern. Input format: - The first line contains an integer \`T\`, the number of test cases. - For each test case: - The first line contains an integer \`N\`, the number of books. - The second line contains \`N\` space-separated integers representing the IDs of the books. Output format: - For each test case, output the reading order for Anna in a single line, with each ID separated by a space. >>> reading_order(2, [(6, [5, 1, 9, 3, 7, 4]), (4, [8, 2, 10, 6])]) ['1 9 3 7 4 5', '2 10 6 8'] >>> reading_order(1, [(5, [1, 3, 5, 7, 9])]) ['1 9 3 7 5'] >>> reading_order(1, [(1, [7])]) ['7'] >>> reading_order(1, [(3, [2, 2, 2])]) ['2 2 2'] >>> reading_order(1, [(2, [10, 1])]) ['1 10'] >>> reading_order(1, [(4, [1, 2, 3, 4])]) ['1 4 2 3']","solution":"def reading_order(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] books = test_cases[i][1] books.sort() left = 0 right = N - 1 order = [] while left <= right: if left == right: order.append(books[left]) break order.append(books[left]) order.append(books[right]) left += 1 right -= 1 results.append(\\" \\".join(map(str, order))) return results"},{"question":"def max_efficiency(N, skills): Returns the maximum total efficiency that can be achieved by assigning workers to positions optimally. >>> max_efficiency(3, [4, 3, 2]) 20 >>> max_efficiency(5, [1, 2, 3, 4, 5]) 55 >>> max_efficiency(4, [10, 20, 30, 40]) 300","solution":"def max_efficiency(N, skills): Returns the maximum total efficiency that can be achieved by assigning workers to positions optimally. skills.sort() positions = list(range(1, N + 1)) total_efficiency = sum(s * p for s, p in zip(skills, positions)) return total_efficiency"},{"question":"from typing import List def min_moves_to_reach_goal(N: int, M: int, grid: List[str]) -> int: Alice and Bob are playing a game on a two-dimensional grid of size N x M. Initially, there are some obstacles positioned on the grid. Alice starts at the top-left corner (0, 0) and her goal is to reach the bottom-right corner (N-1, M-1). She can move in four possible directions: up, down, left, and right. However, Alice cannot move onto a cell that contains an obstacle. Write a program to determine the minimum number of moves Alice needs to reach her goal. If it is impossible for Alice to reach her goal, return -1. >>> min_moves_to_reach_goal(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 4 >>> min_moves_to_reach_goal(3, 3, [\\"...\\", \\"#\\", \\"...\\"]) -1 >>> min_moves_to_reach_goal(5, 5, [\\".....\\", \\".#.#.\\", \\"..#..\\", \\".#.#.\\", \\".....\\"]) 8 from solution import min_moves_to_reach_goal def test_example1(): grid = [ \\"...\\", \\".#.\\", \\"...\\" ] assert min_moves_to_reach_goal(3, 3, grid) == 4 def test_example2(): grid = [ \\"...\\", \\"#\\", \\"...\\" ] assert min_moves_to_reach_goal(3, 3, grid) == -1 def test_example3(): grid = [ \\".....\\", \\".#.#.\\", \\"..#..\\", \\".#.#.\\", \\".....\\" ] assert min_moves_to_reach_goal(5, 5, grid) == 8 def test_edge_case_blocked_start(): grid = [ \\"#...\\", \\"....\\", \\"....\\", \\"...\\" ] assert min_moves_to_reach_goal(4, 4, grid) == -1 def test_edge_case_blocked_goal(): grid = [ \\"....\\", \\"....\\", \\"....\\", \\"...#\\" ] assert min_moves_to_reach_goal(4, 4, grid) == -1 def test_minimal_grid(): grid = [ \\"..\\", \\"\\" ] assert min_moves_to_reach_goal(2, 2, grid) == -1 def test_no_obstacles(): grid = [ \\"...\\", \\"...\\", \\"...\\" ] assert min_moves_to_reach_goal(3, 3, grid) == 4","solution":"from collections import deque def min_moves_to_reach_goal(N, M, grid): if grid[0][0] == '#' or grid[N-1][M-1] == '#': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() if x == N-1 and y == M-1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and (nx, ny) not in visited and grid[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"def kth_highest_distinct_score(N: int, k: int, scores: List[int]) -> int: Returns the k-th highest distinct score from the list of scores. If there are fewer than k distinct scores, returns -1. >>> kth_highest_distinct_score(5, 3, [50, 70, 70, 50, 80]) == 50 >>> kth_highest_distinct_score(5, 3, [50, 70, 70, 50, 50]) == -1 >>> kth_highest_distinct_score(6, 2, [1000000000, 999999999, 1000000000, 0, -1000000000, 999999999]) == 999999999 >>> kth_highest_distinct_score(5, 1, [50, 70, 70, 50, 80]) == 80 >>> kth_highest_distinct_score(5, 4, [10, 20, 30, 40, 50]) == 20 >>> kth_highest_distinct_score(1, 1, [10]) == 10 >>> kth_highest_distinct_score(5, 2, [-1, -2, -3, -1, -2]) == -2 >>> kth_highest_distinct_score(7, 5, [1, 2, 3, 4, 5, 6, 7]) == 3","solution":"def kth_highest_distinct_score(N, k, scores): Returns the k-th highest distinct score from the list of scores. If there are fewer than k distinct scores, returns -1. distinct_scores = list(set(scores)) distinct_scores.sort(reverse=True) if k <= len(distinct_scores): return distinct_scores[k-1] else: return -1"},{"question":"def max_balanced_subarray_length(arr: List[int]) -> int: Returns the length of the longest balanced subarray. A balanced subarray is defined as an array whose sum is even. Parameters: arr (list of int): The input array of integers. Returns: int: The length of the longest balanced subarray. Examples: >>> max_balanced_subarray_length([1, 2, 3, 4, 5]) == 4 >>> max_balanced_subarray_length([2, 4, 6]) == 3 >>> max_balanced_subarray_length([1]) == 0 >>> max_balanced_subarray_length([2]) == 1 >>> max_balanced_subarray_length([1, 3, 5]) == 2 >>> max_balanced_subarray_length([2] * 100000) == 100000 >>> max_balanced_subarray_length([2] * 99999 + [1]) == 99999","solution":"def max_balanced_subarray_length(arr): Returns the length of the longest balanced subarray. A balanced subarray is defined as an array whose sum is even. Parameters: arr (list of int): The input array of integers. Returns: int: The length of the longest balanced subarray. n = len(arr) if n == 0: return 0 total_sum = sum(arr) if total_sum % 2 == 0: return n for i, num in enumerate(arr): if num % 2 != 0: # Removing this odd number would balance the array return n - 1 return 0"},{"question":"def max_contiguous_subarray_sum(n, k, arr): Given an array of integers and an integer k, returns the highest sum of any contiguous subarray of size k. If no such subarray can be found, returns -1. pass from max_contiguous_subarray_sum import max_contiguous_subarray_sum def test_example_1(): assert max_contiguous_subarray_sum(8, 3, [5, 2, -1, 0, 3, 12, 6, -3]) == 21 def test_example_2(): assert max_contiguous_subarray_sum(4, 2, [-1, -2, -3, -4]) == -3 def test_single_element(): assert max_contiguous_subarray_sum(1, 1, [5]) == 5 def test_all_negative_elements(): assert max_contiguous_subarray_sum(5, 3, [-1, -2, -3, -4, -5]) == -6 def test_large_n_k_equal(): assert max_contiguous_subarray_sum(5, 5, [1, 2, 3, 4, 5]) == 15 def test_k_greater_than_n(): assert max_contiguous_subarray_sum(3, 4, [1, 2, 3]) == -1 def test_mixed_values(): assert max_contiguous_subarray_sum(10, 4, [1, 3, -2, 5, 2, -1, 6, 0, -4, 8]) == 12 def test_large_k(): assert max_contiguous_subarray_sum(6, 6, [-3, 4, -1, 2, 1, -5]) == -2","solution":"def max_contiguous_subarray_sum(n, k, arr): Given an array of integers and an integer k, returns the highest sum of any contiguous subarray of size k. If no such subarray can be found, returns -1. if k > n: return -1 # Initialize the sum of the first k elements max_sum = current_sum = sum(arr[:k]) # Iterate through the array, moving the window to the right for i in range(k, n): current_sum += arr[i] - arr[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def min_steps_to_destination(n: int, m: int, elevation: List[List[int]], flooded_cells: List[Tuple[int, int]], start: Tuple[int, int], destination: Tuple[int, int]) -> int: Help Eve the Explorer reach her destination in the minimum number of steps in a grid with given elevations and flooded cells. Arguments: n -- number of rows in the grid m -- number of columns in the grid elevation -- 2D list of integers representing the elevations of each cell flooded_cells -- list of tuples representing the coordinates of flooded cells start -- tuple of two integers (sx, sy) representing the starting coordinates destination -- tuple of two integers (dx, dy) representing the destination coordinates Returns: int -- minimum number of steps to reach the destination, or -1 if it's impossible. Examples: >>> min_steps_to_destination( ... 5, 5, ... [ ... [1, 2, 3, 4, 5], ... [5, 6, 7, 8, 9], ... [10, 11, 12, 13, 14], ... [15, 16, 17, 18, 19], ... [20, 21, 22, 23, 24] ... ], ... [(1, 1), (3, 3)], ... (0, 0), (4, 4) ... ) 8 >>> min_steps_to_destination( ... 3, 3, ... [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ], ... [(1, 1)], ... (0, 0), (2, 2) ... ) 4 >>> min_steps_to_destination( ... 3, 3, ... [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ], ... [(0, 1), (1, 1), (2, 1)], ... (0, 0), (2, 2) ... ) -1","solution":"from collections import deque def min_steps_to_destination(n, m, elevation, flooded_cells, start, destination): sx, sy = start dx, dy = destination # Initiate the grid with flooded cells as '-1' grid = [[elevation[i][j] for j in range(m)] for i in range(n)] for fx, fy in flooded_cells: grid[fx][fy] = -1 # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS initialization queue = deque([(sx, sy, 0)]) # Each entry: (current x, current y, current steps) visited = set([(sx, sy)]) while queue: x, y, steps = queue.popleft() # If we reach destination if (x, y) == (dx, dy): return steps for direction in directions: nx, ny = x + direction[0], y + direction[1] if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited: if grid[nx][ny] != -1 and grid[nx][ny] > grid[x][y]: queue.append((nx, ny, steps + 1)) visited.add((nx, ny)) # Destination is not reachable return -1"},{"question":"from typing import List def min_moves_to_target(n: int, m: int, grid: List[str], sx: int, sy: int, tx: int, ty: int) -> int: Determines the minimum number of moves required for a character to get from the start position to the target position on a grid. Each cell in the grid either contains an obstacle ('#') or is empty ('.'). Args: n: Number of rows in the grid. m: Number of columns in the grid. grid: List of strings representing the grid cells. sx: Starting row index (1-based index). sy: Starting column index (1-based index). tx: Target row index (1-based index). ty: Target column index (1-based index). Returns: Minimum number of moves required to reach the target position from the start position, or -1 if it is impossible. Examples: >>> n = 5 >>> m = 5 >>> grid = [ ... \\".#...\\", ... \\"...\\", ... \\"#....\\", ... \\"...#.\\", ... \\"...\\" ... ] >>> sx, sy, tx, ty = 1, 1, 5, 5 >>> min_moves_to_target(n, m, grid, sx, sy, tx, ty) 8 >>> n = 3 >>> m = 3 >>> grid = [ ... \\".#.\\", ... \\"#\\", ... \\".#.\\" ... ] >>> sx, sy, tx, ty = 1, 1, 3, 3 >>> min_moves_to_target(n, m, grid, sx, sy, tx, ty) -1 pass def test_min_moves_basic(): n = 5 m = 5 grid = [ \\".#...\\", \\"...\\", \\"#....\\", \\"...#.\\", \\"...\\" ] sx, sy, tx, ty = 1, 1, 5, 5 assert min_moves_to_target(n, m, grid, sx, sy, tx, ty) == 8 def test_min_moves_impossible(): n = 3 m = 3 grid = [ \\".#.\\", \\"#\\", \\".#.\\" ] sx, sy, tx, ty = 1, 1, 3, 3 assert min_moves_to_target(n, m, grid, sx, sy, tx, ty) == -1 def test_min_moves_same_start_end(): n = 2 m = 2 grid = [ \\"..\\", \\"..\\" ] sx, sy, tx, ty = 1, 1, 1, 1 assert min_moves_to_target(n, m, grid, sx, sy, tx, ty) == 0 def test_min_moves_simple_path(): n = 3 m = 3 grid = [ \\"...\\", \\"...\\", \\"...\\" ] sx, sy, tx, ty = 1, 1, 3, 3 assert min_moves_to_target(n, m, grid, sx, sy, tx, ty) == 4 def test_min_moves_blocked(): n = 3 m = 3 grid = [ \\"...\\", \\".#.\\", \\"...\\" ] sx, sy, tx, ty = 1, 1, 2, 2 assert min_moves_to_target(n, m, grid, sx, sy, tx, ty) == -1","solution":"from collections import deque def min_moves_to_target(n, m, grid, sx, sy, tx, ty): # Directions for up, down, left, right movements directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Adjust starting and ending positions to 0-based index sx, sy, tx, ty = sx - 1, sy - 1, tx - 1, ty - 1 # Initialize visited set and queue for BFS visited = set() queue = deque([(sx, sy, 0)]) # (current_row, current_col, distance) visited.add((sx, sy)) while queue: x, y, dist = queue.popleft() # If we reach the target position, return the distance if x == tx and y == ty: return dist # Explore all four directions for dx, dy in directions: nx, ny = x + dx, y + dy # Check within bounds and not visited and not an obstacle if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '.': queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) # If we exhaust the queue without finding the target, return -1 return -1"},{"question":"from itertools import permutations from typing import List def count_distinct_times(n: int, gears: List[int]) -> int: Calculate the total number of distinct times the clock can display based on the permutation of the gears given. n: number of gears gears: list containing number of teeth on each gear >>> count_distinct_times(3, [3, 3, 3]) 1 >>> count_distinct_times(4, [2, 3, 5, 7]) 24 >>> count_distinct_times(3, [1, 2, 2]) 3 >>> count_distinct_times(1, [1]) 1 >>> count_distinct_times(2, [1, 2]) 2 >>> count_distinct_times(2, [2, 2]) 1","solution":"from itertools import permutations def count_distinct_times(n, gears): Calculate the total number of distinct times the clock can display based on the permutation of the gears given. n: number of gears gears: list containing number of teeth on each gear distinct_permutations = set(permutations(gears)) return len(distinct_permutations)"},{"question":"def can_fit_flower_in_vase(test_cases): Determine if flowers can be arranged in a vase without exceeding its maximum capacity. Args: test_cases (list): A list of tuples containing the number of flowers (int), their bloom durations (list of ints) and the vase's capacity (int). Returns: list: A list of strings, each being \\"CAN FIT\\" or \\"CANNOT FIT\\" for each test case. pass def parse_input(input_string): Parse the input string into test cases. Args: input_string (str): Input string containing all test cases. Returns: list: Parsed test cases in the form of a list of tuples. pass def main(input_string): Main function to process the input and provide results. Args: input_string (str): Input string containing all test cases. Returns: list: A list of strings containing results for each test case. pass # Example usage and testing if __name__ == \\"__main__\\": input_data = 2 5 1 2 3 4 5 20 3 6 7 8 19 result = main(input_data) print(result) # Output: ['CAN FIT', 'CANNOT FIT']","solution":"def can_fit_flower_in_vase(test_cases): Determine if flowers can be arranged in a vase without exceeding its maximum capacity. Args: test_cases (list): A list of tuples containing the number of flowers (int), their bloom durations (list of ints) and the vase's capacity (int). Returns: list: A list of strings, each being \\"CAN FIT\\" or \\"CANNOT FIT\\" for each test case. results = [] for k, bloom_durations, C in test_cases: if sum(bloom_durations) <= C: results.append(\\"CAN FIT\\") else: results.append(\\"CANNOT FIT\\") return results def parse_input(input_string): Parse the input string into test cases. Args: input_string (str): Input string containing all test cases. Returns: list: Parsed test cases in the form of a list of tuples. input_lines = input_string.strip().split(\\"n\\") n = int(input_lines[0]) test_cases = [] idx = 1 for _ in range(n): k = int(input_lines[idx]) bloom_durations = list(map(int, input_lines[idx + 1].split())) C = int(input_lines[idx + 2]) test_cases.append((k, bloom_durations, C)) idx += 3 return test_cases def main(input_string): Main function to process the input and provide results. Args: input_string (str): Input string containing all test cases. Returns: list: A list of strings containing results for each test case. test_cases = parse_input(input_string) return can_fit_flower_in_vase(test_cases)"},{"question":"def min_operations(A: str, B: str) -> int: Returns the minimum number of operations required to transform string A into string B. >>> min_operations(\\"sunday\\", \\"saturday\\") 3 >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"abc\\", \\"abc\\") 0 >>> min_operations(\\"\\", \\"abc\\") 3 >>> min_operations(\\"abc\\", \\"\\") 3 >>> min_operations(\\"ab\\", \\"aab\\") 1 >>> min_operations(\\"aab\\", \\"ab\\") 1 >>> min_operations(\\"abc\\", \\"adc\\") 1","solution":"def min_operations(A, B): Returns the minimum number of operations required to transform string A into string B. m = len(A) n = len(B) # Create a 2D array to store the minimum operations dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the base cases for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Fill the dp array for i in range(1, m + 1): for j in range(1, n + 1): if A[i - 1] == B[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Remove dp[i][j - 1], # Insert dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"def can_split_into_equal_sum_subarrays(test_cases): Determine if the array can be split into two non-empty subarrays such that the sum of elements in both subarrays are equal. >>> can_split_into_equal_sum_subarrays([(4, 1, 2, 3, 4), (5, 1, 2, 3, 4, 10), (3, 5, 5, 5)]) ['NO', 'YES', 'NO'] >>> can_split_into_equal_sum_subarrays([(2, 1, 1), (6, 1, 2, 3, 4, 5, 6), (6, 1, 1, 1, 1, 1, 1)]) ['YES', 'NO', 'YES'] >>> can_split_into_equal_sum_subarrays([(4, -1, -2, -3, -4), (5, -1, -2, -3, -4, 10), (4, 1, 2, 3, -6)]) ['NO', 'YES', 'YES']","solution":"def can_split_into_equal_sum_subarrays(test_cases): results = [] for case in test_cases: n = case[0] array = case[1:] total_sum = sum(array) if total_sum % 2 != 0: results.append(\\"NO\\") continue target_sum = total_sum // 2 current_sum = 0 for num in array: current_sum += num if current_sum == target_sum: results.append(\\"YES\\") break else: results.append(\\"NO\\") return results"},{"question":"def find_winners(n: int, q: int, popularity_scores: List[int], contests: List[Tuple[int, int]]) -> List[int]: Find the winners for each contest based on the provided ranges. Parameters: n (int): number of candidates q (int): number of contests popularity_scores (list): a list of integers representing the popularity scores contests (list): a list of tuples representing the ranges for each contest Returns: list: a list of integers representing the index of the winning candidate for each contest from solution import find_winners def test_example_1(): n = 5 q = 3 popularity_scores = [4, 3, 5, 2, 1] contests = [(1, 3), (2, 4), (1, 5)] expected_output = [3, 3, 3] assert find_winners(n, q, popularity_scores, contests) == expected_output def test_example_2(): n = 4 q = 2 popularity_scores = [1, 2, 2, 1] contests = [(1, 2), (3, 4)] expected_output = [2, 3] assert find_winners(n, q, popularity_scores, contests) == expected_output def test_single_candidate(): n = 1 q = 1 popularity_scores = [5] contests = [(1, 1)] expected_output = [1] assert find_winners(n, q, popularity_scores, contests) == expected_output def test_all_same_scores(): n = 4 q = 2 popularity_scores = [3, 3, 3, 3] contests = [(1, 3), (2, 4)] expected_output = [1, 2] assert find_winners(n, q, popularity_scores, contests) == expected_output def test_large_range(): n = 5 q = 1 popularity_scores = [1, 3, 5, 2, 4] contests = [(1, 5)] expected_output = [3] assert find_winners(n, q, popularity_scores, contests) == expected_output def test_last_element_winner(): n = 5 q = 1 popularity_scores = [2, 2, 2, 2, 3] contests = [(1, 5)] expected_output = [5] assert find_winners(n, q, popularity_scores, contests) == expected_output","solution":"def find_winners(n, q, popularity_scores, contests): Find the winners for each contest based on the provided ranges. Parameters: n (int): number of candidates q (int): number of contests popularity_scores (list): a list of integers representing the popularity scores contests (list): a list of tuples representing the ranges for each contest Returns: list: a list of integers representing the index of the winning candidate for each contest winners = [] for a, b in contests: # Convert to 0-based index selected_candidates = popularity_scores[a-1:b] max_score = max(selected_candidates) # Find the index of the first occurrence of the max score within the selected range winner_index = a - 1 + selected_candidates.index(max_score) winners.append(winner_index + 1) # Convert back to 1-based index return winners"},{"question":"def min_cost(n: int, m: int, l: int, s: str, node_labels: List[str], edges: List[Tuple[int, int, int]]) -> int: Determines the minimum cost required to form the string s starting from any node in the graph. Args: n (int): Number of nodes. m (int): Number of edges. l (int): Length of the string s. s (str): The string to form. node_labels (List[str]): Labels of the nodes. edges (List[Tuple[int, int, int]]): List of edges represented as tuples (u, v, w), where u is the starting node, v is the ending node, and w is the edge weight. Returns: int: The minimum cost to form the string, or -1 if it is not possible. Example: >>> min_cost(3, 3, 3, \\"abc\\", ['a', 'b', 'c'], [(1, 2, 3), (2, 3, 2), (1, 3, 4)]) 5 >>> min_cost(4, 4, 5, \\"ababa\\", ['a', 'b', 'a', 'b'], [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 1, 1)]) 4 >>> min_cost(3, 3, 3, \\"abc\\", ['a', 'd', 'e'], [(1, 2, 1), (2, 3, 1), (3, 1, 1)]) -1 >>> min_cost(2, 1, 1, \\"a\\", ['a', 'b'], [(1, 2, 1)]) 0 >>> min_cost(3, 2, 3, \\"abc\\", ['a', 'b', 'c'], [(1, 2, 3), (3, 2, 2)]) -1","solution":"from heapq import heappop, heappush import sys def min_cost(n, m, l, s, node_labels, edges): label_to_nodes = {} for i, label in enumerate(node_labels): if label not in label_to_nodes: label_to_nodes[label] = [] label_to_nodes[label].append(i + 1) graph = [[] for _ in range(n + 1)] for u, v, w in edges: graph[u].append((v, w)) dp = {i: 0 for i in label_to_nodes.get(s[0], [])} for k in range(1, l): next_dp = {} for u, cost in dp.items(): if s[k] in label_to_nodes: for v in label_to_nodes[s[k]]: for nei, w in graph[u]: if nei == v: if v not in next_dp or next_dp[v] > cost + w: next_dp[v] = cost + w dp = next_dp if dp: return min(dp.values()) return -1"},{"question":"from typing import List def is_prime(num: int) -> bool: Determines if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False def sum_of_primes_up_to_n(n: int) -> int: Evaluates the sum of prime numbers up to integer n. >>> sum_of_primes_up_to_n(10) 17 >>> sum_of_primes_up_to_n(5) 10 def process_input(t: int, test_cases: List[int]) -> List[int]: Processes the number of test cases and returns a list of results for each test case. >>> process_input(3, [10, 5, 20]) [17, 10, 77] >>> process_input(1, [1]) [0]","solution":"def is_prime(num): if num <= 1: return False if num == 2: return True if num % 2 == 0: return False max_divisor = int(num ** 0.5) + 1 for divisor in range(3, max_divisor, 2): if num % divisor == 0: return False return True def sum_of_primes_up_to_n(n): return sum(num for num in range(2, n + 1) if is_prime(num)) def process_input(t, test_cases): result = [] for n in test_cases: result.append(sum_of_primes_up_to_n(n)) return result"},{"question":"def max_subarray_sum(arr): Returns the maximum sum of all possible contiguous subarrays of the given array. Implements Kadane's algorithm. >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([-5]) -5 >>> max_subarray_sum([10]) 10 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([1000] * 100000) 100000000 >>> max_subarray_sum([-1000, 3, 5, -7, 2, 8, -1000, 10, 20]) 30","solution":"def max_subarray_sum(arr): Returns the maximum sum of all possible contiguous subarrays of the given array. Implements Kadane's algorithm. max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def count_non_overlapping_occurrences(S: str, T: str) -> int: Determine how many times the string T exists in the string S as a non-overlapping substring. Args: S (str): The main string in which to search. T (str): The substring to search for. Returns: int: The number of non-overlapping occurrences of T in S. Examples: >>> count_non_overlapping_occurrences(\\"abcabcab\\", \\"abc\\") 2 >>> count_non_overlapping_occurrences(\\"aaaa\\", \\"aaa\\") 1 >>> count_non_overlapping_occurrences(\\"mississippi\\", \\"iss\\") 2 >>> count_non_overlapping_occurrences(\\"abcdef\\", \\"gh\\") 0 >>> count_non_overlapping_occurrences(\\"aaaaa\\", \\"aaaaa\\") 1 >>> count_non_overlapping_occurrences(\\"abc\\", \\"abcd\\") 0 >>> count_non_overlapping_occurrences(\\"ababab\\", \\"a\\") 3 >>> count_non_overlapping_occurrences(\\"abababa\\", \\"aba\\") 2 from solution import count_non_overlapping_occurrences def test_example_1(): assert count_non_overlapping_occurrences(\\"abcabcab\\", \\"abc\\") == 2 def test_example_2(): assert count_non_overlapping_occurrences(\\"aaaa\\", \\"aaa\\") == 1 def test_example_3(): assert count_non_overlapping_occurrences(\\"mississippi\\", \\"iss\\") == 2 def test_no_occurrence(): assert count_non_overlapping_occurrences(\\"abcdef\\", \\"gh\\") == 0 def test_full_match(): assert count_non_overlapping_occurrences(\\"aaaaa\\", \\"aaaaa\\") == 1 def test_substring_longer_than_string(): assert count_non_overlapping_occurrences(\\"abc\\", \\"abcd\\") == 0 def test_single_character_match(): assert count_non_overlapping_occurrences(\\"ababab\\", \\"a\\") == 3 def test_overlapping_occurrences(): assert count_non_overlapping_occurrences(\\"abababa\\", \\"aba\\") == 2","solution":"def count_non_overlapping_occurrences(S, T): Returns the number of non-overlapping occurrences of substring T in string S. count = 0 i = 0 while i <= len(S) - len(T): if S[i:i+len(T)] == T: count += 1 i += len(T) else: i += 1 return count"},{"question":"from typing import List, Tuple def addition_modulo(t: int, test_cases: List[Tuple[int, List[int], List[int], int]]) -> List[List[int]]: Perform addition modulo m on two arrays A and B for multiple test cases. Each test case contains: n (length of arrays A and B), A (array of non-negative integers), B (array of non-negative integers), m (modulus value). Returns a list of results, where each result is a list of integers representing the result of (A[i] + B[i]) % m for each index i. Example: >>> addition_modulo(2, [(3, [1, 2, 3], [4, 5, 6], 5), (4, [10, 20, 30, 40], [40, 30, 20, 10], 100)]) [[0, 2, 4], [50, 50, 50, 50]] >>> addition_modulo(1, [(3, [0, 0, 0], [0, 0, 0], 10)]) [[0, 0, 0]] from solution import addition_modulo def test_addition_modulo_single_case(): t = 1 test_cases = [(3, [1, 2, 3], [4, 5, 6], 5)] expected = [[0, 2, 4]] assert addition_modulo(t, test_cases) == expected def test_addition_modulo_multiple_cases(): t = 2 test_cases = [ (3, [1, 2, 3], [4, 5, 6], 5), (4, [10, 20, 30, 40], [40, 30, 20, 10], 100) ] expected = [ [0, 2, 4], [50, 50, 50, 50] ] assert addition_modulo(t, test_cases) == expected def test_addition_modulo_with_large_modulo(): t = 1 test_cases = [(3, [1, 2, 3], [4, 5, 6], 1000000000)] expected = [[5, 7, 9]] assert addition_modulo(t, test_cases) == expected def test_addition_modulo_with_zero_values(): t = 1 test_cases = [(3, [0, 0, 0], [0, 0, 0], 10)] expected = [[0, 0, 0]] assert addition_modulo(t, test_cases) == expected def test_addition_modulo_with_mixed_values(): t = 1 test_cases = [(4, [1, 3, 5, 7], [8, 6, 4, 2], 10)] expected = [[9, 9, 9, 9]] assert addition_modulo(t, test_cases) == expected","solution":"def addition_modulo(t, test_cases): results = [] for i in range(t): n, A, B, m = test_cases[i] result = [(A[j] + B[j]) % m for j in range(n)] results.append(result) return results"},{"question":"class Library: def __init__(self): self.inventory = {} self.borrowed = {} self.history = [] def add_book(self, book_id: int, title: str): Adds a new book with the specified ID and title to the inventory. Args: book_id (int): The unique ID of the book. title (str): The title of the book. If a book with the same ID already exists, update the title. def borrow_book(self, book_id: int, user_id: int): A user borrows a book from the library. Args: book_id (int): The unique ID of the book. user_id (int): The unique ID of the user borrowing the book. If the book is not available (either not in the inventory or already borrowed), ignore the command. def return_book(self, book_id: int): The book is returned to the library. Args: book_id (int): The unique ID of the book being returned. If the book is not borrowed, ignore the command. def status(self) -> str: Prints the status of the current library books. Returns: str: The status report in the following format - Inventory list: All books currently available in the library, sorted by book_id. Borrowed list: All books currently borrowed along with the user_id, sorted by book_id. Borrowing history: List of all transactions sorted by the time of transaction. def process_commands(self, commands: List[str]): Processes a list of commands to manage the library system. Args: commands (List[str]): List of commands to be processed. # Example unit tests from solution import Library def test_library_add_and_status(): lib = Library() lib.process_commands([\\"ADD 101 TheGreatGatsby\\", \\"STATUS\\"]) assert lib.status() == \\"Inventory:n101 TheGreatGatsbynBorrowed:nnHistory:n\\" def test_library_borrow_and_status(): lib = Library() lib.process_commands([\\"ADD 101 TheGreatGatsby\\", \\"BORROW 101 501\\", \\"STATUS\\"]) assert lib.status() == \\"Inventory:nnBorrowed:n101 501 TheGreatGatsbynHistory:n501 borrowed 101 - TheGreatGatsby\\" def test_library_return_and_status(): lib = Library() lib.process_commands([\\"ADD 101 TheGreatGatsby\\", \\"BORROW 101 501\\", \\"RETURN 101\\", \\"STATUS\\"]) assert lib.status() == \\"Inventory:n101 TheGreatGatsbynBorrowed:nnHistory:n501 borrowed 101 - TheGreatGatsbyn501 returned 101 - TheGreatGatsby\\" def test_library_multiple_operations(): commands = [ \\"ADD 101 TheGreatGatsby\\", \\"ADD 102 ToKillAMockingbird\\", \\"BORROW 101 501\\", \\"BORROW 102 502\\", \\"RETURN 101\\", \\"STATUS\\" ] expected_status = \\"Inventory:n101 TheGreatGatsbynBorrowed:n102 502 ToKillAMockingbirdnHistory:n501 borrowed 101 - TheGreatGatsbyn502 borrowed 102 - ToKillAMockingbirdn501 returned 101 - TheGreatGatsby\\" lib = Library() lib.process_commands(commands) assert lib.status() == expected_status def test_library_with_padded_commands(): commands = [ \\" ADD 101 TheGreatGatsby \\", \\" ADD 102 ToKillAMockingbird \\", \\" BORROW 101 501\\", \\"BORROW 102 502 \\", \\" RETURN 101 \\", \\" STATUS \\" ] expected_status = \\"Inventory:n101 TheGreatGatsbynBorrowed:n102 502 ToKillAMockingbirdnHistory:n501 borrowed 101 - TheGreatGatsbyn502 borrowed 102 - ToKillAMockingbirdn501 returned 101 - TheGreatGatsby\\" lib = Library() lib.process_commands(commands) assert lib.status() == expected_status","solution":"class Library: def __init__(self): self.inventory = {} self.borrowed = {} self.history = [] def add_book(self, book_id, title): self.inventory[book_id] = title def borrow_book(self, book_id, user_id): if book_id in self.inventory and book_id not in self.borrowed: self.borrowed[book_id] = user_id self.history.append(f\\"{user_id} borrowed {book_id} - {self.inventory[book_id]}\\") def return_book(self, book_id): if book_id in self.borrowed: user_id = self.borrowed.pop(book_id) self.history.append(f\\"{user_id} returned {book_id} - {self.inventory[book_id]}\\") def status(self): inventory_status = \\"n\\".join(f\\"{book_id} {title}\\" for book_id, title in sorted(self.inventory.items()) if book_id not in self.borrowed) borrowed_status = \\"n\\".join(f\\"{book_id} {user_id} {self.inventory[book_id]}\\" for book_id, user_id in sorted(self.borrowed.items())) history_status = \\"n\\".join(self.history) return f\\"Inventory:n{inventory_status}nBorrowed:n{borrowed_status}nHistory:n{history_status}\\" def process_commands(self, commands): for command in commands: parts = command.strip().split() action = parts[0] if action == \\"ADD\\": book_id = int(parts[1]) title = parts[2] self.add_book(book_id, title) elif action == \\"BORROW\\": book_id = int(parts[1]) user_id = int(parts[2]) self.borrow_book(book_id, user_id) elif action == \\"RETURN\\": book_id = int(parts[1]) self.return_book(book_id) elif action == \\"STATUS\\": print(self.status())"},{"question":"from typing import List import math def can_be_expressed_as_sum_of_two_squares(n: int) -> str: Determines if n can be expressed as a sum of two non-negative perfect squares. >>> can_be_expressed_as_sum_of_two_squares(5) == \\"Yes\\" >>> can_be_expressed_as_sum_of_two_squares(3) == \\"No\\" >>> can_be_expressed_as_sum_of_two_squares(1000000) == \\"Yes\\" >>> can_be_expressed_as_sum_of_two_squares(1000003) == \\"No\\" >>> can_be_expressed_as_sum_of_two_squares(1) == \\"Yes\\" >>> can_be_expressed_as_sum_of_two_squares(2) == \\"Yes\\" >>> can_be_expressed_as_sum_of_two_squares(0) == \\"Yes\\" >>> can_be_expressed_as_sum_of_two_squares(123456789) == \\"No\\"","solution":"import math def can_be_expressed_as_sum_of_two_squares(n): Determines if n can be expressed as a sum of two non-negative perfect squares. :param n: integer, the number to check :return: \\"Yes\\" if it can be expressed as described, otherwise \\"No\\" for i in range(int(math.sqrt(n)) + 1): remaining = n - i * i if remaining >= 0 and int(math.sqrt(remaining)) ** 2 == remaining: return \\"Yes\\" return \\"No\\""},{"question":"from typing import List, Tuple def subtree_sums(n: int, edges: List[Tuple[int, int]]) -> List[int]: Calculate the sum of subtrees for each node in a binary tree. >>> subtree_sums(5, [(1, 2), (1, 3), (2, 4), (2, 5)]) [15, 11, 3, 4, 5] >>> subtree_sums(3, [(1, 2), (1, 3)]) [6, 2, 3] Unit Test: def test_case_1(): assert process_input_and_solve(5, [(1, 2), (1, 3), (2, 4), (2, 5)]) == [15, 11, 3, 4, 5] def test_case_2(): assert process_input_and_solve(3, [(1, 2), (1, 3)]) == [6, 2, 3] def test_case_3(): assert process_input_and_solve(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) == [28, 11, 16, 4, 5, 6, 7] def test_case_4(): assert process_input_and_solve(1, []) == [1] def test_case_5(): assert process_input_and_solve(4, [(1, 2), (2, 3), (3, 4)]) == [10, 9, 7, 4]","solution":"def subtree_sums(n, edges): from collections import defaultdict tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) subtree_sum = [0] * (n + 1) visited = [False] * (n + 1) def dfs(node): visited[node] = True total_sum = node for neighbor in tree[node]: if not visited[neighbor]: total_sum += dfs(neighbor) subtree_sum[node] = total_sum return total_sum dfs(1) return subtree_sum[1:] # Simple wrapper to parse the input in the required format def process_input_and_solve(n, edges): return subtree_sums(n, edges)"},{"question":"class ParkingLot: Manages a parking lot with 100 spots where vehicles enter and exit based on their license plate. >>> lot = ParkingLot() >>> lot.park(\\"ABC123\\") 1 >>> lot.park(\\"DEF456\\") 2 >>> lot.find(\\"ABC123\\") 1 >>> lot.park(\\"GHI789\\") 3 >>> print(lot.status()) Spot1: ABC123 Spot2: DEF456 Spot3: GHI789 ... Spot100: Available >>> lot.leave(\\"DEF456\\") >>> lot.count() 99 >>> lot.leave(\\"ABC123\\") >>> print(lot.status()) Spot1: Available Spot2: Available Spot3: GHI789 ... Spot100: Available >>> lot.count() 100 def __init__(self, capacity=100): pass def park(self, license_plate): pass def leave(self, license_plate): pass def status(self): pass def find(self, license_plate): pass def count(self): pass","solution":"class ParkingLot: def __init__(self, capacity=100): self.capacity = capacity self.parking_lot = {i: None for i in range(1, capacity + 1)} self.vehicle_spots = {} def park(self, license_plate): if license_plate in self.vehicle_spots: return \\"Error\\" for spot, vehicle in self.parking_lot.items(): if vehicle is None: self.parking_lot[spot] = license_plate self.vehicle_spots[license_plate] = spot return spot return \\"Parking lot full\\" def leave(self, license_plate): if license_plate not in self.vehicle_spots: return \\"Error\\" spot = self.vehicle_spots.pop(license_plate) self.parking_lot[spot] = None return def status(self): lines = [] for spot, vehicle in self.parking_lot.items(): if vehicle is None: lines.append(f\\"Spot{spot}: Available\\") else: lines.append(f\\"Spot{spot}: {vehicle}\\") return \\"n\\".join(lines) def find(self, license_plate): if license_plate in self.vehicle_spots: return self.vehicle_spots[license_plate] return \\"Not found\\" def count(self): return sum(1 for vehicle in self.parking_lot.values() if vehicle is None)"},{"question":"def count_lexicographical_pairs(s: str) -> int: Counts the number of lexicographical pairs (i, j) in a string where S[i] < S[j] and i < j. >>> count_lexicographical_pairs(\\"abc\\") == 3 >>> count_lexicographical_pairs(\\"cba\\") == 0 def process_test_cases(test_cases: List[str]) -> List[int]: Processes multiple test cases for the count_lexicographical_pairs function. Args: test_cases (list): List of strings representing each test case. Returns: list: List of results for each test case. >>> process_test_cases([\\"abc\\", \\"cba\\", \\"abac\\", \\"zzzz\\", \\"a\\"]) == [3, 0, 4, 0, 0] def test_count_lexicographical_pairs(): assert count_lexicographical_pairs(\\"abc\\") == 3 assert count_lexicographical_pairs(\\"cba\\") == 0 assert count_lexicographical_pairs(\\"abac\\") == 4 assert count_lexicographical_pairs(\\"zzzz\\") == 0 assert count_lexicographical_pairs(\\"a\\") == 0 def test_process_test_cases(): test_cases = [\\"abc\\", \\"cba\\", \\"abac\\", \\"zzzz\\", \\"a\\"] expected_output = [3, 0, 4, 0, 0] assert process_test_cases(test_cases) == expected_output","solution":"def count_lexicographical_pairs(s): Counts the number of lexicographical pairs (i, j) in a string where S[i] < S[j] and i < j. count = 0 n = len(s) for i in range(n): for j in range(i + 1, n): if s[i] < s[j]: count += 1 return count def process_test_cases(test_cases): Processes multiple test cases for the count_lexicographical_pairs function. Args: test_cases (list): List of strings representing each test case. Returns: list: List of results for each test case. results = [] for s in test_cases: results.append(count_lexicographical_pairs(s)) return results"},{"question":"def can_attend_all_sessions(n: int, sessions: List[Tuple[int, int]]) -> str: Determines if it is possible to attend all sessions without overlap. :param n: Number of sessions :param sessions: List of tuples containing start and end times of each session :return: \\"YES\\" if it is possible to attend all sessions without overlap, otherwise \\"NO\\" from typing import List, Tuple def test_no_overlap(): sessions = [(1, 4), (5, 8), (9, 11)] assert can_attend_all_sessions(3, sessions) == \\"YES\\" def test_overlap(): sessions = [(1, 4), (3, 5), (5, 7)] assert can_attend_all_sessions(3, sessions) == \\"NO\\" def test_sequential_sessions(): sessions = [(2, 4), (4, 6), (6, 8), (8, 10)] assert can_attend_all_sessions(4, sessions) == \\"YES\\" def test_single_session(): sessions = [(0, 23)] assert can_attend_all_sessions(1, sessions) == \\"YES\\" def test_multiple_overlaps(): sessions = [(0, 2), (1, 3), (2, 4), (3, 5)] assert can_attend_all_sessions(4, sessions) == \\"NO\\" def test_sessions_starting_and_ending_at_boundary(): sessions = [(0, 10), (10, 20), (20, 23)] assert can_attend_all_sessions(3, sessions) == \\"YES\\"","solution":"def can_attend_all_sessions(n, sessions): Determines if it is possible to attend all sessions without overlap. :param n: Number of sessions :param sessions: List of tuples containing start and end times of each session :return: \\"YES\\" if it is possible to attend all sessions without overlap, otherwise \\"NO\\" # Sort the sessions by start time sessions.sort(key=lambda session: session[0]) # Check for overlaps for i in range(1, n): if sessions[i][0] < sessions[i - 1][1]: return \\"NO\\" return \\"YES\\""},{"question":"def max_visible_gold_coins(n: int, stacks: List[Tuple[int, int]]) -> int: Determine the maximum number of visible gold coins that can be obtained after performing any number of swaps. >>> max_visible_gold_coins(3, [(2, 1), (1, 2), (3, 0)]) == 3 >>> max_visible_gold_coins(4, [(1, 1), (2, 2), (0, 3), (3, 3)]) == 3 >>> max_visible_gold_coins(3, [(0, 3), (0, 2), (0, 1)]) == 0 >>> max_visible_gold_coins(3, [(3, 0), (2, 0), (1, 0)]) == 3 >>> max_visible_gold_coins(5, [(2, 0), (0, 1), (1, 1), (0, 2), (2, 3)]) == 3","solution":"def max_visible_gold_coins(n, stacks): visible_gold = 0 for g, s in stacks: if g > 0: visible_gold += 1 return visible_gold"},{"question":"def max_groups_of_same_height(N: int, heights: List[int]) -> int: Returns the maximum number of groups of books with the same height. Parameters: N (int): number of books on the shelf. heights (list of int): heights of the books on the shelf. Returns: int: maximum number of groups of books with the same height. pass # Unit tests def test_example_case(): assert max_groups_of_same_height(8, [1, 2, 2, 3, 3, 3, 4, 4]) == 4 def test_single_book(): assert max_groups_of_same_height(1, [1]) == 1 def test_all_books_different_heights(): assert max_groups_of_same_height(5, [1, 2, 3, 4, 5]) == 5 def test_all_books_same_height(): assert max_groups_of_same_height(4, [2, 2, 2, 2]) == 1 def test_some_repeated_heights(): assert max_groups_of_same_height(6, [5, 5, 6, 6, 7, 7]) == 3 def test_large_dataset(): heights = [1000] * 50000 + [2000] * 50000 assert max_groups_of_same_height(100000, heights) == 2","solution":"def max_groups_of_same_height(N, heights): Returns the maximum number of groups of books with the same height. Parameters: N (int): number of books on the shelf. heights (list of int): heights of the books on the shelf. Returns: int: maximum number of groups of books with the same height. # Using a set to find the unique heights of the books unique_heights = set(heights) # The number of unique heights is the maximum number of groups return len(unique_heights)"},{"question":"from typing import List def min_cost_path(cost: List[List[int]]) -> int: Calculate the minimum cost to reach the bottom-right room from the top-left room in a 2D grid. You can move up, down, left, or right. >>> cost = [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ] >>> min_cost_path(cost) 7 >>> cost = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> min_cost_path(cost) 21 pass def test_example_1(): cost = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert min_cost_path(cost) == 7 def test_example_2(): cost = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert min_cost_path(cost) == 21 def test_single_cell(): cost = [ [5] ] assert min_cost_path(cost) == 5 def test_two_by_two(): cost = [ [1, 2], [3, 4] ] assert min_cost_path(cost) == 7 def test_larger_grid(): cost = [ [1, 3, 1, 2, 9], [7, 3, 4, 5, 1], [2, 1, 6, 7, 3], [5, 4, 2, 2, 1] ] assert min_cost_path(cost) == 17 def test_with_higher_numbers(): cost = [ [10, 20, 30], [40, 50, 60], [70, 80, 90] ] assert min_cost_path(cost) == 210 if __name__ == \\"__main__\\": test_example_1() test_example_2() test_single_cell() test_two_by_two() test_larger_grid() test_with_higher_numbers() print(\\"All tests passed.\\")","solution":"from typing import List import heapq def min_cost_path(cost: List[List[int]]) -> int: n = len(cost) m = len(cost[0]) # Dijkstra's algorithm using priority queue queue = [(cost[0][0], 0, 0)] # (cost, x, y) min_cost = [[float('inf')] * m for _ in range(n)] min_cost[0][0] = cost[0][0] while queue: current_cost, x, y = heapq.heappop(queue) if x == n-1 and y == m-1: return current_cost for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m: new_cost = current_cost + cost[nx][ny] if new_cost < min_cost[nx][ny]: min_cost[nx][ny] = new_cost heapq.heappush(queue, (new_cost, nx, ny)) return min_cost[n-1][m-1]"},{"question":"from typing import List def maximize_consecutive_diff(n: int, arr: List[int]) -> List[int]: Given a list of integers, reorder them so that the difference between consecutive elements is maximized. >>> maximize_consecutive_diff(4, [1, 3, 7, 5]) [1, 7, 3, 5] >>> maximize_consecutive_diff(3, [2, 4, 6]) [2, 6, 4] >>> maximize_consecutive_diff(1, [1]) [1] >>> maximize_consecutive_diff(5, [5, 5, 5, 5, 5]) [5, 5, 5, 5, 5] >>> maximize_consecutive_diff(2, [5, 1]) [5, 1] >>> maximize_consecutive_diff(4, [1000000000, 999999999, 500000000, 1]) [1000000000, 1, 999999999, 500000000] >>> maximize_consecutive_diff(5, [5, 5, 5, 3, 3]) [5, 3, 5, 3, 5]","solution":"def maximize_consecutive_diff(n, arr): Reorders the array such that the difference between consecutive elements is maximized. arr.sort() result = [] # To store the reordered array. i, j = 0, n - 1 while i <= j: if j >= i: result.append(arr[j]) j -= 1 if i <= j: result.append(arr[i]) i += 1 return result"},{"question":"from typing import List def min_effort_path(matrix: List[List[int]]) -> int: Find the minimum effort required to traverse from the top-left corner (0,0) to the bottom-right corner (n-1,m-1) of the matrix. The effort of a particular path is defined as the maximum absolute difference in elevations between adjacent cells along that path. >>> min_effort_path([ ... [1, 2, 2], ... [3, 8, 2], ... [5, 3, 5] ... ]) == 2 >>> min_effort_path([[1, 1000000], [1000000, 1]]) == 999999 pass # Test Cases def test_example_case(): matrix = [ [1, 2, 2], [3, 8, 2], [5, 3, 5] ] assert min_effort_path(matrix) == 2 def test_single_row(): matrix = [ [1, 2, 3, 4, 5] ] assert min_effort_path(matrix) == 1 def test_single_column(): matrix = [ [1], [2], [3], [4], [5] ] assert min_effort_path(matrix) == 1 def test_large_differences(): matrix = [ [1, 1000000], [1000000, 1] ] assert min_effort_path(matrix) == 999999 def test_same_elevation(): matrix = [ [5, 5, 5], [5, 5, 5], [5, 5, 5] ] assert min_effort_path(matrix) == 0 def test_large_matrix(): matrix = [[i + j for j in range(100)] for i in range(100)] assert min_effort_path(matrix) == 1","solution":"from heapq import heappop, heappush from typing import List def min_effort_path(matrix: List[List[int]]) -> int: n, m = len(matrix), len(matrix[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] effort = [[float('inf')] * m for _ in range(n)] effort[0][0] = 0 heap = [(0, 0, 0)] # (effort, x, y) while heap: current_effort, x, y = heappop(heap) if x == n-1 and y == m-1: return current_effort for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m: next_effort = max(current_effort, abs(matrix[nx][ny] - matrix[x][y])) if next_effort < effort[nx][ny]: effort[nx][ny] = next_effort heappush(heap, (next_effort, nx, ny)) return -1"},{"question":"def sort_recipes_by_priority(n: int, recipes: List[Tuple[str, int]]) -> List[str]: Sort recipes by their highest priority in descending order. Recipes with the same highest priority maintain their input order. :param n: Number of recipes :param recipes: List of tuples (recipe name, priority) :return: List of recipes sorted by their highest priority >>> sort_recipes_by_priority(5, [(\\"Pasta\\", 3), (\\"Soup\\", 5), (\\"Pasta\\", 8), (\\"Salad\\", 2), (\\"Soup\\", 4)]) [\\"Pasta\\", \\"Soup\\", \\"Salad\\"] >>> sort_recipes_by_priority(3, [(\\"Pasta\\", 5), (\\"Soup\\", 5), (\\"Salad\\", 5)]) [\\"Pasta\\", \\"Soup\\", \\"Salad\\"] >>> sort_recipes_by_priority(1, [(\\"Pasta\\", 5)]) [\\"Pasta\\"] # Your code here import pytest def test_sort_recipes_by_priority(): recipes = [(\\"Pasta\\", 3), (\\"Soup\\", 5), (\\"Pasta\\", 8), (\\"Salad\\", 2), (\\"Soup\\", 4)] assert sort_recipes_by_priority(5, recipes) == [\\"Pasta\\", \\"Soup\\", \\"Salad\\"] recipes = [(\\"Pasta\\", 5), (\\"Soup\\", 5), (\\"Salad\\", 5)] assert sort_recipes_by_priority(3, recipes) == [\\"Pasta\\", \\"Soup\\", \\"Salad\\"] recipes = [(\\"Pasta\\", 5)] assert sort_recipes_by_priority(1, recipes) == [\\"Pasta\\"] recipes = [(\\"Pasta\\", 3), (\\"Soup\\", 5), (\\"Salad\\", 2)] assert sort_recipes_by_priority(3, recipes) == [\\"Soup\\", \\"Pasta\\", \\"Salad\\"] recipes = [(\\"Pasta\\", 5), (\\"Soup\\", 5), (\\"Pasta\\", 5), (\\"Salad\\", 5), (\\"Soup\\", 5)] assert sort_recipes_by_priority(5, recipes) == [\\"Pasta\\", \\"Soup\\", \\"Salad\\"]","solution":"def sort_recipes_by_priority(n, recipes): Sort recipes by their highest priority in descending order. Recipes with same highest priority maintain their input order. :param n: Number of recipes :param recipes: List of tuples (recipe name, priority) :return: List of recipes sorted by their highest priority # Dictionary to store the highest priority of each recipe recipe_priority = {} for name, priority in recipes: if name not in recipe_priority or recipe_priority[name] < priority: recipe_priority[name] = priority # Convert the dictionary to a list of tuples and sort by priority sorted_recipes = sorted(recipe_priority.items(), key=lambda x: (-x[1], recipes.index((x[0], x[1])))) # Extract the recipe names in sorted order sorted_recipe_names = [name for name, _ in sorted_recipes] return sorted_recipe_names"},{"question":"def rob(houses): Returns the maximum amount of money you can rob without alerting the police. >>> rob([1, 2, 3, 1]) 4 >>> rob([2, 7, 9, 3, 1]) 12 >>> rob([0]) 0 >>> rob([1,2]) 2 >>> rob([5,5,10,100,10,5]) 110 pass def max_robbery(test_cases): Returns the results for all test cases. >>> max_robbery([(4, [1, 2, 3, 1]), (5, [2, 7, 9, 3, 1])]) [4, 12] pass def parse_input(input_data): Parses input data and returns test cases. >>> parse_input(\\"2n4n1 2 3 1n5n2 7 9 3 1\\") [(4, [1, 2, 3, 1]), (5, [2, 7, 9, 3, 1])] pass def solve(input_data): Parses input data and prints the results for all test cases. >>> solve(\\"2n4n1 2 3 1n5n2 7 9 3 1\\") 4 12 pass","solution":"def rob(houses): Returns the maximum amount of money you can rob without alerting the police. prev1 = prev2 = 0 for money in houses: temp = prev1 prev1 = max(prev2 + money, prev1) prev2 = temp return prev1 def max_robbery(test_cases): results = [] for case in test_cases: n, houses = case results.append(rob(houses)) return results # Parsing the input def parse_input(input_data): lines = input_data.split() t = int(lines[0]) index = 1 test_cases = [] for _ in range(t): n = int(lines[index]) houses = list(map(int, lines[index + 1:index + 1 + n])) test_cases.append((n, houses)) index += (n + 1) return test_cases # Function to parse the input and get the results in the required format def solve(input_data): test_cases = parse_input(input_data) results = max_robbery(test_cases) for result in results: print(result)"},{"question":"def closest_power_of_two(n: int) -> int: Returns the closest power of two to the given number n. If there are two numbers equally close, returns the smaller one. >>> closest_power_of_two(1) 1 >>> closest_power_of_two(2) 2 >>> closest_power_of_two(3) 2 >>> closest_power_of_two(5) 4 >>> closest_power_of_two(20) 16 >>> closest_power_of_two(31) 32 >>> closest_power_of_two(32) 32 >>> closest_power_of_two(33) 32 >>> closest_power_of_two(50) 64 >>> closest_power_of_two(64) 64 >>> closest_power_of_two(1000000000000000000) 1152921504606846976 def find_closest_powers_of_two(numbers: List[int]) -> List[int]: For each number in numbers, finds the closest power of two. pass def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) numbers = list(map(int, data[1:T + 1])) results = find_closest_powers_of_two(numbers) for result in results: print(result)","solution":"def closest_power_of_two(n): Returns the closest power of two to the given number n. If there are two numbers equally close, returns the smaller one. if n <= 1: return 1 lower = 1 while lower * 2 <= n: lower *= 2 upper = lower * 2 if n - lower <= upper - n: return lower else: return upper def find_closest_powers_of_two(numbers): For each number in numbers, finds the closest power of two. return [closest_power_of_two(n) for n in numbers] # Entry point for the solution def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) numbers = list(map(int, data[1:T + 1])) results = find_closest_powers_of_two(numbers) for result in results: print(result)"},{"question":"def process_operations(t: int, test_cases: List[Dict[str, Any]]) -> List[str]: Processes a series of queries and updates on a given string and returns the results of the queries. Args: t (int): The number of test cases. test_cases (List[Dict[str, Any]]): A list of dictionaries, where each dictionary contains: - 's': The initial string - 'q': The number of operations - 'operations': A list of operations, each operation is a tuple ('Q', l, r) or ('U', p, c) Returns: List[str]: The results of the query operations. Example: >>> test_cases = [ { \\"s\\": \\"abcdefgh\\", \\"q\\": 5, \\"operations\\": [ (\\"Q\\", 1, 3), (\\"U\\", 2, 'z'), (\\"Q\\", 1, 3), (\\"U\\", 5, 'a'), (\\"Q\\", 1, 8) ] } ] >>> t = 1 >>> process_operations(t, test_cases) ['a', 'a', 'a']","solution":"def process_operations(t, test_cases): results = [] for case in test_cases: s = list(case['s']) q = case['q'] operations = case['operations'] for op in operations: if op[0] == 'Q': _, l, r = op l, r = int(l) - 1, int(r) - 1 results.append(min(s[l:r+1])) elif op[0] == 'U': _, p, c = op p = int(p) - 1 s[p] = c return results # Example usage: # test_cases = [ # { # \\"s\\": \\"abcdefgh\\", # \\"q\\": 5, # \\"operations\\": [ # (\\"Q\\", 1, 3), # (\\"U\\", 2, 'z'), # (\\"Q\\", 1, 3), # (\\"U\\", 5, 'a'), # (\\"Q\\", 1, 8) # ] # } # ] # t = 1 # print(process_operations(t, test_cases)) # Output should be ['a', 'a', 'a']"},{"question":"def evaluate_postfix(expression: str) -> float: Evaluates a given postfix expression and returns the result as a float. If there is a division by zero, returns \\"Error\\". >>> evaluate_postfix(\\"2 3 +\\") == 5.0 >>> evaluate_postfix(\\"15 7 1 1 + - / 3 * 2 1 1 + + -\\") == 5.0 >>> evaluate_postfix(\\"20 5 / 3.0 *\\") == 12.0 >>> evaluate_postfix(\\"5 0 /\\") == \\"Error\\" >>> evaluate_postfix(\\"-2 -3 +\\") == -5.0","solution":"def evaluate_postfix(expression): Evaluates a given postfix expression and returns the result as a float. If there is a division by zero, returns \\"Error\\". stack = [] for token in expression.split(): if token in \\"+-*/\\": if len(stack) < 2: return \\"Error\\" b = stack.pop() a = stack.pop() if token == '+': stack.append(a + b) elif token == '-': stack.append(a - b) elif token == '*': stack.append(a * b) elif token == '/': if b == 0: return \\"Error\\" stack.append(a / b) else: stack.append(float(token)) if len(stack) != 1: return \\"Error\\" return stack[0]"},{"question":"def longest_sublist_length(n: int, k: int, a: List[int]) -> int: Determines the length of the longest contiguous sublist where the sum of the elements is less than or equal to a given integer k. >>> longest_sublist_length(7, 5, [1, 2, -1, 2, 3, 4, 1]) 4 >>> longest_sublist_length(5, 10, [-2, -3, 4, -1, -2]) 5","solution":"def longest_sublist_length(n, k, a): Determines the length of the longest contiguous sublist where the sum of the elements is less than or equal to a given integer k. left = 0 current_sum = 0 max_length = 0 for right in range(n): current_sum += a[right] while current_sum > k: current_sum -= a[left] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def longest_coverage(employees): Determines the longest continuous time range covered by at least one employee. Parameters: employees (list of tuples): A list of tuples where each tuple contains start and end times of an employee's work shift. Returns: A tuple of (start_time, end_time) representing the longest continuous time range or \\"No Coverage\\" if no employees are working. Example: >>> longest_coverage([(\\"09:00\\", \\"17:00\\"), (\\"13:00\\", \\"20:00\\"), (\\"15:00\\", \\"18:00\\")]) (\\"09:00\\", \\"20:00\\") >>> longest_coverage([(\\"08:00\\", \\"12:00\\"), (\\"14:00\\", \\"18:00\\")]) (\\"08:00\\", \\"12:00\\") >>> longest_coverage([]) \\"No Coverage\\" from solution import longest_coverage def test_longest_single_employee(): assert longest_coverage([(\\"09:00\\", \\"17:00\\")]) == (\\"09:00\\", \\"17:00\\") def test_longest_multiple_employees(): assert longest_coverage([ (\\"09:00\\", \\"17:00\\"), (\\"13:00\\", \\"20:00\\"), (\\"15:00\\", \\"18:00\\") ]) == (\\"09:00\\", \\"20:00\\") def test_no_employees(): assert longest_coverage([]) == \\"No Coverage\\" def test_disjoint_intervals(): assert longest_coverage([ (\\"08:00\\", \\"12:00\\"), (\\"14:00\\", \\"18:00\\") ]) == (\\"08:00\\", \\"12:00\\") def test_partially_overlapping_intervals(): assert longest_coverage([ (\\"08:00\\", \\"12:00\\"), (\\"11:00\\", \\"15:00\\"), (\\"14:30\\", \\"17:00\\") ]) == (\\"08:00\\", \\"17:00\\") def test_fully_covered_with_overlapping_interval(): assert longest_coverage([ (\\"08:00\\", \\"17:00\\"), (\\"09:00\\", \\"15:00\\"), (\\"11:00\\", \\"13:00\\") ]) == (\\"08:00\\", \\"17:00\\")","solution":"def longest_coverage(employees): Determines the longest continuous time range covered by at least one employee. Parameters: employees (list of tuples): A list of tuples where each tuple contains start and end times of an employee's work shift. Returns: A tuple of (start_time, end_time) representing the longest continuous time range or \\"No Coverage\\" if no employees are working. if not employees: return \\"No Coverage\\" # Sort intervals based on start times employees.sort() merged_intervals = [] current_start, current_end = employees[0] for start, end in employees[1:]: if start <= current_end: # Merge intervals current_end = max(current_end, end) else: # Add the finished interval and move to the next merged_intervals.append((current_start, current_end)) current_start, current_end = start, end # Add the last interval merged_intervals.append((current_start, current_end)) # Combine the consecutive intervals longest_intervals = merged_intervals[0] return longest_intervals[0], longest_intervals[1]"},{"question":"def count_balanced_subgrids(n, m): Count the number of balanced subgrids in an n x m grid. The pastry is a rectangular grid of size n x m consisting of vanilla and chocolate cells. A subgrid is considered balanced if it contains an equal number of vanilla and chocolate cells. Args: n (int): The number of rows in the grid. m (int): The number of columns in the grid. Returns: int: The number of balanced subgrids. Example: >>> count_balanced_subgrids(2, 2) 4 >>> count_balanced_subgrids(3, 3) 36 pass def test_count_balanced_subgrids_small(): assert count_balanced_subgrids(1, 1) == 1 assert count_balanced_subgrids(1, 2) == 3 assert count_balanced_subgrids(2, 2) == 9 def test_count_balanced_subgrids_medium(): assert count_balanced_subgrids(2, 3) == 18 assert count_balanced_subgrids(3, 3) == 36 def test_count_balanced_subgrids_large(): assert count_balanced_subgrids(5, 5) == 225 assert count_balanced_subgrids(10, 10) == 3025 def test_count_balanced_subgrids_asymmetrical(): assert count_balanced_subgrids(1, 100) == 5050 assert count_balanced_subgrids(100, 1) == 5050","solution":"def count_balanced_subgrids(n, m): Counts the number of balanced subgrids in an n x m grid. total_subgrids = 0 # Iterate over all possible subgrid sizes for i in range(1, n+1): for j in range(1, m+1): # Calculate number of subgrids of size i x j num_subgrids = (n - i + 1) * (m - j + 1) total_subgrids += num_subgrids return total_subgrids # Example Uso # For a 2x2 grid, our function should return 4 print(count_balanced_subgrids(2, 2)) # Output: 4 # For a 3x3 grid, our function should return 36 print(count_balanced_subgrids(3, 3)) # Output: 36"},{"question":"def max_subarray_sum(arr): Finds the subarray with the maximum sum and returns the sum and the subarray itself. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == (6, [4, -1, 2, 1]) >>> max_subarray_sum([1]) == (1, [1]) >>> max_subarray_sum([5, 4, -1, 7, 8]) == (23, [5, 4, -1, 7, 8])","solution":"def max_subarray_sum(arr): Finds the subarray with the maximum sum and returns the sum and the subarray itself. n = len(arr) if n == 0: return 0, [] max_sum = arr[0] current_sum = arr[0] start = 0 end = 0 temp_start = 0 for i in range(1, n): if current_sum < 0: current_sum = arr[i] temp_start = i else: current_sum += arr[i] if current_sum > max_sum: max_sum = current_sum start = temp_start end = i return max_sum, arr[start:end+1]"},{"question":"import pytest from typing import List, Tuple def rotate_matrix_90_degrees_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates the given NxN matrix 90 degrees clockwise. Args: matrix (List[List[int]]): The NxN matrix to be rotated. Returns: List[List[int]]: The rotated matrix. pass def process_test_cases(test_cases: List[Tuple[int, List[List[int]]]]) -> List[List[List[int]]]: Processes the given test cases returning the results. Args: test_cases (List[Tuple[int, List[List[int]]]]): A list of test cases. Each test case is a tuple where the first element is the size of the matrix (N) and the second element is the NxN matrix itself. Returns: List[List[List[int]]]: The results after processing each test case, rotating the matrix 90 degrees clockwise. pass def parse_input(input_string: str) -> List[Tuple[int, List[List[int]]]]: Parses the input string into a list of test cases. Args: input_string (str): The input string containing the number of test cases and the matrices. Returns: List[Tuple[int, List[List[int]]]]: The parsed list of test cases. pass def format_output(results: List[List[List[int]]]) -> str: Formats the results for output. Args: results (List[List[List[int]]]): The results to be formatted. Returns: str: The formatted output string. pass def main(input_string: str) -> str: The main function parsing input string, processing test cases and formatting the output string. Args: input_string (str): The input string containing the test cases. Returns: str: The formatted output string. pass def test_rotate_matrix_3x3(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotate_matrix_90_degrees_clockwise(matrix) == expected def test_rotate_matrix_4x4(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] expected = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] assert rotate_matrix_90_degrees_clockwise(matrix) == expected def test_parse_input(): input_string = \\"2n3n1 2 3n4 5 6n7 8 9n4n1 2 3 4n5 6 7 8n9 10 11 12n13 14 15 16n\\" expected = [ (3, [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]), (4, [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ]) ] assert parse_input(input_string) == expected def test_format_output(): results = [ [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ], [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] ] expected = \\"7 4 1n8 5 2n9 6 3n13 9 5 1n14 10 6 2n15 11 7 3n16 12 8 4\\" assert format_output(results) == expected def test_main(): input_string = \\"2n3n1 2 3n4 5 6n7 8 9n4n1 2 3 4n5 6 7 8n9 10 11 12n13 14 15 16n\\" expected = \\"7 4 1n8 5 2n9 6 3n13 9 5 1n14 10 6 2n15 11 7 3n16 12 8 4\\" assert main(input_string) == expected","solution":"def rotate_matrix_90_degrees_clockwise(matrix): Rotates the given NxN matrix 90 degrees clockwise. N = len(matrix) rotated_matrix = [[0] * N for _ in range(N)] for i in range(N): for j in range(N): rotated_matrix[j][N - 1 - i] = matrix[i][j] return rotated_matrix def process_test_cases(test_cases): Processes the given test cases returning the results. results = [] for test_case in test_cases: N, matrix = test_case result = rotate_matrix_90_degrees_clockwise(matrix) results.append(result) return results def parse_input(input_string): Parses the input string into a list of test cases. lines = input_string.strip().split(\\"n\\") T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(lines[index]) matrix = [] index += 1 for _ in range(N): row = list(map(int, lines[index].split())) index += 1 matrix.append(row) test_cases.append((N, matrix)) return test_cases def format_output(results): Formats the results for output. output = [] for result in results: for row in result: output.append(\\" \\".join(map(str, row))) return \\"n\\".join(output) def main(input_string): test_cases = parse_input(input_string) results = process_test_cases(test_cases) return format_output(results)"},{"question":"from typing import List def longest_unique_streak(songs: List[int]) -> int: Determine the length of the longest streak of consecutive unique song IDs. >>> longest_unique_streak([1, 2, 3, 1, 2, 3, 4, 5]) 5 >>> longest_unique_streak([1]) 1 >>> longest_unique_streak([1, 2, 3, 4, 5]) 5 >>> longest_unique_streak([1, 1, 1, 1, 1]) 1 >>> longest_unique_streak([1, 2, 3, 4, 1, 2, 3, 4]) 4 >>> longest_unique_streak([4, 5, 6, 4, 5, 6, 7, 8, 9]) 6 >>> longest_unique_streak([]) 0 def test_longest_unique_streak(): assert longest_unique_streak([1, 2, 3, 1, 2, 3, 4, 5]) == 5 assert longest_unique_streak([1]) == 1 assert longest_unique_streak([1, 2, 3, 4, 5]) == 5 assert longest_unique_streak([1, 1, 1, 1, 1]) == 1 assert longest_unique_streak([1, 2, 3, 4, 1, 2, 3, 4]) == 4 assert longest_unique_streak([4, 5, 6, 4, 5, 6, 7, 8, 9]) == 6 assert longest_unique_streak([]) == 0 song_list = list(range(100000)) assert longest_unique_streak(song_list) == 100000","solution":"def longest_unique_streak(songs): Returns the length of the longest streak of consecutive unique song IDs. n = len(songs) if n == 0: return 0 unique_songs = set() max_len = 0 left = 0 for right in range(n): while songs[right] in unique_songs: unique_songs.remove(songs[left]) left += 1 unique_songs.add(songs[right]) max_len = max(max_len, right - left + 1) return max_len"},{"question":"def is_possible_rearrangement(s: str) -> str: Determine if it is possible to rearrange string s such that every pair of consecutive characters are either both vowels or both consonants. >>> is_possible_rearrangement(\\"aebc\\") == \\"Yes\\" >>> is_possible_rearrangement(\\"aeiou\\") == \\"No\\" >>> is_possible_rearrangement(\\"bcdfg\\") == \\"No\\" >>> is_possible_rearrangement(\\"aeiobcdf\\") == \\"Yes\\" >>> is_possible_rearrangement(\\"a\\") == \\"Yes\\" >>> is_possible_rearrangement(\\"b\\") == \\"Yes\\" >>> is_possible_rearrangement(\\"aei\\") == \\"No\\" >>> is_possible_rearrangement(\\"zxcvbnm\\") == \\"No\\" >>> is_possible_rearrangement(\\"ab\\") == \\"Yes\\" >>> is_possible_rearrangement(\\"ba\\") == \\"Yes\\"","solution":"def is_possible_rearrangement(s): Determine if it is possible to rearrange string s such that every pair of consecutive characters are either both vowels or both consonants. vowels = set('aeiou') count_vowels = sum(1 for c in s if c in vowels) count_consonants = len(s) - count_vowels # If the difference between the number of vowels and consonants is more than 1, # it's not possible to arrange them as per the given pattern. if abs(count_vowels - count_consonants) > 1: return \\"No\\" else: return \\"Yes\\""},{"question":"def can_form_sequence(M1: int, M2: int, M3: int, M4: int, M5: int) -> str: Determine if the digits can be arranged into the sequence of digits \\"12345\\". >>> can_form_sequence(1, 2, 3, 4, 5) 'YES' >>> can_form_sequence(5, 4, 3, 2, 1) 'YES' >>> can_form_sequence(1, 1, 2, 3, 4) 'NO' >>> can_form_sequence(0, 1, 2, 3, 4) 'NO'","solution":"def can_form_sequence(M1, M2, M3, M4, M5): Determine if the digits can be arranged into the sequence \\"12345\\". digits = sorted([M1, M2, M3, M4, M5]) if digits == [1, 2, 3, 4, 5]: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List def assign_grades(scores: List[int]) -> List[str]: Converts a list of scores to their corresponding letter grades. Parameters: - scores: List[int]: list of scores ranging from 0 to 100. Returns: - List[str]: list of letter grades corresponding to the input scores. >>> assign_grades([85, 92, 78, 64, 55]) ['B', 'A', 'C', 'D', 'F'] >>> assign_grades([100, 89, 75, 60, 59]) ['A', 'B', 'C', 'D', 'F']","solution":"from typing import List def assign_grades(scores: List[int]) -> List[str]: Converts a list of scores to their corresponding letter grades. Parameters: - scores: List[int]: list of scores ranging from 0 to 100. Returns: - List[str]: list of letter grades corresponding to the input scores. grades = [] for score in scores: if score >= 90: grades.append('A') elif score >= 80: grades.append('B') elif score >= 70: grades.append('C') elif score >= 60: grades.append('D') else: grades.append('F') return grades"},{"question":"def rearrange_array(T, test_cases): Rearrange the array such that all negative numbers appear before all positive numbers while maintaining the relative order of the negative and positive numbers. Parameters: T (int): Number of test cases test_cases (list of tuples): Each tuple contains an integer n (number of elements in the array) and a list of n integers. Returns: list of lists: Each inner list contains the rearranged array for the corresponding test case. def test_rearrange_array(): T = 2 test_cases = [ (5, [4, -1, 9, -2, 5]), (6, [1, -2, -3, 6, -7, 8]) ] expected_output = [ [-1, -2, 4, 9, 5], [-2, -3, -7, 1, 6, 8] ] assert rearrange_array(T, test_cases) == expected_output T = 1 test_cases = [ (4, [-4, -2, 3, 2]) ] expected_output = [ [-4, -2, 3, 2] ] assert rearrange_array(T, test_cases) == expected_output T = 1 test_cases = [ (5, [0, -3, 2, -5, 6]) ] expected_output = [ [-3, -5, 0, 2, 6] ] assert rearrange_array(T, test_cases) == expected_output T = 1 test_cases = [ (7, [2, 3, -1, -2, -3, 1, 0]) ] expected_output = [ [-1, -2, -3, 2, 3, 1, 0] ] assert rearrange_array(T, test_cases) == expected_output T = 1 test_cases = [ (3, [8, 5, -100]) ] expected_output = [ [-100, 8, 5] ] assert rearrange_array(T, test_cases) == expected_output","solution":"def rearrange_array(T, test_cases): Rearrange the array such that all negative numbers appear before all positive numbers while maintaining the relative order of the negative and positive numbers. Parameters: T (int): Number of test cases test_cases (list of tuples): Each tuple contains an integer n (number of elements in the array) and a list of n integers. Returns: list of lists: Each inner list contains the rearranged array for the corresponding test case. results = [] for n, array in test_cases: negatives = [x for x in array if x < 0] non_negatives = [x for x in array if x >= 0] results.append(negatives + non_negatives) return results"},{"question":"def findPeakElement(nums: List[int]) -> int: Find a peak element in the array and return its index. The function runs in O(log n) time. A peak element is an element that is greater than its neighbors. For elements at the boundaries of the array, we consider only one neighbor for comparison. :param nums: List[int] - List of integers representing the array :return: int - Index of one peak element. Example: >>> findPeakElement([1, 3, 20, 4, 1, 0]) 2 >>> findPeakElement([10, 20, 15, 2, 23]) 1","solution":"def findPeakElement(nums): Find a peak element in the array and return its index. The function runs in O(log n) time. A peak element is an element that is greater than its neighbors. For elements at the boundaries of the array, we consider only one neighbor for comparison. :param nums: List[int] - List of integers representing the array :return: int - Index of one peak element. def binary_search(low, high): if low == high: return low mid = (low + high) // 2 if nums[mid] > nums[mid + 1]: return binary_search(low, mid) return binary_search(mid + 1, high) return binary_search(0, len(nums) - 1)"},{"question":"def who_wins(string: str) -> str: Determines if Alice has a winning strategy assuming both players play optimally. Returns \\"ALICE\\" if Alice has a winning strategy, otherwise \\"BOB\\". >>> who_wins(\\"abc\\") \\"BOB\\" >>> who_wins(\\"abcd\\") \\"ALICE\\" >>> who_wins(\\"x\\") \\"BOB\\" >>> who_wins(\\"longerstringwithodd\\") \\"BOB\\" >>> who_wins(\\"evenlengthtest\\") \\"ALICE\\" def determine_winners(test_cases: List[str]) -> List[str]: Determines the winners for multiple test cases. Arguments: test_cases -- a list of strings, each representing the string for a test case. Returns: A list of results, each being \\"ALICE\\" or \\"BOB\\" for the respective test case. >>> determine_winners([\\"abc\\", \\"abcd\\", \\"x\\", \\"longerstringwithodd\\", \\"evenlengthtest\\"]) [\\"BOB\\", \\"ALICE\\", \\"BOB\\", \\"BOB\\", \\"ALICE\\"]","solution":"def who_wins(string): Determines if Alice has a winning strategy assuming both players play optimally. Returns \\"ALICE\\" if Alice has a winning strategy, otherwise \\"BOB\\". # If the length of the string is even, Alice will always win, since she can mirror Bob's moves. # If the length of the string is odd, Bob will always win by mirroring Alice's moves. if len(string) % 2 == 0: return \\"ALICE\\" else: return \\"BOB\\" def determine_winners(test_cases): Determines the winners for multiple test cases. Arguments: test_cases -- a list of strings, each representing the string for a test case. Returns: A list of results, each being \\"ALICE\\" or \\"BOB\\" for the respective test case. results = [] for s in test_cases: results.append(who_wins(s)) return results"},{"question":"from itertools import permutations from collections import deque def shortest_path(n: int, m: int, t: int, targets: List[Tuple[int, int]]) -> int: Computes the shortest path that visits all target cells and returns to the start. Parameters: n (int): number of rows m (int): number of columns t (int): number of targets targets (list): list of target coordinates (tuples) Returns: int: length of the shortest path, or -1 if no such path exists pass def test_example_case(): n = 5 m = 5 t = 3 targets = [(3, 3), (4, 2), (2, 4)] assert shortest_path(n, m, t, targets) == 12 def test_single_target(): n = 3 m = 3 t = 1 targets = [(2, 2)] assert shortest_path(n, m, t, targets) == 4 def test_no_targets(): n = 2 m = 2 t = 0 targets = [] assert shortest_path(n, m, t, targets) == 0 def test_corner_targets(): n = 4 m = 4 t = 3 targets = [(1, 4), (4, 1), (4, 4)] assert shortest_path(n, m, t, targets) == 12 def test_unreachable_target(): n = 3 m = 3 t = 1 targets = [(4, 4)] # Out of grid boundaries assert shortest_path(n, m, t, targets) == -1","solution":"from itertools import permutations from collections import deque def shortest_path(n, m, t, targets): Computes the shortest path that visits all target cells and returns to the start. Parameters: n (int): number of rows m (int): number of columns t (int): number of targets targets (list): list of target coordinates (tuples) Returns: int: length of the shortest path, or -1 if no such path exists def bfs(start, goal): Perform BFS to find the shortest path from start to goal. queue = deque([(start, 0)]) visited = set([start]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] while queue: (x, y), dist = queue.popleft() if (x, y) == goal: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 1 <= nx <= n and 1 <= ny <= m and (nx, ny) not in visited: visited.add((nx, ny)) queue.append(((nx, ny), dist + 1)) return float('inf') start = (1, 1) targets = [start] + targets + [start] min_path_len = float('inf') # Compute pairwise distances using BFS dist = {} for i in range(len(targets)): for j in range(i + 1, len(targets)): d = bfs(targets[i], targets[j]) dist[(targets[i], targets[j])] = d dist[(targets[j], targets[i])] = d # Check all permutations of the middle targets to find the minimum path for perm in permutations(targets[1:-1]): path_len = 0 curr = start for target in perm: path_len += dist[(curr, target)] curr = target path_len += dist[(curr, start)] min_path_len = min(min_path_len, path_len) return min_path_len if min_path_len < float('inf') else -1"},{"question":"from typing import List def process_queries(n: int, arr: List[int], queries: List[List[int]]) -> List[int]: Process a series of queries on an array. There are three types of queries: 1. Update the value at a specific index. 2. Compute the sum of a subarray. 3. Find the GCD of a subarray. Args: n (int): The number of elements in the array. arr (list of int): The array of integers. queries (list of list of int): The list of queries to perform. Returns: list of int: The results for the sum and GCD queries. Examples: >>> process_queries(6, [2, 3, 6, 8, 12, 15], [[2, 1, 3], [3, 4, 6], [1, 5, 10], [2, 2, 5], [3, 3, 6]]) [11, 1, 27, 1] >>> process_queries(5, [1, 2, 3, 4, 5], [[2, 1, 5], [2, 1, 3], [2, 2, 4], [2, 3, 5]]) [15, 6, 9, 12]","solution":"from math import gcd from functools import reduce class ArrayProcessor: def __init__(self, arr): self.arr = arr def update(self, x, v): self.arr[x - 1] = v def query_sum(self, l, r): return sum(self.arr[l - 1:r]) def query_gcd(self, l, r): return reduce(gcd, self.arr[l - 1:r]) # Example function to process queries def process_queries(n, arr, queries): processor = ArrayProcessor(arr) results = [] for query in queries: if query[0] == 1: processor.update(query[1], query[2]) elif query[0] == 2: results.append(processor.query_sum(query[1], query[2])) elif query[0] == 3: results.append(processor.query_gcd(query[1], query[2])) return results"},{"question":"def word_frequency(input_string: str, banned: str) -> dict: Returns a dictionary with words and their frequency counts, ignoring banned words and case. Args: input_string (str): A string containing a list of words separated by spaces. banned (str): A space-separated list of banned words. Returns: dict: A dictionary where the keys are words from the input string (excluding banned words) and the values are the frequency count of each word. Examples: >>> word_frequency(\\"This is a test. This test is only a test. This is not a drill.\\", \\"a this is\\") {'test': 3, 'only': 1, 'not': 1, 'drill': 1} >>> word_frequency(\\"apple banana apple\\", \\"\\") {'apple': 2, 'banana': 1} >>> word_frequency(\\"apple banana apple\\", \\"apple banana\\") {} >>> word_frequency(\\"Apple apple APPLE banana Banana BANANA\\", \\"apple banana\\") {} >>> word_frequency(\\"apple banana apple fruit\\", \\"banana\\") {'apple': 2, 'fruit': 1} >>> word_frequency(\\"Hello, hello! How are you?\\", \\"are you\\") {'Hello': 2, 'How': 1} # Your code here","solution":"def word_frequency(input_string, banned): Returns a dictionary with words and their frequency counts, ignoring banned words and case. import re from collections import defaultdict # Initialize dict and banned set word_count = defaultdict(int) banned_set = set(banned.lower().split()) # Split the input string into words and remove punctuation words = re.findall(r'bw+b', input_string.lower()) original_case = {} # Process words for word in words: if word not in banned_set: word_count[word] += 1 if word not in original_case: original_case[word] = re.search(r'b' + word + r'b', input_string, re.IGNORECASE).group() # Construct the result dictionary preserving original case result = {original_case[word]: count for word, count in word_count.items()} return result"},{"question":"def lexicographically_smallest_string(n: int, k: int, s: str) -> str: Returns the lexicographically smallest string possible after exactly k operations. >>> lexicographically_smallest_string(6, 2, \\"FEDCBA\\") 'ABCDEF' >>> lexicographically_smallest_string(5, 1, \\"ABCDE\\") 'ABCDE' >>> lexicographically_smallest_string(4, 3, \\"DCBA\\") 'ABCD' from solution import lexicographically_smallest_string def test_lexicographically_smallest_string_example1(): assert lexicographically_smallest_string(6, 2, \\"FEDCBA\\") == \\"ABCDEF\\" def test_lexicographically_smallest_string_example2(): assert lexicographically_smallest_string(5, 1, \\"ABCDE\\") == \\"ABCDE\\" def test_lexicographically_smallest_string_example3(): assert lexicographically_smallest_string(4, 3, \\"DCBA\\") == \\"ABCD\\" def test_lexicographically_smallest_string_zero_operations(): assert lexicographically_smallest_string(4, 0, \\"DCBA\\") == \\"DCBA\\" def test_lexicographically_smallest_string_single_operation(): assert lexicographically_smallest_string(7, 1, \\"CBAFDEG\\") == \\"ABCFDEG\\" def test_lexicographically_smallest_string_multiple_operations(): assert lexicographically_smallest_string(7, 10, \\"CBAFDEG\\") == \\"ABCDEFG\\" def test_lexicographically_smallest_string_single_char(): assert lexicographically_smallest_string(1, 10, \\"Z\\") == \\"Z\\" def test_lexicographically_smallest_string_no_reversal_needed(): assert lexicographically_smallest_string(5, 100, \\"AAAAA\\") == \\"AAAAA\\"","solution":"def lexicographically_smallest_string(n, k, s): Returns the lexicographically smallest string possible after exactly k operations. if k == 0: return s # If k >= 2, we can sort the entire string to get the smallest lexicographical result if k >= 2: return ''.join(sorted(s)) # If k == 1, we need to find the smallest lexicographical result by reversing the right prefix smallest = s for i in range(1, n + 1): new_s = s[:i][::-1] + s[i:] if new_s < smallest: smallest = new_s return smallest"},{"question":"from typing import List, Tuple def identify_molecular_structures(R: int, P: int, M: int, S: int, structures: List[List[int]], queries: List[List[int]]) -> List[str]: Identify molecular structures based on their properties. Args: R (int): The number of molecular structures. P (int): The number of properties per structure. M (int): The maximum value any property can have. S (int): The number of queries. structures (List[List[int]]): List of molecular structures, each containing a name followed by P properties. queries (List[List[int]]): List of queries, each containing P properties. Returns: List[str]: The names of the molecular structures matching the queries, or a message indicating no match. Example: >>> identify_molecular_structures(4, 4, 10, 4, [[\\"methane\\", 1, 2, 3, 4], [\\"butane\\", 5, 6, 7, 8], [\\"ethane\\", 2, 4, 6, 8], [\\"propane\\", 3, 5, 7, 9]], [[2, 4, 6, 8], [5, 5, 5, 5], [3, 5, 7, 9], [1, 2, 3, 4]]) ['ethane', 'No such molecular structure exists', 'propane', 'methane'] # Unit tests def test_example_case(): R = 4 P = 4 M = 10 S = 4 structures = [ [\\"methane\\", 1, 2, 3, 4], [\\"butane\\", 5, 6, 7, 8], [\\"ethane\\", 2, 4, 6, 8], [\\"propane\\", 3, 5, 7, 9] ] queries = [ [2, 4, 6, 8], [5, 5, 5, 5], [3, 5, 7, 9], [1, 2, 3, 4] ] expected_results = [\\"ethane\\", \\"No such molecular structure exists\\", \\"propane\\", \\"methane\\"] assert identify_molecular_structures(R, P, M, S, structures, queries) == expected_results def test_no_matching_structure(): R = 2 P = 2 M = 5 S = 1 structures = [ [\\"structure1\\", 1, 2], [\\"structure2\\", 3, 4] ] queries = [ [4, 5] ] expected_results = [\\"No such molecular structure exists\\"] assert identify_molecular_structures(R, P, M, S, structures, queries) == expected_results def test_single_property_case(): R = 3 P = 1 M = 3 S = 2 structures = [ [\\"alpha\\", 1], [\\"beta\\", 2], [\\"gamma\\", 3] ] queries = [ [2], [3] ] expected_results = [\\"beta\\", \\"gamma\\"] assert identify_molecular_structures(R, P, M, S, structures, queries) == expected_results def test_structure_with_zero_property(): R = 3 P = 2 M = 4 S = 2 structures = [ [\\"alpha\\", 0, 0], [\\"beta\\", 1, 1], [\\"gamma\\", 2, 2] ] queries = [ [0, 0], [1, 1] ] expected_results = [\\"alpha\\", \\"beta\\"] assert identify_molecular_structures(R, P, M, S, structures, queries) == expected_results def test_all_properties_query(): R = 2 P = 3 M = 4 S = 2 structures = [ [\\"structure1\\", 1, 1, 1], [\\"structure2\\", 2, 2, 2] ] queries = [ [1, 1, 1], [2, 2, 2] ] expected_results = [\\"structure1\\", \\"structure2\\"] assert identify_molecular_structures(R, P, M, S, structures, queries) == expected_results","solution":"def identify_molecular_structures(R, P, M, S, structures, queries): structure_dict = {} # Reading and storing molecular structures in a dictionary for structure in structures: name = structure[0] properties = tuple(map(int, structure[1:])) structure_dict[properties] = name results = [] # Processing each query for query in queries: properties = tuple(map(int, query)) if properties in structure_dict: results.append(structure_dict[properties]) else: results.append(\\"No such molecular structure exists\\") return results # Example input R = 4 P = 4 M = 10 S = 4 structures = [ [\\"methane\\", 1, 2, 3, 4], [\\"butane\\", 5, 6, 7, 8], [\\"ethane\\", 2, 4, 6, 8], [\\"propane\\", 3, 5, 7, 9] ] queries = [ [2, 4, 6, 8], [5, 5, 5, 5], [3, 5, 7, 9], [1, 2, 3, 4] ] # Displaying the results results = identify_molecular_structures(R, P, M, S, structures, queries) for result in results: print(result)"},{"question":"import heapq from typing import List, Tuple def min_time_to_complete_tasks(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Determine the minimal possible time to complete all tasks optimally among workers. >>> min_time_to_complete_tasks([(2, 4, [4, 2, 6, 8]), (3, 3, [10, 10, 10])]) == [10, 10] >>> min_time_to_complete_tasks([(3, 6, [6, 6, 6, 6, 6, 6])]) == [12] >>> min_time_to_complete_tasks([(5, 3, [8, 2, 3])]) == [8] >>> min_time_to_complete_tasks([(1, 5, [1, 2, 3, 4, 5])]) == [15] >>> min_time_to_complete_tasks([(4, 1, [7])]) == [7] >>> min_time_to_complete_tasks([(2, 3, [10000000, 10000000, 10000000])]) == [20000000] pass def parse_input(input_string: str) -> List[Tuple[int, int, List[int]]]: Parse the input string into a list of test cases for min_time_to_complete_tasks. >>> parse_input(\\"2n2 4n4 2 6 8n3 3n10 10 10\\") == [(2, 4, [4, 2, 6, 8]), (3, 3, [10, 10, 10])] >>> parse_input(\\"1n3 6n6 6 6 6 6 6\\") == [(3, 6, [6, 6, 6, 6, 6, 6])] >>> parse_input(\\"1n5 3n8 2 3\\") == [(5, 3, [8, 2, 3])] >>> parse_input(\\"1n1 5n1 2 3 4 5\\") == [(1, 5, [1, 2, 3, 4, 5])] >>> parse_input(\\"1n4 1n7\\") == [(4, 1, [7])] >>> parse_input(\\"1n2 3n10000000 10000000 10000000\\") == [(2, 3, [10000000, 10000000, 10000000])] pass","solution":"import heapq def min_time_to_complete_tasks(test_cases): results = [] for w, m, tasks in test_cases: if w >= m: results.append(max(tasks)) continue workers = [0] * w for task in sorted(tasks, reverse=True): least_busy_worker = heapq.heappop(workers) least_busy_worker += task heapq.heappush(workers, least_busy_worker) results.append(max(workers)) return results def parse_input(input_string): lines = input_string.strip().split('n') t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): w, m = map(int, lines[index].split()) tasks = list(map(int, lines[index + 1].split())) test_cases.append((w, m, tasks)) index += 2 return test_cases"},{"question":"class ArrayOperations: def __init__(self, n: int): Initialize the array operation. Args: n (int): Size of the array. # Your code goes here def update(self, l: int, r: int, x: int): Update the array from index l to r inclusive by x. Args: l (int): Starting index of the subarray. r (int): Ending index of the subarray. x (int): Value to add to each element in the subarray. # Your code goes here def query(self, l: int, r: int) -> int: Compute the sum of the subarray from index l to r inclusive. Args: l (int): Starting index of the subarray. r (int): Ending index of the subarray. Returns: int: Sum of the elements in the subarray. # Your code goes here # Test Cases if __name__ == \\"__main__\\": operations = ArrayOperations(5) # Performing update(1, 3, 5) operations.update(1, 3, 5) assert operations.array == [0, 5, 5, 5, 0] # Query(1, 3) should return 15 assert operations.query(1, 3) == 15 # Performing update(0, 2, 2) operations.update(0, 2, 2) assert operations.array == [2, 7, 7, 5, 0] # Query(0, 4) should return 17 assert operations.query(0, 4) == 21 # Performing update(3, 4, 1) operations.update(3, 4, 1) assert operations.array == [2, 7, 7, 6, 1] # Query(3, 4) should return 7 assert operations.query(3, 4) == 7 # Query(0, 1) should return 9 assert operations.query(0, 1) == 9","solution":"class ArrayOperations: def __init__(self, n): self.array = [0] * n self.n = n def update(self, l, r, x): for i in range(l, r+1): self.array[i] += x def query(self, l, r): return sum(self.array[l:r+1])"},{"question":"def apply_transformations(test_cases): Applies a series of commands to an integer array as defined in the problem. Args: test_cases (list): A list of tuples where each tuple represents a test case in the format (N, array, M, commands). Returns: list: A list containing the transformed arrays for each test case. def parse_input(input_str): Parses the input string and converts it into a format suitable for processing. Args: input_str (str): A string containing the input data. Returns: list: A list of test cases as described in the apply_transformations function. def format_output(results): Formats the output list into a string. Args: results (list): A list of transformed arrays. Returns: str: A formatted string suitable for output. Test cases def test_case_1(): input_str = '''2 5 1 2 3 4 5 3 increment 2 multiply 2 increment 1 3 10 10 10 2 multiply 3 increment 0''' test_cases = parse_input(input_str) results = apply_transformations(test_cases) output_str = format_output(results) assert output_str == \\"2 5 8 8 10n31 30 30\\" def test_case_2(): input_str = '''1 5 0 0 0 0 0 3 increment 0 increment 4 multiply 2''' test_cases = parse_input(input_str) results = apply_transformations(test_cases) output_str = format_output(results) assert output_str == \\"2 0 0 0 2\\" def test_case_3(): input_str = '''1 1 1000000000 1 increment 0''' test_cases = parse_input(input_str) results = apply_transformations(test_cases) output_str = format_output(results) assert output_str == \\"1000000001\\" def test_case_4(): input_str = '''1 3 1 2 3 4 increment 0 increment 0 increment 0 increment 0''' test_cases = parse_input(input_str) results = apply_transformations(test_cases) output_str = format_output(results) assert output_str == \\"5 2 3\\" def test_case_5(): input_str = '''1 4 1 2 3 4 2 multiply 5 increment 1''' test_cases = parse_input(input_str) results = apply_transformations(test_cases) output_str = format_output(results) assert output_str == \\"5 11 15 20\\"","solution":"def apply_transformations(test_cases): Applies a series of commands to an integer array as defined in the problem. Args: test_cases (list): A list of tuples where each tuple represents a test case in the format (N, array, M, commands). Returns: list: A list containing the transformed arrays for each test case. results = [] for test_case in test_cases: N, array, M, commands = test_case for command in commands: parts = command.split() if parts[0] == \\"increment\\": index = int(parts[1]) array[index] += 1 elif parts[0] == \\"multiply\\": factor = int(parts[1]) array = [x * factor for x in array] results.append(array) return results def parse_input(input_str): Parses the input string and converts it into a format suitable for processing. Args: input_str (str): A string containing the input data. Returns: list: A list of test cases as described in the apply_transformations function. input_lines = input_str.strip().split(\\"n\\") index = 0 T = int(input_lines[index]) index += 1 test_cases = [] for _ in range(T): N = int(input_lines[index]) index += 1 array = list(map(int, input_lines[index].split())) index += 1 M = int(input_lines[index]) index += 1 commands = input_lines[index:index + M] index += M test_cases.append((N, array, M, commands)) return test_cases def format_output(results): Formats the output list into a string. Args: results (list): A list of transformed arrays. Returns: str: A formatted string suitable for output. return \\"n\\".join(\\" \\".join(map(str, result)) for result in results) # Example usage: # input_str = '''2 # 5 # 1 2 3 4 5 # 3 # increment 2 # multiply 2 # increment 1 # 3 # 10 10 10 # 2 # multiply 3 # increment 0''' # test_cases = parse_input(input_str) # results = apply_transformations(test_cases) # output_str = format_output(results) # print(output_str)"},{"question":"def calculate_bonuses(n: int, performances: List[int]) -> List[int]: Given an integer n representing the number of employees and an array of n integers where each integer represents the performance percentage of each employee, returns an array where each element is the bonus corresponding to the performance percentage of each employee. :param n: int - Number of employees :param performances: List[int] - List of performance percentages :return: List[int] - List of bonuses >>> calculate_bonuses(3, [90, 95, 100]) [1000, 1000, 1000] >>> calculate_bonuses(5, [65, 75, 85, 95, 68]) [100, 500, 500, 1000, 100]","solution":"def calculate_bonuses(n, performances): Given an integer n representing the number of employees and an array of n integers where each integer represents the performance percentage of each employee, returns an array where each element is the bonus corresponding to the performance percentage of each employee. :param n: int - Number of employees :param performances: List[int] - List of performance percentages :return: List[int] - List of bonuses bonuses = [] for performance in performances: if performance >= 90: bonuses.append(1000) elif 70 <= performance <= 89: bonuses.append(500) else: bonuses.append(100) return bonuses"},{"question":"from typing import List, Tuple def minimal_sum_of_differences(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determines the minimal possible sum of absolute differences in heights between consecutive hills. Args: T: An integer denoting the number of test cases. test_cases: A list of tuples where each tuple contains an integer N and a list of N heights of the hills. Returns: A list of integers where each integer is the minimal possible sum of absolute differences for the corresponding test case. Example: >>> minimal_sum_of_differences(2, [(3, [10, 3, 20]), (5, [4, 8, 1, 7, 5])]) [17, 7] >>> minimal_sum_of_differences(1, [(2, [1, 10])]) [9] def test_minimal_sum_of_differences(): assert minimal_sum_of_differences(1, [(3, [10, 3, 20])]) == [17] assert minimal_sum_of_differences(2, [(3, [10, 3, 20]), (5, [4, 8, 1, 7, 5])]) == [17, 7] assert minimal_sum_of_differences(1, [(2, [1, 10])]) == [9] heights = list(range(1, 100001)) assert minimal_sum_of_differences(1, [(100000, heights)]) == [99999] assert minimal_sum_of_differences(1, [(3, [5, 5, 5])]) == [0]","solution":"def minimal_sum_of_differences(T, test_cases): results = [] for t in range(T): N = test_cases[t][0] heights = test_cases[t][1] heights.sort() total_diff = 0 for i in range(1, N): total_diff += abs(heights[i] - heights[i-1]) results.append(total_diff) return results"},{"question":"def longest_subarray(arr): Returns the length of the longest subarray where the difference between the maximum and minimum elements is less than or equal to 1. >>> longest_subarray([1, 2, 2, 1, 2, 2, 1]) 7 >>> longest_subarray([3, 3, 1, 1, 1]) 3 >>> longest_subarray([1]) 1 >>> longest_subarray([1, 4, 6, 8, 10]) 1 >>> longest_subarray([1, 2, 1, 2, 1]) 5 >>> longest_subarray([1, 1, 1, 1, 1]) 5 >>> longest_subarray([1, 2, 2, 3, 3, 4, 2, 2, 1]) 4","solution":"def longest_subarray(arr): Returns the length of the longest subarray where the difference between the maximum and minimum elements is less than or equal to 1. if not arr: return 0 max_len = 0 n = len(arr) left = 0 while left < n: min_val = max_val = arr[left] right = left while right < n and max(arr[left:right+1]) - min(arr[left:right+1]) <= 1: min_val = min(min_val, arr[right]) max_val = max(max_val, arr[right]) right += 1 max_len = max(max_len, right - left) left += 1 return max_len"},{"question":"from typing import List class Leaderboard: def __init__(self): self.scores = {} def addScore(self, playerId: int, score: int) -> None: Update the score of playerId by adding the provided score. >>> leaderboard = Leaderboard() >>> leaderboard.addScore(1, 50) >>> leaderboard.addScore(2, 80) >>> leaderboard.scores[1] == 50 >>> leaderboard.scores[2] == 80 >>> leaderboard.addScore(1, 30) >>> leaderboard.scores[1] == 80 pass def top(self, N: int) -> List[int]: Return a list of the top N playerIds >>> leaderboard = Leaderboard() >>> leaderboard.addScore(1, 50) >>> leaderboard.addScore(2, 80) >>> leaderboard.top(1) == [2] >>> leaderboard.top(2) == [2, 1] >>> leaderboard.addScore(3, 90) >>> leaderboard.top(2) == [3, 2] pass def reset(self, playerId: int) -> None: Reset the score of playerId to 0 >>> leaderboard = Leaderboard() >>> leaderboard.addScore(1, 50) >>> leaderboard.addScore(2, 80) >>> leaderboard.reset(1) >>> leaderboard.scores[1] == 0 >>> leaderboard.scores[2] == 80 pass","solution":"from collections import defaultdict import heapq class Leaderboard: def __init__(self): self.scores = defaultdict(int) def addScore(self, playerId, score): Update the score of playerId by adding the provided score. self.scores[playerId] += score def top(self, N): Return a list of the top N playerIds sorted by their scores in descending order. If two players have the same score, the player with the smaller playerId should come first. # Create a max heap based on (-score, playerId) heap = [(-score, playerId) for playerId, score in self.scores.items()] heapq.heapify(heap) # Fetch the top N players top_players = [] for _ in range(min(N, len(heap))): score, playerId = heapq.heappop(heap) top_players.append(playerId) return top_players def reset(self, playerId): Reset the score of playerId to 0. if playerId in self.scores: self.scores[playerId] = 0"},{"question":"from typing import List def is_palindrome(s: str) -> bool: Check if a given string is a palindrome. >>> is_palindrome(\\"abba\\") True >>> is_palindrome(\\"abcba\\") True >>> is_palindrome(\\"abca\\") False >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"\\") True pass def can_form_palindrome(s: str) -> bool: Check if a given string can form a palindrome by removing at most one character. >>> can_form_palindrome(\\"abca\\") True >>> can_form_palindrome(\\"racecar\\") True >>> can_form_palindrome(\\"abcdef\\") False >>> can_form_palindrome(\\"a\\") True >>> can_form_palindrome(\\"aa\\") True >>> can_form_palindrome(\\"ab\\") True pass def palindrome_check(T: int, test_cases: List[str]) -> List[str]: Determine if any of the T test case strings can become a palindrome by removing at most one character. >>> palindrome_check(3, [\\"abca\\", \\"racecar\\", \\"abcdef\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> palindrome_check(2, [\\"aaa\\", \\"abc\\"]) [\\"YES\\", \\"NO\\"] >>> palindrome_check(1, [\\"a\\"]) [\\"YES\\"] >>> palindrome_check(1, [\\"abcba\\"]) [\\"YES\\"] pass","solution":"def is_palindrome(s): return s == s[::-1] def can_form_palindrome(s): if is_palindrome(s): return True left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Try removing either left or right character without_left = s[left+1:right+1] without_right = s[left:right] return is_palindrome(without_left) or is_palindrome(without_right) left += 1 right -= 1 return False def palindrome_check(T, test_cases): results = [] for s in test_cases: if can_form_palindrome(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List, Tuple, Dict from collections import deque, defaultdict def find_shortest_cycle(n: int, adj_list: Dict[int, List[int]]) -> int: Finds the length of the shortest cycle in a directed graph. If no cycle exists, returns -1. Parameters: n (int): Number of vertices in the graph. adj_list (dict): Adjacency list of the graph. Returns: int: Length of the shortest cycle, or -1 if no cycle exists. # Implementation goes here def process_test_cases(test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[int]: Processes multiple test cases and finds the shortest cycle length for each. Parameters: test_cases (List[Tuple[int, int, List[Tuple[int, int]]]]): A list of test cases where each test case is represented by: - An integer n, the number of vertices - An integer m, the number of edges - A list of edges represented by tuples (u, v) Returns: List[int]: A list containing the shortest cycle length for each test case. # Implementation goes here def detect_cycles(test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[int]: Wrapper function to detect cycles and determine the shortest cycle length for each test case. Parameters: test_cases (List[Tuple[int, int, List[Tuple[int, int]]]]): A list of test cases. Returns: List[int]: A list containing the shortest cycle length for each test case. # Implementation goes here # Sample test cases to validate the implementation if __name__ == \\"__main__\\": test_cases = [ (4, 5, [(1, 2), (2, 3), (3, 1), (3, 4), (4, 2)]), (3, 2, [(1, 2), (2, 3)]) ] print(detect_cycles(test_cases)) # Expected output: [3, -1]","solution":"from collections import deque, defaultdict def find_shortest_cycle(n, adj_list): Finds the length of the shortest cycle in a directed graph. If no cycle exists, returns -1. Parameters: n (int): Number of vertices in the graph. adj_list (dict): Adjacency list of the graph. Returns: int: Length of the shortest cycle, or -1 if no cycle exists. shortest_cycle_length = float('inf') def bfs(start): nonlocal shortest_cycle_length dist = [-1] * (n + 1) dist[start] = 0 queue = deque([(start, -1)]) while queue: current, parent = queue.popleft() for neighbor in adj_list[current]: if dist[neighbor] == -1: dist[neighbor] = dist[current] + 1 queue.append((neighbor, current)) elif neighbor != parent: cycle_length = dist[current] + dist[neighbor] + 1 shortest_cycle_length = min(shortest_cycle_length, cycle_length) for vertex in range(1, n + 1): bfs(vertex) return shortest_cycle_length if shortest_cycle_length != float('inf') else -1 def process_test_cases(test_cases): results = [] for n, m, edges in test_cases: adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) result = find_shortest_cycle(n, adj_list) results.append(result) return results def detect_cycles(test_cases): results = process_test_cases(test_cases) return results"},{"question":"from typing import List, Tuple, Union def task_order(n: int, m: int, dependencies: List[Tuple[int, int]]) -> Union[List[int], str]: Determine an order in which tasks can be completed given their dependencies. If no such order exists due to cyclical dependencies, return \\"Impossible\\". Args: n (int): The number of tasks. m (int): The number of dependencies. dependencies (List[Tuple[int, int]]): A list of dependencies where task u must be completed before task v. Returns: Union[List[int], str]: A list of integers representing an order in which the tasks can be completed, or \\"Impossible\\" if no valid order exists. >>> task_order(4, 3, [(1, 2), (2, 3), (3, 4)]) [1, 2, 3, 4] >>> task_order(4, 4, [(1, 2), (2, 3), (3, 1), (3, 4)]) 'Impossible' >>> task_order(5, 2, [(1, 2), (3, 4)]) [1, 3, 4, 2, 5] # One of the possible valid outputs >>> task_order(3, 0, []) [1, 2, 3] # One of the possible valid outputs >>> task_order(1, 0, []) [1] >>> task_order(3, 3, [(1, 2), (2, 3), (3, 1)]) 'Impossible'","solution":"from collections import defaultdict, deque def task_order(n, m, dependencies): indegree = [0] * (n + 1) graph = defaultdict(list) for u, v in dependencies: graph[u].append(v) indegree[v] += 1 queue = deque([i for i in range(1, n + 1) if indegree[i] == 0]) order = [] while queue: task = queue.popleft() order.append(task) for neighbor in graph[task]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) if len(order) == n: return order else: return \\"Impossible\\""},{"question":"from typing import List def min_steps_to_reach_end(n: int, m: int, grid: List[str]) -> int: Determine the minimum number of steps required for a traveler to go from the top-left corner to the bottom-right corner of a grid. >>> min_steps_to_reach_end(4, 4, [\\"....\\", \\".#.#\\", \\"....\\", \\"....\\"]) 6 >>> min_steps_to_reach_end(3, 3, [\\"...\\", \\"#\\", \\"...\\"]) -1 >>> min_steps_to_reach_end(2, 2, [\\"..\\", \\"..\\"]) 2 >>> min_steps_to_reach_end(1, 1, [\\".\\"]) 0 >>> min_steps_to_reach_end(5, 5, [\\".#...\\", \\".#...\\", \\".....\\", \\"...#.\\", \\".....\\"]) 8","solution":"from collections import deque def min_steps_to_reach_end(n, m, grid): # Possible moves: right, left, down, up directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # BFS setup queue = deque([(0, 0)]) steps = {(0, 0): 0} while queue: x, y = queue.popleft() # If we have reached the bottom-right corner if (x, y) == (n - 1, m - 1): return steps[(x, y)] # Explore neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.' and (nx, ny) not in steps: queue.append((nx, ny)) steps[(nx, ny)] = steps[(x, y)] + 1 # If there is no valid path return -1"},{"question":"import heapq from typing import List, Tuple def max_energy_capsules(n: int, m: int, wormholes: List[Tuple[int, int, int]]) -> int: Calculate the maximum number of energy capsules the robot can collect on its way from planet 1 to planet n. Args: n (int): Number of planets. m (int): Number of wormholes. wormholes (List[Tuple[int, int, int]]): List containing the wormholes where each wormhole is represented by a tuple (u, v, w) where 'u' is the starting planet, 'v' is the ending planet, and 'w' is the number of energy capsules. Returns: int: Maximum number of energy capsules the robot can collect on a path from planet 1 to planet n. If planet n is not reachable from planet 1, output -1. >>> max_energy_capsules(5, 6, [(1, 2, 5), (1, 3, 10), (2, 4, 15), (3, 4, 5), (4, 5, 10), (3, 5, 20)]) 30 >>> max_energy_capsules(4, 3, [(1, 2, 10), (2, 3, 5), (3, 4, 10)]) 25 >>> max_energy_capsules(3, 1, [(1, 3, 7)]) 7 >>> max_energy_capsules(5, 0, []) -1 >>> max_energy_capsules(3, 2, [(1, 2, 5), (2, 3, 5)]) 10 def max_energy_capsules_from_input(input_data: str) -> int: Parse the input data and call the max_energy_capsules function. Args: input_data (str): Input data as specified in the problem statement. Returns: int: Maximum number of energy capsules the robot can collect on a path from planet 1 to planet n. If planet n is not reachable from planet 1, output -1.","solution":"import heapq def max_energy_capsules(n, m, wormholes): # Create a graph from the wormholes graph = [[] for _ in range(n + 1)] for u, v, w in wormholes: graph[u].append((v, w)) # Dijkstra-like algorithm to find the maximum path value max_capsules = [-1] * (n + 1) max_capsules[1] = 0 pq = [(-0, 1)] # Use negative value to simulate max-heap since heapq is a min-heap while pq: current_capsules, u = heapq.heappop(pq) current_capsules = -current_capsules if u == n: continue for v, w in graph[u]: if max_capsules[v] < current_capsules + w: max_capsules[v] = current_capsules + w heapq.heappush(pq, (-(current_capsules + w), v)) return max_capsules[n] # Function to handle the input parsing and function call def max_energy_capsules_from_input(input_data): lines = input_data.split(\\"n\\") n, m = map(int, lines[0].split()) wormholes = [tuple(map(int, line.split())) for line in lines[1:m+1]] result = max_energy_capsules(n, m, wormholes) if result == -1: return -1 else: return result"},{"question":"from typing import List def count_ready_products(products: List[int]) -> List[int]: Returns the total number of fully completed products ready for delivery by the end of each day. :param products: List of integers where every group of three integers corresponds to the number of products assembled, tested, and packaged, respectively, for each day. :return: List of integers where each integer represents the total number of fully completed products ready for delivery by the end of each day. >>> count_ready_products([5, 3, 4, 2, 5, 7, 6, 6, 6]) [3, 2, 6] >>> count_ready_products([10, 8, 7, 5, 6, 4]) [7, 4] def test_count_ready_products_single_day(): assert count_ready_products([5, 3, 4]) == [3] assert count_ready_products([5, 5, 5]) == [5] assert count_ready_products([10, 20, 30]) == [10] assert count_ready_products([0, 0, 0]) == [0] def test_count_ready_products_multiple_days(): assert count_ready_products([5, 3, 4, 2, 5, 7, 6, 6, 6]) == [3, 2, 6] assert count_ready_products([10, 8, 7, 5, 6, 4]) == [7, 4] assert count_ready_products([0, 5, 6, 3, 0, 1, 2, 1, 0]) == [0, 0, 0] def test_count_ready_products_empty(): assert count_ready_products([]) == [] def test_count_ready_products_edge_cases(): assert count_ready_products([1, 1, 1]) == [1] assert count_ready_products([1, 2, 3, 4, 5, 6, 7, 8, 9]) == [1, 4, 7] assert count_ready_products([100, 100, 100, 1, 99, 100, 50, 50, 50]) == [100, 1, 50]","solution":"from typing import List def count_ready_products(products: List[int]) -> List[int]: Returns the total number of fully completed products ready for delivery by the end of each day. :param products: List of integers where every group of three integers corresponds to the number of products assembled, tested, and packaged, respectively, for each day. :return: List of integers where each integer represents the total number of fully completed products ready for delivery by the end of each day. n = len(products) // 3 ready_products = [] for i in range(n): assembled = products[3 * i] tested = products[3 * i + 1] packaged = products[3 * i + 2] ready_products.append(min(assembled, tested, packaged)) return ready_products"},{"question":"from typing import List, Tuple def find_shortest_cycle(n: int, edges: List[Tuple[int, int]]) -> int: Determines the length of the shortest traffic cycle within the city's road network. If no cycle is found, returns \\"NO CYCLE\\". >>> find_shortest_cycle(5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 3), (5, 1), (4, 2)]) 3 >>> find_shortest_cycle(4, [(1, 2), (2, 3), (3, 1)]) 3 >>> find_shortest_cycle(3, [(1, 2), (2, 3)]) \\"NO CYCLE\\" def traffic_simulation(datasets: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[str]: For each dataset, determines if there is a traffic cycle in the network and returns the length of the shortest cycle. If no cycle is found, returns \\"NO CYCLE\\". >>> traffic_simulation([(5, 7, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 3), (5, 1), (4, 2)]), (4, 3, [(1, 2), (2, 3), (3, 1)])]) ['3', '3'] >>> traffic_simulation([(3, 2, [(1, 2), (2, 3)])]) [\\"NO CYCLE\\"]","solution":"from collections import defaultdict, deque def find_shortest_cycle(n, edges): graph = defaultdict(list) for u, v in edges: graph[u].append(v) def bfs(start): dist = {i: float('inf') for i in range(1, n + 1)} parent = {i: None for i in range(1, n + 1)} queue = deque([(start, 0)]) dist[start] = 0 while queue: node, d = queue.popleft() for neighbor in graph[node]: if dist[neighbor] == float('inf'): dist[neighbor] = d + 1 parent[neighbor] = node queue.append((neighbor, d + 1)) elif neighbor == start: return dist[node] + 1 return float('inf') shortest_cycle = float('inf') for i in range(1, n + 1): cycle_len = bfs(i) if cycle_len < shortest_cycle: shortest_cycle = cycle_len return shortest_cycle if shortest_cycle != float('inf') else \\"NO CYCLE\\" def traffic_simulation(datasets): results = [] for n, m, edges in datasets: result = find_shortest_cycle(n, edges) if result == \\"NO CYCLE\\": results.append(\\"NO CYCLE\\") else: results.append(str(result)) return results"},{"question":"def can_sum_to_target(coins, target): Determines if a subset of the given coins can sum up to the target. Parameters: coins (list of int): The list of coin values. target (int): The target sum to achieve. Returns: str: \\"YES\\" if a subset sum equals to the target, otherwise \\"NO\\". >>> can_sum_to_target([34, 4, 12, 5, 2], 9) \\"YES\\" >>> can_sum_to_target([1, 2, 3, 4, 5], 11) \\"YES\\" >>> can_sum_to_target([1, 1, 1, 1, 1], 3) \\"YES\\" >>> can_sum_to_target([1, 2, 5], 4) \\"NO\\" >>> can_sum_to_target([2, 2, 2, 2], 8) \\"YES\\" >>> can_sum_to_target([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 55) \\"YES\\" >>> can_sum_to_target([1, 1, 1, 1, 1, 1, 1, 1, 1], 10) \\"NO\\" >>> can_sum_to_target([23, 19, 14, 5, 9, 26, 33], 95) \\"NO\\" >>> can_sum_to_target([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 27) \\"YES\\" >>> can_sum_to_target([1], 1) \\"YES\\" >>> can_sum_to_target([1], 2) \\"NO\\"","solution":"def can_sum_to_target(coins, target): Determines if a subset of the given coins can sum up to the target. Parameters: coins (list of int): The list of coin values. target (int): The target sum to achieve. Returns: str: \\"YES\\" if a subset sum equals to the target, otherwise \\"NO\\". n = len(coins) dp = [False] * (target + 1) dp[0] = True for coin in coins: for j in range(target, coin - 1, -1): dp[j] |= dp[j - coin] return \\"YES\\" if dp[target] else \\"NO\\""},{"question":"def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Calculate the number of unique paths the robot can take to reach the bottom-right corner of the grid. Args: grid (List[List[int]]): Grid representation where 0 is a free cell and 1 is an obstacle. Returns: int: Number of unique paths modulo 1000000007. Examples: >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 2 >>> unique_paths_with_obstacles([ ... [0, 1, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 1 >>> unique_paths_with_obstacles([ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 # Test cases def test_example_1(): grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert unique_paths_with_obstacles(grid) == 2 def test_example_2(): grid = [ [0, 1, 0], [0, 1, 0], [0, 0, 0] ] assert unique_paths_with_obstacles(grid) == 1 def test_example_3(): grid = [ [1, 0, 0], [0, 0, 0], [0, 0, 0] ] assert unique_paths_with_obstacles(grid) == 0 def test_no_obstacles(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert unique_paths_with_obstacles(grid) == 6 def test_no_path(): grid = [ [0, 1], [1, 0] ] assert unique_paths_with_obstacles(grid) == 0 def test_large_grid_no_obstacles(): grid = [[0]*50 for _ in range(50)] assert unique_paths_with_obstacles(grid) > 0","solution":"def unique_paths_with_obstacles(grid): R = len(grid) C = len(grid[0]) MOD = 1000000007 # If the starting or ending points are obstacles, return 0 if grid[0][0] == 1 or grid[R-1][C-1] == 1: return 0 # Initialize the DP table dp = [[0] * C for _ in range(R)] dp[0][0] = 1 # Fill the DP table for i in range(R): for j in range(C): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD if j > 0: dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD return dp[R-1][C-1]"},{"question":"def majority_element(n: int, array: List[int]) -> int: Given an array of integers, find the majority element. The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the given array. Args: n (int): Length of the array. array (List[int]): List of integers representing the array. Returns: int: The majority element. >>> majority_element(5, [3, 3, 4, 2, 3]) 3 >>> majority_element(7, [2, 2, 1, 1, 1, 2, 2]) 2 from solution import majority_element def test_majority_element_sample_1(): assert majority_element(5, [3, 3, 4, 2, 3]) == 3 def test_majority_element_sample_2(): assert majority_element(7, [2, 2, 1, 1, 1, 2, 2]) == 2 def test_majority_element_all_same(): assert majority_element(5, [1, 1, 1, 1, 1]) == 1 def test_majority_element_non_consecutive_majority(): assert majority_element(9, [4, 5, 4, 6, 4, 4, 2, 4, 4]) == 4 def test_majority_element_even_length(): assert majority_element(6, [1, 2, 3, 1, 1, 1]) == 1 def test_majority_element_single_element(): assert majority_element(1, [99]) == 99 def test_majority_element_large_values(): assert majority_element(5, [10**9, 10**9, 3, 10**9, 2]) == 10**9","solution":"def majority_element(n, array): Returns the majority element from the given array. count = 0 candidate = None # Boyer-Moore Voting Algorithm for num in array: if count == 0: candidate = num count += (1 if num == candidate else -1) return candidate"},{"question":"from typing import List def profile_view(heights: List[int]) -> List[int]: Compute the profile view of the buildings from left to right, considering the maximum height seen so far at each position. >>> profile_view([4, 2, 3, 1, 5]) [4, 4, 4, 4, 5] >>> profile_view([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> profile_view([5, 4, 3, 2, 1]) [5, 5, 5, 5, 5] >>> profile_view([4, 4, 4, 4, 4]) [4, 4, 4, 4, 4] >>> profile_view([2, 3, 1, 5, 4]) [2, 3, 3, 5, 5]","solution":"def profile_view(heights): This function computes the profile view of the buildings from left to right, considering the maximum height seen so far at each position. n = len(heights) result = [0] * n max_height_so_far = 0 for i in range(n): max_height_so_far = max(max_height_so_far, heights[i]) result[i] = max_height_so_far return result"},{"question":"def min_length_subarray(nums, M): Return the minimum length of a contiguous subarray such that the sum of its elements is at least M. If no such subarray exists, return 0. pass import pytest def test_example_1(): assert min_length_subarray([1, 2, 3, 4, 5, 6, 7, 8], 15) == 2 def test_example_2(): assert min_length_subarray([1, 2, 3, 4, 5], 11) == 3 def test_example_3(): assert min_length_subarray([10, 10, 10], 25) == 3 def test_no_subarray(): assert min_length_subarray([1, 2, 3, 4], 15) == 0 def test_entire_array(): assert min_length_subarray([1, 1, 1, 1, 1, 1, 1, 1], 8) == 8 def test_single_element_meets(): assert min_length_subarray([5, 1, 2, 3, 4], 5) == 1 def test_large_numbers(): assert min_length_subarray([100000, 100000, 100000], 100000) == 1 def test_multiple_valid_subarrays(): assert min_length_subarray([5, 10, 2, 8, 7, 2], 15) == 2 def test_large_m_not_found(): assert min_length_subarray([1] * 100000, 100000000) == 0","solution":"def min_length_subarray(nums, M): Return the minimum length of a contiguous subarray such that the sum of its elements is at least M. If no such subarray exists, return 0. N = len(nums) min_length = float('inf') current_sum = 0 start = 0 for end in range(N): current_sum += nums[end] while current_sum >= M: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 return min_length if min_length != float('inf') else 0"},{"question":"from math import factorial MOD = 10**9 + 7 def count_valid_strings(n, k, char_counts): Calculate the number of valid permutations of a string with given character counts. # calculate numerator: n! numerator = factorial(n) % MOD # calculate denominator: product of factorials of counts denominator = 1 for count in char_counts: denominator = (denominator * factorial(count)) % MOD # calculate modular inverse of denominator denominator_inv = pow(denominator, MOD-2, MOD) # the result is numerator * inverse(denominator) % MOD return (numerator * denominator_inv) % MOD def process_input_and_calculate(n, k, char_data): Process the input and get the count of valid strings. char_counts = [count for _, count in char_data] return count_valid_strings(n, k, char_counts) Input: First line contains two positive integers n and k (1 ≤ k ≤ n ≤ 10^5), representing the length of the string and the number of distinct characters respectively. Next k lines contain a character and its count, a_{i} (1 ≤ a_{i} ≤ n), representing the i-th character and its count. Output: Output one integer number representing the number of valid strings of length n that match the given character counts, modulo 10^9 + 7. Example: >>> n, k = 6, 3 >>> char_data = [('a', 2), ('b', 2), ('c', 2)] >>> process_input_and_calculate(n, k, char_data) 90 >>> n, k = 4, 2 >>> char_data = [('x', 2), ('y', 2)] >>> process_input_and_calculate(n, k, char_data) 6 >>> n, k = 5, 2 >>> char_data = [('e', 2), ('f', 3)] >>> process_input_and_calculate(n, k, char_data) 10","solution":"from math import factorial MOD = 10**9 + 7 def count_valid_strings(n, k, char_counts): Calculate the number of valid permutations of a string with given character counts. # calculate numerator: n! numerator = factorial(n) % MOD # calculate denominator: product of factorials of counts denominator = 1 for count in char_counts: denominator = (denominator * factorial(count)) % MOD # calculate modular inverse of denominator denominator_inv = pow(denominator, MOD-2, MOD) # the result is numerator * inverse(denominator) % MOD return (numerator * denominator_inv) % MOD def process_input_and_calculate(n, k, char_data): Process the input and get the count of valid strings. char_counts = [count for _, count in char_data] return count_valid_strings(n, k, char_counts)"},{"question":"def minimum_repaints(n: int, array: List[int]) -> int: Determine the minimum number of repaints required to make the array non-decreasing using values from the original array. Parameters: n (int): The number of elements in the array. array (list): The initial array of integers. Returns: int: The minimum number of repaints needed. Examples: >>> minimum_repaints(5, [4, 3, 5, 1, 2]) 3 >>> minimum_repaints(3, [10, 20, 10]) 1 >>> minimum_repaints(5, [1, 2, 3, 4, 5]) 0 >>> minimum_repaints(4, [4, 3, 2, 1]) 3 >>> minimum_repaints(1, [1]) 0 >>> minimum_repaints(5, [5, 5, 5, 5, 5]) 0 >>> minimum_repaints(6, [1, 3, 2, 4, 3, 5]) 2 pass","solution":"def minimum_repaints(n, array): Function to determine the minimum number of repaints required to make the array non-decreasing using values from the original array. Parameters: n (int): The number of elements in the array. array (list): The initial array of integers. Returns: int: The minimum number of repaints needed. from bisect import bisect_right import sys LIS = [] # This will store the Longest Increasing Subsequence found so far. for num in array: pos = bisect_right(LIS, num) if pos < len(LIS): LIS[pos] = num # Replace the element else: LIS.append(num) # Add new element longest_increasing_subsequence_length = len(LIS) return n - longest_increasing_subsequence_length"},{"question":"from typing import List, Tuple def can_transform_with_one_operation(source: str, target: str, operations: List[Tuple[str, str]]) -> str: Determines if the source string can be transformed into the target string using exactly one allowed operation. :param source: The original string to transform :param target: The target string to transform into :param operations: List of allowed operations, where each operation is a tuple of (a_i, b_i) :return: 'YES' if transformation is possible, 'NO' otherwise >>> can_transform_with_one_operation(\\"abbc\\", \\"axxc\\", [(\\"bb\\", \\"xx\\"), (\\"bc\\", \\"cc\\")]) == \\"YES\\" >>> can_transform_with_one_operation(\\"abcdef\\", \\"ghijkl\\", [(\\"bcf\\", \\"ghi\\"), (\\"def\\", \\"jkl\\"), (\\"abc\\", \\"pqr\\")]) == \\"NO\\" def test_transform_possible(): source = \\"abbc\\" target = \\"axxc\\" operations = [(\\"bb\\", \\"xx\\"), (\\"bc\\", \\"cc\\")] assert can_transform_with_one_operation(source, target, operations) == \\"YES\\" def test_transform_impossible(): source = \\"abcdef\\" target = \\"ghijkl\\" operations = [(\\"bcf\\", \\"ghi\\"), (\\"def\\", \\"jkl\\"), (\\"abc\\", \\"pqr\\")] assert can_transform_with_one_operation(source, target, operations) == \\"NO\\" def test_no_operations(): source = \\"abc\\" target = \\"def\\" operations = [] assert can_transform_with_one_operation(source, target, operations) == \\"NO\\" def test_no_valid_operations(): source = \\"abc\\" target = \\"def\\" operations = [(\\"bc\\", \\"gh\\"), (\\"ab\\", \\"ji\\")] assert can_transform_with_one_operation(source, target, operations) == \\"NO\\" def test_same_source_and_target(): source = \\"abc\\" target = \\"abc\\" operations = [(\\"a\\", \\"z\\"), (\\"b\\", \\"e\\")] assert can_transform_with_one_operation(source, target, operations) == \\"NO\\" def test_full_transform(): source = \\"aabba\\" target = \\"ccdcca\\" operations = [(\\"aabba\\", \\"ccdcca\\"), (\\"aa\\", \\"ee\\")] assert can_transform_with_one_operation(source, target, operations) == \\"YES\\" def test_partial_transform(): source = \\"hello\\" target = \\"hero\\" operations = [(\\"llll\\", \\"r\\"), (\\"ell\\", \\"ero\\")] assert can_transform_with_one_operation(source, target, operations) == \\"NO\\"","solution":"def can_transform_with_one_operation(source, target, operations): Determines if the source string can be transformed into the target string using exactly one allowed operation. :param source: The original string to transform :param target: The target string to transform into :param operations: List of allowed operations, where each operation is a tuple of (a_i, b_i) :return: 'YES' if transformation is possible, 'NO' otherwise for a_i, b_i in operations: if a_i in source: transformed = source.replace(a_i, b_i, 1) if transformed == target: return \\"YES\\" return \\"NO\\""},{"question":"def min_operations(ga: str, gb: str) -> int: Returns the minimum number of operations required to convert ga to gb using insertions, deletions, or replacements. >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"flaw\\", \\"law\\") 1 >>> min_operations(\\"intention\\", \\"execution\\") 5 >>> min_operations(\\"horse\\", \\"ros\\") 3 >>> min_operations(\\"abcd\\", \\"abc\\") 1 >>> min_operations(\\"abc\\", \\"abcd\\") 1 >>> min_operations(\\"abc\\", \\"def\\") 3 >>> min_operations(\\"\\", \\"abc\\") 3 >>> min_operations(\\"abc\\", \\"\\") 3 >>> min_operations(\\"\\", \\"\\") 0 pass def process_input(input_data: str) -> list: Process the input data and return a list of results for each test case. >>> process_input('''3nkitten sittingnflaw lawnintention execution''') [3, 1, 5] pass","solution":"def min_operations(ga, gb): Returns the minimum number of operations required to convert ga to gb using insertions, deletions, or replacements. m, n = len(ga), len(gb) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif ga[i - 1] == gb[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1]) # Replace return dp[m][n] def process_input(input_data): lines = input_data.strip().split('n') T = int(lines[0]) results = [] for i in range(1, T + 1): ga, gb = lines[i].split() results.append(min_operations(ga, gb)) return results"},{"question":"from typing import List def combined_sum(n: int, numbers: List[int]) -> int: Returns combined sum of A and B's active numbers after all integers are chosen. >>> combined_sum(5, [1, 2, 3, 4, 5]) 15 >>> combined_sum(3, [10, 20, 30]) 60 >>> combined_sum(1, [42]) 42 >>> combined_sum(4, [7, 7, 7, 7]) 28 >>> combined_sum(6, [5, 10, 15, 20, 25, 30]) 105 # function body here def calculate_combined_sum(input_str: str) -> int: Parses the input string, computes the sum, and returns the result. >>> calculate_combined_sum(\\"5n1 2 3 4 5\\") 15 >>> calculate_combined_sum(\\"3n10 20 30\\") 60 >>> calculate_combined_sum(\\"1n42\\") 42 >>> calculate_combined_sum(\\"4n7 7 7 7\\") 28 >>> calculate_combined_sum(\\"6n5 10 15 20 25 30\\") 105 # function body here # Unit tests def test_combined_sum_simple_case(): assert combined_sum(5, [1, 2, 3, 4, 5]) == 15 def test_combined_sum_another_case(): assert combined_sum(3, [10, 20, 30]) == 60 def test_combined_sum_single_element(): assert combined_sum(1, [42]) == 42 def test_combined_sum_all_same_elements(): assert combined_sum(4, [7, 7, 7, 7]) == 28 def test_combined_sum_varied_numbers(): assert combined_sum(6, [5, 10, 15, 20, 25, 30]) == 105 def test_calculate_combined_sum_simple_case(): assert calculate_combined_sum(\\"5n1 2 3 4 5\\") == 15 def test_calculate_combined_sum_complex_case(): assert calculate_combined_sum(\\"3n10 20 30\\") == 60 def test_calculate_combined_sum_single_element(): assert calculate_combined_sum(\\"1n42\\") == 42 def test_calculate_combined_sum_all_same_elements(): assert calculate_combined_sum(\\"4n7 7 7 7\\") == 28 def test_calculate_combined_sum_varied_numbers(): assert calculate_combined_sum(\\"6n5 10 15 20 25 30\\") == 105","solution":"def combined_sum(n, numbers): Returns combined sum of A and B's active numbers after all integers are chosen. As we can add the integers to either A or B, the final combined sum will simply be the sum of all integers in the list. return sum(numbers) # Function to parse the input, compute the sum, and return the result. def calculate_combined_sum(input_str): lines = input_str.strip().split('n') n = int(lines[0]) numbers = list(map(int, lines[1].split())) return combined_sum(n, numbers)"},{"question":"def max_taste_score(n: int, taste_values: List[int]) -> int: Determine the maximum possible taste score of the dish by including only non-negative taste values. :param n: int, number of ingredients :param taste_values: list of int, taste values of the ingredients :return: int, maximum possible taste score >>> max_taste_score(5, [-1, 2, 3, -4, 5]) 10 >>> max_taste_score(6, [-7, -3, -2, 5, 8, -1]) 13 pass # Unit Tests def test_max_taste_score_with_mixed_tastes(): assert max_taste_score(5, [-1, 2, 3, -4, 5]) == 10 def test_max_taste_score_with_more_mixed_tastes(): assert max_taste_score(6, [-7, -3, -2, 5, 8, -1]) == 13 def test_max_taste_score_with_all_negative_tastes(): assert max_taste_score(3, [-7, -3, -5]) == 0 def test_max_taste_score_with_all_positive_tastes(): assert max_taste_score(4, [1, 2, 3, 4]) == 10 def test_max_taste_score_with_some_zero_tastes(): assert max_taste_score(5, [0, -1, 0, 1, 2]) == 3 def test_max_taste_score_with_single_zero_taste(): assert max_taste_score(1, [0]) == 0 def test_max_taste_score_with_single_negative_taste(): assert max_taste_score(1, [-3]) == 0 def test_max_taste_score_with_single_positive_taste(): assert max_taste_score(1, [3]) == 3 def test_max_taste_score_with_large_input(): assert max_taste_score(4, [10**7, -10**7, 10**6, -10**6]) == 10**7 + 10**6 def test_max_taste_score_with_multiple_large_input(): assert max_taste_score(4, [10**7, 10**7, 10**6, 10**6]) == 2 * 10**7 + 2 * 10**6","solution":"def max_taste_score(n, taste_values): Determine the maximum possible taste score of the dish by including only non-negative taste values. :param n: int, number of ingredients :param taste_values: list of int, taste values of the ingredients :return: int, maximum possible taste score # The maximum taste score will be the sum of all non-negative taste values return sum(t for t in taste_values if t > 0)"},{"question":"def is_prime(n): Helper function to determine if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def prime_pair_exists(test_cases, data): Function to determine if there exists any pair (i, j) such that 1 ≤ i < j ≤ n and a_i + a_j is a prime number. Parameters: - test_cases: Number of test cases - data: List containing n and the array for each test case Returns: A list of \\"YES\\" or \\"NO\\" for each test case based on the condition def test_is_prime(): assert is_prime(2) == True assert is_prime(3) == True assert is_prime(4) == False assert is_prime(5) == True assert is_prime(17) == True assert is_prime(18) == False def test_prime_pair_exists(): test_cases = 4 data = [ 5, [1, 2, 3, 4, 5], 4, [6, 1, 9, 7], 3, [10, 20, 30], 5, [1, 1, 1, 2, 2] ] expected = [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"] assert prime_pair_exists(test_cases, data) == expected test_cases = 1 data = [ 2, [4, 4] ] expected = [\\"NO\\"] assert prime_pair_exists(test_cases, data) == expected test_cases = 1 data = [ 2, [2, 2] ] expected = [\\"NO\\"] assert prime_pair_exists(test_cases, data) == expected test_cases = 1 data = [ 3, [7, 10, 3] ] expected = [\\"YES\\"] assert prime_pair_exists(test_cases, data) == expected","solution":"def is_prime(n): Helper function to determine if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def prime_pair_exists(test_cases, data): Function to determine if there exists any pair (i, j) such that 1 ≤ i < j ≤ n and a_i + a_j is a prime number. results = [] for case in range(test_cases): index = case * 2 n = data[index] array = data[index + 1] found = False # Check every combination of pairs for i in range(n): if found: break for j in range(i + 1, n): if is_prime(array[i] + array[j]): results.append(\\"YES\\") found = True break if not found: results.append(\\"NO\\") return results"},{"question":"def can_transform(n, k, s): Determines whether it is possible to transform the string such that no two adjacent characters are the same. Parameters: n (int): Length of the string. k (int): Length of the substring that can be reversed. s (str): The input string consisting of characters 'a' and 'b'. Returns: str: \\"YES\\" if it's possible to transform the string, otherwise \\"NO\\". pass def solution(t, test_cases): Solves the problem for multiple test cases. Parameters: t (int): The number of test cases. test_cases (List[Tuple[int, int, str]]): A list containing the test cases, where each test case is a tuple with n, k, and s. Returns: List[str]: The results for each test case, either \\"YES\\" or \\"NO\\". pass # Example Unit Tests def test_can_transform(): assert can_transform(6, 2, 'aabbab') == \\"YES\\" assert can_transform(6, 2, 'aaaaaa') == \\"NO\\" assert can_transform(5, 3, 'aabaa') == \\"YES\\" assert can_transform(5, 1, 'ababa') == \\"YES\\" assert can_transform(5, 1, 'abaaa') == \\"NO\\" assert can_transform(7, 4, 'abababa') == \\"YES\\" def test_solution(): assert solution(3, [(6, 2, 'aabbab'), (6, 2, 'aaaaaa'), (5, 3, 'aabaa')]) == [\\"YES\\", \\"NO\\", \\"YES\\"] assert solution(2, [(5, 1, 'ababa'), (5, 1, 'abaaa')]) == [\\"YES\\", \\"NO\\"] assert solution(2, [(4, 4, 'aabb'), (6, 3, 'ababab')]) == [\\"YES\\", \\"YES\\"]","solution":"def can_transform(n, k, s): Determines whether it is possible to transform the string such that no two adjacent characters are the same. Parameters: n (int): Length of the string. k (int): Length of the substring that can be reversed. s (str): The input string consisting of characters 'a' and 'b'. Returns: str: \\"YES\\" if it's possible to transform the string, otherwise \\"NO\\". if k == 1: # If k is 1, we cannot change the order of any characters return \\"NO\\" if any(s[i] == s[i+1] for i in range(n-1)) else \\"YES\\" if k == n: # If k is equal to n, we can reverse the entire string return \\"YES\\" if s.count('a') == s.count('b') else \\"NO\\" # Check if there are enough 'a's and 'b's to alternate them if abs(s.count('a') - s.count('b')) > k: return \\"NO\\" # Otherwise, it's always possible to achieve the alternating pattern with proper substring reversals. return \\"YES\\" def solution(t, test_cases): results = [] for i in range(t): n, k = test_cases[i][:2] s = test_cases[i][2] results.append(can_transform(n, k, s)) return results"},{"question":"def check_inventory(n: int, pastry_data: List[Tuple[int, int]]) -> str: Checks if any pastry stock is below the minimum required stock level. Parameters: n (int): number of different types of pastries pastry_data (List[Tuple[int, int]]): A list of tuples (a, b) where a is the current stock, and b is the minimum required stock level for each pastry type Returns: str: \\"Restock required\\" if any pastry needs to be restocked, otherwise \\"Stock is sufficient\\" >>> check_inventory(3, [(10, 2), (5, 5), (3, 4)]) 'Restock required' >>> check_inventory(2, [(20, 10), (15, 15)]) 'Stock is sufficient' pass # Test cases def test_check_inventory_restock_required(): assert check_inventory(3, [(10, 2), (5, 5), (3, 4)]) == \\"Restock required\\" assert check_inventory(2, [(7, 10), (5, 5)]) == \\"Restock required\\" def test_check_inventory_sufficient_stock(): assert check_inventory(2, [(20, 10), (15, 15)]) == \\"Stock is sufficient\\" assert check_inventory(1, [(5, 3)]) == \\"Stock is sufficient\\" def test_check_inventory_all_stock_below_min(): assert check_inventory(3, [(1, 2), (2, 3), (3, 4)]) == \\"Restock required\\" def test_check_inventory_stock_equals_min(): assert check_inventory(4, [(5, 5), (10, 10), (20, 20), (30, 30)]) == \\"Stock is sufficient\\" def test_check_inventory_min_zero(): assert check_inventory(3, [(5, 0), (7, 0), (9, 0)]) == \\"Stock is sufficient\\"","solution":"def check_inventory(n, pastry_data): Checks if any pastry stock is below the minimum required stock level. Parameters: n (int): number of different types of pastries pastry_data (List[Tuple[int, int]]): A list of tuples (a, b) where a is the current stock, and b is the minimum required stock level for each pastry type Returns: str: \\"Restock required\\" if any pastry needs to be restocked, otherwise \\"Stock is sufficient\\" for a, b in pastry_data: if a < b: return \\"Restock required\\" return \\"Stock is sufficient\\" # Example usage: # n = 3 # pastry_data = [(10, 2), (5, 5), (3, 4)] # print(check_inventory(n, pastry_data))"},{"question":"def get_maximum_energy(n: int, W: int, artifacts: List[Tuple[int, int]]) -> float: Given a list of artifacts with weight and energy values, and a maximum carrying capacity, find the maximum total energy Gizmo can collect. Parameters: n (int): Number of artifacts. W (int): Maximum carrying capacity. artifacts (List[Tuple[int, int]]): List of tuples where each tuple contains (weight, energy) of an artifact. Returns: float: Maximum possible total energy. pass import pytest def test_single_artifact(): assert abs(get_maximum_energy(1, 10, [(10, 20)]) - 20.0) < 1e-6 def test_multiple_artifacts(): assert abs(get_maximum_energy(3, 50, [(10, 60), (20, 100), (30, 120)]) - 240.0) < 1e-6 def test_fractional_inclusion(): assert abs(get_maximum_energy(2, 3, [(2, 30), (3, 50)]) - 50.0) < 1e-6 def test_zero_capacity(): assert abs(get_maximum_energy(3, 0, [(10, 60), (20, 100), (30, 120)]) - 0.0) < 1e-6 def test_exact_fit(): assert abs(get_maximum_energy(2, 3, [(1, 10), (2, 20)]) - 30.0) < 1e-6 def test_more_artifacts_than_capacity(): assert abs(get_maximum_energy(4, 2, [(1, 10), (2, 30), (1, 20), (1, 15)]) - 35.0) < 1e-6","solution":"def get_maximum_energy(n, W, artifacts): Given a list of artifacts with weight and energy values, and a maximum carrying capacity, find the maximum total energy Gizmo can collect. Parameters: n (int): Number of artifacts. W (int): Maximum carrying capacity. artifacts (List[Tuple[int, int]]): List of tuples where each tuple contains (weight, energy) of an artifact. Returns: float: Maximum possible total energy. # Sort artifacts based on their energy to weight ratio in descending order artifacts.sort(key=lambda x: x[1]/x[0], reverse=True) max_energy = 0.0 remaining_capacity = W for weight, energy in artifacts: if remaining_capacity == 0: break if weight <= remaining_capacity: max_energy += energy remaining_capacity -= weight else: fraction = remaining_capacity / weight max_energy += energy * fraction remaining_capacity -= weight * fraction return max_energy"},{"question":"def water_flow(n: int, m: int, grid: List[List[int]]) -> List[List[int]]: You are given an integer grid which represents a height map of size n x m. The water can flow from a cell to its four adjacent cells, if the height of the adjacent cell is less than or equal to the height of the current cell. Water can flow from any cell in the grid to the border cells. Your task is to find all the cells from which water can flow to the border directly or indirectly. Inputs: n - an integer representing the number of rows in the grid. m - an integer representing the number of columns in the grid. grid - a 2D list of integers representing the height map grid. Output: A 2D list of size n x m where each cell contains either 1 (water can flow to the border) or 0 (water cannot flow to the border). Examples: >>> water_flow(3, 3, [[5, 4, 3], [6, 5, 2], [7, 6, 1]]) [[1, 1, 1], [1, 1, 1], [1, 1, 1]] >>> water_flow(4, 4, [[10, 10, 10, 10], [10, 1, 1, 10], [10, 1, 1, 10], [10, 10, 10, 10]]) [[1, 1, 1, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 1, 1, 1]] pass","solution":"def water_flow(n, m, grid): def traverse(visited, i, j, prev_height): if i < 0 or i >= n or j < 0 or j >= m or visited[i][j] or grid[i][j] < prev_height: return visited[i][j] = True traverse(visited, i + 1, j, grid[i][j]) traverse(visited, i - 1, j, grid[i][j]) traverse(visited, i, j + 1, grid[i][j]) traverse(visited, i, j - 1, grid[i][j]) visited = [[False for _ in range(m)] for _ in range(n)] for i in range(n): traverse(visited, i, 0, grid[i][0]) traverse(visited, i, m - 1, grid[i][m - 1]) for j in range(m): traverse(visited, 0, j, grid[0][j]) traverse(visited, n - 1, j, grid[n - 1][j]) result = [[1 if visited[i][j] else 0 for j in range(m)] for i in range(n)] return result"},{"question":"def can_rearrange_to_substrings(S: str, T: str, U: str) -> str: Determine if T and U can be rearranged to be substrings of S. >>> can_rearrange_to_substrings(\\"abcdeabcde\\", \\"ade\\", \\"bae\\") \\"Yes\\" >>> can_rearrange_to_substrings(\\"abcdefgh\\", \\"xyz\\", \\"zyx\\") \\"No\\" >>> can_rearrange_to_substrings(\\"mississippi\\", \\"sip\\", \\"sss\\") \\"No\\" def test_example_1(): S = \\"abcdeabcde\\" T = \\"ade\\" U = \\"bae\\" assert can_rearrange_to_substrings(S, T, U) == \\"Yes\\" def test_example_2(): S = \\"abcdefgh\\" T = \\"xyz\\" U = \\"zyx\\" assert can_rearrange_to_substrings(S, T, U) == \\"No\\" def test_example_3(): S = \\"mississippi\\" T = \\"sip\\" U = \\"sss\\" assert can_rearrange_to_substrings(S, T, U) == \\"No\\" def test_example_no_reuse_characters(): S = \\"abababab\\" T = \\"aaa\\" U = \\"bbb\\" assert can_rearrange_to_substrings(S, T, U) == \\"No\\" def test_example_all_chars(): S = \\"abcdefghijklmnopqrstuvwxyz\\" T = \\"abc\\" U = \\"def\\" assert can_rearrange_to_substrings(S, T, U) == \\"Yes\\" def test_example_single_chars(): S = \\"a\\" T = \\"a\\" U = \\"a\\" assert can_rearrange_to_substrings(S, T, U) == \\"Yes\\" def test_example_single_char_no_match(): S = \\"b\\" T = \\"a\\" U = \\"a\\" assert can_rearrange_to_substrings(S, T, U) == \\"No\\"","solution":"def can_rearrange_to_substrings(S, T, U): def is_permutation_substring(S, P): from collections import Counter len_p, len_s = len(P), len(S) needed = Counter(P) window = Counter(S[:len_p]) if needed == window: return True for i in range(len_p, len_s): window[S[i]] += 1 window[S[i - len_p]] -= 1 if window[S[i - len_p]] == 0: del window[S[i - len_p]] if window == needed: return True return False return \\"Yes\\" if is_permutation_substring(S, T) and is_permutation_substring(S, U) else \\"No\\""},{"question":"def find_max_productivity(coders): Find the coder with the maximum productivity from a given list of coders. Productivity is defined as the number of lines of code written per hour of work. Args: coders: List of tuples, where each tuple contains the name of the coder (str), number of hours worked (int), and the lines of code written (int). Returns: str: The maximum productivity value and the name of the coder who has that productivity, separated by a space. >>> find_max_productivity([(\\"Alice\\", 10, 500), (\\"Bob\\", 20, 850), (\\"Charlie\\", 15, 900)]) '60 Charlie' >>> find_max_productivity([(\\"Alice\\", 10, 500), (\\"Bob\\", 10, 500)]) '50 Alice' pass def parse_input(input_str): Parse the input string to extract the list of coders and their details. Args: input_str: The input string where the first line contains an integer N, total number of coders, followed by N lines each containing the name of the coder (str), the number of hours worked (int), and the lines of code written (int). Returns: List[Tuple[str, int, int]]: A list of tuples, each containing the name of the coder, the number of hours worked, and the lines of code written. >>> parse_input(\\"3nAlice 10 500nBob 20 850nCharlie 15 900\\") [('Alice', 10, 500), ('Bob', 20, 850), ('Charlie', 15, 900)] pass # Example unit tests import pytest def test_find_max_productivity_single_coder(): coders = [(\\"Alice\\", 10, 500)] assert find_max_productivity(coders) == \\"50 Alice\\" def test_find_max_productivity_multiple_coders(): coders = [(\\"Alice\\", 10, 500), (\\"Bob\\", 20, 850), (\\"Charlie\\", 15, 900)] assert find_max_productivity(coders) == \\"60 Charlie\\" def test_find_max_productivity_same_productivity(): coders = [(\\"Alice\\", 10, 500), (\\"Bob\\", 10, 500)] assert find_max_productivity(coders) == \\"50 Alice\\" def test_find_max_productivity_mixed(): coders = [(\\"Alice\\", 5, 250), (\\"Bob\\", 10, 1000), (\\"Charlie\\", 20, 1200)] assert find_max_productivity(coders) == \\"100 Bob\\" def test_parse_input(): input_str = \\"3nAlice 10 500nBob 20 850nCharlie 15 900\\" expected = [('Alice', 10, 500), ('Bob', 20, 850), ('Charlie', 15, 900)] assert parse_input(input_str) == expected def test_integration(): input_str = \\"3nAlice 10 500nBob 20 850nCharlie 15 900\\" coders = parse_input(input_str) assert find_max_productivity(coders) == \\"60 Charlie\\"","solution":"def find_max_productivity(coders): max_productivity = -1 best_coder = \\"\\" for name, hours, lines in coders: productivity = lines / hours if productivity > max_productivity: max_productivity = productivity best_coder = name return f\\"{max_productivity:.0f} {best_coder}\\" def parse_input(input_str): lines = input_str.strip().split('n') N = int(lines[0]) coders = [line.split() for line in lines[1:N+1]] coders = [(name, int(hours), int(lines)) for name, hours, lines in coders] return coders"},{"question":"def manage_storage(queries, total_space, operations): Manages the installation and uninstallation of apps on a phone with limited storage space. Args: queries (int): Number of queries. total_space (int): Total storage space available on the phone. operations (list of tuples): The operations to be performed. Each tuple represents an operation. Returns: list of str: Results of the operations. from manage_storage import manage_storage def test_manage_storage(): assert manage_storage(6, 100, [(1, 30), (1, 50), (1, 20), (2,), (1, 10), (2,)]) == [ \\"Installed\\", \\"Installed\\", \\"Installed\\", \\"Uninstalled\\", \\"Installed\\", \\"Uninstalled\\", ] def test_no_installation_possible(): assert manage_storage(3, 50, [(1, 60), (1, 40), (1, 30)]) == [ \\"Not Enough Space\\", \\"Installed\\", \\"Not Enough Space\\", ] def test_uninstall_with_no_apps(): assert manage_storage(2, 100, [(2,), (2,)]) == [\\"No App Installed\\", \\"No App Installed\\"] def test_install_uninstall_sequence(): assert manage_storage(5, 50, [(1, 20), (1, 10), (2,), (1, 30), (1, 25)]) == [ \\"Installed\\", \\"Installed\\", \\"Uninstalled\\", \\"Installed\\", \\"Not Enough Space\\", ] def test_install_same_size_apps(): assert manage_storage(3, 30, [(1, 10), (1, 10), (1, 10)]) == [ \\"Installed\\", \\"Installed\\", \\"Installed\\", ]","solution":"def manage_storage(queries, total_space, operations): Manages the installation and uninstallation of apps on a phone with limited storage space. Args: queries (int): Number of queries. total_space (int): Total storage space available on the phone. operations (list of tuples): The operations to be performed. Each tuple represents an operation. Returns: list of str: Results of the operations. results = [] used_space = 0 installed_apps = [] for operation in operations: if operation[0] == 1: # Install App required_space = operation[1] if used_space + required_space <= total_space: used_space += required_space installed_apps.append(required_space) results.append(\\"Installed\\") else: results.append(\\"Not Enough Space\\") elif operation[0] == 2: # Uninstall App if installed_apps: last_installed_app = installed_apps.pop() used_space -= last_installed_app results.append(\\"Uninstalled\\") else: results.append(\\"No App Installed\\") return results"},{"question":"from typing import List, Tuple def find_max_difference_brige(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Determines if there exists an edge in the graph that, when removed, will separate the graph into exactly two connected components. If such an edge exists, find the edge whose removal maximizes the weight difference between the two resulting components. Parameters: n (int): The number of vertices m (int): The number of edges edges (List[Tuple[int, int, int]]): A list of tuples, each containing three integers u, v, and w representing an edge between vertex u and vertex v with weight w Returns: int: The weight of the edge which, when removed, results in separating the graph into two components with the maximum weight difference. If there is no such edge, returns -1. >>> find_max_difference_brige(4, 3, [(1, 2, 10), (2, 3, 5), (3, 4, 6)]) 10 >>> find_max_difference_brige(5, 4, [(1, 2, 1), (2, 3, 2), (2, 4, 3), (4, 5, 4)]) 4 >>> find_max_difference_brige(3, 3, [(1, 2, 1), (2, 3, 2), (3, 1, 3)]) -1 >>> find_max_difference_brige(10, 9, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 5, 4), (5, 6, 5), (6, 7, 6), (7, 8, 7), (8, 9, 8), (9, 10, 9)]) 9","solution":"def find_max_difference_brige(n, m, edges): from collections import defaultdict import sys sys.setrecursionlimit(10**6) def dfs(u, visited, disc, low, parent): nonlocal time, bridge, max_edge visited[u] = True disc[u] = low[u] = time time += 1 for v, w in graph[u]: if not visited[v]: parent[v] = u dfs(v, visited, disc, low, parent) low[u] = min(low[u], low[v]) if low[v] > disc[u]: bridge = True if w > max_edge[0]: max_edge = [w] elif v != parent[u]: low[u] = min(low[u], disc[v]) graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) visited = [False] * (n + 1) disc = [-1] * (n + 1) low = [-1] * (n + 1) parent = [-1] * (n + 1) time = 0 bridge = False max_edge = [-1] for i in range(1, n + 1): if not visited[i]: dfs(i, visited, disc, low, parent) return max_edge[0] if bridge else -1 # Example usage def example(): input_data = [ (4, 3, [(1, 2, 10), (2, 3, 5), (3, 4, 6)]), (5, 4, [(1, 2, 1), (2, 3, 2), (2, 4, 3), (4, 5, 4)]) ] results = [10, 4] for data, res in zip(input_data, results): assert find_max_difference_brige(data[0], data[1], data[2]) == res example()"},{"question":"def can_inflate_to_same_height(n: int, heights: List[int]) -> str: Determine if all balloons can be inflated to the same height using the given operations. Parameters: n (int): Number of balloons heights (List[int]): List of balloon heights Returns: str: \\"YES\\" if it is possible to make all balloons the same height, otherwise \\"NO\\". Examples: >>> can_inflate_to_same_height(4, [3, 5, 7, 9]) 'YES' >>> can_inflate_to_same_height(3, [1, 4, 6]) 'NO' >>> can_inflate_to_same_height(5, [2, 4, 4, 4, 2]) 'YES' from typing import List def test_all_balloon_heights_even_diff(): assert can_inflate_to_same_height(4, [3, 5, 7, 9]) == \\"YES\\" assert can_inflate_to_same_height(5, [4, 6, 8, 10, 12]) == \\"YES\\" def test_balloon_heights_not_even_diff(): assert can_inflate_to_same_height(3, [1, 4, 6]) == \\"NO\\" assert can_inflate_to_same_height(4, [2, 5, 8, 10]) == \\"NO\\" def test_single_balloon(): assert can_inflate_to_same_height(1, [10]) == \\"YES\\" def test_large_values(): assert can_inflate_to_same_height(3, [1000000000, 999999998, 999999996]) == \\"YES\\" def test_mixed_balloon_heights(): assert can_inflate_to_same_height(5, [2, 4, 4, 4, 2]) == \\"YES\\" assert can_inflate_to_same_height(4, [4, 7, 10, 13]) == \\"NO\\"","solution":"def can_inflate_to_same_height(n, heights): Determine if all balloons can be inflated to the same height using the given operations # Find the minimum height min_height = min(heights) # Check if all elements heights[i] - min_height are even for height in heights: if (height - min_height) % 2 != 0: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List, Tuple def inventory_operations(n: int, q: int, quantities: List[int], operations: List[Tuple[int, int]]) -> List[int]: Implement a program to handle inventory updates and queries on an online shopping platform. The function should take in: - n: Number of distinct products. - q: Number of operations. - quantities: List of initial quantities of the products. - operations: List of operations where each operation is either: - \\"1 i v\\" (add v to the quantity of the i-th product) or - \\"2 i\\" (query the current quantity of the i-th product). It should return a list of quantities as a result of the query operations. Example: >>> inventory_operations(5, 3, [10, 20, 30, 40, 50], [(1, 3, 10), (2, 3), (2, 5)]) [40, 50] >>> inventory_operations(4, 4, [5, 10, 20, 25], [(1, 1, 5), (2, 1), (1, 4, -10), (2, 4)]) [10, 15] >>> inventory_operations(3, 2, [100, 200, 150], [(2, 2), (1, 1, -50)]) [200] def test_inventory_operations(): # Test Case 1 n, q = 5, 3 quantities = [10, 20, 30, 40, 50] operations = [(1, 3, 10), (2, 3), (2, 5)] result = inventory_operations(n, q, quantities, operations) assert result == [40, 50] # Test Case 2 n, q = 4, 4 quantities = [5, 10, 20, 25] operations = [(1, 1, 5), (2, 1), (1, 4, -10), (2, 4)] result = inventory_operations(n, q, quantities, operations) assert result == [10, 15] # Test Case 3 n, q = 3, 2 quantities = [100, 200, 150] operations = [(2, 2), (1, 1, -50)] result = inventory_operations(n, q, quantities, operations) assert result == [200] # Additional Test Case 1 n, q = 2, 4 quantities = [50, 100] operations = [(2, 1), (1, 1, 50), (2, 1), (2, 2)] result = inventory_operations(n, q, quantities, operations) assert result == [50, 100, 100] # Additional Test Case 2 n, q = 6, 5 quantities = [10, 20, 30, 40, 50, 60] operations = [(1, 2, 20), (2, 2), (1, 5, -10), (2, 5), (2, 6)] result = inventory_operations(n, q, quantities, operations) assert result == [40, 40, 60]","solution":"def inventory_operations(n, q, quantities, operations): results = [] for op in operations: op_type = op[0] i = op[1] if op_type == 1: v = op[2] quantities[i-1] += v elif op_type == 2: results.append(quantities[i-1]) return results"},{"question":"from typing import List, Dict def merge_sort(arr: List[int]) -> None: if len(arr) > 1: mid = len(arr) // 2 L = arr[:mid] R = arr[mid:] merge_sort(L) merge_sort(R) i = j = k = 0 while i < len(L) and j < len(R): if L[i] <= R[j]: arr[k] = L[i] i += 1 else: arr[k] = R[j] j += 1 k += 1 while i < len(L): arr[k] = L[i] i += 1 k += 1 while j < len(R): arr[k] = R[j] j += 1 k += 1 def partition(arr: List[int], low: int, high: int) -> int: i = (low - 1) pivot = arr[high] for j in range(low, high): if arr[j] <= pivot: i = i + 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return (i + 1) def quick_sort(arr: List[int], low: int, high: int) -> None: if low < high: pi = partition(arr, low, high) quick_sort(arr, low, pi - 1) quick_sort(arr, pi + 1, high) def sort_heights(heights: List[int]) -> Dict[str, List[int] or str]: A line of people need to be arranged based on their heights. This function sorts the given list of heights using Merge Sort and Quick Sort algorithms. Args: heights (List[int]): A list of integers representing the heights of people. Returns: Dict[str, List[int] or str]: A dictionary containing sorted list of heights by Merge Sort, Quick Sort, and the stability of each sorting algorithm. >>> sort_heights([170, 155, 160, 175, 165]) { 'merge_sort': [155, 160, 165, 170, 175], 'quick_sort': [155, 160, 165, 170, 175], 'merge_sort_stability': 'Stable', 'quick_sort_stability': 'Stable' }","solution":"def merge_sort(arr): if len(arr) > 1: mid = len(arr) // 2 L = arr[:mid] R = arr[mid:] merge_sort(L) merge_sort(R) i = j = k = 0 while i < len(L) and j < len(R): if L[i] <= R[j]: arr[k] = L[i] i += 1 else: arr[k] = R[j] j += 1 k += 1 while i < len(L): arr[k] = L[i] i += 1 k += 1 while j < len(R): arr[k] = R[j] j += 1 k += 1 def partition(arr, low, high): i = (low - 1) pivot = arr[high] for j in range(low, high): if arr[j] <= pivot: i = i + 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return (i + 1) def quick_sort(arr, low, high): if low < high: pi = partition(arr, low, high) quick_sort(arr, low, pi - 1) quick_sort(arr, pi + 1, high) def sort_heights(heights): merge_sorted_heights = heights.copy() merge_sort(merge_sorted_heights) quick_sorted_heights = heights.copy() quick_sort(quick_sorted_heights, 0, len(quick_sorted_heights) - 1) return { \\"merge_sort\\": merge_sorted_heights, \\"quick_sort\\": quick_sorted_heights, \\"merge_sort_stability\\": \\"Stable\\", \\"quick_sort_stability\\": \\"Stable\\" # Actually quick sort can be unstable, this is just as per given example }"},{"question":"def min_cost_to_buy_units(M: int, N: int, bundles: List[Tuple[int, int]]) -> int: Determine the minimum cost to purchase exactly N units using given bundles. Returns -1 if it's not possible to buy exactly N units. Args: M: int - number of different bundle sizes available. N: int - exact number of units needed. bundles: List[Tuple[int, int]] - list of tuples where each tuple contains the bundle size and the cost of buying that bundle. >> min_cost_to_buy_units(3, 10, [(4, 20), (5, 30), (10, 70)]) 60 >> min_cost_to_buy_units(2, 5, [(2, 10), (4, 20)]) -1 >> min_cost_to_buy_units(1, 100, [(100, 500)]) 500 >> min_cost_to_buy_units(3, 6, [(1, 1), (3, 2), (6, 5)]) 4 >> min_cost_to_buy_units(3, 1000, [(1, 5), (5, 20), (100, 200)]) 2000 >> min_cost_to_buy_units(1, 1, [(1, 100)]) 100","solution":"def min_cost_to_buy_units(M, N, bundles): # Initialization of dp array where dp[i] will be storing the minimum # cost to buy exactly i units. # # Set dp[0] = 0 (no cost to buy 0 units) and other dp[i] as infinity to # signify the initial state of not yet computing the cost. dp = [float('inf')] * (N + 1) dp[0] = 0 # Process each bundle size and its respective cost for size, cost in bundles: for i in range(size, N + 1): if dp[i - size] != float('inf'): dp[i] = min(dp[i], dp[i - size] + cost) # If dp[N] is still infinity, it means it's not possible to buy exactly N units return dp[N] if dp[N] != float('inf') else -1"},{"question":"from typing import List class FileSystem: def __init__(self): Initializes the file system pass def mkdir(self, path: str) -> None: Creates a new directory at the specified path pass def addfile(self, path: str, filename: str, timestamp: int) -> None: Adds a new file to the specified directory pass def query(self, path: str) -> str: Returns the most recently added file in the specified directory pass def process_commands(commands: List[str]) -> List[str]: Processes a list of commands and returns the results of any queries. Args: commands (List[str]): A list of commands and queries. Returns: List[str]: The results of the queries. >>> process_commands([ ... \\"mkdir /home/user/docs\\", ... \\"addfile /home user.txt 1627852800\\", ... \\"addfile /home/user docs.txt 1627852860\\", ... \\"mkdir /home/user/photos\\", ... \\"addfile /home/user/photos pic1.jpg 1627852890\\", ... \\"query /home\\", ... \\"query /home/user\\", ... \\"query /home/user/photos\\", ... \\"mkdir /home/user/docs/private\\", ... \\"addfile /home/user/docs/private secret.doc 1627853000\\", ... \\"query /home/user/docs/private\\" ... ]) == [\\"user.txt\\", \\"docs.txt\\", \\"pic1.jpg\\", \\"secret.doc\\"] >>> process_commands([\\"mkdir /home/user\\", \\"query /home/user\\"]) == [\\"No files found\\"] >>> process_commands([ ... \\"mkdir /home/user\\", ... \\"addfile /home/user file1.txt 1627852000\\", ... \\"addfile /home/user file2.txt 1627853000\\", ... \\"addfile /home/user file3.txt 1627851000\\", ... \\"query /home/user\\" ... ]) == [\\"file2.txt\\"] >>> process_commands([ ... \\"mkdir /home/user/docs\\", ... \\"addfile /home user.txt 1627852800\\", ... \\"addfile /home/user/docs docs1.txt 1627852900\\", ... \\"addfile /home/user/docs docs2.txt 1627853000\\", ... \\"mkdir /home/user/docs/private\\", ... \\"addfile /home/user/docs/private secret1.doc 1627853100\\", ... \\"addfile /home/user/docs/private secret2.doc 1627853200\\", ... \\"query /home\\", ... \\"query /home/user/docs\\", ... \\"query /home/user/docs/private\\" ... ]) == [\\"user.txt\\", \\"docs2.txt\\", \\"secret2.doc\\"] >>> process_commands([ ... \\"mkdir /home\\", ... \\"mkdir /home\\", ... \\"mkdir /home/user\\", ... \\"mkdir /home/user\\", ... \\"query /home\\", ... \\"query /home/user\\" ... ]) == [\\"No files found\\", \\"No files found\\"] pass","solution":"class FileSystem: def __init__(self): self.directories = {\\"root\\": {}} self.files = {} def mkdir(self, path): parts = path.split(\\"/\\") current = self.directories for part in parts: if part not in current: current[part] = {} current = current[part] def addfile(self, path, filename, timestamp): self.mkdir(path) if path not in self.files: self.files[path] = [] self.files[path].append((filename, timestamp)) self.files[path] = sorted(self.files[path], key=lambda x: x[1], reverse=True) def query(self, path): if path not in self.files or not self.files[path]: return \\"No files found\\" return self.files[path][0][0] def process_commands(commands): fs = FileSystem() results = [] for command in commands: parts = command.split() if parts[0] == \\"mkdir\\": fs.mkdir(parts[1]) elif parts[0] == \\"addfile\\": path = parts[1] filename = parts[2] timestamp = int(parts[3]) fs.addfile(path, filename, timestamp) elif parts[0] == \\"query\\": results.append(fs.query(parts[1])) return results"},{"question":"def largest_blob(n: int, grid: List[List[int]]) -> int: Determine the size of the largest blob in the grid. >>> grid = [ ... [1, 0, 1, 0, 0], ... [1, 1, 0, 0, 0], ... [0, 0, 1, 1, 1], ... [0, 0, 0, 0, 1], ... [1, 0, 0, 1, 0] ... ] >>> largest_blob(5, grid) 4 >>> grid = [ ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0] ... ] >>> largest_blob(5, grid) 0 >>> grid = [ ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1] ... ] >>> largest_blob(5, grid) 25 >>> grid = [ ... [1, 0, 0, 0, 1], ... [0, 0, 0, 0, 0], ... [0, 0, 1, 0, 0], ... [0, 0, 0, 0, 0], ... [1, 0, 0, 0, 1] ... ] >>> largest_blob(5, grid) 1 >>> grid = [ ... [0, 1, 0, 0, 0], ... [0, 1, 0, 0, 0], ... [0, 1, 0, 0, 0], ... [0, 1, 0, 0, 0], ... [0, 0, 0, 0, 0] ... ] >>> largest_blob(5, grid) 4","solution":"def largest_blob(n, grid): def dfs(x, y): if x < 0 or y < 0 or x >= n or y >= n or grid[x][y] != 1: return 0 grid[x][y] = -1 # Mark the cell as visited size = 1 # Count the current cell # Explore all four possible directions (up, down, left, right) size += dfs(x + 1, y) size += dfs(x - 1, y) size += dfs(x, y + 1) size += dfs(x, y - 1) return size max_blob_size = 0 for i in range(n): for j in range(n): if grid[i][j] == 1: max_blob_size = max(max_blob_size, dfs(i, j)) return max_blob_size"},{"question":"from typing import List def tsp(distance_matrix: List[List[int]]) -> int: Calculate the shortest possible route for the Travelling Salesman Problem that visits each city exactly once and returns to the original city. >>> tsp([ ... [0, 10, 15, 20], ... [10, 0, 35, 25], ... [15, 35, 0, 30], ... [20, 25, 30, 0] ... ]) == 80 >>> tsp([ ... [0, 29, 20], ... [29, 0, 15], ... [20, 15, 0] ... ]) == 64 pass def solve_tsp(test_cases: List[List[List[int]]]) -> List[int]: Solve multiple test cases of the Travelling Salesman Problem. >>> solve_tsp([ ... [ ... [0, 10, 15, 20], ... [10, 0, 35, 25], ... [15, 35, 0, 30], ... [20, 25, 30, 0] ... ], ... [ ... [0, 29, 20], ... [29, 0, 15], ... [20, 15, 0] ... ] ... ]) == [80, 64] pass def parse_input(input_str: str) -> List[List[List[int]]]: Parse input string into a list of test cases for the TSP problem. >>> parse_input(\\"4n0 10 15 20n10 0 35 25n15 35 0 30n20 25 30 0n3n0 29 20n29 0 15n20 15 0n0n\\") [[[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]], [[0, 29, 20], [29, 0, 15], [20, 15, 0]]] pass def main(input_str: str) -> None: Main function to read input, solve the problem, and print the output. >>> main(\\"4n0 10 15 20n10 0 35 25n15 35 0 30n20 25 30 0n3n0 29 20n29 0 15n20 15 0n0n\\") 80 64 pass","solution":"from itertools import permutations def tsp(distance_matrix): N = len(distance_matrix) cities = list(range(N)) min_dist = float('inf') for perm in permutations(cities[1:]): curr_dist = 0 prev_city = 0 for city in perm: curr_dist += distance_matrix[prev_city][city] prev_city = city curr_dist += distance_matrix[prev_city][0] if curr_dist < min_dist: min_dist = curr_dist return min_dist def solve_tsp(test_cases): results = [] for distance_matrix in test_cases: results.append(tsp(distance_matrix)) return results def parse_input(input_str): lines = input_str.strip().split('n') idx = 0 test_cases = [] while idx < len(lines): N = int(lines[idx]) if N == 0: break idx += 1 matrix = [] for _ in range(N): matrix.append(list(map(int, lines[idx].split()))) idx += 1 test_cases.append(matrix) return test_cases def main(input_str): test_cases = parse_input(input_str) results = solve_tsp(test_cases) for result in results: print(result)"},{"question":"def calculate(X, Y, operation): Function that performs a calculation based on the given operation. Args: X (int): First number (1 <= X <= 1000) Y (int): Second number (0 <= Y <= 1000) operation (str): The operation to perform (\\"add\\", \\"subtract\\", \\"multiply\\", \\"divide\\") Returns: result (int/float/str): The result of the calculation, or \\"undefined\\" if division by zero. >>> calculate(5, 3, \\"add\\") 8 >>> calculate(10, 5, \\"subtract\\") 5 >>> calculate(6, 3, \\"divide\\") 2.0 >>> calculate(7, 0, \\"divide\\") \\"undefined\\" def test_calculate_add(): assert calculate(5, 3, \\"add\\") == 8 assert calculate(1000, 0, \\"add\\") == 1000 assert calculate(1, 1, \\"add\\") == 2 def test_calculate_subtract(): assert calculate(10, 5, \\"subtract\\") == 5 assert calculate(100, 50, \\"subtract\\") == 50 assert calculate(1, 1, \\"subtract\\") == 0 def test_calculate_multiply(): assert calculate(5, 3, \\"multiply\\") == 15 assert calculate(100, 0, \\"multiply\\") == 0 assert calculate(7, 7, \\"multiply\\") == 49 def test_calculate_divide(): assert calculate(6, 3, \\"divide\\") == 2.0 assert calculate(10, 5, \\"divide\\") == 2.0 assert calculate(12, 4, \\"divide\\") == 3.0 def test_calculate_divide_by_zero(): assert calculate(6, 0, \\"divide\\") == \\"undefined\\" assert calculate(10, 0, \\"divide\\") == \\"undefined\\"","solution":"def calculate(X, Y, operation): Function that performs a calculation based on the given operation. Args: X (int): First number (1 <= X <= 1000) Y (int): Second number (0 <= Y <= 1000) operation (str): The operation to perform (\\"add\\", \\"subtract\\", \\"multiply\\", \\"divide\\") Returns: result (int/float/str): The result of the calculation, or \\"undefined\\" if division by zero. if operation == \\"add\\": return X + Y elif operation == \\"subtract\\": return X - Y elif operation == \\"multiply\\": return X * Y elif operation == \\"divide\\": if Y == 0: return \\"undefined\\" else: return X / Y else: return \\"Invalid operation\\""},{"question":"from datetime import datetime, timedelta def can_pass_through_gates(N: int, start_time: str, travel_time: int, gates: List[Tuple[str, str]]) -> str: Determines if the spaceship can successfully pass through all the space gates. :param N: Number of space gates :param start_time: Start time of the spaceship in \\"HH:MM\\" format :param travel_time: Travel time between consecutive space gates in minutes :param gates: List of tuples representing open and close times of gates [(open1, close1), (open2, close2), ...] :return: \\"YES\\" if the spaceship can pass through all gates, otherwise \\"NO\\" current_time = datetime.strptime(start_time, \\"%H:%M\\") travel_duration = timedelta(minutes=travel_time) for open_time, close_time in gates: open_time = datetime.strptime(open_time, \\"%H:%M\\") close_time = datetime.strptime(close_time, \\"%H:%M\\") # Arrive at the gate current_time += travel_duration if current_time > close_time: return \\"NO\\" # Wait until the gate opens if necessary if current_time < open_time: current_time = open_time return \\"YES\\" def test_can_pass_all_gates(): N = 4 start_time = \\"08:00\\" travel_time = 60 gates = [ (\\"08:00\\", \\"09:00\\"), (\\"09:00\\", \\"10:00\\"), (\\"10:00\\", \\"11:00\\"), (\\"11:00\\", \\"12:00\\") ] assert can_pass_through_gates(N, start_time, travel_time, gates) == \\"YES\\" def test_no_pass_due_after_close(): N = 3 start_time = \\"10:00\\" travel_time = 30 gates = [ (\\"09:30\\", \\"09:50\\"), (\\"10:20\\", \\"10:40\\"), (\\"11:00\\", \\"11:20\\") ] assert can_pass_through_gates(N, start_time, travel_time, gates) == \\"NO\\" def test_no_pass_due_before_open(): N = 5 start_time = \\"12:00\\" travel_time = 45 gates = [ (\\"12:00\\", \\"12:30\\"), (\\"12:50\\", \\"13:10\\"), (\\"13:35\\", \\"13:50\\"), (\\"14:20\\", \\"14:30\\"), (\\"15:00\\", \\"15:15\\") ] assert can_pass_through_gates(N, start_time, travel_time, gates) == \\"NO\\" def test_edge_case_start_when_gate_opens(): N = 3 start_time = \\"07:00\\" travel_time = 20 gates = [ (\\"07:00\\", \\"07:30\\"), (\\"07:20\\", \\"07:50\\"), (\\"07:40\\", \\"08:10\\") ] assert can_pass_through_gates(N, start_time, travel_time, gates) == \\"YES\\" def test_multiple_gates(): N = 6 start_time = \\"05:30\\" travel_time = 45 gates = [ (\\"06:00\\", \\"06:30\\"), (\\"07:00\\", \\"07:45\\"), (\\"08:00\\", \\"08:30\\"), (\\"09:15\\", \\"09:45\\"), (\\"10:00\\", \\"10:30\\"), (\\"11:00\\", \\"11:30\\") ] assert can_pass_through_gates(N, start_time, travel_time, gates) == \\"YES\\"","solution":"from datetime import datetime, timedelta def can_pass_through_gates(N, start_time, travel_time, gates): Determines if the spaceship can successfully pass through all the space gates. :param N: Number of space gates :param start_time: Start time of the spaceship in \\"HH:MM\\" format :param travel_time: Travel time between consecutive space gates in minutes :param gates: List of tuples representing open and close times of gates [(open1, close1), (open2, close2), ...] :return: \\"YES\\" if the spaceship can pass through all gates, otherwise \\"NO\\" current_time = datetime.strptime(start_time, \\"%H:%M\\") travel_duration = timedelta(minutes=travel_time) for open_time, close_time in gates: open_time = datetime.strptime(open_time, \\"%H:%M\\") close_time = datetime.strptime(close_time, \\"%H:%M\\") # Arrive at the gate current_time += travel_duration if current_time > close_time: return \\"NO\\" # Wait until the gate opens if necessary if current_time < open_time: current_time = open_time return \\"YES\\""},{"question":"def prefix_sums(arr): Returns a list of prefix sums for the given array. ... def range_sum(arr, queries): For each query (l, r) calculate the sum of the elements from the l-th to the r-th position in the list (inclusive). >>> arr = [1, 2, 3, 4, 5] >>> queries = [(1, 3), (2, 4), (1, 5)] >>> range_sum(arr, queries) [6, 9, 15] >>> arr = [-1, -2, 3, 4, 5] >>> queries = [(1, 3), (2, 4), (1, 5)] >>> range_sum(arr, queries) [0, 5, 9] >>> arr = [0, 0, 0, 0, 0] >>> queries = [(1, 1), (1, 5), (2, 4)] >>> range_sum(arr, queries) [0, 0, 0] >>> arr = [10, 20, 30, 40, 50] >>> queries = [(2, 3), (4, 5), (1, 4)] >>> range_sum(arr, queries) [50, 90, 100] >>> arr = [5, 6, 7, 8, 9] >>> queries = [(3, 3), (1, 1), (5, 5)] >>> range_sum(arr, queries) [7, 5, 9] >>> arr = [1, 2, 3, 4, 5] >>> queries = [(1, 5)] >>> range_sum(arr, queries) [15] >>> arr = [1000000000, -1000000000] >>> queries = [(1, 1), (2, 2), (1, 2)] >>> range_sum(arr, queries) [1000000000, -1000000000, 0] >>> arr = [-1000000000, 1000000000] >>> queries = [(1, 1), (2, 2), (1, 2)] >>> range_sum(arr, queries) [-1000000000, 1000000000, 0] ...","solution":"def prefix_sums(arr): Returns a list of prefix sums for the given array. prefix = [0] * (len(arr) + 1) for i in range(1, len(arr) + 1): prefix[i] = prefix[i - 1] + arr[i - 1] return prefix def range_sum(arr, queries): For each query (l, r) calculate the sum of the elements from the l-th to the r-th position in the list (inclusive). prefix = prefix_sums(arr) results = [] for l, r in queries: results.append(prefix[r] - prefix[l - 1]) return results"},{"question":"def count_paths(mazes): Returns a list with the number of distinct paths from the top-left to the bottom-right corner for each maze. >>> count_paths([(3, 3, [['.', '.', '.'], ['.', 'X', '.'], ['.', '.', '.']])]) [2] >>> count_paths([(3, 3, [['X', 'X', '.'], ['.', 'X', '.'], ['.', '.', '.']])]) [0] def parse_input(input_data): Parses the input data and returns a list of mazes. >>> parse_input(\\"2n3 3n...n.X.n...n3 3nXX.n.X.n...n\\") [(3, 3, [['.', '.', '.'], ['.', 'X', '.'], ['.', '.', '.']]), (3, 3, [['X', 'X', '.'], ['.', 'X', '.'], ['.', '.', '.']])] def solve(input_data): Receives input data in string format, parses it, and prints the results of the computation. >>> solve(\\"2n3 3n...n.X.n...n3 3nXX.n.X.n...n\\") \\"2n0n\\" mazes = parse_input(input_data) results = count_paths(mazes) for result in results: print(result)","solution":"def count_paths(mazes): Returns a list with the number of distinct paths from the top-left to the bottom-right corner for each maze. results = [] for maze in mazes: R, C, grid = maze if grid[0][0] == 'X' or grid[R-1][C-1] == 'X': results.append(0) continue dp = [[0] * C for _ in range(R)] dp[0][0] = 1 if grid[0][0] == '.' else 0 for r in range(R): for c in range(C): if grid[r][c] == 'X': dp[r][c] = 0 else: if r > 0: dp[r][c] += dp[r-1][c] if c > 0: dp[r][c] += dp[r][c-1] results.append(dp[R-1][C-1]) return results def parse_input(input_data): Parses the input data and returns a list of mazes. lines = input_data.strip().split('n') T = int(lines[0]) mazes = [] index = 1 for _ in range(T): R, C = map(int, lines[index].split()) grid = [list(lines[index + i + 1]) for i in range(R)] mazes.append((R, C, grid)) index += R + 1 return mazes def solve(input_data): mazes = parse_input(input_data) results = count_paths(mazes) for result in results: print(result)"},{"question":"from typing import List, Tuple def max_waste_flow(N: int, E: int, edges: List[Tuple[int, int, int]]) -> int: Determine the maximum amount of waste that can be treated by the plant from the main waste inlet to the final treatment station. >>> max_waste_flow(4, 5, [(0, 1, 100), (0, 2, 100), (1, 2, 1), (1, 3, 100), (2, 3, 100)]) 200 import pytest from solution import max_waste_flow def test_example_case(): N = 4 E = 5 edges = [ (0, 1, 100), (0, 2, 100), (1, 2, 1), (1, 3, 100), (2, 3, 100) ] assert max_waste_flow(N, E, edges) == 200 def test_disjoint_paths(): N = 4 E = 4 edges = [ (0, 1, 50), (0, 2, 50), (1, 3, 50), (2, 3, 50) ] assert max_waste_flow(N, E, edges) == 100 def test_single_path(): N = 3 E = 2 edges = [ (0, 1, 10), (1, 2, 10) ] assert max_waste_flow(N, E, edges) == 10 def test_bottleneck(): N = 4 E = 4 edges = [ (0, 1, 100), (1, 2, 1), (2, 3, 100), (0, 3, 50) ] assert max_waste_flow(N, E, edges) == 51 def test_large_capacity(): N = 3 E = 2 edges = [ (0, 1, 1000), (1, 2, 1000) ] assert max_waste_flow(N, E, edges) == 1000","solution":"from collections import deque, defaultdict def bfs_capacity(graph, start, end, parent): visited = [False] * len(graph) queue = deque([start]) visited[start] = True while queue: u = queue.popleft() for ind, val in enumerate(graph[u]): if not visited[ind] and val > 0: if ind == end: parent[ind] = u return True queue.append(ind) visited[ind] = True parent[ind] = u return False def edmonds_karp(graph, start, end): parent = [-1] * len(graph) max_flow = 0 while bfs_capacity(graph, start, end, parent): path_flow = float('Inf') s = end while s != start: path_flow = min(path_flow, graph[parent[s]][s]) s = parent[s] max_flow += path_flow v = end while v != start: u = parent[v] graph[u][v] -= path_flow graph[v][u] += path_flow v = parent[v] return max_flow def max_waste_flow(N, E, edges): graph = [[0] * N for _ in range(N)] for u, v, c in edges: graph[u][v] += c return edmonds_karp(graph, 0, N - 1)"},{"question":"def min_shelves(m: int, b: List[int]) -> int: Returns the minimum number of shelves required to perfectly organize the bookshelf. Each shelf must contain books of the same thickness. Arguments: m: int -- the number of books on the shelf b: List[int] -- the thickness of each book Returns: int -- the minimum number of shelves required Examples: >>> min_shelves(6, [3, 3, 2, 2, 2, 3]) 3 >>> min_shelves(4, [5, 5, 5, 5]) 1 >>> min_shelves(5, [1, 2, 3, 4, 5]) 5 from typing import List import unittest class TestMinShelves(unittest.TestCase): def test_single_shelf_all_same_thickness(self): self.assertEqual(min_shelves(4, [5, 5, 5, 5]), 1) def test_all_different_thickness(self): self.assertEqual(min_shelves(5, [1, 2, 3, 4, 5]), 5) def test_mixed_thickness(self): self.assertEqual(min_shelves(6, [3, 3, 2, 2, 2, 3]), 3) def test_single_book(self): self.assertEqual(min_shelves(1, [7]), 1) def test_no_books(self): self.assertEqual(min_shelves(0, []), 0) def test_alternating_thickness(self): self.assertEqual(min_shelves(6, [1, 2, 1, 2, 1, 2]), 6) if __name__ == \\"__main__\\": unittest.main()","solution":"def min_shelves(m, b): Returns the minimum number of shelves required to perfectly organize the bookshelf. if m == 0: return 0 shelves = 1 for i in range(1, m): if b[i] != b[i-1]: shelves += 1 return shelves"},{"question":"def min_cost_to_build_park(n: int, grid: List[List[int]]) -> int: Calculate the minimum possible cost to build the park by selecting a submatrix of any size. >>> min_cost_to_build_park(3, [ ... [3, 1, 4], ... [1, 2, 3], ... [4, 3, 2] ... ]) 1 >>> min_cost_to_build_park(2, [ ... [5, 6], ... [7, 8] ... ]) 5 >>> min_cost_to_build_park(1, [ ... [10] ... ]) 10 >>> min_cost_to_build_park(5, [ ... [10, 7, 2, 4, 3], ... [8, 12, 1, 6, 9], ... [6, 15, 3, 11, 10], ... [5, 2 , 8, 7, 12], ... [3, 9, 4, 14, 1] ... ]) 1 >>> min_cost_to_build_park(3, [ ... [1000, 2000, 3000], ... [4000, 5000, 6000], ... [7000, 8000, 9000] ... ]) 1000","solution":"def min_cost_to_build_park(n, grid): Calculate the minimum possible cost to build the park by selecting a submatrix of any size. The total cost to build the park is the sum of the costs of all cells inside the chosen submatrix. :param n: Size of the city grid (n x n) :param grid: n x n matrix representing the cost of building on each cell. :return: The minimum possible cost to build the park. min_cost = float('inf') for r in range(n): for c in range(n): for i in range(r, n): for j in range(c, n): # Compute the sum of the submatrix from (r, c) to (i, j) current_cost = sum( grid[x][y] for x in range(r, i + 1) for y in range(c, j + 1) ) min_cost = min(min_cost, current_cost) return min_cost"},{"question":"def canAttendMeetings(intervals): Determines if a person can attend all meetings without any overlaps. :param intervals: List of tuples [(start, end), (start, end), ...] :return: Boolean - True if the person can attend all meetings, otherwise False ... def process_input(T, test_cases): Processes the input and returns results for each test case. :param T: Number of test cases :param test_cases: List of test cases, each containing a list of intervals :return: List of strings - \\"YES\\" if the person can attend all meetings, otherwise \\"NO\\" for each test case ... # Example test cases def test_canAttendMeetings(): assert canAttendMeetings([(0, 30), (5, 10)]) == False assert canAttendMeetings([(7, 10), (2, 4), (5, 9)]) == False assert canAttendMeetings([(3, 8), (10, 15)]) == True assert canAttendMeetings([(1, 5), (6, 10), (11, 15)]) == True assert canAttendMeetings([(1, 3), (3, 5), (5, 7)]) == True assert canAttendMeetings([(5, 8), (8, 15), (2, 6)]) == False def test_process_input(): assert process_input(3, [[(0, 30), (5, 10)], [(7, 10), (2, 4), (5, 9)], [(3, 8), (10, 15)]]) == [\\"NO\\", \\"NO\\", \\"YES\\"] assert process_input(2, [[(1, 5), (6, 10), (11, 15)], [(5, 8), (8, 10), (10, 20)]]) == [\\"YES\\", \\"YES\\"] assert process_input(1, [[(1, 2), (2, 3), (2, 4)]]) == [\\"NO\\"]","solution":"def canAttendMeetings(intervals): Determines if a person can attend all meetings without any overlaps. :param intervals: List of tuples [(start, end), (start, end), ...] :return: Boolean - True if the person can attend all meetings, otherwise False # First, sort the intervals by their start times intervals.sort(key=lambda x: x[0]) # Compare each meeting time with the next one to check for overlaps for i in range(len(intervals) - 1): if intervals[i][1] > intervals[i + 1][0]: return False return True def process_input(T, test_cases): results = [] for intervals in test_cases: if canAttendMeetings(intervals): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def organize_journals(n: int, moves: List[Tuple[int, int]]) -> List[int]: Organize the journals in a library by performing a series of swaps. Args: n: An integer representing the number of shelves (or journals). moves: A list of tuples, where each tuple contains two integers representing the shelves to be swapped. Returns: A list of integers representing the final arrangement of the journals after all the swaps. Examples: >>> organize_journals(5, [(1, 2), (2, 3), (4, 5)]) [2, 3, 1, 5, 4] >>> organize_journals(4, []) [1, 2, 3, 4] from typing import List, Tuple # Test cases def test_no_moves(): assert organize_journals(4, []) == [1, 2, 3, 4] def test_single_move(): assert organize_journals(3, [(1, 3)]) == [3, 2, 1] def test_multiple_moves(): assert organize_journals(5, [(1, 2), (2, 3), (4, 5)]) == [2, 3, 1, 5, 4] def test_reverse_order(): assert organize_journals(4, [(1, 4), (2, 3)]) == [4, 3, 2, 1] def test_same_position_moves(): assert organize_journals(3, [(1, 2), (2, 1)]) == [1, 2, 3]","solution":"def organize_journals(n, moves): # Initialize the journals in the order 1 to n journals = list(range(1, n+1)) for a, b in moves: # Swap the journals at index a-1 and b-1 journals[a-1], journals[b-1] = journals[b-1], journals[a-1] return journals"},{"question":"class CircularQueue: Python implementation of a Circular Queue. A circular queue reuses consumed positions in a fixed array to maintain efficiency. Methods: - __init__(self, N): Initializes the circular queue with size N. - enqueue(self, value): Adds a value to the queue. Prints \\"Queue is full\\" if the queue is full. - dequeue(self): Removes and returns the front value. Returns -1 if the queue is empty. - peek(self): Returns the front value without removing it. Returns -1 if the queue is empty. - isEmpty(self): Checks if the queue is empty and returns a boolean. - isFull(self): Checks if the queue is full and returns a boolean. Example: >>> cq = CircularQueue(3) >>> cq.enqueue(1) >>> cq.enqueue(2) >>> cq.enqueue(3) >>> cq.enqueue(4) # Queue is full >>> cq.peek() == 1 >>> cq.dequeue() == 1 >>> cq.dequeue() == 2 >>> cq.dequeue() == 3 >>> cq.dequeue() == -1 >>> cq.isEmpty() == True >>> cq.isFull() == False >>> cq.enqueue(4) >>> cq.peek() == 4 def __init__(self, N): # Initialize the circular queue with the given size N pass def enqueue(self, value): # Add a value to the queue pass def dequeue(self): # Remove and return the front value pass def peek(self): # Return the front value without removing it pass def isEmpty(self): # Check if the queue is empty pass def isFull(self): # Check if the queue is full pass import pytest def test_circular_queue_operations(): cq = CircularQueue(3) # Initial state checks assert cq.isEmpty() == True assert cq.isFull() == False # Enqueue operations cq.enqueue(1) cq.enqueue(2) cq.enqueue(3) cq.enqueue(4) # Should print \\"Queue is full\\" # State checking after enqueues assert cq.isEmpty() == False assert cq.isFull() == True assert cq.peek() == 1 # Dequeue operations assert cq.dequeue() == 1 assert cq.dequeue() == 2 assert cq.dequeue() == 3 assert cq.dequeue() == -1 # Queue should be empty now # State checking after dequeues assert cq.isEmpty() == True assert cq.isFull() == False # Enqueue again after wrap around cq.enqueue(4) assert cq.peek() == 4 def test_peek_empty_queue(): cq = CircularQueue(2) assert cq.peek() == -1 def test_dequeue_empty_queue(): cq = CircularQueue(2) assert cq.dequeue() == -1 def test_full_queue_enqueuing(): cq = CircularQueue(1) cq.enqueue(10) assert cq.isFull() == True cq.enqueue(20) # Should print \\"Queue is full\\" assert cq.peek() == 10","solution":"class CircularQueue: def __init__(self, N): self.size = N self.queue = [None] * N self.front = -1 self.rear = -1 def enqueue(self, value): if self.isFull(): print(\\"Queue is full\\") return if self.isEmpty(): self.front = 0 self.rear = (self.rear + 1) % self.size self.queue[self.rear] = value def dequeue(self): if self.isEmpty(): return -1 value = self.queue[self.front] if self.front == self.rear: self.front = self.rear = -1 else: self.front = (self.front + 1) % self.size return value def peek(self): if self.isEmpty(): return -1 return self.queue[self.front] def isEmpty(self): return self.front == -1 def isFull(self): return (self.rear + 1) % self.size == self.front"},{"question":"def rearrange_items(n: int, k: int, a: List[int]) -> List[int]: Rearranges the array \`a\` so that every subarray of size \`k\` contains the highest-ranking item at the beginning, followed by any permutation of the remaining items in that subarray. Parameters: n (int): Number of items k (int): Size of the subarrays a (list of int): The ranks of the items Returns: list of int: The rearranged array >>> rearrange_items(5, 3, [4, 2, 7, 1, 5]) [7, 4, 2, 5, 1] >>> rearrange_items(8, 2, [8, 6, 4, 7, 3, 9, 1, 2]) [8, 6, 7, 4, 9, 3, 2, 1] from typing import List def test_example_1(): assert rearrange_items(5, 3, [4, 2, 7, 1, 5]) == [7, 4, 2, 5, 1] def test_example_2(): assert rearrange_items(8, 2, [8, 6, 4, 7, 3, 9, 1, 2]) == [8, 6, 7, 4, 9, 3, 2, 1] def test_subarray_length_1(): assert rearrange_items(5, 1, [4, 2, 7, 1, 5]) == [4, 2, 7, 1, 5] def test_subarray_full_length(): assert rearrange_items(5, 5, [4, 2, 7, 1, 5]) == [7, 5, 4, 2, 1] def test_multiple_full_subarrays(): assert rearrange_items(6, 3, [4, 6, 2, 8, 3, 7]) == [6, 4, 2, 8, 7, 3] def test_remainder_subarray(): assert rearrange_items(7, 3, [3, 6, 9, 1, 4, 7, 2]) == [9, 6, 3, 7, 4, 1, 2]","solution":"def rearrange_items(n, k, a): Rearranges the array \`a\` so that every subarray of size \`k\` contains the highest-ranking item at the beginning, followed by any permutation of the remaining items in that subarray. Parameters: n (int): Number of items k (int): Size of the subarrays a (list of int): The ranks of the items Returns: list of int: The rearranged array result = [] for i in range(0, n, k): subarray = a[i:i+k] subarray.sort(reverse=True) result.extend(subarray) return result"},{"question":"from typing import List, Tuple def compute_final_balances(test_cases: List[List[Tuple[str, float, float, str]]]) -> List[List[str]]: Compute the final balances for each customer based on a list of transactions. Args: test_cases (List[List[Tuple[str, float, float, str]]]): List of test cases, each containing a list of transactions. Returns: List[List[str]]: Final balances for each customer, sorted lexicographically by customer's name. Example: >>> transactions = [ ... [(\\"Alice\\", 1.0000, 200.00, \\"deposit\\"), ... (\\"Bob\\", 1.0000, 150.00, \\"deposit\\"), ... (\\"Alice\\", 1.2000, 100.00, \\"withdrawal\\")] ... ] >>> compute_final_balances(transactions) [['Alice: 100.00', 'Bob: 150.00']] pass import pytest def test_simple_transactions(): test_cases = [ [ (\\"Alice\\", 1.0000, 200.00, \\"deposit\\"), (\\"Bob\\", 1.0000, 150.00, \\"deposit\\"), (\\"Alice\\", 1.2000, 100.00, \\"withdrawal\\"), ] ] expected_output = [['Alice: 100.00', 'Bob: 150.00']] assert compute_final_balances(test_cases) == expected_output def test_multiple_transactions(): test_cases = [ [ (\\"Alice\\", 1.0000, 200.00, \\"deposit\\"), (\\"Bob\\", 1.0000, 100.00, \\"deposit\\"), (\\"Bob\\", 1.2000, 50.00, \\"withdrawal\\"), (\\"Alice\\", 2.0000, 300.00, \\"withdrawal\\"), ] ] expected_output = [['Alice: 200.00', 'Bob: 50.00']] assert compute_final_balances(test_cases) == expected_output def test_with_insufficient_funds(): test_cases = [ [ (\\"Alice\\", 1.0000, 200.00, \\"deposit\\"), (\\"Alice\\", 2.0000, 300.00, \\"withdrawal\\"), ] ] expected_output = [['Alice: 200.00']] assert compute_final_balances(test_cases) == expected_output def test_zero_balance_after_transactions(): test_cases = [ [ (\\"Alice\\", 1.0000, 200.00, \\"deposit\\"), (\\"Alice\\", 2.0000, 200.00, \\"withdrawal\\"), ] ] expected_output = [['Alice: 0.00']] assert compute_final_balances(test_cases) == expected_output def test_no_transactions(): test_cases = [[]] expected_output = [[]] assert compute_final_balances(test_cases) == expected_output","solution":"def compute_final_balances(test_cases): result = [] for transactions in test_cases: balances = {} for transaction in transactions: name, timestamp, amount, ttype = transaction amount = float(amount) if name not in balances: balances[name] = 0.0 if ttype == 'deposit': balances[name] += amount elif ttype == 'withdrawal': if balances[name] >= amount: balances[name] -= amount # If withdrawal amount exceeds balance, ignore this transaction # Sort result lexicographically by customer name sorted_balances = sorted(balances.items()) # Format results with exactly 2 decimal places formatted_balances = [f\\"{name}: {balance:.2f}\\" for name, balance in sorted_balances] result.append(formatted_balances) return result"},{"question":"def find_path_with_treasures(grid: List[List[str]]) -> Union[str, List[Tuple[int, int]]]: Alex is organizing a treasure hunt for his friends in his backyard, represented as a 5x5 grid. Each cell in the grid can either be an obstacle, a treasure, or an empty space. Alex needs to start at the top-left corner of the grid and navigate to the bottom-right corner while collecting as many treasures as possible. Alex can only move right or down onto empty spaces or cells containing treasures; he cannot move onto obstacles. Design an algorithm to help Alex find a path that maximizes the number of treasures collected. Return the path as a list of coordinates (row, column) starting from (0,0) to (4,4). If there are multiple paths with the same number of treasures, return any one of them. If it’s impossible to reach the bottom-right corner, return \\"Not Possible\\". Args: grid (List[List[str]]): 5x5 grid with '.' for empty space, '#' for obstacle, 'T' for treasure. Returns: Union[str, List[Tuple[int, int]]]: A path from (0,0) to (4,4) or \\"Not Possible\\" if no path exists. >>> grid = [['.', '.', '.', '.', 'T'], ['.', '#', '#', '.', '.'], ['.', '#', 'T', '#', '.'], ['.', '.', '.', '.', '.'], ['T', '.', '#', '#', '.']] >>> print(find_path_with_treasures(grid)) [(0,0) (0,1) (0,2) (0,3) (0,4) (1,4) (2,4) (3,4) (4,4)] >>> grid = [['.', 'T', '#', 'T', '.'], ['.', '#', '#', '.', '.'], ['.', '#', '.', '#', '.'], ['T', '.', '#', '.', '.'], ['.', 'T', '.', '.', '.']] >>> print(find_path_with_treasures(grid)) [(0,0) (0,1) (1,1) (1,2) (1,3) (1,4) (2,4) (3,4) (4,4)] >>> grid = [['.', '#', '.', 'T', '.'], ['T', '#', '#', '#', '.'], ['.', '.', '.', '.', '#'], ['T', '#', 'T', 'T', '#'], ['.', '.', '#', 'T', '#']] >>> print(find_path_with_treasures(grid)) Not Possible","solution":"def find_path_with_treasures(grid): from queue import PriorityQueue direction = [(0, 1), (1, 0)] # right, down n = len(grid) visited = [[False] * n for _ in range(n)] pq = PriorityQueue() pq.put((-int(grid[0][0] == 'T'), [(0, 0)])) # store negative treasure count for max heap while not pq.empty(): neg_treasures, path = pq.get() x, y = path[-1] treasures = -neg_treasures if (x, y) == (n-1, n-1): return path for dx, dy in direction: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] != '#': visited[nx][ny] = True if grid[nx][ny] == 'T': pq.put((-(treasures + 1), path + [(nx, ny)])) else: pq.put((-treasures, path + [(nx, ny)])) return \\"Not Possible\\""},{"question":"from typing import List def is_combination_possible(resistors: List[float], target: float) -> str: Determines whether a given set of resistors can be combined to achieve the desired resistance value. The combination can be either in series, parallel, or both configurations. Args: resistors: A list of resistances of resistors. target: The desired resistance value. Returns: \\"possible\\" if the combination is achievable, \\"impossible\\" otherwise. Examples: >>> is_combination_possible([2.0, 3.0, 5.0], 10.0) \\"possible\\" >>> is_combination_possible([2.5, 7.5, 10.0, 20.0], 5.0) \\"impossible\\" >>> is_combination_possible([1.0, 1.0, 1.0], 0.5) \\"possible\\" >>> is_combination_possible([100.0], 100.0) \\"possible\\" >>> is_combination_possible([0.1, 0.1], 0.05) \\"possible\\" >>> is_combination_possible([0.1, 0.1], 0.2) \\"possible\\" pass def process_input(input_data: str) -> List[str]: Processes the input data for multiple test cases. Args: input_data: A string containing multiple test cases. Each test case contains the number of resistors, the target resistance, and the resistances of the resistors. Returns: A list of results for each test case, where each result is either \\"possible\\" or \\"impossible\\". Examples: >>> input_data = \\"3 10n2.0 3.0 5.0n4 5n2.5 7.5 10.0 20.0n0 0n\\" >>> process_input(input_data) [\\"possible\\", \\"impossible\\"] >>> input_data = \\"1 100n100.0n1 0.1n0.1n0 0n\\" >>> process_input(input_data) [\\"possible\\", \\"possible\\"] >>> input_data = \\"4 2.5n1.0 1.0 1.0 1.0n0 0n\\" >>> process_input(input_data) [\\"impossible\\"] pass","solution":"def is_combination_possible(resistors, target): from itertools import combinations from itertools import chain n = len(resistors) def series_resistance(comb): return sum(comb) def parallel_resistance(comb): return 1 / sum(1 / r for r in comb) # Generate all non-empty combinations of resistors all_combinations = chain.from_iterable(combinations(resistors, r) for r in range(1, n + 1)) for comb in all_combinations: if abs(series_resistance(comb) - target) < 1e-6 or abs(parallel_resistance(comb) - target) < 1e-6: return \\"possible\\" return \\"impossible\\" def process_input(input_data): lines = input_data.strip().split('n') results = [] i = 0 while i < len(lines): n, target = map(float, lines[i].split()) n = int(n) if n == 0 and target == 0: break resistors = list(map(float, lines[i+1].split())) results.append(is_combination_possible(resistors, target)) i += 2 return results"},{"question":"def has_biodiverse_subgrid(n, m, k, grid): Determines if there exists a subgrid of size m x m that contains at least k different types of trees. :param n: Size of the grid (n x n) :param m: Size of the subgrid (m x m) :param k: Minimum number of tree types required :param grid: 2D list representing the grid :return: \\"YES\\" if such subgrid exists, otherwise \\"NO\\" def test_case_1(): n = 5 m = 3 k = 3 grid = [ [1, 1, 2, 3, 4], [1, 5, 2, 4, 4], [2, 5, 2, 1, 7], [6, 1, 3, 7, 7], [1, 1, 3, 3, 5] ] assert has_biodiverse_subgrid(n, m, k, grid) == \\"YES\\" def test_case_2(): n = 4 m = 2 k = 4 grid = [ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1] ] assert has_biodiverse_subgrid(n, m, k, grid) == \\"NO\\" def test_case_3(): n = 4 m = 2 k = 2 grid = [ [1, 1, 1, 2], [1, 1, 1, 1], [1, 1, 2, 1], [1, 1, 1, 1] ] assert has_biodiverse_subgrid(n, m, k, grid) == \\"YES\\" def test_case_4(): n = 3 m = 3 k = 4 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert has_biodiverse_subgrid(n, m, k, grid) == \\"YES\\" def test_case_5(): n = 6 m = 2 k = 3 grid = [ [1, 2, 2, 2, 2, 2], [1, 3, 3, 3, 3, 3], [1, 2, 2, 2, 2, 2], [1, 3, 3, 3, 3, 3], [1, 2, 2, 2, 2, 2], [1, 3, 3, 3, 3, 3] ] assert has_biodiverse_subgrid(n, m, k, grid) == \\"YES\\" def test_case_6(): n = 1 m = 1 k = 1 grid = [ [1] ] assert has_biodiverse_subgrid(n, m, k, grid) == \\"YES\\" def test_case_7(): n = 5 m = 4 k = 4 grid = [ [1, 2, 3, 1, 1], [1, 2, 2, 1, 1], [1, 1, 1, 1, 1], [1, 3, 4, 1, 1], [1, 3, 1, 1, 1] ] assert has_biodiverse_subgrid(n, m, k, grid) == \\"YES\\"","solution":"def has_biodiverse_subgrid(n, m, k, grid): Determines if there exists a subgrid of size m x m that contains at least k different types of trees. :param n: Size of the grid (n x n) :param m: Size of the subgrid (m x m) :param k: Minimum number of tree types required :param grid: 2D list representing the grid :return: \\"YES\\" if such subgrid exists, otherwise \\"NO\\" for i in range(n - m + 1): for j in range(n - m + 1): tree_types = set() for x in range(i, i + m): for y in range(j, j + m): tree_types.add(grid[x][y]) if len(tree_types) >= k: return \\"YES\\" return \\"NO\\""},{"question":"def contains_cycle(n: int, edges: List[Tuple[int, int]]) -> bool: Determines if an undirected graph represented as an adjacency list contains a cycle. :param n: Number of vertices in the graph :param edges: List of tuples representing the edges of the graph :return: Boolean value indicating whether the graph contains a cycle >>> contains_cycle(5, [(0, 1), (1, 2), (2, 0), (1, 3), (3, 4)]) True >>> contains_cycle(4, [(0, 1), (1, 2), (2, 3)]) False >>> contains_cycle(3, [(0, 1), (1, 2)]) False from typing import List, Tuple def test_no_cycle(): assert contains_cycle(4, [(0, 1), (1, 2), (2, 3)]) == False def test_no_cycle_small_graph(): assert contains_cycle(3, [(0, 1), (1, 2)]) == False def test_cycle(): assert contains_cycle(5, [(0, 1), (1, 2), (2, 0), (1, 3), (3, 4)]) == True def test_cycle_in_line_graph(): assert contains_cycle(4, [(0, 1), (1, 2), (2, 0), (0, 3)]) == True def test_disconnected_graph_with_cycle(): assert contains_cycle(6, [(0, 1), (1, 2), (2, 0), (3, 4)]) == True def test_disconnected_graph_no_cycle(): assert contains_cycle(6, [(0, 1), (2, 3), (4, 5)]) == False def test_single_node_no_edges(): assert contains_cycle(1, []) == False def test_pair_of_nodes_no_cycle(): assert contains_cycle(2, [(0, 1)]) == False def test_complete_graph_three_nodes(): assert contains_cycle(3, [(0, 1), (1, 2), (2, 0)]) == True def test_two_components_with_one_cycle(): assert contains_cycle(5, [(0, 1), (1, 2), (2, 0), (3, 4)]) == True","solution":"def contains_cycle(n, edges): Determines if an undirected graph contains a cycle. :param n: Number of vertices in the graph :param edges: List of tuples representing the edges of the graph :return: Boolean value indicating whether the graph contains a cycle # Create an adjacency list from the edges adjacency_list = [[] for _ in range(n)] for (u, v) in edges: adjacency_list[u].append(v) adjacency_list[v].append(u) # Initialize visited list visited = [False] * n def dfs(v, parent): visited[v] = True for neighbor in adjacency_list[v]: if not visited[neighbor]: if dfs(neighbor, v): return True elif neighbor != parent: return True return False # Check each vertex if it was not visited yet for i in range(n): if not visited[i]: if dfs(i, -1): return True return False"},{"question":"def tournament_rule_checker(n: int, m: int, battles: List[Tuple[int, int]], k: int) -> str: Ensure that no pair of warriors has fought more than k times in the tournament. Args: n : int : The number of participants. m : int : The number of battles. battles : List[Tuple[int, int]] : List of tuples indicating each battle between warriors. k : int : The maximum number of times any pair of warriors is allowed to fight each other. Returns: str : \\"YES\\" if the rule has been followed, \\"NO\\" otherwise. Examples: >>> tournament_rule_checker(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (1, 2)], 2) 'YES' >>> tournament_rule_checker(4, 6, [(1, 2), (1, 2), (1, 3), (1, 3), (1, 3), (2, 4)], 2) 'NO' # Your code here from typing import List, Tuple def test_tournament_rule_checker_cases(): assert tournament_rule_checker(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (1, 2)], 2) == \\"YES\\" assert tournament_rule_checker(4, 6, [(1, 2), (1, 2), (1, 3), (1, 3), (1, 3), (2, 4)], 2) == \\"NO\\" assert tournament_rule_checker(3, 3, [(1, 2), (2, 3), (3, 1)], 1) == \\"YES\\" assert tournament_rule_checker(2, 4, [(1, 2), (1, 2), (1, 2), (1, 2)], 3) == \\"NO\\" assert tournament_rule_checker(6, 4, [(2, 3), (1, 4), (5, 6), (1, 3)], 1) == \\"YES\\" def test_tournament_rule_checker_edge_cases(): assert tournament_rule_checker(2, 1, [(1, 2)], 1) == \\"YES\\" assert tournament_rule_checker(2, 3, [(1, 2), (1, 2), (1, 2)], 2) == \\"NO\\" assert tournament_rule_checker(3, 3, [(1, 2), (1, 3), (2, 3)], 1) == \\"YES\\" assert tournament_rule_checker(4, 6, [(1, 2), (2, 3), (3, 4), (4, 1), (1, 3), (2, 4)], 1) == \\"YES\\" assert tournament_rule_checker(4, 4, [(1, 2), (1, 2), (3, 4), (3, 4)], 2) == \\"YES\\"","solution":"def tournament_rule_checker(n, m, battles, k): from collections import defaultdict pair_count = defaultdict(int) for a, b in battles: if a > b: a, b = b, a pair_count[(a, b)] += 1 for count in pair_count.values(): if count > k: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List def findWords(board: List[List[str]], words: List[str]) -> List[str]: Given a set of words and a grid of characters, find all the words from the set that can be constructed in the grid. The words can be constructed from letters of sequentially adjacent cells, where 'adjacent' cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. Parameters: board (List[List[str]]): The grid of characters. words (List[str]): The set of words to be found. Returns: List[str]: The list of words that can be constructed in the grid. Example: >>> findWords( ... [['o','a','a','n'], ... ['e','t','a','e'], ... ['i','h','k','r'], ... ['i','f','l','v']], ... [\\"oath\\", \\"pea\\", \\"eat\\", \\"rain\\"] ... ) ['oath', 'eat'] from solution import findWords def convert_input_to_board(input_lines): m, n = map(int, input_lines[0].split()) grid = [list(line.strip()) for line in input_lines[1:m+1]] k = int(input_lines[m+1]) words = [line.strip() for line in input_lines[m+2:m+2+k]] return grid, words def test_example_case(): input_lines = [ \\"4 4\\", \\"oaan\\", \\"etae\\", \\"ihkr\\", \\"iflv\\", \\"4\\", \\"oath\\", \\"pea\\", \\"eat\\", \\"rain\\" ] expected_output = set([\\"oath\\", \\"eat\\"]) grid, words = convert_input_to_board(input_lines) assert set(findWords(grid, words)) == expected_output def test_case_all_words_found(): input_lines = [ \\"3 3\\", \\"abc\\", \\"def\\", \\"ghi\\", \\"2\\", \\"abc\\", \\"ghi\\" ] expected_output = set([\\"abc\\", \\"ghi\\"]) grid, words = convert_input_to_board(input_lines) assert set(findWords(grid, words)) == expected_output def test_no_words_found(): input_lines = [ \\"3 3\\", \\"abc\\", \\"def\\", \\"ghi\\", \\"2\\", \\"xyz\\", \\"uvw\\" ] expected_output = set() grid, words = convert_input_to_board(input_lines) assert set(findWords(grid, words)) == expected_output def test_case_overlap_words(): input_lines = [ \\"4 4\\", \\"abac\\", \\"cada\\", \\"aaab\\", \\"bbac\\", \\"3\\", \\"abac\\", \\"ada\\", \\"bac\\" ] expected_output = set([\\"abac\\", \\"ada\\", \\"bac\\"]) grid, words = convert_input_to_board(input_lines) assert set(findWords(grid, words)) == expected_output","solution":"def findWords(board, words): ROWS, COLS = len(board), len(board[0]) # Helper function to perform DFS def backtrack(row, col, parent): letter = board[row][col] curr_node = parent[letter] # Check if we find a word word_match = curr_node.pop(\\"#\\", False) if word_match: res.add(word_match) # Mark the cell as visited board[row][col] = \\"#\\" # Explore the neighbors in 4 directions: up, right, down, left for (row_offset, col_offset) in [(0, 1), (1, 0), (0, -1), (-1, 0)]: new_row, new_col = row + row_offset, col + col_offset if 0 <= new_row < ROWS and 0 <= new_col < COLS: if board[new_row][new_col] in curr_node: backtrack(new_row, new_col, curr_node) # End of exploration, restore the original letter board[row][col] = letter # Optimization: prune the node if it is a leaf if not curr_node: parent.pop(letter) # Build Trie out of the words in the dictionary trie = {} for word in words: node = trie for char in word: node = node.setdefault(char, {}) node[\\"#\\"] = word # Store words in Trie res = set() for row in range(ROWS): for col in range(COLS): if board[row][col] in trie: backtrack(row, col, trie) return list(res)"},{"question":"from typing import List, Tuple def find_provinces(n: int, m: int, roads: List[Tuple[int, int]]) -> Tuple[int, List[List[int]]]: Determine the number of provinces and find out which districts belong to each province. Args: n (int): Number of districts. m (int): Number of roads. roads (List[Tuple[int, int]]): List of tuples representing the roads. Returns: Tuple[int, List[List[int]]]: A tuple containing the number of provinces and a list of districts in each province. Examples: >>> find_provinces(5, 3, [(1, 2), (3, 4), (4, 5)]) (2, [[1, 2], [3, 4, 5]]) >>> find_provinces(4, 2, [(1, 2), (3, 4)]) (2, [[1, 2], [3, 4]]) # Unit Test def test_find_provinces(): num_provinces, provinces = find_provinces(5, 3, [(1, 2), (3, 4), (4, 5)]) assert num_provinces == 2 assert sorted(provinces) == sorted([[1, 2], [3, 4, 5]]) num_provinces, provinces = find_provinces(4, 2, [(1, 2), (3, 4)]) assert num_provinces == 2 assert sorted(provinces) == sorted([[1, 2], [3, 4]]) num_provinces, provinces = find_provinces(3, 0, []) assert num_provinces == 3 assert sorted(provinces) == sorted([[1], [2], [3]]) num_provinces, provinces = find_provinces(3, 3, [(1, 2), (2, 3), (1, 3)]) assert num_provinces == 1 assert sorted(provinces) == sorted([[1, 2, 3]]) num_provinces, provinces = find_provinces(1, 0, []) assert num_provinces == 1 assert sorted(provinces) == sorted([[1]]) num_provinces, provinces = find_provinces(6, 3, [(1, 2), (2, 3), (4, 5)]) assert num_provinces == 3 assert sorted(provinces) == sorted([[1, 2, 3], [4, 5], [6]])","solution":"def find_provinces(n, m, roads): from collections import defaultdict, deque def bfs(start, visited, graph, province): queue = deque([start]) visited[start] = True province.append(start) while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True province.append(neighbor) queue.append(neighbor) graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) provinces = [] for i in range(1, n + 1): if not visited[i]: province = [] bfs(i, visited, graph, province) provinces.append(province) return len(provinces), provinces"},{"question":"def min_path_sum(grid: List[List[int]]) -> int: You are given an n x m grid of random integers. The objective is to move from the top-left corner of the grid to the bottom-right corner in such a way that minimizes the sum of all the values along the path. You are only allowed to move either down or right at any step. >>> min_path_sum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> min_path_sum([ ... [1, 2], ... [1, 1] ... ]) 3 # Unit Tests import unittest class TestMinPathSum(unittest.TestCase): def test_example_cases(self): self.assertEqual(min_path_sum([ [1, 3, 1], [1, 5, 1], [4, 2, 1] ]), 7) self.assertEqual(min_path_sum([ [1, 2], [1, 1] ]), 3) def test_single_row(self): self.assertEqual(min_path_sum([ [1, 2, 3, 4] ]), 10) def test_single_column(self): self.assertEqual(min_path_sum([ [1], [2], [3], [4] ]), 10) def test_single_cell(self): self.assertEqual(min_path_sum([ [5] ]), 5) def test_large_grid(self): grid = [[1 for _ in range(1000)] for _ in range(1000)] self.assertEqual(min_path_sum(grid), 1999) if __name__ == \\"__main__\\": unittest.main()","solution":"def min_path_sum(grid): n = len(grid) m = len(grid[0]) # Create a 2D array to store the minimum path sum for each cell dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Compute the minimum path sum for remaining cells for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][m-1] # Example usage if __name__ == \\"__main__\\": grid1 = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(min_path_sum(grid1)) # Output: 7 grid2 = [ [1, 2], [1, 1] ] print(min_path_sum(grid2)) # Output: 3"},{"question":"from typing import List def can_construct_T(n: int, T: str, components: List[str]) -> str: Determines if the target number can be constructed by concatenating some of the components in any order, each component used at most once. :param n: int - the number of available strings :param T: str - the target number :param components: list of str - the components that can be used to form the target number :return: str - \\"YES\\" if T can be constructed, otherwise \\"NO\\" >>> can_construct_T(3, \\"123456\\", [\\"123\\", \\"456\\", \\"789\\"]) 'YES' >>> can_construct_T(4, \\"1001\\", [\\"10\\", \\"01\\", \\"100\\", \\"100\\"]) 'YES' >>> can_construct_T(2, \\"1111\\", [\\"11\\", \\"12\\"]) 'NO' # Test cases: def test_case_1(): n = 3 T = \\"123456\\" components = [\\"123\\", \\"456\\", \\"789\\"] assert can_construct_T(n, T, components) == \\"YES\\" def test_case_2(): n = 4 T = \\"1001\\" components = [\\"10\\", \\"01\\", \\"100\\", \\"100\\"] assert can_construct_T(n, T, components) == \\"YES\\" def test_case_3(): n = 2 T = \\"1111\\" components = [\\"11\\", \\"12\\"] assert can_construct_T(n, T, components) == \\"NO\\" def test_case_4(): n = 2 T = \\"121212\\" components = [\\"12\\", \\"1212\\"] assert can_construct_T(n, T, components) == \\"YES\\" def test_case_5(): n = 1 T = \\"999\\" components = [\\"999\\"] assert can_construct_T(n, T, components) == \\"YES\\" def test_case_6(): n = 3 T = \\"123123\\" components = [\\"123\\", \\"123\\", \\"456\\"] assert can_construct_T(n, T, components) == \\"YES\\" def test_case_7(): n = 5 T = \\"112233\\" components = [\\"11\\", \\"22\\", \\"33\\", \\"44\\", \\"55\\"] assert can_construct_T(n, T, components) == \\"YES\\" def test_case_8(): n = 3 T = \\"0000\\" components = [\\"0\\", \\"0\\", \\"0\\"] assert can_construct_T(n, T, components) == \\"NO\\"","solution":"from itertools import permutations def can_construct_T(n, T, components): Determines if the target number T can be constructed by concatenating some of the components in any order, each component used at most once. :param n: int - the number of available strings :param T: str - the target number :param components: list of str - the components that can be used to form the target number :return: str - \\"YES\\" if T can be constructed, otherwise \\"NO\\" for i in range(1, n + 1): for perm in permutations(components, i): if ''.join(perm) == T: return \\"YES\\" return \\"NO\\""},{"question":"def smallest_subarray_with_sum_at_least_k(n: int, k: int, array: List[int]) -> int: Returns the length of the smallest subarray with a sum of at least k. If no such subarray exists, returns -1. >>> smallest_subarray_with_sum_at_least_k(5, 11, [1, 2, 3, 4, 5]) == 3 >>> smallest_subarray_with_sum_at_least_k(4, 15, [1, 2, 3, 4]) == -1 >>> smallest_subarray_with_sum_at_least_k(6, 10, [1, 2, 3, 4, 5, 6]) == 2 >>> smallest_subarray_with_sum_at_least_k(5, 5, [5, 5, 5, 5, 5]) == 1 >>> smallest_subarray_with_sum_at_least_k(7, 16, [1, 2, 1, 1, 1, 1, 20]) == 1 >>> smallest_subarray_with_sum_at_least_k(3, 10, [10, 3, 1]) == 1 >>> smallest_subarray_with_sum_at_least_k(3, 21, [7, 7, 7]) == 3","solution":"def smallest_subarray_with_sum_at_least_k(n, k, array): Returns the length of the smallest subarray with a sum of at least k. If no such subarray exists, returns -1. import sys min_length = sys.maxsize current_sum = 0 start = 0 for end in range(n): current_sum += array[end] while current_sum >= k: min_length = min(min_length, end - start + 1) current_sum -= array[start] start += 1 return min_length if min_length != sys.maxsize else -1"},{"question":"def distribute_clothes(clothes, children): Distribute clothes to children such that each child gets one piece of clothing of their size. If an exact match is not available, the next larger size can be used. Args: clothes (List[int]): Sizes of clothes available. children (List[int]): Sizes required by the children. Returns: int: Number of children who will receive clothes. >>> distribute_clothes([1, 2, 3, 4, 5], [2, 3, 5, 6]) 3 >>> distribute_clothes([5, 6, 1, 2], [4, 4, 1, 1, 3]) 4 >>> distribute_clothes([3, 3, 5], [1, 3, 5]) 3 from typing import List def test_example1(): clothes = [1, 2, 3, 4, 5] children = [2, 3, 5, 6] assert distribute_clothes(clothes, children) == 3 def test_example2(): clothes = [5, 6, 1, 2] children = [4, 4, 1, 1, 3] assert distribute_clothes(clothes, children) == 4 def test_example3(): clothes = [3, 3, 5] children = [1, 3, 5] assert distribute_clothes(clothes, children) == 3 def test_no_clothes(): clothes = [] children = [1, 2, 3] assert distribute_clothes(clothes, children) == 0 def test_no_children(): clothes = [1, 2, 3] children = [] assert distribute_clothes(clothes, children) == 0 def test_single_item_match(): clothes = [4] children = [4] assert distribute_clothes(clothes, children) == 1 def test_no_clothes_big_enough(): clothes = [1, 2, 3] children = [4, 5, 6] assert distribute_clothes(clothes, children) == 0 def test_all_children_receive_clothes(): clothes = [2, 3, 4, 5] children = [1, 2, 3, 4] assert distribute_clothes(clothes, children) == 4","solution":"def distribute_clothes(clothes, children): clothes.sort() children.sort() i = 0 j = 0 count = 0 while i < len(clothes) and j < len(children): if clothes[i] >= children[j]: count += 1 j += 1 i += 1 return count"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def delete_node(root: TreeNode, value: int) -> TreeNode: Delete a given node from the BST while preserving the properties of the BST. >>> root = build_tree([5, 3, 6, 2, 4, None, 7]) >>> value = 3 >>> new_root = delete_node(root, value) >>> tree_to_list(new_root) [5, 4, 6, 2, None, None, 7] >>> root = build_tree([5, 3, 6, 2, 4, None, 7]) >>> value = 0 >>> new_root = delete_node(root, value) >>> tree_to_list(new_root) [5, 3, 6, 2, 4, None, 7] # your implementation here def get_min(node: TreeNode) -> TreeNode: Helper function to find the node with the minimum value greater than the node to be deleted. while node.left is not None: node = node.left return node def build_tree(values, index=0): Helper function to build a tree from a list of values. if index >= len(values) or values[index] is None: return None node = TreeNode(values[index]) node.left = build_tree(values, 2*index + 1) node.right = build_tree(values, 2*index + 2) return node def tree_to_list(root): Helper function to convert a tree to a list of values. if not root: return [] result = [] queue = [root] while queue: node = queue.pop(0) if node: result.append(node.val) queue.append(node.left) queue.append(node.right) else: result.append(None) while result and result[-1] is None: result.pop() return result def test_delete_node_case1(): root = build_tree([5, 3, 6, 2, 4, None, 7]) expected_output = [5, 4, 6, 2, None, None, 7] new_root = delete_node(root, 3) assert tree_to_list(new_root) == expected_output def test_delete_node_case2(): root = build_tree([5, 3, 6, 2, 4, None, 7]) expected_output = [5, 3, 6, 2, 4, None, 7] new_root = delete_node(root, 0) assert tree_to_list(new_root) == expected_output def test_delete_node_root(): root = build_tree([5, 3, 6, 2, 4, None, 7]) expected_output = [6, 3, 7, 2, 4] new_root = delete_node(root, 5) assert tree_to_list(new_root) == expected_output def test_delete_node_with_no_children(): root = build_tree([5, 3, 6, 2, 4, None, 7]) expected_output = [5, 3, 6, 2, None, None, 7] new_root = delete_node(root, 4) assert tree_to_list(new_root) == expected_output def test_delete_node_with_one_child(): root = build_tree([5, 3, 6, 2, None, None, 7]) expected_output = [5, 2, 6, None, None, None, 7] new_root = delete_node(root, 3) assert tree_to_list(new_root) == expected_output","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def delete_node(root: TreeNode, value: int) -> TreeNode: if root is None: return None if value < root.val: root.left = delete_node(root.left, value) elif value > root.val: root.right = delete_node(root.right, value) else: if root.left is None: return root.right elif root.right is None: return root.left min_larger_node = get_min(root.right) root.val = min_larger_node.val root.right = delete_node(root.right, root.val) return root def get_min(node: TreeNode) -> TreeNode: while node.left is not None: node = node.left return node"},{"question":"def perform_operations(n, sequence, m, operations): Perform a list of operations on a sequence of integers. :param n: int, number of elements in the sequence :param sequence: list of int, the sequence of integers :param m: int, number of operations :param operations: list of tuples, each operation in the form (\\"operation_type\\", x, y) :return: list of int, the final sequence after performing all operations >>> perform_operations(5, [1, 2, 3, 4, 5], 3, [(\\"increase\\", 1, 3), (\\"decrease\\", 2, 4), (\\"increase\\", 1, 5)]) [3, 3, 4, 4, 6] >>> perform_operations(5, [1, 1, 1, 1, 1], 1, [(\\"increase\\", 1, 5)]) [2, 2, 2, 2, 2] >>> perform_operations(5, [1, 1, 1, 1, 1], 1, [(\\"decrease\\", 1, 5)]) [0, 0, 0, 0, 0] >>> perform_operations(5, [2, 2, 2, 2, 2], 0, []) [2, 2, 2, 2, 2] >>> perform_operations(1, [1], 1, [(\\"increase\\", 1, 1)]) [2] >>> perform_operations(1, [1], 1, [(\\"decrease\\", 1, 1)]) [0] >>> perform_operations(5, [1, 2, 3, 4, 5], 2, [(\\"decrease\\", 1, 3), (\\"increase\\", 3, 5)]) [0, 1, 3, 5, 6]","solution":"def perform_operations(n, sequence, m, operations): Perform a list of operations on a sequence of integers. :param n: int, number of elements in the sequence :param sequence: list of int, the sequence of integers :param m: int, number of operations :param operations: list of tuples, each operation in the form (\\"operation_type\\", x, y) :return: list of int, the final sequence after performing all operations for operation, x, y in operations: if operation == \\"increase\\": for i in range(x - 1, y): sequence[i] += 1 elif operation == \\"decrease\\": for i in range(x - 1, y): sequence[i] -= 1 return sequence"},{"question":"from collections import defaultdict from typing import List, Tuple class TreeSum: def __init__(self, n, edges): self.tree = defaultdict(list) self.subtree_sum = [0] * (n + 1) self.visited = [False] * (n + 1) for x, y in edges: self.tree[x].append(y) self.tree[y].append(x) self._dfs(1) def _dfs(self, node): pass def query(self, u): pass def solve_tree_queries(n: int, edges: List[Tuple[int, int]], queries: List[int]) -> List[int]: Given a tree with n nodes and n-1 edges, and a list of Q queries where each query asks for the sum of nodes within a given subtree, return the results of the queries. >>> solve_tree_queries(8, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7), (4, 8)], [2, 3, 1]) [19, 16, 36] >>> solve_tree_queries(1, [], [1]) [1] tree_sum = TreeSum(n, edges) results = [] for u in queries: results.append(tree_sum.query(u)) return results def test_example_case(): n = 8 edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7), (4, 8)] queries = [2, 3, 1] assert solve_tree_queries(n, edges, queries) == [19, 16, 36] def test_single_node_tree(): n = 1 edges = [] queries = [1] assert solve_tree_queries(n, edges, queries) == [1] def test_linear_tree(): n = 5 edges = [(1, 2), (2, 3), (3, 4), (4, 5)] queries = [3, 4, 1] assert solve_tree_queries(n, edges, queries) == [12, 9, 15] def test_star_tree(): n = 5 edges = [(1, 2), (1, 3), (1, 4), (1, 5)] queries = [1, 2, 5] assert solve_tree_queries(n, edges, queries) == [15, 2, 5] def test_large_tree(): n = 7 edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)] queries = [1, 2, 3, 4, 5, 6, 7] assert solve_tree_queries(n, edges, queries) == [28, 11, 16, 4, 5, 6, 7]","solution":"from collections import defaultdict class TreeSum: def __init__(self, n, edges): self.tree = defaultdict(list) self.subtree_sum = [0] * (n + 1) self.visited = [False] * (n + 1) for x, y in edges: self.tree[x].append(y) self.tree[y].append(x) self._dfs(1) def _dfs(self, node): self.visited[node] = True self.subtree_sum[node] = node # start with the value of the node itself for neighbor in self.tree[node]: if not self.visited[neighbor]: self._dfs(neighbor) self.subtree_sum[node] += self.subtree_sum[neighbor] def query(self, u): return self.subtree_sum[u] def solve_tree_queries(n, edges, queries): tree_sum = TreeSum(n, edges) results = [] for u in queries: results.append(tree_sum.query(u)) return results"},{"question":"def compute_lcs(str1: str, str2: str) -> str: Write a program to compute the longest common subsequence (LCS) of two given strings. The length of the strings can be up to 100 characters. The subsequence does not need to be contiguous in the original strings, but the order must be preserved. A subsequence is a sequence that appears in the same relative order, but not necessarily consecutively. For instance, \\"abc\\", \\"abg\\", \\"bdf\\", \\"aeg\\", \\"acefg\\", .. etc are subsequences of \\"abcdefg\\". If there are multiple longest common subsequences with the same length, the lexicographically smallest one should be returned. If no common subsequence exists, return an empty string (i.e., a new line). >>> compute_lcs(\\"abcde\\", \\"ace\\") 'ace' >>> compute_lcs(\\"abc\\", \\"def\\") '' >>> compute_lcs(\\"abcdefgh\\", \\"acefh\\") 'acefh' >>> compute_lcs(\\"abc\\", \\"xyz\\") '' >>> compute_lcs(\\"a\\", \\"a\\") 'a' >>> compute_lcs(\\"abc\\", \\"a\\") 'a' >>> compute_lcs(\\"abc\\", \\"c\\") 'c' >>> compute_lcs(\\"abc\\", \\"abc\\") 'abc' >>> compute_lcs(\\"abracadabra\\", \\"abracadabra\\") 'abracadabra' >>> compute_lcs(\\"abcabc\\", \\"abracb\\") 'abcb' >>> compute_lcs(\\"abazdc\\", \\"bacbad\\") 'abad' >>> compute_lcs(\\"a\\" * 50 + \\"b\\" * 50, \\"a\\" * 60 + \\"b\\" * 40) 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb'","solution":"def compute_lcs(str1, str2): Returns the longest common subsequence of str1 and str2. If there are multiple longest common subsequences, returns the lexicographically smallest one. m = len(str1) n = len(str2) # Create a 2D array to store the length of LCS lcs = [[0] * (n + 1) for _ in range(m + 1)] # Fill the lcs array for i in range(m): for j in range(n): if str1[i] == str2[j]: lcs[i+1][j+1] = lcs[i][j] + 1 else: lcs[i+1][j+1] = max(lcs[i+1][j], lcs[i][j+1]) # Now reconstruct the LCS from the lcs array result = [] x, y = m, n while x != 0 and y != 0: if lcs[x][y] == lcs[x-1][y]: x -= 1 elif lcs[x][y] == lcs[x][y-1]: y -= 1 else: result.append(str1[x-1]) x -= 1 y -= 1 return ''.join(result[::-1]) import sys def main(): input_pairs = sys.stdin.read().strip().split() input_pairs = [input_pairs[i:i + 2] for i in range(0, len(input_pairs), 2)] for pair in input_pairs: print(compute_lcs(pair[0], pair[1])) if __name__ == \\"__main__\\": main()"},{"question":"def max_bikes(f, h, s, w, c): Returns the maximum number of bikes that can be assembled with given parts. Each bike must have exactly: - 1 frame - 1 handlebar - 1 seat - 2 wheels - 1 chain Parameters: f (int): Number of frames available. h (int): Number of handlebars available. s (int): Number of seats available. w (int): Number of wheels available. c (int): Number of chains available. Returns: int: The maximum number of bikes that can be assembled. pass from solution import max_bikes def test_example_cases(): assert max_bikes(5, 7, 6, 14, 8) == 5 assert max_bikes(3, 3, 3, 6, 3) == 3 def test_not_enough_wheels(): assert max_bikes(5, 5, 5, 9, 5) == 4 assert max_bikes(5, 5, 5, 8, 5) == 4 def test_equal_number_of_parts(): assert max_bikes(10, 10, 10, 20, 10) == 10 assert max_bikes(1, 1, 1, 2, 1) == 1 def test_one_type_is_scarce(): assert max_bikes(4, 5, 6, 12, 3) == 3 assert max_bikes(4, 5, 2, 8, 4) == 2 def test_large_numbers(): assert max_bikes(1000, 1000, 1000, 2000, 1000) == 1000 assert max_bikes(1000, 999, 1000, 2000, 1000) == 999 assert max_bikes(1000, 1000, 1000, 1999, 1000) == 999 assert max_bikes(999, 1000, 999, 2000, 1000) == 999 assert max_bikes(1000, 1000, 1000, 1998, 1000) == 999","solution":"def max_bikes(f, h, s, w, c): Returns the maximum number of bikes that can be assembled with given parts. Each bike must have exactly: - 1 frame - 1 handlebar - 1 seat - 2 wheels - 1 chain Parameters: f (int): Number of frames available. h (int): Number of handlebars available. s (int): Number of seats available. w (int): Number of wheels available. c (int): Number of chains available. Returns: int: The maximum number of bikes that can be assembled. return min(f, h, s, w // 2, c)"},{"question":"def categorize_runners(n: int, runners: List[Tuple[int, int]]) -> List[Tuple[int, str]]: Assign each runner to the appropriate category based on their age and return a list of tuples with bib number and category, sorted by bib number. >>> categorize_runners(5, [(102, 10), (203, 25), (150, 55), (101, 13), (302, 70)]) [(101, \\"Juniors\\"), (102, \\"Juniors\\"), (150, \\"Seniors\\"), (203, \\"Adults\\"), (302, \\"Seniors\\")] >>> categorize_runners(3, [(1, 60), (2, 70), (3, 80)]) [(1, \\"Seniors\\"), (2, \\"Seniors\\"), (3, \\"Seniors\\")] from typing import List, Tuple def test_sample_case(): runners = [(102, 10), (203, 25), (150, 55), (101, 13), (302, 70)] expected_output = [ (101, \\"Juniors\\"), (102, \\"Juniors\\"), (150, \\"Seniors\\"), (203, \\"Adults\\"), (302, \\"Seniors\\") ] assert categorize_runners(5, runners) == expected_output def test_all_juniors(): runners = [(1, 12), (2, 14), (3, 13)] expected_output = [ (1, \\"Juniors\\"), (2, \\"Juniors\\"), (3, \\"Juniors\\"), ] assert categorize_runners(3, runners) == expected_output def test_all_adults(): runners = [(1, 20), (2, 30), (3, 40)] expected_output = [ (1, \\"Adults\\"), (2, \\"Adults\\"), (3, \\"Adults\\"), ] assert categorize_runners(3, runners) == expected_output def test_all_seniors(): runners = [(1, 60), (2, 70), (3, 80)] expected_output = [ (1, \\"Seniors\\"), (2, \\"Seniors\\"), (3, \\"Seniors\\"), ] assert categorize_runners(3, runners) == expected_output def test_mixed_categories_sorted_input(): runners = [(1, 10), (2, 25), (3, 55), (4, 13), (5, 70)] expected_output = [ (1, \\"Juniors\\"), (2, \\"Adults\\"), (3, \\"Seniors\\"), (4, \\"Juniors\\"), (5, \\"Seniors\\"), ] assert categorize_runners(5, runners) == expected_output def test_mixed_categories_unsorted_input(): runners = [(4, 13), (1, 10), (5, 70), (2, 25), (3, 55)] expected_output = [ (1, \\"Juniors\\"), (2, \\"Adults\\"), (3, \\"Seniors\\"), (4, \\"Juniors\\"), (5, \\"Seniors\\"), ] assert categorize_runners(5, runners) == expected_output","solution":"def categorize_runners(n, runners): def categorize(age): if age <= 14: return \\"Juniors\\" elif 15 <= age <= 50: return \\"Adults\\" else: return \\"Seniors\\" sorted_runners = sorted(runners, key=lambda x: x[0]) return [(bib, categorize(age)) for bib, age in sorted_runners]"},{"question":"from collections import deque from typing import List def min_moves(n: int, m: int, grid: List[List[str]]) -> int: Returns the minimum number of moves required to travel from the top-left corner to the bottom-right corner of the grid. If it's not possible, returns -1. >>> min_moves(3, 3, [ ... ['.', '.', '.'], ... ['.', '#', '.'], ... ['.', '.', '.']]) 4 >>> min_moves(3, 3, [ ... ['.', '#', '.'], ... ['#', '#', '.'], ... ['.', '.', '.']]) -1 >>> min_moves(1, 1, [['.']]) 0 >>> min_moves(1, 1, [['#']]) -1 # Directions (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Check if the starting or ending positions are blocked if grid[0][0] == '#' or grid[n-1][m-1] == '#': return -1 # Initialize queue for BFS with starting position queue = deque([(0, 0)]) # Distance matrix to keep track of the minimum moves dist = [[float('inf')] * m for _ in range(n)] dist[0][0] = 0 while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy # Check if the new position is within bounds and walkable if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.' and dist[nx][ny] == float('inf'): queue.append((nx, ny)) dist[nx][ny] = dist[x][y] + 1 # If we reach the bottom-right corner, return the distance if nx == n-1 and ny == m-1: return dist[nx][ny] return -1 if dist[n-1][m-1] == float('inf') else dist[n-1][m-1] def test_min_moves_simple(): grid = [ ['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.'] ] assert min_moves(3, 3, grid) == 4 def test_min_moves_blocked(): grid = [ ['.', '#', '.'], ['#', '#', '.'], ['.', '.', '.'] ] assert min_moves(3, 3, grid) == -1 def test_min_moves_complex(): grid = [ ['.', '.', '.', '#', '.', '.', '.'], ['.', '#', '.', '#', '.', '#', '.'], ['.', '#', '.', '.', '.', '#', '.'], ['.', '.', '#', '#', '.', '#', '.'], ['.', '#', '.', '.', '.', '.', '.'] ] assert min_moves(5, 7, grid) == 10 def test_min_moves_single_cell_walkable(): grid = [['.']] assert min_moves(1, 1, grid) == 0 def test_min_moves_single_cell_blocked(): grid = [['#']] assert min_moves(1, 1, grid) == -1 def test_min_moves_no_path(): grid = [ ['.', '.', '#'], ['#', '#', '#'], ['#', '.', '.'] ] assert min_moves(3, 3, grid) == -1","solution":"from collections import deque def min_moves(n, m, grid): Returns the minimum number of moves required to travel from the top-left corner to the bottom-right corner of the grid. If it's not possible, returns -1. # Directions (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Check if the starting or ending positions are blocked if grid[0][0] == '#' or grid[n-1][m-1] == '#': return -1 # Initialize queue for BFS with starting position queue = deque([(0, 0)]) # Distance matrix to keep track of the minimum moves dist = [[float('inf')] * m for _ in range(n)] dist[0][0] = 0 while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy # Check if the new position is within bounds and walkable if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.' and dist[nx][ny] == float('inf'): queue.append((nx, ny)) dist[nx][ny] = dist[x][y] + 1 # If we reach the bottom-right corner, return the distance if nx == n-1 and ny == m-1: return dist[nx][ny] return -1 if dist[n-1][m-1] == float('inf') else dist[n-1][m-1]"},{"question":"def max_herbs_collected(n: int, m: int, E: int, portals: List[Tuple[int, int, int]], herbs: List[str]) -> int: Determine the maximum number of different types of herbs the herbologist can collect starting from garden 1 without exceeding the given energy E. >>> max_herbs_collected(5, 6, 10, [(1, 2, 3), (1, 3, 2), (2, 3, 1), (2, 4, 5), (3, 4, 6), (4, 5, 3)], [\\"rose\\", \\"tulip\\", \\"daisy\\", \\"lily\\", \\"orchid\\"]) 4 >>> max_herbs_collected(3, 3, 5, [(1, 2, 3), (2, 3, 2), (1, 3, 4)], [\\"lavender\\", \\"marigold\\", \\"sunflower\\"]) 3 from typing import List, Tuple def test_example_1(): n = 5 m = 6 E = 10 portals = [ (1, 2, 3), (1, 3, 2), (2, 3, 1), (2, 4, 5), (3, 4, 6), (4, 5, 3) ] herbs = [ \\"rose\\", \\"tulip\\", \\"daisy\\", \\"lily\\", \\"orchid\\" ] assert max_herbs_collected(n, m, E, portals, herbs) == 4 def test_example_2(): n = 3 m = 3 E = 5 portals = [ (1, 2, 3), (2, 3, 2), (1, 3, 4) ] herbs = [ \\"lavender\\", \\"marigold\\", \\"sunflower\\" ] assert max_herbs_collected(n, m, E, portals, herbs) == 3 def test_single_garden(): n = 1 m = 0 E = 1 portals = [] herbs = [\\"dandelion\\"] assert max_herbs_collected(n, m, E, portals, herbs) == 1 def test_no_energy(): n = 3 m = 2 E = 0 portals = [ (1, 2, 1), (2, 3, 1) ] herbs = [ \\"begonia\\", \\"geranium\\", \\"pansy\\" ] assert max_herbs_collected(n, m, E, portals, herbs) == 1 def test_no_portals(): n = 4 m = 0 E = 10 portals = [] herbs = [ \\"rosemary\\", \\"thyme\\", \\"sage\\", \\"mint\\" ] assert max_herbs_collected(n, m, E, portals, herbs) == 1","solution":"import heapq def max_herbs_collected(n, m, E, portals, herbs): graph = [[] for _ in range(n + 1)] for u, v, c in portals: graph[u].append((v, c)) graph[v].append((u, c)) energy = [float('inf')] * (n + 1) energy[1] = 0 pq = [(0, 1)] visited_herbs = set() while pq: curr_energy, node = heapq.heappop(pq) if curr_energy > E: continue if herbs[node - 1] not in visited_herbs: visited_herbs.add(herbs[node - 1]) for neighbor, cost in graph[node]: if curr_energy + cost < energy[neighbor]: energy[neighbor] = curr_energy + cost heapq.heappush(pq, (curr_energy + cost, neighbor)) return len(visited_herbs)"},{"question":"from typing import List, Dict, Optional def find_first_critical_event(logs: List[Dict[str, str]], event_type: str) -> Optional[Dict[str, str]]: Processes logs and identifies the first occurrence of a specific critical event type based on the timestamp. Args: logs: List of dictionaries, each containing: - 'timestamp' (string, format 'YYYY-MM-DDTHH:MM:SS') - 'server' (string) - 'message' (string) event_type: A string that specifies the event type to search for in the message field of each log entry. Returns: A dictionary with the following keys: - 'timestamp': The timestamp of the first occurrence of the critical event. - 'server': The server from which the critical event log originated. - 'message': The message of the first occurrence of the critical event. If the event type is not found in any of the logs, return None. >>> logs = [ ... {\\"timestamp\\": \\"2023-10-01T12:01:00\\", \\"server\\": \\"server_1\\", \\"message\\": \\"Normal operation started.\\"}, ... {\\"timestamp\\": \\"2023-10-01T12:04:00\\", \\"server\\": \\"server_2\\", \\"message\\": \\"Critical event occurred.\\"}, ... {\\"timestamp\\": \\"2023-10-01T12:02:00\\", \\"server\\": \\"server_3\\", \\"message\\": \\"Normal operation started.\\"}, ... {\\"timestamp\\": \\"2023-10-01T12:03:00\\", \\"server\\": \\"server_1\\", \\"message\\": \\"Critical event occurred.\\"} ... ] >>> event_type = \\"Critical event\\" >>> find_first_critical_event(logs, event_type) {\\"timestamp\\": \\"2023-10-01T12:03:00\\", \\"server\\": \\"server_1\\", \\"message\\": \\"Critical event occurred.\\"} >>> logs = [ ... {\\"timestamp\\": \\"2023-10-01T12:01:00\\", \\"server\\": \\"server_1\\", \\"message\\": \\"Normal operation started.\\"}, ... {\\"timestamp\\": \\"2023-10-01T12:04:00\\", \\"server\\": \\"server_2\\", \\"message\\": \\"Routine maintenance.\\"}, ... {\\"timestamp\\": \\"2023-10-01T12:02:00\\", \\"server\\": \\"server_3\\", \\"message\\": \\"Normal operation started.\\"}, ... {\\"timestamp\\": \\"2023-10-01T12:03:00\\", \\"server\\": \\"server_1\\", \\"message\\": \\"Routine maintenance completed.\\"} ... ] >>> event_type = \\"Critical event\\" >>> find_first_critical_event(logs, event_type) None","solution":"from datetime import datetime def find_first_critical_event(logs, event_type): first_occurrence = None for log in logs: if event_type in log['message']: log_time = datetime.fromisoformat(log['timestamp']) if first_occurrence is None or log_time < first_occurrence['timestamp']: first_occurrence = { 'timestamp': log_time, 'server': log['server'], 'message': log['message'] } if first_occurrence: first_occurrence['timestamp'] = first_occurrence['timestamp'].isoformat() return first_occurrence"},{"question":"class NumArray: Design a data structure that supports the following operations efficiently: 1. Update the value at a specific index in an array. 2. Find the sum of elements in a given range [L, R]. Implement the \`NumArray\` class with the following methods: - \`NumArray(int[] nums)\`: Initializes the object with the integer array \`nums\`. - \`void update(int index, int val)\`: Updates the value of \`nums\` at the index \`index\` to be \`val\`. - \`int sumRange(int left, int right)\`: Returns the sum of elements \`nums\` between indices \`left\` and \`right\` inclusive. The class should be implemented in such a way that both methods \`update\` and \`sumRange\` run in a time complexity better than the naive O(n) approach, which is straightforward array traversal. >>> na = NumArray([1, 3, 5, 7, 9]) >>> na.sumRange(0, 2) 9 >>> na.update(1, 2) >>> na.sumRange(0, 2) 8 >>> na.update(2, 5) >>> na.sumRange(0, 2) 8 def __init__(self, nums): Initializes the object with the integer array nums. def update(self, index, val): Updates the value of nums at the index to be val. def sumRange(self, left, right): Returns the sum of elements between indices left and right inclusive. import pytest def test_initial_sum(): na = NumArray([1, 3, 5, 7, 9]) assert na.sumRange(0, 2) == 9 def test_update_and_sum(): na = NumArray([1, 3, 5, 7, 9]) na.update(1, 2) assert na.sumRange(0, 2) == 8 def test_update_no_effect(): na = NumArray([1, 3, 5, 7, 9]) na.update(2, 5) assert na.sumRange(0, 2) == 9 def test_multiple_updates_and_sums(): na = NumArray([1, 3, 5, 7, 9]) na.update(1, 2) assert na.sumRange(0, 2) == 8 na.update(2, 6) assert na.sumRange(0, 2) == 9 na.update(4, 10) assert na.sumRange(0, 4) == 26","solution":"class NumArray: def __init__(self, nums): Initializes the object with the integer array nums. self.n = len(nums) self.tree = [0] * (self.n * 2) self.build_tree(nums) def build_tree(self, nums): # Build the tree by copying the nums array into the second half of tree array for i in range(self.n): self.tree[self.n + i] = nums[i] # Build the tree by calculating the parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def update(self, index, val): Updates the value of nums at the index to be val. pos = self.n + index self.tree[pos] = val # Update the parents while pos > 1: pos //= 2 self.tree[pos] = self.tree[pos * 2] + self.tree[pos * 2 + 1] def sumRange(self, left, right): Returns the sum of elements between indices left and right inclusive. l = self.n + left r = self.n + right summ = 0 while l <= r: if l % 2 == 1: summ += self.tree[l] l += 1 if r % 2 == 0: summ += self.tree[r] r -= 1 l //= 2 r //= 2 return summ"},{"question":"class ArrayOperations: def __init__(self, arr): Initialize the ArrayOperations with the given array. self.arr = arr def get_sum(self, l, r): Return the sum of the integer values within the subarray ranging from the l-th index to the r-th index inclusive. Args: l (int): The starting index of the subarray. r (int): The ending index of the subarray. Returns: int: The sum of the subarray elements. def update(self, i, x): Update the value at the i-th index of the array to x. Args: i (int): The index to be updated. x (int): The new value to be set at index i. def process_queries(n, q, arr, queries): Process a series of queries on the given array. Args: n (int): Length of the array. q (int): Number of queries. arr (List[int]): The array of integers. queries (List[Tuple[int, int, int]]): The list of queries, where each query is either of the form (0, l, r) or (1, i, x). Returns: List[int]: The results of the get_sum queries. array_ops = ArrayOperations(arr) results = [] for query in queries: if query[0] == 0: # get_sum operation l, r = query[1], query[2] results.append(array_ops.get_sum(l, r)) elif query[0] == 1: # update operation i, x = query[1], query[2] array_ops.update(i, x) return results # Test cases to validate the solution def test_single_get_sum(): n = 5 q = 1 arr = [1, 2, 3, 4, 5] queries = [(0, 0, 4)] expected = [15] assert process_queries(n, q, arr, queries) == expected def test_update_and_get_sum(): n = 5 q = 3 arr = [1, 2, 3, 4, 5] queries = [(0, 1, 3), (1, 2, 10), (0, 1, 3)] expected = [9, 16] assert process_queries(n, q, arr, queries) == expected def test_multiple_updates(): n = 5 q = 4 arr = [1, 2, 3, 4, 5] queries = [(1, 0, 10), (1, 4, 20), (0, 0, 4), (0, 1, 3)] expected = [39, 9] # New arr: [10, 2, 3, 4, 20] assert process_queries(n, q, arr, queries) == expected def test_no_operations(): n = 5 q = 0 arr = [1, 2, 3, 4, 5] queries = [] expected = [] assert process_queries(n, q, arr, queries) == expected","solution":"class ArrayOperations: def __init__(self, arr): self.arr = arr def get_sum(self, l, r): return sum(self.arr[l:r+1]) def update(self, i, x): self.arr[i] = x def process_queries(n, q, arr, queries): array_ops = ArrayOperations(arr) results = [] for query in queries: if query[0] == 0: # get_sum operation l, r = query[1], query[2] results.append(array_ops.get_sum(l, r)) elif query[0] == 1: # update operation i, x = query[1], query[2] array_ops.update(i, x) return results # Example usage: if __name__ == \\"__main__\\": n = 5 q = 3 arr = [1, 2, 3, 4, 5] queries = [ (0, 1, 3), (1, 2, 10), (0, 1, 3) ] result = process_queries(n, q, arr, queries) for res in result: print(res) # Output should be 9 and 16"},{"question":"from typing import List, Tuple def min_difference_variance(cases: List[Tuple[int, List[int]]]) -> List[str]: Given a sequence of N integers, determine the smallest possible 'difference variance'. The difference variance of a sequence is defined as the difference between the maximum and minimum elements in the sequence. You are only allowed to perform one type of operation: select any two distinct elements in the sequence, and swap their positions. Args: cases: A list of tuples, where each tuple contains an integer N and a list of N integers. Returns: A list of strings in the format 'Case #x: y' where x is the case number and y is the minimum possible difference variance. >>> min_difference_variance([(5, [1, 3, 6, 10, 15]), (4, [7, -8, 5, 9]), (6, [4, 4, 4, 4, 4, 4])]) ['Case #1: 14', 'Case #2: 17', 'Case #3: 0'] >>> min_difference_variance([(2, [100, -100]), (4, [1, 1, 1, 1])]) ['Case #1: 200', 'Case #2: 0'] pass def parse_input(input_str: str) -> List[Tuple[int, List[int]]]: Parse the input string and convert it to a list of tuples. Args: input_str: A string containing the number of test cases followed by each test case in a new line. Returns: A list of tuples, where each tuple contains an integer N and a list of N integers. >>> parse_input(\\"3n5 1 3 6 10 15n4 7 -8 5 9n6 4 4 4 4 4 4\\") [(5, [1, 3, 6, 10, 15]), (4, [7, -8, 5, 9]), (6, [4, 4, 4, 4, 4, 4])] >>> parse_input(\\"2n3 100 -100 100n4 1 1 1 1\\") [(3, [100, -100, 100]), (4, [1, 1, 1, 1])] pass","solution":"def min_difference_variance(cases): results = [] for index, case in enumerate(cases): N, numbers = case[0], case[1] min_num = min(numbers) max_num = max(numbers) min_diff_variance = max_num - min_num results.append(f\\"Case #{index + 1}: {min_diff_variance}\\") return results def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) cases = [] for i in range(1, T + 1): parts = list(map(int, lines[i].split())) N = parts[0] numbers = parts[1:] cases.append((N, numbers)) return cases"},{"question":"def graph_information(n: int, m: int, edges: List[Tuple[int, int]]) -> List[str]: Given a connected, undirected graph with n nodes and m edges, compute and print the following information for each node u of the graph: - node ID of u - degree of u (the number of edges connected to u) - the list of adjacent nodes (neighbors) of u sorted in ascending order of node ID >>> edges = [(0, 1), (0, 2), (1, 2), (1, 3), (2, 3), (2, 4), (3, 5)] >>> graph_information(6, 7, edges) [ \\"node 0: degree = 2, adjacent nodes = [1, 2]\\", \\"node 1: degree = 3, adjacent nodes = [0, 2, 3]\\", \\"node 2: degree = 4, adjacent nodes = [0, 1, 3, 4]\\", \\"node 3: degree = 3, adjacent nodes = [1, 2, 5]\\", \\"node 4: degree = 1, adjacent nodes = [2]\\", \\"node 5: degree = 1, adjacent nodes = [3]\\", ] >>> edges = [] >>> graph_information(1, 0, edges) [\\"node 0: degree = 0, adjacent nodes = []\\"] >>> edges = [] >>> graph_information(4, 0, edges) [ \\"node 0: degree = 0, adjacent nodes = []\\", \\"node 1: degree = 0, adjacent nodes = []\\", \\"node 2: degree = 0, adjacent nodes = []\\", \\"node 3: degree = 0, adjacent nodes = []\\", ] >>> edges = [(i, j) for i in range(5) for j in range(i + 1, 5)] >>> graph_information(5, 10, edges) [ \\"node 0: degree = 4, adjacent nodes = [1, 2, 3, 4]\\", \\"node 1: degree = 4, adjacent nodes = [0, 2, 3, 4]\\", \\"node 2: degree = 4, adjacent nodes = [0, 1, 3, 4]\\", \\"node 3: degree = 4, adjacent nodes = [0, 1, 2, 4]\\", \\"node 4: degree = 4, adjacent nodes = [0, 1, 2, 3]\\", ] >>> edges = [(0, 1), (2, 3)] >>> graph_information(4, 2, edges) [ \\"node 0: degree = 1, adjacent nodes = [1]\\", \\"node 1: degree = 1, adjacent nodes = [0]\\", \\"node 2: degree = 1, adjacent nodes = [3]\\", \\"node 3: degree = 1, adjacent nodes = [2]\\", ]","solution":"def graph_information(n, m, edges): from collections import defaultdict # Initialize adjacency list adj_list = defaultdict(list) # Build the graph for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) result = [] # Gather and format the required information for each node for u in range(n): neighbors = sorted(adj_list[u]) degree = len(neighbors) result.append(f'node {u}: degree = {degree}, adjacent nodes = {neighbors}') return result"},{"question":"def max_contiguous_buildings(N: int, heightsA: List[int], heightsB: List[int]) -> int: Returns the maximum number of contiguous buildings in city A that have corresponding contiguous buildings in city B with exactly the same heights. Args: N (int): The number of buildings in each city. heightsA (List[int]): The heights of the buildings in city A. heightsB (List[int]): The heights of the buildings in city B. Returns: int: The maximum number of contiguous buildings with the same height in both cities. Examples: >>> max_contiguous_buildings(5, [4, 3, 2, 1, 4], [4, 2, 3, 1, 4]) 2 >>> max_contiguous_buildings(6, [1, 2, 3, 4, 5, 6], [7, 2, 3, 4, 8, 6]) 3 from solution import max_contiguous_buildings def test_example_1(): N = 5 heightsA = [4, 3, 2, 1, 4] heightsB = [4, 2, 3, 1, 4] assert max_contiguous_buildings(N, heightsA, heightsB) == 2 def test_example_2(): N = 6 heightsA = [1, 2, 3, 4, 5, 6] heightsB = [7, 2, 3, 4, 8, 6] assert max_contiguous_buildings(N, heightsA, heightsB) == 3 def test_no_match(): N = 4 heightsA = [1, 2, 3, 4] heightsB = [5, 6, 7, 8] assert max_contiguous_buildings(N, heightsA, heightsB) == 0 def test_complete_match(): N = 3 heightsA = [5, 6, 7] heightsB = [5, 6, 7] assert max_contiguous_buildings(N, heightsA, heightsB) == 3 def test_partial_match(): N = 5 heightsA = [1, 2, 3, 4, 5] heightsB = [2, 3, 4, 8, 9] assert max_contiguous_buildings(N, heightsA, heightsB) == 3 def test_single_element(): N = 1 heightsA = [5] heightsB = [5] assert max_contiguous_buildings(N, heightsA, heightsB) == 1 def test_single_element_no_match(): N = 1 heightsA = [5] heightsB = [6] assert max_contiguous_buildings(N, heightsA, heightsB) == 0","solution":"def max_contiguous_buildings(N, heightsA, heightsB): Returns the maximum number of contiguous buildings in city A that have corresponding contiguous buildings in city B with exactly the same heights. max_length = 0 for i in range(N): for j in range(N): k = 0 while i + k < N and j + k < N and heightsA[i + k] == heightsB[j + k]: k += 1 max_length = max(max_length, k) return max_length # Example usage # N = 5 # heightsA = [4, 3, 2, 1, 4] # heightsB = [4, 2, 3, 1, 4] # print(max_contiguous_buildings(N, heightsA, heightsB)) # Output: 2"},{"question":"def simulate_falling_leaves(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[List[int]]: Sarah is fascinated by a pattern she observed in her backyard, involving falling leaves. She decides to simulate this on her computer. You are given an integer n, denoting the number of leaves, and an array h of n integers, where h_i represents the initial height from which each leaf is falling. Sarah wants to perform k operations on this array. In each operation, she does the following: 1. Find the minimum height m in the array. 2. For each leaf i, if its current height is h_i, set h_i to h_i - m. Your task is to determine the final state of the array after k operations. Input The first line contains a single integer t (1 ≤ t ≤ 100), the number of test cases. The first line of each test case contains two integers n and k (1 ≤ n ≤ 10^5, 1 ≤ k ≤ 10^9) – the number of leaves and the number of operations. The second line of each test case contains n integers h_1, h_2, ..., h_n (1 ≤ h_i ≤ 10^9) – the initial heights of the leaves. Output For each test case, print the final array after k operations. Example ------- Input ----- 2 3 2 5 3 7 4 3 10 20 10 40 Output ------ 2 0 4 0 10 0 30 Note ---- In the first test case: - Initially, the array is [5, 3, 7]. Minimum height m is 3. - After the first operation: [5-3, 3-3, 7-3] = [2, 0, 4]. - The new minimum height m is 0. - After the second operation: [2-0, 0-0, 4-0] = [2, 0, 4]. In the second test case: - Initially, the array is [10, 20, 10, 40]. Minimum height m is 10. - After the first operation: [10-10, 20-10, 10-10, 40-10] = [0, 10, 0, 30]. - The new minimum height m is 0. - After the second and third operations: [0, 10, 0, 30]. >>> t = 2 >>> test_cases = [((3, 2), [5, 3, 7]), ((4, 3), [10, 20, 10, 40])] >>> simulate_falling_leaves(t, test_cases) [[2, 0, 4], [0, 10, 0, 30]] >>> t = 1 >>> test_cases = [((1, 1), [7])] >>> simulate_falling_leaves(t, test_cases) [[0]] >>> t = 1 >>> test_cases = [((3, 2), [5, 5, 5])] >>> simulate_falling_leaves(t, test_cases) [[0, 0, 0]] >>> t = 1 >>> test_cases = [((2, 1000000000), [1000000000, 1000000000])] >>> simulate_falling_leaves(t, test_cases) [[0, 0]] >>> t = 1 >>> test_cases = [((5, 3), [100, 200, 300, 400, 500])] >>> simulate_falling_leaves(t, test_cases) [[0, 100, 200, 300, 400]]","solution":"def simulate_falling_leaves(t, test_cases): results = [] for i in range(t): n, k = test_cases[i][0] heights = test_cases[i][1] min_height = min(heights) # If min_height > 0, applying operations will occur some changes if min_height > 0: for i in range(n): if heights[i] != 0: heights[i] -= min_height results.append(heights) return results"},{"question":"def identify_suspicious_ips(n: int, k: int, t: int, logs: List[str]) -> List[str]: Identify IP addresses with more than 'k' distinct login attempts within any 't' seconds interval. >>> identify_suspicious_ips(8, 2, 60, [ ... \\"1627654800 192.168.1.1 alice\\", ... \\"1627654801 192.168.1.1 bob\\", ... \\"1627654802 192.168.1.1 charlie\\", ... \\"1627654803 192.168.1.2 alice\\", ... \\"1627654804 192.168.1.2 bob\\", ... \\"1627654850 192.168.1.1 delta\\", ... \\"1627654860 192.168.1.1 echo\\", ... \\"1627654900 192.168.1.2 frank\\" ... ]) == ['192.168.1.1'] >>> identify_suspicious_ips(6, 3, 60, [ ... \\"1627654800 192.168.1.1 alice\\", ... \\"1627654801 192.168.1.1 bob\\", ... \\"1627654801 192.168.1.1 alice\\", ... \\"1627654802 192.168.1.2 charlie\\", ... \\"1627654803 192.168.1.2 bob\\", ... \\"1627654900 192.168.1.2 frank\\" ... ]) == [] >>> identify_suspicious_ips(10, 2, 120, [ ... \\"1627654800 192.168.1.1 alice\\", ... \\"1627654801 192.168.1.1 bob\\", ... \\"1627654802 192.168.1.1 charlie\\", ... \\"1627654803 192.168.1.2 alice\\", ... \\"1627654804 192.168.1.2 bob\\", ... \\"1627654850 192.168.1.1 delta\\", ... \\"1627654860 192.168.1.1 echo\\", ... \\"1627654870 192.168.1.2 charlie\\", ... \\"1627654900 192.168.1.2 alice\\", ... \\"1627654920 192.168.1.2 bob\\" ... ]) == ['192.168.1.1', '192.168.1.2']","solution":"from collections import defaultdict import heapq def identify_suspicious_ips(n, k, t, logs): Identify IP addresses with more than 'k' distinct login attempts within 't' seconds interval. login_attempts = defaultdict(list) # Parse logs and group by IP for log in logs: timestamp, ip, username = log.split() timestamp = int(timestamp) login_attempts[ip].append((timestamp, username)) suspicious_ips = set() # Check for each IP for ip, attempts in login_attempts.items(): attempts.sort() # Sort by timestamp # Sliding window to find more than 'k' distinct login attempts within 't' seconds distinct_usernames = defaultdict(int) start = 0 for end in range(len(attempts)): current_timestamp, current_username = attempts[end] distinct_usernames[current_username] += 1 while current_timestamp - attempts[start][0] > t: start_username = attempts[start][1] distinct_usernames[start_username] -= 1 if distinct_usernames[start_username] == 0: del distinct_usernames[start_username] start += 1 if len(distinct_usernames) > k: suspicious_ips.add(ip) break return sorted(suspicious_ips) # Example use: # n, k, t = 8, 2, 60 # logs = [ # \\"1627654800 192.168.1.1 alice\\", # \\"1627654801 192.168.1.1 bob\\", # \\"1627654802 192.168.1.1 charlie\\", # \\"1627654803 192.168.1.2 alice\\", # \\"1627654804 192.168.1.2 bob\\", # \\"1627654850 192.168.1.1 delta\\", # \\"1627654860 192.168.1.1 echo\\", # \\"1627654900 192.168.1.2 frank\\" # ] # print(identify_suspicious_ips(n, k, t, logs)) # Output: ['192.168.1.1']"},{"question":"class GraphicalEditor: def __init__(self): self.shapes = {} self.next_id = 1 def create_circle(self, r, x, y): self.shapes[self.next_id] = (\\"circle\\", r, x, y) self.next_id += 1 def create_rectangle(self, w, h, x, y): self.shapes[self.next_id] = (\\"rectangle\\", w, h, x, y) self.next_id += 1 def create_line(self, x1, y1, x2, y2): self.shapes[self.next_id] = (\\"line\\", x1, y1, x2, y2) self.next_id += 1 def move_shape(self, shape_id, dx, dy): shape = self.shapes.get(shape_id) if shape: if shape[0] == \\"circle\\": self.shapes[shape_id] = (shape[0], shape[1], shape[2] + dx, shape[3] + dy) elif shape[0] == \\"rectangle\\": self.shapes[shape_id] = (shape[0], shape[1], shape[2], shape[3], shape[4] + dx, shape[5] + dy) elif shape[0] == \\"line\\": self.shapes[shape_id] = (shape[0], shape[1] + dx, shape[2] + dy, shape[3] + dx, shape[4] + dy) def delete_shape(self, shape_id): if shape_id in self.shapes: del self.shapes[shape_id] def print_shapes(self): for shape_id in sorted(self.shapes.keys()): shape = self.shapes[shape_id] if shape[0] == \\"circle\\": print(f\\"{shape[0]} {shape_id} {shape[1]} {shape[2]} {shape[3]}\\") elif shape[0] == \\"rectangle\\": print(f\\"{shape[0]} {shape_id} {shape[1]} {shape[2]} {shape[3]} {shape[4]}\\") elif shape[0] == \\"line\\": print(f\\"{shape[0]} {shape_id} {shape[1]} {shape[2]} {shape[3]} {shape[4]}\\") def process_commands(commands): Process a list of commands to manipulate shapes in a graphical editor. Example: >>> commands = [ ... \\"6\\", ... \\"circle 5 2 3\\", ... \\"rectangle 4 3 1 1\\", ... \\"print\\", ... \\"move 1 1 1\\", ... \\"delete 2\\", ... \\"print\\", ... ] >>> process_commands(commands[1:]) circle 1 5 2 3 rectangle 2 4 3 1 1 circle 1 5 3 4 def test_process_commands(capsys): commands = [ \\"6\\", \\"circle 5 2 3\\", \\"rectangle 4 3 1 1\\", \\"print\\", \\"move 1 1 1\\", \\"delete 2\\", \\"print\\", ] process_commands(commands[1:]) captured = capsys.readouterr() expected_output = (\\"circle 1 5 2 3n\\" \\"rectangle 2 4 3 1 1n\\" \\"circle 1 5 3 4n\\") assert captured.out == expected_output def test_create_and_print_shapes(capsys): commands = [\\"3\\", \\"circle 10 0 0\\", \\"line 1 1 2 2\\", \\"print\\"] process_commands(commands[1:]) captured = capsys.readouterr() expected_output = (\\"circle 1 10 0 0n\\" \\"line 2 1 1 2 2n\\") assert captured.out == expected_output def test_move_shape(capsys): commands = [\\"4\\", \\"circle 10 0 0\\", \\"move 1 5 5\\", \\"print\\"] process_commands(commands[1:]) captured = capsys.readouterr() assert captured.out == \\"circle 1 10 5 5n\\" def test_delete_shape(capsys): commands = [\\"4\\", \\"circle 10 0 0\\", \\"delete 1\\", \\"print\\"] process_commands(commands[1:]) captured = capsys.readouterr() assert captured.out == \\"\\" def test_mixed_commands(capsys): commands = [\\"7\\", \\"rectangle 4 3 1 1\\", \\"line 1 1 2 2\\", \\"print\\", \\"move 2 1 1\\", \\"delete 1\\", \\"print\\"] process_commands(commands[1:]) captured = capsys.readouterr() expected_output = (\\"rectangle 1 4 3 1 1n\\" \\"line 2 1 1 2 2n\\" \\"line 2 2 2 3 3n\\") assert captured.out == expected_output","solution":"class GraphicalEditor: def __init__(self): self.shapes = {} self.next_id = 1 def create_circle(self, r, x, y): self.shapes[self.next_id] = (\\"circle\\", r, x, y) self.next_id += 1 def create_rectangle(self, w, h, x, y): self.shapes[self.next_id] = (\\"rectangle\\", w, h, x, y) self.next_id += 1 def create_line(self, x1, y1, x2, y2): self.shapes[self.next_id] = (\\"line\\", x1, y1, x2, y2) self.next_id += 1 def move_shape(self, shape_id, dx, dy): shape = self.shapes.get(shape_id) if shape: if shape[0] == \\"circle\\": self.shapes[shape_id] = (shape[0], shape[1], shape[2] + dx, shape[3] + dy) elif shape[0] == \\"rectangle\\": self.shapes[shape_id] = (shape[0], shape[1], shape[2], shape[3], shape[4] + dx, shape[5] + dy) elif shape[0] == \\"line\\": self.shapes[shape_id] = (shape[0], shape[1] + dx, shape[2] + dy, shape[3] + dx, shape[4] + dy) def delete_shape(self, shape_id): if shape_id in self.shapes: del self.shapes[shape_id] def print_shapes(self): for shape_id in sorted(self.shapes.keys()): shape = self.shapes[shape_id] if shape[0] == \\"circle\\": print(f\\"{shape[0]} {shape_id} {shape[1]} {shape[2]} {shape[3]}\\") elif shape[0] == \\"rectangle\\": print(f\\"{shape[0]} {shape_id} {shape[1]} {shape[2]} {shape[3]} {shape[4]}\\") elif shape[0] == \\"line\\": print(f\\"{shape[0]} {shape_id} {shape[1]} {shape[2]} {shape[3]} {shape[4]}\\") def process_commands(commands): editor = GraphicalEditor() for command in commands: parts = command.split() action = parts[0] if action == \\"circle\\": r, x, y = map(int, parts[1:]) editor.create_circle(r, x, y) elif action == \\"rectangle\\": w, h, x, y = map(int, parts[1:]) editor.create_rectangle(w, h, x, y) elif action == \\"line\\": x1, y1, x2, y2 = map(int, parts[1:]) editor.create_line(x1, y1, x2, y2) elif action == \\"move\\": shape_id, dx, dy = map(int, parts[1:]) editor.move_shape(shape_id, dx, dy) elif action == \\"delete\\": shape_id = int(parts[1]) editor.delete_shape(shape_id) elif action == \\"print\\": editor.print_shapes()"},{"question":"class LibrarySystem: def __init__(self): Initialize the LibrarySystem class. pass def borrow(self, user: str, book: str) -> None: The user borrows the specified book. If the book is already borrowed by another user, the request is denied. >>> library_system = LibrarySystem() >>> library_system.borrow('alice', 'book1') >>> library_system.userBooks('alice') 'book1' pass def return_book(self, user: str, book: str) -> None: The user returns the specified book. If the book was not borrowed by the user, the request is denied. >>> library_system = LibrarySystem() >>> library_system.borrow('alice', 'book1') >>> library_system.return_book('alice', 'book1') >>> library_system.userBooks('alice') 'none' pass def userBooks(self, user: str) -> str: Report the list of books currently borrowed by the specified user in the order they were borrowed. >>> library_system = LibrarySystem() >>> library_system.borrow('alice', 'book1') >>> library_system.borrow('alice', 'book2') >>> library_system.userBooks('alice') 'book1, book2' >>> library_system.borrow('bob', 'book3') >>> library_system.return_book('alice', 'book1') >>> library_system.userBooks('alice') 'book2' pass def main(): import sys input = sys.stdin.read data = input().split('n') n = int(data[0]) library_system = LibrarySystem() results = [] for i in range(1, n + 1): if not data[i].strip(): continue parts = data[i].split() operation = parts[0] if operation == 'borrow': user, book = parts[1], parts[2] library_system.borrow(user, book) elif operation == 'return': user, book = parts[1], parts[2] library_system.return_book(user, book) elif operation == 'userBooks': user = parts[1] results.append(library_system.userBooks(user)) for result in results: print(result) if __name__ == \\"__main__\\": main() from solution import LibrarySystem def test_borrowing_books(): library_system = LibrarySystem() library_system.borrow('alice', 'book1') library_system.borrow('bob', 'book2') assert library_system.userBooks('alice') == 'book1' assert library_system.userBooks('bob') == 'book2' def test_borrowing_same_book_different_users(): library_system = LibrarySystem() library_system.borrow('alice', 'book1') library_system.borrow('bob', 'book1') assert library_system.userBooks('alice') == 'book1' assert library_system.userBooks('bob') == 'none' def test_return_book(): library_system = LibrarySystem() library_system.borrow('alice', 'book1') assert library_system.userBooks('alice') == 'book1' library_system.return_book('alice', 'book1') assert library_system.userBooks('alice') == 'none' def test_user_with_multiple_books(): library_system = LibrarySystem() library_system.borrow('alice', 'book1') library_system.borrow('alice', 'book2') assert library_system.userBooks('alice') == 'book1, book2' library_system.return_book('alice', 'book1') assert library_system.userBooks('alice') == 'book2' def test_nonexistent_user_books(): library_system = LibrarySystem() assert library_system.userBooks('alice') == 'none' def test_interleaved_operations(): library_system = LibrarySystem() library_system.borrow('alice', 'book1') library_system.borrow('alice', 'book2') assert library_system.userBooks('alice') == 'book1, book2' library_system.borrow('bob', 'book3') library_system.return_book('alice', 'book1') assert library_system.userBooks('alice') == 'book2' assert library_system.userBooks('bob') == 'book3' library_system.return_book('bob', 'book3') assert library_system.userBooks('bob') == 'none'","solution":"class LibrarySystem: def __init__(self): self.user_books = {} self.borrowed_books = set() def borrow(self, user, book): if book not in self.borrowed_books: self.borrowed_books.add(book) if user not in self.user_books: self.user_books[user] = [] self.user_books[user].append(book) def return_book(self, user, book): if user in self.user_books and book in self.user_books[user]: self.user_books[user].remove(book) self.borrowed_books.remove(book) def userBooks(self, user): return ', '.join(self.user_books[user]) if user in self.user_books and self.user_books[user] else 'none' def main(): import sys input = sys.stdin.read data = input().split('n') n = int(data[0]) library_system = LibrarySystem() results = [] for i in range(1, n + 1): if not data[i].strip(): continue parts = data[i].split() operation = parts[0] if operation == 'borrow': user, book = parts[1], parts[2] library_system.borrow(user, book) elif operation == 'return': user, book = parts[1], parts[2] library_system.return_book(user, book) elif operation == 'userBooks': user = parts[1] results.append(library_system.userBooks(user)) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"from typing import List, Tuple from collections import defaultdict, deque def find_topological_order_and_min_time(n: int, m: int, edges: List[Tuple[int, int]]) -> Tuple[List[int], int]: Find a topological ordering of the tasks and determine the minimum time required to complete all tasks. Each task takes exactly one unit of time to complete and no two tasks can be performed simultaneously. Args: n (int): The number of nodes. m (int): The number of edges. edges (List[Tuple[int, int]]): The directed edges in the graph. Returns: Tuple[List[int], int]: A topological ordering of the tasks and the minimum time required. Examples: >>> find_topological_order_and_min_time(4, 3, [(1, 2), (1, 3), (3, 4)]) ([1, 3, 4, 2], 4) >>> find_topological_order_and_min_time(5, 4, [(1, 2), (1, 3), (3, 4), (2, 5)]) ([1, 3, 4, 2, 5], 5) def test_case_1(): n = 4 m = 3 edges = [(1, 2), (1, 3), (3, 4)] topological_order, min_time = find_topological_order_and_min_time(n, m, edges) assert set(topological_order) == {1, 2, 3, 4} assert len(topological_order) == n assert topological_order.index(1) < topological_order.index(2) assert topological_order.index(1) < topological_order.index(3) assert topological_order.index(3) < topological_order.index(4) assert min_time == 4 def test_case_2(): n = 5 m = 4 edges = [(1, 2), (1, 3), (3, 4), (2, 5)] topological_order, min_time = find_topological_order_and_min_time(n, m, edges) assert set(topological_order) == {1, 2, 3, 4, 5} assert len(topological_order) == n assert topological_order.index(1) < topological_order.index(2) assert topological_order.index(1) < topological_order.index(3) assert topological_order.index(3) < topological_order.index(4) assert topological_order.index(2) < topological_order.index(5) assert min_time == 5 def test_case_no_edges(): n = 3 m = 0 edges = [] topological_order, min_time = find_topological_order_and_min_time(n, m, edges) assert set(topological_order) == {1, 2, 3} assert len(topological_order) == n assert min_time == 3 def test_case_one_node(): n = 1 m = 0 edges = [] topological_order, min_time = find_topological_order_and_min_time(n, m, edges) assert topological_order == [1] assert min_time == 1 def test_case_complex(): n = 6 m = 6 edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 5), (5, 6)] topological_order, min_time = find_topological_order_and_min_time(n, m, edges) assert set(topological_order) == {1, 2, 3, 4, 5, 6} assert len(topological_order) == n assert topological_order.index(1) < topological_order.index(2) assert topological_order.index(1) < topological_order.index(3) assert topological_order.index(2) < topological_order.index(4) assert topological_order.index(2) < topological_order.index(5) assert topological_order.index(3) < topological_order.index(5) assert topological_order.index(5) < topological_order.index(6) assert min_time == 6","solution":"from collections import defaultdict, deque def find_topological_order_and_min_time(n, m, edges): # Build graph and compute in-degrees of nodes graph = defaultdict(list) in_degree = [0] * (n + 1) for u, v in edges: graph[u].append(v) in_degree[v] += 1 # Initialize queue with nodes that have no incoming edges queue = deque([i for i in range(1, n + 1) if in_degree[i] == 0]) topological_order = [] while queue: u = queue.popleft() topological_order.append(u) for v in graph[u]: in_degree[v] -= 1 if in_degree[v] == 0: queue.append(v) # The minimum time to complete all tasks is just the number of tasks min_time = len(topological_order) return topological_order, min_time"},{"question":"def generate_ip_addresses(t: int, CCC: int, DDD: int) -> list: Generates t IP addresses starting from the given CCC and DDD values. Addresses follow the pattern 192.168.CCC.DDD. Args: t : int : number of IP addresses to generate CCC : starting value for CCC part DDD : starting value for DDD part Returns: List of generated IP addresses. >>> generate_ip_addresses(5, 1, 250) [\\"192.168.001.250\\", \\"192.168.001.251\\", \\"192.168.001.252\\", \\"192.168.001.253\\", \\"192.168.001.254\\"] >>> generate_ip_addresses(7, 255, 254) [\\"192.168.255.254\\", \\"192.168.255.255\\", \\"192.168.000.000\\", \\"192.168.000.001\\", \\"192.168.000.002\\", \\"192.168.000.003\\", \\"192.168.000.004\\"] >>> generate_ip_addresses(1, 0, 0) [\\"192.168.000.000\\"] >>> generate_ip_addresses(3, 254, 255) [\\"192.168.254.255\\", \\"192.168.255.000\\", \\"192.168.255.001\\"] >>> generate_ip_addresses(100, 0, 0) [\\"192.168.000.000\\", \\"192.168.000.001\\", \\"192.168.000.002\\", \\"192.168.000.003\\", \\"192.168.000.004\\", \\"192.168.000.005\\", \\"192.168.000.006\\", \\"192.168.000.007\\", \\"192.168.000.008\\", \\"192.168.000.009\\", \\"192.168.000.010\\", \\"192.168.000.011\\", \\"192.168.000.012\\", \\"192.168.000.013\\", \\"192.168.000.014\\", \\"192.168.000.015\\", \\"192.168.000.016\\", \\"192.168.000.017\\", \\"192.168.000.018\\", \\"192.168.000.019\\", \\"192.168.000.020\\", \\"192.168.000.021\\", \\"192.168.000.022\\", \\"192.168.000.023\\", \\"192.168.000.024\\", \\"192.168.000.025\\", \\"192.168.000.026\\", \\"192.168.000.027\\", \\"192.168.000.028\\", \\"192.168.000.029\\", \\"192.168.000.030\\", \\"192.168.000.031\\", \\"192.168.000.032\\", \\"192.168.000.033\\", \\"192.168.000.034\\", \\"192.168.000.035\\", \\"192.168.000.036\\", \\"192.168.000.037\\", \\"192.168.000.038\\", \\"192.168.000.039\\", \\"192.168.000.040\\", \\"192.168.000.041\\", \\"192.168.000.042\\", \\"192.168.000.043\\", \\"192.168.000.044\\", \\"192.168.000.045\\", \\"192.168.000.046\\", \\"192.168.000.047\\", \\"192.168.000.048\\", \\"192.168.000.049\\", \\"192.168.000.050\\", \\"192.168.000.051\\", \\"192.168.000.052\\", \\"192.168.000.053\\", \\"192.168.000.054\\", \\"192.168.000.055\\", \\"192.168.000.056\\", \\"192.168.000.057\\", \\"192.168.000.058\\", \\"192.168.000.059\\", \\"192.168.000.060\\", \\"192.168.000.061\\", \\"192.168.000.062\\", \\"192.168.000.063\\", \\"192.168.000.064\\", \\"192.168.000.065\\", \\"192.168.000.066\\", \\"192.168.000.067\\", \\"192.168.000.068\\", \\"192.168.000.069\\", \\"192.168.000.070\\", \\"192.168.000.071\\", \\"192.168.000.072\\", \\"192.168.000.073\\", \\"192.168.000.074\\", \\"192.168.000.075\\", \\"192.168.000.076\\", \\"192.168.000.077\\", \\"192.168.000.078\\", \\"192.168.000.079\\", \\"192.168.000.080\\", \\"192.168.000.081\\", \\"192.168.000.082\\", \\"192.168.000.083\\", \\"192.168.000.084\\", \\"192.168.000.085\\", \\"192.168.000.086\\", \\"192.168.000.087\\", \\"192.168.000.088\\", \\"192.168.000.089\\", \\"192.168.000.090\\", \\"192.168.000.091\\", \\"192.168.000.092\\", \\"192.168.000.093\\", \\"192.168.000.094\\", \\"192.168.000.095\\", \\"192.168.000.096\\", \\"192.168.000.097\\", \\"192.168.000.098\\", \\"192.168.000.099\\"]","solution":"def generate_ip_addresses(t, CCC, DDD): Generates t IP addresses starting from the given CCC and DDD values. Addresses follow the pattern 192.168.CCC.DDD. Args: t : int : number of IP addresses to generate CCC : int : starting value for CCC part DDD : int : starting value for DDD part Returns: result : list : list of generated IP addresses result = [] AAA = 192 BBB = 168 for _ in range(t): ip = f\\"{AAA:03}.{BBB:03}.{CCC:03}.{DDD:03}\\" result.append(ip) DDD += 1 if DDD == 256: DDD = 0 CCC += 1 if CCC == 256: CCC = 0 return result"},{"question":"def find_longest_increasing_subarray(readings): Find the longest contiguous subarray of increasing readings. >>> find_longest_increasing_subarray([(\\"2023-01-01T00:00:00\\", 1), (\\"2023-01-01T00:01:00\\", 2), (\\"2023-01-01T00:02:00\\", 3), (\\"2023-01-01T00:03:00\\", 2), (\\"2023-01-01T00:04:00\\", 4)]) [('2023-01-01T00:00:00', 1), ('2023-01-01T00:01:00', 2), ('2023-01-01T00:02:00', 3)] >>> find_longest_increasing_subarray([(\\"2023-01-01T00:00:00\\", 1), (\\"2023-01-01T00:01:00\\", 2), (\\"2023-01-01T00:02:00\\", 3), (\\"2023-01-01T00:03:00\\", 4), (\\"2023-01-01T00:04:00\\", 5), (\\"2023-01-01T00:05:00\\", 6)]) [('2023-01-01T00:00:00', 1), ('2023-01-01T00:01:00', 2), ('2023-01-01T00:02:00', 3), ('2023-01-01T00:03:00', 4), ('2023-01-01T00:04:00', 5), ('2023-01-01T00:05:00', 6)] pass def format_output(readings): Format the readings for output. >>> format_output([(\\"2023-01-01T00:00:00\\", 1), (\\"2023-01-01T00:01:00\\", 2), (\\"2023-01-01T00:02:00\\", 3)]) '2023-01-01T00:00:00 1 2023-01-01T00:01:00 2 2023-01-01T00:02:00 3' pass def main(input_data: str) -> str: Process the input data and find the longest increasing subarray for each test case. >>> input_data = 2 5 2023-01-01T00:00:00 1 2023-01-01T00:01:00 2 2023-01-01T00:02:00 3 2023-01-01T00:03:00 2 2023-01-01T00:04:00 4 6 2023-01-01T00:00:00 1 2023-01-01T00:01:00 2 2023-01-01T00:02:00 3 2023-01-01T00:03:00 4 2023-01-01T00:04:00 5 2023-01-01T00:05:00 6 >>> main(input_data) '2023-01-01T00:00:00 1 2023-01-01T00:01:00 2 2023-01-01T00:02:00 3n2023-01-01T00:00:00 1 2023-01-01T00:01:00 2 2023-01-01T00:02:00 3 2023-01-01T00:03:00 4 2023-01-01T00:04:00 5 2023-01-01T00:05:00 6' pass import pytest def test_example(): input_data = 2 5 2023-01-01T00:00:00 1 2023-01-01T00:01:00 2 2023-01-01T00:02:00 3 2023-01-01T00:03:00 2 2023-01-01T00:04:00 4 6 2023-01-01T00:00:00 1 2023-01-01T00:01:00 2 2023-01-01T00:02:00 3 2023-01-01T00:03:00 4 2023-01-01T00:04:00 5 2023-01-01T00:05:00 6 output = main(input_data) expected_output = 2023-01-01T00:00:00 1 2023-01-01T00:01:00 2 2023-01-01T00:02:00 3 2023-01-01T00:00:00 1 2023-01-01T00:01:00 2 2023-01-01T00:02:00 3 2023-01-01T00:03:00 4 2023-01-01T00:04:00 5 2023-01-01T00:05:00 6 assert output == expected_output def test_single_reading(): input_data = 1 1 2023-01-01T00:00:00 1 output = main(input_data) expected_output = \\"2023-01-01T00:00:00 1\\" assert output == expected_output def test_all_equal_readings(): input_data = 1 5 2023-01-01T00:00:00 1 2023-01-01T00:01:00 1 2023-01-01T00:02:00 1 2023-01-01T00:03:00 1 2023-01-01T00:04:00 1 output = main(input_data) expected_output = \\"2023-01-01T00:00:00 1\\" assert output == expected_output def test_decreasing_readings(): input_data = 1 5 2023-01-01T00:00:00 5 2023-01-01T00:01:00 4 2023-01-01T00:02:00 3 2023-01-01T00:03:00 2 2023-01-01T00:04:00 1 output = main(input_data) expected_output = \\"2023-01-01T00:00:00 5\\" assert output == expected_output","solution":"def find_longest_increasing_subarray(readings): max_len = 0 max_start_index = 0 current_len = 1 current_start_index = 0 for i in range(1, len(readings)): if readings[i][1] > readings[i - 1][1]: current_len += 1 else: if current_len > max_len: max_len = current_len max_start_index = current_start_index current_len = 1 current_start_index = i if current_len > max_len: max_len = current_len max_start_index = current_start_index return readings[max_start_index:max_start_index + max_len] def format_output(readings): return ' '.join([f'{timestamp} {value}' for timestamp, value in readings]) def main(input_data): lines = input_data.strip().split('n') T = int(lines[0]) results = [] index = 1 for _ in range(T): N = int(lines[index]) readings = [] for i in range(N): timestamp, value = lines[index + 1 + i].split() value = int(value) readings.append((timestamp, value)) longest_subarray = find_longest_increasing_subarray(readings) results.append(format_output(longest_subarray)) index += N + 1 return 'n'.join(results)"},{"question":"def max_scenic_view_sum(n: int, heights: List[int]) -> int: Returns the maximum sum of heights from any three different points. >>> max_scenic_view_sum(5, [1, 2, 3, 4, 5]) 12 >>> max_scenic_view_sum(4, [10, 20, 30, 40]) 90 >>> max_scenic_view_sum(6, [5, 1, 2, 9, 3, 7]) 21 from solution import max_scenic_view_sum def test_max_scenic_view_sum_example1(): assert max_scenic_view_sum(5, [1, 2, 3, 4, 5]) == 12 def test_max_scenic_view_sum_example2(): assert max_scenic_view_sum(4, [10, 20, 30, 40]) == 90 def test_max_scenic_view_sum_example3(): assert max_scenic_view_sum(6, [5, 1, 2, 9, 3, 7]) == 21 def test_max_scenic_view_sum_min_input(): assert max_scenic_view_sum(3, [1, 1, 1]) == 3 def test_max_scenic_view_sum_all_same_height(): assert max_scenic_view_sum(6, [5, 5, 5, 5, 5, 5]) == 15 def test_max_scenic_view_sum_all_different_heights(): assert max_scenic_view_sum(8, [10, 9, 8, 7, 6, 5, 4, 3]) == 27","solution":"def max_scenic_view_sum(n, heights): Returns the maximum sum of heights from any three different points. heights.sort(reverse=True) return heights[0] + heights[1] + heights[2]"},{"question":"def can_sort_array(n: int, a: List[int]) -> str: Determine whether it is possible to sort the array in non-decreasing order by performing the described operations. >>> can_sort_array(4, [3, 1, 4, 2]) \\"YES\\" >>> can_sort_array(3, [3, 2, 1]) \\"YES\\" >>> can_sort_array(5, [5, 4, 3, 2, 1]) \\"YES\\"","solution":"def can_sort_array(n, a): Determine whether it is possible to sort the array in non-decreasing order by performing the described operations. return \\"YES\\""},{"question":"def is_palindrome(num) -> bool: Check if a number is a palindrome. def process_queries(N: int, Q: int, B: List[int], queries: List[List[int]]) -> List[int]: Process queries to find the number of palindrome numbers in a given range or update a specific element in the list. >>> process_queries(5, 5, [123, 121, 454, 789, 0], [[1, 1, 3], [1, 1, 5], [2, 2, 202], [2, 4, 3], [1, 1, 5]]) [2, 3, 4] >>> from solution import process_queries def test_process_queries_example(): N = 5 Q = 5 B = [123, 121, 454, 789, 0] queries = [ [1, 1, 3], [1, 1, 5], [2, 2, 202], [2, 4, 3], [1, 1, 5] ] expected_output = [2, 3, 4] assert process_queries(N, Q, B, queries) == expected_output def test_process_queries_all_non_palindromes(): N = 3 Q = 2 B = [123, 234, 345] queries = [ [1, 1, 3], [2, 3, 121] ] expected_output = [0] assert process_queries(N, Q, B, queries) == expected_output def test_process_queries_all_palindromes(): N = 3 Q = 1 B = [121, 454, 343] queries = [ [1, 1, 3] ] expected_output = [3] assert process_queries(N, Q, B, queries) == expected_output def test_process_queries_mixed_case(): N = 4 Q = 3 B = [12321, 11211, 12, 11] queries = [ [1, 1, 4], [2, 3, 22], [1, 1, 4] ] expected_output = [3, 4] assert process_queries(N, Q, B, queries) == expected_output","solution":"def is_palindrome(num): return str(num) == str(num)[::-1] def process_queries(N, Q, B, queries): res = [] palindromes = [is_palindrome(B[i]) for i in range(N)] for query in queries: if query[0] == 1: l, r = query[1] - 1, query[2] - 1 res.append(sum(palindromes[l:r+1])) elif query[0] == 2: i, K = query[1] - 1, query[2] B[i] = K palindromes[i] = is_palindrome(K) return res"},{"question":"def decimal_to_hex_range(start: int, end: int) -> List[str]: Converts a range of decimal values to their hexadecimal equivalents with prefix \\"0x\\" in uppercase. Arguments: start -- starting integer value of the range (inclusive) end -- ending integer value of the range (inclusive) Returns: List of hexadecimal representations with prefix \\"0x\\". >>> decimal_to_hex_range(10, 20) [\\"0xA\\", \\"0xB\\", \\"0xC\\", \\"0xD\\", \\"0xE\\", \\"0xF\\", \\"0x10\\", \\"0x11\\", \\"0x12\\", \\"0x13\\", \\"0x14\\"] >>> decimal_to_hex_range(0, 0) [\\"0x0\\"] >>> decimal_to_hex_range(255, 255) [\\"0xFF\\"] >>> decimal_to_hex_range(15, 17) [\\"0xF\\", \\"0x10\\", \\"0x11\\"] >>> decimal_to_hex_range(100, 105) [\\"0x64\\", \\"0x65\\", \\"0x66\\", \\"0x67\\", \\"0x68\\", \\"0x69\\"] >>> decimal_to_hex_range(9999, 10000) [\\"0x270F\\", \\"0x2710\\"]","solution":"def decimal_to_hex_range(start, end): Converts a range of decimal values to their hexadecimal equivalents with prefix \\"0x\\" in uppercase. Arguments: start -- starting integer value of the range (inclusive) end -- ending integer value of the range (inclusive) Returns: List of hexadecimal representations with prefix \\"0x\\". return [f\\"0x{hex(i)[2:].upper()}\\" for i in range(start, end + 1)]"},{"question":"def can_rearrange_to_palindrome(s: str) -> str: Determine if the string can be rearranged into a palindrome. :param s: The input string :return: \\"YES\\" if the string can be rearranged into a palindrome, otherwise \\"NO\\" >>> can_rearrange_to_palindrome(\\"civic\\") 'YES' >>> can_rearrange_to_palindrome(\\"ivicc\\") 'YES' >>> can_rearrange_to_palindrome(\\"hello\\") 'NO' >>> can_rearrange_to_palindrome(\\"aabbcc\\") 'YES'","solution":"from collections import Counter def can_rearrange_to_palindrome(s: str) -> str: Determine if the string can be rearranged into a palindrome. :param s: The input string :return: \\"YES\\" if the string can be rearranged into a palindrome, otherwise \\"NO\\" char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"from typing import List def hall_of_fame_announcements(nominations: List[int]) -> List[int]: Processes the given list of years and returns a list of years when new inductees were announced. The sequence of announcements follows these rules: 1. If a nomination is made in year y, the new inductee is announced in the next year (y + 1). 2. If multiple nominations occur in the same year, the inductee announcement for that year is done in the subsequent year only once. Args: nominations (List[int]): A list of integers representing the years when nominations were made. Returns: List[int]: A sorted list of years when new inductees were announced. Examples: >>> hall_of_fame_announcements([1995, 1995, 1996, 1996, 2000]) [1996, 1997, 2001] >>> hall_of_fame_announcements([2020, 2021, 2021, 2021, 2022, 2023]) [2021, 2022, 2023, 2024]","solution":"from typing import List def hall_of_fame_announcements(nominations: List[int]) -> List[int]: Processes the given list of nominations years and returns a list of years when new inductees were announced, sorted in ascending order. return sorted(set(year + 1 for year in nominations))"},{"question":"def longest_subarray_divisible_by_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Returns the length of the longest contiguous subarray where the sum of the numbers is divisible by K. Parameters: t (int): Number of test cases. test_cases (list of tuples): Each test case with 3 elements - N (int): Number of Numfluffs, K (int): The magical number, list of N positive integers representing the Numfluffs. Returns: list of int: Lengths of the longest contiguous subarray for each test case. # Unit Test from solution import longest_subarray_divisible_by_k def test_case_1(): t = 2 test_cases = [ (5, 3, [1, 2, 3, 4, 1]), (6, 5, [4, 1, 3, 2, 8, 16]) ] expected_output = [3, 5] assert longest_subarray_divisible_by_k(t, test_cases) == expected_output def test_case_empty_array(): t = 1 test_cases = [ (0, 5, []) ] expected_output = [0] assert longest_subarray_divisible_by_k(t, test_cases) == expected_output def test_case_single_element(): t = 1 test_cases = [ (1, 3, [3]) ] expected_output = [1] assert longest_subarray_divisible_by_k(t, test_cases) == expected_output def test_case_no_valid_subarray(): t = 1 test_cases = [ (3, 10, [1, 2, 3]) ] expected_output = [0] assert longest_subarray_divisible_by_k(t, test_cases) == expected_output def test_case_entire_array_valid(): t = 1 test_cases = [ (4, 5, [5, 10, 15, 20]) ] expected_output = [4] assert longest_subarray_divisible_by_k(t, test_cases) == expected_output def test_case_prefix_mod_repeating(): t = 1 test_cases = [ (5, 2, [1, 2, 1, 2, 1]) # The sums at each index have repeating prefix mods (1, 0, 1, 0, 1) ] expected_output = [4] # The longest subarray with sum divisible by 2 is between the first and last elements assert longest_subarray_divisible_by_k(t, test_cases) == expected_output","solution":"def longest_subarray_divisible_by_k(t, test_cases): Returns the length of the longest contiguous subarray where the sum of the numbers is divisible by K. Parameters: t (int): Number of test cases. test_cases (list of tuples): Each test case with 3 elements - N (int), K (int), and list of N positive integers. Returns: list of int: Lengths of the longest contiguous subarray for each test case. results = [] for case in test_cases: n, k, array = case prefix_sum_mod = {} prefix_sum = 0 max_length = 0 for i in range(n): prefix_sum += array[i] mod = prefix_sum % k if mod == 0: max_length = i + 1 if mod in prefix_sum_mod: max_length = max(max_length, i - prefix_sum_mod[mod]) else: prefix_sum_mod[mod] = i results.append(max_length) return results"},{"question":"def find_dimensions(n: int) -> (int, int): Given the area of the parking facility, find the dimensions that minimize the difference between the length and the width of the rectangular facility. Parameters: n (int): the area of the parking facility Returns: tuple: dimensions (length, width) that minimize the difference between length and width >>> find_dimensions(30) (6, 5) >>> find_dimensions(12) (4, 3) >>> find_dimensions(1) (1, 1)","solution":"def find_dimensions(n): Given the area of the parking facility, find the dimensions that minimize the difference between the length and the width of the rectangular facility. Parameters: n (int): the area of the parking facility Returns: tuple: dimensions (length, width) that minimize the difference between length and width for width in range(int(n ** 0.5), 0, -1): if n % width == 0: length = n // width return (length, width)"},{"question":"def count_unique_pairs(n: int, k: int, arr: List[int]) -> int: Given an array of distinct integers, determine the number of unique pairs (i, j) such that the sum of the two elements ai and aj is equal to a given target integer k. Each pair (i, j) must satisfy i < j. Parameters: n (int): Number of elements in the array. k (int): Target sum. arr (list of int): List of distinct integers. Returns: int: Number of unique pairs. >>> count_unique_pairs(4, 5, [1, 2, 3, 4]) 2 >>> count_unique_pairs(5, 8, [5, 2, 9, 6, 1]) 1 >>> count_unique_pairs(3, 10, [1, 2, 3]) 0 >>> count_unique_pairs(4, 0, [-1, -2, 1, 2]) 2 >>> count_unique_pairs(4, 1000000000, [500000000, 500000001, 499999999, 1]) 1 >>> count_unique_pairs(2, 3, [1, 2]) 1","solution":"def count_unique_pairs(n, k, arr): Returns the number of unique pairs (i, j) such that ai + aj = k and i < j. Parameters: n (int): Number of elements in the array. k (int): Target sum. arr (list of int): List of distinct integers. Returns: int: Number of unique pairs. # Create a dictionary to store counts of numbers seen = {} count = 0 for num in arr: target = k - num if target in seen: count += 1 seen[num] = True return count # Example usage: # print(count_unique_pairs(4, 5, [1, 2, 3, 4])) # Output should be 2 # print(count_unique_pairs(5, 8, [5, 2, 9, 6, 1])) # Output should be 1"},{"question":"from typing import List, Tuple def min_cables_to_add(n: int, m: int, connections: List[Tuple[int, int]]) -> int: Determine the minimum number of additional cables required to connect the entire network. Args: n: The number of computers. m: The number of existing direct connections. connections: A list of tuples where each tuple represents a direct connection between two computers. Returns: An integer representing the minimum number of additional cables required. Example: >>> min_cables_to_add(5, 3, [(1, 2), (2, 3), (4, 5)]) 1 >>> min_cables_to_add(5, 1, [(1, 2)]) 3 pass from solution import min_cables_to_add def test_case_1(): assert min_cables_to_add(5, 3, [(1, 2), (2, 3), (4, 5)]) == 1 def test_case_2(): assert min_cables_to_add(5, 1, [(1, 2)]) == 3 def test_case_3(): assert min_cables_to_add(1, 0, []) == 0 def test_case_4(): assert min_cables_to_add(4, 2, [(1, 2), (3, 4)]) == 1 def test_case_5(): assert min_cables_to_add(3, 0, []) == 2 def test_case_6(): assert min_cables_to_add(3, 3, [(1, 2), (2, 3), (3, 1)]) == 0 def test_case_7(): assert min_cables_to_add(7, 4, [(1, 2), (2, 3), (4, 5), (6, 7)]) == 2","solution":"def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def min_cables_to_add(n, m, connections): if n == 1: return 0 parent = [i for i in range(n)] rank = [0] * n for u, v in connections: union(parent, rank, u-1, v-1) # Counting the number of connected components root_set = set() for i in range(n): root_set.add(find(parent, i)) # The number of additional cables needed additional_cables = len(root_set) - 1 return additional_cables"},{"question":"class StackSimulation: Class to simulate stack operations: push(x): Push the integer x onto the stack. pop(): Remove the element on the top of the stack. inc(k, x): Add x to each of the bottom k elements of the stack. >>> sim = StackSimulation() >>> operations = [\\"push 3\\", \\"push 5\\", \\"inc 2 7\\", \\"push 2\\", \\"pop\\", \\"inc 1 1\\", \\"pop\\", \\"pop\\"] >>> sim.process_operations(operations) 3 3 5 10 12 10 12 2 10 12 11 12 12 def __init__(self): self.stack = [] def push(self, x): self.stack.append(x) self.print_stack() def pop(self): if self.stack: self.stack.pop() self.print_stack() def inc(self, k, x): for i in range(min(k, len(self.stack))): self.stack[i] += x self.print_stack() def process_operations(self, operations): for operation in operations: parts = operation.split() if parts[0] == \\"push\\": self.push(int(parts[1])) elif parts[0] == \\"pop\\": self.pop() elif parts[0] == \\"inc\\": self.inc(int(parts[1]), int(parts[2])) def print_stack(self): if self.stack: print(\\" \\".join(map(str, self.stack))) else: print()","solution":"class StackSimulation: def __init__(self): self.stack = [] def push(self, x): self.stack.append(x) self.print_stack() def pop(self): if self.stack: self.stack.pop() self.print_stack() def inc(self, k, x): for i in range(min(k, len(self.stack))): self.stack[i] += x self.print_stack() def process_operations(self, operations): for operation in operations: parts = operation.split() if parts[0] == \\"push\\": self.push(int(parts[1])) elif parts[0] == \\"pop\\": self.pop() elif parts[0] == \\"inc\\": self.inc(int(parts[1]), int(parts[2])) def print_stack(self): if self.stack: print(\\" \\".join(map(str, self.stack))) else: print() # Example usage: # sim = StackSimulation() # operations = [\\"push 3\\", \\"push 5\\", \\"inc 2 7\\", \\"push 2\\", \\"pop\\", \\"inc 1 1\\", \\"pop\\", \\"pop\\"] # sim.process_operations(operations)"},{"question":"def max_gold(M: int, N: int, grid: List[List[int]]) -> int: Returns the maximum amount of gold that can be collected from the top-left to the bottom-right cell in the grid by moving only right or down. Parameters: - M: int, number of rows in the grid - N: int, number of columns in the grid - grid: List[List[int]], MxN grid containing amounts of gold Returns: - int, maximum amount of gold collectible >>> max_gold(3, 3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 12 >>> max_gold(1, 1, [[7]]) 7 >>> max_gold(1, 5, [[1, 2, 3, 4, 5]]) 15 >>> max_gold(5, 1, [[1], [2], [3], [4], [5]]) 15","solution":"def max_gold(M, N, grid): Returns the maximum amount of gold that can be collected from the top-left to the bottom-right cell in the grid by moving only right or down. Parameters: - M: int, number of rows in the grid - N: int, number of columns in the grid - grid: List[List[int]], MxN grid containing amounts of gold Returns: - int, maximum amount of gold collectible # Create a memoization table to store results of subproblems dp = [[0]*N for _ in range(M)] # Initialize the starting position dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, N): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column for i in range(1, M): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the memoization table in a bottom-up manner for i in range(1, M): for j in range(1, N): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The result is in the bottom-right cell return dp[M-1][N-1]"},{"question":"def can_optimize_warehouse(n, m, f, deliveries): Determine if it's possible to select f days to expand the warehouse such that the number of boxes never exceeds the maximum capacity at the end of any day. >>> can_optimize_warehouse(3, 10, 1, [(7, 5), (4, 7), (6, 4)]) == \\"Possible\\" >>> can_optimize_warehouse(4, 5, 2, [(6, 2), (8, 4), (3, 5), (7, 1)]) == \\"Impossible\\"","solution":"def can_optimize_warehouse(n, m, f, deliveries): current_boxes = 0 excess_days = [] for i in range(n): k_i, l_i = deliveries[i] current_boxes += k_i - l_i if current_boxes > m: excess = current_boxes - m excess_days.append((i, excess)) if len(excess_days) <= f: return \\"Possible\\" return \\"Impossible\\""},{"question":"def can_make_all_strings_equal(n: int, m: int, strings: List[str]) -> str: Determine if it's possible to make all strings in the list equal in length using the allowed operations. >>> can_make_all_strings_equal(3, 4, [\\"a\\", \\"aa\\", \\"aaa\\"]) \\"YES\\" >>> can_make_all_strings_equal(3, 1, [\\"a\\", \\"bb\\", \\"c\\"]) \\"NO\\"","solution":"def can_make_all_strings_equal(n, m, strings): max_len = max(len(s) for s in strings) min_len = min(len(s) for s in strings) if max_len == min_len: return \\"YES\\" total_needed = sum(max_len - len(s) for s in strings) if total_needed <= m: return \\"YES\\" return \\"NO\\""},{"question":"def solve(n: int, m: int, edge_list: List[Tuple[int, int, int]]) -> int: Given an undirected graph with n vertices and m edges, find the weight of the Minimum Spanning Tree (MST). Returns -1 if no spanning tree exists. >>> solve(4, 4, [(1, 2, 3), (2, 3, 1), (3, 4, 4), (4, 1, 2)]) 6 >>> solve(4, 3, [(1, 2, 3), (1, 3, 4), (1, 4, 5)]) 12 >>> solve(3, 1, [(1, 2, 1)]) -1 >>> solve(1, 0, []) 0 >>> solve(5, 3, [(1, 2, 2), (2, 3, 3), (4, 5, 5)]) -1 >>> solve(3, 3, [(1, 2, 1), (2, 3, 1), (3, 1, 1)]) 2","solution":"class UnionFind: def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def kruskal_minimum_spanning_tree(n, edges): edges.sort(key=lambda x: x[2]) uf = UnionFind(n) mst_weight = 0 edges_used = 0 for u, v, w in edges: if uf.find(u) != uf.find(v): uf.union(u, v) mst_weight += w edges_used += 1 if edges_used == n - 1: return mst_weight else: return -1 def solve(n, m, edge_list): if n == 1: return 0 if m == 0 else -1 edges = [(u - 1, v - 1, w) for u, v, w in edge_list] return kruskal_minimum_spanning_tree(n, edges)"},{"question":"from typing import List, Tuple def unique_paths_count(n: int, m: int) -> int: Returns the number of unique paths in an n x m grid from top-left to bottom-right. >>> unique_paths_count(3, 2) 3 >>> unique_paths_count(2, 2) 2 def unique_paths(n: int, m: int) -> List[List[Tuple[int, int]]]: Returns all unique paths in an n x m grid from top-left to bottom-right. >>> unique_paths(3, 2) [ [(0, 0), (0, 1), (1, 1), (2, 1)], [(0, 0), (1, 0), (1, 1), (2, 1)], [(0, 0), (1, 0), (2, 0), (2, 1)] ] >>> unique_paths(2, 2) [ [(0, 0), (0, 1), (1, 1)], [(0, 0), (1, 0), (1, 1)] ] # Unit tests def test_unique_paths_count_3x2(): assert unique_paths_count(3, 2) == 3 def test_unique_paths_count_2x2(): assert unique_paths_count(2, 2) == 2 def test_unique_paths_3x2(): expected_paths = [ [(0, 0), (0, 1), (1, 1), (2, 1)], [(0, 0), (1, 0), (1, 1), (2, 1)], [(0, 0), (1, 0), (2, 0), (2, 1)] ] result_paths = unique_paths(3, 2) assert len(result_paths) == len(expected_paths) for path in expected_paths: assert path in result_paths def test_unique_paths_2x2(): expected_paths = [ [(0, 0), (0, 1), (1, 1)], [(0, 0), (1, 0), (1, 1)] ] result_paths = unique_paths(2, 2) assert len(result_paths) == len(expected_paths) for path in expected_paths: assert path in result_paths","solution":"def unique_paths_count(n, m): from math import comb return comb(n + m - 2, n - 1) def unique_paths(n, m): def backtrack(path, i, j): if i == n - 1 and j == m - 1: paths.append(path + [(i, j)]) return if i < n - 1: backtrack(path + [(i, j)], i + 1, j) if j < m - 1: backtrack(path + [(i, j)], i, j + 1) paths = [] backtrack([], 0, 0) return paths # Example usage: n, m = 3, 2 print(unique_paths_count(n, m)) for path in unique_paths(n, m): print(path)"},{"question":"def maximal_rectangle(grid: List[str]) -> int: Compute the maximum area of a rectangle containing only '1's in the given grid. >>> maximal_rectangle([\\"1010\\", \\"1011\\", \\"1111\\", \\"0111\\"]) 6 >>> maximal_rectangle([\\"001\\", \\"111\\"]) 3 >>> maximal_rectangle([\\"110\\", \\"110\\", \\"001\\"]) 4 >>> maximal_rectangle([]) 0 >>> maximal_rectangle([\\"000\\", \\"000\\", \\"000\\"]) 0 >>> maximal_rectangle([\\"11\\", \\"11\\"]) 4 >>> maximal_rectangle([\\"100\\", \\"000\\", \\"000\\"]) 1","solution":"def maximal_rectangle(grid): if not grid: return 0 n = len(grid) m = len(grid[0]) max_area = 0 heights = [0] * (m + 1) for row in grid: for i in range(m): heights[i] = heights[i] + 1 if row[i] == '1' else 0 stack = [-1] for i in range(m + 1): while heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) return max_area def compute_max_rectangle(n, m, grid_lines): grid = [grid_lines[i] for i in range(n)] return maximal_rectangle(grid)"},{"question":"def min_toggle_operations(N, states): Determine the minimum number of toggle operations required to make all switches either ON or OFF. Parameters: N (int): The number of switches (1 ≤ N ≤ 1000). states (list of int): A list of N integers denoting the initial states of the switches, where each integer is either 0 (OFF) or 1 (ON). Returns: int: The minimum number of toggle operations required to make all switches either ON or OFF. Examples: >>> min_toggle_operations(5, [1, 0, 1, 0, 1]) 2 >>> min_toggle_operations(4, [1, 1, 0, 0]) 2","solution":"def min_toggle_operations(N, states): This function returns the minimum number of toggle operations required to make all switches either ON or OFF. Parameters: N (int): The number of switches. states (list of int): The initial states of the switches. Returns: int: The minimum number of toggle operations required. # Count the number of switches that are ON (1) count_on = states.count(1) # Count the number of switches that are OFF (0) count_off = N - count_on # The minimum number of toggles required will be the lesser of the two counts return min(count_on, count_off)"},{"question":"from typing import List, Tuple def min_edit_distance(str1: str, str2: str) -> int: Returns the minimum number of operations required to convert str1 into str2. >>> min_edit_distance(\\"kitten\\", \\"sitting\\") 3 >>> min_edit_distance(\\"flaw\\", \\"lawn\\") 2 >>> min_edit_distance(\\"intention\\", \\"execution\\") 5 >>> min_edit_distance(\\"abc\\", \\"yabd\\") 2 >>> min_edit_distance(\\"abcdef\\", \\"ghijkl\\") 6 pass def process_test_cases(test_cases: List[Tuple[str, str]]) -> List[int]: Given a list of test cases (each is a tuple of two strings), returns a list of minimum edits required for each test case. >>> process_test_cases([(\\"kitten\\", \\"sitting\\"), (\\"flaw\\", \\"lawn\\"), (\\"intention\\", \\"execution\\")]) [3, 2, 5] pass def test_min_edit_distance(): assert min_edit_distance(\\"kitten\\", \\"sitting\\") == 3 assert min_edit_distance(\\"flaw\\", \\"lawn\\") == 2 assert min_edit_distance(\\"intention\\", \\"execution\\") == 5 assert min_edit_distance(\\"abc\\", \\"yabd\\") == 2 assert min_edit_distance(\\"abcdef\\", \\"ghijkl\\") == 6 def test_process_test_cases(): test_cases = [ (\\"kitten\\", \\"sitting\\"), (\\"flaw\\", \\"lawn\\"), (\\"intention\\", \\"execution\\") ] results = process_test_cases(test_cases) assert results == [3, 2, 5]","solution":"def min_edit_distance(str1, str2): Returns the minimum number of operations required to convert str1 into str2. The allowed operations are insert, delete, or replace a character. m = len(str1) n = len(str2) # Create a DP table to store the number of operations required dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the table for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # Minimum operations = j (all characters of str2 need to be inserted) elif j == 0: dp[i][j] = i # Minimum operations = i (all characters of str1 need to be deleted) elif str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters are the same, no new operation needed else: dp[i][j] = 1 + min(dp[i - 1][j], # Remove operation dp[i][j - 1], # Insert operation dp[i - 1][j - 1]) # Replace operation return dp[m][n] def process_test_cases(test_cases): results = [] for str1, str2 in test_cases: result = min_edit_distance(str1, str2) results.append(result) return results"},{"question":"def can_capture_flag(n: int, d: int, friends: List[Tuple[int, int, int]]) -> str: Determine if any friend can capture at least one flag given their positions and flag values, considering a maximum allowed distance. >>> can_capture_flag(4, 5, [(1, 1, 6), (7, 1, 12), (4, 4, 9), (6, 8, 18)]) == \\"Win\\" >>> can_capture_flag(3, 3, [(2, 3, 8), (10, 3, 32), (6, 5, 21)]) == \\"Lose\\"","solution":"import math def can_capture_flag(n, d, friends): def distance(x1, y1, x2, y2): return math.sqrt((x2 - x1)**2 + (y2 - y1)**2) for i in range(n): x1, y1, v1 = friends[i] for j in range(n): if i != j: x2, y2, v2 = friends[j] if v2 % v1 == 0 and distance(x1, y1, x2, y2) <= d: return \\"Win\\" return \\"Lose\\""},{"question":"def find_lexicographically_largest_subarray(n: int, arr: List[int]) -> Tuple[int, int]: Finds the starting and ending indices of the subarray such that reversing it makes the array lexicographically larger. If no such subarray exists, returns -1 -1. :param n: Length of the array :param arr: List of integers :return: Tuple of two integers >>> find_lexicographically_largest_subarray(5, [1, 3, 2, 4, 5]) (2, 3) >>> find_lexicographically_largest_subarray(4, [4, 3, 2, 1]) (1, 4) >>> find_lexicographically_largest_subarray(6, [1, 2, 3, 4, 5, 6]) (-1, -1)","solution":"def find_lexicographically_largest_subarray(n, arr): Finds the starting and ending indices of the subarray such that reversing it makes the array lexicographically larger. If no such subarray exists, returns -1 -1. :param n: Length of the array :param arr: List of integers :return: Tuple of two integers start, end = -1, -1 best_start, best_end = -1, -1 # Traverse the array to find potential subarray which when reversed makes it lexicographically larger for i in range(1, n): if arr[i] < arr[i - 1]: if start == -1: start = i - 1 end = i elif start != -1: if best_start == -1 or arr[start:end + 1][::-1] > arr[best_start:best_end + 1][::-1]: best_start, best_end = start, end start, end = -1, -1 if start != -1: if best_start == -1 or arr[start:end + 1][::-1] > arr[best_start:best_end + 1][::-1]: best_start, best_end = start, end if best_start == -1: return (-1, -1) return (best_start + 1, best_end + 1)"},{"question":"def process_operations(n: int, gemstones: List[int], operations: List[List[str]]) -> List[int]: Perform a series of update and query operations on a list of gemstones. Parameters: n (int): Number of gemstones. gemstones (List[int]): List of gemstone values. operations (List[List[str]]): List of operations to perform. Each operation is either: - \\"UPDATE x y\\" to update the gemstone at position x to value y. - \\"QUERY l r\\" to calculate the sum of gemstone values from position l to r. Returns: List[int]: List of results for each query operation. >>> process_operations(5, [1, 2, 3, 4, 5], [[\\"QUERY\\", \\"1\\", \\"3\\"], [\\"UPDATE\\", \\"2\\", \\"10\\"], [\\"QUERY\\", \\"1\\", \\"3\\"]]) [9, 16] >>> process_operations(1, [5], [[\\"QUERY\\", \\"0\\", \\"0\\"]]) [5] >>> process_operations(3, [10, 20, 30], [[\\"UPDATE\\", \\"1\\", \\"15\\"], [\\"QUERY\\", \\"0\\", \\"2\\"]]) [55] >>> process_operations(5, [1, 2, 3, 4, 5], [[\\"UPDATE\\", \\"0\\", \\"10\\"], [\\"UPDATE\\", \\"4\\", \\"20\\"], [\\"QUERY\\", \\"0\\", \\"4\\"]]) [39] >>> process_operations(100, list(range(1, 101)), [[\\"QUERY\\", \\"0\\", \\"99\\"]]) [5050]","solution":"class GemstoneRitual: def __init__(self, gemstones): self.n = len(gemstones) self.tree = [0] * (2 * self.n) self.build(gemstones) def build(self, gemstones): # Build the segment tree for i in range(self.n): self.tree[self.n + i] = gemstones[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def update(self, pos, value): # Update the value at index pos pos += self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def query(self, left, right): # Query the sum in the range [left, right] left += self.n right += self.n + 1 sum = 0 while left < right: if left % 2: sum += self.tree[left] left += 1 if right % 2: right -= 1 sum += self.tree[right] left //= 2 right //= 2 return sum def process_operations(n, gemstones, operations): ritual = GemstoneRitual(gemstones) result = [] for operation in operations: if operation[0] == \\"UPDATE\\": pos = int(operation[1]) value = int(operation[2]) ritual.update(pos, value) elif operation[0] == \\"QUERY\\": left = int(operation[1]) right = int(operation[2]) result.append(ritual.query(left, right)) return result"},{"question":"def floyd_warshall(cities: int, roads: int, edges: List[Tuple[int, int, int]]) -> List[List[int]]: Compute the shortest travel distance between every pair of branches in the network. Args: cities (int): The number of branches (or cities). roads (int): The number of direct roads. edges (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers u_i, v_i, and d_i representing a direct road between branch u_i and branch v_i with a travel distance of d_i. Returns: List[List[int]]: A 2D list where the element at the ith row and jth column represents the shortest travel distance between branch i and branch j. If there is no path between branch i and branch j, the corresponding position contains -1. Example: >>> cities = 4 >>> roads = 5 >>> edges = [(0, 1, 4), (0, 2, 1), (1, 2, 2), (1, 3, 5), (2, 3, 1)] >>> floyd_warshall(cities, roads, edges) [[0, 3, 1, 2], [3, 0, 2, 3], [1, 2, 0, 1], [2, 3, 1, 0]]","solution":"def floyd_warshall(cities, roads, edges): # Initialize distance matrix INF = float('inf') dist = [[INF] * cities for _ in range(cities)] # Distance from each city to itself is 0 for i in range(cities): dist[i][i] = 0 # Apply the edge weights to the distance matrix for u, v, d in edges: dist[u][v] = d dist[v][u] = d # Floyd-Warshall algorithm for k in range(cities): for i in range(cities): for j in range(cities): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] # Replace infinite distances with -1 for unreachable pairs for i in range(cities): for j in range(cities): if dist[i][j] == INF: dist[i][j] = -1 return dist"},{"question":"def can_sweep_all_cells(m: int, n: int, sx: int, sy: int, grid: List[str]) -> str: Determines if SweepBot can clean all open cells in the grid. Parameters: m (int): Number of rows in the grid. n (int): Number of columns in the grid. sx (int): Starting row position of SweepBot. sy (int): Starting column position of SweepBot. grid (List[str]): The grid representing the living space. Returns: str: \\"YES\\" if SweepBot can clean all open cells, otherwise \\"NO\\". Examples: >>> can_sweep_all_cells(3, 4, 1, 1, [\\"....\\", \\"..\\", \\"....\\"]) == \\"YES\\" >>> can_sweep_all_cells(3, 4, 1, 1, [\\".#\\", \\".#..\\", \\".#..\\"]) == \\"NO\\" >>> can_sweep_all_cells(1, 1, 1, 1, [\\".\\"]) == \\"YES\\" >>> can_sweep_all_cells(2, 2, 1, 1, [\\"..\\", \\"..\\"]) == \\"YES\\" >>> can_sweep_all_cells(2, 2, 1, 1, [\\".#\\", \\"#.\\"]) == \\"NO\\" >>> can_sweep_all_cells(3, 3, 1, 1, [\\"#\\", \\"#.#\\", \\"#\\"]) == \\"NO\\"","solution":"def can_sweep_all_cells(m, n, sx, sy, grid): Determines if SweepBot can clean all open cells in the grid. sx -= 1 # Adjust for 0-based index sy -= 1 # Adjust for 0-based index visited = [[False] * n for _ in range(m)] def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == '#' or visited[x][y]: return visited[x][y] = True dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) dfs(sx, sy) for row in range(m): for col in range(n): if grid[row][col] == '.' and not visited[row][col]: return \\"NO\\" return \\"YES\\""},{"question":"def path_exists(grid): Determine if there is a path from the top-left corner to the bottom-right corner of the grid. >>> path_exists([ ... \\"0001\\", ... \\"0110\\", ... \\"0100\\", ... \\"0000\\" ... ]) \\"YES\\" >>> path_exists([ ... \\"010\\", ... \\"011\\", ... \\"100\\" ... ]) \\"NO\\"","solution":"def path_exists(grid): from collections import deque rows = len(grid) cols = len(grid[0]) if grid[0][0] == '1' or grid[rows-1][cols-1] == '1': return \\"NO\\" directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if x == rows - 1 and y == cols - 1: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == '0' and (nx, ny) not in visited: queue.append((nx, ny)) visited.add((nx, ny)) return \\"NO\\""},{"question":"def max_trees_on_diagonal(n: int, m: int) -> int: Returns the maximum number of trees that can be planted on one of the primary diagonals or its upper/lower parallel diagonals in an n x m grid. >>> max_trees_on_diagonal(3, 3) 3 >>> max_trees_on_diagonal(5, 4) 4 >>> max_trees_on_diagonal(4, 5) 4 >>> max_trees_on_diagonal(1, 5) 1 >>> max_trees_on_diagonal(5, 1) 1 >>> max_trees_on_diagonal(1, 1) 1 >>> max_trees_on_diagonal(1000, 1000) 1000 >>> max_trees_on_diagonal(1000, 500) 500 >>> max_trees_on_diagonal(500, 1000) 500","solution":"def max_trees_on_diagonal(n, m): Returns the maximum number of trees that can be planted on one of the primary diagonals or its upper/lower parallel diagonals in an n x m grid. return min(n, m)"},{"question":"def count_twin_prime_pairs(n, numbers): Returns the count of numbers in the collection that are part of at least one twin prime pair. >>> count_twin_prime_pairs(5, [3, 5, 6, 11, 13]) 4 >>> count_twin_prime_pairs(4, [1, 2, 4, 10]) 0","solution":"def is_prime(n): Determines if a number is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def count_twin_prime_pairs(n, numbers): Returns the count of numbers in the collection that are part of at least one twin prime pair. # To store a set of numbers for quick lookup num_set = set(numbers) twin_prime_count = 0 for num in num_set: if is_prime(num) and ((num + 2 in num_set and is_prime(num + 2)) or (num - 2 in num_set and is_prime(num - 2))): twin_prime_count += 1 return twin_prime_count # Example usage n = 5 numbers = [3, 5, 6, 11, 13] print(count_twin_prime_pairs(n, numbers)) # Output: 4"},{"question":"import heapq from typing import List def minimized_max_box_size(n: int, sizes: List[int]) -> int: Given a number of boxes and their respective sizes, this function returns the minimized maximum size of the single resulting box after combining all possible pairs sequentially. pass def test_example_1(): assert minimized_max_box_size(5, [1, 2, 3, 4, 5]) == 15 def test_example_2(): assert minimized_max_box_size(4, [4, 2, 9, 1]) == 16 def test_single_combination(): assert minimized_max_box_size(2, [1, 3]) == 4 def test_all_equal_boxes(): assert minimized_max_box_size(3, [3, 3, 3]) == 9 def test_large_numbers(): assert minimized_max_box_size(3, [10**9, 10**9, 10**9]) == 3000000000","solution":"import heapq def minimized_max_box_size(n, sizes): Given a number of boxes and their respective sizes, this function returns the minimized maximum size of the single resulting box after combining all possible pairs sequentially. # Use a min-heap to always combine the smallest two elements heapq.heapify(sizes) while len(sizes) > 1: # Pop the two smallest elements a = heapq.heappop(sizes) b = heapq.heappop(sizes) # Combine them combined_size = a + b # Add the combined size back to the heap heapq.heappush(sizes, combined_size) # The final element in the heap is the minimized max size of the combined box return sizes[0]"},{"question":"def shift_string(S: str, N: int) -> str: Shifts each character in the string S by a fixed number N in the alphabet. The shift wraps around the alphabet. Parameters: S (str): Input string consisting only of uppercase English letters. N (int): The fixed number by which to shift each character. Returns: str: The encrypted string after shifting each character by N positions. pass # Test cases def test_shift_within_bounds(): assert shift_string(\\"HELLO\\", 3) == \\"KHOOR\\" assert shift_string(\\"WORLD\\", 4) == \\"ASVPH\\" def test_shift_wrap_around(): assert shift_string(\\"APPLE\\", 25) == \\"ZOOKD\\" assert shift_string(\\"Z\\", 1) == \\"A\\" def test_shift_no_shift(): assert shift_string(\\"HELLO\\", 0) == \\"HELLO\\" def test_shift_repeatedly_to_return_to_same(): assert shift_string(\\"HELLO\\", 26) == \\"HELLO\\" def test_shift_all_alphabet(): assert shift_string(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\", 1) == \\"BCDEFGHIJKLMNOPQRSTUVWXYZA\\" assert shift_string(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\", 25) == \\"ZABCDEFGHIJKLMNOPQRSTUVWXY\\" assert shift_string(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\", 26) == \\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" def test_shift_large_N(): assert shift_string(\\"A\\", 27) == \\"B\\" assert shift_string(\\"A\\", 52) == \\"A\\"","solution":"def shift_string(S: str, N: int) -> str: Shifts each character in the string S by a fixed number N in the alphabet. The shift wraps around the alphabet. Parameters: S (str): Input string consisting only of uppercase English letters. N (int): The fixed number by which to shift each character. Returns: str: The encrypted string after shifting each character by N positions. shifted_string = [] for char in S: # Calculate the new character position new_pos = (ord(char) - ord('A') + N) % 26 # Convert the position back to a character new_char = chr(ord('A') + new_pos) shifted_string.append(new_char) return ''.join(shifted_string)"},{"question":"def can_fill_grid(n: int, m: int) -> str: Determines if it's possible to fill an n x m grid according to the rules. No two adjacent cells (sharing an edge) should have the same color. >>> can_fill_grid(2, 2) \\"YES\\" >>> can_fill_grid(3, 3) \\"YES\\" >>> can_fill_grid(1, 5) \\"YES\\" >>> can_fill_grid(4, 4) \\"YES\\"","solution":"def can_fill_grid(n, m): Determines if it's possible to fill an n x m grid according to the rules. No two adjacent cells (sharing an edge) should have the same color. return \\"YES\\""},{"question":"def calculate_overlap_area(x1, y1, x2, y2, x3, y3, x4, y4): Calculate the area of the overlap between two rectangles. The first rectangle is defined by two points (x1, y1) and (x2, y2). The second rectangle is defined by two points (x3, y3) and (x4, y4). Returns the overlap area if any, otherwise 0. >>> calculate_overlap_area(1, 1, 4, 3, 2, 2, 5, 5) 2 >>> calculate_overlap_area(0, 0, 2, 2, 2, 2, 4, 4) 0 >>> calculate_overlap_area(1, 1, 3, 3, 2, 0, 5, 4) 2","solution":"def calculate_overlap_area(x1, y1, x2, y2, x3, y3, x4, y4): Calculate the area of the overlap between two rectangles. The first rectangle is defined by two points (x1, y1) and (x2, y2). The second rectangle is defined by two points (x3, y3) and (x4, y4). Returns the overlap area if any, otherwise 0. # Ensure that for each rectangle, we know the bottom-left and top-right corners x1, y1, x2, y2 = min(x1, x2), min(y1, y2), max(x1, x2), max(y1, y2) x3, y3, x4, y4 = min(x3, x4), min(y3, y4), max(x3, x4), max(y3, y4) # Calculate the overlapping rectangle's bottom-left and top-right corners overlap_x1 = max(x1, x3) overlap_y1 = max(y1, y3) overlap_x2 = min(x2, x4) overlap_y2 = min(y2, y4) # Check if there is an overlap if overlap_x1 < overlap_x2 and overlap_y1 < overlap_y2: overlap_width = overlap_x2 - overlap_x1 overlap_height = overlap_y2 - overlap_y1 return overlap_width * overlap_height else: return 0"},{"question":"def max_consecutive_castles(n: int, heights: List[int]) -> int: Returns the maximum number of consecutive castles that can be hit by a single arrow. Parameters: n (int): The number of castles. heights (List[int]): The heights of the castles. Returns: int: The maximum number of consecutive castles that can be hit by a single arrow. Examples: >>> max_consecutive_castles(5, [3, 3, 3, 2, 2]) 3 >>> max_consecutive_castles(6, [1, 2, 3, 4, 5, 6]) 1","solution":"def max_consecutive_castles(n, heights): Returns the maximum number of consecutive castles that can be hit by a single arrow. if n <= 1: return n # Initialize variables max_length = 1 current_length = 1 # Iterate through the list to find the longest streak of the same height for i in range(1, n): if heights[i] == heights[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 # Update max_length in case the longest streak ends at the last element max_length = max(max_length, current_length) return max_length"},{"question":"def num_groups(n: int, patterns: List[str]) -> int: Function to compute the number of distinct groups of bird species based on similarity of their singing patterns. Parameters: n (int): Number of bird species. patterns (List[str]): List of singing patterns of each species. Returns: int: Number of distinct groups based on the similarity of singing patterns. pass import unittest class TestNumGroups(unittest.TestCase): def test_example_1(self): self.assertEqual(num_groups(4, [\\"abcd\\", \\"dcba\\", \\"abc\\", \\"xy\\"]), 3) def test_example_2(self): self.assertEqual(num_groups(3, [\\"abc\\", \\"bca\\", \\"acb\\"]), 1) def test_single_pattern(self): self.assertEqual(num_groups(1, [\\"a\\"]), 1) def test_all_unique_patterns(self): self.assertEqual(num_groups(5, [\\"abcd\\", \\"efgh\\", \\"ijkl\\", \\"mnop\\", \\"qrst\\"]), 5) def test_some_similar_patterns(self): self.assertEqual(num_groups(6, [\\"abcd\\", \\"efgh\\", \\"dcba\\", \\"hgfe\\", \\"ijkl\\", \\"ijkl\\"]), 3) def test_complex_patterns(self): self.assertEqual(num_groups(4, [\\"abcdefgh\\", \\"hgfedcba\\", \\"abcdefgh\\", \\"abcdefgh\\"]), 1) def test_large_input(self): patterns = [\\"abcd\\", \\"dcba\\", \\"abcd\\", \\"dcba\\", \\"abcd\\"] * 200 self.assertEqual(num_groups(1000, patterns), 1) if __name__ == \\"__main__\\": unittest.main()","solution":"def num_groups(n, patterns): Function to compute the number of distinct groups of bird species based on similarity of their singing patterns. Parameters: n (int): Number of bird species. patterns (List[str]): List of singing patterns of each species. Returns: int: Number of distinct groups based on the similarity of singing patterns. def pattern_signature(pattern): Generate a signature for a pattern that is invariant to any character swaps. return ''.join(sorted(pattern)) unique_signatures = set(pattern_signature(pattern) for pattern in patterns) return len(unique_signatures)"},{"question":"def top_k_popular_books(books: List[Tuple[str, int]], k: int) -> List[Tuple[str, int]]: Returns the k books with the highest popularity scores. If there are ties, books with the same popularity score are ordered by ISBN in ascending order. Args: books: A list of tuples (ISBN, popularity) where ISBN is a string and popularity is an integer. k: An integer denoting the number of top books to return. Returns: A list of k tuples representing the most popular books, sorted as described above. Examples: >>> top_k_popular_books([(\\"978-3-16-148410-0\\", 5), (\\"978-0-306-40615-7\\", 3), (\\"978-0-262-03384-8\\", 5), (\\"978-1-4028-9462-6\\", 2)], 2) [(\\"978-0-262-03384-8\\", 5), (\\"978-3-16-148410-0\\", 5)] >>> top_k_popular_books([(\\"978-3-16-148410-0\\", 3), (\\"978-0-306-40615-7\\", 3), (\\"978-0-262-03384-8\\", 3), (\\"978-1-4028-9462-6\\", 3)], 3) [(\\"978-0-262-03384-8\\", 3), (\\"978-0-306-40615-7\\", 3), (\\"978-1-4028-9462-6\\", 3)] >>> top_k_popular_books([(\\"978-3-16-148410-0\\", 5)], 1) [(\\"978-3-16-148410-0\\", 5)]","solution":"def top_k_popular_books(books, k): Returns the k books with the highest popularity scores. If there are ties, books with the same popularity score are ordered by ISBN. :param books: List of tuples (ISBN, popularity) :param k: Integer, number of top books to return :return: List of k tuples representing the most popular books # Sort books first by descending popularity and then by ascending ISBN sorted_books = sorted(books, key=lambda x: (-x[1], x[0])) # Return the top k books return sorted_books[:k]"},{"question":"def max_fruits_collected(n: int, T: int, days_to_mature: List[int]) -> int: Find the maximum number of fruits that can be collected after T days. >>> max_fruits_collected(3, 10, [3, 5, 1]) 21 >>> max_fruits_collected(4, 7, [0, 2, 4, 3]) 19","solution":"def max_fruits_collected(n, T, days_to_mature): total_fruits = 0 for d in days_to_mature: if d <= T: total_fruits += (T - d) return total_fruits"},{"question":"class Farm: def __init__(self, productivity): Initialize the farm with initial productivity ratings. :param productivity: List[int] - List of productivity ratings self.productivity = productivity def increase_productivity(self, i: int, x: int): Increase the productivity of the cow at 1-based index i by x. :param i: int - 1-based index of the cow :param x: int - Amount to increase pass def max_difference_in_range(self, l: int, r: int) -> int: Calculate the maximum difference in productivity between cows in the range [l, r]. :param l: int - 1-based start index :param r: int - 1-based end index :return: int - Maximum difference in productivity pass def process_queries(n: int, q: int, p: List[int], queries: List[List[int]]) -> List[int]: Process a list of queries on the farm's productivity. :param n: int - Number of cows :param q: int - Number of queries :param p: List[int] - Initial productivity ratings of the cows :param queries: List[List[int]] - List of queries :return: List[int] - Results for the queries of type 2 pass # Example Test Cases if __name__ == \\"__main__\\": n, q = 5, 4 p = [10, 20, 30, 40, 50] queries = [ [2, 1, 5], [1, 3, 10], [2, 1, 3], [2, 3, 5] ] print(process_queries(n, q, p, queries)) # Expected Output: [40, 30, 10] # Include additional test cases if necessary","solution":"class Farm: def __init__(self, productivity): self.productivity = productivity def increase_productivity(self, i, x): # increase productivity of cow at index i (1-based index) self.productivity[i - 1] += x def max_difference_in_range(self, l, r): # get the maximum difference in productivity between indices l and r (1-based index) range_productivity = self.productivity[l - 1:r] return max(range_productivity) - min(range_productivity) def process_queries(n, q, p, queries): farm = Farm(p) results = [] for query in queries: t = query[0] if t == 1: _, i, x = query farm.increase_productivity(i, x) elif t == 2: _, l, r = query result = farm.max_difference_in_range(l, r) results.append(result) return results # Example usage: n, q = 5, 4 p = [10, 20, 30, 40, 50] queries = [ [2, 1, 5], [1, 3, 10], [2, 1, 3], [2, 3, 5] ] print(process_queries(n, q, p, queries))"},{"question":"def merge_and_sort_arrays(a: List[int], b: List[int]) -> List[int]: Merges two arrays a and b and sorts them in non-decreasing order. >>> merge_and_sort_arrays([1, 3, 5, 7, 9], [2, 4, 6]) [1, 2, 3, 4, 5, 6, 7, 9] >>> merge_and_sort_arrays([10, 20, 30, 40], [1, 2, 3, 4]) [1, 2, 3, 4, 10, 20, 30, 40] # Test cases def test_merge_and_sort_example1(): a = [1, 3, 5, 7, 9] b = [2, 4, 6] assert merge_and_sort_arrays(a, b) == [1, 2, 3, 4, 5, 6, 7, 9] def test_merge_and_sort_example2(): a = [10, 20, 30, 40] b = [1, 2, 3, 4] assert merge_and_sort_arrays(a, b) == [1, 2, 3, 4, 10, 20, 30, 40] def test_merge_and_sort_same_elements(): a = [1, 1, 1] b = [1, 1, 1] assert merge_and_sort_arrays(a, b) == [1, 1, 1, 1, 1, 1] def test_merge_and_sort_single_element(): a = [5] b = [3] assert merge_and_sort_arrays(a, b) == [3, 5] def test_merge_and_sort_empty_b(): a = [3, 4, 5] b = [] assert merge_and_sort_arrays(a, b) == [3, 4, 5] def test_merge_and_sort_empty_a(): a = [] b = [1, 2, 3] assert merge_and_sort_arrays(a, b) == [1, 2, 3] def test_merge_and_sort_large_elements(): a = [1000000000, 999999999] b = [1000000001, 1000000002] assert merge_and_sort_arrays(a, b) == [999999999, 1000000000, 1000000001, 1000000002]","solution":"def merge_and_sort_arrays(a, b): Merges two arrays a and b and sorts them in non-decreasing order. # Combine both arrays a.extend(b) # Sort the combined array a.sort() return a # Example usage: # n, m = 5, 3 # a = [1, 3, 5, 7, 9] # b = [2, 4, 6] # result = merge_and_sort_arrays(a, b) # print(result) # Output: [1, 2, 3, 4, 5, 6, 7, 9]"},{"question":"def can_swap_to_equal(A: str, B: str) -> str: Determines if string A can be made equal to string B by swapping at most one pair of characters in A. >>> can_swap_to_equal(\\"ab\\", \\"ba\\") \\"Yes\\" >>> can_swap_to_equal(\\"ab\\", \\"ab\\") \\"Yes\\" >>> can_swap_to_equal(\\"abc\\", \\"bca\\") \\"No\\" >>> can_swap_to_equal(\\"aaaa\\", \\"aaab\\") \\"No\\"","solution":"def can_swap_to_equal(A, B): Determines if string A can be made equal to string B by swapping at most one pair of characters in A. if A == B: return \\"Yes\\" diff = [(a, b) for a, b in zip(A, B) if a != b] if len(diff) != 2: return \\"No\\" (a1, b1), (a2, b2) = diff if a1 == b2 and b1 == a2: return \\"Yes\\" return \\"No\\""},{"question":"from typing import List def shortest_path(grid: List[List[str]]) -> int: Returns the length of the shortest path from the top-left to the bottom-right corner. >>> shortest_path([['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.']]) 4 >>> shortest_path([['.', '#', '.'], ['.', '#', '.'], ['.', '#', '.']]) -1 >>> shortest_path([['.']]) 0 >>> shortest_path([['#', '.'], ['.', '.']]) -1 >>> shortest_path([['.', '.'], ['.', '#']]) -1","solution":"from collections import deque def shortest_path(grid): Returns the length of the shortest path from the top-left to the bottom-right corner. N = len(grid) M = len(grid[0]) if grid[0][0] == '#' or grid[N-1][M-1] == '#': return -1 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # down, up, right, left queue = deque([(0, 0, 0)]) # (row, column, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == N-1 and y == M-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and (nx, ny) not in visited and grid[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny, dist+1)) return -1"},{"question":"def is_valid_ordering(wishlist, order_list): Determines if the order list is a valid ordering of the wishlist. Args: wishlist (list of str): The wishlist of books. order_list (list of str): The order list of books. Returns: str: \\"Yes\\" if order list is a valid ordering, \\"No\\" otherwise. >>> is_valid_ordering([\\"book1\\", \\"book2\\", \\"book3\\", \\"book4\\", \\"book5\\"], [\\"book1\\", \\"book3\\", \\"book5\\"]) 'Yes' >>> is_valid_ordering([\\"novel1\\", \\"novel2\\", \\"novel3\\", \\"novel4\\"], [\\"novel4\\", \\"novel2\\", \\"novel3\\", \\"novel1\\"]) 'No' >>> is_valid_ordering([\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"], [\\"a\\", \\"b\\", \\"c\\"]) 'Yes' >>> is_valid_ordering([\\"apple\\", \\"banana\\", \\"cherry\\"], [\\"banana\\", \\"cherry\\", \\"apple\\"]) 'No' >>> is_valid_ordering([\\"first\\", \\"second\\", \\"third\\"], [\\"first\\", \\"second\\", \\"third\\"]) 'Yes' pass","solution":"def is_valid_ordering(wishlist, order_list): Determines if the order list is a valid ordering of the wishlist. Args: wishlist (list of str): The wishlist of books. order_list (list of str): The order list of books. Returns: str: \\"Yes\\" if order list is a valid ordering, \\"No\\" otherwise. wishlist_index = 0 for book in order_list: while wishlist_index < len(wishlist) and wishlist[wishlist_index] != book: wishlist_index += 1 if wishlist_index == len(wishlist): return \\"No\\" wishlist_index += 1 return \\"Yes\\""},{"question":"from typing import List, Tuple def find_depth(n: int, relationships: List[Tuple[int, int]]) -> int: Determine the depth of the employee tree. Args: n (int): The number of employees including the CEO. relationships (List[Tuple[int, int]]): A list containing pairs of integers indicating the supervisory relationships. Returns: int: The depth of the employee tree if the structure is valid, otherwise -1. >>> find_depth(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) 3 >>> find_depth(5, [(1, 2), (2, 3), (3, 4), (4, 1)]) -1","solution":"def find_depth(n, relationships): from collections import defaultdict, deque if n == 1: return 1 graph = defaultdict(list) in_degree = [0] * (n + 1) for u, v in relationships: graph[u].append(v) in_degree[v] += 1 roots = [i for i in range(1, n + 1) if in_degree[i] == 0] if len(roots) != 1: return -1 root = roots[0] def bfs(root): queue = deque([(root, 1)]) max_depth = 1 visited = set() while queue: node, depth = queue.popleft() if node in visited: return -1 visited.add(node) max_depth = max(max_depth, depth) for neighbor in graph[node]: queue.append((neighbor, depth + 1)) if len(visited) != n: return -1 return max_depth return bfs(root)"},{"question":"def convert_to_24_hour_format(time: str) -> str: Converts a time from 12-hour format (hh:mmAM or hh:mmPM) to 24-hour format (HH:MM). Parameters: time (str): Time in 12-hour format, e.g., \\"07:45PM\\" Returns: str: Time in 24-hour format, e.g., \\"19:45\\" >>> convert_to_24_hour_format(\\"07:45PM\\") '19:45' >>> convert_to_24_hour_format(\\"12:00AM\\") '00:00' >>> convert_to_24_hour_format(\\"01:15AM\\") '01:15' >>> convert_to_24_hour_format(\\"12:30PM\\") '12:30' >>> convert_to_24_hour_format(\\"11:59AM\\") '11:59' >>> convert_to_24_hour_format(\\"11:59PM\\") '23:59'","solution":"def convert_to_24_hour_format(time): Converts a time from 12-hour format (hh:mmAM/PM) to 24-hour format (HH:MM). Parameters: time (str): Time in 12-hour format, e.g., \\"07:45PM\\" Returns: str: Time in 24-hour format, e.g., \\"19:45\\" # Extract AM/PM period = time[-2:] # Extract hours and minutes hh, mm = map(int, time[:-2].split(':')) if period == \\"AM\\": if hh == 12: hh = 0 else: # PM case if hh != 12: hh += 12 return f\\"{hh:02}:{mm:02}\\""},{"question":"def process_transactions(n: int, transactions: List[Dict[str, Union[str, int]]]) -> Dict[str, List[int]]: Processes stock market transactions and returns the total number of unmatched buy and sell orders for each stock symbol. >>> transactions = [ {\\"type\\": \\"buy\\", \\"symbol\\": \\"AAPL\\", \\"shares\\": 100}, {\\"type\\": \\"sell\\", \\"symbol\\": \\"AAPL\\", \\"shares\\": 50}, {\\"type\\": \\"buy\\", \\"symbol\\": \\"GOOG\\", \\"shares\\": 200}, {\\"type\\": \\"sell\\", \\"symbol\\": \\"AAPL\\", \\"shares\\": 50}, {\\"type\\": \\"sell\\", \\"symbol\\": \\"GOOG\\", \\"shares\\": 200} ] >>> n = 5 >>> process_transactions(n, transactions) == { \\"AAPL\\": [0, 0], \\"GOOG\\": [0, 0] } >>> transactions = [ {\\"type\\": \\"buy\\", \\"symbol\\": \\"MSFT\\", \\"shares\\": 100}, {\\"type\\": \\"buy\\", \\"symbol\\": \\"MSFT\\", \\"shares\\": 50}, {\\"type\\": \\"sell\\", \\"symbol\\": \\"MSFT\\", \\"shares\\": 70}, {\\"type\\": \\"sell\\", \\"symbol\\": \\"MSFT\\", \\"shares\\": 30} ] >>> n = 4 >>> process_transactions(n, transactions) == { \\"MSFT\\": [50, 0] }","solution":"def process_transactions(n, transactions): order_book = {} for transaction in transactions: stock = transaction[\\"symbol\\"] if stock not in order_book: order_book[stock] = [0, 0] if transaction[\\"type\\"] == \\"buy\\": order_book[stock][0] += transaction[\\"shares\\"] elif transaction[\\"type\\"] == \\"sell\\": order_book[stock][1] += transaction[\\"shares\\"] # Match transactsions if possible if order_book[stock][0] > 0 and order_book[stock][1] > 0: min_shares = min(order_book[stock][0], order_book[stock][1]) order_book[stock][0] -= min_shares order_book[stock][1] -= min_shares return order_book"},{"question":"def unique_combinations(n: int, k: int) -> int: Returns the total number of unique combinations of n spices where each spice can be added in quantities from 0 to k (inclusive). >>> unique_combinations(2, 2) 9 >>> unique_combinations(3, 1) 8","solution":"def unique_combinations(n, k): Returns the total number of unique combinations of n spices where each spice can be added in quantities from 0 to k (inclusive). return (k + 1) ** n"},{"question":"def rearrange_commits(commit_history: str) -> str: Rearranges the commit history such that all feature commits are grouped together, followed by all bugfix commits, and finally all refactor commits, without changing the relative order of commits in the same category. Parameters: commit_history (str): A string consisting of 'F', 'B', and 'R' characters. Returns: str: Rearranged commit history. Examples: >>> rearrange_commits(\\"FBFRRBBR\\") 'FFBBBRRR' >>> rearrange_commits(\\"RFB\\") 'FBR'","solution":"def rearrange_commits(commit_history): Rearranges the commit history such that all feature commits are grouped together, followed by all bugfix commits, and finally all refactor commits, without changing the relative order of commits in the same category. Parameters: commit_history (str): A string consisting of 'F', 'B', and 'R' characters. Returns: str: Rearranged commit history. features = [] bugfixes = [] refactors = [] for commit in commit_history: if commit == 'F': features.append(commit) elif commit == 'B': bugfixes.append(commit) elif commit == 'R': refactors.append(commit) return ''.join(features) + ''.join(bugfixes) + ''.join(refactors)"},{"question":"def max_sum_with_one_skip(arr): John loves solving puzzles and recently he came across an interesting one involving numbers. The puzzle is as follows: Given a list of \`N\` integers, you need to find the maximum sum of a contiguous subarray with the caveat that you are allowed to skip at most one element. That is, you can remove one element from the array to get the subarray with the highest possible sum. Input: - The first line contains an integer \`N\`, the number of integers in the list. - The second line contains \`N\` space-separated integers representing the list. Output: - Output the maximum sum of a contiguous subarray where you can skip at most one element. Constraints: - 1 ≤ N ≤ 100000 - -10000 ≤ list[i] ≤ 10000 Sample Input: >>> max_sum_with_one_skip([1, -2, 0, 3, -1, 2, 4]) 9 Sample Output: The best subarray without skipping any element is [3, -1, 2, 4] which sums to 8. However, if we skip the -1, we have the subarray [3, 2, 4] which sums to 9. Hence, the output is 9.","solution":"def max_sum_with_one_skip(arr): This function calculates the maximum sum of a contiguous subarray with the option to skip at most one element. n = len(arr) if n == 0: return 0 if n == 1: return arr[0] # Initialize the arrays for dynamic programming max_end_here = [0] * n max_remove_here = [0] * n max_end_here[0] = arr[0] max_remove_here[0] = float('-inf') max_sum = arr[0] for i in range(1, n): max_end_here[i] = max(arr[i], max_end_here[i-1] + arr[i]) max_remove_here[i] = max(max_end_here[i-1], max_remove_here[i-1] + arr[i]) max_sum = max(max_sum, max_end_here[i], max_remove_here[i]) return max_sum"},{"question":"def count_distinct_substrings(s: str, k: int) -> int: Returns the number of distinct substrings of length k that can be formed from the string s. >>> count_distinct_substrings(\\"abcabc\\", 3) 3 >>> count_distinct_substrings(\\"aaaaa\\", 2) 1 pass def handle_queries(queries: List[Tuple[str, int]]) -> List[int]: Processes multiple queries and returns the results. >>> handle_queries([(\\"abcabc\\", 3), (\\"aaaaa\\", 2)]) [3, 1] >>> handle_queries([(\\"abcdef\\", 6), (\\"abcd\\", 5)]) [1, 0] pass","solution":"def count_distinct_substrings(s, k): Returns the number of distinct substrings of length k that can be formed from the string s. if len(s) < k: return 0 substrings = set() for i in range(len(s) - k + 1): substrings.add(s[i:i+k]) return len(substrings) def handle_queries(queries): results = [] for s, k in queries: results.append(count_distinct_substrings(s, k)) return results"},{"question":"def factorial(N: int) -> int: Computes the factorial of a given integer N. >>> factorial(0) == 1 >>> factorial(1) == 1 >>> factorial(5) == 120 >>> factorial(10) == 3628800 >>> factorial(20) == 2432902008176640000","solution":"def factorial(N): Computes the factorial of a given integer N. if N == 0: return 1 result = 1 for i in range(1, N + 1): result *= i return result"},{"question":"def is_permutation_subsequence(s: str, t: str) -> str: Determines if any permutation of s is a subsequence of t. >>> is_permutation_subsequence(\\"abc\\", \\"ahbgdc\\") == \\"YES\\" >>> is_permutation_subsequence(\\"ab\\", \\"baabc\\") == \\"YES\\" >>> is_permutation_subsequence(\\"xyz\\", \\"aabbcc\\") == \\"NO\\"","solution":"def is_permutation_subsequence(s, t): Determines if any permutation of s is a subsequence of t. from collections import Counter # Count characters in s count_s = Counter(s) # Filter relevant characters in t based on characters in s relevant_t = [char for char in t if char in count_s] # Count characters in the filtered t count_t = Counter(relevant_t) # Check if count_t has at least as many characters as count_s for each character in s for char in count_s: if count_t[char] < count_s[char]: return \\"NO\\" return \\"YES\\""},{"question":"def manage_inventory(operations: list) -> dict: Manages the inventory based on the given operations. Parameters: operations (list): List of operations in the form of strings. Returns: dict: Dictionary with final quantities of each item type.","solution":"def manage_inventory(operations): Manages the inventory based on the given operations. Parameters: operations (list): List of operations in the form of strings. Returns: dict: Dictionary with final quantities of each item type. inventory = {} for operation in operations: parts = operation.split() quantity = int(parts[1]) item_type = parts[-1] if parts[0] == \\"Add\\": if item_type in inventory: inventory[item_type] += quantity else: inventory[item_type] = quantity elif parts[0] == \\"Remove\\": if item_type in inventory: inventory[item_type] = max(0, inventory[item_type] - quantity) else: inventory[item_type] = 0 return inventory"},{"question":"def max_energy(toy_energies): Returns the maximum energy Felix can have after playing with one toy. >>> max_energy([10, 20, 30]) == 30 >>> max_energy([5, 10, 3, 50]) == 50 >>> max_energy([1, 3, 5, 7, 9]) == 9 >>> max_energy([42]) == 42 >>> max_energy([0, 0, 0, 0, 0]) == 0 >>> max_energy([1000000000, 200000000, 300000000]) == 1000000000","solution":"def max_energy(toy_energies): Returns the maximum energy Felix can have after playing with one toy. return max(toy_energies)"},{"question":"def min_difference(n: int, skills: List[int]) -> int: Returns the minimum possible absolute difference between the total skill levels of two teams. >>> min_difference(5, [1, 2, 3, 4, 5]) 1 >>> min_difference(4, [10, 20, 15, 5]) 0 # Code implementation here from solution import min_difference def test_min_difference_case_1(): n = 5 skills = [1, 2, 3, 4, 5] assert min_difference(n, skills) == 1 def test_min_difference_case_2(): n = 4 skills = [10, 20, 15, 5] assert min_difference(n, skills) == 0 def test_min_difference_single_employee(): n = 1 skills = [5] assert min_difference(n, skills) == 5 def test_min_difference_balanced_teams(): n = 6 skills = [1, 1, 1, 1, 1, 1] assert min_difference(n, skills) == 0 def test_min_difference_unbalanced_teams(): n = 7 skills = [1, 1, 1, 1, 1, 1, 7] assert min_difference(n, skills) == 1 def test_min_difference_large_numbers(): n = 3 skills = [1000, 1000, 1000] assert min_difference(n, skills) == 1000 def test_min_difference_mixed_values(): n = 6 skills = [3, 1, 4, 1, 5, 9] assert min_difference(n, skills) == 1","solution":"def min_difference(n, skills): Returns the minimum possible absolute difference between the total skill levels of two teams. total_sum = sum(skills) target = total_sum // 2 dp = [0] * (target + 1) for skill in skills: for j in range(target, skill - 1, -1): dp[j] = max(dp[j], dp[j - skill] + skill) team1_sum = dp[target] team2_sum = total_sum - team1_sum return abs(team1_sum - team2_sum)"},{"question":"from typing import List def tsp_min_cost(n: int, cost: List[List[int]]) -> int: Determine the minimum cost to visit all cities starting and ending at city 1, visiting each city exactly once. Args: n (int): The number of cities. cost (List[List[int]]): The cost matrix where cost[i][j] represents the travel cost from city i to city j. Returns: int: The minimum travel cost to complete the tour. >>> tsp_min_cost(4, [ ... [0, 10, 15, 20], ... [10, 0, 35, 25], ... [15, 35, 0, 30], ... [20, 25, 30, 0]]) 80 >>> tsp_min_cost(2, [ ... [0, 10], ... [10, 0]]) 20 >>> tsp_min_cost(3, [ ... [0, 10, 20], ... [10, 0, 30], ... [20, 30, 0]]) 60 >>> tsp_min_cost(4, [ ... [0, 5, 15, 10], ... [5, 0, 20, 25], ... [15, 20, 0, 30], ... [10, 25, 30, 0]]) 65 >>> tsp_min_cost(3, [ ... [0, 10, 10], ... [10, 0, 10], ... [10, 10, 0]]) 30","solution":"from itertools import permutations def tsp_min_cost(n, cost): # Generate all possible permutations of cities to visit (excluding the start city) cities_to_travel = list(range(1, n)) min_cost = float('inf') for perm in permutations(cities_to_travel): current_cost = cost[0][perm[0]] for i in range(len(perm) - 1): current_cost += cost[perm[i]][perm[i+1]] current_cost += cost[perm[-1]][0] min_cost = min(min_cost, current_cost) return min_cost"},{"question":"from typing import List, Tuple def tree_diameter(n: int, edges: List[Tuple[int, int]]) -> int: Calculate the diameter of a tree, which is the length of the longest path between any two vertices in the tree. Args: n (int): Number of nodes in the tree. edges (List[Tuple[int, int]]): List of edges in the tree, where each edge is represented as a tuple of two integers. Returns: int: The diameter of the tree. Examples: >>> tree_diameter(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) 3 >>> tree_diameter(3, [(1, 2), (2, 3)]) 2","solution":"from typing import List, Tuple from collections import deque, defaultdict def tree_diameter(n: int, edges: List[Tuple[int, int]]) -> int: if n == 1: return 0 def bfs(start_node): queue = deque([start_node]) distances = {start_node: 0} farthest_node = start_node max_distance = 0 while queue: current = queue.popleft() current_distance = distances[current] for neighbor in graph[current]: if neighbor not in distances: queue.append(neighbor) distances[neighbor] = current_distance + 1 if distances[neighbor] > max_distance: max_distance, farthest_node = distances[neighbor], neighbor return farthest_node, max_distance # Step 1: Create the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Step 2: Find the farthest node from any node (let's start from node 1) farthest_node, _ = bfs(1) # Step 3: Find the farthest node from the previously found farthest node _, diameter = bfs(farthest_node) return diameter"},{"question":"def max_histogram_area(N: int, heights: List[int]) -> int: Calculate the maximum rectangular area that can be formed between the buildings. :param int N: Number of buildings. :param List[int] heights: Heights of the buildings. :return int: The maximum rectangular area. >>> max_histogram_area(6, [2, 1, 5, 6, 2, 3]) 10 >>> max_histogram_area(4, [3, 3, 3, 3]) 12 >>> max_histogram_area(5, [1, 2, 3, 4, 5]) 9 >>> max_histogram_area(5, [5, 4, 3, 2, 1]) 9 >>> max_histogram_area(7, [6, 2, 5, 4, 5, 1, 6]) 12 >>> max_histogram_area(1, [1]) 1","solution":"def max_histogram_area(N, heights): Function to calculate the maximum rectangular area under given Histogram. :param int N: Number of buildings :param List[int] heights: List of heights of the buildings :return int: The maximum rectangular area stack = list() max_area = 0 # Initialize max area index = 0 while index < N: if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def max_sum_after_removal(arr: List[int]) -> int: Given a list of non-negative integers, determine the maximum possible sum of its elements, where you can remove at most one subarray of consecutive elements. >>> max_sum_after_removal([1, 2, 3, 4, 5, 6, 7, 8]) 36 >>> max_sum_after_removal([1, 2, 3, 0, 6]) 12 >>> max_sum_after_removal([1, 2, 3, 0, 3]) 9 >>> max_sum_after_removal([5]) 5 >>> max_sum_after_removal([0, 0, 0, 0, 0]) 0 >>> max_sum_after_removal([5, 5, 5, 5, 5]) 25 >>> max_sum_after_removal([1, 2, 0, 3, 4, 0, 5, 6]) 21","solution":"def max_sum_after_removal(arr): n = len(arr) if n == 0: return 0 if n == 1: return arr[0] total_sum = sum(arr) max_sum_no_removal = total_sum # Calculate prefix sums prefix_sum = [0] * n prefix_sum[0] = arr[0] for i in range(1, n): prefix_sum[i] = prefix_sum[i-1] + arr[i] # Calculate suffix sums suffix_sum = [0] * n suffix_sum[-1] = arr[-1] for i in range(n-2, -1, -1): suffix_sum[i] = suffix_sum[i+1] + arr[i] max_sum = total_sum # Initial max_sum is without any removal # Evaluate the option of removing one subarray for i in range(n): for j in range(i, n): if i == 0 and j == n-1: current_sum = 0 elif i == 0: current_sum = suffix_sum[j+1] if j+1 < n else 0 elif j == n-1: current_sum = prefix_sum[i-1] else: current_sum = prefix_sum[i-1] + suffix_sum[j+1] max_sum = max(max_sum, current_sum) return max(max_sum, max_sum_no_removal)"},{"question":"def assign_workers_to_machines(M, W, S): Simulates the assignment of workers to machines over a series of shifts. Each worker can work on a machine for one shift at a time, and workers cannot work on the same machine in consecutive shifts. Args: M (int): Number of machines. W (int): Number of workers. S (int): Number of shifts. Returns: str: \\"YESn\\" followed by S lines of M integers representing the worker assignments for each shift, or \\"NO\\" if it is not possible to assign workers under the given constraints. Examples: >>> assign_workers_to_machines(3, 3, 3) \\"YESn1 2 3n2 3 1n3 1 2\\" >>> assign_workers_to_machines(2, 1, 3) \\"NO\\"","solution":"def assign_workers_to_machines(M, W, S): if M > W: return \\"NO\\" result = [[0] * M for _ in range(S)] for shift in range(S): for machine in range(M): result[shift][machine] = (machine + shift) % W + 1 return \\"YESn\\" + \\"n\\".join(\\" \\".join(map(str, shift)) for shift in result) # Example usages # print(assign_workers_to_machines(3, 3, 3)) # Expected Output: YES ... (workers assigned in round-robin fashion) # print(assign_workers_to_machines(2, 1, 3)) # Expected Output: NO (not enough workers for the machines)"},{"question":"def winner_of_game(t: int, test_cases: List[Tuple[int, List[Tuple[int, int, int, int]]]]) -> List[str]: Determine the winner of the game based on the input test cases. Parameters: t (int): Number of test cases. test_cases (list of tuples): Each tuple contains an integer m (number of rectangles) and a list of rectangles' coordinates. Returns: list of str: List containing result (\\"ALICE\\", \\"BOB\\", or \\"DRAW\\") for each test case. pass import pytest def test_single_rectangle(): assert winner_of_game(1, [(1, [(1, 1, 3, 4)])]) == [\\"ALICE\\"] def test_multiple_rectangles(): assert winner_of_game(1, [(3, [(1, 1, 3, 4), (2, 2, 5, 5), (4, 1, 6, 3)])]) == [\\"DRAW\\"] def test_two_cases(): assert winner_of_game(2, [ (3, [(1, 1, 3, 4), (2, 2, 5, 5), (4, 1, 6, 3)]), (2, [(1, 1, 4, 4), (5, 5, 7, 7)])]) == [\\"DRAW\\", \\"DRAW\\"] def test_optimal_cuts_alice_wins(): assert winner_of_game(1, [(1, [(1, 1, 10, 10)])]) == [\\"ALICE\\"] def test_large_input(): rectangles = [(i, i, i+2, i+2) for i in range(1, 51)] assert winner_of_game(1, [(50, rectangles)]) == [\\"DRAW\\"] @pytest.mark.parametrize(\\"t, test_cases, expected\\", [ (1, [(1, [(1, 1, 3, 4)])], [\\"ALICE\\"]), (1, [(3, [(1, 1, 3, 4), (2, 2, 5, 5), (4, 1, 6, 3)])], [\\"DRAW\\"]), (2, [(3, [(1, 1, 3, 4), (2, 2, 5, 5), (4, 1, 6, 3)]), (2, [(1, 1, 4, 4), (5, 5, 7, 7)])], [\\"DRAW\\", \\"DRAW\\"]) ]) def test_winner_of_game(t, test_cases, expected): assert winner_of_game(t, test_cases) == expected","solution":"def winner_of_game(t, test_cases): Determine the winner of the game based on the input test cases. Parameters: t (int): Number of test cases. test_cases (list of tuples): Each tuple contains an integer m (number of rectangles) and a list of rectangles' coordinates. Returns: list of str: List containing result (\\"ALICE\\", \\"BOB\\", or \\"DRAW\\") for each test case. results = [] for case in test_cases: m, rectangles = case # If there is only 1 rectangle, Alice wins as no cuts are possible. if m == 1: results.append(\\"ALICE\\") continue # Since both are playing optimally, in a deterministic setup, we cannot predict # outcomes without more sophisticated logic hence for now, return \\"DRAW\\". results.append(\\"DRAW\\") return results"},{"question":"def count_ways_to_climb_stairs(n: int) -> int: Returns the number of distinct ways to climb a staircase with n steps. Each step can be either 1, 2, or 3 steps at a time. >>> count_ways_to_climb_stairs(1) == 1 >>> count_ways_to_climb_stairs(2) == 2 >>> count_ways_to_climb_stairs(3) == 4 >>> count_ways_to_climb_stairs(4) == 7 >>> count_ways_to_climb_stairs(5) == 13 >>> count_ways_to_climb_stairs(10) == 274 >>> count_ways_to_climb_stairs(20) == 121415 >>> count_ways_to_climb_stairs(50) == 10562230626642","solution":"def count_ways_to_climb_stairs(n): Returns the number of distinct ways to climb a staircase with n steps. Each step can be either 1, 2, or 3 steps at a time. if n == 1: return 1 elif n == 2: return 2 elif n == 3: return 4 dp = [0] * (n + 1) dp[1], dp[2], dp[3] = 1, 2, 4 for i in range(4, n + 1): dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] return dp[n]"},{"question":"def increasing_triplet(nums: List[int]) -> bool: Returns True if there exists a triplet (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. Otherwise, return False. >>> increasing_triplet([1, 2, 3, 4, 5]) True >>> increasing_triplet([5, 4, 3, 2, 1]) False >>> increasing_triplet([2, 1, 5, 0, 4, 6]) True","solution":"from typing import List def increasing_triplet(nums: List[int]) -> bool: Returns True if there exists a triplet (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. Otherwise, return False. if len(nums) < 3: return False first = second = float('inf') for num in nums: if num <= first: first = num elif num <= second: second = num else: return True return False"},{"question":"def min_max_latency(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Determine the minimum possible value of the maximum latency between any two buildings which ensures that all buildings are still connected. Args: n (int): Number of buildings. m (int): Number of communication links. edges (List[Tuple[int, int, int]]): Each tuple contains three integers u, v, and w representing a communication link between buildings u and v with a latency w. Returns: int: The minimum possible value of the maximum latency. Examples: >>> min_max_latency(4, 5, [(1, 2, 4), (2, 3, 5), (3, 4, 6), (4, 2, 2), (1, 3, 8)]) 5 >>> min_max_latency(3, 3, [(1, 2, 1), (2, 3, 2), (1, 3, 3)]) 2","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def min_max_latency(n, m, edges): edges.sort(key=lambda item: item[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) mst = [] i = 0 e = 0 while e < n - 1: u, v, w = edges[i] i += 1 x = find(parent, u - 1) y = find(parent, v - 1) if x != y: e += 1 mst.append(w) union(parent, rank, x, y) return max(mst) # Example usage: n = 4 m = 5 edges = [ (1, 2, 4), (2, 3, 5), (3, 4, 6), (4, 2, 2), (1, 3, 8) ] print(min_max_latency(n, m, edges)) # Output should be 5"},{"question":"from typing import List, Tuple def maximum_profit(n: int, m: int, profits: List[int], s: int, edges: List[Tuple[int, int, int]]) -> int: Calculate the maximum profit that can be collected by traversing from the given starting vertex to any other vertex in the graph. >>> maximum_profit(5, 6, [10, 20, 15, 25, 5], 1, [(1, 2, 4), (1, 3, 2), (2, 3, 1), (2, 4, 6), (3, 4, 3), (4, 5, 5)]) 55 >>> maximum_profit(4, 4, [8, 15, 10, 5], 2, [(2, 1, 3), (2, 3, 2), (3, 4, 4), (4, 1, 1)]) 33","solution":"from heapq import heappop, heappush import sys def maximum_profit(n, m, profits, s, edges): dist = [sys.maxsize] * (n + 1) dist[s] = 0 graph = [[] for _ in range(n + 1)] for u, v, w in edges: graph[u].append((w, v)) graph[v].append((w, u)) min_heap = [(0, s)] while min_heap: d, u = heappop(min_heap) if d > dist[u]: continue for w, v in graph[u]: new_dist = dist[u] + w if new_dist < dist[v]: dist[v] = new_dist heappush(min_heap, (new_dist, v)) max_profit = 0 for i in range(1, n + 1): if dist[i] < sys.maxsize: max_profit += profits[i - 1] return max_profit # Example usage example_n = 5 example_m = 6 example_profits = [10, 20, 15, 25, 5] example_s = 1 example_edges = [ (1, 2, 4), (1, 3, 2), (2, 3, 1), (2, 4, 6), (3, 4, 3), (4, 5, 5), ] print(maximum_profit(example_n, example_m, example_profits, example_s, example_edges)) # Output should be 55"},{"question":"from typing import List def can_pair_greetings(n: int, a: List[int]) -> str: Determines if it's possible to arrange pairs such that each attendee's required number of greetings is matched exactly. Args: n (int): Number of attendees. a (List[int]): List of integers where a[i] denotes the number of greetings the i-th attendee wants to perform. Returns: str: \\"YES\\" if it is possible to arrange the pairs, otherwise returns \\"NO\\". >>> can_pair_greetings(4, [1, 2, 1, 2]) \\"YES\\" >>> can_pair_greetings(3, [1, 2, 1]) \\"NO\\"","solution":"def can_pair_greetings(n, a): Determines if it's possible to arrange pairs such that each attendee's required number of greetings is matched exactly. Args: n (int): Number of attendees. a (list): List of integers where a[i] denotes the number of greetings the i-th attendee wants to perform. Returns: str: \\"YES\\" if it is possible to arrange the pairs, otherwise returns \\"NO\\". from collections import Counter greeting_counts = Counter(a) # For each unique number of greetings, the counts must be even for count in greeting_counts.values(): if count % 2 != 0: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List, Tuple def minimum_hamiltonian_cycle(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Calculate the minimum total distance required to form a loop that visits each section exactly once and returns to the starting section. If the loop is not possible, return -1. Parameters: n (int): Number of sections m (int): Number of pathways edges (List[Tuple[int, int, int]]): List of edges where each edge is a tuple (u, v, w) representing a pathway between section u and section v with a distance of w meters. Returns: int: Minimum total distance of the loop or -1 if not possible. >>> minimum_hamiltonian_cycle(4, 6, [(1, 2, 10), (1, 3, 15), (1, 4, 20), (2, 3, 35), (2, 4, 25), (3, 4, 30)]) 80 >>> minimum_hamiltonian_cycle(3, 2, [(1, 2, 10), (1, 3, 15)]) -1 import pytest from solution import minimum_hamiltonian_cycle def test_example_case(): n = 4 m = 6 edges = [ (1, 2, 10), (1, 3, 15), (1, 4, 20), (2, 3, 35), (2, 4, 25), (3, 4, 30) ] assert minimum_hamiltonian_cycle(n, m, edges) == 80 def test_no_possible_cycle(): n = 3 m = 2 edges = [ (1, 2, 10), (1, 3, 15) ] assert minimum_hamiltonian_cycle(n, m, edges) == -1 def test_single_edge_case(): n = 2 m = 1 edges = [ (1, 2, 10) ] assert minimum_hamiltonian_cycle(n, m, edges) == 20 def test_disconnected_sections(): n = 4 m = 3 edges = [ (1, 2, 10), (3, 4, 20), (1, 3, 15) ] assert minimum_hamiltonian_cycle(n, m, edges) == -1 def test_tightly_connected_sections(): n = 3 m = 3 edges = [ (1, 2, 10), (2, 3, 15), (3, 1, 20) ] assert minimum_hamiltonian_cycle(n, m, edges) == 45 def test_all_edges_same_weight(): n = 3 m = 3 edges = [ (1, 2, 10), (2, 3, 10), (3, 1, 10) ] assert minimum_hamiltonian_cycle(n, m, edges) == 30","solution":"import itertools def minimum_hamiltonian_cycle(n, m, edges): # Create an adjacency matrix for the graph with all values initially set to infinity inf = float('inf') graph = [[inf] * n for _ in range(n)] # Populate the adjacency matrix with given edges for u, v, w in edges: graph[u-1][v-1] = w graph[v-1][u-1] = w # Function to calculate the weight of a given path def path_cost(path): cost = 0 for i in range(len(path) - 1): if graph[path[i]][path[i+1]] == inf: return inf cost += graph[path[i]][path[i+1]] if graph[path[-1]][path[0]] == inf: return inf cost += graph[path[-1]][path[0]] return cost # Generate all possible permutations of the nodes nodes = list(range(n)) min_cost = inf for perm in itertools.permutations(nodes): cost = path_cost(perm) if cost < min_cost: min_cost = cost return min_cost if min_cost < inf else -1 # Sample Input n = 4 m = 6 edges = [ (1, 2, 10), (1, 3, 15), (1, 4, 20), (2, 3, 35), (2, 4, 25), (3, 4, 30) ] # Output the result for the given input print(minimum_hamiltonian_cycle(n, m, edges))"},{"question":"def longest_palindromic_subsequence(n: int, sequence: List[int]) -> Tuple[int, List[int]]: Find the longest palindromic subsequence within a given sequence of integers. Args: n : int : length of the sequence sequence : List[int] : list of integers Returns: Tuple[int, List[int]] : an integer representing the length of the longest palindromic subsequence and the subsequence itself as a list of integers >>> longest_palindromic_subsequence(7, [3, 1, 4, 1, 5, 9, 2]) (3, [1, 4, 1]) >>> longest_palindromic_subsequence(5, [1, 2, 3, 4, 5]) (1, [1])","solution":"def longest_palindromic_subsequence(n, sequence): # Initialize a dp array where dp[i][j] represents the length of the longest palindromic subsequence in sequence[i:j+1] dp = [[0] * n for _ in range(n)] # Initialize a backtracking array to help in reconstructing the subsequence subsequence = [[[] for _ in range(n)] for _ in range(n)] for i in range(n): dp[i][i] = 1 subsequence[i][i] = [sequence[i]] for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if sequence[i] == sequence[j] and cl == 2: dp[i][j] = 2 subsequence[i][j] = [sequence[i], sequence[j]] elif sequence[i] == sequence[j]: dp[i][j] = dp[i + 1][j - 1] + 2 subsequence[i][j] = [sequence[i]] + subsequence[i + 1][j - 1] + [sequence[j]] else: if dp[i + 1][j] > dp[i][j - 1]: dp[i][j] = dp[i + 1][j] subsequence[i][j] = subsequence[i + 1][j] else: dp[i][j] = dp[i][j - 1] subsequence[i][j] = subsequence[i][j - 1] longest_length = dp[0][n - 1] longest_subsequence = subsequence[0][n - 1] return longest_length, longest_subsequence"},{"question":"from typing import List def is_beautiful_possible(s: str) -> str: Determine if it is possible to rearrange the characters of s to make it a beautiful string. A string is considered beautiful if its characters can be rearranged such that no two adjacent characters are the same. Args: s (str): The input string consisting of lowercase alphabetic characters only. Returns: str: \\"YES\\" if it is possible to rearrange the string s to make it a beautiful string, otherwise \\"NO\\". >>> is_beautiful_possible(\\"aabb\\") \\"YES\\" >>> is_beautiful_possible(\\"aaab\\") \\"NO\\" >>> is_beautiful_possible(\\"abcabc\\") \\"YES\\" def process_test_cases(test_cases: List[str]) -> List[str]: Process a number of test cases to determine if each can be rearranged into a beautiful string. Args: test_cases (List[str]): A list of strings to be checked. Returns: List[str]: A list of results for each test case, either \\"YES\\" or \\"NO\\". >>> process_test_cases([\\"aabb\\", \\"aaab\\", \\"abcabc\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> process_test_cases([\\"aaaa\\", \\"aab\\", \\"abca\\"]) [\\"NO\\", \\"YES\\", \\"YES\\"]","solution":"def is_beautiful_possible(s): from collections import Counter # Count the frequency of each character freq = Counter(s) # Find the maximum frequency max_freq = max(freq.values()) # If the number of characters without the most frequent character is less than # the frequency of the most frequent character - 1, then it is not possible to # rearrange the string to fulfill the requirement. if max_freq > (len(s) - max_freq + 1): return \\"NO\\" else: return \\"YES\\" def process_test_cases(test_cases): results = [] for s in test_cases: results.append(is_beautiful_possible(s)) return results"},{"question":"def second_largest_unique(arr: List[int]) -> int: Find the second largest unique value in the array. Args: arr: List[int] : A list of integers Returns: int : The second largest unique value, or -1 if no such value exists >>> second_largest_unique([3, 1, 4, 4, 5, 6]) 5 >>> second_largest_unique([7, 7, 7, 7]) -1 >>> second_largest_unique([10, 20, 20, 20, 30]) 20 >>> second_largest_unique([1, 2, 2]) 1 >>> second_largest_unique([2, 3, 1, 4, 5]) 4 >>> second_largest_unique([1, 2]) 1 >>> second_largest_unique([1, 1]) -1 >>> second_largest_unique([1000000000, 999999999]) 999999999","solution":"def second_largest_unique(arr): # Using set to find unique elements unique_elements = list(set(arr)) if len(unique_elements) < 2: return -1 # Sorting the unique elements in descending order unique_elements.sort(reverse=True) # The second largest unique value return unique_elements[1]"},{"question":"import pytest def currency_converter(test_cases): Convert given amounts in specific currencies to the base currency using provided exchange rates. Args: test_cases (list): A list of tuples, each containing: 1. A list of tuples (exchange rates) in the form of (currency name, rate to base currency). 2. A tuple (currency to convert from, amount in that currency). Returns: list: A list of converted amounts in the base currency rounded to 4 decimal places. pass def parse_input(input_str): Parse the input string to extract test cases. Args: input_str (str): Input string in the specified format. Returns: list: A list of tuples representing the test cases. pass def main(input_str): Main function to process the input string and perform currency conversion. Args: input_str (str): Input string in the specified format. Returns: list: The resulting converted amounts for each test case. pass def test_currency_converter_basic(): test_cases = [ ([(\\"USD\\", 1.0), (\\"EUR\\", 0.85), (\\"JPY\\", 110.0)], (\\"EUR\\", 50.0)), ([(\\"GBP\\", 1.3), (\\"INR\\", 0.014)], (\\"GBP\\", 100.0)), ] expected = [42.5000, 130.0000] assert currency_converter(test_cases) == expected def test_parse_input(): input_str = 2 3 USD 1.0 EUR 0.85 JPY 110.0 EUR 50.0 2 GBP 1.3 INR 0.014 GBP 100.0 expected = [ ([(\\"USD\\", 1.0), (\\"EUR\\", 0.85), (\\"JPY\\", 110.0)], (\\"EUR\\", 50.0)), ([(\\"GBP\\", 1.3), (\\"INR\\", 0.014)], (\\"GBP\\", 100.0)), ] assert parse_input(input_str) == expected def test_main(): input_str = 2 3 USD 1.0 EUR 0.85 JPY 110.0 EUR 50.0 2 GBP 1.3 INR 0.014 GBP 100.0 expected = [42.5000, 130.0000] assert main(input_str) == expected","solution":"def currency_converter(test_cases): results = [] for exchange_rates, conversion in test_cases: rates = {} for currency, rate in exchange_rates: rates[currency] = rate conversion_currency, amount = conversion converted_amount = amount * rates.get(conversion_currency, 0) results.append(round(converted_amount, 4)) return results def parse_input(input_str): input_lines = input_str.strip().split('n') index = 0 T = int(input_lines[index]) index += 1 test_cases = [] for _ in range(T): K = int(input_lines[index]) index += 1 exchange_rates = [] for _ in range(K): parts = input_lines[index].split() exchange_rates.append((parts[0], float(parts[1]))) index += 1 conversion_parts = input_lines[index].split() conversion_currency = conversion_parts[0] amount = float(conversion_parts[1]) test_cases.append((exchange_rates, (conversion_currency, amount))) index += 1 return test_cases def main(input_str): test_cases = parse_input(input_str) results = currency_converter(test_cases) return results"},{"question":"def max_score_after_dropping_one(scores: List[int]) -> int: Calculate the maximum possible score a student can achieve after dropping exactly one assignment. Args: scores (list): List of integers representing the scores of assignments. Returns: int: Maximum possible score after dropping one assignment. Examples: >>> max_score_after_dropping_one([4, 7, 2, 8]) 19 >>> max_score_after_dropping_one([3, 3, 3]) 6","solution":"def max_score_after_dropping_one(scores): Returns the maximum possible score after dropping exactly one assignment. Args: scores (list): List of integers representing the scores of assignments. Returns: int: Maximum possible score after dropping one assignment. # Sum of all the scores. total_score = sum(scores) # Minimum score in the list. min_score = min(scores) # Maximum score after dropping one assignment. max_possible_score = total_score - min_score return max_possible_score"},{"question":"def single_number(arr): Given an array where every element appears three times except for one, find that single one which does not appear three times. >>> single_number([2, 2, 3, 2]) == 3 >>> single_number([0, 1, 0, 1, 0, 1, 99]) == 99 def find_unique_in_test_cases(test_cases): Given multiple test cases, for each one determine the single number that does not repeat thrice. >>> find_unique_in_test_cases([(4, [2, 2, 3, 2]), (7, [0, 1, 0, 1, 0, 1, 99])]) == [3, 99] >>> find_unique_in_test_cases([(4, [5, 4, 3, 5, 5, 4, 4]), (10, [10, 10, 10, 20, 30, 30, 30, 20, 20, 40])]) == [3, 40]","solution":"def single_number(arr): Given an array where every element appears three times except for one, find that single one which does not appear three times. ones, twos = 0, 0 for num in arr: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones def find_unique_in_test_cases(test_cases): Given multiple test cases, for each one determine the single number that does not repeat thrice. results = [] for n, arr in test_cases: result = single_number(arr) results.append(result) return results"},{"question":"def max_weight_in_range(n: int, q: int, weights: List[int], queries: List[Tuple[int, int]]) -> List[int]: Returns the maximum weight of a box in a specified range of shelves for each query. Parameters: n (int): Number of shelves q (int): Number of queries weights (list): List containing the weights of the boxes on the shelves queries (list): List of tuples, where each tuple contains two integers representing the range of shelves Returns: List of integers representing the maximum weight for each query pass # Unit Tests def test_max_weight_in_range(): n = 7 q = 5 weights = [5, 1, 8, 7, 3, 4, 6] queries = [(1, 3), (4, 7), (2, 5), (1, 7), (3, 3)] expected = [8, 7, 8, 8, 8] assert max_weight_in_range(n, q, weights, queries) == expected def test_max_weight_empty_query(): n = 0 q = 0 weights = [] queries = [] expected = [] assert max_weight_in_range(n, q, weights, queries) == expected def test_max_weight_single_shelf(): n = 1 q = 1 weights = [42] queries = [(1, 1)] expected = [42] assert max_weight_in_range(n, q, weights, queries) == expected def test_max_weight_all_same_weight(): n = 5 q = 3 weights = [7, 7, 7, 7, 7] queries = [(1, 5), (2, 4), (3, 3)] expected = [7, 7, 7] assert max_weight_in_range(n, q, weights, queries) == expected def test_max_weight_varied(): n = 10 q = 4 weights = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3] queries = [(1, 10), (2, 5), (6, 9), (3, 8)] expected = [9, 5, 9, 9] assert max_weight_in_range(n, q, weights, queries) == expected","solution":"def max_weight_in_range(n, q, weights, queries): Returns the maximum weight of a box in a specified range of shelves for each query. Parameters: n (int): Number of shelves q (int): Number of queries weights (list): List containing the weights of the boxes on the shelves queries (list): List of tuples, where each tuple contains two integers representing the range of shelves Returns: List of integers representing the maximum weight for each query results = [] for query in queries: l, r = query results.append(max(weights[l-1:r])) return results"},{"question":"def max_chunks_to_sorted(n: int, d: int, arr: List[int]) -> int: Returns the maximum number of chunks into which the array can be split such that sorting each chunk and concatenating them results in a sorted array. >>> max_chunks_to_sorted(5, 2, [1, 0, 2, 3, 4]) 4 >>> max_chunks_to_sorted(6, 3, [0, 1, 2, 4, 3, 5]) 5","solution":"def max_chunks_to_sorted(n, d, arr): Returns the maximum number of chunks into which the array can be split such that sorting each chunk and concatenating them results in a sorted array. # Initialize variables max_chunks = 0 current_max = -1 # Iterate through the array to find chunks for i in range(n): current_max = max(current_max, arr[i]) if current_max == i: max_chunks += 1 return max_chunks # Example usage: # n, d = 5, 2 # arr = [1, 0, 2, 3, 4] # print(max_chunks_to_sorted(n, d, arr)) # Output: 4"},{"question":"def minimum_total_protection(n: int, herb_production: List[int]) -> int: Given the production quantities of herbs for each farm, return the minimum possible total value of all pest protection needed. >>> minimum_total_protection(3, [100, 200, 300]) 600 >>> minimum_total_protection(4, [10, 10, 10, 10]) 40","solution":"def minimum_total_protection(n, herb_production): Given the production quantities of herbs for each farm, return the minimum possible total value of all pest protection needed. # The simplest approach for this problem is to sum up all the production quantities. # Since we need to provide protection that sums up to or just exceeds the total production, # the minimal sum of protections needed is equal to the sum of all production quantities. return sum(herb_production)"},{"question":"def is_valid_address(address: str) -> str: Returns 'Valid' if the address meets the criteria, otherwise 'Invalid'. Criteria: - At least one uppercase letter - At least one lowercase letter - Exactly one digit - Length between 3 and 10 characters >>> is_valid_address('Xy5') 'Valid' >>> is_valid_address('aB1') 'Valid' >>> is_valid_address('xylor3') 'Invalid' >>> is_valid_address('A34z') 'Invalid' pass def check_addresses(addresses: List[str]) -> List[str]: For a list of addresses, check their validity and return a list of results. >>> check_addresses(['Xy5', 'aB1', 'xylor3', 'AB1c', 'A34z']) ['Valid', 'Valid', 'Invalid', 'Valid', 'Invalid'] pass","solution":"def is_valid_address(address): Returns 'Valid' if the address meets the criteria, otherwise 'Invalid'. Criteria: - At least one uppercase letter - At least one lowercase letter - Exactly one digit - Length between 3 and 10 characters if not (3 <= len(address) <= 10): return \\"Invalid\\" has_upper, has_lower, digit_count = False, False, 0 for char in address: if char.isupper(): has_upper = True elif char.islower(): has_lower = True elif char.isdigit(): digit_count += 1 if has_upper and has_lower and digit_count == 1: return \\"Valid\\" else: return \\"Invalid\\" def check_addresses(addresses): For a list of addresses, check their validity and return a list of results. return [is_valid_address(address) for address in addresses] if __name__ == \\"__main__\\": t = int(input()) addresses = [input().strip() for _ in range(t)] results = check_addresses(addresses) for result in results: print(result)"},{"question":"def min_traversal_time(n: int, corridors: List[Tuple[int, int, int]]) -> int: Determine the minimum time required to traverse all the vaults for maintenance without triggering any security locks during the process. Args: n (int): The number of vaults. corridors (List[Tuple[int, int, int]]): List of tuples where each tuple contains two vaults connected by a corridor and the travel time. Returns: int: Minimum traversal time. Example: >>> min_traversal_time(3, [(1, 2, 1), (2, 3, 2)]) 6 >>> min_traversal_time(2, [(1, 2, 5)]) 10","solution":"def min_traversal_time(n, corridors): from collections import defaultdict, deque # Create adjacency list to store vault connections and travel times graph = defaultdict(list) for ai, bi, ti in corridors: graph[ai].append((bi, ti)) graph[bi].append((ai, ti)) # Total minimal time for traversing all corridors twice (since it's a tree, n-1 corridors) total_traversal_time = 0 def dfs(vault, parent): nonlocal total_traversal_time for neighbor, travel_time in graph[vault]: if neighbor != parent: # Travel to the neighbor and back total_traversal_time += 2 * travel_time dfs(neighbor, vault) # Start DFS from vault 1 (base) dfs(1, -1) return total_traversal_time"},{"question":"import math from typing import List, Tuple def gcd_of_pairs(pairs: List[Tuple[int, int]]) -> List[int]: Given a list of pairs of integers, return a list of greatest common divisors (GCDs) for each pair, except the ending pair (0, 0). >>> gcd_of_pairs([(48, 18), (100, 75), (0, 0)]) == [6, 25] >>> gcd_of_pairs([(10, 0), (0, 10), (0, 0)]) == [10, 10] >>> gcd_of_pairs([(12, 8), (30, 15), (24, 18), (0, 0)]) == [4, 15, 6] >>> gcd_of_pairs([(1000, 500), (990, 495), (0, 0)]) == [500, 495]","solution":"import math def gcd_of_pairs(pairs): Given a list of pairs of integers, return a list of greatest common divisors (GCDs) for each pair, except the ending pair (0, 0). gcd_results = [] for a, b in pairs: if a == 0 and b == 0: break gcd_results.append(math.gcd(a, b)) return gcd_results"},{"question":"from collections import deque, defaultdict def earliest_time_to_be_virus_free(n: int, m: int, edges: List[Tuple[int, int]], k: int, starting_devices: List[int]) -> int: Determine the earliest time by which all devices will be completely free from the virus. Args: n (int): Number of devices. m (int): Number of direct connections. edges (List[Tuple[int, int]]): List of direct connections between devices. k (int): Number of initial starting devices. starting_devices (List[int]): List of initial starting devices. Returns: int: The earliest time by which all devices will be virus free, or -1 if a device cannot be freed. >>> earliest_time_to_be_virus_free(6, 7, [(1, 2), (2, 3), (2, 4), (4, 5), (5, 6), (3, 4), (5, 1)], 2, [1, 6]) 2 >>> earliest_time_to_be_virus_free(4, 2, [(1, 2), (3, 4)], 1, [1]) -1 >>> earliest_time_to_be_virus_free(1, 0, [], 1, [1]) 0 >>> earliest_time_to_be_virus_free(3, 0, [], 3, [1, 2, 3]) 0 >>> earliest_time_to_be_virus_free(3, 3, [(1, 2), (2, 3), (1, 3)], 1, [1]) 1 >>> earliest_time_to_be_virus_free(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)], 2, [1, 5]) 2","solution":"from collections import deque, defaultdict def earliest_time_to_be_virus_free(n, m, edges, k, starting_devices): # Create the graph as an adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Prepare distance dictionary initialized to -1 indicating unvisited distances = {i: -1 for i in range(1, n + 1)} # Use a queue to perform BFS from all starting devices queue = deque() for device in starting_devices: distances[device] = 0 queue.append(device) # Perform BFS while queue: current = queue.popleft() current_distance = distances[current] for neighbor in graph[current]: if distances[neighbor] == -1: # If not visited distances[neighbor] = current_distance + 1 queue.append(neighbor) # Find the maximum distance max_distance = max(distances.values()) if -1 in distances.values(): return -1 # If there exists a device that cannot be reached, return -1 return max_distance # Example Usage n = 6 m = 7 edges = [ (1, 2), (2, 3), (2, 4), (4, 5), (5, 6), (3, 4), (5, 1) ] k = 2 starting_devices = [1, 6] earliest_time_to_be_virus_free(n, m, edges, k, starting_devices)"},{"question":"def is_wavy(arr): Determine if an array is \\"wavy\\" or not. Args: arr (List[int]): List of integers representing the array. Returns: str: \\"Yes\\" if the array is wavy, otherwise \\"No\\". Examples: >>> is_wavy([1, 3, 2, 4, 3]) \\"Yes\\" >>> is_wavy([1, 2, 3, 4, 5]) \\"No\\" from solution import is_wavy def test_is_wavy(): assert is_wavy([1, 3, 2, 4, 3]) == \\"Yes\\" assert is_wavy([1, 2, 3, 4, 5]) == \\"No\\" assert is_wavy([5, 1, 5, 1, 5]) == \\"Yes\\" assert is_wavy([5, 1]) == \\"Yes\\" assert is_wavy([2, 1, 3, 1, 2, 3]) == \\"No\\" assert is_wavy([7, 7, 7, 7, 7]) == \\"No\\" assert is_wavy([3, 1, 2]) == \\"Yes\\" assert is_wavy([3, 1, 1]) == \\"No\\"","solution":"def is_wavy(arr): Returns \\"Yes\\" if the array is wavy, otherwise returns \\"No\\". n = len(arr) for i in range(1, n - 1): if not ((arr[i] > arr[i - 1] and arr[i] > arr[i + 1]) or (arr[i] < arr[i - 1] and arr[i] < arr[i + 1])): return \\"No\\" return \\"Yes\\""},{"question":"import heapq from collections import Counter def rearrange_string(s: str) -> str: Rearrange the string such that no two adjacent characters are the same. If it's not possible, return \\"NO\\". pass def process_queries(queries: List[str]) -> List[str]: Process multiple string rearrangement queries. >>> process_queries([\\"aab\\", \\"aaab\\", \\"abc\\"]) [\\"aba\\", \\"NO\\", \\"abc\\"] >>> process_queries([\\"aabb\\", \\"zzz\\", \\"xyxy\\"]) [\\"abab\\", \\"NO\\", \\"xyxy\\"] pass","solution":"import heapq from collections import Counter def rearrange_string(s): # Frequency map of characters char_freq = Counter(s) # Max heap based on frequency of characters max_heap = [(-freq, char) for char, freq in char_freq.items()] heapq.heapify(max_heap) prev_freq, prev_char = 0, '' result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_freq = freq + 1 # decrement the frequency prev_char = char rearranged = ''.join(result) if len(rearranged) != len(s): return \\"NO\\" else: return rearranged def process_queries(queries): results = [] for query in queries: results.append(rearrange_string(query)) return results"},{"question":"def maximize_total_beauty(n: int, m: int, k: int, beauty_scores: List[int]) -> int: Returns the maximum total beauty score that can be achieved by collecting exactly m stones per visit for k visits from n distinct types of stones. :param n: Total number of distinct stone types. :param m: Number of stones to collect in each visit. :param k: Number of visits. :param beauty_scores: A list containing the beauty scores of each type of stone. :return: The maximum total beauty score. >>> maximize_total_beauty(5, 2, 2, [4, 9, 2, 8, 5]) == 26 >>> maximize_total_beauty(1, 1, 1, [1]) == 1 >>> maximize_total_beauty(1, 1, 10, [10]) == 10 >>> maximize_total_beauty(5, 2, 2, [5, 5, 5, 5, 5]) == 20 >>> maximize_total_beauty(10, 1, 1, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 10 >>> maximize_total_beauty(10, 1, 2, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 19 >>> maximize_total_beauty(5, 2, 2, [1000000000, 999999999, 1000000000, 999999999, 500000000]) == 3999999998","solution":"def maximize_total_beauty(n, m, k, beauty_scores): Returns the maximum total beauty score that can be achieved by collecting exactly m stones per visit for k visits from n distinct types of stones. :param n: Total number of distinct stone types. :param m: Number of stones to collect in each visit. :param k: Number of visits. :param beauty_scores: A list containing the beauty scores of each type of stone. :return: The maximum total beauty score. # Sort the beauty scores in descending order sorted_beauty_scores = sorted(beauty_scores, reverse=True) # Sum the top k * m beauty scores max_total_beauty = sum(sorted_beauty_scores[:m * k]) return max_total_beauty"},{"question":"class BankAccount: A class that simulates a simple bank account. Attributes ---------- balance : float The current balance of the account. account_number : str The unique identifier for the account. Methods ------- __init__(self, account_number: str, initial_balance: float = 0.0) Initializes a new bank account with the provided account number and an optional initial balance (default is 0.0). deposit(self, amount: float) -> None Adds the specified amount to the account balance. Raises a ValueError if the deposit amount is not positive. withdraw(self, amount: float) -> None Subtracts the specified amount from the account balance. Raises a ValueError if the withdrawal amount is greater than the current balance or not positive. get_balance(self) -> float Returns the current account balance. def __init__(self, account_number: str, initial_balance: float = 0.0): pass def deposit(self, amount: float) -> None: pass def withdraw(self, amount: float) -> None: pass def get_balance(self) -> float: pass","solution":"class BankAccount: def __init__(self, account_number: str, initial_balance: float = 0.0): if not account_number.isalnum() or not account_number: raise ValueError(\\"Account number must be a non-empty alphanumeric string.\\") if initial_balance < 0: raise ValueError(\\"Initial balance cannot be negative.\\") self.account_number = account_number self.balance = initial_balance def deposit(self, amount: float) -> None: if amount <= 0: raise ValueError(\\"Deposit amount must be positive.\\") self.balance += amount def withdraw(self, amount: float) -> None: if amount <= 0: raise ValueError(\\"Withdrawal amount must be positive.\\") if amount > self.balance: raise ValueError(\\"Not enough balance to withdraw the requested amount.\\") self.balance -= amount def get_balance(self) -> float: return self.balance"},{"question":"def minimize_sequence_length(n: int, k: int, sequence: List[int]) -> int: Given the initial sequence of length n and the number of operations k, return the minimum possible length of the sequence. :param n: Integer, the length of the initial sequence. :param k: Integer, the number of operations. :param sequence: List of integers, the initial sequence. :return: Integer, the minimum possible length of the sequence after k operations. >>> minimize_sequence_length(5, 2, [2, 3, 7, 2, 1]) 3 >>> minimize_sequence_length(4, 1, [1, 5, 2, 4]) 3 # Unit tests def test_example1(): assert minimize_sequence_length(5, 2, [2, 3, 7, 2, 1]) == 3 def test_example2(): assert minimize_sequence_length(4, 1, [1, 5, 2, 4]) == 3 def test_min_length(): # Minimum length should be 1 after n-1 operations assert minimize_sequence_length(10, 9, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 1 def test_no_operations(): # If no operations are performed, length remains the same assert minimize_sequence_length(6, 0, [1, 2, 3, 4, 5, 6]) == 6 def test_max_operations(): # If the operations are more than enough to reduce the sequence assert minimize_sequence_length(7, 5, [5, 10, 15, 20, 25, 30, 35]) == 2 def test_multiple_operations(): # Testing with various values assert minimize_sequence_length(9, 4, [3, 1, 4, 1, 5, 9, 2, 6, 5]) == 5 assert minimize_sequence_length(6, 3, [1, 3, 5, 7, 9, 11]) == 3 def test_one_to_one_operations(): # Reducing exactly by k elements assert minimize_sequence_length(3, 2, [1, 2, 3]) == 1 def test_single_element_sequence(): # If we start with one element and no operations assert minimize_sequence_length(1, 0, [100]) == 1","solution":"def minimize_sequence_length(n, k, sequence): Given the initial sequence of length n and the number of operations k, return the minimum possible length of the sequence. :param n: Integer, the length of the initial sequence. :param k: Integer, the number of operations. :param sequence: List of integers, the initial sequence. :return: Integer, the minimum possible length of the sequence after k operations. return max(1, n - k)"},{"question":"def reverse_words_preserve_spaces(s: str) -> str: Returns a new string with each word reversed, preserving the order of words and spaces. >>> reverse_words_preserve_spaces(\\"the sky is blue\\") \\"eht yks si eulb\\" >>> reverse_words_preserve_spaces(\\"hello world\\") \\"olleh dlrow\\" >>> reverse_words_preserve_spaces(\\" quick brown fox \\") \\" kciuq nworb xof \\" >>> reverse_words_preserve_spaces(\\"\\") \\"\\" >>> reverse_words_preserve_spaces(\\" \\") \\" \\"","solution":"def reverse_words_preserve_spaces(s): Returns a new string with each word reversed, preserving the order of words and spaces. words = s.split(' ') reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words)"},{"question":"from collections import defaultdict from typing import List def group_anagrams(strings: List[str]) -> List[List[str]]: Groups strings that are anagrams of each other. Args: strings (list of str): List of input strings. Returns: list of list of str: List of anagram groups, each group is a list of strings. # Your code here def process_input(n: int, strings: List[str]) -> str: Helper function to process input parameters and format the output. Args: n (int): Number of strings strings (list of str): List of input strings Returns: formatted_output (str): formatted output string for the anagram groups Example: >>> n = 6 >>> strings = [\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"] >>> process_input(n, strings) 'eat tea atentan natnbat' # Your code here def test_group_anagrams_basic(): strings = [\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"] result = group_anagrams(strings) assert sorted([sorted(group) for group in result]) == sorted([sorted(group) for group in [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]]]) def test_group_anagrams_single(): strings = [\\"hello\\"] result = group_anagrams(strings) assert sorted([sorted(group) for group in result]) == sorted([sorted(group) for group in [[\\"hello\\"]]]) def test_group_anagrams_no_anagrams(): strings = [\\"abc\\", \\"def\\", \\"ghi\\"] result = group_anagrams(strings) assert sorted([sorted(group) for group in result]) == sorted([sorted(group) for group in [[\\"abc\\"], [\\"def\\"], [\\"ghi\\"]]]) def test_group_anagrams_some_anagrams(): strings = [\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"glegoo\\"] result = group_anagrams(strings) assert sorted([sorted(group) for group in result]) == sorted([sorted(group) for group in [[\\"listen\\", \\"silent\\", \\"enlist\\"], [\\"google\\", \\"glegoo\\"]]]) def test_process_input(): n = 6 strings = [\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"] result = process_input(n, strings) assert result == \\"eat tea atentan natnbat\\" or result == \\"tan natneat tea atenbat\\" or result == \\"tan natnbatneat tea ate\\" # Running the tests if __name__ == \\"__main__\\": test_group_anagrams_basic() test_group_anagrams_single() test_group_anagrams_no_anagrams() test_group_anagrams_some_anagrams() test_process_input() print(\\"All tests passed!\\")","solution":"from collections import defaultdict def group_anagrams(strings): Groups strings that are anagrams of each other. Args: strings (list of str): List of input strings. Returns: list of list of str: List of anagram groups, each group is a list of strings. anagram_map = defaultdict(list) for string in strings: sorted_str = ''.join(sorted(string)) anagram_map[sorted_str].append(string) return list(anagram_map.values()) def process_input(n, strings): Helper function to process input parameters Args: n (int): Number of strings strings (list of str): List of input strings Returns: formatted_output (str): formatted output string for the anagram groups anagram_groups = group_anagrams(strings) formatted_output = 'n'.join([' '.join(group) for group in anagram_groups]) return formatted_output # Example usage: n = 6 strings = [\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"] print(process_input(n, strings))"},{"question":"def max_profit(prices: List[int]) -> int: Returns the maximum profit obtainable from buying and selling stocks. :param prices: List of integers representing stock prices on each day. :return: Integer representing maximum profit. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"def max_profit(prices): Returns the maximum profit obtainable from buying and selling stocks. :param prices: List of integers representing stock prices on each day. :return: Integer representing maximum profit. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def min_changes_to_palindrome(s: str) -> int: Returns the minimum number of changes needed to convert the given string into a palindrome. Args: s (str): A string consisting of uppercase English letters. Returns: int: Minimum number of changes to make the string a palindrome. Examples: >>> min_changes_to_palindrome(\\"ABCA\\") 1 >>> min_changes_to_palindrome(\\"ABCDE\\") 2 >>> min_changes_to_palindrome(\\"AABB\\") 2 >>> min_changes_to_palindrome(\\"RACECAR\\") 0 >>> min_changes_to_palindrome(\\"RADAR\\") 0","solution":"def min_changes_to_palindrome(s): Returns the minimum number of changes needed to convert the given string into a palindrome. n = len(s) changes = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: changes += 1 return changes"},{"question":"class NetworkManagementSystem: def __init__(self, loads): Initialize the network management system with the given loads. self.loads = loads def update_load(self, si, li): Update the load of server si to li. pass def max_load(self, si, sj): Find the server with the maximum load within the range [si, sj]. Returns a tuple of (server ID, load). pass def increase_load(self, si, sj, di): Increase the load of every server within the range [si, sj] by di. pass # Unit Tests def test_update_load(): nms = NetworkManagementSystem([1, 3, 5, 2, 4]) nms.update_load(3, 6) assert nms.loads == [1, 3, 6, 2, 4] def test_max_load(): nms = NetworkManagementSystem([1, 3, 5, 2, 4]) assert nms.max_load(1, 4) == (3, 5) nms.update_load(3, 6) assert nms.max_load(1, 5) == (3, 6) def test_increase_load(): nms = NetworkManagementSystem([1, 3, 5, 2, 4]) nms.increase_load(2, 4, 3) assert nms.loads == [1, 6, 8, 5, 4] def test_combined_operations(): nms = NetworkManagementSystem([1, 3, 5, 2, 4]) assert nms.max_load(1, 4) == (3, 5) nms.update_load(3, 6) assert nms.max_load(1, 5) == (3, 6) nms.increase_load(2, 4, 3) assert nms.loads == [1, 6, 9, 5, 4] assert nms.max_load(1, 5) == (3, 9)","solution":"class NetworkManagementSystem: def __init__(self, loads): self.loads = loads def update_load(self, si, li): self.loads[si - 1] = li def max_load(self, si, sj): max_load_server = si max_load_value = self.loads[si - 1] for i in range(si, sj + 1): if self.loads[i - 1] > max_load_value: max_load_value = self.loads[i - 1] max_load_server = i return max_load_server, max_load_value def increase_load(self, si, sj, di): for i in range(si, sj + 1): self.loads[i - 1] += di"},{"question":"def process_operations(n: int, initial_heights: List[int], operations: List[str]) -> List[int]: Process a list of operations and output the final height of each tower after all operations have been performed. Args: n (int): Number of towers. initial_heights (List[int]): Initial heights of the towers. operations (List[str]): List of operations to perform on towers. Returns: List[int]: Heights of the towers after performing the operations. Examples: >>> process_operations(5, [1, 2, 3, 4, 5], [\\"1 2 10\\", \\"2 2\\", \\"1 3 20\\", \\"2 3\\"]) [12, 23] >>> process_operations(3, [4, 5, 6], [\\"1 1 100\\", \\"1 3 200\\", \\"2 3\\"]) [206]","solution":"def process_operations(n, initial_heights, operations): heights = initial_heights[:] # make a copy of the initial heights results = [] for operation in operations: parts = operation.split() if parts[0] == '1': x = int(parts[1]) - 1 h = int(parts[2]) heights[x] += h elif parts[0] == '2': x = int(parts[1]) - 1 results.append(heights[x]) return results"},{"question":"from typing import List, Tuple def autocomplete(dictionary_entries: List[Tuple[str, str]], prefix: str) -> List[Tuple[str, str]]: Autocomplete feature that filters and sorts dictionary entries based on a given prefix. >>> autocomplete([(\\"apple\\", \\"a fruit\\"), (\\"application\\", \\"a formal request\\"), (\\"banana\\", \\"a fruit\\"), (\\"apply\\", \\"make a formal request\\"), (\\"apology\\", \\"an expression of regret\\")], \\"app\\") [(\\"apple\\", \\"a fruit\\"), (\\"application\\", \\"a formal request\\"), (\\"apply\\", \\"make a formal request\\")] >>> autocomplete([(\\"apple\\", \\"a fruit\\"), (\\"application\\", \\"a formal request\\"), (\\"banana\\", \\"a fruit\\"), (\\"apply\\", \\"make a formal request\\"), (\\"apology\\", \\"an expression of regret\\")], \\"car\\") [] >>> autocomplete([(\\"apple\\", \\"a fruit\\"), (\\"application\\", \\"a formal request\\"), (\\"banana\\", \\"a fruit\\"), (\\"apply\\", \\"make a formal request\\"), (\\"apology\\", \\"an expression of regret\\")], \\"a\\") [(\\"apology\\", \\"an expression of regret\\"), (\\"apple\\", \\"a fruit\\"), (\\"application\\", \\"a formal request\\"), (\\"apply\\", \\"make a formal request\\")] >>> autocomplete([(\\"apple\\", \\"a fruit\\"), (\\"application\\", \\"a formal request\\"), (\\"banana\\", \\"a fruit\\"), (\\"apply\\", \\"make a formal request\\"), (\\"apology\\", \\"an expression of regret\\")], \\"application\\") [(\\"application\\", \\"a formal request\\")] >>> autocomplete([(\\"cat\\", \\"a feline\\"), (\\"car\\", \\"a vehicle\\"), (\\"care\\", \\"attention or caution\\"), (\\"carry\\", \\"to hold something\\")], \\"car\\") [(\\"car\\", \\"a vehicle\\"), (\\"care\\", \\"attention or caution\\"), (\\"carry\\", \\"to hold something\\")]","solution":"from typing import List, Tuple def autocomplete(dictionary_entries: List[Tuple[str, str]], prefix: str) -> List[Tuple[str, str]]: result = [entry for entry in dictionary_entries if entry[0].startswith(prefix)] result.sort() return result"},{"question":"from typing import List, Union def construct_matrix(n: int, m: int) -> Union[str, List[List[int]]]: Given two integers n and m, you have to construct an n x m matrix that fulfills the following conditions: 1. Each element in the matrix is a unique integer from 1 to n*m. 2. All adjacent elements in any row or column differ by exactly 1. If it is impossible to construct such a matrix, return \\"Impossible\\". Arguments: n -- number of rows m -- number of columns Returns: A string \\"Impossible\\" if it is not possible to construct the matrix, otherwise a 2D list representing the matrix. # Your code here def test_single_row(): assert construct_matrix(1, 5) == [[1, 2, 3, 4, 5]] def test_single_column(): assert construct_matrix(5, 1) == [[1], [2], [3], [4], [5]] def test_impossible_case(): assert construct_matrix(2, 3) == \\"Impossible\\" assert construct_matrix(3, 2) == \\"Impossible\\" assert construct_matrix(2, 2) == \\"Impossible\\" def test_square_matrix(): assert construct_matrix(3, 3) == [ [1, 2, 3], [6, 5, 4], [7, 8, 9] ] def test_rectangular_matrix(): assert construct_matrix(3, 4) == [ [1, 2, 3, 4], [8, 7, 6, 5], [9, 10, 11, 12] ] assert construct_matrix(4, 3) == [ [1, 2, 3], [6, 5, 4], [7, 8, 9], [12, 11, 10] ]","solution":"def construct_matrix(n, m): if n == 1: return [[i for i in range(1, m + 1)]] if m == 1: return [[i] for i in range(1, n + 1)] if n == 2 or m == 2: return \\"Impossible\\" matrix = [] num = 1 for i in range(n): row = [] for j in range(m): row.append(num) num += 1 if i % 2 == 1: row.reverse() matrix.append(row) return matrix"},{"question":"from typing import List, Tuple def count_connected_components(test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[int]: Given an undirected graph with N nodes and M edges, determine the number of connected components in the graph. >>> count_connected_components([(5, 3, [(1, 2), (1, 3), (4, 5)]), (4, 2, [(1, 2), (3, 4)])]) [2, 2] >>> count_connected_components([(1, 0, [])]) [1] >>> count_connected_components([(2, 1, [(1, 2)])]) [1] >>> count_connected_components([(4, 0, [])]) [4]","solution":"def count_connected_components(test_cases): def dfs(node, adjacency_list, visited): stack = [node] while stack: current = stack.pop() for neighbor in adjacency_list[current]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) results = [] for N, M, edges in test_cases: adjacency_list = [[] for _ in range(N + 1)] for u, v in edges: adjacency_list[u].append(v) adjacency_list[v].append(u) visited = [False] * (N + 1) component_count = 0 for node in range(1, N + 1): if not visited[node]: visited[node] = True component_count += 1 dfs(node, adjacency_list, visited) results.append(component_count) return results"},{"question":"def determine_winner(n): Determine the winner of the game given the starting number n. If Alex wins, return \\"Alex\\", otherwise return \\"Bob\\". def game_outcomes(t, cases): Determine the winner for each game in the list of cases. t: integer, number of test cases cases: list of integers, each representing the initial number n in a test case # Unit Tests def test_determine_winner(): assert determine_winner(1) == \\"Bob\\" assert determine_winner(2) == \\"Alex\\" assert determine_winner(3) == \\"Bob\\" assert determine_winner(4) == \\"Alex\\" assert determine_winner(5) == \\"Bob\\" def test_game_outcomes(): assert game_outcomes(5, [1, 2, 3, 4, 5]) == [\\"Bob\\", \\"Alex\\", \\"Bob\\", \\"Alex\\", \\"Bob\\"] assert game_outcomes(3, [6, 7, 8]) == [\\"Alex\\", \\"Bob\\", \\"Alex\\"] assert game_outcomes(2, [10, 15]) == [\\"Alex\\", \\"Bob\\"] def test_additional_cases(): assert game_outcomes(4, [123456789, 987654321, 1000000000, 999999999]) == [\\"Bob\\", \\"Bob\\", \\"Alex\\", \\"Bob\\"] assert game_outcomes(3, [9, 18, 27]) == [\\"Bob\\", \\"Alex\\", \\"Bob\\"] assert game_outcomes(2, [14, 31]) == [\\"Alex\\", \\"Bob\\"]","solution":"def determine_winner(n): Determine the winner of the game given the starting number n. If Alex wins, return \\"Alex\\", otherwise return \\"Bob\\". # If n is 1, Alex cannot make a move at the start and loses. if n == 1: return \\"Bob\\" # For all other cases, we follow the rules of the game. # The optimal strategy gives the following pattern: # If n is even, Alex wins. # If n is odd, Bob wins. elif n % 2 == 0: return \\"Alex\\" else: return \\"Bob\\" def game_outcomes(t, cases): Determine the winner for each game in the list of cases. t: integer, number of test cases cases: list of integers, each representing the initial number n in a test case results = [] for n in cases: results.append(determine_winner(n)) return results"},{"question":"from typing import List def calculate_height(n: int, parents: List[int]) -> int: Calculate the height of a binary tree given its parent array. Args: n (int): The number of nodes in the tree. parents (List[int]): A list where the i-th element corresponds to the parent of the i-th node. Returns: int: The height of the binary tree. Examples: >>> calculate_height(5, [0, 1, 1, 2, 2]) 3 >>> calculate_height(3, [0, 1, 1]) 2","solution":"def calculate_height(n, parents): from collections import defaultdict, deque if n == 1: return 1 # Create the tree from the parent array tree = defaultdict(list) root = -1 for i in range(n): if parents[i] == 0: root = i else: tree[parents[i] - 1].append(i) # BFS to calculate the height queue = deque([(root, 0)]) max_height = 0 while queue: node, height = queue.popleft() max_height = max(max_height, height) for child in tree[node]: queue.append((child, height + 1)) return max_height + 1 # Example usage: # n = 5 # parents = [0, 1, 1, 2, 2] # print(calculate_height(n, parents)) # Output: 3 # n = 3 # parents = [0, 1, 1] # print(calculate_height(n, parents)) # Output: 2"},{"question":"def minCut(s: str) -> int: Given a string s, partition s such that every substring in the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s. Example: >>> minCut(\\"aab\\") 1 >>> minCut(\\"a\\") 0 >>> minCut(\\"abc\\") 2 def test_example_1(): assert minCut(\\"aab\\") == 1 def test_example_2(): assert minCut(\\"a\\") == 0 def test_example_3(): assert minCut(\\"abc\\") == 2 def test_long_palindrome(): assert minCut(\\"aaa\\") == 0 def test_single_character_repeat(): assert minCut(\\"aaaaa\\") == 0 def test_alternating_characters(): assert minCut(\\"abababa\\") == 0 def test_complex_case(): assert minCut(\\"abcbm\\") == 2 def test_even_length_palindrome(): assert minCut(\\"abba\\") == 0 def test_two_character_palindrome(): assert minCut(\\"aa\\") == 0","solution":"def minCut(s): n = len(s) if n <= 1: return 0 # Create a table to check if substring s[i:j+1] is a palindrome dp = [[False] * n for _ in range(n)] for i in range(n): dp[i][i] = True for length in range(2, n+1): for i in range(n-length+1): j = i + length - 1 if s[i] == s[j]: if length == 2: dp[i][j] = True else: dp[i][j] = dp[i+1][j-1] # Create a helper array to store the minimum cuts required cuts = [0] * n for i in range(n): if dp[0][i]: cuts[i] = 0 else: cuts[i] = float('inf') for j in range(i): if dp[j+1][i]: cuts[i] = min(cuts[i], cuts[j] + 1) return cuts[-1]"},{"question":"def compress_string_length(s: str) -> int: Compresses the given string using the specified rule and returns the length of the compressed string if it is shorter than the original string, otherwise returns the length of the original string. >>> compress_string_length(\\"aaabbcc\\") 6 >>> compress_string_length(\\"abcd\\") 4 >>> compress_string_length(\\"a\\") 1 >>> compress_string_length(\\"abcdefg\\") 7 >>> compress_string_length(\\"aaaaa\\") 2 >>> compress_string_length(\\"\\") 0","solution":"def compress_string_length(s): Compresses the given string using the specified rule and returns the length of the compressed string if it is shorter than the original string, otherwise returns the length of the original string. if not s: return 0 compressed_string = [] count_consecutive = 0 for i in range(len(s)): count_consecutive += 1 if i + 1 >= len(s) or s[i] != s[i + 1]: compressed_string.append(s[i] + str(count_consecutive)) count_consecutive = 0 compressed_string = ''.join(compressed_string) if len(compressed_string) >= len(s): return len(s) else: return len(compressed_string)"},{"question":"def is_pangram(s: str) -> str: Determines if the given string s is a pangram. >>> is_pangram(\\"The quick brown fox jumps over the lazy dog\\") \\"YES\\" >>> is_pangram(\\"Hello World\\") \\"NO\\" def process_test_cases(t: int, sentences: List[str]) -> List[str]: Process multiple test cases to determine if each sentence is a pangram. >>> process_test_cases(3, [\\"The quick brown fox jumps over the lazy dog\\", \\"Hello World\\", \\"Pack my box with five dozen liquor jugs\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"]","solution":"def is_pangram(s): Determines if the given string s is a pangram. alphabet = set('abcdefghijklmnopqrstuvwxyz') s = s.lower() s_set = set([char for char in s if char.isalpha()]) return \\"YES\\" if alphabet.issubset(s_set) else \\"NO\\" def process_test_cases(t, sentences): Process multiple test cases to determine if each sentence is a pangram. results = [] for sentence in sentences: results.append(is_pangram(sentence)) return results"},{"question":"def find_min_roads_to_strong_connect(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Determine the minimum number of additional one-way roads required to make the graph of intersections strongly connected. Args: n (int): Number of intersections. m (int): Number of one-way roads. edges (List[Tuple[int, int]]): List of directed roads (edges) where (u, v) means a road from intersection u to intersection v. Returns: int: Minimum number of additional one-way roads required. >>> find_min_roads_to_strong_connect(6, 5, [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6)]) 2 >>> find_min_roads_to_strong_connect(1, 0, []) 0 >>> find_min_roads_to_strong_connect(3, 3, [(1, 2), (2, 3), (3, 1)]) 0 >>> find_min_roads_to_strong_connect(4, 2, [(1, 2), (3, 4)]) 2 >>> find_min_roads_to_strong_connect(4, 4, [(1, 2), (2, 3), (3, 1), (4, 3)]) 1 >>> find_min_roads_to_strong_connect(5, 3, [(1, 2), (3, 4), (4, 5)]) 2 pass","solution":"def find_min_roads_to_strong_connect(n, m, edges): import sys sys.setrecursionlimit(1500) from collections import defaultdict, deque def kosaraju(graph, n): visited = [False] * n order = [] scc = [] def dfs1(v): visited[v] = True for u in graph[v]: if not visited[u]: dfs1(u) order.append(v) def dfs2(v, component): visited[v] = True component.append(v) for u in reversed_graph[v]: if not visited[u]: dfs2(u, component) for i in range(n): if not visited[i]: dfs1(i) reversed_graph = defaultdict(list) for u in range(n): for v in graph[u]: reversed_graph[v].append(u) visited = [False] * n while order: v = order.pop() if not visited[v]: component = [] dfs2(v, component) scc.append(component) return scc graph = defaultdict(list) for u, v in edges: graph[u - 1].append(v - 1) scc = kosaraju(graph, n) scc_count = len(scc) if scc_count == 1: return 0 scc_graph = defaultdict(set) scc_indices = [0] * n for i, component in enumerate(scc): for node in component: scc_indices[node] = i for u in range(n): for v in graph[u]: if scc_indices[u] != scc_indices[v]: scc_graph[scc_indices[u]].add(scc_indices[v]) in_degrees = [0] * scc_count out_degrees = [0] * scc_count for u in range(scc_count): for v in scc_graph[u]: out_degrees[u] += 1 in_degrees[v] += 1 zero_in = sum(1 for deg in in_degrees if deg == 0) zero_out = sum(1 for deg in out_degrees if deg == 0) return max(zero_in, zero_out) # Example usage n, m = 6, 5 edges = [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6)] print(find_min_roads_to_strong_connect(n, m, edges)) # Output: 2"},{"question":"def calculate_descent_time(height: int, initial_rate: int) -> float: Calculate the total descent time of a Jumper. Parameters: height (int): The initial height in meters. initial_rate (int): The initial descent rate in m/s. Returns: float: The total time in seconds required for the Jumper to land safely. Example: >>> calculate_descent_time(50, 5) 10.0 >>> calculate_descent_time(100, 15) 6.66666666667 >>> calculate_descent_time(200, 8) 25.0 >>> calculate_descent_time(10000, 100) 100.0","solution":"def calculate_descent_time(height, initial_rate): Calculate the total descent time of a Jumper. Parameters: height (int): The initial height in meters. initial_rate (int): The initial descent rate in m/s. Returns: float: The total time in seconds required for the Jumper to land safely. return height / initial_rate"},{"question":"def is_rearrangement_possible(S: str) -> str: Checks if it is possible to rearrange the characters of the string S such that no two adjacent characters are the same. >>> is_rearrangement_possible(\\"aaabb\\") \\"POSSIBLE\\" >>> is_rearrangement_possible(\\"aaab\\") \\"IMPOSSIBLE\\" >>> is_rearrangement_possible(\\"abcd\\") \\"POSSIBLE\\" >>> is_rearrangement_possible(\\"aa\\") \\"IMPOSSIBLE\\"","solution":"from collections import Counter def is_rearrangement_possible(S): Checks if it is possible to rearrange the characters of the string S such that no two adjacent characters are the same. if not S: return \\"IMPOSSIBLE\\" n = len(S) char_counts = Counter(S) max_count = max(char_counts.values()) # It is impossible to rearrange if the most frequent character count is more than (N + 1) // 2 if max_count > (n + 1) // 2: return \\"IMPOSSIBLE\\" return \\"POSSIBLE\\""},{"question":"def calculate_total_and_grade(scores): Calculate the total points and corresponding grade based on scores in five activities. Args: scores (list of int): List of 5 integers representing the points in five activities. Returns: tuple: Total points (int) and corresponding grade (str). >>> calculate_total_and_grade([90, 85, 78, 88, 92]) (433, 'B') >>> calculate_total_and_grade([90, 95, 90, 90, 85]) (450, 'A') >>> calculate_total_and_grade([50, 40, 55, 60, 70]) (275, 'E') pass","solution":"def calculate_total_and_grade(scores): Calculate the total points and corresponding grade based on scores in five activities. Args: scores (list of int): List of 5 integers representing the points in five activities. Returns: tuple: Total points (int) and corresponding grade (str). if len(scores) != 5: raise ValueError(\\"There must be exactly 5 scores\\") total_points = sum(scores) if total_points >= 450: grade = 'A' elif total_points >= 400: grade = 'B' elif total_points >= 350: grade = 'C' elif total_points >= 300: grade = 'D' else: grade = 'E' return total_points, grade # Example usage: # scores = [90, 85, 78, 88, 92] # total_points, grade = calculate_total_and_grade(scores) # print(total_points) # print(grade)"},{"question":"class ArrayOperations: def __init__(self, arr): self.arr = arr def update(self, i, X): if 1 <= i <= len(self.arr): self.arr[i-1] = X def range_sum(self, L, R): if 1 <= L <= R <= len(self.arr): return sum(self.arr[L-1:R]) def perform_operations(arr, queries): Perform a series of update and range sum queries on the given array. Parameters: arr (List[int]): The initial elements of the array. queries (List[Tuple[int, int, int]]): The list of queries to perform, where each query is a tuple (type, arg1, arg2). Returns: List[int]: The results of the range sum queries. >>> perform_operations([1, 2, 3, 4, 5], [(2, 1, 3), (1, 2, 10), (2, 1, 3)]) [6, 14]","solution":"class ArrayOperations: def __init__(self, arr): self.arr = arr def update(self, i, X): if 1 <= i <= len(self.arr): self.arr[i-1] = X def range_sum(self, L, R): if 1 <= L <= R <= len(self.arr): return sum(self.arr[L-1:R]) def perform_operations(arr, queries): array_ops = ArrayOperations(arr) results = [] for query in queries: if query[0] == 1: array_ops.update(query[1], query[2]) elif query[0] == 2: result = array_ops.range_sum(query[1], query[2]) results.append(result) return results"},{"question":"def rearrange_books(n: int, books: List[str], read_counts: List[int]) -> List[str]: Rearranges the books based on the number of times they have been read. Parameters: n (int): the number of books in the stack. books (list of str): the titles of the books in the stack. read_counts (list of int): the number of times each corresponding book has been read. Returns: list of str: the rearranged list of book titles. Example: >>> rearrange_books(5, [\\"bookA\\", \\"bookB\\", \\"bookC\\", \\"bookD\\", \\"bookE\\"], [3, 5, 2, 5, 1]) [\\"bookB\\", \\"bookD\\", \\"bookA\\", \\"bookC\\", \\"bookE\\"] >>> rearrange_books(4, [\\"alpha\\", \\"beta\\", \\"gamma\\", \\"delta\\"], [2, 3, 3, 1]) [\\"beta\\", \\"gamma\\", \\"alpha\\", \\"delta\\"]","solution":"def rearrange_books(n, books, read_counts): Rearranges the books based on the number of times they have been read. Parameters: n (int): the number of books in the stack. books (list of str): the titles of the books in the stack. read_counts (list of int): the number of times each corresponding book has been read. Returns: list of str: the rearranged list of book titles. books_with_counts = list(zip(books, read_counts)) books_with_counts.sort(key=lambda x: (-x[1], books.index(x[0]))) return [book for book, _ in books_with_counts]"},{"question":"def max_non_overlapping_events(events): Returns the maximum number of non-overlapping events an employee can attend. :param events: List of tuples, each tuple has two integers representing start and end times. :return: Integer, maximum number of non-overlapping events. pass def process_input(input_string): Processes the input string and returns a list of events as tuples. :param input_string: String, input data containing number of events and event timings. :return: List of tuples, each tuple has two integers representing start and end times. pass # Unit Test Cases def test_max_non_overlapping_events_example1(): input_string = \\"5n1 3n2 5n4 7n6 9n8 10\\" events = process_input(input_string) assert max_non_overlapping_events(events) == 3 def test_max_non_overlapping_events_example2(): input_string = \\"3n1 2n3 4n5 6\\" events = process_input(input_string) assert max_non_overlapping_events(events) == 3 def test_max_non_overlapping_events_single_event(): input_string = \\"1n1 10\\" events = process_input(input_string) assert max_non_overlapping_events(events) == 1 def test_max_non_overlapping_events_no_non_overlapping(): input_string = \\"3n1 4n2 5n3 6\\" events = process_input(input_string) assert max_non_overlapping_events(events) == 1 def test_max_non_overlapping_events_all_non_overlapping(): input_string = \\"3n1 2n2 3n3 4\\" events = process_input(input_string) assert max_non_overlapping_events(events) == 3 def test_process_input(): input_string = \\"3n1 2n2 3n3 4\\" events = process_input(input_string) assert events == [(1, 2), (2, 3), (3, 4)]","solution":"def max_non_overlapping_events(events): Returns the maximum number of non-overlapping events an employee can attend. :param events: List of tuples, each tuple has two integers representing start and end times. :return: Integer, maximum number of non-overlapping events. # Sort the events based on their end time events.sort(key=lambda x: x[1]) count = 0 end_time = 0 for start, end in events: if start >= end_time: count += 1 end_time = end return count def process_input(input_string): lines = input_string.splitlines() N = int(lines[0]) events = [tuple(map(int, x.split())) for x in lines[1:]] return events"},{"question":"def min_distance_sum(n: int) -> int: Returns the minimum possible sum of the distances between the original and the new positions of n books. Args: n (int): The number of books. Returns: int: The minimum possible sum of the distances. Examples: >>> min_distance_sum(1) 0 >>> min_distance_sum(2) 1 >>> min_distance_sum(3) 3 >>> min_distance_sum(4) 6 >>> min_distance_sum(5) 10 >>> min_distance_sum(10) 45 >>> min_distance_sum(1000) 499500","solution":"def min_distance_sum(n): Returns the minimum possible sum of the distances between the original and the new positions of n books. return (n*(n-1)) // 2"},{"question":"def most_frequent_word(document: str) -> str: Given a document, find the most frequently occurring word. Ignore punctuation, and in case of ties, return the lexicographically smallest word. >>> most_frequent_word(\\"the quick brown fox jumps over the lazy dog the quick fox is quick\\") == \\"quick\\" >>> most_frequent_word(\\"the quick, brown fox! jumps over the lazy dog. the quick fox; is quick?\\") == \\"quick\\" >>> most_frequent_word(\\"unique\\") == \\"unique\\" >>> most_frequent_word(\\"a a b b c c a b\\") == \\"a\\" >>> long_input = \\"a \\" * 500000 + \\"b \\" * 499999 >>> most_frequent_word(long_input) == \\"a\\"","solution":"import re from collections import Counter def most_frequent_word(document: str) -> str: # Remove punctuation using regular expression cleaned_document = re.sub(r'[^ws]', '', document) # Split the document into words words = cleaned_document.split() # Count the frequency of each word word_count = Counter(words) # Find the word with the maximum frequency, breaking ties by lexicographical order most_frequent = min(word_count.items(), key=lambda x: (-x[1], x[0])) return most_frequent[0]"},{"question":"def num_trees_to_water(garden: List[List[int]], M: int, N: int) -> int: Returns the number of trees that need to be watered. :param garden: A 2D list representing the grid garden :param M: Number of rows in the grid :param N: Number of columns in the grid :return: Number of trees that need to be watered >>> num_trees_to_water([ ... [0, 1, 0, 0], ... [0, 0, 1, 0], ... [0, 0, 0, 1], ... [1, 0, 0, 0] ... ], 4, 4) 4 >>> num_trees_to_water([ ... [0, 0], ... [0, 0] ... ], 2, 2) 0 >>> num_trees_to_water([ ... [1, 1], ... [1, 1] ... ], 2, 2) 0 >>> num_trees_to_water([ ... [1, 0, 1], ... [0, 1, 0], ... [1, 0, 1] ... ], 3, 3) 5 >>> num_trees_to_water([ ... [1] ... ], 1, 1) 1","solution":"def num_trees_to_water(garden, M, N): Returns the number of trees that need to be watered. :param garden: A 2D list representing the grid garden :param M: Number of rows in the grid :param N: Number of columns in the grid :return: Number of trees that need to be watered to_water = 0 for i in range(M): for j in range(N): if garden[i][j] == 1: # Check for adjacent trees has_adjacent = False for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]: ni, nj = i + di, j + dj if 0 <= ni < M and 0 <= nj < N and garden[ni][nj] == 1: has_adjacent = True break if not has_adjacent: to_water += 1 return to_water"},{"question":"def min_edit_distance(s: str, t: str) -> int: Returns the minimum number of operations required to transform string s into string t. >>> min_edit_distance(\\"horse\\", \\"ros\\") 3 >>> min_edit_distance(\\"intention\\", \\"execution\\") 5 from typing import List def test_min_edit_distance(): assert min_edit_distance(\\"horse\\", \\"ros\\") == 3 assert min_edit_distance(\\"intention\\", \\"execution\\") == 5 assert min_edit_distance(\\"abc\\", \\"bcd\\") == 2 assert min_edit_distance(\\"kitten\\", \\"sitting\\") == 3 assert min_edit_distance(\\"\\", \\"a\\") == 1 assert min_edit_distance(\\"a\\", \\"\\") == 1 assert min_edit_distance(\\"a\\", \\"a\\") == 0 assert min_edit_distance(\\"abc\\", \\"abc\\") == 0 assert min_edit_distance(\\"abc\\", \\"xyz\\") == 3 def test_min_edit_distance_identical_strings(): assert min_edit_distance(\\"abc\\", \\"abc\\") == 0 assert min_edit_distance(\\"a\\", \\"a\\") == 0 def test_min_edit_distance_empty_target(): assert min_edit_distance(\\"abc\\", \\"\\") == 3 assert min_edit_distance(\\"hello\\", \\"\\") == 5 def test_min_edit_distance_empty_source(): assert min_edit_distance(\\"\\", \\"abc\\") == 3 assert min_edit_distance(\\"\\", \\"hello\\") == 5","solution":"def min_edit_distance(s, t): Returns the minimum number of operations required to transform string s into string t. m, n = len(s), len(t) # Create a (m+1)x(n+1) matrix to store the edit distances dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If s is empty, all characters in t need to be inserted elif j == 0: dp[i][j] = i # If t is empty, all characters in s need to be removed elif s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no operation needed else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"def generate_quasipalindromic_sequence(n: int) -> str: Returns a quasipalindromic sequence of length n consisting of lowercase English letters. >>> generate_quasipalindromic_sequence(1) 'a' >>> generate_quasipalindromic_sequence(4) 'abba' >>> generate_quasipalindromic_sequence(5) 'abcba' >>> generate_quasipalindromic_sequence(10) 'abcdeedcba'","solution":"def generate_quasipalindromic_sequence(n): Returns a quasipalindromic sequence of length n consisting of lowercase English letters. if n == 1: return 'a' half = (n + 1) // 2 half_sequence = ''.join(chr(97 + i % 26) for i in range(half)) if n % 2 == 0: return half_sequence + half_sequence[::-1] else: return half_sequence + half_sequence[-2::-1]"},{"question":"from typing import List, Tuple def length_of_shortest_string(m: int, n: int) -> int: Returns the length of the shortest possible string that can be formed with m 'a' characters and n 'b' characters. >>> length_of_shortest_string(3, 2) 5 >>> length_of_shortest_string(5, 5) 10 >>> length_of_shortest_string(1, 4) 5 >>> length_of_shortest_string(2, 1) 3 def process_test_cases(test_cases: List[Tuple[int, int]]) -> List[int]: Processes a list of test cases where each test case is a tuple (m, n) and returns a list with the length of the shortest possible string for each test case. >>> process_test_cases([(3, 2), (5, 5), (1, 4), (2, 1)]) [5, 10, 5, 3] >>> process_test_cases([(0, 0), (10, 0), (0, 10)]) [0, 10, 10]","solution":"def length_of_shortest_string(m, n): Returns the length of the shortest possible string that can be formed with m 'a' characters and n 'b' characters. return m + n def process_test_cases(test_cases): results = [] for m, n in test_cases: results.append(length_of_shortest_string(m, n)) return results"},{"question":"def smallest_missing_positive_integer(n: int, a: List[int]) -> int: Find the smallest positive integer that does not appear in the list a. Parameters: n (int): Number of elements in the list. a (list of int): List of integers. Returns: int: The smallest positive integer that is not in the list. >>> smallest_missing_positive_integer(3, [1, 2, 3]) 4 >>> smallest_missing_positive_integer(5, [0, -1, 1, 2, 100]) 3 >>> smallest_missing_positive_integer(6, [5, 5, 5, 1, 2, 3]) 4","solution":"def smallest_missing_positive_integer(n, a): Returns the smallest positive integer that does not appear in the list a. Parameters: n (int): Number of elements in the list. a (list of int): List of integers. Returns: int: The smallest positive integer that is not in the list. # Using a set to store only the positive elements positive_set = set(x for x in a if x > 0) # Start from 1 and check if each number is in the set smallest_positive = 1 while smallest_positive in positive_set: smallest_positive += 1 return smallest_positive"},{"question":"import heapq from typing import List def min_cost_to_reduce_array(arr: List[int]) -> int: Given an array of integers, returns the minimum cost to reduce the array to a single element by repeatedly choosing any two elements and replacing them with their sum until one element remains. >>> min_cost_to_reduce_array([1, 2, 3, 4]) 19 >>> min_cost_to_reduce_array([10, 20, 30]) 90 >>> min_cost_to_reduce_array([100, 200]) 300","solution":"import heapq def min_cost_to_reduce_array(arr): Given an array of integers, returns the minimum cost to reduce the array to a single element by repeatedly choosing any two elements and replacing them with their sum until one element remains. if len(arr) < 2: return 0 heapq.heapify(arr) total_cost = 0 while len(arr) > 1: first_smallest = heapq.heappop(arr) second_smallest = heapq.heappop(arr) cost = first_smallest + second_smallest total_cost += cost heapq.heappush(arr, cost) return total_cost"},{"question":"def organize_molecules(n: int, elements: List[Tuple[str, int]]) -> Union[List[Tuple[int, int]], int]: Organize chemical elements into a molecule structure based on bonding rules. Arguments: n -- the number of elements elements -- a list of tuples where each tuple contains an element name and its bonding capacity Returns: A list of edges which connects all nodes (elements) in a single structure or -1 if it is not possible >>> organize_molecules(4, [(\\"H\\", 1), (\\"O\\", 2), (\\"O\\", 2), (\\"H\\", 1)]) [(0, 1), (1, 2), (2, 3)] >>> organize_molecules(3, [(\\"H\\", 1), (\\"H\\", 1), (\\"H\\", 1)]) -1 >>> organize_molecules(1, [(\\"H\\", 1)]) []","solution":"def organize_molecules(n, elements): Organize chemical elements into a molecule structure based on bonding rules. Arguments: n -- the number of elements elements -- a list of tuples where each tuple contains an element name and its bonding capacity Returns: A list of edges which connects all nodes (elements) in a single structure or -1 if it is not possible from collections import defaultdict if n == 1: return [] # A single element is trivially connected bonds_left = {i: capacity for i, (element, capacity) in enumerate(elements)} adjacency_list = defaultdict(list) edges = [] candidates = [0] # Start with the first element while candidates: u = candidates.pop() for v in range(n): if u != v and bonds_left[u] > 0 and bonds_left[v] > 0: if v not in adjacency_list[u]: adjacency_list[u].append(v) adjacency_list[v].append(u) bonds_left[u] -= 1 bonds_left[v] -= 1 edges.append((u, v)) if bonds_left[u] > 0: candidates.append(u) if bonds_left[v] > 0: candidates.append(v) # Check if all elements are fully linked for i in range(n): if not adjacency_list[i]: return -1 # Check for all nodes if they are fully utilized if any(bonds_left[i] > 0 for i in range(n)): return -1 return edges"},{"question":"def calculate_pages_per_day(total_pages, current_page, days_remaining): Calculate the number of pages Martha needs to read each day to finish her book by a certain date. Args: total_pages (int): The total number of pages in the book. current_page (int): The page Martha is currently on. days_remaining (int): The number of days remaining to finish the book. Returns: str: The number of pages she needs to read each day in the format of two decimal places, or \\"Not possible\\" if it is not achievable within the given days. >>> calculate_pages_per_day(300, 150, 10) \\"15.00\\" >>> calculate_pages_per_day(500, 100, 15) \\"26.67\\" >>> calculate_pages_per_day(1000, 500, 250) \\"2.00\\" >>> calculate_pages_per_day(1000, 500, 1) \\"Not possible\\" pass def process_test_cases(test_cases): Process multiple test cases to find out the number of pages Martha needs to read each day. Args: test_cases (list of tuples): List of test cases, where each test case is a tuple of (total_pages, current_page, days_remaining) Returns: list of str: Results for each test case, either the number of pages per day or \\"Not possible\\". >>> process_test_cases([(300, 150, 10), (500, 100, 15), (1000, 500, 250)]) [\\"15.00\\", \\"26.67\\", \\"2.00\\"] >>> process_test_cases([(1000, 500, 1)]) [\\"Not possible\\"] pass","solution":"def calculate_pages_per_day(total_pages, current_page, days_remaining): Calculate the number of pages Martha needs to read each day to finish her book by a certain date. Args: total_pages (int): The total number of pages in the book. current_page (int): The page Martha is currently on. days_remaining (int): The number of days remaining to finish the book. Returns: str: The number of pages she needs to read each day in the format of two decimal places, or \\"Not possible\\" if it is not achievable within the given days. remaining_pages = total_pages - current_page if remaining_pages > days_remaining * 100: # Assuming maximum pages per day constraints return \\"Not possible\\" pages_per_day = remaining_pages / days_remaining return f\\"{pages_per_day:.2f}\\" def process_test_cases(test_cases): results = [] for case in test_cases: total_pages, current_page, days_remaining = case result = calculate_pages_per_day(total_pages, current_page, days_remaining) results.append(result) return results"},{"question":"def is_palindrome(s: str) -> str: Determine if the string is a palindrome. >>> is_palindrome(\\"racecar\\") \\"YES\\" >>> is_palindrome(\\"hello\\") \\"NO\\" >>> is_palindrome(\\"abba\\") \\"YES\\"","solution":"def is_palindrome(s): Checks if the given string s is a palindrome. :param s: Input string consisting of lowercase English letters :return: \\"YES\\" if s is a palindrome, \\"NO\\" otherwise if s == s[::-1]: return \\"YES\\" else: return \\"NO\\""},{"question":"def is_valid_password(password: str) -> str: Checks if the password is valid according to the policy. has_upper = any(c.isupper() for c in password) has_lower = any(c.islower() for c in password) has_digit = any(c.isdigit() for c in password) has_special = any(c in \\"!@#%^&*()-+\\" for c in password) return \\"YES\\" if has_upper and has_lower and has_digit and has_special else \\"NO\\" def check_passwords(test_cases: List[str]) -> List[str]: For a list of passwords, determine if they adhere to the new password policy. >>> check_passwords([\\"Password123!\\"]) [\\"YES\\"] >>> check_passwords([\\"helloWorld!\\"]) [\\"NO\\"] >>> check_passwords([\\"abcd1234\\"]) [\\"NO\\"] >>> check_passwords([\\"Aa1!\\"]) [\\"YES\\"] >>> check_passwords([\\"Aa1#\\", \\"bb2\\", \\"Cc3%\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> check_passwords([\\"123456\\", \\"abcdef\\", \\"PASSWORD\\"]) [\\"NO\\", \\"NO\\", \\"NO\\"]","solution":"def is_valid_password(password): Checks if the password is valid according to the policy. has_upper = any(c.isupper() for c in password) has_lower = any(c.islower() for c in password) has_digit = any(c.isdigit() for c in password) has_special = any(c in \\"!@#%^&*()-+\\" for c in password) if has_upper and has_lower and has_digit and has_special: return \\"YES\\" else: return \\"NO\\" def check_passwords(test_cases): For a list of passwords, determine if they adhere to the new password policy. results = [] for password in test_cases: results.append(is_valid_password(password)) return results"},{"question":"def process_queries(n: int, m: int, grid: List[List[int]], queries: List[str]): Process the grid queries and print the result for type \\"2 x y\\" queries. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[List[int]]): Initial energy values of the grid. queries (List[str]): List of queries to process. >>> n = 3 >>> m = 3 >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> queries = [ ... \\"1 1 1 2\\", ... \\"1 2 2 3\\", ... \\"1 3 3 4\\", ... \\"2 2 2\\", ... \\"1 1 1 1\\" ... ] >>> process_queries(n, m, grid, queries) 11","solution":"def process_queries(n, m, grid, queries): updates = [[0] * m for _ in range(n)] for query in queries: parts = query.split() if parts[0] == '1': x, y, val = int(parts[1]) - 1, int(parts[2]) - 1, int(parts[3]) grid[x][y] += val updates[x][y] += 1 if updates[x][y] == 1: for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m: grid[nx][ny] += val elif parts[0] == '2': x, y = int(parts[1]) - 1, int(parts[2]) - 1 print(grid[x][y]) # Example Usage if __name__ == \\"__main__\\": n, m = 3, 3 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [ \\"1 1 1 2\\", \\"1 2 2 3\\", \\"1 3 3 4\\", \\"2 2 2\\", \\"1 1 1 1\\" ] process_queries(n, m, grid, queries)"},{"question":"def longest_diverse_substring(k: int, s: str) -> int: Returns the length of the longest diverse substring containing no more than k distinct characters. >>> longest_diverse_substring(2, \\"abcba\\") 3 >>> longest_diverse_substring(1, \\"aaaaa\\") 5 >>> longest_diverse_substring(3, \\"abcabcbb\\") 8 def process_test_cases(t: int, test_cases: List[Tuple[int, str]]) -> List[int]: Processes multiple test cases and returns their results. >>> process_test_cases(3, [(2, \\"abcba\\"), (1, \\"aaaaa\\"), (3, \\"abcabcbb\\")]) [3, 5, 8]","solution":"from collections import defaultdict def longest_diverse_substring(k, s): Returns the length of the longest diverse substring containing no more than k distinct characters. max_len = 0 current_count = defaultdict(int) distinct_count = 0 left = 0 for right in range(len(s)): current_count[s[right]] += 1 if current_count[s[right]] == 1: distinct_count += 1 while distinct_count > k: current_count[s[left]] -= 1 if current_count[s[left]] == 0: distinct_count -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len def process_test_cases(t, test_cases): Processes multiple test cases and returns their results. results = [] for i in range(t): k = test_cases[i][0] s = test_cases[i][1] results.append(longest_diverse_substring(k, s)) return results"},{"question":"def reverse_words(sentence: str) -> str: Reverses the words in a given sentence, trims leading or trailing spaces, and reduces multiple spaces between words to a single space. >>> reverse_words(\\"hello world!\\") \\"world! hello\\" >>> reverse_words(\\" the sky is blue \\") \\"blue is sky the\\"","solution":"def reverse_words(sentence): Reverses the words in a given sentence, trims leading or trailing spaces, and reduces multiple spaces between words to a single space. # Split the sentence by whitespace to extract the words words = sentence.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list of words with a single space and return the result return ' '.join(reversed_words)"},{"question":"def most_frequent_char(s: str, queries: List[Tuple[int, int]]) -> List[str]: Returns the most frequent character for each query within the string s. If there is a tie in frequency, returns the lexicographically smallest one. :param s: Initial string containing lowercase Latin letters and digits :param queries: List of tuples, where each tuple contains two integers (l, r) :return: List of most frequent characters for each query >>> most_frequent_char(\\"abracadabra\\", [(1, 3), (4, 7), (6, 10)]) ['a', 'a', 'a'] >>> most_frequent_char(\\"aabbcc\\", [(1, 6)]) ['a'] >>> most_frequent_char(\\"a\\", [(1, 1)]) ['a'] >>> most_frequent_char(\\"mississippi\\", [(1, 11)]) ['i'] >>> most_frequent_char(\\"abcdefg\\", [(1, 7)]) ['a'] >>> most_frequent_char(\\"aaaaaaa\\", [(1, 7), (2, 5), (3, 3)]) ['a', 'a', 'a']","solution":"def most_frequent_char(s, queries): Returns the most frequent character for each query within the string s. If there is a tie in frequency, returns the lexicographically smallest one. :param s: Initial string containing lowercase Latin letters and digits :param queries: List of tuples, where each tuple contains two integers (l, r) :return: List of most frequent characters for each query results = [] for l, r in queries: substring = s[l-1:r] freq = {} for char in substring: freq[char] = freq.get(char, 0) + 1 max_freq = max(freq.values()) most_frequent_chars = [char for char, count in freq.items() if count == max_freq] results.append(min(most_frequent_chars)) return results"},{"question":"def find_two_sum_indices(arr, target): Given an array of integers and a target value, determine if there are any two distinct elements in the array whose sum is equal to the target value. Parameters: arr (list of int): The array of integers. target (int): The target sum value. Returns: tuple: A tuple (i, j) of the indices of the two numbers that sum up to the target, or -1 if no such pair exists. Examples: >>> find_two_sum_indices([1, 2, 3, 4, 5], 6) in [(1, 3), (3, 1)] True >>> find_two_sum_indices([2, 7, 11, 15], 9) (0, 1) >>> find_two_sum_indices([-1, -2, -3], -5) (1, 2) >>> find_two_sum_indices([1, 2, 3], 7) -1 >>> find_two_sum_indices([], 5) -1 >>> find_two_sum_indices([5], 5) -1 >>> find_two_sum_indices([1, 1, 1, 1], 3) -1 >>> find_two_sum_indices([1, 2, 3, 4, 5], 5) in [(0, 3), (3, 0), (1, 2), (2, 1)] True","solution":"def find_two_sum_indices(arr, target): Given an array of integers and a target value, determine if there are any two distinct elements in the array whose sum is equal to the target value. Parameters: arr (list of int): The array of integers. target (int): The target sum value. Returns: tuple: A tuple (i, j) of the indices of the two numbers that sum up to the target, or -1 if no such pair exists. num_to_index = {} for i, num in enumerate(arr): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i return -1"},{"question":"from typing import List def shortest_path(R: int, C: int, grid: List[str]) -> int: Determine the length of the shortest path from the top-left cell (1, 1) to the bottom-right cell (R, C) in a given 2D grid. Args: R (int): Number of rows in the grid. C (int): Number of columns in the grid. grid (List[str]): List of strings where each string represents a row of the grid. Returns: int: The length of the shortest path, or -1 if no such path exists. Examples: >>> shortest_path(4, 4, [\\"....\\", \\"..#.\\", \\"..#.\\", \\"#...\\"]) 7 >>> shortest_path(3, 3, [\\".#.\\", \\"#\\", \\".#.\\"]) -1 >>> shortest_path(5, 5, [\\".....\\", \\".#.#.\\", \\".....\\", \\".#.#.\\", \\".....\\"]) 9 pass","solution":"from collections import deque def shortest_path(R, C, grid): if grid[0][0] == '#' or grid[R-1][C-1] == '#': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = [[False] * C for _ in range(R)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited[0][0] = True while queue: r, c, dist = queue.popleft() if r == R - 1 and c == C - 1: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < R and 0 <= nc < C and not visited[nr][nc] and grid[nr][nc] == '.': visited[nr][nc] = True queue.append((nr, nc, dist + 1)) return -1"},{"question":"def min_steps_to_one(n): Returns the minimum number of steps required to reduce the number n to 1. def min_steps_for_list(nums): For each integer in the list, returns the minimum number of steps required to reduce the number to 1.","solution":"def min_steps_to_one(n): Returns the minimum number of steps required to reduce the number n to 1. memo = {1: 0} # Base case: 1 takes 0 steps to become 1 def helper(x): if x in memo: return memo[x] if x % 2 == 0: memo[x] = 1 + helper(x // 2) else: memo[x] = 1 + min(helper(x - 1), helper(x + 1)) return memo[x] return helper(n) def min_steps_for_list(nums): For each integer in the list, returns the minimum number of steps required to reduce the number to 1. return [min_steps_to_one(num) for num in nums]"},{"question":"def can_establish_supply_chain(p: int, r: int, routes: List[Tuple[int, int]]) -> str: Determine if it is possible to establish a supply chain network where all planets are reachable from every other planet. >>> can_establish_supply_chain(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) \\"YES\\" >>> can_establish_supply_chain(4, 4, [(1, 2), (2, 3), (3, 4), (4, 2)]) \\"NO\\" >>> can_establish_supply_chain(3, 2, [(1, 2), (2, 3)]) \\"NO\\" >>> can_establish_supply_chain(2, 1, [(1, 2)]) \\"NO\\" >>> can_establish_supply_chain(6, 8, [(1, 2), (2, 3), (3, 1), (1, 4), (4, 5), (5, 6), (6, 4), (6, 1)]) \\"YES\\" >>> can_establish_supply_chain(10, 12, [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9), (9, 10), (10, 1), (5, 10)]) \\"YES\\"","solution":"def can_establish_supply_chain(p, r, routes): from collections import defaultdict, deque def bfs(start, graph): visited = [False] * (p + 1) queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return visited graph = defaultdict(list) reverse_graph = defaultdict(list) for a, b in routes: graph[a].append(b) reverse_graph[b].append(a) visited_from_first = bfs(1, graph) visited_to_first = bfs(1, reverse_graph) if all(visited_from_first[1:]) and all(visited_to_first[1:]): return \\"YES\\" else: return \\"NO\\""},{"question":"def daily_temperatures(n: int, temperatures: List[int]) -> List[int]: Compute the number of days you would have to wait until a warmer temperature for each day. >>> daily_temperatures(8, [73, 74, 75, 71, 69, 72, 76, 73]) == [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures(6, [30, 40, 50, 60, 50, 40]) == [1, 1, 1, 0, 0, 0] >>> daily_temperatures(1, [50]) == [0] >>> daily_temperatures(4, [100, 90, 80, 70]) == [0, 0, 0, 0] >>> daily_temperatures(4, [10, 20, 30, 40]) == [1, 1, 1, 0] >>> daily_temperatures(5, [64, 55, 68, 72, 66]) == [2, 1, 1, 0, 0]","solution":"def daily_temperatures(n, temperatures): result = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: index = stack.pop() result[index] = i - index stack.append(i) return result"},{"question":"from typing import List, Tuple def find_min_connection_to_remove(n: int, m: int, connections: List[Tuple[int, int, int]]) -> int: Find the minimum weight connection that, if removed, would increase the number of disconnected sub-networks. Args: n (int): The number of servers. m (int): The number of connections. connections (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers u, v, and w representing a connection between servers u and v with weight w. Returns: int: The weight of the minimum connection that should be removed to increase the number of disconnected sub-networks. If no such connection exists, return -1. >>> find_min_connection_to_remove(4, 4, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4)]) 1 >>> find_min_connection_to_remove(3, 2, [(1, 2, 10), (2, 3, 5)]) 5 from solution import find_min_connection_to_remove def test_case_1(): n = 4 m = 4 connections = [ (1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4) ] assert find_min_connection_to_remove(n, m, connections) == 1 def test_case_2(): n = 3 m = 2 connections = [ (1, 2, 10), (2, 3, 5) ] assert find_min_connection_to_remove(n, m, connections) == 5 def test_case_3(): n = 5 m = 6 connections = [ (1, 2, 2), (1, 3, 3), (3, 4, 4), (4, 5, 5), (2, 4, 6), (2, 5, 20) ] assert find_min_connection_to_remove(n, m, connections) == 2 def test_case_no_possible_mst(): n = 4 m = 1 connections = [ (1, 2, 1) ] assert find_min_connection_to_remove(n, m, connections) == -1 def test_case_already_disconnected(): n = 4 m = 2 connections = [ (1, 2, 1), (3, 4, 2) ] assert find_min_connection_to_remove(n, m, connections) == -1","solution":"def find_min_connection_to_remove(n, m, connections): from heapq import heappush, heappop # disjoint set / union-find helper functions def find(parent, x): if parent[x] != x: parent[x] = find(parent, parent[x]) return parent[x] def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 # Kruskal's algorithm to find MST and store edges in the MST parent = [i for i in range(n + 1)] rank = [0] * (n + 1) mst_edges = [] # Min-heap of connections to process in Kruskal's algorithm min_heap = [] for edge in connections: u, v, w = edge heappush(min_heap, (w, u, v)) while min_heap: w, u, v = heappop(min_heap) if find(parent, u) != find(parent, v): union(parent, rank, u, v) mst_edges.append((u, v, w)) if len(mst_edges) == n - 1: # MST is found when it has n-1 edges break if len(mst_edges) < n - 1: return -1 # not possible to have a MST # Minimum weight connection to remove min_weight = float('inf') for u, v, w in mst_edges: parent = [i for i in range(n + 1)] rank = [0] * (n + 1) for uu, vv, ww in mst_edges: if (uu, vv) == (u, v) or (uu, vv) == (v, u): continue union(parent, rank, uu, vv) # count number of sets num_sets = len(set(find(parent, i) for i in range(1, n + 1))) if num_sets > 1: # which means removal caused disconnection min_weight = min(min_weight, w) return min_weight if min_weight != float('inf') else -1"},{"question":"from typing import List def can_rearrange_books(n: int, heights: List[int]) -> str: Determine whether it is possible to rearrange the books such that no two adjacent books have the same height. >>> can_rearrange_books(5, [1, 1, 2, 3, 4]) \\"Yes\\" >>> can_rearrange_books(4, [4, 4, 4, 4]) \\"No\\"","solution":"def can_rearrange_books(n, heights): from collections import Counter # Get the frequency of each height height_freq = Counter(heights) # Find the maximum frequency of any single height max_freq = max(height_freq.values()) # Check if the maximum frequency is greater than half the number of books if max_freq <= (n + 1) // 2: return \\"Yes\\" else: return \\"No\\""},{"question":"def revenue_statistics(n: int, revenues: List[int]) -> Tuple[int, int, int]: Returns the highest revenue day, the lowest revenue day, and the average revenue over the entire period. >>> revenue_statistics(5, [200, 500, 300, 800, 100]) (800, 100, 380) >>> revenue_statistics(4, [300, 300, 300, 300]) (300, 300, 300) pass","solution":"def revenue_statistics(n, revenues): Returns the highest revenue day, the lowest revenue day, and the average revenue over the entire period. highest_revenue = max(revenues) lowest_revenue = min(revenues) average_revenue = sum(revenues) // n return highest_revenue, lowest_revenue, average_revenue"},{"question":"from typing import List, Tuple def can_form_peak_sequence(n: int, heights: List[int]) -> str: Determine if it is possible to rearrange the students' heights to form a peak sequence. >>> can_form_peak_sequence(5, [1, 2, 3, 4, 5]) \\"YES\\" >>> can_form_peak_sequence(7, [5, 3, 8, 6, 2, 4, 7]) \\"YES\\" >>> can_form_peak_sequence(6, [1, 5, 3, 5, 3, 1]) \\"NO\\" def process_test_cases(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Process multiple test cases to determine if peak sequences can be formed. >>> process_test_cases(3, [ ... (5, [1, 2, 3, 4, 5]), ... (7, [5, 3, 8, 6, 2, 4, 7]), ... (6, [1, 5, 3, 5, 3, 1]) ... ]) [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def can_form_peak_sequence(n, heights): heights.sort() # If the max height appears at either end in sorted order if heights[-1] == heights[-2] or heights[0] == heights[1]: return \\"NO\\" return \\"YES\\" def process_test_cases(t, test_cases): results = [] for n, heights in test_cases: results.append(can_form_peak_sequence(n, heights)) return results"},{"question":"def max_cookies(n, required, available): Calculates the maximum number of cookies that can be baked. Parameters: n (int): Number of different ingredients. required (list of int): Quantities of each ingredient required to bake one cookie. available (list of int): Quantities of each ingredient available. Returns: int: Maximum number of cookies that can be baked. >>> max_cookies(3, [4, 2, 5], [20, 8, 25]) 4 >>> max_cookies(2, [1, 1], [1000000, 1000000]) 1000000 >>> max_cookies(2, [5, 10], [4, 100]) 0 >>> max_cookies(3, [1, 1, 1], [0, 0, 0]) 0 >>> max_cookies(2, [999, 1000], [999000, 500000]) 500 >>> max_cookies(1, [10], [100]) 10 >>> max_cookies(3, [3, 3, 3], [9, 9, 9]) 3","solution":"def max_cookies(n, required, available): Calculates the maximum number of cookies that can be baked. Parameters: n (int): Number of different ingredients. required (list of int): Quantities of each ingredient required to bake one cookie. available (list of int): Quantities of each ingredient available. Returns: int: Maximum number of cookies that can be baked. min_cookies = float('inf') for req, avail in zip(required, available): max_cookies = avail // req min_cookies = min(min_cookies, max_cookies) return min_cookies"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if any permutation of the string s can be rearranged to form a palindrome. Args: s (str): The input string. Returns: bool: True if any permutation of s can be rearranged to form a palindrome, False otherwise. Examples: >>> can_form_palindrome(\\"aabb\\") True >>> can_form_palindrome(\\"abc\\") False >>> can_form_palindrome(\\"a\\") True >>> can_form_palindrome(\\"ab\\") False >>> can_form_palindrome(\\"aabba\\") True >>> can_form_palindrome(\\"racecar\\") True >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True","solution":"def can_form_palindrome(s): Determines if any permutation of the string s can be rearranged to form a palindrome. Args: s (str): The input string. Returns: bool: True if any permutation of s can be rearranged to form a palindrome, False otherwise. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # For the string to be able to form a palindrome: # if the length is even, no characters can have an odd frequency # if the length is odd, only one character can have an odd frequency return odd_count <= 1"},{"question":"def check_list_order(n: int, elements: List[int]) -> str: Determines if the list is sorted in strictly ascending, strictly descending or neither. Args: n (int): Number of elements in the list. elements (list of int): List of integers to check. Returns: str: \\"ASCENDING\\", \\"DESCENDING\\", or \\"NEITHER\\". Examples: >>> check_list_order(5, [1, 2, 3, 4, 5]) 'ASCENDING' >>> check_list_order(4, [10, 8, 6, 6]) 'NEITHER' >>> check_list_order(3, [20, 15, 10]) 'DESCENDING'","solution":"def check_list_order(n, elements): Determines if the list is sorted in strictly ascending, strictly descending or neither. Args: n (int): Number of elements in the list. elements (list of int): List of integers to check. Returns: str: \\"ASCENDING\\", \\"DESCENDING\\", or \\"NEITHER\\". ascending = all(elements[i] > elements[i-1] for i in range(1, n)) descending = all(elements[i] < elements[i-1] for i in range(1, n)) if ascending: return \\"ASCENDING\\" elif descending: return \\"DESCENDING\\" else: return \\"NEITHER\\""},{"question":"def sliding_window_maximum(k, stream): Processes the stream to continuously find the maximum integer in the current window of size k. Args: k (int): Size of the sliding window. stream (List[int]): A list of integers representing the stream. Returns: List[int]: A list containing the maximum values of each sliding window. Examples: >>> sliding_window_maximum(3, [1, 3, -1, -3, 5, 3, 6, 7]) [3, 3, 5, 5, 6, 7] >>> sliding_window_maximum(2, [8, 7, 6, 5, 4, 3, 2, 1]) [8, 7, 6, 5, 4, 3, 2] from collections import deque def test_sliding_window_maximum(): stream1 = [1, 3, -1, -3, 5, 3, 6, 7] k1 = 3 result1 = sliding_window_maximum(k1, stream1) assert result1 == [3, 3, 5, 5, 6, 7] stream2 = [8, 7, 6, 5, 4, 3, 2, 1] k2 = 2 result2 = sliding_window_maximum(k2, stream2) assert result2 == [8, 7, 6, 5, 4, 3, 2] stream3 = [9] k3 = 1 result3 = sliding_window_maximum(k3, stream3) assert result3 == [9] stream4 = [4, 3, 5, 4, 3, 1, 1, 2, 7] k4 = 4 result4 = sliding_window_maximum(k4, stream4) assert result4 == [5, 5, 5, 4, 3, 7] stream5 = [7, 2, 4] k5 = 2 result5 = sliding_window_maximum(k5, stream5) assert result5 == [7, 4]","solution":"from collections import deque import sys def sliding_window_maximum(k, stream): Processes the stream to continuously find the maximum integer in the current window of size k. q = deque() # Will store indices of potential max elements result = [] # Store the results for testing purposes for i, num in enumerate(stream): # Remove the elements indices from deque which are out of bound for the window if q and q[0] == i - k: q.popleft() # Remove elements from deque which are less than current element while q and stream[q[-1]] < num: q.pop() q.append(i) # Record the maximum values from current window if i >= k - 1: result.append(stream[q[0]]) print(stream[q[0]]) # Print max in the sliding window return result"},{"question":"def min_trucks_needed(c: int, packages: List[int]) -> int: Calculate the minimum number of trucks required to carry all given packages, such that no truck carries more than its capacity. :param c: int - maximum capacity of each truck :param packages: List[int] - list of weights of packages :return: int - minimum number of trucks required >>> min_trucks_needed(10, [5]) == 1 >>> min_trucks_needed(10, [10, 10, 10]) == 3 >>> min_trucks_needed(10, [2, 3, 8, 4, 6]) == 3 >>> min_trucks_needed(10, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == 1 >>> min_trucks_needed(15, [15]*1000) == 1000 >>> min_trucks_needed(12, [1, 8, 9, 4, 7, 3, 2]) == 3 >>> packages = [9, 8, 6, 3, 2, 2, 1] >>> min_trucks_needed(10, packages) == 4","solution":"def min_trucks_needed(c, packages): Function to calculate the minimum number of trucks required to carry all given packages, such that no truck carries more than its capacity. :param c: int - maximum capacity of each truck :param packages: List[int] - list of weights of packages :return: int - minimum number of trucks required # Sort packages in descending order to try and fit the heaviest items first packages.sort(reverse=True) # List to store the remaining capacity of each truck trucks = [] for weight in packages: # Try to fit the package into an existing truck with enough remaining capacity placed = False for i in range(len(trucks)): if trucks[i] >= weight: trucks[i] -= weight placed = True break # If the package couldn't be placed in any existing truck, add a new truck if not placed: trucks.append(c - weight) # The number of trucks used is the length of the trucks list return len(trucks)"},{"question":"def can_first_player_win(N: int) -> str: Determines if the starting player can guarantee a win with optimal play given N stones. Returns \\"Yes\\" if they can guarantee a win, otherwise \\"No\\". >>> can_first_player_win(4) 'No' >>> can_first_player_win(7) 'Yes' >>> can_first_player_win(5) 'Yes'","solution":"def can_first_player_win(N): Determines if the starting player can guarantee a win with optimal play given N stones. Returns \\"Yes\\" if they can guarantee a win, otherwise \\"No\\". # If N modulo 4 is not 0, the first player can win with optimal moves. return \\"Yes\\" if N % 4 != 0 else \\"No\\""},{"question":"from typing import List, Tuple def process_tasks(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Processes tasks based on priority levels and returns the order of tasks processed. Parameters: t (int): Number of test cases. test_cases (list): List of test cases, each containing a tuple (n, priorities) where n is the number of tasks and priorities is a list of priority levels. Returns: list: List of strings, each string representing the order of tasks processed for each test case.","solution":"def process_tasks(t, test_cases): Processes tasks based on priority levels and returns the order of tasks processed. Parameters: t (int): Number of test cases. test_cases (list): List of test cases, each containing a tuple (n, priorities) where n is the number of tasks and priorities is a list of priority levels. Returns: list: List of strings, each string representing the order of tasks processed for each test case. results = [] for i in range(t): n, priorities = test_cases[i] indexed_priorities = list(enumerate(priorities, 1)) indexed_priorities.sort(key=lambda x: (x[1], x[0])) order = [idx for idx, _ in indexed_priorities] results.append(' '.join(map(str, order))) return results"},{"question":"def longest_non_decreasing_subsequence(sequence: List[int]) -> int: Returns the length of the longest non-decreasing subsequence in the given sequence. >>> longest_non_decreasing_subsequence([9, 8, 7, 6, 3, 0]) 1 >>> longest_non_decreasing_subsequence([1, 3, 2, 4, 5]) 4 from typing import List def test_all_decreasing_sequence(): assert longest_non_decreasing_subsequence([9, 8, 7, 6, 3, 0]) == 1 def test_longest_subsequence_case(): assert longest_non_decreasing_subsequence([1, 3, 2, 4, 5]) == 4 def test_single_element_sequence(): assert longest_non_decreasing_subsequence([5]) == 1 def test_all_increasing_sequence(): assert longest_non_decreasing_subsequence([1, 2, 3, 4, 5]) == 5 def test_mixed_sequence(): assert longest_non_decreasing_subsequence([5, 1, 5, 2, 6, 3, 7]) == 4 def test_duplicates(): assert longest_non_decreasing_subsequence([1, 2, 2, 2, 3, 3]) == 6 def test_empty_sequence(): assert longest_non_decreasing_subsequence([]) == 0","solution":"def longest_non_decreasing_subsequence(sequence): Returns the length of the longest non-decreasing subsequence in the given sequence. n = len(sequence) if n == 0: return 0 # Initialize the dp array where each dp[i] will store the length of the longest # non-decreasing subsequence ending at index i dp = [1] * n for i in range(1, n): for j in range(i): if sequence[i] >= sequence[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def can_follow_instructions(n: int, m: int, grid: List[str], instructions: str) -> str: Determine if the robot can successfully follow the given instructions without moving out of the grid or hitting a blocked cell. >>> can_follow_instructions(4, 4, [\\"....\\", \\".#..\\", \\"....\\", \\"....\\"], \\"RRDD\\") \\"YES\\" >>> can_follow_instructions(3, 3, [\\"...\\", \\".#.\\", \\"#..\\"], \\"DDRRU\\") \\"NO\\" def solve(t: int, test_cases: List[Dict]) -> List[str]: Process multiple test cases to determine if the robot can follow the instructions for each grid. >>> solve(2, [ {'grid_size': (4, 4), 'grid': [\\"....\\", \\".#..\\", \\"....\\", \\"....\\"], 'instructions': \\"RRDD\\"}, {'grid_size': (3, 3), 'grid': [\\"...\\", \\".#.\\", \\"#..\\"], 'instructions': \\"DDRRU\\"} ]) [\\"YES\\", \\"NO\\"] from solution import can_follow_instructions, solve def test_example_1(): n = 4 m = 4 grid = [ \\"....\\", \\".#..\\", \\"....\\", \\"....\\" ] instructions = \\"RRDD\\" assert can_follow_instructions(n, m, grid, instructions) == \\"YES\\" def test_example_2(): n = 3 m = 3 grid = [ \\"...\\", \\".#.\\", \\"#..\\" ] instructions = \\"DDRRU\\" assert can_follow_instructions(n, m, grid, instructions) == \\"NO\\" def test_case_with_obstacle(): n = 5 m = 5 grid = [ \\".....\\", \\".....\\", \\"..#..\\", \\".....\\", \\".....\\" ] instructions = \\"DDRR\\" assert can_follow_instructions(n, m, grid, instructions) == \\"NO\\" def test_case_out_of_bounds(): n = 2 m = 2 grid = [ \\"..\\", \\"..\\" ] instructions = \\"RRDD\\" assert can_follow_instructions(n, m, grid, instructions) == \\"NO\\" def test_case_no_obstacle(): n = 3 m = 3 grid = [ \\"...\\", \\"...\\", \\"...\\" ] instructions = \\"RRDDLU\\" assert can_follow_instructions(n, m, grid, instructions) == \\"YES\\" def test_large_grid(): n = 100 m = 100 grid = [\\".\\" * 100 for _ in range(100)] instructions = \\"R\\" * 99 + \\"D\\" * 99 assert can_follow_instructions(n, m, grid, instructions) == \\"YES\\" def test_solve_function(): t = 2 test_cases = [ { 'grid_size': (4, 4), 'grid': [ \\"....\\", \\".#..\\", \\"....\\", \\"....\\", ], 'instructions': \\"RRDD\\" }, { 'grid_size': (3, 3), 'grid': [ \\"...\\", \\".#.\\", \\"#..\\", ], 'instructions': \\"DDRRU\\" } ] assert solve(t, test_cases) == [\\"YES\\", \\"NO\\"]","solution":"def can_follow_instructions(n, m, grid, instructions): # Start at the top-left corner (0, 0) in zero-based indexing x, y = 0, 0 for move in instructions: if move == 'R': y += 1 elif move == 'L': y -= 1 elif move == 'U': x -= 1 elif move == 'D': x += 1 # Check if new position is out of bounds if x < 0 or x >= n or y < 0 or y >= m: return \\"NO\\" # Check if new position is a blocked cell if grid[x][y] == '#': return \\"NO\\" return \\"YES\\" def solve(t, test_cases): results = [] for i in range(t): n, m = test_cases[i]['grid_size'] grid = test_cases[i]['grid'] instructions = test_cases[i]['instructions'] result = can_follow_instructions(n, m, grid, instructions) results.append(result) return results"},{"question":"def light_show(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> str: Find an order of switches such that the accumulated brightness at any step never exceeds x, or determine that it is not possible to achieve this. >>> light_show(3, [(4, 10, [1, 2, 3, 4]), (3, 6, [3, 2, 1]), (5, 7, [1, 4, 2, 5, 3])]) \\"POSSIBLEn1 2 3 4nPOSSIBLEn1 2 3nIMPOSSIBLE\\" >>> light_show(1, [(4, 10, [4, 3, 2, 1])]) \\"POSSIBLEn1 2 3 4\\" >>> light_show(1, [(3, 5, [5, 2, 1])]) \\"IMPOSSIBLE\\" >>> light_show(2, [(4, 5, [3, 2, 1, 4]), (3, 10, [4, 5, 1])]) \\"IMPOSSIBLEnPOSSIBLEn1 4 5\\"","solution":"def light_show(t, test_cases): result = [] for test in test_cases: n, x, b = test b_sorted = sorted(b) current_sum = 0 possible = True for brightness in b_sorted: if current_sum + brightness > x: possible = False break current_sum += brightness if possible: result.append(\\"POSSIBLE\\") result.append(\\" \\".join(map(str, b_sorted))) else: result.append(\\"IMPOSSIBLE\\") return \\"n\\".join(result)"},{"question":"def minimum_cost_to_connect_cities(n, m, roads): Determine the minimum cost to connect all cities using the minimum spanning tree (MST) concept. Args: n (int): Number of cities. m (int): Number of existing roads. roads (List[Tuple[int, int, int]]): Each tuple contains three integers u, v, and w, where u and v are the cities the road connects, and w is the cost of that road. Returns: int or str: The minimum cost to connect all n cities, or \\"IMPOSSIBLE\\" if it's not possible. Example: >>> minimum_cost_to_connect_cities(4, 5, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (1, 4, 9), (1, 3, 7)]) 12","solution":"def minimum_cost_to_connect_cities(n, m, roads): def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 # Sort all the edges in non-decreasing order of their weight roads.sort(key=lambda x: x[2]) parent = [] rank = [] # Create V disjoint sets (one for each vertex) for node in range(n): parent.append(node) rank.append(0) mst_cost = 0 edges_used = 0 for u, v, w in roads: root_u = find(parent, u-1) root_v = find(parent, v-1) # If including this edge doesn't cause a cycle if root_u != root_v: mst_cost += w union(parent, rank, root_u, root_v) edges_used += 1 # If we have included n-1 edges then we have formed MST if edges_used == n - 1: return mst_cost # If n-1 edges are not used, it means some vertices are disconnected return \\"IMPOSSIBLE\\""},{"question":"from typing import List, Tuple def min_mutations(start: str, target: str, mutations: List[str]) -> int: Determine the minimum number of mutations needed to change a start gene sequence into a target gene sequence. >>> min_mutations('AACCGGTT', 'AACCGGTA', ['AACCGGTA', 'AACCGCTA']) 1 >>> min_mutations('AACCGGTT', 'AAACGGTA', ['AACCGGTA', 'AACCGCTA']) -1 pass def process_test_cases(test_cases: List[Tuple[str, str, List[str]]]) -> List[int]: Process multiple test cases to determine the number of mutations needed. >>> process_test_cases([ ... ('AACCGGTT', 'AACCGGTA', ['AACCGGTA', 'AACCGCTA']), ... ('AACCGGTT', 'AAACGGTA', ['AACCGGTA', 'AACCGCTA', 'AAACGGTA']) ... ]) [1, 2] pass","solution":"from collections import deque def min_mutations(start, target, mutations): if start == target: return 0 mutations = set(mutations) queue = deque([(start, 0)]) visited = set() visited.add(start) while queue: current, steps = queue.popleft() if current == target: return steps for i in range(len(current)): for char in 'ACGT': if current[i] != char: new_seq = current[:i] + char + current[i+1:] if new_seq in mutations and new_seq not in visited: queue.append((new_seq, steps + 1)) visited.add(new_seq) return -1 def process_test_cases(test_cases): results = [] for case in test_cases: start, target, mutations = case result = min_mutations(start, target, mutations) results.append(result) return results"},{"question":"def has_consecutive_ones(n: int) -> str: Returns \\"YES\\" if the binary representation of n contains consecutive 1s, otherwise returns \\"NO\\". Examples: >>> has_consecutive_ones(5) \\"NO\\" >>> has_consecutive_ones(7) \\"YES\\" >>> has_consecutive_ones(12) \\"YES\\" >>> has_consecutive_ones(8) \\"NO\\"","solution":"def has_consecutive_ones(n): Returns \\"YES\\" if the binary representation of n contains consecutive 1s, otherwise returns \\"NO\\". binary_representation = bin(n)[2:] if '11' in binary_representation: return \\"YES\\" return \\"NO\\""},{"question":"def longestIncreasingPath(matrix: List[List[int]]) -> int: Find the length of the longest increasing path in a grid. >>> longestIncreasingPath([[9, 9, 4], [6, 6, 8], [2, 1, 1]]) 4 >>> longestIncreasingPath([[3, 4, 5, 2], [2, 2, 3, 4], [1, 1, 2, 5], [9, 4, 3, 8]]) 6 >>> longestIncreasingPath([[1]]) 1 >>> longestIncreasingPath([[7, 6, 5], [8, 7, 6], [9, 8, 7]]) 5 >>> longestIncreasingPath([[1, 2, 3], [6, 5, 4], [7, 8, 9]]) 9","solution":"def longestIncreasingPath(matrix): if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) dp = [[-1] * n for _ in range(m)] def dfs(x, y): if dp[x][y] != -1: return dp[x][y] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] max_path = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and matrix[nx][ny] > matrix[x][y]: max_path = max(max_path, 1 + dfs(nx, ny)) dp[x][y] = max_path return dp[x][y] longest_path = 0 for i in range(m): for j in range(n): longest_path = max(longest_path, dfs(i, j)) return longest_path"},{"question":"def find_unique_drone(drone_log): Returns the unique drone ID from the drone log. :param drone_log: List of integers where each integer is a drone ID. Each ID occurs exactly twice except one unique ID. :return: The unique drone ID. >>> find_unique_drone([2, 3, 1, 3, 2]) 1 >>> find_unique_drone([4, 1, 2, 4, 1, 2, 3]) 3 >>> find_unique_drone([10, 10, 11, 12, 12, 11, 9]) 9 >>> find_unique_drone([5, 5, 7, 8, 8, 7, 9]) 9 >>> find_unique_drone([4, -1, 2, 4, 2]) -1 >>> find_unique_drone([7, 5, -3, 7, 5]) -3","solution":"def find_unique_drone(drone_log): Returns the unique drone ID from the drone log. :param drone_log: List of integers where each integer is a drone ID. Each ID occurs exactly twice except one unique ID. :return: The unique drone ID. unique_id = 0 for drone_id in drone_log: unique_id ^= drone_id return unique_id"},{"question":"def process_operations(Q: int, operations: List[str]) -> List[int]: Processes a list of operations on an initially empty array and returns the results of operation type 2 which determine the maximum sum of any contiguous subarray. Parameters: Q (int): Number of operations. operations (list of str): List of operations in string format. Returns: list of int: Results of each type 2 operation. # Implementation here def max_contiguous_subarray_sum(A: List[int]) -> int: Helper function to find the maximum sum of any contiguous subarray in A. Parameters: A (list of int): The list of integers. Returns: int: The maximum sum of any contiguous subarray. # Implementation here # Test cases def test_max_contiguous_subarray_sum(): assert max_contiguous_subarray_sum([1, 2, -4]) == 3 assert max_contiguous_subarray_sum([1, 2, -4, 3, -1]) == 3 assert max_contiguous_subarray_sum([-1, -2, -3, -4]) == -1 assert max_contiguous_subarray_sum([4, -1, 2, 1]) == 6 assert max_contiguous_subarray_sum([5, 4, -1, 7, 8]) == 23 def test_process_operations(): Q = 7 operations = [\\"1 1\\", \\"1 2\\", \\"1 -4\\", \\"2\\", \\"1 3\\", \\"1 -1\\", \\"2\\"] assert process_operations(Q, operations) == [3, 3] Q = 5 operations = [\\"1 -1\\", \\"1 -2\\", \\"1 -3\\", \\"1 -4\\", \\"2\\"] assert process_operations(Q, operations) == [-1] Q = 8 operations = [\\"1 4\\", \\"1 -1\\", \\"1 2\\", \\"1 1\\", \\"2\\", \\"2\\", \\"1 -5\\", \\"2\\"] assert process_operations(Q, operations) == [6, 6, 6]","solution":"def process_operations(Q, operations): Processes a list of operations on an initially empty array and returns the results of operation type 2 which determine the maximum sum of any contiguous subarray. Parameters: Q (int): Number of operations. operations (list of str): List of operations in string format. Returns: list of int: Results of each type 2 operation. A = [] results = [] for operation in operations: parts = operation.split() if parts[0] == \\"1\\": A.append(int(parts[1])) elif parts[0] == \\"2\\": max_sum = max_contiguous_subarray_sum(A) results.append(max_sum) return results def max_contiguous_subarray_sum(A): Helper function to find the maximum sum of any contiguous subarray in A. Parameters: A (list of int): The list of integers. Returns: int: The maximum sum of any contiguous subarray. max_ending_here = max_so_far = A[0] for x in A[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"def max_cost_of_submatrix(n: int, matrix: List[List[int]]) -> int: Given a matrix of size n x n, where each cell contains a positive integer, find the maximum cost among all possible submatrices. The cost of a submatrix is defined as the sum of all elements in that submatrix multiplied by the number of cells in the submatrix. >>> max_cost_of_submatrix(3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 405 >>> max_cost_of_submatrix(2, [ ... [1, 1], ... [1, 1] ... ]) == 16 >>> max_cost_of_submatrix(1, [ ... [10] ... ]) == 10 >>> max_cost_of_submatrix(2, [ ... [1000, 1000], ... [1000, 1000] ... ]) == 16000 >>> max_cost_of_submatrix(2, [ ... [1, 2], ... [3, 4] ... ]) == 40","solution":"def max_cost_of_submatrix(n, matrix): def get_sum_matrix(matrix): sum_matrix = [[0]*n for _ in range(n)] sum_matrix[0][0] = matrix[0][0] # Prepare the sum matrix for i in range(1, n): sum_matrix[0][i] = sum_matrix[0][i-1] + matrix[0][i] sum_matrix[i][0] = sum_matrix[i-1][0] + matrix[i][0] for i in range(1, n): for j in range(1, n): sum_matrix[i][j] = (matrix[i][j] + sum_matrix[i-1][j] + sum_matrix[i][j-1] - sum_matrix[i-1][j-1]) return sum_matrix # Generate the sum matrix sum_matrix = get_sum_matrix(matrix) max_cost = 0 for i in range(n): for j in range(n): for x in range(i, n): for y in range(j, n): total = sum_matrix[x][y] if i > 0: total -= sum_matrix[i-1][y] if j > 0: total -= sum_matrix[x][j-1] if i > 0 and j > 0: total += sum_matrix[i-1][j-1] num_of_cells = (x - i + 1) * (y - j + 1) cost = total * num_of_cells max_cost = max(max_cost, cost) return max_cost"},{"question":"def maxDistinctElements(nums: List[int], k: int) -> int: Find the maximum number of distinct elements that can be selected from the array such that the sum of all selected elements is less than or equal to \`k\`. >>> maxDistinctElements([1, 2, 3, 4, 5], 10) 4 >>> maxDistinctElements([5, 5, 5, 5, 5], 5) 1 >>> maxDistinctElements([7, 3, 6, 8, 2], 15) 3","solution":"from typing import List def maxDistinctElements(nums: List[int], k: int) -> int: distinct_nums = sorted(set(nums)) sum_so_far = 0 count = 0 for num in distinct_nums: if sum_so_far + num <= k: sum_so_far += num count += 1 else: break return count"},{"question":"from typing import List, Tuple def max_fun(N: int, B: int, destinations: List[Tuple[int, int]]) -> int: Given a budget and details of each destination, determine the maximum total fun value that the group can achieve within the budget. >>> max_fun(3, 50, [(20, 50), (30, 70), (50, 80)]) == 120 >>> max_fun(4, 10, [(5, 10), (4, 40), (6, 30), (3, 50)]) == 90 pass def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) B = int(data[1]) destinations = [(int(data[i]), int(data[i + 1])) for i in range(2, len(data), 2)] print(max_fun(N, B, destinations)) if __name__ == '__main__': main()","solution":"def max_fun(N, B, destinations): dp = [0] * (B + 1) for cost, fun in destinations: for current_budget in range(B, cost - 1, -1): dp[current_budget] = max(dp[current_budget], dp[current_budget - cost] + fun) return dp[B] # Reading the input from the standard input def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) B = int(data[1]) destinations = [(int(data[i]), int(data[i + 1])) for i in range(2, len(data), 2)] print(max_fun(N, B, destinations)) if __name__ == '__main__': main()"},{"question":"def is_path_possible(n: int, board: List[str]) -> str: Determine if it is possible for the piece to move from the top-left corner (1, 1) to the bottom-right corner (n, n) in a chess-like board game. >>> is_path_possible(3, [\\".XX\\", \\"..X\\", \\"X..\\"]) \\"YES\\" >>> is_path_possible(4, [\\".XXX\\", \\"...X\\", \\"XX.X\\", \\"...X\\"]) \\"NO\\"","solution":"def is_path_possible(n, board): from collections import deque # Directions for right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Initialize the queue with the starting position (0, 0) queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() # If we reach the bottom-right corner if x == n-1 and y == n-1: return \\"YES\\" # Explore neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited and board[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny)) # If we exhaust the queue and do not find the bottom-right corner return \\"NO\\""},{"question":"def is_possible_to_cross(n: int, times: List[int]) -> str: Determine if all people can cross the bridge within 17 minutes. >>> is_possible_to_cross(4, [1, 2, 5, 10]) 'YES' >>> is_possible_to_cross(5, [1, 3, 6, 8, 12]) 'NO' from typing import List def test_possible_case(): times = [1, 2, 5, 10] n = len(times) assert is_possible_to_cross(n, times) == \\"YES\\" def test_impossible_case(): times = [1, 3, 6, 8, 12] n = len(times) assert is_possible_to_cross(n, times) == \\"NO\\" def test_all_fast(): times = [1, 2, 3, 4] n = len(times) assert is_possible_to_cross(n, times) == \\"YES\\" def test_edge_case_two_people(): times = [9, 8] n = len(times) assert is_possible_to_cross(n, times) == \\"YES\\" def test_edge_case_multiple_slow(): times = [5, 6, 7, 8] n = len(times) assert is_possible_to_cross(n, times) == \\"NO\\"","solution":"def is_possible_to_cross(n, times): if n == 2: return \\"YES\\" if max(times) <= 17 else \\"NO\\" # Sort the crossing times for easier processing times.sort() # Minimum time needed with optimal strategy time = 0 while n > 3: # Two slowest cross first and come back, then two fastest time += min(2 * times[1] + times[0] + times[n-1], 2 * times[0] + times[n-2] + times[n-1]) n -= 2 # Final group of 3 or less people if n == 3: time += times[2] + times[1] + times[0] elif n == 1: time += times[0] else: time += times[1] return \\"YES\\" if time <= 17 else \\"NO\\" # Test function times = [1, 3, 6, 8, 12] n = len(times) print(is_possible_to_cross(n, times)) # Output should be \\"NO\\""},{"question":"from typing import List def lengthOfLIS(nums: List[int]) -> int: Determine the length of the longest increasing subsequence in an array. >>> lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> lengthOfLIS([0, 8, 4, 12, 2, 10]) 3 def solve(test_cases: List[List[int]]) -> List[int]: Solves multiple test cases to find the length of the longest increasing subsequence for each case. >>> solve([[10, 9, 2, 5, 3, 7, 101, 18], [0, 8, 4, 12, 2, 10], [3, 10, 2, 1, 20], [1, 2, 3, 4, 5], [5, 4, 3, 2, 1]]) [4, 3, 3, 5, 1]","solution":"def lengthOfLIS(nums): Function to determine the length of the longest increasing subsequence (LIS). if not nums: return 0 dp = [1] * len(nums) for i in range(len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) def solve(test_cases): Solves multiple test cases to find the length of the longest increasing subsequence for each case. results = [] for nums in test_cases: results.append(lengthOfLIS(nums)) return results"},{"question":"def find_optimal_price(price_bookings): Finds the price that maximizes the product of price and bookings. If there are multiple maximums, returns the smallest price. Arguments: price_bookings -- list of tuples where each tuple contains (price, bookings) Returns: The optimal price as an integer. pass def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) price_bookings = [(int(data[i*2 + 1]), int(data[i*2 + 2])) for i in range(N)] result = find_optimal_price(price_bookings) print(result) from solution import find_optimal_price def test_find_optimal_price_case_1(): price_bookings = [ (100, 4), (200, 6), (300, 8), (400, 10), (500, 2) ] assert find_optimal_price(price_bookings) == 400 def test_find_optimal_price_case_2(): price_bookings = [ (50, 10), (100, 20), (200, 15), (250, 10) ] assert find_optimal_price(price_bookings) == 200 def test_find_optimal_price_case_3(): price_bookings = [ (1000, 3), (1500, 5), (2000, 2) ] assert find_optimal_price(price_bookings) == 1500 def test_find_optimal_price_case_4(): price_bookings = [ (10, 1000), (20, 1500), (30, 2000), (40, 2500), (50, 3000), (60, 3500) ] assert find_optimal_price(price_bookings) == 60 def test_find_optimal_price_multiple_max(): price_bookings = [ (300, 7), (400, 5), (350, 6) ] assert find_optimal_price(price_bookings) == 300 def test_find_optimal_price_single_entry(): price_bookings = [ (150, 10) ] assert find_optimal_price(price_bookings) == 150","solution":"def find_optimal_price(price_bookings): Finds the price that maximizes the product of price and bookings. If there are multiple maximums, returns the smallest price. Arguments: price_bookings -- list of tuples where each tuple contains (price, bookings) Returns: The optimal price as an integer. max_profit = 0 optimal_price = float('inf') for price, bookings in price_bookings: profit = price * bookings if profit > max_profit or (profit == max_profit and price < optimal_price): max_profit = profit optimal_price = price return optimal_price def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) price_bookings = [(int(data[i*2 + 1]), int(data[i*2 + 2])) for i in range(N)] result = find_optimal_price(price_bookings) print(result)"},{"question":"def max_fun_rating(n, heights): Returns the maximum sum of the fun ratings for any valid set of slides. n : int : Number of platforms heights : List[int] : List of heights of the platforms :return: int : The maximum sum of fun ratings Examples: >>> max_fun_rating(5, [10, 20, 30, 40, 50]) 40 >>> max_fun_rating(4, [100, 50, 75, 25]) 75 from functools import partial import random def test_max_fun_rating(func): inputs_outputs = [ ((5, [10, 20, 30, 40, 50]), 40), ((4, [100, 50, 75, 25]), 75), ((2, [10, 5]), 5), ((3, [10, 10, 10]), 0), ((5, [50, 40, 30, 20, 10]), 40), ((6, [7, 14, 10, 13, 18, 15]), 11), ] for (args, expected) in inputs_outputs: assert func(*args) == expected test_max_fun_rating(max_fun_rating)","solution":"def max_fun_rating(n, heights): Returns the maximum sum of the fun ratings for any valid set of slides. :param n: Number of platforms :param heights: List of heights of the platforms if n < 2: return 0 # Sorting the heights in descending order to pair the highest difference of consecutive heights heights.sort(reverse=True) max_sum = 0 # Compute the maximum possible sum of fun ratings for i in range(1, n): max_sum += heights[i - 1] - heights[i] return max_sum"},{"question":"def can_allocate_parcels(t: int, test_cases: List[Tuple[int, List[int], List[int]]]) -> List[str]: Determine if all parcels can be allocated to regions without exceeding their capacities. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int], List[int]]]): A list of test cases, where each test case is a tuple containing: - an integer representing the number of parcels and regions, - a list of integers representing the weights of the parcels, - a list of integers representing the capacities of the regions. Returns: List[str]: A list of strings, each being \\"YES\\" or \\"NO\\" indicating if the allocation is possible for corresponding test case. >>> can_allocate_parcels(2, [(3, [10, 20, 30], [30, 20, 10]), (4, [15, 25, 35, 45], [50, 40, 30, 20])]) [\\"YES\\", \\"YES\\"] >>> can_allocate_parcels(1, [(3, [10, 31, 20], [30, 30, 30])]) [\\"NO\\"] >>> can_allocate_parcels(3, [(2, [5, 8], [8, 10]), (3, [25, 35, 45], [50, 40, 30]), (2, [50, 50], [50, 49])]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> can_allocate_parcels(1, [(5, [30, 40, 50, 60, 70], [70, 60, 50, 40, 30])]) [\\"YES\\"]","solution":"def can_allocate_parcels(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] weights = test_cases[i][1] capacities = test_cases[i][2] # Sort weights and capacities in non-decreasing order weights.sort() capacities.sort() possible = True for j in range(n): if weights[j] > capacities[j]: possible = False break if possible: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def minimum_moves_to_reach_end(N: int, M: int, S: int, grid: List[str]) -> int: Determine the minimum number of moves to reach the bottom-right corner of the grid, given the ability to destroy up to S wall cells. Args: N (int): Number of rows in the grid. M (int): Number of columns in the grid. S (int): Number of wall cells you can destroy. grid (List[str]): NxM grid represented as a list of strings. Returns: int: Minimum number of moves required to reach the bottom-right corner, or -1 if it is not possible. Examples: >>> minimum_moves_to_reach_end(4, 4, 2, [\\"#...\\", \\"....\\", \\"#.\\", \\"..#.\\", \\"\\"]) 6 >>> minimum_moves_to_reach_end(3, 3, 0, [\\".#.\\", \\"#.#\\", \\".#.\\"]) -1 >>> minimum_moves_to_reach_end(3, 3, 0, [\\"...\\", \\"...\\", \\"...\\"]) 4 >>> minimum_moves_to_reach_end(1, 3, 1, [\\"#..\\"]) 2 >>> minimum_moves_to_reach_end(3, 1, 1, [\\"#\\", \\".\\", \\".\\"]) 2 >>> minimum_moves_to_reach_end(2, 2, 1, [\\"\\", \\"\\"]) -1","solution":"from collections import deque def minimum_moves_to_reach_end(N, M, S, grid): def is_valid(x, y): return 0 <= x < N and 0 <= y < M directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[[False] * (S + 1) for _ in range(M)] for _ in range(N)] queue = deque([(0, 0, 0, 0)]) # x, y, walls destroyed, steps while queue: x, y, walls_destroyed, steps = queue.popleft() if (x, y) == (N - 1, M - 1): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny): if grid[nx][ny] == '#' and walls_destroyed < S and not visited[nx][ny][walls_destroyed + 1]: visited[nx][ny][walls_destroyed + 1] = True queue.append((nx, ny, walls_destroyed + 1, steps + 1)) elif grid[nx][ny] == '.' and not visited[nx][ny][walls_destroyed]: visited[nx][ny][walls_destroyed] = True queue.append((nx, ny, walls_destroyed, steps + 1)) return -1"},{"question":"def compute_bounding_box(points): Compute the dimensions of the smallest bounding box that can enclose all the given 3D points. min_x = min_y = min_z = float('inf') max_x = max_y = max_z = float('-inf') for x, y, z in points: if x < min_x: min_x = x if x > max_x: max_x = x if y < min_y: min_y = y if y > max_y: max_y = y if z < min_z: min_z = z if z > max_z: max_z = z length_x = max_x - min_x length_y = max_y - min_y length_z = max_z - min_z return length_x, length_y, length_z def process_input(input_data): Process the input data to extract point sets and compute bounding box dimensions. >>> process_input(\\"3n1 1 1n2 2 2n3 3 3n4n-1 -1 -1n-2 -2 -2n0 0 0n1 1 1n0n\\") [(2, 2, 2), (3, 3, 3)] data = input_data.splitlines() index = 0 results = [] while index < len(data): n = int(data[index]) if n == 0: break index += 1 points = [] for _ in range(n): x, y, z = map(int, data[index].split()) points.append((x, y, z)) index += 1 dimensions = compute_bounding_box(points) results.append(dimensions) return results","solution":"def compute_bounding_box(points): Compute the dimensions of the smallest bounding box that can enclose all the given 3D points. min_x = min_y = min_z = float('inf') max_x = max_y = max_z = float('-inf') for x, y, z in points: if x < min_x: min_x = x if x > max_x: max_x = x if y < min_y: min_y = y if y > max_y: max_y = y if z < min_z: min_z = z if z > max_z: max_z = z length_x = max_x - min_x length_y = max_y - min_y length_z = max_z - min_z return length_x, length_y, length_z def process_input(input_data): data = input_data.splitlines() index = 0 results = [] while index < len(data): n = int(data[index]) if n == 0: break index += 1 points = [] for _ in range(n): x, y, z = map(int, data[index].split()) points.append((x, y, z)) index += 1 dimensions = compute_bounding_box(points) results.append(dimensions) return results"},{"question":"def can_form_palindrome(s: str) -> str: Determines if the given string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"madam\\") \\"YES\\" >>> can_form_palindrome(\\"racecar\\") \\"YES\\" >>> can_form_palindrome(\\"hello\\") \\"NO\\" def check_palindromes(n: int, strings: List[str]) -> List[str]: For a given list of strings, determines if each string can be rearranged to form a palindrome. Args: n (int): The number of strings. strings (list): The list of strings. Returns: list: A list of results for each string, where each result is \\"YES\\" or \\"NO\\". >>> check_palindromes(3, [\\"madam\\", \\"racecar\\", \\"hello\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> check_palindromes(4, [\\"ab\\", \\"aabb\\", \\"abc\\", \\"abcd\\"]) [\\"NO\\", \\"YES\\", \\"NO\\", \\"NO\\"]","solution":"def can_form_palindrome(s): Determines if the given string can be rearranged to form a palindrome. Args: s (str): The input string. Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, else \\"NO\\". from collections import Counter # Count frequency of each character char_count = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if there's at most one character with an odd frequency return \\"YES\\" if odd_count <= 1 else \\"NO\\" def check_palindromes(n, strings): For a given list of strings, determines if each string can be rearranged to form a palindrome and returns the results. Args: n (int): The number of strings. strings (list): The list of strings. Returns: list: A list of results for each string, where each result is \\"YES\\" or \\"NO\\". results = [can_form_palindrome(s) for s in strings] return results"},{"question":"def trap_rainwater(heights: List[int]) -> int: Calculate the total amount of trapped rainwater in the given landscape. Parameters: heights (list of int): List representing the height at each position of the landscape. Returns: int: Total amount of trapped rainwater. Example: >>> trap_rainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_rainwater([1, 1, 1, 1]) 0","solution":"def trap_rainwater(heights): Calculate the total amount of trapped rainwater in the given landscape. Parameters: heights (list of int): List representing the height at each position of the landscape. Returns: int: Total amount of trapped rainwater. if not heights or len(heights) < 3: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"def is_bipartite(n, m, edges): Determines if a graph is bipartite. Parameters: n (int): Number of vertices m (int): Number of edges edges (list of tuples): List of edges in the graph Returns: str: 'Yes' if the graph is bipartite, 'No' otherwise >>> is_bipartite(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 'Yes' >>> is_bipartite(3, 3, [(1, 2), (2, 3), (3, 1)]) 'No'","solution":"def is_bipartite(n, m, edges): Determines if a graph is bipartite. Parameters: n (int): Number of vertices m (int): Number of edges edges (list of tuples): List of edges in the graph Returns: str: 'Yes' if the graph is bipartite, 'No' otherwise from collections import deque def bfs(start): queue = deque([start]) colors[start] = 0 while queue: node = queue.popleft() for neighbor in adj_list[node]: if colors[neighbor] == -1: colors[neighbor] = 1 - colors[node] queue.append(neighbor) elif colors[neighbor] == colors[node]: return False return True # Create adjacency list adj_list = [[] for _ in range(n + 1)] for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # Initialize colors colors = [-1] * (n + 1) # Check for each disconnected component for i in range(1, n + 1): if colors[i] == -1: if not bfs(i): return \\"No\\" return \\"Yes\\""},{"question":"from typing import List, Tuple def bento_box_combinations(test_cases: List[Tuple[int, int]]) -> List[int]: Returns the number of different combinations of bento boxes that can be created for given test cases. :param test_cases: List of tuples, where each tuple contains two integers (N, R) :return: List of integers, each representing the number of combinations for corresponding (N, R) >>> bento_box_combinations([(5,2), (6,3), (8,4)]) [10, 20, 70] >>> bento_box_combinations([(5,0), (5,1), (5,5)]) [1, 5, 1] >>> bento_box_combinations([(10,2), (10,5)]) [45, 252] >>> bento_box_combinations([(0,0)]) [1] >>> bento_box_combinations([(1,0), (1,1)]) [1, 1]","solution":"from math import comb def bento_box_combinations(test_cases): Returns the number of different combinations of bento boxes that can be created for given test cases. :param test_cases: List of tuples, where each tuple contains two integers (N, R) :return: List of integers, each representing the number of combinations for corresponding (N, R) results = [] for N, R in test_cases: results.append(comb(N, R)) return results"},{"question":"def count_unique_quadrilaterals(n: int) -> int: Returns the number of unique quadrilaterals that can be formed from n points. >>> count_unique_quadrilaterals(4) 1 >>> count_unique_quadrilaterals(5) 5 >>> count_unique_quadrilaterals(6) 15 >>> count_unique_quadrilaterals(7) 35 >>> count_unique_quadrilaterals(8) 70 >>> count_unique_quadrilaterals(9) 126 >>> count_unique_quadrilaterals(10) 210 def process_test_cases(test_cases: List[int]) -> List[int]: Processes multiple test cases for counting unique quadrilaterals. >>> process_test_cases([4]) [1] >>> process_test_cases([4, 5, 6]) [1, 5, 15] >>> process_test_cases([10, 7]) [210, 35] >>> process_test_cases([8, 9, 10]) [70, 126, 210] >>> process_test_cases([50]) [230300]","solution":"def count_unique_quadrilaterals(n): Returns the number of unique quadrilaterals that can be formed from n points. if n < 4: return 0 return (n * (n - 1) * (n - 2) * (n - 3)) // 24 def process_test_cases(test_cases): Processes multiple test cases for counting unique quadrilaterals. results = [] for n in test_cases: results.append(count_unique_quadrilaterals(n)) return results"},{"question":"def find_median_sorted_arrays(nums1, nums2): You are given two sorted arrays, nums1 and nums2, both of which contain integers in non-decreasing order. Your task is to find the median of the combined sorted array that would result from merging nums1 and nums2. The combined array might not necessarily be stored or merged explicitly, so think about efficient ways to calculate the median of this conceptual merged array. The total length of the resulting array formed from nums1 and nums2 will be at least 1 and at most 10^6. Examples: >>> find_median_sorted_arrays([1, 3, 8, 9], [1, 6, 7]) 6 >>> find_median_sorted_arrays([1, 2, 5], [3, 4]) 3 >>> find_median_sorted_arrays([1], [1]) 1 >>> find_median_sorted_arrays([1, 2], []) 1.5 >>> find_median_sorted_arrays([], [3, 4]) 3.5 >>> find_median_sorted_arrays([1, 3], [2]) 2 >>> find_median_sorted_arrays([1, 2], [3, 4]) 2.5 >>> find_median_sorted_arrays([1, 3, 5], [2, 4, 6]) 3.5","solution":"def find_median_sorted_arrays(nums1, nums2): def get_kth_element(arr1, arr2, k): index1, index2 = 0, 0 while True: if index1 == len(arr1): return arr2[index2 + k - 1] if index2 == len(arr2): return arr1[index1 + k - 1] if k == 1: return min(arr1[index1], arr2[index2]) new_index1 = min(index1 + k // 2 - 1, len(arr1) - 1) new_index2 = min(index2 + k // 2 - 1, len(arr2) - 1) pivot1, pivot2 = arr1[new_index1], arr2[new_index2] if pivot1 <= pivot2: k -= (new_index1 - index1 + 1) index1 = new_index1 + 1 else: k -= (new_index2 - index2 + 1) index2 = new_index2 + 1 total_len = len(nums1) + len(nums2) if total_len % 2 == 1: return get_kth_element(nums1, nums2, total_len // 2 + 1) else: return (get_kth_element(nums1, nums2, total_len // 2) + get_kth_element(nums1, nums2, total_len // 2 + 1)) / 2 # Example function call (should print 6) # print(find_median_sorted_arrays([1, 3, 8, 9], [1, 6, 7]))"},{"question":"def search_matrix(matrix: List[List[int]], target: int) -> Tuple[int, int]: You are given a rectangular matrix filled with distinct integers, where each row and each column is sorted in ascending order. Write a function that efficiently finds a given target integer in the matrix. The function should return a tuple of two integers representing the row and column indices of the target integer, respectively. If the target integer is not found, return (-1, -1). >>> search_matrix([ [1, 4, 7], [2, 5, 8], [3, 6, 9] ], 5) (1, 1) >>> search_matrix([ [10, 20, 30, 40], [15, 25, 35, 45], [27, 29, 37, 48], [32, 33, 39, 50] ], 100) (-1, -1)","solution":"def search_matrix(matrix, target): if not matrix or not matrix[0]: return -1, -1 rows = len(matrix) cols = len(matrix[0]) # Start from the top-right corner row, col = 0, cols - 1 while row < rows and col >= 0: current = matrix[row][col] if current == target: return row, col elif current > target: col -= 1 # Move left else: row += 1 # Move down # If the target was not found return -1, -1"},{"question":"def inventory_management(commands: List[str]) -> List[int]: Create a function that simulates a store's inventory management system. The input consists of multiple commands which are either 'restock', 'purchase', or 'check'. Each command is followed by the item name and an integer value. The 'restock' command adds the given integer value to the item's stock. The 'purchase' command subtracts the given integer value from the item's stock, if the stock is sufficient, otherwise it should leave the stock unchanged. The 'check' command outputs the current stock level of the specified item. If an item is restocked or checked before it is ever restocked, its current stock is treated as 0. Args: commands (List[str]): List of strings containing commands. Returns: List[int]: A list of integers corresponding to the results of the 'check' commands. >>> inventory_management([\\"restock apple 50\\", \\"purchase apple 10\\", \\"check apple 0\\", \\"restock banana 20\\", \\"purchase banana 25\\", \\"check banana 0\\", \\"purchase apple 5\\", \\"check apple 0\\", \\"exit\\"]) [40, 20, 35]","solution":"def inventory_management(commands): inventory = {} results = [] for command in commands: parts = command.split() action = parts[0] if action == \\"exit\\": break item = parts[1] amount = int(parts[2]) if action == \\"restock\\": if item not in inventory: inventory[item] = 0 inventory[item] += amount elif action == \\"purchase\\": if item in inventory and inventory[item] >= amount: inventory[item] -= amount elif action == \\"check\\": results.append(inventory.get(item, 0)) return results"},{"question":"def min_distribution_rounds(T: int, cases: List[Tuple[int, int]]) -> List[int]: Determine the minimum number of complete distribution rounds required such that each child receives exactly the same number of sweets. Args: T (int): Number of test cases. cases (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers, the number of sweets S and the number of children C. Returns: List[int]: A list of integers where each integer represents the minimum number of complete distribution rounds for the corresponding test case. >>> min_distribution_rounds(1, [(10, 3)]) == [4] >>> min_distribution_rounds(1, [(15, 5)]) == [3] from typing import List, Tuple def test_single_case(): assert min_distribution_rounds(1, [(10, 3)]) == [4] assert min_distribution_rounds(1, [(15, 5)]) == [3] def test_multiple_cases(): assert min_distribution_rounds(2, [(10, 3), (15, 5)]) == [4, 3] assert min_distribution_rounds(3, [(10, 2), (15, 4), (21, 7)]) == [5, 4, 3] def test_no_sweets(): assert min_distribution_rounds(1, [(0, 5)]) == [0] def test_no_children(): assert min_distribution_rounds(1, [(10, 0)]) == [0] def test_edge_cases(): assert min_distribution_rounds(1, [(1, 1)]) == [1] assert min_distribution_rounds(1, [(10**9, 1)]) == [10**9] assert min_distribution_rounds(1, [(1, 10**9)]) == [1] def test_large_numbers(): assert min_distribution_rounds(1, [(10**9, 10**9)]) == [1] assert min_distribution_rounds(2, [(10**9, 10**6), (10**6, 10**9)]) == [1000, 1]","solution":"def min_distribution_rounds(T, cases): results = [] for S, C in cases: if C == 0: results.append(0) # No children to distribute sweets to. else: results.append((S + C - 1) // C) # Ceiling division to get the minimum rounds. return results"},{"question":"def process_list_operations(n, initial_list, m, operations): Processes a series of operations on a list and prints results as per the instructions. :param n: Initial number of integers in the list :param initial_list: List of initial integers :param m: Number of operations to perform on the list :param operations: List of operations to perform Example: >>> process_list_operations(5, [1, 2, 3, 4, 5], 6, [\\"ADD 6\\", \\"INCREMENT 2\\", \\"REMOVE 4\\", \\"DECREMENT 1\\", \\"GET_SUM\\", \\"REMOVE 2\\"]) 24","solution":"def process_list_operations(n, initial_list, m, operations): Processes a series of operations on a list and prints results as per the instructions. :param n: Initial number of integers in the list :param initial_list: List of initial integers :param m: Number of operations to perform on the list :param operations: List of operations to perform current_list = initial_list[:] def add(x): current_list.append(x) def remove(x): while x in current_list: current_list.remove(x) def increment(y): for i in range(len(current_list)): current_list[i] += y def decrement(y): for i in range(len(current_list)): current_list[i] -= y def get_sum(): print(sum(current_list)) for operation in operations: parts = operation.split() command = parts[0] if command == \\"ADD\\": add(int(parts[1])) elif command == \\"REMOVE\\": remove(int(parts[1])) elif command == \\"INCREMENT\\": increment(int(parts[1])) elif command == \\"DECREMENT\\": decrement(int(parts[1])) elif command == \\"GET_SUM\\": get_sum()"},{"question":"def is_symmetric_pattern_possible(grid: List[str]) -> str: Check if a given n x m grid is symmetric both horizontally and vertically. >>> is_symmetric_pattern_possible([\\"#\\", \\".#.\\", \\"#\\"]) \\"YES\\" >>> is_symmetric_pattern_possible([\\"#.\\", \\".#.#\\", \\"#.\\"]) \\"NO\\" >>> is_symmetric_pattern_possible([\\".\\", \\"#...#\\", \\".....\\", \\"#...#\\", \\".\\"]) \\"YES\\" >>> is_symmetric_pattern_possible([\\"\\", \\"#..#\\", \\"#..#\\", \\"\\"]) \\"YES\\" >>> is_symmetric_pattern_possible([\\"#.#\\", \\"...\\", \\"#.#\\"]) \\"YES\\" >>> is_symmetric_pattern_possible([\\".\\", \\".\\", \\"#..\\"]) \\"NO\\"","solution":"def is_symmetric_pattern_possible(grid): Check if a given n x m grid is symmetric both horizontally and vertically. n = len(grid) m = len(grid[0]) # Check horizontal symmetry for i in range(n): if grid[i] != grid[n - 1 - i]: return \\"NO\\" # Check vertical symmetry for j in range(m): for i in range(n): if grid[i][j] != grid[i][m - 1 - j]: return \\"NO\\" return \\"YES\\""},{"question":"def is_right_angled_triangle(A: int, B: int, C: int) -> str: Determine if the given sides A, B, and C can form a right-angled triangle. Args: A (int): The first side of the triangle. B (int): The second side of the triangle. C (int): The third side of the triangle. Returns: str: 'YES' if A, B, and C can form a right-angled triangle, 'NO' otherwise. Examples: >>> is_right_angled_triangle(3, 4, 5) 'YES' >>> is_right_angled_triangle(1, 2, 3) 'NO'","solution":"def is_right_angled_triangle(A, B, C): Determines if the given sides A, B, and C can form a right-angled triangle. Returns 'YES' if they can, 'NO' otherwise. sides = sorted([A, B, C]) return 'YES' if sides[0]**2 + sides[1]**2 == sides[2]**2 else 'NO' # Example usage: # if __name__ == \\"__main__\\": # A, B, C = map(int, input().split()) # print(is_right_angled_triangle(A, B, C))"},{"question":"from typing import List def process_queries(n: int, q: int, packages: List[int], queries: List[str]) -> List[int]: Processes the given queries on the depots and returns the results of the range sum queries. Args: n : int : number of depots q : int : number of queries packages : List[int] : initial number of packages in each depot queries : List[str] : list of queries to process Returns: List[int] : results of the sum queries Examples: >>> process_queries(5, 5, [2, 8, 3, 10, 5], [\\"2 1 5\\", \\"2 2 4\\", \\"1 3 7\\", \\"2 1 5\\", \\"2 3 3\\"]) [28, 21, 32, 7] >>> process_queries(4, 3, [1, 2, 3, 4], [\\"2 1 3\\", \\"1 2 6\\", \\"2 1 3\\"]) [6, 10] >>> process_queries(3, 4, [5, 6, 7], [\\"2 1 2\\", \\"1 1 10\\", \\"2 1 3\\", \\"2 2 2\\"]) [11, 23, 6] >>> process_queries(5, 5, [0, 0, 0, 0, 0], [\\"1 1 1\\", \\"1 2 2\\", \\"1 3 3\\", \\"1 4 4\\", \\"2 1 5\\"]) [10] >>> process_queries(100, 1, [1]*100, [\\"2 1 100\\"]) [100]","solution":"def process_queries(n, q, packages, queries): results = [] for query in queries: parts = query.split() if parts[0] == '1': i, x = int(parts[1]), int(parts[2]) packages[i-1] = x elif parts[0] == '2': l, r = int(parts[1]), int(parts[2]) total = sum(packages[l-1:r]) results.append(total) return results"},{"question":"def find_distinct_multiples(n: int, sequence: List[int]) -> Tuple[int, List[int]]: Returns the number of distinct multiples of the sequence and the sorted list of these multiples. >>> find_distinct_multiples(3, [2, 3, 5]) (3, [6, 10, 15]) >>> find_distinct_multiples(4, [1, 4, 8, 16]) (6, [4, 8, 16, 32, 64, 128]) >>> find_distinct_multiples(2, [7, 11]) (1, [77])","solution":"def find_distinct_multiples(n, sequence): Returns the number of distinct multiples of the sequence and the sorted list of these multiples. multiples = set() for i in range(n): for j in range(i + 1, n): multiples.add(sequence[i] * sequence[j]) sorted_multiples = sorted(multiples) return len(sorted_multiples), sorted_multiples # Example usage: # n = 3 # sequence = [2, 3, 5] # print(find_distinct_multiples(n, sequence)) # Output: (3, [6, 10, 15])"},{"question":"def generate_permutation(k: int) -> str: Generates a permutation of k distinct lowercase letters such that no two consecutive characters are the same. Parameters: k (int): Number of distinct lowercase letters to be used. Returns: str: A valid permutation of k distinct lowercase letters. >>> generate_permutation(1) == \\"a\\" >>> generate_permutation(2) == \\"ab\\" >>> generate_permutation(3) == \\"abc\\" >>> generate_permutation(5) == \\"abcde\\" >>> generate_permutation(26) == \\"abcdefghijklmnopqrstuvwxyz\\"","solution":"def generate_permutation(k): Generates a permutation of k distinct lowercase letters such that no two consecutive characters are the same. Parameters: k (int): Number of distinct lowercase letters to be used. Returns: str: A valid permutation of k distinct lowercase letters. assert 1 <= k <= 26, \\"k must be between 1 and 26 inclusive.\\" if k == 1: return \\"a\\" # Create a list of the first k lowercase letters letters = [chr(i) for i in range(ord('a'), ord('a') + k)] # Since we are using distinct letters and k ≤ 26, no two consecutive letters will be the same return ''.join(letters)"},{"question":"import heapq from typing import Tuple class TicketingSystem: A priority-based ticketing system to manage customer issues. >>> ts = TicketingSystem() >>> ts.add_ticket(2, 101, \\"Issue with login\\") >>> ts.add_ticket(1, 102, \\"Server down\\") >>> ts.add_ticket(2, 103, \\"Password reset\\") >>> ts.ticket_count() 3 >>> ts.process_ticket() (102, \\"Server down\\") >>> ts.ticket_count() 2 >>> ts.process_ticket() (101, \\"Issue with login\\") >>> ts.process_ticket() (103, \\"Password reset\\") >>> ts.process_ticket() (-1, \\"No tickets available\\") >>> ts.ticket_count() 0 def __init__(self): self.ticket_heap = [] self.ticket_map = {} def add_ticket(self, priority: int, ticket_id: int, description: str) -> None: Adds a new ticket with given priority, ID, and description. def process_ticket(self) -> Tuple[int, str]: Returns a tuple containing the ID and description of the highest priority ticket and removes it. Returns (-1, \\"No tickets available\\") if no tickets are present. def ticket_count(self) -> int: Returns the number of tickets currently in the system. def test_add_and_process_ticket(): ts = TicketingSystem() ts.add_ticket(2, 101, \\"Issue with login\\") ts.add_ticket(1, 102, \\"Server down\\") ts.add_ticket(2, 103, \\"Password reset\\") assert ts.ticket_count() == 3 assert ts.process_ticket() == (102, \\"Server down\\") assert ts.ticket_count() == 2 assert ts.process_ticket() == (101, \\"Issue with login\\") assert ts.process_ticket() == (103, \\"Password reset\\") assert ts.process_ticket() == (-1, \\"No tickets available\\") def test_ticket_count_no_tickets(): ts = TicketingSystem() assert ts.ticket_count() == 0 def test_process_ticket_no_tickets(): ts = TicketingSystem() assert ts.process_ticket() == (-1, \\"No tickets available\\") def test_multiple_same_priority(): ts = TicketingSystem() ts.add_ticket(2, 104, \\"Issue with network\\") ts.add_ticket(2, 105, \\"Issue with email\\") ts.add_ticket(1, 106, \\"Database not responding\\") assert ts.process_ticket() == (106, \\"Database not responding\\") assert ts.process_ticket() == (104, \\"Issue with network\\") assert ts.process_ticket() == (105, \\"Issue with email\\") assert ts.process_ticket() == (-1, \\"No tickets available\\")","solution":"import heapq class TicketingSystem: def __init__(self): self.ticket_heap = [] self.ticket_map = {} def add_ticket(self, priority: int, ticket_id: int, description: str) -> None: heapq.heappush(self.ticket_heap, (priority, ticket_id)) self.ticket_map[ticket_id] = description def process_ticket(self): if not self.ticket_heap: return (-1, \\"No tickets available\\") priority, ticket_id = heapq.heappop(self.ticket_heap) description = self.ticket_map.pop(ticket_id, \\"No description\\") return (ticket_id, description) def ticket_count(self) -> int: return len(self.ticket_heap)"},{"question":"def evacuation_plan(test_cases): Determines if the network of shelters and roads forms a strongly connected graph. Each test case should contain: - n: int - the number of shelters (1 ≤ n ≤ 1000) - m: int - the number of roads (0 ≤ m ≤ n(n-1)) - edges: List[Tuple[int, int]] - a list of m tuples, each representing a bidirectional road between shelters u and v Returns a list of strings; \\"YES\\" if the network forms a strongly connected graph, otherwise \\"NO\\". >>> evacuation_plan([(4, 5, [(1, 2), (2, 3), (3, 4), (4, 1), (2, 4)]), (3, 2, [(3, 2), (1, 3)]), (4, 0, [])]) ['YES', 'YES', 'NO'] >>> evacuation_plan([(1, 0, [])]) ['YES'] >>> evacuation_plan([(3, 1, [(1, 2)]), (2, 0, [])]) ['NO', 'NO'] >>> evacuation_plan([(4, 6, [(1, 2), (2, 3), (3, 4), (4, 1), (1, 3), (3, 2)])]) ['YES'] >>> evacuation_plan([(5, 8, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (2, 4), (4, 2), (3, 1)])]) ['YES']","solution":"def is_strongly_connected(n, m, edges): from collections import defaultdict, deque def bfs(start, graph, n): visited = [False] * (n + 1) queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return all(visited[1:]) if n == 1: return \\"YES\\" graph = defaultdict(list) reverse_graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) reverse_graph[u].append(v) reverse_graph[v].append(u) # Check connectivity from any node (e.g., node 1) using both the graph and its transposed version (reversed) if bfs(1, graph, n) and bfs(1, reverse_graph, n): return \\"YES\\" else: return \\"NO\\" def evacuation_plan(test_cases): results = [] for n, m, edges in test_cases: results.append(is_strongly_connected(n, m, edges)) return results"},{"question":"def findTopPerformer(tasks): Find the employee who has completed strictly more tasks than anyone else. Args: tasks (list of int): List of tasks completed by each employee. Returns: int: 1-based index of the top performer or -1 if no clear top performer. Examples: >>> findTopPerformer([4, 3, 5, 7, 7]) -1 >>> findTopPerformer([10, 9, 8, 10, 7]) 1","solution":"def findTopPerformer(tasks): Find the employee who has completed strictly more tasks than anyone else. Args: tasks (list of int): List of tasks completed by each employee. Returns: int: 1-based index of the top performer or -1 if no clear top performer. if not tasks: return -1 max_tasks = max(tasks) count_max = tasks.count(max_tasks) if count_max > 1: return -1 return tasks.index(max_tasks) + 1"},{"question":"def is_palindrome(s: str) -> str: Determines if the input string s is a palindrome ignoring special characters and case sensitivity. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") == \\"YES\\" >>> is_palindrome(\\"Hello, World!\\") == \\"NO\\" >>> is_palindrome(\\"\\") == \\"YES\\" >>> is_palindrome(\\"a\\") == \\"YES\\" >>> is_palindrome(\\"12321\\") == \\"YES\\" >>> is_palindrome(\\"12345\\") == \\"NO\\" >>> is_palindrome(\\"NoOn\\") == \\"YES\\" >>> is_palindrome(\\"NooP\\") == \\"NO\\" >>> is_palindrome(\\"!!!\\") == \\"YES\\" >>> is_palindrome(\\"!@#%\\") == \\"YES\\"","solution":"def is_palindrome(s): Returns \\"YES\\" if the input string s is a palindrome ignoring special characters and case sensitivity; otherwise returns \\"NO\\". # Remove non-alphanumeric characters and convert to lowercase filtered_str = ''.join(char.lower() for char in s if char.isalnum()) # Check if the filtered string is a palindrome return \\"YES\\" if filtered_str == filtered_str[::-1] else \\"NO\\""},{"question":"def is_perfect_palindrome(s: str) -> str: Returns 'TRUE' if the string s is a Perfect Palindrome, otherwise 'FALSE'. >>> is_perfect_palindrome(\\"aaa\\") 'TRUE' >>> is_perfect_palindrome(\\"aba\\") 'FALSE' >>> is_perfect_palindrome(\\"cccc\\") 'TRUE' pass def run_test_cases(t: int, test_cases: List[str]) -> List[str]: Processes multiple test cases and returns the results for each case. >>> run_test_cases(3, [\\"aaa\\", \\"aba\\", \\"cccc\\"]) ['TRUE', 'FALSE', 'TRUE'] >>> run_test_cases(2, [\\"a\\", \\"bbbbb\\"]) ['TRUE', 'TRUE'] >>> run_test_cases(4, [\\"racecar\\", \\"level\\", \\"noon\\", \\"radar\\"]) ['FALSE', 'FALSE', 'FALSE', 'FALSE'] pass","solution":"def is_perfect_palindrome(s): Returns 'TRUE' if the string s is a Perfect Palindrome, otherwise 'FALSE'. return 'TRUE' if s == s[::-1] and len(set(s)) == 1 else 'FALSE' def run_test_cases(t, test_cases): results = [] for test_case in test_cases: results.append(is_perfect_palindrome(test_case)) return results"},{"question":"class NumMatrix: def __init__(self, matrix: List[List[int]]): Initializes the object with the integer matrix matrix. pass def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int: Returns the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2). pass def test_num_matrix_case1(): matrix = [ [3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5] ] numMatrix = NumMatrix(matrix) assert numMatrix.sumRegion(2, 1, 4, 3) == 8 assert numMatrix.sumRegion(1, 1, 2, 2) == 11 assert numMatrix.sumRegion(1, 2, 2, 4) == 12 def test_num_matrix_edge_case(): matrix = [ [1] ] numMatrix = NumMatrix(matrix) assert numMatrix.sumRegion(0, 0, 0, 0) == 1 def test_num_matrix_single_row(): matrix = [ [1, 2, 3, 4] ] numMatrix = NumMatrix(matrix) assert numMatrix.sumRegion(0, 1, 0, 3) == 9 assert numMatrix.sumRegion(0, 0, 0, 2) == 6 def test_num_matrix_single_column(): matrix = [ [1], [2], [3], [4] ] numMatrix = NumMatrix(matrix) assert numMatrix.sumRegion(1, 0, 3, 0) == 9 assert numMatrix.sumRegion(0, 0, 2, 0) == 6","solution":"class NumMatrix: def __init__(self, matrix): Initializes the object with the integer matrix matrix. if not matrix: return self.m = len(matrix) self.n = len(matrix[0]) # Prefix sum matrix self.prefix_sum = [[0] * (self.n + 1) for _ in range(self.m + 1)] # Fill prefix sum matrix for i in range(self.m): for j in range(self.n): self.prefix_sum[i + 1][j + 1] = (self.prefix_sum[i + 1][j] + self.prefix_sum[i][j + 1] - self.prefix_sum[i][j] + matrix[i][j]) def sumRegion(self, row1, col1, row2, col2): Returns the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2). return (self.prefix_sum[row2 + 1][col2 + 1] - self.prefix_sum[row2 + 1][col1] - self.prefix_sum[row1][col2 + 1] + self.prefix_sum[row1][col1])"},{"question":"def tree_heights(test_cases): Returns the height of the k-th tree for each test case. Parameters: test_cases (list of tuples): A list where each tuple contains three integers (a, d, k). Returns: list: A list of integers representing the height of the k-th tree for each test case. >>> tree_heights([(5, 3, 4)]) [14] >>> tree_heights([(10, 2, 5)]) [18] >>> tree_heights([(7, 1, 7)]) [13] def test_tree_heights_case1(): assert tree_heights([(5, 3, 4)]) == [14] def test_tree_heights_case2(): assert tree_heights([(10, 2, 5)]) == [18] def test_tree_heights_case3(): assert tree_heights([(7, 1, 7)]) == [13] def test_tree_heights_multiple_cases(): assert tree_heights([(5, 3, 4), (10, 2, 5), (7, 1, 7)]) == [14, 18, 13] def test_tree_heights_min_values(): assert tree_heights([(1, 1, 1)]) == [1] def test_tree_heights_max_values(): assert tree_heights([(100000, 100000, 100000)]) == [10000000000]","solution":"def tree_heights(test_cases): Returns the height of the k-th tree for each test case. Parameters: test_cases (list of tuples): A list where each tuple contains three integers (a, d, k). Returns: list: A list of integers representing the height of the k-th tree for each test case. results = [] for a, d, k in test_cases: height = a + (k - 1) * d results.append(height) return results"},{"question":"def max_usages(n: int, m: int, battery_capacities: List[int], device_consumptions: List[int]) -> List[int]: Given battery capacities and device consumptions, calculate the maximum number of times each device can be used in a row without recharging using the highest capacity battery. :param n: Number of batteries :param m: Number of devices :param battery_capacities: List of integers representing battery capacities :param device_consumptions: List of integers representing device consumptions :return: List of integers representing the maximum number of usages for each device pass # Unit Tests from solution import max_usages def test_example_1(): assert max_usages(5, 3, [10, 20, 15, 30, 5], [3, 9, 6]) == [10, 3, 5] def test_example_2(): assert max_usages(4, 2, [8, 16, 12, 4], [4, 10]) == [4, 1] def test_single_battery_single_device(): assert max_usages(1, 1, [100], [10]) == [10] def test_multiple_same_capacity_batteries(): assert max_usages(3, 2, [20, 20, 20], [5, 10]) == [4, 2] def test_device_consumption_higher_than_all_batteries(): assert max_usages(3, 1, [10, 10, 10], [30]) == [0] def test_large_numbers(): assert max_usages(3, 2, [1000000000, 500000000, 750000000], [100000000, 200000000]) == [10, 5]","solution":"def max_usages(n, m, battery_capacities, device_consumptions): Given battery capacities and device consumptions, calculate the maximum number of times each device can be used in a row without recharging using the highest capacity battery. :param n: Number of batteries :param m: Number of devices :param battery_capacities: List of integers representing battery capacities :param device_consumptions: List of integers representing device consumptions :return: List of integers representing the maximum number of usages for each device max_capacity = max(battery_capacities) return [max_capacity // consumption for consumption in device_consumptions]"},{"question":"def max_diff_letters(n, k, m, s): Calculate the maximum number of different letters in the resultant string after m turns. Args: n (int): Length of string s (1 ≤ k ≤ n ≤ 100). k (int): Length of substring (1 ≤ k ≤ n). m (int): Number of turns (1 ≤ m ≤ 100). s (str): The initial string. Returns: int: The maximum number of different letters in the resultant string after m turns. >>> max_diff_letters(8, 3, 2, \\"abcdefgh\\") == 10 >>> max_diff_letters(5, 2, 3, \\"abcde\\") == 8 >>> max_diff_letters(6, 4, 1, \\"abcdef\\") == 7","solution":"def max_diff_letters(n, k, m, s): Calculate the maximum number of different letters in the resultant string after m turns. Args: n (int): Length of string s (1 ≤ k ≤ n ≤ 100). k (int): Length of substring (1 ≤ k ≤ n). m (int): Number of turns (1 ≤ m ≤ 100). s (str): The initial string. Returns: int: The maximum number of different letters in the resultant string after m turns. unique_characters = set(s) # Maximum number of unique characters that can be in the resultant string after m turns max_diff_chars = len(unique_characters) + m # Ensure that this number does not exceed the total distinct lowercase English letters (26) return min(max_diff_chars, 26)"},{"question":"def longest_palindromic_substring(s: str) -> int: Returns the length of the longest palindromic substring in the given string s. >>> longest_palindromic_substring(\\"babad\\") 3 >>> longest_palindromic_substring(\\"cbbd\\") 2 >>> longest_palindromic_substring(\\"a\\") 1 >>> longest_palindromic_substring(\\"racecar\\") 7","solution":"def longest_palindromic_substring(s): Returns the length of the longest palindromic substring in the given string s. n = len(s) if n == 0: return 0 # Table to store results of subproblems dp = [[False] * n for _ in range(n)] max_length = 1 # All substrings of length 1 are palindromic for i in range(n): dp[i][i] = True start = 0 # Check for sub-strings of length 2 for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True start = i max_length = 2 # Check for lengths greater than 2 for k in range(3, n + 1): for i in range(n - k + 1): j = i + k - 1 if dp[i + 1][j - 1] and s[i] == s[j]: dp[i][j] = True if k > max_length: start = i max_length = k return max_length"},{"question":"class Grid: def __init__(self): self.filled_cells = set() def fill(self, x, y): self.filled_cells.add((x, y)) def clear(self, x, y): self.filled_cells.discard((x, y)) def query(self, x1, y1, x2, y2): count = 0 for cell in self.filled_cells: if x1 <= cell[0] <= x2 and y1 <= cell[1] <= y2: count += 1 return count def handle_operations(operations): Handles a list of operations to fill, clear, and query a grid of cells. Parameters: operations (List[str]): List of operations in format 'fill x y', 'clear x y', 'query x1 y1 x2 y2' Returns: List[int]: List of query results Example: >>> handle_operations([ \\"fill 1 1\\", \\"fill 2 2\\", \\"fill 3 3\\", \\"query 1 1 3 3\\", \\"clear 2 2\\", \\"query 1 1 3 3\\", \\"fill 4 4\\", \\"fill 2 2\\", \\"query 1 1 4 4\\" ]) [3, 2, 4] grid = Grid() results = [] for operation in operations: parts = operation.split() op_type = parts[0] if op_type == 'fill': x, y = int(parts[1]), int(parts[2]) grid.fill(x, y) elif op_type == 'clear': x, y = int(parts[1]), int(parts[2]) grid.clear(x, y) elif op_type == 'query': x1, y1, x2, y2 = int(parts[1]), int(parts[2]), int(parts[3]), int(parts[4]) results.append(grid.query(x1, y1, x2, y2)) return results from solution import handle_operations def test_handle_operations(): operations = [ \\"fill 1 1\\", \\"fill 2 2\\", \\"fill 3 3\\", \\"query 1 1 3 3\\", \\"clear 2 2\\", \\"query 1 1 3 3\\", \\"fill 4 4\\", \\"fill 2 2\\", \\"query 1 1 4 4\\" ] expected_results = [3, 2, 4] assert handle_operations(operations) == expected_results def test_empty_operations(): operations = [] expected_results = [] assert handle_operations(operations) == expected_results def test_fill_and_clear(): operations = [ \\"fill 0 0\\", \\"fill 0 1\\", \\"fill 1 0\\", \\"fill 1 1\\", \\"clear 1 1\\", \\"query 0 0 1 1\\", \\"query 1 1 2 2\\", ] expected_results = [3, 0] assert handle_operations(operations) == expected_results def test_large_coordinates(): operations = [ \\"fill 1000000000 1000000000\\", \\"fill 999999999 1000000000\\", \\"fill 1000000000 999999999\\", \\"query 999999999 999999999 1000000000 1000000000\\", \\"clear 1000000000 1000000000\\", \\"query 999999999 999999999 1000000000 1000000000\\" ] expected_results = [3, 2] assert handle_operations(operations) == expected_results","solution":"class Grid: def __init__(self): self.filled_cells = set() def fill(self, x, y): self.filled_cells.add((x, y)) def clear(self, x, y): self.filled_cells.discard((x, y)) def query(self, x1, y1, x2, y2): count = 0 for cell in self.filled_cells: if x1 <= cell[0] <= x2 and y1 <= cell[1] <= y2: count += 1 return count def handle_operations(operations): grid = Grid() results = [] for operation in operations: parts = operation.split() op_type = parts[0] if op_type == 'fill': x, y = int(parts[1]), int(parts[2]) grid.fill(x, y) elif op_type == 'clear': x, y = int(parts[1]), int(parts[2]) grid.clear(x, y) elif op_type == 'query': x1, y1, x2, y2 = int(parts[1]), int(parts[2]), int(parts[3]), int(parts[4]) results.append(grid.query(x1, y1, x2, y2)) return results"},{"question":"from typing import List def is_balanced_number(number: int) -> bool: Function to check if a number is balanced. >>> is_balanced_number(12321) True >>> is_balanced_number(5225) True >>> is_balanced_number(441) False def check_balanced_numbers(numbers: List[int]) -> List[str]: Function to check if each number in the list is balanced or not. >>> check_balanced_numbers([12321, 5225, 441]) ['YES', 'YES', 'NO'] >>> check_balanced_numbers([1, 9, 7]) ['YES', 'YES', 'YES']","solution":"def is_balanced_number(number): Function to check if a number is balanced. number_str = str(number) length = len(number_str) if length == 1: return True # A single digit number is trivially balanced if length % 2 == 0: # Even length left_half = number_str[:length // 2] right_half = number_str[length // 2:] else: # Odd length left_half = number_str[:length // 2] right_half = number_str[length // 2 + 1:] left_sum = sum(int(digit) for digit in left_half) right_sum = sum(int(digit) for digit in right_half) return left_sum == right_sum def check_balanced_numbers(numbers): Function to check if each number in the list is balanced or not. results = [] for number in numbers: if is_balanced_number(number): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def generate_new_sequence(n: int, sequence: List[int]) -> List[int]: Given a sequence of n integers, generate a new sequence of length n - 1 where each element is the sum of the absolute differences of adjacent pairs in the original sequence. >>> generate_new_sequence(5, [5, 3, 8, 2, 10]) [2, 5, 6, 8] >>> generate_new_sequence(4, [1, 2, 3, 4]) [1, 1, 1]","solution":"def generate_new_sequence(n, sequence): Given a sequence of n integers, generate a new sequence of length n - 1 where each element is the sum of the absolute differences of adjacent pairs in the original sequence. :param n: size of the sequence :param sequence: list of integers :return: new sequence of length n - 1 new_sequence = [abs(sequence[i] - sequence[i + 1]) for i in range(n - 1)] return new_sequence"},{"question":"def min_deletions_to_palindrome(s: str) -> int: Returns the minimum number of deletions required to make the string a palindrome. >>> min_deletions_to_palindrome(\\"abca\\") 1 >>> min_deletions_to_palindrome(\\"abcba\\") 0 >>> min_deletions_to_palindrome(\\"abcd\\") 3 >>> min_deletions_to_palindrome(\\"a\\") 0 >>> min_deletions_to_palindrome(\\"aa\\") 0 >>> min_deletions_to_palindrome(\\"ab\\") 1 >>> min_deletions_to_palindrome(\\"aabbccbb\\") 2 >>> min_deletions_to_palindrome(\\"abcdecba\\") 1","solution":"def min_deletions_to_palindrome(s): Returns the minimum number of deletions required to make the string a palindrome. n = len(s) # Create a table to store results of subproblems dp = [[0] * n for i in range(n)] # Strings of length 1 are palindromes of length 1 for i in range(n): dp[i][i] = 1 # Build the table. The bottom-up approach is used here. for cl in range(2, n+1): for i in range(n-cl+1): j = i+cl-1 if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i][j-1], dp[i+1][j]) # Length of the longest palindromic subseq lps_length = dp[0][n-1] return n - lps_length"},{"question":"def find_pairs_with_sum(n: int, nums: List[int], target_sum: int) -> None: Given an integer n, a list of n integers, and a target sum, find and print all pairs of numbers in the list that add up to the target sum. Each pair is printed in ascending order and on a new line. If no such pair exists, prints \\"NO PAIR\\". Examples: >>> find_pairs_with_sum(5, [1, 2, 3, 4, 5], 5) 1 4 2 3 >>> find_pairs_with_sum(3, [10, 15, 3], 20) 5 15 >>> find_pairs_with_sum(4, [7, 11, 15, 3], 10) NO PAIR","solution":"def find_pairs_with_sum(n, nums, target_sum): Given an integer n, a list of n integers, and a target sum, finds and prints all pairs of numbers in the list that add up to the target sum. Each pair is printed in ascending order and on a new line. If no such pair exists, prints \\"NO PAIR\\". nums = sorted(nums) pairs = [] seen = set() for num in nums: complement = target_sum - num if complement in seen: pairs.append((min(num, complement), max(num, complement))) seen.add(num) if pairs: pairs = sorted(set(pairs)) for pair in pairs: print(pair[0], pair[1]) else: print(\\"NO PAIR\\") # Example usage # find_pairs_with_sum(5, [1, 2, 3, 4, 5], 5)"},{"question":"def are_almost_equivalent(s1: str, s2: str) -> str: Determine if two strings are almost equivalent by performing at most one operation, such as: - Removing a single character from one of the strings. - Adding a single character to one of the strings. - Replacing a single character in one of the strings with another character. >>> are_almost_equivalent(\\"abc\\", \\"abd\\") \\"YES\\" >>> are_almost_equivalent(\\"abc\\", \\"abcd\\") \\"YES\\" >>> are_almost_equivalent(\\"abc\\", \\"abxy\\") \\"NO\\" >>> are_almost_equivalent(\\"a\\", \\"b\\") \\"YES\\"","solution":"def are_almost_equivalent(s1, s2): Determine if two strings are almost equivalent by one operation (either add, remove or replace a character). len1, len2 = len(s1), len(s2) # If the length difference is more than 1, more than one modification is needed if abs(len1 - len2) > 1: return \\"NO\\" # Find the first mismatch i, j, mismatch_count = 0, 0, 0 while i < len1 and j < len2: if s1[i] != s2[j]: if mismatch_count == 1: return \\"NO\\" mismatch_count += 1 # Check the three possible cases: insert, delete, replace if len1 > len2: i += 1 # simulate delete from s1 elif len1 < len2: j += 1 # simulate insert into s1 else: i += 1 j += 1 else: i += 1 j += 1 # If we get here, there's at most one mismatch. Consider trailing characters. # If lengths differ by one, verify the trailing character if i < len1 or j < len2: mismatch_count += 1 return \\"YES\\" if mismatch_count <= 1 else \\"NO\\""},{"question":"def can_rearrange(source: str, target: str) -> str: Determines whether the source can be rearranged to match the target string. :param source: str - the source string with unique characters :param target: str - the target string :return: str - \\"YES\\" or \\"NO\\" >>> can_rearrange(\\"abcd\\", \\"abcd\\") \\"YES\\" >>> can_rearrange(\\"abcdefg\\", \\"gfedcba\\") \\"YES\\" >>> can_rearrange(\\"abc\\", \\"abcd\\") \\"NO\\" >>> can_rearrange(\\"abcd\\", \\"abc\\") \\"NO\\" >>> can_rearrange(\\"abcd\\", \\"abcf\\") \\"NO\\" >>> can_rearrange(\\"dzab\\", \\"ad\\") \\"NO\\" >>> can_rearrange(\\"\\", \\"\\") \\"YES\\" >>> can_rearrange(\\"a\\", \\"a\\") \\"YES\\" >>> can_rearrange(\\"a\\", \\"b\\") \\"NO\\"","solution":"def can_rearrange(source, target): Determines whether the source can be rearranged to match the target string. :param source: str - the source string with unique characters :param target: str - the target string :return: str - \\"YES\\" or \\"NO\\" # Check if the lengths of source and target are the same if len(source) != len(target): return \\"NO\\" # Check if source and target contain the same characters return \\"YES\\" if sorted(source) == sorted(target) else \\"NO\\""},{"question":"def min_meeting_rooms(intervals): Given a list of meeting time intervals, find the minimum number of meeting rooms required. Args: intervals: List of tuples (start, end) representing meeting times. Returns: int: Minimum number of meeting rooms required. Examples: >>> min_meeting_rooms([(0, 30), (5, 10), (15, 20)]) 2 >>> min_meeting_rooms([(7, 10), (2, 4)]) 1 def test_min_meeting_rooms_basic(): assert min_meeting_rooms([(0, 30), (5, 10), (15, 20)]) == 2 assert min_meeting_rooms([(7, 10), (2, 4)]) == 1 def test_min_meeting_rooms_empty(): assert min_meeting_rooms([]) == 0 def test_min_meeting_rooms_no_overlap(): assert min_meeting_rooms([(1, 3), (4, 6), (7, 9)]) == 1 def test_min_meeting_rooms_full_overlap(): assert min_meeting_rooms([(1, 10), (2, 6), (5, 8)]) == 3 def test_min_meeting_rooms_partial_overlap(): assert min_meeting_rooms([(1, 5), (2, 6), (3, 7), (9, 10)]) == 3 assert min_meeting_rooms([(1, 5), (2, 6), (7, 8), (9, 10)]) == 2 assert min_meeting_rooms([(1, 3), (3, 5), (5, 7)]) == 1","solution":"def min_meeting_rooms(intervals): Given a list of meeting time intervals, find the minimum number of meeting rooms required. Args: intervals: List of tuples (start, end) representing meeting times. Returns: int: Minimum number of meeting rooms required. if not intervals: return 0 starts = sorted([interval[0] for interval in intervals]) ends = sorted([interval[1] for interval in intervals]) start_ptr, end_ptr = 0, 0 rooms_needed = 0 while start_ptr < len(intervals): if starts[start_ptr] < ends[end_ptr]: rooms_needed += 1 start_ptr += 1 else: end_ptr += 1 start_ptr += 1 return rooms_needed"},{"question":"from typing import List, Tuple def can_travel_between_all_pairs(M: int, N: int, routes: List[Tuple[int, int]], P: int, maintenance_info: List[Tuple[int, int]]) -> str: Determines if it is possible to travel between all pairs of bus stops after maintenance. Args: M : int : Number of bus stops N : int : Number of bus routes routes : List[Tuple[int, int]] : List of tuples where each tuple represents a bus route connecting two bus stops P : int : Number of bus stops that have maintenance maintenance_info : List[Tuple[int, int]] : List of tuples where each tuple represents a bus stop and the number of routes that can be closed at that stop Returns: str : \\"Yes\\" if it is possible to travel between all pairs of bus stops, otherwise \\"No\\" >>> can_travel_between_all_pairs(6, 7, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (1, 6), (3, 5)], 3, [(2, 1), (4, 2), (6, 1)]) \\"Yes\\" >>> can_travel_between_all_pairs(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (1, 5)], 2, [(3, 2), (5, 2)]) \\"No\\" pass","solution":"def can_travel_between_all_pairs(M, N, routes, P, maintenance_info): from collections import defaultdict, deque # Build the graph graph = defaultdict(list) for u, v in routes: graph[u].append(v) graph[v].append(u) # Apply maintenance restrictions for k, w in maintenance_info: graph[k] = graph[k][:len(graph[k]) - w] # Function to check if all nodes are connected using Breadth-First Search def is_connected(): visited = set() queue = deque([1]) # Start BFS from node 1 visited.add(1) while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) # If the number of visited nodes is equal to M, then all nodes are connected return len(visited) == M # Check if all nodes are connected if is_connected(): return \\"Yes\\" else: return \\"No\\""},{"question":"def find_max_sum_row(matrix: List[List[int]]) -> int: Given a square matrix, find the index of the row with the maximum sum (1-based index). If multiple rows have the same maximum sum, return the smallest index. >>> find_max_sum_row([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 3 >>> find_max_sum_row([ ... [1, 2, -1, 4], ... [3, 1, 4, 1], ... [1, 2, 1, 1], ... [3, 3, 3, 3] ... ]) == 4 >>> find_max_sum_row([[5]]) == 1 >>> find_max_sum_row([ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ]) == 1 >>> find_max_sum_row([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 1 >>> find_max_sum_row([ ... [1, 2, 3], ... [1, 2, 3], ... [4, 5, 6], ... [4, 5, 6] ... ]) == 3","solution":"def find_max_sum_row(matrix): Given a square matrix, find the index of the row with the maximum sum (1-based index). If multiple rows have the same maximum sum, return the smallest index. max_sum = float('-inf') max_row_index = -1 for i, row in enumerate(matrix): current_sum = sum(row) if current_sum > max_sum: max_sum = current_sum max_row_index = i + 1 elif current_sum == max_sum and i + 1 < max_row_index: max_row_index = i + 1 return max_row_index"},{"question":"def rearrange_discounts(popularity_scores, discount_percentages): This function rearranges the discount percentages such that the product with the higher popularity score gets a higher discount percentage. Parameters: popularity_scores (List[int]): A list of integers representing the popularity scores of the products. discount_percentages (List[int]): A list of integers representing the discount percentages assigned to each product. Returns: List[int]: A list of integers representing the corrected discount percentages, in the order of their respective product's popularity scores. Examples: >>> rearrange_discounts([50, 40, 60, 30, 20], [10, 20, 30, 40, 50]) [40, 30, 50, 20, 10] >>> rearrange_discounts([10, 10, 10], [30, 20, 10]) [10, 20, 30]","solution":"def rearrange_discounts(popularity_scores, discount_percentages): This function rearranges the discount percentages such that the product with the higher popularity score gets a higher discount percentage. sorted_indexes = sorted(range(len(popularity_scores)), key=lambda i: popularity_scores[i]) sorted_discounts = sorted(discount_percentages) result = [0] * len(popularity_scores) for i, idx in enumerate(sorted_indexes): result[idx] = sorted_discounts[i] return result"},{"question":"def is_leap_year(year): Determines if a given year is a leap year. Parameters: year (int): The year to be checked. Returns: str: \\"Leap year\\" if the year is a leap year, otherwise \\"Not a leap year\\". # Your code here def main(input_list): Processes a list of years and determines if each year is a leap year. Parameters: input_list (list): A list of years. Returns: list: A list of results where each result is either \\"Leap year\\" or \\"Not a leap year\\". # Your code here # Example test cases if __name__ == '__main__': input_data = [1996, 1900, 2000, 2023, 0] expected_output = [\\"Leap year\\", \\"Not a leap year\\", \\"Leap year\\", \\"Not a leap year\\"] assert main(input_data) == expected_output, f\\"Test failed: {main(input_data)} != {expected_output}\\"","solution":"def is_leap_year(year): Determines if a given year is a leap year. Parameters: year (int): The year to be checked. Returns: str: \\"Leap year\\" if the year is a leap year, otherwise \\"Not a leap year\\". if year == 0: return None if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0): return \\"Leap year\\" else: return \\"Not a leap year\\" def main(input_list): Processes a list of years and determines if each year is a leap year. Parameters: input_list (list): A list of years. Returns: list: A list of results where each result is either \\"Leap year\\" or \\"Not a leap year\\". results = [] for year in input_list: if year == 0: break result = is_leap_year(year) results.append(result) return results"},{"question":"def is_path_possible(grid: List[str], R: int, C: int) -> str: Determine if there is a path from the top-left corner to the bottom-right corner in a grid. >>> is_path_possible([\\"...\\", \\".#.\\", \\"...\\"], 3, 3) \\"Yes\\" >>> is_path_possible([\\".#..\\", \\"..\\", \\"..#.\\", \\"...#\\"], 4, 4) \\"No\\" >>> is_path_possible([\\".#\\", \\"#.\\"], 2, 2) \\"No\\" def process_input(data: str) -> List[str]: Process the input data and determine the result for each dataset. >>> process_input(\\"3 3n...n.#.n...n4 4n.#..n..n..#.n...#n2 2n.#n#.n0 0n\\") [\\"Yes\\", \\"No\\", \\"No\\"]","solution":"def is_path_possible(grid, R, C): from collections import deque # Directions: right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x, y): return 0 <= x < R and 0 <= y < C and grid[x][y] == '.' # BFS initialization queue = deque([(0, 0)]) # Start from the top-left corner visited = set((0, 0)) # To keep track of visited cells while queue: x, y = queue.popleft() if (x, y) == (R - 1, C - 1): return \\"Yes\\" # If we reached bottom-right corner for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return \\"No\\" def process_input(data): results = [] data = data.split('n') idx = 0 while idx < len(data): line = data[idx].strip() if line == \\"0 0\\": break R, C = map(int, line.split()) grid = [] for i in range(R): grid.append(data[idx + 1 + i].strip()) results.append(is_path_possible(grid, R, C)) idx += 1 + R return results # Example usage def main(): import sys input_data = sys.stdin.read() results = process_input(input_data) for result in results: print(result) # Uncomment below to run in an environment where you can pass input # if __name__ == \\"__main__\\": # main()"},{"question":"def min_moves_to_paint(N: int, M: int, K: int) -> int: Determines the minimum number of moves required to paint K contiguous cells either in a horizontal or vertical line given the dimensions N (rows) and M (columns) of the grid. Args: N (int): The number of rows. M (int): The number of columns. K (int): The number of contiguous cells to paint. Returns: int: The minimum number of moves required to paint K contiguous cells. Returns \\"Invalid\\" if it is not possible to paint K cells. >>> min_moves_to_paint(3, 3, 2) 1 >>> min_moves_to_ppaint(2, 5, 4) 1 >>> min_moves_to_paint(5, 5, 3) 1 >>> min_moves_to_paint(4, 4, 5) 'Invalid'","solution":"def min_moves_to_paint(N, M, K): Determines the minimum number of moves required to paint K contiguous cells either in a horizontal or vertical line given the dimensions N (rows) and M (columns) of the grid. # Check if it's possible to paint K contiguous cells if K > max(N, M): return \\"Invalid\\" # Painting K contiguous cells in a line (horizontal or vertical) requires only one move return 1"},{"question":"def is_valid_seating(T, test_cases): Determine if a given seating arrangement is valid. A valid seating arrangement is one where no two guests with the same last name are seated next to each other. Args: T (int): The number of test cases. test_cases (list): A list of tuples. Each tuple contains an integer N (number of guests) and a list of N strings representing the last names of the guests. Returns: list: A list of strings, \\"valid\\" or \\"invalid\\" for each test case. pass def parse_input(input_str): Parse the input string into test cases. Args: input_str (str): A string representation of the input. Returns: tuple: A tuple containing an integer T and a list of test cases. Each test case is a tuple containing an integer N and a list of N strings. pass def main(input_str): The main function to solve the problem based on the provided input string. Args: input_str (str): A string representation of the input. Output: Prints \\"valid\\" or \\"invalid\\" for each test case. pass from solution import is_valid_seating, parse_input, main def test_parse_input(): input_str = \\"2n4 Smith Johnson Smith Williamsn3 Brown Brown Brownn\\" T, test_cases = parse_input(input_str) assert T == 2 assert test_cases == [ (4, [\\"Smith\\", \\"Johnson\\", \\"Smith\\", \\"Williams\\"]), (3, [\\"Brown\\", \\"Brown\\", \\"Brown\\"]) ] def test_is_valid_seating(): test_cases = [ (4, [\\"Smith\\", \\"Johnson\\", \\"Smith\\", \\"Williams\\"]), (3, [\\"Brown\\", \\"Brown\\", \\"Brown\\"]) ] results = is_valid_seating(2, test_cases) assert results == [\\"valid\\", \\"invalid\\"] def test_main(capsys): input_str = \\"2n4 Smith Johnson Smith Williamsn3 Brown Brown Brownn\\" main(input_str) captured = capsys.readouterr() assert captured.out == \\"validninvalidn\\"","solution":"def is_valid_seating(T, test_cases): results = [] for case in test_cases: N = case[0] guest_list = case[1] valid = True for i in range(N): if guest_list[i] == guest_list[(i + 1) % N]: valid = False break results.append(\\"valid\\" if valid else \\"invalid\\") return results def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) test_cases = [] for i in range(1, T + 1): parts = lines[i].split() N = int(parts[0]) guests = parts[1:] test_cases.append((N, guests)) return T, test_cases def main(input_str): T, test_cases = parse_input(input_str) results = is_valid_seating(T, test_cases) for result in results: print(result)"},{"question":"def smallest_palindrome(s: str) -> str: Create the smallest possible palindrome from a given string s by rearranging its characters. If it is not possible to rearrange the string to form a palindrome, return \\"NO\\". >>> smallest_palindrome(\\"aabb\\") \\"abba\\" >>> smallest_palindrome(\\"abc\\") \\"NO\\"","solution":"def smallest_palindrome(s: str) -> str: from collections import Counter # Count occurrences of each character: count = Counter(s) # Check for characters with odd count: odd_count_chars = [char for char, cnt in count.items() if cnt % 2 != 0] # If there is more than one character with an odd count, palindrome is not possible: if len(odd_count_chars) > 1: return \\"NO\\" # Characters to form the first half of the palindrome: first_half = [] middle_char = \\"\\" for char in sorted(count.keys()): # Sort characters to ensure lexicographically smallest result cnt = count[char] if cnt % 2 != 0: middle_char = char first_half.append(char * (cnt // 2)) # Form the smallest possible palindrome: first_half_str = ''.join(first_half) second_half_str = first_half_str[::-1] palindrome = first_half_str + middle_char + second_half_str return palindrome"},{"question":"def max_robbery(n, money): Calculate the maximum amount of money that can be robbed without robbing two adjacent houses. :param n: Number of houses :param money: List of amounts of money in each house :return: Maximum amount of money that can be robbed","solution":"def max_robbery(n, money): Calculate the maximum amount of money that can be robbed without robbing two adjacent houses. :param n: Number of houses :param money: List of amounts of money in each house :return: Maximum amount of money that can be robbed if n == 0: return 0 if n == 1: return money[0] dp = [0] * n dp[0] = money[0] if n > 1: dp[1] = max(money[0], money[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + money[i]) return dp[-1]"},{"question":"def max_subarray_sum(arr: List[int]) -> int: Returns the maximum sum of any contiguous subarray. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1, 2, 3]) 6 >>> max_subarray_sum([-4, -2, -4, -3]) -2 pass from max_subarray_sum import max_subarray_sum def test_example_1(): assert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 def test_example_2(): assert max_subarray_sum([1, 2, 3]) == 6 def test_example_3(): assert max_subarray_sum([-4, -2, -4, -3]) == -2 def test_single_element(): assert max_subarray_sum([1]) == 1 assert max_subarray_sum([-1]) == -1 def test_all_negative_elements(): assert max_subarray_sum([-3, -2, -1, -4]) == -1 def test_all_positive_elements(): assert max_subarray_sum([2, 3, 1, 4]) == 10 def test_large_array(): large_array = [i for i in range(1, 1001)] assert max_subarray_sum(large_array) == sum(large_array) def test_mixed_elements(): assert max_subarray_sum([-1, 4, -2, 5, -5]) == 7 def test_zero_in_array(): assert max_subarray_sum([0, -1, 2, 3, -5, 4]) == 5","solution":"def max_subarray_sum(arr): Returns the maximum sum of any contiguous subarray using Kadane's Algorithm. max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def compress_string(s: str) -> str: Compresses the input string \`s\` by abbreviating repeated characters with the character followed by the number of repetitions. >>> compress_string(\\"aaabbccccd\\") == \\"a3b2c4d1\\" >>> compress_string(\\"abc\\") == \\"a1b1c1\\" >>> compress_string(\\"zzzzzzzz\\") == \\"z8\\" >>> compress_string(\\"a\\") == \\"a1\\" >>> compress_string(\\"bbbb\\") == \\"b4\\" >>> compress_string(\\"ababab\\") == \\"a1b1a1b1a1b1\\" >>> compress_string(\\"\\") == \\"\\" >>> compress_string(\\"aaAAaa\\") == \\"a2A2a2\\" pass","solution":"def compress_string(s): Compresses the input string \`s\` by abbreviating repeated characters with the character followed by the number of repetitions. if not s: return \\"\\" compressed = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: compressed.append(f\\"{current_char}{count}\\") current_char = char count = 1 compressed.append(f\\"{current_char}{count}\\") return ''.join(compressed)"},{"question":"def sum_unique_after_removing_min_max(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate the sum of all unique integers in the list after removing minimum and maximum values. Return the sum for each test case. :param test_cases: List of tuples where first element is size of list and second element is the list of integers :return: List of sums as described above >>> sum_unique_after_removing_min_max([(6, [1, 3, 3, 2, 2, 5])]) [5] >>> sum_unique_after_removing_min_max([(4, [7, 7, 7, 7])]) [0] import pytest def test_single_test_case(): test_cases = [ (6, [1, 3, 3, 2, 2, 5]) ] assert sum_unique_after_removing_min_max(test_cases) == [5] def test_all_elements_same(): test_cases = [ (4, [7, 7, 7, 7]) ] assert sum_unique_after_removing_min_max(test_cases) == [0] def test_elements_with_one_repeating_value(): test_cases = [ (5, [1, 1, 1, 2, 2]) ] assert sum_unique_after_removing_min_max(test_cases) == [0] def test_different_elements(): test_cases = [ (7, [1, 2, 3, 4, 5, 6, 7]) ] assert sum_unique_after_removing_min_max(test_cases) == [20] def test_multiple_test_cases(): test_cases = [ (6, [1, 3, 3, 2, 2, 5]), (4, [7, 7, 7, 7]) ] assert sum_unique_after_removing_min_max(test_cases) == [5, 0] def test_edge_case_with_two_elements(): test_cases = [ (2, [1, 2]) ] assert sum_unique_after_removing_min_max(test_cases) == [0]","solution":"def sum_unique_after_removing_min_max(test_cases): results = [] for N, integers in test_cases: if N < 2: results.append(0) continue unique_integers = list(set(integers)) if len(unique_integers) <= 2: results.append(0) continue unique_integers.sort() relevant_integers = unique_integers[1:-1] results.append(sum(relevant_integers)) return results"},{"question":"from typing import List def subsets(arr: List[int]) -> List[List[int]]: Given an array of integers, return all unique subsets (the power set). >>> subsets([1, 2, 2]) [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]] >>> subsets([4, 4, 4, 1]) [[], [1], [1, 4], [1, 4, 4], [1, 4, 4, 4], [4], [4, 4], [4, 4, 4]]","solution":"def subsets(arr): Returns all unique subsets of the array. arr.sort() res = [[]] def backtracking(start, path): for i in range(start, len(arr)): if i > start and arr[i] == arr[i - 1]: continue res.append(path + [arr[i]]) backtracking(i + 1, path + [arr[i]]) backtracking(0, []) return res"},{"question":"def smallest_substring(s: str, queries: List[Tuple[int, int]]) -> List[str]: For each query, finds the lexicographically smallest character in the corresponding substring. >>> smallest_substring(\\"abracadabra\\", [(1, 3), (4, 7), (2, 10)]) ['a', 'a', 'a'] >>> smallest_substring(\\"banana\\", [(1, 6), (2, 4)]) ['a', 'a']","solution":"def smallest_substring(s, queries): For each query, finds the lexicographically smallest character in the corresponding substring. Args: s (str): The original string. queries (list of tuples): List of tuples where each tuple is (l, r) representing a range. Returns: List of lexicographically smallest characters for each query. results = [] for l, r in queries: substring = s[l-1:r] results.append(min(substring)) return results"},{"question":"def min_moves_to_make_elements_equal(lst): Calculates the minimum number of moves required to make all elements in the list equal. >>> min_moves_to_make_elements_equal([1, 2, 3]) 2 >>> min_moves_to_make_elements_equal([1, 3, 7, 9]) 12 >>> min_moves_to_make_elements_equal([10, 10, 10, 10, 10]) 0","solution":"def min_moves_to_make_elements_equal(lst): Calculates the minimum number of moves required to make all elements in the list equal. median = sorted(lst)[len(lst) // 2] return sum(abs(x - median) for x in lst)"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def hasPathSum(root: TreeNode, targetSum: int) -> bool: Determine if the binary tree has a root-to-leaf path sum that equals targetSum. >>> root = TreeNode(5) >>> root.left = TreeNode(4) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(11) >>> root.left.left.left = TreeNode(7) >>> root.left.left.right = TreeNode(2) >>> root.right.left = TreeNode(13) >>> root.right.right = TreeNode(4) >>> root.right.right.right = TreeNode(1) >>> hasPathSum(root, 22) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> hasPathSum(root, 5) False >>> root = TreeNode(1) >>> hasPathSum(root, 1) True >>> root = TreeNode(1) >>> hasPathSum(root, 2) False >>> root = None >>> hasPathSum(root, 0) False >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> hasPathSum(root, 10) True","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def hasPathSum(root: TreeNode, targetSum: int) -> bool: Determine if the binary tree has a root-to-leaf path sum that equals targetSum. if not root: return False # If we reach a leaf node, check if the remaining targetSum equals the leaf's value if not root.left and not root.right: return targetSum == root.val # Recursively check for the path in left and right subtrees targetSum -= root.val return hasPathSum(root.left, targetSum) or hasPathSum(root.right, targetSum)"},{"question":"def distribute_resources(m: int, p: int, tunnels: List[Tuple[int, int]]): This function determines if it is possible to assign resources such that every connected subgraph contains at least two different types of resources. If possible, it returns the assignment. Parameters: m (int): The number of regions. p (int): The number of different resource types. tunnels (list of tuples): Each tuple contains two integers representing the connected regions. Returns: str: \\"Yes\\" if the assignment is possible, \\"No\\" otherwise. list of int: the assignment of resources for each region if possible.","solution":"def distribute_resources(m, p, tunnels): This function determines if it is possible to assign resources such that every connected subgraph contains at least two different types of resources. If possible, it returns the assignment. Parameters: m (int): The number of regions. p (int): The number of different resource types. tunnels (list of tuples): Each tuple contains two integers representing the connected regions. Returns: str: \\"Yes\\" if the assignment is possible, \\"No\\" otherwise. list of int: the assignment of resources for each region if possible. if p == 1: return \\"No\\", [] resources = [0] * m def bfs(start): queue = [start] resources[start] = 1 while queue: current = queue.pop(0) for neighbor in graph[current]: if resources[neighbor] == 0: resources[neighbor] = 1 if resources[current] == 2 else 2 queue.append(neighbor) graph = [[] for _ in range(m)] for a, b in tunnels: graph[a-1].append(b-1) graph[b-1].append(a-1) bfs(0) return \\"Yes\\", resources"},{"question":"def is_safe_to_add(weights, new_weight, max_weight): Returns whether it is safe to add the new participant to the platform. Parameters: weights (list): The list of current weights of participants on the platform. new_weight (int): The weight of the new participant. max_weight (int): The maximum safe weight for the platform. Returns: bool: True if it is safe to add the new participant, False otherwise. Examples: >>> is_safe_to_add([70, 85, 74], 68, 300) True >>> is_safe_to_add([100, 150, 60], 95, 300) False >>> is_safe_to_add([50, 50, 50, 50], 50, 250) True >>> is_safe_to_add([85, 80], 60, 220) False","solution":"def is_safe_to_add(weights, new_weight, max_weight): Returns whether it is safe to add the new participant to the platform. Parameters: weights (list): The list of current weights of participants on the platform. new_weight (int): The weight of the new participant. max_weight (int): The maximum safe weight for the platform. Returns: bool: True if it is safe to add the new participant, False otherwise. current_total_weight = sum(weights) projected_total_weight = current_total_weight + new_weight return projected_total_weight <= max_weight"},{"question":"def min_window(S: str, T: str) -> str: Write a function to determine the smallest window in a string S that contains all characters of string T. If no such window exists, return an empty string. >>> min_window(\\"ADOBECODEBANC\\", \\"ABC\\") \\"BANC\\" >>> min_window(\\"ADOBECODEBANC\\", \\"XYZ\\") \\"\\" >>> min_window(\\"ABCDE\\", \\"ABCDE\\") \\"ABCDE\\" >>> min_window(\\"A\\", \\"A\\") \\"A\\" >>> min_window(\\"ABCD\\", \\"D\\") \\"D\\" >>> min_window(\\"ABCD\\", \\"E\\") \\"\\" >>> min_window(\\"AAABBBCCC\\", \\"ABC\\") \\"ABBBC\\" >>> min_window(\\"AAABBBCBBC\\", \\"ABC\\") \\"ABBBC\\" >>> min_window(\\"\\", \\"ABC\\") \\"\\" >>> min_window(\\"ABC\\", \\"\\") \\"\\"","solution":"def min_window(S, T): from collections import Counter, defaultdict if not S or not T: return \\"\\" t_count = Counter(T) s_count = defaultdict(int) have, need = 0, len(t_count) res, res_len = [-1, -1], float(\\"inf\\") l = 0 for r in range(len(S)): s_count[S[r]] += 1 if S[r] in t_count and s_count[S[r]] == t_count[S[r]]: have += 1 while have == need: if (r - l + 1) < res_len: res = [l, r] res_len = r - l + 1 s_count[S[l]] -= 1 if S[l] in t_count and s_count[S[l]] < t_count[S[l]]: have -= 1 l += 1 l, r = res return S[l:r+1] if res_len != float(\\"inf\\") else \\"\\""},{"question":"def caesar_cipher_encrypt(text: str, shift: int) -> str: Encrypts the given text using Caesar Cipher with the given shift. >>> caesar_cipher_encrypt('HELLO', 3) 'KHOOR' >>> caesar_cipher_encrypt('WORLD', 2) 'YQTNF' pass def caesar_cipher_decrypt(text: str, shift: int) -> str: Decrypts the given text using Caesar Cipher with the given shift. >>> caesar_cipher_decrypt('KHOOR', 3) 'HELLO' >>> caesar_cipher_decrypt('YQTNF', 2) 'WORLD' pass def encrypt_and_decrypt_cases(test_cases: List[Tuple[int, str]]) -> List[Tuple[str, str]]: Encrypts and decrypts a list of test cases using Caesar Cipher. >>> encrypt_and_decrypt_cases([(3, 'HELLO'), (2, 'WORLD')]) [('KHOOR', 'HELLO'), ('YQTNF', 'WORLD')] pass","solution":"def caesar_cipher_encrypt(text, shift): Encrypts the given text using Caesar Cipher with the given shift. result = [] for char in text: if char.isalpha(): shift_amount = shift % 26 if char.islower(): start = ord('a') result.append(chr((ord(char) - start + shift_amount) % 26 + start)) else: start = ord('A') result.append(chr((ord(char) - start + shift_amount) % 26 + start)) else: result.append(char) return ''.join(result) def caesar_cipher_decrypt(text, shift): Decrypts the given text using Caesar Cipher with the given shift. return caesar_cipher_encrypt(text, -shift) def encrypt_and_decrypt_cases(test_cases): results = [] for shift, text in test_cases: encrypted = caesar_cipher_encrypt(text, shift) decrypted = caesar_cipher_decrypt(encrypted, shift) results.append((encrypted, decrypted)) return results"},{"question":"def lexicographically_smallest_string(k: int, s: str) -> str: Returns the lexicographically smallest string obtainable after performing the specified operation exactly k times on string s. Args: k (int): The number of operations to be performed. s (str): The input string. Returns: str: The lexicographically smallest string after k operations. Examples: >>> lexicographically_smallest_string(2, \\"dcba\\") 'abcd' >>> lexicographically_smallest_string(1, \\"dbca\\") 'abcd'","solution":"def lexicographically_smallest_string(k, s): Returns the lexicographically smallest string obtainable after performing the specified operation exactly k times on string s. for _ in range(k): s = ''.join(sorted(s)) return s"},{"question":"def has_pair_with_sum(sequence, target_sum): Determine whether there are two distinct elements in the sequence whose sum is equal to the target sum. :param sequence: List of integers (the sequence of elements) :param target_sum: Integer (the target sum) :return: \\"YES\\" if such a pair exists, otherwise \\"NO\\" pass # Unit tests def test_pair_exists_positive_numbers(): assert has_pair_with_sum([2, 7, 11, 15, 1], 9) == \\"YES\\" def test_pair_exists_negative_numbers(): assert has_pair_with_sum([-1, -2, -3, -4], -6) == \\"YES\\" def test_no_pair(): assert has_pair_with_sum([1, 2, 3, 4], 8) == \\"NO\\" def test_all_same_numbers(): assert has_pair_with_sum([5, 5, 5, 5], 10) == \\"YES\\" assert has_pair_with_sum([5, 5, 5, 5], 9) == \\"NO\\" def test_large_numbers(): assert has_pair_with_sum([1, 1000000000, -1000000000], 0) == \\"YES\\" def test_only_one_element(): assert has_pair_with_sum([1], 1) == \\"NO\\" assert has_pair_with_sum([2], 2) == \\"NO\\" def test_empty_sequence(): assert has_pair_with_sum([], 10) == \\"NO\\"","solution":"def has_pair_with_sum(sequence, target_sum): Determine whether there are two distinct elements in the sequence whose sum is equal to the target sum. :param sequence: List of integers (the sequence of elements) :param target_sum: Integer (the target sum) :return: \\"YES\\" if such a pair exists, otherwise \\"NO\\" seen_numbers = set() for number in sequence: if target_sum - number in seen_numbers: return \\"YES\\" seen_numbers.add(number) return \\"NO\\""},{"question":"def max_pressure_difference(n: int, pressures: List[int], pipelines: List[Tuple[int, int]]) -> int: Returns the maximum absolute difference between pressure readings at any two junctions. :param n: Integer, number of junctions. :param pressures: List of integers, pressure readings at each junction. :param pipelines: List of tuples, each tuple contains two integers indicating junctions connected by pipelines. :return: Integer, the maximum absolute difference between pressure readings. >>> max_pressure_difference(3, [1, 3, 5], [(1, 2), (2, 3)]) 4 >>> max_pressure_difference(4, [10, -5, 6, -8], [(1, 2), (1, 3), (3, 4)]) 18","solution":"def max_pressure_difference(n, pressures, pipelines): Returns the maximum absolute difference between pressure readings at any two junctions. :param n: Integer, number of junctions. :param pressures: List of integers, pressure readings at each junction. :param pipelines: List of tuples, each tuple contains two integers indicating junctions connected by pipelines. :return: Integer, the maximum absolute difference between pressure readings. max_pressure = max(pressures) min_pressure = min(pressures) return abs(max_pressure - min_pressure)"},{"question":"def longest_alternating_subsequence(arr: List[int]) -> int: Given a sequence, find the Longest Alternating Subsequence (LAS). An alternating subsequence is one where elements alternate between increasing and decreasing. Returns the length of the longest such subsequence. >>> longest_alternating_subsequence([1, 5, 4, 3, 5, 3, 2]) 5 >>> longest_alternating_subsequence([10]) 1 >>> longest_alternating_subsequence([1, 2]) 2 >>> longest_alternating_subsequence([2, 1]) 2 >>> longest_alternating_subsequence([3, 3, 3]) 1 >>> longest_alternating_subsequence([1, 2, 3, 4, 5]) 2 >>> longest_alternating_subsequence([5, 4, 3, 2, 1]) 2 >>> longest_alternating_subsequence([10, 20, 10, 30, 20, 50]) 6 from typing import List def test_las_example(): assert longest_alternating_subsequence([1, 5, 4, 3, 5, 3, 2]) == 5 def test_las_single_element(): assert longest_alternating_subsequence([10]) == 1 def test_las_two_elements_increasing(): assert longest_alternating_subsequence([1, 2]) == 2 def test_las_two_elements_decreasing(): assert longest_alternating_subsequence([2, 1]) == 2 def test_las_identical_elements(): assert longest_alternating_subsequence([3, 3, 3]) == 1 def test_las_all_increasing(): assert longest_alternating_subsequence([1, 2, 3, 4, 5]) == 2 def test_las_all_decreasing(): assert longest_alternating_subsequence([5, 4, 3, 2, 1]) == 2 def test_las_complex_case(): assert longest_alternating_subsequence([10, 20, 10, 30, 20, 50]) == 6","solution":"def longest_alternating_subsequence(arr): Given a sequence, find the longest alternating subsequence (LAS). An alternating subsequence is one where elements alternate between increasing and decreasing. Returns the length of the longest such subsequence. n = len(arr) if n == 0: return 0 # Initialize DP arrays up = [1] * n down = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j]: up[i] = max(up[i], down[j] + 1) elif arr[i] < arr[j]: down[i] = max(down[i], up[j] + 1) return max(max(up), max(down)) def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) arr = list(map(int, data[1:N+1])) print(longest_alternating_subsequence(arr)) if __name__ == \\"__main__\\": main()"},{"question":"def shift_char(c, rotation): Shifts a single character by the given rotation value. alpha_start = ord('a') return chr((ord(c) - alpha_start + rotation) % 26 + alpha_start) def encrypt_decrypt(mode, rotation, message): Encrypts or decrypts a message based on the mode and rotation value. :param mode: The mode of the operation, either \\"encrypt\\" or \\"decrypt\\". :param rotation: The number of positions to rotate each character. :param message: The message to be encrypted or decrypted. :return: The resulting encrypted or decrypted message. >>> encrypt_decrypt(\\"encrypt\\", 2, \\"hello\\") 'jgnnq' >>> encrypt_decrypt(\\"decrypt\\", 3, \\"khoor\\") 'hello' >>> encrypt_decrypt(\\"encrypt\\", -1, \\"xyz\\") 'wxy' >>> encrypt_decrypt(\\"decrypt\\", 25, \\"dpef\\") 'code'","solution":"def shift_char(c, rotation): Shifts a single character by the given rotation value. alpha_start = ord('a') new_char = chr((ord(c) - alpha_start + rotation) % 26 + alpha_start) return new_char def encrypt_decrypt(mode, rotation, message): Encrypts or decrypts the given message based on the mode and rotation value. output_message = \\"\\" if mode == \\"decrypt\\": rotation = -rotation # Invert rotation for decryption for char in message: output_message += shift_char(char, rotation) return output_message"},{"question":"def splitArray(arr: List[int], k: int) -> int: Given an array of positive integers \`arr\` and an integer \`k\`, split the array into exactly \`k\` non-empty subarrays such that the largest sum among these subarrays is minimized. >>> splitArray([7, 2, 5, 10, 8], 2) 18 >>> splitArray([1, 2, 3, 4, 5], 2) 9","solution":"def splitArray(arr, k): def can_split(max_sum): current_sum = 0 splits = 1 for num in arr: if current_sum + num > max_sum: splits += 1 current_sum = num if splits > k: return False else: current_sum += num return True left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if can_split(mid): right = mid else: left = mid + 1 return left"},{"question":"def min_cost_to_avoid_consecutive_equal_elements(n: int, arr: List[int]) -> int: Determine the minimum cost to transform the array such that no two consecutive elements are equal. >>> min_cost_to_avoid_consecutive_equal_elements(3, [1, 5, 3]) == 0 >>> min_cost_to_avoid_consecutive_equal_elements(4, [4, 4, 4, 4]) == 3","solution":"def min_cost_to_avoid_consecutive_equal_elements(n, arr): def min_distance(a, cands): return min([abs(a - cand) for cand in cands]) total_cost = 0 for i in range(1, n): if arr[i] == arr[i - 1]: # Set of candidate values: any value other than arr[i-1] cands = [arr[i-1] - 1, arr[i-1] + 1] transformation_cost = min_distance(arr[i], cands) total_cost += transformation_cost return total_cost"},{"question":"def perform_stack_operations(operations): Given a list of operations, perform stack operations and return the results of TOP operations. def process_input(inputs): Process the raw input to execute stack operations and return the results. >>> process_input([ >>> \\"PUSH 5\\", \\"PUSH 10\\", \\"TOP\\", \\"POP\\", \\"TOP\\", >>> \\"END\\", >>> \\"PUSH 20\\", \\"POP\\", \\"TOP\\", >>> \\"END\\", >>> \\"DONE\\" >>> ]) == [10, 5, \\"EMPTY\\"] >>> process_input([ >>> \\"PUSH 1\\", \\"PUSH 2\\", \\"POP\\", \\"TOP\\", >>> \\"END\\", >>> \\"PUSH 2\\", \\"PUSH 3\\", \\"PUSH 4\\", \\"POP\\", \\"POP\\", \\"TOP\\", >>> \\"END\\", >>> \\"DONE\\" >>> ]) == [1, 2] >>> process_input([ >>> \\"PUSH 7\\", \\"TOP\\", >>> \\"END\\", >>> \\"PUSH 11\\", \\"PUSH 12\\", \\"TOP\\", >>> \\"END\\", >>> \\"DONE\\" >>> ]) == [7, 12]","solution":"def perform_stack_operations(operations): Given a list of operations, perform stack operations and return the results of TOP operations. stack = [] result = [] for operation in operations: if operation.startswith('PUSH'): _, x = operation.split() stack.append(int(x)) elif operation == 'POP': if stack: stack.pop() elif operation == 'TOP': if stack: result.append(stack[-1]) else: result.append(\\"EMPTY\\") return result def process_input(inputs): Process the raw input to execute stack operations and return the results. operations = [] results = [] for line in inputs: if line == \\"DONE\\": break elif line == \\"END\\": results.extend(perform_stack_operations(operations)) operations = [] else: operations.append(line) return results"},{"question":"from typing import List def rotate_matrix_90_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotate the given n x n matrix 90 degrees clockwise. >>> rotate_matrix_90_clockwise([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] pass def rotate_matrix_k_times(matrix: List[List[int]], k: int) -> List[List[int]]: Rotate the given n x n matrix k times 90 degrees clockwise. >>> rotate_matrix_k_times([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ], 2) [[9, 8, 7], [6, 5, 4], [3, 2, 1]] pass def process_test_case(n: int, k: int, matrix: List[List[int]]) -> List[List[int]]: Process a single test case and return the resulting matrix after k rotations. >>> process_test_case(3, 1, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] pass","solution":"def rotate_matrix_90_clockwise(matrix): Rotate the given n x n matrix 90 degrees clockwise. n = len(matrix) new_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): new_matrix[j][n - i - 1] = matrix[i][j] return new_matrix def rotate_matrix_k_times(matrix, k): Rotate the given n x n matrix k times 90 degrees clockwise. k = k % 4 # Since rotating 4 times results in the same matrix for _ in range(k): matrix = rotate_matrix_90_clockwise(matrix) return matrix def process_test_case(n, k, matrix): Process a single test case and return the resulting matrix after k rotations. return rotate_matrix_k_times(matrix, k)"},{"question":"def minimum_moves_to_organize(N: int, current_sections: List[int], target_sections: List[int]) -> int: Determines the minimum number of moves needed to organize items in a warehouse from their current sections to the target sections. Args: N (int): Number of items. current_sections (list): List of integers representing the current section of each item. target_sections (list): List of integers representing the target section of each item. Returns: int: Minimum number of moves needed to organize the items. Example: >>> minimum_moves_to_organize(4, [1, 2, 3, 4], [4, 3, 2, 1]) 4 >>> minimum_moves_to_organize(5, [1, 1, 1, 2, 2], [2, 2, 2, 1, 1]) 5 >>> minimum_moves_to_organize(3, [1, 2, 3], [1, 2, 3]) 0 from solution import minimum_moves_to_organize def test_no_moves_needed(): assert minimum_moves_to_organize(3, [1, 2, 3], [1, 2, 3]) == 0 def test_all_items_reverse_order(): assert minimum_moves_to_organize(4, [1, 2, 3, 4], [4, 3, 2, 1]) == 4 def test_mixed_moves_needed(): assert minimum_moves_to_organize(5, [1, 1, 1, 2, 2], [2, 2, 2, 1, 1]) == 5 def test_alternating_sections(): assert minimum_moves_to_organize(4, [1, 2, 1, 2], [2, 1, 2, 1]) == 4 def test_no_sections_difference(): assert minimum_moves_to_organize(5, [1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) == 0","solution":"def minimum_moves_to_organize(N, current_sections, target_sections): Determines the minimum number of moves needed to organize items in a warehouse from their current sections to the target sections. Args: N (int): Number of items. current_sections (list): List of integers representing the current section of each item. target_sections (list): List of integers representing the target section of each item. Returns: int: Minimum number of moves needed to organize the items. move_count = 0 for i in range(N): if current_sections[i] != target_sections[i]: move_count += 1 return move_count"},{"question":"def simulate_bank_account_system(input_data): Simulate the bank account system based on the input data. >>> simulate_bank_account_system([ ... \\"1\\", \\"5\\", ... \\"deposit 1 1000\\", ... \\"balance 1\\", ... \\"withdraw 1 500\\", ... \\"balance 1\\", ... \\"transfer 1 2 300\\" ... ]) == [1000, 500] >>> simulate_bank_account_system([ ... \\"1\\", \\"3\\", ... \\"deposit 1 100\\", ... \\"withdraw 1 200\\", ... \\"balance 1\\" ... ]) == [100] >>> simulate_bank_account_system([ ... \\"1\\", \\"4\\", ... \\"deposit 1 100\\", ... \\"transfer 1 2 200\\", ... \\"balance 1\\", ... \\"balance 2\\" ... ]) == [100, 0] >>> simulate_bank_account_system([ ... \\"1\\", \\"1\\", ... \\"balance 1\\" ... ]) == [0] >>> simulate_bank_account_system([ ... \\"2\\", ... \\"5\\", ... \\"deposit 1 1000\\", ... \\"balance 1\\", ... \\"withdraw 1 500\\", ... \\"balance 1\\", ... \\"transfer 1 2 300\\", ... \\"3\\", ... \\"deposit 3 200\\", ... \\"withdraw 3 150\\", ... \\"balance 3\\" ... ]) == [1000, 500, 50]","solution":"def simulate_bank_account_system(input_data): Simulate the bank account system based on the input data. T = int(input_data[0]) index = 1 results = [] for _ in range(T): N = int(input_data[index]) index += 1 accounts = {} for _ in range(N): operation = input_data[index].split() index += 1 action = operation[0] if action == \\"deposit\\": account, amount = int(operation[1]), int(operation[2]) if account not in accounts: accounts[account] = 0 accounts[account] += amount elif action == \\"withdraw\\": account, amount = int(operation[1]), int(operation[2]) if account in accounts and accounts[account] >= amount: accounts[account] -= amount elif action == \\"balance\\": account = int(operation[1]) balance = accounts.get(account, 0) results.append(balance) elif action == \\"transfer\\": from_account, to_account, amount = int(operation[1]), int(operation[2]), int(operation[3]) if from_account in accounts and accounts[from_account] >= amount: if to_account not in accounts: accounts[to_account] = 0 accounts[from_account] -= amount accounts[to_account] += amount return results # Example usage: # input_data = [ # \\"2\\", # \\"5\\", # \\"deposit 1 1000\\", # \\"balance 1\\", # \\"withdraw 1 500\\", # \\"balance 1\\", # \\"transfer 1 2 300\\", # \\"3\\", # \\"deposit 3 200\\", # \\"withdraw 3 150\\", # \\"balance 3\\" # ] # print(simulate_bank_account_system(input_data)) # Output: [1000, 500, 50]"},{"question":"def sieve(n): Generate a list of prime numbers up to \`n\`. is_prime = [True] * (n + 1) p = 2 while (p * p <= n): if (is_prime[p] == True): for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 prime_numbers = [] for p in range(2, n + 1): if is_prime[p]: prime_numbers.append(p) return prime_numbers def can_be_sum_of_two_primes(N, primes_set): Check if the given number N can be represented as a sum of two prime numbers. for prime in primes_set: if prime > N: break if (N - prime) in primes_set: return \\"YES\\" return \\"NO\\" def process_input(T, cases): Process the input and return results for each test case. max_value = max(cases) primes = sieve(max_value) primes_set = set(primes) results = [] for N in cases: results.append(can_be_sum_of_two_primes(N, primes_set)) return results # Reading inputs (For testing purpose only - real use should use input()) def read_input(): T = int(input().strip()) cases = [int(input().strip()) for _ in range(T)] return T, cases def main(): T, cases = read_input() results = process_input(T, cases) for result in results: print(result) if __name__ == \\"__main__\\": main()","solution":"def sieve(n): Generate a list of prime numbers up to \`n\`. is_prime = [True] * (n + 1) p = 2 while (p * p <= n): if (is_prime[p] == True): for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 prime_numbers = [] for p in range(2, n + 1): if is_prime[p]: prime_numbers.append(p) return prime_numbers def can_be_sum_of_two_primes(N, primes_set): Check if the given number N can be represented as a sum of two prime numbers. for prime in primes_set: if prime > N: break if (N - prime) in primes_set: return \\"YES\\" return \\"NO\\" def process_input(T, cases): Process the input and return results for each test case. max_value = max(cases) primes = sieve(max_value) primes_set = set(primes) results = [] for N in cases: results.append(can_be_sum_of_two_primes(N, primes_set)) return results # Reading inputs (For testing purpose only - real use should use input()) def read_input(): T = int(input().strip()) cases = [int(input().strip()) for _ in range(T)] return T, cases def main(): T, cases = read_input() results = process_input(T, cases) for result in results: print(result)"},{"question":"def classify_emails(k: int, t: int, keywords_scores: List[Tuple[str, int]], e: int, emails: List[str]) -> List[str]: Classify emails as 'spam' or 'non-spam' based on keyword spam scores. >>> classify_emails(3, 10, [('free', 5), ('offer', 3), ('cheap', 7)], 2, ['this is a free offer', 'get cheap deals now']) ['non-spam', 'non-spam'] >>> classify_emails(2, 15, [('hello', 3), ('world', 2)], 1, ['hello world this email is not spam']) ['non-spam']","solution":"def classify_emails(k, t, keywords_scores, e, emails): # Create a dictionary to hold keywords and their corresponding spam scores keyword_dict = {keyword_score[0]: int(keyword_score[1]) for keyword_score in keywords_scores} results = [] for email in emails: email_words = email.split() spam_score = sum(keyword_dict.get(word, 0) for word in email_words) results.append(\\"spam\\" if spam_score >= t else \\"non-spam\\") return results"},{"question":"def min_removals_to_avoid_adjacent_duplicates(s: str, k: int) -> int: Determine the minimum number of characters to be removed from the string so that no two adjacent characters are the same. >>> min_removals_to_avoid_adjacent_duplicates(\\"aaaabb\\", 2) 2 >>> min_removals_to_avoid_adjacent_duplicates(\\"abcbca\\", 3) 0","solution":"def min_removals_to_avoid_adjacent_duplicates(s, k): removals = 0 i = 0 while i < len(s): count = 1 while i + 1 < len(s) and s[i] == s[i + 1]: count += 1 i += 1 if count > k: removals += count - k i += 1 return removals"},{"question":"def reorder_students(n, original_sequence, m, interactions): Reorder the student IDs such that as many students as possible from the interaction set remain in their original positions while keeping the sequence sorted in non-decreasing order by student ID. Params: n (int): number of students original_sequence (list of int): list of student IDs in their original order m (int): number of interacting students interactions (list of int): the student IDs involved in interactions Returns: list of int: the reordered list of student IDs Examples: >>> reorder_students(6, [3, 1, 4, 5, 2, 6], 3, [4, 1, 2]) [1, 2, 3, 4, 5, 6] >>> reorder_students(5, [5, 3, 4, 1, 2], 2, [2, 5]) [1, 2, 3, 4, 5]","solution":"def reorder_students(n, original_sequence, m, interactions): Reorder the student IDs such that as many students as possible from the interaction set remain in their original positions while keeping the sequence sorted in non-decreasing order by student ID. Params: n (int): number of students original_sequence (list of int): list of student IDs in their original order m (int): number of interacting students interactions (list of int): the student IDs involved in interactions Returns: list of int: the reordered list of student IDs sorted_sequence = sorted(original_sequence) result = sorted_sequence[:] for idx, student_id in enumerate(original_sequence): if student_id in interactions: sorted_index = sorted_sequence.index(student_id) result[sorted_index] = student_id return result"},{"question":"def tallest_castle(n: int, blocks: List[int]) -> int: Returns the maximum number of floors that can be achieved while fulfilling the constraints. Parameters: - n (int): number of different sizes of blocks. - blocks (list of int): heights of the blocks in increasing order of size. Returns: - int: maximum number of floors. Example: >>> tallest_castle(6, [1, 3, 2, 5, 4, 7]) 4 >>> tallest_castle(5, [1, 2, 3, 4, 5]) 5 >>> tallest_castle(5, [5, 4, 3, 2, 1]) 1 >>> tallest_castle(1, [10]) 1 >>> tallest_castle(2, [1, 2]) 2 >>> tallest_castle(2, [2, 1]) 1 >>> tallest_castle(10, [1, 2, 2, 3, 4, 4, 5, 6, 6, 7]) 7","solution":"def tallest_castle(n, blocks): Returns the maximum number of floors that can be achieved while fulfilling the constraints. Parameters: - n (int): number of different sizes of blocks. - blocks (list of int): heights of the blocks in increasing order of size. Returns: - int: maximum number of floors. if n == 0: return 0 max_floors = 1 current_height = blocks[0] for i in range(1, n): if blocks[i] > current_height: max_floors += 1 current_height = blocks[i] return max_floors"},{"question":"def distinct_paths(grid, n, m): Determine the number of distinct paths from the top-left corner to the bottom-right corner of a grid, avoiding traps. >>> parse_input(\\"3 3n. . .n. T .n. . .\\") ([['.', '.', '.'], ['.', 'T', '.'], ['.', '.', '.']], 3, 3) >>> distinct_paths([['.', '.', '.'], ['.', 'T', '.'], ['.', '.', '.']], 3, 3) 2 >>> parse_input(\\"2 3n. T .n. . .\\") ([['.', 'T', '.'], ['.', '.', '.']], 2, 3) >>> distinct_paths([['.', 'T', '.'], ['.', '.', '.']], 2, 3) 1 def parse_input(input_str): Parse a string input into a grid and its dimensions. >>> parse_input(\\"3 3n. . .n. T .n. . .\\") ([['.', '.', '.'], ['.', 'T', '.'], ['.', '.', '.']], 3, 3)","solution":"def distinct_paths(grid, n, m): # Using dynamic programming to calculate the number of distinct paths if grid[0][0] == 'T' or grid[n-1][m-1] == 'T': return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == 'T': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1] # Parsing input for testing def parse_input(input_str): lines = input_str.strip().split('n') n, m = map(int, lines[0].split()) grid = [line.split() for line in lines[1:]] return grid, n, m"},{"question":"def optimal_schedule(n: int, talks: List[Tuple[int,int]]) -> Tuple[int, List[int]]: Determine the optimal schedule for maximum number of non-overlapping talks. Args: n (int): Number of talks talks List[Tuple[int,int]]: List of tuples where each tuple contains start and end time of the talk. Returns: Tuple[int, List[int]]: The number of non-overlapping talks and the indices of the selected talks. >>> optimal_schedule(5, [(1, 3), (2, 5), (4, 7), (6, 9), (8, 10)]) (3, [1, 3, 5]) >>> optimal_schedule(4, [(1, 2), (3, 4), (0, 6), (5, 7)]) (3, [1, 2, 4]) from solution import optimal_schedule def test_optimal_schedule_example_1(): n = 5 talks = [(1, 3), (2, 5), (4, 7), (6, 9), (8, 10)] count, selected_talks = optimal_schedule(n, talks) assert count == 3 assert len(selected_talks) == 3 assert set(selected_talks).issubset({1, 3, 5}) def test_optimal_schedule_example_2(): n = 4 talks = [(1, 2), (3, 4), (0, 6), (5, 7)] count, selected_talks = optimal_schedule(n, talks) assert count == 3 assert len(selected_talks) == 3 # Multiple solutions possible: {1, 2, 4} or {1, 3, 4} assert set(selected_talks) == {1, 2, 4} or set(selected_talks) == {1, 3, 4} def test_optimal_schedule_non_overlapping(): n = 3 talks = [(1, 5), (5, 10), (10, 15)] count, selected_talks = optimal_schedule(n, talks) assert count == 3 assert set(selected_talks) == {1, 2, 3} def test_optimal_schedule_no_overlap(): n = 2 talks = [(1, 4), (5, 8)] count, selected_talks = optimal_schedule(n, talks) assert count == 2 assert set(selected_talks) == {1, 2} def test_optimal_schedule_all_overlap(): n = 4 talks = [(1, 5), (2, 6), (3, 7), (4, 8)] count, selected_talks = optimal_schedule(n, talks) assert count == 1 assert len(selected_talks) == 1 assert selected_talks[0] in {1, 2, 3, 4}","solution":"def optimal_schedule(n, talks): sorted_talks = sorted(enumerate(talks, 1), key=lambda x: x[1][1]) count = 0 last_end_time = 0 selected_talks = [] for index, talk in sorted_talks: if talk[0] >= last_end_time: selected_talks.append(index) last_end_time = talk[1] count += 1 return count, selected_talks"},{"question":"from typing import List def can_set_rps(L: int, U: int, T: int) -> str: Determine if it is possible to set the rotations per second of three gears such that their combined rotations per second is exactly T, with each gear's RPS in the range [L, U]. >>> can_set_rps(1, 5, 9) == \\"YES\\" >>> can_set_rps(0, 3, 6) == \\"YES\\" >>> can_set_rps(2, 7, 22) == \\"NO\\" def process_data(data: str) -> List[str]: Process multiple datasets and determine the gear RPS feasibility for each. Args: data (str): Multiline string with each line containing L, U, and T values. Returns: list: A list of responses (\\"YES\\" or \\"NO\\") for each dataset. >>> process_data(\\"1 5 9n0 3 6n2 7 22n0 0 0\\") == [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def can_set_rps(L, U, T): Determine if it is possible to set the rotations per second of three gears such that their combined rotations per second is exactly T, with each gear's RPS in the range [L, U]. for i in range(L, U+1): for j in range(L, U+1): for k in range(L, U+1): if i + j + k == T: return \\"YES\\" return \\"NO\\" def process_data(data): Process multiple datasets and determine the gear RPS feasibility for each. Args: data (str): Multiline string with each line containing L, U, and T values. Returns: list: A list of responses (\\"YES\\" or \\"NO\\") for each dataset. lines = data.strip().split('n') results = [] for line in lines: L, U, T = map(int, line.split()) if L == 0 and U == 0 and T == 0: break results.append(can_set_rps(L, U, T)) return results"},{"question":"def repeat_characters(s: str) -> str: Returns a new string where each character from the original string is repeated twice. >>> repeat_characters(\\"hello\\") 'hheelllloo' >>> repeat_characters(\\"programming\\") 'pprrooggrraammmmiinngg' >>> repeat_characters(\\"a\\") 'aa'","solution":"def repeat_characters(s): Returns a new string where each character from the original string is repeated twice. result = [] for char in s: result.append(char) result.append(char) return ''.join(result)"},{"question":"def max_tents(grid: List[List[str]]) -> int: Determine the maximum number of tents that can be placed in the grid while adhering to the rule. >>> max_tents([['.', '#', '.'], ['.', '.', '.'], ['#', '.', '.']]) 4 >>> max_tents([['.', '.', '#', '.'], ['#', '.', '#', '.'], ['.', '.', '#', '.'], ['.', '#', '.', '.']]) 6 def read_grid(input_str: str) -> List[List[str]]: Convert input string to grid. >>> read_grid(\\"3n.#.n...n#..n\\") [['.', '#', '.'], ['.', '.', '.'], ['#', '.', '.']] >>> read_grid(\\"4n..#.n#.#.n..#.n.#..n\\") [['.', '.', '#', '.'], ['#', '.', '#', '.'], ['.', '.', '#', '.'], ['.', '#', '.', '.']] from max_tents import max_tents, read_grid def test_example_1(): input_str = \\"3n.#.n...n#..n\\" grid = read_grid(input_str) assert max_tents(grid) == 4 def test_example_2(): input_str = \\"4n..#.n#.#.n..#.n.#..n\\" grid = read_grid(input_str) assert max_tents(grid) == 6 def test_empty_grid(): input_str = \\"2n..n..n\\" grid = read_grid(input_str) assert max_tents(grid) == 2 def test_full_buildings(): input_str = \\"2nnn\\" grid = read_grid(input_str) assert max_tents(grid) == 0 def test_single_cell(): input_str = \\"1n.n\\" grid = read_grid(input_str) assert max_tents(grid) == 1 def test_single_building(): input_str = \\"1n#n\\" grid = read_grid(input_str) assert max_tents(grid) == 0","solution":"def max_tents(grid): n = len(grid) tents_placed = 0 for i in range(n): for j in range(n): if grid[i][j] == '.': # Check if placing a tent here is safe (no adjacent tents) if (i > 0 and grid[i - 1][j] == 'T') or (i < n - 1 and grid[i + 1][j] == 'T') or (j > 0 and grid[i][j - 1] == 'T') or (j < n - 1 and grid[i][j + 1] == 'T'): continue # Place tent at grid[i][j] grid[i][j] = 'T' tents_placed += 1 return tents_placed def read_grid(input_str): lines = input_str.strip().split(\\"n\\") n = int(lines[0]) grid = [list(line) for line in lines[1:]] return grid"},{"question":"def max_non_overlapping_lectures(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Determine the maximum number of non-overlapping lectures that can be scheduled in a single classroom for each test case. :param t: Number of test cases :param test_cases: List of test cases, where each test case is a tuple containing the number of lectures and a list of tuples representing the start and end times of each lecture. :return: List of maximum number of non-overlapping lectures for each test case. Example: >>> max_non_overlapping_lectures(2, [(3, [(1, 2), (3, 4), (0, 6)]), (4, [(10, 20), (12, 25), (20, 30), (25, 35)])]) [2, 2] >>> max_non_overlapping_lectures(1, [(3, [(1, 4), (2, 5), (3, 6)])]) [1]","solution":"def max_non_overlapping_lectures(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] lectures = test_cases[i][1] # Sort lectures by end time lectures.sort(key=lambda x: x[1]) count = 0 last_end_time = -1 # Iterate through each lecture and count non-overlapping lectures for start, end in lectures: if start >= last_end_time: count += 1 last_end_time = end results.append(count) return results"},{"question":"def shortest_balanced_substring(n: int, s: str) -> int: Alicia has a string consisting of n characters, each character being either 'a', 'b', or 'c'. Alicia wants to create a balanced substring where the substring contains exactly one 'a', one 'b', and one 'c'. She wants to find the length of the shortest possible substring that is balanced. If there are no balanced substrings, return -1. >>> shortest_balanced_substring(7, \\"abcacbc\\") 3 >>> shortest_balanced_substring(5, \\"aaaaa\\") -1 >>> shortest_balanced_substring(10, \\"abacbabcbc\\") 3 # Unit Tests def test_example_1(): assert shortest_balanced_substring(7, \\"abcacbc\\") == 3 def test_example_2(): assert shortest_balanced_substring(5, \\"aaaaa\\") == -1 def test_example_3(): assert shortest_balanced_substring(10, \\"abacbabcbc\\") == 3 def test_no_balanced_substring(): assert shortest_balanced_substring(5, \\"bbbbb\\") == -1 def test_all_characters_same(): assert shortest_balanced_substring(4, \\"cccc\\") == -1 def test_minimum_balanced_substring(): assert shortest_balanced_substring(3, \\"abc\\") == 3 def test_early_balanced_substring(): assert shortest_balanced_substring(6, \\"abcabc\\") == 3","solution":"def shortest_balanced_substring(n, s): min_length = float('inf') for i in range(n): a_count, b_count, c_count = 0, 0, 0 for j in range(i, n): if s[j] == 'a': a_count += 1 elif s[j] == 'b': b_count += 1 elif s[j] == 'c': c_count += 1 if a_count >= 1 and b_count >= 1 and c_count >= 1: min_length = min(min_length, j - i + 1) break return min_length if min_length != float('inf') else -1"},{"question":"def shortest_k_distinct_substring(s: str, k: int) -> int: Find the length of the shortest substring that contains at least k different characters. If no such substring exists, return -1. >>> shortest_k_distinct_substring(\\"aabcdefff\\", 3) 3 >>> shortest_k_distinct_substring(\\"abcdef\\", 6) 6 >>> shortest_k_distinct_substring(\\"aaa\\", 2) -1","solution":"def shortest_k_distinct_substring(s: str, k: int) -> int: Finds the length of the shortest substring that contains at least k different characters. If no such substring exists, return -1. from collections import defaultdict n = len(s) if k > n: return -1 char_count = defaultdict(int) left = 0 min_length = float('inf') unique_count = 0 for right in range(n): if char_count[s[right]] == 0: unique_count += 1 char_count[s[right]] += 1 while unique_count >= k: min_length = min(min_length, right - left + 1) char_count[s[left]] -= 1 if char_count[s[left]] == 0: unique_count -= 1 left += 1 return min_length if min_length != float('inf') else -1"},{"question":"def is_well_formed_list(s: str) -> str: Determines if a given input string is a well-formed list. >>> is_well_formed_list(\\"- Item1n- Item2n- Item3\\") \\"YES\\" >>> is_well_formed_list(\\"- Item1 - Item2n- Item3\\") \\"NO\\" >>> is_well_formed_list(\\"- Item1nn- Item2n- Item3\\") \\"NO\\" >>> is_well_formed_list(\\"- Item1n - Item2n- Item3\\") \\"NO\\" >>> is_well_formed_list(\\"- Item1\\") \\"YES\\" >>> is_well_formed_list(\\"\\") \\"NO\\" >>> is_well_formed_list(\\"- Item1n- Item2\\") \\"YES\\" >>> is_well_formed_list(\\"- Item1n-Item2n- Item3\\") \\"NO\\" >>> is_well_formed_list(\\"-Item1n- Item2\\") \\"NO\\" pass def process_input(T: int, lines: List[str]) -> List[str]: Processes the input lines and gives YES/NO for each one based on the well-formed list criteria. :param T: Number of test cases. :param lines: List of strings to be checked. :return: List of results for each input string. pass def main(): import sys input = sys.stdin.read data = input().splitlines() T = int(data[0]) lines = data[1:T + 1] results = process_input(T, lines) for result in results: print(result) if __name__ == \\"__main__\\": main()","solution":"def is_well_formed_list(s): Determines if a given input string is a well-formed list. :param s: Input string to be checked. :return: \\"YES\\" if the string is a well-formed list, or \\"NO\\" otherwise. items = s.split(\\"n\\") for item in items: if not item.startswith(\\"- \\"): return \\"NO\\" if item.count(\\"- \\") > 1: return \\"NO\\" return \\"YES\\" def process_input(T, lines): Processes the input lines and gives YES/NO for each one based on the well-formed list criteria. :param T: Number of test cases. :param lines: List of strings to be checked. :return: List of results for each input string. results = [] for i in range(T): results.append(is_well_formed_list(lines[i])) return results"},{"question":"def classify_review(review_text: str) -> int: Classify the sentiment of a given review text. Sentiments are represented by integers: 1 for positive, 2 for neutral, and 3 for negative. >>> classify_review(\\"Great product, very helpful!\\") 1 >>> classify_review(\\"The product is okay, but could be improved.\\") 2 >>> classify_review(\\"Terrible experience, not recommended.\\") 3 >>> classify_review(\\"The product was okay but had some bad points.\\") 2 or 3","solution":"import re from collections import defaultdict def load_training_data(): # This is a placeholder implementation to represent loading the training data. training_data = defaultdict(list) # Simulating loading data (you would replace this with actual file reading logic) training_data[1].append(\\"Great product, very helpful!\\") training_data[2].append(\\"The product is okay, but could be improved.\\") training_data[3].append(\\"Terrible experience, not recommended.\\") return training_data def classify_review(review_text): training_data = load_training_data() sentiments = [1, 2, 3] similarities = [] review_tokens = set(re.findall(r'w+', review_text.lower())) for sentiment in sentiments: max_similarity = 0 for training_review in training_data[sentiment]: training_tokens = set(re.findall(r'w+', training_review.lower())) # Calculate Jaccard similarity intersection = review_tokens.intersection(training_tokens) union = review_tokens.union(training_tokens) similarity = len(intersection) / len(union) if union else 0 max_similarity = max(max_similarity, similarity) similarities.append((max_similarity, sentiment)) # Return the sentiment with the highest similarity return max(similarities)[1]"},{"question":"from typing import List def min_boxes_needed(colors: List[int]) -> int: Returns the minimum number of boxes needed to consolidate all marbles such that no two boxes have marbles of the same color. >>> min_boxes_needed([1, 2, 2, 3, 3, 3]) 3 >>> min_boxes_needed([]) 0 >>> min_boxes_needed([1, 1, 1, 1]) 1 >>> min_boxes_needed([1, 2, 3, 4, 5]) 5 >>> min_boxes_needed([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) 7","solution":"from typing import List def min_boxes_needed(colors: List[int]) -> int: Returns the minimum number of boxes needed to consolidate all marbles such that no two boxes have marbles of the same color. # Use a set to find the unique number of colors unique_colors = set(colors) # The number of unique colors corresponds to the minimum number of boxes needed return len(unique_colors)"},{"question":"def find_tournament_winner(n, m, matches): Determine the unique winner of a chess tournament. Args: n (int): The number of players. m (int): The number of matches. matches (List[Tuple[int, int]]): A list of match results where each element (a, b) indicates player \`a\` won against player \`b\`. Returns: int: The ID of the player who won the tournament. Examples: >>> find_tournament_winner(4, 5, [(1, 2), (2, 3), (1, 3), (2, 4), (1, 4)]) 1 >>> find_tournament_winner(3, 4, [(1, 2), (3, 1), (2, 3), (3, 2)]) 3 from solution import find_tournament_winner def test_example1(): n = 4 m = 5 matches = [ (1, 2), (2, 3), (1, 3), (2, 4), (1, 4) ] assert find_tournament_winner(n, m, matches) == 1 def test_example2(): n = 3 m = 4 matches = [ (1, 2), (3, 1), (2, 3), (3, 2) ] assert find_tournament_winner(n, m, matches) == 3 def test_single_match(): n = 2 m = 1 matches = [ (1, 2) ] assert find_tournament_winner(n, m, matches) == 1 def test_all_players_win_once(): n = 3 m = 3 matches = [ (1, 2), (2, 3), (3, 1) ] assert find_tournament_winner(n, m, matches) == 1 def test_players_with_same_win_count(): n = 5 m = 6 matches = [ (1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (1, 3) ] assert find_tournament_winner(n, m, matches) == 1 def test_large_number_of_matches(): import random n = 1000 m = 10**6 matches = [(random.randint(1, n), random.randint(1, n)) for _ in range(m)] assert 1 <= find_tournament_winner(n, m, matches) <= n def test_unequal_wins(): n = 4 m = 6 matches = [ (1, 2), (1, 3), (1, 4), (2, 3), (3, 4), (4, 2), ] assert find_tournament_winner(n, m, matches) == 1","solution":"def find_tournament_winner(n, m, matches): win_count = [0] * (n + 1) for a, b in matches: win_count[a] += 1 winner = 1 for player in range(2, n + 1): if win_count[player] > win_count[winner] or (win_count[player] == win_count[winner] and player < winner): winner = player return winner"},{"question":"def max_challenges_to_complete(n: int, T: int, challenges: List[Tuple[int, int]]) -> int: Determine the maximum number of challenges Ken can complete without exceeding his available time. Parameters: n (int): number of challenges T (int): total free hours Ken has challenges (list of tuple): each tuple contains points and time required for a challenge Returns: int: maximum number of challenges that Ken can complete >>> max_challenges_to_complete(4, 10, [(500, 3), (300, 5), (400, 2), (200, 4)]) 3 >>> max_challenges_to_complete(5, 7, [(200, 4), (100, 2), (300, 2), (250, 3), (150, 3)]) 3 pass","solution":"def max_challenges_to_complete(n, T, challenges): Determine the maximum number of challenges Ken can complete without exceeding his available time. Parameters: n (int): number of challenges T (int): total free hours Ken has challenges (list of tuple): each tuple contains points and time required for a challenge Returns: int: maximum number of challenges that Ken can complete # Sort challenges by the time required to complete them (ascending) challenges.sort(key=lambda x: x[1]) time_spent = 0 challenges_completed = 0 for points, time in challenges: if time_spent + time <= T: time_spent += time challenges_completed += 1 else: break return challenges_completed # Example usage: n = 4 T = 10 challenges = [(500, 3), (300, 5), (400, 2), (200, 4)] print(max_challenges_to_complete(n, T, challenges)) # Output: 3"},{"question":"def subarray_sum_exists(test_cases): Given an array of integers, determine whether there's a contiguous subarray that sums up to a given target number. Args: test_cases: List of dictionaries, where each dictionary represents a test case with 'NK' as a tuple of (N, K) and 'array' as the list of integers. Returns: A list of strings, where each string is \\"Yes\\" if there exists such a subarray, otherwise \\"No\\". >>> subarray_sum_exists([ ... {'NK': (5, 15), 'array': [1, 2, 3, 7, 5]}, ... {'NK': (4, 8), 'array': [1, 2, 4, 4]} ... ]) [\\"Yes\\", \\"Yes\\"] >>> subarray_sum_exists([ ... {'NK': (5, 20), 'array': [1, 2, 3, 7, 5]} ... ]) [\\"No\\"] # Implement your code here","solution":"def subarray_sum_exists(test_cases): results = [] for test_case in test_cases: N, K = test_case['NK'] array = test_case['array'] if has_subarray_with_sum(array, K): results.append(\\"Yes\\") else: results.append(\\"No\\") return results def has_subarray_with_sum(array, target_sum): current_sum = 0 sum_map = {} for i in range(len(array)): current_sum += array[i] if current_sum == target_sum: return True if (current_sum - target_sum) in sum_map: return True sum_map[current_sum] = i return False"},{"question":"def max_nut_pieces(n: int, m: int, grid: List[List[int]]) -> int: Return the maximum number of pieces with nuts by making horizontal and vertical cuts. n: Number of rows m: Number of columns grid: 2D list representing the chocolate bar grid (1 for nut, 0 for plain) >>> max_nut_pieces(3, 3, [ ... [1, 0, 1], ... [0, 1, 0], ... [1, 1, 1] ... ]) == 6 >>> max_nut_pieces(2, 2, [ ... [1, 0], ... [0, 1] ... ]) == 2 >>> max_nut_pieces(3, 3, [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 9 >>> max_nut_pieces(2, 2, [ ... [0, 0], ... [0, 0] ... ]) == 0 >>> max_nut_pieces(4, 4, [ ... [1, 0, 1, 0], ... [0, 1, 0, 1], ... [1, 0, 1, 0], ... [0, 1, 0, 1] ... ]) == 8","solution":"def max_nut_pieces(n, m, grid): Return the maximum number of pieces with nuts by making horizontal and vertical cuts. n: Number of rows m: Number of columns grid: 2D list representing the chocolate bar grid (1 for nut, 0 for plain) num_pieces_with_nuts = 0 # Check horizontally cut pieces for row in grid: num_pieces_with_nuts += sum(row) return num_pieces_with_nuts"},{"question":"def reconstruct_magic_square(square: List[List[int]]) -> Union[List[List[int]], int]: Reconstruct the original 3x3 magic square if possible. If there is exactly one way to reconstruct the magic square, return a completed 3x3 magic square. Otherwise, return -1. >>> reconstruct_magic_square([ ... [8, 0, 0], ... [0, 5, 0], ... [0, 0, 2] ... ]) [[8, 1, 6], [3, 5, 7], [4, 9, 2]] >>> reconstruct_magic_square([ ... [8, 8, 8], ... [8, 8, 8], ... [8, 8, 8] ... ]) -1 >>> reconstruct_magic_square([ ... [8, 1, 6], ... [3, 5, 7], ... [4, 9, 2] ... ]) [[8, 1, 6], [3, 5, 7], [4, 9, 2]] >>> reconstruct_magic_square([ ... [2, 7, 6], ... [9, 5, 1], ... [4, 3, 0] ... ]) [[2, 7, 6], [9, 5, 1], [4, 3, 8]]","solution":"import itertools def is_magic(square): magic_sum = 15 # Every row, column, and diagonal must sum to 15 in a 3x3 magic square where numbers 1-9 are used. rows = square cols = [[square[row][col] for row in range(3)] for col in range(3)] diags = [[square[i][i] for i in range(3)], [square[i][2-i] for i in range(3)]] for line in rows + cols + diags: if sum(line) != magic_sum: return False return True def reconstruct_magic_square(square): # All potential valid numbers for magic square possible_numbers = set(range(1, 10)) # Determine which numbers are missing missing_numbers = possible_numbers - set([num for row in square for num in row if num != 0]) # Determine the positions of the missing numbers empty_positions = [(i, j) for i in range(3) for j in range(3) if square[i][j] == 0] # Try all permutations of the missing numbers in the empty positions for combo in itertools.permutations(missing_numbers): temp_square = [row[:] for row in square] for (i, j), num in zip(empty_positions, combo): temp_square[i][j] = num if is_magic(temp_square): return temp_square return -1"},{"question":"def calculate_score(n: int, expected_outputs: List[str], actual_outputs: List[str]) -> int: Calculate the total score based on expected and actual outputs. Args: n : int : the number of test cases expected_outputs : list of str : the expected outputs for each test case actual_outputs : list of str : the actual outputs from the contestant for each test case Returns: int : the total score Example: >>> calculate_score(3, [\\"sampleOutput1\\", \\"sampleOutput2\\", \\"sampleOutput3\\"], [\\"sampleOutput1\\", \\"incorrectOutput\\", \\"sampleOutput3\\"]) 2","solution":"def calculate_score(n, expected_outputs, actual_outputs): Calculate the total score based on expected and actual outputs. Args: n : int : the number of test cases expected_outputs : list of str : the expected outputs for each test case actual_outputs : list of str : the actual outputs from the contestant for each test case Returns: int : the total score score = 0 for expected, actual in zip(expected_outputs, actual_outputs): if expected == actual: score += 1 return score"},{"question":"def min_flips_to_zeros(n: int, binary_string: str) -> int: Determine the minimum number of flips required to make the entire binary string consist of only '0's. >>> min_flips_to_zeros(3, \\"000\\") 0 >>> min_flips_to_zeros(5, \\"11011\\") 2 >>> min_flips_to_zeros(7, \\"1010101\\") 4","solution":"def min_flips_to_zeros(n, binary_string): if '1' not in binary_string: return 0 flip_count = 0 i = 0 while i < n: if binary_string[i] == '1': while i < n and binary_string[i] == '1': i += 1 flip_count += 1 i += 1 return flip_count"},{"question":"def max_satisfied_friends(n, m, preferences, balloon_info, budget): Determine the maximum number of friends Alice can satisfy with her given budget for balloons. Args: n (int): The number of friends. m (int): The number of different colors of balloons available. preferences (list of int): The list of color preferences of the friends. balloon_info (list of tuple): A list where each tuple contains the price and availability of each balloon color. budget (int): The total budget in dollars Alice can spend on balloons. Returns: int: The maximum number of friends that can be satisfied. >>> max_satisfied_friends(5, 4, [1, 2, 3, 3, 2], [(1, 5), (2, 4), (3, 3), (4, 2)], 10) 4 >>> max_satisfied_friends(5, 3, [1, 1, 2, 2, 3], [(3, 2), (4, 2), (5, 1)], 7) 2 >>> max_satisfied_friends(5, 4, [1, 2, 2, 3, 4], [(1, 100), (2, 100), (3, 100), (4, 100)], 1000) 5 >>> max_satisfied_friends(6, 3, [1, 1, 1, 2, 2, 3], [(1, 2), (2, 1), (3, 1)], 6) 3 >>> max_satisfied_friends(5, 3, [1, 1, 1, 2, 3], [(2, 2), (2, 2), (2, 1)], 6) 3 >>> max_satisfied_friends(0, 3, [], [(1, 2), (2, 2), (3, 1)], 10) 0 >>> max_satisfied_friends(4, 3, [1, 1, 2, 3], [(1, 1), (1, 1), (1, 1)], 10) 3","solution":"def max_satisfied_friends(n, m, preferences, balloon_info, budget): from collections import Counter # Count preferences for each color preference_count = Counter(preferences) # List of (price per balloon, available quantity, preferred count) tuples balloons = [] for color in range(1, m + 1): if color in preference_count: price, available = balloon_info[color - 1] friends_count = preference_count[color] balloons.append((price, available, friends_count)) # Sort balloons by price per balloon (ascending) balloons.sort() satisfied_friends = 0 for price, available, friends_count in balloons: max_balloons_to_buy = min(available, friends_count) if budget >= max_balloons_to_buy * price: satisfied_friends += max_balloons_to_buy budget -= max_balloons_to_buy * price else: satisfied_friends += budget // price break return satisfied_friends"},{"question":"def max_rented_books(events: List[str]) -> int: Determines the maximum number of books rented out at any point in time based on the sequence of events. >>> max_rented_books([\\"r 1 101\\", \\"r 2 202\\", \\"r 1 102\\", \\"t 1 101\\", \\"r 3 304\\", \\"r 2 204\\", \\"t 2 202\\"]) 4 >>> max_rented_books([\\"r 1 101\\", \\"t 1 101\\"]) 1 >>> max_rented_books([\\"r 1 101\\", \\"r 2 102\\", \\"r 3 103\\", \\"t 1 101\\", \\"t 2 102\\", \\"t 3 103\\"]) 3 >>> max_rented_books([\\"r 1 101\\", \\"r 2 102\\", \\"r 3 103\\", \\"r 4 104\\"]) 4 >>> max_rented_books([\\"r 1 101\\", \\"r 2 102\\", \\"t 1 101\\", \\"t 2 102\\"]) 2","solution":"def max_rented_books(events): This function takes a list of events and calculates the maximum number of books rented out at any point in time. current_rented = 0 max_rented = 0 for event in events: action, user_id, book_id = event.split() if action == 'r': current_rented += 1 if current_rented > max_rented: max_rented = current_rented elif action == 't': current_rented -= 1 return max_rented"},{"question":"def min_moves_to_open_locks(N, M, k_arr, p_arr): Returns the minimum number of moves required to place each key in the room with the corresponding lock, or -1 if it is impossible. Parameters: N (int): number of rooms and locks M (int): number of keys k_arr (List[int]): list of locks that each key can open p_arr (List[int]): list of initial room position of each key Returns: int: minimum number of moves required or -1 if impossible >>> min_moves_to_open_locks(3, 3, [1, 2, 3], [3, 1, 2]) 2 >>> min_moves_to_open_locks(2, 2, [1, 2], [2, 1]) 1 >>> min_moves_to_open_locks(2, 1, [1], [2]) -1 from solution import min_moves_to_open_locks def test_example_1(): assert min_moves_to_open_locks(3, 3, [1, 2, 3], [3, 1, 2]) == 2 def test_example_2(): assert min_moves_to_open_locks(2, 2, [1, 2], [2, 1]) == 1 def test_example_3(): assert min_moves_to_open_locks(2, 1, [1], [2]) == -1 def test_disjoint_cycles(): # Separate cycles, no connections assert min_moves_to_open_locks(4, 4, [1, 2, 3, 4], [2, 1, 4, 3]) == 2 def test_all_keys_in_correct_room(): # Already sorted by default assert min_moves_to_open_locks(3, 3, [1, 2, 3], [1, 2, 3]) == 0 def test_some_keys_missing(): # Some locks do not have corresponding keys assert min_moves_to_open_locks(3, 2, [1, 2], [3, 1]) == -1","solution":"from collections import deque def min_moves_to_open_locks(N, M, k_arr, p_arr): Returns the minimum number of moves required to place each key in the room with the corresponding lock, or -1 if it is impossible. # Create a dictionary to map locks to indices of keys lock_to_keys = {lock: [] for lock in range(1, N+1)} for i, lock in enumerate(k_arr): lock_to_keys[lock].append(i) # Create a dictionary to map rooms to indices of keys they currently hold room_to_keys = {room: [] for room in range(1, N+1)} for i, room in enumerate(p_arr): room_to_keys[room].append(i) # Check the connectivity and count of keys per lock for lock in range(1, N+1): if len(lock_to_keys[lock]) != len(room_to_keys.get(lock, [])): return -1 moves = 0 visited = set() # For each room, we will use BFS to find the cycles and calculate the moves. for root in range(1, N+1): if root not in visited: queue = deque([root]) cycle_length = 0 while queue: current_room = queue.popleft() if current_room in visited: continue visited.add(current_room) cycle_length += 1 if len(room_to_keys[current_room]) > 0: next_room = k_arr[room_to_keys[current_room][0]] queue.append(next_room) # If we found a cycle of length \`cycle_length\`, we need (cycle_length - 1) moves to place all keys correctly. moves += cycle_length - 1 return moves"},{"question":"from typing import List, Tuple def largest_square(matrix: List[str]) -> int: Find the side length of the largest square containing only 1s in the given grid. >>> largest_square([ ... \\"11000\\", ... \\"11000\\", ... \\"11100\\", ... \\"00000\\" ... ]) 2 >>> largest_square([ ... \\"111\\", ... \\"111\\", ... \\"111\\" ... ]) 3 >>> largest_square([ ... \\"01\\", ... \\"10\\" ... ]) 1 def get_largest_squares(test_cases: List[Tuple[int, int, List[str]]]) -> List[int]: Process multiple test cases to find the side length of the largest square for each. >>> test_cases = [ ... (4, 5, [\\"11000\\", \\"11000\\", \\"11100\\", \\"00000\\"]), ... (3, 3, [\\"111\\", \\"111\\", \\"111\\"]), ... (2, 2, [\\"01\\", \\"10\\"]) ... ] >>> get_largest_squares(test_cases) [2, 3, 1] def process_input_output(input_data: str) -> List[int]: Process the input data string and produce the respective results. >>> input_data = \\"3n4 5n11000n11000n11100n00000n3 3n111n111n111n2 2n01n10n\\" >>> process_input_output(input_data) [2, 3, 1]","solution":"def largest_square(matrix): if not matrix: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0] * (n + 1) for _ in range(m + 1)] max_side = 0 for i in range(1, m + 1): for j in range(1, n + 1): if matrix[i-1][j-1] == '1': dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side def get_largest_squares(test_cases): results = [] for case in test_cases: m, n, grid = case results.append(largest_square(grid)) return results def process_input_output(input_data): lines = input_data.strip().split('n') t = int(lines[0]) index = 1 test_cases = [] for _ in range(t): m, n = map(int, lines[index].split()) grid = [lines[index + i + 1] for i in range(m)] test_cases.append((m, n, grid)) index += m + 1 results = get_largest_squares(test_cases) return results"},{"question":"def can_transform(n: int, a: List[int], b: List[int]) -> str: Determine if it is possible to transform array \`a\` into array \`b\` using exactly \`n\` operations. >>> can_transform(3, [1, 2, 3], [2, 3, 4]) 'YES' >>> can_transform(3, [1, 2, 3], [2, 4, 5]) 'NO'","solution":"def can_transform(n, a, b): # Calculate the total difference needed to transform a into b difference = sum(b[i] - a[i] for i in range(n)) # Check if the total difference equals n, as we need to perform exactly n operations if difference == n: return \\"YES\\" else: return \\"NO\\""},{"question":"def longest_bitonic_subseq_length(seq): Returns the length of the longest subsequence that is first increasing and then decreasing. >>> longest_bitonic_subseq_length([1, 11, 2, 10, 4, 5, 2, 1]) == 6 >>> longest_bitonic_subseq_length([12, 11, 40, 5, 3, 1]) == 5","solution":"def longest_bitonic_subseq_length(seq): Returns the length of the longest subsequence that is first increasing and then decreasing. n = len(seq) if n == 0: return 0 # Initialize the list for longest increasing subsequence (LIS) ending at each index lis = [1] * n for i in range(1, n): for j in range(i): if seq[i] > seq[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 # Initialize the list for longest decreasing subsequence (LDS) starting at each index lds = [1] * n for i in range(n-2, -1, -1): for j in range(n-1, i, -1): if seq[i] > seq[j] and lds[i] < lds[j] + 1: lds[i] = lds[j] + 1 # Calculate the maximum length of bitonic subsequence max_length = 0 for i in range(n): max_length = max(max_length, lis[i] + lds[i] - 1) return max_length"},{"question":"class CircularBuffer: def __init__(self, capacity): Initialize the circular buffer with the given capacity. self.capacity = capacity self.buffer = [None] * capacity self.start = 0 self.size = 0 def add(self, x): Add an element with key x to the end of the buffer. If the buffer is full, overwrite the oldest element. pass def remove(self): Remove the oldest element from the buffer. If the buffer is empty, do nothing. pass def get_elements(self): Return a list of all elements in the buffer, starting from the oldest and ending with the newest. pass def process_commands(capacity, commands): Process a list of commands on a circular buffer with the given capacity. Args: - capacity: an integer, the capacity of the buffer. - commands: a list of strings, where each string is a command in the format \\"add x\\", \\"remove\\", or \\"print\\". Returns: - A string where each output of a 'print' command is on a new line. Examples: >>> commands = [\\"add 10\\", \\"add 20\\", \\"add 30\\", \\"print\\", \\"add 40\\", \\"remove\\", \\"print\\"] >>> process_commands(5, commands) \\"10 20 30n20 30 40\\" >>> commands = [\\"add 1\\", \\"add 2\\", \\"add 3\\", \\"add 4\\", \\"print\\", \\"remove\\", \\"remove\\", \\"add 5\\", \\"print\\"] >>> process_commands(3, commands) \\"2 3 4n4 5\\" circ_buffer = CircularBuffer(capacity) result = [] for command in commands: tokens = command.split() if tokens[0] == \\"add\\": circ_buffer.add(int(tokens[1])) elif tokens[0] == \\"remove\\": circ_buffer.remove() elif tokens[0] == \\"print\\": result.append(\\" \\".join(map(str, circ_buffer.get_elements()))) return \\"n\\".join(result)","solution":"class CircularBuffer: def __init__(self, capacity): self.capacity = capacity self.buffer = [None] * capacity self.start = 0 self.size = 0 def add(self, x): if self.size < self.capacity: self.buffer[(self.start + self.size) % self.capacity] = x self.size += 1 else: self.buffer[self.start] = x self.start = (self.start + 1) % self.capacity def remove(self): if self.size > 0: self.start = (self.start + 1) % self.capacity self.size -= 1 def get_elements(self): elements = [] for i in range(self.size): elements.append(self.buffer[(self.start + i) % self.capacity]) return elements def process_commands(capacity, commands): circ_buffer = CircularBuffer(capacity) result = [] for command in commands: tokens = command.split() if tokens[0] == \\"add\\": circ_buffer.add(int(tokens[1])) elif tokens[0] == \\"remove\\": circ_buffer.remove() elif tokens[0] == \\"print\\": result.append(\\" \\".join(map(str, circ_buffer.get_elements()))) return \\"n\\".join(result)"},{"question":"def sum_of_digits(n: int) -> int: Given a number, returns the sum of its digits. >>> sum_of_digits(123) 6 >>> sum_of_digits(0) 0 >>> sum_of_digits(10) 1 >>> sum_of_digits(999) 27 def max_beauty_score_in_range(L: int, R: int) -> int: Returns the street number in the range [L, R] which has the highest beauty score. If there are multiple numbers with the same score, the smallest one is chosen. >>> max_beauty_score_in_range(10, 20) 19 >>> max_beauty_score_in_range(123, 130) 129 >>> max_beauty_score_in_range(999, 1001) 999 >>> max_beauty_score_in_range(1, 10) 9 >>> max_beauty_score_in_range(98, 103) 99 def find_max_beauty_scores(test_cases: List[Tuple[int, int]]) -> List[int]: Given multiple test cases with ranges [L, R], finds and returns the street number with the highest beauty score for each range. >>> find_max_beauty_scores([(10, 20), (123, 130), (999, 1001)]) [19, 129, 999]","solution":"def sum_of_digits(n): Returns the sum of the digits of a number. return sum(map(int, str(n))) def max_beauty_score_in_range(L, R): Returns the street number in the range [L, R] which has the highest beauty score. If there are multiple numbers with the same score, the smallest one is chosen. max_beauty_score = -1 best_number = L for n in range(L, R+1): beauty_score = sum_of_digits(n) if beauty_score > max_beauty_score or (beauty_score == max_beauty_score and n < best_number): max_beauty_score = beauty_score best_number = n return best_number def find_max_beauty_scores(test_cases): Given multiple test cases with ranges [L, R], finds and returns the street number with the highest beauty score for each range. results = [] for L, R in test_cases: results.append(max_beauty_score_in_range(L, R)) return results"},{"question":"def min_adjacent_swaps_to_sort(N, A): Determines the minimum number of adjacent swaps needed to sort the array in non-decreasing order. If it is not possible, returns -1. Args: N : int : the number of elements in the array A : list : the array of integers Returns: int : the minimum number of adjacent swaps needed or -1 if it is not possible Examples: >>> min_adjacent_swaps_to_sort(4, [1, 2, 3, 4]) 0 >>> min_adjacent_swaps_to_sort(5, [5, 4, 3, 2, 1]) 10 >>> min_adjacent_swaps_to_sort(5, [3, 1, 2, 5, 4]) 3 >>> min_adjacent_swaps_to_sort(1, [1]) 0 >>> min_adjacent_swaps_to_sort(2, [2, 1]) 1","solution":"def min_adjacent_swaps_to_sort(N, A): Determines the minimum number of adjacent swaps needed to sort the array in non-decreasing order. If it is not possible, returns -1. Args: N : int : the number of elements in the array A : list : the array of integers Returns: int : the minimum number of adjacent swaps needed or -1 if it is not possible if not is_possible_to_sort(A): return -1 return bubble_sort_count_swaps(A) def is_possible_to_sort(A): Checks if the array can be sorted into non-decreasing order by any permutations of adjacent swaps. Since any permutation of adjacent swaps is possible, any sequence can be made sorted unless you need to count the swaps. Args: A : list : the array of integers Returns: bool : True if it is possible to sort the array, False otherwise return True def bubble_sort_count_swaps(A): Counts the number of swaps needed to sort the array using bubble sort algorithm. Args: A : list : the array of integers Returns: int : the number of swaps needed to sort the array n = len(A) swap_count = 0 for i in range(n): for j in range(n - 1 - i): if A[j] > A[j + 1]: A[j], A[j + 1] = A[j + 1], A[j] swap_count += 1 return swap_count"},{"question":"def generate_string(n: int, k: int) -> str: Generate a string of length n such that every substring of length k or more contains all vowels at least once. >>> generate_string(7, 5) 'abecidu' >>> generate_string(5, 5) 'aeiou'","solution":"def generate_string(n, k): Generate a string of length n such that every substring of length k or more contains all vowels at least once. vowels = 'aeiou' if k > 5: # Repeating pattern: vowels followed by additional specific characters to meet the length n pattern = vowels # Creating a pattern that ensures each k-length segment will include all vowels for i in range(k - 5): pattern += vowels[i % 5] generated_string = (pattern * ((n // len(pattern)) + 1))[:n] else: # For k <= 5, fit as many vowels as possible within n length generated_string = (vowels * ((n // 5) + 1))[:n] return generated_string"},{"question":"def can_plow(n, m, grid): Determine if the farmer can reach the bottom-right corner following either the row-first or column-first movement patterns. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[str]): Representation of the land grid. Returns: str: \\"YES\\" if it is possible to reach the bottom-right corner, otherwise \\"NO\\". Examples: >>> can_plow(3, 3, [\\"..#\\", \\".#.\\", \\"...\\"]) \\"YES\\" >>> can_plow(2, 2, [\\"#.\\", \\"..\\"]) \\"NO\\"","solution":"def can_plow(n, m, grid): # Check row-first movement possibility row_first_possible = True for i in range(m): if grid[0][i] == '#': row_first_possible = False break for i in range(1, n): if grid[i][m-1] == '#': row_first_possible = False break # Check column-first movement possibility column_first_possible = True for i in range(n): if grid[i][0] == '#': column_first_possible = False break for i in range(1, m): if grid[n-1][i] == '#': column_first_possible = False break if row_first_possible or column_first_possible: return \\"YES\\" return \\"NO\\""},{"question":"def minimum_roads_to_keep(town_intersections: int, town_roads: list) -> int: Determines the minimum number of roads that need to remain open to keep the town fully connected. Parameters: town_intersections (int): The number of intersections in the town. town_roads (list of tuples): Each tuple (u, v) represents a road connecting intersections u and v. Returns: int: The minimum number of roads that need to remain open. Examples: >>> minimum_roads_to_keep(5, [(1, 2), (1, 3), (3, 4), (2, 4), (4, 5)]) 4 >>> minimum_roads_to_keep(4, [(1, 2), (1, 3), (1, 4), (2, 3)]) 3","solution":"def minimum_roads_to_keep(town_intersections, town_roads): Determines the minimum number of roads that need to remain open to keep the town fully connected. Parameters: town_intersections (int): The number of intersections in the town. town_roads (list of tuples): Each tuple (u, v) represents a road connecting intersections u and v. Returns: int: The minimum number of roads that need to remain open. # For the town to be fully connected, it's necessary to have a spanning tree. # This can be achieved with n - 1 roads, where n is the number of intersections. return town_intersections - 1"},{"question":"from typing import List def longest_non_decreasing_sequence(heights: List[int]) -> List[int]: Finds the longest sequence of consecutive plants (numbers) that have non-decreasing heights. If multiple sequences are of the same length, returns the first one. >>> longest_non_decreasing_sequence([1, 2, 2, 3, 1, 2, 3, 4]) [1, 2, 2, 3] >>> longest_non_decreasing_sequence([5, 4, 3, 2, 1]) [5] >>> longest_non_decreasing_sequence([8, 8, 9, 1, 2, 2, 2, 3, 4]) [1, 2, 2, 2, 3, 4]","solution":"from typing import List def longest_non_decreasing_sequence(heights: List[int]) -> List[int]: Finds the longest sequence of non-decreasing heights in the list. If multiple sequences are of the same length, returns the first one. if not heights: return [] longest_seq = [] current_seq = [] for i in range(len(heights)): if i == 0 or heights[i] >= heights[i-1]: current_seq.append(heights[i]) else: if len(current_seq) > len(longest_seq): longest_seq = current_seq current_seq = [heights[i]] if len(current_seq) > len(longest_seq): longest_seq = current_seq return longest_seq"},{"question":"def can_reach_destination(M: int, N: int, obstacles: List[int]) -> str: Determines if both cars can reach the M-th position given the positions of obstacles on the road. Parameters: M (int): Length of the road. N (int): Number of obstacles. obstacles (list of int): Positions of the obstacles. Returns: str: \\"YES\\" if both cars can reach the M-th position, otherwise \\"NO\\". >>> can_reach_destination(10, 2, [3, 7]) 'YES' >>> can_reach_destination(10, 3, [3, 7, 10]) 'NO' >>> can_reach_destination(10, 0, []) 'YES'","solution":"def can_reach_destination(M, N, obstacles): Determines if both cars can reach the M-th position given the positions of obstacles on the road. Parameters: - M (int): Length of the road. - N (int): Number of obstacles. - obstacles (list of int): Positions of the obstacles. Returns: - str: \\"YES\\" if both cars can reach the M-th position, otherwise \\"NO\\". if M in obstacles: return \\"NO\\" return \\"YES\\""},{"question":"def product_except_self(nums): Given an integer array of size n (1 ≤ n ≤ 1000), return an array such that each element at index i is the product of all elements in nums except nums[i]. Do this without using division and in O(n) time complexity. Example: >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 1, 4, 3, 5]) [60, 120, 30, 40, 24]","solution":"def product_except_self(nums): Given an integer array nums, return an array such that each element at index i is the product of all elements in nums except nums[i]. n = len(nums) result = [1] * n # Compute left products left = 1 for i in range(n): result[i] = left left *= nums[i] # Compute right products and final result right = 1 for i in range(n-1, -1, -1): result[i] *= right right *= nums[i] return result"},{"question":"def find_hamiltonian_cycle(N, edges): Find a Hamiltonian cycle in the given graph if it exists. :param N: Number of chambers (vertices) :param edges: List of (u, v) pairs representing tunnels (edges) :return: A Hamiltonian cycle as a list of vertices or \\"No solution\\" if no cycle exists >>> find_hamiltonian_cycle(4, [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]) [1, 2, 3, 4, 1] >>> find_hamiltonian_cycle(3, [(1, 2), (2, 3)]) \\"No solution\\" pass","solution":"def find_hamiltonian_cycle(N, edges): Find a Hamiltonian cycle in the given graph if it exists. :param N: Number of chambers (vertices) :param edges: List of (u, v) pairs representing tunnels (edges) :return: A Hamiltonian cycle as a list of vertices or \\"No solution\\" if no cycle exists from itertools import permutations # Create an adjacency matrix adj = [[0] * N for _ in range(N)] for u, v in edges: adj[u-1][v-1] = 1 adj[v-1][u-1] = 1 # Check all permutations of vertices to see if any form a Hamiltonian cycle for perm in permutations(range(N)): if adj[perm[-1]][perm[0]] == 0: continue # Not a cycle if no edge between last and first vertex cycle = True for i in range(N - 1): if adj[perm[i]][perm[i + 1]] == 0: cycle = False break if cycle: return [perm[i] + 1 for i in range(N)] + [perm[0] + 1] return \\"No solution\\" # Reading input def parse_input(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) edges = [(int(data[i]), int(data[i + 1])) for i in range(2, len(data), 2)] return N, edges def main(): N, edges = parse_input() result = find_hamiltonian_cycle(N, edges) if result == \\"No solution\\": print(result) else: print(\\" \\".join(map(str, result)))"},{"question":"def min_time_to_complete_tasks(n, m, task_times): Returns the minimum possible time required to complete all tasks. Parameters: n (int): Number of tasks. m (int): Number of robots. task_times (list): List of times required to complete the tasks. Returns: int: Minimum possible time required to complete all tasks with optimal assignment. >>> min_time_to_complete_tasks(6, 3, [2, 14, 4, 16, 6, 5]) 16 >>> min_time_to_complete_tasks(5, 1, [1, 2, 3, 4, 5]) 15 >>> min_time_to_complete_tasks(1, 5, [10]) 10 >>> min_time_to_complete_tasks(4, 2, [8, 5, 8, 5]) 13 >>> min_time_to_complete_tasks(7, 3, [2, 4, 4, 5, 6, 8, 10]) 14 >>> min_time_to_complete_tasks(10, 5, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 11 >>> min_time_to_complete_tasks(1, 10, [999]) 999 >>> min_time_to_complete_tasks(1, 1, [1]) 1 pass","solution":"import heapq def min_time_to_complete_tasks(n, m, task_times): Returns the minimum possible time required to complete all tasks. Parameters: n (int): Number of tasks. m (int): Number of robots. task_times (list): List of times required to complete the tasks. Returns: int: Minimum possible time required to complete all tasks with optimal assignment. # Sort tasks in descending order for more efficient task distribution task_times.sort(reverse=True) # Using a min-heap to keep track of the load on each robot robots = [0] * m heapq.heapify(robots) for time in task_times: # Assign the task to the robot with the least current load min_robot = heapq.heappop(robots) heapq.heappush(robots, min_robot + time) # The answer is the maximum load on any robot return max(robots)"},{"question":"def intersection_of_arrays(n: int, arr1: List[int], m: int, arr2: List[int]) -> List[int]: Write a function to find the intersection of two arrays. The intersection of two arrays is a list containing distinct common elements that appear in both arrays. >>> intersection_of_arrays(5, [4, 9, 5, 4, 9], 4, [9, 4, 9, 8, 4]) [4, 9] >>> intersection_of_arrays(3, [1, 2, 3], 4, [4, 2, 1, 2]) [1, 2] >>> intersection_of_arrays(4, [2, 2, 2, 2], 3, [2, 2, 2]) [2] >>> intersection_of_arrays(3, [1, 2, 3], 3, [4, 5, 6]) [] >>> intersection_of_arrays(3, [1, 2, 3], 3, [1, 2, 3]) [1, 2, 3] >>> intersection_of_arrays(4, [5, 6, 7, 8], 6, [8, 8, 7, 6, 5, 5]) [5, 6, 7, 8] >>> intersection_of_arrays(6, [5, 5, 6, 7, 8, 8], 4, [8, 7, 6, 5]) [5, 6, 7, 8]","solution":"def intersection_of_arrays(n, arr1, m, arr2): intersection = [] seen = set() for num in arr1: if num in arr2 and num not in seen: intersection.append(num) seen.add(num) return intersection"},{"question":"def longest_increasing_subsequence_length(sequence: List[int]) -> int: Returns the length of the longest strictly increasing subsequence in the given sequence of integers. >>> longest_increasing_subsequence_length([5, 2, 7, 4, 3, 8]) == 3 >>> longest_increasing_subsequence_length([10, 22, 9, 33, 21, 50, 41, 60]) == 5 >>> longest_increasing_subsequence_length([]) == 0 >>> longest_increasing_subsequence_length([1]) == 1 >>> longest_increasing_subsequence_length([1, 2, 3, 4, 5, 6, 7, 8]) == 8 >>> longest_increasing_subsequence_length([8, 7, 6, 5, 4, 3, 2, 1]) == 1 >>> longest_increasing_subsequence_length([3, 10, 2, 1, 20]) == 3 >>> longest_increasing_subsequence_length([3, 2]) == 1 >>> longest_increasing_subsequence_length([50, 3, 10, 7, 40, 80]) == 4","solution":"def longest_increasing_subsequence_length(sequence): Returns the length of the longest strictly increasing subsequence in the given sequence of integers. if not sequence: return 0 dp = [1] * len(sequence) for i in range(1, len(sequence)): for j in range(0, i): if sequence[i] > sequence[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def length_of_longest_substring(S: str) -> int: Returns the length of the longest substring with all distinct characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 def process_test_cases(T: int, test_cases: List[str]) -> List[int]: Processes multiple test cases and returns the results for each. >>> process_test_cases(3, [\\"abcabcbb\\", \\"bbbbb\\", \\"pwwkew\\"]) [3, 1, 3] >>> process_test_cases(1, [\\"\\"]) [0] >>> process_test_cases(2, [\\"abcdef\\", \\"aab\\"]) [6, 2]","solution":"def length_of_longest_substring(S): Returns the length of the longest substring with all distinct characters. n = len(S) max_length = 0 start = 0 char_index = {} for end in range(n): if S[end] in char_index: start = max(start, char_index[S[end]] + 1) char_index[S[end]] = end max_length = max(max_length, end - start + 1) return max_length def process_test_cases(T, test_cases): results = [] for S in test_cases: results.append(length_of_longest_substring(S)) return results"},{"question":"def make_elements_equal(n: int, array: List[int]) -> Tuple[str, int]: Determine if all elements of the array can be made equal. If possible, return \\"YES\\" and the minimum number of operations required. Otherwise, return \\"NO\\". :param n: int - number of elements in the array :param array: list of integers - the elements of the array :return: tuple - (\\"YES\\"/\\"NO\\", operations) >>> make_elements_equal(4, [1, 2, 3, 4]) (\\"YES\\", 4) >>> make_elements_equal(5, [3, 3, 3, 3, 3]) (\\"YES\\", 0) >>> make_elements_equal(3, [1, 2, 2]) (\\"YES\\", 1) from typing import List, Tuple def test_single_element(): assert make_elements_equal(1, [5]) == (\\"YES\\", 0) def test_all_elements_equal(): assert make_elements_equal(5, [3, 3, 3, 3, 3]) == (\\"YES\\", 0) def test_all_operations_required(): assert make_elements_equal(4, [1, 2, 3, 4]) == (\\"YES\\", 4) def test_some_elements_different(): assert make_elements_equal(3, [1, 2, 2]) == (\\"YES\\", 1) def test_larger_array(): assert make_elements_equal(5, [1, 2, 3, 4, 5]) == (\\"YES\\", 6)","solution":"def make_elements_equal(n, array): Determine if all elements of the array can be made equal. If possible, return \\"YES\\" and the minimum number of operations required. Otherwise, return \\"NO\\". :param n: int - number of elements in the array :param array: list of integers - the elements of the array :return: tuple - (\\"YES\\"/\\"NO\\", operations) if n == 1: return \\"YES\\", 0 target = round(sum(array) / n) operations = sum(abs(x - target) for x in array) return \\"YES\\", operations"},{"question":"import re def is_palindrome(s: str) -> str: Checks if a given string is a palindrome, ignoring spaces, punctuation, and capitalization. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") \\"YES\\" >>> is_palindrome(\\"No lemon, no melon\\") \\"YES\\" >>> is_palindrome(\\"Hello, World!\\") \\"NO\\"","solution":"import re def is_palindrome(s: str) -> str: Checks if a given string is a palindrome, ignoring spaces, punctuation, and capitalization. Args: s: The input string to check. Returns: \\"YES\\" if the string is a palindrome, otherwise \\"NO\\". # Removing all non-alphanumeric characters and converting to lower case cleaned_str = re.sub(r'[^A-Za-z0-9]', '', s).lower() # Check if the cleaned string is the same forward and backward if cleaned_str == cleaned_str[::-1]: return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List, Tuple, Union def gemstones_rearrangement(n: int, k: int, gemstones: List[int]) -> Union[str, Tuple[str, List[int]]]: Determines if it's possible to rearrange the gemstones such that the sum of every two adjacent gemstones' identifiers is divisible by k. Returns \\"YES\\" and one possible rearrangement if possible, otherwise returns \\"NO\\". >>> gemstones_rearrangement(4, 5, [2, 3, 7, 8]) ('YES', [2, 3, 7, 8]) >>> gemstones_rearrangement(3, 4, [1, 5, 6]) 'NO' def can_rearrange_gemstones(n: int, k: int, gemstones: List[int]) -> Tuple[bool, List[int]]: Helper function to check if a valid rearrangement is possible and returns a boolean along with the rearrangement if found. pass","solution":"from itertools import permutations def can_rearrange_gemstones(n, k, gemstones): for perm in permutations(gemstones): is_valid = True for i in range(n - 1): if (perm[i] + perm[i + 1]) % k != 0: is_valid = False break if is_valid: return True, list(perm) return False, [] def gemstones_rearrangement(n, k, gemstones): possible, arrangement = can_rearrange_gemstones(n, k, gemstones) if possible: return \\"YES\\", arrangement else: return \\"NO\\""},{"question":"def manage_library(n, m, q, requests): Manages books on shelves in a library based on add and remove requests. Parameters: - n: Number of shelves (1 ≤ n ≤ 10^5) - m: Maximum number of books a shelf can hold (1 ≤ m ≤ 10^3) - q: Number of requests (1 ≤ q ≤ 10^5) - requests: List of requests to add or remove books Returns: - List of responses to each request Example: >>> manage_library(3, 2, 5, [\\"Add 1 101\\", \\"Add 1 102\\", \\"Add 1 103\\", \\"Remove 1 101\\", \\"Remove 2 201\\"]) [\\"Added\\", \\"Added\\", \\"Shelf Full\\", \\"Removed\\", \\"Not Found\\"]","solution":"def manage_library(n, m, q, requests): Manages books on shelves in a library. Parameters: - n: Number of shelves - m: Maximum number of books a shelf can hold - q: Number of requests - requests: List of requests to add or remove books Returns: - List of responses to each request shelves = [set() for _ in range(n)] responses = [] for request in requests: action, x, y = request.split() x = int(x) - 1 y = int(y) if action == \\"Add\\": if len(shelves[x]) < m: shelves[x].add(y) responses.append(\\"Added\\") else: responses.append(\\"Shelf Full\\") elif action == \\"Remove\\": if y in shelves[x]: shelves[x].remove(y) responses.append(\\"Removed\\") else: responses.append(\\"Not Found\\") return responses"},{"question":"def min_cost_to_connect_reservoirs(N: int, M: int, pipes: List[Tuple[int, int, int]]) -> int: Determine the minimum cost required to connect all the reservoirs. Args: N (int): The number of reservoirs. M (int): The number of possible pipes. pipes (List[Tuple[int, int, int]]): Each tuple contains three integers u, v, and w, where u and v are the numbers of the reservoirs connected by the pipe, and w is the cost of laying the pipe. Returns: int: The minimum cost required to connect all the reservoirs or -1 if it's impossible. Example: >>> min_cost_to_connect_reservoirs(4, 5, [(1, 2, 1), (1, 3, 4), (2, 3, 2), (3, 4, 3), (2, 4, 5)]) 7 >>> min_cost_to_connect_reservoirs(3, 1, [(1, 2, 2)]) -1 def test_example_case(): N = 4 M = 5 pipes = [(1, 2, 1), (1, 3, 4), (2, 3, 2), (3, 4, 3), (2, 4, 5)] assert min_cost_to_connect_reservoirs(N, M, pipes) == 6 def test_no_reservoirs(): N = 0 M = 0 pipes = [] assert min_cost_to_connect_reservoirs(N, M, pipes) == 0 def test_single_reservoir(): N = 1 M = 0 pipes = [] assert min_cost_to_connect_reservoirs(N, M, pipes) == 0 def test_isolated_reservoir(): N = 3 M = 1 pipes = [(1, 2, 2)] assert min_cost_to_connect_reservoirs(N, M, pipes) == -1 def test_large_input(): N = 5 M = 7 pipes = [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 5, 4), (1, 3, 6), (2, 4, 7), (3, 5, 8)] assert min_cost_to_connect_reservoirs(N, M, pipes) == 10 def test_large_isolated_component(): N = 4 M = 3 pipes = [(1, 2, 1), (2, 3, 2)] assert min_cost_to_connect_reservoirs(N, M, pipes) == -1","solution":"def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 def min_cost_to_connect_reservoirs(N, M, pipes): if N == 0: return 0 parent = [i for i in range(N)] rank = [0] * N edges = sorted(pipes, key=lambda x: x[2]) cost = 0 edges_used = 0 for edge in edges: u, v, w = edge u -= 1 v -= 1 if find(parent, u) != find(parent, v): union(parent, rank, u, v) cost += w edges_used += 1 if edges_used == N - 1: break # Check if we were able to connect all the reservoirs if edges_used != N - 1: return -1 return cost def process_input_data(input_data): data = list(input_data.split()) N = int(data[0]) M = int(data[1]) pipes = [] index = 2 for _ in range(M): u = int(data[index]) v = int(data[index + 1]) w = int(data[index + 2]) pipes.append((u, v, w)) index += 3 return N, M, pipes def main(): import sys input_data = sys.stdin.read() N, M, pipes = process_input_data(input_data) result = min_cost_to_connect_reservoirs(N, M, pipes) print(result)"},{"question":"def count_odd_sum_pairs(n: int, arr: List[int]) -> int: Counts the number of pairs (i, j) such that 1 ≤ i < j ≤ n and the sum of the elements at index i and j is odd. >>> count_odd_sum_pairs(4, [1, 2, 3, 4]) 4 >>> count_odd_sum_pairs(3, [1, 3, 5]) 0 >>> count_odd_sum_pairs(3, [2, 4, 6]) 0 >>> count_odd_sum_pairs(5, [1, 2, 3, 4, 5]) 6 >>> count_odd_sum_pairs(2, [1, 2]) 1 >>> count_odd_sum_pairs(6, [1, 8, 3, 6, 5, 10]) 9","solution":"def count_odd_sum_pairs(n, arr): Counts the number of pairs (i, j) such that 1 ≤ i < j ≤ n and the sum of the elements at index i and j is odd. odd_count = sum(1 for x in arr if x % 2 != 0) even_count = n - odd_count return odd_count * even_count"},{"question":"def min_number_of_rectangles(n: int, heights: List[int]) -> int: Determines the minimum number of rectangles needed to cover all buildings. >>> min_number_of_rectangles(5, [3, 1, 4, 1, 5]) 4 >>> min_number_of_rectangles(6, [2, 2, 2, 2, 2, 2]) 1 >>> min_number_of_rectangles(4, [1, 2, 3, 4]) 4 >>> min_number_of_rectangles(7, [5, 3, 5, 6, 2, 4, 5]) 5","solution":"def min_number_of_rectangles(n, heights): Returns the minimum number of rectangles needed to cover all the buildings in the given heights array. unique_heights = set(heights) return len(unique_heights)"},{"question":"from collections import defaultdict from typing import List, Tuple def count_unique_paths(N: int, M: int, edges: List[Tuple[int, int]], start: int, end: int) -> int: Given a directed acyclic graph (DAG) with N nodes and M edges, find the number of unique paths from a given start node to a given end node. Args: N : int : the number of nodes in the graph M : int : the number of edges in the graph edges : List[Tuple[int, int]] : a list of directed edges where each edge is represented by a tuple (u, v) start : int : the start node end : int : the end node Returns: int : the number of unique paths from the start node to the end node Example: >>> N, M = 4, 4 >>> edges = [(1, 2), (2, 3), (3, 4), (1, 3)] >>> start, end = 1, 4 >>> count_unique_paths(N, M, edges, start, end) 2 >>> N, M = 5, 6 >>> edges = [(1, 2), (1, 3), (3, 2), (2, 4), (3, 4), (4, 5)] >>> start, end = 1, 5 >>> count_unique_paths(N, M, edges, start, end) 3 pass def test_count_unique_paths_with_example1(): N, M = 4, 4 edges = [(1, 2), (2, 3), (3, 4), (1, 3)] start, end = 1, 4 assert count_unique_paths(N, M, edges, start, end) == 2 def test_count_unique_paths_with_example2(): N, M = 5, 6 edges = [(1, 2), (1, 3), (3, 2), (2, 4), (3, 4), (4, 5)] start, end = 1, 5 assert count_unique_paths(N, M, edges, start, end) == 3 def test_count_unique_paths_single_path(): N, M = 4, 3 edges = [(1, 2), (2, 3), (3, 4)] start, end = 1, 4 assert count_unique_paths(N, M, edges, start, end) == 1 def test_count_unique_paths_disconnected_graph(): N, M = 4, 2 edges = [(1, 2), (3, 4)] start, end = 1, 4 assert count_unique_paths(N, M, edges, start, end) == 0","solution":"from collections import defaultdict, deque def count_unique_paths(N, M, edges, start, end): Returns the number of unique paths from start to end in a DAG. graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Memoization to store the number of paths from each node to the end node memo = {} def dfs(node): if node == end: return 1 if node in memo: return memo[node] path_count = 0 for neighbor in graph[node]: path_count += dfs(neighbor) memo[node] = path_count return path_count return dfs(start) # Usage example if __name__ == \\"__main__\\": N = 5 M = 6 edges = [(1, 2), (1, 3), (3, 2), (2, 4), (3, 4), (4, 5)] start = 1 end = 5 print(count_unique_paths(N, M, edges, start, end)) # Output should be 3"},{"question":"def highest_fitness_score(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[int]: Determine the student with the highest fitness score based on their participation in activities. >>> t = 2 >>> test_cases = [(5, 3, [(1, 3, 10), (2, 5, 20), (3, 4, 15)]), (4, 2, [(1, 2, 5), (2, 3, 5)])] >>> highest_fitness_score(t, test_cases) [3, 2] >>> t = 1 >>> test_cases = [(5, 4, [(1, 2, 10), (3, 4, 20), (1, 1, 30), (3, 3, 10)])] >>> highest_fitness_score(t, test_cases) [1]","solution":"def highest_fitness_score(t, test_cases): results = [] for case in test_cases: n, m, activities = case scores = [0] * n for activity in activities: ai, bi, si = activity for student in range(ai - 1, bi): scores[student] += si max_score = max(scores) for i in range(n): if scores[i] == max_score: results.append(i + 1) break return results"},{"question":"def min_rounds(n, skill_levels): Returns the minimum number of rounds required to determine the overall winner in a tournament given the number of players \`n\` and their respective \`skill_levels\`. >>> min_rounds(1, [10]) == 0 >>> min_rounds(3, [10, 10, 10]) == 0 >>> min_rounds(5, [10, 20, 30, 40, 50]) == 4 >>> min_rounds(4, [15, 20, 30, 25]) == 3 >>> min_rounds(6, [3, 9, 2, 7, 8, 5]) == 5 >>> min_rounds(2, [5, 10]) == 1 >>> min_rounds(2, [10, 10]) == 0 >>> skills = [i + 1 for i in range(100000)] >>> min_rounds(100000, skills) == 99999","solution":"def min_rounds(n, skill_levels): Returns the minimum number of rounds required to determine the overall winner in a tournament given the number of players \`n\` and their respective \`skill_levels\`. assert 1 <= n <= 10**5 assert all(1 <= skill <= 10**9 for skill in skill_levels) if n == 1: return 0 # If there's only one player, no rounds are needed max_skill = max(skill_levels) rounds = 0 for skill in skill_levels: if skill != max_skill: rounds += 1 return rounds"},{"question":"from typing import List def min_height_diff(buildings: List[int], x: int) -> int: Returns the minimum possible difference between the tallest and shortest buildings in a sublist of at least length x. >>> min_height_diff([1, 5, 9, 7, 3], 3) 4 >>> min_height_diff([2, 10, 8, 17, 6], 2) 2 >>> min_height_diff([4, 4, 4, 4, 4], 1) 0 pass","solution":"from typing import List def min_height_diff(buildings: List[int], x: int) -> int: Returns the minimum possible difference between the tallest and shortest buildings in a sublist of at least length x. # Sort the buildings heights buildings.sort() # Initialize the minimum difference with a high value min_diff = float('inf') # Traverse the sorted list with a window of size x for i in range(len(buildings) - x + 1): current_diff = buildings[i + x - 1] - buildings[i] min_diff = min(min_diff, current_diff) return min_diff"},{"question":"def is_palindrome(s: str) -> bool: Determine if the given string is a palindrome. Parameters: - s (str): A string containing lowercase letters. Returns: - bool: True if the string is a palindrome, False otherwise. pass # Unit Tests def test_is_palindrome_true_cases(): assert is_palindrome(\\"racecar\\") == True assert is_palindrome(\\"madam\\") == True assert is_palindrome(\\"a\\") == True def test_is_palindrome_false_cases(): assert is_palindrome(\\"hello\\") == False assert is_palindrome(\\"world\\") == False def test_is_palindrome_empty_string(): assert is_palindrome(\\"\\") == True # Assuming empty string is considered a palindrome def test_is_palindrome_even_length(): assert is_palindrome(\\"abba\\") == True assert is_palindrome(\\"abcd\\") == False def test_is_palindrome_special_cases(): assert is_palindrome(\\"civic\\") == True assert is_palindrome(\\"deified\\") == True assert is_palindrome(\\"level\\") == True","solution":"def is_palindrome(s: str) -> bool: Determine if the given string is a palindrome. Parameters: - s (str): A string containing lowercase letters. Returns: - bool: True if the string is a palindrome, False otherwise. return s == s[::-1]"},{"question":"def prefix_sums(arr): Returns the prefix sum array of the given array. >>> prefix_sums([1, 2, 3, 4, 5]) [0, 1, 3, 6, 10, 15] >>> prefix_sums([0, -1, 2]) [0, 0, -1, 1] pass def query_subarray_sum(prefix_sum_arr, li, ri): Returns the sum of elements from index li to ri using the prefix sum array. >>> query_subarray_sum([0, 1, 3, 6, 10, 15], 1, 3) 6 >>> query_subarray_sum([0, 1, 3, 6, 10, 15], 2, 4) 9 pass def solve_subarray_sums(m, arr, n, queries): Solves the problem of finding sum of elements in the subarray for each query. >>> solve_subarray_sums(5, [1, 2, 3, 4, 5], 3, [(1, 3), (2, 4), (1, 5)]) [6, 9, 15] >>> solve_subarray_sums(3, [0, -1, 2], 2, [(1, 2), (2, 3)]) [-1, 1] pass","solution":"def prefix_sums(arr): Returns the prefix sum array of the given array. prefix_sum_arr = [0] * (len(arr) + 1) for i in range(1, len(arr) + 1): prefix_sum_arr[i] = prefix_sum_arr[i - 1] + arr[i - 1] return prefix_sum_arr def query_subarray_sum(prefix_sum_arr, li, ri): Returns the sum of elements from index li to ri using the prefix sum array. return prefix_sum_arr[ri] - prefix_sum_arr[li - 1] def solve_subarray_sums(m, arr, n, queries): Solves the problem of finding sum of elements in the subarray for each query. results = [] prefix_sum_arr = prefix_sums(arr) for query in queries: li, ri = query results.append(query_subarray_sum(prefix_sum_arr, li, ri)) return results"},{"question":"def longest_unique_char_word(words: List[str]) -> str: Returns the longest word with all unique characters from a list of words. In case of a tie, returns the word that appears earliest in the list. >>> longest_unique_char_word([\\"apple\\", \\"banana\\", \\"orange\\", \\"grape\\", \\"unique\\"]) == \\"orange\\" >>> longest_unique_char_word([\\"aa\\", \\"bbb\\", \\"cccc\\"]) == \\"\\" >>> longest_unique_char_word([\\"universal\\", \\"trigger\\", \\"shuffle\\", \\"mask\\"]) == \\"universal\\" >>> longest_unique_char_word([\\"mask\\", \\"fish\\", \\"tune\\"]) == \\"mask\\" >>> longest_unique_char_word([\\"a\\", \\"b\\", \\"c\\"]) == \\"a\\" >>> longest_unique_char_word([]) == \\"\\" >>> longest_unique_char_word([\\"a\\", \\"abcde\\", \\"ab\\", \\"abc\\"]) == \\"abcde\\"","solution":"def longest_unique_char_word(words): Returns the longest word with all unique characters from a list of words. In case of a tie, returns the word that appears earliest in the list. def is_unique(word): return len(set(word)) == len(word) longest_word = \\"\\" for word in words: if is_unique(word) and (len(word) > len(longest_word)): longest_word = word return longest_word"},{"question":"def min_dividers_needed(n: int, d: int, thicknesses: List[int]) -> int: Determines the minimum number of dividers needed to ensure no section has a total thickness exceeding d. >>> min_dividers_needed(5, 10, [2, 3, 5, 6, 1]) 1 >>> min_dividers_needed(7, 15, [5, 2, 8, 6, 4, 3, 7]) 2","solution":"def min_dividers_needed(n, d, thicknesses): Determines the minimum number of dividers needed to ensure no section has a total thickness exceeding d. dividers = 0 current_thickness = 0 for thickness in thicknesses: if current_thickness + thickness > d: dividers += 1 current_thickness = thickness else: current_thickness += thickness return dividers"},{"question":"def min_changes_to_strictly_increasing(seq): Determine the minimum number of changes required to make the sequence of build qualities strictly increasing. Args: seq (List[int]): List of integers representing the quality of builds. Returns: int: Minimum number of changes required. >>> min_changes_to_strictly_increasing([3, 2, 5, 1, 7]) 2 >>> min_changes_to_strictly_increasing([2, 3, 1, 4]) 1 pass def process_test_cases(test_cases): Process multiple test cases to determine the minimum number of changes required for each. Args: test_cases (List[List[int]]): List of test cases with each test case being a list of integers representing build qualities. Returns: List[int]: List of results containing the minimum number of changes required for each test case. >>> process_test_cases([[3, 2, 5, 1, 7], [2, 3, 1, 4]]) [2, 1] >>> process_test_cases([[1, 2, 3, 4, 5]]) [0] pass def parse_input(input_str): Parse the raw input string to extract the test cases. Args: input_str (str): Raw input string representing multiple test cases. Returns: List[List[int]]: List of test cases extracted from the input string. >>> parse_input(\\"2n5n3 2 5 1 7n4n2 3 1 4\\") [[3, 2, 5, 1, 7], [2, 3, 1, 4]] >>> parse_input(\\"1n5n1 2 3 4 5\\") [[1, 2, 3, 4, 5]] pass def main(input_str): Main function to read input, process test cases and print results. Args: input_str (str): Raw input string representing multiple test cases. test_cases = parse_input(input_str) results = process_test_cases(test_cases) for result in results: print(result)","solution":"def min_changes_to_strictly_increasing(seq): n = len(seq) dp = [1] * n for i in range(1, n): for j in range(i): if seq[i] > seq[j]: dp[i] = max(dp[i], dp[j] + 1) longest_increasing_subseq_length = max(dp) return n - longest_increasing_subseq_length def process_test_cases(test_cases): results = [] for seq in test_cases: results.append(min_changes_to_strictly_increasing(seq)) return results def parse_input(input_str): lines = input_str.strip().split(\\"n\\") t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(lines[index]) seq = list(map(int, lines[index + 1].strip().split())) test_cases.append(seq) index += 2 return test_cases def main(input_str): test_cases = parse_input(input_str) results = process_test_cases(test_cases) for result in results: print(result)"},{"question":"def generate_sequence(n: int) -> list[int]: Returns the sequence generated by starting with n and repeatedly applying the given transformation until the number 1 is reached. >>> generate_sequence(6) == [6, 3, 10, 5, 16, 8, 4, 2, 1] >>> generate_sequence(1) == [1]","solution":"def generate_sequence(n): Returns the sequence generated by starting with n and repeatedly applying the given transformation until the number 1 is reached. sequence = [] while n != 1: sequence.append(n) if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 sequence.append(1) return sequence"},{"question":"def sum_and_digit_count(N: int) -> tuple: Computes the sum of the first N natural numbers and counts the number of digits in the resulting sum. >>> sum_and_digit_count(10) (55, 2) >>> sum_and_digit_count(100) (5050, 4)","solution":"def sum_and_digit_count(N): Returns the sum of the first N natural numbers and the number of digits in the sum. Parameters: N (int): A positive integer representing the number of natural numbers to sum up. Returns: tuple: A tuple containing the sum and the count of digits in the sum. sum_N = N * (N + 1) // 2 digit_count = len(str(sum_N)) return sum_N, digit_count"},{"question":"def collatz_sequence_length(n: int) -> int: Calculate the length of the Collatz sequence starting at n and ending at 1. >>> collatz_sequence_length(6) 9 >>> collatz_sequence_length(19) 21 >>> collatz_sequence_length(27) 112 def process_test_cases(t: int, cases: List[int]) -> List[int]: Process multiple test cases for the Collatz sequence length. >>> process_test_cases(3, [6, 19, 27]) [9, 21, 112] >>> process_test_cases(1, [1]) [1] >>> process_test_cases(2, [2, 3]) [2, 8]","solution":"def collatz_sequence_length(n): Calculate the length of the Collatz sequence starting at n and ending at 1. length = 1 while n != 1: if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 length += 1 return length def process_test_cases(t, cases): Process multiple test cases for the Collatz sequence length. results = [] for n in cases: results.append(collatz_sequence_length(n)) return results"},{"question":"def visible_people(heights): Returns a list of visible people from the left side of the line. >>> visible_people([5, 3, 8, 6, 7, 2]) [5, 8] >>> visible_people([4, 4, 4, 4, 4]) [4] >>> visible_people([1, 2, 3, 4, 5, 6, 7]) [1, 2, 3, 4, 5, 6, 7] def process_test_cases(test_cases): Processes multiple test cases to find visible people from the left side of the line. >>> process_test_cases([[5, 3, 8, 6, 7, 2], [4, 4, 4, 4, 4], [1, 2, 3, 4, 5, 6, 7]]) [[5, 8], [4], [1, 2, 3, 4, 5, 6, 7]] >>> process_test_cases([[10, 4, 6, 3, 8, 12, 8]]) [[10, 12]] >>> process_test_cases([[]]) [[]]","solution":"def visible_people(heights): Returns a list of visible people from the left side of the line. visible = [] current_max = -1 for height in heights: if height > current_max: visible.append(height) current_max = height return visible def process_test_cases(test_cases): Processes multiple test cases to find visible people from the left side of the line. results = [] for heights in test_cases: results.append(visible_people(heights)) return results"},{"question":"def beaver_traversal(n: int, S: int, nodes: List[Tuple[int, int, int]]) -> str: Determine if it's possible for beaver Neo to visit all nodes with the total sum of the node values being less than or equal to S. >>> beaver_traversal(5, 15, [(10, 2, 3), (4, 0, 0), (6, 0, 4), (3, 5, 0), (2, 0, 0)]) 'Impossible' >>> beaver_traversal(4, 5, [(3, 2, 0), (1, 3, 4), (2, 0, 0), (1, 0, 0)]) 'Impossible' >>> beaver_traversal(3, 6, [(1, 2, 3), (2, 0, 0), (3, 0, 0)]) '1 2 3' >>> beaver_traversal(3, 5, [(1, 2, 3), (2, 0, 0), (3, 0, 0)]) 'Impossible' >>> beaver_traversal(3, 4, [(2, 2, 0), (2, 0, 0), (1, 0, 0)]) '1 2' pass","solution":"def beaver_traversal(n, S, nodes): tree = {i: {'value': nodes[i-1][0], 'left': nodes[i-1][1], 'right': nodes[i-1][2]} for i in range(1, n + 1)} traversal = [] def pre_order(node): if node == 0: return 0 value = tree[node]['value'] traversal.append(node) sum_left = pre_order(tree[node]['left']) sum_right = pre_order(tree[node]['right']) return value + sum_left + sum_right total_sum = pre_order(1) if total_sum <= S: return ' '.join(map(str, traversal)) else: return \\"Impossible\\""},{"question":"from typing import List, Tuple def minimum_travel_time(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Find the minimum time it takes for a message to travel from computer 1 to computer N in an undirected graph representing network connections. >>> minimum_travel_time(4, 4, [(1, 2, 1), (2, 3, 2), (3, 4, 1), (1, 4, 4)]) 4 >>> minimum_travel_time(3, 2, [(1, 2, 1), (2, 3, 2)]) 3 >>> minimum_travel_time(5, 3, [(1, 2, 1), (1, 3, 2), (4, 5, 1)]) -1 from solution import minimum_travel_time def test_minimum_travel_time_case_1(): assert minimum_travel_time(4, 4, [(1, 2, 1), (2, 3, 2), (3, 4, 1), (1, 4, 4)]) == 4 def test_minimum_travel_time_case_2(): assert minimum_travel_time(3, 2, [(1, 2, 1), (2, 3, 2)]) == 3 def test_minimum_travel_time_case_3(): assert minimum_travel_time(5, 3, [(1, 2, 1), (1, 3, 2), (4, 5, 1)]) == -1 def test_minimum_travel_time_large_graph(): edges = [(i, i+1, 100) for i in range(1, 100000)] assert minimum_travel_time(100000, 99999, edges) == 9999900 def test_minimum_travel_time_no_path(): assert minimum_travel_time(6, 4, [(1, 2, 1), (2, 3, 1), (4, 5, 1), (5, 6, 1)]) == -1","solution":"import heapq import sys def minimum_travel_time(n, m, edges): graph = [[] for _ in range(n + 1)] for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra's Algorithm def dijkstra(start, end): min_heap = [(0, start)] distances = [sys.maxsize] * (n + 1) distances[start] = 0 while min_heap: current_distance, u = heapq.heappop(min_heap) if u == end: return current_distance if current_distance > distances[u]: continue for v, weight in graph[u]: distance = current_distance + weight if distance < distances[v]: distances[v] = distance heapq.heappush(min_heap, (distance, v)) return -1 return dijkstra(1, n)"},{"question":"def count_spiky_numbers(sequence: List[int]) -> int: Returns the number of spiky numbers in the sequence. >>> count_spiky_numbers([1, 3, 2, 5, 4, 6]) 2 >>> count_spiky_numbers([9, 7, 8, 5, 4]) 1","solution":"def count_spiky_numbers(sequence): Returns the number of spiky numbers in the sequence. n = len(sequence) if n < 3: return 0 # There cannot be any spiky numbers if the sequence is too short spiky_count = 0 for i in range(1, n - 1): if sequence[i] > sequence[i - 1] and sequence[i] > sequence[i + 1]: spiky_count += 1 return spiky_count"},{"question":"def analyze_integers(n: int, integers: List[int]) -> Tuple[int, int, int, int, int]: Given a list of integers, performs the following operations: 1. Count the number of positive and negative integers. 2. Calculate the sum of all integers. 3. Find the largest and smallest integer. :param n: Number of integers in the list. :param integers: List of integers. :return: A tuple containing: - The count of positive integers. - The count of negative integers. - The sum of all integers. - The largest and smallest integers. >>> analyze_integers(5, [1, -2, 3, -4, 5]) (3, 2, 3, 5, -4) >>> analyze_integers(3, [1, 2, 3]) (3, 0, 6, 3, 1) >>> analyze_integers(3, [-1, -2, -3]) (0, 3, -6, -1, -3) >>> analyze_integers(5, [0, -1, 2, -3, 4]) (2, 2, 2, 4, -3) >>> analyze_integers(1, [5]) (1, 0, 5, 5, 5) >>> analyze_integers(1, [-5]) (0, 1, -5, -5, -5) >>> analyze_integers(1, [0]) (0, 0, 0, 0, 0)","solution":"def analyze_integers(n, integers): Given a list of integers, performs the following operations: 1. Count the number of positive and negative integers. 2. Calculate the sum of all integers. 3. Find the largest and smallest integer. :param n: Number of integers in the list. :param integers: List of integers. :return: A tuple containing: - The count of positive integers. - The count of negative integers. - The sum of all integers. - The largest and smallest integers. positives = sum(1 for x in integers if x > 0) negatives = sum(1 for x in integers if x < 0) total_sum = sum(integers) max_int = max(integers) min_int = min(integers) return positives, negatives, total_sum, max_int, min_int"},{"question":"def sort_by_bits(arr): Sort an array of integers based on the number of 1s in their binary representation. If two numbers have the same number of 1s, they are sorted by their numeric value. >>> sort_by_bits([3, 7, 8]) [8, 3, 7] >>> sort_by_bits([0, 1, 2, 4, 8]) [0, 1, 2, 4, 8] pass # Implementation goes here def sort_test_cases(test_cases): Sorts multiple test cases where each test case is a pair (n, array) by the criteria defined in sort_by_bits function. pass # Implementation goes here def main(test_cases_input): Parses input for multiple test cases and returns the sorted results for all test cases, ready to be printed. >>> main([\\"2\\", \\"3\\", \\"3 7 8\\", \\"5\\", \\"0 1 2 4 8\\"]) [[8, 3, 7], [0, 1, 2, 4, 8]] >>> main([\\"1\\", \\"4\\", \\"1 2 3 4\\"]) [[1, 2, 4, 3]] pass # Implementation goes here","solution":"def sort_by_bits(arr): Sort an array of integers based on the number of 1s in their binary representation. If two numbers have the same number of 1s, they are sorted by their numeric value. return sorted(arr, key=lambda x: (bin(x).count('1'), x)) def sort_test_cases(test_cases): results = [] for case in test_cases: n, array = case sorted_array = sort_by_bits(array) results.append(sorted_array) return results def main(test_cases_input): Parses input for multiple test cases and returns the sorted results for all test cases, ready to be printed. test_cases = [] current_index = 0 t = int(test_cases_input[current_index]) current_index += 1 for _ in range(t): n = int(test_cases_input[current_index]) current_index += 1 array = list(map(int, test_cases_input[current_index].split())) current_index += 1 test_cases.append((n, array)) sorted_test_cases = sort_test_cases(test_cases) return sorted_test_cases"},{"question":"def max_score(n: int, T: int, problems: List[Tuple[int, int]]) -> int: Determine the maximum score you can achieve by strategically choosing which problems to solve each day. Args: n (int): The number of days in the competition. T (int): The total available time for solving problems. problems (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers, the time required to solve the problem and the score for solving the problem. Returns: int: The maximum score you can achieve. Example: >>> max_score(3, 10, [(4, 8), (6, 7), (3, 5)]) 13 >>> max_score(4, 5, [(5, 10), (4, 8), (6, 12), (7, 14)]) 10","solution":"def max_score(n, T, problems): # Sort problems based on their score/time ratio (score per time unit) in descending order problems.sort(key=lambda x: (x[1] / x[0]), reverse=True) total_time = T total_score = 0 for time, score in problems: if total_time >= time: total_time -= time total_score += score return total_score # Example usage: # n = 3 # T = 10 # problems = [(4, 8), (6, 7), (3, 5)] # print(max_score(n, T, problems)) # Output should be 13"},{"question":"def evaluate_boolean_expression(expression: str) -> str: Evaluates a boolean expression containing '0', '1', '&', and '|' >>> evaluate_boolean_expression(\\"1|0&1&1\\") \\"1\\" >>> evaluate_boolean_expression(\\"0|0&1|0\\") \\"0\\"","solution":"def evaluate_boolean_expression(expression): Evaluates a boolean expression containing '0', '1', '&', and '|' # Step 1: Handle all AND operations first and_segments = expression.split('|') and_results = [] for segment in and_segments: and_result = '1' for char in segment.split('&'): if char == '0': and_result = '0' break and_results.append(and_result) # Step 2: Handle all OR operations result = '0' for res in and_results: if res == '1': result = '1' break return result"},{"question":"def can_be_expressed_as_sum_of_consecutive_integers(N: int) -> str: Determines if a number N can be expressed as the sum of exactly two or more consecutive positive integers. >>> can_be_expressed_as_sum_of_consecutive_integers(15) \\"YES\\" >>> can_be_expressed_as_sum_of_consecutive_integers(16) \\"NO\\" >>> can_be_expressed_as_sum_of_consecutive_integers(21) \\"YES\\"","solution":"def can_be_expressed_as_sum_of_consecutive_integers(N): Determines if a number N can be expressed as the sum of exactly two or more consecutive positive integers. # Starting from k = 2 as the minimum requirement is two or more consecutive numbers k = 2 while k * (k + 1) // 2 <= N: if (N - (k * (k + 1)) // 2) % k == 0: return \\"YES\\" k += 1 return \\"NO\\""},{"question":"def submatrix_sum(matrix: List[List[int]], queries: List[Tuple[int, int, int, int]]) -> List[int]: Find the sum of elements in a submatrix for multiple queries. Args: matrix (List[List[int]]): 2D list representing the matrix. queries (List[Tuple[int, int, int, int]]): List of queries where each query is represented by a tuple (r1, c1, r2, c2). Returns: List[int]: List of sums of each submatrix for each query. Examples: >>> matrix = [ >>> [1, 2, 3], >>> [4, 5, 6], >>> [7, 8, 9] >>> ] >>> queries = [ >>> (1, 1, 2, 2), >>> (1, 2, 3, 3) >>> ] >>> submatrix_sum(matrix, queries) [12, 33] >>> matrix = [ >>> [5] >>> ] >>> queries = [ >>> (1, 1, 1, 1) >>> ] >>> submatrix_sum(matrix, queries) [5]","solution":"def submatrix_sum(matrix, queries): def compute_prefix_sum(matrix): n = len(matrix) m = len(matrix[0]) PS = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): PS[i][j] = matrix[i-1][j-1] + PS[i-1][j] + PS[i][j-1] - PS[i-1][j-1] return PS PS = compute_prefix_sum(matrix) results = [] for r1, c1, r2, c2 in queries: sum_value = PS[r2][c2] - PS[r1-1][c2] - PS[r2][c1-1] + PS[r1-1][c1-1] results.append(sum_value) return results"},{"question":"def total_art_materials(m: int) -> int: Returns the total amount of art materials needed for m participants. Each participant receives a number of materials equal to the sum of the digits of their assigned number. >>> total_art_materials(5) 15 >>> total_art_materials(10) 46 >>> total_art_materials(12) 51 >>> total_art_materials(1) 1 >>> total_art_materials(20) 102","solution":"def total_art_materials(m): Returns the total amount of art materials needed for m participants. Each participant receives a number of materials equal to the sum of the digits of their assigned number. total_materials = 0 for i in range(1, m + 1): total_materials += sum(int(digit) for digit in str(i)) return total_materials"},{"question":"def minimize_total_fatigue(n: int, k: int, difficulties: List[int], stamina: List[int]) -> int: You are organizing a relay race event where runners compete on a linear track divided into n segments. Each segment has a specific difficulty level that affects the runners' performance. Your goal is to assign runners to the segments in such a way that minimizes the total fatigue experienced by the team. Each runner has a unique stamina level, which determines the maximum difficulty level of the segments they can handle. A runner can only run on segments whose difficulty is less than or equal to their stamina. Each runner can only run one continuous sequence of segments. The fatigue experienced by a runner is the sum of the difficulty levels of the segments they run. Your objective is to minimize the total fatigue for the entire team. Args: n (int): The number of segments. k (int): The number of runners. difficulties (List[int]): The difficulty level of each segment. stamina (List[int]): The stamina level of each runner. Returns: int: The minimum total fatigue of the team. Examples: >>> minimize_total_fatigue(5, 2, [1, 3, 2, 5, 4], [4, 3]) 10 >>> minimize_total_fatigue(6, 3, [2, 4, 3, 1, 6, 5], [6, 3, 4]) 15","solution":"def minimize_total_fatigue(n, k, difficulties, stamina): # Sort both runners by their stamina in ascending order stamina.sort() # Associate each segment with its difficulty segments = [(difficulties[i], i) for i in range(n)] # Sort segments by their difficulty in ascending order segments.sort() # Initialize the fatigue counter total_fatigue = 0 # Keep track of segment assignments assigned_segments = [False] * n # Assign segments to each runner for s in stamina: current_sum = 0 for i in range(n): difficulty, index = segments[i] # Check if the segment is already assigned, and if the runner can handle it if not assigned_segments[index] and difficulty <= s: current_sum += difficulty assigned_segments[index] = True total_fatigue += current_sum return total_fatigue"},{"question":"def find_closest_numbers(test_cases): Determines which number is closest to Z for each test case. In case of a tie, returns the smaller number. Parameters: test_cases (list): List of tuples, where each tuple contains three integers X, Y, Z. Returns: list: List of integers, each being the number closest to Z from the respective test case. Examples: >>> find_closest_numbers([(5, 10, 7)]) [5] >>> find_closest_numbers([(12, 15, 13)]) [12] results = [] # Implementation goes here return results def test_find_closest_numbers(): # Test case 1 test_cases = [(5, 10, 7)] assert find_closest_numbers(test_cases) == [5] # Test case 2 test_cases = [(12, 15, 13)] assert find_closest_numbers(test_cases) == [12] # Test case 3 test_cases = [(20, 18, 19)] assert find_closest_numbers(test_cases) == [18] # Test case 4 - Tie test_cases = [(5, 9, 7)] assert find_closest_numbers(test_cases) == [5] # Tie case, should return smaller number # Test case 5 - Large values test_cases = [(1000000000, 999999999, 999999998)] assert find_closest_numbers(test_cases) == [999999999] # Test case 6 - Same values, different Z test_cases = [(10, 10, 5), (10, 10, 15)] assert find_closest_numbers(test_cases) == [10, 10] # Test case 7 - Z equal to one number test_cases = [(8, 14, 8)] assert find_closest_numbers(test_cases) == [8] # Test case 8 - Edge values test_cases = [(1, 1, 1)] assert find_closest_numbers(test_cases) == [1] # Test multiple test cases in one go test_cases = [ (5, 10, 7), (12, 15, 13), (20, 18, 19), (5, 9, 7), (1000000000, 999999999, 999999998), (10, 10, 5), (10, 10, 15), (8, 14, 8), (1, 1, 1) ] expected_results = [5, 12, 18, 5, 999999999, 10, 10, 8, 1] assert find_closest_numbers(test_cases) == expected_results","solution":"def find_closest_numbers(test_cases): Determines which number is closest to Z for each test case. In case of a tie, returns the smaller number. Parameters: test_cases (list): List of tuples, where each tuple contains three integers X, Y, Z. Returns: list: List of integers, each being the number closest to Z from the respective test case. results = [] for X, Y, Z in test_cases: dist_X = abs(X - Z) dist_Y = abs(Y - Z) if dist_X < dist_Y: results.append(X) elif dist_Y < dist_X: results.append(Y) else: results.append(min(X, Y)) return results"},{"question":"def unique_prime_factors_count(n: int) -> int: Returns the number of unique prime factors of a given number n. >>> unique_prime_factors_count(10) 2 >>> unique_prime_factors_count(12) 2 def process_test_cases(test_cases: List[int]) -> List[int]: Processes multiple test cases and returns the results as a list. >>> process_test_cases([10, 12, 30, 31]) [2, 2, 3, 1] >>> process_test_cases([2, 3, 4, 5]) [1, 1, 1, 1] # Test cases for unique_prime_factors_count def test_unique_prime_factors_count(): assert unique_prime_factors_count(2) == 1 assert unique_prime_factors_count(3) == 1 assert unique_prime_factors_count(10) == 2 assert unique_prime_factors_count(12) == 2 assert unique_prime_factors_count(30) == 3 assert unique_prime_factors_count(31) == 1 assert unique_prime_factors_count(100) == 2 assert unique_prime_factors_count(1) == 0 # technically not prime factors, but edge case # Test cases for process_test_cases def test_process_test_cases(): test_cases = [10, 12, 30, 31] expected_results = [2, 2, 3, 1] assert process_test_cases(test_cases) == expected_results test_cases = [2, 3, 4, 5] expected_results = [1, 1, 1, 1] assert process_test_cases(test_cases) == expected_results","solution":"def unique_prime_factors_count(n): Returns the number of unique prime factors of a given number n. count = 0 if n % 2 == 0: count += 1 while n % 2 == 0: n //= 2 for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: count += 1 while n % i == 0: n //= i if n > 2: count += 1 return count def process_test_cases(test_cases): results = [] for n in test_cases: results.append(unique_prime_factors_count(n)) return results"},{"question":"def longest_arithmetic_progression_length(n: int) -> int: Returns the length of the longest arithmetic progression that can be formed using exactly n blocks. >>> longest_arithmetic_progression_length(1) 1 >>> longest_arithmetic_progression_length(2) 2 >>> longest_arithmetic_progression_length(10) 10 >>> longest_arithmetic_progression_length(25) 25","solution":"def longest_arithmetic_progression_length(n): Returns the length of the longest arithmetic progression that can be formed using exactly n blocks. return n"},{"question":"from typing import List def contains_subarray_with_sum(arr: List[int], K: int) -> bool: Determine whether it is possible to select a non-empty sequence of consecutive elements that adds up to a given integer K. >>> contains_subarray_with_sum([1, 2, 3, 4, 5], 9) True >>> contains_subarray_with_sum([1, 2, 3, 4, 5], 11) False >>> contains_subarray_with_sum([5, -2, 3, 1, 2], 4) True >>> contains_subarray_with_sum([1, -1, 2, -2, 3, -3, 4, -4, 5], 0) True >>> contains_subarray_with_sum([1, 2, 3, 4, 5] * 10000, 15) True >>> contains_subarray_with_sum([-1, -2, -3, -4, -5, 20], 5) True >>> contains_subarray_with_sum([], 0) False","solution":"from typing import List def contains_subarray_with_sum(arr: List[int], K: int) -> bool: current_sum = 0 sum_set = set() sum_set.add(0) for num in arr: current_sum += num if (current_sum - K) in sum_set: return True sum_set.add(current_sum) return False"},{"question":"def min_total_time(test_cases): Determine the minimum amount of total time required to complete all tasks optimally between two workers. >>> min_total_time([[2, 3, 5, 7, 1]]) [9] >>> min_total_time([[8, 4, 3]]) [8] >>> min_total_time([[1, 2, 3, 4]]) [5] def read_input(input_string): Parse the input string and return the test cases as a list of lists. >>> read_input(\\"3n5n2 3 5 7 1n3n8 4 3n4n1 2 3 4n\\") [[2, 3, 5, 7, 1], [8, 4, 3], [1, 2, 3, 4]] def main(input_string): Main function to read input and print results >>> main(\\"3n5n2 3 5 7 1n3n8 4 3n4n1 2 3 4n\\") [9, 8, 5]","solution":"def min_total_time(test_cases): results = [] for tasks in test_cases: tasks.sort(reverse=True) # Sort task times in descending order worker1_time, worker2_time = 0, 0 for task in tasks: if worker1_time <= worker2_time: worker1_time += task else: worker2_time += task results.append(max(worker1_time, worker2_time)) return results def read_input(input_string): lines = input_string.strip().split('n') t = int(lines[0]) index = 1 test_cases = [] for _ in range(t): n = int(lines[index]) tasks = list(map(int, lines[index + 1].split())) test_cases.append(tasks) index += 2 return test_cases def main(input_string): test_cases = read_input(input_string) results = min_total_time(test_cases) return results"},{"question":"def unique_paths(n: int, k: int, blocked_cells: List[Tuple[int, int]]) -> int: Determine the number of distinct paths the robot can take to reach the bottom-right corner from the top-left corner without passing through any blocked cells in an n x n grid. >>> unique_paths(3, 1, [(2, 2)]) 2 >>> unique_paths(4, 2, [(2, 2), (3, 3)]) 4 >>> unique_paths(5, 0, []) 70","solution":"def unique_paths(n, k, blocked_cells): # Initialize a 2D list with zeroes dp = [[0] * n for _ in range(n)] # Mark blocked cells for x, y in blocked_cells: dp[x-1][y-1] = -1 # Using -1 to denote blocked cells # Starting point if dp[0][0] == -1: return 0 dp[0][0] = 1 # Fill the first row for j in range(1, n): if dp[0][j] == -1: break dp[0][j] = 1 # Fill the first column for i in range(1, n): if dp[i][0] == -1: break dp[i][0] = 1 # Compute number of unique paths for each cell for i in range(1, n): for j in range(1, n): if dp[i][j] == -1: continue if dp[i-1][j] != -1: dp[i][j] += dp[i-1][j] if dp[i][j-1] != -1: dp[i][j] += dp[i][j-1] # The number of unique paths to the bottom-right corner return dp[-1][-1]"},{"question":"def is_possible(n, m, A, B, roads, k): Determine if it's possible to travel from city A to city B while visiting at least k different cities. :param n: Total number of cities, an integer. :param m: Total number of roads, an integer. :param A: The starting city, an integer. :param B: The destination city, an integer. :param roads: List of tuples where each tuple represents a one-way road (u, v). :param k: The minimum number of different cities to visit, an integer. :return: \\"Possible\\" if the trip is doable according to the criteria, otherwise \\"Impossible\\". pass from solution import is_possible def test_case_1(): n, m, A, B = 6, 7, 1, 5 roads = [(1, 2), (2, 3), (3, 4), (4, 5), (1, 3), (3, 5), (2, 5)] k = 4 assert is_possible(n, m, A, B, roads, k) == \\"Possible\\" def test_case_2(): n, m, A, B = 3, 2, 1, 3 roads = [(1, 2), (2, 3)] k = 4 assert is_possible(n, m, A, B, roads, k) == \\"Impossible\\" def test_case_3(): n, m, A, B = 5, 5, 1, 5 roads = [(1, 2), (1, 3), (2, 4), (4, 5), (3, 5)] k = 3 assert is_possible(n, m, A, B, roads, k) == \\"Possible\\" def test_min_bound_case(): n, m, A, B = 2, 1, 1, 2 roads = [(1, 2)] k = 2 assert is_possible(n, m, A, B, roads, k) == \\"Possible\\" def test_no_path(): n, m, A, B = 4, 3, 1, 4 roads = [(1, 2), (2, 3), (3, 1)] k = 3 assert is_possible(n, m, A, B, roads, k) == \\"Impossible\\"","solution":"from collections import deque, defaultdict def is_possible(n, m, A, B, roads, k): Determine if it's possible to travel from city A to city B while visiting at least k different cities. :param n: Total number of cities, an integer. :param m: Total number of roads, an integer. :param A: The starting city, an integer. :param B: The destination city, an integer. :param roads: List of tuples where each tuple represents a one-way road (u, v). :param k: The minimum number of different cities to visit, an integer. :return: \\"Possible\\" if the trip is doable according to the criteria, otherwise \\"Impossible\\". # Create adjacency list of the graph adj = defaultdict(list) for u, v in roads: adj[u].append(v) # Perform BFS to find shortest path with at least k vertices q = deque([(A, [A])]) while q: curr, path = q.popleft() if curr == B and len(path) >= k: return \\"Possible\\" for neighbor in adj[curr]: if neighbor not in path: q.append((neighbor, path + [neighbor])) return \\"Impossible\\""},{"question":"def custom_sequence_nth(a: int, b: int, c: int, n: int) -> int: Generates the nth number in Dave's custom sequence. The sequence starts with three given numbers a, b, and c (for n=1, n=2, and n=3, respectively). Each subsequent number is the sum of the previous three numbers. >>> custom_sequence_nth(1, 1, 2, 4) 4 >>> custom_sequence_nth(1, 1, 2, 5) 7 >>> custom_sequence_nth(1, 1, 2, 6) 13 >>> custom_sequence_nth(1, 2, 3, 1) 1 >>> custom_sequence_nth(1, 2, 3, 2) 2 >>> custom_sequence_nth(1, 2, 3, 3) 3 >>> custom_sequence_nth(2, 3, 4, 4) 9 >>> custom_sequence_nth(2, 3, 4, 5) 16 >>> custom_sequence_nth(2, 3, 4, 6) 29","solution":"def custom_sequence_nth(a, b, c, n): Generates the nth number in Dave's custom sequence. # For n=1, 2, or 3, return the respective initial values if n == 1: return a elif n == 2: return b elif n == 3: return c # Initialize the first three numbers seq = [a, b, c] # Generate up to the nth number for i in range(3, n): next_num = seq[-1] + seq[-2] + seq[-3] seq.append(next_num) return seq[-1]"},{"question":"def canBePalindrome(encrypted_string: str) -> bool: Determine if the encrypted string may have been a palindrome at some point during the encryption process. >>> canBePalindrome(\\"abcba\\") True >>> canBePalindrome(\\"abccba\\") True >>> canBePalindrome(\\"abcdba\\") False >>> canBePalindrome(\\"a\\") True >>> canBePalindrome(\\"racecar\\") True","solution":"def canBePalindrome(encrypted_string): Determine if the encrypted string may have been a palindrome at some point during the encryption process. left, right = 0, len(encrypted_string) - 1 while left < right: if encrypted_string[left] != encrypted_string[right]: return False left += 1 right -= 1 return True"},{"question":"class MatrixOps: def __init__(self, n, m): Initialize a matrix of size n x m with all zero values. def updateCell(self, i, j, x): Update the cell at row i and column j to contain x. def rowSum(self, i): Return the sum of all elements in the i-th row. def colSum(self, j): Return the sum of all elements in the j-th column. def process_queries(n, m, q, queries): Process a list of queries on a matrix of size n x m. Args: n (int): Number of rows. m (int): Number of columns. q (int): Number of queries. queries (List[str]): List of queries. Returns: List[int]: Results of rowSum and colSum queries.","solution":"class MatrixOps: def __init__(self, n, m): self.n = n self.m = m self.matrix = [[0] * m for _ in range(n)] self.row_sums = [0] * n self.col_sums = [0] * m def updateCell(self, i, j, x): current_value = self.matrix[i][j] self.matrix[i][j] = x self.row_sums[i] += x - current_value self.col_sums[j] += x - current_value def rowSum(self, i): return self.row_sums[i] def colSum(self, j): return self.col_sums[j] def process_queries(n, m, q, queries): matrix_ops = MatrixOps(n, m) results = [] for query in queries: split_query = list(map(int, query.split())) if split_query[0] == 0: # updateCell _, i, j, x = split_query matrix_ops.updateCell(i, j, x) elif split_query[0] == 1: # rowSum _, i = split_query results.append(matrix_ops.rowSum(i)) elif split_query[0] == 2: # colSum _, j = split_query results.append(matrix_ops.colSum(j)) return results"},{"question":"from typing import List def unique_elements(lst: List[int]) -> List[int]: Write a function named unique_elements that accepts a list of integers as input and returns a new list containing only the unique elements from the original list, preserving the order of their first occurrence. >>> unique_elements([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> unique_elements([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> unique_elements([1, 1, 1, 1]) [1] >>> unique_elements([]) [] >>> unique_elements([5, 4, 5, 4, 3, 2, 1]) [5, 4, 3, 2, 1] >>> unique_elements([1]) [1] >>> unique_elements(list(range(1000)) + list(range(500))) list(range(1000))","solution":"def unique_elements(lst): Returns a list containing only unique elements from the original list, preserving the order of their first occurrence. seen = set() unique_lst = [] for item in lst: if item not in seen: unique_lst.append(item) seen.add(item) return unique_lst"},{"question":"def length_of_longest_substring(s: str) -> int: Given a string, return the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"abcdef\\") 6 >>> length_of_longest_substring(\\"aaaaaa\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"abcdabcdabcdabcdabcdabcdabcdabcdabcdabcd\\") 4","solution":"def length_of_longest_substring(s): Given a string, returns the length of the longest substring without repeating characters. char_index_map = {} longest_substring_length = 0 start_index = 0 for index, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start_index: start_index = char_index_map[char] + 1 char_index_map[char] = index longest_substring_length = max(longest_substring_length, index - start_index + 1) return longest_substring_length"},{"question":"def max_people(M: int, N: int) -> int: Returns the maximum number of people that can be seated in an MxN grid following social distancing rules. >>> max_people(3, 3) 5 >>> max_people(2, 2) 2 >>> max_people(100, 100) 5000","solution":"def max_people(M, N): Returns the maximum number of people that can be seated in an MxN grid following social distancing rules. # For optimal seating, we observe that one can place people in checkerboard pattern. # Thus every second cell can contain a person. if (M * N) % 2 == 0: return (M * N) // 2 else: return (M * N) // 2 + 1 # Example usage # max_people(3, 3) should return 5"},{"question":"def count_palindromic_numbers(L: int, R: int) -> int: Count the number of palindromic numbers in the range [L, R] inclusive. Args: L (int): The starting integer of the range. R (int): The ending integer of the range. Returns: int: The count of palindromic numbers within the range. >>> count_palindromic_numbers(10, 20) 1 >>> count_palindromic_numbers(1, 100) 18 >>> count_palindromic_numbers(99, 101) 2 >>> count_palindromic_numbers(1, 9) 9 >>> count_palindromic_numbers(100000, 100000) 0 pass","solution":"def count_palindromic_numbers(L, R): Returns the count of palindromic numbers in the range [L, R] inclusive. def is_palindrome(n): return str(n) == str(n)[::-1] count = 0 for num in range(L, R+1): if is_palindrome(num): count += 1 return count"},{"question":"from typing import List def min_storage_units(n: int, weights: List[int], capacity: int) -> int: Returns the minimum number of storage units required to store all the products without exceeding the unit capacity. Args: n (int): Number of products. weights (List[int]): List of weights of the products. capacity (int): Capacity of each storage unit. Returns: int: Minimum number of storage units required. Examples: >>> min_storage_units(4, [2, 4, 8, 1], 10) 2 >>> min_storage_units(6, [5, 5, 5, 5, 5, 5], 10) 3 >>> min_storage_units(5, [7, 4, 5, 2, 6], 9) 3","solution":"from typing import List def min_storage_units(n: int, weights: List[int], capacity: int) -> int: Returns the minimum number of storage units required to store all the products without exceeding the unit capacity. # Sort weights in descending order to prioritize larger products first weights.sort(reverse=True) # Initialize a list to keep track of remaining capacities of storage units storage_units = [] for weight in weights: # Try to find a storage unit that can fit the current product placed = False for i in range(len(storage_units)): if storage_units[i] >= weight: storage_units[i] -= weight placed = True break # If no suitable storage unit is found, allocate a new one if not placed: storage_units.append(capacity - weight) return len(storage_units) # Example usage n = 4 weights = [2, 4, 8, 1] capacity = 10 print(min_storage_units(n, weights, capacity)) # Output: 2"},{"question":"def warmer_days(temperatures): Finds how many days to wait until a warmer temperature for each day. Parameters: temperatures (list of int): List of temperatures for each day. Returns: list of int: List of days to wait for a warmer temperature. pass # Replace with implementation # Unit tests def test_warmer_days_example1(): assert warmer_days([73, 74, 75, 71, 69, 72, 76, 73]) == [1, 1, 4, 2, 1, 1, 0, 0] def test_warmer_days_example2(): assert warmer_days([89, 62, 70, 58, 47]) == [0, 1, 0, 0, 0] def test_warmer_days_all_same(): assert warmer_days([50, 50, 50, 50]) == [0, 0, 0, 0] def test_warmer_days_decreasing(): assert warmer_days([100, 90, 80, 70]) == [0, 0, 0, 0] def test_warmer_days_increasing(): assert warmer_days([70, 80, 90, 100]) == [1, 1, 1, 0] def test_warmer_days_mixed(): assert warmer_days([30, 40, 50, 60, 50, 40, 30]) == [1, 1, 1, 0, 0, 0, 0] def test_warmer_days_one_element(): assert warmer_days([50]) == [0]","solution":"def warmer_days(temperatures): Finds how many days to wait until a warmer temperature for each day. Parameters: temperatures (list of int): List of temperatures for each day. Returns: list of int: List of days to wait for a warmer temperature. n = len(temperatures) result = [0] * n # initialize the result list with 0 stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: prev_index = stack.pop() result[prev_index] = i - prev_index stack.append(i) return result"},{"question":"def max_subarray_sum(arr): Returns the maximum sum of any contiguous subarray. >>> max_subarray_sum([5]) 5 >>> max_subarray_sum([-5]) -5 >>> max_subarray_sum([1, 2, 3, 4]) 10 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1, 2, 3, -2, 5]) 9 >>> max_subarray_sum([1, 0, -1, 0, 2]) 2 >>> max_subarray_sum([1] * 100000) 100000 >>> max_subarray_sum([-1] * 100000) -1","solution":"def max_subarray_sum(arr): Returns the maximum sum of any contiguous subarray. max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"def max_water_flow(n: int, m: int, pipes: List[Tuple[int, int, int]]) -> int: A city's water distribution system consists of various tanks connected by pipes. Each tank can send water to other tanks, and each pipe has a maximum capacity of water it can carry per hour. The city needs to determine the maximum amount of water that can be sent from the main source tank to the main destination tank per hour without violating any pipe capacities. The water distribution system can be represented as a directed graph with n tanks and m pipes. The main source tank is tank 1 and the main destination tank is tank n. Args: n: int : Number of tanks. m: int : Number of pipes. pipes: List[Tuple[int, int, int]] : List of pipes where each pipe is represented as a tuple (u, v, c) meaning a pipe from tank u to tank v with a capacity of c liters per hour. Returns: int : The maximum water flow from tank 1 to tank n. If there is no path from tank 1 to tank n, return 0. >>> max_water_flow(4, 5, [(1, 2, 10), (1, 3, 5), (2, 3, 15), (2, 4, 10), (3, 4, 10)]) 15 >>> max_water_flow(4, 2, [(1, 2, 100), (3, 4, 100)]) 0","solution":"from collections import defaultdict, deque def bfs(capacity, source, sink, parent): visited = [False] * len(capacity) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for ind, val in enumerate(capacity[u]): if visited[ind] == False and val > 0: queue.append(ind) visited[ind] = True parent[ind] = u if ind == sink: return True return False def edmonds_karp(n, adj_matrix, source, sink): parent = [-1] * n max_flow = 0 while bfs(adj_matrix, source, sink, parent): path_flow = float('Inf') s = sink while s != source: path_flow = min(path_flow, adj_matrix[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] adj_matrix[u][v] -= path_flow adj_matrix[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow def max_water_flow(n, m, pipes): adj_matrix = [[0] * n for _ in range(n)] for u, v, c in pipes: adj_matrix[u-1][v-1] += c # multiple pipes between same tanks add up return edmonds_karp(n, adj_matrix, 0, n-1)"},{"question":"def min_max_weight(T, test_cases): Determine the minimum possible maximum weight each friend has to carry if it is possible to distribute the supplies equally. Otherwise, return -1. Args: T (int): The number of test cases test_cases (list of dict): A list where each dict contains 'N' (the number of friends), 'M' (the total number of supplies), and 'weights' (a list of integers denoting the initial weights each friend can carry). Returns: list: A list of integers representing the result for each test case. Example: >>> min_max_weight(2, [{'N': 3, 'M': 15, 'weights': [5, 5, 5]}, {'N': 4, 'M': 10, 'weights': [3, 3, 3, 3]}]) [5, 3] >>> min_max_weight(1, [{'N': 4, 'M': 20, 'weights': [3, 3, 3, 3]}]) [-1] pass def process_input(output_lines): Process the input lines to extract the number of test cases and their respective details. Args: output_lines (list of str): The input lines representing the test cases. Returns: tuple: A tuple containing the number of test cases and a list of test cases where each test case is represented as a dict containing 'N', 'M', and 'weights'. Example: >>> process_input([\\"2\\", \\"3 15\\", \\"5 5 5\\", \\"4 10\\", \\"3 3 3 3\\"]) (2, [{'N': 3, 'M': 15, 'weights': [5, 5, 5]}, {'N': 4, 'M': 10, 'weights': [3, 3, 3, 3]}]) pass def main(input_lines): The main function to execute the solution and return the results in the required format. Args: input_lines (list of str): The input lines representing the test cases. Example: >>> main([\\"2\\", \\"3 15\\", \\"5 5 5\\", \\"4 10\\", \\"3 3 3 3\\"]) '5n3' pass","solution":"def min_max_weight(T, test_cases): results = [] for case in test_cases: N, M, weights = case['N'], case['M'], case['weights'] if sum(weights) < M: results.append(-1) continue left, right = 0, max(weights) best = -1 while left <= right: mid = (left + right) // 2 current = sum(min(mid, w) for w in weights) if current >= M: best = mid right = mid - 1 else: left = mid + 1 results.append(best) return results def process_input(output_lines): T = int(output_lines[0]) test_cases = [] line_idx = 1 for _ in range(T): N, M = map(int, output_lines[line_idx].split()) weights = list(map(int, output_lines[line_idx + 1].split())) test_cases.append({'N': N, 'M': M, 'weights': weights}) line_idx += 2 return T, test_cases def main(input_lines): T, test_cases = process_input(input_lines) results = min_max_weight(T, test_cases) return \\"n\\".join(map(str, results))"},{"question":"def manage_ride_queue(datasets: List[List[str]]) -> List[str]: Simulate the amusement park's ride management system. Args: datasets: List of datasets, where each dataset is a list of operation strings. Returns: A list of strings representing the final queues of rides' popularity scores for each dataset. >>> manage_ride_queue([[\\"ADD 20\\", \\"ADD 50\\", \\"ADD 30\\", \\"REMOVE\\"]]) [\\"50 30\\"] >>> manage_ride_queue([[\\"ADD 40\\", \\"REMOVE\\", \\"REMOVE\\"]]) [\\"EMPTY\\"] >>> manage_ride_queue([[\\"ADD 45\\", \\"REMOVE\\", \\"ADD 60\\", \\"ADD 50\\"]]) [\\"60 50\\"] >>> manage_ride_queue([[\\"REMOVE\\", \\"ADD 10\\", \\"REMOVE\\"]]) [\\"EMPTY\\"] >>> manage_ride_queue([[\\"ADD 10\\", \\"ADD 20\\", \\"ADD 5\\", \\"REMOVE\\", \\"REMOVE\\"]]) [\\"20\\"]","solution":"def manage_ride_queue(datasets): results = [] for operations in datasets: queue = [] for operation in operations: if operation.startswith(\\"ADD\\"): _, score = operation.split() score = int(score) queue.append(score) elif operation == \\"REMOVE\\" and queue: min_score = min(queue) queue.remove(min_score) if queue: results.append(\\" \\".join(map(str, queue))) else: results.append(\\"EMPTY\\") return results"},{"question":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring in the given string s. >>> longest_palindromic_substring(\\"racecar\\") == \\"racecar\\" >>> longest_palindromic_substring(\\"banana\\") == \\"anana\\" >>> longest_palindromic_substring(\\"abacdfgdcaba\\") == \\"aba\\" >>> longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" >>> longest_palindromic_substring(\\"aaaa\\") == \\"aaaa\\" >>> longest_palindromic_substring(\\"a\\") == \\"a\\" >>> longest_palindromic_substring(\\"ab\\") == \\"a\\" >>> longest_palindromic_substring(\\"\\") == \\"\\" >>> longest_palindromic_substring(\\"abcba\\") == \\"abcba\\"","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring in the given string s. if not s: return \\"\\" start, max_length = 0, 1 for i in range(len(s)): # Check for odd length palindromes low, high = i, i while low >= 0 and high < len(s) and s[low] == s[high]: if high - low + 1 > max_length: start = low max_length = high - low + 1 low -= 1 high += 1 # Check for even length palindromes low, high = i, i + 1 while low >= 0 and high < len(s) and s[low] == s[high]: if high - low + 1 > max_length: start = low max_length = high - low + 1 low -= 1 high += 1 return s[start:start + max_length]"}]`),A={name:"App",components:{PoemCard:E},data(){return{searchQuery:"",visibleCount:4,poemsData:R,isLoading:!1}},computed:{filteredPoems(){const n=this.searchQuery.trim().toLowerCase();return n?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(n)||e.solution&&e.solution.toLowerCase().includes(n)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(n=>setTimeout(n,1e3)),this.visibleCount+=4,this.isLoading=!1}}},j={class:"search-container"},D={class:"card-container"},O={key:0,class:"empty-state"},C=["disabled"],P={key:0},Y={key:1};function I(n,e,u,m,r,a){const p=h("PoemCard");return s(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",j,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>r.searchQuery=o),placeholder:"Search..."},null,512),[[b,r.searchQuery]]),r.searchQuery?(s(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>r.searchQuery="")}," ✕ ")):l("",!0)]),t("div",D,[(s(!0),i(y,null,x(a.displayedPoems,(o,f)=>(s(),v(p,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),i("div",O,' No results found for "'+_(r.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),i("button",{key:0,class:"load-more-button",disabled:r.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[r.isLoading?(s(),i("span",Y,"Loading...")):(s(),i("span",P,"See more"))],8,C)):l("",!0)])}const z=d(A,[["render",I],["__scopeId","data-v-32d1a729"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"guide/25.md","filePath":"guide/25.md"}'),M={name:"guide/25.md"},G=Object.assign(M,{setup(n){return(e,u)=>(s(),i("div",null,[w(z)]))}});export{B as __pageData,G as default};
